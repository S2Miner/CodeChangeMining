[{"original_method":"@Test\n    public void testNestedDeploy() throws Exception {\n        TesteeSet ts = createTestee();\n        File nestedDir = new File(tmpDir, \"nested\");\n        File war = createFile(nestedDir, \"foo.war\");\n        File dodeploy = createFile(nestedDir, \"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed = new File(nestedDir, \"foo.war\" + FileSystemDeploymentService.DEPLOYED);\n        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeSuccessResponse(1);\n        ts.testee.scan();\n        assertEquals(1, ts.repo.content.size());\n        assertTrue(war.exists());\n        assertFalse(dodeploy.exists());\n        assertTrue(deployed.exists());\n    }","id":33000,"modified_method":"@Test\n    public void testNestedDeploy() throws Exception {\n        TesteeSet ts = createTestee();\n        File nestedDir = new File(tmpDir, \"nested\");\n        File war = createFile(nestedDir, \"foo.war\");\n        File dodeploy = createFile(nestedDir, \"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed = new File(nestedDir, \"foo.war\" + FileSystemDeploymentService.DEPLOYED);\n//        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeSuccessResponse(1);\n        ts.testee.scan();\n        assertEquals(1, ts.repo.content.size());\n        assertTrue(war.exists());\n        assertFalse(dodeploy.exists());\n        assertTrue(deployed.exists());\n    }","commit_id":"81d2fa87a7ce0f117466e6e6a2222fb1b0f48866","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testOverridePreexisting() throws Exception {\n        File war = createFile(\"foo.war\");\n        File dodeploy = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.DEPLOYED);\n        TesteeSet ts = createTestee(\"foo.war\");\n        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeSuccessResponse(1);\n        ts.testee.scan();\n        assertEquals(1, ts.repo.content.size());\n        assertTrue(war.exists());\n        assertFalse(dodeploy.exists());\n        assertTrue(deployed.exists());\n    }","id":33001,"modified_method":"@Test\n    public void testOverridePreexisting() throws Exception {\n        File war = createFile(\"foo.war\");\n        File dodeploy = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.DEPLOYED);\n        TesteeSet ts = createTestee(\"foo.war\");\n//        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeSuccessResponse(1);\n        ts.testee.scan();\n        assertEquals(1, ts.repo.content.size());\n        assertTrue(war.exists());\n        assertFalse(dodeploy.exists());\n        assertTrue(deployed.exists());\n    }","commit_id":"81d2fa87a7ce0f117466e6e6a2222fb1b0f48866","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testRedeploy() throws Exception {\n        File war = createFile(\"foo.war\");\n        File dodeploy = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.DEPLOYED);\n        TesteeSet ts = createTestee(\"foo.war\");\n        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeSuccessResponse(1);\n        ts.testee.scan();\n        assertEquals(1, ts.repo.content.size());\n        assertTrue(war.exists());\n        assertFalse(dodeploy.exists());\n        assertTrue(deployed.exists());\n\n        dodeploy = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeSuccessResponse(1);\n        ts.testee.scan();\n        assertEquals(2, ts.repo.content.size());\n        assertTrue(war.exists());\n        assertFalse(dodeploy.exists());\n        assertTrue(deployed.exists());\n    }","id":33002,"modified_method":"@Test\n    public void testRedeploy() throws Exception {\n        File war = createFile(\"foo.war\");\n        File dodeploy = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.DEPLOYED);\n        TesteeSet ts = createTestee(\"foo.war\");\n//        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeSuccessResponse(1);\n        ts.testee.scan();\n        assertEquals(1, ts.repo.content.size());\n        assertTrue(war.exists());\n        assertFalse(dodeploy.exists());\n        assertTrue(deployed.exists());\n        assertEquals(1, ts.controller.added.size());\n        assertEquals(1, ts.controller.deployed.size());\n        byte[] bytes = ts.controller.deployed.get(\"foo.war\");\n        assertTrue(Arrays.equals(bytes, ts.repo.content.iterator().next()));\n\n        dodeploy = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n//        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeSuccessResponse(1);\n        ts.testee.scan();\n        assertEquals(2, ts.repo.content.size());\n        assertTrue(war.exists());\n        assertFalse(dodeploy.exists());\n        assertTrue(deployed.exists());\n        assertEquals(1, ts.controller.added.size());\n        assertEquals(1, ts.controller.deployed.size());\n        byte[] newbytes = ts.controller.deployed.get(\"foo.war\");\n        assertFalse(Arrays.equals(newbytes, bytes));\n        boolean installed = false;\n        for (byte[] content : ts.repo.content) {\n            if (Arrays.equals(newbytes, content)) {\n                installed = true;\n                break;\n            }\n        }\n        assertTrue(installed);\n    }","commit_id":"81d2fa87a7ce0f117466e6e6a2222fb1b0f48866","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testTwoFileDeploy() throws Exception {\n        File war1 = createFile(\"foo.war\");\n        File dodeploy1 = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed1 = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.DEPLOYED);\n        File war2 = createFile(\"bar.war\");\n        File dodeploy2 = createFile(\"bar.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed2 = new File(tmpDir, \"bar.war\" + FileSystemDeploymentService.DEPLOYED);\n        TesteeSet ts = createTestee();\n        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeSuccessResponse(2);\n        ts.testee.scan();\n        assertEquals(2, ts.repo.content.size());\n        assertTrue(war1.exists());\n        assertFalse(dodeploy1.exists());\n        assertTrue(deployed1.exists());\n        assertTrue(war2.exists());\n        assertFalse(dodeploy2.exists());\n        assertTrue(deployed2.exists());\n    }","id":33003,"modified_method":"@Test\n    public void testTwoFileDeploy() throws Exception {\n        File war1 = createFile(\"foo.war\");\n        File dodeploy1 = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed1 = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.DEPLOYED);\n        File war2 = createFile(\"bar.war\");\n        File dodeploy2 = createFile(\"bar.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed2 = new File(tmpDir, \"bar.war\" + FileSystemDeploymentService.DEPLOYED);\n        TesteeSet ts = createTestee();\n//        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeSuccessResponse(2);\n        ts.testee.scan();\n        assertEquals(2, ts.repo.content.size());\n        assertTrue(war1.exists());\n        assertFalse(dodeploy1.exists());\n        assertTrue(deployed1.exists());\n        assertTrue(war2.exists());\n        assertFalse(dodeploy2.exists());\n        assertTrue(deployed2.exists());\n    }","commit_id":"81d2fa87a7ce0f117466e6e6a2222fb1b0f48866","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testCancellationDueToFailure() throws Exception {\n        File war1 = createFile(\"bar.war\");\n        File dodeploy1 = createFile(\"bar.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed1 = new File(tmpDir, \"bar.war\" + FileSystemDeploymentService.DEPLOYED);\n        File failed1 = new File(tmpDir, \"bar.war\" + FileSystemDeploymentService.FAILED_DEPLOY);\n        File war2 = createFile(\"foo.war\");\n        File dodeploy2 = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed2 = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.DEPLOYED);\n        File failed2 = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.FAILED_DEPLOY);\n        TesteeSet ts = createTestee();\n        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeFailureResponse(2, 1);\n        // Retry fails as well\n        ts.controller.addCompositeFailureResponse(1, 1);\n        ts.testee.scan();\n        assertEquals(2, ts.repo.content.size());\n        assertTrue(war1.exists());\n        assertFalse(dodeploy1.exists());\n        assertFalse(deployed1.exists());\n        assertTrue(failed1.exists());\n        assertTrue(war2.exists());\n        assertFalse(dodeploy2.exists());\n        assertFalse(deployed2.exists());\n        assertTrue(failed2.exists());\n    }","id":33004,"modified_method":"@Test\n    public void testCancellationDueToFailure() throws Exception {\n        File war1 = createFile(\"bar.war\");\n        File dodeploy1 = createFile(\"bar.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed1 = new File(tmpDir, \"bar.war\" + FileSystemDeploymentService.DEPLOYED);\n        File failed1 = new File(tmpDir, \"bar.war\" + FileSystemDeploymentService.FAILED_DEPLOY);\n        File war2 = createFile(\"foo.war\");\n        File dodeploy2 = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed2 = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.DEPLOYED);\n        File failed2 = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.FAILED_DEPLOY);\n        TesteeSet ts = createTestee();\n//        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeFailureResponse(2, 1);\n        // Retry fails as well\n        ts.controller.addCompositeFailureResponse(1, 1);\n        ts.testee.scan();\n        assertEquals(2, ts.repo.content.size());\n        assertTrue(war1.exists());\n        assertFalse(dodeploy1.exists());\n        assertFalse(deployed1.exists());\n        assertTrue(failed1.exists());\n        assertTrue(war2.exists());\n        assertFalse(dodeploy2.exists());\n        assertFalse(deployed2.exists());\n        assertTrue(failed2.exists());\n    }","commit_id":"81d2fa87a7ce0f117466e6e6a2222fb1b0f48866","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testTwoFileFailedRedeploy() throws Exception {\n        File war1 = createFile(\"bar.war\");\n        File dodeploy1 = createFile(\"bar.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed1 = new File(tmpDir, \"bar.war\" + FileSystemDeploymentService.DEPLOYED);\n        File failed1 = new File(tmpDir, \"bar.war\" + FileSystemDeploymentService.FAILED_DEPLOY);\n        File war2 = createFile(\"foo.war\");\n        File dodeploy2 = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed2 = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.DEPLOYED);\n        File failed2 = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.FAILED_DEPLOY);\n        TesteeSet ts = createTestee();\n        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeSuccessResponse(2);\n        ts.testee.scan();\n        assertEquals(2, ts.repo.content.size());\n        assertTrue(war1.exists());\n        assertFalse(dodeploy1.exists());\n        assertTrue(deployed1.exists());\n        assertTrue(war2.exists());\n        assertFalse(dodeploy2.exists());\n        assertTrue(deployed2.exists());\n\n        dodeploy1 = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        dodeploy2 = createFile(\"bar.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeFailureResponse(2, 1);\n        // Retry fails as well\n        ts.controller.addCompositeFailureResponse(1, 1);\n        ts.testee.scan();\n        assertEquals(4, ts.repo.content.size());\n        assertTrue(war1.exists());\n        assertFalse(dodeploy1.exists());\n        assertFalse(deployed1.exists());\n        assertTrue(failed1.exists());\n        assertTrue(war2.exists());\n        assertFalse(dodeploy2.exists());\n        assertFalse(deployed2.exists());\n        assertTrue(failed2.exists());\n    }","id":33005,"modified_method":"@Test\n    public void testTwoFileFailedRedeploy() throws Exception {\n        File war1 = createFile(\"bar.war\");\n        File dodeploy1 = createFile(\"bar.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed1 = new File(tmpDir, \"bar.war\" + FileSystemDeploymentService.DEPLOYED);\n        File failed1 = new File(tmpDir, \"bar.war\" + FileSystemDeploymentService.FAILED_DEPLOY);\n        File war2 = createFile(\"foo.war\");\n        File dodeploy2 = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed2 = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.DEPLOYED);\n        File failed2 = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.FAILED_DEPLOY);\n        TesteeSet ts = createTestee();\n//        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeSuccessResponse(2);\n        ts.testee.scan();\n        assertEquals(2, ts.repo.content.size());\n        assertTrue(war1.exists());\n        assertFalse(dodeploy1.exists());\n        assertTrue(deployed1.exists());\n        assertTrue(war2.exists());\n        assertFalse(dodeploy2.exists());\n        assertTrue(deployed2.exists());\n\n        dodeploy1 = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        dodeploy2 = createFile(\"bar.war\" + FileSystemDeploymentService.DO_DEPLOY);\n//        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeFailureResponse(2, 1);\n        // Retry fails as well\n        ts.controller.addCompositeFailureResponse(1, 1);\n        ts.testee.scan();\n        assertEquals(4, ts.repo.content.size());\n        assertTrue(war1.exists());\n        assertFalse(dodeploy1.exists());\n        assertFalse(deployed1.exists());\n        assertTrue(failed1.exists());\n        assertTrue(war2.exists());\n        assertFalse(dodeploy2.exists());\n        assertFalse(deployed2.exists());\n        assertTrue(failed2.exists());\n    }","commit_id":"81d2fa87a7ce0f117466e6e6a2222fb1b0f48866","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void addCompositeFailureResponse(int count, int failureStep) {\n\n            if (count < failureStep) {\n                throw new IllegalArgumentException(\"failureStep must be > count\");\n            }\n\n            ModelNode rsp = new ModelNode();\n            rsp.get(OUTCOME).set(FAILED);\n            ModelNode result = rsp.get(RESULT);\n            for (int i = 1; i <= count; i++) {\n                String step = \"step-\" + i;\n                if (i < failureStep) {\n                    result.get(step, OUTCOME).set(FAILED);\n                    result.get(step, RESULT);\n                    result.get(step, ROLLED_BACK).set(true);\n                }\n                else if (i == failureStep){\n                    result.get(step, OUTCOME).set(FAILED);\n                    result.get(step, FAILURE_DESCRIPTION).set(new ModelNode().set(\"badness happened\"));\n                    result.get(step, ROLLED_BACK).set(true);\n                }\n                else {\n                    result.get(step, OUTCOME).set(CANCELLED);\n                }\n            }\n            rsp.get(FAILURE_DESCRIPTION).set(new ModelNode().set(\"badness happened\"));\n            rsp.get(ROLLED_BACK).set(true);\n\n            addResponse(rsp);\n        }","id":33006,"modified_method":"public void addCompositeFailureResponse(int count, int failureStep) {\n\n            if (count < failureStep) {\n                throw new IllegalArgumentException(\"failureStep must be > count\");\n            }\n\n            ModelNode rsp = new ModelNode();\n            rsp.get(OUTCOME).set(FAILED);\n            ModelNode result = rsp.get(RESULT);\n            for (int i = 1; i <= count; i++) {\n                String step = \"step-\" + i;\n                if (i < failureStep) {\n                    result.get(step, OUTCOME).set(FAILED);\n                    result.get(step, RESULT);\n                    result.get(step, ROLLED_BACK).set(true);\n                }\n                else if (i == failureStep){\n                    result.get(step, OUTCOME).set(FAILED);\n                    result.get(step, FAILURE_DESCRIPTION).set(new ModelNode().set(\"badness happened\"));\n                    result.get(step, ROLLED_BACK).set(true);\n                }\n                else {\n                    result.get(step, OUTCOME).set(CANCELLED);\n                }\n            }\n            rsp.get(FAILURE_DESCRIPTION).set(new ModelNode().set(\"badness happened\"));\n            rsp.get(ROLLED_BACK).set(true);\n\n            responses.add(new Response(true, rsp));\n        }","commit_id":"81d2fa87a7ce0f117466e6e6a2222fb1b0f48866","url":"https://github.com/wildfly/wildfly"},{"original_method":"void addGetDeploymentNamesResponse(String... deployments) {\n            ModelNode content = new ModelNode();\n            content.get(OUTCOME).set(SUCCESS);\n            ModelNode result = content.get(RESULT);\n            result.setEmptyList();\n            for (String deployment : deployments) {\n                result.add(deployment);\n            }\n            addResponse(content);\n        }","id":33007,"modified_method":"private ModelNode getDeploymentNamesResponse() {\n            ModelNode content = new ModelNode();\n            content.get(OUTCOME).set(SUCCESS);\n            ModelNode result = content.get(RESULT);\n            result.setEmptyList();\n            for (String deployment : added.keySet()) {\n                result.add(deployment);\n            }\n            return content;\n        }","commit_id":"81d2fa87a7ce0f117466e6e6a2222fb1b0f48866","url":"https://github.com/wildfly/wildfly"},{"original_method":"private TesteeSet createTestee(String... existingContent) throws OperationFailedException {\n        return createTestee(new MockServerController(existingContent));\n    }","id":33008,"modified_method":"private TesteeSet createTestee(String... existingContent) throws OperationFailedException {\n        return createTestee(new MockServerController(new MockDeploymentRepository(), existingContent));\n    }","commit_id":"81d2fa87a7ce0f117466e6e6a2222fb1b0f48866","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void addCompositeSuccessResponse(int count) {\n            ModelNode rsp = new ModelNode();\n            rsp.get(OUTCOME).set(SUCCESS);\n            ModelNode result = rsp.get(RESULT);\n            for (int i = 1; i <= count; i++) {\n                result.get(\"step-\" + i, OUTCOME).set(SUCCESS);\n                result.get(\"step-\" + i, RESULT);\n            }\n\n            addResponse(rsp);\n        }","id":33009,"modified_method":"public void addCompositeSuccessResponse(int count) {\n            ModelNode rsp = new ModelNode();\n            rsp.get(OUTCOME).set(SUCCESS);\n            ModelNode result = rsp.get(RESULT);\n            for (int i = 1; i <= count; i++) {\n                result.get(\"step-\" + i, OUTCOME).set(SUCCESS);\n                result.get(\"step-\" + i, RESULT);\n            }\n\n            responses.add(new Response(true, rsp));\n        }","commit_id":"81d2fa87a7ce0f117466e6e6a2222fb1b0f48866","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testBasicFailure() throws Exception {\n        File war = createFile(\"foo.war\");\n        File dodeploy = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.DEPLOYED);\n        File failed = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.FAILED_DEPLOY);\n        TesteeSet ts = createTestee();\n        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeFailureResponse(1, 1);\n        ts.testee.scan();\n        assertEquals(1, ts.repo.content.size());\n        assertTrue(war.exists());\n        assertFalse(dodeploy.exists());\n        assertFalse(deployed.exists());\n        assertTrue(failed.exists());\n    }","id":33010,"modified_method":"@Test\n    public void testBasicFailure() throws Exception {\n        File war = createFile(\"foo.war\");\n        File dodeploy = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.DEPLOYED);\n        File failed = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.FAILED_DEPLOY);\n        TesteeSet ts = createTestee();\n//        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeFailureResponse(1, 1);\n        ts.testee.scan();\n        assertEquals(1, ts.repo.content.size());\n        assertTrue(war.exists());\n        assertFalse(dodeploy.exists());\n        assertFalse(deployed.exists());\n        assertTrue(failed.exists());\n    }","commit_id":"81d2fa87a7ce0f117466e6e6a2222fb1b0f48866","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testUndeploy() throws Exception {\n        File war = createFile(\"foo.war\");\n        File dodeploy = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.DEPLOYED);\n        TesteeSet ts = createTestee(\"foo.war\");\n        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeSuccessResponse(1);\n        ts.testee.scan();\n        assertEquals(1, ts.repo.content.size());\n        assertTrue(war.exists());\n        assertFalse(dodeploy.exists());\n        assertTrue(deployed.exists());\n\n        assertTrue(deployed.delete());\n        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeSuccessResponse(1);\n        ts.testee.scan();\n        assertEquals(1, ts.repo.content.size());\n        assertTrue(war.exists());\n        assertFalse(dodeploy.exists());\n        assertFalse(deployed.exists());\n    }","id":33011,"modified_method":"@Test\n    public void testUndeploy() throws Exception {\n        File war = createFile(\"foo.war\");\n        File dodeploy = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.DEPLOYED);\n        TesteeSet ts = createTestee();\n//        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeSuccessResponse(1);\n        ts.testee.scan();\n        assertEquals(1, ts.repo.content.size());\n        assertTrue(war.exists());\n        assertFalse(dodeploy.exists());\n        assertTrue(deployed.exists());\n        assertEquals(1, ts.controller.added.size());\n        assertEquals(1, ts.controller.deployed.size());\n\n        assertTrue(deployed.delete());\n//        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeSuccessResponse(1);\n        ts.testee.scan();\n        assertEquals(1, ts.repo.content.size());\n        assertTrue(war.exists());\n        assertFalse(dodeploy.exists());\n        assertFalse(deployed.exists());\n        assertEquals(0, ts.controller.added.size());\n        assertEquals(0, ts.controller.deployed.size());\n    }","commit_id":"81d2fa87a7ce0f117466e6e6a2222fb1b0f48866","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testBasicDeploy() throws Exception {\n        File war = createFile(\"foo.war\");\n        File dodeploy = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.DEPLOYED);\n        TesteeSet ts = createTestee();\n        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeSuccessResponse(1);\n        ts.testee.scan();\n        assertEquals(1, ts.repo.content.size());\n        assertTrue(war.exists());\n        assertFalse(dodeploy.exists());\n        assertTrue(deployed.exists());\n    }","id":33012,"modified_method":"@Test\n    public void testBasicDeploy() throws Exception {\n        File war = createFile(\"foo.war\");\n        File dodeploy = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.DEPLOYED);\n        TesteeSet ts = createTestee();\n//        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeSuccessResponse(1);\n        ts.testee.scan();\n        assertEquals(1, ts.repo.content.size());\n        assertTrue(war.exists());\n        assertFalse(dodeploy.exists());\n        assertTrue(deployed.exists());\n    }","commit_id":"81d2fa87a7ce0f117466e6e6a2222fb1b0f48866","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testSuccessfulRetry() throws Exception {\n        File war1 = createFile(\"bar.war\");\n        File dodeploy1 = createFile(\"bar.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed1 = new File(tmpDir, \"bar.war\" + FileSystemDeploymentService.DEPLOYED);\n        File failed1 = new File(tmpDir, \"bar.war\" + FileSystemDeploymentService.FAILED_DEPLOY);\n        File war2 = createFile(\"foo.war\");\n        File dodeploy2 = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed2 = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.DEPLOYED);\n        File failed2 = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.FAILED_DEPLOY);\n        TesteeSet ts = createTestee();\n        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeFailureResponse(2, 1);\n        // Retry succeeds\n        ts.controller.addCompositeSuccessResponse(1);\n        ts.testee.scan();\n        assertEquals(2, ts.repo.content.size());\n        assertTrue(war1.exists());\n        assertTrue(war2.exists());\n        assertFalse(dodeploy1.exists());\n        assertFalse(dodeploy2.exists());\n        assertFalse(deployed1.exists() && deployed2.exists());\n        assertTrue(failed1.exists() || failed2.exists());\n    }","id":33013,"modified_method":"@Test\n    public void testSuccessfulRetry() throws Exception {\n        File war1 = createFile(\"bar.war\");\n        File dodeploy1 = createFile(\"bar.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed1 = new File(tmpDir, \"bar.war\" + FileSystemDeploymentService.DEPLOYED);\n        File failed1 = new File(tmpDir, \"bar.war\" + FileSystemDeploymentService.FAILED_DEPLOY);\n        File war2 = createFile(\"foo.war\");\n        File dodeploy2 = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed2 = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.DEPLOYED);\n        File failed2 = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.FAILED_DEPLOY);\n        TesteeSet ts = createTestee();\n//        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeFailureResponse(2, 1);\n        // Retry succeeds\n        ts.controller.addCompositeSuccessResponse(1);\n        ts.testee.scan();\n        assertEquals(2, ts.repo.content.size());\n        assertTrue(war1.exists());\n        assertTrue(war2.exists());\n        assertFalse(dodeploy1.exists());\n        assertFalse(dodeploy2.exists());\n        assertFalse(deployed1.exists() && deployed2.exists());\n        assertTrue(failed1.exists() || failed2.exists());\n    }","commit_id":"81d2fa87a7ce0f117466e6e6a2222fb1b0f48866","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testTwoFileFailure() throws Exception {\n        File war1 = createFile(\"foo.war\");\n        File dodeploy1 = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed1 = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.DEPLOYED);\n        File failed1 = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.FAILED_DEPLOY);\n        File war2 = createFile(\"bar.war\");\n        File dodeploy2 = createFile(\"bar.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed2 = new File(tmpDir, \"bar.war\" + FileSystemDeploymentService.DEPLOYED);\n        File failed2 = new File(tmpDir, \"bar.war\" + FileSystemDeploymentService.FAILED_DEPLOY);\n        TesteeSet ts = createTestee();\n        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeFailureResponse(2, 2);\n        ts.testee.scan();\n        assertEquals(2, ts.repo.content.size());\n        assertTrue(war1.exists());\n        assertFalse(dodeploy1.exists());\n        assertFalse(deployed1.exists());\n        assertTrue(failed1.exists());\n        assertTrue(war2.exists());\n        assertFalse(dodeploy2.exists());\n        assertFalse(deployed2.exists());\n        assertTrue(failed2.exists());\n    }","id":33014,"modified_method":"@Test\n    public void testTwoFileFailure() throws Exception {\n        File war1 = createFile(\"foo.war\");\n        File dodeploy1 = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed1 = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.DEPLOYED);\n        File failed1 = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.FAILED_DEPLOY);\n        File war2 = createFile(\"bar.war\");\n        File dodeploy2 = createFile(\"bar.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed2 = new File(tmpDir, \"bar.war\" + FileSystemDeploymentService.DEPLOYED);\n        File failed2 = new File(tmpDir, \"bar.war\" + FileSystemDeploymentService.FAILED_DEPLOY);\n        TesteeSet ts = createTestee();\n//        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeFailureResponse(2, 2);\n        ts.testee.scan();\n        assertEquals(2, ts.repo.content.size());\n        assertTrue(war1.exists());\n        assertFalse(dodeploy1.exists());\n        assertFalse(deployed1.exists());\n        assertTrue(failed1.exists());\n        assertTrue(war2.exists());\n        assertFalse(dodeploy2.exists());\n        assertFalse(deployed2.exists());\n        assertTrue(failed2.exists());\n    }","commit_id":"81d2fa87a7ce0f117466e6e6a2222fb1b0f48866","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testFailedRedeploy() throws Exception {\n        File war = createFile(\"foo.war\");\n        File dodeploy = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.DEPLOYED);\n        File failed = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.FAILED_DEPLOY);\n        TesteeSet ts = createTestee(\"foo.war\");\n        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeSuccessResponse(1);\n        ts.testee.scan();\n        assertEquals(1, ts.repo.content.size());\n        assertTrue(war.exists());\n        assertFalse(dodeploy.exists());\n        assertTrue(deployed.exists());\n        assertFalse(failed.exists());\n\n        dodeploy = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeFailureResponse(1, 1);\n        ts.testee.scan();\n        assertEquals(2, ts.repo.content.size());\n        assertTrue(war.exists());\n        assertFalse(dodeploy.exists());\n        assertFalse(deployed.exists());\n        assertTrue(failed.exists());\n    }","id":33015,"modified_method":"@Test\n    public void testFailedRedeploy() throws Exception {\n        File war = createFile(\"foo.war\");\n        File dodeploy = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.DEPLOYED);\n        File failed = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.FAILED_DEPLOY);\n        TesteeSet ts = createTestee(\"foo.war\");\n//        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeSuccessResponse(1);\n        ts.testee.scan();\n        assertEquals(1, ts.repo.content.size());\n        assertTrue(war.exists());\n        assertFalse(dodeploy.exists());\n        assertTrue(deployed.exists());\n        assertFalse(failed.exists());\n\n        dodeploy = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n//        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeFailureResponse(1, 1);\n        ts.testee.scan();\n        assertEquals(2, ts.repo.content.size());\n        assertTrue(war.exists());\n        assertFalse(dodeploy.exists());\n        assertFalse(deployed.exists());\n        assertTrue(failed.exists());\n    }","commit_id":"81d2fa87a7ce0f117466e6e6a2222fb1b0f48866","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testIgnoreNoMarker() throws Exception {\n        File f1 = createFile(\"foo.war\");\n        TesteeSet ts = createTestee();\n        ts.controller.addGetDeploymentNamesResponse();\n        ts.testee.scan();\n        assertTrue(ts.repo.content.isEmpty());\n        assertTrue(f1.exists());\n    }","id":33016,"modified_method":"@Test\n    public void testIgnoreNoMarker() throws Exception {\n        File f1 = createFile(\"foo.war\");\n        TesteeSet ts = createTestee();\n//        ts.controller.addGetDeploymentNamesResponse();\n        ts.testee.scan();\n        assertTrue(ts.repo.content.isEmpty());\n        assertTrue(f1.exists());\n    }","commit_id":"81d2fa87a7ce0f117466e6e6a2222fb1b0f48866","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testFilesystemDeployment() throws Exception {\n        final JavaArchive archive = ShrinkWrapUtils.createJavaArchive(\"servermodule/test-deployment.sar\", Simple.class.getPackage());\n        final File dir = new File(\"target/archives\");\n        dir.mkdirs();\n        final File file = new File(dir, \"test-deployment.sar\");\n        archive.as(ZipExporter.class).exportZip(file, true);\n\n\n        final File deployDir = new File(\"target\", \"deployments\");\n        deployDir.mkdirs();\n        Assert.assertTrue(deployDir.exists());\n\n        ModelControllerClient client = ModelControllerClient.Factory.create(InetAddress.getByName(\"localhost\"), 9999);\n        ModelNode add = new ModelNode();\n        add.get(OP).set(ADD);\n        ModelNode addr = new ModelNode();\n        addr.add(\"subsystem\", \"deployment-scanner\");\n        addr.add(\"scanner\", \"test\");\n        add.get(OP_ADDR).set(addr);\n        add.get(\"path\").set(deployDir.getAbsolutePath());\n        add.get(\"scan-enabled\").set(true);\n        add.get(\"scan-interval\").set(1000);\n\n        ModelNode result = client.execute(add);\n        Assert.assertEquals(ModelDescriptionConstants.SUCCESS, result.require(ModelDescriptionConstants.OUTCOME).asString());\n\n        try {\n            final File target = new File(deployDir, \"test-deployment.sar\");\n            final File deployed = new File(deployDir, \"test-deployment.sar.deployed\");\n            Assert.assertFalse(target.exists());\n\n            testDeployments(new DeploymentExecutor() {\n                @Override\n                public void initialDeploy() throws IOException {\n                    //Copy file to deploy directory\n                    final InputStream in = new BufferedInputStream(new FileInputStream(file));\n                    try {\n                        final OutputStream out = new BufferedOutputStream(new FileOutputStream(target));\n                        try {\n                            int i = in.read();\n                            while (i != -1) {\n                                out.write(i);\n                                i = in.read();\n                            }\n                        } finally {\n                            StreamUtils.safeClose(out);\n                        }\n                    } finally {\n                        StreamUtils.safeClose(in);\n                    }\n                }\n\n                @Override\n                public void fullReplace() throws IOException {\n                    //Copy file to deploy directory again\n                    initialDeploy();\n                }\n\n                @Override\n                public void undeploy() {\n                    //Delete file from deploy directory\n                    deployed.delete();\n                }\n            });\n        } finally {\n            try {\n                client.execute(result.get(ModelDescriptionConstants.COMPENSATING_OPERATION));\n            } catch (Exception e) {\n                client.close();\n            }\n        }\n    }","id":33017,"modified_method":"@Test\n    public void testFilesystemDeployment() throws Exception {\n        final JavaArchive archive = ShrinkWrapUtils.createJavaArchive(\"servermodule/test-deployment.sar\", Simple.class.getPackage());\n        final File dir = new File(\"target/archives\");\n        dir.mkdirs();\n        final File file = new File(dir, \"test-deployment.sar\");\n        archive.as(ZipExporter.class).exportZip(file, true);\n\n\n        final File deployDir = new File(\"target\", \"deployments\");\n        deployDir.mkdirs();\n        Assert.assertTrue(deployDir.exists());\n\n        ModelControllerClient client = ModelControllerClient.Factory.create(InetAddress.getByName(\"localhost\"), 9999);\n        ModelNode add = new ModelNode();\n        add.get(OP).set(ADD);\n        ModelNode addr = new ModelNode();\n        addr.add(\"subsystem\", \"deployment-scanner\");\n        addr.add(\"scanner\", \"test\");\n        add.get(OP_ADDR).set(addr);\n        add.get(\"path\").set(deployDir.getAbsolutePath());\n        add.get(\"scan-enabled\").set(true);\n        add.get(\"scan-interval\").set(1000);\n\n        ModelNode result = client.execute(add);\n        Assert.assertEquals(ModelDescriptionConstants.SUCCESS, result.require(ModelDescriptionConstants.OUTCOME).asString());\n\n        try {\n            final File target = new File(deployDir, \"test-deployment.sar\");\n            final File deployed = new File(deployDir, \"test-deployment.sar.deployed\");\n            Assert.assertFalse(target.exists());\n\n            testDeployments(new DeploymentExecutor() {\n                @Override\n                public void initialDeploy() throws IOException {\n                    //Copy file to deploy directory\n                    final InputStream in = new BufferedInputStream(new FileInputStream(file));\n                    try {\n                        final OutputStream out = new BufferedOutputStream(new FileOutputStream(target));\n                        try {\n                            int i = in.read();\n                            while (i != -1) {\n                                out.write(i);\n                                i = in.read();\n                            }\n                        } finally {\n                            StreamUtils.safeClose(out);\n                        }\n                    } finally {\n                        StreamUtils.safeClose(in);\n                    }\n                    // Create the .dodeploy file\n                    final File dodeploy = new File(deployDir, \"test-deployment.sar.dodeploy\");\n                    final OutputStream out = new BufferedOutputStream(new FileOutputStream(dodeploy));\n                    try {\n                        out.write(\"test-deployment.sar\".getBytes());\n                    } finally {\n                        StreamUtils.safeClose(out);\n                    }\n                    Assert.assertTrue(dodeploy.exists());\n                }\n\n                @Override\n                public void fullReplace() throws IOException {\n                    //Copy file to deploy directory again\n                    initialDeploy();\n                }\n\n                @Override\n                public void undeploy() {\n                    final File dodeploy = new File(deployDir, \"test-deployment.sar.dodeploy\");\n                    for (int i = 0; i < 100; i++) {\n                        if (!dodeploy.exists() && deployed.exists()) {\n                            break;\n                        }\n                        // Wait for the last action to complete :(\n                        try {\n                            Thread.sleep(10);\n                        } catch (InterruptedException e) {\n                            Thread.currentThread().interrupt();\n                            break;\n                        }\n                    }\n                    //Delete file from deploy directory\n                    deployed.delete();\n                }\n            });\n        } finally {\n            try {\n                client.execute(result.get(ModelDescriptionConstants.COMPENSATING_OPERATION));\n            } catch (Exception e) {\n                client.close();\n            }\n        }\n    }","commit_id":"81d2fa87a7ce0f117466e6e6a2222fb1b0f48866","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected Endpoint createEndpoint() throws BusException, EndpointException {        \n        serviceFactory.setFeatures(getFeatures());\n        if (serviceName != null) {\n            serviceFactory.setServiceName(serviceName);\n        }\n        \n        if (endpointName != null) {\n            serviceFactory.setEndpointName(endpointName);    \n        }\n        \n        Service service = serviceFactory.getService();\n        \n        if (service == null) {\n            initializeServiceFactory();\n            service = serviceFactory.create();\n        }\n        \n        if (endpointName == null) {\n            endpointName = serviceFactory.getEndpointName();\n        }\n        EndpointInfo ei = service.getEndpointInfo(endpointName);\n        if (ei != null) {\n            if (transportId != null\n                && !ei.getTransportId().equals(transportId)) {\n                ei = null;\n            } else {\n                BindingFactoryManager bfm = getBus().getExtension(BindingFactoryManager.class);\n                bindingFactory = bfm.getBindingFactory(ei.getBinding().getBindingId());\n            }\n        }\n        \n        if (ei == null) {\n            if (getAddress() == null) {\n                ei = ServiceModelUtil.findBestEndpointInfo(serviceFactory.getInterfaceName(), service\n                    .getServiceInfos());\n            }\n            if (ei == null) {\n                ei = createEndpointInfo();\n            }\n        } else if (getAddress() != null) {\n            ei.setAddress(getAddress()); \n        }\n\n        if (endpointReference != null) {\n            ei.setAddress(endpointReference);\n        }\n        Endpoint ep = service.getEndpoints().get(ei.getName());\n        \n        if (ep == null) {\n            ep = serviceFactory.createEndpoint(ei);\n            ((EndpointImpl)ep).initializeActiveFeatures(getFeatures());\n        } else {\n            serviceFactory.setEndpointName(ei.getName());\n            if (ep.getActiveFeatures() == null) {\n                ((EndpointImpl)ep).initializeActiveFeatures(getFeatures());\n            }\n        }\n        \n        if (properties != null) {\n            ep.putAll(properties);\n        }\n        \n        service.getEndpoints().put(ep.getEndpointInfo().getName(), ep);\n        \n        if (getInInterceptors() != null) {\n            ep.getInInterceptors().addAll(getInInterceptors());\n        }\n        if (getOutInterceptors() != null) {\n            ep.getOutInterceptors().addAll(getOutInterceptors());\n        }\n        if (getInFaultInterceptors() != null) {\n            ep.getInFaultInterceptors().addAll(getInFaultInterceptors());\n        }\n        if (getOutFaultInterceptors() != null) {\n            ep.getOutFaultInterceptors().addAll(getOutFaultInterceptors());\n        }\n        return ep;\n    }","id":33018,"modified_method":"protected Endpoint createEndpoint() throws BusException, EndpointException {        \n        serviceFactory.setFeatures(getFeatures());\n        if (serviceName != null) {\n            serviceFactory.setServiceName(serviceName);\n        }\n        \n        if (endpointName != null) {\n            serviceFactory.setEndpointName(endpointName);    \n        }\n        \n        Service service = serviceFactory.getService();\n        \n        if (service == null) {\n            initializeServiceFactory();\n            service = serviceFactory.create();\n        }\n        \n        if (endpointName == null) {\n            endpointName = serviceFactory.getEndpointName();\n        }\n        EndpointInfo ei = service.getEndpointInfo(endpointName);\n        \n        if (ei != null) {\n            if (transportId != null\n                && !ei.getTransportId().equals(transportId)) {\n                ei = null;\n            } else {\n                BindingFactoryManager bfm = getBus().getExtension(BindingFactoryManager.class);\n                bindingFactory = bfm.getBindingFactory(ei.getBinding().getBindingId());\n            }\n        }\n        \n        if (ei == null) {\n            if (getAddress() == null) {\n                ei = ServiceModelUtil.findBestEndpointInfo(serviceFactory.getInterfaceName(), service\n                    .getServiceInfos());\n            }\n            if (ei == null && !serviceFactory.isPopulateFromClass()) {\n                ei = ServiceModelUtil.findBestEndpointInfo(serviceFactory.getInterfaceName(), service\n                                                           .getServiceInfos());\n                if (ei != null\n                    && transportId != null\n                    && !ei.getTransportId().equals(transportId)) {\n                    ei = null;\n                }\n                if (ei != null) {\n                    BindingFactoryManager bfm = getBus().getExtension(BindingFactoryManager.class);\n                    bindingFactory = bfm.getBindingFactory(ei.getBinding().getBindingId());\n                }\n\n                if (ei == null) {\n                    LOG.warning(\"Could not find endpoint/port for \" \n                                + endpointName + \" in wsdl. Creating default.\");\n                } else {\n                    LOG.warning(\"Could not find endpoint/port for \" \n                                + endpointName + \" in wsdl. Using \" \n                                + ei.getName() + \".\");                        \n                }\n            }\n            if (ei == null) {\n                ei = createEndpointInfo();\n            } else if (getAddress() != null) {\n                ei.setAddress(getAddress()); \n            }\n        } else if (getAddress() != null) {\n            ei.setAddress(getAddress()); \n        }\n\n        if (endpointReference != null) {\n            ei.setAddress(endpointReference);\n        }\n        Endpoint ep = service.getEndpoints().get(ei.getName());\n        \n        if (ep == null) {\n            ep = serviceFactory.createEndpoint(ei);\n            ((EndpointImpl)ep).initializeActiveFeatures(getFeatures());\n        } else {\n            serviceFactory.setEndpointName(ei.getName());\n            if (ep.getActiveFeatures() == null) {\n                ((EndpointImpl)ep).initializeActiveFeatures(getFeatures());\n            }\n        }\n        \n        if (properties != null) {\n            ep.putAll(properties);\n        }\n        \n        service.getEndpoints().put(ep.getEndpointInfo().getName(), ep);\n        \n        if (getInInterceptors() != null) {\n            ep.getInInterceptors().addAll(getInInterceptors());\n        }\n        if (getOutInterceptors() != null) {\n            ep.getOutInterceptors().addAll(getOutInterceptors());\n        }\n        if (getInFaultInterceptors() != null) {\n            ep.getInFaultInterceptors().addAll(getInFaultInterceptors());\n        }\n        if (getOutFaultInterceptors() != null) {\n            ep.getOutFaultInterceptors().addAll(getOutFaultInterceptors());\n        }\n        return ep;\n    }","commit_id":"70aea2b7e5289ab247b825aa03ce186667fee784","url":"https://github.com/apache/cxf"},{"original_method":"private SOAPFault createSoapFault(Exception ex) throws SOAPException {\n        SOAPFault soapFault;\n        try {\n            soapFault = ((SOAPBinding)getBinding()).getSOAPFactory().createFault();\n        } catch (Throwable t) {\n            //probably an old version of saaj or something that is not allowing createFault \n            //method to work.  Try the saaj 1.2 method of doing this.\n            try {\n                soapFault = ((SOAPBinding)getBinding()).getMessageFactory().createMessage()\n                    .getSOAPBody().addFault();\n            } catch (Throwable t2) {\n                //still didn't work, we'll just throw what we have\n                return null;\n            }                        \n        }\n        \n        if (ex instanceof SoapFault) {\n            soapFault.setFaultString(((SoapFault)ex).getReason());\n            soapFault.setFaultCode(((SoapFault)ex).getFaultCode());\n            soapFault.setFaultActor(((SoapFault)ex).getRole());\n\n            Node nd = soapFault.getOwnerDocument().importNode(((SoapFault)ex).getOrCreateDetail(),\n                                                              true);\n            nd = nd.getFirstChild();\n            soapFault.addDetail();\n            while (nd != null) {\n                Node next = nd.getNextSibling();\n                soapFault.getDetail().appendChild(nd);\n                nd = next;\n            }\n\n        } else {\n            soapFault.setFaultCode(new QName(\"http://cxf.apache.org/faultcode\", \"HandlerFault\"));\n            String msg = ex.getMessage();\n            if (msg != null) {\n                soapFault.setFaultString(msg);\n            }\n        }      \n        return soapFault;\n    }","id":33019,"modified_method":"private SOAPFault createSoapFault(Exception ex) throws SOAPException {\n        SOAPFault soapFault;\n        try {\n            soapFault = ((SOAPBinding)getBinding()).getSOAPFactory().createFault();\n        } catch (Throwable t) {\n            //probably an old version of saaj or something that is not allowing createFault \n            //method to work.  Try the saaj 1.2 method of doing this.\n            try {\n                soapFault = ((SOAPBinding)getBinding()).getMessageFactory().createMessage()\n                    .getSOAPBody().addFault();\n            } catch (Throwable t2) {\n                //still didn't work, we'll just throw what we have\n                return null;\n            }                        \n        }\n        \n        if (ex instanceof SoapFault) {\n            soapFault.setFaultString(((SoapFault)ex).getReason());\n            soapFault.setFaultCode(((SoapFault)ex).getFaultCode());\n            soapFault.setFaultActor(((SoapFault)ex).getRole());\n\n            Node nd = soapFault.getOwnerDocument().importNode(((SoapFault)ex).getOrCreateDetail(),\n                                                              true);\n            nd = nd.getFirstChild();\n            soapFault.addDetail();\n            while (nd != null) {\n                Node next = nd.getNextSibling();\n                soapFault.getDetail().appendChild(nd);\n                nd = next;\n            }\n\n        } else {\n            try {\n                soapFault.setFaultCode(new QName(\"http://cxf.apache.org/faultcode\", \"HandlerFault\"));\n            } catch (SOAPException ex2) {\n                //ignore\n            }\n            String msg = ex.getMessage();\n            if (msg != null) {\n                soapFault.setFaultString(msg);\n            }\n        }      \n        return soapFault;\n    }","commit_id":"70aea2b7e5289ab247b825aa03ce186667fee784","url":"https://github.com/apache/cxf"},{"original_method":"public void handleMessage(Message message) {\n        if (isGET(message)) {\n            LOG.info(\"RPCInInterceptor skipped in HTTP GET method\");\n            return;\n        }\n        DepthXMLStreamReader xmlReader = getXMLStreamReader(message);\n\n        BindingOperationInfo operation = null;\n        if (!StaxUtils.toNextElement(xmlReader)) {\n            message.setContent(Exception.class, new RuntimeException(\"There must be a method name element.\"));\n        }\n        String opName = xmlReader.getLocalName();\n        if (isRequestor(message) && opName.endsWith(\"Response\")) {\n            opName = opName.substring(0, opName.length() - 8);\n        }\n\n        if (message.getExchange().get(BindingOperationInfo.class) == null) {\n            operation = getOperation(message, new QName(xmlReader.getNamespaceURI(), opName));\n            if (operation == null) {\n                // it's doc-lit-bare\n                new BareInInterceptor().handleMessage(message);\n                return;\n            } else {\n                setMessage(message, operation);\n            }\n        } else {\n            operation = message.getExchange().get(BindingOperationInfo.class);\n        }\n        MessageInfo msg;\n        DataReader<XMLStreamReader> dr = getDataReader(message, XMLStreamReader.class);\n\n        if (!isRequestor(message)) {\n            msg = operation.getOperationInfo().getInput();\n        } else {\n            msg = operation.getOperationInfo().getOutput();\n        }\n        message.put(MessageInfo.class, msg);\n        \n        MessageContentsList parameters = new MessageContentsList();\n\n        StaxUtils.nextEvent(xmlReader);\n        \n        boolean hasNext = true;\n        Iterator<MessagePartInfo> itr = msg.getMessageParts().iterator();\n        while (itr.hasNext()) {\n            MessagePartInfo part = itr.next();\n            if (hasNext) {\n                hasNext = StaxUtils.toNextElement(xmlReader);\n            }\n            if (hasNext) {\n                QName qn = xmlReader.getName();\n                // WSI-BP states that RPC/Lit part accessors should be completely unqualified\n                // However, older toolkits (Axis 1.x) are qualifying them.   We'll go\n                // ahead and just match on the localpart.   The RPCOutInterceptor\n                // will always generate WSI-BP compliant messages so it's unknown if\n                // the non-WSI-BP toolkits will be able to understand the CXF\n                // generated messages if they are expecting it to be qualified.\n                Iterator<MessagePartInfo> partItr = msg.getMessageParts().iterator();\n                while (!qn.getLocalPart().equals(part.getConcreteName().getLocalPart())\n                    && partItr.hasNext()) {\n                    part = partItr.next();\n                }\n                \n                if (!qn.equals(part.getConcreteName())) {\n                    throw new Fault(\n                                    new org.apache.cxf.common.i18n.Message(\n                                                                           \"UNKNOWN_RPC_LIT_PART\",\n                                                                           LOG,\n                                                                           qn));\n                }\n                //honor JAXBAnnotation\n                part.setProperty(\"honor.jaxb.annotations\", true);\n                try {\n                    parameters.put(part, dr.read(part, xmlReader));\n                } catch (Fault f) {\n                    if (!isRequestor(message)) {\n                        f.setFaultCode(Fault.FAULT_CODE_CLIENT);\n                    }\n                    throw f;\n                }\n            }\n        }\n\n        message.setContent(List.class, parameters);\n    }","id":33020,"modified_method":"public void handleMessage(Message message) {\n        if (isGET(message)) {\n            LOG.info(\"RPCInInterceptor skipped in HTTP GET method\");\n            return;\n        }\n        DepthXMLStreamReader xmlReader = getXMLStreamReader(message);\n\n        BindingOperationInfo operation = null;\n        if (!StaxUtils.toNextElement(xmlReader)) {\n            message.setContent(Exception.class, new RuntimeException(\"There must be a method name element.\"));\n        }\n        String opName = xmlReader.getLocalName();\n        if (isRequestor(message) && opName.endsWith(\"Response\")) {\n            opName = opName.substring(0, opName.length() - 8);\n        }\n\n        if (message.getExchange().get(BindingOperationInfo.class) == null) {\n            operation = getOperation(message, new QName(xmlReader.getNamespaceURI(), opName));\n            if (operation == null) {\n                // it's doc-lit-bare\n                new BareInInterceptor().handleMessage(message);\n                return;\n            } else {\n                setMessage(message, operation);\n            }\n        } else {\n            operation = message.getExchange().get(BindingOperationInfo.class);\n        }\n        MessageInfo msg;\n        DataReader<XMLStreamReader> dr = getDataReader(message, XMLStreamReader.class);\n\n        if (!isRequestor(message)) {\n            msg = operation.getOperationInfo().getInput();\n        } else {\n            msg = operation.getOperationInfo().getOutput();\n        }\n        message.put(MessageInfo.class, msg);\n        \n        MessageContentsList parameters = new MessageContentsList();\n\n        StaxUtils.nextEvent(xmlReader);\n        \n        boolean hasNext = true;\n        Iterator<MessagePartInfo> itr = msg.getMessageParts().iterator();\n        while (itr.hasNext()) {\n            MessagePartInfo part = itr.next();\n            if (hasNext) {\n                hasNext = StaxUtils.toNextElement(xmlReader);\n            }\n\n            if (hasNext) {\n                QName qn = xmlReader.getName();\n                if (qn.equals(SOAP12_RESULT)) {\n                    //just ignore this.   The parts should work correctly.\n                    try {\n                        while (xmlReader.getEventType() != XMLStreamReader.END_ELEMENT) {\n                            xmlReader.next();\n                        }\n                        xmlReader.next();\n                    } catch (XMLStreamException e) {\n                        //ignore\n                    }\n                    StaxUtils.toNextElement(xmlReader);\n                    qn = xmlReader.getName();\n                }\n                \n                \n                // WSI-BP states that RPC/Lit part accessors should be completely unqualified\n                // However, older toolkits (Axis 1.x) are qualifying them.   We'll go\n                // ahead and just match on the localpart.   The RPCOutInterceptor\n                // will always generate WSI-BP compliant messages so it's unknown if\n                // the non-WSI-BP toolkits will be able to understand the CXF\n                // generated messages if they are expecting it to be qualified.\n                Iterator<MessagePartInfo> partItr = msg.getMessageParts().iterator();\n                while (!qn.getLocalPart().equals(part.getConcreteName().getLocalPart())\n                    && partItr.hasNext()) {\n                    part = partItr.next();\n                }\n                \n                if (!qn.equals(part.getConcreteName())) {\n                    throw new Fault(\n                                    new org.apache.cxf.common.i18n.Message(\n                                                                           \"UNKNOWN_RPC_LIT_PART\",\n                                                                           LOG,\n                                                                           qn));\n                }\n                //honor JAXBAnnotation\n                part.setProperty(\"honor.jaxb.annotations\", true);\n                try {\n                    parameters.put(part, dr.read(part, xmlReader));\n                } catch (Fault f) {\n                    if (!isRequestor(message)) {\n                        f.setFaultCode(Fault.FAULT_CODE_CLIENT);\n                    }\n                    throw f;\n                }\n            }\n        }\n\n        message.setContent(List.class, parameters);\n    }","commit_id":"70aea2b7e5289ab247b825aa03ce186667fee784","url":"https://github.com/apache/cxf"},{"original_method":"private BindingOperationInfo getOperation(Message message, QName opName) {\n        return ServiceModelUtil.getOperation(message.getExchange(), opName);\n    }","id":33021,"modified_method":"private BindingOperationInfo getOperation(Message message, QName opName) {\n        BindingOperationInfo bop = ServiceModelUtil.getOperation(message.getExchange(), opName);\n        if (bop == null) {\n            Endpoint ep = message.getExchange().get(Endpoint.class);\n            if (ep == null) {\n                return null;\n            }\n            BindingInfo service = ep.getEndpointInfo().getBinding();\n            boolean output = !isRequestor(message);\n            for (BindingOperationInfo info : service.getOperations()) {\n                if (info.getName().getLocalPart().equals(opName.getLocalPart())) {\n                    SoapBody body = null;\n                    if (output) {\n                        body = info.getOutput().getExtensor(SoapBody.class);\n                    } else {\n                        body = info.getInput().getExtensor(SoapBody.class);\n                    }        \n                    if (body != null \n                        && opName.getNamespaceURI().equals(body.getNamespaceURI())) {\n                        return info;\n                    }\n                }\n            }\n        }\n        return bop;\n    }","commit_id":"70aea2b7e5289ab247b825aa03ce186667fee784","url":"https://github.com/apache/cxf"},{"original_method":"public void handleMessage(Message message) {\n        try {\n            NSStack nsStack = new NSStack();\n            nsStack.push();\n\n            BindingOperationInfo operation = (BindingOperationInfo) message.getExchange().get(\n                            BindingOperationInfo.class.getName());\n\n            assert operation.getName() != null;\n\n            XMLStreamWriter xmlWriter = getXMLStreamWriter(message);\n\n            addOperationNode(nsStack, message, xmlWriter);\n\n            List<MessagePartInfo> parts = null;\n\n            if (!isRequestor(message)) {\n                parts = operation.getOutput().getMessageParts();\n            } else {\n                parts = operation.getInput().getMessageParts();\n            }\n            \n            MessageContentsList objs = MessageContentsList.getContentsList(message);\n            if (objs == null) {\n                return;\n            }\n            \n            \n            for (MessagePartInfo part : parts) {\n                if (objs.hasValue(part)) {\n                    Object o = objs.get(part);\n                    if (o == null) {\n                        //WSI-BP R2211 - RPC/Lit parts are not allowed to be xsi:nil\n                        throw new Fault(\n                            new org.apache.cxf.common.i18n.Message(\"BP_2211_RPCLIT_CANNOT_BE_NULL\",\n                                                                   LOG, part.getConcreteName()));\n                    }\n                   //WSI-BP R2737  -RPC/LIG part name space is empty\n                   // part.setConcreteName(new QName(\"\", part.getConcreteName().getLocalPart()));\n                    part.setProperty(\"honor.jaxb.annotations\", true);\n                    \n                }\n            }\n            writeParts(message, message.getExchange(), operation, objs, parts);\n            \n            // Finishing the writing.\n            xmlWriter.writeEndElement();            \n        } catch (XMLStreamException e) {\n            throw new Fault(e);\n        }\n    }","id":33022,"modified_method":"public void handleMessage(Message message) {\n        try {\n            NSStack nsStack = new NSStack();\n            nsStack.push();\n\n            BindingOperationInfo operation = (BindingOperationInfo) message.getExchange().get(\n                            BindingOperationInfo.class.getName());\n\n            assert operation.getName() != null;\n\n            XMLStreamWriter xmlWriter = getXMLStreamWriter(message);\n\n\n            List<MessagePartInfo> parts = null;\n\n            if (!isRequestor(message)) {\n                parts = operation.getOutput().getMessageParts();\n                addOperationNode(nsStack, message, xmlWriter, true, operation);\n            } else {\n                parts = operation.getInput().getMessageParts();\n                addOperationNode(nsStack, message, xmlWriter, false, operation);\n            }\n            \n            MessageContentsList objs = MessageContentsList.getContentsList(message);\n            if (objs == null) {\n                return;\n            }\n            \n            \n            for (MessagePartInfo part : parts) {\n                if (objs.hasValue(part)) {\n                    Object o = objs.get(part);\n                    if (o == null) {\n                        //WSI-BP R2211 - RPC/Lit parts are not allowed to be xsi:nil\n                        throw new Fault(\n                            new org.apache.cxf.common.i18n.Message(\"BP_2211_RPCLIT_CANNOT_BE_NULL\",\n                                                                   LOG, part.getConcreteName()));\n                    }\n                   //WSI-BP R2737  -RPC/LIG part name space is empty\n                   // part.setConcreteName(new QName(\"\", part.getConcreteName().getLocalPart()));\n                    part.setProperty(\"honor.jaxb.annotations\", true);\n                    \n                }\n            }\n            writeParts(message, message.getExchange(), operation, objs, parts);\n            \n            // Finishing the writing.\n            xmlWriter.writeEndElement();            \n        } catch (XMLStreamException e) {\n            throw new Fault(e);\n        }\n    }","commit_id":"70aea2b7e5289ab247b825aa03ce186667fee784","url":"https://github.com/apache/cxf"},{"original_method":"protected String addOperationNode(NSStack nsStack, Message message, XMLStreamWriter xmlWriter) \n        throws XMLStreamException {\n        String responseSuffix = !isRequestor(message) ? \"Response\" : \"\";\n        BindingOperationInfo boi = message.getExchange().get(BindingOperationInfo.class);\n        String ns = boi.getName().getNamespaceURI();\n        nsStack.add(ns);\n        String prefix = nsStack.getPrefix(ns);\n        StaxUtils.writeStartElement(xmlWriter, prefix, boi.getName().getLocalPart() + responseSuffix, ns);\n        return ns;\n    }","id":33023,"modified_method":"protected String addOperationNode(NSStack nsStack, Message message, \n                                      XMLStreamWriter xmlWriter, \n                                      boolean output,\n                                      BindingOperationInfo boi) \n        throws XMLStreamException {\n        String responseSuffix = output ? \"Response\" : \"\";\n        String ns = boi.getName().getNamespaceURI();\n        SoapBody body = null;\n        if (output) {\n            body = boi.getOutput().getExtensor(SoapBody.class);\n        } else {\n            body = boi.getInput().getExtensor(SoapBody.class);\n        }        \n        if (body != null && !StringUtils.isEmpty(body.getNamespaceURI())) {\n            ns = body.getNamespaceURI();\n        }\n\n        nsStack.add(ns);\n        String prefix = nsStack.getPrefix(ns);\n        StaxUtils.writeStartElement(xmlWriter, prefix, boi.getName().getLocalPart() + responseSuffix, ns);\n        return ns;\n    }","commit_id":"70aea2b7e5289ab247b825aa03ce186667fee784","url":"https://github.com/apache/cxf"},{"original_method":"protected void run()  {\n        // We use a null binding id in the call to EndpointImpl\n        // constructor. Why?\n        final String nullBindingID = null;\n\n        // We need to specify to use defaults on constructing the\n        // bus, because our configuration file doesn't have\n        // everything needed.\n        final boolean useDefaults = true;\n\n        // We configure a new bus for this server.\n        setBus(new SpringBusFactory().createBus(configFileURL, useDefaults));\n\n        // This impl class must have the appropriate annotations\n        // to match the WSDL file that we are using.\n        Object implementor = new GreeterImpl(name);\n        \n        // I don't know why this works.\n        EndpointImpl ep = \n            new EndpointImpl(\n                    getBus(), \n                    implementor,\n                    nullBindingID,\n                    this.getClass().getResource(\"resources/greeting.wsdl\").toString());\n        // How the hell do I know what the name of the \n        // http-destination is from using this call?\n        \n        ep.publish(address);\n    }","id":33024,"modified_method":"protected void run()  {\n        // We use a null binding id in the call to EndpointImpl\n        // constructor. Why?\n        final String nullBindingID = null;\n\n        // We need to specify to use defaults on constructing the\n        // bus, because our configuration file doesn't have\n        // everything needed.\n        final boolean useDefaults = true;\n\n        // We configure a new bus for this server.\n        setBus(new SpringBusFactory().createBus(configFileURL, useDefaults));\n\n        // This impl class must have the appropriate annotations\n        // to match the WSDL file that we are using.\n        Object implementor = new GreeterImpl(name);\n        \n        // I don't know why this works.\n        EndpointImpl ep = \n            new EndpointImpl(\n                    getBus(), \n                    implementor,\n                    nullBindingID,\n                    this.getClass().getResource(\"resources/greeting.wsdl\").toString());\n        // How the hell do I know what the name of the \n        // http-destination is from using this call?\n        ep.setEndpointName(new QName(\"http://apache.org/hello_world\", name));\n        ep.publish(address);\n    }","commit_id":"70aea2b7e5289ab247b825aa03ce186667fee784","url":"https://github.com/apache/cxf"},{"original_method":"private void initializeMessage(SoapBindingInfo bi, BindingOperationInfo boi, BindingMessageInfo bmsg) {\n        MessageInfo msg = bmsg.getMessageInfo();\n\n        List<MessagePartInfo> messageParts = new ArrayList<MessagePartInfo>();\n        messageParts.addAll(msg.getMessageParts());\n\n        List<SoapHeader> headers =\n            SOAPBindingUtil.getSoapHeaders(bmsg.getExtensors(ExtensibilityElement.class));\n        if (headers != null) {\n            for (SoapHeader header : headers) {\n                SoapHeaderInfo headerInfo = new SoapHeaderInfo();\n                headerInfo.setUse(header.getUse());\n                MessagePartInfo part = msg.getMessagePart(new QName(msg.getName().getNamespaceURI(), \n                                                                    header.getPart()));\n                if (part != null && header.getMessage() != null\n                    && !part.getMessageInfo().getName().equals(header.getMessage())) {\n                    part = null;\n                    //out of band, let's find it\n                    for (MessagePartInfo mpi : msg.getOutOfBandParts()) {\n                        if (mpi.getName().getLocalPart().equals(header.getPart())\n                            && mpi.getMessageInfo().getName().equals(header.getMessage())) {\n                            part = mpi;\n                        }\n                    }\n                }\n                if (part != null) {\n                    headerInfo.setPart(part);\n                    messageParts.remove(part);\n                    bmsg.addExtensor(headerInfo);\n                }\n            }\n\n            // Exclude the header parts from the message part list.\n            bmsg.setMessageParts(messageParts);\n        }\n\n        SoapBodyInfo bodyInfo = new SoapBodyInfo();\n        SoapBody soapBody = SOAPBindingUtil.getSoapBody(bmsg.getExtensors(ExtensibilityElement.class));\n        List parts = null;\n        if (soapBody == null) {\n            MIMEMultipartRelated mmr = bmsg.getExtensor(MIMEMultipartRelated.class);\n            if (mmr != null) {\n                parts = mmr.getMIMEParts();\n            }\n        } else {\n            bodyInfo.setUse(soapBody.getUse());\n            parts = soapBody.getParts();\n        }\n\n        // Initialize the body parts.\n        List<MessagePartInfo> attParts = null;\n        if (parts != null) {\n            List<MessagePartInfo> bodyParts = new ArrayList<MessagePartInfo>();\n            for (Iterator itr = parts.iterator(); itr.hasNext();) {\n                Object part = itr.next();\n                if (part instanceof MIMEPart) {\n                    MIMEPart mpart = (MIMEPart) part;\n                    attParts = handleMimePart(mpart, attParts, msg, bmsg, bodyParts, messageParts);\n                } else {\n                    addSoapBodyPart(msg, bodyParts, (String)part);\n                }\n            }\n            bodyInfo.setParts(bodyParts);\n            bodyInfo.setAttachments(attParts);\n        } else {\n            bodyInfo.setParts(messageParts);\n        }\n\n        bmsg.addExtensor(bodyInfo);\n    }","id":33025,"modified_method":"private void initializeMessage(SoapBindingInfo bi, BindingOperationInfo boi, BindingMessageInfo bmsg) {\n        MessageInfo msg = bmsg.getMessageInfo();\n\n        List<MessagePartInfo> messageParts = new ArrayList<MessagePartInfo>();\n        messageParts.addAll(msg.getMessageParts());\n\n        List<SoapHeader> headers =\n            SOAPBindingUtil.getSoapHeaders(bmsg.getExtensors(ExtensibilityElement.class));\n        if (headers != null) {\n            for (SoapHeader header : headers) {\n                SoapHeaderInfo headerInfo = new SoapHeaderInfo();\n                headerInfo.setUse(header.getUse());\n                MessagePartInfo part = msg.getMessagePart(new QName(msg.getName().getNamespaceURI(), \n                                                                    header.getPart()));\n                if (part != null && header.getMessage() != null\n                    && !part.getMessageInfo().getName().equals(header.getMessage())) {\n                    part = null;\n                    //out of band, let's find it\n                    for (MessagePartInfo mpi : msg.getOutOfBandParts()) {\n                        if (mpi.getName().getLocalPart().equals(header.getPart())\n                            && mpi.getMessageInfo().getName().equals(header.getMessage())) {\n                            part = mpi;\n                        }\n                    }\n                }\n                if (part != null) {\n                    headerInfo.setPart(part);\n                    messageParts.remove(part);\n                    bmsg.addExtensor(headerInfo);\n                }\n            }\n\n            // Exclude the header parts from the message part list.\n            bmsg.setMessageParts(messageParts);\n        }\n\n        SoapBodyInfo bodyInfo = new SoapBodyInfo();\n        SoapBody soapBody = SOAPBindingUtil.getSoapBody(bmsg.getExtensors(ExtensibilityElement.class));\n        \n        List parts = null;\n        if (soapBody == null) {\n            MIMEMultipartRelated mmr = bmsg.getExtensor(MIMEMultipartRelated.class);\n            if (mmr != null) {\n                parts = mmr.getMIMEParts();\n            }\n        } else {\n            bmsg.addExtensor(soapBody);\n            bodyInfo.setUse(soapBody.getUse());\n            parts = soapBody.getParts();\n        }\n\n        // Initialize the body parts.\n        List<MessagePartInfo> attParts = null;\n        if (parts != null) {\n            List<MessagePartInfo> bodyParts = new ArrayList<MessagePartInfo>();\n            for (Iterator itr = parts.iterator(); itr.hasNext();) {\n                Object part = itr.next();\n                if (part instanceof MIMEPart) {\n                    MIMEPart mpart = (MIMEPart) part;\n                    attParts = handleMimePart(mpart, attParts, msg, bmsg, bodyParts, messageParts);\n                } else {\n                    addSoapBodyPart(msg, bodyParts, (String)part);\n                }\n            }\n            bodyInfo.setParts(bodyParts);\n            bodyInfo.setAttachments(attParts);\n        } else {\n            bodyInfo.setParts(messageParts);\n        }\n\n        bmsg.addExtensor(bodyInfo);\n    }","commit_id":"70aea2b7e5289ab247b825aa03ce186667fee784","url":"https://github.com/apache/cxf"},{"original_method":"public static void main(String... args) throws Exception\n    {\n        Server server = new Server();\n\n        ServletContextHandler context = new ServletContextHandler(server, \"/\",ServletContextHandler.SESSIONS);\n        context.setResourceBase(\"/tmp\");\n        context.addFilter(PushSessionCacheFilter.class,\"/*\",EnumSet.of(DispatcherType.REQUEST))\n        .setInitParameter(\"ports\",\"443,6443,8443\");\n        context.addServlet(new ServletHolder(servlet), \"/test/*\");\n        context.addServlet(DefaultServlet.class, \"/\").setInitParameter(\"maxCacheSize\",\"81920\");\n        server.setHandler(context);\n\n\n        // HTTP Configuration\n        HttpConfiguration http_config = new HttpConfiguration();\n        http_config.setSecureScheme(\"https\");\n        http_config.setSecurePort(8443);\n        http_config.setSendXPoweredBy(true);\n        http_config.setSendServerVersion(true);\n\n        // HTTP connector\n        ServerConnector http = new ServerConnector(server,new HttpConnectionFactory(http_config));        \n        http.setPort(8080);\n        server.addConnector(http);\n \n        // SSL Context Factory for HTTPS and SPDY\n        String jetty_distro = System.getProperty(\"jetty.distro\",\"../../jetty-distribution/target/distribution\");\n        SslContextFactory sslContextFactory = new SslContextFactory();\n        sslContextFactory.setKeyStorePath(jetty_distro + \"/etc/keystore\");\n        sslContextFactory.setKeyStorePassword(\"OBF:1vny1zlo1x8e1vnw1vn61x8g1zlu1vn4\");\n        sslContextFactory.setKeyManagerPassword(\"OBF:1u2u1wml1z7s1z7a1wnl1u2g\");\n\n        // HTTPS Configuration\n        HttpConfiguration https_config = new HttpConfiguration(http_config);\n        https_config.addCustomizer(new SecureRequestCustomizer());\n        \n        \n        // HTTP2 factory\n        HTTP2ServerConnectionFactory h2 = new HTTP2ServerConnectionFactory(https_config);\n        \n        NegotiatingServerConnectionFactory.checkProtocolNegotiationAvailable();\n        ALPNServerConnectionFactory alpn = new ALPNServerConnectionFactory();\n        alpn.setDefaultProtocol(http.getDefaultProtocol());\n        \n        // SSL Factory\n        SslConnectionFactory ssl = new SslConnectionFactory(sslContextFactory,alpn.getProtocol());\n        \n        // HTTP2 Connector\n        ServerConnector http2Connector = \n            new ServerConnector(server,ssl,alpn,h2,new HttpConnectionFactory(https_config));\n        http2Connector.setPort(8443);\n        server.addConnector(http2Connector);\n        \n        ALPN.debug=false;\n        \n        server.start();\n        server.dumpStdErr();\n        server.join();\n    }","id":33026,"modified_method":"public static void main(String... args) throws Exception\n    {\n        Server server = new Server();\n\n        ServletContextHandler context = new ServletContextHandler(server, \"/\",ServletContextHandler.SESSIONS);\n        context.setResourceBase(\"src/test/docroot\");\n        context.addFilter(PushSessionCacheFilter.class,\"/*\",EnumSet.of(DispatcherType.REQUEST));\n        context.addFilter(PushedTilesFilter.class,\"/*\",EnumSet.of(DispatcherType.REQUEST));\n        context.addServlet(new ServletHolder(servlet), \"/test/*\");\n        context.addServlet(DefaultServlet.class, \"/\").setInitParameter(\"maxCacheSize\",\"81920\");\n        server.setHandler(context);\n\n        // HTTP Configuration\n        HttpConfiguration http_config = new HttpConfiguration();\n        http_config.setSecureScheme(\"https\");\n        http_config.setSecurePort(8443);\n        http_config.setSendXPoweredBy(true);\n        http_config.setSendServerVersion(true);\n\n        // HTTP connector\n        ServerConnector http = new ServerConnector(server,new HttpConnectionFactory(http_config));        \n        http.setPort(8080);\n        server.addConnector(http);\n \n        // SSL Context Factory for HTTPS and SPDY\n        String jetty_distro = System.getProperty(\"jetty.distro\",\"../../jetty-distribution/target/distribution\");\n        SslContextFactory sslContextFactory = new SslContextFactory();\n        sslContextFactory.setKeyStorePath(jetty_distro + \"/etc/keystore\");\n        sslContextFactory.setKeyStorePassword(\"OBF:1vny1zlo1x8e1vnw1vn61x8g1zlu1vn4\");\n        sslContextFactory.setKeyManagerPassword(\"OBF:1u2u1wml1z7s1z7a1wnl1u2g\");\n\n        // HTTPS Configuration\n        HttpConfiguration https_config = new HttpConfiguration(http_config);\n        https_config.addCustomizer(new SecureRequestCustomizer());\n        \n        // HTTP2 factory\n        HTTP2ServerConnectionFactory h2 = new HTTP2ServerConnectionFactory(https_config);\n        \n        NegotiatingServerConnectionFactory.checkProtocolNegotiationAvailable();\n        ALPNServerConnectionFactory alpn = new ALPNServerConnectionFactory();\n        alpn.setDefaultProtocol(http.getDefaultProtocol());\n        \n        // SSL Factory\n        SslConnectionFactory ssl = new SslConnectionFactory(sslContextFactory,alpn.getProtocol());\n        \n        // HTTP2 Connector\n        ServerConnector http2Connector = \n            new ServerConnector(server,ssl,alpn,h2,new HttpConnectionFactory(https_config));\n        http2Connector.setPort(8443);\n        server.addConnector(http2Connector);\n        \n        ALPN.debug=false;\n        \n        server.start();\n        server.dumpStdErr();\n        server.join();\n    }","commit_id":"14cd10b67667af2f57cb0d608095dc97dee14131","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void push(final MetaData.Request request)\n    {\n        if (!stream.getSession().isPushEnabled())\n        {\n            if (LOG.isDebugEnabled())\n                LOG.debug(\"HTTP/2 Push disabled for {}\", request);\n            return;\n        }\n\n        stream.push(new PushPromiseFrame(stream.getId(), 0, request), new Promise<Stream>()\n        {\n            @Override\n            public void succeeded(Stream pushStream)\n            {\n                connection.onPush(connector, (IStream)pushStream, request);\n            }\n\n            @Override\n            public void failed(Throwable x)\n            {\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"Could not push \" + request, x);\n            }\n        });\n    }","id":33027,"modified_method":"@Override\n    public void push(final MetaData.Request request)\n    {\n        if (!stream.getSession().isPushEnabled())\n        {\n            if (LOG.isDebugEnabled())\n                LOG.debug(\"HTTP/2 Push disabled for {}\", request);\n            return;\n        }\n\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"HTTP/2 Push {}\",request);\n        \n        stream.push(new PushPromiseFrame(stream.getId(), 0, request), new Promise<Stream>()\n        {\n            @Override\n            public void succeeded(Stream pushStream)\n            {\n                connection.onPush(connector, (IStream)pushStream, request);\n            }\n\n            @Override\n            public void failed(Throwable x)\n            {\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"Could not push \" + request, x);\n            }\n        });\n    }","commit_id":"14cd10b67667af2f57cb0d608095dc97dee14131","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public PushBuilder(Request request, HttpFields fields, String method, String queryString, String sessionId, boolean conditional)\n    {\n        super();\n        _request = request;\n        _fields = fields;\n        _method = method;\n        _queryString = queryString;\n        _sessionId = sessionId;\n        _conditional = conditional;\n    }","id":33028,"modified_method":"public PushBuilder(Request request, HttpFields fields, String method, String queryString, String sessionId, boolean conditional)\n    {\n        super();\n        _request = request;\n        _fields = fields;\n        _method = method;\n        _queryString = queryString;\n        _sessionId = sessionId;\n        _conditional = conditional;\n        _fields.add(JettyPush);\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"PushBuilder({} {}?{} s={} c={})\",_method,_request.getRequestURI(),_queryString,_sessionId,_conditional);\n    }","commit_id":"14cd10b67667af2f57cb0d608095dc97dee14131","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/** Push a resource.\n     * Push a resource based on the current state of the PushBuilder.  If {@link #isConditional()}\n     * is true and an etag or lastModified value is provided, then an appropriate conditional header\n     * will be generated. If an etag and lastModified value are provided only an If-None-Match header\n     * will be generated. If the builder has a session ID, then the pushed request\n     * will include the session ID either as a Cookie or as a URI parameter as appropriate.The builders\n     * query string is merged with any passed query string.\n     * @param path The URI of the resource to push.\n     * @param etag The etag for the resource or null if not available\n     * @param lastModified The last modified date of the resource or null if not available\n     * @throws IllegalArgumentException if the method set expects a request \n     * body (eg POST)\n     */\n    public void push(String path,String etag,String lastModified)\n    {\n        if (HttpMethod.POST.is(_method) || HttpMethod.PUT.is(_method))\n            throw new IllegalStateException(\"Bad Method \"+_method);\n        \n        String query=_queryString;\n        int q=path.indexOf('?');\n        if (q>=0)\n        {\n            query=path.substring(q+1)+'&'+query;\n            path=path.substring(0,q);\n        }\n                \n        String param=null;\n        if (_sessionId!=null && _request.isRequestedSessionIdFromURL())\n            param=\"jsessionid=\"+_sessionId;\n        \n        if (_conditional)\n        {\n            if (etag!=null)\n                _fields.add(HttpHeader.IF_NONE_MATCH,etag);\n            else if (lastModified!=null)\n                _fields.add(HttpHeader.IF_MODIFIED_SINCE,lastModified);\n        }\n        \n        HttpURI uri = HttpURI.createHttpURI(_request.getScheme(),_request.getServerName(),_request.getServerPort(),path,param,query,null);\n        MetaData.Request push = new MetaData.Request(_method,uri,_request.getHttpVersion(),_fields);\n        _request.getHttpChannel().getHttpTransport().push(push);\n    }","id":33029,"modified_method":"/** Push a resource.\n     * Push a resource based on the current state of the PushBuilder.  If {@link #isConditional()}\n     * is true and an etag or lastModified value is provided, then an appropriate conditional header\n     * will be generated. If an etag and lastModified value are provided only an If-None-Match header\n     * will be generated. If the builder has a session ID, then the pushed request\n     * will include the session ID either as a Cookie or as a URI parameter as appropriate.The builders\n     * query string is merged with any passed query string.\n     * @param path The URI of the resource to push.\n     * @param etag The etag for the resource or null if not available\n     * @param lastModified The last modified date of the resource or null if not available\n     * @throws IllegalArgumentException if the method set expects a request \n     * body (eg POST)\n     */\n    public void push(String path,String etag,String lastModified)\n    {\n        if (HttpMethod.POST.is(_method) || HttpMethod.PUT.is(_method))\n            throw new IllegalStateException(\"Bad Method \"+_method);\n        \n        String query=_queryString;\n        int q=path.indexOf('?');\n        if (q>=0)\n        {\n            query=path.substring(q+1)+'&'+query;\n            path=path.substring(0,q);\n        }\n                \n        String param=null;\n        if (_sessionId!=null && _request.isRequestedSessionIdFromURL())\n            param=\"jsessionid=\"+_sessionId;\n        \n        if (_conditional)\n        {\n            if (etag!=null)\n                _fields.add(HttpHeader.IF_NONE_MATCH,etag);\n            else if (lastModified!=null)\n                _fields.add(HttpHeader.IF_MODIFIED_SINCE,lastModified);\n        }\n        \n        HttpURI uri = HttpURI.createHttpURI(_request.getScheme(),_request.getServerName(),_request.getServerPort(),path,param,query,null);\n        MetaData.Request push = new MetaData.Request(_method,uri,_request.getHttpVersion(),_fields);\n        \n        if (LOG.isDebugEnabled())\n            LOG.debug(\"Push {} {} inm={} ims={}\",_method,uri,_fields.get(HttpHeader.IF_NONE_MATCH),_fields.get(HttpHeader.IF_MODIFIED_SINCE));\n        \n        _request.getHttpChannel().getHttpTransport().push(push);\n    }","commit_id":"14cd10b67667af2f57cb0d608095dc97dee14131","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * @see javax.servlet.Filter#doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain)\n     */\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException\n    { \n        // Get Jetty request as these APIs are not yet standard\n        Request baseRequest = Request.getBaseRequest(request);\n        String uri=baseRequest.getRequestURI();\n\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"{} {} push={}\",baseRequest.getMethod(),uri,baseRequest.isPush());\n\n        HttpSession session = baseRequest.getSession(true);\n\n        // find the target for this resource\n        Target target = _cache.get(uri);\n        if (target == null)\n        {\n            Target t=new Target(uri);\n            target = _cache.putIfAbsent(uri,t);\n            target = target==null?t:target;\n        }\n        request.setAttribute(TARGET_ATTR,target);\n        \n        // Set the timestamp for this resource in this session\n        ConcurrentHashMap<String, Long> timestamps = (ConcurrentHashMap<String, Long>)session.getAttribute(TIMESTAMP_ATTR);\n        if (timestamps==null)\n        {\n            timestamps=new ConcurrentHashMap<>();\n            session.setAttribute(TIMESTAMP_ATTR,timestamps);\n        }\n        timestamps.put(uri,System.currentTimeMillis());\n        \n        // push any associated resources\n        if (baseRequest.isPushSupported() && target._associated.size()>0)\n        {\n            PushBuilder builder = baseRequest.getPushBuilder();\n            if (!session.isNew())\n                builder.setConditional(true);\n            for (Target associated : target._associated.values())\n            {\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"PUSH {}->{}\",uri,associated);\n                builder.push(associated._path,associated._etag,associated._lastModified);\n            }\n        }\n\n        chain.doFilter(request,response);\n    }","id":33030,"modified_method":"/**\n     * @see javax.servlet.Filter#doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain)\n     */\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException\n    { \n        // Get Jetty request as these APIs are not yet standard\n        Request baseRequest = Request.getBaseRequest(request);\n        String uri=baseRequest.getRequestURI();\n\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"{} {} push={}\",baseRequest.getMethod(),uri,baseRequest.isPush());\n\n        HttpSession session = baseRequest.getSession(true);\n\n        // find the target for this resource\n        Target target = _cache.get(uri);\n        if (target == null)\n        {\n            Target t=new Target(uri);\n            target = _cache.putIfAbsent(uri,t);\n            target = target==null?t:target;\n        }\n        request.setAttribute(TARGET_ATTR,target);\n        \n        // Set the timestamp for this resource in this session\n        ConcurrentHashMap<String, Long> timestamps = (ConcurrentHashMap<String, Long>)session.getAttribute(TIMESTAMP_ATTR);\n        if (timestamps==null)\n        {\n            timestamps=new ConcurrentHashMap<>();\n            session.setAttribute(TIMESTAMP_ATTR,timestamps);\n        }\n        timestamps.put(uri,System.currentTimeMillis());\n        \n        // push any associated resources\n        if (baseRequest.isPushSupported() && target._associated.size()>0)\n        {\n            PushBuilder builder = baseRequest.getPushBuilder();\n            for (Target associated : target._associated.values())\n            {\n                String path = associated._path;\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"PUSH {} <- {}\",path,uri);\n                \n                builder.push(path,associated._etag,associated._lastModified);\n            }\n        }\n\n        chain.doFilter(request,response);\n    }","commit_id":"14cd10b67667af2f57cb0d608095dc97dee14131","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * @see javax.servlet.Filter#init(javax.servlet.FilterConfig)\n     */\n    @Override\n    public void init(FilterConfig config) throws ServletException\n    {\n        if (config.getInitParameter(\"associateDelay\")!=null)\n            _associateDelay=Long.valueOf(config.getInitParameter(\"associateDelay\"));\n        \n        // Add a listener that is used to collect information about associated resource,\n        // etags and modified dates\n        config.getServletContext().addListener(new ServletRequestListener()\n        {\n            // Collect information when request is destroyed.\n            @Override\n            public void requestDestroyed(ServletRequestEvent sre)\n            {\n                Request request = Request.getBaseRequest(sre.getServletRequest());\n                Target target = (Target)request.getAttribute(TARGET_ATTR);\n                if (target==null)\n                    return;\n\n                // Update conditional data\n                Response response = request.getResponse();\n                target._etag=response.getHttpFields().get(HttpHeader.ETAG);\n                target._lastModified=response.getHttpFields().get(HttpHeader.LAST_MODIFIED);\n                \n                // Does this request have a referer?\n                String referer = request.getHttpFields().get(HttpHeader.REFERER);\n                \n                if (referer!=null)\n                {\n                    // Is the referer from this contexts?\n                    HttpURI referer_uri = new HttpURI(referer);\n                    if (request.getServerName().equals(referer_uri.getHost()))\n                    {\n                        Target referer_target = _cache.get(referer_uri.getPath());\n                        if (referer_target!=null)\n                        {\n                            HttpSession session = request.getSession();                            \n                            ConcurrentHashMap<String, Long> timestamps = (ConcurrentHashMap<String, Long>)session.getAttribute(TIMESTAMP_ATTR);\n                            Long last = timestamps.get(referer_target._path);\n                            if (last!=null && (System.currentTimeMillis()-last)<_associateDelay)\n                            {\n                                if (referer_target._associated.putIfAbsent(target._path,target)==null)\n                                {\n                                    if (LOG.isDebugEnabled())\n                                        LOG.debug(\"ASSOCIATE {}->{}\",referer_target._path,target._path);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            @Override\n            public void requestInitialized(ServletRequestEvent sre)\n            {\n            }\n            \n        });\n        \n    }","id":33031,"modified_method":"/**\n     * @see javax.servlet.Filter#init(javax.servlet.FilterConfig)\n     */\n    @Override\n    public void init(FilterConfig config) throws ServletException\n    {\n        if (config.getInitParameter(\"associateDelay\")!=null)\n            _associateDelay=Long.valueOf(config.getInitParameter(\"associateDelay\"));\n        \n        // Add a listener that is used to collect information about associated resource,\n        // etags and modified dates\n        config.getServletContext().addListener(new ServletRequestListener()\n        {\n            // Collect information when request is destroyed.\n            @Override\n            public void requestDestroyed(ServletRequestEvent sre)\n            {\n                Request request = Request.getBaseRequest(sre.getServletRequest());\n                Target target = (Target)request.getAttribute(TARGET_ATTR);\n                if (target==null)\n                    return;\n\n                // Update conditional data\n                Response response = request.getResponse();\n                target._etag=response.getHttpFields().get(HttpHeader.ETAG);\n                target._lastModified=response.getHttpFields().get(HttpHeader.LAST_MODIFIED);\n                \n                // Don't associate pushes\n                if (request.isPush())\n                {\n                    if (LOG.isDebugEnabled())\n                        LOG.debug(\"Pushed {} for {}\",request.getResponse().getStatus(),request.getRequestURI());\n                    return;\n                } \n                else if (LOG.isDebugEnabled())\n                    LOG.debug(\"Served {} for {}\",request.getResponse().getStatus(),request.getRequestURI());\n                \n                // Does this request have a referer?\n                String referer = request.getHttpFields().get(HttpHeader.REFERER);\n                \n                if (referer!=null)\n                {\n                    // Is the referer from this contexts?\n                    HttpURI referer_uri = new HttpURI(referer);\n                    if (request.getServerName().equals(referer_uri.getHost()))\n                    {\n                        Target referer_target = _cache.get(referer_uri.getPath());\n                        if (referer_target!=null)\n                        {\n                            HttpSession session = request.getSession();                            \n                            ConcurrentHashMap<String, Long> timestamps = (ConcurrentHashMap<String, Long>)session.getAttribute(TIMESTAMP_ATTR);\n                            Long last = timestamps.get(referer_target._path);\n                            if (last!=null && (System.currentTimeMillis()-last)<_associateDelay)\n                            {\n                                if (referer_target._associated.putIfAbsent(target._path,target)==null)\n                                {\n                                    if (LOG.isDebugEnabled())\n                                        LOG.debug(\"ASSOCIATE {}->{}\",referer_target._path,target._path);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            @Override\n            public void requestInitialized(ServletRequestEvent sre)\n            {\n            }\n            \n        });\n        \n    }","commit_id":"14cd10b67667af2f57cb0d608095dc97dee14131","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Get all tags within the wiki.\n     *\n     * @param context XWiki context.\n     * @return list of tags (alphabetical order).\n     * @throws com.xpn.xwiki.XWikiException if search query fails (possible failures: DB access problems, etc).\n     */\n    public static List<String> getAllTags(XWikiContext context) throws XWikiException\n    {\n        List<String> results;\n\n        String hql = \"select distinct elements(prop.list) from XWikiDocument as doc, BaseObject as obj, \"\n            + \"DBStringListProperty as prop where obj.name=doc.fullName and obj.className='XWiki.TagClass' and \"\n            + \"obj.id=prop.id.id and prop.id.name='tags'\";\n\n        try {\n            Query query = context.getWiki().getStore().getQueryManager().createQuery(hql, Query.HQL);\n            query.addFilter(Utils.<QueryFilter> getComponent(QueryFilter.class, HIDDEN_QUERYFILTER_HINT));\n            results = query.execute();\n        } catch (QueryException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE, XWikiException.ERROR_XWIKI_UNKNOWN,\n                String.format(\"Failed to get all tags\", hql), e);\n        }\n\n        Collections.sort(results, String.CASE_INSENSITIVE_ORDER);\n\n        return results;\n    }","id":33032,"modified_method":"/**\n     * Get all tags within the wiki.\n     *\n     * @param context XWiki context.\n     * @return list of tags (alphabetical order).\n     * @throws com.xpn.xwiki.XWikiException if search query fails (possible failures: DB access problems, etc).\n     */\n    public static List<String> getAllTags(XWikiContext context) throws XWikiException\n    {\n        List<String> results;\n\n        String hql = \"select distinct elements(prop.list) from XWikiDocument as doc, BaseObject as obj, \"\n            + \"DBStringListProperty as prop where obj.name=doc.fullName and obj.className='XWiki.TagClass' and \"\n            + \"obj.id=prop.id.id and prop.id.name='tags'\";\n\n        try {\n            Query query = context.getWiki().getStore().getQueryManager().createQuery(hql, Query.HQL);\n            query.addFilter(Utils.<QueryFilter> getComponent(QueryFilter.class, HiddenDocumentFilter.HINT));\n            results = query.execute();\n        } catch (QueryException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE, XWikiException.ERROR_XWIKI_UNKNOWN,\n                String.format(\"Failed to get all tags\", hql), e);\n        }\n\n        Collections.sort(results, String.CASE_INSENSITIVE_ORDER);\n\n        return results;\n    }","commit_id":"5863bc80236ff9d3e6d5ef53012686d289a16b65","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Get cardinality map of tags matching a parameterized hql query.\n     *\n     * @param fromHql the <code>from<\/code> fragment of the hql query\n     * @param whereHql the <code>where<\/code> fragment of the hql query\n     * @param parameterValues list of parameter values for the query\n     * @param context XWiki context.\n     * @return map of tags (alphabetical order) with their occurrences counts.\n     * @throws XWikiException if search query fails (possible failures: DB access problems, etc).\n     * @since 1.18\n     * @see TagPluginApi#getTagCountForQuery(String, String, java.util.List)\n     */\n    public static Map<String, Integer> getTagCountForQuery(String fromHql, String whereHql, List< ? > parameterValues,\n            XWikiContext context) throws XWikiException\n    {\n        List<String> results = null;\n        Map<String, Integer> tagCount = new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER);\n\n        String from = \"select elements(prop.list) from XWikiDocument as doc, BaseObject as tagobject, \"\n            + \"DBStringListProperty as prop\";\n        String where = \" where tagobject.name=doc.fullName and tagobject.className='XWiki.TagClass' and \"\n            + \"tagobject.id=prop.id.id and prop.id.name='tags'\";\n\n        // If at least one of the fragments is passed, the query should be matching XWiki documents\n        if (!StringUtils.isBlank(fromHql) || !StringUtils.isBlank(whereHql)) {\n            from += fromHql;\n        }\n        if (!StringUtils.isBlank(whereHql)) {\n            where += \" and \" + whereHql;\n        }\n\n        List<?> params = parameterValues;\n        if (params == null) {\n            params = new ArrayList<String>();\n        }\n        String hql = from + where;\n\n        try {\n            Query query = context.getWiki().getStore().getQueryManager().createQuery(hql, Query.HQL);\n            query.bindValues((List<Object>) params);\n            query.addFilter(Utils.<QueryFilter> getComponent(QueryFilter.class, HIDDEN_QUERYFILTER_HINT));\n            results = query.execute();\n        } catch (QueryException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE, XWikiException.ERROR_XWIKI_UNKNOWN,\n                String.format(\"Failed to get tag count for query [%s], with parameters [%s]\", hql, params.toString()),\n                e);\n        }\n\n        Collections.sort(results, String.CASE_INSENSITIVE_ORDER);\n        Map<String, String> processedTags = new HashMap<String, String>();\n\n        // We have to manually build a cardinality map since we have to ignore tags case.\n        for (String result : results) {\n            // This key allows to keep track of the case variants we've encountered.\n            String lowerTag = result.toLowerCase();\n\n            // We store the first case variant to reuse it in the final result set.\n            if (!processedTags.containsKey(lowerTag)) {\n                processedTags.put(lowerTag, result);\n            }\n\n            String tagCountKey = processedTags.get(lowerTag);\n            int tagCountForTag = 0;\n            if (tagCount.get(tagCountKey) != null) {\n                tagCountForTag = tagCount.get(tagCountKey);\n            }\n            tagCount.put(tagCountKey, tagCountForTag + 1);\n        }\n\n        return tagCount;\n    }","id":33033,"modified_method":"/**\n     * Get cardinality map of tags matching a parameterized hql query.\n     *\n     * @param fromHql the <code>from<\/code> fragment of the hql query\n     * @param whereHql the <code>where<\/code> fragment of the hql query\n     * @param parameterValues list of parameter values for the query\n     * @param context XWiki context.\n     * @return map of tags (alphabetical order) with their occurrences counts.\n     * @throws XWikiException if search query fails (possible failures: DB access problems, etc).\n     * @since 1.18\n     * @see TagPluginApi#getTagCountForQuery(String, String, java.util.List)\n     */\n    public static Map<String, Integer> getTagCountForQuery(String fromHql, String whereHql, List< ? > parameterValues,\n            XWikiContext context) throws XWikiException\n    {\n        List<String> results = null;\n        Map<String, Integer> tagCount = new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER);\n\n        String from = \"select elements(prop.list) from XWikiDocument as doc, BaseObject as tagobject, \"\n            + \"DBStringListProperty as prop\";\n        String where = \" where tagobject.name=doc.fullName and tagobject.className='XWiki.TagClass' and \"\n            + \"tagobject.id=prop.id.id and prop.id.name='tags'\";\n\n        // If at least one of the fragments is passed, the query should be matching XWiki documents\n        if (!StringUtils.isBlank(fromHql) || !StringUtils.isBlank(whereHql)) {\n            from += fromHql;\n        }\n        if (!StringUtils.isBlank(whereHql)) {\n            where += \" and \" + whereHql;\n        }\n\n        List<?> params = parameterValues;\n        if (params == null) {\n            params = new ArrayList<String>();\n        }\n        String hql = from + where;\n\n        try {\n            Query query = context.getWiki().getStore().getQueryManager().createQuery(hql, Query.HQL);\n            query.bindValues((List<Object>) params);\n            query.addFilter(Utils.<QueryFilter> getComponent(QueryFilter.class, HiddenDocumentFilter.HINT));\n            results = query.execute();\n        } catch (QueryException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE, XWikiException.ERROR_XWIKI_UNKNOWN,\n                String.format(\"Failed to get tag count for query [%s], with parameters [%s]\", hql, params.toString()),\n                e);\n        }\n\n        Collections.sort(results, String.CASE_INSENSITIVE_ORDER);\n        Map<String, String> processedTags = new HashMap<String, String>();\n\n        // We have to manually build a cardinality map since we have to ignore tags case.\n        for (String result : results) {\n            // This key allows to keep track of the case variants we've encountered.\n            String lowerTag = result.toLowerCase();\n\n            // We store the first case variant to reuse it in the final result set.\n            if (!processedTags.containsKey(lowerTag)) {\n                processedTags.put(lowerTag, result);\n            }\n\n            String tagCountKey = processedTags.get(lowerTag);\n            int tagCountForTag = 0;\n            if (tagCount.get(tagCountKey) != null) {\n                tagCountForTag = tagCount.get(tagCountKey);\n            }\n            tagCount.put(tagCountKey, tagCountForTag + 1);\n        }\n\n        return tagCount;\n    }","commit_id":"5863bc80236ff9d3e6d5ef53012686d289a16b65","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Get documents with the passed tags with the result depending on whether the caller decides to include\n     * hidden documents or not.\n     *\n     * @param tag a list of tags to match.\n     * @param includeHiddenDocuments if true then include hidden documents\n     * @param context XWiki context.\n     * @return list of docNames.\n     * @throws XWikiException if search query fails (possible failures: DB access problems, etc).\n     * @since 6.2M1\n     */\n    public static List<String> getDocumentsWithTag(String tag, boolean includeHiddenDocuments, XWikiContext context)\n        throws XWikiException\n    {\n        List<String> results;\n        List<Object> parameters = new ArrayList<>();\n        parameters.add(TagPlugin.TAG_CLASS);\n        parameters.add(tag);\n        String hql = \", BaseObject as obj, DBStringListProperty as prop join prop.list item where obj.className=? and \"\n            + \"obj.name=doc.fullName and obj.id=prop.id.id and prop.id.name='tags' and lower(item)=lower(?) order by \"\n            + \"doc.fullName\";\n\n        try {\n            Query query = context.getWiki().getStore().getQueryManager().createQuery(hql, Query.HQL);\n            query.bindValues(parameters);\n            if (!includeHiddenDocuments) {\n                query.addFilter(Utils.getComponent(QueryFilter.class, HIDDEN_QUERYFILTER_HINT));\n            }\n            results = query.execute();\n        } catch (QueryException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE, XWikiException.ERROR_XWIKI_UNKNOWN,\n                String.format(\"Failed to search for document with tag [%s]\", tag), e);\n        }\n\n        return results;\n    }","id":33034,"modified_method":"/**\n     * Get documents with the passed tags with the result depending on whether the caller decides to include\n     * hidden documents or not.\n     *\n     * @param tag a list of tags to match.\n     * @param includeHiddenDocuments if true then include hidden documents\n     * @param context XWiki context.\n     * @return list of docNames.\n     * @throws XWikiException if search query fails (possible failures: DB access problems, etc).\n     * @since 6.2M1\n     */\n    public static List<String> getDocumentsWithTag(String tag, boolean includeHiddenDocuments, XWikiContext context)\n        throws XWikiException\n    {\n        List<String> results;\n        List<Object> parameters = new ArrayList<>();\n        parameters.add(TagPlugin.TAG_CLASS);\n        parameters.add(tag);\n        String hql = \", BaseObject as obj, DBStringListProperty as prop join prop.list item where obj.className=? and \"\n            + \"obj.name=doc.fullName and obj.id=prop.id.id and prop.id.name='tags' and lower(item)=lower(?) order by \"\n            + \"doc.fullName\";\n\n        try {\n            Query query = context.getWiki().getStore().getQueryManager().createQuery(hql, Query.HQL);\n            query.bindValues(parameters);\n            query.addFilter(Utils.getComponent(QueryFilter.class, UniqueDocumentFilter.HINT));\n            if (!includeHiddenDocuments) {\n                query.addFilter(Utils.getComponent(QueryFilter.class, HiddenDocumentFilter.HINT));\n            }\n            results = query.execute();\n        } catch (QueryException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE, XWikiException.ERROR_XWIKI_UNKNOWN,\n                String.format(\"Failed to search for document with tag [%s]\", tag), e);\n        }\n\n        return results;\n    }","commit_id":"5863bc80236ff9d3e6d5ef53012686d289a16b65","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n   * Constructor.\n   * @param d dialog reference\n   */\n  public DialogAdd(final DialogProps d) {\n    dialog = d;\n    setLayout(new BorderLayout());\n\n    target = new BaseXTextField(\"/\", d);\n    target.addKeyListener(d.keys);\n\n    final BaseXBack pnl = new BaseXBack(new TableLayout(2, 1));\n    pnl.add(new BaseXLabel(TARGET_PATH + COLS, true, true).border(12, 0, 6, 0));\n    pnl.add(target);\n\n    // option panels\n    final DialogParsing parsing = new DialogParsing(d);\n    general = new DialogImport(d, pnl, parsing);\n\n    final BaseXTabs tabs = new BaseXTabs(d);\n    tabs.addTab(GENERAL, general);\n    tabs.addTab(PARSING, parsing);\n    add(tabs, BorderLayout.NORTH);\n\n    // buttons\n    add = new BaseXButton(ADD + DOTS, d);\n    optimize = new BaseXButton(OPTIMIZE + DOTS, d);\n    final BaseXBack buttons = new BaseXBack(Fill.NONE);\n    buttons.add(add);\n    buttons.add(optimize);\n\n    final BaseXBack btn = new BaseXBack(Fill.NONE).layout(new BorderLayout());\n    btn.add(buttons, BorderLayout.EAST);\n    add(btn, BorderLayout.EAST);\n  }","id":33035,"modified_method":"/**\n   * Constructor.\n   * @param d dialog reference\n   */\n  public DialogAdd(final DialogProps d) {\n    dialog = d;\n    setLayout(new BorderLayout());\n\n    target = new BaseXTextField(\"/\", d);\n    target.addKeyListener(d.keys);\n\n    final BaseXBack pnl = new BaseXBack(new TableLayout(2, 1));\n    pnl.add(new BaseXLabel(TARGET_PATH + COLS, true, true).border(8, 0, 6, 0));\n    pnl.add(target);\n\n    // option panels\n    final BaseXTabs tabs = new BaseXTabs(d);\n    final DialogParsing parsing = new DialogParsing(d, tabs);\n    general = new DialogImport(d, pnl, parsing);\n\n    tabs.addTab(GENERAL, general);\n    tabs.addTab(PARSING, parsing);\n    add(tabs, BorderLayout.NORTH);\n\n    // buttons\n    add = new BaseXButton(ADD + DOTS, d);\n    optimize = new BaseXButton(OPTIMIZE + DOTS, d);\n    final BaseXBack buttons = new BaseXBack(Fill.NONE);\n    buttons.add(add);\n    buttons.add(optimize);\n\n    final BaseXBack btn = new BaseXBack(Fill.NONE).layout(new BorderLayout());\n    btn.add(buttons, BorderLayout.EAST);\n    add(btn, BorderLayout.EAST);\n\n    action(general.parser);\n  }","commit_id":"abce6747ee15fe8eeea66f55263bbdb76cfb4be5","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Reacts on user input.\n   * @param comp the action component\n   */\n  void action(final Object comp) {\n    final String src = general.input();\n    final String trg = target.getText().trim();\n\n    if(comp == add) {\n      general.setOptions();\n      final Runnable run = new Runnable() {\n        @Override\n        public void run() {\n          dialog.resources.refreshNewFolder(trg);\n        }\n      };\n      DialogProgress.execute(dialog, \"\", run, new Add(trg, src));\n\n    } else if (comp == optimize) {\n      DialogProgress.execute(dialog, \"\", new Optimize());\n\n    } else if (comp == general.browse) {\n      target.setText(general.dbname);\n\n    } else {\n      boolean ok = general.action(comp, false);\n      String inf = !ok ? FILE_NOT_FOUND : !ok ? ENTER_DB_NAME : null;\n      final Msg icon = Msg.ERROR;\n      if(ok) {\n        // check if target path is valid\n        ok = MetaData.normPath(trg) != null;\n        if(!ok) inf = Util.info(INVALID_X, TARGET_PATH);\n      }\n      general.info.setText(inf, icon);\n      add.setEnabled(ok);\n      optimize.setEnabled(!dialog.gui.context.data().meta.uptodate);\n    }\n  }","id":33036,"modified_method":"/**\n   * Reacts on user input.\n   * @param comp the action component\n   */\n  void action(final Object comp) {\n    final String src = general.input();\n    final String trg = target.getText().trim();\n\n    if(comp == add) {\n      general.setOptions();\n      final Runnable run = new Runnable() {\n        @Override\n        public void run() {\n          dialog.resources.refreshNewFolder(trg);\n        }\n      };\n      DialogProgress.execute(dialog, \"\", run, new Add(trg, src));\n\n    } else if (comp == optimize) {\n      DialogProgress.execute(dialog, \"\", new Optimize());\n\n    } else if (comp == general.browse || comp == general.input) {\n      target.setText(general.dbname);\n\n    } else {\n      boolean ok = general.action(comp, false);\n      String inf = !ok ? FILE_NOT_FOUND : !ok ? ENTER_DB_NAME : null;\n      final Msg icon = Msg.ERROR;\n      if(ok) {\n        // check if target path is valid\n        ok = MetaData.normPath(trg) != null;\n        if(!ok) inf = Util.info(INVALID_X, TARGET_PATH);\n      }\n      general.info.setText(inf, icon);\n      add.setEnabled(ok);\n      optimize.setEnabled(!dialog.gui.context.data().meta.uptodate);\n    }\n  }","commit_id":"abce6747ee15fe8eeea66f55263bbdb76cfb4be5","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Constructor.\r\n   * @param d dialog reference\r\n   * @param create create dialog\r\n   */\r\n  DialogFT(final Dialog d, final boolean create) {\r\n    dialog = d;\r\n    layout(new TableLayout(create ? 9 : 16, 1));\r\n\r\n    final Prop prop = d.gui.context.prop;\r\n    add(new BaseXLabel(H_FULLTEXT_INDEX, true, false).border(0, 0, 12, 0));\r\n\r\n    final String sw = prop.get(Prop.STOPWORDS);\r\n    final String[] cb = { LANGUAGE, SUPPORT_WILDCARDS, STEMMING,\r\n        CASE_SENSITIVITY, DIACRITICS, TFIDF_SCORING, STOPWORD_LIST };\r\n    final String[] desc = { H_LANGUAGE, H_WILDCARD, H_STEMMING, H_CASE,\r\n        H_DIACRITICS, H_SCORING, H_STOPWORDS };\r\n    final boolean[] val = {\r\n        !prop.get(Prop.LANGUAGE).isEmpty(), prop.is(Prop.WILDCARDS),\r\n        prop.is(Prop.STEMMING), prop.is(Prop.CASESENS),\r\n        prop.is(Prop.DIACRITICS), prop.num(Prop.SCORING) > 0, !sw.isEmpty() };\r\n\r\n    for(int f = 0; f < check.length; ++f) {\r\n      check[f] = new BaseXCheckBox(cb[f], val[f], create ? 1 : 0, d);\r\n      if(!create) {\r\n        labels[f] = new BaseXLabel(desc[f], true, false);\r\n      } else {\r\n        check[f].setToolTipText(desc[f]);\r\n      }\r\n    }\r\n\r\n    final BaseXBack b1 = new BaseXBack(new TableLayout(1, 2, 8, 0));\r\n    b1.add(check[F_LANG]);\r\n    final StringList langs = FTLexer.languages();\r\n    language = new BaseXCombo(d, langs.toArray());\r\n    final Language ln = Language.get(prop);\r\n    for(final String l : langs) {\r\n      final String s = l.replaceFirst(\" \\\\(.*\", \"\");\r\n      if(s.equals(ln.toString())) language.setSelectedItem(l);\r\n    }\r\n\r\n    b1.add(language);\r\n    add(b1);\r\n    if(!create) add(labels[F_LANG]);\r\n\r\n    for(int f = 1; f < F_SCORE; ++f) {\r\n      add(check[f]);\r\n      if(!create) add(labels[f]);\r\n    }\r\n\r\n    final BaseXBack b2 = new BaseXBack(new TableLayout(1, 2, 8, 0));\r\n    b2.add(check[F_SCORE]);\r\n    scoring = new BaseXCombo(d, DOCUMENTS, TEXT_NODES);\r\n    b2.add(scoring);\r\n    add(b2);\r\n    if(!create) add(labels[F_SCORE]);\r\n\r\n    add(check[F_STOP]);\r\n    check[F_STOP].setBorder(new EmptyBorder(0, 0, 4, 0));\r\n    final BaseXBack b3 = new BaseXBack(new TableLayout(1, 2, 8, 0));\r\n    swpath = new BaseXTextField(sw.isEmpty() ?\r\n        d.gui.gprop.get(GUIProp.STOPPATH) : sw, d);\r\n    b3.add(swpath);\r\n\r\n    swbrowse = new BaseXButton(BROWSE_D, d);\r\n    swbrowse.addActionListener(new ActionListener() {\r\n      @Override\r\n      public void actionPerformed(final ActionEvent e) {\r\n        chooseStop();\r\n      }\r\n    });\r\n    b3.add(swbrowse);\r\n    add(b3);\r\n    if(!create) add(labels[F_STOP]);\r\n  }","id":33037,"modified_method":"/**\r\n   * Constructor.\r\n   * @param d dialog reference\r\n   * @param create create dialog\r\n   */\r\n  DialogFT(final Dialog d, final boolean create) {\r\n    dialog = d;\r\n    layout(new TableLayout(create ? 10 : 17, 1));\r\n\r\n    final Prop prop = d.gui.context.prop;\r\n    add(new BaseXLabel(H_FULLTEXT_INDEX, true, false).border(0, 0, 12, 0));\r\n\r\n    final String sw = prop.get(Prop.STOPWORDS);\r\n    final String[] cb = { LANGUAGE, SUPPORT_WILDCARDS, STEMMING,\r\n        CASE_SENSITIVITY, DIACRITICS, TFIDF_SCORING, STOPWORD_LIST };\r\n    final String[] desc = { H_LANGUAGE, H_WILDCARD, H_STEMMING, H_CASE,\r\n        H_DIACRITICS, H_SCORING, H_STOPWORDS };\r\n    final boolean[] val = {\r\n        !prop.get(Prop.LANGUAGE).isEmpty(), prop.is(Prop.WILDCARDS),\r\n        prop.is(Prop.STEMMING), prop.is(Prop.CASESENS),\r\n        prop.is(Prop.DIACRITICS), prop.num(Prop.SCORING) > 0, !sw.isEmpty() };\r\n\r\n    for(int f = 0; f < check.length; ++f) {\r\n      check[f] = new BaseXCheckBox(cb[f], val[f], create ? 1 : 0, d);\r\n      if(!create) {\r\n        labels[f] = new BaseXLabel(desc[f], true, false);\r\n      } else {\r\n        check[f].setToolTipText(desc[f]);\r\n      }\r\n    }\r\n\r\n    final BaseXBack b1 = new BaseXBack(new TableLayout(1, 2, 8, 0));\r\n    b1.add(check[F_LANG]);\r\n    final StringList langs = FTLexer.languages();\r\n    language = new BaseXCombo(d, langs.toArray());\r\n    final Language ln = Language.get(prop);\r\n    for(final String l : langs) {\r\n      final String s = l.replaceFirst(\" \\\\(.*\", \"\");\r\n      if(s.equals(ln.toString())) language.setSelectedItem(l);\r\n    }\r\n\r\n    b1.add(language);\r\n    add(b1);\r\n    if(!create) add(labels[F_LANG]);\r\n\r\n    for(int f = 1; f < F_SCORE; ++f) {\r\n      add(check[f]);\r\n      if(!create) add(labels[f]);\r\n    }\r\n\r\n    final BaseXBack b2 = new BaseXBack(new TableLayout(1, 2, 8, 0));\r\n    b2.add(check[F_SCORE]);\r\n    scoring = new BaseXCombo(d, DOCUMENTS, TEXT_NODES);\r\n    b2.add(scoring);\r\n    add(b2);\r\n    if(!create) add(labels[F_SCORE]);\r\n\r\n    add(check[F_STOP]);\r\n    add(Box.createVerticalStrut(4));\r\n    final BaseXBack b3 = new BaseXBack(new TableLayout(1, 2, 8, 0));\r\n    swpath = new BaseXTextField(sw.isEmpty() ?\r\n        d.gui.gprop.get(GUIProp.STOPPATH) : sw, d);\r\n    b3.add(swpath);\r\n\r\n    swbrowse = new BaseXButton(BROWSE_D, d);\r\n    swbrowse.addActionListener(new ActionListener() {\r\n      @Override\r\n      public void actionPerformed(final ActionEvent e) {\r\n        chooseStop();\r\n      }\r\n    });\r\n    b3.add(swbrowse);\r\n    add(b3);\r\n    if(!create) add(labels[F_STOP]);\r\n  }","commit_id":"abce6747ee15fe8eeea66f55263bbdb76cfb4be5","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Opens a file dialog to choose an XML catalog or directory.\n   */\n  void choose() {\n    final IOFile in = inputFile();\n    if(in == null) return;\n    final String path = in.path();\n    input.setText(path);\n    dbname = in.dbname();\n\n    final int i = path.lastIndexOf('.');\n    if(i == -1) return;\n    final String suf = path.substring(i).toLowerCase(Locale.ENGLISH);\n\n    String type = null;\n    if(Token.eq(suf, IO.XMLSUFFIX)) type = DataText.M_XML;\n    if(Token.eq(suf, IO.HTMLSUFFIXES)) type = DataText.M_HTML;\n    if(Token.eq(suf, IO.CSVSUFFIX)) type = DataText.M_CSV;\n    if(Token.eq(suf, IO.TXTSUFFIX)) type = DataText.M_TEXT;\n    if(Token.eq(suf, IO.JSONSUFFIX)) type = DataText.M_JSON;\n\n    if(type != null) {\n      parser.setSelectedItem(type.toUpperCase(Locale.ENGLISH));\n      parsing.updateType(type);\n      filter.setText(\"*.\" + type);\n    }\n  }","id":33038,"modified_method":"/**\n   * Opens a file dialog to choose an input file or directory,\n   * and updates the panel.\n   */\n  void choose() {\n    // get user input (may be canceled)\n    final IOFile in = inputFile();\n    if(in == null) return;\n    input.setText(in.path());\n    setType(in.path());\n  }","commit_id":"abce6747ee15fe8eeea66f55263bbdb76cfb4be5","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns the parsing type.\n   * @return type\n   */\n  private String parser() {\n    return parser.getSelectedItem().toString().toLowerCase(Locale.ENGLISH);\n  }","id":33039,"modified_method":"/**\n   * Returns the parsing type.\n   * @return type\n   */\n  String parser() {\n    return parser.getSelectedItem().toString().toLowerCase(Locale.ENGLISH);\n  }","commit_id":"abce6747ee15fe8eeea66f55263bbdb76cfb4be5","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor.\n   * @param dialog dialog reference\n   * @param panel feature panel\n   * @param parse parsing dialog\n   */\n  public DialogImport(final Dialog dialog, final BaseXBack panel,\n      final DialogParsing parse) {\n\n    gui = dialog.gui;\n    parsing = parse;\n\n    layout(new TableLayout(8, 1));\n    border(8);\n\n    // add options\n    add(new BaseXLabel(FILE_OR_DIR + COL, true, true).border(0, 0, 6, 0));\n\n    input = new BaseXTextField(gui.gprop.get(GUIProp.CREATEPATH), dialog);\n    input.addKeyListener(dialog.keys);\n    browse = new BaseXButton(BROWSE_D, dialog);\n    browse.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(final ActionEvent e) { choose(); }\n    });\n    final BaseXBack b = new BaseXBack(new TableLayout(1, 2, 8, 0));\n    b.add(input);\n    b.add(browse);\n    add(b);\n\n    final Prop prop = gui.context.prop;\n    skip = new BaseXCheckBox(SKIP_CORRUPT_FILES,\n        prop.is(Prop.SKIPCORRUPT), dialog);\n    add(skip);\n\n    archives = new BaseXCheckBox(PARSE_ARCHIVES, prop.is(Prop.ADDARCHIVES),\n        dialog);\n    add(archives);\n\n    final StringList parsers = new StringList(PARSING.length);\n    final String type = prop.get(Prop.PARSER);\n    for(final String p : PARSING) parsers.add(p.toUpperCase(Locale.ENGLISH));\n    parser = new BaseXCombo(dialog, parsers.toArray());\n    parser.setSelectedItem(type.toUpperCase(Locale.ENGLISH));\n\n    filter = new BaseXTextField(prop.get(Prop.CREATEFILTER), dialog);\n    BaseXLayout.setWidth(filter, 200);\n    raw = new BaseXCheckBox(ADD_RAW_FILES, prop.is(Prop.ADDRAW), dialog);\n    raw.setBorder(new EmptyBorder(12, 0, 0, 0));\n\n    // add additional options\n    add(panel);\n\n    final BaseXBack p = new BaseXBack(new TableLayout(2, 2, 16, 0));\n    p.add(new BaseXLabel(INPUT_FORMAT, false, true).border(12, 0, 6, 0));\n    p.add(new BaseXLabel(FILE_PATTERNS + COL, false, true).border(12, 0, 6, 0));\n    p.add(parser);\n    p.add(filter);\n    add(p);\n    add(raw);\n\n    // add info label\n    info = new BaseXLabel(\" \").border(24, 0, 6, 0);\n\n    parsing.updateType(parser());\n    add(info);\n  }","id":33040,"modified_method":"/**\n   * Constructor.\n   * @param dial dialog reference\n   * @param panel feature panel\n   * @param parse parsing dialog\n   */\n  public DialogImport(final Dialog dial, final BaseXBack panel,\n      final DialogParsing parse) {\n\n    gui = dial.gui;\n    parsing = parse;\n\n    layout(new TableLayout(10, 1));\n    border(8);\n\n    // add options\n    add(new BaseXLabel(FILE_OR_DIR + COL, true, true).border(0, 0, 6, 0));\n\n    final String in = gui.gprop.get(GUIProp.CREATEPATH);\n    input = new BaseXTextField(gui.gprop.get(GUIProp.CREATEPATH), dial);\n    final IO io = IO.get(in);\n    if(io instanceof IOFile && !in.isEmpty()) dbname = io.dbname();\n\n    input.addKeyListener(dial.keys);\n    browse = new BaseXButton(BROWSE_D, dial);\n    browse.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(final ActionEvent e) { choose(); }\n    });\n    final BaseXBack b = new BaseXBack(new TableLayout(1, 2, 8, 0));\n    b.add(input);\n    b.add(browse);\n    add(b);\n\n    // add additional options\n    add(panel);\n    add(Box.createVerticalStrut(12));\n\n    final Prop prop = gui.context.prop;\n    final StringList parsers = new StringList(PARSING.length);\n    final String type = prop.get(Prop.PARSER);\n    for(final String p : PARSING) parsers.add(p.toUpperCase(Locale.ENGLISH));\n    parser = new BaseXCombo(dial, parsers.toArray());\n    parser.setSelectedItem(type.toUpperCase(Locale.ENGLISH));\n    filter = new BaseXTextField(prop.get(Prop.CREATEFILTER), dial);\n    BaseXLayout.setWidth(filter, 200);\n\n    addRaw = new BaseXCheckBox(ADD_RAW_FILES, prop.is(Prop.ADDRAW), dial);\n    skipCorrupt = new BaseXCheckBox(SKIP_CORRUPT_FILES, prop.is(Prop.SKIPCORRUPT), dial);\n    archives = new BaseXCheckBox(PARSE_ARCHIVES, prop.is(Prop.ADDARCHIVES), dial);\n\n    final BaseXBack p = new BaseXBack(new TableLayout(2, 2, 20, 0));\n    p.add(new BaseXLabel(INPUT_FORMAT, false, true).border(0, 0, 6, 0));\n    p.add(new BaseXLabel(FILE_PATTERNS + COL, false, true).border(0, 0, 6, 0));\n    p.add(parser);\n    p.add(filter);\n    add(p);\n    add(Box.createVerticalStrut(8));\n    add(addRaw);\n    add(skipCorrupt);\n    add(archives);\n\n    // add info label\n    info = new BaseXLabel(\" \").border(24, 0, 6, 0);\n    add(info);\n  }","commit_id":"abce6747ee15fe8eeea66f55263bbdb76cfb4be5","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Sets the parsing options.\n   */\n  public void setOptions() {\n    final String type = parser();\n    gui.set(Prop.PARSER, type);\n    gui.set(Prop.CREATEFILTER, filter.getText());\n    gui.set(Prop.ADDARCHIVES, archives.isSelected());\n    gui.set(Prop.SKIPCORRUPT, skip.isSelected());\n    gui.set(Prop.ADDRAW, raw.isSelected());\n    parsing.setOptions(type);\n  }","id":33041,"modified_method":"/**\n   * Sets the parsing options.\n   */\n  void setOptions() {\n    final String type = parser();\n    gui.set(Prop.PARSER, type);\n    gui.set(Prop.CREATEFILTER, filter.getText());\n    gui.set(Prop.ADDARCHIVES, archives.isSelected());\n    gui.set(Prop.SKIPCORRUPT, skipCorrupt.isSelected());\n    gui.set(Prop.ADDRAW, addRaw.isSelected());\n    parsing.setOptions(type);\n  }","commit_id":"abce6747ee15fe8eeea66f55263bbdb76cfb4be5","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Updates the dialog window.\n   * @param comp component\n   * @param empty allow empty input\n   * @return success flag, or {@code false} if specified input is not found\n   */\n  boolean action(final Object comp, final boolean empty) {\n    parsing.action();\n    if(comp == parser) {\n      final String type = parser();\n      parsing.updateType(type);\n      filter.setText(\"*.\" + type);\n    }\n\n    final String in = input.getText().trim();\n    final IO io = IO.get(in);\n    gui.gprop.set(GUIProp.CREATEPATH, in);\n\n    info.setText(null, null);\n    final boolean ok = empty ? in.isEmpty() || io.exists() :\n      !in.isEmpty() && io.exists();\n    final boolean dir = ok && io.isDir();\n    filter.setEnabled(dir);\n    raw.setEnabled(dir && !gui.context.prop.is(Prop.MAINMEM));\n    return ok;\n  }","id":33042,"modified_method":"/**\n   * Updates the dialog window.\n   * @param comp component\n   * @param empty allow empty input\n   * @return success flag, or {@code false} if specified input is not found\n   */\n  boolean action(final Object comp, final boolean empty) {\n    parsing.action();\n\n    final String in = input.getText().trim();\n    final IO io = IO.get(in);\n    gui.gprop.set(GUIProp.CREATEPATH, in);\n    final boolean dir = io.isDir();\n\n    final String type = parser();\n    final boolean r = type.equals(DataText.M_RAW);\n    if(comp == parser) {\n      parsing.updateType(type);\n      if(dir) filter.setText(r ? \"*\" : \"*.\" + type);\n    }\n\n    if(comp == input) setType(in);\n\n    info.setText(null, null);\n    final boolean ok = empty ? in.isEmpty() || io.exists() :\n      !in.isEmpty() && io.exists();\n\n    filter.setEnabled(dir && ok);\n    addRaw.setEnabled(dir && !r && !gui.context.prop.is(Prop.MAINMEM));\n    skipCorrupt.setEnabled(!r);\n    return ok;\n  }","commit_id":"abce6747ee15fe8eeea66f55263bbdb76cfb4be5","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns an XML file chosen by the user.\n   * @return file chooser\n   */\n  IOFile inputFile() {\n    final BaseXFileChooser fc = new BaseXFileChooser(FILE_OR_DIR,\n        gui.gprop.get(GUIProp.CREATEPATH), gui);\n    fc.addFilter(XML_DOCUMENTS, IO.XMLSUFFIX);\n    fc.addFilter(JSON_DOCUMENTS, IO.JSONSUFFIX);\n    fc.addFilter(HTML_DOCUMENTS, IO.HTMLSUFFIXES);\n    fc.addFilter(CSV_DOCUMENTS, IO.CSVSUFFIX);\n    fc.addFilter(PLAIN_TEXT, IO.TXTSUFFIX);\n    fc.addFilter(GZIP_ARCHIVES, IO.GZSUFFIX);\n    fc.addFilter(ZIP_ARCHIVES, IO.ZIPSUFFIXES);\n    final IOFile file = fc.select(Mode.FDOPEN);\n    if(file != null) gui.gprop.set(GUIProp.CREATEPATH, file.path());\n    return file;\n  }","id":33043,"modified_method":"/**\n   * Returns an XML file chosen by the user.\n   * @return file chooser\n   */\n  IOFile inputFile() {\n    final String path = gui.gprop.get(GUIProp.CREATEPATH);\n    final BaseXFileChooser fc = new BaseXFileChooser(FILE_OR_DIR, path, gui);\n    fc.addFilter(XML_DOCUMENTS, IO.XMLSUFFIXES);\n    fc.addFilter(HTML_DOCUMENTS, IO.HTMLSUFFIXES);\n    fc.addFilter(JSON_DOCUMENTS, IO.JSONSUFFIX);\n    fc.addFilter(CSV_DOCUMENTS, IO.CSVSUFFIX);\n    fc.addFilter(PLAIN_TEXT, IO.TXTSUFFIXES);\n    fc.addFilter(ZIP_ARCHIVES, IO.ZIPSUFFIXES);\n    final IOFile file = fc.select(Mode.FDOPEN);\n    if(file != null) gui.gprop.set(GUIProp.CREATEPATH, file.path());\n    return file;\n  }","commit_id":"abce6747ee15fe8eeea66f55263bbdb76cfb4be5","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Default constructor.\r\n   * @param main reference to the main window\r\n   */\r\n  public DialogNew(final GUI main) {\r\n    super(main, CREATE_DATABASE);\r\n\r\n    // define buttons first to assign simplest mnemonics\r\n    buttons = okCancel();\r\n\r\n    db = List.list(main.context);\r\n    final Prop prop = gui.context.prop;\r\n    final GUIProp gprop = main.gprop;\r\n\r\n    target = new BaseXTextField(gprop.get(GUIProp.CREATENAME), this);\r\n    target.addKeyListener(keys);\r\n\r\n    final BaseXBack pnl = new BaseXBack(new TableLayout(2, 1));\r\n    pnl.add(new BaseXLabel(NAME_OF_DB + COLS, false, true).border(12, 0, 6, 0));\r\n    pnl.add(target);\r\n\r\n    // option panels\r\n    final DialogParsing parsing = new DialogParsing(this);\r\n    general = new DialogImport(this, pnl, parsing);\r\n\r\n    // index panel\r\n    final BaseXBack indexes =\r\n        new BaseXBack(new TableLayout(6, 1, 0, 0)).border(8);\r\n\r\n    //indexes.add(new BaseXLabel(INDEXES).border(0, 0, 16, 0).large());\r\n\r\n    pathindex = new BaseXCheckBox(PATH_INDEX,\r\n        prop.is(Prop.PATHINDEX), 0, this).large();;\r\n    indexes.add(pathindex);\r\n    indexes.add(new BaseXLabel(H_PATH_INDEX, true, false));\r\n\r\n    txtindex = new BaseXCheckBox(TEXT_INDEX,\r\n        prop.is(Prop.TEXTINDEX), 0, this).large();;\r\n    indexes.add(txtindex);\r\n    indexes.add(new BaseXLabel(H_TEXT_INDEX, true, false));\r\n\r\n    atvindex = new BaseXCheckBox(ATTRIBUTE_INDEX,\r\n        prop.is(Prop.ATTRINDEX), 0, this).large();\r\n    indexes.add(atvindex);\r\n    indexes.add(new BaseXLabel(H_ATTR_INDEX, true, false));\r\n\r\n    // full-text panel\r\n    final BaseXBack fulltext =\r\n        new BaseXBack(new TableLayout(2, 1, 0, 0)).border(8);\r\n    ftxindex = new BaseXCheckBox(FULLTEXT_INDEX,\r\n        prop.is(Prop.FTINDEX), 0, this).large();\r\n    fulltext.add(ftxindex);\r\n\r\n    ft = new DialogFT(this, true);\r\n    fulltext.add(ft);\r\n\r\n    final BaseXTabs tabs = new BaseXTabs(this);\r\n    tabs.addTab(GENERAL, general);\r\n    tabs.addTab(PARSING, parsing);\r\n    tabs.addTab(INDEXES, indexes);\r\n    tabs.addTab(FULLTEXT, fulltext);\r\n    set(tabs, BorderLayout.CENTER);\r\n\r\n    set(buttons, BorderLayout.SOUTH);\r\n\r\n    action(null);\r\n    finish(null);\r\n  }","id":33044,"modified_method":"/**\r\n   * Default constructor.\r\n   * @param main reference to the main window\r\n   */\r\n  public DialogNew(final GUI main) {\r\n    super(main, CREATE_DATABASE);\r\n\r\n    // define buttons first to assign simplest mnemonics\r\n    buttons = okCancel();\r\n\r\n    db = List.list(main.context);\r\n    final Prop prop = gui.context.prop;\r\n    final GUIProp gprop = main.gprop;\r\n\r\n    target = new BaseXTextField(gprop.get(GUIProp.CREATENAME), this);\r\n    target.addKeyListener(keys);\r\n\r\n    final BaseXBack pnl = new BaseXBack(new TableLayout(2, 1));\r\n    pnl.add(new BaseXLabel(NAME_OF_DB + COLS, false, true).border(8, 0, 6, 0));\r\n    pnl.add(target);\r\n\r\n    // option panels\r\n    final BaseXTabs tabs = new BaseXTabs(this);\r\n    final DialogParsing parsing = new DialogParsing(this, tabs);\r\n    general = new DialogImport(this, pnl, parsing);\r\n\r\n    // index panel\r\n    final BaseXBack indexes =\r\n        new BaseXBack(new TableLayout(6, 1, 0, 0)).border(8);\r\n\r\n    //indexes.add(new BaseXLabel(INDEXES).border(0, 0, 16, 0).large());\r\n\r\n    pathindex = new BaseXCheckBox(PATH_INDEX,\r\n        prop.is(Prop.PATHINDEX), 0, this).large();;\r\n    indexes.add(pathindex);\r\n    indexes.add(new BaseXLabel(H_PATH_INDEX, true, false));\r\n\r\n    txtindex = new BaseXCheckBox(TEXT_INDEX,\r\n        prop.is(Prop.TEXTINDEX), 0, this).large();;\r\n    indexes.add(txtindex);\r\n    indexes.add(new BaseXLabel(H_TEXT_INDEX, true, false));\r\n\r\n    atvindex = new BaseXCheckBox(ATTRIBUTE_INDEX,\r\n        prop.is(Prop.ATTRINDEX), 0, this).large();\r\n    indexes.add(atvindex);\r\n    indexes.add(new BaseXLabel(H_ATTR_INDEX, true, false));\r\n\r\n    // full-text panel\r\n    final BaseXBack fulltext =\r\n        new BaseXBack(new TableLayout(2, 1, 0, 0)).border(8);\r\n    ftxindex = new BaseXCheckBox(FULLTEXT_INDEX,\r\n        prop.is(Prop.FTINDEX), 0, this).large();\r\n    fulltext.add(ftxindex);\r\n\r\n    ft = new DialogFT(this, true);\r\n    fulltext.add(ft);\r\n\r\n    tabs.addTab(GENERAL, general);\r\n    tabs.addTab(PARSING, parsing);\r\n    tabs.addTab(INDEXES, indexes);\r\n    tabs.addTab(FULLTEXT, fulltext);\r\n    set(tabs, BorderLayout.CENTER);\r\n\r\n    set(buttons, BorderLayout.SOUTH);\r\n\r\n    action(general.parser);\r\n    finish(null);\r\n  }","commit_id":"abce6747ee15fe8eeea66f55263bbdb76cfb4be5","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public void action(final Object cmp) {\r\n    final boolean valid = general.action(cmp, true);\r\n    ft.action();\r\n\r\n    // ...must be located before remaining checks\r\n    if(cmp == general.browse) target.setText(general.dbname);\r\n\r\n    final String nm = target.getText().trim();\r\n    ok = valid && !nm.isEmpty();\r\n\r\n    String inf = !valid ? FILE_NOT_FOUND : !ok ? ENTER_DB_NAME : null;\r\n    Msg icon = Msg.ERROR;\r\n    if(ok) {\r\n      ok = MetaData.validName(nm, false);\r\n      if(ok) gui.gprop.set(GUIProp.CREATENAME, nm);\r\n\r\n      if(!ok) {\r\n        // name of database is invalid\r\n        inf = Util.info(INVALID_X, NAME);\r\n      } else if(general.input.getText().trim().isEmpty()) {\r\n        // database will be empty\r\n        inf = EMPTY_DB;\r\n        icon = Msg.WARN;\r\n      } else if(db.contains(nm)) {\r\n        // old database will be overwritten\r\n        inf = OVERWRITE_DB;\r\n        icon = Msg.WARN;\r\n      }\r\n    }\r\n\r\n    general.info.setText(inf, icon);\r\n    enableOK(buttons, B_OK, ok);\r\n  }","id":33045,"modified_method":"@Override\r\n  public void action(final Object comp) {\r\n    final boolean valid = general.action(comp, true);\r\n    ft.action();\r\n\r\n    // ...must be located before remaining checks\r\n    if(comp == general.browse || comp == general.input)\r\n      target.setText(general.dbname);\r\n\r\n    final String nm = target.getText().trim();\r\n    ok = valid && !nm.isEmpty();\r\n\r\n    String inf = !valid ? FILE_NOT_FOUND : !ok ? ENTER_DB_NAME : null;\r\n    Msg icon = Msg.ERROR;\r\n    if(ok) {\r\n      ok = MetaData.validName(nm, false);\r\n      if(ok) gui.gprop.set(GUIProp.CREATENAME, nm);\r\n\r\n      if(!ok) {\r\n        // name of database is invalid\r\n        inf = Util.info(INVALID_X, NAME);\r\n      } else if(general.input.getText().trim().isEmpty()) {\r\n        // database will be empty\r\n        inf = EMPTY_DB;\r\n        icon = Msg.WARN;\r\n      } else if(db.contains(nm)) {\r\n        // old database will be overwritten\r\n        inf = OVERWRITE_DB;\r\n        icon = Msg.WARN;\r\n      }\r\n    }\r\n\r\n    general.info.setText(inf, icon);\r\n    enableOK(buttons, B_OK, ok);\r\n  }","commit_id":"abce6747ee15fe8eeea66f55263bbdb76cfb4be5","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Default constructor.\n   * @param d dialog reference\n   */\n  public DialogParsing(final Dialog d) {\n    main = new BaseXBack(new TableLayout(2, 1)).border(8);\n    gui = d.gui;\n\n    label = new BaseXLabel(\" \").border(0, 0, 12, 0).large();\n\n    final Prop prop = gui.context.prop;\n    try {\n      props = new ParserProp(prop.get(Prop.PARSEROPT));\n    } catch(final IOException ex) {\n      props = new ParserProp();\n    }\n\n    intparse = new BaseXCheckBox(INT_PARSER, prop.is(Prop.INTPARSE), 0, d);\n    dtd = new BaseXCheckBox(PARSE_DTDS, prop.is(Prop.DTD), 0, d);\n    chop = new BaseXCheckBox(CHOP_WS, prop.is(Prop.CHOP), 0, d);\n    cfile = new BaseXTextField(prop.get(Prop.CATFILE), d);\n    browsec = new BaseXButton(BROWSE_D, d);\n    usecat = new BaseXCheckBox(USE_CATALOG_FILE,\n      !prop.get(Prop.CATFILE).isEmpty(), 0, d);\n\n    jsonml = new BaseXCheckBox(PARSE_AS_JSONML,\n      props.is(ParserProp.JSONML), 0, d);\n\n    lines = new BaseXCheckBox(SPLIT_INPUT_LINES,\n      props.is(ParserProp.LINES), 0, d);\n    header = new BaseXCheckBox(FIRST_LINE_HEADER,\n      props.is(ParserProp.HEADER), 0, d);\n    separator = new BaseXCombo(d, CSVParser.SEPARATORS);\n    separator.setSelectedItem(props.get(ParserProp.SEPARATOR));\n    format = new BaseXCombo(d, CSVParser.FORMATS);\n    format.setSelectedItem(props.get(ParserProp.FORMAT));\n\n    final String enc = props.get(ParserProp.ENCODING);\n    cencoding = DialogExport.encoding(d, enc);\n    tencoding = DialogExport.encoding(d, enc);\n    jencoding = DialogExport.encoding(d, enc);\n\n    xmlopts  = new BaseXBack(new TableLayout(8, 1));\n    htmlopts = new BaseXBack(new TableLayout(1, 1));\n    jsonopts = new BaseXBack(new TableLayout(2, 1));\n    csvopts  = new BaseXBack(new TableLayout(2, 1));\n    textopts = new BaseXBack(new TableLayout(2, 1));\n    createOptionsPanels();\n\n    setLayout(new TableLayout(1, 1));\n    add(main);\n  }","id":33046,"modified_method":"/**\n   * Default constructor.\n   * @param d dialog reference\n   * @param t tabs\n   */\n  public DialogParsing(final Dialog d, final BaseXTabs t) {\n    main = new BaseXBack(new TableLayout(2, 1)).border(8);\n    gui = d.gui;\n    tabs = t;\n\n    label = new BaseXLabel(\" \").border(0, 0, 12, 0).large();\n\n    final Prop prop = gui.context.prop;\n    try {\n      props = new ParserProp(prop.get(Prop.PARSEROPT));\n    } catch(final IOException ex) {\n      props = new ParserProp();\n    }\n\n    intparse = new BaseXCheckBox(INT_PARSER, prop.is(Prop.INTPARSE), 0, d);\n    dtd = new BaseXCheckBox(PARSE_DTDS, prop.is(Prop.DTD), 0, d);\n    chop = new BaseXCheckBox(CHOP_WS, prop.is(Prop.CHOP), 0, d);\n    cfile = new BaseXTextField(prop.get(Prop.CATFILE), d);\n    browsec = new BaseXButton(BROWSE_D, d);\n    usecat = new BaseXCheckBox(USE_CATALOG_FILE,\n      !prop.get(Prop.CATFILE).isEmpty(), 0, d);\n\n    jsonml = new BaseXCheckBox(PARSE_AS_JSONML,\n      props.is(ParserProp.JSONML), 0, d);\n\n    lines = new BaseXCheckBox(SPLIT_INPUT_LINES,\n      props.is(ParserProp.LINES), 0, d);\n    header = new BaseXCheckBox(FIRST_LINE_HEADER,\n      props.is(ParserProp.HEADER), 0, d);\n    separator = new BaseXCombo(d, CSVParser.SEPARATORS);\n    separator.setSelectedItem(props.get(ParserProp.SEPARATOR));\n    format = new BaseXCombo(d, CSVParser.FORMATS);\n    format.setSelectedItem(props.get(ParserProp.FORMAT));\n\n    final String enc = props.get(ParserProp.ENCODING);\n    cencoding = DialogExport.encoding(d, enc);\n    tencoding = DialogExport.encoding(d, enc);\n    jencoding = DialogExport.encoding(d, enc);\n\n    xmlopts  = new BaseXBack(new TableLayout(8, 1));\n    htmlopts = new BaseXBack(new TableLayout(1, 1));\n    jsonopts = new BaseXBack(new TableLayout(2, 1));\n    csvopts  = new BaseXBack(new TableLayout(2, 1));\n    textopts = new BaseXBack(new TableLayout(2, 1));\n    createOptionsPanels();\n\n    setLayout(new TableLayout(1, 1));\n    add(main);\n  }","commit_id":"abce6747ee15fe8eeea66f55263bbdb76cfb4be5","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Updates the options, depending on the specific type.\n   * @param type parsing type\n   */\n  void updateType(final String type) {\n    label.setText(type.toUpperCase(Locale.ENGLISH) + \" Parser\");\n\n    if(type.equals(DataText.M_XML)) {\n      parseropts = xmlopts;\n    } else if(type.equals(DataText.M_HTML)) {\n      parseropts = htmlopts;\n    } else if(type.equals(DataText.M_JSON)) {\n      parseropts = jsonopts;\n    } else if(type.equals(DataText.M_CSV)) {\n      parseropts = csvopts;\n    } else if(type.equals(DataText.M_TEXT)) {\n      parseropts = textopts;\n    }\n\n    main.removeAll();\n    main.add(label);\n    main.add(parseropts);\n    main.revalidate();\n  }","id":33047,"modified_method":"/**\n   * Updates the options, depending on the specific type.\n   * @param type parsing type\n   */\n  void updateType(final String type) {\n    label.setText(type.toUpperCase(Locale.ENGLISH) + \" Parser\");\n\n    if(type.equals(DataText.M_XML)) {\n      parseropts = xmlopts;\n    } else if(type.equals(DataText.M_HTML)) {\n      parseropts = htmlopts;\n    } else if(type.equals(DataText.M_JSON)) {\n      parseropts = jsonopts;\n    } else if(type.equals(DataText.M_CSV)) {\n      parseropts = csvopts;\n    } else if(type.equals(DataText.M_TEXT)) {\n      parseropts = textopts;\n    }\n\n    main.removeAll();\n    main.add(label);\n    if(parseropts != null) main.add(parseropts);\n    main.revalidate();\n    tabs.setEnabledAt(1, !type.equals(DataText.M_RAW));\n  }","commit_id":"abce6747ee15fe8eeea66f55263bbdb76cfb4be5","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Default constructor.\r\n   * @param main reference to the main window\r\n   */\r\n  public DialogProps(final GUI main) {\r\n    super(main, DB_PROPS);\r\n    panel.setLayout(new BorderLayout(5, 0));\r\n\r\n    // resource tree\r\n    resources = new DialogResources(this);\r\n\r\n    // tab: database info\r\n    final Data data = gui.context.data();\r\n    final BaseXBack tabInfo = new BaseXBack(new BorderLayout(0, 8)).border(8);\r\n    final Font f = tabInfo.getFont();\r\n    final BaseXLabel doc = new BaseXLabel(data.meta.name).border(\r\n        0, 0, 6, 0).large();\r\n    BaseXLayout.setWidth(doc, 400);\r\n    tabInfo.add(doc, BorderLayout.NORTH);\r\n\r\n    final String db = InfoDB.db(data.meta, true, false, true);\r\n    final TokenBuilder info = new TokenBuilder(db);\r\n    if(data.nspaces.size() != 0) {\r\n      info.bold().add(NL + NAMESPACES + NL).norm().add(data.nspaces.info());\r\n    }\r\n\r\n    final BaseXEditor text = text(info.finish());\r\n    text.setFont(f);\r\n    tabInfo.add(text, BorderLayout.CENTER);\r\n\r\n    // tab: resources\r\n    add = new DialogAdd(this);\r\n    ft = new DialogFT(this, false);\r\n    final BaseXBack tabRes = add.border(8);\r\n\r\n    for(int i = 0; i < LABELS.length; ++i) {\r\n      String lbl = LABELS[i];\r\n      if(!data.meta.uptodate) lbl += \" (\" + OUT_OF_DATE + ')';\r\n      labels[i] = new BaseXLabel(lbl).large();\r\n      panels[i] = new BaseXBack(new BorderLayout(0, 4));\r\n      infos[i] = new BaseXEditor(false, this);\r\n      BaseXLayout.setHeight(infos[i], 200);\r\n      if(i >= 2) {\r\n        indxs[i] = new BaseXButton(\"\", this);\r\n        indxs[i].setEnabled(data instanceof DiskData);\r\n      }\r\n    }\r\n\r\n    // tab: name indexes\r\n    final BaseXBack tabNames =\r\n        new BaseXBack(new GridLayout(2, 1, 0, 8)).border(8);\r\n    add(0, tabNames, null);\r\n    add(1, tabNames, null);\r\n\r\n    // tab: path index\r\n    final BaseXBack tabPath = new BaseXBack(new GridLayout(1, 1)).border(8);\r\n    add(2, tabPath, null);\r\n\r\n    // tab: value indexes\r\n    final BaseXBack tabValues =\r\n        new BaseXBack(new GridLayout(2, 1, 0, 8)).border(8);\r\n    add(3, tabValues, null);\r\n    add(4, tabValues, null);\r\n\r\n    // tab: full-text index\r\n    tabFT = new BaseXBack(new GridLayout(1, 1)).border(8);\r\n    add(5, tabFT, null);\r\n\r\n    final BaseXTabs tabs = new BaseXTabs(this);\r\n    tabs.addTab(GENERAL, tabInfo);\r\n    tabs.addTab(RESOURCES, tabRes);\r\n    tabs.addTab(NAMES, tabNames);\r\n    tabs.addTab(PATH_INDEX, tabPath);\r\n    tabs.addTab(INDEXES, tabValues);\r\n    tabs.addTab(FULLTEXT, tabFT);\r\n\r\n    set(resources, BorderLayout.WEST);\r\n    set(tabs, BorderLayout.CENTER);\r\n\r\n    action(this);\r\n    setResizable(true);\r\n    setMinimumSize(getPreferredSize());\r\n    finish(null);\r\n  }","id":33048,"modified_method":"/**\r\n   * Default constructor.\r\n   * @param main reference to the main window\r\n   */\r\n  public DialogProps(final GUI main) {\r\n    super(main, DB_PROPS);\r\n    panel.setLayout(new BorderLayout(5, 0));\r\n\r\n    // resource tree\r\n    resources = new DialogResources(this);\r\n\r\n    // tab: resources\r\n    add = new DialogAdd(this);\r\n    ft = new DialogFT(this, false);\r\n    final BaseXBack tabRes = add.border(8);\r\n\r\n    final Data data = gui.context.data();\r\n    for(int i = 0; i < LABELS.length; ++i) {\r\n      String lbl = LABELS[i];\r\n      if(!data.meta.uptodate) lbl += \" (\" + OUT_OF_DATE + ')';\r\n      labels[i] = new BaseXLabel(lbl).large();\r\n      panels[i] = new BaseXBack(new BorderLayout(0, 4));\r\n      infos[i] = new BaseXEditor(false, this);\r\n      BaseXLayout.setHeight(infos[i], 200);\r\n      if(i >= 2) {\r\n        indxs[i] = new BaseXButton(\"\", this);\r\n        indxs[i].setEnabled(data instanceof DiskData);\r\n      }\r\n    }\r\n\r\n    // tab: database info\r\n    final BaseXBack tabInfo = new BaseXBack(new BorderLayout(0, 8)).border(8);\r\n    final Font f = tabInfo.getFont();\r\n    final BaseXLabel doc = new BaseXLabel(data.meta.name).border(\r\n        0, 0, 6, 0).large();\r\n    BaseXLayout.setWidth(doc, 400);\r\n    tabInfo.add(doc, BorderLayout.NORTH);\r\n\r\n    final String db = InfoDB.db(data.meta, true, false, true);\r\n    final TokenBuilder info = new TokenBuilder(db);\r\n    if(data.nspaces.size() != 0) {\r\n      info.bold().add(NL + NAMESPACES + NL).norm().add(data.nspaces.info());\r\n    }\r\n\r\n    final BaseXEditor text = text(info.finish());\r\n    text.setFont(f);\r\n    tabInfo.add(text, BorderLayout.CENTER);\r\n\r\n    // tab: name indexes\r\n    final BaseXBack tabNames =\r\n        new BaseXBack(new GridLayout(2, 1, 0, 8)).border(8);\r\n    add(0, tabNames, null);\r\n    add(1, tabNames, null);\r\n\r\n    // tab: path index\r\n    final BaseXBack tabPath = new BaseXBack(new GridLayout(1, 1)).border(8);\r\n    add(2, tabPath, null);\r\n\r\n    // tab: value indexes\r\n    final BaseXBack tabValues =\r\n        new BaseXBack(new GridLayout(2, 1, 0, 8)).border(8);\r\n    add(3, tabValues, null);\r\n    add(4, tabValues, null);\r\n\r\n    // tab: full-text index\r\n    tabFT = new BaseXBack(new GridLayout(1, 1)).border(8);\r\n    add(5, tabFT, null);\r\n\r\n    final BaseXTabs tabs = new BaseXTabs(this);\r\n    tabs.addTab(RESOURCES, tabRes);\r\n    tabs.addTab(INFORMATION, tabInfo);\r\n    tabs.addTab(NAMES, tabNames);\r\n    tabs.addTab(PATH_INDEX, tabPath);\r\n    tabs.addTab(INDEXES, tabValues);\r\n    tabs.addTab(FULLTEXT, tabFT);\r\n\r\n    set(resources, BorderLayout.WEST);\r\n    set(tabs, BorderLayout.CENTER);\r\n\r\n    action(this);\r\n    setResizable(true);\r\n    setMinimumSize(getPreferredSize());\r\n    finish(null);\r\n  }","commit_id":"abce6747ee15fe8eeea66f55263bbdb76cfb4be5","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Parses the specified file or its children.\n   * @param b builder\n   * @param io current input\n   * @throws IOException I/O exception\n   */\n  private void parse(final Builder b, final IO io) throws IOException {\n    if(io.isDir()) {\n      // only {@link IOFile} instances can have children\n      for(final IO f : ((IOFile) io).children()) parse(b, f);\n    } else {\n      src = io;\n\n      while(io.more(archives)) {\n        b.checkStop();\n\n        String nm = io.name();\n        if(Prop.WIN) nm = nm.toLowerCase(Locale.ENGLISH);\n\n        final long l = src.length();\n        if(l != -1) b.meta.filesize += l;\n\n        // use global target as prefix\n        String targ = trg;\n        final String name = src.name();\n        String path = src.path();\n\n        // add relative path without root (prefix) and file name (suffix)\n        if(path.endsWith('/' + name)) {\n          path = path.substring(0, path.length() - name.length());\n          if(path.startsWith(root)) path = path.substring(root.length());\n          targ = (targ + path).replace(\"//\", \"/\");\n        }\n\n        if(filter != null && !filter.matcher(nm).matches()) {\n          // store binary files\n          if(binaries != null) {\n            Store.store(src.inputSource(), new IOFile(binaries, targ + name));\n          }\n        } else {\n          boolean ok = true;\n          IO in = io;\n          if(skip) {\n            // parse file twice to ensure that it is well-formed\n            try {\n              // cache file contents to allow or speed up a second run\n              in = new IOContent(io.read());\n              in.name(io.name());\n              parser = Parser.fileParser(in, prop, targ);\n              MemBuilder.build(\"\", parser, prop);\n            } catch(final IOException ex) {\n              Util.debug(ex.getMessage());\n              skipped.add(io.path());\n              ok = false;\n            }\n          }\n\n          if(ok) {\n            parser = Parser.fileParser(in, prop, targ);\n            parser.parse(b);\n          }\n          parser = null;\n          if(Util.debug && (++c & 0x3FF) == 0) Util.err(\";\");\n        }\n      }\n    }\n  }","id":33049,"modified_method":"/**\n   * Parses the specified file or its children.\n   * @param b builder\n   * @param io current input\n   * @throws IOException I/O exception\n   */\n  private void parse(final Builder b, final IO io) throws IOException {\n    if(io.isDir()) {\n      // only {@link IOFile} instances can have children\n      for(final IO f : ((IOFile) io).children()) parse(b, f);\n    } else {\n      src = io;\n\n      // loop through all (potentially zipped) files\n      while(io.more(archives)) {\n        b.checkStop();\n\n        // add file size for database meta information\n        final long l = io.length();\n        if(l != -1) b.meta.filesize += l;\n\n        // use global target as path prefix\n        String targ = trg;\n        String path = io.path();\n\n        // add relative path without root (prefix) and file name (suffix)\n        final String name = io.name();\n        if(path.endsWith('/' + name)) {\n          path = path.substring(0, path.length() - name.length());\n          if(path.startsWith(root)) path = path.substring(root.length());\n          targ = (targ + path).replace(\"//\", \"/\");\n        }\n\n        // check if file passes the name filter pattern\n        boolean exclude = false;\n        if(filter != null) {\n          String nm = io.name();\n          if(Prop.WIN) nm = name.toLowerCase(Locale.ENGLISH);\n          exclude = !filter.matcher(nm).matches();\n        }\n\n        if(exclude) {\n          // exclude file: check if will be added as raw file\n          if(addRaw && rawPath != null) {\n            Store.store(io.inputSource(), new IOFile(rawPath, targ + name));\n          }\n        } else {\n          if(rawParser) {\n            // store input in raw format if database path is known\n            if(rawPath != null) {\n              Store.store(io.inputSource(), new IOFile(rawPath, targ + name));\n            }\n          } else {\n            // store input as XML\n            boolean ok = true;\n            IO in = io;\n            if(skipCorrupt) {\n              // parse file twice to ensure that it is well-formed\n              try {\n                // cache file contents to allow or speed up a second run\n                in = new IOContent(io.read());\n                in.name(io.name());\n                parser = Parser.fileParser(in, prop, targ);\n                MemBuilder.build(\"\", parser, prop);\n              } catch(final IOException ex) {\n                Util.debug(ex.getMessage());\n                skipped.add(io.path());\n                ok = false;\n              }\n            }\n\n            // parse file\n            if(ok) {\n              parser = Parser.fileParser(in, prop, targ);\n              parser.parse(b);\n            }\n            parser = null;\n            // dump debug data\n            if(Util.debug && (++c & 0x3FF) == 0) Util.err(\";\");\n          }\n        }\n      }\n    }\n  }","commit_id":"abce6747ee15fe8eeea66f55263bbdb76cfb4be5","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor, specifying a target path.\n   * @param source source path\n   * @param target target path\n   * @param pr database properties\n   * @param path future database path\n   */\n  public DirParser(final IO source, final String target, final Prop pr,\n      final IOFile path) {\n\n    super(source, target);\n    prop = pr;\n    final String parent = source.dir();\n    root = parent.endsWith(\"/\") ? parent : parent + '/';\n    skip = prop.is(Prop.SKIPCORRUPT);\n    archives = prop.is(Prop.ADDARCHIVES);\n    filter = !source.isDir() && !source.isArchive() ? null :\n      Pattern.compile(IOFile.regex(pr.get(Prop.CREATEFILTER)));\n    binaries = path != null && prop.is(Prop.ADDRAW) ?\n        new IOFile(path, M_RAW) : null;\n  }","id":33050,"modified_method":"/**\n   * Constructor, specifying a target path.\n   * @param source source path\n   * @param target target path\n   * @param pr database properties\n   * @param path future database path\n   */\n  public DirParser(final IO source, final String target, final Prop pr,\n      final IOFile path) {\n\n    super(source, target);\n    prop = pr;\n    final String parent = source.dir();\n    root = parent.endsWith(\"/\") ? parent : parent + '/';\n    skipCorrupt = prop.is(Prop.SKIPCORRUPT);\n    archives = prop.is(Prop.ADDARCHIVES);\n    addRaw = prop.is(Prop.ADDRAW);\n    rawParser = prop.get(Prop.PARSER).toLowerCase(Locale.ENGLISH).\n        equals(DataText.M_RAW);\n\n    filter = !source.isDir() && !source.isArchive() ? null :\n      Pattern.compile(IOFile.regex(pr.get(Prop.CREATEFILTER)));\n    // choose binary storage if (disk-based) database path is known and\n    // if raw parser or \"add raw\" option were chosen\n    rawPath = path != null && (addRaw || rawParser) ?\n        new IOFile(path, M_RAW) : null;\n  }","commit_id":"abce6747ee15fe8eeea66f55263bbdb76cfb4be5","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Returns a file parser instance.\r\n   * @param source document source\r\n   * @param prop database properties\r\n   * @param target relative path reference\r\n   * @return xml parser\r\n   * @throws IOException I/O exception\r\n   */\r\n  static SingleParser fileParser(final IO source, final Prop prop,\r\n      final String target) throws IOException {\r\n\r\n    // use file specific parser\r\n    final String parser = prop.get(Prop.PARSER).toLowerCase(Locale.ENGLISH);\r\n    if(parser.equals(DataText.M_HTML))\r\n      return new HTMLParser(source, target, prop);\r\n    if(parser.equals(DataText.M_TEXT))\r\n      return new TextParser(source, target, prop);\r\n    if(parser.equals(DataText.M_MAB2))\r\n      return new MAB2Parser(source, target, prop);\r\n    if(parser.equals(DataText.M_JSON))\r\n      return new JSONParser(source, target, prop);\r\n    if(parser.equals(DataText.M_CSV))\r\n      return new CSVParser(source, target, prop);\r\n    return xmlParser(source, prop, target);\r\n  }","id":33051,"modified_method":"/**\r\n   * Returns a file parser instance.\r\n   * @param source document source\r\n   * @param prop database properties\r\n   * @param target relative path reference\r\n   * @return xml parser\r\n   * @throws IOException I/O exception\r\n   */\r\n  static SingleParser fileParser(final IO source, final Prop prop,\r\n      final String target) throws IOException {\r\n\r\n    // use file specific parser\r\n    final String parser = prop.get(Prop.PARSER).toLowerCase(Locale.ENGLISH);\r\n    if(parser.equals(DataText.M_HTML))\r\n      return new HTMLParser(source, target, prop);\r\n    if(parser.equals(DataText.M_TEXT))\r\n      return new TextParser(source, target, prop);\r\n    if(parser.equals(DataText.M_MAB2))\r\n      return new MAB2Parser(source, target, prop);\r\n    if(parser.equals(DataText.M_JSON))\r\n      return new JSONParser(source, target, prop);\r\n    if(parser.equals(DataText.M_CSV))\r\n      return new CSVParser(source, target, prop);\r\n    if(parser.equals(DataText.M_XML))\r\n      return xmlParser(source, prop, target);\r\n    throw new BuildException(UNKNOWN_PARSER_X, parser);\r\n  }","commit_id":"abce6747ee15fe8eeea66f55263bbdb76cfb4be5","url":"https://github.com/BaseXdb/basex"},{"original_method":"public RestRequest( URI baseUri, String username, String password ) {\n        this.baseUri = uriWithoutSlash( baseUri );\n        client = DEFAULT_CLIENT;\n        if ( username != null ) client.addFilter( new HTTPBasicAuthFilter( username, password ) );\n\n    }","id":33052,"modified_method":"public RestRequest( URI baseUri, String username, String password ) {\n        this.baseUri = uriWithoutSlash( baseUri );\n        if ( username != null )\n        {\n            client = Client.create();\n            client.addFilter( new HTTPBasicAuthFilter( username, password ) );\n        }\n        else\n        {\n            client = DEFAULT_CLIENT;\n        }\n    }","commit_id":"7efc417bdb57832c3f939300cfc3c509acc394c0","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * from org.apache.solr.client.solrj.embedded.JettySolrRunner\n     */\n    public static Server startServer(String context, int port, EmbeddedSolrConnector c) {\n        //this.context = context;\n        Server server = new Server(port);\n        /*\n         SocketConnector connector = new SocketConnector();\n         connector.setPort(port);\n         connector.setReuseAddress(true);\n         this.server.setConnectors(new Connector[] { connector });\n         this.server.setSessionIdManager(new HashSessionIdManager(new Random()));\n         */\n        ServerConnector connector = new ServerConnector(server);\n        connector.setPort(port);\n\n        server.addConnector(connector);\n        server.setStopAtShutdown(true);\n        ServletContextHandler root = new ServletContextHandler(ServletContextHandler.SESSIONS); //new Context(server, context, Context.SESSIONS);\n        root.addServlet(SolrServlet.Servlet404.class, \"/*\");\n\n        // attach org.apache.solr.response.XMLWriter to search requests\n        SolrServlet.initCore(c);\n        FilterHolder dispatchFilter = root.addFilter(SolrServlet.class, \"*\", EnumSet.of(DispatcherType.REQUEST));\n        //root.addFilter(new FilterHolder(SolrServlet.class), \"/*\", EnumSet.of(DispatcherType.REQUEST));\n        server.setHandler(root);\n        if (!server.isRunning()) {\n            try {\n                server.start();\n                waitForSolr(context, port);\n            } catch (final Exception e) {\n                e.printStackTrace();\n            }\n        }\n        return server;\n    }","id":33053,"modified_method":"/**\n     * from org.apache.solr.client.solrj.embedded.JettySolrRunner\n     */\n    public static Server startServer(String context, int port, EmbeddedSolrConnector c) {\n        Server server = new Server(port);    \n        server.setStopAtShutdown(true);\n        \n        SocketConnector connector = new SocketConnector();\n        connector.setPort(port);\n        connector.setReuseAddress(true);\n        server.setConnectors(new Connector[] { connector });\n        server.setSessionIdManager(new HashSessionIdManager(new Random()));\n        server.setStopAtShutdown(true);\n        \n        ServletContextHandler root = new ServletContextHandler(ServletContextHandler.SESSIONS); //new Context(server, context, Context.SESSIONS);\n        root.setContextPath(context);\n        root.addServlet(SolrServlet.Servlet404.class, \"/*\");\n\n        // attach org.apache.solr.response.XMLWriter to search requests\n        SolrServlet.initCore(c);\n        root.addFilter(new FilterHolder(SolrServlet.class), \"/*\", EnumSet.of(DispatcherType.REQUEST));\n        server.setHandler(root);\n        if (!server.isRunning()) {\n            try {\n                server.start();\n                waitForSolr(context, port);\n            } catch (final Exception e) {\n                e.printStackTrace();\n            }\n        }\n        return server;\n    }","commit_id":"b4fdb8c8874afdcfc81b19461a8800a31bcd1bde","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static void main(String[] args) {\n        File solr_config = new File(\"defaults/solr\");\n        File storage = new File(\"DATA/INDEX/webportal/SEGMENTS/text/solr/\");\n        storage.mkdirs();\n        try {\n            EmbeddedInstance localCollectionInstance = new EmbeddedInstance(solr_config, storage, CollectionSchema.CORE_NAME, new String[]{CollectionSchema.CORE_NAME, WebgraphSchema.CORE_NAME});\n            EmbeddedSolrConnector solr = new EmbeddedSolrConnector(localCollectionInstance);\n            SolrInputDocument doc = new SolrInputDocument();\n            doc.addField(CollectionSchema.id.name(), \"ABCD0000abcd\");\n            doc.addField(CollectionSchema.title.name(), \"Lorem ipsum\");\n            doc.addField(CollectionSchema.host_s.name(), \"yacy.net\");\n            doc.addField(CollectionSchema.text_t.name(), \"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\");\n            solr.add(doc);\n\n            // start a server\n            startServer(\"/solr\", 8091, solr); // try http://localhost:8091/solr/select?q=*:*\n\n            // do a normal query\n            SolrDocumentList select = solr.getDocumentListByQuery(CollectionSchema.text_t.name() + \":tempor\", 0, 10);\n            for (SolrDocument d : select) {\n                System.out.println(\"***TEST SELECT*** \" + d.toString());\n            }\n\n            // do a facet query\n            select = solr.getDocumentListByQuery(CollectionSchema.text_t.name() + \":tempor\", 0, 10);\n            for (SolrDocument d : select) {\n                System.out.println(\"***TEST SELECT*** \" + d.toString());\n            }\n\n\n            // try http://127.0.0.1:8091/solr/select?q=ping\n            try {\n                Thread.sleep(1000 * 1000);\n            } catch (final InterruptedException e) {\n            }\n            solr.close();\n        } catch (final IOException e) {\n            e.printStackTrace();\n        }\n\n    }","id":33054,"modified_method":"public static void main(String[] args) {\n        File solr_config = new File(\"defaults/solr\");\n        File storage = new File(\"DATA/INDEX/webportal/SEGMENTS/text/solr/\");\n        storage.mkdirs();\n        try {\n            EmbeddedInstance localCollectionInstance = new EmbeddedInstance(solr_config, storage, CollectionSchema.CORE_NAME, new String[]{CollectionSchema.CORE_NAME, WebgraphSchema.CORE_NAME});\n            EmbeddedSolrConnector solr = new EmbeddedSolrConnector(localCollectionInstance);\n            SolrInputDocument doc = new SolrInputDocument();\n            doc.addField(CollectionSchema.id.name(), \"ABCD0000abcd\");\n            doc.addField(CollectionSchema.title.name(), \"Lorem ipsum\");\n            doc.addField(CollectionSchema.host_s.name(), \"yacy.net\");\n            doc.addField(CollectionSchema.text_t.name(), \"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\");\n            solr.add(doc);\n            solr.commit(true);\n            // start a server\n            startServer(\"/solr\", 8091, solr); // try http://localhost:8091/solr/select?q=*:*\n\n            // do a normal query\n            SolrDocumentList select = solr.getDocumentListByQuery(CollectionSchema.text_t.name() + \":tempor\", 0, 10);\n            for (SolrDocument d : select) {\n                System.out.println(\"***TEST SELECT*** \" + d.toString());\n            }\n\n            // do a facet query\n            select = solr.getDocumentListByQuery(CollectionSchema.text_t.name() + \":tempor\", 0, 10);\n            for (SolrDocument d : select) {\n                System.out.println(\"***TEST SELECT*** \" + d.toString());\n            }\n\n\n            // try http://127.0.0.1:8091/solr/select?q=ping\n            solr.close();            \n        } catch (final IOException e) {\n            e.printStackTrace();\n        }\n\n    }","commit_id":"b4fdb8c8874afdcfc81b19461a8800a31bcd1bde","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"@Override\n    public void visit(NegativeOp that) {\n        super.visit(that);\n        propagateFromTerm(that, that.getTerm());\n    }","id":33055,"modified_method":"@Override\n    public void visit(NegativeOp that) {\n        super.visit(that);\n        // FIXME: when operator methods support better unboxing than this, reenable this:\n        //propagateFromTerm(that, that.getTerm());\n        if(that.getTerm() instanceof Tree.NaturalLiteral)\n            Util.markUnBoxed(that);\n    }","commit_id":"6a0e60531cb4505262c1dbec631942321833f4dd","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public void visit(PositiveOp that) {\n        super.visit(that);\n        propagateFromTerm(that, that.getTerm());\n    }","id":33056,"modified_method":"@Override\n    public void visit(PositiveOp that) {\n        super.visit(that);\n        // FIXME: when operator methods support better unboxing than this, reenable this:\n        //propagateFromTerm(that, that.getTerm());\n        if(that.getTerm() instanceof Tree.NaturalLiteral)\n            Util.markUnBoxed(that);\n    }","commit_id":"6a0e60531cb4505262c1dbec631942321833f4dd","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public void visit(Tree.DefaultArgument d) {\n        if (annotationConstructor != null) {\n            if (!(d.getSpecifierExpression().getExpression().getTerm() instanceof Tree.Literal)) {\n                error(d, \"Only literal default parameters allowed\");\n            }\n        }\n    }","id":33057,"modified_method":"@Override\n    public void visit(Tree.DefaultArgument d) {\n        if (annotationConstructor != null) {\n            Declaration t = d.getUnit().getLanguageModuleDeclaration(\"true\");\n            Declaration f = d.getUnit().getLanguageModuleDeclaration(\"false\");\n            Term term = d.getSpecifierExpression().getExpression().getTerm();\n            if (!(term instanceof Tree.Literal\n                    || term instanceof Tree.BaseMemberExpression\n                    && (((Tree.BaseMemberExpression)term).getDeclaration().equals(t)\n                        || ((Tree.BaseMemberExpression)term).getDeclaration().equals(f)))) {\n                error(d, \"Only literal default parameters allowed\");\n            }\n        }\n    }","commit_id":"1885dd15386b5ec46662b011f259be995aae7316","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public JCAnnotation transformConstructor(Tree.InvocationExpression invocation) {\n        \n        List<InlineArgument> arguments = annotationConstructor.getInlineInfo().getArguments();\n        java.util.List<Parameter> classParameters = annotationClass.getParameterList().getParameters();\n        for (int classParameterIndex = 0; classParameterIndex < classParameters.size(); classParameterIndex++) {\n            Parameter classParameter = classParameters.get(classParameterIndex);\n            parameterName = classParameter.getName();\n            if (classParameterIndex >= arguments.size()) {\n                // => We're using the annotation class's defaulted parameter\n                continue;\n            }\n            InlineArgument argument = arguments.get(classParameterIndex);\n            \n            if (argument instanceof InlineInfo.ParameterArgument) {\n                InlineInfo.ParameterArgument parameterArgument = (InlineInfo.ParameterArgument)argument;\n                int argumentIndex = ((Functional)parameterArgument.getSourceParameter().getContainer()).getParameterLists().get(0).getParameters().indexOf(parameterArgument.getSourceParameter());\n                if (invocation.getPositionalArgumentList() != null) {\n                    java.util.List<PositionalArgument> pa = invocation.getPositionalArgumentList().getPositionalArguments();\n                    \n                    if (parameterArgument.isSpread()) {\n                        transformSpreadArgument(pa.subList(argumentIndex, pa.size()), classParameter);\n                    } else {\n                        if (0 <= argumentIndex && argumentIndex < pa.size()) {\n                            PositionalArgument pargument = pa.get(argumentIndex);\n                            if (pargument.getParameter().isSequenced()) {\n                                transformVarargs(argumentIndex, pa);\n                            } else {\n                                transformArgument(pargument);\n                            }\n                        } else {\n                            // Use the default parameter from the constructor\n                            append(exprGen.naming.makeQuotedQualIdent(\n                                    exprGen.naming.makeName(annotationConstructor, Naming.NA_FQ | Naming.NA_WRAPPER ),\n                                    parameterName));\n                        }\n                    }\n                } else if (invocation.getNamedArgumentList() != null) {\n                    if (parameterArgument.isSpread()) {\n                        append(exprGen.makeErroneous(invocation, \"Spread argument with named invocation not supported\"));\n                    } else {\n                        boolean found = false;\n                        for (Tree.NamedArgument na : invocation.getNamedArgumentList().getNamedArguments()) {\n                            Parameter parameter = na.getParameter();\n                            int parameterIndex = annotationConstructor.getParameterLists().get(0).getParameters().indexOf(parameter);\n                            if (parameterIndex == argumentIndex) {\n                                transformArgument(na);\n                                found = true;\n                                break;\n                            }\n                        }\n                        if (!found) {\n                            append(exprGen.makeErroneous(invocation, \"Unable to find argument\"));\n                        }    \n                    }\n                }\n            } else if (argument instanceof LiteralArgument) {\n                exprGen.at(invocation);\n                append(exprGen.naming.makeQuotedQualIdent(\n                                exprGen.naming.makeName(annotationConstructor, Naming.NA_FQ | Naming.NA_WRAPPER ),\n                                parameterName));\n            } else {\n                append(exprGen.makeErroneous(invocation, \"Unable to find argument\"));\n            }\n            \n        }\n        JCAnnotation annotation = exprGen.at(invocation).Annotation(exprGen.makeJavaType(annotationClass.getType(), ExpressionTransformer.JT_ANNOTATION), annotationArguments.toList());\n        return annotation;\n    }","id":33058,"modified_method":"public JCAnnotation transformConstructor(Tree.InvocationExpression invocation) {\n        \n        List<InlineArgument> arguments = annotationConstructor.getInlineInfo().getArguments();\n        java.util.List<Parameter> classParameters = annotationClass.getParameterList().getParameters();\n        for (int classParameterIndex = 0; classParameterIndex < classParameters.size(); classParameterIndex++) {\n            Parameter classParameter = classParameters.get(classParameterIndex);\n            parameterName = classParameter.getName();\n            if (classParameterIndex >= arguments.size()) {\n                // => We're using the annotation class's defaulted parameter\n                continue;\n            }\n            InlineArgument argument = arguments.get(classParameterIndex);\n            \n            if (argument instanceof InlineInfo.ParameterArgument) {\n                InlineInfo.ParameterArgument parameterArgument = (InlineInfo.ParameterArgument)argument;\n                int argumentIndex = ((Functional)parameterArgument.getSourceParameter().getContainer()).getParameterLists().get(0).getParameters().indexOf(parameterArgument.getSourceParameter());\n                if (invocation.getPositionalArgumentList() != null) {\n                    java.util.List<PositionalArgument> pa = invocation.getPositionalArgumentList().getPositionalArguments();\n                    \n                    if (parameterArgument.isSpread()) {\n                        transformSpreadArgument(pa.subList(argumentIndex, pa.size()), classParameter);\n                    } else {\n                        if (0 <= argumentIndex && argumentIndex < pa.size()) {\n                            PositionalArgument pargument = pa.get(argumentIndex);\n                            if (pargument.getParameter().isSequenced()) {\n                                transformVarargs(argumentIndex, pa);\n                            } else {\n                                transformArgument(pargument);\n                            }\n                        } else if (parameterArgument.getSourceParameter().isDefaulted()) {\n                            // Use the default parameter from the constructor\n                            appendConstructorDefaultParameter(parameterArgument);\n                        }\n                    }\n                } else if (invocation.getNamedArgumentList() != null) {\n                    if (parameterArgument.isSpread()) {\n                        append(exprGen.makeErroneous(invocation, \"Spread argument with named invocation not supported\"));\n                    } else {\n                        boolean found = false;\n                        for (Tree.NamedArgument na : invocation.getNamedArgumentList().getNamedArguments()) {\n                            Parameter parameter = na.getParameter();\n                            int parameterIndex = annotationConstructor.getParameterLists().get(0).getParameters().indexOf(parameter);\n                            if (parameterIndex == argumentIndex) {\n                                transformArgument(na);\n                                found = true;\n                                break;\n                            }\n                        }\n                        if (!found) {\n                            if (parameterArgument.getSourceParameter().isDefaulted()) {\n                                appendConstructorDefaultParameter(parameterArgument);\n                            } else {\n                                append(exprGen.makeErroneous(invocation, \"Unable to find argument\"));\n                            }\n                        }    \n                    }\n                }\n            } else if (argument instanceof LiteralArgument) {\n                exprGen.at(invocation);\n                append(exprGen.naming.makeQuotedQualIdent(\n                                exprGen.naming.makeName(annotationConstructor, Naming.NA_FQ | Naming.NA_WRAPPER ),\n                                parameterName));\n            } else {\n                append(exprGen.makeErroneous(invocation, \"Unable to find argument\"));\n            }\n            \n        }\n        JCAnnotation annotation = exprGen.at(invocation).Annotation(exprGen.makeJavaType(annotationClass.getType(), ExpressionTransformer.JT_ANNOTATION), annotationArguments.toList());\n        return annotation;\n    }","commit_id":"1885dd15386b5ec46662b011f259be995aae7316","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public void visit(Expression that) {\n        super.visit(that);\n        propagateFromTerm(that, that.getTerm());\n    }","id":33059,"modified_method":"@Override\n    public void visit(Expression that) {\n        super.visit(that);\n        Term term = that.getTerm();\n        propagateFromTerm(that, term);\n        \n        // Special case where a method reference surrounded\n        // by an expression will be turned into a Callable\n        // which will need to be marked boxed\n        if (term instanceof MemberOrTypeExpression) {\n            Tree.MemberOrTypeExpression expr = (Tree.MemberOrTypeExpression)term;\n            if (expr.getDeclaration() instanceof Method) {\n                that.setUnboxed(false);\n            }\n        }\n        \n    }","commit_id":"1c5875049e7d8798fca663328aa41a9cfe5bb2f1","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@NotNull\n    @Override\n    public ChildAttributes getChildAttributes(int newChildIndex) {\n        Indent childIndent = Indent.getNoneIndent();\n        if (CODE_BLOCKS.contains(myNode.getElementType()) || myNode.getElementType() == JetNodeTypes.WHEN) {\n            childIndent = Indent.getNormalIndent();\n        }\n        return new ChildAttributes(childIndent, null);\n    }","id":33060,"modified_method":"@NotNull\n    @Override\n    public ChildAttributes getChildAttributes(int newChildIndex) {\n        final IElementType type = getNode().getElementType();\n        if (CODE_BLOCKS.contains(type) ||\n                type == JetNodeTypes.WHEN ||\n                type == JetNodeTypes.IF ||\n                type == JetNodeTypes.FOR ||\n                type == JetNodeTypes.WHILE ||\n                type == JetNodeTypes.DO_WHILE) {\n\n            return new ChildAttributes(Indent.getNormalIndent(), null);\n        }\n\n        return new ChildAttributes(Indent.getNoneIndent(), null);\n    }","commit_id":"e5f4377ee44871b70dfa972d7f137c1b0419aeb4","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public JetBlock(ASTNode node, Alignment alignment, Indent indent, Wrap wrap, CodeStyleSettings settings,\n                    SpacingBuilder spacingBuilder) {\n        myNode = node;\n        myAlignment = alignment;\n        myIndent = indent;\n        myWrap = wrap;\n        mySettings = settings;\n        mySpacingBuilder = spacingBuilder;\n    }","id":33061,"modified_method":"public JetBlock(@NotNull ASTNode node,\n            Alignment alignment,\n            Indent indent,\n            Wrap wrap,\n            CodeStyleSettings settings,\n            SpacingBuilder spacingBuilder) {\n\n        super(node, wrap, alignment);\n        myIndent = indent;\n        mySettings = settings;\n        mySpacingBuilder = spacingBuilder;\n    }","commit_id":"e5f4377ee44871b70dfa972d7f137c1b0419aeb4","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void parseDoWhile() {\n        assert _at(DO_KEYWORD);\n\n        PsiBuilder.Marker loop = mark();\n\n        advance(); // DO_KEYWORD\n\n        if (!at(WHILE_KEYWORD)) {\n            parseControlStructureBody();\n        }\n\n        expect(WHILE_KEYWORD, \"Expecting 'while' followed by a post-condition\");\n\n        parseCondition();\n\n        loop.done(DO_WHILE);\n    }","id":33062,"modified_method":"private void parseDoWhile() {\n        assert _at(DO_KEYWORD);\n\n        PsiBuilder.Marker loop = mark();\n\n        advance(); // DO_KEYWORD\n\n        if (!at(WHILE_KEYWORD)) {\n            parseControlStructureBody();\n        }\n\n        if (expect(WHILE_KEYWORD, \"Expecting 'while' followed by a post-condition\")) {\n            parseCondition();\n        }\n\n        loop.done(DO_WHILE);\n    }","commit_id":"e5f4377ee44871b70dfa972d7f137c1b0419aeb4","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n  public ChildAttributes getChildAttributes(final int newChildIndex) {\n    ASTNode astNode = getNode();\n    final PsiElement psiParent = astNode.getPsi();\n    if (psiParent instanceof GroovyFileBase) {\n      return new ChildAttributes(Indent.getNoneIndent(), null);\n    }\n    if (psiParent instanceof GrSwitchStatement) {\n      List<Block> subBlocks = getSubBlocks();\n      if (newChildIndex > 0) {\n        Block block = subBlocks.get(newChildIndex - 1);\n        if (block instanceof GroovyBlock) {\n          PsiElement anchorPsi = ((GroovyBlock)block).getNode().getPsi();\n          if (anchorPsi instanceof GrCaseSection) {\n            for (GrStatement statement : ((GrCaseSection)anchorPsi).getStatements()) {\n              if (statement instanceof GrBreakStatement ||\n                  statement instanceof GrContinueStatement ||\n                  statement instanceof GrReturnStatement ||\n                  statement instanceof GrThrowStatement) {\n                return new ChildAttributes(GroovyIndentProcessor.getSwitchCaseIndent(anchorPsi), null);\n              }\n            }\n            @SuppressWarnings(\"ConstantConditions\")\n            int indentSize = mySettings.getIndentOptions().INDENT_SIZE;\n            return new ChildAttributes(Indent.getSpaceIndent(mySettings.INDENT_CASE_FROM_SWITCH ? 2 * indentSize : indentSize), null);\n          }\n        }\n      }\n    }\n\n    if (BLOCK_SET.contains(astNode.getElementType()) || SWITCH_STATEMENT.equals(astNode.getElementType())) {\n      return new ChildAttributes(Indent.getNormalIndent(), null);\n    }\n    if (CASE_SECTION.equals(astNode.getElementType())) {\n      return new ChildAttributes(Indent.getNormalIndent(), null);\n    }\n    if (psiParent instanceof GrBinaryExpression ||\n        psiParent instanceof GrCommandArgumentList ||\n        psiParent instanceof GrArgumentList) {\n      return new ChildAttributes(Indent.getContinuationWithoutFirstIndent(), null);\n    }\n    if (psiParent instanceof GrParameterList) {\n      return new ChildAttributes(getIndent(), getAlignment());\n    }\n    if (psiParent instanceof GrListOrMap) {\n      return new ChildAttributes(Indent.getContinuationIndent(), null);\n    }\n    if (psiParent instanceof GrDocComment || psiParent instanceof GrDocTag) {\n      return new ChildAttributes(Indent.getSpaceIndent(GroovyIndentProcessor.GDOC_COMMENT_INDENT), null);\n    }\n    if (psiParent instanceof GrVariable || psiParent instanceof GrAssignmentExpression) {\n      return new ChildAttributes(Indent.getNormalIndent(), null);\n    }\n    if (psiParent instanceof GrIfStatement || psiParent instanceof GrLoopStatement) {\n      return new ChildAttributes(Indent.getNormalIndent(), null);\n    }\n    if (psiParent instanceof GrAnnotationArgumentList) {\n      return new ChildAttributes(Indent.getContinuationIndent(), null);\n    }\n    return new ChildAttributes(Indent.getNoneIndent(), null);\n  }","id":33063,"modified_method":"@NotNull\n  public ChildAttributes getChildAttributes(final int newChildIndex) {\n    ASTNode astNode = getNode();\n    final PsiElement psiParent = astNode.getPsi();\n    if (psiParent instanceof GroovyFileBase) {\n      return new ChildAttributes(Indent.getNoneIndent(), null);\n    }\n    if (psiParent instanceof GrSwitchStatement) {\n      List<Block> subBlocks = getSubBlocks();\n      if (newChildIndex > 0) {\n        Block block = subBlocks.get(newChildIndex - 1);\n        if (block instanceof GroovyBlock) {\n          PsiElement anchorPsi = ((GroovyBlock)block).getNode().getPsi();\n          if (anchorPsi instanceof GrCaseSection) {\n            for (GrStatement statement : ((GrCaseSection)anchorPsi).getStatements()) {\n              if (statement instanceof GrBreakStatement ||\n                  statement instanceof GrContinueStatement ||\n                  statement instanceof GrReturnStatement ||\n                  statement instanceof GrThrowStatement) {\n                return new ChildAttributes(GroovyIndentProcessor.getSwitchCaseIndent(anchorPsi), null);\n              }\n            }\n            @SuppressWarnings(\"ConstantConditions\")\n            int indentSize = mySettings.getIndentOptions().INDENT_SIZE;\n            return new ChildAttributes(Indent.getSpaceIndent(mySettings.INDENT_CASE_FROM_SWITCH ? 2 * indentSize : indentSize), null);\n          }\n        }\n      }\n    }\n\n    if (TokenSets.BLOCK_SET.contains(astNode.getElementType()) || SWITCH_STATEMENT.equals(astNode.getElementType())) {\n      return new ChildAttributes(Indent.getNormalIndent(), null);\n    }\n    if (CASE_SECTION.equals(astNode.getElementType())) {\n      return new ChildAttributes(Indent.getNormalIndent(), null);\n    }\n    if (psiParent instanceof GrBinaryExpression ||\n        psiParent instanceof GrCommandArgumentList ||\n        psiParent instanceof GrArgumentList) {\n      return new ChildAttributes(Indent.getContinuationWithoutFirstIndent(), null);\n    }\n    if (psiParent instanceof GrParameterList) {\n      return new ChildAttributes(getIndent(), getAlignment());\n    }\n    if (psiParent instanceof GrListOrMap) {\n      return new ChildAttributes(Indent.getContinuationIndent(), null);\n    }\n    if (psiParent instanceof GrDocComment || psiParent instanceof GrDocTag) {\n      return new ChildAttributes(Indent.getSpaceIndent(GroovyIndentProcessor.GDOC_COMMENT_INDENT), null);\n    }\n    if (psiParent instanceof GrVariable || psiParent instanceof GrAssignmentExpression) {\n      return new ChildAttributes(Indent.getNormalIndent(), null);\n    }\n    if (psiParent instanceof GrIfStatement || psiParent instanceof GrLoopStatement) {\n      return new ChildAttributes(Indent.getNormalIndent(), null);\n    }\n    if (psiParent instanceof GrAnnotationArgumentList) {\n      return new ChildAttributes(Indent.getContinuationIndent(), null);\n    }\n    return new ChildAttributes(Indent.getNoneIndent(), null);\n  }","commit_id":"b73fd92f468b3f82a1226f7df70bc207af050c93","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public List<Block> generateSubBlockForCodeBlocks(boolean classLevel, final List<ASTNode> children) {\n\n    calculateAlignments(children, classLevel);\n    final ArrayList<Block> subBlocks = new ArrayList<Block>();\n\n    if (classLevel && myAlignment != null) {\n      final AlignmentProvider.Aligner aligner = myAlignmentProvider.createAligner(true);\n      for (ASTNode child : children) {\n        aligner.append(child.getPsi());\n      }\n    }\n    for (ASTNode childNode : children) {\n      final Indent indent = GroovyIndentProcessor.getChildIndent(myBlock, childNode);\n      subBlocks.add(new GroovyBlock(childNode, indent, myWrap, mySettings, myGroovySettings, myAlignmentProvider));\n    }\n    return subBlocks;\n  }","id":33064,"modified_method":"public List<Block> generateSubBlockForCodeBlocks(boolean classLevel, final List<ASTNode> children) {\n\n    calculateAlignments(children, classLevel);\n    final ArrayList<Block> subBlocks = new ArrayList<Block>();\n\n    if (classLevel && myAlignment != null) {\n      final AlignmentProvider.Aligner aligner = myAlignmentProvider.createAligner(true);\n      for (ASTNode child : children) {\n        aligner.append(child.getPsi());\n      }\n    }\n    for (ASTNode childNode : children) {\n      final Indent indent = new GroovyIndentProcessor().getChildIndent(myBlock, childNode);\n      subBlocks.add(new GroovyBlock(childNode, indent, myWrap, mySettings, myGroovySettings, myAlignmentProvider));\n    }\n    return subBlocks;\n  }","commit_id":"b73fd92f468b3f82a1226f7df70bc207af050c93","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public List<Block> generateSubBlocks() {\n\n    //For binary expressions\n    PsiElement blockPsi = myNode.getPsi();\n    IElementType elementType = myNode.getElementType();\n\n    if (blockPsi instanceof GrBinaryExpression && !(blockPsi.getParent() instanceof GrBinaryExpression)) {\n      return generateForBinaryExpr();\n    }\n\n    //For multiline strings\n    if ((elementType == mSTRING_LITERAL || elementType == mGSTRING_LITERAL) && myBlock.getTextRange().equals(myNode.getTextRange())) {\n      String text = myNode.getText();\n      if (text.length() > 6) {\n        if (text.substring(0, 3).equals(\"'''\") && text.substring(text.length() - 3).equals(\"'''\") ||\n            text.substring(0, 3).equals(\"\\\"\\\"\\\"\") & text.substring(text.length() - 3).equals(\"\\\"\\\"\\\"\")) {\n          return generateForMultiLineString();\n        }\n      }\n    }\n\n    //for gstrings\n    if (elementType == GSTRING || elementType == REGEX || elementType == mREGEX_LITERAL || elementType == mDOLLAR_SLASH_REGEX_LITERAL) {\n      final ArrayList<Block> subBlocks = new ArrayList<Block>();\n      ASTNode[] children = getGroovyChildren(myNode);\n      for (ASTNode childNode : children) {\n        if (childNode.getTextRange().getLength() > 0) {\n          final Indent indent = GroovyIndentProcessor.getChildIndent(myBlock, childNode);\n          subBlocks.add(new GroovyBlock(childNode, indent, myWrap, mySettings, myGroovySettings, myAlignmentProvider));\n        }\n      }\n      return subBlocks;\n    }\n\n    // chained properties, calls, indexing, etc\n    if (NESTED.contains(elementType) && blockPsi.getParent() != null && !NESTED.contains(blockPsi.getParent().getNode().getElementType())) {\n      final List<Block> subBlocks = new ArrayList<Block>();\n      AlignmentProvider.Aligner dotsAligner = mySettings.ALIGN_MULTILINE_CHAINED_METHODS ? myAlignmentProvider.createAligner(true) : null;\n      addNestedChildren(myNode.getPsi(), subBlocks, dotsAligner, true);\n      return subBlocks;\n    }\n\n    if (blockPsi instanceof GrListOrMap && ((GrListOrMap)blockPsi).isMap() && myGroovySettings.ALIGN_NAMED_ARGS_IN_MAP) {\n      AlignmentProvider.Aligner labels = myAlignmentProvider.createAligner(false);\n      AlignmentProvider.Aligner exprs = myAlignmentProvider.createAligner(true);\n      GrNamedArgument[] namedArgs = ((GrListOrMap)blockPsi).getNamedArguments();\n      for (GrNamedArgument arg : namedArgs) {\n        GrArgumentLabel label = arg.getLabel();\n        if (label != null) labels.append(label);\n\n        PsiElement colon = arg.getColon();\n        if (colon == null) colon = arg.getExpression();\n        if (colon != null) exprs.append(colon);\n      }\n    }\n\n    // For Parameter lists\n    if (isListLikeClause(blockPsi)) {\n      final ArrayList<Block> subBlocks = new ArrayList<Block>();\n      List<ASTNode> astNodes = visibleChildren(myNode);\n\n      if (mustAlign(blockPsi, astNodes)) {\n        final AlignmentProvider.Aligner aligner = myAlignmentProvider.createAligner(false);\n        for (ASTNode node : astNodes) {\n          if (!isKeyword(node)) aligner.append(node.getPsi());\n        }\n      }\n      for (ASTNode childNode : astNodes) {\n        final Indent indent = GroovyIndentProcessor.getChildIndent(myBlock, childNode);\n        subBlocks.add(new GroovyBlock(childNode, indent, myWrap, mySettings, myGroovySettings, myAlignmentProvider));\n      }\n      return subBlocks;\n    }\n\n    boolean classLevel = blockPsi instanceof GrTypeDefinitionBody;\n    if (blockPsi instanceof GrClosableBlock &&\n        ((GrClosableBlock)blockPsi).getArrow() != null &&\n        ((GrClosableBlock)blockPsi).getParameters().length > 0 &&\n        !getClosureBodyVisibleChildren(myNode).isEmpty()) {\n      GrClosableBlock closableBlock = (GrClosableBlock)blockPsi;\n\n      ArrayList<Block> blocks = new ArrayList<Block>();\n\n      PsiElement lbrace = closableBlock.getLBrace();\n      if (lbrace != null) {\n        ASTNode node = lbrace.getNode();\n        Indent indent = GroovyIndentProcessor.getChildIndent(myBlock, node);\n        blocks.add(new GroovyBlock(node, indent, myWrap, mySettings, myGroovySettings, myAlignmentProvider));\n      }\n\n     /* {\n        Indent indent = GroovyIndentProcessor.getChildIndent(myBlock, parameterListNode);\n        GroovyBlock block = new GroovyBlock(parameterListNode, indent, myWrap, mySettings, myGroovySettings, myAlignmentProvider);\n        blocks.add(block);\n      }\n\n      {\n        PsiElement arrow = closableBlock.getArrow();\n        ASTNode node = arrow.getNode();\n        Indent indent = GroovyIndentProcessor.getChildIndent(myBlock, node);\n        GroovyBlock block = new GroovyBlock(node, indent, myWrap, mySettings, myGroovySettings, myAlignmentProvider);\n        blocks.add(block);\n      }*/\n\n      {\n        Indent indent = Indent.getNormalIndent();\n        ASTNode parameterListNode = closableBlock.getParameterList().getNode();\n        ClosureBodyBlock bodyBlock = new ClosureBodyBlock(parameterListNode, indent, myWrap, mySettings, myGroovySettings, myAlignmentProvider);\n        blocks.add(bodyBlock);\n      }\n\n      PsiElement rbrace = closableBlock.getRBrace();\n      if (rbrace != null) {\n        ASTNode node = rbrace.getNode();\n        Indent indent = GroovyIndentProcessor.getChildIndent(myBlock, node);\n        blocks.add(new GroovyBlock(node, indent, myWrap, mySettings, myGroovySettings, myAlignmentProvider));\n      }\n\n      return blocks;\n    }\n\n    if (blockPsi instanceof GrCodeBlock || blockPsi instanceof GroovyFile || classLevel) {\n      return generateSubBlockForCodeBlocks(classLevel, visibleChildren(myNode));\n    }\n\n    // For other cases\n    final ArrayList<Block> subBlocks = new ArrayList<Block>();\n    for (ASTNode childNode : visibleChildren(myNode)) {\n      final Indent indent = GroovyIndentProcessor.getChildIndent(myBlock, childNode);\n      subBlocks.add(new GroovyBlock(childNode, indent, myWrap, mySettings, myGroovySettings, myAlignmentProvider));\n    }\n    return subBlocks;\n  }","id":33065,"modified_method":"public List<Block> generateSubBlocks() {\n\n    //For binary expressions\n    PsiElement blockPsi = myNode.getPsi();\n    IElementType elementType = myNode.getElementType();\n\n    if (blockPsi instanceof GrBinaryExpression && !(blockPsi.getParent() instanceof GrBinaryExpression)) {\n      return generateForBinaryExpr();\n    }\n\n    //For multiline strings\n    if ((elementType == mSTRING_LITERAL || elementType == mGSTRING_LITERAL) && myBlock.getTextRange().equals(myNode.getTextRange())) {\n      String text = myNode.getText();\n      if (text.length() > 6) {\n        if (text.substring(0, 3).equals(\"'''\") && text.substring(text.length() - 3).equals(\"'''\") ||\n            text.substring(0, 3).equals(\"\\\"\\\"\\\"\") & text.substring(text.length() - 3).equals(\"\\\"\\\"\\\"\")) {\n          return generateForMultiLineString();\n        }\n      }\n    }\n\n    //for gstrings\n    if (elementType == GSTRING || elementType == REGEX || elementType == mREGEX_LITERAL || elementType == mDOLLAR_SLASH_REGEX_LITERAL) {\n      final ArrayList<Block> subBlocks = new ArrayList<Block>();\n      ASTNode[] children = getGroovyChildren(myNode);\n      for (ASTNode childNode : children) {\n        if (childNode.getTextRange().getLength() > 0) {\n          final Indent indent = new GroovyIndentProcessor().getChildIndent(myBlock, childNode);\n          subBlocks.add(new GroovyBlock(childNode, indent, myWrap, mySettings, myGroovySettings, myAlignmentProvider));\n        }\n      }\n      return subBlocks;\n    }\n\n    // chained properties, calls, indexing, etc\n    if (NESTED.contains(elementType) && blockPsi.getParent() != null && !NESTED.contains(blockPsi.getParent().getNode().getElementType())) {\n      final List<Block> subBlocks = new ArrayList<Block>();\n      AlignmentProvider.Aligner dotsAligner = mySettings.ALIGN_MULTILINE_CHAINED_METHODS ? myAlignmentProvider.createAligner(true) : null;\n      addNestedChildren(myNode.getPsi(), subBlocks, dotsAligner, true);\n      return subBlocks;\n    }\n\n    if (blockPsi instanceof GrListOrMap && ((GrListOrMap)blockPsi).isMap() && myGroovySettings.ALIGN_NAMED_ARGS_IN_MAP) {\n      AlignmentProvider.Aligner labels = myAlignmentProvider.createAligner(false);\n      AlignmentProvider.Aligner exprs = myAlignmentProvider.createAligner(true);\n      GrNamedArgument[] namedArgs = ((GrListOrMap)blockPsi).getNamedArguments();\n      for (GrNamedArgument arg : namedArgs) {\n        GrArgumentLabel label = arg.getLabel();\n        if (label != null) labels.append(label);\n\n        PsiElement colon = arg.getColon();\n        if (colon == null) colon = arg.getExpression();\n        if (colon != null) exprs.append(colon);\n      }\n    }\n\n    // For Parameter lists\n    if (isListLikeClause(blockPsi)) {\n      final ArrayList<Block> subBlocks = new ArrayList<Block>();\n      List<ASTNode> astNodes = visibleChildren(myNode);\n\n      if (mustAlign(blockPsi, astNodes)) {\n        final AlignmentProvider.Aligner aligner = myAlignmentProvider.createAligner(false);\n        for (ASTNode node : astNodes) {\n          if (!isKeyword(node)) aligner.append(node.getPsi());\n        }\n      }\n      for (ASTNode childNode : astNodes) {\n        final Indent indent = new GroovyIndentProcessor().getChildIndent(myBlock, childNode);\n        subBlocks.add(new GroovyBlock(childNode, indent, myWrap, mySettings, myGroovySettings, myAlignmentProvider));\n      }\n      return subBlocks;\n    }\n\n    boolean classLevel = blockPsi instanceof GrTypeDefinitionBody;\n    if (blockPsi instanceof GrClosableBlock &&\n        ((GrClosableBlock)blockPsi).getArrow() != null &&\n        ((GrClosableBlock)blockPsi).getParameters().length > 0 &&\n        !getClosureBodyVisibleChildren(myNode).isEmpty()) {\n      GrClosableBlock closableBlock = (GrClosableBlock)blockPsi;\n\n      ArrayList<Block> blocks = new ArrayList<Block>();\n\n      PsiElement lbrace = closableBlock.getLBrace();\n      if (lbrace != null) {\n        ASTNode node = lbrace.getNode();\n        Indent indent = new GroovyIndentProcessor().getChildIndent(myBlock, node);\n        blocks.add(new GroovyBlock(node, indent, myWrap, mySettings, myGroovySettings, myAlignmentProvider));\n      }\n\n     /* {\n        Indent indent = GroovyIndentProcessor.getChildIndent(myBlock, parameterListNode);\n        GroovyBlock block = new GroovyBlock(parameterListNode, indent, myWrap, mySettings, myGroovySettings, myAlignmentProvider);\n        blocks.add(block);\n      }\n\n      {\n        PsiElement arrow = closableBlock.getArrow();\n        ASTNode node = arrow.getNode();\n        Indent indent = GroovyIndentProcessor.getChildIndent(myBlock, node);\n        GroovyBlock block = new GroovyBlock(node, indent, myWrap, mySettings, myGroovySettings, myAlignmentProvider);\n        blocks.add(block);\n      }*/\n\n      {\n        Indent indent = Indent.getNormalIndent();\n        ASTNode parameterListNode = closableBlock.getParameterList().getNode();\n        ClosureBodyBlock bodyBlock = new ClosureBodyBlock(parameterListNode, indent, myWrap, mySettings, myGroovySettings, myAlignmentProvider);\n        blocks.add(bodyBlock);\n      }\n\n      PsiElement rbrace = closableBlock.getRBrace();\n      if (rbrace != null) {\n        ASTNode node = rbrace.getNode();\n        Indent indent = new GroovyIndentProcessor().getChildIndent(myBlock, node);\n        blocks.add(new GroovyBlock(node, indent, myWrap, mySettings, myGroovySettings, myAlignmentProvider));\n      }\n\n      return blocks;\n    }\n\n    if (blockPsi instanceof GrCodeBlock || blockPsi instanceof GroovyFile || classLevel) {\n      return generateSubBlockForCodeBlocks(classLevel, visibleChildren(myNode));\n    }\n\n    // For other cases\n    final ArrayList<Block> subBlocks = new ArrayList<Block>();\n    for (ASTNode childNode : visibleChildren(myNode)) {\n      final Indent indent = new GroovyIndentProcessor().getChildIndent(myBlock, childNode);\n      subBlocks.add(new GroovyBlock(childNode, indent, myWrap, mySettings, myGroovySettings, myAlignmentProvider));\n    }\n    return subBlocks;\n  }","commit_id":"b73fd92f468b3f82a1226f7df70bc207af050c93","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void appendDescriptors(PsiElement element, List<FoldingDescriptor> descriptors, Set<PsiElement> usedComments) {\n    ASTNode node = element.getNode();\n    if (node == null) return;\n    IElementType type = node.getElementType();\n\n    if (BLOCK_SET.contains(type) && !isSingleHighLevelClassBody(element) || type == CLOSABLE_BLOCK) {\n      if (isMultiline(element)) {\n        collapseBlock(descriptors, element);\n      }\n    }\n    // comments\n    if (((type.equals(mML_COMMENT) && !isCustomRegionStart(node)) || type.equals(GROOVY_DOC_COMMENT)) &&\n        isMultiline(element) &&\n        isWellEndedComment(element)) {\n      descriptors.add(new FoldingDescriptor(node, node.getTextRange()));\n    }\n\n    if (type.equals(mSL_COMMENT) && !isCustomRegionStart(node) && !usedComments.contains(element)) {\n      usedComments.add(element);\n      PsiElement end = null;\n      for (PsiElement current = element.getNextSibling(); current != null; current = current.getNextSibling()) {\n        IElementType elementType = current.getNode().getElementType();\n        if (elementType == mSL_COMMENT) {\n          end = current;\n          usedComments.add(current);\n          continue;\n        }\n        if (TokenSets.WHITE_SPACES_SET.contains(elementType)) {\n          continue;\n        }\n        break;\n      }\n      if (end != null) {\n        final TextRange range = new TextRange(element.getTextRange().getStartOffset(), end.getTextRange().getEndOffset());\n        descriptors.add(new FoldingDescriptor(element, range));\n      }\n    }\n\n    //multiline strings\n    addFoldingForStrings(descriptors, node);\n\n    Set<PsiElement> newUsedComments = new HashSet<PsiElement>();\n    for (PsiElement child = element.getFirstChild(); child != null; child = child.getNextSibling()) {\n      appendDescriptors(child, descriptors, newUsedComments);\n    }\n\n    if (element instanceof GroovyFile) {\n      processImports(descriptors, ((GroovyFile)element).getImportStatements());\n    }\n  }","id":33066,"modified_method":"private void appendDescriptors(PsiElement element, List<FoldingDescriptor> descriptors, Set<PsiElement> usedComments) {\n    ASTNode node = element.getNode();\n    if (node == null) return;\n    IElementType type = node.getElementType();\n\n    if (BLOCK_SET.contains(type) && !isSingleHighLevelClassBody(element) || type == CLOSABLE_BLOCK) {\n      if (isMultiline(element)) {\n        collapseBlock(descriptors, element);\n      }\n    }\n    // comments\n    if (((type.equals(mML_COMMENT) && !isCustomRegionStart(node)) || type.equals(GROOVY_DOC_COMMENT)) &&\n        isMultiline(element) &&\n        isWellEndedComment(element)) {\n      descriptors.add(new FoldingDescriptor(node, node.getTextRange()));\n    }\n\n    if (type.equals(mSL_COMMENT) && !isCustomRegionStart(node) && !usedComments.contains(element)) {\n      usedComments.add(element);\n      PsiElement end = null;\n      for (PsiElement current = element.getNextSibling(); current != null; current = current.getNextSibling()) {\n        IElementType elementType = current.getNode().getElementType();\n        if (elementType == mSL_COMMENT) {\n          end = current;\n          usedComments.add(current);\n          continue;\n        }\n        if (WHITE_SPACES_SET.contains(elementType)) {\n          continue;\n        }\n        break;\n      }\n      if (end != null) {\n        final TextRange range = new TextRange(element.getTextRange().getStartOffset(), end.getTextRange().getEndOffset());\n        descriptors.add(new FoldingDescriptor(element, range));\n      }\n    }\n\n    //multiline strings\n    addFoldingForStrings(descriptors, node);\n\n    Set<PsiElement> newUsedComments = new HashSet<PsiElement>();\n    for (PsiElement child = element.getFirstChild(); child != null; child = child.getNextSibling()) {\n      appendDescriptors(child, descriptors, newUsedComments);\n    }\n\n    if (element instanceof GroovyFile) {\n      processImports(descriptors, ((GroovyFile)element).getImportStatements());\n    }\n  }","commit_id":"b73fd92f468b3f82a1226f7df70bc207af050c93","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void processImports(final List<FoldingDescriptor> descriptors, GrImportStatement[] imports) {\n    if (imports.length < 2) return;\n\n    PsiElement first = imports[0];\n    while (first != null) {\n      PsiElement marker = first;\n      PsiElement next = first.getNextSibling();\n      while (next instanceof GrImportStatement || next instanceof LeafPsiElement) {\n        if (next instanceof GrImportStatement) marker = next;\n        next = next.getNextSibling();\n      }\n      if (marker != first) {\n        int start = first.getTextRange().getStartOffset();\n        int end = marker.getTextRange().getEndOffset();\n        int tail = \"import \".length();\n        if (start + tail < end && !JavaFoldingBuilder.hasErrorElementsNearby(first.getContainingFile(), start, end)) {\n          descriptors.add(new FoldingDescriptor(first.getNode(), new TextRange(start + tail, end)));\n        }\n      }\n      while (!(next instanceof GrImportStatement) && next != null) next = next.getNextSibling();\n      first = next;\n    }\n  }","id":33067,"modified_method":"private static void processImports(final List<FoldingDescriptor> descriptors, GrImportStatement[] imports) {\n    if (imports.length < 2) return;\n\n    PsiElement first = imports[0];\n    while (first != null) {\n      PsiElement marker = first;\n      PsiElement next = first.getNextSibling();\n      while (next instanceof GrImportStatement || next instanceof LeafPsiElement) {\n        if (next instanceof GrImportStatement) marker = next;\n        next = next.getNextSibling();\n      }\n      if (marker != first) {\n        int start = first.getTextRange().getStartOffset();\n        int end = marker.getTextRange().getEndOffset();\n        int tail = \"import \".length();\n        if (start + tail < end && !JavaFoldingBuilderBase.hasErrorElementsNearby(first.getContainingFile(), start, end)) {\n          descriptors.add(new FoldingDescriptor(first.getNode(), new TextRange(start + tail, end)));\n        }\n      }\n      while (!(next instanceof GrImportStatement) && next != null) next = next.getNextSibling();\n      first = next;\n    }\n  }","commit_id":"b73fd92f468b3f82a1226f7df70bc207af050c93","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isMultiLineStringLiteral(ASTNode node) {\n    return (TokenSets.STRING_LITERAL_SET.contains(node.getElementType()) ||\n            node.getElementType().equals(GSTRING) ||\n            node.getElementType().equals(REGEX)) &&\n           isMultiline(node.getPsi()) &&\n           GrStringUtil.isWellEndedString(node.getPsi());\n  }","id":33068,"modified_method":"private static boolean isMultiLineStringLiteral(ASTNode node) {\n    return (STRING_LITERAL_SET.contains(node.getElementType()) ||\n            node.getElementType().equals(GSTRING) ||\n            node.getElementType().equals(REGEX)) &&\n           isMultiline(node.getPsi()) &&\n           GrStringUtil.isWellEndedString(node.getPsi());\n  }","commit_id":"b73fd92f468b3f82a1226f7df70bc207af050c93","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void collapseBlock(List<FoldingDescriptor> descriptors, PsiElement psi) {\n    if (psi instanceof GrCodeBlock) {\n      final int lineFeedCount = StringUtil.countChars(psi.getText(), '\\n');\n      if (lineFeedCount <= 2) {\n        final PsiElement lbrace = ((GrCodeBlock)psi).getLBrace();\n        final PsiElement rbrace = ((GrCodeBlock)psi).getRBrace();\n        if (lbrace != null && rbrace != null) {\n          final PsiElement next = lbrace.getNextSibling();\n          final PsiElement prev = rbrace.getPrevSibling();\n          if (next != null && TokenSets.WHITE_SPACES_SET.contains(next.getNode().getElementType()) &&\n              prev != null && TokenSets.WHITE_SPACES_SET.contains(prev.getNode().getElementType())) {\n            final FoldingGroup group = FoldingGroup.newGroup(\"block_group\");\n            descriptors.add(new NamedFoldingDescriptor(psi.getNode(), lbrace.getTextRange().getStartOffset(), next.getTextRange().getEndOffset(), group, \"{\"));\n            descriptors.add(new NamedFoldingDescriptor(psi.getNode(), prev.getTextRange().getStartOffset(), rbrace.getTextRange().getEndOffset(), group, \"}\"));\n            return;\n          }\n        }\n      }\n    }\n    descriptors.add(new FoldingDescriptor(psi, psi.getTextRange()));\n  }","id":33069,"modified_method":"private static void collapseBlock(List<FoldingDescriptor> descriptors, PsiElement psi) {\n    if (psi instanceof GrCodeBlock) {\n      final int lineFeedCount = StringUtil.countChars(psi.getText(), '\\n');\n      if (lineFeedCount <= 2) {\n        final PsiElement lbrace = ((GrCodeBlock)psi).getLBrace();\n        final PsiElement rbrace = ((GrCodeBlock)psi).getRBrace();\n        if (lbrace != null && rbrace != null) {\n          final PsiElement next = lbrace.getNextSibling();\n          final PsiElement prev = rbrace.getPrevSibling();\n          if (next != null && WHITE_SPACES_SET.contains(next.getNode().getElementType()) &&\n              prev != null && WHITE_SPACES_SET.contains(prev.getNode().getElementType())) {\n            final FoldingGroup group = FoldingGroup.newGroup(\"block_group\");\n            descriptors.add(new NamedFoldingDescriptor(psi.getNode(), lbrace.getTextRange().getStartOffset(), next.getTextRange().getEndOffset(), group, \"{\"));\n            descriptors.add(new NamedFoldingDescriptor(psi.getNode(), prev.getTextRange().getStartOffset(), rbrace.getTextRange().getEndOffset(), group, \"}\"));\n            return;\n          }\n        }\n      }\n    }\n    descriptors.add(new FoldingDescriptor(psi, psi.getTextRange()));\n  }","commit_id":"b73fd92f468b3f82a1226f7df70bc207af050c93","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Indent getSwitchCaseIndent(PsiElement psiParent) {\n    return getGroovySettings(psiParent).INDENT_CASE_FROM_SWITCH ? Indent.getNormalIndent() : Indent.getNoneIndent();\n  }","id":33070,"modified_method":"public static Indent getSwitchCaseIndent(PsiElement psiParent) {\n    if (getGroovySettings(psiParent).INDENT_CASE_FROM_SWITCH) {\n      return Indent.getNormalIndent();\n    }\n    else {\n      return Indent.getNoneIndent();\n    }\n  }","commit_id":"b73fd92f468b3f82a1226f7df70bc207af050c93","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Calculates indent, based on code style, between parent block and child node\n   *\n   * @param parentBlock   parent block\n   * @param child         child node\n   * @return indent\n   */\n  @NotNull\n  public static Indent getChildIndent(@NotNull final GroovyBlock parentBlock, @NotNull final ASTNode child) {\n    ASTNode node = parentBlock.getNode();\n\n    final PsiElement psiParent = node.getPsi();\n    PsiElement psiChild = child.getPsi();\n\n\n    IElementType childType = child.getElementType();\n    IElementType parentType = node.getElementType();\n\n\n    // For Groovy file\n    if (psiParent instanceof GroovyFileBase) {\n      return Indent.getNoneIndent();\n    }\n\n    if (psiParent instanceof GrMethod && childType == PARAMETERS_LIST) {\n      return Indent.getContinuationIndent();\n    }\n\n    if (GSTRING_TOKENS_INNER.contains(childType) && mGSTRING_BEGIN != childType) {\n      return Indent.getAbsoluteNoneIndent();\n    }\n\n    if (parentType == ASSERT_STATEMENT && childType != GroovyTokenTypes.kASSERT) {\n      return Indent.getContinuationIndent();\n    }\n\n    if (parentType == LIST_OR_MAP) {\n      boolean isBracket = childType == mLBRACK || childType == mRBRACK;\n      return isBracket ? Indent.getNoneIndent() : Indent.getContinuationWithoutFirstIndent();\n    }\n\n    if (parentBlock instanceof ClosureBodyBlock && childType == GroovyElementTypes.PARAMETERS_LIST) {\n      return Indent.getNoneIndent();\n    }\n\n    // For common code block\n    if (BLOCK_SET.contains(parentType) && !BLOCK_STATEMENT.equals(parentType) || parentBlock instanceof ClosureBodyBlock) {\n      boolean isBrace = child.getElementType() == mLCURLY || child.getElementType() == mRCURLY;\n      return isBrace ? Indent.getNoneIndent() : Indent.getNormalIndent();\n    }\n\n    if (CASE_SECTION.equals(parentType)) {\n      return child.getElementType() == CASE_LABEL ? Indent.getNoneIndent() : Indent.getNormalIndent();\n    }\n\n    if (SWITCH_STATEMENT.equals(parentType)) {\n      return child.getElementType() == CASE_SECTION ? getSwitchCaseIndent(psiParent) : Indent.getNoneIndent();\n    }\n\n    if (parentType == LABELED_STATEMENT && childType == LABEL) {\n      CommonCodeStyleSettings.IndentOptions indentOptions = parentBlock.getSettings().getIndentOptions();\n      boolean isLabelIndentAbsolute = indentOptions != null && indentOptions.LABEL_INDENT_ABSOLUTE;\n      return isLabelIndentAbsolute ? Indent.getAbsoluteLabelIndent() : Indent.getLabelIndent();\n    }\n\n    if (parentType == ANNOTATION) {\n      if (childType == ANNOTATION_ARGUMENTS) return Indent.getContinuationIndent();\n      return Indent.getNoneIndent();\n    }\n\n    if (parentType == ANNOTATION_ARGUMENTS) {\n      if (childType == mLPAREN || childType == mRPAREN) return Indent.getNoneIndent();\n      return Indent.getContinuationIndent();\n    }\n\n    // for control structures\n    if (psiParent instanceof GrControlStatement) {\n      return getControlIndent(psiParent, child);\n    }\n\n    if (psiParent instanceof GrExpression) {\n      return getExpressionIndent(psiParent, child);\n    }\n\n    if (psiParent instanceof GrVariable && psiChild == ((GrVariable)psiParent).getInitializerGroovy()) {\n      return Indent.getNormalIndent();\n    }\n\n    //For parameter lists\n    if (psiParent instanceof GrParameterList || psiParent instanceof GrExtendsClause || psiParent instanceof GrImplementsClause || psiParent instanceof GrThrowsClause) {\n      Indent parentIndent = parentBlock.getIndent();\n      return parentIndent != null ? Indent.getContinuationWithoutFirstIndent() : Indent.getNoneIndent();\n    }\n\n    // For arguments\n    if (psiParent instanceof GrArgumentList && childType != mLPAREN && childType != mRPAREN) {\n      return Indent.getContinuationWithoutFirstIndent();\n    }\n\n    if (psiParent instanceof GrDocComment && childType != mGDOC_COMMENT_START ||\n        psiParent instanceof GrDocTag     && childType != mGDOC_TAG_NAME) {\n      return Indent.getSpaceIndent(GDOC_COMMENT_INDENT);\n    }\n\n    if (psiParent instanceof GrNamedArgument && child.getPsi() == ((GrNamedArgument)psiParent).getExpression()) {\n      return Indent.getContinuationIndent();\n    }\n\n    if (psiChild instanceof GrVariable && psiParent instanceof GrVariableDeclaration) {\n      return Indent.getContinuationWithoutFirstIndent();\n    }\n\n    return Indent.getNoneIndent();\n  }","id":33071,"modified_method":"/**\n   * Calculates indent, based on code style, between parent block and child node\n   *\n   * @param parentBlock parent block\n   * @param child       child node\n   * @return indent\n   */\n  @NotNull\n  public Indent getChildIndent(@NotNull final GroovyBlock parentBlock, @NotNull final ASTNode child) {\n    myChildType = child.getElementType();\n    if (parentBlock instanceof ClosureBodyBlock) {\n      if (myChildType == PARAMETERS_LIST) {\n        return Indent.getNoneIndent();\n      }\n      else if (myChildType != mLCURLY && myChildType != mRCURLY) {\n        return Indent.getNormalIndent();\n      }\n    }\n\n    if (GSTRING_TOKENS_INNER.contains(myChildType)) {\n      return Indent.getAbsoluteNoneIndent();\n    }\n\n    final PsiElement parent = parentBlock.getNode().getPsi();\n    if (parent instanceof GroovyPsiElement) {\n      myBlock = parentBlock;\n      myChild = child.getPsi();\n      ((GroovyPsiElement)parent).accept(this);\n      if (myResult != null) return myResult;\n    }\n\n    return Indent.getNoneIndent();\n  }","commit_id":"b73fd92f468b3f82a1226f7df70bc207af050c93","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public CommonCodeStyleSettings getDefaultCommonSettings() {\n    CommonCodeStyleSettings defaultSettings = new CommonCodeStyleSettings(GroovyFileType.GROOVY_LANGUAGE);\n    defaultSettings.initIndentOptions();\n    defaultSettings.SPACE_WITHIN_BRACES = true;\n    defaultSettings.KEEP_SIMPLE_CLASSES_IN_ONE_LINE = true;\n    defaultSettings.KEEP_SIMPLE_METHODS_IN_ONE_LINE = true;\n    return defaultSettings;\n  }","id":33072,"modified_method":"@Override\n  public CommonCodeStyleSettings getDefaultCommonSettings() {\n    CommonCodeStyleSettings defaultSettings = new CommonCodeStyleSettings(GroovyFileType.GROOVY_LANGUAGE);\n    defaultSettings.initIndentOptions();\n    defaultSettings.SPACE_WITHIN_BRACES = true;\n    defaultSettings.KEEP_SIMPLE_CLASSES_IN_ONE_LINE = true;\n    defaultSettings.KEEP_SIMPLE_METHODS_IN_ONE_LINE = true;\n    defaultSettings.KEEP_SIMPLE_BLOCKS_IN_ONE_LINE = true;\n    return defaultSettings;\n  }","commit_id":"b73fd92f468b3f82a1226f7df70bc207af050c93","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Indent getSwitchCaseIndent(PsiElement psiParent) {\n    if (getGroovySettings(psiParent).INDENT_CASE_FROM_SWITCH) {\n        return Indent.getNormalIndent();\n      }\n    return Indent.getNoneIndent();\n  }","id":33073,"modified_method":"public static Indent getSwitchCaseIndent(PsiElement psiParent) {\n    return getGroovySettings(psiParent).INDENT_CASE_FROM_SWITCH ? Indent.getNormalIndent() : Indent.getNoneIndent();\n  }","commit_id":"aa6df67b752f9d558f38aa7141e2b64a78e734c5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Calculates indent, based on code style, between parent block and child node\n   *\n   * @param parent        parent block\n   * @param child         child node\n   * @return indent\n   */\n  @NotNull\n  public static Indent getChildIndent(@NotNull final GroovyBlock parent, @NotNull final ASTNode child) {\n    ASTNode astNode = parent.getNode();\n    final PsiElement psiParent = astNode.getPsi();\n\n    // For Groovy file\n    if (psiParent instanceof GroovyFileBase) {\n      return Indent.getNoneIndent();\n    }\n\n    if (psiParent instanceof GrMethod && child.getPsi() instanceof GrParameterList) {\n      return Indent.getContinuationIndent();\n    }\n\n    if (GSTRING_TOKENS_INNER.contains(child.getElementType()) && mGSTRING_BEGIN != child.getElementType()) {\n      return Indent.getAbsoluteNoneIndent();\n    }\n\n    if (psiParent instanceof GrListOrMap) {\n      if (mLBRACK.equals(child.getElementType()) || mRBRACK.equals(child.getElementType())) {\n        return Indent.getNoneIndent();\n      } else {\n        return Indent.getContinuationWithoutFirstIndent();\n      }\n    }\n\n    if (child.getElementType() == GroovyElementTypes.PARAMETERS_LIST && parent instanceof ClosureBodyBlock) {\n      return Indent.getNoneIndent();\n    }\n\n    // For common code block\n    if (BLOCK_SET.contains(astNode.getElementType()) &&\n        !BLOCK_STATEMENT.equals(astNode.getElementType()) || parent instanceof ClosureBodyBlock) {\n      return indentForBlock(psiParent, child);\n    }\n\n    if (CASE_SECTION.equals(astNode.getElementType())) {\n      return indentForCaseSection(child);\n    }\n\n    if (SWITCH_STATEMENT.equals(astNode.getElementType())) {\n      return indentForSwitchStatement(psiParent, child);\n    }\n\n    if (psiParent instanceof GrLabeledStatement) {\n      if (child.getPsi() instanceof GrLabel) {\n        CommonCodeStyleSettings.IndentOptions indentOptions = parent.getSettings().getIndentOptions();\n        if (indentOptions.LABEL_INDENT_ABSOLUTE) {\n          return Indent.getAbsoluteLabelIndent();\n        }\n        return Indent.getLabelIndent();\n      }\n    }\n\n    // for control structures\n    if (psiParent instanceof GrControlStatement) {\n      return getControlIndent(psiParent, child);\n    }\n\n    if (psiParent instanceof GrExpression) {\n      return getExpressionIndent(psiParent, child);\n    }\n    if (psiParent instanceof GrVariable && child.getPsi() == ((GrVariable)psiParent).getInitializerGroovy()) {\n      return Indent.getNormalIndent();\n    }\n\n    //For parameter lists\n    if (psiParent instanceof GrParameterList ||\n        psiParent instanceof GrExtendsClause ||\n        psiParent instanceof GrThrowsClause) {\n      if (parent.getIndent() != null) {\n        return Indent.getContinuationWithoutFirstIndent();\n      }\n      return Indent.getNoneIndent();\n    }\n\n    // For arguments\n    if (psiParent instanceof GrArgumentList) {\n      if (child.getElementType() != mLPAREN && child.getElementType() != mRPAREN /*&& child.getElementType() != mCOMMA*/) {\n        return Indent.getContinuationWithoutFirstIndent();\n      }\n    }\n\n    if ((psiParent instanceof GrDocComment &&\n        child.getElementType() != mGDOC_COMMENT_START) ||\n        psiParent instanceof GrDocTag &&\n            child.getElementType() != mGDOC_TAG_NAME) {\n      return Indent.getSpaceIndent(GDOC_COMMENT_INDENT);\n    }\n\n    if (psiParent instanceof GrNamedArgument && child.getPsi() == ((GrNamedArgument)psiParent).getExpression()) {\n      return Indent.getContinuationIndent();\n    }\n\n    if (child.getPsi() instanceof GrVariable && psiParent instanceof GrVariableDeclaration) {\n      return Indent.getContinuationWithoutFirstIndent();\n    }\n\n    return Indent.getNoneIndent();\n  }","id":33074,"modified_method":"/**\n   * Calculates indent, based on code style, between parent block and child node\n   *\n   * @param parentBlock   parent block\n   * @param child         child node\n   * @return indent\n   */\n  @NotNull\n  public static Indent getChildIndent(@NotNull final GroovyBlock parentBlock, @NotNull final ASTNode child) {\n    ASTNode node = parentBlock.getNode();\n\n    final PsiElement psiParent = node.getPsi();\n    PsiElement psiChild = child.getPsi();\n\n\n    IElementType childType = child.getElementType();\n    IElementType parentType = node.getElementType();\n\n\n    // For Groovy file\n    if (psiParent instanceof GroovyFileBase) {\n      return Indent.getNoneIndent();\n    }\n\n    if (psiParent instanceof GrMethod && childType == PARAMETERS_LIST) {\n      return Indent.getContinuationIndent();\n    }\n\n    if (GSTRING_TOKENS_INNER.contains(childType) && mGSTRING_BEGIN != childType) {\n      return Indent.getAbsoluteNoneIndent();\n    }\n\n    if (parentType == ASSERT_STATEMENT && childType != GroovyTokenTypes.kASSERT) {\n      return Indent.getContinuationIndent();\n    }\n\n    if (parentType == LIST_OR_MAP) {\n      boolean isBracket = childType == mLBRACK || childType == mRBRACK;\n      return isBracket ? Indent.getNoneIndent() : Indent.getContinuationWithoutFirstIndent();\n    }\n\n    if (parentBlock instanceof ClosureBodyBlock && childType == GroovyElementTypes.PARAMETERS_LIST) {\n      return Indent.getNoneIndent();\n    }\n\n    // For common code block\n    if (BLOCK_SET.contains(parentType) && !BLOCK_STATEMENT.equals(parentType) || parentBlock instanceof ClosureBodyBlock) {\n      boolean isBrace = child.getElementType() == mLCURLY || child.getElementType() == mRCURLY;\n      return isBrace ? Indent.getNoneIndent() : Indent.getNormalIndent();\n    }\n\n    if (CASE_SECTION.equals(parentType)) {\n      return child.getElementType() == CASE_LABEL ? Indent.getNoneIndent() : Indent.getNormalIndent();\n    }\n\n    if (SWITCH_STATEMENT.equals(parentType)) {\n      return child.getElementType() == CASE_SECTION ? getSwitchCaseIndent(psiParent) : Indent.getNoneIndent();\n    }\n\n    if (parentType == LABELED_STATEMENT && childType == LABEL) {\n      CommonCodeStyleSettings.IndentOptions indentOptions = parentBlock.getSettings().getIndentOptions();\n      boolean isLabelIndentAbsolute = indentOptions != null && indentOptions.LABEL_INDENT_ABSOLUTE;\n      return isLabelIndentAbsolute ? Indent.getAbsoluteLabelIndent() : Indent.getLabelIndent();\n    }\n\n    // for control structures\n    if (psiParent instanceof GrControlStatement) {\n      return getControlIndent(psiParent, child);\n    }\n\n    if (psiParent instanceof GrExpression) {\n      return getExpressionIndent(psiParent, child);\n    }\n\n    if (psiParent instanceof GrVariable && psiChild == ((GrVariable)psiParent).getInitializerGroovy()) {\n      return Indent.getNormalIndent();\n    }\n\n    //For parameter lists\n    if (psiParent instanceof GrParameterList || psiParent instanceof GrExtendsClause || psiParent instanceof GrThrowsClause) {\n      Indent parentIndent = parentBlock.getIndent();\n      return parentIndent != null ? Indent.getContinuationWithoutFirstIndent() : Indent.getNoneIndent();\n    }\n\n    // For arguments\n    if (psiParent instanceof GrArgumentList && childType != mLPAREN && childType != mRPAREN) {\n      return Indent.getContinuationWithoutFirstIndent();\n    }\n\n    if (psiParent instanceof GrDocComment && childType != mGDOC_COMMENT_START ||\n        psiParent instanceof GrDocTag     && childType != mGDOC_TAG_NAME) {\n      return Indent.getSpaceIndent(GDOC_COMMENT_INDENT);\n    }\n\n    if (psiParent instanceof GrNamedArgument && child.getPsi() == ((GrNamedArgument)psiParent).getExpression()) {\n      return Indent.getContinuationIndent();\n    }\n\n    if (psiChild instanceof GrVariable && psiParent instanceof GrVariableDeclaration) {\n      return Indent.getContinuationWithoutFirstIndent();\n    }\n\n    return Indent.getNoneIndent();\n  }","commit_id":"aa6df67b752f9d558f38aa7141e2b64a78e734c5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static List<RangeValue> getRange( String range )\n    {\n        List<RangeValue> ranges = new ArrayList<RangeValue>();\n\n        for ( String token : range.split( \",\" ) )\n        {\n            if ( token.startsWith( \"[\" ) )\n            {\n                ranges.add( new RangeValue( token.replace( \"[\", \"\" ), true ) );\n            }\n            else if ( token.startsWith( \"(\" ) )\n            {\n                ranges.add( new RangeValue( token.replace( \"(\", \"\" ), false ) );\n            }\n            else if ( token.endsWith( \"]\" ) )\n            {\n                ranges.add( new RangeValue( token.replace( \"]\", \"\" ), true ) );\n            }\n            else if ( token.endsWith( \")\" ) )\n            {\n                ranges.add( new RangeValue( token.replace( \")\", \"\" ), false ) );\n            }\n\n        }\n        if ( ranges.size() < 2 )\n        {\n            ranges.add( new RangeValue( \"99999999\", false ) );\n        }\n        return ranges;\n    }","id":33075,"modified_method":"private static List<RangeValue> getRange( String range )\n    {\n        List<RangeValue> ranges = new ArrayList<RangeValue>();\n\n        for ( String token : range.split( \",\" ) )\n        {\n            if ( token.startsWith( \"[\" ) )\n            {\n                ranges.add( new RangeValue( token.replace( \"[\", \"\" ), true ) );\n            }\n            else if ( token.startsWith( \"(\" ) )\n            {\n                ranges.add( new RangeValue( token.replace( \"(\", \"\" ), false ) );\n            }\n            else if ( token.endsWith( \"]\" ) )\n            {\n                ranges.add( new RangeValue( token.replace( \"]\", \"\" ), true ) );\n            }\n            else if ( token.endsWith( \")\" ) )\n            {\n                ranges.add( new RangeValue( token.replace( \")\", \"\" ), false ) );\n            }\n            else if ( token.length() <= 0 )\n            {\n                ranges.add( new RangeValue( \"\", false ) );\n            }\n        }\n        if ( ranges.size() < 2 )\n        {\n            ranges.add( new RangeValue( \"99999999\", false ) );\n        }\n        return ranges;\n    }","commit_id":"db85e427b96a8515dd5489cb26caf203e833d26f","url":"https://github.com/apache/maven"},{"original_method":"private static int getRelationOrder( String value, RangeValue rangeValue, boolean isLeft )\n    {\n        List<String> valueTokens = Arrays.asList( value.split( \".\" ) );\n        List<String> rangeValueTokens = Arrays.asList( rangeValue.value.split( \".\" ) );\n\n        int max = Math.max( valueTokens.size(), rangeValueTokens.size() );\n        addZeroTokens( valueTokens, max );\n        addZeroTokens( rangeValueTokens, max );\n\n        if ( value.equals( rangeValue.value ) )\n        {\n            return ( rangeValue.isClosed() ) ? 0 : -1;\n        }\n\n        for ( int i = 0; i < valueTokens.size(); i++ )\n        {\n            int x = Integer.getInteger( valueTokens.get( i ) );\n            int y = Integer.getInteger( rangeValueTokens.get( i ) );\n            if ( x < y )\n            {\n                return -1;\n            }\n            else if ( x > y )\n            {\n                return 1;\n            }\n        }\n        return 0;\n    }","id":33076,"modified_method":"private static int getRelationOrder( String value, RangeValue rangeValue, boolean isLeft )\n    {\n        if ( rangeValue.value.length() <= 0 )\n        {\n            return isLeft ? 1 : -1;\n        }\n\n        List<String> valueTokens = new ArrayList<String>( Arrays.asList( value.split( \"\\\\.\" ) ) );\n        List<String> rangeValueTokens = new ArrayList<String>( Arrays.asList( rangeValue.value.split( \"\\\\.\" ) ) );\n\n        int max = Math.max( valueTokens.size(), rangeValueTokens.size() );\n        addZeroTokens( valueTokens, max );\n        addZeroTokens( rangeValueTokens, max );\n\n        if ( value.equals( rangeValue.value ) )\n        {\n            if ( !rangeValue.isClosed() )\n            {\n                return isLeft ? -1 : 1;\n            }\n            return 0;\n        }\n\n        for ( int i = 0; i < valueTokens.size(); i++ )\n        {\n            int x = Integer.parseInt( valueTokens.get( i ) );\n            int y = Integer.parseInt( rangeValueTokens.get( i ) );\n            if ( x < y )\n            {\n                return -1;\n            }\n            else if ( x > y )\n            {\n                return 1;\n            }\n        }\n        if ( !rangeValue.isClosed() )\n        {\n            return isLeft ? -1 : 1;\n        }\n        return 0;\n    }","commit_id":"db85e427b96a8515dd5489cb26caf203e833d26f","url":"https://github.com/apache/maven"},{"original_method":"@org.junit.Test\n    public void jdkVersionRange_OpenEdgeWithPadding()  {\n        List<ModelProperty> modelProperties = new ArrayList<ModelProperty>();\n        modelProperties.add(new ModelProperty(ProjectUri.Profiles.Profile.xUri, null));\n        modelProperties.add(new ModelProperty(ProjectUri.Profiles.Profile.Activation.xUri , null));\n        modelProperties.add(new ModelProperty(ProjectUri.Profiles.Profile.Activation.jdk , \"(1.5.0,\"));\n\n        ModelContainer modelContainer = new DefaultModelContainer(modelProperties);\n\n        List<InterpolatorProperty> props = new ArrayList<InterpolatorProperty>();\n        props.add(new InterpolatorProperty(\"${java.specification.version}\" , \"1.5\"));\n\n        JdkMatcher matcher = new JdkMatcher();\n        assertTrue(matcher.isMatch(modelContainer, props));\n    }","id":33077,"modified_method":"@org.junit.Test\n    public void jdkVersionRange_OpenEdgeWithPadding()  {\n        List<ModelProperty> modelProperties = new ArrayList<ModelProperty>();\n        modelProperties.add(new ModelProperty(ProjectUri.Profiles.Profile.xUri, null));\n        modelProperties.add(new ModelProperty(ProjectUri.Profiles.Profile.Activation.xUri , null));\n        modelProperties.add(new ModelProperty(ProjectUri.Profiles.Profile.Activation.jdk , \"(1.5.0,\"));\n\n        ModelContainer modelContainer = new DefaultModelContainer(modelProperties);\n\n        List<InterpolatorProperty> props = new ArrayList<InterpolatorProperty>();\n        props.add(new InterpolatorProperty(\"${java.specification.version}\" , \"1.5\"));\n\n        JdkMatcher matcher = new JdkMatcher();\n        assertFalse(matcher.isMatch(modelContainer, props));\n    }","commit_id":"db85e427b96a8515dd5489cb26caf203e833d26f","url":"https://github.com/apache/maven"},{"original_method":"/**\n     * Worker function for drawing areas.\n     *\n     * @param osm the primitive\n     * @param path the path object for the area that should be drawn; in case\n     * of multipolygons, this can path can be a complex shape with one outer\n     * polygon and one or more inner polygons\n     * @param color The color to fill the area with.\n     * @param fillImage The image to fill the area with. Overrides color.\n     * @param extent if not null, area will be filled partially; specifies, how\n     * far to fill from the boundary towards the center of the area;\n     * if null, area will be filled completely\n     * @param unclosedHighlight true, if the fact that the way / multipolygon is not\n     * properly closed should be highlighted; this parameter is only used\n     * for partial fill ({@code extent != null}), otherwise it is ignored\n     * @param disabled If this should be drawn with a special disabled style.\n     * @param text The text to write on the area.\n     */\n    protected void drawArea(OsmPrimitive osm, Path2D.Double path, Color color, MapImage fillImage, Float extent, boolean unclosedHighlight,\n            boolean disabled, TextElement text) {\n\n        Shape area = path.createTransformedShape(nc.getAffineTransform());\n\n        if (!isOutlineOnly) {\n            g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);\n            if (fillImage == null) {\n                if (isInactiveMode) {\n                    g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.33f));\n                }\n                g.setColor(color);\n                if (extent == null) {\n                    g.fill(area);\n                } else {\n                    if (unclosedHighlight) {\n                        g.setStroke(new BasicStroke((int) (unclosedAreaHighlightWidth / 100 * extent),\n                                BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER));\n                        g.draw(area);\n                    } else {\n                        Shape clip = g.getClip();\n                        g.clip(area);\n                        g.setStroke(new BasicStroke(2 * extent, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER));\n                        g.draw(area);\n                        g.setClip(clip);\n                    }\n                }\n            } else {\n                TexturePaint texture = new TexturePaint(fillImage.getImage(disabled),\n                        new Rectangle(0, 0, fillImage.getWidth(), fillImage.getHeight()));\n                g.setPaint(texture);\n                Float alpha = fillImage.getAlphaFloat();\n                if (!Utils.equalsEpsilon(alpha, 1f)) {\n                    g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, alpha));\n                }\n                if (extent == null) {\n                    g.fill(area);\n                } else {\n                    if (unclosedHighlight) {\n                        g.setStroke(new BasicStroke((int) (unclosedAreaHighlightWidth / 100 * extent),\n                                BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER));\n                        g.draw(area);\n                    } else {\n                        Shape clip = g.getClip();\n                        BasicStroke stroke = new BasicStroke(2 * extent, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER);\n                        g.clip(stroke.createStrokedShape(area));\n                        g.fill(area);\n                        g.setClip(clip);\n                    }\n                }\n                g.setPaintMode();\n            }\n            g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, antialiasing);\n        }\n\n        drawAreaText(osm, text, area);\n    }","id":33078,"modified_method":"/**\n     * Worker function for drawing areas.\n     *\n     * @param osm the primitive\n     * @param path the path object for the area that should be drawn; in case\n     * of multipolygons, this can path can be a complex shape with one outer\n     * polygon and one or more inner polygons\n     * @param color The color to fill the area with.\n     * @param fillImage The image to fill the area with. Overrides color.\n     * @param extent if not null, area will be filled partially; specifies, how\n     * far to fill from the boundary towards the center of the area;\n     * if null, area will be filled completely\n     * @param pfClip clipping area for partial fill\n     * @param unclosedHighlight true, if the fact that the way / multipolygon is not\n     * properly closed should be highlighted; this parameter is only used\n     * for partial fill ({@code extent != null}), otherwise it is ignored\n     * @param disabled If this should be drawn with a special disabled style.\n     * @param text The text to write on the area.\n     */\n    protected void drawArea(OsmPrimitive osm, Path2D.Double path, Color color, MapImage fillImage, Float extent, Path2D.Double pfClip, boolean unclosedHighlight,\n            boolean disabled, TextElement text) {\n\n        Shape area = path.createTransformedShape(nc.getAffineTransform());\n\n        if (!isOutlineOnly) {\n            g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);\n            if (fillImage == null) {\n                if (isInactiveMode) {\n                    g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.33f));\n                }\n                g.setColor(color);\n                if (extent == null) {\n                    g.fill(area);\n                } else {\n                    if (unclosedHighlight) {\n                        g.setStroke(new BasicStroke((int) (unclosedAreaHighlightWidth / 100 * extent),\n                                BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER));\n                        g.draw(area);\n                    } else {\n                        Shape oldClip = g.getClip();\n                        Shape clip = area;\n                        if (pfClip != null) {\n                            clip = pfClip.createTransformedShape(nc.getAffineTransform());\n                        }\n                        g.clip(clip);\n                        g.setStroke(new BasicStroke(2 * extent, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER));\n                        g.draw(area);\n                        g.setClip(oldClip);\n                    }\n                }\n            } else {\n                TexturePaint texture = new TexturePaint(fillImage.getImage(disabled),\n                        new Rectangle(0, 0, fillImage.getWidth(), fillImage.getHeight()));\n                g.setPaint(texture);\n                Float alpha = fillImage.getAlphaFloat();\n                if (!Utils.equalsEpsilon(alpha, 1f)) {\n                    g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, alpha));\n                }\n                if (extent == null) {\n                    g.fill(area);\n                } else {\n                    if (unclosedHighlight) {\n                        g.setStroke(new BasicStroke((int) (unclosedAreaHighlightWidth / 100 * extent),\n                                BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER));\n                        g.draw(area);\n                    } else {\n                        Shape oldClip = g.getClip();\n                        BasicStroke stroke = new BasicStroke(2 * extent, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER);\n                        g.clip(stroke.createStrokedShape(area));\n                        Shape fill = area;\n                        if (pfClip != null) {\n                            fill = pfClip.createTransformedShape(nc.getAffineTransform());\n                        }\n                        g.fill(fill);\n                        g.setClip(oldClip);\n                    }\n                }\n                g.setPaintMode();\n            }\n            g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, antialiasing);\n        }\n\n        drawAreaText(osm, text, area);\n    }","commit_id":"0d3ccf3519806fac8346f75a6fc86c9a9e5aa86d","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Draws an area defined by a way. They way does not need to be closed, but it should.\n     * @param w The way.\n     * @param color The color to fill the area with.\n     * @param fillImage The image to fill the area with. Overrides color.\n     * @param extent if not null, area will be filled partially; specifies, how\n     * far to fill from the boundary towards the center of the area;\n     * if null, area will be filled completely\n     * @param disabled If this should be drawn with a special disabled style.\n     * @param text The text to write on the area.\n     */\n    public void drawArea(Way w, Color color, MapImage fillImage, Float extent, boolean disabled, TextElement text) {\n        if (extent != null && w.isClosed()) {\n            AreaAndPerimeter ap = Geometry.getAreaAndPerimeter(w.getNodes());\n            // if partial fill would only leave a small gap in the center ...\n            if (ap.getPerimeter() * extent * scale > partialFillThreshold / 100 * ap.getArea()) {\n                // ... turn it off and fill completely\n                extent = null;\n            }\n        }\n        drawArea(w, getPath(w), color, fillImage, extent, isUnclosedAreaHighlight && !w.isClosed(), disabled, text);\n    }","id":33079,"modified_method":"/**\n     * Draws an area defined by a way. They way does not need to be closed, but it should.\n     * @param w The way.\n     * @param color The color to fill the area with.\n     * @param fillImage The image to fill the area with. Overrides color.\n     * @param extent if not null, area will be filled partially; specifies, how\n     * far to fill from the boundary towards the center of the area;\n     * if null, area will be filled completely\n     * @param disabled If this should be drawn with a special disabled style.\n     * @param text The text to write on the area.\n     */\n    public void drawArea(Way w, Color color, MapImage fillImage, Float extent, boolean disabled, TextElement text) {\n        Path2D.Double pfClip = null;\n        if (extent != null) {\n            if (w.isClosed()) {\n                AreaAndPerimeter ap = Geometry.getAreaAndPerimeter(w.getNodes());\n                // if partial fill would only leave a small gap in the center ...\n                if (ap.getPerimeter() * extent * scale > partialFillThreshold / 100 * ap.getArea()) {\n                    // ... turn it off and fill completely\n                    extent = null;\n                }\n            } else {\n                pfClip = getPFClip(w, extent * scale);\n            }\n        }\n        drawArea(w, getPath(w), color, fillImage, extent, pfClip, isUnclosedAreaHighlight && !w.isClosed(), disabled, text);\n    }","commit_id":"0d3ccf3519806fac8346f75a6fc86c9a9e5aa86d","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Draws a multipolygon area.\n     * @param r The multipolygon relation\n     * @param color The color to fill the area with.\n     * @param fillImage The image to fill the area with. Overrides color.\n     * @param extent if not null, area will be filled partially; specifies, how\n     * far to fill from the boundary towards the center of the area;\n     * if null, area will be filled completely\n     * @param disabled If this should be drawn with a special disabled style.\n     * @param text The text to write on the area.\n     */\n    public void drawArea(Relation r, Color color, MapImage fillImage, Float extent, boolean disabled, TextElement text) {\n        Multipolygon multipolygon = MultipolygonCache.getInstance().get(nc, r);\n        if (!r.isDisabled() && !multipolygon.getOuterWays().isEmpty()) {\n            for (PolyData pd : multipolygon.getCombinedPolygons()) {\n                Path2D.Double p = pd.get();\n                if (!isAreaVisible(p)) {\n                    continue;\n                }\n                boolean unclosedHighlight = false;\n                if (extent != null) {\n                    if (pd.isClosed()) {\n                        AreaAndPerimeter ap = pd.getAreaAndPerimeter();\n                        // if partial fill would only leave a small gap in the center ...\n                        if (ap.getPerimeter() * extent * scale > partialFillThreshold / 100 * ap.getArea()) {\n                            // ... turn it off and fill completely\n                            extent = null;\n                        }\n                    } else {\n                        unclosedHighlight = isUnclosedAreaHighlight;\n                    }\n                }\n                drawArea(r, p,\n                        pd.selected ? paintSettings.getRelationSelectedColor(color.getAlpha()) : color,\n                        fillImage, extent, unclosedHighlight, disabled, text);\n            }\n        }\n    }","id":33080,"modified_method":"/**\n     * Draws a multipolygon area.\n     * @param r The multipolygon relation\n     * @param color The color to fill the area with.\n     * @param fillImage The image to fill the area with. Overrides color.\n     * @param extent if not null, area will be filled partially; specifies, how\n     * far to fill from the boundary towards the center of the area;\n     * if null, area will be filled completely\n     * @param disabled If this should be drawn with a special disabled style.\n     * @param text The text to write on the area.\n     */\n    public void drawArea(Relation r, Color color, MapImage fillImage, Float extent, boolean disabled, TextElement text) {\n        Multipolygon multipolygon = MultipolygonCache.getInstance().get(nc, r);\n        if (!r.isDisabled() && !multipolygon.getOuterWays().isEmpty()) {\n            for (PolyData pd : multipolygon.getCombinedPolygons()) {\n                Path2D.Double p = pd.get();\n                Path2D.Double pfClip = null;\n                if (!isAreaVisible(p)) {\n                    continue;\n                }\n                boolean unclosedHighlight = false;\n                if (extent != null) {\n                    if (pd.isClosed()) {\n                        AreaAndPerimeter ap = pd.getAreaAndPerimeter();\n                        // if partial fill would only leave a small gap in the center ...\n                        if (ap.getPerimeter() * extent * scale > partialFillThreshold / 100 * ap.getArea()) {\n                            // ... turn it off and fill completely\n                            extent = null;\n                        }\n                    } else {\n                        unclosedHighlight = isUnclosedAreaHighlight;\n                        pfClip = getPFClip(pd, extent * scale);\n                    }\n                }\n                drawArea(r, p,\n                        pd.selected ? paintSettings.getRelationSelectedColor(color.getAlpha()) : color,\n                        fillImage, extent, pfClip, unclosedHighlight, disabled, text);\n            }\n        }\n    }","commit_id":"0d3ccf3519806fac8346f75a6fc86c9a9e5aa86d","url":"https://github.com/openstreetmap/josm"},{"original_method":"public OMMapBufferEntry(final OFileMMap iFile, final MappedByteBuffer buffer, final long beginOffset, final int size) {\r\n    this.file = iFile;\r\n    this.buffer = buffer;\r\n    this.beginOffset = beginOffset;\r\n    this.size = size;\r\n    this.counter = 0;\r\n    this.dirty = false;\r\n  }","id":33081,"modified_method":"public OMMapBufferEntry(final OFileMMap iFile, final MappedByteBuffer buffer, final long beginOffset, final int size) {\r\n    this.file = iFile;\r\n    this.buffer = buffer;\r\n    this.beginOffset = beginOffset;\r\n    this.size = size;\r\n    this.dirty = false;\r\n    updateLastUsedTime();\r\n  }","commit_id":"df28f29cf0afe030445be099c06e1f7db4aa7997","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n   * Force closing of file if it's opened yet.\r\n   */\r\n  void close() {\r\n    acquireExclusiveLock();\r\n    try {\r\n\r\n      if (buffer != null) {\r\n        if (dirty)\r\n          buffer.force();\r\n\r\n        if (cleanerMethod != null) {\r\n          // USE SUN JVM SPECIAL METHOD TO FREE RESOURCES\r\n          try {\r\n            final Object cleaner = cleanerMethod.invoke(buffer);\r\n            if (cleaner != null)\r\n              cleaner.getClass().getMethod(\"clean\").invoke(cleaner);\r\n          } catch (Exception e) {\r\n            OLogManager.instance().error(this, \"Error on calling Sun's MMap buffer clean\", e);\r\n          }\r\n        }\r\n\r\n        buffer = null;\r\n      }\r\n      counter = 0;\r\n      file = null;\r\n\r\n    } finally {\r\n      releaseExclusiveLock();\r\n    }\r\n  }","id":33082,"modified_method":"/**\r\n   * Force closing of file if it's opened yet.\r\n   */\r\n  void close() {\r\n    acquireExclusiveLock();\r\n    try {\r\n\r\n      if (buffer != null) {\r\n        if (dirty)\r\n          buffer.force();\r\n\r\n        if (cleanerMethod != null) {\r\n          // USE SUN JVM SPECIAL METHOD TO FREE RESOURCES\r\n          try {\r\n            final Object cleaner = cleanerMethod.invoke(buffer);\r\n            if (cleaner != null)\r\n              cleaner.getClass().getMethod(\"clean\").invoke(cleaner);\r\n          } catch (Exception e) {\r\n            OLogManager.instance().error(this, \"Error on calling Sun's MMap buffer clean\", e);\r\n          }\r\n        }\r\n\r\n        buffer = null;\r\n      }\r\n      lastUsed = 0;\r\n      file = null;\r\n\r\n    } finally {\r\n      releaseExclusiveLock();\r\n    }\r\n  }","commit_id":"df28f29cf0afe030445be099c06e1f7db4aa7997","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void init() {\r\n    Orient\r\n        .instance()\r\n        .getProfiler()\r\n        .registerHookValue(\"system.file.mmap.mappedPages\", \"Number of memory mapped pages used\", METRIC_TYPE.COUNTER,\r\n            new OProfilerHookValue() {\r\n              public Object getValue() {\r\n                return metricMappedPages;\r\n              }\r\n            });\r\n    Orient\r\n        .instance()\r\n        .getProfiler()\r\n        .registerHookValue(\"system.file.mmap.reusedPages\", \"Number of times memory mapped pages have been reused\",\r\n            METRIC_TYPE.COUNTER, new OProfilerHookValue() {\r\n              public Object getValue() {\r\n                return metricReusedPages;\r\n              }\r\n            });\r\n  }","id":33083,"modified_method":"public void init() {\r\n    Orient\r\n        .instance()\r\n        .getProfiler()\r\n        .registerHookValue(\"system.file.mmap.mappedPages\", \"Number of memory mapped pages used\", METRIC_TYPE.COUNTER,\r\n            new OProfilerHookValue() {\r\n              public Object getValue() {\r\n                return metricMappedPages;\r\n              }\r\n            });\r\n    Orient\r\n        .instance()\r\n        .getProfiler()\r\n        .registerHookValue(\"system.file.mmap.reusedPages\", \"Number of times memory mapped pages have been reused\",\r\n            METRIC_TYPE.COUNTER, new OProfilerHookValue() {\r\n              public Object getValue() {\r\n                return metricReusedPages;\r\n              }\r\n            });\r\n\r\n    int autoFlushTimer = OGlobalConfiguration.FILE_MMAP_AUTOFLUSH_TIMER.getValueAsInteger();\r\n    if (autoFlushTimer > 0) {\r\n      autoFlushTimer *= 1000;\r\n      autoFlushUnusedTime = OGlobalConfiguration.FILE_MMAP_AUTOFLUSH_UNUSED_TIME.getValueAsInteger() * 1000;\r\n\r\n      autoFlushTask = new TimerTask() {\r\n        @Override\r\n        public void run() {\r\n          flush();\r\n        }\r\n      };\r\n\r\n      Orient.getTimer().schedule(autoFlushTask, autoFlushTimer, autoFlushTimer);\r\n    }\r\n  }","commit_id":"df28f29cf0afe030445be099c06e1f7db4aa7997","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n   * {@inheritDoc}\r\n   * <p/>\r\n   * Flush all closed files on disk. If some mapped entries not flushed successfully file will be asociated with not flushed\r\n   * entries. When flush will be performed again not flushed records will be flushed again, File information for files which have\r\n   * all records flushed will be removed from mmap manager.\r\n   */\r\n  public void flush() {\r\n    for (Iterator<Map.Entry<OFileMMap, OMMapBufferEntry[]>> it = bufferPoolPerFile.entrySet().iterator(); it.hasNext();) {\r\n      OFileMMap file;\r\n      final Map.Entry<OFileMMap, OMMapBufferEntry[]> mapEntry = it.next();\r\n      file = mapEntry.getKey();\r\n      lockManager.acquireLock(Thread.currentThread(), file, OLockManager.LOCK.EXCLUSIVE);\r\n      try {\r\n        if (file.isClosed()) {\r\n          OMMapBufferEntry[] notFlushed = EMPTY_BUFFER_ENTRIES;\r\n          for (OMMapBufferEntry entry : mapEntry.getValue()) {\r\n            if (!removeEntry(entry)) {\r\n              notFlushed = addEntry(notFlushed, entry);\r\n            }\r\n          }\r\n\r\n          if (notFlushed.length == 0) {\r\n            it.remove();\r\n          } else {\r\n            mapEntry.setValue(notFlushed);\r\n          }\r\n        }\r\n      } finally {\r\n        lockManager.releaseLock(Thread.currentThread(), file, OLockManager.LOCK.EXCLUSIVE);\r\n      }\r\n    }\r\n  }","id":33084,"modified_method":"/**\r\n   * {@inheritDoc}\r\n   * <p/>\r\n   * Flush all closed files on disk. If some mapped entries not flushed successfully file will be associated with not flushed\r\n   * entries. When flush will be performed again not flushed records will be flushed again, File information for files which have\r\n   * all records flushed will be removed from mmap manager.\r\n   */\r\n  public void flush() {\r\n    OLogManager.instance().debug(this, \"[OMMapManagerNew] flushing pages in memory...\");\r\n    int flushedBlocks = 0;\r\n    int totalBlocks = 0;\r\n\r\n    final long now = System.currentTimeMillis();\r\n\r\n    for (Iterator<Map.Entry<OFileMMap, OMMapBufferEntry[]>> it = bufferPoolPerFile.entrySet().iterator(); it.hasNext();) {\r\n      OFileMMap file;\r\n      final Map.Entry<OFileMMap, OMMapBufferEntry[]> mapEntry = it.next();\r\n      file = mapEntry.getKey();\r\n\r\n      // FLUSHES ALL THE BLOCK OF THE FILE\r\n      lockManager.acquireLock(Thread.currentThread(), file, OLockManager.LOCK.EXCLUSIVE);\r\n      try {\r\n        if (autoFlushUnusedTime > 0 || file.isClosed()) {\r\n          OMMapBufferEntry[] notFlushed = EMPTY_BUFFER_ENTRIES;\r\n          for (OMMapBufferEntry entry : mapEntry.getValue()) {\r\n            totalBlocks++;\r\n\r\n            if ((file.isClosed() || autoFlushUnusedTime == 0 || now - entry.getLastUsed() > autoFlushUnusedTime) && removeEntry(entry))\r\n              // OK: FLUSHED\r\n              flushedBlocks++;\r\n            else\r\n              // CANNOT FLUSH AWAY\r\n              notFlushed = addEntry(notFlushed, entry);\r\n          }\r\n\r\n          if (notFlushed.length == 0) {\r\n            it.remove();\r\n          } else {\r\n            mapEntry.setValue(notFlushed);\r\n          }\r\n        }\r\n      } finally {\r\n        lockManager.releaseLock(Thread.currentThread(), file, OLockManager.LOCK.EXCLUSIVE);\r\n      }\r\n\r\n    }\r\n    OLogManager.instance().debug(this, \"[OMMapManagerNew] flushed %d/%d blocks\", flushedBlocks, totalBlocks);\r\n  }","commit_id":"df28f29cf0afe030445be099c06e1f7db4aa7997","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n   * Search for a buffer in the ordered list.\r\n   * \r\n   * @param fileEntries\r\n   *          to search necessary record.\r\n   * @param iBeginOffset\r\n   *          file offset to start search from it.\r\n   * @param iSize\r\n   *          that will be contained in founded entries.\r\n   * @return negative number means not found. The position to insert is the (return value +1)*-1. Zero or positive number is the\r\n   *         found position.\r\n   */\r\n  private static int searchEntry(final List<OMMapBufferEntry> fileEntries, final long iBeginOffset, final int iSize) {\r\n    if (fileEntries == null || fileEntries.size() == 0)\r\n      return -1;\r\n\r\n    int high = fileEntries.size() - 1;\r\n    if (high < 0)\r\n      // NOT FOUND\r\n      return -1;\r\n\r\n    int low = 0;\r\n    int mid = -1;\r\n\r\n    // BINARY SEARCH\r\n    OMMapBufferEntry e;\r\n\r\n    while (low <= high) {\r\n      mid = (low + high) >>> 1;\r\n      e = fileEntries.get(mid);\r\n\r\n      if (iBeginOffset >= e.beginOffset && iBeginOffset + iSize <= e.beginOffset + e.size) {\r\n        // FOUND: USE IT\r\n        metricReusedPages++;\r\n        e.counter++;\r\n        return mid;\r\n      }\r\n\r\n      if (low == high) {\r\n        if (iBeginOffset > e.beginOffset)\r\n          // NEXT POSITION\r\n          low++;\r\n\r\n        // NOT FOUND\r\n        return (low + 2) * -1;\r\n      }\r\n\r\n      if (iBeginOffset >= e.beginOffset)\r\n        low = mid + 1;\r\n      else\r\n        high = mid;\r\n    }\r\n\r\n    // NOT FOUND\r\n    return mid;\r\n  }","id":33085,"modified_method":"/**\r\n   * Search for a buffer in the ordered list.\r\n   * \r\n   * @param fileEntries\r\n   *          to search necessary record.\r\n   * @param iBeginOffset\r\n   *          file offset to start search from it.\r\n   * @param iSize\r\n   *          that will be contained in founded entries.\r\n   * @return negative number means not found. The position to insert is the (return value +1)*-1. Zero or positive number is the\r\n   *         found position.\r\n   */\r\n  private static int searchEntry(final List<OMMapBufferEntry> fileEntries, final long iBeginOffset, final int iSize) {\r\n    if (fileEntries == null || fileEntries.size() == 0)\r\n      return -1;\r\n\r\n    int high = fileEntries.size() - 1;\r\n    if (high < 0)\r\n      // NOT FOUND\r\n      return -1;\r\n\r\n    int low = 0;\r\n    int mid = -1;\r\n\r\n    // BINARY SEARCH\r\n    OMMapBufferEntry e;\r\n\r\n    while (low <= high) {\r\n      mid = (low + high) >>> 1;\r\n      e = fileEntries.get(mid);\r\n\r\n      if (iBeginOffset >= e.beginOffset && iBeginOffset + iSize <= e.beginOffset + e.size) {\r\n        // FOUND: USE IT\r\n        metricReusedPages++;\r\n        e.updateLastUsedTime();\r\n        return mid;\r\n      }\r\n\r\n      if (low == high) {\r\n        if (iBeginOffset > e.beginOffset)\r\n          // NEXT POSITION\r\n          low++;\r\n\r\n        // NOT FOUND\r\n        return (low + 2) * -1;\r\n      }\r\n\r\n      if (iBeginOffset >= e.beginOffset)\r\n        low = mid + 1;\r\n      else\r\n        high = mid;\r\n    }\r\n\r\n    // NOT FOUND\r\n    return mid;\r\n  }","commit_id":"df28f29cf0afe030445be099c06e1f7db4aa7997","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private static void freeResources() {\r\n    final long memoryThreshold = (long) (maxMemory * 0.75);\r\n    final long startingMemory = totalMemory;\r\n\r\n    if (OLogManager.instance().isDebugEnabled())\r\n      OLogManager.instance().debug(null, \"Freeing off-heap memory as mmmap blocks, target is %s...\",\r\n          OFileUtils.getSizeAsString(startingMemory - memoryThreshold));\r\n\r\n    // SORT AS LRU, FIRST = MOST USED\r\n    Collections.sort(bufferPoolLRU, new Comparator<OMMapBufferEntry>() {\r\n      public int compare(final OMMapBufferEntry o1, final OMMapBufferEntry o2) {\r\n        return (int) (o1.counter - o2.counter);\r\n      }\r\n    });\r\n\r\n    // REMOVE THE LESS USED ENTRY AND UPDATE THE TOTAL MEMORY\r\n    for (Iterator<OMMapBufferEntry> it = bufferPoolLRU.iterator(); it.hasNext();) {\r\n      final OMMapBufferEntry entry = it.next();\r\n\r\n      // REMOVE FROM COLLECTIONS\r\n      if (removeEntry(entry))\r\n        it.remove();\r\n\r\n      if (totalMemory < memoryThreshold)\r\n        break;\r\n    }\r\n\r\n    if (OLogManager.instance().isDebugEnabled())\r\n      OLogManager.instance().debug(null, \"Freed off-heap memory as mmmap blocks for %s...\",\r\n          OFileUtils.getSizeAsString(startingMemory - totalMemory));\r\n  }","id":33086,"modified_method":"private static void freeResources() {\r\n    final long memoryThreshold = (long) (maxMemory * 0.75);\r\n    final long startingMemory = totalMemory;\r\n\r\n    if (OLogManager.instance().isDebugEnabled())\r\n      OLogManager.instance().debug(null, \"Freeing off-heap memory as mmmap blocks, target is %s...\",\r\n          OFileUtils.getSizeAsString(startingMemory - memoryThreshold));\r\n\r\n    // SORT AS LRU, FIRST = MOST USED\r\n    Collections.sort(bufferPoolLRU, new Comparator<OMMapBufferEntry>() {\r\n      public int compare(final OMMapBufferEntry o1, final OMMapBufferEntry o2) {\r\n        return (int) (o1.getLastUsed() - o2.getLastUsed());\r\n      }\r\n    });\r\n\r\n    // REMOVE THE LESS USED ENTRY AND UPDATE THE TOTAL MEMORY\r\n    for (Iterator<OMMapBufferEntry> it = bufferPoolLRU.iterator(); it.hasNext();) {\r\n      final OMMapBufferEntry entry = it.next();\r\n\r\n      // REMOVE FROM COLLECTIONS\r\n      if (removeEntry(entry))\r\n        it.remove();\r\n\r\n      if (totalMemory < memoryThreshold)\r\n        break;\r\n    }\r\n\r\n    if (OLogManager.instance().isDebugEnabled())\r\n      OLogManager.instance().debug(null, \"Freed off-heap memory as mmmap blocks for %s...\",\r\n          OFileUtils.getSizeAsString(startingMemory - totalMemory));\r\n  }","commit_id":"df28f29cf0afe030445be099c06e1f7db4aa7997","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private static OMMapBufferEntry searchBetweenLastBlocks(final OFileMMap iFile, final long iBeginOffset, final int iSize) {\r\n    if (!bufferPoolLRU.isEmpty()) {\r\n      // SEARCH IF IT'S BETWEEN THE LAST 5 BLOCK USED: THIS IS THE COMMON CASE ON MASSIVE INSERTION\r\n      final int min = Math.max(bufferPoolLRU.size() - 5, -1);\r\n      for (int i = bufferPoolLRU.size() - 1; i > min; --i) {\r\n        final OMMapBufferEntry e = bufferPoolLRU.get(i);\r\n\r\n        if (e.isValid() && e.file == iFile && iBeginOffset >= e.beginOffset && iBeginOffset + iSize <= e.beginOffset + e.size) {\r\n          // FOUND: USE IT\r\n          metricReusedPagesBetweenLast++;\r\n          e.counter++;\r\n          return e;\r\n        }\r\n      }\r\n    }\r\n    return null;\r\n  }","id":33087,"modified_method":"private static OMMapBufferEntry searchBetweenLastBlocks(final OFileMMap iFile, final long iBeginOffset, final int iSize) {\r\n    if (!bufferPoolLRU.isEmpty()) {\r\n      // SEARCH IF IT'S BETWEEN THE LAST 5 BLOCK USED: THIS IS THE COMMON CASE ON MASSIVE INSERTION\r\n      final int min = Math.max(bufferPoolLRU.size() - 5, -1);\r\n      for (int i = bufferPoolLRU.size() - 1; i > min; --i) {\r\n        final OMMapBufferEntry e = bufferPoolLRU.get(i);\r\n\r\n        if (e.isValid() && e.file == iFile && iBeginOffset >= e.beginOffset && iBeginOffset + iSize <= e.beginOffset + e.size) {\r\n          // FOUND: USE IT\r\n          metricReusedPagesBetweenLast++;\r\n          e.updateLastUsedTime();\r\n          return e;\r\n        }\r\n      }\r\n    }\r\n    return null;\r\n  }","commit_id":"df28f29cf0afe030445be099c06e1f7db4aa7997","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public boolean close(boolean forced) {\n        for (I2PTunnelDCCClient c : _incoming.values()) {\n            c.stop();\n        }\n        _incoming.clear();\n        for (I2PTunnelDCCClient c : _active.values()) {\n            c.stop();\n        }\n        _active.clear();\n        return true;\n    }","id":33088,"modified_method":"public boolean close(boolean forced) {\n        for (I2PTunnelDCCClient c : _incoming.values()) {\n            c.stop();\n        }\n        _incoming.clear();\n        for (I2PTunnelDCCClient c : _active.values()) {\n            c.stop();\n        }\n        _active.clear();\n        _complete.clear();\n        return true;\n    }","commit_id":"f87e3b52e305ed78cd67874d2052355603cf32af","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private void expireInbound() {\n        for (Iterator<I2PTunnelDCCClient> iter = _incoming.values().iterator(); iter.hasNext(); ) {\n            I2PTunnelDCCClient c = iter.next();\n            if (c.getExpires() < _tunnel.getContext().clock().now()) {\n                iter.remove();\n                c.stop();\n            }\n        }\n        // shouldn't need to expire active\n    }","id":33089,"modified_method":"private void expireInbound() {\n        for (Iterator<I2PTunnelDCCClient> iter = _incoming.values().iterator(); iter.hasNext(); ) {\n            I2PTunnelDCCClient c = iter.next();\n            if (c.getExpires() < _tunnel.getContext().clock().now()) {\n                iter.remove();\n                c.stop();\n            }\n        }\n        // shouldn't need to expire active\n        for (Iterator<I2PTunnelDCCClient> iter = _complete.values().iterator(); iter.hasNext(); ) {\n            I2PTunnelDCCClient c = iter.next();\n            if (c.getExpires() < _tunnel.getContext().clock().now()) {\n                iter.remove();\n                c.stop();\n            }\n        }\n    }","commit_id":"f87e3b52e305ed78cd67874d2052355603cf32af","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private void connStarted(I2PTunnelDCCClient client) {\n        Integer lport = Integer.valueOf(client.getLocalPort());\n        I2PTunnelDCCClient c = _incoming.remove(lport);\n        if (c != null) {\n            _active.put(lport, client);\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"Added client tunnel for port \" + lport +\n                          \" pending count now: \" + _incoming.size() +\n                          \" active count now: \" + _active.size());\n        }\n    }","id":33090,"modified_method":"private void connStarted(I2PTunnelDCCClient client) {\n        Integer lport = Integer.valueOf(client.getLocalPort());\n        I2PTunnelDCCClient c = _incoming.remove(lport);\n        if (c != null) {\n            _active.put(lport, client);\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"Added client tunnel for port \" + lport +\n                          \" pending count now: \" + _incoming.size() +\n                          \" active count now: \" + _active.size() +\n                          \" complete count now: \" + _complete.size());\n        }\n    }","commit_id":"f87e3b52e305ed78cd67874d2052355603cf32af","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private void connStopped(Integer lport) {\n        _incoming.remove(lport);\n        _active.remove(lport);\n        if (_log.shouldLog(Log.WARN))\n            _log.warn(\"Removed client tunnel for port \" + lport +\n                      \" pending count now: \" + _incoming.size() +\n                      \" active count now: \" + _active.size());\n    }","id":33091,"modified_method":"private void connStopped(Integer lport) {\n        I2PTunnelDCCClient tun = _incoming.remove(lport);\n        if (tun != null)\n            _complete.put(lport, tun);\n        tun = _active.remove(lport);\n        if (tun != null)\n            _complete.put(lport, tun);\n        if (_log.shouldLog(Log.WARN))\n            _log.warn(\"Removed client tunnel for port \" + lport +\n                      \" pending count now: \" + _incoming.size() +\n                      \" active count now: \" + _active.size() +\n                      \" complete count now: \" + _complete.size());\n    }","commit_id":"f87e3b52e305ed78cd67874d2052355603cf32af","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public DCCClientManager(I2PSocketManager sktMgr, Logging logging,\n                            EventDispatcher dispatch, I2PTunnel tunnel) {\n        sockMgr = sktMgr;\n        l = logging;\n        _dispatch = dispatch;\n        _tunnel = tunnel;\n        _log = tunnel.getContext().logManager().getLog(DCCClientManager.class);\n        _incoming = new ConcurrentHashMap(8);\n        _active = new ConcurrentHashMap(8);\n    }","id":33092,"modified_method":"public DCCClientManager(I2PSocketManager sktMgr, Logging logging,\n                            EventDispatcher dispatch, I2PTunnel tunnel) {\n        sockMgr = sktMgr;\n        l = logging;\n        _dispatch = dispatch;\n        _tunnel = tunnel;\n        _log = tunnel.getContext().logManager().getLog(DCCClientManager.class);\n        _incoming = new ConcurrentHashMap(8);\n        _active = new ConcurrentHashMap(8);\n        _complete = new ConcurrentHashMap(8);\n    }","commit_id":"f87e3b52e305ed78cd67874d2052355603cf32af","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  An incoming DCC request\n     *\n     *  @param b32 remote dcc server address\n     *  @param port remote dcc server port\n     *  @param type ignored\n     *  @return local server port or -1 on error\n     */\n    public int newIncoming(String b32, int port, String type) {\n        expireInbound();\n        if (_incoming.size() >= MAX_INCOMING_PENDING ||\n            _active.size() >= MAX_INCOMING_PENDING) {\n            _log.error(\"Too many incoming DCC, max is \" + MAX_INCOMING_PENDING +\n                       '/' + MAX_INCOMING_ACTIVE + \" pending/active\");\n            return -1;\n        }\n        try {\n            // Transparent tunnel used for all types...\n            // Do we need to do any filtering for chat?\n            I2PTunnelDCCClient cTunnel = new I2PTunnelDCCClient(b32, port, l, sockMgr,\n                                                                _dispatch, _tunnel, ++_id);\n            cTunnel.attachEventDispatcher(this);\n            int lport = cTunnel.getLocalPort();\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"Opened client tunnel at port \" + lport +\n                          \" pointing to \" + b32 + ':' + port);\n            _incoming.put(Integer.valueOf(lport), cTunnel);\n            return lport;\n        } catch (IllegalArgumentException uhe) {\n            l.log(\"Could not find listen host to bind to [\" + _tunnel.host + \"]\");\n            _log.error(\"Error finding host to bind\", uhe);\n            return -1;\n        }\n    }","id":33093,"modified_method":"/**\n     *  An incoming DCC request\n     *\n     *  @param b32 remote dcc server b32 address\n     *  @param port remote dcc server I2P port\n     *  @param type ignored\n     *  @return local DCC client tunnel port or -1 on error\n     */\n    public int newIncoming(String b32, int port, String type) {\n        return newIncoming(b32, port, type, 0);\n    }","commit_id":"f87e3b52e305ed78cd67874d2052355603cf32af","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"@Override\n        public void run() {\n            notifyEvent(CONNECT_START_EVENT, I2PTunnelDCCClient.this);\n            super.run();\n            notifyEvent(CONNECT_STOP_EVENT, Integer.valueOf(getLocalPort()));\n        }","id":33094,"modified_method":"@Override\n        public void run() {\n            _expires = getTunnel().getContext().clock().now() + INBOUND_STOP_EXPIRE;\n            notifyEvent(CONNECT_START_EVENT, I2PTunnelDCCClient.this);\n            super.run();\n            _expires = getTunnel().getContext().clock().now() + INBOUND_STOP_EXPIRE;\n            notifyEvent(CONNECT_STOP_EVENT, Integer.valueOf(getLocalPort()));\n        }","commit_id":"f87e3b52e305ed78cd67874d2052355603cf32af","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * @param dest the target, presumably b32\n     * @throws IllegalArgumentException if the I2PTunnel does not contain\n     *                                  valid config to contact the router\n     */\n    public I2PTunnelDCCClient(String dest, int remotePort, Logging l,\n                           I2PSocketManager sktMgr, EventDispatcher notifyThis, \n                           I2PTunnel tunnel, long clientId) throws IllegalArgumentException {\n        super(0, l, sktMgr, tunnel, notifyThis, clientId);\n        _dest = dest;\n        _remotePort = remotePort;\n        _expires = tunnel.getContext().clock().now() + INBOUND_EXPIRE;\n\n        setName(\"DCC send -> \" + dest + ':' + remotePort);\n\n        startRunning();\n    }","id":33095,"modified_method":"/**\n     * @param dest the target, presumably b32\n     * @param localPort if 0, use any port, get actual port selected with getLocalPort()\n     * @throws IllegalArgumentException if the I2PTunnel does not contain\n     *                                  valid config to contact the router\n     */\n    public I2PTunnelDCCClient(String dest, int localPort, int remotePort, Logging l,\n                           I2PSocketManager sktMgr, EventDispatcher notifyThis, \n                           I2PTunnel tunnel, long clientId) throws IllegalArgumentException {\n        super(localPort, l, sktMgr, tunnel, notifyThis, clientId);\n        _dest = dest;\n        _remotePort = remotePort;\n        _expires = tunnel.getContext().clock().now() + INBOUND_EXPIRE;\n\n        setName(\"DCC send -> \" + dest + ':' + remotePort);\n\n        startRunning();\n    }","commit_id":"f87e3b52e305ed78cd67874d2052355603cf32af","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  An incoming DCC connection, only accept for a known port.\n     *  Passed through without filtering.\n     */\n    @Override\n    protected void blockingHandle(I2PSocket socket) {\n        if (_log.shouldLog(Log.INFO))\n            _log.info(\"Incoming connection to '\" + toString() + \"' from: \" + socket.getPeerDestination().calculateHash().toBase64());\n\n        try {\n            expireOutbound();\n            int myPort = socket.getLocalPort();\n            // Port is a one-time-use only\n            LocalAddress local = _outgoing.remove(Integer.valueOf(myPort));\n            if (local == null) {\n                if (_log.shouldLog(Log.WARN))\n                    _log.warn(\"Rejecting incoming DCC connection for unknown port \" + myPort);\n                try {\n                    socket.close();\n                } catch (IOException ioe) {}\n                return;\n            }\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"Incoming DCC connection for I2P port \" + myPort +\n                          \" sending to \" + local.ia + ':' + local.port);\n            Socket s = new Socket(local.ia, local.port);\n            new I2PTunnelRunner(s, socket, slock, null, null);\n            _active.put(Integer.valueOf(myPort), socket);\n        } catch (SocketException ex) {\n            try {\n                socket.close();\n            } catch (IOException ioe) {}\n            if (_log.shouldLog(Log.ERROR))\n                _log.error(\"Error connecting to server \" + remoteHost + ':' + remotePort, ex);\n        } catch (IOException ex) {\n            _log.error(\"Error while waiting for I2PConnections\", ex);\n        }\n    }","id":33096,"modified_method":"/**\n     *  An incoming DCC connection, only accept for a known port.\n     *  Passed through without filtering.\n     */\n    @Override\n    protected void blockingHandle(I2PSocket socket) {\n        if (_log.shouldLog(Log.INFO))\n            _log.info(\"Incoming connection to '\" + toString() + \"' from: \" + socket.getPeerDestination().calculateHash().toBase64());\n\n        try {\n            expireOutbound();\n            int myPort = socket.getLocalPort();\n            // Port is a one-time-use only\n            LocalAddress local = _outgoing.remove(Integer.valueOf(myPort));\n            if (local == null) {\n                if (_log.shouldLog(Log.WARN))\n                    _log.warn(\"Rejecting incoming DCC connection for unknown port \" + myPort);\n                try {\n                    socket.close();\n                } catch (IOException ioe) {}\n                return;\n            }\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"Incoming DCC connection for I2P port \" + myPort +\n                          \" sending to \" + local.ia + ':' + local.port);\n            Socket s = new Socket(local.ia, local.port);\n            _sockList.add(socket);\n            new I2PTunnelRunner(s, socket, slock, null, _sockList);\n            local.socket = socket;\n            local.expire = getTunnel().getContext().clock().now() + OUTBOUND_EXPIRE;\n            _active.put(Integer.valueOf(myPort), local);\n        } catch (SocketException ex) {\n            try {\n                socket.close();\n            } catch (IOException ioe) {}\n            if (_log.shouldLog(Log.ERROR))\n                _log.error(\"Error connecting to server \" + remoteHost + ':' + remotePort, ex);\n        } catch (IOException ex) {\n            _log.error(\"Error while waiting for I2PConnections\", ex);\n        }\n    }","commit_id":"f87e3b52e305ed78cd67874d2052355603cf32af","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  An outgoing DCC request\n     *\n     *  @param ip local irc client IP\n     *  @param port local irc client port\n     *  @param type ignored\n     *  @return i2p port or -1 on error\n     */\n    public int newOutgoing(byte[] ip, int port, String type) {\n        expireOutbound();\n        if (_outgoing.size() >= MAX_OUTGOING_PENDING ||\n            _active.size() >= MAX_OUTGOING_ACTIVE) {\n            _log.error(\"Too many outgoing DCC, max is \" + MAX_OUTGOING_PENDING +\n                       '/' + MAX_OUTGOING_ACTIVE + \" pending/active\");\n            return -1;\n        }\n        InetAddress ia;\n        try {\n            ia = InetAddress.getByAddress(ip);\n        } catch (UnknownHostException uhe) {\n            return -1;\n        }\n        LocalAddress client = new LocalAddress(ia, port, getTunnel().getContext().clock().now() + OUTBOUND_EXPIRE);\n        for (int i = 0; i < 10; i++) {\n            int iport = MIN_I2P_PORT + getTunnel().getContext().random().nextInt(1 + MAX_I2P_PORT - MIN_I2P_PORT);\n            if (_active.containsKey(Integer.valueOf(iport)))\n                continue;\n            LocalAddress old = _outgoing.putIfAbsent(Integer.valueOf(iport), client);\n            if (old != null)\n                continue;\n            // TODO expire in a few minutes\n            return iport;\n        }\n        // couldn't find an unused i2p port\n        return -1;\n    }","id":33097,"modified_method":"/**\n     *  An outgoing DCC request\n     *\n     *  @param ip local irc client IP\n     *  @param port local irc client port\n     *  @param type ignored\n     *  @return i2p port or -1 on error\n     */\n    public int newOutgoing(byte[] ip, int port, String type) {\n        return newOutgoing(ip, port, type, 0);\n    }","commit_id":"f87e3b52e305ed78cd67874d2052355603cf32af","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * There's no support for unsolicited incoming I2P connections,\n     * so there's no server host or port parameters.\n     *\n     * @param sktMgr an existing socket manager\n     * @throws IllegalArgumentException if the I2PTunnel does not contain\n     *                                  valid config to contact the router\n     */\n    public I2PTunnelDCCServer(I2PSocketManager sktMgr, Logging l,\n                              EventDispatcher notifyThis, I2PTunnel tunnel) {\n        super(DUMMY, 0, sktMgr, l, notifyThis, tunnel);\n        _outgoing = new ConcurrentHashMap(8);\n        _active = new ConcurrentHashMap(8);\n    }","id":33098,"modified_method":"/**\n     * There's no support for unsolicited incoming I2P connections,\n     * so there's no server host or port parameters.\n     *\n     * @param sktMgr an existing socket manager\n     * @throws IllegalArgumentException if the I2PTunnel does not contain\n     *                                  valid config to contact the router\n     */\n    public I2PTunnelDCCServer(I2PSocketManager sktMgr, Logging l,\n                              EventDispatcher notifyThis, I2PTunnel tunnel) {\n        super(DUMMY, 0, sktMgr, l, notifyThis, tunnel);\n        _outgoing = new ConcurrentHashMap(8);\n        _active = new ConcurrentHashMap(8);\n        _resume = new ConcurrentHashMap(8);\n        _sockList = new CopyOnWriteArrayList();\n    }","commit_id":"f87e3b52e305ed78cd67874d2052355603cf32af","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private void expireOutbound() {\n        for (Iterator<LocalAddress> iter = _outgoing.values().iterator(); iter.hasNext(); ) {\n            LocalAddress a = iter.next();\n            if (a.expire < getTunnel().getContext().clock().now())\n                iter.remove();\n        }\n        for (Iterator<I2PSocket> iter = _active.values().iterator(); iter.hasNext(); ) {\n            I2PSocket s = iter.next();\n            if (s.isClosed())\n                iter.remove();\n        }\n    }","id":33099,"modified_method":"private void expireOutbound() {\n        for (Iterator<LocalAddress> iter = _outgoing.values().iterator(); iter.hasNext(); ) {\n            LocalAddress a = iter.next();\n            if (a.expire < getTunnel().getContext().clock().now())\n                iter.remove();\n        }\n        for (Iterator<LocalAddress> iter = _active.values().iterator(); iter.hasNext(); ) {\n            LocalAddress a = iter.next();\n            I2PSocket s = a.socket;\n            if (s != null && s.isClosed())\n                iter.remove();\n        }\n    }","commit_id":"f87e3b52e305ed78cd67874d2052355603cf32af","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"@Override\n    public boolean close(boolean forced) {\n        _outgoing.clear();\n        _active.clear();\n        return super.close(forced);\n    }","id":33100,"modified_method":"@Override\n    public boolean close(boolean forced) {\n        _outgoing.clear();\n        _active.clear();\n        for (I2PSocket s : _sockList) {\n            try {\n                s.close();\n            } catch (IOException ioe) {}\n        }\n        _sockList.clear();\n        return super.close(forced);\n    }","commit_id":"f87e3b52e305ed78cd67874d2052355603cf32af","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public int acceptIncoming(int port) {\n        return -1;\n    }","id":33101,"modified_method":"public int acceptIncoming(int port) {\n        DCCClientManager tracker = _DCCClientManager;\n        if (tracker != null)\n            return tracker.acceptIncoming(port);\n        return -1;\n    }","commit_id":"f87e3b52e305ed78cd67874d2052355603cf32af","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public int acceptOutgoing(int port) {\n        return -1;\n    }","id":33102,"modified_method":"public int acceptOutgoing(int port) {\n        I2PTunnelDCCServer server = _DCCServer;\n        if (server != null)\n            return server.acceptOutgoing(port);\n        return -1;\n    }","commit_id":"f87e3b52e305ed78cd67874d2052355603cf32af","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public int resumeOutgoing(int port) {\n        return -1;\n    }","id":33103,"modified_method":"public int resumeOutgoing(int port) {\n        DCCClientManager tracker = _DCCClientManager;\n        if (tracker != null)\n            return tracker.resumeOutgoing(port);\n        return -1;\n    }","commit_id":"f87e3b52e305ed78cd67874d2052355603cf32af","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public int resumeIncoming(int port) {\n        return -1;\n    }","id":33104,"modified_method":"public int resumeIncoming(int port) {\n        I2PTunnelDCCServer server = _DCCServer;\n        if (server != null)\n            return server.resumeIncoming(port);\n        return -1;\n    }","commit_id":"f87e3b52e305ed78cd67874d2052355603cf32af","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"@Override\n        public void run() {\n            if (pool.isClosed()) {\n                if (pool.getSize() <= 0) {\n                    run = false;\n                }\n            } else if ((System.currentTimeMillis() - lastRun) > sleepTime) {\n                lastRun = System.currentTimeMillis();\n                try {\n                    if (pool.getPoolProperties().isRemoveAbandoned())\n                        pool.checkAbandoned();\n                    if (pool.getPoolProperties().getMinIdle() < pool.idle\n                            .size())\n                        pool.checkIdle();\n                    if (pool.getPoolProperties().isTestWhileIdle())\n                        pool.testAllIdle();\n                } catch (Exception x) {\n                    log.error(\"\", x);\n                } // catch\n            } // end if\n        }","id":33105,"modified_method":"@Override\n        public void run() {\n            ConnectionPool pool = this.pool.get();\n            if (pool == null) {\n                stopRunning();\n            } else if (!pool.isClosed() &&\n                    (System.currentTimeMillis() - lastRun) > sleepTime) {\n                lastRun = System.currentTimeMillis();\n                try {\n                    if (pool.getPoolProperties().isRemoveAbandoned())\n                        pool.checkAbandoned();\n                    if (pool.getPoolProperties().getMinIdle() < pool.idle\n                            .size())\n                        pool.checkIdle();\n                    if (pool.getPoolProperties().isTestWhileIdle())\n                        pool.testAllIdle();\n                } catch (Exception x) {\n                    log.error(\"\", x);\n                }\n            }\n        }","commit_id":"a81538dd6eb18a06120c8c8826246dafe2c5bbf8","url":"https://github.com/apache/tomcat"},{"original_method":"PoolCleaner(ConnectionPool pool, long sleepTime) {\n            this.pool = pool;\n            this.sleepTime = sleepTime;\n            if (sleepTime <= 0) {\n                log.warn(\"Database connection pool evicter thread interval is set to 0, defaulting to 30 seconds\");\n                this.sleepTime = 1000 * 30;\n            } else if (sleepTime < 1000) {\n                log.warn(\"Database connection pool evicter thread interval is set to lower than 1 second.\");\n            }\n        }","id":33106,"modified_method":"PoolCleaner(ConnectionPool pool, long sleepTime) {\n            this.pool = new WeakReference<>(pool);\n            this.sleepTime = sleepTime;\n            if (sleepTime <= 0) {\n                log.warn(\"Database connection pool evicter thread interval is set to 0, defaulting to 30 seconds\");\n                this.sleepTime = 1000 * 30;\n            } else if (sleepTime < 1000) {\n                log.warn(\"Database connection pool evicter thread interval is set to lower than 1 second.\");\n            }\n        }","commit_id":"a81538dd6eb18a06120c8c8826246dafe2c5bbf8","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n        public void onFillable()\n        {\n            try\n            {\n                ByteBuffer buffer = BufferUtil.allocate(4);\n                int filled = getEndPoint().fill(buffer);\n                Assert.assertEquals(4, filled);\n                Assert.assertArrayEquals(CAFE_BABE, buffer.array());\n                getEndPoint().write(new Callback.Adapter(), buffer);\n\n                // We are good, upgrade the connection\n                ClientConnectionFactory.Helper.replaceConnection(this, connectionFactory.newConnection(connector, getEndPoint()));\n            }\n            catch (Throwable x)\n            {\n                close();\n            }\n        }","id":33107,"modified_method":"@Override\n        public void onFillable()\n        {\n            try\n            {\n                ByteBuffer buffer = BufferUtil.allocate(4);\n                int filled = getEndPoint().fill(buffer);\n                Assert.assertEquals(4, filled);\n                Assert.assertArrayEquals(CAFE_BABE, buffer.array());\n                getEndPoint().write(Callback.NOOP, buffer);\n\n                // We are good, upgrade the connection\n                getEndPoint().upgrade(connectionFactory.newConnection(connector, getEndPoint()));\n            }\n            catch (Throwable x)\n            {\n                close();\n            }\n        }","commit_id":"3fc6320881e7463cb2976388f250e4536d926d1b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n        public void onOpen()\n        {\n            super.onOpen();\n            fillInterested();\n            getEndPoint().write(new Callback.Adapter(), ByteBuffer.wrap(CAFE_BABE));\n        }","id":33108,"modified_method":"@Override\n        public void onOpen()\n        {\n            super.onOpen();\n            fillInterested();\n            getEndPoint().write(Callback.NOOP, ByteBuffer.wrap(CAFE_BABE));\n        }","commit_id":"3fc6320881e7463cb2976388f250e4536d926d1b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n        public void onFillable()\n        {\n            try\n            {\n                ByteBuffer buffer = BufferUtil.allocate(4);\n                int filled = getEndPoint().fill(buffer);\n                Assert.assertEquals(4, filled);\n                Assert.assertArrayEquals(CAFE_BABE, buffer.array());\n\n                // We are good, upgrade the connection\n                ClientConnectionFactory.Helper.replaceConnection(this, connectionFactory.newConnection(getEndPoint(), context));\n            }\n            catch (Throwable x)\n            {\n                close();\n                @SuppressWarnings(\"unchecked\")\n                Promise<Connection> promise = (Promise<Connection>)context.get(HttpClientTransport.HTTP_CONNECTION_PROMISE_CONTEXT_KEY);\n                promise.failed(x);\n            }\n        }","id":33109,"modified_method":"@Override\n        public void onFillable()\n        {\n            try\n            {\n                ByteBuffer buffer = BufferUtil.allocate(4);\n                int filled = getEndPoint().fill(buffer);\n                Assert.assertEquals(4, filled);\n                Assert.assertArrayEquals(CAFE_BABE, buffer.array());\n\n                // We are good, upgrade the connection\n                getEndPoint().upgrade(connectionFactory.newConnection(getEndPoint(), context));\n            }\n            catch (Throwable x)\n            {\n                close();\n                @SuppressWarnings(\"unchecked\")\n                Promise<Connection> promise = (Promise<Connection>)context.get(HttpClientTransport.HTTP_CONNECTION_PROMISE_CONTEXT_KEY);\n                promise.failed(x);\n            }\n        }","commit_id":"3fc6320881e7463cb2976388f250e4536d926d1b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void tunnelSucceeded()\n            {\n                try\n                {\n                    // Replace the promise back with the original\n                    context.put(HttpClientTransport.HTTP_CONNECTION_PROMISE_CONTEXT_KEY, promise);\n                    HttpDestination destination = (HttpDestination)context.get(HttpClientTransport.HTTP_DESTINATION_CONTEXT_KEY);\n                    HttpClient client = destination.getHttpClient();\n                    ClientConnectionFactory sslConnectionFactory = new SslClientConnectionFactory(client.getSslContextFactory(), client.getByteBufferPool(), client.getExecutor(), connectionFactory);\n                    HttpConnectionOverHTTP oldConnection = (HttpConnectionOverHTTP)endPoint.getConnection();\n                    org.eclipse.jetty.io.Connection newConnection = sslConnectionFactory.newConnection(endPoint, context);\n                    Helper.replaceConnection(oldConnection, newConnection);\n                    // Avoid setting fill interest in the old Connection,\n                    // without closing the underlying EndPoint.\n                    oldConnection.softClose();\n                    if (LOG.isDebugEnabled())\n                        LOG.debug(\"HTTP tunnel established: {} over {}\", oldConnection, newConnection);\n                }\n                catch (Throwable x)\n                {\n                    tunnelFailed(x);\n                }\n            }","id":33110,"modified_method":"private void tunnelSucceeded()\n            {\n                try\n                {\n                    // Replace the promise back with the original\n                    context.put(HttpClientTransport.HTTP_CONNECTION_PROMISE_CONTEXT_KEY, promise);\n                    HttpDestination destination = (HttpDestination)context.get(HttpClientTransport.HTTP_DESTINATION_CONTEXT_KEY);\n                    HttpClient client = destination.getHttpClient();\n                    ClientConnectionFactory sslConnectionFactory = new SslClientConnectionFactory(client.getSslContextFactory(), client.getByteBufferPool(), client.getExecutor(), connectionFactory);\n                    HttpConnectionOverHTTP oldConnection = (HttpConnectionOverHTTP)endPoint.getConnection();\n                    org.eclipse.jetty.io.Connection newConnection = sslConnectionFactory.newConnection(endPoint, context);\n                    endPoint.upgrade(newConnection);\n                    if (LOG.isDebugEnabled())\n                        LOG.debug(\"HTTP tunnel established: {} over {}\", oldConnection, newConnection);\n                }\n                catch (Throwable x)\n                {\n                    tunnelFailed(x);\n                }\n            }","commit_id":"3fc6320881e7463cb2976388f250e4536d926d1b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void process()\n    {\n        try\n        {\n            HttpConnectionOverHTTP connection = getHttpConnection();\n            EndPoint endPoint = connection.getEndPoint();\n            while (true)\n            {\n                // Connection may be closed in a parser callback.\n                if (connection.isClosed())\n                {\n                    if (LOG.isDebugEnabled())\n                        LOG.debug(\"{} closed\", connection);\n                    releaseBuffer();\n                    return;\n                }\n\n                if (parse())\n                    return;\n\n                int read = endPoint.fill(buffer);\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"Read {} bytes {} from {}\", read, BufferUtil.toDetailString(buffer), endPoint);\n\n                if (read > 0)\n                {\n                    if (parse())\n                        return;\n                }\n                else if (read == 0)\n                {\n                    releaseBuffer();\n                    fillInterested();\n                    return;\n                }\n                else\n                {\n                    releaseBuffer();\n                    shutdown();\n                    return;\n                }\n            }\n        }\n        catch (Throwable x)\n        {\n            if (LOG.isDebugEnabled())\n                LOG.debug(x);\n            BufferUtil.clear(buffer);\n            if (buffer != null)\n                releaseBuffer();\n            failAndClose(x);\n        }\n    }","id":33111,"modified_method":"private void process()\n    {\n        try\n        {\n            HttpConnectionOverHTTP connection = getHttpConnection();\n            EndPoint endPoint = connection.getEndPoint();\n            while (true)\n            {\n                boolean upgraded = connection != endPoint.getConnection();\n\n                // Connection may be closed or upgraded in a parser callback.\n                if (connection.isClosed() || upgraded)\n                {\n                    if (LOG.isDebugEnabled())\n                        LOG.debug(\"{} {}\", connection, upgraded ? \"upgraded\" : \"closed\");\n                    releaseBuffer();\n                    return;\n                }\n\n                if (parse())\n                    return;\n\n                int read = endPoint.fill(buffer);\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"Read {} bytes {} from {}\", read, BufferUtil.toDetailString(buffer), endPoint);\n\n                if (read > 0)\n                {\n                    if (parse())\n                        return;\n                }\n                else if (read == 0)\n                {\n                    releaseBuffer();\n                    fillInterested();\n                    return;\n                }\n                else\n                {\n                    releaseBuffer();\n                    shutdown();\n                    return;\n                }\n            }\n        }\n        catch (Throwable x)\n        {\n            if (LOG.isDebugEnabled())\n                LOG.debug(x);\n            BufferUtil.clear(buffer);\n            if (buffer != null)\n                releaseBuffer();\n            failAndClose(x);\n        }\n    }","commit_id":"3fc6320881e7463cb2976388f250e4536d926d1b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Before\n    public void init() throws Exception\n    {\n        client = new HttpClient();\n        client.start();\n        destination = new HttpDestinationOverHTTP(client, new Origin(\"http\", \"localhost\", 8080));\n        endPoint = new ByteArrayEndPoint();\n        connection = new HttpConnectionOverHTTP(endPoint, destination, new Promise.Adapter<Connection>());\n    }","id":33112,"modified_method":"@Before\n    public void init() throws Exception\n    {\n        client = new HttpClient();\n        client.start();\n        destination = new HttpDestinationOverHTTP(client, new Origin(\"http\", \"localhost\", 8080));\n        endPoint = new ByteArrayEndPoint();\n        connection = new HttpConnectionOverHTTP(endPoint, destination, new Promise.Adapter<>());\n        endPoint.setConnection(connection);\n    }","commit_id":"3fc6320881e7463cb2976388f250e4536d926d1b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void test_FillInterested_RacingWith_BufferRelease() throws Exception\n    {\n        connection = new HttpConnectionOverHTTP(endPoint, destination, new Promise.Adapter<Connection>())\n        {\n            @Override\n            protected HttpChannelOverHTTP newHttpChannel()\n            {\n                return new HttpChannelOverHTTP(this)\n                {\n                    @Override\n                    protected HttpReceiverOverHTTP newHttpReceiver()\n                    {\n                        return new HttpReceiverOverHTTP(this)\n                        {\n                            @Override\n                            protected void fillInterested()\n                            {\n                                // Verify that the buffer has been released\n                                // before fillInterested() is called.\n                                Assert.assertNull(getResponseBuffer());\n                                // Fill the endpoint so receive is called again.\n                                endPoint.addInput(\"X\");\n                                super.fillInterested();\n                            }\n                        };\n                    }\n                };\n            }\n        };\n        \n        // Partial response to trigger the call to fillInterested().\n        endPoint.addInput(\"\" +\n                \"HTTP/1.1 200 OK\\r\\n\" +\n                \"Content-Length: 1\\r\\n\" +\n                \"\\r\\n\");\n\n        HttpExchange exchange = newExchange();\n        FutureResponseListener listener = (FutureResponseListener)exchange.getResponseListeners().get(0);\n        connection.getHttpChannel().receive();\n\n        Response response = listener.get(5, TimeUnit.SECONDS);\n        Assert.assertNotNull(response);\n        Assert.assertEquals(200, response.getStatus());\n    }","id":33113,"modified_method":"@Test\n    public void test_FillInterested_RacingWith_BufferRelease() throws Exception\n    {\n        connection = new HttpConnectionOverHTTP(endPoint, destination, new Promise.Adapter<>())\n        {\n            @Override\n            protected HttpChannelOverHTTP newHttpChannel()\n            {\n                return new HttpChannelOverHTTP(this)\n                {\n                    @Override\n                    protected HttpReceiverOverHTTP newHttpReceiver()\n                    {\n                        return new HttpReceiverOverHTTP(this)\n                        {\n                            @Override\n                            protected void fillInterested()\n                            {\n                                // Verify that the buffer has been released\n                                // before fillInterested() is called.\n                                Assert.assertNull(getResponseBuffer());\n                                // Fill the endpoint so receive is called again.\n                                endPoint.addInput(\"X\");\n                                super.fillInterested();\n                            }\n                        };\n                    }\n                };\n            }\n        };\n        endPoint.setConnection(connection);\n\n        // Partial response to trigger the call to fillInterested().\n        endPoint.addInput(\"\" +\n                \"HTTP/1.1 200 OK\\r\\n\" +\n                \"Content-Length: 1\\r\\n\" +\n                \"\\r\\n\");\n\n        HttpExchange exchange = newExchange();\n        FutureResponseListener listener = (FutureResponseListener)exchange.getResponseListeners().get(0);\n        connection.getHttpChannel().receive();\n\n        Response response = listener.get(5, TimeUnit.SECONDS);\n        Assert.assertNotNull(response);\n        Assert.assertEquals(200, response.getStatus());\n    }","commit_id":"3fc6320881e7463cb2976388f250e4536d926d1b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void replaceConnection()\n    {\n        EndPoint endPoint = getEndPoint();\n        try\n        {\n            Connection oldConnection = endPoint.getConnection();\n            Connection newConnection = connectionFactory.newConnection(endPoint, context);\n            ClientConnectionFactory.Helper.replaceConnection(oldConnection, newConnection);\n        }\n        catch (Throwable x)\n        {\n            LOG.debug(x);\n            close();\n        }\n    }","id":33114,"modified_method":"private void replaceConnection()\n    {\n        EndPoint endPoint = getEndPoint();\n        try\n        {\n            endPoint.upgrade(connectionFactory.newConnection(endPoint, context));\n        }\n        catch (Throwable x)\n        {\n            LOG.debug(x);\n            close();\n        }\n    }","commit_id":"3fc6320881e7463cb2976388f250e4536d926d1b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void tunnel()\n        {\n            try\n            {\n                HttpDestination destination = (HttpDestination)context.get(HttpClientTransport.HTTP_DESTINATION_CONTEXT_KEY);\n                HttpClient client = destination.getHttpClient();\n                ClientConnectionFactory connectionFactory = this.connectionFactory;\n                if (HttpScheme.HTTPS.is(destination.getScheme()))\n                    connectionFactory = new SslClientConnectionFactory(client.getSslContextFactory(), client.getByteBufferPool(), client.getExecutor(), connectionFactory);\n                org.eclipse.jetty.io.Connection connection = connectionFactory.newConnection(getEndPoint(), context);\n                ClientConnectionFactory.Helper.replaceConnection(this, connection);\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"SOCKS4 tunnel established: {} over {}\", this, connection);\n            }\n            catch (Throwable x)\n            {\n                failed(x);\n            }\n        }","id":33115,"modified_method":"private void tunnel()\n        {\n            try\n            {\n                HttpDestination destination = (HttpDestination)context.get(HttpClientTransport.HTTP_DESTINATION_CONTEXT_KEY);\n                HttpClient client = destination.getHttpClient();\n                ClientConnectionFactory connectionFactory = this.connectionFactory;\n                if (HttpScheme.HTTPS.is(destination.getScheme()))\n                    connectionFactory = new SslClientConnectionFactory(client.getSslContextFactory(), client.getByteBufferPool(), client.getExecutor(), connectionFactory);\n                org.eclipse.jetty.io.Connection newConnection = connectionFactory.newConnection(getEndPoint(), context);\n                getEndPoint().upgrade(newConnection);\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"SOCKS4 tunnel established: {} over {}\", this, newConnection);\n            }\n            catch (Throwable x)\n            {\n                failed(x);\n            }\n        }","commit_id":"3fc6320881e7463cb2976388f250e4536d926d1b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n  public int getSessionNonce(int id) throws RuntimeException {\n    Preconditions.checkNotNull(accountDAO,\"Account data access objects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO,\"Nonce data access objects cannot be null\");\n\n    try {\n      return nonceDAO.getNonce(id, NonceDAO.NONCE_TYPE.SESSION);\n    } catch (Exception e) {\n      throw new RuntimeException(e.getMessage());\n    }\n\n  }","id":33116,"modified_method":"@Override\n  public int getSessionNonce(int id) {\n    Preconditions.checkNotNull(accountDAO,\"Account data access objects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO, \"Nonce data access objects cannot be null\");\n    int nonce = -1 ;\n    try {\n      nonce =  nonceDAO.getNonce(id, NonceDAO.NONCE_TYPE.SESSION);\n    } catch (Exception e) {\n      Throwables.propagate(e);\n    }\n    return nonce;\n  }","commit_id":"46e6123b4ad61dbe0347a90c38d8e9b6f4740a43","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Register an {@code Account} in the system\n   *\n   * @param account Account information\n   * @return Instance of {@code Status}\n   * @throws RuntimeException\n   */\n  @Override\n  public Account registerAccount(Account account) throws RuntimeException, AccountAlreadyExistsException {\n    Preconditions.checkNotNull(accountDAO,\"Account data accessobjects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO,\"Nonce data access objects cannot be null\");\n\n    try {\n      return accountDAO.createAccount(account);\n    } catch (ConfigurationException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n  }","id":33117,"modified_method":"/**\n   * Register an {@code Account} in the system\n   *\n   * @param account Account information\n   * @return Instance of {@code Status}\n   */\n  @Override\n  public Account registerAccount(Account account) throws AccountAlreadyExistsException {\n    Preconditions.checkNotNull(accountDAO,\"Account data access objects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO, \"Nonce data access objects cannot be null\");\n    Account accountCreated = null;\n    try {\n      accountCreated = accountDAO.createAccount(account);\n    } catch (ConfigurationException e) {\n      Throwables.propagate(e);\n    }\n    return accountCreated;\n  }","commit_id":"46e6123b4ad61dbe0347a90c38d8e9b6f4740a43","url":"https://github.com/caskdata/cdap"},{"original_method":"public VPC addVPC(int accountId, VPC vpc) throws RuntimeException {\n    Preconditions.checkNotNull(accountDAO,\"Account data access objects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO,\"Nonce data access objects cannot be null\");\n\n    try {\n      return vpcDao.addVPC(accountId, vpc);\n    } catch (ConfigurationException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n  }","id":33118,"modified_method":"public VPC addVPC(int accountId, VPC vpc) {\n    Preconditions.checkNotNull(accountDAO, \"Account data access objects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO,\"Nonce data access objects cannot be null\");\n\n    VPC vpcReturned = null;\n    try {\n      vpcReturned =  vpcDao.addVPC(accountId, vpc);\n    } catch (ConfigurationException e) {\n      Throwables.propagate(e);\n    }\n    return vpcReturned;\n  }","commit_id":"46e6123b4ad61dbe0347a90c38d8e9b6f4740a43","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public List<VPC> getVPC(int accountId) {\n\n    Preconditions.checkNotNull(accountDAO,\"Account data access objects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO,\"Nonce data access objects cannot be null\");\n\n    List<VPC> vpcs;\n\n    try {\n      vpcs = vpcDao.getVPC(accountId);\n    } catch (ConfigurationException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n    return vpcs;\n  }","id":33119,"modified_method":"@Override\n  public List<VPC> getVPC(int accountId) {\n\n    Preconditions.checkNotNull(accountDAO, \"Account data access objects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO,\"Nonce data access objects cannot be null\");\n\n    List<VPC> vpcs = null;\n\n    try {\n      vpcs = vpcDao.getVPC(accountId);\n    } catch (ConfigurationException e) {\n      Throwables.propagate(e);\n    }\n    return vpcs;\n  }","commit_id":"46e6123b4ad61dbe0347a90c38d8e9b6f4740a43","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public int getActivationId(int nonce) throws RuntimeException {\n    Preconditions.checkNotNull(accountDAO,\"Account data access objects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO,\"Nonce data access objects cannot be null\");\n\n    try {\n      return nonceDAO.getId(nonce, NonceDAO.NONCE_TYPE.ACTIVATION);\n    } catch (Exception e) {\n      throw new RuntimeException(e.getMessage());\n    }\n  }","id":33120,"modified_method":"@Override\n  public int getActivationId(int nonce) {\n    Preconditions.checkNotNull(accountDAO,\"Account data access objects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO, \"Nonce data access objects cannot be null\");\n    int id = -1;\n    try {\n      id = nonceDAO.getId(nonce, NonceDAO.NONCE_TYPE.ACTIVATION);\n    } catch (Exception e) {\n      Throwables.propagate(e);\n    }\n    return id;\n  }","commit_id":"46e6123b4ad61dbe0347a90c38d8e9b6f4740a43","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Unregister a {@code Component} in the system\n   *\n   * @param accountId\n   * @param credentials\n   * @param component\n   * @return Instance of {@code Status}\n   * @throws RuntimeException\n   */\n  @Override\n  public Status unRegisterComponent(String accountId, Credentials credentials, Component component)\n    throws RetryException {\n    return null;  //To change body of implemented methods use File | Settings | File Templates.\n  }","id":33121,"modified_method":"/**\n   * Unregister a {@code Component} in the system\n   *\n   * @param accountId\n   * @param credentials\n   * @param component\n   * @return Instance of {@code Status}\n   */\n  @Override\n  public Status unRegisterComponent(String accountId, Credentials credentials, Component component) {\n    return null;  //To change body of implemented methods use File | Settings | File Templates.\n  }","commit_id":"46e6123b4ad61dbe0347a90c38d8e9b6f4740a43","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void confirmDownload(int accountId) throws RuntimeException {\n    Preconditions.checkNotNull(accountDAO,\"Account data accessobjects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO,\"Nonce data access objects cannot be null\");\n\n    try {\n      accountDAO.confirmDownload(accountId);\n    } catch (ConfigurationException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n  }","id":33122,"modified_method":"@Override\n  public void confirmDownload(int accountId){\n    Preconditions.checkNotNull(accountDAO,\"Account data access objects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO, \"Nonce data access objects cannot be null\");\n\n    try {\n      accountDAO.confirmDownload(accountId);\n    } catch (ConfigurationException e) {\n      Throwables.propagate(e);\n    }\n  }","commit_id":"46e6123b4ad61dbe0347a90c38d8e9b6f4740a43","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void deleteVPC(int accountId, int vpcId) throws RuntimeException, VPCNotFoundException {\n    Preconditions.checkNotNull(accountDAO,\"Account data access objects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO,\"Nonce data access objects cannot be null\");\n\n    try {\n      vpcDao.removeVPC(accountId, vpcId);\n    } catch (ConfigurationException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n\n\n  }","id":33123,"modified_method":"@Override\n  public void deleteVPC(int accountId, int vpcId) throws VPCNotFoundException {\n    Preconditions.checkNotNull(accountDAO,\"Account data access objects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO, \"Nonce data access objects cannot be null\");\n    try {\n      vpcDao.removeVPC(accountId, vpcId);\n    } catch (ConfigurationException e) {\n      Throwables.propagate(e);\n    }\n\n\n  }","commit_id":"46e6123b4ad61dbe0347a90c38d8e9b6f4740a43","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void changePassword(int accountId, String oldPassword, String newPassword) throws RuntimeException {\n    Preconditions.checkNotNull(accountDAO,\"Account data access objects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO,\"Nonce data access objects cannot be null\");\n\n    try {\n      accountDAO.changePassword(accountId, oldPassword, newPassword);\n    } catch (Exception e) {\n      throw new RuntimeException(e.getMessage());\n    }\n\n  }","id":33124,"modified_method":"@Override\n  public void changePassword(int accountId, String oldPassword, String newPassword) {\n    Preconditions.checkNotNull(accountDAO, \"Account data access objects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO,\"Nonce data access objects cannot be null\");\n\n    try {\n      accountDAO.changePassword(accountId, oldPassword, newPassword);\n    } catch (Exception e) {\n      Throwables.propagate(e);\n    }\n\n  }","commit_id":"46e6123b4ad61dbe0347a90c38d8e9b6f4740a43","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Account getAccount(String emailId){\n    Preconditions.checkNotNull(accountDAO,\"Account data access objects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO,\"Nonce data access objects cannot be null\");\n\n    Account account = null;\n\n    try {\n      account = accountDAO.getAccount(emailId);\n    } catch (ConfigurationException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n    return account;\n  }","id":33125,"modified_method":"@Override\n  public Account getAccount(String emailId){\n    Preconditions.checkNotNull(accountDAO, \"Account data access objects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO,\"Nonce data access objects cannot be null\");\n\n    Account account = null;\n\n    try {\n      account = accountDAO.getAccount(emailId);\n    } catch (ConfigurationException e) {\n      Throwables.propagate(e);\n    }\n    return account;\n  }","commit_id":"46e6123b4ad61dbe0347a90c38d8e9b6f4740a43","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public int getActivationNonce(int id) throws RuntimeException {\n    Preconditions.checkNotNull(accountDAO,\"Account data access objects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO,\"Nonce data access objects cannot be null\");\n\n    try {\n      return nonceDAO.getNonce(id, NonceDAO.NONCE_TYPE.ACTIVATION);\n    } catch (Exception e) {\n      throw new RuntimeException(e.getMessage());\n    }\n\n  }","id":33126,"modified_method":"@Override\n  public int getActivationNonce(int id){\n    Preconditions.checkNotNull(accountDAO, \"Account data access objects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO,\"Nonce data access objects cannot be null\");\n    int nonce= -1;\n    try {\n      nonce =  nonceDAO.getNonce(id, NonceDAO.NONCE_TYPE.ACTIVATION);\n    } catch (Exception e) {\n      Throwables.propagate(e);\n    }\n    return nonce;\n  }","commit_id":"46e6123b4ad61dbe0347a90c38d8e9b6f4740a43","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Register a component with the account- Example: register VPC, Register DataSet\n   *\n   * @param accountId\n   * @param credentials\n   * @param component\n   * @return Instance of {@code Status}\n   * @throws RuntimeException\n   */\n  @Override\n  public Status registerComponents(String accountId, Credentials credentials, Component component)\n    throws RuntimeException {\n    return null;  //To change body of implemented methods use File | Settings | File Templates.\n  }","id":33127,"modified_method":"/**\n   * Register a component with the account- Example: register VPC, Register DataSet\n   *\n   * @param accountId\n   * @param credentials\n   * @param component\n   * @return Instance of {@code Status}\n   */\n  @Override\n  public Status registerComponents(String accountId, Credentials credentials, Component component){\n    return null;  //To change body of implemented methods use File | Settings | File Templates.\n  }","commit_id":"46e6123b4ad61dbe0347a90c38d8e9b6f4740a43","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public VPC getVPC(int accountId, int vpcId) {\n    Preconditions.checkNotNull(accountDAO,\"Account data access objects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO,\"Nonce data access objects cannot be null\");\n    try {\n      return vpcDao.getVPC(accountId, vpcId);\n    } catch (ConfigurationException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n  }","id":33128,"modified_method":"@Override\n  public VPC getVPC(int accountId, int vpcId) {\n    Preconditions.checkNotNull(accountDAO,\"Account data access objects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO,\"Nonce data access objects cannot be null\");\n    VPC vpc = null;\n    try {\n      vpc  =  vpcDao.getVPC(accountId, vpcId);\n    } catch (ConfigurationException e) {\n      Throwables.propagate(e);\n    }\n    return vpc;\n  }","commit_id":"46e6123b4ad61dbe0347a90c38d8e9b6f4740a43","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * @param accountId\n   * @param credentials\n   * @param component\n   * @return Instance of {@code Status}\n   * @throws RuntimeException\n   */\n  @Override\n  public Status updateComponent(String accountId, Credentials credentials, Component component)\n    throws RetryException {\n    return null;  //To change body of implemented methods use File | Settings | File Templates.\n  }","id":33129,"modified_method":"/**\n   * @param accountId\n   * @param credentials\n   * @param component\n   * @return Instance of {@code Status}\n   */\n  @Override\n  public Status updateComponent(String accountId, Credentials credentials, Component component){\n    return null;  //To change body of implemented methods use File | Settings | File Templates.\n  }","commit_id":"46e6123b4ad61dbe0347a90c38d8e9b6f4740a43","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * GetAccount object\n   *\n   * @param accountId Id of the account\n   * @return Instance of {@code Account}\n   */\n  @Override\n  public Account getAccount(int accountId) throws RuntimeException {\n    Preconditions.checkNotNull(accountDAO,\"Account data access objects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO,\"Nonce data access objects cannot be null\");\n\n    Account account = null;\n    try {\n      account = accountDAO.getAccount(accountId);\n    } catch (ConfigurationException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n    return account;\n  }","id":33130,"modified_method":"/**\n   * GetAccount object\n   *\n   * @param accountId Id of the account\n   * @return Instance of {@code Account}\n   */\n  @Override\n  public Account getAccount(int accountId)  {\n    Preconditions.checkNotNull(accountDAO, \"Account data access objects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO,\"Nonce data access objects cannot be null\");\n\n    Account account = null;\n    try {\n      account = accountDAO.getAccount(accountId);\n    } catch (ConfigurationException e) {\n      Throwables.propagate(e);\n    }\n    return account;\n  }","commit_id":"46e6123b4ad61dbe0347a90c38d8e9b6f4740a43","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Update account with passed Params\n   *\n   * @param accountId accountId\n   * @param params    Map<\"keyName\", \"value\">\n   */\n  @Override\n  public void updateAccount(int accountId, Map<String, Object> params) throws RuntimeException {\n    Preconditions.checkNotNull(accountDAO,\"Account data access objects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO,\"Nonce data access objects cannot be null\");\n\n    try {\n      accountDAO.updateAccount(accountId, params);\n    } catch (Exception e) {\n      throw new RuntimeException(e.getMessage());\n    }\n\n  }","id":33131,"modified_method":"/**\n   * Update account with passed Params\n   *\n   * @param accountId accountId\n   * @param params    Map<\"keyName\", \"value\">\n   */\n  @Override\n  public void updateAccount(int accountId, Map<String, Object> params) {\n    Preconditions.checkNotNull(accountDAO,\"Account data access objects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO,\"Nonce data access objects cannot be null\");\n\n    try {\n      accountDAO.updateAccount(accountId, params);\n    } catch (Exception e) {\n      Throwables.propagate(e);\n    }\n  }","commit_id":"46e6123b4ad61dbe0347a90c38d8e9b6f4740a43","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Get VPC List based on the ApiKey\n   *\n   * @param apiKey apiKey of the account\n   * @return List of {@code VPC}\n   */\n  @Override\n  public List<VPC> getVPC(String apiKey) {\n    Preconditions.checkNotNull(accountDAO,\"Account data access objects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO,\"Nonce data access objects cannot be null\");\n\n    List<VPC> vpcs;\n    try {\n      vpcs = vpcDao.getVPC(apiKey);\n    } catch (ConfigurationException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n    return vpcs;\n\n  }","id":33132,"modified_method":"/**\n   * Get VPC List based on the ApiKey\n   *\n   * @param apiKey apiKey of the account\n   * @return List of {@code VPC}\n   */\n  @Override\n  public List<VPC> getVPC(String apiKey) {\n    Preconditions.checkNotNull(accountDAO,\"Account data access objects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO,\"Nonce data access objects cannot be null\");\n\n    List<VPC> vpcs = null;\n    try {\n      vpcs = vpcDao.getVPC(apiKey);\n    } catch (ConfigurationException e) {\n      Throwables.propagate(e);\n    }\n    return vpcs;\n }","commit_id":"46e6123b4ad61dbe0347a90c38d8e9b6f4740a43","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Delete an {@code Account} in the system\n   *\n   * @param accountId account to be deleted\n   * @throws RuntimeException\n   */\n  @Override\n  public void deleteAccount(int accountId) throws RuntimeException, AccountNotFoundException {\n    Preconditions.checkNotNull(accountDAO,\"Account data accessobjects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO,\"Nonce data access objects cannot be null\");\n\n    try {\n      accountDAO.deleteAccount(accountId);\n    } catch (ConfigurationException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n  }","id":33133,"modified_method":"/**\n   * Delete an {@code Account} in the system\n   *\n   * @param accountId account to be deleted\n   */\n  @Override\n  public void deleteAccount(int accountId) throws AccountNotFoundException {\n    Preconditions.checkNotNull(accountDAO,\"Account data access objects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO, \"Nonce data access objects cannot be null\");\n\n    try {\n      accountDAO.deleteAccount(accountId);\n    } catch (ConfigurationException e) {\n      Throwables.propagate(e);\n    }\n  }","commit_id":"46e6123b4ad61dbe0347a90c38d8e9b6f4740a43","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public int getSessionId(int nonce) throws RuntimeException {\n    Preconditions.checkNotNull(accountDAO,\"Account data access objects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO,\"Nonce data access objects cannot be null\");\n\n    try {\n      return nonceDAO.getId(nonce, NonceDAO.NONCE_TYPE.SESSION);\n    } catch (Exception e) {\n      throw new RuntimeException(e.getMessage());\n    }\n  }","id":33134,"modified_method":"@Override\n  public int getSessionId(int nonce) {\n    Preconditions.checkNotNull(accountDAO,\"Account data access objects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO, \"Nonce data access objects cannot be null\");\n\n    int id = -1;\n    try {\n      id =  nonceDAO.getId(nonce, NonceDAO.NONCE_TYPE.SESSION);\n    } catch (Exception e) {\n      Throwables.propagate(e);\n    }\n    return id;\n  }","commit_id":"46e6123b4ad61dbe0347a90c38d8e9b6f4740a43","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Status confirmRegistration(Account account, String password) throws RuntimeException {\n    Preconditions.checkNotNull(accountDAO,\"Account data accessobjects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO,\"Nonce data access objects cannot be null\");\n\n    try {\n      accountDAO.confirmRegistration(account, password);\n    } catch (ConfigurationException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n    return null;\n  }","id":33135,"modified_method":"@Override\n  public void confirmRegistration(Account account, String password) {\n    Preconditions.checkNotNull(accountDAO, \"Account data access objects cannot be null\");\n    Preconditions.checkNotNull(vpcDao,\"VPC data access objects cannot be null\");\n    Preconditions.checkNotNull(nonceDAO,\"Nonce data access objects cannot be null\");\n\n    try {\n      accountDAO.confirmRegistration(account, password);\n    } catch (ConfigurationException e) {\n      Throwables.propagate(e);\n    }\n  }","commit_id":"46e6123b4ad61dbe0347a90c38d8e9b6f4740a43","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Create Account in the system\n   * @param account Instance of {@code Account}\n   * @return boolean status of account creation\n   * @throws {@code RetryException}\n   */\n  @Override\n  public boolean createAccount(Account account) throws ConfigurationException, RuntimeException {\n    //TODO: Return boolean?\n    if (this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      Connection connection= this.poolManager.getConnection();\n      //TODO: Execute in a thread ...\n      SQLChain chain =  SQLChainImpl.getSqlChain(connection);\n      chain.insert(Common.AccountTable.TABLE_NAME)\n           .columns(Common.AccountTable.EMAIL_COLUMN, Common.AccountTable.FIRST_NAME_COLUMN,\n                    Common.AccountTable.LAST_NAME_COLUMN, Common.AccountTable.COMPANY_COLUMN,\n                    Common.AccountTable.CONFIRMED_COLUMN)\n           .values(account.getEmailId(), account.getFirstName(), account.getLastName(),\n                   account.getCompany(),Common.AccountTable.ACCOUNT_UNCONFIRMED)\n           .execute();\n    } catch (SQLException e) {\n      //TODO: Log\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    }\n    return true;\n  }","id":33136,"modified_method":"/**\n   * Create Account in the system\n   * @param account Instance of {@code Account}\n   * @return boolean status of account creation\n   * @throws {@code RetryException}\n   */\n  @Override\n  public long createAccount(Account account) throws ConfigurationException, RuntimeException {\n    //TODO: Return boolean?\n    if (this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      Connection connection= this.poolManager.getConnection();\n\n      PreparedStatement ps = null;\n      String SQL = String.format( \"INSERT INTO %s (%s,%s,%s,%s,%s) VALUES (?,?,?,?,?)\", Common.AccountTable.TABLE_NAME,\n                                  Common.AccountTable.EMAIL_COLUMN,\n                                  Common.AccountTable.FIRST_NAME_COLUMN,Common.AccountTable.LAST_NAME_COLUMN,\n                                  Common.AccountTable.COMPANY_COLUMN,Common.AccountTable.CONFIRMED_COLUMN);\n\n      ps = connection.prepareStatement(SQL, Statement.RETURN_GENERATED_KEYS);\n      ps.setString(1,account.getEmailId());\n      ps.setString(2,account.getFirstName());\n      ps.setString(3,account.getLastName());\n      ps.setString(4,account.getCompany());\n      ps.setInt(5,0);\n\n      ps.executeUpdate();\n      ResultSet result = ps.getGeneratedKeys();\n      if (result == null) {\n        throw new RuntimeException(\"Failed Insert\");\n      }\n      result.next();\n      long id = result.getLong(1);\n\n      return id;\n    } catch (SQLException e) {\n      //TODO: Log\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    }\n  }","commit_id":"3ea7b39607f7626f6e428e74037d53b95ed4c054","url":"https://github.com/caskdata/cdap"},{"original_method":"@Path(\"create\")\n  @PUT\n  @Produces(\"application/json\")\n  @Consumes(\"application/json\")\n  public Response createAccount(String data) {\n\n    try{\n      JsonParser parser = new JsonParser();\n      JsonElement element = parser.parse(data);\n      JsonObject jsonObject = element.getAsJsonObject();\n\n      String firstName = jsonObject.get(\"first_name\") == null? null : jsonObject.get(\"first_name\").getAsString();\n      String lastName = jsonObject.get(\"first_name\") == null? null : jsonObject.get(\"last_name\").getAsString();\n      String emailId = jsonObject.get(\"email_id\") == null? null : jsonObject.get(\"email_id\").getAsString();\n      String company = jsonObject.get(\"company\") == null? null : jsonObject.get(\"company\").getAsString();\n\n      if ( (firstName == null) || (lastName == null) || (emailId == null) || (company == null) ){\n        return Response.status(Response.Status.BAD_REQUEST)\n          .entity(Utils.getJson(\"FAILED\", \"Account name or email id or company is missing\")).build();\n      }\n      else {\n        DataManagementServiceImpl.getInstance().registerAccount(new Account(firstName,lastName,company,emailId));\n        return Response.ok(Utils.getJson(\"OK\",\"Account Created\")).build();\n      }\n    }\n    catch (Exception e){\n      return Response.status(Response.Status.BAD_REQUEST)\n        .entity(Utils.getJson(\"FAILED\", \"Account Creation Failed\", e))\n        .build();\n    }\n  }","id":33137,"modified_method":"@Path(\"create\")\n  @PUT\n  @Produces(\"application/json\")\n  @Consumes(\"application/json\")\n  public Response createAccount(String data) {\n\n    try{\n      JsonParser parser = new JsonParser();\n      JsonElement element = parser.parse(data);\n      JsonObject jsonObject = element.getAsJsonObject();\n\n      String firstName = jsonObject.get(\"first_name\") == null? null : jsonObject.get(\"first_name\").getAsString();\n      String lastName = jsonObject.get(\"first_name\") == null? null : jsonObject.get(\"last_name\").getAsString();\n      String emailId = jsonObject.get(\"email_id\") == null? null : jsonObject.get(\"email_id\").getAsString();\n      String company = jsonObject.get(\"company\") == null? null : jsonObject.get(\"company\").getAsString();\n\n      if ( (firstName == null) || (lastName == null) || (emailId == null) || (company == null) ){\n        return Response.status(Response.Status.BAD_REQUEST)\n          .entity(Utils.getJson(\"FAILED\", \"Account name or email id or company is missing\")).build();\n      }\n      else {\n        long genId = DataManagementServiceImpl.getInstance().registerAccount(new Account(firstName,lastName,company,emailId));\n        return Response.ok(Utils.getJson(\"OK\",\"Account Created\",genId)).build();\n      }\n    }\n    catch (Exception e){\n      return Response.status(Response.Status.BAD_REQUEST)\n        .entity(Utils.getJson(\"FAILED\", \"Account Creation Failed\", e))\n        .build();\n    }\n  }","commit_id":"3ea7b39607f7626f6e428e74037d53b95ed4c054","url":"https://github.com/caskdata/cdap"},{"original_method":"public Status addVPC(int accountId, VPC vpc) throws RuntimeException {\n    if(vpcDao == null) {\n      throw new RuntimeException(\"Could not initialize data access object\");\n    }\n    try {\n      vpcDao.addVPC(accountId, vpc);\n    } catch (ConfigurationException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n    return null;\n  }","id":33138,"modified_method":"public long addVPC(int accountId, VPC vpc) throws RuntimeException {\n    if(vpcDao == null) {\n      throw new RuntimeException(\"Could not initialize data access object\");\n    }\n    try {\n     return vpcDao.addVPC(accountId, vpc);\n    } catch (ConfigurationException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n  }","commit_id":"3ea7b39607f7626f6e428e74037d53b95ed4c054","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Register an {@code Account} in the system\n   *\n   * @param account Account information\n   * @return Instance of {@code Status}\n   * @throws RuntimeException\n   */\n  @Override\n  public Status registerAccount(Account account) throws RuntimeException {\n    if (accountDAO ==null) {\n      throw new RuntimeException(\"Could not init data access Object\");\n\n    }\n    try {\n      accountDAO.createAccount(account);\n    } catch (ConfigurationException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n    return null;\n  }","id":33139,"modified_method":"/**\n   * Register an {@code Account} in the system\n   *\n   * @param account Account information\n   * @return Instance of {@code Status}\n   * @throws RuntimeException\n   */\n  @Override\n  public long registerAccount(Account account) throws RuntimeException {\n    if (accountDAO ==null) {\n      throw new RuntimeException(\"Could not init data access Object\");\n\n    }\n    try {\n      return accountDAO.createAccount(account);\n    } catch (ConfigurationException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n  }","commit_id":"3ea7b39607f7626f6e428e74037d53b95ed4c054","url":"https://github.com/caskdata/cdap"},{"original_method":"private DataManagementServiceImpl() {\n    accountDAO = new AccountDBAccess();\n    Map<String,String> config = new HashMap<String,String>();\n    config.put(\"jdbcType\",\"mysql\");\n    config.put(\"connectionString\",\"jdbc:mysql://a101.dev.sl:3306/continuuity?user=passport_user\");\n    //config.put(\"connectionString\",\"jdbc:mysql://localhost/continuuity?user=passport_user\");\n    accountDAO.configure(config);\n\n    vpcDao = new VpcDBAccess();\n    vpcDao.configure(config);\n  }","id":33140,"modified_method":"private DataManagementServiceImpl() {\n    accountDAO = new AccountDBAccess();\n    Map<String,String> config = new HashMap<String,String>();\n    config.put(\"jdbcType\",\"mysql\");\n    //config.put(\"connectionString\",\"jdbc:mysql://a101.dev.sl:3306/continuuity?user=passport_user\");\n    config.put(\"connectionString\",\"jdbc:mysql://localhost/continuuity?user=passport_user\");\n    accountDAO.configure(config);\n\n    vpcDao = new VpcDBAccess();\n    vpcDao.configure(config);\n  }","commit_id":"3ea7b39607f7626f6e428e74037d53b95ed4c054","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public boolean addVPC(int accountId, VPC vpc) throws ConfigurationException, RuntimeException {\n    if (this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      Connection connection= this.poolManager.getConnection();\n      //TODO: Execute in a thread ...\n      SQLChain chain =  SQLChainImpl.getSqlChain(connection);\n      chain.insert(Common.VPC.TABLE_NAME)\n        .columns(Common.VPC.ACCOUNT_ID_COLUMN,Common.VPC.NAME_COLUMN)\n        .values(accountId, vpc.getVpcName())\n        .execute();\n    } catch (SQLException e) {\n      //TODO: Log\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    }\n    return true;\n  }","id":33141,"modified_method":"@Override\n  public long addVPC(int accountId, VPC vpc) throws ConfigurationException, RuntimeException {\n    if (this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      Connection connection= this.poolManager.getConnection();\n//\n      PreparedStatement ps = null;\n      String SQL = String.format( \"INSERT INTO %s (%s,%s) VALUES (?,?)\",\n                                  Common.VPC.TABLE_NAME,\n                                  Common.VPC.ACCOUNT_ID_COLUMN,Common.VPC.NAME_COLUMN );\n\n\n      ps = connection.prepareStatement(SQL, Statement.RETURN_GENERATED_KEYS);\n      ps.setInt(1,accountId);\n      ps.setString(2,vpc.getVpcName());\n\n      ps.executeUpdate();\n      ResultSet result = ps.getGeneratedKeys();\n      if (result == null) {\n        throw new RuntimeException(\"Failed Insert\");\n      }\n      result.next();\n      long id = result.getLong(1);\n      return id;\n    } catch (SQLException e) {\n      //TODO: Log\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    }\n  }","commit_id":"3ea7b39607f7626f6e428e74037d53b95ed4c054","url":"https://github.com/caskdata/cdap"},{"original_method":"protected void assertEntitiesInDatabase(int count, String entity) {\n        List<?> results = jpaTemplate.find(\"select o from \" + entity + \" o\");\n        assertEquals(count, results.size());\n    }","id":33142,"modified_method":"protected void assertEntitiesInDatabase(int count, String entity) {\n        List<?> results = entityManager.createQuery(\"select o from \" + entity + \" o\").getResultList();\n        assertEquals(count, results.size());\n    }","commit_id":"e696c601329d695a82673227b28ab134644bf52c","url":"https://github.com/apache/camel"},{"original_method":"protected void setUp(String endpointUri) throws Exception {\n        template = camelContext.createProducerTemplate();\n        startServices(template, camelContext);\n\n        endpoint = camelContext.getEndpoint(endpointUri, JpaEndpoint.class);\n\n        transactionStrategy = endpoint.createTransactionStrategy();\n        jpaTemplate = endpoint.getTemplate();\n        \n        transactionStrategy.execute(new JpaCallback<Object>() {\n            public Object doInJpa(EntityManager entityManager) throws PersistenceException {\n                entityManager.createQuery(\"delete from \" + Customer.class.getName()).executeUpdate();\n                return null;\n            }\n        });\n        \n        assertEntitiesInDatabase(0, Customer.class.getName());\n        assertEntitiesInDatabase(0, Address.class.getName());\n    }","id":33143,"modified_method":"protected void setUp(String endpointUri) throws Exception {\n        template = camelContext.createProducerTemplate();\n        startServices(template, camelContext);\n\n        endpoint = camelContext.getEndpoint(endpointUri, JpaEndpoint.class);\n\n        transactionTemplate = endpoint.createTransactionTemplate();\n        entityManager = endpoint.createEntityManager();\n        \n        transactionTemplate.execute(new TransactionCallback<Object>() {\n            public Object doInTransaction(TransactionStatus status) {\n            \tentityManager.joinTransaction();\n                entityManager.createQuery(\"delete from \" + Customer.class.getName()).executeUpdate();\n                return null;\n            }\n        });\n        \n        assertEntitiesInDatabase(0, Customer.class.getName());\n        assertEntitiesInDatabase(0, Address.class.getName());\n    }","commit_id":"e696c601329d695a82673227b28ab134644bf52c","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void consumeEntity() throws Exception {\n        setUp(\"jpa://\" + Customer.class.getName() + \"?usePersist=\" + (usePersist() ? \"true\" : \"false\"));\n    \n        final Customer customer = createDefaultCustomer();\n        save(customer);\n        \n        final CountDownLatch latch = new CountDownLatch(1);\n        \n        consumer = endpoint.createConsumer(new Processor() {\n            public void process(Exchange e) {\n                receivedExchange = e;\n                assertNotNull(e.getIn().getHeader(JpaConstants.JPA_TEMPLATE, JpaTemplate.class));\n                latch.countDown();\n            }\n        });\n        consumer.start();\n        \n        assertTrue(latch.await(50, TimeUnit.SECONDS));\n        \n        assertNotNull(receivedExchange);\n        Customer receivedCustomer = receivedExchange.getIn().getBody(Customer.class);\n        assertEquals(customer.getName(), receivedCustomer.getName());\n        assertEquals(customer.getId(), receivedCustomer.getId());\n        assertEquals(customer.getAddress().getAddressLine1(), receivedCustomer.getAddress().getAddressLine1());\n        assertEquals(customer.getAddress().getAddressLine2(), receivedCustomer.getAddress().getAddressLine2());\n        assertEquals(customer.getAddress().getId(), receivedCustomer.getAddress().getId());\n        \n        // give a bit tiem for consumer to delete after done\n        Thread.sleep(1000);\n        \n        assertEntitiesInDatabase(0, Customer.class.getName());\n        assertEntitiesInDatabase(0, Address.class.getName());\n    }","id":33144,"modified_method":"@Test\n    public void consumeEntity() throws Exception {\n        setUp(\"jpa://\" + Customer.class.getName() + \"?usePersist=\" + (usePersist() ? \"true\" : \"false\"));\n    \n        final Customer customer = createDefaultCustomer();\n        save(customer);\n        \n        final CountDownLatch latch = new CountDownLatch(1);\n        \n        consumer = endpoint.createConsumer(new Processor() {\n            public void process(Exchange e) {\n                receivedExchange = e;\n                assertNotNull(e.getIn().getHeader(JpaConstants.ENTITYMANAGER, EntityManager.class));\n                latch.countDown();\n            }\n        });\n        consumer.start();\n        \n        assertTrue(latch.await(50, TimeUnit.SECONDS));\n        \n        assertNotNull(receivedExchange);\n        Customer receivedCustomer = receivedExchange.getIn().getBody(Customer.class);\n        assertEquals(customer.getName(), receivedCustomer.getName());\n        assertEquals(customer.getId(), receivedCustomer.getId());\n        assertEquals(customer.getAddress().getAddressLine1(), receivedCustomer.getAddress().getAddressLine1());\n        assertEquals(customer.getAddress().getAddressLine2(), receivedCustomer.getAddress().getAddressLine2());\n        assertEquals(customer.getAddress().getId(), receivedCustomer.getAddress().getId());\n        \n        // give a bit tiem for consumer to delete after done\n        Thread.sleep(1000);\n        \n        assertEntitiesInDatabase(0, Customer.class.getName());\n        assertEntitiesInDatabase(0, Address.class.getName());\n    }","commit_id":"e696c601329d695a82673227b28ab134644bf52c","url":"https://github.com/apache/camel"},{"original_method":"@After\n    public void tearDown() throws Exception {\n        stopServices(consumer, template, camelContext);\n    }","id":33145,"modified_method":"@After\n    public void tearDown() throws Exception {\n        stopServices(consumer, template, camelContext);\n        entityManager.close();\n    }","commit_id":"e696c601329d695a82673227b28ab134644bf52c","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void produceNewEntity() throws Exception {\n        setUp(\"jpa://\" + Customer.class.getName() + \"?usePersist=\" + (usePersist() ? \"true\" : \"false\"));\n        \n        Customer customer = createDefaultCustomer();\n        Exchange exchange = new DefaultExchange(camelContext);\n        exchange.getIn().setBody(customer);\n        Exchange returnedExchange = template.send(endpoint, exchange);\n        \n        Customer receivedCustomer = returnedExchange.getIn().getBody(Customer.class);\n        assertEquals(customer.getName(), receivedCustomer.getName());\n        assertNotNull(receivedCustomer.getId());\n        assertEquals(customer.getAddress().getAddressLine1(), receivedCustomer.getAddress().getAddressLine1());\n        assertEquals(customer.getAddress().getAddressLine2(), receivedCustomer.getAddress().getAddressLine2());\n        assertNotNull(receivedCustomer.getAddress().getId());\n        \n        List<?> results = jpaTemplate.find(\"select o from \" + Customer.class.getName() + \" o\");\n        assertEquals(1, results.size());\n        Customer persistedCustomer = (Customer) results.get(0);\n        assertEquals(receivedCustomer.getName(), persistedCustomer.getName());\n        assertEquals(receivedCustomer.getId(), persistedCustomer.getId());\n        assertEquals(receivedCustomer.getAddress().getAddressLine1(), persistedCustomer.getAddress().getAddressLine1());\n        assertEquals(receivedCustomer.getAddress().getAddressLine2(), persistedCustomer.getAddress().getAddressLine2());\n        assertEquals(receivedCustomer.getAddress().getId(), persistedCustomer.getAddress().getId());\n    }","id":33146,"modified_method":"@Test\n    public void produceNewEntity() throws Exception {\n        setUp(\"jpa://\" + Customer.class.getName() + \"?usePersist=\" + (usePersist() ? \"true\" : \"false\"));\n        \n        Customer customer = createDefaultCustomer();\n        Exchange exchange = new DefaultExchange(camelContext);\n        exchange.getIn().setBody(customer);\n        Exchange returnedExchange = template.send(endpoint, exchange);\n        \n        Customer receivedCustomer = returnedExchange.getIn().getBody(Customer.class);\n        assertEquals(customer.getName(), receivedCustomer.getName());\n        assertNotNull(receivedCustomer.getId());\n        assertEquals(customer.getAddress().getAddressLine1(), receivedCustomer.getAddress().getAddressLine1());\n        assertEquals(customer.getAddress().getAddressLine2(), receivedCustomer.getAddress().getAddressLine2());\n        assertNotNull(receivedCustomer.getAddress().getId());\n        \n        List<?> results = entityManager.createQuery(\"select o from \" + Customer.class.getName() + \" o\").getResultList();\n        assertEquals(1, results.size());\n        Customer persistedCustomer = (Customer) results.get(0);\n        assertEquals(receivedCustomer.getName(), persistedCustomer.getName());\n        assertEquals(receivedCustomer.getId(), persistedCustomer.getId());\n        assertEquals(receivedCustomer.getAddress().getAddressLine1(), persistedCustomer.getAddress().getAddressLine1());\n        assertEquals(receivedCustomer.getAddress().getAddressLine2(), persistedCustomer.getAddress().getAddressLine2());\n        assertEquals(receivedCustomer.getAddress().getId(), persistedCustomer.getAddress().getId());\n    }","commit_id":"e696c601329d695a82673227b28ab134644bf52c","url":"https://github.com/apache/camel"},{"original_method":"protected void save(final Customer customer) {\n        transactionStrategy.execute(new JpaCallback<Object>() {\n            public Object doInJpa(EntityManager entityManager) throws PersistenceException {\n                entityManager.persist(customer);\n                entityManager.flush();\n                return null;\n            }\n        });\n        \n        assertEntitiesInDatabase(1, Customer.class.getName());\n        assertEntitiesInDatabase(1, Address.class.getName());\n    }","id":33147,"modified_method":"protected void save(final Customer customer) {\n    \ttransactionTemplate.execute(new TransactionCallback<Object>() {\n            public Object doInTransaction(TransactionStatus status) {\n            \tentityManager.joinTransaction();\n                entityManager.persist(customer);\n                entityManager.flush();\n                return null;\n            }\n        });\n        \n        assertEntitiesInDatabase(1, Customer.class.getName());\n        assertEntitiesInDatabase(1, Address.class.getName());\n    }","commit_id":"e696c601329d695a82673227b28ab134644bf52c","url":"https://github.com/apache/camel"},{"original_method":"@Before\n    public void setUp() throws Exception {\n        super.setUp();\n        cleanupRepository();\n        deleteDirectory(\"target/idempotent\");\n        template.sendBodyAndHeader(\"file://target/idempotent/\", \"Hello World\", Exchange.FILE_NAME, \"report.txt\");\n    }","id":33148,"modified_method":"@Before\n    public void setUp() throws Exception {\n        super.setUp();\n        deleteDirectory(\"target/idempotent\");\n        template.sendBodyAndHeader(\"file://target/idempotent/\", \"Hello World\", Exchange.FILE_NAME, \"report.txt\");\n    }","commit_id":"e696c601329d695a82673227b28ab134644bf52c","url":"https://github.com/apache/camel"},{"original_method":"protected void cleanupRepository() {\n        jpaTemplate = applicationContext.getBean(\"jpaTemplate\", JpaTemplate.class);\n\n        TransactionTemplate transactionTemplate = new TransactionTemplate();\n        transactionTemplate.setTransactionManager(new JpaTransactionManager(jpaTemplate.getEntityManagerFactory()));\n        transactionTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);\n\n        transactionTemplate.execute(new TransactionCallback<Object>() {\n            public Object doInTransaction(TransactionStatus arg0) {\n                List<?> list = jpaTemplate.find(SELECT_ALL_STRING, PROCESSOR_NAME);\n                for (Object item : list) {\n                    jpaTemplate.remove(item);\n                }\n                jpaTemplate.flush();\n                return Boolean.TRUE;\n            }\n        });\n    }","id":33149,"modified_method":"@Override\n    protected void cleanupRepository() {\n        transactionTemplate.execute(new TransactionCallback<Object>() {\n            public Object doInTransaction(TransactionStatus arg0) {\n            \tentityManager.joinTransaction();\n            \tQuery query = entityManager.createQuery(SELECT_ALL_STRING);\n            \tquery.setParameter(1, PROCESSOR_NAME);\n                List<?> list = query.getResultList();\n                for (Object item : list) {\n                \tentityManager.remove(item);\n                }\n                entityManager.flush();\n                return Boolean.TRUE;\n            }\n        });\n    }","commit_id":"e696c601329d695a82673227b28ab134644bf52c","url":"https://github.com/apache/camel"},{"original_method":"private void assertEntityInDB() throws Exception {\n        jpaTemplate = applicationContext.getBean(\"jpaTemplate\", JpaTemplate.class);\n\n        List<?> list = jpaTemplate.find(SELECT_ALL_STRING);\n        assertEquals(1, list.size());\n\n        assertIsInstanceOf(SendEmail.class, list.get(0));\n    }","id":33150,"modified_method":"private void assertEntityInDB() throws Exception {\n        List<?> list = entityManager.createQuery(SELECT_ALL_STRING).getResultList();\n        assertEquals(1, list.size());\n\n        assertIsInstanceOf(SendEmail.class, list.get(0));\n    }","commit_id":"e696c601329d695a82673227b28ab134644bf52c","url":"https://github.com/apache/camel"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    @Test\n    public void testDuplicateMessagesAreFilteredOut() throws Exception {\n        context.addRoutes(new SpringRouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                // START SNIPPET: idempotent\n                from(\"direct:start\").idempotentConsumer(\n                        header(\"messageId\"),\n                        jpaMessageIdRepository(lookup(JpaTemplate.class), PROCESSOR_NAME)\n                ).to(\"mock:result\");\n                // END SNIPPET: idempotent\n            }\n        });\n        context.start();\n\n        resultEndpoint.expectedBodiesReceived(\"one\", \"two\", \"three\");\n\n        sendMessage(\"1\", \"one\");\n        sendMessage(\"2\", \"two\");\n        sendMessage(\"1\", \"one\");\n        sendMessage(\"2\", \"two\");\n        sendMessage(\"1\", \"one\");\n        sendMessage(\"3\", \"three\");\n\n        assertMockEndpointsSatisfied();\n\n        // all 3 messages should be in jpa repo\n        Set<String> ids = new HashSet<String>();\n        List<MessageProcessed> list = jpaTemplate.find(SELECT_ALL_STRING, PROCESSOR_NAME);\n        for (MessageProcessed item : list) {\n            ids.add(item.getMessageId());\n        }\n\n        assertEquals(3, ids.size());\n        assertTrue(\"Should contain message 1\", ids.contains(\"1\"));\n        assertTrue(\"Should contain message 2\", ids.contains(\"2\"));\n        assertTrue(\"Should contain message 3\", ids.contains(\"3\"));\n    }","id":33151,"modified_method":"@SuppressWarnings(\"unchecked\")\n    @Test\n    public void testDuplicateMessagesAreFilteredOut() throws Exception {\n        context.addRoutes(new SpringRouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                // START SNIPPET: idempotent\n                from(\"direct:start\").idempotentConsumer(\n                        header(\"messageId\"),\n                        jpaMessageIdRepository(lookup(EntityManagerFactory.class), PROCESSOR_NAME)\n                ).to(\"mock:result\");\n                // END SNIPPET: idempotent\n            }\n        });\n        context.start();\n\n        resultEndpoint.expectedBodiesReceived(\"one\", \"two\", \"three\");\n\n        sendMessage(\"1\", \"one\");\n        sendMessage(\"2\", \"two\");\n        sendMessage(\"1\", \"one\");\n        sendMessage(\"2\", \"two\");\n        sendMessage(\"1\", \"one\");\n        sendMessage(\"3\", \"three\");\n\n        assertMockEndpointsSatisfied();\n\n        // all 3 messages should be in jpa repo\n        Set<String> ids = new HashSet<String>();\n        Query query = entityManager.createQuery(SELECT_ALL_STRING);\n    \tquery.setParameter(1, PROCESSOR_NAME);\n    \tList<MessageProcessed> list = query.getResultList();\n        for (MessageProcessed item : list) {\n            ids.add(item.getMessageId());\n        }\n\n        assertEquals(3, ids.size());\n        assertTrue(\"Should contain message 1\", ids.contains(\"1\"));\n        assertTrue(\"Should contain message 2\", ids.contains(\"2\"));\n        assertTrue(\"Should contain message 3\", ids.contains(\"3\"));\n    }","commit_id":"e696c601329d695a82673227b28ab134644bf52c","url":"https://github.com/apache/camel"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    @Test\n    public void testFailedExchangesNotAdded() throws Exception {\n        context.addRoutes(new SpringRouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                errorHandler(deadLetterChannel(\"mock:error\").maximumRedeliveries(0).redeliveryDelay(0).logStackTrace(false));\n\n                from(\"direct:start\").idempotentConsumer(\n                        header(\"messageId\"),\n                        jpaMessageIdRepository(lookup(JpaTemplate.class), PROCESSOR_NAME)\n                ).process(new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        String id = exchange.getIn().getHeader(\"messageId\", String.class);\n                        if (id.equals(\"2\")) {\n                            throw new IllegalArgumentException(\"Damn I cannot handle id 2\");\n                        }\n                    }\n                }).to(\"mock:result\");\n            }\n        });\n        context.start();\n\n        // we send in 2 messages with id 2 that fails\n        getMockEndpoint(\"mock:error\").expectedMessageCount(2);\n        resultEndpoint.expectedBodiesReceived(\"one\", \"three\");\n\n        sendMessage(\"1\", \"one\");\n        sendMessage(\"2\", \"two\");\n        sendMessage(\"1\", \"one\");\n        sendMessage(\"2\", \"two\");\n        sendMessage(\"1\", \"one\");\n        sendMessage(\"3\", \"three\");\n\n        assertMockEndpointsSatisfied();\n\n        // only message 1 and 3 should be in jpa repo\n        Set<String> ids = new HashSet<String>();\n        List<MessageProcessed> list = jpaTemplate.find(SELECT_ALL_STRING, PROCESSOR_NAME);\n        for (MessageProcessed item : list) {\n            ids.add(item.getMessageId());\n        }\n\n        assertEquals(2, ids.size());\n        assertTrue(\"Should contain message 1\", ids.contains(\"1\"));\n        assertTrue(\"Should contain message 3\", ids.contains(\"3\"));\n    }","id":33152,"modified_method":"@SuppressWarnings(\"unchecked\")\n    @Test\n    public void testFailedExchangesNotAdded() throws Exception {\n        context.addRoutes(new SpringRouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                errorHandler(deadLetterChannel(\"mock:error\").maximumRedeliveries(0).redeliveryDelay(0).logStackTrace(false));\n\n                from(\"direct:start\").idempotentConsumer(\n                        header(\"messageId\"),\n                        jpaMessageIdRepository(lookup(EntityManagerFactory.class), PROCESSOR_NAME)\n                ).process(new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        String id = exchange.getIn().getHeader(\"messageId\", String.class);\n                        if (id.equals(\"2\")) {\n                            throw new IllegalArgumentException(\"Damn I cannot handle id 2\");\n                        }\n                    }\n                }).to(\"mock:result\");\n            }\n        });\n        context.start();\n\n        // we send in 2 messages with id 2 that fails\n        getMockEndpoint(\"mock:error\").expectedMessageCount(2);\n        resultEndpoint.expectedBodiesReceived(\"one\", \"three\");\n\n        sendMessage(\"1\", \"one\");\n        sendMessage(\"2\", \"two\");\n        sendMessage(\"1\", \"one\");\n        sendMessage(\"2\", \"two\");\n        sendMessage(\"1\", \"one\");\n        sendMessage(\"3\", \"three\");\n\n        assertMockEndpointsSatisfied();\n\n        // only message 1 and 3 should be in jpa repo\n        Set<String> ids = new HashSet<String>();\n        Query query = entityManager.createQuery(SELECT_ALL_STRING);\n    \tquery.setParameter(1, PROCESSOR_NAME);\n    \tList<MessageProcessed> list = query.getResultList();\n        for (MessageProcessed item : list) {\n            ids.add(item.getMessageId());\n        }\n\n        assertEquals(2, ids.size());\n        assertTrue(\"Should contain message 1\", ids.contains(\"1\"));\n        assertTrue(\"Should contain message 3\", ids.contains(\"3\"));\n    }","commit_id":"e696c601329d695a82673227b28ab134644bf52c","url":"https://github.com/apache/camel"},{"original_method":"protected void cleanupRepository() {\n        jpaTemplate = applicationContext.getBean(\"jpaTemplate\", JpaTemplate.class);\n\n        TransactionTemplate transactionTemplate = new TransactionTemplate();\n        transactionTemplate.setTransactionManager(new JpaTransactionManager(jpaTemplate.getEntityManagerFactory()));\n        transactionTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);\n\n        transactionTemplate.execute(new TransactionCallback<Object>() {\n            public Object doInTransaction(TransactionStatus arg0) {\n                List<?> list = jpaTemplate.find(SELECT_ALL_STRING, PROCESSOR_NAME);\n                for (Object item : list) {\n                    jpaTemplate.remove(item);\n                }\n                jpaTemplate.flush();\n                return Boolean.TRUE;\n            }\n        });\n    }","id":33153,"modified_method":"@Override\n    protected void cleanupRepository() {\n        transactionTemplate.execute(new TransactionCallback<Object>() {\n            public Object doInTransaction(TransactionStatus arg0) {\n            \tentityManager.joinTransaction();\n            \tQuery query = entityManager.createQuery(SELECT_ALL_STRING);\n            \tquery.setParameter(1, PROCESSOR_NAME);\n                List<?> list = query.getResultList();\n                for (Object item : list) {\n                \tentityManager.remove(item);\n                }\n                entityManager.flush();\n                return Boolean.TRUE;\n            }\n        });\n    }","commit_id":"e696c601329d695a82673227b28ab134644bf52c","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testRouteJpa() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedMinimumMessageCount(1);\n\n        template.sendBody(\"direct:start\", new SendEmail(\"one@somewhere.org\"));\n        template.sendBody(\"direct:start\", new SendEmail(\"two@somewhere.org\"));\n        template.sendBody(\"direct:start\", new SendEmail(\"three@somewhere.org\"));\n\n        assertMockEndpointsSatisfied();\n        assertEntityInDB();\n\n        // should not consume 3 at once\n        assertTrue(\"Should not consume all 3 at once\", mock.getReceivedCounter() < 3);\n    }","id":33154,"modified_method":"@Test\n    public void testRouteJpa() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedMinimumMessageCount(1);\n\n        template.sendBody(\"direct:start\", new SendEmail(\"one@somewhere.org\"));\n        template.sendBody(\"direct:start\", new SendEmail(\"two@somewhere.org\"));\n        template.sendBody(\"direct:start\", new SendEmail(\"three@somewhere.org\"));\n\n        assertMockEndpointsSatisfied();\n        assertEntityInDB(3);\n\n        // should not consume 3 at once\n        assertTrue(\"Should not consume all 3 at once\", mock.getReceivedCounter() < 3);\n    }","commit_id":"e696c601329d695a82673227b28ab134644bf52c","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testRouteJpa() throws Exception {\n        // should auto setup transaction manager and entity factory\n        JpaComponent jpa = context.getComponent(\"jpa\", JpaComponent.class);\n        assertNotNull(\"Should have been auto assigned\", jpa.getEntityManagerFactory());\n        assertNotNull(\"Should have been auto assigned\", jpa.getTransactionManager());\n\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedMessageCount(1);\n\n        template.sendBody(\"direct:start\", new SendEmail(\"someone@somewhere.org\"));\n\n        assertMockEndpointsSatisfied();\n        assertEntityInDB();\n    }","id":33155,"modified_method":"@Test\n    public void testRouteJpa() throws Exception {\n        // should auto setup transaction manager and entity factory\n        JpaComponent jpa = context.getComponent(\"jpa\", JpaComponent.class);\n        assertNotNull(\"Should have been auto assigned\", jpa.getEntityManagerFactory());\n        assertNotNull(\"Should have been auto assigned\", jpa.getTransactionManager());\n\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedMessageCount(1);\n\n        template.sendBody(\"direct:start\", new SendEmail(\"someone@somewhere.org\"));\n\n        assertMockEndpointsSatisfied();\n        assertEntityInDB(1);\n    }","commit_id":"e696c601329d695a82673227b28ab134644bf52c","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testRouteJpa() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedMessageCount(2);\n\n        template.sendBody(\"direct:start\", new SendEmail(\"one@somewhere.org\"));\n        template.sendBody(\"direct:start\", new SendEmail(\"two@somewhere.org\"));\n        template.sendBody(\"direct:start\", new SendEmail(\"three@somewhere.org\"));\n\n        assertMockEndpointsSatisfied();\n        assertEntityInDB();\n    }","id":33156,"modified_method":"@Test\n    public void testRouteJpa() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedMessageCount(2);\n\n        template.sendBody(\"direct:start\", new SendEmail(\"one@somewhere.org\"));\n        template.sendBody(\"direct:start\", new SendEmail(\"two@somewhere.org\"));\n        template.sendBody(\"direct:start\", new SendEmail(\"three@somewhere.org\"));\n\n        assertMockEndpointsSatisfied();\n        assertEntityInDB(3);\n    }","commit_id":"e696c601329d695a82673227b28ab134644bf52c","url":"https://github.com/apache/camel"},{"original_method":"@After\n    public void tearDown() throws Exception {\n        stopServices(consumer, template, camelContext);\n    }","id":33157,"modified_method":"@After\n    public void tearDown() throws Exception {\n        stopServices(consumer, template, camelContext);\n        entityManager.close();\n    }","commit_id":"e696c601329d695a82673227b28ab134644bf52c","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testProducerInsertsIntoDatabaseThenConsumerFiresMessageExchange() throws Exception {\n        transactionStrategy.execute(new JpaCallback<Object>() {\n            public Object doInJpa(EntityManager entityManager) throws PersistenceException {\n                // lets delete any exiting records before the test\n                entityManager.createQuery(\"delete from \" + entityName).executeUpdate();\n                return null;\n            }\n        });\n\n        List<?> results = jpaTemplate.find(queryText);\n        assertEquals(\"Should have no results: \" + results, 0, results.size());\n\n        // lets produce some objects\n        template.send(endpoint, new Processor() {\n            public void process(Exchange exchange) {\n                exchange.getIn().setBody(new SendEmail(\"foo@bar.com\"));\n            }\n        });\n\n        // now lets assert that there is a result\n        results = jpaTemplate.find(queryText);\n        assertEquals(\"Should have results: \" + results, 1, results.size());\n        SendEmail mail = (SendEmail) results.get(0);\n        assertEquals(\"address property\", \"foo@bar.com\", mail.getAddress());\n\n        // now lets create a consumer to consume it\n        consumer = endpoint.createConsumer(new Processor() {\n            public void process(Exchange e) {\n                LOG.info(\"Received exchange: \" + e.getIn());\n                receivedExchange = e;\n                // should have a JpaTemplate\n                JpaTemplate template = e.getIn().getHeader(JpaConstants.JPA_TEMPLATE, JpaTemplate.class);\n                assertNotNull(\"Should have a JpaTemplate as header\", template);\n                latch.countDown();\n            }\n        });\n        consumer.start();\n\n        assertTrue(latch.await(50, TimeUnit.SECONDS));\n\n        assertNotNull(receivedExchange);\n        SendEmail result = receivedExchange.getIn().getBody(SendEmail.class);\n        assertNotNull(\"Received a POJO\", result);\n        assertEquals(\"address property\", \"foo@bar.com\", result.getAddress());\n    }","id":33158,"modified_method":"@Test\n    public void testProducerInsertsIntoDatabaseThenConsumerFiresMessageExchange() throws Exception {\n    \ttransactionTemplate.execute(new TransactionCallback<Object>() {\n            public Object doInTransaction(TransactionStatus status) {\n            \tentityManager.joinTransaction();\n                // lets delete any exiting records before the test\n                entityManager.createQuery(\"delete from \" + entityName).executeUpdate();\n                return null;\n            }\n        });\n\n        List<?> results = entityManager.createQuery(queryText).getResultList();\n        assertEquals(\"Should have no results: \" + results, 0, results.size());\n\n        // lets produce some objects\n        template.send(endpoint, new Processor() {\n            public void process(Exchange exchange) {\n                exchange.getIn().setBody(new SendEmail(\"foo@bar.com\"));\n            }\n        });\n\n        // now lets assert that there is a result\n        results = entityManager.createQuery(queryText).getResultList();\n        assertEquals(\"Should have results: \" + results, 1, results.size());\n        SendEmail mail = (SendEmail) results.get(0);\n        assertEquals(\"address property\", \"foo@bar.com\", mail.getAddress());\n\n        // now lets create a consumer to consume it\n        consumer = endpoint.createConsumer(new Processor() {\n            public void process(Exchange e) {\n                LOG.info(\"Received exchange: \" + e.getIn());\n                receivedExchange = e;\n                // should have a EntityManager\n                EntityManager entityManager = e.getIn().getHeader(JpaConstants.ENTITYMANAGER, EntityManager.class);\n                assertNotNull(\"Should have a EntityManager as header\", entityManager);\n                latch.countDown();\n            }\n        });\n        consumer.start();\n\n        assertTrue(latch.await(50, TimeUnit.SECONDS));\n\n        assertNotNull(receivedExchange);\n        SendEmail result = receivedExchange.getIn().getBody(SendEmail.class);\n        assertNotNull(\"Received a POJO\", result);\n        assertEquals(\"address property\", \"foo@bar.com\", result.getAddress());\n    }","commit_id":"e696c601329d695a82673227b28ab134644bf52c","url":"https://github.com/apache/camel"},{"original_method":"@Before\n    public void setUp() throws Exception {\n        template = camelContext.createProducerTemplate();\n        startServices(template, camelContext);\n\n        Endpoint value = camelContext.getEndpoint(getEndpointUri());\n        assertNotNull(\"Could not find endpoint!\", value);\n        assertTrue(\"Should be a JPA endpoint but was: \" + value, value instanceof JpaEndpoint);\n        endpoint = (JpaEndpoint) value;\n\n        transactionStrategy = endpoint.createTransactionStrategy();\n        jpaTemplate = endpoint.getTemplate();\n    }","id":33159,"modified_method":"@Before\n    public void setUp() throws Exception {\n        template = camelContext.createProducerTemplate();\n        startServices(template, camelContext);\n\n        Endpoint value = camelContext.getEndpoint(getEndpointUri());\n        assertNotNull(\"Could not find endpoint!\", value);\n        assertTrue(\"Should be a JPA endpoint but was: \" + value, value instanceof JpaEndpoint);\n        endpoint = (JpaEndpoint) value;\n\n        transactionTemplate = endpoint.createTransactionTemplate();\n        entityManager = endpoint.createEntityManager();\n    }","commit_id":"e696c601329d695a82673227b28ab134644bf52c","url":"https://github.com/apache/camel"},{"original_method":"protected void cleanupRepository() {\n        jpaTemplate = applicationContext.getBean(\"jpaTemplate\", JpaTemplate.class);\n\n        TransactionTemplate transactionTemplate = new TransactionTemplate();\n        transactionTemplate.setTransactionManager(new JpaTransactionManager(jpaTemplate.getEntityManagerFactory()));\n        transactionTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);\n\n        transactionTemplate.execute(new TransactionCallback<Object>() {\n            public Object doInTransaction(TransactionStatus arg0) {\n                List<?> list = jpaTemplate.find(SELECT_ALL_STRING);\n                for (Object item : list) {\n                    jpaTemplate.remove(item);\n                }\n                jpaTemplate.flush();\n                return Boolean.TRUE;\n            }\n        });\n    }","id":33160,"modified_method":"protected void cleanupRepository() {\n    \tentityManagerFactory = applicationContext.getBean(\"entityManagerFactory\", EntityManagerFactory.class);\n    \tfinal EntityManager entityManager = entityManagerFactory.createEntityManager();\n        TransactionTemplate transactionTemplate = new TransactionTemplate();\n        transactionTemplate.setTransactionManager(new JpaTransactionManager(entityManagerFactory));\n        transactionTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);\n\n        transactionTemplate.execute(new TransactionCallback<Object>() {\n            public Object doInTransaction(TransactionStatus arg0) {\n                List<?> list = entityManager.createQuery(SELECT_ALL_STRING).getResultList();\n                for (Object item : list) {\n                \tentityManager.remove(item);\n                }\n                entityManager.flush();\n                return Boolean.TRUE;\n            }\n        });\n        \n        entityManager.close();\n    }","commit_id":"e696c601329d695a82673227b28ab134644bf52c","url":"https://github.com/apache/camel"},{"original_method":"private void assertEntityInDB() throws Exception {\n        jpaTemplate = applicationContext.getBean(\"jpaTemplate\", JpaTemplate.class);\n\n        List<?> list = jpaTemplate.find(SELECT_ALL_STRING);\n        assertEquals(1, list.size());\n        \n        JpaTraceEventMessage db = (JpaTraceEventMessage) list.get(0);\n        assertNotNull(db.getId());\n        assertEquals(\"direct://start\", db.getFromEndpointUri());\n        assertEquals(\"mock://result\", db.getToNode());\n        assertEquals(\"foo\", db.getRouteId());\n    }","id":33161,"modified_method":"private void assertEntityInDB() throws Exception {\n    \tentityManagerFactory = applicationContext.getBean(\"entityManagerFactory\", EntityManagerFactory.class);\n    \tEntityManager entityManager = entityManagerFactory.createEntityManager();\n    \t\n        List<?> list = entityManager.createQuery(SELECT_ALL_STRING).getResultList();\n        assertEquals(1, list.size());\n        \n        JpaTraceEventMessage db = (JpaTraceEventMessage) list.get(0);\n        assertNotNull(db.getId());\n        assertEquals(\"direct://start\", db.getFromEndpointUri());\n        assertEquals(\"mock://result\", db.getToNode());\n        assertEquals(\"foo\", db.getRouteId());\n        \n        entityManager.close();\n    }","commit_id":"e696c601329d695a82673227b28ab134644bf52c","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void produceExistingEntity() throws Exception {\n        setUp(\"jpa://\" + Customer.class.getName() + \"?usePersist=false\");\n        \n        final Customer customer = createDefaultCustomer();\n        transactionStrategy.execute(new JpaCallback<Object>() {\n            public Object doInJpa(EntityManager entityManager) throws PersistenceException {\n                entityManager.persist(customer);\n                entityManager.flush();\n                return null;\n            }\n        });\n        \n        assertEntitiesInDatabase(1, Customer.class.getName());\n        assertEntitiesInDatabase(1, Address.class.getName());\n        \n        customer.setName(\"Max Mustermann\");\n        customer.getAddress().setAddressLine1(\"Musterstr. 1\");\n        customer.getAddress().setAddressLine2(\"11111 Enterhausen\");\n        \n        Exchange exchange = new DefaultExchange(camelContext);\n        exchange.getIn().setBody(customer);\n        Exchange returnedExchange = template.send(endpoint, exchange);\n        \n        Customer receivedCustomer = returnedExchange.getIn().getBody(Customer.class);\n        assertEquals(customer.getName(), receivedCustomer.getName());\n        assertNotNull(receivedCustomer.getId());\n        assertEquals(customer.getAddress().getAddressLine1(), receivedCustomer.getAddress().getAddressLine1());\n        assertEquals(customer.getAddress().getAddressLine2(), receivedCustomer.getAddress().getAddressLine2());\n        assertNotNull(receivedCustomer.getAddress().getId());\n        \n        List<?> results = jpaTemplate.find(\"select o from \" + Customer.class.getName() + \" o\");\n        assertEquals(1, results.size());\n        Customer persistedCustomer = (Customer) results.get(0);\n        assertEquals(receivedCustomer.getName(), persistedCustomer.getName());\n        assertEquals(receivedCustomer.getId(), persistedCustomer.getId());\n        assertEquals(receivedCustomer.getAddress().getAddressLine1(), persistedCustomer.getAddress().getAddressLine1());\n        assertEquals(receivedCustomer.getAddress().getAddressLine2(), persistedCustomer.getAddress().getAddressLine2());\n        assertEquals(receivedCustomer.getAddress().getId(), persistedCustomer.getAddress().getId());\n    }","id":33162,"modified_method":"@Test\n    public void produceExistingEntity() throws Exception {\n        setUp(\"jpa://\" + Customer.class.getName() + \"?usePersist=false\");\n        \n        final Customer customer = createDefaultCustomer();\n        transactionTemplate.execute(new TransactionCallback<Object>() {\n            public Object doInTransaction(TransactionStatus status) {\n            \tentityManager.joinTransaction();\n                entityManager.persist(customer);\n                entityManager.flush();\n                return null;\n            }\n        });\n        \n        assertEntitiesInDatabase(1, Customer.class.getName());\n        assertEntitiesInDatabase(1, Address.class.getName());\n        \n        customer.setName(\"Max Mustermann\");\n        customer.getAddress().setAddressLine1(\"Musterstr. 1\");\n        customer.getAddress().setAddressLine2(\"11111 Enterhausen\");\n        \n        Exchange exchange = new DefaultExchange(camelContext);\n        exchange.getIn().setBody(customer);\n        Exchange returnedExchange = template.send(endpoint, exchange);\n        \n        Customer receivedCustomer = returnedExchange.getIn().getBody(Customer.class);\n        assertEquals(customer.getName(), receivedCustomer.getName());\n        assertNotNull(receivedCustomer.getId());\n        assertEquals(customer.getAddress().getAddressLine1(), receivedCustomer.getAddress().getAddressLine1());\n        assertEquals(customer.getAddress().getAddressLine2(), receivedCustomer.getAddress().getAddressLine2());\n        assertNotNull(receivedCustomer.getAddress().getId());\n        \n        List<?> results = entityManager.createQuery(\"select o from \" + Customer.class.getName() + \" o\").getResultList();\n        assertEquals(1, results.size());\n        Customer persistedCustomer = (Customer) results.get(0);\n        assertEquals(receivedCustomer.getName(), persistedCustomer.getName());\n        assertEquals(receivedCustomer.getId(), persistedCustomer.getId());\n        assertEquals(receivedCustomer.getAddress().getAddressLine1(), persistedCustomer.getAddress().getAddressLine1());\n        assertEquals(receivedCustomer.getAddress().getAddressLine2(), persistedCustomer.getAddress().getAddressLine2());\n        assertEquals(receivedCustomer.getAddress().getId(), persistedCustomer.getAddress().getId());\n    }","commit_id":"e696c601329d695a82673227b28ab134644bf52c","url":"https://github.com/apache/camel"},{"original_method":"@After\n    public void tearDown() throws Exception {\n        ServiceHelper.stopServices(consumer, template, camelContext);\n    }","id":33163,"modified_method":"@After\n    public void tearDown() throws Exception {\n        ServiceHelper.stopServices(consumer, template, camelContext);\n        entityManager.close();\n    }","commit_id":"e696c601329d695a82673227b28ab134644bf52c","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testProducerInsertsIntoDatabaseThenConsumerFiresMessageExchange() throws Exception {\n        transactionStrategy.execute(new JpaCallback<Object>() {\n            public Object doInJpa(EntityManager entityManager) throws PersistenceException {\n                // lets delete any exiting records before the test\n                entityManager.createQuery(\"delete from \" + entityName).executeUpdate();\n\n                // now lets create a dummy entry\n                MultiSteps dummy = new MultiSteps(\"cheese\");\n                dummy.setStep(4);\n                entityManager.persist(dummy);\n                return null;\n            }\n        });\n\n        List<?> results = jpaTemplate.find(queryText);\n        assertEquals(\"Should have no results: \" + results, 0, results.size());\n\n        // lets produce some objects\n        template.send(endpoint, new Processor() {\n            public void process(Exchange exchange) {\n                exchange.getIn().setBody(new MultiSteps(\"foo@bar.com\"));\n            }\n        });\n\n        // now lets assert that there is a result\n        results = jpaTemplate.find(queryText);\n        assertEquals(\"Should have results: \" + results, 1, results.size());\n        MultiSteps mail = (MultiSteps)results.get(0);\n        assertEquals(\"address property\", \"foo@bar.com\", mail.getAddress());\n\n        // now lets create a consumer to consume it\n        consumer = endpoint.createConsumer(new Processor() {\n            public void process(Exchange e) {\n                LOG.info(\"Received exchange: \" + e.getIn());\n                receivedExchange = e;\n                latch.countDown();\n            }\n        });\n        consumer.start();\n\n        assertTrue(latch.await(50, TimeUnit.SECONDS));\n\n        assertReceivedResult(receivedExchange);\n\n        // lets now test that the database is updated\n        // we need to sleep as we will be invoked from inside the transaction!\n        Thread.sleep(1000);\n\n        transactionStrategy.execute(new JpaCallback<Object>() {\n            public Object doInJpa(EntityManager entityManager) throws PersistenceException {\n\n                // now lets assert that there are still 2 entities left\n                List<?> rows = entityManager.createQuery(\"select x from MultiSteps x\").getResultList();\n                assertEquals(\"Number of entities: \" + rows, 2, rows.size());\n\n                int counter = 1;\n                for (Object rowObj : rows) {\n                    assertTrue(\"Rows are not instances of MultiSteps\",  rowObj instanceof MultiSteps);\n                    final MultiSteps row = (MultiSteps) rowObj;\n                    LOG.info(\"entity: \" + counter++ + \" = \" + row);\n\n                    if (row.getAddress().equals(\"foo@bar.com\")) {\n                        LOG.info(\"Found updated row: \" + row);\n\n                        assertEquals(\"Updated row step for: \" + row, getUpdatedStepValue(), row.getStep());\n                    } else {\n                        // dummy row\n                        assertEquals(\"dummy row step for: \" + row, 4, row.getStep());\n                    }\n                }\n                return null;\n            }\n        });\n\n        JpaConsumer jpaConsumer = (JpaConsumer) consumer;\n        assertURIQueryOption(jpaConsumer);\n    }","id":33164,"modified_method":"@Test\n    public void testProducerInsertsIntoDatabaseThenConsumerFiresMessageExchange() throws Exception {\n    \ttransactionTemplate.execute(new TransactionCallback<Object>() {\n            public Object doInTransaction(TransactionStatus status) {\n            \tentityManager.joinTransaction();\n                // lets delete any exiting records before the test\n                entityManager.createQuery(\"delete from \" + entityName).executeUpdate();\n\n                // now lets create a dummy entry\n                MultiSteps dummy = new MultiSteps(\"cheese\");\n                dummy.setStep(4);\n                entityManager.persist(dummy);\n                return null;\n            }\n        });\n\n        List<?> results = entityManager.createQuery(queryText).getResultList();\n        assertEquals(\"Should have no results: \" + results, 0, results.size());\n\n        // lets produce some objects\n        template.send(endpoint, new Processor() {\n            public void process(Exchange exchange) {\n                exchange.getIn().setBody(new MultiSteps(\"foo@bar.com\"));\n            }\n        });\n\n        // now lets assert that there is a result\n        results = entityManager.createQuery(queryText).getResultList();\n        assertEquals(\"Should have results: \" + results, 1, results.size());\n        MultiSteps mail = (MultiSteps)results.get(0);\n        assertEquals(\"address property\", \"foo@bar.com\", mail.getAddress());\n\n        // now lets create a consumer to consume it\n        consumer = endpoint.createConsumer(new Processor() {\n            public void process(Exchange e) {\n                LOG.info(\"Received exchange: \" + e.getIn());\n                receivedExchange = e;\n                latch.countDown();\n            }\n        });\n        consumer.start();\n\n        assertTrue(latch.await(50, TimeUnit.SECONDS));\n\n        assertReceivedResult(receivedExchange);\n\n        // lets now test that the database is updated\n        // we need to sleep as we will be invoked from inside the transaction!\n        Thread.sleep(1000);\n\n        transactionTemplate.execute(new TransactionCallback<Object>() {\n            public Object doInTransaction(TransactionStatus status) {\n            \tentityManager.joinTransaction();\n\n                // now lets assert that there are still 2 entities left\n                List<?> rows = entityManager.createQuery(\"select x from MultiSteps x\").getResultList();\n                assertEquals(\"Number of entities: \" + rows, 2, rows.size());\n\n                int counter = 1;\n                for (Object rowObj : rows) {\n                    assertTrue(\"Rows are not instances of MultiSteps\",  rowObj instanceof MultiSteps);\n                    final MultiSteps row = (MultiSteps) rowObj;\n                    LOG.info(\"entity: \" + counter++ + \" = \" + row);\n\n                    if (row.getAddress().equals(\"foo@bar.com\")) {\n                        LOG.info(\"Found updated row: \" + row);\n\n                        assertEquals(\"Updated row step for: \" + row, getUpdatedStepValue(), row.getStep());\n                    } else {\n                        // dummy row\n                        assertEquals(\"dummy row step for: \" + row, 4, row.getStep());\n                    }\n                }\n                return null;\n            }\n        });\n\n        JpaConsumer jpaConsumer = (JpaConsumer) consumer;\n        assertURIQueryOption(jpaConsumer);\n    }","commit_id":"e696c601329d695a82673227b28ab134644bf52c","url":"https://github.com/apache/camel"},{"original_method":"@Before\n    public void setUp() throws Exception {\n        template = camelContext.createProducerTemplate();\n        ServiceHelper.startServices(template, camelContext);\n\n        Endpoint value = camelContext.getEndpoint(getEndpointUri());\n        assertNotNull(\"Could not find endpoint!\", value);\n        assertTrue(\"Should be a JPA endpoint but was: \" + value, value instanceof JpaEndpoint);\n        endpoint = (JpaEndpoint)value;\n\n        transactionStrategy = endpoint.createTransactionStrategy();\n        jpaTemplate = endpoint.getTemplate();\n    }","id":33165,"modified_method":"@Before\n    public void setUp() throws Exception {\n        template = camelContext.createProducerTemplate();\n        ServiceHelper.startServices(template, camelContext);\n\n        Endpoint value = camelContext.getEndpoint(getEndpointUri());\n        assertNotNull(\"Could not find endpoint!\", value);\n        assertTrue(\"Should be a JPA endpoint but was: \" + value, value instanceof JpaEndpoint);\n        endpoint = (JpaEndpoint)value;\n\n        transactionTemplate = endpoint.createTransactionTemplate();\n        entityManager = endpoint.createEntityManager();\n    }","commit_id":"e696c601329d695a82673227b28ab134644bf52c","url":"https://github.com/apache/camel"},{"original_method":"private GitSmartOperationDialog(@NotNull Project project, @NotNull List<Change> changes, @NotNull String operationTitle,\n                                  boolean showForceButton) {\n    super(project);\n    myProject = project;\n    myChanges = changes;\n    myOperationTitle = operationTitle;\n    myShowForceButton = showForceButton;\n    setOKButtonText(\"Smart \" + capitalize(myOperationTitle));\n    setCancelButtonText(\"Don't \" + capitalize(myOperationTitle));\n    getCancelAction().putValue(FOCUSED_ACTION, Boolean.TRUE);\n    init();\n  }","id":33166,"modified_method":"private GitSmartOperationDialog(@NotNull Project project, @NotNull List<Change> changes, @NotNull String operationTitle,\n                                  boolean showForceButton) {\n    super(project);\n    myProject = project;\n    myChanges = changes;\n    myOperationTitle = operationTitle;\n    myShowForceButton = showForceButton;\n    String capitalizedOperation = capitalize(myOperationTitle);\n    setTitle(\"Git \" + capitalizedOperation + \" Problem\");\n    setOKButtonText(\"Smart \" + capitalizedOperation);\n    setCancelButtonText(\"Don't \" + capitalizedOperation);\n    getCancelAction().putValue(FOCUSED_ACTION, Boolean.TRUE);\n    init();\n  }","commit_id":"247b764aaa43e380a3d94a159b35228c240908a6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String calculateDescriptorTaskName(String publicationName) {\n        return String.format(\n                \"generate%sIvyModuleDescriptor\",\n                publicationName.toLowerCase().equals(\"ivy\") ? \"\" : capitalize(publicationName)\n        );\n    }","id":33167,"modified_method":"private String calculateDescriptorTaskName(String publicationName) {\n        return String.format(\"generateDescriptorFileFor%sPublication\", capitalize(publicationName));\n    }","commit_id":"e59c19f028e312283dacfccb7f61c11a0897f6a8","url":"https://github.com/gradle/gradle"},{"original_method":"private String executeMethod(HttpMethod method) throws Exception {\n    HttpClient client = getHttpClient();\n    String entityContent;\n    client.executeMethod(method);\n    // Can't use HttpMethod#getResponseBodyAsString because Trello doesn't specify encoding\n    // in Content-Type header and by default this method decodes from Latin-1\n    entityContent = StreamUtil.readText(method.getResponseBodyAsStream(), \"utf-8\");\n    LOG.debug(entityContent);\n    if (method.getStatusCode() != HttpStatus.SC_OK) {\n      Header header = method.getResponseHeader(\"Content-Type\");\n      if (header != null && header.getValue().startsWith(\"text/plain\")) {\n        throw new Exception(\"Request failed. Reason: \" + StringUtil.capitalize(entityContent));\n      }\n      throw new Exception(\"Request failed with HTTP error: \" + method.getStatusText());\n    }\n    //return new InputStreamReader(method.getResponseBodyAsStream(), \"utf-8\");\n    return entityContent;\n  }","id":33168,"modified_method":"@NotNull\n  private String executeMethod(@NotNull HttpMethod method) throws Exception {\n    HttpClient client = getHttpClient();\n    client.executeMethod(method);\n    String entityContent = ResponseUtil.getResponseContentAsString(method);\n    TaskUtil.prettyFormatJsonToLog(LOG, entityContent);\n    // LOG.debug(\"Response size: \" + method.getResponseHeader(\"Content-Length\").getValue() + \" bytes\");\n    if (method.getStatusCode() != HttpStatus.SC_OK) {\n      Header header = method.getResponseHeader(\"Content-Type\");\n      if (header != null && header.getValue().startsWith(\"text/plain\")) {\n        throw new Exception(TaskBundle.message(\"failure.server.message\", StringUtil.capitalize(entityContent)));\n      }\n      throw new Exception(TaskBundle.message(\"failure.http.error\", method.getStatusCode(), method.getStatusText()));\n    }\n    return entityContent;\n  }","commit_id":"614e90e9eb3d59e3a57df750feafe25cd0acd2e1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public String getName() {\n    final String propName = myProperty.getName();\n    assert propName != null;\n    if (myIsSetter) return \"set\" + StringUtil.capitalize(propName);\n    return \"get\" + StringUtil.capitalize(propName);\n  }","id":33169,"modified_method":"@NotNull\n  public String getName() {\n    final String propName = myProperty.getName();\n    assert propName != null;\n    String capitalized = StringUtil.capitalize(propName);\n    if (myIsSetter) return \"set\" + capitalized;\n    if (PsiType.BOOLEAN.equals(myProperty.getTypeGroovy())) return \"is\" + capitalized;\n    return \"get\" + capitalized;\n  }","commit_id":"263e576f0f358c8b09eda71e5446e25fa9ea6726","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void handleTARArchive(ArchiveStoreContext ctx, FreenetURI key, InputStream data, String element, ArchiveExtractCallback callback, MutableBoolean gotElement, boolean throwAtExit, ObjectContainer container, ClientContext context) throws ArchiveFailureException, ArchiveRestartException {\n\t\tif(logMINOR) Logger.minor(this, \"Handling a TAR Archive\");\n\t\tTarInputStream tarIS = null;\n\t\ttry {\n\t\t\ttarIS = new TarInputStream(data);\n\t\t\t\n\t\t\t// MINOR: Assumes the first entry in the tarball is a directory. \n\t\t\tTarEntry entry;\n\t\t\t\n\t\t\tbyte[] buf = new byte[32768];\n\t\t\tHashSet<String> names = new HashSet<String>();\n\t\t\tboolean gotMetadata = false;\n\t\t\t\nouterTAR:\t\twhile(true) {\n\t\t\t\tentry = tarIS.getNextEntry();\n\t\t\t\tif(entry == null) break;\n\t\t\t\tif(entry.isDirectory()) continue;\n\t\t\t\tString name = entry.getName();\n\t\t\t\tif(names.contains(name)) {\n\t\t\t\t\tLogger.error(this, \"Duplicate key \"+name+\" in archive \"+key);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlong size = entry.getSize();\n\t\t\t\tif(size > maxArchivedFileSize) {\n\t\t\t\t\taddErrorElement(ctx, key, name, \"File too big: \"+maxArchivedFileSize+\" greater than current archived file size limit \"+maxArchivedFileSize);\n\t\t\t\t} else {\n\t\t\t\t\t// Read the element\n\t\t\t\t\tlong realLen = 0;\n\t\t\t\t\tBucket output = tempBucketFactory.makeBucket(size);\n\t\t\t\t\tOutputStream out = output.getOutputStream();\n\n\t\t\t\t\tint readBytes;\n\t\t\t\t\twhile((readBytes = tarIS.read(buf)) > 0) {\n\t\t\t\t\t\tout.write(buf, 0, readBytes);\n\t\t\t\t\t\treadBytes += realLen;\n\t\t\t\t\t\tif(readBytes > maxArchivedFileSize) {\n\t\t\t\t\t\t\taddErrorElement(ctx, key, name, \"File too big: \"+maxArchivedFileSize+\" greater than current archived file size limit \"+maxArchivedFileSize);\n\t\t\t\t\t\t\tout.close();\n\t\t\t\t\t\t\toutput.free();\n\t\t\t\t\t\t\tcontinue outerTAR;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tout.close();\n\t\t\t\t\tif(name.equals(\".metadata\"))\n\t\t\t\t\t\tgotMetadata = true;\n\t\t\t\t\taddStoreElement(ctx, key, name, output, gotElement, element, callback, container, context);\n\t\t\t\t\tnames.add(name);\n\t\t\t\t\ttrimStoredData();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If no metadata, generate some\n\t\t\tif(!gotMetadata) {\n\t\t\t\tgenerateMetadata(ctx, key, names, gotElement, element, callback, container, context);\n\t\t\t\ttrimStoredData();\n\t\t\t}\n\t\t\tif(throwAtExit) throw new ArchiveRestartException(\"Archive changed on re-fetch\");\n\t\t\t\n\t\t\tif((!gotElement.value) && element != null)\n\t\t\t\tcallback.notInArchive(container, context);\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\tthrow new ArchiveFailureException(\"Error reading archive: \"+e.getMessage(), e);\n\t\t} finally {\n\t\t\tCloser.close(tarIS);\n\t\t}\n\t}","id":33170,"modified_method":"private void handleTARArchive(ArchiveStoreContext ctx, FreenetURI key, InputStream data, String element, ArchiveExtractCallback callback, MutableBoolean gotElement, boolean throwAtExit, ObjectContainer container, ClientContext context) throws ArchiveFailureException, ArchiveRestartException {\n\t\tif(logMINOR) Logger.minor(this, \"Handling a TAR Archive\");\n\t\tTarInputStream tarIS = null;\n\t\ttry {\n\t\t\ttarIS = new TarInputStream(data);\n\t\t\t\n\t\t\t// MINOR: Assumes the first entry in the tarball is a directory. \n\t\t\tTarEntry entry;\n\t\t\t\n\t\t\tbyte[] buf = new byte[32768];\n\t\t\tHashSet<String> names = new HashSet<String>();\n\t\t\tboolean gotMetadata = false;\n\t\t\t\nouterTAR:\t\twhile(true) {\n\t\t\t\tentry = tarIS.getNextEntry();\n\t\t\t\tif(entry == null) break;\n\t\t\t\tif(entry.isDirectory()) continue;\n\t\t\t\tString name = entry.getName();\n\t\t\t\tif(names.contains(name)) {\n\t\t\t\t\tLogger.error(this, \"Duplicate key \"+name+\" in archive \"+key);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlong size = entry.getSize();\n\t\t\t\tif(name.equals(\".metadata\"))\n\t\t\t\t\tgotMetadata = true;\n\t\t\t\tif(size > maxArchivedFileSize && !name.equals(element)) {\n\t\t\t\t\taddErrorElement(ctx, key, name, \"File too big: \"+size+\" greater than current archived file size limit \"+maxArchivedFileSize, true);\n\t\t\t\t} else {\n\t\t\t\t\t// Read the element\n\t\t\t\t\tlong realLen = 0;\n\t\t\t\t\tBucket output = tempBucketFactory.makeBucket(size);\n\t\t\t\t\tOutputStream out = output.getOutputStream();\n\n\t\t\t\t\tint readBytes;\n\t\t\t\t\twhile((readBytes = tarIS.read(buf)) > 0) {\n\t\t\t\t\t\tout.write(buf, 0, readBytes);\n\t\t\t\t\t\treadBytes += realLen;\n\t\t\t\t\t\tif(readBytes > maxArchivedFileSize) {\n\t\t\t\t\t\t\taddErrorElement(ctx, key, name, \"File too big: \"+maxArchivedFileSize+\" greater than current archived file size limit \"+maxArchivedFileSize, true);\n\t\t\t\t\t\t\tout.close();\n\t\t\t\t\t\t\toutput.free();\n\t\t\t\t\t\t\tcontinue outerTAR;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tout.close();\n\t\t\t\t\tif(size <= maxArchivedFileSize) {\n\t\t\t\t\t\taddStoreElement(ctx, key, name, output, gotElement, element, callback, container, context);\n\t\t\t\t\t\tnames.add(name);\n\t\t\t\t\t\ttrimStoredData();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcallback.gotBucket(output, container, context);\n\t\t\t\t\t\tgotElement.value = true;\n\t\t\t\t\t\taddErrorElement(ctx, key, name, \"File too big: \"+size+\" greater than current archived file size limit \"+maxArchivedFileSize, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If no metadata, generate some\n\t\t\tif(!gotMetadata) {\n\t\t\t\tgenerateMetadata(ctx, key, names, gotElement, element, callback, container, context);\n\t\t\t\ttrimStoredData();\n\t\t\t}\n\t\t\tif(throwAtExit) throw new ArchiveRestartException(\"Archive changed on re-fetch\");\n\t\t\t\n\t\t\tif((!gotElement.value) && element != null)\n\t\t\t\tcallback.notInArchive(container, context);\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\tthrow new ArchiveFailureException(\"Error reading archive: \"+e.getMessage(), e);\n\t\t} finally {\n\t\t\tCloser.close(tarIS);\n\t\t}\n\t}","commit_id":"7fcbc32590e534853f93e6a4aba03dd7c0a82294","url":"https://github.com/freenet/fred"},{"original_method":"private void handleZIPArchive(ArchiveStoreContext ctx, FreenetURI key, InputStream data, String element, ArchiveExtractCallback callback, MutableBoolean gotElement, boolean throwAtExit, ObjectContainer container, ClientContext context) throws ArchiveFailureException, ArchiveRestartException {\n\t\tif(logMINOR) Logger.minor(this, \"Handling a ZIP Archive\");\n\t\tZipInputStream zis = null;\n\t\ttry {\n\t\t\tzis = new ZipInputStream(data);\n\t\t\t\n\t\t\t// MINOR: Assumes the first entry in the zip is a directory. \n\t\t\tZipEntry entry;\n\t\t\t\n\t\t\tbyte[] buf = new byte[32768];\n\t\t\tHashSet<String> names = new HashSet<String>();\n\t\t\tboolean gotMetadata = false;\n\t\t\t\nouterZIP:\t\twhile(true) {\n\t\t\t\tentry = zis.getNextEntry();\n\t\t\t\tif(entry == null) break;\n\t\t\t\tif(entry.isDirectory()) continue;\n\t\t\t\tString name = entry.getName();\n\t\t\t\tif(names.contains(name)) {\n\t\t\t\t\tLogger.error(this, \"Duplicate key \"+name+\" in archive \"+key);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlong size = entry.getSize();\n\t\t\t\tif(size > maxArchivedFileSize) {\n\t\t\t\t\taddErrorElement(ctx, key, name, \"File too big: \"+maxArchivedFileSize+\" greater than current archived file size limit \"+maxArchivedFileSize);\n\t\t\t\t} else {\n\t\t\t\t\t// Read the element\n\t\t\t\t\tlong realLen = 0;\n\t\t\t\t\tBucket output = tempBucketFactory.makeBucket(size);\n\t\t\t\t\tOutputStream out = output.getOutputStream();\n\n\t\t\t\t\tint readBytes;\n\t\t\t\t\twhile((readBytes = zis.read(buf)) > 0) {\n\t\t\t\t\t\tout.write(buf, 0, readBytes);\n\t\t\t\t\t\treadBytes += realLen;\n\t\t\t\t\t\tif(readBytes > maxArchivedFileSize) {\n\t\t\t\t\t\t\taddErrorElement(ctx, key, name, \"File too big: \"+maxArchivedFileSize+\" greater than current archived file size limit \"+maxArchivedFileSize);\n\t\t\t\t\t\t\tout.close();\n\t\t\t\t\t\t\toutput.free();\n\t\t\t\t\t\t\tcontinue outerZIP;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tout.close();\n\t\t\t\t\tif(name.equals(\".metadata\"))\n\t\t\t\t\t\tgotMetadata = true;\n\t\t\t\t\taddStoreElement(ctx, key, name, output, gotElement, element, callback, container, context);\n\t\t\t\t\tnames.add(name);\n\t\t\t\t\ttrimStoredData();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If no metadata, generate some\n\t\t\tif(!gotMetadata) {\n\t\t\t\tgenerateMetadata(ctx, key, names, gotElement, element, callback, container, context);\n\t\t\t\ttrimStoredData();\n\t\t\t}\n\t\t\tif(throwAtExit) throw new ArchiveRestartException(\"Archive changed on re-fetch\");\n\t\t\t\n\t\t\tif((!gotElement.value) && element != null)\n\t\t\t\tcallback.notInArchive(container, context);\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\tthrow new ArchiveFailureException(\"Error reading archive: \"+e.getMessage(), e);\n\t\t} finally {\n\t\t\tif(zis != null) {\n\t\t\t\ttry {\n\t\t\t\t\tzis.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLogger.error(this, \"Failed to close stream: \"+e, e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":33171,"modified_method":"private void handleZIPArchive(ArchiveStoreContext ctx, FreenetURI key, InputStream data, String element, ArchiveExtractCallback callback, MutableBoolean gotElement, boolean throwAtExit, ObjectContainer container, ClientContext context) throws ArchiveFailureException, ArchiveRestartException {\n\t\tif(logMINOR) Logger.minor(this, \"Handling a ZIP Archive\");\n\t\tZipInputStream zis = null;\n\t\ttry {\n\t\t\tzis = new ZipInputStream(data);\n\t\t\t\n\t\t\t// MINOR: Assumes the first entry in the zip is a directory. \n\t\t\tZipEntry entry;\n\t\t\t\n\t\t\tbyte[] buf = new byte[32768];\n\t\t\tHashSet<String> names = new HashSet<String>();\n\t\t\tboolean gotMetadata = false;\n\t\t\t\nouterZIP:\t\twhile(true) {\n\t\t\t\tentry = zis.getNextEntry();\n\t\t\t\tif(entry == null) break;\n\t\t\t\tif(entry.isDirectory()) continue;\n\t\t\t\tString name = entry.getName();\n\t\t\t\tif(names.contains(name)) {\n\t\t\t\t\tLogger.error(this, \"Duplicate key \"+name+\" in archive \"+key);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlong size = entry.getSize();\n\t\t\t\tif(size > maxArchivedFileSize) {\n\t\t\t\t\taddErrorElement(ctx, key, name, \"File too big: \"+maxArchivedFileSize+\" greater than current archived file size limit \"+maxArchivedFileSize, true);\n\t\t\t\t} else {\n\t\t\t\t\t// Read the element\n\t\t\t\t\tlong realLen = 0;\n\t\t\t\t\tBucket output = tempBucketFactory.makeBucket(size);\n\t\t\t\t\tOutputStream out = output.getOutputStream();\n\n\t\t\t\t\tint readBytes;\n\t\t\t\t\twhile((readBytes = zis.read(buf)) > 0) {\n\t\t\t\t\t\tout.write(buf, 0, readBytes);\n\t\t\t\t\t\treadBytes += realLen;\n\t\t\t\t\t\tif(readBytes > maxArchivedFileSize) {\n\t\t\t\t\t\t\taddErrorElement(ctx, key, name, \"File too big: \"+maxArchivedFileSize+\" greater than current archived file size limit \"+maxArchivedFileSize, true);\n\t\t\t\t\t\t\tout.close();\n\t\t\t\t\t\t\toutput.free();\n\t\t\t\t\t\t\tcontinue outerZIP;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tout.close();\n\t\t\t\t\tif(name.equals(\".metadata\"))\n\t\t\t\t\t\tgotMetadata = true;\n\t\t\t\t\taddStoreElement(ctx, key, name, output, gotElement, element, callback, container, context);\n\t\t\t\t\tnames.add(name);\n\t\t\t\t\ttrimStoredData();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If no metadata, generate some\n\t\t\tif(!gotMetadata) {\n\t\t\t\tgenerateMetadata(ctx, key, names, gotElement, element, callback, container, context);\n\t\t\t\ttrimStoredData();\n\t\t\t}\n\t\t\tif(throwAtExit) throw new ArchiveRestartException(\"Archive changed on re-fetch\");\n\t\t\t\n\t\t\tif((!gotElement.value) && element != null)\n\t\t\t\tcallback.notInArchive(container, context);\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\tthrow new ArchiveFailureException(\"Error reading archive: \"+e.getMessage(), e);\n\t\t} finally {\n\t\t\tif(zis != null) {\n\t\t\t\ttry {\n\t\t\t\t\tzis.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLogger.error(this, \"Failed to close stream: \"+e, e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"7fcbc32590e534853f93e6a4aba03dd7c0a82294","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Add an error element to the cache. This happens when a single file in the archive\n\t * is invalid (usually because it is too large).\n\t * @param ctx The ArchiveStoreContext which must be notified about this element's creation.\n\t * @param key The key from which the archive was fetched.\n\t * @param name The name of the file within the archive.\n\t * @param error The error message to be included on the eventual exception thrown,\n\t * if anyone tries to extract the data for this element.\n\t */\n\tprivate void addErrorElement(ArchiveStoreContext ctx, FreenetURI key, String name, String error) {\n\t\tErrorArchiveStoreItem element = new ErrorArchiveStoreItem(ctx, key, name, error);\n\t\tif(logMINOR) Logger.minor(this, \"Adding error element: \"+element+\" for \"+key+ ' ' +name);\n\t\tArchiveStoreItem oldItem;\n\t\tsynchronized (this) {\n\t\t\toldItem = storedData.get(element.key);\n\t\t\tstoredData.push(element.key, element);\t\n\t\t\tif(oldItem != null) {\n\t\t\t\toldItem.close();\n\t\t\t\tcachedData -= oldItem.spaceUsed();\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Dropping old store element from archive cache: \"+oldItem);\n\t\t\t}\n\t\t}\n\t}","id":33172,"modified_method":"/**\n\t * Add an error element to the cache. This happens when a single file in the archive\n\t * is invalid (usually because it is too large).\n\t * @param ctx The ArchiveStoreContext which must be notified about this element's creation.\n\t * @param key The key from which the archive was fetched.\n\t * @param name The name of the file within the archive.\n\t * @param error The error message to be included on the eventual exception thrown,\n\t * if anyone tries to extract the data for this element.\n\t */\n\tprivate void addErrorElement(ArchiveStoreContext ctx, FreenetURI key, String name, String error, boolean tooBig) {\n\t\tErrorArchiveStoreItem element = new ErrorArchiveStoreItem(ctx, key, name, error, tooBig);\n\t\tif(logMINOR) Logger.minor(this, \"Adding error element: \"+element+\" for \"+key+ ' ' +name);\n\t\tArchiveStoreItem oldItem;\n\t\tsynchronized (this) {\n\t\t\toldItem = storedData.get(element.key);\n\t\t\tstoredData.push(element.key, element);\t\n\t\t\tif(oldItem != null) {\n\t\t\t\toldItem.close();\n\t\t\t\tcachedData -= oldItem.spaceUsed();\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Dropping old store element from archive cache: \"+oldItem);\n\t\t\t}\n\t\t}\n\t}","commit_id":"7fcbc32590e534853f93e6a4aba03dd7c0a82294","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\tBucket getReaderBucket() throws ArchiveFailureException {\n\t\tthrow new ArchiveFailureException(error);\n\t}","id":33173,"modified_method":"@Override\n\tBucket getReaderBucket() throws ArchiveFailureException {\n\t\tif(tooBig) return null;\n\t\tthrow new ArchiveFailureException(error);\n\t}","commit_id":"7fcbc32590e534853f93e6a4aba03dd7c0a82294","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Create a placeholder item for a file which could not be extracted from the archive.\n\t * @param ctx The context object which tracks all the items with this key.\n\t * @param key2 The key from which the archive was fetched.\n\t * @param name The name of the file which failed to extract.\n\t * @param error The error message to be included in the thrown exception when\n\t * somebody tries to get the data.\n\t */\n\tpublic ErrorArchiveStoreItem(ArchiveStoreContext ctx, FreenetURI key2, String name, String error) {\n\t\tsuper(new ArchiveKey(key2, name), ctx);\n\t\tthis.error = error;\n\t}","id":33174,"modified_method":"/**\n\t * Create a placeholder item for a file which could not be extracted from the archive.\n\t * @param ctx The context object which tracks all the items with this key.\n\t * @param key2 The key from which the archive was fetched.\n\t * @param name The name of the file which failed to extract.\n\t * @param error The error message to be included in the thrown exception when\n\t * somebody tries to get the data.\n\t */\n\tpublic ErrorArchiveStoreItem(ArchiveStoreContext ctx, FreenetURI key2, String name, String error, boolean tooBig) {\n\t\tsuper(new ArchiveKey(key2, name), ctx);\n\t\tthis.error = error;\n\t\tthis.tooBig = tooBig;\n\t}","commit_id":"7fcbc32590e534853f93e6a4aba03dd7c0a82294","url":"https://github.com/freenet/fred"},{"original_method":"private void handleZIPArchive(ArchiveStoreContext ctx, FreenetURI key, InputStream data, String element, ArchiveExtractCallback callback, MutableBoolean gotElement, boolean throwAtExit, ObjectContainer container, ClientContext context) throws ArchiveFailureException, ArchiveRestartException {\n\t\tif(logMINOR) Logger.minor(this, \"Handling a ZIP Archive\");\n\t\tZipInputStream zis = null;\n\t\ttry {\n\t\t\tzis = new ZipInputStream(data);\n\t\t\t\n\t\t\t// MINOR: Assumes the first entry in the zip is a directory. \n\t\t\tZipEntry entry;\n\t\t\t\n\t\t\tbyte[] buf = new byte[32768];\n\t\t\tHashSet<String> names = new HashSet<String>();\n\t\t\tboolean gotMetadata = false;\n\t\t\t\nouterZIP:\t\twhile(true) {\n\t\t\t\tentry = zis.getNextEntry();\n\t\t\t\tif(entry == null) break;\n\t\t\t\tif(entry.isDirectory()) continue;\n\t\t\t\tString name = entry.getName();\n\t\t\t\tif(names.contains(name)) {\n\t\t\t\t\tLogger.error(this, \"Duplicate key \"+name+\" in archive \"+key);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlong size = entry.getSize();\n\t\t\t\tif(size > maxArchivedFileSize) {\n\t\t\t\t\taddErrorElement(ctx, key, name, \"File too big: \"+maxArchivedFileSize+\" greater than current archived file size limit \"+maxArchivedFileSize, true);\n\t\t\t\t} else {\n\t\t\t\t\t// Read the element\n\t\t\t\t\tlong realLen = 0;\n\t\t\t\t\tBucket output = tempBucketFactory.makeBucket(size);\n\t\t\t\t\tOutputStream out = output.getOutputStream();\n\n\t\t\t\t\tint readBytes;\n\t\t\t\t\twhile((readBytes = zis.read(buf)) > 0) {\n\t\t\t\t\t\tout.write(buf, 0, readBytes);\n\t\t\t\t\t\treadBytes += realLen;\n\t\t\t\t\t\tif(readBytes > maxArchivedFileSize) {\n\t\t\t\t\t\t\taddErrorElement(ctx, key, name, \"File too big: \"+maxArchivedFileSize+\" greater than current archived file size limit \"+maxArchivedFileSize, true);\n\t\t\t\t\t\t\tout.close();\n\t\t\t\t\t\t\toutput.free();\n\t\t\t\t\t\t\tcontinue outerZIP;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tout.close();\n\t\t\t\t\tif(name.equals(\".metadata\"))\n\t\t\t\t\t\tgotMetadata = true;\n\t\t\t\t\taddStoreElement(ctx, key, name, output, gotElement, element, callback, container, context);\n\t\t\t\t\tnames.add(name);\n\t\t\t\t\ttrimStoredData();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If no metadata, generate some\n\t\t\tif(!gotMetadata) {\n\t\t\t\tgenerateMetadata(ctx, key, names, gotElement, element, callback, container, context);\n\t\t\t\ttrimStoredData();\n\t\t\t}\n\t\t\tif(throwAtExit) throw new ArchiveRestartException(\"Archive changed on re-fetch\");\n\t\t\t\n\t\t\tif((!gotElement.value) && element != null)\n\t\t\t\tcallback.notInArchive(container, context);\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\tthrow new ArchiveFailureException(\"Error reading archive: \"+e.getMessage(), e);\n\t\t} finally {\n\t\t\tif(zis != null) {\n\t\t\t\ttry {\n\t\t\t\t\tzis.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLogger.error(this, \"Failed to close stream: \"+e, e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":33175,"modified_method":"private void handleZIPArchive(ArchiveStoreContext ctx, FreenetURI key, InputStream data, String element, ArchiveExtractCallback callback, MutableBoolean gotElement, boolean throwAtExit, ObjectContainer container, ClientContext context) throws ArchiveFailureException, ArchiveRestartException {\n\t\tif(logMINOR) Logger.minor(this, \"Handling a ZIP Archive\");\n\t\tZipInputStream zis = null;\n\t\ttry {\n\t\t\tzis = new ZipInputStream(data);\n\t\t\t\n\t\t\t// MINOR: Assumes the first entry in the zip is a directory. \n\t\t\tZipEntry entry;\n\t\t\t\n\t\t\tbyte[] buf = new byte[32768];\n\t\t\tHashSet<String> names = new HashSet<String>();\n\t\t\tboolean gotMetadata = false;\n\t\t\t\nouterZIP:\t\twhile(true) {\n\t\t\t\tentry = zis.getNextEntry();\n\t\t\t\tif(entry == null) break;\n\t\t\t\tif(entry.isDirectory()) continue;\n\t\t\t\tString name = entry.getName();\n\t\t\t\tif(names.contains(name)) {\n\t\t\t\t\tLogger.error(this, \"Duplicate key \"+name+\" in archive \"+key);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlong size = entry.getSize();\n\t\t\t\tif(name.equals(\".metadata\"))\n\t\t\t\t\tgotMetadata = true;\n\t\t\t\tif(size > maxArchivedFileSize && !name.equals(element)) {\n\t\t\t\t\taddErrorElement(ctx, key, name, \"File too big: \"+maxArchivedFileSize+\" greater than current archived file size limit \"+maxArchivedFileSize, true);\n\t\t\t\t} else {\n\t\t\t\t\t// Read the element\n\t\t\t\t\tlong realLen = 0;\n\t\t\t\t\tBucket output = tempBucketFactory.makeBucket(size);\n\t\t\t\t\tOutputStream out = output.getOutputStream();\n\n\t\t\t\t\tint readBytes;\n\t\t\t\t\twhile((readBytes = zis.read(buf)) > 0) {\n\t\t\t\t\t\tout.write(buf, 0, readBytes);\n\t\t\t\t\t\treadBytes += realLen;\n\t\t\t\t\t\tif(readBytes > maxArchivedFileSize) {\n\t\t\t\t\t\t\taddErrorElement(ctx, key, name, \"File too big: \"+maxArchivedFileSize+\" greater than current archived file size limit \"+maxArchivedFileSize, true);\n\t\t\t\t\t\t\tout.close();\n\t\t\t\t\t\t\toutput.free();\n\t\t\t\t\t\t\tcontinue outerZIP;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tout.close();\n\t\t\t\t\tif(size <= maxArchivedFileSize) {\n\t\t\t\t\t\taddStoreElement(ctx, key, name, output, gotElement, element, callback, container, context);\n\t\t\t\t\t\tnames.add(name);\n\t\t\t\t\t\ttrimStoredData();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcallback.gotBucket(output, container, context);\n\t\t\t\t\t\tgotElement.value = true;\n\t\t\t\t\t\taddErrorElement(ctx, key, name, \"File too big: \"+size+\" greater than current archived file size limit \"+maxArchivedFileSize, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If no metadata, generate some\n\t\t\tif(!gotMetadata) {\n\t\t\t\tgenerateMetadata(ctx, key, names, gotElement, element, callback, container, context);\n\t\t\t\ttrimStoredData();\n\t\t\t}\n\t\t\tif(throwAtExit) throw new ArchiveRestartException(\"Archive changed on re-fetch\");\n\t\t\t\n\t\t\tif((!gotElement.value) && element != null)\n\t\t\t\tcallback.notInArchive(container, context);\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\tthrow new ArchiveFailureException(\"Error reading archive: \"+e.getMessage(), e);\n\t\t} finally {\n\t\t\tif(zis != null) {\n\t\t\t\ttry {\n\t\t\t\t\tzis.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLogger.error(this, \"Failed to close stream: \"+e, e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"d3bee4fde7704224adcaa633bdcdbfa31c838801","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Generate fake metadata for an archive which doesn't have any.\n\t * @param ctx The context object.\n\t * @param key The key from which the archive we are unpacking was fetched.\n\t * @param names Set of names in the archive.\n\t * @throws ArchiveFailureException \n\t */\n\tprivate void generateMetadata(ArchiveStoreContext ctx, FreenetURI key, HashSet names) throws ArchiveFailureException {\n\t\t/* What we have to do is to:\n\t\t * - Construct a filesystem tree of the names.\n\t\t * - Turn each level of the tree into a Metadata object, including those below it, with\n\t\t * simple manifests and archive internal redirects.\n\t\t * - Turn the master Metadata object into binary metadata, with all its subsidiaries.\n\t\t * - Create a .metadata entry containing this data.\n\t\t */\n\t\t// Root directory.\n\t\t// String -> either itself, or another HashMap\n\t\tHashMap dir = new HashMap();\n\t\tIterator i = names.iterator();\n\t\twhile(i.hasNext()) {\n\t\t\tString name = (String) i.next();\n\t\t\taddToDirectory(dir, name, \"\");\n\t\t}\n\t\tMetadata metadata = new Metadata(dir);\n\t\tTempStoreElement element = makeTempStoreBucket(-1);\n\t\tint x = 0;\n\t\twhile(true) {\n\t\t\ttry {\n\t\t\t\tbyte[] buf = metadata.writeToByteArray();\n\t\t\t\tOutputStream os = element.bucket.getOutputStream();\n\t\t\t\tos.write(buf);\n\t\t\t\tos.close();\n\t\t\t\taddStoreElement(ctx, key, \".metadata\", element);\n\t\t\t\tbreak;\n\t\t\t} catch (MetadataUnresolvedException e) {\n\t\t\t\ttry {\n\t\t\t\t\tx = resolve(e, x, element, ctx, key);\n\t\t\t\t} catch (IOException e1) {\n\t\t\t\t\tthrow new ArchiveFailureException(\"Failed to create metadata: \"+e1, e1);\n\t\t\t\t}\n\t\t\t} catch (IOException e1) {\n\t\t\t\tthrow new ArchiveFailureException(\"Failed to create metadata: \"+e1, e1);\n\t\t\t}\n\t\t}\n\t}","id":33176,"modified_method":"/**\n\t * Generate fake metadata for an archive which doesn't have any.\n\t * @param ctx The context object.\n\t * @param key The key from which the archive we are unpacking was fetched.\n\t * @param names Set of names in the archive.\n\t * @throws ArchiveFailureException \n\t */\n\tprivate ArchiveStoreItem generateMetadata(ArchiveStoreContext ctx, FreenetURI key, HashSet names) throws ArchiveFailureException {\n\t\t/* What we have to do is to:\n\t\t * - Construct a filesystem tree of the names.\n\t\t * - Turn each level of the tree into a Metadata object, including those below it, with\n\t\t * simple manifests and archive internal redirects.\n\t\t * - Turn the master Metadata object into binary metadata, with all its subsidiaries.\n\t\t * - Create a .metadata entry containing this data.\n\t\t */\n\t\t// Root directory.\n\t\t// String -> either itself, or another HashMap\n\t\tHashMap dir = new HashMap();\n\t\tIterator i = names.iterator();\n\t\twhile(i.hasNext()) {\n\t\t\tString name = (String) i.next();\n\t\t\taddToDirectory(dir, name, \"\");\n\t\t}\n\t\tMetadata metadata = new Metadata(dir);\n\t\tTempStoreElement element = makeTempStoreBucket(-1);\n\t\tint x = 0;\n\t\twhile(true) {\n\t\t\ttry {\n\t\t\t\tbyte[] buf = metadata.writeToByteArray();\n\t\t\t\tOutputStream os = element.bucket.getOutputStream();\n\t\t\t\tos.write(buf);\n\t\t\t\tos.close();\n\t\t\t\treturn addStoreElement(ctx, key, \".metadata\", element);\n\t\t\t} catch (MetadataUnresolvedException e) {\n\t\t\t\ttry {\n\t\t\t\t\tx = resolve(e, x, element, ctx, key);\n\t\t\t\t} catch (IOException e1) {\n\t\t\t\t\tthrow new ArchiveFailureException(\"Failed to create metadata: \"+e1, e1);\n\t\t\t\t}\n\t\t\t} catch (IOException e1) {\n\t\t\t\tthrow new ArchiveFailureException(\"Failed to create metadata: \"+e1, e1);\n\t\t\t}\n\t\t}\n\t}","commit_id":"cfbe41b63ad0b52191edb159fa9ed2dcd4eeae96","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Extract data to cache. Call synchronized on ctx.\n\t * @param key The key the data was fetched from.\n\t * @param archiveType The archive type. Must be Metadata.ARCHIVE_ZIP.\n\t * @param data The actual data fetched.\n\t * @param archiveContext The context for the whole fetch process.\n\t * @param ctx The ArchiveStoreContext for this key.\n\t * @throws ArchiveFailureException If we could not extract the data, or it was too big, etc.\n\t * @throws ArchiveRestartException \n\t * @throws ArchiveRestartException If the request needs to be restarted because the archive\n\t * changed.\n\t */\n\tpublic void extractToCache(FreenetURI key, short archiveType, Bucket data, ArchiveContext archiveContext, ArchiveStoreContext ctx) throws ArchiveFailureException, ArchiveRestartException {\n\t\t\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\t\n\t\tif(logMINOR) Logger.minor(this, \"Extracting \"+key);\n\t\tctx.onExtract();\n\t\tctx.removeAllCachedItems(); // flush cache anyway\n\t\tlong expectedSize = ctx.getLastSize();\n\t\tlong archiveSize = data.size();\n\t\t/** Set if we need to throw a RestartedException rather than returning success,\n\t\t * after we have unpacked everything.\n\t\t */\n\t\tboolean throwAtExit = false;\n\t\tif((expectedSize != -1) && (archiveSize != expectedSize)) {\n\t\t\tthrowAtExit = true;\n\t\t\tctx.setLastSize(archiveSize);\n\t\t}\n\t\tbyte[] expectedHash = ctx.getLastHash();\n\t\tif(expectedHash != null) {\n\t\t\tbyte[] realHash;\n\t\t\ttry {\n\t\t\t\trealHash = BucketTools.hash(data);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new ArchiveFailureException(\"Error reading archive data: \"+e, e);\n\t\t\t}\n\t\t\tif(!Arrays.equals(realHash, expectedHash))\n\t\t\t\tthrowAtExit = true;\n\t\t\tctx.setLastHash(realHash);\n\t\t}\n\t\tif(data.size() > maxArchiveSize)\n\t\t\tthrow new ArchiveFailureException(\"Archive too big\");\n\t\tif(archiveType != Metadata.ARCHIVE_ZIP)\n\t\t\tthrow new ArchiveFailureException(\"Unknown or unsupported archive algorithm \"+archiveType);\n\t\t\n\t\tZipInputStream zis = null;\n\t\ttry {\n\t\t\tzis = new ZipInputStream(data.getInputStream());\n\t\t\t\n\t\t\t// MINOR: Assumes the first entry in the zip is a directory. \n\t\t\tZipEntry entry;\n\t\t\t\n\t\t\tbyte[] buf = new byte[4096];\n\t\t\tHashSet names = new HashSet();\n\t\t\tboolean gotMetadata = false;\n\t\t\t\nouter:\t\twhile(true) {\n\t\t\t\tentry = zis.getNextEntry();\n\t\t\t\tif(entry == null) break;\n\t\t\t\tif(entry.isDirectory()) continue;\n\t\t\t\tString name = entry.getName();\n\t\t\t\tif(names.contains(name)) {\n\t\t\t\t\tLogger.error(this, \"Duplicate key \"+name+\" in archive \"+key);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlong size = entry.getSize();\n\t\t\t\tif(size > maxArchivedFileSize) {\n\t\t\t\t\taddErrorElement(ctx, key, name, \"File too big: \"+maxArchivedFileSize+\" greater than current archived file size limit \"+maxArchivedFileSize);\n\t\t\t\t} else {\n\t\t\t\t\t// Read the element\n\t\t\t\t\tlong realLen = 0;\n\t\t\t\t\tTempStoreElement temp = makeTempStoreBucket(size);\n\t\t\t\t\tBucket output = temp.bucket;\n\t\t\t\t\tOutputStream out = output.getOutputStream();\n\n\t\t\t\t\tint readBytes;\n\t\t\t\t\twhile((readBytes = zis.read(buf)) > 0) {\n\t\t\t\t\t\tout.write(buf, 0, readBytes);\n\t\t\t\t\t\treadBytes += realLen;\n\t\t\t\t\t\tif(readBytes > maxArchivedFileSize) {\n\t\t\t\t\t\t\taddErrorElement(ctx, key, name, \"File too big: \"+maxArchivedFileSize+\" greater than current archived file size limit \"+maxArchivedFileSize);\n\t\t\t\t\t\t\tout.close();\n\t\t\t\t\t\t\ttemp.close();\n\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tout.close();\n\t\t\t\t\tif(name.equals(\".metadata\"))\n\t\t\t\t\t\tgotMetadata = true;\n\t\t\t\t\taddStoreElement(ctx, key, name, temp);\n\t\t\t\t\tnames.add(name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If no metadata, generate some\n\t\t\tif(!gotMetadata) {\n\t\t\t\tgenerateMetadata(ctx, key, names);\n\t\t\t}\n\t\t\tif(throwAtExit) throw new ArchiveRestartException(\"Archive changed on re-fetch\");\n\t\t} catch (IOException e) {\n\t\t\tthrow new ArchiveFailureException(\"Error reading archive: \"+e.getMessage(), e);\n\t\t} finally {\n\t\t\tif(zis != null) {\n\t\t\t\ttry {\n\t\t\t\t\tzis.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLogger.error(this, \"Failed to close stream: \"+e, e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":33177,"modified_method":"/**\n\t * Extract data to cache. Call synchronized on ctx.\n\t * @param key The key the data was fetched from.\n\t * @param archiveType The archive type. Must be Metadata.ARCHIVE_ZIP.\n\t * @param data The actual data fetched.\n\t * @param archiveContext The context for the whole fetch process.\n\t * @param ctx The ArchiveStoreContext for this key.\n\t * @param element A particular element that the caller is especially interested in, or null.\n\t * @param callback A callback to be called if we find that element, or if we don't.\n\t * @throws ArchiveFailureException If we could not extract the data, or it was too big, etc.\n\t * @throws ArchiveRestartException \n\t * @throws ArchiveRestartException If the request needs to be restarted because the archive\n\t * changed.\n\t */\n\tpublic void extractToCache(FreenetURI key, short archiveType, Bucket data, ArchiveContext archiveContext, ArchiveStoreContext ctx, String element, ArchiveExtractCallback callback) throws ArchiveFailureException, ArchiveRestartException {\n\t\t\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\t\n\t\tboolean gotElement = false;\n\t\tif(logMINOR) Logger.minor(this, \"Extracting \"+key);\n\t\tctx.onExtract();\n\t\tctx.removeAllCachedItems(); // flush cache anyway\n\t\tlong expectedSize = ctx.getLastSize();\n\t\tlong archiveSize = data.size();\n\t\t/** Set if we need to throw a RestartedException rather than returning success,\n\t\t * after we have unpacked everything.\n\t\t */\n\t\tboolean throwAtExit = false;\n\t\tif((expectedSize != -1) && (archiveSize != expectedSize)) {\n\t\t\tthrowAtExit = true;\n\t\t\tctx.setLastSize(archiveSize);\n\t\t}\n\t\tbyte[] expectedHash = ctx.getLastHash();\n\t\tif(expectedHash != null) {\n\t\t\tbyte[] realHash;\n\t\t\ttry {\n\t\t\t\trealHash = BucketTools.hash(data);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new ArchiveFailureException(\"Error reading archive data: \"+e, e);\n\t\t\t}\n\t\t\tif(!Arrays.equals(realHash, expectedHash))\n\t\t\t\tthrowAtExit = true;\n\t\t\tctx.setLastHash(realHash);\n\t\t}\n\t\tif(data.size() > maxArchiveSize)\n\t\t\tthrow new ArchiveFailureException(\"Archive too big\");\n\t\tif(archiveType != Metadata.ARCHIVE_ZIP)\n\t\t\tthrow new ArchiveFailureException(\"Unknown or unsupported archive algorithm \"+archiveType);\n\t\t\n\t\tZipInputStream zis = null;\n\t\ttry {\n\t\t\tzis = new ZipInputStream(data.getInputStream());\n\t\t\t\n\t\t\t// MINOR: Assumes the first entry in the zip is a directory. \n\t\t\tZipEntry entry;\n\t\t\t\n\t\t\tbyte[] buf = new byte[4096];\n\t\t\tHashSet names = new HashSet();\n\t\t\tboolean gotMetadata = false;\n\t\t\t\nouter:\t\twhile(true) {\n\t\t\t\tentry = zis.getNextEntry();\n\t\t\t\tif(entry == null) break;\n\t\t\t\tif(entry.isDirectory()) continue;\n\t\t\t\tString name = entry.getName();\n\t\t\t\tif(names.contains(name)) {\n\t\t\t\t\tLogger.error(this, \"Duplicate key \"+name+\" in archive \"+key);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlong size = entry.getSize();\n\t\t\t\tif(size > maxArchivedFileSize) {\n\t\t\t\t\taddErrorElement(ctx, key, name, \"File too big: \"+maxArchivedFileSize+\" greater than current archived file size limit \"+maxArchivedFileSize);\n\t\t\t\t} else {\n\t\t\t\t\t// Read the element\n\t\t\t\t\tlong realLen = 0;\n\t\t\t\t\tTempStoreElement temp = makeTempStoreBucket(size);\n\t\t\t\t\tBucket output = temp.bucket;\n\t\t\t\t\tOutputStream out = output.getOutputStream();\n\n\t\t\t\t\tint readBytes;\n\t\t\t\t\twhile((readBytes = zis.read(buf)) > 0) {\n\t\t\t\t\t\tout.write(buf, 0, readBytes);\n\t\t\t\t\t\treadBytes += realLen;\n\t\t\t\t\t\tif(readBytes > maxArchivedFileSize) {\n\t\t\t\t\t\t\taddErrorElement(ctx, key, name, \"File too big: \"+maxArchivedFileSize+\" greater than current archived file size limit \"+maxArchivedFileSize);\n\t\t\t\t\t\t\tout.close();\n\t\t\t\t\t\t\ttemp.close();\n\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tout.close();\n\t\t\t\t\tif(name.equals(\".metadata\"))\n\t\t\t\t\t\tgotMetadata = true;\n\t\t\t\t\tArchiveStoreItem item = addStoreElement(ctx, key, name, temp);\n\t\t\t\t\tif((!gotElement) && element != null && name.equals(element)) {\n\t\t\t\t\t\tgotElement = true;\n\t\t\t\t\t\t// Let it throw, if it does something is drastically wrong\n\t\t\t\t\t\tcallback.gotBucket(item.getReaderBucket());\n\t\t\t\t\t}\n\t\t\t\t\tnames.add(name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If no metadata, generate some\n\t\t\tif(!gotMetadata) {\n\t\t\t\tArchiveStoreItem item = generateMetadata(ctx, key, names);\n\t\t\t\tif(element != null && (!gotElement) && element.equals(METADATA_NAME)) {\n\t\t\t\t\tgotElement = true;\n\t\t\t\t\t// Let it throw, if it does something is drastically wrong\n\t\t\t\t\tcallback.gotBucket(item.getReaderBucket());\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(throwAtExit) throw new ArchiveRestartException(\"Archive changed on re-fetch\");\n\t\t\t\n\t\t\tif((!gotElement) && element != null)\n\t\t\t\tcallback.notInArchive();\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\tthrow new ArchiveFailureException(\"Error reading archive: \"+e.getMessage(), e);\n\t\t} finally {\n\t\t\tif(zis != null) {\n\t\t\t\ttry {\n\t\t\t\t\tzis.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLogger.error(this, \"Failed to close stream: \"+e, e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"cfbe41b63ad0b52191edb159fa9ed2dcd4eeae96","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Get a cached, previously extracted, file from an archive.\n\t * @param key The key used to fetch the archive.\n\t * @param filename The name of the file within the archive.\n\t * @return A Bucket containing the data requested, or null.\n\t * @throws ArchiveFailureException \n\t */\n\tpublic Bucket getCached(FreenetURI key, String filename) throws ArchiveFailureException {\n\t\tif(logMINOR) Logger.minor(this, \"Fetch cached: \"+key+ ' ' +filename);\n\t\tArchiveKey k = new ArchiveKey(key, filename);\n\t\tArchiveStoreItem asi = null;\n\t\tsynchronized (storedData) {\n\t\t\tasi = (ArchiveStoreItem) storedData.get(k);\t\n\t\t\tif(asi == null) return null;\n\t\t\t// Promote to top of LRU\n\t\t\tstoredData.push(k, asi);\n\t\t}\n\t\tif(logMINOR) Logger.minor(this, \"Found data\");\n\t\treturn asi.getDataOrThrow();\n\t}","id":33178,"modified_method":"/**\n\t * Get a cached, previously extracted, file from an archive.\n\t * @param key The key used to fetch the archive.\n\t * @param filename The name of the file within the archive.\n\t * @return A Bucket containing the data requested, or null.\n\t * @throws ArchiveFailureException \n\t */\n\tpublic Bucket getCached(FreenetURI key, String filename) throws ArchiveFailureException {\n\t\tif(logMINOR) Logger.minor(this, \"Fetch cached: \"+key+ ' ' +filename);\n\t\tArchiveKey k = new ArchiveKey(key, filename);\n\t\tArchiveStoreItem asi = null;\n\t\tsynchronized (storedData) {\n\t\t\tasi = (ArchiveStoreItem) storedData.get(k);\t\n\t\t\tif(asi == null) return null;\n\t\t\t// Promote to top of LRU\n\t\t\tstoredData.push(k, asi);\n\t\t}\n\t\tif(logMINOR) Logger.minor(this, \"Found data\");\n\t\treturn asi.getReaderBucket();\n\t}","commit_id":"cfbe41b63ad0b52191edb159fa9ed2dcd4eeae96","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Add a store element.\n\t */\n\tprivate void addStoreElement(ArchiveStoreContext ctx, FreenetURI key, String name, TempStoreElement temp) {\n\t\tRealArchiveStoreItem element = new RealArchiveStoreItem(this, ctx, key, name, temp);\n\t\tif(logMINOR) Logger.minor(this, \"Adding store element: \"+element+\" ( \"+key+ ' ' +name+\" size \"+element.spaceUsed()+\" )\");\n\t\tsynchronized (storedData) {\n\t\t\tstoredData.push(element.key, element);\n\t\t}\n\t\ttrimStoredData();\n\t}","id":33179,"modified_method":"/**\n\t * Add a store element.\n\t */\n\tprivate ArchiveStoreItem addStoreElement(ArchiveStoreContext ctx, FreenetURI key, String name, TempStoreElement temp) {\n\t\tRealArchiveStoreItem element = new RealArchiveStoreItem(this, ctx, key, name, temp);\n\t\tif(logMINOR) Logger.minor(this, \"Adding store element: \"+element+\" ( \"+key+ ' ' +name+\" size \"+element.spaceUsed()+\" )\");\n\t\tsynchronized (storedData) {\n\t\t\tstoredData.push(element.key, element);\n\t\t}\n\t\ttrimStoredData();\n\t\treturn element;\n\t}","commit_id":"cfbe41b63ad0b52191edb159fa9ed2dcd4eeae96","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Fetch a file in an archive.\n\t */\n\tpublic Bucket get(String internalName, ArchiveContext archiveContext, ClientMetadata dm, int recursionLevel, \n\t\t\tboolean dontEnterImplicitArchives) throws ArchiveFailureException, ArchiveRestartException, MetadataParseException, FetchException {\n\n\t\t// Do loop detection on the archive that we are about to fetch.\n\t\tarchiveContext.doLoopDetection(key);\n\t\t\n\t\tif(forceRefetchArchive) return null;\n\t\t\n\t\tBucket data;\n\t\t\n\t\t// Fetch from cache\n\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\tLogger.minor(this, \"Checking cache: \"+key+ ' ' +internalName);\n\t\tif((data = manager.getCached(key, internalName)) != null) {\n\t\t\treturn data;\n\t\t}\t\n\t\t\n\t\treturn null;\n\t}","id":33180,"modified_method":"/**\n\t * Fetch a file in an archive.\n\t * @return A Bucket containing the data. This will not be freed until the \n\t * client is finished with it i.e. calls free() or it is finalized.\n\t */\n\tpublic Bucket get(String internalName, ArchiveContext archiveContext, ClientMetadata dm, int recursionLevel, \n\t\t\tboolean dontEnterImplicitArchives) throws ArchiveFailureException, ArchiveRestartException, MetadataParseException, FetchException {\n\n\t\t// Do loop detection on the archive that we are about to fetch.\n\t\tarchiveContext.doLoopDetection(key);\n\t\t\n\t\tif(forceRefetchArchive) return null;\n\t\t\n\t\tBucket data;\n\t\t\n\t\t// Fetch from cache\n\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\tLogger.minor(this, \"Checking cache: \"+key+ ' ' +internalName);\n\t\tif((data = manager.getCached(key, internalName)) != null) {\n\t\t\treturn data;\n\t\t}\t\n\t\t\n\t\treturn null;\n\t}","commit_id":"cfbe41b63ad0b52191edb159fa9ed2dcd4eeae96","url":"https://github.com/freenet/fred"},{"original_method":"public void extractToCache(Bucket bucket, ArchiveContext actx) throws ArchiveFailureException, ArchiveRestartException {\n\t\tmanager.extractToCache(key, archiveType, bucket, actx, this);\n\t}","id":33181,"modified_method":"public void extractToCache(Bucket bucket, ArchiveContext actx, String element, ArchiveExtractCallback callback) throws ArchiveFailureException, ArchiveRestartException {\n\t\tmanager.extractToCache(key, archiveType, bucket, actx, this, element, callback);\n\t}","commit_id":"cfbe41b63ad0b52191edb159fa9ed2dcd4eeae96","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Create an ArchiveStoreElement from a TempStoreElement.\n\t * @param key2 The key of the archive the file came from.\n\t * @param realName The name of the file in that archive.\n\t * @param temp The TempStoreElement currently storing the data.\n\t * @param manager The parent ArchiveManager within which this item is stored.\n\t */\n\tRealArchiveStoreItem(ArchiveManager manager, ArchiveStoreContext ctx, FreenetURI key2, String realName, TempStoreElement temp) {\n\t\tsuper(new ArchiveKey(key2, realName), ctx);\n\t\tthis.manager = manager;\n\t\tthis.bucket = temp.bucket;\n\t\tthis.underBucket = temp.underBucket;\n\t\tunderBucket.setReadOnly();\n\t\tthis.myFilename = underBucket.getFile();\n\t\tspaceUsed = FileUtil.estimateUsage(myFilename, underBucket.size());\n\t\tthis.manager.incrementSpace(spaceUsed);\n\t}","id":33182,"modified_method":"/**\n\t * Create an ArchiveStoreElement from a TempStoreElement.\n\t * @param key2 The key of the archive the file came from.\n\t * @param realName The name of the file in that archive.\n\t * @param temp The TempStoreElement currently storing the data.\n\t * @param manager The parent ArchiveManager within which this item is stored.\n\t */\n\tRealArchiveStoreItem(ArchiveManager manager, ArchiveStoreContext ctx, FreenetURI key2, String realName, TempStoreElement temp) {\n\t\tsuper(new ArchiveKey(key2, realName), ctx);\n\t\tthis.manager = manager;\n\t\tmb = new MultiReaderBucket(temp.bucket);\n\t\tthis.bucket = mb.getReaderBucket();\n\t\ttemp.underBucket.setReadOnly();\n\t\tthis.myFilename = temp.underBucket.getFile();\n\t\tspaceUsed = FileUtil.estimateUsage(myFilename, temp.underBucket.size());\n\t\tthis.manager.incrementSpace(spaceUsed);\n\t}","commit_id":"cfbe41b63ad0b52191edb159fa9ed2dcd4eeae96","url":"https://github.com/freenet/fred"},{"original_method":"void innerClose() {\n\t\tunderBucket.free();\n\t}","id":33183,"modified_method":"void innerClose() {\n\t\tbucket.free();\n\t}","commit_id":"cfbe41b63ad0b52191edb159fa9ed2dcd4eeae96","url":"https://github.com/freenet/fred"},{"original_method":"private void handleMetadata() throws FetchException, MetadataParseException, ArchiveFailureException, ArchiveRestartException {\n\t\twhile(true) {\n\t\t\tif(metadata.isSimpleManifest()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Is simple manifest\");\n\t\t\t\tString name;\n\t\t\t\tif(metaStrings.isEmpty())\n\t\t\t\t\tthrow new FetchException(FetchException.NOT_ENOUGH_PATH_COMPONENTS);\n\t\t\t\telse name = removeMetaString();\n\t\t\t\t// Since metadata is a document, we just replace metadata here\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Next meta-string: \"+name);\n\t\t\t\tif(name == null) {\n\t\t\t\t\tmetadata = metadata.getDefaultDocument();\n\t\t\t\t\tif(metadata == null)\n\t\t\t\t\t\tthrow new FetchException(FetchException.NOT_ENOUGH_PATH_COMPONENTS);\n\t\t\t\t} else {\n\t\t\t\t\tmetadata = metadata.getDocument(name);\n\t\t\t\t\tthisKey = thisKey.pushMetaString(name);\n\t\t\t\t\tif(metadata == null)\n\t\t\t\t\t\tthrow new FetchException(FetchException.NOT_IN_ARCHIVE);\n\t\t\t\t}\n\t\t\t\tcontinue; // loop\n\t\t\t} else if(metadata.isArchiveManifest()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Is archive manifest\");\n\t\t\t\tif(metaStrings.isEmpty() && ctx.returnZIPManifests) {\n\t\t\t\t\t// Just return the archive, whole.\n\t\t\t\t\tmetadata.setSimpleRedirect();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// First we need the archive metadata.\n\t\t\t\t// Then parse it. Then we may need to fetch something from inside the archive.\n\t\t\t\t// It's more efficient to keep the existing ah if we can, and it is vital in\n\t\t\t\t// the case of binary blobs.\n\t\t\t\tif(ah == null || !ah.getKey().equals(thisKey))\n\t\t\t\t\tah = (ArchiveStoreContext) ctx.archiveManager.makeHandler(thisKey, metadata.getArchiveType(), false, \n\t\t\t\t\t\t\t(parent instanceof ClientGetter ? ((ClientGetter)parent).collectingBinaryBlob() : false));\n\t\t\t\tarchiveMetadata = metadata;\n\t\t\t\t// ah is set. This means we are currently handling an archive.\n\t\t\t\tBucket metadataBucket;\n\t\t\t\tmetadataBucket = ah.getMetadata(actx, null, recursionLevel+1, true);\n\t\t\t\tif(metadataBucket != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tmetadata = Metadata.construct(metadataBucket);\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t// Bucket error?\n\t\t\t\t\t\tthrow new FetchException(FetchException.BUCKET_ERROR, e);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfetchArchive(false, archiveMetadata); // will result in this function being called again\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if(metadata.isArchiveInternalRedirect()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Is archive-internal redirect\");\n\t\t\t\tclientMetadata.mergeNoOverwrite(metadata.getClientMetadata());\n\t\t\t\t// Fetch it from the archive\n\t\t\t\tif(ah == null)\n\t\t\t\t\tthrow new FetchException(FetchException.UNKNOWN_METADATA, \"Archive redirect not in an archive manifest\");\n\t\t\t\tString filename = metadata.getZIPInternalName();\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Fetching \"+filename);\n\t\t\t\tBucket dataBucket = ah.get(filename, actx, null, recursionLevel+1, true);\n\t\t\t\tif(dataBucket != null) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Returning data\");\n\t\t\t\t\t// The client may free it, which is bad, or it may hang on to it for so long that it gets\n\t\t\t\t\t// freed by us, which is also bad.\n\t\t\t\t\t// So copy it.\n\t\t\t\t\t// FIXME this is stupid, reconsider how we determine when to free buckets; refcounts maybe?\n\t\t\t\t\tBucket out;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif(returnBucket != null)\n\t\t\t\t\t\t\tout = returnBucket;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tout = ctx.bucketFactory.makeBucket(dataBucket.size());\n\t\t\t\t\t\tBucketTools.copy(dataBucket, out);\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tonFailure(new FetchException(FetchException.BUCKET_ERROR));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// Return the data\n\t\t\t\t\tonSuccess(new FetchResult(this.clientMetadata, out));\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Fetching archive (thisKey=\"+thisKey+ ')');\n\t\t\t\t\t// Metadata cannot contain pointers to files which don't exist.\n\t\t\t\t\t// We enforce this in ArchiveHandler.\n\t\t\t\t\t// Therefore, the archive needs to be fetched.\n\t\t\t\t\tfetchArchive(true, archiveMetadata);\n\t\t\t\t\t// Will call back into this function when it has been fetched.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if(metadata.isMultiLevelMetadata()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Is multi-level metadata\");\n\t\t\t\t// Fetch on a second SingleFileFetcher, like with archives.\n\t\t\t\tMetadata newMeta = (Metadata) metadata.clone();\n\t\t\t\tnewMeta.setSimpleRedirect();\n\t\t\t\tSingleFileFetcher f = new SingleFileFetcher(this, newMeta, new MultiLevelMetadataCallback(), ctx);\n\t\t\t\tf.handleMetadata();\n\t\t\t\treturn;\n\t\t\t} else if(metadata.isSingleFileRedirect()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Is single-file redirect\");\n\t\t\t\tclientMetadata.mergeNoOverwrite(metadata.getClientMetadata()); // even splitfiles can have mime types!\n\t\t\t\t// FIXME implement implicit archive support\n\t\t\t\t\n\t\t\t\t// Simple redirect\n\t\t\t\t// Just create a new SingleFileFetcher\n\t\t\t\t// Which will then fetch the target URI, and call the rcd.success\n\t\t\t\t// Hopefully!\n\t\t\t\tFreenetURI newURI = metadata.getSingleTarget();\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Redirecting to \"+newURI);\n\t\t\t\tClientKey key;\n\t\t\t\ttry {\n\t\t\t\t\tBaseClientKey k = BaseClientKey.getBaseKey(newURI);\n\t\t\t\t\tif(k instanceof ClientKey)\n\t\t\t\t\t\tkey = (ClientKey) k;\n\t\t\t\t\telse\n\t\t\t\t\t\t// FIXME do we want to allow redirects to USKs?\n\t\t\t\t\t\t// Without redirects to USKs, all SSK and CHKs are static.\n\t\t\t\t\t\t// This may be a desirable property.\n\t\t\t\t\t\tthrow new FetchException(FetchException.UNKNOWN_METADATA, \"Redirect to a USK\");\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\tthrow new FetchException(FetchException.INVALID_URI, e);\n\t\t\t\t}\n\t\t\t\tLinkedList newMetaStrings = newURI.listMetaStrings();\n\t\t\t\t\n\t\t\t\t// Move any new meta strings to beginning of our list of remaining meta strings\n\t\t\t\twhile(!newMetaStrings.isEmpty()) {\n\t\t\t\t\tObject o = newMetaStrings.removeLast();\n\t\t\t\t\tmetaStrings.addFirst(o);\n\t\t\t\t\taddedMetaStrings++;\n\t\t\t\t}\n\n\t\t\t\t// **FIXME** Is key in the call to SingleFileFetcher here supposed to be this.key or the same key used in the try block above?  MultiLevelMetadataCallback.onSuccess() below uses this.key, thus the question\n\t\t\t\tSingleFileFetcher f = new SingleFileFetcher(parent, rcb, clientMetadata, key, metaStrings, this.uri, addedMetaStrings, ctx, actx, ah, maxRetries, recursionLevel, false, token, true, returnBucket, isFinal);\n\t\t\t\tif((key instanceof ClientCHK) && !((ClientCHK)key).isMetadata())\n\t\t\t\t\trcb.onBlockSetFinished(this);\n\t\t\t\tif(metadata.isCompressed()) {\n\t\t\t\t\tCompressor codec = Compressor.getCompressionAlgorithmByMetadataID(metadata.getCompressionCodec());\n\t\t\t\t\tf.addDecompressor(codec);\n\t\t\t\t}\n\t\t\t\tparent.onTransition(this, f);\n\t\t\t\tf.schedule();\n\t\t\t\t// All done! No longer our problem!\n\t\t\t\treturn;\n\t\t\t} else if(metadata.isSplitfile()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Fetching splitfile\");\n\t\t\t\t// FIXME implicit archive support\n\t\t\t\t\n\t\t\t\tclientMetadata.mergeNoOverwrite(metadata.getClientMetadata()); // even splitfiles can have mime types!\n\t\t\t\t\n\t\t\t\t// Splitfile (possibly compressed)\n\t\t\t\t\n\t\t\t\tif(metadata.isCompressed()) {\n\t\t\t\t\tCompressor codec = Compressor.getCompressionAlgorithmByMetadataID(metadata.getCompressionCodec());\n\t\t\t\t\taddDecompressor(codec);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(isFinal && !ctx.ignoreTooManyPathComponents) {\n\t\t\t\t\tif(!metaStrings.isEmpty()) {\n\t\t\t\t\t\t// Some meta-strings left\n\t\t\t\t\t\tif(addedMetaStrings > 0) {\n\t\t\t\t\t\t\t// Should this be an error?\n\t\t\t\t\t\t\t// It would be useful to be able to fetch the data ...\n\t\t\t\t\t\t\t// On the other hand such inserts could cause unpredictable results?\n\t\t\t\t\t\t\t// Would be useful to make a redirect to the key we actually fetched.\n\t\t\t\t\t\t\trcb.onFailure(new FetchException(FetchException.INVALID_METADATA, \"Invalid metadata: too many path components in redirects\", thisKey), this);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// TOO_MANY_PATH_COMPONENTS\n\t\t\t\t\t\t\t// report to user\n\t\t\t\t\t\t\tFreenetURI tryURI = uri;\n\t\t\t\t\t\t\ttryURI = tryURI.dropLastMetaStrings(metaStrings.size());\n\t\t\t\t\t\t\trcb.onFailure(new FetchException(FetchException.TOO_MANY_PATH_COMPONENTS, metadata.uncompressedDataLength(), (rcb == parent), clientMetadata.getMIMEType(), tryURI), this);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Not finished: rcb=\"+rcb+\" for \"+this); \n\t\t\t\t\n\t\t\t\tlong len = metadata.dataLength();\n\t\t\t\tif(metadata.uncompressedDataLength() > len)\n\t\t\t\t\tlen = metadata.uncompressedDataLength();\n\t\t\t\t\n\t\t\t\tif((len > ctx.maxOutputLength) ||\n\t\t\t\t\t\t(len > ctx.maxTempLength)) {\n\t\t\t\t\t\n\t\t\t\t\tonFailure(new FetchException(FetchException.TOO_BIG, len, isFinal && decompressors.size() <= (metadata.isCompressed() ? 1 : 0), clientMetadata.getMIMEType()));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSplitFileFetcher sf = new SplitFileFetcher(metadata, rcb, parent, ctx, \n\t\t\t\t\t\tdecompressors, clientMetadata, actx, recursionLevel, returnBucket, token);\n\t\t\t\tparent.onTransition(this, sf);\n\t\t\t\tsf.scheduleOffThread();\n\t\t\t\trcb.onBlockSetFinished(this);\n\t\t\t\t// SplitFile will now run.\n\t\t\t\t// Then it will return data to rcd.\n\t\t\t\t// We are now out of the loop. Yay!\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tLogger.error(this, \"Don't know what to do with metadata: \"+metadata);\n\t\t\t\tthrow new FetchException(FetchException.UNKNOWN_METADATA);\n\t\t\t}\n\t\t}\n\t}","id":33184,"modified_method":"private void handleMetadata() throws FetchException, MetadataParseException, ArchiveFailureException, ArchiveRestartException {\n\t\twhile(true) {\n\t\t\tif(metadata.isSimpleManifest()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Is simple manifest\");\n\t\t\t\tString name;\n\t\t\t\tif(metaStrings.isEmpty())\n\t\t\t\t\tthrow new FetchException(FetchException.NOT_ENOUGH_PATH_COMPONENTS);\n\t\t\t\telse name = removeMetaString();\n\t\t\t\t// Since metadata is a document, we just replace metadata here\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Next meta-string: \"+name);\n\t\t\t\tif(name == null) {\n\t\t\t\t\tmetadata = metadata.getDefaultDocument();\n\t\t\t\t\tif(metadata == null)\n\t\t\t\t\t\tthrow new FetchException(FetchException.NOT_ENOUGH_PATH_COMPONENTS);\n\t\t\t\t} else {\n\t\t\t\t\tmetadata = metadata.getDocument(name);\n\t\t\t\t\tthisKey = thisKey.pushMetaString(name);\n\t\t\t\t\tif(metadata == null)\n\t\t\t\t\t\tthrow new FetchException(FetchException.NOT_IN_ARCHIVE);\n\t\t\t\t}\n\t\t\t\tcontinue; // loop\n\t\t\t} else if(metadata.isArchiveManifest()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Is archive manifest\");\n\t\t\t\tif(metaStrings.isEmpty() && ctx.returnZIPManifests) {\n\t\t\t\t\t// Just return the archive, whole.\n\t\t\t\t\tmetadata.setSimpleRedirect();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// First we need the archive metadata.\n\t\t\t\t// Then parse it. Then we may need to fetch something from inside the archive.\n\t\t\t\t// It's more efficient to keep the existing ah if we can, and it is vital in\n\t\t\t\t// the case of binary blobs.\n\t\t\t\tif(ah == null || !ah.getKey().equals(thisKey))\n\t\t\t\t\tah = (ArchiveStoreContext) ctx.archiveManager.makeHandler(thisKey, metadata.getArchiveType(), false, \n\t\t\t\t\t\t\t(parent instanceof ClientGetter ? ((ClientGetter)parent).collectingBinaryBlob() : false));\n\t\t\t\tarchiveMetadata = metadata;\n\t\t\t\t// ah is set. This means we are currently handling an archive.\n\t\t\t\tBucket metadataBucket;\n\t\t\t\tmetadataBucket = ah.getMetadata(actx, null, recursionLevel+1, true);\n\t\t\t\tif(metadataBucket != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tmetadata = Metadata.construct(metadataBucket);\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t// Bucket error?\n\t\t\t\t\t\tthrow new FetchException(FetchException.BUCKET_ERROR, e);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfetchArchive(false, archiveMetadata, ArchiveManager.METADATA_NAME, new ArchiveExtractCallback() {\n\t\t\t\t\t\tpublic void gotBucket(Bucket data) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tmetadata = Metadata.construct(data);\n\t\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\t// Bucket error?\n\t\t\t\t\t\t\t\tonFailure(new FetchException(FetchException.BUCKET_ERROR, e));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\thandleMetadata();\n\t\t\t\t\t\t\t} catch (MetadataParseException e) {\n\t\t\t\t\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e));\n\t\t\t\t\t\t\t} catch (FetchException e) {\n\t\t\t\t\t\t\t\te.setNotFinalizedSize();\n\t\t\t\t\t\t\t\tSingleFileFetcher.this.onFailure(e);\n\t\t\t\t\t\t\t} catch (ArchiveFailureException e) {\n\t\t\t\t\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e));\n\t\t\t\t\t\t\t} catch (ArchiveRestartException e) {\n\t\t\t\t\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void notInArchive() {\n\t\t\t\t\t\t\tonFailure(new FetchException(FetchException.INTERNAL_ERROR, \"No metadata in container! Cannot happen as ArchiveManager should synthesise some!\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t}); // will result in this function being called again\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if(metadata.isArchiveInternalRedirect()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Is archive-internal redirect\");\n\t\t\t\tclientMetadata.mergeNoOverwrite(metadata.getClientMetadata());\n\t\t\t\t// Fetch it from the archive\n\t\t\t\tif(ah == null)\n\t\t\t\t\tthrow new FetchException(FetchException.UNKNOWN_METADATA, \"Archive redirect not in an archive manifest\");\n\t\t\t\tString filename = metadata.getZIPInternalName();\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Fetching \"+filename);\n\t\t\t\tBucket dataBucket = ah.get(filename, actx, null, recursionLevel+1, true);\n\t\t\t\tif(dataBucket != null) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Returning data\");\n\t\t\t\t\tBucket out;\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Data will not be freed until client is finished with it.\n\t\t\t\t\t\tif(returnBucket != null) {\n\t\t\t\t\t\t\tout = returnBucket;\n\t\t\t\t\t\t\tBucketTools.copy(dataBucket, out);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tout = dataBucket;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tonFailure(new FetchException(FetchException.BUCKET_ERROR));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// Return the data\n\t\t\t\t\tonSuccess(new FetchResult(this.clientMetadata, out));\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Fetching archive (thisKey=\"+thisKey+ ')');\n\t\t\t\t\t// Metadata cannot contain pointers to files which don't exist.\n\t\t\t\t\t// We enforce this in ArchiveHandler.\n\t\t\t\t\t// Therefore, the archive needs to be fetched.\n\t\t\t\t\tfetchArchive(true, archiveMetadata, filename, new ArchiveExtractCallback() {\n\t\t\t\t\t\tpublic void gotBucket(Bucket data) {\n\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Returning data\");\n\t\t\t\t\t\t\tBucket out;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t// Data will not be freed until client is finished with it.\n\t\t\t\t\t\t\t\tif(returnBucket != null) {\n\t\t\t\t\t\t\t\t\tout = returnBucket;\n\t\t\t\t\t\t\t\t\tBucketTools.copy(data, out);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tout = data;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\tonFailure(new FetchException(FetchException.BUCKET_ERROR));\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Return the data\n\t\t\t\t\t\t\tonSuccess(new FetchResult(clientMetadata, out));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void notInArchive() {\n\t\t\t\t\t\t\tonFailure(new FetchException(FetchException.NOT_IN_ARCHIVE));\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t// Will call back into this function when it has been fetched.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if(metadata.isMultiLevelMetadata()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Is multi-level metadata\");\n\t\t\t\t// Fetch on a second SingleFileFetcher, like with archives.\n\t\t\t\tMetadata newMeta = (Metadata) metadata.clone();\n\t\t\t\tnewMeta.setSimpleRedirect();\n\t\t\t\tSingleFileFetcher f = new SingleFileFetcher(this, newMeta, new MultiLevelMetadataCallback(), ctx);\n\t\t\t\tf.handleMetadata();\n\t\t\t\treturn;\n\t\t\t} else if(metadata.isSingleFileRedirect()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Is single-file redirect\");\n\t\t\t\tclientMetadata.mergeNoOverwrite(metadata.getClientMetadata()); // even splitfiles can have mime types!\n\t\t\t\t// FIXME implement implicit archive support\n\t\t\t\t\n\t\t\t\t// Simple redirect\n\t\t\t\t// Just create a new SingleFileFetcher\n\t\t\t\t// Which will then fetch the target URI, and call the rcd.success\n\t\t\t\t// Hopefully!\n\t\t\t\tFreenetURI newURI = metadata.getSingleTarget();\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Redirecting to \"+newURI);\n\t\t\t\tClientKey key;\n\t\t\t\ttry {\n\t\t\t\t\tBaseClientKey k = BaseClientKey.getBaseKey(newURI);\n\t\t\t\t\tif(k instanceof ClientKey)\n\t\t\t\t\t\tkey = (ClientKey) k;\n\t\t\t\t\telse\n\t\t\t\t\t\t// FIXME do we want to allow redirects to USKs?\n\t\t\t\t\t\t// Without redirects to USKs, all SSK and CHKs are static.\n\t\t\t\t\t\t// This may be a desirable property.\n\t\t\t\t\t\tthrow new FetchException(FetchException.UNKNOWN_METADATA, \"Redirect to a USK\");\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\tthrow new FetchException(FetchException.INVALID_URI, e);\n\t\t\t\t}\n\t\t\t\tLinkedList newMetaStrings = newURI.listMetaStrings();\n\t\t\t\t\n\t\t\t\t// Move any new meta strings to beginning of our list of remaining meta strings\n\t\t\t\twhile(!newMetaStrings.isEmpty()) {\n\t\t\t\t\tObject o = newMetaStrings.removeLast();\n\t\t\t\t\tmetaStrings.addFirst(o);\n\t\t\t\t\taddedMetaStrings++;\n\t\t\t\t}\n\n\t\t\t\t// **FIXME** Is key in the call to SingleFileFetcher here supposed to be this.key or the same key used in the try block above?  MultiLevelMetadataCallback.onSuccess() below uses this.key, thus the question\n\t\t\t\tSingleFileFetcher f = new SingleFileFetcher(parent, rcb, clientMetadata, key, metaStrings, this.uri, addedMetaStrings, ctx, actx, ah, maxRetries, recursionLevel, false, token, true, returnBucket, isFinal);\n\t\t\t\tif((key instanceof ClientCHK) && !((ClientCHK)key).isMetadata())\n\t\t\t\t\trcb.onBlockSetFinished(this);\n\t\t\t\tif(metadata.isCompressed()) {\n\t\t\t\t\tCompressor codec = Compressor.getCompressionAlgorithmByMetadataID(metadata.getCompressionCodec());\n\t\t\t\t\tf.addDecompressor(codec);\n\t\t\t\t}\n\t\t\t\tparent.onTransition(this, f);\n\t\t\t\tf.schedule();\n\t\t\t\t// All done! No longer our problem!\n\t\t\t\treturn;\n\t\t\t} else if(metadata.isSplitfile()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Fetching splitfile\");\n\t\t\t\t// FIXME implicit archive support\n\t\t\t\t\n\t\t\t\tclientMetadata.mergeNoOverwrite(metadata.getClientMetadata()); // even splitfiles can have mime types!\n\t\t\t\t\n\t\t\t\t// Splitfile (possibly compressed)\n\t\t\t\t\n\t\t\t\tif(metadata.isCompressed()) {\n\t\t\t\t\tCompressor codec = Compressor.getCompressionAlgorithmByMetadataID(metadata.getCompressionCodec());\n\t\t\t\t\taddDecompressor(codec);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(isFinal && !ctx.ignoreTooManyPathComponents) {\n\t\t\t\t\tif(!metaStrings.isEmpty()) {\n\t\t\t\t\t\t// Some meta-strings left\n\t\t\t\t\t\tif(addedMetaStrings > 0) {\n\t\t\t\t\t\t\t// Should this be an error?\n\t\t\t\t\t\t\t// It would be useful to be able to fetch the data ...\n\t\t\t\t\t\t\t// On the other hand such inserts could cause unpredictable results?\n\t\t\t\t\t\t\t// Would be useful to make a redirect to the key we actually fetched.\n\t\t\t\t\t\t\trcb.onFailure(new FetchException(FetchException.INVALID_METADATA, \"Invalid metadata: too many path components in redirects\", thisKey), this);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// TOO_MANY_PATH_COMPONENTS\n\t\t\t\t\t\t\t// report to user\n\t\t\t\t\t\t\tFreenetURI tryURI = uri;\n\t\t\t\t\t\t\ttryURI = tryURI.dropLastMetaStrings(metaStrings.size());\n\t\t\t\t\t\t\trcb.onFailure(new FetchException(FetchException.TOO_MANY_PATH_COMPONENTS, metadata.uncompressedDataLength(), (rcb == parent), clientMetadata.getMIMEType(), tryURI), this);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Not finished: rcb=\"+rcb+\" for \"+this); \n\t\t\t\t\n\t\t\t\tlong len = metadata.dataLength();\n\t\t\t\tif(metadata.uncompressedDataLength() > len)\n\t\t\t\t\tlen = metadata.uncompressedDataLength();\n\t\t\t\t\n\t\t\t\tif((len > ctx.maxOutputLength) ||\n\t\t\t\t\t\t(len > ctx.maxTempLength)) {\n\t\t\t\t\t\n\t\t\t\t\tonFailure(new FetchException(FetchException.TOO_BIG, len, isFinal && decompressors.size() <= (metadata.isCompressed() ? 1 : 0), clientMetadata.getMIMEType()));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSplitFileFetcher sf = new SplitFileFetcher(metadata, rcb, parent, ctx, \n\t\t\t\t\t\tdecompressors, clientMetadata, actx, recursionLevel, returnBucket, token);\n\t\t\t\tparent.onTransition(this, sf);\n\t\t\t\tsf.scheduleOffThread();\n\t\t\t\trcb.onBlockSetFinished(this);\n\t\t\t\t// SplitFile will now run.\n\t\t\t\t// Then it will return data to rcd.\n\t\t\t\t// We are now out of the loop. Yay!\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tLogger.error(this, \"Don't know what to do with metadata: \"+metadata);\n\t\t\t\tthrow new FetchException(FetchException.UNKNOWN_METADATA);\n\t\t\t}\n\t\t}\n\t}","commit_id":"cfbe41b63ad0b52191edb159fa9ed2dcd4eeae96","url":"https://github.com/freenet/fred"},{"original_method":"private void fetchArchive(boolean forData, Metadata meta) throws FetchException, MetadataParseException, ArchiveFailureException, ArchiveRestartException {\n\t\tif(logMINOR) Logger.minor(this, \"fetchArchive()\");\n\t\t// Fetch the archive\n\t\t// How?\n\t\t// Spawn a separate SingleFileFetcher,\n\t\t// which fetches the archive, then calls\n\t\t// our Callback, which unpacks the archive, then\n\t\t// reschedules us.\n\t\tMetadata newMeta = (Metadata) meta.clone();\n\t\tnewMeta.setSimpleRedirect();\n\t\tSingleFileFetcher f;\n\t\tf = new SingleFileFetcher(this, newMeta, new ArchiveFetcherCallback(forData), new FetchContext(ctx, FetchContext.SET_RETURN_ARCHIVES, true));\n\t\tf.handleMetadata();\n\t\t// When it is done (if successful), the ArchiveCallback will re-call this function.\n\t\t// Which will then discover that the metadata *is* available.\n\t\t// And will also discover that the data is available, and will complete.\n\t}","id":33185,"modified_method":"private void fetchArchive(boolean forData, Metadata meta, String element, ArchiveExtractCallback callback) throws FetchException, MetadataParseException, ArchiveFailureException, ArchiveRestartException {\n\t\tif(logMINOR) Logger.minor(this, \"fetchArchive()\");\n\t\t// Fetch the archive\n\t\t// How?\n\t\t// Spawn a separate SingleFileFetcher,\n\t\t// which fetches the archive, then calls\n\t\t// our Callback, which unpacks the archive, then\n\t\t// reschedules us.\n\t\tMetadata newMeta = (Metadata) meta.clone();\n\t\tnewMeta.setSimpleRedirect();\n\t\tSingleFileFetcher f;\n\t\tf = new SingleFileFetcher(this, newMeta, new ArchiveFetcherCallback(forData, element, callback), new FetchContext(ctx, FetchContext.SET_RETURN_ARCHIVES, true));\n\t\tf.handleMetadata();\n\t\t// When it is done (if successful), the ArchiveCallback will re-call this function.\n\t\t// Which will then discover that the metadata *is* available.\n\t\t// And will also discover that the data is available, and will complete.\n\t}","commit_id":"cfbe41b63ad0b52191edb159fa9ed2dcd4eeae96","url":"https://github.com/freenet/fred"},{"original_method":"public void onSuccess(FetchResult result, ClientGetState state) {\n\t\t\ttry {\n\t\t\t\tah.extractToCache(result.asBucket(), actx);\n\t\t\t} catch (ArchiveFailureException e) {\n\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e));\n\t\t\t\treturn;\n\t\t\t} catch (ArchiveRestartException e) {\n\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\thandleMetadata();\n\t\t\t} catch (MetadataParseException e) {\n\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e));\n\t\t\t} catch (FetchException e) {\n\t\t\t\te.setNotFinalizedSize();\n\t\t\t\tSingleFileFetcher.this.onFailure(e);\n\t\t\t} catch (ArchiveFailureException e) {\n\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e));\n\t\t\t} catch (ArchiveRestartException e) {\n\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e));\n\t\t\t}\n\t\t}","id":33186,"modified_method":"public void onSuccess(FetchResult result, ClientGetState state) {\n\t\t\ttry {\n\t\t\t\tah.extractToCache(result.asBucket(), actx, element, callback);\n\t\t\t} catch (ArchiveFailureException e) {\n\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e));\n\t\t\t\treturn;\n\t\t\t} catch (ArchiveRestartException e) {\n\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\thandleMetadata();\n\t\t\t} catch (MetadataParseException e) {\n\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e));\n\t\t\t} catch (FetchException e) {\n\t\t\t\te.setNotFinalizedSize();\n\t\t\t\tSingleFileFetcher.this.onFailure(e);\n\t\t\t} catch (ArchiveFailureException e) {\n\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e));\n\t\t\t} catch (ArchiveRestartException e) {\n\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e));\n\t\t\t}\n\t\t}","commit_id":"cfbe41b63ad0b52191edb159fa9ed2dcd4eeae96","url":"https://github.com/freenet/fred"},{"original_method":"public void onSuccess(FetchResult result, ClientGetState state) {\n\t\t\ttry {\n\t\t\t\tmetadata = Metadata.construct(result.asBucket());\n\t\t\t\thandleMetadata();\n\t\t\t} catch (MetadataParseException e) {\n\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e));\n\t\t\t\treturn;\n\t\t\t} catch (IOException e) {\n\t\t\t\t// Bucket error?\n\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(FetchException.BUCKET_ERROR, e));\n\t\t\t\treturn;\n\t\t\t} catch (FetchException e) {\n\t\t\t\te.setNotFinalizedSize();\n\t\t\t\tonFailure(e, SingleFileFetcher.this);\n\t\t\t} catch (ArchiveFailureException e) {\n\t\t\t\tonFailure(new FetchException(FetchException.ARCHIVE_FAILURE), SingleFileFetcher.this);\n\t\t\t} catch (ArchiveRestartException e) {\n\t\t\t\tonFailure(new FetchException(FetchException.ARCHIVE_RESTART), SingleFileFetcher.this);\n\t\t\t}\n\t\t}","id":33187,"modified_method":"ArchiveFetcherCallback(boolean wasFetchingFinalData, String element, ArchiveExtractCallback cb) {\n\t\t\tthis.wasFetchingFinalData = wasFetchingFinalData;\n\t\t\tthis.element = element;\n\t\t\tthis.callback = cb;\n\t\t}","commit_id":"cfbe41b63ad0b52191edb159fa9ed2dcd4eeae96","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n    public AccountResponse createAccountResponse(Account account) {\n        boolean accountIsAdmin = (account.getType() == Account.ACCOUNT_TYPE_ADMIN);\n        AccountResponse accountResponse = new AccountResponse();\n        accountResponse.setId(account.getId());\n        accountResponse.setName(encodeParam(account.getAccountName()));\n        accountResponse.setAccountType(account.getType());\n        accountResponse.setDomainId(account.getDomainId());\n        accountResponse.setDomainName(ApiDBUtils.findDomainById(account.getDomainId()).getName());\n        accountResponse.setState(account.getState().toString());\n\n        // get network stat\n        List<UserStatisticsVO> stats = ApiDBUtils.listUserStatsBy(account.getId());\n        if (stats == null) {\n            throw new ServerApiException(BaseCmd.INTERNAL_ERROR, \"Internal error searching for user stats\");\n        }\n\n        Long bytesSent = 0L;\n        Long bytesReceived = 0L;\n        for (UserStatisticsVO stat : stats) {\n            Long rx = stat.getNetBytesReceived() + stat.getCurrentBytesReceived();\n            Long tx = stat.getNetBytesSent() + stat.getCurrentBytesSent();\n            bytesReceived = bytesReceived + Long.valueOf(rx);\n            bytesSent = bytesSent + Long.valueOf(tx);\n        }\n        accountResponse.setBytesReceived(bytesReceived);\n        accountResponse.setBytesSent(bytesSent);\n\n        // Get resource limits and counts\n\n        Long vmLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.user_vm, account.getId());\n        String vmLimitDisplay = (accountIsAdmin || vmLimit == -1) ? \"Unlimited\" : String.valueOf(vmLimit);\n        Long vmTotal = ApiDBUtils.getResourceCount(ResourceType.user_vm, account.getId());\n        String vmAvail = (accountIsAdmin || vmLimit == -1) ? \"Unlimited\" : String.valueOf(vmLimit - vmTotal);\n        accountResponse.setVmLimit(vmLimitDisplay);\n        accountResponse.setVmTotal(vmTotal);\n        accountResponse.setVmAvailable(vmAvail);\n\n        Long ipLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.public_ip, account.getId());\n        String ipLimitDisplay = (accountIsAdmin || ipLimit == -1) ? \"Unlimited\" : String.valueOf(ipLimit);\n        Long ipTotal = ApiDBUtils.getResourceCount(ResourceType.public_ip, account.getId());\n        String ipAvail = (accountIsAdmin || ipLimit == -1) ? \"Unlimited\" : String.valueOf(ipLimit - ipTotal);\n        accountResponse.setIpLimit(ipLimitDisplay);\n        accountResponse.setIpTotal(ipTotal);\n        accountResponse.setIpAvailable(ipAvail);\n\n        Long volumeLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.volume, account.getId());\n        String volumeLimitDisplay = (accountIsAdmin || volumeLimit == -1) ? \"Unlimited\" : String.valueOf(volumeLimit);\n        Long volumeTotal = ApiDBUtils.getResourceCount(ResourceType.volume, account.getId());\n        String volumeAvail = (accountIsAdmin || volumeLimit == -1) ? \"Unlimited\" : String.valueOf(volumeLimit - volumeTotal);\n        accountResponse.setVolumeLimit(volumeLimitDisplay);\n        accountResponse.setVolumeTotal(volumeTotal);\n        accountResponse.setVolumeAvailable(volumeAvail);\n\n        Long snapshotLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.snapshot, account.getId());\n        String snapshotLimitDisplay = (accountIsAdmin || snapshotLimit == -1) ? \"Unlimited\" : String.valueOf(snapshotLimit);\n        Long snapshotTotal = ApiDBUtils.getResourceCount(ResourceType.snapshot, account.getId());\n        String snapshotAvail = (accountIsAdmin || snapshotLimit == -1) ? \"Unlimited\" : String.valueOf(snapshotLimit - snapshotTotal);\n        accountResponse.setSnapshotLimit(snapshotLimitDisplay);\n        accountResponse.setSnapshotTotal(snapshotTotal);\n        accountResponse.setSnapshotAvailable(snapshotAvail);\n\n        Long templateLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.template, account.getId());\n        String templateLimitDisplay = (accountIsAdmin || templateLimit == -1) ? \"Unlimited\" : String.valueOf(templateLimit);\n        Long templateTotal = ApiDBUtils.getResourceCount(ResourceType.template, account.getId());\n        String templateAvail = (accountIsAdmin || templateLimit == -1) ? \"Unlimited\" : String.valueOf(templateLimit - templateTotal);\n        accountResponse.setTemplateLimit(templateLimitDisplay);\n        accountResponse.setTemplateTotal(templateTotal);\n        accountResponse.setTemplateAvailable(templateAvail);\n\n        // Get stopped and running VMs\n        int vmStopped = 0;\n        int vmRunning = 0;\n\n        Long[] accountIds = new Long[1];\n        accountIds[0] = account.getId();\n\n        Criteria c1 = new Criteria();\n        c1.addCriteria(Criteria.ACCOUNTID, accountIds);\n        List<? extends UserVm> virtualMachines = ApiDBUtils.searchForUserVMs(c1);\n\n        // get Running/Stopped VMs\n        for (Iterator<? extends UserVm> iter = virtualMachines.iterator(); iter.hasNext();) {\n            // count how many stopped/running vms we have\n            UserVm vm = iter.next();\n\n            if (vm.getState() == State.Stopped) {\n                vmStopped++;\n            } else if (vm.getState() == State.Running) {\n                vmRunning++;\n            }\n        }\n\n        accountResponse.setVmStopped(vmStopped);\n        accountResponse.setVmRunning(vmRunning);\n        accountResponse.setObjectName(\"account\");\n\n        // adding all the users for an account as part of the response obj\n        List<UserVO> usersForAccount = ApiDBUtils.listUsersByAccount(account.getAccountId());\n        List<UserResponse> userResponseList = new ArrayList<UserResponse>();\n        for (UserVO user : usersForAccount) {\n            UserResponse userResponse = new UserResponse();\n            userResponse.setAccountName(encodeParam(account.getAccountName()));\n            userResponse.setAccountType(account.getType());\n            userResponse.setApiKey(user.getApiKey());\n            userResponse.setCreated(user.getCreated());\n            userResponse.setDomainId(account.getDomainId());\n            userResponse.setDomainName(ApiDBUtils.findDomainById(account.getDomainId()).getName());\n            userResponse.setEmail(encodeParam(user.getEmail()));\n            userResponse.setFirstname(user.getFirstname());\n            userResponse.setId(user.getId());\n            userResponse.setSecretKey(user.getSecretKey());\n            userResponse.setLastname(user.getLastname());\n            userResponse.setState(user.getState().toString());\n            userResponse.setTimezone(user.getTimezone());\n            userResponse.setUsername(encodeParam(user.getUsername()));\n\n            userResponseList.add(userResponse);\n        }\n\n        accountResponse.setUsers(userResponseList);\n        return accountResponse;\n    }","id":33188,"modified_method":"@Override\n    public AccountResponse createAccountResponse(Account account) {\n        boolean accountIsAdmin = (account.getType() == Account.ACCOUNT_TYPE_ADMIN);\n        AccountResponse accountResponse = new AccountResponse();\n        accountResponse.setId(account.getId());\n        accountResponse.setName(account.getAccountName());\n        accountResponse.setAccountType(account.getType());\n        accountResponse.setDomainId(account.getDomainId());\n        accountResponse.setDomainName(ApiDBUtils.findDomainById(account.getDomainId()).getName());\n        accountResponse.setState(account.getState().toString());\n\n        // get network stat\n        List<UserStatisticsVO> stats = ApiDBUtils.listUserStatsBy(account.getId());\n        if (stats == null) {\n            throw new ServerApiException(BaseCmd.INTERNAL_ERROR, \"Internal error searching for user stats\");\n        }\n\n        Long bytesSent = 0L;\n        Long bytesReceived = 0L;\n        for (UserStatisticsVO stat : stats) {\n            Long rx = stat.getNetBytesReceived() + stat.getCurrentBytesReceived();\n            Long tx = stat.getNetBytesSent() + stat.getCurrentBytesSent();\n            bytesReceived = bytesReceived + Long.valueOf(rx);\n            bytesSent = bytesSent + Long.valueOf(tx);\n        }\n        accountResponse.setBytesReceived(bytesReceived);\n        accountResponse.setBytesSent(bytesSent);\n\n        // Get resource limits and counts\n\n        Long vmLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.user_vm, account.getId());\n        String vmLimitDisplay = (accountIsAdmin || vmLimit == -1) ? \"Unlimited\" : String.valueOf(vmLimit);\n        Long vmTotal = ApiDBUtils.getResourceCount(ResourceType.user_vm, account.getId());\n        String vmAvail = (accountIsAdmin || vmLimit == -1) ? \"Unlimited\" : String.valueOf(vmLimit - vmTotal);\n        accountResponse.setVmLimit(vmLimitDisplay);\n        accountResponse.setVmTotal(vmTotal);\n        accountResponse.setVmAvailable(vmAvail);\n\n        Long ipLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.public_ip, account.getId());\n        String ipLimitDisplay = (accountIsAdmin || ipLimit == -1) ? \"Unlimited\" : String.valueOf(ipLimit);\n        Long ipTotal = ApiDBUtils.getResourceCount(ResourceType.public_ip, account.getId());\n        String ipAvail = (accountIsAdmin || ipLimit == -1) ? \"Unlimited\" : String.valueOf(ipLimit - ipTotal);\n        accountResponse.setIpLimit(ipLimitDisplay);\n        accountResponse.setIpTotal(ipTotal);\n        accountResponse.setIpAvailable(ipAvail);\n\n        Long volumeLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.volume, account.getId());\n        String volumeLimitDisplay = (accountIsAdmin || volumeLimit == -1) ? \"Unlimited\" : String.valueOf(volumeLimit);\n        Long volumeTotal = ApiDBUtils.getResourceCount(ResourceType.volume, account.getId());\n        String volumeAvail = (accountIsAdmin || volumeLimit == -1) ? \"Unlimited\" : String.valueOf(volumeLimit - volumeTotal);\n        accountResponse.setVolumeLimit(volumeLimitDisplay);\n        accountResponse.setVolumeTotal(volumeTotal);\n        accountResponse.setVolumeAvailable(volumeAvail);\n\n        Long snapshotLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.snapshot, account.getId());\n        String snapshotLimitDisplay = (accountIsAdmin || snapshotLimit == -1) ? \"Unlimited\" : String.valueOf(snapshotLimit);\n        Long snapshotTotal = ApiDBUtils.getResourceCount(ResourceType.snapshot, account.getId());\n        String snapshotAvail = (accountIsAdmin || snapshotLimit == -1) ? \"Unlimited\" : String.valueOf(snapshotLimit - snapshotTotal);\n        accountResponse.setSnapshotLimit(snapshotLimitDisplay);\n        accountResponse.setSnapshotTotal(snapshotTotal);\n        accountResponse.setSnapshotAvailable(snapshotAvail);\n\n        Long templateLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.template, account.getId());\n        String templateLimitDisplay = (accountIsAdmin || templateLimit == -1) ? \"Unlimited\" : String.valueOf(templateLimit);\n        Long templateTotal = ApiDBUtils.getResourceCount(ResourceType.template, account.getId());\n        String templateAvail = (accountIsAdmin || templateLimit == -1) ? \"Unlimited\" : String.valueOf(templateLimit - templateTotal);\n        accountResponse.setTemplateLimit(templateLimitDisplay);\n        accountResponse.setTemplateTotal(templateTotal);\n        accountResponse.setTemplateAvailable(templateAvail);\n\n        // Get stopped and running VMs\n        int vmStopped = 0;\n        int vmRunning = 0;\n\n        Long[] accountIds = new Long[1];\n        accountIds[0] = account.getId();\n\n        Criteria c1 = new Criteria();\n        c1.addCriteria(Criteria.ACCOUNTID, accountIds);\n        List<? extends UserVm> virtualMachines = ApiDBUtils.searchForUserVMs(c1);\n\n        // get Running/Stopped VMs\n        for (Iterator<? extends UserVm> iter = virtualMachines.iterator(); iter.hasNext();) {\n            // count how many stopped/running vms we have\n            UserVm vm = iter.next();\n\n            if (vm.getState() == State.Stopped) {\n                vmStopped++;\n            } else if (vm.getState() == State.Running) {\n                vmRunning++;\n            }\n        }\n\n        accountResponse.setVmStopped(vmStopped);\n        accountResponse.setVmRunning(vmRunning);\n        accountResponse.setObjectName(\"account\");\n\n        // adding all the users for an account as part of the response obj\n        List<UserVO> usersForAccount = ApiDBUtils.listUsersByAccount(account.getAccountId());\n        List<UserResponse> userResponseList = new ArrayList<UserResponse>();\n        for (UserVO user : usersForAccount) {\n            UserResponse userResponse = new UserResponse();\n            userResponse.setAccountName(account.getAccountName());\n            userResponse.setAccountType(account.getType());\n            userResponse.setApiKey(user.getApiKey());\n            userResponse.setCreated(user.getCreated());\n            userResponse.setDomainId(account.getDomainId());\n            userResponse.setDomainName(ApiDBUtils.findDomainById(account.getDomainId()).getName());\n            userResponse.setEmail(user.getEmail());\n            userResponse.setFirstname(user.getFirstname());\n            userResponse.setId(user.getId());\n            userResponse.setSecretKey(user.getSecretKey());\n            userResponse.setLastname(user.getLastname());\n            userResponse.setState(user.getState().toString());\n            userResponse.setTimezone(user.getTimezone());\n            userResponse.setUsername(user.getUsername());\n\n            userResponseList.add(userResponse);\n        }\n\n        accountResponse.setUsers(userResponseList);\n        return accountResponse;\n    }","commit_id":"b888db2ac660130a9d6b6d7206443b2e479aef46","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public AccountResponse createAccountResponse(Account account) {\n        boolean accountIsAdmin = (account.getType() == Account.ACCOUNT_TYPE_ADMIN);\n        AccountResponse accountResponse = new AccountResponse();\n        accountResponse.setId(account.getId());\n        accountResponse.setName(encodeParam(account.getAccountName()));\n        accountResponse.setAccountType(account.getType());\n        accountResponse.setDomainId(account.getDomainId());\n        accountResponse.setDomainName(ApiDBUtils.findDomainById(account.getDomainId()).getName());\n        accountResponse.setState(account.getState().toString());\n\n        // get network stat\n        List<UserStatisticsVO> stats = ApiDBUtils.listUserStatsBy(account.getId());\n        if (stats == null) {\n            throw new ServerApiException(BaseCmd.INTERNAL_ERROR, \"Internal error searching for user stats\");\n        }\n\n        Long bytesSent = 0L;\n        Long bytesReceived = 0L;\n        for (UserStatisticsVO stat : stats) {\n            Long rx = stat.getNetBytesReceived() + stat.getCurrentBytesReceived();\n            Long tx = stat.getNetBytesSent() + stat.getCurrentBytesSent();\n            bytesReceived = bytesReceived + Long.valueOf(rx);\n            bytesSent = bytesSent + Long.valueOf(tx);\n        }\n        accountResponse.setBytesReceived(bytesReceived);\n        accountResponse.setBytesSent(bytesSent);\n\n        // Get resource limits and counts\n\n        Long vmLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.user_vm, account.getId());\n        String vmLimitDisplay = (accountIsAdmin || vmLimit == -1) ? \"Unlimited\" : String.valueOf(vmLimit);\n        Long vmTotal = ApiDBUtils.getResourceCount(ResourceType.user_vm, account.getId());\n        String vmAvail = (accountIsAdmin || vmLimit == -1) ? \"Unlimited\" : String.valueOf(vmLimit - vmTotal);\n        accountResponse.setVmLimit(vmLimitDisplay);\n        accountResponse.setVmTotal(vmTotal);\n        accountResponse.setVmAvailable(vmAvail);\n\n        Long ipLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.public_ip, account.getId());\n        String ipLimitDisplay = (accountIsAdmin || ipLimit == -1) ? \"Unlimited\" : String.valueOf(ipLimit);\n        Long ipTotal = ApiDBUtils.getResourceCount(ResourceType.public_ip, account.getId());\n        String ipAvail = (accountIsAdmin || ipLimit == -1) ? \"Unlimited\" : String.valueOf(ipLimit - ipTotal);\n        accountResponse.setIpLimit(ipLimitDisplay);\n        accountResponse.setIpTotal(ipTotal);\n        accountResponse.setIpAvailable(ipAvail);\n\n        Long volumeLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.volume, account.getId());\n        String volumeLimitDisplay = (accountIsAdmin || volumeLimit == -1) ? \"Unlimited\" : String.valueOf(volumeLimit);\n        Long volumeTotal = ApiDBUtils.getResourceCount(ResourceType.volume, account.getId());\n        String volumeAvail = (accountIsAdmin || volumeLimit == -1) ? \"Unlimited\" : String.valueOf(volumeLimit - volumeTotal);\n        accountResponse.setVolumeLimit(volumeLimitDisplay);\n        accountResponse.setVolumeTotal(volumeTotal);\n        accountResponse.setVolumeAvailable(volumeAvail);\n\n        Long snapshotLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.snapshot, account.getId());\n        String snapshotLimitDisplay = (accountIsAdmin || snapshotLimit == -1) ? \"Unlimited\" : String.valueOf(snapshotLimit);\n        Long snapshotTotal = ApiDBUtils.getResourceCount(ResourceType.snapshot, account.getId());\n        String snapshotAvail = (accountIsAdmin || snapshotLimit == -1) ? \"Unlimited\" : String.valueOf(snapshotLimit - snapshotTotal);\n        accountResponse.setSnapshotLimit(snapshotLimitDisplay);\n        accountResponse.setSnapshotTotal(snapshotTotal);\n        accountResponse.setSnapshotAvailable(snapshotAvail);\n\n        Long templateLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.template, account.getId());\n        String templateLimitDisplay = (accountIsAdmin || templateLimit == -1) ? \"Unlimited\" : String.valueOf(templateLimit);\n        Long templateTotal = ApiDBUtils.getResourceCount(ResourceType.template, account.getId());\n        String templateAvail = (accountIsAdmin || templateLimit == -1) ? \"Unlimited\" : String.valueOf(templateLimit - templateTotal);\n        accountResponse.setTemplateLimit(templateLimitDisplay);\n        accountResponse.setTemplateTotal(templateTotal);\n        accountResponse.setTemplateAvailable(templateAvail);\n\n        // Get stopped and running VMs\n        int vmStopped = 0;\n        int vmRunning = 0;\n\n        Long[] accountIds = new Long[1];\n        accountIds[0] = account.getId();\n\n        Criteria c1 = new Criteria();\n        c1.addCriteria(Criteria.ACCOUNTID, accountIds);\n        List<? extends UserVm> virtualMachines = ApiDBUtils.searchForUserVMs(c1);\n\n        // get Running/Stopped VMs\n        for (Iterator<? extends UserVm> iter = virtualMachines.iterator(); iter.hasNext();) {\n            // count how many stopped/running vms we have\n            UserVm vm = iter.next();\n\n            if (vm.getState() == State.Stopped) {\n                vmStopped++;\n            } else if (vm.getState() == State.Running) {\n                vmRunning++;\n            }\n        }\n\n        accountResponse.setVmStopped(vmStopped);\n        accountResponse.setVmRunning(vmRunning);\n        accountResponse.setObjectName(\"account\");\n\n        // adding all the users for an account as part of the response obj\n        List<UserVO> usersForAccount = ApiDBUtils.listUsersByAccount(account.getAccountId());\n        List<UserResponse> userResponseList = new ArrayList<UserResponse>();\n        for (UserVO user : usersForAccount) {\n            UserResponse userResponse = new UserResponse();\n            userResponse.setAccountName(encodeParam(account.getAccountName()));\n            userResponse.setAccountType(account.getType());\n            userResponse.setApiKey(user.getApiKey());\n            userResponse.setCreated(user.getCreated());\n            userResponse.setDomainId(account.getDomainId());\n            userResponse.setDomainName(ApiDBUtils.findDomainById(account.getDomainId()).getName());\n            userResponse.setEmail(encodeParam(user.getEmail()));\n            userResponse.setFirstname(user.getFirstname());\n            userResponse.setId(user.getId());\n            userResponse.setSecretKey(user.getSecretKey());\n            userResponse.setLastname(user.getLastname());\n            userResponse.setState(user.getState().toString());\n            userResponse.setTimezone(user.getTimezone());\n            userResponse.setUsername(encodeParam(user.getUsername()));\n\n            userResponseList.add(userResponse);\n        }\n\n        accountResponse.setUsers(userResponseList);\n        return accountResponse;\n    }","id":33189,"modified_method":"@Override\n    public AccountResponse createAccountResponse(Account account) {\n        boolean accountIsAdmin = (account.getType() == Account.ACCOUNT_TYPE_ADMIN);\n        AccountResponse accountResponse = new AccountResponse();\n        accountResponse.setId(account.getId());\n        accountResponse.setName(account.getAccountName());\n        accountResponse.setAccountType(account.getType());\n        accountResponse.setDomainId(account.getDomainId());\n        accountResponse.setDomainName(ApiDBUtils.findDomainById(account.getDomainId()).getName());\n        accountResponse.setState(account.getState().toString());\n\n        // get network stat\n        List<UserStatisticsVO> stats = ApiDBUtils.listUserStatsBy(account.getId());\n        if (stats == null) {\n            throw new ServerApiException(BaseCmd.INTERNAL_ERROR, \"Internal error searching for user stats\");\n        }\n\n        Long bytesSent = 0L;\n        Long bytesReceived = 0L;\n        for (UserStatisticsVO stat : stats) {\n            Long rx = stat.getNetBytesReceived() + stat.getCurrentBytesReceived();\n            Long tx = stat.getNetBytesSent() + stat.getCurrentBytesSent();\n            bytesReceived = bytesReceived + Long.valueOf(rx);\n            bytesSent = bytesSent + Long.valueOf(tx);\n        }\n        accountResponse.setBytesReceived(bytesReceived);\n        accountResponse.setBytesSent(bytesSent);\n\n        // Get resource limits and counts\n\n        Long vmLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.user_vm, account.getId());\n        String vmLimitDisplay = (accountIsAdmin || vmLimit == -1) ? \"Unlimited\" : String.valueOf(vmLimit);\n        Long vmTotal = ApiDBUtils.getResourceCount(ResourceType.user_vm, account.getId());\n        String vmAvail = (accountIsAdmin || vmLimit == -1) ? \"Unlimited\" : String.valueOf(vmLimit - vmTotal);\n        accountResponse.setVmLimit(vmLimitDisplay);\n        accountResponse.setVmTotal(vmTotal);\n        accountResponse.setVmAvailable(vmAvail);\n\n        Long ipLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.public_ip, account.getId());\n        String ipLimitDisplay = (accountIsAdmin || ipLimit == -1) ? \"Unlimited\" : String.valueOf(ipLimit);\n        Long ipTotal = ApiDBUtils.getResourceCount(ResourceType.public_ip, account.getId());\n        String ipAvail = (accountIsAdmin || ipLimit == -1) ? \"Unlimited\" : String.valueOf(ipLimit - ipTotal);\n        accountResponse.setIpLimit(ipLimitDisplay);\n        accountResponse.setIpTotal(ipTotal);\n        accountResponse.setIpAvailable(ipAvail);\n\n        Long volumeLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.volume, account.getId());\n        String volumeLimitDisplay = (accountIsAdmin || volumeLimit == -1) ? \"Unlimited\" : String.valueOf(volumeLimit);\n        Long volumeTotal = ApiDBUtils.getResourceCount(ResourceType.volume, account.getId());\n        String volumeAvail = (accountIsAdmin || volumeLimit == -1) ? \"Unlimited\" : String.valueOf(volumeLimit - volumeTotal);\n        accountResponse.setVolumeLimit(volumeLimitDisplay);\n        accountResponse.setVolumeTotal(volumeTotal);\n        accountResponse.setVolumeAvailable(volumeAvail);\n\n        Long snapshotLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.snapshot, account.getId());\n        String snapshotLimitDisplay = (accountIsAdmin || snapshotLimit == -1) ? \"Unlimited\" : String.valueOf(snapshotLimit);\n        Long snapshotTotal = ApiDBUtils.getResourceCount(ResourceType.snapshot, account.getId());\n        String snapshotAvail = (accountIsAdmin || snapshotLimit == -1) ? \"Unlimited\" : String.valueOf(snapshotLimit - snapshotTotal);\n        accountResponse.setSnapshotLimit(snapshotLimitDisplay);\n        accountResponse.setSnapshotTotal(snapshotTotal);\n        accountResponse.setSnapshotAvailable(snapshotAvail);\n\n        Long templateLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.template, account.getId());\n        String templateLimitDisplay = (accountIsAdmin || templateLimit == -1) ? \"Unlimited\" : String.valueOf(templateLimit);\n        Long templateTotal = ApiDBUtils.getResourceCount(ResourceType.template, account.getId());\n        String templateAvail = (accountIsAdmin || templateLimit == -1) ? \"Unlimited\" : String.valueOf(templateLimit - templateTotal);\n        accountResponse.setTemplateLimit(templateLimitDisplay);\n        accountResponse.setTemplateTotal(templateTotal);\n        accountResponse.setTemplateAvailable(templateAvail);\n\n        // Get stopped and running VMs\n        int vmStopped = 0;\n        int vmRunning = 0;\n\n        Long[] accountIds = new Long[1];\n        accountIds[0] = account.getId();\n\n        Criteria c1 = new Criteria();\n        c1.addCriteria(Criteria.ACCOUNTID, accountIds);\n        List<? extends UserVm> virtualMachines = ApiDBUtils.searchForUserVMs(c1);\n\n        // get Running/Stopped VMs\n        for (Iterator<? extends UserVm> iter = virtualMachines.iterator(); iter.hasNext();) {\n            // count how many stopped/running vms we have\n            UserVm vm = iter.next();\n\n            if (vm.getState() == State.Stopped) {\n                vmStopped++;\n            } else if (vm.getState() == State.Running) {\n                vmRunning++;\n            }\n        }\n\n        accountResponse.setVmStopped(vmStopped);\n        accountResponse.setVmRunning(vmRunning);\n        accountResponse.setObjectName(\"account\");\n\n        // adding all the users for an account as part of the response obj\n        List<UserVO> usersForAccount = ApiDBUtils.listUsersByAccount(account.getAccountId());\n        List<UserResponse> userResponseList = new ArrayList<UserResponse>();\n        for (UserVO user : usersForAccount) {\n            UserResponse userResponse = new UserResponse();\n            userResponse.setAccountName(account.getAccountName());\n            userResponse.setAccountType(account.getType());\n            userResponse.setApiKey(user.getApiKey());\n            userResponse.setCreated(user.getCreated());\n            userResponse.setDomainId(account.getDomainId());\n            userResponse.setDomainName(ApiDBUtils.findDomainById(account.getDomainId()).getName());\n            userResponse.setEmail(user.getEmail());\n            userResponse.setFirstname(user.getFirstname());\n            userResponse.setId(user.getId());\n            userResponse.setSecretKey(user.getSecretKey());\n            userResponse.setLastname(user.getLastname());\n            userResponse.setState(user.getState().toString());\n            userResponse.setTimezone(user.getTimezone());\n            userResponse.setUsername(user.getUsername());\n\n            userResponseList.add(userResponse);\n        }\n\n        accountResponse.setUsers(userResponseList);\n        return accountResponse;\n    }","commit_id":"f4ad575270806b3c4a2dd8d1780fd7d7f9e5805e","url":"https://github.com/apache/cloudstack"},{"original_method":"public Object execute(TransactionCallback callback) throws Exception\n    {\n        if (config == null) {\n            return callback.doInTransaction();\n        } else {\n            byte action = config.getAction();\n            UMOTransaction tx = TransactionCoordination.getInstance().getTransaction();\n\n            if (action == UMOTransactionConfig.ACTION_NONE && tx != null) {\n                throw new IllegalTransactionStateException(new Message(Messages.TX_AVAILABLE_BUT_ACTION_IS_X, \"None\"));\n            } else if (action == UMOTransactionConfig.ACTION_ALWAYS_BEGIN && tx != null) {\n                throw new IllegalTransactionStateException(new Message(Messages.TX_AVAILABLE_BUT_ACTION_IS_X,\n                                                                       \"Always Begin\"));\n            } else if (action == UMOTransactionConfig.ACTION_ALWAYS_JOIN && tx == null) {\n                throw new IllegalTransactionStateException(new Message(Messages.TX_NOT_AVAILABLE_BUT_ACTION_IS_X,\n                                                                       \"Always Join\"));\n            }\n\n            if (action == UMOTransactionConfig.ACTION_ALWAYS_BEGIN\n                    || action == UMOTransactionConfig.ACTION_BEGIN_OR_JOIN) {\n                logger.debug(\"Beginning transaction\");\n                tx = config.getFactory().beginTransaction();\n                logger.debug(\"Transaction successfully started\");\n            } else {\n                tx = null;\n            }\n            try {\n                Object result = callback.doInTransaction();\n                if (tx != null) {\n                    if (tx.isRollbackOnly()) {\n                        logger.debug(\"Transaction is marked for rollback\");\n                        tx.rollback();\n                    } else {\n                        logger.debug(\"Committing transaction\");\n                        tx.commit();\n                    }\n                }\n                return result;\n            } catch (Exception e) {\n                logger.info(\"Exception Caught in Transaction template.  Handing of to exception handler: \"\n                        + exceptionListener);\n                exceptionListener.exceptionThrown(e);\n                if (tx != null) {\n                    // The exception strategy can choose to route exception\n                    // messages\n                    // as part of the current transaction. So only rollback the\n                    // tx\n                    // if it has been marked for rollback (which is the default\n                    // case in the\n                    // AbstractExceptionListener)\n                    if (tx.isRollbackOnly()) {\n                        logger.debug(\"Exception caught: rollback transaction\", e);\n                        tx.rollback();\n                    } else {\n                        tx.commit();\n                    }\n                }\n                // throw e;\n                // we've handled this exception above. just return null now\n                return null;\n            } catch (Error e) {\n                if (tx != null) {\n                    logger.info(\"Error caught: rollback transaction\", e);\n                    tx.rollback();\n                }\n                throw e;\n            }\n        }\n    }","id":33190,"modified_method":"public Object execute(TransactionCallback callback) throws Exception\n    {\n        if (config == null) {\n            return callback.doInTransaction();\n        } else {\n            byte action = config.getAction();\n            UMOTransaction tx = TransactionCoordination.getInstance().getTransaction();\n\n            if (action == UMOTransactionConfig.ACTION_NONE && tx != null) {\n                throw new IllegalTransactionStateException(new Message(Messages.TX_AVAILABLE_BUT_ACTION_IS_X, \"None\"));\n            } else if (action == UMOTransactionConfig.ACTION_ALWAYS_BEGIN && tx != null) {\n                throw new IllegalTransactionStateException(new Message(Messages.TX_AVAILABLE_BUT_ACTION_IS_X,\n                                                                       \"Always Begin\"));\n            } else if (action == UMOTransactionConfig.ACTION_ALWAYS_JOIN && tx == null) {\n                throw new IllegalTransactionStateException(new Message(Messages.TX_NOT_AVAILABLE_BUT_ACTION_IS_X,\n                                                                       \"Always Join\"));\n            }\n\n            if (action == UMOTransactionConfig.ACTION_ALWAYS_BEGIN\n                    || action == UMOTransactionConfig.ACTION_BEGIN_OR_JOIN) {\n                logger.debug(\"Beginning transaction\");\n                tx = config.getFactory().beginTransaction();\n                logger.debug(\"Transaction successfully started\");\n            } else {\n                tx = null;\n            }\n            try {\n                Object result = callback.doInTransaction();\n                if (tx != null) {\n                    if (tx.isRollbackOnly()) {\n                        logger.debug(\"Transaction is marked for rollback\");\n                        tx.rollback();\n                    } else {\n                        logger.debug(\"Committing transaction\");\n                        tx.commit();\n                    }\n                }\n                return result;\n            } catch (Exception e) {\n                if (exceptionListener != null) {\n                    logger.info(\"Exception Caught in Transaction template.  Handing of to exception handler: \"\n                            + exceptionListener);\n                    exceptionListener.exceptionThrown(e);\n                } else {\n                    logger.info(\"Exception Caught in Transaction template without any exception listeners defined, exception is rethrown.\");\n                    if (tx != null) {\n                        tx.setRollbackOnly();\n                    }\n                }\n                if (tx != null) {\n                    // The exception strategy can choose to route exception\n                    // messages\n                    // as part of the current transaction. So only rollback the\n                    // tx\n                    // if it has been marked for rollback (which is the default\n                    // case in the\n                    // AbstractExceptionListener)\n                    if (tx.isRollbackOnly()) {\n                        logger.debug(\"Exception caught: rollback transaction\", e);\n                        tx.rollback();\n                    } else {\n                        tx.commit();\n                    }\n                }\n                // we've handled this exception above. just return null now\n                if (exceptionListener != null) {\n                    return null;\n                } else {\n                    throw e;\n                }\n            } catch (Error e) {\n                if (tx != null) {\n                    logger.info(\"Error caught: rollback transaction\", e);\n                    tx.rollback();\n                }\n                throw e;\n            }\n        }\n    }","commit_id":"12633492fb2890b5ff881edc836f19d40001f7b5","url":"https://github.com/mulesoft/mule"},{"original_method":"public Object execute(TransactionCallback callback) throws Exception\n    {\n        if (config == null) {\n            return callback.doInTransaction();\n        } else {\n            byte action = config.getAction();\n            UMOTransaction tx = TransactionCoordination.getInstance().getTransaction();\n\n            if (action == UMOTransactionConfig.ACTION_NONE && tx != null) {\n                throw new IllegalTransactionStateException(new Message(Messages.TX_AVAILABLE_BUT_ACTION_IS_X, \"None\"));\n            } else if (action == UMOTransactionConfig.ACTION_ALWAYS_BEGIN && tx != null) {\n                throw new IllegalTransactionStateException(new Message(Messages.TX_AVAILABLE_BUT_ACTION_IS_X,\n                                                                       \"Always Begin\"));\n            } else if (action == UMOTransactionConfig.ACTION_ALWAYS_JOIN && tx == null) {\n                throw new IllegalTransactionStateException(new Message(Messages.TX_NOT_AVAILABLE_BUT_ACTION_IS_X,\n                                                                       \"Always Join\"));\n            }\n\n            if (action == UMOTransactionConfig.ACTION_ALWAYS_BEGIN\n                    || action == UMOTransactionConfig.ACTION_BEGIN_OR_JOIN) {\n                logger.debug(\"Beginning transaction\");\n                tx = config.getFactory().beginTransaction();\n                logger.debug(\"Transaction successfully started\");\n            } else {\n                tx = null;\n            }\n            try {\n                Object result = callback.doInTransaction();\n                if (tx != null) {\n                    if (tx.isRollbackOnly()) {\n                        logger.debug(\"Transaction is marked for rollback\");\n                        tx.rollback();\n                    } else {\n                        logger.debug(\"Committing transaction\");\n                        tx.commit();\n                    }\n                }\n                return result;\n            } catch (Exception e) {\n                logger.info(\"Exception Caught in Transaction template.  Handing of to exception handler: \"\n                        + exceptionListener);\n                exceptionListener.exceptionThrown(e);\n                if (tx != null) {\n                    // The exception strategy can choose to route exception\n                    // messages\n                    // as part of the current transaction. So only rollback the\n                    // tx\n                    // if it has been marked for rollback (which is the default\n                    // case in the\n                    // AbstractExceptionListener)\n                    if (tx.isRollbackOnly()) {\n                        logger.debug(\"Exception caught: rollback transaction\", e);\n                        tx.rollback();\n                    } else {\n                        tx.commit();\n                    }\n                }\n                // throw e;\n                // we've handled this exception above. just return null now\n                return null;\n            } catch (Error e) {\n                if (tx != null) {\n                    logger.info(\"Error caught: rollback transaction\", e);\n                    tx.rollback();\n                }\n                throw e;\n            }\n        }\n    }","id":33191,"modified_method":"public Object execute(TransactionCallback callback) throws Exception\n    {\n        if (config == null) {\n            return callback.doInTransaction();\n        } else {\n            byte action = config.getAction();\n            UMOTransaction tx = TransactionCoordination.getInstance().getTransaction();\n\n            if (action == UMOTransactionConfig.ACTION_NONE && tx != null) {\n                throw new IllegalTransactionStateException(new Message(Messages.TX_AVAILABLE_BUT_ACTION_IS_X, \"None\"));\n            } else if (action == UMOTransactionConfig.ACTION_ALWAYS_BEGIN && tx != null) {\n                throw new IllegalTransactionStateException(new Message(Messages.TX_AVAILABLE_BUT_ACTION_IS_X,\n                                                                       \"Always Begin\"));\n            } else if (action == UMOTransactionConfig.ACTION_ALWAYS_JOIN && tx == null) {\n                throw new IllegalTransactionStateException(new Message(Messages.TX_NOT_AVAILABLE_BUT_ACTION_IS_X,\n                                                                       \"Always Join\"));\n            }\n\n            if (action == UMOTransactionConfig.ACTION_ALWAYS_BEGIN\n                    || action == UMOTransactionConfig.ACTION_BEGIN_OR_JOIN) {\n                logger.debug(\"Beginning transaction\");\n                tx = config.getFactory().beginTransaction();\n                logger.debug(\"Transaction successfully started\");\n            } else {\n                tx = null;\n            }\n            try {\n                Object result = callback.doInTransaction();\n                if (tx != null) {\n                    if (tx.isRollbackOnly()) {\n                        logger.debug(\"Transaction is marked for rollback\");\n                        tx.rollback();\n                    } else {\n                        logger.debug(\"Committing transaction\");\n                        tx.commit();\n                    }\n                }\n                return result;\n            } catch (Exception e) {\n                if (exceptionListener != null) {\n                    logger.info(\"Exception Caught in Transaction template.  Handing of to exception handler: \"\n                            + exceptionListener);\n                    exceptionListener.exceptionThrown(e);\n                } else {\n                    logger.info(\"Exception Caught in Transaction template without any exception listeners defined, exception is rethrown.\");\n                    if (tx != null) {\n                        tx.setRollbackOnly();\n                    }\n                }\n                if (tx != null) {\n                    // The exception strategy can choose to route exception\n                    // messages\n                    // as part of the current transaction. So only rollback the\n                    // tx\n                    // if it has been marked for rollback (which is the default\n                    // case in the\n                    // AbstractExceptionListener)\n                    if (tx.isRollbackOnly()) {\n                        logger.debug(\"Exception caught: rollback transaction\", e);\n                        tx.rollback();\n                    } else {\n                        tx.commit();\n                    }\n                }\n                // we've handled this exception above. just return null now\n                if (exceptionListener != null) {\n                    return null;\n                } else {\n                    throw e;\n                }\n            } catch (Error e) {\n                if (tx != null) {\n                    logger.info(\"Error caught: rollback transaction\", e);\n                    tx.rollback();\n                }\n                throw e;\n            }\n        }\n    }","commit_id":"d8d434e673fa2f7fb3a5ac33647e727e0ce3d60e","url":"https://github.com/mulesoft/mule"},{"original_method":"public void handleException(Exception exception)\n    {\n        // TODO What's the difference between this and getConnector().handleException(e) ?\n        connector.getExceptionListener().exceptionThrown(exception);\n    }","id":33192,"modified_method":"public void handleException(Exception exception)\n    {\n        if (exception instanceof ConnectException)\n        {\n            logger.info(\"Exception caught is a ConnectException, disconnecting receiver and invoking ReconnectStrategy\");\n            try\n            {\n                disconnect();\n            }\n            catch (Exception e)\n            {\n                connector.getExceptionListener().exceptionThrown(e);\n            }\n        }\n        connector.getExceptionListener().exceptionThrown(exception);\n        if (exception instanceof ConnectException)\n        {\n            try\n            {\n                logger.warn(\"Reconnecting after exception: \" + exception.getMessage(), exception);\n                connect();\n            }\n            catch (Exception e)\n            {\n                connector.getExceptionListener().exceptionThrown(e);\n            }\n        }\n    }","commit_id":"55a96b16be12260ffe92ee7197623c56b99352f9","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n   * Internal function which does the actual wrapping. This is 90% borrowed from bnd's source code.\n   *\n   * @param module\n   * @param compileContext the compile context\n   * @param inputJar       the input file\n   * @param outputJar      the output file\n   * @param properties     properties for the manifest. these may contain bnd instructions\n   * @return true if the bundling was successful, false otherwise.\n   * @throws Exception in case something goes wrong.\n   */\n  private boolean doWrap(@NotNull Module module,\n                         @NotNull final CompileContext compileContext,\n                         @NotNull File inputJar,\n                         @NotNull final File outputJar,\n                         @NotNull Map<String, String> properties) throws Exception {\n    final String messagePrefix = \"[\" + module.getName() + \"][Library \" + inputJar.getName() + \"] \";\n\n    String sourceFileUrl = VfsUtil.pathToUrl(inputJar.getPath());\n    Analyzer analyzer = new ReportingAnalyzer(compileContext, sourceFileUrl);\n    analyzer.setPedantic(false);\n    analyzer.setJar(inputJar);\n    Jar dot = analyzer.getJar();\n    analyzer.putAll(properties, false);\n    if (analyzer.getProperty(Constants.IMPORT_PACKAGE) == null) {\n      analyzer.setProperty(Constants.IMPORT_PACKAGE, \"*;resolution:=optional\");\n    }\n    if (analyzer.getProperty(Constants.BUNDLE_SYMBOLICNAME) == null) {\n      Pattern p = Pattern.compile(\"(\" + Verifier.SYMBOLICNAME.pattern() + \")(-[0-9])?.*\\\\.jar\");\n      String base = inputJar.getName();\n      Matcher m = p.matcher(base);\n      if (m.matches()) {\n        base = m.group(1);\n      }\n      else {\n        compileContext.addMessage(CompilerMessageCategory.ERROR,\n                                  messagePrefix + \"Can not calculate name of output bundle, rename jar or use -properties\", sourceFileUrl,\n                                  0, 0);\n        return false;\n      }\n\n      analyzer.setProperty(Constants.BUNDLE_SYMBOLICNAME, base);\n    }\n    if (analyzer.getProperty(Constants.EXPORT_PACKAGE) == null) {\n      // avoid spurious error messages about string starting with \",\"\n      // String export = analyzer.calculateExportsFromContents(dot).replaceFirst(\"^\\\\s*,\", \"\");\n      analyzer.setProperty(Constants.EXPORT_PACKAGE, \"*\");\n//      analyzer.setProperty(Constants.EXPORT_PACKAGE, export);\n    }\n    analyzer.mergeManifest(dot.getManifest());\n    String version = analyzer.getProperty(Constants.BUNDLE_VERSION);\n    if (version != null) {\n      version = Analyzer.cleanupVersion(version);\n      analyzer.setProperty(Constants.BUNDLE_VERSION, version);\n    }\n    Manifest mf = analyzer.calcManifest();\n    Jar jar = analyzer.getJar();\n    final File f = FileUtil.createTempFile(\"tmpbnd\", \".jar\");\n    jar.write(f);\n    jar.close();\n    analyzer.close();\n\n    // IDEA-26817 delete the old bundle, so the renameTo later works...\n    if (outputJar.exists()) {\n      if (!outputJar.delete()) {\n        compileContext.addMessage(CompilerMessageCategory.ERROR,\n                                  messagePrefix + \"Could not delete outdated generated bundle. Is \" + outputJar.getPath() + \" writable?\",\n                                  null, 0, 0);\n        return false;\n      }\n    }\n\n    final Ref<Boolean> result = new Ref<Boolean>(false);\n    ApplicationManager.getApplication().invokeAndWait(new Runnable() {\n      public void run() {\n        result.set(ApplicationManager.getApplication().runWriteAction(new Computable<Boolean>() {\n          public Boolean compute() {\n            // this should work in 99% of the cases\n            if (!f.renameTo(outputJar)) {\n              // and this is for the remaining 1%.\n              VirtualFile src = LocalFileSystem.getInstance().findFileByIoFile(f);\n              if (src == null) {\n                compileContext.addMessage(CompilerMessageCategory.ERROR,\n                                          messagePrefix +\n                                          \"No jar file was created. This should not happen. Is \" +\n                                          f.getPath() +\n                                          \" writable?\", null, 0,\n                                          0);\n                return false;\n              }\n              // make sure the parent folder exists:\n              File parentFolder = outputJar.getParentFile();\n              if (!parentFolder.exists()) {\n                if (!parentFolder.mkdirs()) {\n                  compileContext\n                    .addMessage(CompilerMessageCategory.ERROR,\n                                messagePrefix + \"Cannot create output folder. Is \" + parentFolder.getPath() + \" writable?\",\n                                null, 0, 0);\n                  return false;\n                }\n              }\n\n              // now get the target folder\n              VirtualFile target = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(parentFolder);\n              if (target == null) {\n                // this actually should not happen but since we are bound by murphy's law, we check this as well\n                // and believe it or not it DID happen.\n                compileContext.addMessage(CompilerMessageCategory.ERROR, messagePrefix + \"Output path \" +\n                                                                         parentFolder.getPath() +\n                                                                         \" was created but cannot be found anymore. This should not happen.\",\n                                          null, 0, 0);\n                return false;\n              }\n              // IDEA-26817: target must be the dir, not the the file, so:\n              // and then put this in. This should produce the correct result.\n              try {\n                VfsUtilCore.copyFile(this, src, target, outputJar.getName());\n              }\n              catch (IOException e) {\n                compileContext\n                  .addMessage(CompilerMessageCategory.ERROR, messagePrefix + \"Could not copy \" + src + \" to \" + target, null, 0, 0);\n                return false;\n              }\n            }\n            return true;\n          }\n        }));\n      }\n    }, ModalityState.defaultModalityState());\n    return result.get();\n  }","id":33193,"modified_method":"/**\n   * Internal function which does the actual wrapping. This is 90% borrowed from bnd's source code.\n   *\n   * @param module\n   * @param compileContext the compile context\n   * @param inputJar       the input file\n   * @param outputJar      the output file\n   * @param properties     properties for the manifest. these may contain bnd instructions\n   * @return true if the bundling was successful, false otherwise.\n   * @throws Exception in case something goes wrong.\n   */\n  private boolean doWrap(@NotNull Module module,\n                         @NotNull final CompileContext compileContext,\n                         @NotNull File inputJar,\n                         @NotNull final File outputJar,\n                         @NotNull Map<String, String> properties) throws Exception {\n    final String messagePrefix = \"[\" + module.getName() + \"][Library \" + inputJar.getName() + \"] \";\n\n    String sourceFileUrl = VfsUtilCore.pathToUrl(inputJar.getPath());\n    Analyzer analyzer = new ReportingAnalyzer(compileContext, sourceFileUrl);\n    analyzer.setPedantic(false);\n    analyzer.setJar(inputJar);\n    Jar dot = analyzer.getJar();\n    analyzer.putAll(properties, false);\n    if (analyzer.getProperty(Constants.IMPORT_PACKAGE) == null) {\n      analyzer.setProperty(Constants.IMPORT_PACKAGE, \"*;resolution:=optional\");\n    }\n    if (analyzer.getProperty(Constants.BUNDLE_SYMBOLICNAME) == null) {\n      Pattern p = Pattern.compile(\"(\" + Verifier.SYMBOLICNAME.pattern() + \")(-[0-9])?.*\\\\.jar\");\n      String base = inputJar.getName();\n      Matcher m = p.matcher(base);\n      if (m.matches()) {\n        base = m.group(1);\n      }\n      else {\n        compileContext.addMessage(CompilerMessageCategory.ERROR,\n                                  messagePrefix + \"Can not calculate name of output bundle, rename jar or use -properties\", sourceFileUrl,\n                                  0, 0);\n        return false;\n      }\n\n      analyzer.setProperty(Constants.BUNDLE_SYMBOLICNAME, base);\n    }\n    if (analyzer.getProperty(Constants.EXPORT_PACKAGE) == null) {\n      // avoid spurious error messages about string starting with \",\"\n      // String export = analyzer.calculateExportsFromContents(dot).replaceFirst(\"^\\\\s*,\", \"\");\n      analyzer.setProperty(Constants.EXPORT_PACKAGE, \"*\");\n//      analyzer.setProperty(Constants.EXPORT_PACKAGE, export);\n    }\n    analyzer.mergeManifest(dot.getManifest());\n    String version = analyzer.getProperty(Constants.BUNDLE_VERSION);\n    if (version != null) {\n      version = Analyzer.cleanupVersion(version);\n      analyzer.setProperty(Constants.BUNDLE_VERSION, version);\n    }\n    analyzer.calcManifest();\n    Jar jar = analyzer.getJar();\n    final File f = FileUtil.createTempFile(\"tmpbnd\", \".jar\");\n    jar.write(f);\n    jar.close();\n    analyzer.close();\n\n    // IDEA-26817 delete the old bundle, so the renameTo later works...\n    if (outputJar.exists()) {\n      if (!outputJar.delete()) {\n        compileContext.addMessage(CompilerMessageCategory.ERROR,\n                                  messagePrefix + \"Could not delete outdated generated bundle. Is \" + outputJar.getPath() + \" writable?\",\n                                  null, 0, 0);\n        return false;\n      }\n    }\n\n    final Ref<Boolean> result = new Ref<Boolean>(false);\n    ApplicationManager.getApplication().invokeAndWait(new Runnable() {\n      public void run() {\n        result.set(ApplicationManager.getApplication().runWriteAction(new Computable<Boolean>() {\n          public Boolean compute() {\n            // this should work in 99% of the cases\n            if (!f.renameTo(outputJar)) {\n              // and this is for the remaining 1%.\n              VirtualFile src = LocalFileSystem.getInstance().findFileByIoFile(f);\n              if (src == null) {\n                compileContext.addMessage(CompilerMessageCategory.ERROR,\n                                          messagePrefix +\n                                          \"No jar file was created. This should not happen. Is \" +\n                                          f.getPath() +\n                                          \" writable?\", null, 0,\n                                          0);\n                return false;\n              }\n              // make sure the parent folder exists:\n              File parentFolder = outputJar.getParentFile();\n              if (!parentFolder.exists()) {\n                if (!parentFolder.mkdirs()) {\n                  compileContext\n                    .addMessage(CompilerMessageCategory.ERROR,\n                                messagePrefix + \"Cannot create output folder. Is \" + parentFolder.getPath() + \" writable?\",\n                                null, 0, 0);\n                  return false;\n                }\n              }\n\n              // now get the target folder\n              VirtualFile target = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(parentFolder);\n              if (target == null) {\n                // this actually should not happen but since we are bound by murphy's law, we check this as well\n                // and believe it or not it DID happen.\n                compileContext.addMessage(CompilerMessageCategory.ERROR, messagePrefix + \"Output path \" +\n                                                                         parentFolder.getPath() +\n                                                                         \" was created but cannot be found anymore. This should not happen.\",\n                                          null, 0, 0);\n                return false;\n              }\n              // IDEA-26817: target must be the dir, not the the file, so:\n              // and then put this in. This should produce the correct result.\n              try {\n                VfsUtilCore.copyFile(this, src, target, outputJar.getName());\n              }\n              catch (IOException e) {\n                compileContext\n                  .addMessage(CompilerMessageCategory.ERROR, messagePrefix + \"Could not copy \" + src + \" to \" + target, null, 0, 0);\n                return false;\n              }\n            }\n            return true;\n          }\n        }));\n      }\n    }, ModalityState.defaultModalityState());\n    return result.get();\n  }","commit_id":"fc5560fd753b4cea59d3031867cef3428d156d08","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n   * Wraps an existing jar file using bnd's analyzer. This class will check and use any applying bundlification rules\n   * for this library that have been set up in Osmorcs library bundlification dialog.\n   * <p/>\n   *\n   * @param module\n   * @param compileContext a compile context\n   * @param sourceJarUrl   the URL to the source jar file\n   * @param outputPath     the path where to place the bundled library.\n   * @return the URL to the bundled library.\n   */\n  @Nullable\n  public String wrapLibrary(Module module, @NotNull CompileContext compileContext, final String sourceJarUrl, String outputPath) {\n    String messagePrefix = \"[\" + module.getName() + \"] \";\n    try {\n      File targetDir = new File(outputPath);\n      File sourceFile = new File(VfsUtil.urlToPath(sourceJarUrl));\n      if (!sourceFile.exists()) {\n        compileContext.addMessage(CompilerMessageCategory.WARNING, messagePrefix +\n                                                                   \"The library \" +\n                                                                   sourceFile.getPath() +\n                                                                   \" does not exist. Please check your module settings. Ignoring missing library.\",\n                                  null, 0, 0);\n        return null;\n      }\n      if (sourceFile.isDirectory()) {\n        // ok it's an exploded directory, we cannot bundle it.\n        return null;\n      }\n\n      File targetFile = new File(targetDir.getPath() + File.separator + sourceFile.getName());\n      Map<String, String> additionalProperties = new HashMap<String, String>();\n\n      // okay try to find a rule for this nice package:\n      long lastModified = Long.MIN_VALUE;\n      ApplicationSettings settings = ServiceManager.getService(ApplicationSettings.class);\n      for (LibraryBundlificationRule bundlificationRule : settings.getLibraryBundlificationRules()) {\n        if (bundlificationRule.appliesTo(sourceFile.getName())) {\n          if (bundlificationRule.isDoNotBundle()) {\n            return null; // make it quick in this case\n          }\n          additionalProperties.putAll(bundlificationRule.getAdditionalPropertiesMap());\n          // if a rule applies which has been changed recently we need to re-bundle the file\n          lastModified = Math.max(lastModified, bundlificationRule.getLastModified());\n\n          // if stop after this rule is true, we will no longer try to find any more matching rules\n          if (bundlificationRule.isStopAfterThisRule()) {\n            break;\n          }\n        }\n      }\n\n\n      if (!targetFile.exists() || targetFile.lastModified() < sourceFile.lastModified() ||\n          targetFile.lastModified() < lastModified) {\n        if (doWrap(module, compileContext, sourceFile, targetFile, additionalProperties)) {\n          return VfsUtil.pathToUrl(targetFile.getCanonicalPath());\n        }\n      }\n      else {\n        // Fixes IDEADEV-39099. When the wrapper does not return anything the library is not regarded\n        // as a bundle.\n        return VfsUtil.pathToUrl(targetFile.getCanonicalPath());\n      }\n    }\n    catch (final Exception e) {\n      // There is some reported issue where a lot of exceptions have been thrown which caused a ton of popup\n      // boxes, so we better put this into the compile context as normal error message. Can't reproduce the issue\n      // but i think it's stil the better way.\n      // IDEA-27101\n      // IDEA-69149 - Changed this form ERROR to WARNING, as a non-bundlified library might not be fatal (especially when importing a ton of libs from maven)\n      compileContext.addMessage(CompilerMessageCategory.WARNING,\n                                MessageFormat\n                                  .format(messagePrefix + \"There was an unexpected problem when trying to bundlify {0}: {1}\", sourceJarUrl,\n                                          StacktraceUtil.stackTraceToString(e)), null, 0, 0);\n    }\n    return null;\n  }","id":33194,"modified_method":"/**\n   * Wraps an existing jar file using bnd's analyzer. This class will check and use any applying bundlification rules\n   * for this library that have been set up in Osmorcs library bundlification dialog.\n   */\n  @Nullable\n  public String wrapLibrary(Module module, @NotNull CompileContext compileContext, final String sourceJarUrl, File targetDir) {\n    String messagePrefix = \"[\" + module.getName() + \"] \";\n    try {\n      File sourceFile = new File(VfsUtilCore.urlToPath(sourceJarUrl));\n      if (!sourceFile.exists()) {\n        compileContext.addMessage(CompilerMessageCategory.WARNING, messagePrefix +\n                                                                   \"The library \" +\n                                                                   sourceFile.getPath() +\n                                                                   \" does not exist. Please check your module settings. Ignoring missing library.\",\n                                  null, 0, 0);\n        return null;\n      }\n      if (sourceFile.isDirectory()) {\n        // ok it's an exploded directory, we cannot bundle it.\n        return null;\n      }\n\n      File targetFile = new File(targetDir.getPath() + File.separator + sourceFile.getName());\n      Map<String, String> additionalProperties = new HashMap<String, String>();\n\n      // okay try to find a rule for this nice package:\n      long lastModified = Long.MIN_VALUE;\n      ApplicationSettings settings = ServiceManager.getService(ApplicationSettings.class);\n      for (LibraryBundlificationRule bundlificationRule : settings.getLibraryBundlificationRules()) {\n        if (bundlificationRule.appliesTo(sourceFile.getName())) {\n          if (bundlificationRule.isDoNotBundle()) {\n            return null; // make it quick in this case\n          }\n          additionalProperties.putAll(bundlificationRule.getAdditionalPropertiesMap());\n          // if a rule applies which has been changed recently we need to re-bundle the file\n          lastModified = Math.max(lastModified, bundlificationRule.getLastModified());\n\n          // if stop after this rule is true, we will no longer try to find any more matching rules\n          if (bundlificationRule.isStopAfterThisRule()) {\n            break;\n          }\n        }\n      }\n\n\n      if (!targetFile.exists() || targetFile.lastModified() < sourceFile.lastModified() ||\n          targetFile.lastModified() < lastModified) {\n        if (doWrap(module, compileContext, sourceFile, targetFile, additionalProperties)) {\n          return VfsUtilCore.pathToUrl(targetFile.getCanonicalPath());\n        }\n      }\n      else {\n        // Fixes IDEADEV-39099. When the wrapper does not return anything the library is not regarded\n        // as a bundle.\n        return VfsUtilCore.pathToUrl(targetFile.getCanonicalPath());\n      }\n    }\n    catch (final Exception e) {\n      // There is some reported issue where a lot of exceptions have been thrown which caused a ton of popup\n      // boxes, so we better put this into the compile context as normal error message. Can't reproduce the issue\n      // but i think it's stil the better way.\n      // IDEA-27101\n      // IDEA-69149 - Changed this form ERROR to WARNING, as a non-bundlified library might not be fatal (especially when importing a ton of libs from maven)\n      compileContext.addMessage(CompilerMessageCategory.WARNING,\n                                MessageFormat\n                                  .format(messagePrefix + \"There was an unexpected problem when trying to bundlify {0}: {1}\", sourceJarUrl,\n                                          StacktraceUtil.stackTraceToString(e)), null, 0, 0);\n    }\n    return null;\n  }","commit_id":"fc5560fd753b4cea59d3031867cef3428d156d08","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n   * Builds the jar file for the given module. This is called inside a compile run.\n   *\n   * @param module          the module to be built.\n   * @param compileContext  the current compile context. this is used for issuing error messages.\n   * @param classPathUrls   a list of urls comprising the classpath. this is given to bnd, so it can pull classes and resources from there.\n   * @param outputPath      the output path, that is the full path name of the jar file to be created.\n   * @param buildProperties a list of properties containing bnd configuration values.\n   * @return true if the build succeeded, false otherwise.\n   */\n  public static boolean build(@NotNull Module module, @NotNull CompileContext compileContext,\n                              @NotNull String[] classPathUrls, @NotNull String outputPath,\n                              @NotNull Map<String, String> buildProperties) {\n\n    String messagePrefix = \"[\" + module.getName() + \"] \";\n    File[] classPathEntries = new File[classPathUrls.length];\n    for (int i = 0; i < classPathUrls.length; i++) {\n      String classPathUrl = classPathUrls[i];\n      classPathEntries[i] = new File(VfsUtil.urlToPath(classPathUrl));\n    }\n\n    // build a bnd file here containing all accumulated settings.\n    File bndFile;\n    try {\n      bndFile = makeBndFile(module, buildProperties, compileContext);\n    }\n    catch (IOException e) {\n      compileContext\n        .addMessage(CompilerMessageCategory.ERROR, messagePrefix + \"Problem when generating bnd file \" + e.getMessage(), null, 0, 0);\n      return false;\n    }\n\n    File outFile = new File(outputPath);\n    try {\n      return doBuild(module, compileContext, bndFile, classPathEntries, outFile);\n    }\n    catch (Exception e) {\n      compileContext.addMessage(CompilerMessageCategory.ERROR, messagePrefix + \"Unexpected error: \" + e.getMessage(), null, 0, 0);\n      return false;\n    }\n  }","id":33195,"modified_method":"/**\n   * Builds the jar file for the given module. This is called inside a compile run.\n   */\n  public static boolean build(@NotNull Module module,\n                              @NotNull CompileContext compileContext,\n                              @NotNull File bndFile,\n                              @NotNull List<String> classPathUrls,\n                              @NotNull String outputPath) throws Exception {\n    String prefix = \"[\" + module.getName() + \"] \";\n\n    ReportingBuilder builder = new ReportingBuilder(compileContext, VfsUtilCore.pathToUrl(bndFile.getPath()), module);\n    builder.setPedantic(false);\n    builder.setProperties(bndFile);\n\n    File[] classPath = new File[classPathUrls.size()];\n    for (int i = 0; i < classPathUrls.size(); i++) {\n      classPath[i] = new File(VfsUtilCore.urlToPath(classPathUrls.get(i)));\n    }\n    builder.setClasspath(classPath);\n\n    // Check if the manifest version is missing (IDEADEV-41174)\n    String manifest = builder.getProperty(aQute.lib.osgi.Constants.MANIFEST);\n    if (manifest != null) {\n      File manifestFile = builder.getFile(manifest);\n      if (manifestFile != null && manifestFile.canRead()) {\n        Properties props = new Properties();\n        FileInputStream fileInputStream = new FileInputStream(manifestFile);\n        try {\n          props.load(fileInputStream);\n          String value = props.getProperty(Attributes.Name.MANIFEST_VERSION.toString());\n          if (StringUtil.isEmptyOrSpaces(value)) {\n            String message = \"Your manifest does not contain a Manifest-Version entry. This may produce an empty manifest in the resulting bundle.\";\n            compileContext.addMessage(CompilerMessageCategory.WARNING, prefix + message, VfsUtilCore.pathToUrl(manifestFile.getAbsolutePath()), 0, 0);\n          }\n        }\n        catch (Exception ex) {\n          String message = \"There was a problem reading your manifest.\";\n          compileContext.addMessage(CompilerMessageCategory.WARNING, prefix + message, VfsUtilCore.pathToUrl(manifestFile.getAbsolutePath()), 0, 0);\n        }\n        finally {\n          fileInputStream.close();\n        }\n      }\n    }\n\n    File output = new File(outputPath);\n    Jar jar = builder.build();\n    jar.setName(output.getName());\n    jar.write(output);\n    builder.close();\n\n    return true;\n  }","commit_id":"fc5560fd753b4cea59d3031867cef3428d156d08","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n   * Tries to determine the compiler output path of the given module\n   *\n   * @param m       the module\n   * @param context the compile context\n   * @return the compiler output path or null, if it cannot be determined.\n   */\n  @Nullable\n  static String getOutputPath(final @NotNull Module m, @NotNull CompileContext context) {\n    final CompilerModuleExtension extension = CompilerModuleExtension.getInstance(m);\n    if (extension == null) {\n      context.addMessage(CompilerMessageCategory.WARNING, \"Unable to determine the compiler output path for module \" + m.getName(),\n                         null, 0, 0);\n      return null;\n    }\n    VirtualFile moduleCompilerOutputPath = extension.getCompilerOutputPath();\n\n    String path;\n    if (moduleCompilerOutputPath == null) {\n      // get the url\n      String outputPathUrl = extension.getCompilerOutputUrl();\n\n      // create the paths\n      // FIX  \t IDEADEV-40112\n      File f = new File(VfsUtil.urlToPath(outputPathUrl));\n      if (!f.exists() && !f.mkdirs()) {\n        context.addMessage(CompilerMessageCategory.ERROR, \"Cannot create compiler output path!\", null, 0, 0);\n        return null;\n      }\n\n      path = f.getParentFile().getPath() + File.separator + \"bundles\";\n    }\n    else {\n      path = moduleCompilerOutputPath.getParent().getPath() + File.separator + \"bundles\";\n    }\n\n    File f = new File(path);\n    if (!f.exists()) {\n      if (!f.mkdirs()) {\n        context\n          .addMessage(CompilerMessageCategory.ERROR, \"Could not create output path: \" + path + \" Please check file permissions.\", null, 0,\n                      0);\n        return null;\n      }\n    }\n    return path;\n  }","id":33196,"modified_method":"/**\n   * Creates Osmorc output dir relative to a module's one.\n   */\n  @Nullable\n  public static File getOutputDir(@NotNull File moduleOutputDir, @NotNull CompileContext context) {\n    File outputDir = new File(moduleOutputDir.getParent(), \"bundles\");\n    if (!outputDir.exists() && !outputDir.mkdirs()) {\n      String message = \"Could not create output directory: \" + outputDir + \". Please check file permissions.\";\n      context.addMessage(CompilerMessageCategory.ERROR, message, null, 0, 0);\n      return null;\n    }\n    return outputDir;\n  }","commit_id":"fc5560fd753b4cea59d3031867cef3428d156d08","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n   * Generates a bnd file from the given contents map and returns it.\n   *\n   * @param module         the module for which the file should be built. The file will be placed in the output path of the module.\n   * @param contents       the contents of the file\n   * @param compileContext a compile context.\n   * @return the generated file\n   * @throws IOException in case creation of the file fails.\n   */\n  @NotNull\n  private static File makeBndFile(@NotNull Module module, @NotNull Map<String, String> contents, @NotNull CompileContext compileContext)\n    throws IOException {\n    final String outputPath = getOutputPath(module, compileContext);\n    if (outputPath == null) {\n      throw new IOException(\"Unable to determine module output path for module \" + module.getName());\n    }\n    OrderedProperties props = OrderedProperties.fromMap(contents);\n    File tmpFile = FileUtil.createTempFile(new File(outputPath), \"osmorc\", \".bnd\", true);\n    // create one\n    BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(tmpFile));\n    try {\n      props.store(bos,\n                  \"Bnd file generated by Osmorc for build of Module \" + module.getName() + \" in project \" + module.getProject().getName());\n    }\n    finally {\n      bos.close();\n    }\n    tmpFile.deleteOnExit();\n    return tmpFile;\n  }","id":33197,"modified_method":"/**\n   * Generates a bnd file from the given contents map and returns it.\n   */\n  @NotNull\n  public static File makeBndFile(@NotNull Module module,\n                                 @NotNull Map<String, String> contents,\n                                 @NotNull File outputDir) throws IOException {\n    File tmpFile = FileUtil.createTempFile(outputDir, \"osmorc.\", \".bnd\", true);\n\n    BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(tmpFile));\n    try {\n      OrderedProperties props = OrderedProperties.fromMap(contents);\n      String comments = \"Bnd file generated by Osmorc for build of module \" + module.getName() + \" in project \" + module.getProject().getName();\n      props.store(bos, comments);\n    }\n    finally {\n      bos.close();\n    }\n\n    tmpFile.deleteOnExit();\n    return tmpFile;\n  }","commit_id":"fc5560fd753b4cea59d3031867cef3428d156d08","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n   * Returns all processingitems (== Bundles to be created) for the given compile context\n   *\n   * @param compileContext the compile context\n   * @return a list of bundles that need to be compiled\n   */\n  @NotNull\n  public ProcessingItem[] getProcessingItems(final CompileContext compileContext) {\n    return ApplicationManager.getApplication().runReadAction(new Computable<ProcessingItem[]>() {\n      public ProcessingItem[] compute() {\n        // find and add all dependent modules to the list of stuff to be compiled\n        CompileScope compilescope = compileContext.getCompileScope();\n        Module[] affectedModules = compilescope.getAffectedModules();\n        if (affectedModules.length == 0) {\n          return ProcessingItem.EMPTY_ARRAY;\n        }\n\n        List<ProcessingItem> result = new ArrayList<ProcessingItem>();\n        for (Module affectedModule : affectedModules) {\n          if (OsmorcFacet.hasOsmorcFacet(affectedModule)) {\n            result.add(new BundleProcessingItem(affectedModule));\n          }\n        }\n        return result.toArray(new ProcessingItem[result.size()]);\n      }\n    });\n  }","id":33198,"modified_method":"/**\n   * Returns all processing items (modules with bundles to be created) for the given compile context.\n   */\n  @NotNull\n  @Override\n  public ProcessingItem[] getProcessingItems(final CompileContext compileContext) {\n    return ApplicationManager.getApplication().runReadAction(new Computable<ProcessingItem[]>() {\n      public ProcessingItem[] compute() {\n        // find and add all dependent modules to the list of stuff to be compiled\n        Module[] affectedModules = compileContext.getCompileScope().getAffectedModules();\n        if (affectedModules.length == 0) {\n          return ProcessingItem.EMPTY_ARRAY;\n        }\n\n        List<ProcessingItem> result = ContainerUtil.newArrayList();\n        for (Module module : affectedModules) {\n          OsmorcFacet facet = OsmorcFacet.getInstance(module);\n          if (facet != null) {\n            result.add(new BundleProcessingItem(module, facet));\n          }\n        }\n        return result.toArray(new ProcessingItem[result.size()]);\n      }\n    });\n  }","commit_id":"fc5560fd753b4cea59d3031867cef3428d156d08","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n   * Recreates a validity state from a data input stream\n   *\n   * @param in stream containing the data\n   * @return the validity state\n   * @throws IOException in case something goes wrong\n   */\n  public ValidityState createValidityState(DataInput in) throws IOException {\n    return new BundleValidityState(in);\n  }","id":33199,"modified_method":"/**\n   * Recreates a validity state from a data input stream.\n   */\n  @Override\n  public ValidityState createValidityState(DataInput in) throws IOException {\n    return new BundleValidityState(in);\n  }","commit_id":"fc5560fd753b4cea59d3031867cef3428d156d08","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n   * Builds the bundle for a given module.\n   *\n   * @param module            the module\n   * @param progressIndicator the progress indicator\n   * @param compileContext\n   * @throws IOException in case something goes wrong.\n   */\n  private static void buildBundle(final Module module, final ProgressIndicator progressIndicator,\n                                  final CompileContext compileContext)\n    throws IOException {\n    String messagePrefix = \"[\" + module.getName() + \"] \";\n    progressIndicator.setText(\"Building bundle for module \" + module.getName());\n    // create the jar file\n    final File jarFile = new File(VfsUtil.urlToPath(getJarFileName(module)));\n    FileUtil.delete(jarFile);\n\n    if (!FileUtil.createParentDirs(jarFile)) {\n      compileContext.addMessage(CompilerMessageCategory.ERROR, messagePrefix + \"Cannot create path to \" + jarFile.getPath(), null, 0, 0);\n      return;\n    }\n\n    final VirtualFile moduleOutputDir = new ReadAction<VirtualFile>() {\n      protected void run(Result<VirtualFile> result) {\n        result.setResult(getModuleOutputUrl(module));\n      }\n    }.execute().getResultObject();\n\n    final BndWrapper wrapper = new BndWrapper();\n    OsmorcFacet osmorcFacet = OsmorcFacet.getInstance(module);\n    final OsmorcFacetConfiguration configuration = osmorcFacet.getConfiguration();\n    final List<String> classPaths = new ArrayList<String>();\n\n    if (moduleOutputDir != null) {\n      classPaths.add(moduleOutputDir.getUrl());\n    }\n\n\n    // build a bnd file or use a provided one.\n    // use a linked hash map to keep the order of properties.\n    Map<String, String> buildProperties = new LinkedHashMap<String, String>();\n    if (configuration.isUseBndFile()) {\n      File bndFile = findFileInModuleContentRoots(configuration.getBndFileLocation(), module);\n      if (bndFile == null || !bndFile.exists()) {\n        compileContext.addMessage(CompilerMessageCategory.ERROR,\n                                  String.format(messagePrefix + \"The bnd file \\\"%s\\\" for module \\\"%s\\\" does not exist.\",\n                                                configuration.getBndFileLocation(), module.getName()),\n                                  configuration.getBndFileLocation(), 0, 0);\n        return;\n      }\n      else {\n        OrderedProperties props = new OrderedProperties();\n        FileInputStream fis = new FileInputStream(bndFile);\n        try {\n          props.load(fis);\n        }\n        finally {\n          fis.close();\n        }\n        // copy properties to map\n        buildProperties.putAll(props.toMap());\n      }\n    }\n    else if (configuration.isUseBundlorFile()) {\n      // bundlor, in this case we use bnd for creating the jar only, and later run bundlor to\n      // do the manifest magic.\n    }\n    else if (configuration.isOsmorcControlsManifest()) {\n      // fully osmorc controlled, no bnd file, read in all  properties\n      buildProperties.putAll(configuration.getBndFileProperties());\n    }\n    else if (configuration.isManifestManuallyEdited()) { // manually edited manifest\n      boolean manifestExists = false;\n      VirtualFile manifestFile = osmorcFacet.getManifestFile();\n      if (manifestFile != null) {\n        String manifestFilePath = manifestFile.getPath();\n        if (manifestFilePath != null) {\n          buildProperties.put(\"-manifest\", manifestFilePath);\n          manifestExists = true;\n        }\n      }\n      if (!manifestExists) {\n        compileContext.addMessage(CompilerMessageCategory.ERROR,\n                                  messagePrefix +\n                                  \"Manifest file for module \" +\n                                  module.getName() +\n                                  \": '\" +\n                                  osmorcFacet.getManifestLocation() +\n                                  \"' does not exist or cannot be found. Check that file exists and is not excluded from the module.\", null,\n                                  0, 0);\n        return;\n      }\n    }\n    else {\n      compileContext.addMessage(CompilerMessageCategory.ERROR, messagePrefix + \"OSGi facet configuration for module \" + module.getName() +\n                                                               \" seems to be invalid. No supported manifest handling method is set up.\" +\n                                                               \" Please check configuration and try again.\", null, 0, 0);\n    }\n\n    if (configuration.isManifestManuallyEdited() || configuration.isOsmorcControlsManifest()) {\n      // in this case we manually add all the classpaths as resources\n      StringBuilder pathBuilder = new StringBuilder();\n      // add all the classpaths to include resources, so stuff from the project gets copied over.\n      // XXX: one could argue if this should be done for a non-osmorc build\n      for (int i = 0; i < classPaths.size(); i++) {\n        String classPath = classPaths.get(i);\n        String relPath = FileUtil.getRelativePath(new File(BndWrapper.getOutputPath(module,  compileContext)),\n                                                  new File(VfsUtil.urlToPath(classPath)));\n        if (i != 0) {\n          pathBuilder.append(\",\");\n        }\n        pathBuilder.append(relPath);\n      }\n\n      // now include the paths from the configuration\n      List<Pair<String, String>> list = configuration.getAdditionalJARContents();\n      for (Pair<String, String> stringStringPair : list) {\n        pathBuilder.append(\",\").append(stringStringPair.second).append(\" = \").append(stringStringPair.first);\n      }\n\n      // and tell bnd what resources to include\n      String includedResources = configuration.getAdditionalPropertiesAsMap().get(\"Include-Resource\");\n      if (includedResources == null) {\n        includedResources = pathBuilder.toString();\n      }\n      else {\n        includedResources = includedResources + \",\" + pathBuilder.toString();\n      }\n      buildProperties.put(\"Include-Resource\", includedResources);\n\n      if (!configuration.isIgnorePatternValid()) {\n        compileContext.addMessage(CompilerMessageCategory.ERROR,\n                                  messagePrefix + \"The file ignore pattern in the facet configuration is invalid.\", null, 0, 0);\n        return;\n      }\n\n      // add the ignore pattern for the resources\n      if (!configuration.getIgnoreFilePattern().isEmpty()) {\n        buildProperties.put(\"-donotcopy\", configuration.getIgnoreFilePattern());\n      }\n    }\n\n    if ( configuration.isOsmorcControlsManifest() ) {\n      // support the {local-packages} instruction\n      progressIndicator.setText2(\"Calculating local packages\");\n      LocalPackageCollector.addLocalPackages(VfsUtil.virtualToIoFile(moduleOutputDir), buildProperties);\n    }\n\n    String outputPath = jarFile.getPath();\n    if (configuration.isUseBundlorFile()) {\n      // we create a temp jar file in this case.\n      outputPath += \".tmp.jar\";\n    }\n\n    progressIndicator.setText2(\"Running bnd to build the bundle\");\n    BndWrapper.build(module, compileContext, ArrayUtil.toStringArray(classPaths), outputPath, buildProperties);\n\n    // if we use bundlor, let bundlor work on the generated file.\n    if (configuration.isUseBundlorFile()) {\n      progressIndicator.setText2(\"Running bundlor to calculate the manifest\");\n      File bundlorFile = findFileInModuleContentRoots(configuration.getBundlorFileLocation(), module);\n      if (bundlorFile == null || !bundlorFile.exists()) {\n        compileContext.addMessage(CompilerMessageCategory.ERROR,\n                                  String.format(messagePrefix + \"The Bundlor file \\\"%s\\\" for module \\\"%s\\\" does not exist.\",\n                                                configuration.getBundlorFileLocation(), module.getName()),\n                                  configuration.getBundlorFileLocation(), 0, 0);\n        return;\n      }\n      BundlorWrapper bw = new BundlorWrapper();\n      try {\n        if (!bw.wrapModule(compileContext, outputPath, jarFile.getPath(), bundlorFile.getPath())) {\n\n          compileContext.addMessage(CompilerMessageCategory.ERROR,\n                                    messagePrefix + \"Bundlifying the file \" + jarFile.getPath() + \" with Bundlor failed.\", null, 0, 0);\n          return;\n        }\n      }\n      finally {\n        // delete the tmp jar\n        File tempJar = new File(outputPath);\n        if (tempJar.exists()) {\n          if (!tempJar.delete()) {\n            compileContext\n              .addMessage(CompilerMessageCategory.WARNING, messagePrefix + \"Could not delete temporary file: \" + tempJar.getPath(), null, 0,\n                          0);\n          }\n        }\n      }\n    }\n\n    if (!configuration.isUseBndFile() && !configuration.isUseBundlorFile()) {\n      // finally bundlify all the libs for this one\n      bundlifyLibraries(module, progressIndicator, compileContext);\n    }\n  }","id":33200,"modified_method":"/**\n   * Builds the bundle for a given module.\n   */\n  private static void buildBundle(Module module, OsmorcFacet facet, CompileContext context) {\n    ProgressIndicator progressIndicator = context.getProgressIndicator();\n    progressIndicator.setText(\"Building bundle for module \" + module.getName());\n\n    String messagePrefix = \"[\" + module.getName() + \"] \";\n\n    // create the jar file\n    File jarFile = new File(VfsUtilCore.urlToPath(getJarFileName(module)));\n    FileUtil.delete(jarFile);\n    if (!FileUtil.createParentDirs(jarFile)) {\n      context.addMessage(CompilerMessageCategory.ERROR, messagePrefix + \"Cannot create path to \" + jarFile.getPath(), null, 0, 0);\n      return;\n    }\n\n    OsmorcFacetConfiguration configuration = facet.getConfiguration();\n\n    VirtualFile moduleOutputUrl = getModuleOutputUrl(module);\n    if (moduleOutputUrl == null) {\n      String message = \"Unable to determine the compiler output path for module \" + module.getName();\n      context.addMessage(CompilerMessageCategory.WARNING, message, null, 0, 0);\n      return;\n    }\n    File moduleOutputDir = VfsUtilCore.virtualToIoFile(moduleOutputUrl);\n\n    List<String> classPathUrls = ContainerUtil.newSmartList(moduleOutputUrl.getUrl());\n\n    // build a bnd file or use a provided one.\n    File bndFile = getBndFile(module, facet, context, moduleOutputDir);\n    if (bndFile == null) {\n      // error already reported\n      return;\n    }\n\n    String outputPath = jarFile.getPath();\n    if (configuration.isUseBundlorFile()) {\n      // we create a temp jar file in this case.\n      outputPath += \".tmp.jar\";\n    }\n\n    progressIndicator.setText2(\"Running bnd to build the bundle\");\n    try {\n      BndWrapper.build(module, context, bndFile, classPathUrls, outputPath);\n    }\n    catch (Exception e) {\n      context.addMessage(CompilerMessageCategory.ERROR, messagePrefix + \"Unexpected error: \" + e.getMessage(), null, 0, 0);\n      return;\n    }\n\n    // if we use bundlor, let bundlor work on the generated file.\n    if (configuration.isUseBundlorFile()) {\n      progressIndicator.setText2(\"Running bundlor to calculate the manifest\");\n\n      File bundlorFile = findFileInModuleContentRoots(configuration.getBundlorFileLocation(), module);\n      if (bundlorFile == null || !bundlorFile.exists()) {\n        String message = String.format(\"The Bundlor file \\\"%s\\\" for module \\\"%s\\\" does not exist.\",\n                                       configuration.getBundlorFileLocation(), module.getName());\n        context.addMessage(CompilerMessageCategory.ERROR, messagePrefix + message, configuration.getBundlorFileLocation(), 0, 0);\n        return;\n      }\n\n      BundlorWrapper bw = new BundlorWrapper();\n      try {\n        if (!bw.wrapModule(context, outputPath, jarFile.getPath(), bundlorFile.getPath())) {\n          String message = \"Bundlifying the file \" + jarFile.getPath() + \" with Bundlor failed.\";\n          context.addMessage(CompilerMessageCategory.ERROR, messagePrefix + message, null, 0, 0);\n          return;\n        }\n      }\n      finally {\n        // delete the tmp jar\n        File tempJar = new File(outputPath);\n        if (tempJar.exists() && !tempJar.delete()) {\n          String message = \"Could not delete temporary file: \" + tempJar.getPath();\n          context.addMessage(CompilerMessageCategory.WARNING, messagePrefix + message, null, 0, 0);\n        }\n      }\n    }\n\n    if (!configuration.isUseBndFile() && !configuration.isUseBundlorFile()) {\n      // finally bundlify all the libs for this one\n      bundlifyLibraries(module, progressIndicator, context);\n    }\n  }","commit_id":"fc5560fd753b4cea59d3031867cef3428d156d08","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  protected static File findFileInModuleContentRoots(String file, Module module) {\n    ModuleRootManager manager = ModuleRootManager.getInstance(module);\n    for (VirtualFile root : manager.getContentRoots()) {\n      VirtualFile result = VfsUtil.findRelativeFile(file, root);\n      if (result != null) {\n        return new File(result.getPath());\n      }\n    }\n    return null;\n  }","id":33201,"modified_method":"@Nullable\n  protected static File findFileInModuleContentRoots(String file, Module module) {\n    ModuleRootManager manager = ModuleRootManager.getInstance(module);\n    for (VirtualFile root : manager.getContentRoots()) {\n      VirtualFile result = VfsUtilCore.findRelativeFile(file, root);\n      if (result != null) {\n        return new File(result.getPath());\n      }\n    }\n    return null;\n  }","commit_id":"fc5560fd753b4cea59d3031867cef3428d156d08","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n   * On Windows a file url must have at least 3 slashes at the beginning. 2 for the protocoll separation and one for\n   * the empty host (e.g.: file:///c:/bla instead of file://c:/bla). If there are only two the drive letter is\n   * interpreted as the host of the url which naturally doesn't exist. On Unix systems it's the same case, but since\n   * all paths start with a slash, a misinterpretation of part of the path as a host cannot occur.\n   *\n   * @param url The URL to fix\n   * @return The fixed URL\n   */\n  @NotNull\n  public static String fixFileURL(@NotNull String url) {\n    return url.startsWith(\"file:///\") ? url : url.replace(\"file://\", \"file:///\");\n  }","id":33202,"modified_method":"/**\n   * On Windows a file url must have at least 3 slashes at the beginning. 2 for the protocol separation and one for\n   * the empty host (e.g.: file:///c:/bla instead of file://c:/bla). If there are only two the drive letter is\n   * interpreted as the host of the url which naturally doesn't exist. On Unix systems it's the same case, but since\n   * all paths start with a slash, a misinterpretation of part of the path as a host cannot occur.\n   */\n  @NotNull\n  public static String fixFileURL(@NotNull String url) {\n    return url.startsWith(\"file:///\") ? url : url.replace(\"file://\", \"file:///\");\n  }","commit_id":"fc5560fd753b4cea59d3031867cef3428d156d08","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n   * Checks the configuration.\n   *\n   * @param compileScope the compilescope\n   * @return true if the configuration is valid, false otherwise\n   */\n  public boolean validateConfiguration(CompileScope compileScope) {\n    return true;\n  }","id":33203,"modified_method":"@Override\n  public boolean validateConfiguration(CompileScope compileScope) {\n    return true;\n  }","commit_id":"fc5560fd753b4cea59d3031867cef3428d156d08","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n   * Returns a virtual file representing the module's output path.\n   *\n   * @param module the module\n   * @return the module's output url or null if it could not be determined.\n   */\n  @Nullable\n  static VirtualFile getModuleOutputUrl(@NotNull Module module) {\n    final CompilerModuleExtension extension = CompilerModuleExtension.getInstance(module);\n    if (extension != null) {\n      return extension.getCompilerOutputPath();\n    }\n    return null;\n  }","id":33204,"modified_method":"/**\n   * Returns a virtual file representing the module's output path.\n   */\n  @Nullable\n  public static VirtualFile getModuleOutputUrl(@NotNull Module module) {\n    CompilerModuleExtension extension = CompilerModuleExtension.getInstance(module);\n    return extension != null ? extension.getCompilerOutputPath() : null;\n  }","commit_id":"fc5560fd753b4cea59d3031867cef3428d156d08","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n   * @return a description (probably not used anywhere)\n   */\n  @NotNull\n  public String getDescription() {\n    return \"bundle compile\";\n  }","id":33205,"modified_method":"@NotNull\n  @Override\n  public String getDescription() {\n    return \"bundle compile\";\n  }","commit_id":"fc5560fd753b4cea59d3031867cef3428d156d08","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n   * Bundlifies all libraries that belong to the given module and that are not bundles and that are not modules. The bundles are cached, so if\n   * the source library does not change, it will not be bundlified again.\n   *\n   * @param module         the module whose libraries are to be bundled.\n   * @param indicator      a progress indicator.\n   * @param compileContext\n   * @return a string array containing the urls of the bundlified libraries.\n   */\n  @NotNull\n  public static String[] bundlifyLibraries(@NotNull Module module, @NotNull ProgressIndicator indicator,\n                                           @NotNull CompileContext compileContext) {\n    ArrayList<String> result = new ArrayList<String>();\n\n    final String[] urls = OrderEnumerator.orderEntries(module).withoutSdk().withoutModuleSourceEntries().withoutDepModules()\n      .satisfying(NOT_FRAMEWORK_LIBRARY_CONDITION).recursively().exportedOnly().classes().getUrls();\n\n    BndWrapper wrapper = new BndWrapper();\n    for (String url : urls) {\n      url = convertJarUrlToFileUrl(url);\n\n      if (CachingBundleInfoProvider.canBeBundlified(url)) { // Fixes IDEA-56666\n        indicator.setText(\"Bundling non-OSGi libraries for module: \" + module.getName());\n        indicator.setText2(url);\n        // ok it is not a bundle, so we need to bundlify\n        final String outputPath = BndWrapper.getOutputPath(module, compileContext);\n        if (outputPath == null) {\n          // couldnt create output path, abort here..\n          break;\n        }\n        String bundledLocation = wrapper.wrapLibrary(module, compileContext, url, outputPath);\n        // if no bundle could (or should) be created, we exempt this library\n        if (bundledLocation != null) {\n          result.add(fixFileURL(bundledLocation));\n        }\n      }\n      else {\n        if (CachingBundleInfoProvider.isBundle(url)) { // Exclude non-bundles (IDEA-56666)\n          result.add(fixFileURL(url));\n        }\n      }\n    }\n    return ArrayUtil.toStringArray(result);\n  }","id":33206,"modified_method":"/**\n   * Bundlifies all libraries that belong to the given module and that are not bundles and that are not modules.\n   * The bundles are cached, so if * the source library does not change, it will not be bundlified again.\n   * Returns a string array containing the urls of the bundlified libraries.\n   */\n  @NotNull\n  public static String[] bundlifyLibraries(@NotNull Module module,\n                                           @NotNull ProgressIndicator indicator,\n                                           @NotNull CompileContext compileContext) {\n    String[] urls = OrderEnumerator.orderEntries(module).withoutSdk().withoutModuleSourceEntries().withoutDepModules()\n      .satisfying(NOT_FRAMEWORK_LIBRARY_CONDITION).recursively().exportedOnly().classes().getUrls();\n\n    File outputDir = null;\n    VirtualFile moduleOutputUrl = getModuleOutputUrl(module);\n    if (moduleOutputUrl != null) {\n      outputDir = BndWrapper.getOutputDir(VfsUtilCore.virtualToIoFile(moduleOutputUrl), compileContext);\n    }\n    if (outputDir == null) {\n      // couldn't create output path, abort here..\n      return ArrayUtil.EMPTY_STRING_ARRAY;\n    }\n\n    List<String> result = new ArrayList<String>();\n    BndWrapper wrapper = new BndWrapper();\n    for (String url : urls) {\n      url = convertJarUrlToFileUrl(url);\n      if (CachingBundleInfoProvider.canBeBundlified(url)) { // Fixes IDEA-56666\n        indicator.setText(\"Bundling non-OSGi libraries for module: \" + module.getName());\n        indicator.setText2(url);\n        // ok it is not a bundle, so we need to bundlify\n        String bundledLocation = wrapper.wrapLibrary(module, compileContext, url, outputDir);\n        // if no bundle could (or should) be created, we exempt this library\n        if (bundledLocation != null) {\n          result.add(fixFileURL(bundledLocation));\n        }\n      }\n      else if (CachingBundleInfoProvider.isBundle(url)) { // Exclude non-bundles (IDEA-56666)\n        result.add(fixFileURL(url));\n      }\n    }\n    return ArrayUtil.toStringArray(result);\n  }","commit_id":"fc5560fd753b4cea59d3031867cef3428d156d08","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n   * Builds the name of the jar file for a given module.\n   *\n   * @param module the module\n   * @return the name of the jar file that will be produced for this module by this compiler, or\n   *         null if the module does not have an Osmorc facet attached.\n   */\n  @Nullable\n  public static String getJarFileName(@NotNull final Module module) {\n    final OsmorcFacet facet = OsmorcFacet.getInstance(module);\n    if (facet != null) {\n      return facet.getConfiguration().getJarFileLocation();\n    }\n    return null;\n  }","id":33207,"modified_method":"/**\n   * Builds the name of the jar file for a given module.\n   */\n  @Nullable\n  public static String getJarFileName(@NotNull final Module module) {\n    final OsmorcFacet facet = OsmorcFacet.getInstance(module);\n    if (facet != null) {\n      return facet.getConfiguration().getJarFileLocation();\n    }\n    return null;\n  }","commit_id":"fc5560fd753b4cea59d3031867cef3428d156d08","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n   * Returns the manifest file for the given module if it exists\n   *\n   * @param module the module\n   * @return the manifest file or null if it doesnt exist\n   */\n  @Nullable\n  public static VirtualFile getManifestFile(@NotNull Module module) {\n    OsmorcFacet facet = OsmorcFacet.getInstance(module);\n    // FIXES Exception (http://ea.jetbrains.com/browser/ea_problems/17161)\n    if (facet == null) {\n      return null;\n    }\n    ModuleRootManager manager = ModuleRootManager.getInstance(module);\n    for (VirtualFile root : manager.getContentRoots()) {\n      VirtualFile result = VfsUtil.findRelativeFile(facet.getManifestLocation(), root);\n      // IDEADEV-40357\n//            if (result != null) {\n//                result = result.findChild(\"MANIFEST.MF\");\n//            }\n      if (result != null) {\n        return result;\n      }\n    }\n    return null;\n  }","id":33208,"modified_method":"/**\n   * Returns the manifest file for the given module if it exists\n   *\n   * @param module the module\n   * @return the manifest file or null if it doesnt exist\n   */\n  @Nullable\n  public static VirtualFile getManifestFile(@NotNull Module module) {\n    OsmorcFacet facet = OsmorcFacet.getInstance(module);\n    // FIXES Exception (http://ea.jetbrains.com/browser/ea_problems/17161)\n    if (facet == null) {\n      return null;\n    }\n    ModuleRootManager manager = ModuleRootManager.getInstance(module);\n    for (VirtualFile root : manager.getContentRoots()) {\n      VirtualFile result = VfsUtilCore.findRelativeFile(facet.getManifestLocation(), root);\n      if (result != null) {\n        return result;\n      }\n    }\n    return null;\n  }","commit_id":"fc5560fd753b4cea59d3031867cef3428d156d08","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n   * Processes a processing item (=module)\n   *\n   * @param compileContext  the compile context\n   * @param processingItems the list of processing items\n   * @return the list of processing items that remain for further processing (if any)\n   */\n  public ProcessingItem[] process(CompileContext compileContext,\n                                  ProcessingItem[] processingItems) {\n    try {\n      for (ProcessingItem processingItem : processingItems) {\n        Module module = ((BundleProcessingItem)processingItem).getModule();\n        buildBundle(module, compileContext.getProgressIndicator(), compileContext);\n      }\n    }\n    catch (IOException ioexception) {\n      logger.error(ioexception);\n    }\n    return processingItems;\n  }","id":33209,"modified_method":"/**\n   * Processes a processing item (module).\n   */\n  @Override\n  public ProcessingItem[] process(CompileContext compileContext, ProcessingItem[] processingItems) {\n    for (ProcessingItem processingItem : processingItems) {\n      BundleProcessingItem bundleProcessingItem = (BundleProcessingItem)processingItem;\n      buildBundle(bundleProcessingItem.getModule(), bundleProcessingItem.getFacet(), compileContext);\n    }\n    return processingItems;\n  }","commit_id":"fc5560fd753b4cea59d3031867cef3428d156d08","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n   * Converts a jar url gained from OrderEntry.getUrls or Library.getUrls into a file url that can be processed.\n   *\n   * @param url the url to be converted\n   * @return the converted url\n   */\n  @NotNull\n  public static String convertJarUrlToFileUrl(@NotNull String url) {\n    // urls end with !/ we cut that\n    // XXX: not sure if this is a hack\n    url = url.replaceAll(\"!.*\", \"\");\n    url = url.replace(\"jar://\", \"file://\");\n    return url;\n  }","id":33210,"modified_method":"/**\n   * Converts a jar url gained from OrderEntry.getUrls or Library.getUrls into a file url that can be processed.\n   */\n  @NotNull\n  public static String convertJarUrlToFileUrl(@NotNull String url) {\n    // urls end with !/ we cut that\n    // XXX: not sure if this is a hack\n    url = url.replaceAll(\"!.*\", \"\");\n    url = url.replace(\"jar://\", \"file://\");\n    return url;\n  }","commit_id":"fc5560fd753b4cea59d3031867cef3428d156d08","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public BundleProcessingItem(Module module) {\n    _module = module;\n  }","id":33211,"modified_method":"public BundleProcessingItem(@NotNull Module module, @NotNull OsmorcFacet facet) {\n    myModule = module;\n    myFacet = facet;\n  }","commit_id":"fc5560fd753b4cea59d3031867cef3428d156d08","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public Module getModule() {\n    return _module;\n  }","id":33212,"modified_method":"public Module getModule() {\n    return myModule;\n  }","commit_id":"fc5560fd753b4cea59d3031867cef3428d156d08","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public ValidityState getValidityState() {\n    return new BundleValidityState(_module);\n  }","id":33213,"modified_method":"@Override\n  public ValidityState getValidityState() {\n    return new BundleValidityState(myModule);\n  }","commit_id":"fc5560fd753b4cea59d3031867cef3428d156d08","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  public VirtualFile getFile() {\n    return _module.getModuleFile();\n  }","id":33214,"modified_method":"@NotNull\n  @Override\n  public VirtualFile getFile() {\n    //noinspection ConstantConditions\n    return myModule.getModuleFile();\n  }","commit_id":"fc5560fd753b4cea59d3031867cef3428d156d08","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public void progress(String s, Object... objects) {\n    myContext.addMessage(CompilerMessageCategory.INFORMATION, MessageFormat.format(myMessagePrefix + s, objects), mySourceFileName, 0, 0);\n  }","id":33215,"modified_method":"@Override\n  public void progress(String s, Object... objects) {\n    String message = MessageFormat.format(myMessagePrefix + s, objects);\n    myContext.addMessage(CompilerMessageCategory.INFORMATION, message, mySourceFileName, 0, 0);\n  }","commit_id":"fc5560fd753b4cea59d3031867cef3428d156d08","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public void error(String s, Object... objects) {\n    myContext.addMessage(CompilerMessageCategory.ERROR, MessageFormat.format(myMessagePrefix + s, objects), mySourceFileName, 0, 0);\n  }","id":33216,"modified_method":"@Override\n  public void error(String s, Object... objects) {\n    String message = MessageFormat.format(myMessagePrefix + s, objects);\n    myContext.addMessage(CompilerMessageCategory.ERROR, message, mySourceFileName, 0, 0);\n  }","commit_id":"fc5560fd753b4cea59d3031867cef3428d156d08","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public void error(String s, Throwable throwable, Object... objects) {\n    myContext.addMessage(CompilerMessageCategory.ERROR,\n                         MessageFormat.format(myMessagePrefix + s, objects) + \"(\" + throwable.getMessage() + \")\",\n                         mySourceFileName, 0, 0);\n  }","id":33217,"modified_method":"@Override\n  public void error(String s, Throwable throwable, Object... objects) {\n    String message = MessageFormat.format(myMessagePrefix + s, objects) + \"(\" + throwable.getMessage() + \")\";\n    myContext.addMessage(CompilerMessageCategory.ERROR, message, mySourceFileName, 0, 0);\n  }","commit_id":"fc5560fd753b4cea59d3031867cef3428d156d08","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public void warning(String s, Object... objects) {\n    myContext.addMessage(CompilerMessageCategory.WARNING, MessageFormat.format(myMessagePrefix + s, objects), mySourceFileName, 0, 0);\n  }","id":33218,"modified_method":"@Override\n  public void warning(String s, Object... objects) {\n    String message = MessageFormat.format(myMessagePrefix + s, objects);\n    myContext.addMessage(CompilerMessageCategory.WARNING, message, mySourceFileName, 0, 0);\n  }","commit_id":"fc5560fd753b4cea59d3031867cef3428d156d08","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public ReportingBuilder(CompileContext context, String sourceFileName, Module module) {\n    super();\n    myContext = context;\n    OsmorcFacet facet = OsmorcFacet.getInstance(module);\n    mySourceFileName = sourceFileName;\n    // link back to the original manifest if it's manually edited\n    if (facet != null) {\n      OsmorcFacetConfiguration configuration = facet.getConfiguration();\n      if (configuration.isManifestManuallyEdited()) {\n        BundleManager bundleManager = ServiceManager.getService(module.getProject(), BundleManager.class);\n        BundleManifest bundleManifest = bundleManager.getManifestByObject(module);\n        if (bundleManifest != null) {\n          PsiFile manifestFile = bundleManifest.getManifestFile();\n          VirtualFile virtualFile = manifestFile.getVirtualFile();\n          if (virtualFile != null) {\n            mySourceFileName = VfsUtil.pathToUrl(virtualFile.getPath());\n          }\n        }\n      }\n      else {\n        // try if module was imported from maven.\n        MavenProjectsManager projectsManager = MavenProjectsManager.getInstance(module.getProject());\n        MavenProject project = projectsManager.findProject(module);\n        if (project != null) {\n          MavenPlugin plugin = project.findPlugin(\"org.apache.felix\", \"maven-bundle-plugin\");\n          if (plugin != null) {\n            // ok it's imported from maven, link warnings/errors back to pom.xml\n            mySourceFileName = VfsUtil.pathToUrl(project.getPath());\n          }\n        }\n      }\n    }\n    myMessagePrefix = \"[\" + module.getName() + \"] \";\n  }","id":33219,"modified_method":"public ReportingBuilder(CompileContext context, String sourceFileName, Module module) {\n    myContext = context;\n\n    // link back to the original manifest if it's manually edited\n    OsmorcFacet facet = OsmorcFacet.getInstance(module);\n    if (facet != null) {\n      OsmorcFacetConfiguration configuration = facet.getConfiguration();\n      if (configuration.isManifestManuallyEdited()) {\n        BundleManager bundleManager = ServiceManager.getService(module.getProject(), BundleManager.class);\n        BundleManifest bundleManifest = bundleManager.getManifestByObject(module);\n        if (bundleManifest != null) {\n          PsiFile manifestFile = bundleManifest.getManifestFile();\n          VirtualFile virtualFile = manifestFile.getVirtualFile();\n          if (virtualFile != null) {\n            sourceFileName = VfsUtilCore.pathToUrl(virtualFile.getPath());\n          }\n        }\n      }\n      else {\n        // try if module was imported from maven.\n        MavenProjectsManager projectsManager = MavenProjectsManager.getInstance(module.getProject());\n        MavenProject project = projectsManager.findProject(module);\n        if (project != null) {\n          MavenPlugin plugin = project.findPlugin(\"org.apache.felix\", \"maven-bundle-plugin\");\n          if (plugin != null) {\n            // ok it's imported from maven, link warnings/errors back to pom.xml\n            sourceFileName = VfsUtilCore.pathToUrl(project.getPath());\n          }\n        }\n      }\n    }\n    mySourceFileName = sourceFileName;\n\n    myMessagePrefix = \"[\" + module.getName() + \"] \";\n  }","commit_id":"fc5560fd753b4cea59d3031867cef3428d156d08","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private String getAbsolutePath(String path) {\n    try {\n      return FileUtil.toSystemIndependentName(new File(VfsUtil.urlToPath(path)).getCanonicalPath());\n    }\n    catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }","id":33220,"modified_method":"private String getAbsolutePath(String path) {\n    path = VfsUtil.urlToPath(path);\n    path = PathUtil.getCanonicalPath(path);\n    return FileUtil.toSystemIndependentName(path);\n  }","commit_id":"a4365cedbee1485ba9a2c568bde02b14f951ea52","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void assertModuleOutput(String moduleName, String output, String testOutput) {\n    ModuleRootManager m = getRootManager(moduleName);\n    final CompilerModuleExtension compilerModuleExtension = CompilerModuleExtension.getInstance(m.getModule());\n    assertFalse(compilerModuleExtension.isCompilerOutputPathInherited());\n    assertEquals(output, getAbsolutePath(compilerModuleExtension.getCompilerOutputUrl()));\n    assertEquals(testOutput, getAbsolutePath(compilerModuleExtension.getCompilerOutputUrlForTests()));\n  }","id":33221,"modified_method":"protected void assertModuleOutput(String moduleName, String output, String testOutput) {\n    CompilerModuleExtension e = getCompilerExtension(moduleName);\n\n    assertFalse(e.isCompilerOutputPathInherited());\n    assertEquals(output, getAbsolutePath(e.getCompilerOutputUrl()));\n    assertEquals(testOutput, getAbsolutePath(e.getCompilerOutputUrlForTests()));\n  }","commit_id":"a4365cedbee1485ba9a2c568bde02b14f951ea52","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void assertProjectOutput(String module) {\n    ModuleRootManager m = getRootManager(module);\n    assertTrue(CompilerModuleExtension.getInstance(m.getModule()).isCompilerOutputPathInherited());\n  }","id":33222,"modified_method":"protected void assertProjectOutput(String module) {\n    assertTrue(getCompilerExtension(module).isCompilerOutputPathInherited());\n  }","commit_id":"a4365cedbee1485ba9a2c568bde02b14f951ea52","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void useModuleOutput(String production, String test) {\n    CompilerModuleExtensionImpl.getInstance(myRootModel.getModule()).inheritCompilerOutputPath(false);\n    CompilerModuleExtension.getInstance(myRootModel.getModule()).setCompilerOutputPath(toUrl(production).getUrl());\n    CompilerModuleExtension.getInstance(myRootModel.getModule()).setCompilerOutputPathForTests(toUrl(test).getUrl());\n  }","id":33223,"modified_method":"public void useModuleOutput(String production, String test) {\n    getCompilerExtension().inheritCompilerOutputPath(false);\n    getCompilerExtension().setCompilerOutputPath(toUrl(production).getUrl());\n    getCompilerExtension().setCompilerOutputPathForTests(toUrl(test).getUrl());\n  }","commit_id":"a4365cedbee1485ba9a2c568bde02b14f951ea52","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void useProjectOutput() {\n    CompilerModuleExtensionImpl.getInstance(myRootModel.getModule()).inheritCompilerOutputPath(true);\n  }","id":33224,"modified_method":"public void useProjectOutput() {\n    getCompilerExtension().inheritCompilerOutputPath(true);\n  }","commit_id":"a4365cedbee1485ba9a2c568bde02b14f951ea52","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static void getLibraryFiles(@NotNull ModuleBuildTarget target, @NotNull List<String> result) {\n        Set<JpsLibrary> libraries = JpsUtils.getAllDependencies(target).getLibraries();\n        for (JpsLibrary library : libraries) {\n            for (JpsLibraryRoot root : library.getRoots(JpsOrderRootType.COMPILED)) {\n                String path = JpsPathUtil.urlToPath(root.getUrl());\n                // TODO: Do we need to add to dependency all libraries?\n                if (LibraryUtils.isJsRuntimeLibrary(new File(path))) {\n                    result.add(path);\n                }\n            }\n        }\n    }","id":33225,"modified_method":"static void getLibraryFiles(@NotNull ModuleBuildTarget target, @NotNull List<String> result) {\n        Set<JpsLibrary> libraries = JpsUtils.getAllDependencies(target).getLibraries();\n        for (JpsLibrary library : libraries) {\n            for (JpsLibraryRoot root : library.getRoots(JpsOrderRootType.COMPILED)) {\n                result.add(JpsPathUtil.urlToPath(root.getUrl()));\n            }\n        }\n    }","commit_id":"f5d957445ffd86edbd5509932c18a58760bcf8ee","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void meetInto(ResourceValueFrame fact, Edge edge, ResourceValueFrame result) throws DataflowAnalysisException {\n\t\tBasicBlock source = edge.getSource();\n\t\tBasicBlock dest = edge.getDest();\n\n\t\tif (dest.isExceptionHandler()) {\n\t\t\tResourceValueFrame tmpFact = null;\n\n\t\t\t// Clear stack, push value for exception\n\t\t\tif (fact.isValid()) {\n\t\t\t\ttmpFact = createFact();\n\t\t\t\ttmpFact.copyFrom(fact);\n\t\t\t\ttmpFact.clearStack();\n\t\t\t\ttmpFact.pushValue(ResourceValue.notInstance());\n\t\t\t}\n\n\t\t\t// Special case: if the instruction that closes the resource\n\t\t\t// throws an exception, we consider the resource to be successfully\n\t\t\t// closed anyway.\n\t\t\tInstructionHandle exceptionThrower = source.getExceptionThrower();\n\t\t\tassert exceptionThrower != null; // is it possible to reach an exception handler by a non-exception edge?\n\t\t\tif (resourceTracker.isResourceClose(dest, exceptionThrower, methodGen.getConstantPool(), resource)) {\n\t\t\t\tif (tmpFact == null) {\n\t\t\t\t\ttmpFact = createFact();\n\t\t\t\t\ttmpFact.copyFrom(fact);\n\t\t\t\t}\n\t\t\t\ttmpFact.setStatus(ResourceValueFrame.CLOSED);\n\t\t\t}\n\n\t\t\tif (tmpFact != null)\n\t\t\t\tfact = tmpFact;\n\t\t}\n\n\t\tresult.mergeWith(fact);\n\t}","id":33226,"modified_method":"public void meetInto(ResourceValueFrame fact, Edge edge, ResourceValueFrame result) throws DataflowAnalysisException {\n\t\tBasicBlock source = edge.getSource();\n\t\tBasicBlock dest = edge.getDest();\n\n\t\tResourceValueFrame tmpFact = null;\n\n\t\tif (dest.isExceptionHandler()) {\n\t\t\t// Clear stack, push value for exception\n\t\t\tif (fact.isValid()) {\n\t\t\t\ttmpFact = modifyFrame(fact, tmpFact);\n\t\t\t\ttmpFact.clearStack();\n\t\t\t\ttmpFact.pushValue(ResourceValue.notInstance());\n\t\t\t}\n\n\t\t\t// Special case: if the instruction that closes the resource\n\t\t\t// throws an exception, we consider the resource to be successfully\n\t\t\t// closed anyway.\n\t\t\tInstructionHandle exceptionThrower = source.getExceptionThrower();\n\t\t\tassert exceptionThrower != null; // is it possible to reach an exception handler by a non-exception edge?\n\t\t\tif (resourceTracker.isResourceClose(dest, exceptionThrower, methodGen.getConstantPool(), resource)) {\n\t\t\t\ttmpFact = modifyFrame(fact, tmpFact);\n\t\t\t\ttmpFact.setStatus(ResourceValueFrame.CLOSED);\n\t\t\t}\n\t\t}\n\n\t\t// Make the resource nonexistent if it is compared against null\n\t\tint edgeType = edge.getType();\n\t\tif (edgeType == IFCMP_EDGE || edgeType == FALL_THROUGH_EDGE) {\n\t\t\tInstructionHandle lastInSourceHandle = source.getLastInstruction();\n\t\t\tif (lastInSourceHandle != null) {\n\t\t\t\tInstruction lastInSource = lastInSourceHandle.getInstruction();\n\t\t\t\tif (lastInSource instanceof IFNULL || lastInSource instanceof IFNONNULL) {\n\t\t\t\t\t// Get the frame at the if statement\n\t\t\t\t\tResourceValueFrame frameAtIf = getFactAtLocation(new Location(lastInSourceHandle, source));\n\t\t\t\t\tResourceValue topValue = frameAtIf.getValue(frameAtIf.getNumSlots() - 1);\n\n\t\t\t\t\tif (topValue.isInstance()) {\n\t\t\t\t\t\tif ((lastInSource instanceof IFNULL && edgeType == IFCMP_EDGE) ||\n\t\t\t\t\t\t\t(lastInSource instanceof IFNONNULL && edgeType == FALL_THROUGH_EDGE)) {\n\t\t\t\t\t\t\t//System.out.println(\"**** making resource nonexistent on edge \"+edge.getId());\n\t\t\t\t\t\t\ttmpFact = modifyFrame(fact, tmpFact);\n\t\t\t\t\t\t\ttmpFact.setStatus(ResourceValueFrame.NONEXISTENT);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (tmpFact != null)\n\t\t\tfact = tmpFact;\n\n\t\tresult.mergeWith(fact);\n\t}","commit_id":"dc4bd023c326f1e8a62473551573e12db3145550","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void meetInto(IsNullValueFrame fact, Edge edge, IsNullValueFrame result)\n\t\tthrows DataflowAnalysisException {\n\n\t\tif (fact.isValid()) {\n\t\t\tfinal int numSlots = fact.getNumSlots();\n\n\t\t\tif (!NO_SPLIT_DOWNGRADE_NSP) {\n\t\t\t\t// Downgrade NSP to DNR on non-exception control splits\n\t\t\t\tif (!edge.isExceptionEdge() && numNonExceptionSuccessorMap[edge.getSource().getId()] > 1) {\n\t\t\t\t\tIsNullValueFrame tmpFact = createFact();\n\t\t\t\t\ttmpFact.copyFrom(fact);\n\t\t\t\t\tfor (int i = 0; i < numSlots; ++i) {\n\t\t\t\t\t\tIsNullValue value = tmpFact.getValue(i);\n\t\t\t\t\t\tif (value.equals(IsNullValue.nullOnSomePathValue()))\n\t\t\t\t\t\t\ttmpFact.setValue(i, IsNullValue.doNotReportValue());\n\t\t\t\t\t}\n\t\t\t\t\tfact = tmpFact;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal BasicBlock destBlock = edge.getDest();\n\n\t\t\tif (destBlock.isExceptionHandler()) {\n\t\t\t\t// Exception handler - clear stack and push a non-null value\n\t\t\t\t// to represent the exception.\n\t\t\t\tIsNullValueFrame tmpFrame = createFact();\n\t\t\t\ttmpFrame.copyFrom(fact);\n\t\t\t\ttmpFrame.clearStack();\n\n\t\t\t\t// Mark all values as having occurred on an exception path\n\t\t\t\tfor (int i = 0; i < tmpFrame.getNumSlots(); ++i)\n\t\t\t\t\ttmpFrame.setValue(i, tmpFrame.getValue(i).toExceptionValue());\n\n\t\t\t\t// Push the exception value\n\t\t\t\ttmpFrame.pushValue(IsNullValue.nonNullValue());\n\t\t\t\tfact = tmpFrame;\n\t\t\t} else {\n\t\t\t\t// Determine if the edge conveys any information about the\n\t\t\t\t// null/non-null status of operands in the incoming frame.\n\t\n\t\t\t\tint nullInfo = getNullInfoFromEdge(edge);\n\n\t\t\t\tswitch (nullInfo) {\n\t\t\t\tcase TOS_NULL:\n\t\t\t\tcase TOS_NON_NULL:\n\t\t\t\tcase NEXT_TO_TOS_NULL:\n\t\t\t\tcase NEXT_TO_TOS_NON_NULL:\n\t\t\t\t\t{\n\t\t\t\t\t\t// What we know here is that the value that was\n\t\t\t\t\t\t// just popped off the stack is either null or non-null.\n\t\t\t\t\t\t// We can use this info to increase the precision of\n\t\t\t\t\t\t// any stack slots containing the same value.\n\n\t\t\t\t\t\t// Get ValueNumberFrame and IsNullValueFrame at location\n\t\t\t\t\t\t// just before the IF instruction in the source block.\n\t\t\t\t\t\tBasicBlock sourceBlock = edge.getSource();\n\t\t\t\t\t\tLocation atIf = new Location(sourceBlock.getLastInstruction(), sourceBlock);\n\t\t\t\t\t\tIsNullValueFrame prevIsNullValueFrame = getFactAtLocation(atIf);\n\t\t\t\t\t\tValueNumberFrame prevVnaFrame = vnaDataflow.getFactAtLocation(atIf);\n\n\t\t\t\t\t\tint prevNumSlots = prevIsNullValueFrame.getNumSlots();\n\t\t\t\t\t\tassert prevNumSlots == prevVnaFrame.getNumSlots();\n\n\t\t\t\t\t\t// Figure out which slot contains the value we have information about\n\t\t\t\t\t\tint slotToReplace = (nullInfo == TOS_NULL || nullInfo == TOS_NON_NULL)\n\t\t\t\t\t\t\t? prevNumSlots - 1\n\t\t\t\t\t\t\t: prevNumSlots - 2;\n\n\t\t\t\t\t\t// Get the value we have information about, as well as the\n\t\t\t\t\t\t// condition the IF statement is controlled by.\n\t\t\t\t\t\tValueNumber replaceMe = prevVnaFrame.getValue(slotToReplace);\n\t\t\t\t\t\tIsNullValue origIsNullValue = prevIsNullValueFrame.getValue(slotToReplace);\n\n\t\t\t\t\t\t// Update all slots containing the value which was used\n\t\t\t\t\t\t// in the IF statement.\n\t\t\t\t\t\tfact = replaceValues(fact, replaceMe, prevVnaFrame,\n\t\t\t\t\t\t\t(nullInfo == TOS_NULL || nullInfo == NEXT_TO_TOS_NULL)\n\t\t\t\t\t\t\t\t? IsNullValue.flowSensitiveNullValue(origIsNullValue)\n\t\t\t\t\t\t\t\t: IsNullValue.flowSensitiveNonNullValue(origIsNullValue));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase REF_OPERAND_NON_NULL:\n\t\t\t\t\t{\n\t\t\t\t\t\tValueNumberFrame vnaFrame = vnaDataflow.getStartFact(destBlock);\n\t\t\t\t\t\tif (vnaFrame == null)\n\t\t\t\t\t\t\tthrow new IllegalStateException(\"no vna frame at block entry?\");\n\n\t\t\t\t\t\t// For all of the instructions which have a null-checked\n\t\t\t\t\t\t// reference operand, it is pushed onto the stack before\n\t\t\t\t\t\t// all of the other operands to the instruction.\n\t\t\t\t\t\tInstruction firstInDest = edge.getDest().getFirstInstruction().getInstruction();\n\t\t\t\t\t\tint numSlotsConsumed = firstInDest.consumeStack(methodGen.getConstantPool());\n\t\t\t\t\t\tif (numSlotsConsumed == Constants.UNPREDICTABLE)\n\t\t\t\t\t\t\tthrow new DataflowAnalysisException(\"Unpredictable stack consumption for \" + firstInDest);\n\t\t\t\t\t\tValueNumber replaceMe = vnaFrame.getValue(numSlots - numSlotsConsumed);\n\n\t\t\t\t\t\tfact = replaceValues(fact, replaceMe, vnaFrame, IsNullValue.nonNullValue());\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase NO_INFO:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tassert false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Normal dataflow merge\n\t\tresult.mergeWith(fact);\n\t}","id":33227,"modified_method":"public void meetInto(IsNullValueFrame fact, Edge edge, IsNullValueFrame result)\n\t\tthrows DataflowAnalysisException {\n\n\t\tif (fact.isValid()) {\n\t\t\tIsNullValueFrame tmpFact = null;\n\n\t\t\tfinal int numSlots = fact.getNumSlots();\n\n\t\t\tif (!NO_SPLIT_DOWNGRADE_NSP) {\n\t\t\t\t// Downgrade NSP to DNR on non-exception control splits\n\t\t\t\tif (!edge.isExceptionEdge() && numNonExceptionSuccessorMap[edge.getSource().getId()] > 1) {\n\t\t\t\t\ttmpFact = modifyFrame(fact, tmpFact);\n\n\t\t\t\t\tfor (int i = 0; i < numSlots; ++i) {\n\t\t\t\t\t\tIsNullValue value = tmpFact.getValue(i);\n\t\t\t\t\t\tif (value.equals(IsNullValue.nullOnSomePathValue()))\n\t\t\t\t\t\t\ttmpFact.setValue(i, IsNullValue.doNotReportValue());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal BasicBlock destBlock = edge.getDest();\n\n\t\t\tif (destBlock.isExceptionHandler()) {\n\t\t\t\t// Exception handler - clear stack and push a non-null value\n\t\t\t\t// to represent the exception.\n\t\t\t\tIsNullValueFrame tmpFrame = createFact();\n\t\t\t\ttmpFrame.copyFrom(fact);\n\t\t\t\ttmpFrame.clearStack();\n\n\t\t\t\t// Mark all values as having occurred on an exception path\n\t\t\t\tfor (int i = 0; i < tmpFrame.getNumSlots(); ++i)\n\t\t\t\t\ttmpFrame.setValue(i, tmpFrame.getValue(i).toExceptionValue());\n\n\t\t\t\t// Push the exception value\n\t\t\t\ttmpFrame.pushValue(IsNullValue.nonNullValue());\n\t\t\t\tfact = tmpFrame;\n\t\t\t} else {\n\t\t\t\t// Determine if the edge conveys any information about the\n\t\t\t\t// null/non-null status of operands in the incoming frame.\n\n\t\t\t\tfinal BasicBlock sourceBlock = edge.getSource();\n\t\t\t\tfinal InstructionHandle lastInSourceHandle = sourceBlock.getLastInstruction();\n\t\t\t\tfinal int edgeType = edge.getType();\n\n\t\t\t\t// Handle IFNULL, IFNONNULL, IF_ACMPEQ, and IF_ACMPNE to\n\t\t\t\t// produce flow-sensitive information about whether or not the\n\t\t\t\t// compared value or values were null.\n\t\t\t\tif (lastInSourceHandle != null) {\n\t\t\t\t\tshort lastInSourceOpcode = lastInSourceHandle.getInstruction().getOpcode();\n\t\t\t\t\tif (nullComparisonInstructionSet.get(lastInSourceOpcode)) {\n\t\t\t\t\t\t// Get ValueNumberFrame and IsNullValueFrame at location\n\t\t\t\t\t\t// just before the IF instruction in the source block.\n\t\t\t\t\t\tfinal Location atIf = new Location(lastInSourceHandle, sourceBlock);\n\t\t\t\t\t\tfinal IsNullValueFrame prevIsNullValueFrame = getFactAtLocation(atIf);\n\t\t\t\t\t\tfinal ValueNumberFrame prevVnaFrame = vnaDataflow.getFactAtLocation(atIf);\n\t\t\t\t\t\tfinal int prevNumSlots = prevIsNullValueFrame.getNumSlots();\n\t\t\t\t\t\tfinal IsNullValue conditionValue = prevIsNullValueFrame.getTopValue();\n\n\t\t\t\t\t\tswitch (lastInSourceOpcode) {\n\t\t\t\t\t\tcase Constants.IFNULL:\n\t\t\t\t\t\tcase Constants.IFNONNULL:\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttmpFact = replaceValues(fact, tmpFact, prevVnaFrame.getTopValue(), prevVnaFrame,\n\t\t\t\t\t\t\t\t\tifNullComparison(lastInSourceOpcode, edgeType, conditionValue));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase Constants.IF_ACMPEQ:\n\t\t\t\t\t\tcase Constants.IF_ACMPNE:\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tIsNullValue tos = prevIsNullValueFrame.getValue(prevNumSlots - 1);\n\t\t\t\t\t\t\t\tIsNullValue nextToTOS = prevIsNullValueFrame.getValue(prevNumSlots - 2);\n\n\t\t\t\t\t\t\t\tif (tos.isDefinitelyNull()) {\n\t\t\t\t\t\t\t\t\t// TOS is null, so next-to-TOS is flow-sensitively null\n\t\t\t\t\t\t\t\t\ttmpFact = replaceValues(fact, tmpFact, prevVnaFrame.getValue(prevNumSlots-2), prevVnaFrame,\n\t\t\t\t\t\t\t\t\t\tifNullComparison(lastInSourceOpcode, edgeType, conditionValue));\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (nextToTOS.isDefinitelyNull()) {\n\t\t\t\t\t\t\t\t\t// Next-to-TOS is null, so TOS is flow-sensitively null\n\t\t\t\t\t\t\t\t\ttmpFact = replaceValues(fact, tmpFact, prevVnaFrame.getTopValue(), prevVnaFrame,\n\t\t\t\t\t\t\t\t\t\tifNullComparison(lastInSourceOpcode, edgeType, conditionValue));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If this is a fall-through edge from a null check,\n\t\t\t\t// then we know the value checked is not null.\n\t\t\t\tif (sourceBlock.isNullCheck() && edgeType == FALL_THROUGH_EDGE) {\n\t\t\t\t\tValueNumberFrame vnaFrame = vnaDataflow.getStartFact(destBlock);\n\t\t\t\t\tif (vnaFrame == null)\n\t\t\t\t\t\tthrow new IllegalStateException(\"no vna frame at block entry?\");\n\n\t\t\t\t\t// For all of the instructions which have a null-checked\n\t\t\t\t\t// reference operand, it is pushed onto the stack before\n\t\t\t\t\t// all of the other operands to the instruction.\n\t\t\t\t\tInstruction firstInDest = edge.getDest().getFirstInstruction().getInstruction();\n\t\t\t\t\tint numSlotsConsumed = firstInDest.consumeStack(methodGen.getConstantPool());\n\t\t\t\t\tif (numSlotsConsumed == Constants.UNPREDICTABLE)\n\t\t\t\t\t\tthrow new DataflowAnalysisException(\"Unpredictable stack consumption for \" + firstInDest);\n\t\t\t\t\tValueNumber replaceMe = vnaFrame.getValue(numSlots - numSlotsConsumed);\n\n\t\t\t\t\ttmpFact = replaceValues(fact, tmpFact, replaceMe, vnaFrame, IsNullValue.nonNullValue());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tmpFact != null)\n\t\t\t\tfact = tmpFact;\n\t\t}\n\n\t\t// Normal dataflow merge\n\t\tresult.mergeWith(fact);\n\t}","commit_id":"faf0cad29f6c92a323ede3b2081f84e0c25df98c","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private IsNullValueFrame replaceValues(IsNullValueFrame frame, ValueNumber replaceMe, ValueNumberFrame vnaFrame,\n\t\tIsNullValue replacementValue) {\n\n\t\t// The VNA frame may have more slots than the IsNullValueFrame\n\t\t// if it was produced by an IF comparison (whose operand or operands\n\t\t// are subsequently popped off the stack).\n\n\t\tfinal int numSlots = Math.min(frame.getNumSlots(), vnaFrame.getNumSlots());\n\n\t\tfinal IsNullValueFrame result = createFact();\n\t\tresult.copyFrom(frame);\n\n\t\tfor (int i = 0; i < numSlots; ++i) {\n\t\t\tif (vnaFrame.getValue(i).equals(replaceMe))\n\t\t\t\tresult.setValue(i, replacementValue);\n\t\t}\n\n\t\treturn result;\n\n\t}","id":33228,"modified_method":"private IsNullValueFrame replaceValues(IsNullValueFrame origFrame, IsNullValueFrame frame,\n\t\tValueNumber replaceMe, ValueNumberFrame vnaFrame, IsNullValue replacementValue) {\n\n\t\t// If required, make a copy of the frame\n\t\tframe = modifyFrame(origFrame, frame);\n\n\t\t// The VNA frame may have more slots than the IsNullValueFrame\n\t\t// if it was produced by an IF comparison (whose operand or operands\n\t\t// are subsequently popped off the stack).\n\n\t\tfinal int numSlots = Math.min(frame.getNumSlots(), vnaFrame.getNumSlots());\n\n\t\tfor (int i = 0; i < numSlots; ++i) {\n\t\t\tif (vnaFrame.getValue(i).equals(replaceMe))\n\t\t\t\tframe.setValue(i, replacementValue);\n\t\t}\n\n\t\treturn frame;\n\n\t}","commit_id":"faf0cad29f6c92a323ede3b2081f84e0c25df98c","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private Map calculateImportedPackagesUnresolved(IModule module, Map candidatesMap)\n    {\n//System.out.println(\"calculateImportedPackagesUnresolved(\"+module+\")\");\n        Map pkgMap = new HashMap();\n\n        // Get the candidate set list to get all candidates for\n        // all of the module's requirements.\n        List candSetList = (List) candidatesMap.get(module);\n\n        // Loop through all candidate sets that represent import dependencies\n        // for the module and add the current candidate's package source to the\n        // imported package map.\n        for (int candSetIdx = 0; (candSetList != null) && (candSetIdx < candSetList.size()); candSetIdx++)\n        {\n            CandidateSet cs = (CandidateSet) candSetList.get(candSetIdx);\n            PackageSource ps = cs.m_candidates[cs.m_idx];\n\n            if (ps.m_capability.getNamespace().equals(ICapability.PACKAGE_NAMESPACE))\n            {\n                String pkgName = (String)\n                    ps.m_capability.getProperties().get(ICapability.PACKAGE_PROPERTY);\n\n                ResolvedPackage rp = new ResolvedPackage(pkgName);\n                rp.m_sourceSet.add(ps);\n                pkgMap.put(rp.m_name, rp);\n            }\n        }\n\n        return pkgMap;\n    }","id":33229,"modified_method":"private Map calculateImportedPackagesUnresolved(IModule targetModule, Map candidatesMap)\n    {\n//System.out.println(\"calculateImportedPackagesUnresolved(\"+targetModule+\")\");\n        Map pkgMap = new HashMap();\n\n        // Get the candidate set list to get all candidates for\n        // all of the target module's requirements.\n        List candSetList = (List) candidatesMap.get(targetModule);\n\n        // Loop through all candidate sets that represent import dependencies\n        // for the target module and add the current candidate's package source\n        // to the imported package map.\n        for (int candSetIdx = 0; (candSetList != null) && (candSetIdx < candSetList.size()); candSetIdx++)\n        {\n            CandidateSet cs = (CandidateSet) candSetList.get(candSetIdx);\n            PackageSource ps = cs.m_candidates[cs.m_idx];\n\n            if (ps.m_capability.getNamespace().equals(ICapability.PACKAGE_NAMESPACE))\n            {\n                String pkgName = (String)\n                    ps.m_capability.getProperties().get(ICapability.PACKAGE_PROPERTY);\n\n                ResolvedPackage rp = new ResolvedPackage(pkgName);\n                rp.m_sourceList.add(ps);\n                pkgMap.put(rp.m_name, rp);\n            }\n        }\n\n        return pkgMap;\n    }","commit_id":"3ec1284279a07f0d3fa67b6a4213f4cf5cae473a","url":"https://github.com/apache/felix"},{"original_method":"private Map calculateExportedPackages(IModule module)\n    {\n//System.out.println(\"calculateExportedPackages(\"+module+\")\");\n        Map pkgMap = new HashMap();\n\n        // Loop through all capabilities that represent exported packages\n        // and add them to the exported package map.\n        ICapability[] caps = module.getDefinition().getCapabilities();\n        for (int capIdx = 0; (caps != null) && (capIdx < caps.length); capIdx++)\n        {\n            if (caps[capIdx].getNamespace().equals(ICapability.PACKAGE_NAMESPACE))\n            {\n                String pkgName = (String)\n                    caps[capIdx].getProperties().get(ICapability.PACKAGE_PROPERTY);\n                ResolvedPackage rp = (ResolvedPackage) pkgMap.get(pkgName);\n                rp = (rp == null) ? new ResolvedPackage(pkgName) : rp;\n                rp.m_sourceSet.add(new PackageSource(module, caps[capIdx]));\n                pkgMap.put(rp.m_name, rp);\n            }\n        }\n\n        return pkgMap;\n    }","id":33230,"modified_method":"private Map calculateExportedPackages(IModule targetModule)\n    {\n//System.out.println(\"calculateExportedPackages(\"+targetModule+\")\");\n        Map pkgMap = new HashMap();\n\n        // Loop through the target module's capabilities that represent\n        // exported packages and add them to the exported package map.\n        ICapability[] caps = targetModule.getDefinition().getCapabilities();\n        for (int capIdx = 0; (caps != null) && (capIdx < caps.length); capIdx++)\n        {\n            if (caps[capIdx].getNamespace().equals(ICapability.PACKAGE_NAMESPACE))\n            {\n                String pkgName = (String)\n                    caps[capIdx].getProperties().get(ICapability.PACKAGE_PROPERTY);\n                ResolvedPackage rp = (ResolvedPackage) pkgMap.get(pkgName);\n                rp = (rp == null) ? new ResolvedPackage(pkgName) : rp;\n                rp.m_sourceList.add(new PackageSource(targetModule, caps[capIdx]));\n                pkgMap.put(rp.m_name, rp);\n            }\n        }\n\n        return pkgMap;\n    }","commit_id":"3ec1284279a07f0d3fa67b6a4213f4cf5cae473a","url":"https://github.com/apache/felix"},{"original_method":"public StringBuffer toString(String padding, StringBuffer sb)\n        {\n            sb.append(padding);\n            sb.append(m_name);\n            sb.append(\" from [\");\n            for (Iterator i = m_sourceSet.iterator(); i.hasNext(); )\n            {\n                PackageSource ps = (PackageSource) i.next();\n                sb.append(ps.m_module);\n                if (i.hasNext())\n                {\n                    sb.append(\", \");\n                }\n            }\n            sb.append(\"]\");\n            return sb;\n        }","id":33231,"modified_method":"public StringBuffer toString(String padding, StringBuffer sb)\n        {\n            sb.append(padding);\n            sb.append(m_name);\n            sb.append(\" from [\");\n            for (int i = 0; i < m_sourceList.size(); i++)\n            {\n                PackageSource ps = (PackageSource) m_sourceList.get(i);\n                sb.append(ps.m_module);\n                if ((i + 1) < m_sourceList.size())\n                {\n                    sb.append(\", \");\n                }\n            }\n            sb.append(\"]\");\n            return sb;\n        }","commit_id":"3ec1284279a07f0d3fa67b6a4213f4cf5cae473a","url":"https://github.com/apache/felix"},{"original_method":"private Map calculateExportedAndReexportedPackagesUnresolved(PackageSource psTarget, Map candidatesMap, Map pkgMap, Map cycleMap)\n    {\n//System.out.println(\"calculateExportedAndReexportedPackagesUnresolved(\"+psTarget.m_module+\")\");\n        if (cycleMap.get(psTarget.m_module) != null)\n        {\n            return pkgMap;\n        }\n\n        cycleMap.put(psTarget.m_module, psTarget.m_module);\n\n        // Loop through all export package capabilities and merge them\n        // into the package map adding the original target as a source.\n        ICapability[] candCaps = psTarget.m_module.getDefinition().getCapabilities();\n        for (int capIdx = 0; (candCaps != null) && (capIdx < candCaps.length); capIdx++)\n        {\n            if (candCaps[capIdx].getNamespace().equals(ICapability.PACKAGE_NAMESPACE))\n            {\n                String pkgName = (String)\n                    candCaps[capIdx].getProperties().get(ICapability.PACKAGE_PROPERTY);\n                ResolvedPackage rp = (ResolvedPackage) pkgMap.get(pkgName);\n                rp = (rp == null) ? new ResolvedPackage(pkgName) : rp;\n                rp.m_sourceSet.add(new PackageSource(psTarget.m_module, candCaps[capIdx]));\n                pkgMap.put(rp.m_name, rp);\n            }\n        }\n\n        // Loop through all current candidates for module dependencies and\n        // merge re-exported packages.\n        Map allRequiredMap = new HashMap();\n        List candSetList = (List) candidatesMap.get(psTarget.m_module);\n        for (int candSetIdx = 0; candSetIdx < candSetList.size(); candSetIdx++)\n        {\n            CandidateSet cs = (CandidateSet) candSetList.get(candSetIdx);\n            PackageSource ps = cs.m_candidates[cs.m_idx];\n\n            // If the candidate is resolving a module dependency, then\n            // flatten the required packages if they are re-exported.\n            if (ps.m_capability.getNamespace().equals(ICapability.MODULE_NAMESPACE))\n            {\n                // Determine if required packages are re-exported.\n                boolean reexport = false;\n                R4Directive[] dirs =  ((Requirement) cs.m_requirement).getDirectives();\n                for (int dirIdx = 0;\n                    !reexport && (dirs != null) && (dirIdx < dirs.length); dirIdx++)\n                {\n                    if (dirs[dirIdx].getName().equals(Constants.VISIBILITY_DIRECTIVE)\n                        && dirs[dirIdx].getValue().equals(Constants.VISIBILITY_REEXPORT))\n                    {\n                        reexport = true;\n                    }\n                }\n\n                // Recursively calculate the required packages for the\n                // current candidate.\n                Map requiredMap = calculateExportedAndReexportedPackages(ps, candidatesMap, new HashMap(), cycleMap);\n\n                // Merge the candidate's required packages with the existing packages.\n                for (Iterator reqIter = requiredMap.entrySet().iterator(); reqIter.hasNext(); )\n                {\n                    Map.Entry entry = (Map.Entry) reqIter.next();\n                    String pkgName = (String) entry.getKey();\n\n                    // Merge the current set of required packages into\n                    // the overall complete set of required packages.\n                    // We must keep track of all possible re-exported\n                    // packages, because despite the fact that some packages\n                    // will be required \"privately\" and some will be required\n                    // \"reexport\", any re-exported package sources will\n                    // ultimately need to be combined with privately required\n                    // package sources, if the required packages overlap.\n                    // This is one of the bad things about require-bundle\n                    // behavior, it does not necessarily obey the visibility\n                    // rules declared in the dependency.\n                    ResolvedPackage rp = (ResolvedPackage) allRequiredMap.get(pkgName);\n                    if (rp != null)\n                    {\n                        // Create the union of all package sources.\n                        ResolvedPackage rpReq = (ResolvedPackage) entry.getValue();\n                        rp.m_sourceSet.addAll(rpReq.m_sourceSet);                       \n                    }\n                    else\n                    {\n                        allRequiredMap.put(entry.getKey(), entry.getValue());\n                    }\n\n                    // Now merge any re-exported packages into the module's\n                    // overall package map, since these re-exported packages\n                    // will become part of the module's export signature.\n                    rp = (ResolvedPackage) pkgMap.get(entry.getKey());\n                    if ((rp == null) && reexport)\n                    {\n                        pkgMap.put(entry.getKey(), entry.getValue());\n                    }\n                }\n            }\n        }\n\n        // Using the package map that represents the module's complete\n        // export signature (i.e., it includes exported and re-exported\n        // packages), merge in the package sources for any required\n        // packages that overlap the set of exported/re-exported packages.\n        for (Iterator reqIter = allRequiredMap.entrySet().iterator(); reqIter.hasNext(); )\n        {\n            Map.Entry entry = (Map.Entry) reqIter.next();\n            ResolvedPackage rp = (ResolvedPackage) pkgMap.get(entry.getKey());\n            if (rp != null)\n            {\n                // Create the union of all package sources.\n                ResolvedPackage rpReq = (ResolvedPackage) entry.getValue();\n                rp.m_sourceSet.addAll(rpReq.m_sourceSet);                       \n            }\n        }\n\n        return pkgMap;\n    }","id":33232,"modified_method":"private Map calculateExportedAndReexportedPackagesUnresolved(\n        PackageSource psTarget, Map candidatesMap, Map cycleMap)\n    {\n//System.out.println(\"calculateExportedAndReexportedPackagesUnresolved(\"+psTarget.m_module+\")\");\n        Map pkgMap = new HashMap();\n\n        if (cycleMap.get(psTarget.m_module) != null)\n        {\n            return pkgMap;\n        }\n\n        cycleMap.put(psTarget.m_module, psTarget.m_module);\n\n        // Loop through all current candidates for target module's dependencies\n        // and calculate the module's complete set of required packages (and\n        // their associated package sources) and the complete set of required\n        // packages to be re-exported.\n        Map allRequiredMap = new HashMap();\n        Map reexportedPkgMap = new HashMap();\n        List candSetList = (List) candidatesMap.get(psTarget.m_module);\n        for (int candSetIdx = 0; candSetIdx < candSetList.size(); candSetIdx++)\n        {\n            CandidateSet cs = (CandidateSet) candSetList.get(candSetIdx);\n            PackageSource ps = cs.m_candidates[cs.m_idx];\n\n            // If the candidate is resolving a module dependency, then\n            // flatten the required packages if they are re-exported.\n            if (ps.m_capability.getNamespace().equals(ICapability.MODULE_NAMESPACE))\n            {\n                // Determine if required packages are re-exported.\n                boolean reexport = false;\n                R4Directive[] dirs =  ((Requirement) cs.m_requirement).getDirectives();\n                for (int dirIdx = 0;\n                    !reexport && (dirs != null) && (dirIdx < dirs.length); dirIdx++)\n                {\n                    if (dirs[dirIdx].getName().equals(Constants.VISIBILITY_DIRECTIVE)\n                        && dirs[dirIdx].getValue().equals(Constants.VISIBILITY_REEXPORT))\n                    {\n                        reexport = true;\n                    }\n                }\n\n                // Recursively calculate the required packages for the\n                // current candidate.\n                Map requiredMap = calculateExportedAndReexportedPackages(ps, candidatesMap, cycleMap);\n\n                // Merge the candidate's exported and re-exported packages\n                // into the complete set of required packages.\n                for (Iterator reqIter = requiredMap.entrySet().iterator(); reqIter.hasNext(); )\n                {\n                    Map.Entry entry = (Map.Entry) reqIter.next();\n                    String pkgName = (String) entry.getKey();\n\n                    // Merge the current set of required packages into\n                    // the overall complete set of required packages.\n                    // We calculate all the required packages, because\n                    // despite the fact that some packages will be required\n                    // \"privately\" and some will be required \"reexport\", any\n                    // re-exported package sources will ultimately need to\n                    // be combined with privately required package sources,\n                    // if the required packages overlap. This is one of the\n                    // bad things about require-bundle behavior, it does not\n                    // necessarily obey the visibility rules declared in the\n                    // dependency.\n                    ResolvedPackage rp = (ResolvedPackage) allRequiredMap.get(pkgName);\n                    if (rp != null)\n                    {\n                        // Create the union of all package sources.\n                        ResolvedPackage rpReq = (ResolvedPackage) entry.getValue();\n                        rp.merge(rpReq);\n                    }\n                    else\n                    {\n                        // Add package to required map.\n                        allRequiredMap.put(pkgName, entry.getValue());\n                    }\n\n                    // Keep track of all required packages to be re-exported.\n                    // All re-exported packages will need to be merged into the\n                    // target module's package map and become part of its overall\n                    // export signature.\n                    if (reexport)\n                    {\n                        reexportedPkgMap.put(pkgName, pkgName);\n                    }\n                }\n            }\n        }\n\n        // For the target module we have now calculated its entire set\n        // of required packages and their associated package sources in\n        // allRequiredMap and have calculated all packages to be re-exported\n        // in reexportedPkgMap. Add all re-exported required packages to the\n        // target module's package map since they will be part of its export\n        // signature.\n        for (Iterator iter = reexportedPkgMap.entrySet().iterator(); iter.hasNext(); )\n        {\n            String pkgName = (String) ((Map.Entry) iter.next()).getKey();\n            pkgMap.put(pkgName, allRequiredMap.get(pkgName));\n        }\n\n        // Now loop through the target module's export package capabilities and\n        // add the target module as a package source for any exported packages.\n        ICapability[] candCaps = psTarget.m_module.getDefinition().getCapabilities();\n        for (int capIdx = 0; (candCaps != null) && (capIdx < candCaps.length); capIdx++)\n        {\n            if (candCaps[capIdx].getNamespace().equals(ICapability.PACKAGE_NAMESPACE))\n            {\n                String pkgName = (String)\n                    candCaps[capIdx].getProperties().get(ICapability.PACKAGE_PROPERTY);\n                ResolvedPackage rp = (ResolvedPackage) pkgMap.get(pkgName);\n                rp = (rp == null) ? new ResolvedPackage(pkgName) : rp;\n                rp.m_sourceList.add(new PackageSource(psTarget.m_module, candCaps[capIdx]));\n                pkgMap.put(rp.m_name, rp);\n            }\n        }\n\n        return pkgMap;\n    }","commit_id":"3ec1284279a07f0d3fa67b6a4213f4cf5cae473a","url":"https://github.com/apache/felix"},{"original_method":"public boolean isSubset(ResolvedPackage rp)\n        {\n            if (rp.m_sourceSet.size() > m_sourceSet.size())\n            {\n                return false;\n            }\n            else if (!rp.m_name.equals(m_name))\n            {\n                return false;\n            }\n\n            // Determine if the target set of source modules is a subset.\n            return m_sourceSet.containsAll(rp.m_sourceSet);\n        }","id":33233,"modified_method":"public boolean isSubset(ResolvedPackage rp)\n        {\n            if (m_sourceList.size() > rp.m_sourceList.size())\n            {\n                return false;\n            }\n            else if (!m_name.equals(rp.m_name))\n            {\n                return false;\n            }\n\n            // Determine if the target set of source modules is a subset.\n            return rp.m_sourceList.containsAll(m_sourceList);\n        }","commit_id":"3ec1284279a07f0d3fa67b6a4213f4cf5cae473a","url":"https://github.com/apache/felix"},{"original_method":"private Map calculateUsesConstraints(PackageSource ps, Map moduleMap, Map usesMap, Map cycleMap, Map candidatesMap)\n    {\n//System.out.println(\"calculateUsesConstraints2(\"+ps.m_module+\")\");\n        // If we are in a cycle, then return for now.\n        if (cycleMap.get(ps) != null)\n        {\n            return usesMap;\n        }\n\n        // Record the package source in the cycle map.\n        cycleMap.put(ps, ps);\n\n        // Get all packages accessible from the module of the\n        // current package source.\n        Map pkgMap = getModulePackages(moduleMap, ps.m_module, candidatesMap);\n\n        // Get capability (i.e., package) of the package source.\n        Capability cap = (Capability) ps.m_capability;\n\n        // Loop through all \"used\" packages of the capability.\n        for (int i = 0; i < cap.getUses().length; i++)\n        {\n            // The package source module should have a resolved package\n            // for the \"used\" package in its set of accessible packages,\n            // since it claims to use it, so get the associated resolved\n            // package.\n            ResolvedPackage rp = (ResolvedPackage) pkgMap.get(cap.getUses()[i]);\n\n            // In general, the resolved package should not be null,\n            // but check for safety.\n            if (rp != null)\n            {\n                // First, iterate through all package sources for the resolved\n                // package associated with the current \"used\" package and calculate\n                // and combine the \"uses\" constraints for each package source.\n                for (Iterator srcIter = rp.m_sourceSet.iterator(); srcIter.hasNext(); )\n                {\n                    usesMap = calculateUsesConstraints(\n                        (PackageSource) srcIter.next(),\n                        moduleMap, usesMap, cycleMap, candidatesMap);\n                }\n\n                // Then, add the resolved package for the current \"used\" package\n                // as a \"uses\" constraint too; add it to an existing constraint\n                // list if the current \"used\" package is already in the uses map.\n                List constraintList = (List) usesMap.get(cap.getUses()[i]);\n                if (constraintList == null)\n                {\n                    constraintList = new ArrayList();\n                }\n                constraintList.add(rp);\n                usesMap.put(cap.getUses()[i], constraintList);\n            }\n        }\n\n        return usesMap;\n    }","id":33234,"modified_method":"private Map calculateUsesConstraints(\n        PackageSource psTarget, Map moduleMap, Map usesMap,\n        Map cycleMap, Map candidatesMap)\n    {\n//System.out.println(\"calculateUsesConstraints2(\"+psTarget.m_module+\")\");\n        // If we are in a cycle, then return for now.\n        if (cycleMap.get(psTarget) != null)\n        {\n            return usesMap;\n        }\n\n        // Record the target package source in the cycle map.\n        cycleMap.put(psTarget, psTarget);\n\n        // Get all packages accessible from the module of the\n        // target package source.\n        Map pkgMap = getModulePackages(moduleMap, psTarget.m_module, candidatesMap);\n\n        // Get capability (i.e., package) of the target package source.\n        Capability cap = (Capability) psTarget.m_capability;\n\n        // Loop through all \"used\" packages of the capability.\n        for (int i = 0; i < cap.getUses().length; i++)\n        {\n            // The target package source module should have a resolved package\n            // for the \"used\" package in its set of accessible packages,\n            // since it claims to use it, so get the associated resolved\n            // package.\n            ResolvedPackage rp = (ResolvedPackage) pkgMap.get(cap.getUses()[i]);\n\n            // In general, the resolved package should not be null,\n            // but check for safety.\n            if (rp != null)\n            {\n                // First, iterate through all package sources for the resolved\n                // package associated with the current \"used\" package and calculate\n                // and combine the \"uses\" constraints for each package source.\n                for (int srcIdx = 0; srcIdx < rp.m_sourceList.size(); srcIdx++)\n                {\n                    usesMap = calculateUsesConstraints(\n                        (PackageSource) rp.m_sourceList.get(srcIdx),\n                        moduleMap, usesMap, cycleMap, candidatesMap);\n                }\n\n                // Then, add the resolved package for the current \"used\" package\n                // as a \"uses\" constraint too; add it to an existing constraint\n                // list if the current \"used\" package is already in the uses map.\n                List constraintList = (List) usesMap.get(cap.getUses()[i]);\n                if (constraintList == null)\n                {\n                    constraintList = new ArrayList();\n                }\n                constraintList.add(rp);\n                usesMap.put(cap.getUses()[i], constraintList);\n            }\n        }\n\n        return usesMap;\n    }","commit_id":"3ec1284279a07f0d3fa67b6a4213f4cf5cae473a","url":"https://github.com/apache/felix"},{"original_method":"public Object clone()\n        {\n            ResolvedPackage rp = new ResolvedPackage(m_name);\n            rp.m_sourceSet.addAll(m_sourceSet);\n            return rp;\n        }","id":33235,"modified_method":"public Object clone()\n        {\n            ResolvedPackage rp = new ResolvedPackage(m_name);\n            rp.m_sourceList.addAll(m_sourceList);\n            return rp;\n        }","commit_id":"3ec1284279a07f0d3fa67b6a4213f4cf5cae473a","url":"https://github.com/apache/felix"},{"original_method":"private Map calculateRequiredPackagesResolved(IModule module)\n    {\n//System.out.println(\"calculateRequiredPackagesResolved(\"+module+\")\");\n        Map pkgMap = new HashMap();\n\n        IWire[] wires = module.getWires();\n        for (int i = 0; (wires != null) && (i < wires.length); i++)\n        {\n            // If the candidate is a module dependency, then flatten it to packages.\n            if (wires[i].getCapability().getNamespace().equals(ICapability.MODULE_NAMESPACE))\n            {\n                // We can call calculateExportedAndReexportedPackagesResolved()\n                // directly, since we know all dependencies have to be resolved\n                // because this module itself is resolved.\n                Map cycleMap = new HashMap();\n                cycleMap.put(module, module);\n                Map requireMap = calculateExportedAndReexportedPackagesResolved(\n                    wires[i].getExporter(), new HashMap(), cycleMap);\n\n                // Merge sources.\n                for (Iterator reqIter = requireMap.entrySet().iterator(); reqIter.hasNext(); )\n                {\n                    Map.Entry entry = (Map.Entry) reqIter.next();\n                    ResolvedPackage rp = (ResolvedPackage) pkgMap.get(entry.getKey());\n                    if (rp != null)\n                    {\n                        ResolvedPackage rpReq = (ResolvedPackage) entry.getValue();\n                        rp.m_sourceSet.addAll(rpReq.m_sourceSet);\n                    }\n                    else\n                    {\n                        pkgMap.put(entry.getKey(), entry.getValue());\n                    }\n                }\n            }\n        }\n\n        return pkgMap;\n    }","id":33236,"modified_method":"private Map calculateRequiredPackagesResolved(IModule targetModule)\n    {\n//System.out.println(\"calculateRequiredPackagesResolved(\"+targetModule+\")\");\n        Map pkgMap = new HashMap();\n\n        // Loop through target module's wires for module dependencies\n        // and merge re-exported packages.\n        IWire[] wires = targetModule.getWires();\n        for (int i = 0; (wires != null) && (i < wires.length); i++)\n        {\n            // If the wire is a module dependency, then flatten it to packages.\n            if (wires[i].getCapability().getNamespace().equals(ICapability.MODULE_NAMESPACE))\n            {\n                // Calculate transitively required packages.\n                // We can call calculateExportedAndReexportedPackagesResolved()\n                // directly, since we know all dependencies have to be resolved\n                // because this module itself is resolved.\n                Map cycleMap = new HashMap();\n                cycleMap.put(targetModule, targetModule);\n                Map requireMap =\n                    calculateExportedAndReexportedPackagesResolved(\n                        wires[i].getExporter(), cycleMap);\n\n                // Take the flattened required package map for the current\n                // module dependency and merge it into the existing map\n                // of required packages.\n                for (Iterator reqIter = requireMap.entrySet().iterator(); reqIter.hasNext(); )\n                {\n                    Map.Entry entry = (Map.Entry) reqIter.next();\n                    ResolvedPackage rp = (ResolvedPackage) pkgMap.get(entry.getKey());\n                    if (rp != null)\n                    {\n                        // Merge required packages, avoiding duplicate\n                        // package sources and maintaining ordering.\n                        ResolvedPackage rpReq = (ResolvedPackage) entry.getValue();\n                        rp.merge(rpReq);\n                    }\n                    else\n                    {\n                        pkgMap.put(entry.getKey(), entry.getValue());\n                    }\n                }\n            }\n        }\n\n        return pkgMap;\n    }","commit_id":"3ec1284279a07f0d3fa67b6a4213f4cf5cae473a","url":"https://github.com/apache/felix"},{"original_method":"private Map calculateImportedPackages(IModule module, Map candidatesMap)\n    {\n        return (candidatesMap.get(module) == null)\n            ? calculateImportedPackagesResolved(module)\n            : calculateImportedPackagesUnresolved(module, candidatesMap);\n    }","id":33237,"modified_method":"private Map calculateImportedPackages(IModule targetModule, Map candidatesMap)\n    {\n        return (candidatesMap.get(targetModule) == null)\n            ? calculateImportedPackagesResolved(targetModule)\n            : calculateImportedPackagesUnresolved(targetModule, candidatesMap);\n    }","commit_id":"3ec1284279a07f0d3fa67b6a4213f4cf5cae473a","url":"https://github.com/apache/felix"},{"original_method":"private Map calculateRequiredPackages(IModule module, Map candidatesMap)\n    {\n        return (candidatesMap.get(module) == null)\n            ? calculateRequiredPackagesResolved(module)\n            : calculateRequiredPackagesUnresolved(module, candidatesMap);      \n    }","id":33238,"modified_method":"private Map calculateRequiredPackages(IModule targetModule, Map candidatesMap)\n    {\n        return (candidatesMap.get(targetModule) == null)\n            ? calculateRequiredPackagesResolved(targetModule)\n            : calculateRequiredPackagesUnresolved(targetModule, candidatesMap);      \n    }","commit_id":"3ec1284279a07f0d3fa67b6a4213f4cf5cae473a","url":"https://github.com/apache/felix"},{"original_method":"private Map calculateCandidateRequiredPackages(IModule module, PackageSource psTarget, Map candidatesMap)\n    {\n//System.out.println(\"calculateCandidateRequiredPackages(\"+module+\")\");\n        Map cycleMap = new HashMap();\n        cycleMap.put(module, module);\n        return calculateExportedAndReexportedPackages(psTarget, candidatesMap, new HashMap(), cycleMap);\n    }","id":33239,"modified_method":"private Map calculateCandidateRequiredPackages(IModule module, PackageSource psTarget, Map candidatesMap)\n    {\n//System.out.println(\"calculateCandidateRequiredPackages(\"+module+\")\");\n        Map cycleMap = new HashMap();\n        cycleMap.put(module, module);\n        return calculateExportedAndReexportedPackages(psTarget, candidatesMap, cycleMap);\n    }","commit_id":"3ec1284279a07f0d3fa67b6a4213f4cf5cae473a","url":"https://github.com/apache/felix"},{"original_method":"private Map calculateModulePackages(IModule module, Map candidatesMap)\n    {\n//System.out.println(\"calculateModulePackages(\"+module+\")\");\n        Map importedPackages = calculateImportedPackages(module, candidatesMap);\n        Map exportedPackages = calculateExportedPackages(module);\n        Map requiredPackages = calculateRequiredPackages(module, candidatesMap);\n\n        // Merge exported packages into required packages. If a package is both\n        // exported and required, then append the exported source to the end of\n        // the require package sources; otherwise just add it to the package map.\n        for (Iterator i = exportedPackages.entrySet().iterator(); i.hasNext(); )\n        {\n            Map.Entry entry = (Map.Entry) i.next();\n            ResolvedPackage rpReq = (ResolvedPackage) requiredPackages.get(entry.getKey());\n            if (rpReq != null)\n            {\n                ResolvedPackage rpExport = (ResolvedPackage) entry.getValue();\n                rpReq.m_sourceSet.addAll(rpExport.m_sourceSet);\n            }\n            else\n            {\n                requiredPackages.put(entry.getKey(), entry.getValue());\n            }\n        }\n\n        // Merge imported packages into required packages. Imports overwrite\n        // any required and/or exported package.\n        for (Iterator i = importedPackages.entrySet().iterator(); i.hasNext(); )\n        {\n            Map.Entry entry = (Map.Entry) i.next();\n            requiredPackages.put(entry.getKey(), entry.getValue());\n        }\n\n        return requiredPackages;\n    }","id":33240,"modified_method":"/**\n     * <p>\n     * Calculates the module's set of accessible packages and their\n     * assocaited package sources. This method uses the current candidates\n     * for resolving the module's requirements from the candidate map\n     * to calculate the module's accessible packages.\n     * <\/p>\n     * @param module the module whose package map is to be calculated.\n     * @param candidatesMap the map of potential candidates for resolving\n     *        the module's requirements.\n     * @return a map of the packages accessible to the specified module where\n     *         the key of the map is the package name and the value of the map\n     *         is a ResolvedPackage.\n    **/\n    private Map calculateModulePackages(IModule module, Map candidatesMap)\n    {\n//System.out.println(\"calculateModulePackages(\"+module+\")\");\n        Map importedPackages = calculateImportedPackages(module, candidatesMap);\n        Map exportedPackages = calculateExportedPackages(module);\n        Map requiredPackages = calculateRequiredPackages(module, candidatesMap);\n\n        // Merge exported packages into required packages. If a package is both\n        // exported and required, then append the exported source to the end of\n        // the require package sources; otherwise just add it to the package map.\n        for (Iterator i = exportedPackages.entrySet().iterator(); i.hasNext(); )\n        {\n            Map.Entry entry = (Map.Entry) i.next();\n            ResolvedPackage rpReq = (ResolvedPackage) requiredPackages.get(entry.getKey());\n            if (rpReq != null)\n            {\n                // Merge exported and required packages, avoiding duplicate\n                // package sources and maintaining ordering.\n                ResolvedPackage rpExport = (ResolvedPackage) entry.getValue();\n                rpReq.merge(rpExport);\n            }\n            else\n            {\n                requiredPackages.put(entry.getKey(), entry.getValue());\n            }\n        }\n\n        // Merge imported packages into required packages. Imports overwrite\n        // any required and/or exported package.\n        for (Iterator i = importedPackages.entrySet().iterator(); i.hasNext(); )\n        {\n            Map.Entry entry = (Map.Entry) i.next();\n            requiredPackages.put(entry.getKey(), entry.getValue());\n        }\n\n        return requiredPackages;\n    }","commit_id":"3ec1284279a07f0d3fa67b6a4213f4cf5cae473a","url":"https://github.com/apache/felix"},{"original_method":"private Map calculateRequiredPackagesUnresolved(IModule module, Map candidatesMap)\n    {\n//System.out.println(\"calculateRequiredPackagesUnresolved(\"+module+\")\");\n        Map pkgMap = new HashMap();\n\n        // Loop through all current candidates for module dependencies and\n        // merge re-exported packages.\n        List candSetList = (List) candidatesMap.get(module);\n        for (int candSetIdx = 0; (candSetList != null) && (candSetIdx < candSetList.size()); candSetIdx++)\n        {\n            CandidateSet cs = (CandidateSet) candSetList.get(candSetIdx);\n            PackageSource ps = cs.m_candidates[cs.m_idx];\n\n            // If the capabaility is a module dependency, then flatten it to packages.\n            if (ps.m_capability.getNamespace().equals(ICapability.MODULE_NAMESPACE))\n            {\n                // Calculate transitively required packages.\n                Map cycleMap = new HashMap();\n                cycleMap.put(module, module);\n                Map requireMap = calculateExportedAndReexportedPackages(\n                    ps, candidatesMap, new HashMap(), cycleMap);\n\n                // Loop through all export package capabilities and merge them\n                // into the package map adding the original target as a source.\n                for (Iterator reqIter = requireMap.entrySet().iterator(); reqIter.hasNext(); )\n                {\n                    Map.Entry entry = (Map.Entry) reqIter.next();\n                    ResolvedPackage rp = (ResolvedPackage) pkgMap.get(entry.getKey());\n                    if (rp != null)\n                    {\n                        ResolvedPackage rpReq = (ResolvedPackage) entry.getValue();\n                        rp.m_sourceSet.addAll(rpReq.m_sourceSet);\n                    }\n                    else\n                    {\n                        pkgMap.put(entry.getKey(), entry.getValue());\n                    }\n                }\n            }\n        }\n\n        return pkgMap;\n    }","id":33241,"modified_method":"private Map calculateRequiredPackagesUnresolved(IModule targetModule, Map candidatesMap)\n    {\n//System.out.println(\"calculateRequiredPackagesUnresolved(\"+targetModule+\")\");\n        Map pkgMap = new HashMap();\n\n        // Loop through target module's candidate list for candidates\n        // for its module dependencies and merge re-exported packages.\n        List candSetList = (List) candidatesMap.get(targetModule);\n        for (int candSetIdx = 0; (candSetList != null) && (candSetIdx < candSetList.size()); candSetIdx++)\n        {\n            CandidateSet cs = (CandidateSet) candSetList.get(candSetIdx);\n            PackageSource ps = cs.m_candidates[cs.m_idx];\n\n            // If the capabaility is a module dependency, then flatten it to packages.\n            if (ps.m_capability.getNamespace().equals(ICapability.MODULE_NAMESPACE))\n            {\n                // Calculate transitively required packages.\n                Map cycleMap = new HashMap();\n                cycleMap.put(targetModule, targetModule);\n                Map requireMap =\n                    calculateExportedAndReexportedPackages(\n                        ps, candidatesMap, cycleMap);\n\n                // Take the flattened required package map for the current\n                // module dependency and merge it into the existing map\n                // of required packages.\n                for (Iterator reqIter = requireMap.entrySet().iterator(); reqIter.hasNext(); )\n                {\n                    Map.Entry entry = (Map.Entry) reqIter.next();\n                    ResolvedPackage rp = (ResolvedPackage) pkgMap.get(entry.getKey());\n                    if (rp != null)\n                    {\n                        // Merge required packages, avoiding duplicate\n                        // package sources and maintaining ordering.\n                        ResolvedPackage rpReq = (ResolvedPackage) entry.getValue();\n                        rp.merge(rpReq);\n                    }\n                    else\n                    {\n                        pkgMap.put(entry.getKey(), entry.getValue());\n                    }\n                }\n            }\n        }\n\n        return pkgMap;\n    }","commit_id":"3ec1284279a07f0d3fa67b6a4213f4cf5cae473a","url":"https://github.com/apache/felix"},{"original_method":"private boolean isClassSpaceConsistent(\n        IModule rootModule, Map moduleMap, Map cycleMap, Map candidatesMap)\n    {\n//System.out.println(\"isClassSpaceConsistent(\"+rootModule+\")\");\n        // If we are in a cycle, then assume true for now.\n        if (cycleMap.get(rootModule) != null)\n        {\n            return true;\n        }\n\n        // Record the root module in the cycle map.\n        cycleMap.put(rootModule, rootModule);\n\n        // Get the package map for the root module, which is a\n        // map of all packages accessible to the module and their\n        // associated package sources.\n        Map pkgMap = getModulePackages(moduleMap, rootModule, candidatesMap);\n\n        // Loop through all of the module's accessible packages and verify\n        // that all package sources are consistent.\n        for (Iterator iter = pkgMap.entrySet().iterator(); iter.hasNext(); )\n        {\n            Map.Entry entry = (Map.Entry) iter.next();\n            // Get the resolved package, which contains the set of all\n            // package sources for the given package.\n            ResolvedPackage rp = (ResolvedPackage) entry.getValue();\n            // Loop through each package source and test if it is consistent.\n            for (Iterator srcIter = rp.m_sourceSet.iterator(); srcIter.hasNext(); )\n            {\n                PackageSource ps = (PackageSource) srcIter.next();\n                if (!isClassSpaceConsistent(ps.m_module, moduleMap, cycleMap, candidatesMap))\n                {\n                    return false;\n                }\n            }\n        }\n\n        // Now we need to calculate the \"uses\" constraints of every package\n        // accessible to the module based on the current candidates.\n        Map usesMap = calculateUsesConstraints(rootModule, moduleMap, candidatesMap);\n\n        // Verify that none of the implied \"uses\" constraints in the uses map\n        // conflict with anything in the root module's package map.\n        for (Iterator iter = usesMap.entrySet().iterator(); iter.hasNext(); )\n        {\n            Map.Entry entry = (Map.Entry) iter.next();\n\n            // For the given \"used\" package, get that package from the\n            // root module's package map, if present.\n            ResolvedPackage rp = (ResolvedPackage) pkgMap.get(entry.getKey());\n\n            // If the \"used\" package is also visible to the root module,\n            // make sure there is no conflicts in the implied \"uses\"\n            // constraints.\n            if (rp != null)\n            {\n                // Clone the resolve package so we can modify it.\n                rp = (ResolvedPackage) rp.clone();\n\n                // Loop through all implied \"uses\" constraints for the current\n                // \"used\" package and verify that all package sources are\n                // compatible with the package source of the root module's\n                // package map.\n                List constraintList = (List) entry.getValue();\n                for (int constIdx = 0; constIdx < constraintList.size(); constIdx++)\n                {\n                    // Get a specific \"uses\" constraint for the current \"used\"\n                    // package.\n                    ResolvedPackage rpUses = (ResolvedPackage) constraintList.get(constIdx);\n                    // Determine if the implied \"uses\" constraint is compatible with\n                    // the root module's package sources for the given \"used\" package.\n                    // They are compatible if one is the subset of the other.\n                    if (rp.isSubset(rpUses) || rpUses.isSubset(rp))\n                    {\n                        // In case they are compatible, then create the union of\n                        // the root module's package sources and those of the\n                        // \"uses\" constraint for continued testing of the\n                        // remaining \"uses\" constraints.\n                        rp.m_sourceSet.addAll(rpUses.m_sourceSet);\n                    }\n                    else\n                    {\n                        m_logger.log(\n                            Logger.LOG_DEBUG,\n                            \"Constraint violation for \" + rootModule\n                            + \" detected; module can see \"\n                            + rp + \" and \" + rpUses);\n                        return false;\n                    }\n                }\n            }\n        }\n\n        return true;\n    }","id":33242,"modified_method":"private boolean isClassSpaceConsistent(\n        IModule targetModule, Map moduleMap, Map cycleMap, Map candidatesMap)\n    {\n//System.out.println(\"isClassSpaceConsistent(\"+targetModule+\")\");\n        // If we are in a cycle, then assume true for now.\n        if (cycleMap.get(targetModule) != null)\n        {\n            return true;\n        }\n\n        // Record the target module in the cycle map.\n        cycleMap.put(targetModule, targetModule);\n\n        // Get the package map for the target module, which is a\n        // map of all packages accessible to the module and their\n        // associated package sources.\n        Map pkgMap = getModulePackages(moduleMap, targetModule, candidatesMap);\n\n        // Loop through all of the target module's accessible packages and\n        // verify that all package sources are consistent.\n        for (Iterator iter = pkgMap.entrySet().iterator(); iter.hasNext(); )\n        {\n            Map.Entry entry = (Map.Entry) iter.next();\n            // Get the resolved package, which contains the set of all\n            // package sources for the given package.\n            ResolvedPackage rp = (ResolvedPackage) entry.getValue();\n            // Loop through each package source and test if it is consistent.\n            for (int srcIdx = 0; srcIdx < rp.m_sourceList.size(); srcIdx++)\n            {\n                PackageSource ps = (PackageSource) rp.m_sourceList.get(srcIdx);\n                if (!isClassSpaceConsistent(ps.m_module, moduleMap, cycleMap, candidatesMap))\n                {\n                    return false;\n                }\n            }\n        }\n\n        // Now we need to calculate the \"uses\" constraints of every package\n        // accessible to the target module based on the current candidates.\n        Map usesMap = calculateUsesConstraints(targetModule, moduleMap, candidatesMap);\n\n        // Verify that none of the implied \"uses\" constraints in the uses map\n        // conflict with anything in the target module's package map.\n        for (Iterator iter = usesMap.entrySet().iterator(); iter.hasNext(); )\n        {\n            Map.Entry entry = (Map.Entry) iter.next();\n\n            // For the given \"used\" package, get that package from the\n            // target module's package map, if present.\n            ResolvedPackage rp = (ResolvedPackage) pkgMap.get(entry.getKey());\n\n            // If the \"used\" package is also visible to the target module,\n            // make sure there is no conflicts in the implied \"uses\"\n            // constraints.\n            if (rp != null)\n            {\n                // Clone the resolve package so we can modify it.\n                rp = (ResolvedPackage) rp.clone();\n\n                // Loop through all implied \"uses\" constraints for the current\n                // \"used\" package and verify that all package sources are\n                // compatible with the package source of the root module's\n                // package map.\n                List constraintList = (List) entry.getValue();\n                for (int constIdx = 0; constIdx < constraintList.size(); constIdx++)\n                {\n                    // Get a specific \"uses\" constraint for the current \"used\"\n                    // package.\n                    ResolvedPackage rpUses = (ResolvedPackage) constraintList.get(constIdx);\n                    // Determine if the implied \"uses\" constraint is compatible with\n                    // the target module's package sources for the given \"used\"\n                    // package. They are compatible if one is the subset of the other.\n                    // Retain the union of the two sets if they are compatible.\n                    if (rpUses.isSubset(rp))\n                    {\n                        // Do nothing because we already have the superset.\n                    }\n                    else if (rp.isSubset(rpUses))\n                    {\n                        // Keep the superset, i.e., the union.\n                        rp.m_sourceList.clear();\n                        rp.m_sourceList.addAll(rpUses.m_sourceList);\n                    }\n                    else\n                    {\n                        m_logger.log(\n                            Logger.LOG_DEBUG,\n                            \"Constraint violation for \" + targetModule\n                            + \" detected; module can see \"\n                            + rp + \" and \" + rpUses);\n                        return false;\n                    }\n                }\n            }\n        }\n\n        return true;\n    }","commit_id":"3ec1284279a07f0d3fa67b6a4213f4cf5cae473a","url":"https://github.com/apache/felix"},{"original_method":"private Map calculateUsesConstraints(IModule rootModule, Map moduleMap, Map candidatesMap)\n    {\n//System.out.println(\"calculateUsesConstraints(\"+rootModule+\")\");\n        // Map to store calculated uses constraints. This maps a\n        // package name to a list of resolved packages, where each\n        // resolved package represents a constraint on anyone\n        // importing the given package name. This map is returned\n        // by this method.\n        Map usesMap = new HashMap();\n\n        // Re-usable map to detect cycles.\n        Map cycleMap = new HashMap();\n\n        // Get all packages accessible by the root module.\n        Map pkgMap = getModulePackages(moduleMap, rootModule, candidatesMap);\n\n        // Each package accessible from the root module is potentially\n        // comprised of one or more modules, called package sources. The\n        // \"uses\" constraints implied by all package sources must be\n        // calculated and combined to determine the complete set of implied\n        // \"uses\" constraints for each package accessible by the root module.\n        for (Iterator iter = pkgMap.entrySet().iterator(); iter.hasNext(); )\n        {\n            Map.Entry entry = (Map.Entry) iter.next();\n            ResolvedPackage rp = (ResolvedPackage) entry.getValue();\n            for (Iterator srcIter = rp.m_sourceSet.iterator(); srcIter.hasNext(); )\n            {\n                usesMap = calculateUsesConstraints(\n                    (PackageSource) srcIter.next(),\n                    moduleMap, usesMap, cycleMap, candidatesMap);\n            }\n        }\n        return usesMap;\n    }","id":33243,"modified_method":"private Map calculateUsesConstraints(\n        IModule targetModule, Map moduleMap, Map candidatesMap)\n    {\n//System.out.println(\"calculateUsesConstraints(\"+targetModule+\")\");\n        // Map to store calculated uses constraints. This maps a\n        // package name to a list of resolved packages, where each\n        // resolved package represents a constraint on anyone\n        // importing the given package name. This map is returned\n        // by this method.\n        Map usesMap = new HashMap();\n\n        // Re-usable map to detect cycles.\n        Map cycleMap = new HashMap();\n\n        // Get all packages accessible by the target module.\n        Map pkgMap = getModulePackages(moduleMap, targetModule, candidatesMap);\n\n        // Each package accessible from the target module is potentially\n        // comprised of one or more modules, called package sources. The\n        // \"uses\" constraints implied by all package sources must be\n        // calculated and combined to determine the complete set of implied\n        // \"uses\" constraints for each package accessible by the target module.\n        for (Iterator iter = pkgMap.entrySet().iterator(); iter.hasNext(); )\n        {\n            Map.Entry entry = (Map.Entry) iter.next();\n            ResolvedPackage rp = (ResolvedPackage) entry.getValue();\n            for (int srcIdx = 0; srcIdx < rp.m_sourceList.size(); srcIdx++)\n            {\n                usesMap = calculateUsesConstraints(\n                    (PackageSource) rp.m_sourceList.get(srcIdx),\n                    moduleMap, usesMap, cycleMap, candidatesMap);\n            }\n        }\n        return usesMap;\n    }","commit_id":"3ec1284279a07f0d3fa67b6a4213f4cf5cae473a","url":"https://github.com/apache/felix"},{"original_method":"private Map calculateImportedPackagesResolved(IModule module)\n    {\n//System.out.println(\"calculateImportedPackagesResolved(\"+module+\")\");\n        Map pkgMap = new HashMap();\n\n        // Loop through all wires for the module that represent package\n        // dependencies and add the resolved package source to the\n        // imported package map.\n        IWire[] wires = module.getWires();\n        for (int i = 0; (wires != null) && (i < wires.length); i++)\n        {\n            if (wires[i].getCapability().getNamespace().equals(ICapability.PACKAGE_NAMESPACE))\n            {\n                String pkgName = (String)\n                    wires[i].getCapability().getProperties().get(ICapability.PACKAGE_PROPERTY);\n                ResolvedPackage rp = (ResolvedPackage) pkgMap.get(pkgName);\n                rp = (rp == null) ? new ResolvedPackage(pkgName) : rp;\n                rp.m_sourceSet.add(new PackageSource(wires[i].getExporter(), wires[i].getCapability()));\n                pkgMap.put(rp.m_name, rp);\n            }\n        }\n\n        return pkgMap;\n    }","id":33244,"modified_method":"private Map calculateImportedPackagesResolved(IModule targetModule)\n    {\n//System.out.println(\"calculateImportedPackagesResolved(\"+targetModule+\")\");\n        Map pkgMap = new HashMap();\n\n        // Loop through the target module's wires for package\n        // dependencies and add the resolved package source to the\n        // imported package map.\n        IWire[] wires = targetModule.getWires();\n        for (int i = 0; (wires != null) && (i < wires.length); i++)\n        {\n            if (wires[i].getCapability().getNamespace().equals(ICapability.PACKAGE_NAMESPACE))\n            {\n                String pkgName = (String)\n                    wires[i].getCapability().getProperties().get(ICapability.PACKAGE_PROPERTY);\n                ResolvedPackage rp = (ResolvedPackage) pkgMap.get(pkgName);\n                rp = (rp == null) ? new ResolvedPackage(pkgName) : rp;\n                rp.m_sourceList.add(new PackageSource(wires[i].getExporter(), wires[i].getCapability()));\n                pkgMap.put(rp.m_name, rp);\n            }\n        }\n\n        return pkgMap;\n    }","commit_id":"3ec1284279a07f0d3fa67b6a4213f4cf5cae473a","url":"https://github.com/apache/felix"},{"original_method":"private Map calculateExportedAndReexportedPackages(PackageSource psTarget, Map candidatesMap, Map pkgMap, Map cycleMap)\n    {\n        return (candidatesMap.get(psTarget.m_module) == null)\n            ? calculateExportedAndReexportedPackagesResolved(psTarget.m_module, pkgMap, cycleMap)\n            : calculateExportedAndReexportedPackagesUnresolved(psTarget, candidatesMap, pkgMap, cycleMap);      \n    }","id":33245,"modified_method":"private Map calculateExportedAndReexportedPackages(\n        PackageSource psTarget, Map candidatesMap, Map cycleMap)\n    {\n        return (candidatesMap.get(psTarget.m_module) == null)\n            ? calculateExportedAndReexportedPackagesResolved(psTarget.m_module, cycleMap)\n            : calculateExportedAndReexportedPackagesUnresolved(psTarget, candidatesMap, cycleMap);      \n    }","commit_id":"3ec1284279a07f0d3fa67b6a4213f4cf5cae473a","url":"https://github.com/apache/felix"},{"original_method":"private Map calculateExportedAndReexportedPackagesResolved(IModule module, Map pkgMap, Map cycleMap)\n    {\n//System.out.println(\"calculateExportedAndRequiredPackagesResolved(\"+module+\")\");\n        if (cycleMap.get(module) != null)\n        {\n            return pkgMap;\n        }\n\n        cycleMap.put(module, module);\n\n        // Loop through all export package capabilities and merge them\n        // into the package map adding the original target as a source.\n        ICapability[] caps = module.getDefinition().getCapabilities();\n        for (int i = 0; (caps != null) && (i < caps.length); i++)\n        {\n            if (caps[i].getNamespace().equals(ICapability.PACKAGE_NAMESPACE))\n            {\n                String pkgName = (String)\n                    caps[i].getProperties().get(ICapability.PACKAGE_PROPERTY);\n                ResolvedPackage rp = (ResolvedPackage) pkgMap.get(pkgName);\n                rp = (rp == null) ? new ResolvedPackage(pkgName) : rp;\n                rp.m_sourceSet.add(new PackageSource(module, caps[i]));\n                pkgMap.put(rp.m_name, rp);\n            }\n        }\n\n        Map allRequiredMap = new HashMap();\n        IWire[] wires = module.getWires();\n        for (int i = 0; (wires != null) && (i < wires.length); i++)\n        {\n            // If the wire is a module dependency, then flatten it to packages.\n            if (wires[i].getCapability().getNamespace().equals(ICapability.MODULE_NAMESPACE))\n            {\n                // Determine if required packages are re-exported.\n                boolean reexport = false;\n                R4Directive[] dirs =  ((Requirement) wires[i].getRequirement()).getDirectives();\n                for (int dirIdx = 0;\n                    !reexport && (dirs != null) && (dirIdx < dirs.length); dirIdx++)\n                {\n                    if (dirs[dirIdx].getName().equals(Constants.VISIBILITY_DIRECTIVE)\n                        && dirs[dirIdx].getValue().equals(Constants.VISIBILITY_REEXPORT))\n                    {\n                        reexport = true;\n                    }\n                }\n\n                // Recursively calculate the required packages for the\n                // wire's exporting module.\n                Map requiredMap = calculateExportedAndReexportedPackagesResolved(wires[i].getExporter(), new HashMap(), cycleMap);\n\n                // Merge the exporting module's required packages with the\n                // existing packages.\n                for (Iterator reqIter = requiredMap.entrySet().iterator(); reqIter.hasNext(); )\n                {\n                    Map.Entry entry = (Map.Entry) reqIter.next();\n                    String pkgName = (String) entry.getKey();\n\n                    // Merge the current set of required packages into\n                    // the overall complete set of required packages.\n                    // We must keep track of all possible re-exported\n                    // packages, because despite the fact that some packages\n                    // will be required \"privately\" and some will be required\n                    // \"reexport\", any re-exported package sources will\n                    // ultimately need to be combined with privately required\n                    // package sources, if the required packages overlap.\n                    // This is one of the bad things about require-bundle\n                    // behavior, it does not necessarily obey the visibility\n                    // rules declared in the dependency.\n                    ResolvedPackage rp = (ResolvedPackage) allRequiredMap.get(pkgName);\n                    if (rp != null)\n                    {\n                        // Create the union of all package sources.\n                        ResolvedPackage rpReq = (ResolvedPackage) entry.getValue();\n                        rp.m_sourceSet.addAll(rpReq.m_sourceSet);                       \n                    }\n                    else\n                    {\n                        allRequiredMap.put(entry.getKey(), entry.getValue());\n                    }\n\n                    // Now merge any re-exported packages into the module's\n                    // overall package map, since these re-exported packages\n                    // will become part of the module's export signature.\n                    rp = (ResolvedPackage) pkgMap.get(entry.getKey());\n                    if ((rp == null) && reexport)\n                    {\n                        pkgMap.put(entry.getKey(), entry.getValue());\n                    }\n                }\n            }\n        }\n\n        // Using the package map that represents the module's complete\n        // export signature (i.e., it includes exported and re-exported\n        // packages), merge in the package sources for any required\n        // packages that overlap the set of exported/re-exported packages.\n        for (Iterator reqIter = allRequiredMap.entrySet().iterator(); reqIter.hasNext(); )\n        {\n            Map.Entry entry = (Map.Entry) reqIter.next();\n            ResolvedPackage rp = (ResolvedPackage) pkgMap.get(entry.getKey());\n            if (rp != null)\n            {\n                // Create the union of all package sources.\n                ResolvedPackage rpReq = (ResolvedPackage) entry.getValue();\n                rp.m_sourceSet.addAll(rpReq.m_sourceSet);                       \n            }\n        }\n\n        return pkgMap;\n    }","id":33246,"modified_method":"private Map calculateExportedAndReexportedPackagesResolved(\n        IModule targetModule, Map cycleMap)\n    {\n//System.out.println(\"calculateExportedAndRequiredPackagesResolved(\"+targetModule+\")\");\n        Map pkgMap = new HashMap();\n\n        if (cycleMap.get(targetModule) != null)\n        {\n            return pkgMap;\n        }\n\n        cycleMap.put(targetModule, targetModule);\n\n        // Loop through all wires for the target module's module dependencies\n        // and calculate the module's complete set of required packages (and\n        // their associated package sources) and the complete set of required\n        // packages to be re-exported.\n        Map allRequiredMap = new HashMap();\n        Map reexportedPkgMap = new HashMap();\n        IWire[] wires = targetModule.getWires();\n        for (int i = 0; (wires != null) && (i < wires.length); i++)\n        {\n            // If the wire is a module dependency, then flatten it to packages.\n            if (wires[i].getCapability().getNamespace().equals(ICapability.MODULE_NAMESPACE))\n            {\n                // Determine if required packages are re-exported.\n                boolean reexport = false;\n                R4Directive[] dirs =  ((Requirement) wires[i].getRequirement()).getDirectives();\n                for (int dirIdx = 0;\n                    !reexport && (dirs != null) && (dirIdx < dirs.length); dirIdx++)\n                {\n                    if (dirs[dirIdx].getName().equals(Constants.VISIBILITY_DIRECTIVE)\n                        && dirs[dirIdx].getValue().equals(Constants.VISIBILITY_REEXPORT))\n                    {\n                        reexport = true;\n                    }\n                }\n\n                // Recursively calculate the required packages for the\n                // wire's exporting module.\n                Map requiredMap = calculateExportedAndReexportedPackagesResolved(wires[i].getExporter(), cycleMap);\n\n                // Merge the wires exported and re-exported packages\n                // into the complete set of required packages.\n                for (Iterator reqIter = requiredMap.entrySet().iterator(); reqIter.hasNext(); )\n                {\n                    Map.Entry entry = (Map.Entry) reqIter.next();\n                    String pkgName = (String) entry.getKey();\n\n                    // Merge the current set of required packages into\n                    // the overall complete set of required packages.\n                    // We calculate all the required packages, because\n                    // despite the fact that some packages will be required\n                    // \"privately\" and some will be required \"reexport\", any\n                    // re-exported package sources will ultimately need to\n                    // be combined with privately required package sources,\n                    // if the required packages overlap. This is one of the\n                    // bad things about require-bundle behavior, it does not\n                    // necessarily obey the visibility rules declared in the\n                    // dependency.\n                    ResolvedPackage rp = (ResolvedPackage) allRequiredMap.get(pkgName);\n                    if (rp != null)\n                    {\n                        // Create the union of all package sources.\n                        ResolvedPackage rpReq = (ResolvedPackage) entry.getValue();\n                        rp.merge(rpReq);\n                    }\n                    else\n                    {\n                        // Add package to required map.\n                        allRequiredMap.put(pkgName, entry.getValue());\n                    }\n\n                    // Keep track of all required packages to be re-exported.\n                    // All re-exported packages will need to be merged into the\n                    // target module's package map and become part of its overall\n                    // export signature.\n                    if (reexport)\n                    {\n                        reexportedPkgMap.put(pkgName, pkgName);\n                    }\n                }\n            }\n        }\n\n        // For the target module we have now calculated its entire set\n        // of required packages and their associated package sources in\n        // allRequiredMap and have calculated all packages to be re-exported\n        // in reexportedPkgMap. Add all re-exported required packages to the\n        // target module's package map since they will be part of its export\n        // signature.\n        for (Iterator iter = reexportedPkgMap.entrySet().iterator(); iter.hasNext(); )\n        {\n            String pkgName = (String) ((Map.Entry) iter.next()).getKey();\n            pkgMap.put(pkgName, allRequiredMap.get(pkgName));\n        }\n\n        // Now loop through the target module's export package capabilities and\n        // add the target module as a package source for any exported packages.\n        ICapability[] caps = targetModule.getDefinition().getCapabilities();\n        for (int i = 0; (caps != null) && (i < caps.length); i++)\n        {\n            if (caps[i].getNamespace().equals(ICapability.PACKAGE_NAMESPACE))\n            {\n                String pkgName = (String)\n                    caps[i].getProperties().get(ICapability.PACKAGE_PROPERTY);\n                ResolvedPackage rp = (ResolvedPackage) pkgMap.get(pkgName);\n                rp = (rp == null) ? new ResolvedPackage(pkgName) : rp;\n                rp.m_sourceList.add(new PackageSource(targetModule, caps[i]));\n                pkgMap.put(rp.m_name, rp);\n            }\n        }\n\n        return pkgMap;\n    }","commit_id":"3ec1284279a07f0d3fa67b6a4213f4cf5cae473a","url":"https://github.com/apache/felix"},{"original_method":"public Class getClass(String name) throws ClassNotFoundException\n    {\n        // Get the package of the target class.\n        String pkgName = Util.getClassPackage(name);\n\n        ResolvedPackage rp = (ResolvedPackage) m_pkgMap.get(pkgName);\n        if (rp != null)\n        {\n            for (Iterator srcIter = rp.m_sourceSet.iterator(); srcIter.hasNext(); )\n            {\n                PackageSource ps = (PackageSource) srcIter.next();\n                if ((ps.m_module == m_importer) ||\n                    ((ps.m_capability instanceof Capability) &&\n                    ((Capability) ps.m_capability).isIncluded(name)))\n                {\n                    Class clazz = ps.m_module.getContentLoader().getClass(name);\n                    if (clazz != null)\n                    {\n                        return clazz;\n                    }\n                }\n            }\n        }\n\n        return null;\n    }","id":33247,"modified_method":"public Class getClass(String name) throws ClassNotFoundException\n    {\n        // Get the package of the target class.\n        String pkgName = Util.getClassPackage(name);\n\n        ResolvedPackage rp = (ResolvedPackage) m_pkgMap.get(pkgName);\n        if (rp != null)\n        {\n            for (int srcIdx = 0; srcIdx < rp.m_sourceList.size(); srcIdx++)\n            {\n                PackageSource ps = (PackageSource) rp.m_sourceList.get(srcIdx);\n                if ((ps.m_module == m_importer) ||\n                    ((ps.m_capability instanceof Capability) &&\n                    ((Capability) ps.m_capability).isIncluded(name)))\n                {\n                    Class clazz = ps.m_module.getContentLoader().getClass(name);\n                    if (clazz != null)\n                    {\n                        return clazz;\n                    }\n                }\n            }\n        }\n\n        return null;\n    }","commit_id":"3ec1284279a07f0d3fa67b6a4213f4cf5cae473a","url":"https://github.com/apache/felix"},{"original_method":"public URL getResource(String name) throws ResourceNotFoundException\n    {\n        // Get the package of the target class.\n        String pkgName = Util.getResourcePackage(name);\n\n        ResolvedPackage rp = (ResolvedPackage) m_pkgMap.get(pkgName);\n        if (rp != null)\n        {\n            for (Iterator srcIter = rp.m_sourceSet.iterator(); srcIter.hasNext(); )\n            {\n                PackageSource ps = (PackageSource) srcIter.next();\n                URL url = ps.m_module.getContentLoader().getResource(name);\n                if (url != null)\n                {\n                    return url;\n                }\n            }\n        }\n\n        return null;\n    }","id":33248,"modified_method":"public URL getResource(String name) throws ResourceNotFoundException\n    {\n        // Get the package of the target class.\n        String pkgName = Util.getResourcePackage(name);\n\n        ResolvedPackage rp = (ResolvedPackage) m_pkgMap.get(pkgName);\n        if (rp != null)\n        {\n            for (int srcIdx = 0; srcIdx < rp.m_sourceList.size(); srcIdx++)\n            {\n                PackageSource ps = (PackageSource) rp.m_sourceList.get(srcIdx);\n                URL url = ps.m_module.getContentLoader().getResource(name);\n                if (url != null)\n                {\n                    return url;\n                }\n            }\n        }\n\n        return null;\n    }","commit_id":"3ec1284279a07f0d3fa67b6a4213f4cf5cae473a","url":"https://github.com/apache/felix"},{"original_method":"private Map getModulePackages(Map moduleMap, IModule module, Map resolverMap)\n    {\n        Map map = (Map) moduleMap.get(module);\n\n        if (map == null)\n        {\n            map = calculateModulePackages(module, resolverMap);\n            moduleMap.put(module, map);\n//if (!module.getId().equals(\"0\"))\n//{\n//    System.out.println(\"PACKAGES FOR \" + module.getId() + \":\");\n//    dumpPackageSources(map);\n//}\n        }\n        return map;\n    }","id":33249,"modified_method":"private Map getModulePackages(Map moduleMap, IModule module, Map candidatesMap)\n    {\n        Map map = (Map) moduleMap.get(module);\n\n        if (map == null)\n        {\n            map = calculateModulePackages(module, candidatesMap);\n            moduleMap.put(module, map);\n//if (!module.getId().equals(\"0\"))\n//{\n//    System.out.println(\"PACKAGES FOR \" + module.getId() + \":\");\n//    dumpPackageSources(map);\n//}\n        }\n        return map;\n    }","commit_id":"9d428f74fa209ea6dd91f3a1ea0bc1c937bad14e","url":"https://github.com/apache/felix"},{"original_method":"private Map calculateImportedPackagesUnresolved(IModule module, Map resolverMap)\n    {\n//System.out.println(\"calculateImportedPackagesUnresolved(\"+module+\")\");\n        Map pkgMap = new HashMap();\n\n        // Get the candidate set list to get all candidates for\n        // all of the module's requirements.\n        List candSetList = (List) resolverMap.get(module);\n\n        // Loop through all candidate sets that represent import dependencies\n        // for the module and add the current candidate's package source to the\n        // imported package map.\n        for (int candSetIdx = 0; (candSetList != null) && (candSetIdx < candSetList.size()); candSetIdx++)\n        {\n            CandidateSet cs = (CandidateSet) candSetList.get(candSetIdx);\n            PackageSource ps = cs.m_candidates[cs.m_idx];\n\n            if (ps.m_capability.getNamespace().equals(ICapability.PACKAGE_NAMESPACE))\n            {\n                String pkgName = (String)\n                    ps.m_capability.getProperties().get(ICapability.PACKAGE_PROPERTY);\n\n                ResolvedPackage rp = new ResolvedPackage(pkgName);\n                rp.m_sourceSet.add(ps);\n                pkgMap.put(rp.m_name, rp);\n            }\n        }\n\n        return pkgMap;\n    }","id":33250,"modified_method":"private Map calculateImportedPackagesUnresolved(IModule module, Map candidatesMap)\n    {\n//System.out.println(\"calculateImportedPackagesUnresolved(\"+module+\")\");\n        Map pkgMap = new HashMap();\n\n        // Get the candidate set list to get all candidates for\n        // all of the module's requirements.\n        List candSetList = (List) candidatesMap.get(module);\n\n        // Loop through all candidate sets that represent import dependencies\n        // for the module and add the current candidate's package source to the\n        // imported package map.\n        for (int candSetIdx = 0; (candSetList != null) && (candSetIdx < candSetList.size()); candSetIdx++)\n        {\n            CandidateSet cs = (CandidateSet) candSetList.get(candSetIdx);\n            PackageSource ps = cs.m_candidates[cs.m_idx];\n\n            if (ps.m_capability.getNamespace().equals(ICapability.PACKAGE_NAMESPACE))\n            {\n                String pkgName = (String)\n                    ps.m_capability.getProperties().get(ICapability.PACKAGE_PROPERTY);\n\n                ResolvedPackage rp = new ResolvedPackage(pkgName);\n                rp.m_sourceSet.add(ps);\n                pkgMap.put(rp.m_name, rp);\n            }\n        }\n\n        return pkgMap;\n    }","commit_id":"9d428f74fa209ea6dd91f3a1ea0bc1c937bad14e","url":"https://github.com/apache/felix"},{"original_method":"private void populateResolverMap(Map resolverMap, IModule module)\n        throws ResolveException\n    {\n        // Detect cycles.\n        if (resolverMap.get(module) != null)\n        {\n            return;\n        }\n        // List to hold the resolving candidate sets for the module's\n        // requirements.\n        List candSetList = new ArrayList();\n\n        // Even though the candidate set list is currently empty, we\n        // record it in the resolver map early so we can use it to\n        // detect cycles.\n        resolverMap.put(module, candSetList);\n\n        // Loop through each import and calculate its resolving\n        // set of candidates.\n        IRequirement[] reqs = module.getDefinition().getRequirements();\n        for (int reqIdx = 0; (reqs != null) && (reqIdx < reqs.length); reqIdx++)\n        {\n            // Get the candidates from the \"in use\" and \"available\"\n            // package maps. Candidates \"in use\" have higher priority\n            // than \"available\" ones, so put the \"in use\" candidates\n            // at the front of the list of candidates.\n            PackageSource[] inuse = getInUseCandidates(reqs[reqIdx]);\n            PackageSource[] available = getUnusedCandidates(reqs[reqIdx]);\n            PackageSource[] candidates = new PackageSource[inuse.length + available.length];\n// TODO: RB - This duplicates \"in use\" candidates from \"available\" candidates.\n            System.arraycopy(inuse, 0, candidates, 0, inuse.length);\n            System.arraycopy(available, 0, candidates, inuse.length, available.length);\n\n            // If we have candidates, then we need to recursively populate\n            // the resolver map with each of them.\n            ResolveException rethrow = null;\n            if (candidates.length > 0)\n            {\n                for (int candIdx = 0; candIdx < candidates.length; candIdx++)\n                {\n                    try\n                    {\n                        // Only populate the resolver map with modules that\n                        // are not already resolved.\n                        if (!isResolved(candidates[candIdx].m_module))\n                        {\n                            populateResolverMap(resolverMap, candidates[candIdx].m_module);\n                        }\n                    }\n                    catch (ResolveException ex)\n                    {\n                        // If we received a resolve exception, then the\n                        // current candidate is not resolvable for some\n                        // reason and should be removed from the list of\n                        // candidates. For now, just null it.\n                        candidates[candIdx] = null;\n                        rethrow = ex;\n                    }\n                }\n\n                // Remove any nulled candidates to create the final list\n                // of available candidates.\n                candidates = shrinkCandidateArray(candidates);\n            }\n\n            // If no candidates exist at this point, then throw a\n            // resolve exception unless the import is optional.\n            if ((candidates.length == 0) && !reqs[reqIdx].isOptional())\n            {\n                // If we have received an exception while trying to populate\n                // the resolver map, rethrow that exception since it might\n                // be useful. NOTE: This is not necessarily the \"only\"\n                // correct exception, since it is possible that multiple\n                // candidates were not resolvable, but it is better than\n                // nothing.\n                if (rethrow != null)\n                {\n                    throw rethrow;\n                }\n                else\n                {\n                    throw new ResolveException(\n                        \"Unable to resolve.\", module, reqs[reqIdx]);\n                }\n            }\n            else if (candidates.length > 0)\n            {\n                candSetList.add(\n                    new CandidateSet(module, reqs[reqIdx], candidates));\n            }\n        }\n    }","id":33251,"modified_method":"private void populateCandidatesMap(Map candidatesMap, IModule module)\n        throws ResolveException\n    {\n        // Detect cycles.\n        if (candidatesMap.get(module) != null)\n        {\n            return;\n        }\n\n        // List to hold the resolving candidate sets for the module's\n        // requirements.\n        List candSetList = new ArrayList();\n\n        // Even though the candidate set list is currently empty, we\n        // record it in the candidates map early so we can use it to\n        // detect cycles.\n        candidatesMap.put(module, candSetList);\n\n        // Loop through each requirement and calculate its resolving\n        // set of candidates.\n        IRequirement[] reqs = module.getDefinition().getRequirements();\n        for (int reqIdx = 0; (reqs != null) && (reqIdx < reqs.length); reqIdx++)\n        {\n            // Get the candidates from the \"in use\" and \"available\"\n            // package maps. Candidates \"in use\" have higher priority\n            // than \"available\" ones, so put the \"in use\" candidates\n            // at the front of the list of candidates.\n            PackageSource[] inuse = getInUseCandidates(reqs[reqIdx]);\n            PackageSource[] available = getUnusedCandidates(reqs[reqIdx]);\n            PackageSource[] candidates = new PackageSource[inuse.length + available.length];\n// TODO: RB - This duplicates \"in use\" candidates from \"available\" candidates.\n            System.arraycopy(inuse, 0, candidates, 0, inuse.length);\n            System.arraycopy(available, 0, candidates, inuse.length, available.length);\n\n            // If we have candidates, then we need to recursively populate\n            // the resolver map with each of them.\n            ResolveException rethrow = null;\n            if (candidates.length > 0)\n            {\n                for (int candIdx = 0; candIdx < candidates.length; candIdx++)\n                {\n                    try\n                    {\n                        // Only populate the resolver map with modules that\n                        // are not already resolved.\n                        if (!isResolved(candidates[candIdx].m_module))\n                        {\n                            populateCandidatesMap(candidatesMap, candidates[candIdx].m_module);\n                        }\n                    }\n                    catch (ResolveException ex)\n                    {\n                        // If we received a resolve exception, then the\n                        // current candidate is not resolvable for some\n                        // reason and should be removed from the list of\n                        // candidates. For now, just null it.\n                        candidates[candIdx] = null;\n                        rethrow = ex;\n                    }\n                }\n\n                // Remove any nulled candidates to create the final list\n                // of available candidates.\n                candidates = shrinkCandidateArray(candidates);\n            }\n\n            // If no candidates exist at this point, then throw a\n            // resolve exception unless the import is optional.\n            if ((candidates.length == 0) && !reqs[reqIdx].isOptional())\n            {\n                // If we have received an exception while trying to populate\n                // the resolver map, rethrow that exception since it might\n                // be useful. NOTE: This is not necessarily the \"only\"\n                // correct exception, since it is possible that multiple\n                // candidates were not resolvable, but it is better than\n                // nothing.\n                if (rethrow != null)\n                {\n                    throw rethrow;\n                }\n                else\n                {\n                    throw new ResolveException(\n                        \"Unable to resolve.\", module, reqs[reqIdx]);\n                }\n            }\n            else if (candidates.length > 0)\n            {\n                candSetList.add(\n                    new CandidateSet(module, reqs[reqIdx], candidates));\n            }\n        }\n    }","commit_id":"9d428f74fa209ea6dd91f3a1ea0bc1c937bad14e","url":"https://github.com/apache/felix"},{"original_method":"private Map calculateUsesConstraints(PackageSource ps, Map moduleMap, Map usesMap, Map cycleMap, Map resolverMap)\n    {\n//System.out.println(\"calculateUsesConstraints2(\"+ps.m_module+\")\");\n        if (cycleMap.get(ps) != null)\n        {\n            return usesMap;\n        }\n\n        cycleMap.put(ps, ps);\n\n        Map pkgMap = getModulePackages(moduleMap, ps.m_module, resolverMap);\n\n        Capability cap = (Capability) ps.m_capability;\n        for (int i = 0; i < cap.getUses().length; i++)\n        {\n            ResolvedPackage rp = (ResolvedPackage) pkgMap.get(cap.getUses()[i]);\n            if (rp != null)\n            {\n                for (Iterator srcIter = rp.m_sourceSet.iterator(); srcIter.hasNext(); )\n                {\n                    usesMap = calculateUsesConstraints(\n                        (PackageSource) srcIter.next(),\n                        moduleMap, usesMap, cycleMap, resolverMap);\n                }\n\n                // Now merge current uses constraint with existing ones.\n                ResolvedPackage rpExisting = (ResolvedPackage) usesMap.get(cap.getUses()[i]);\n                if (rpExisting != null)\n                {\n                    // Create union of package source if there is a subset\n                    // relationship.\n                    if (rpExisting.isSubset(rp) || rp.isSubset(rpExisting))\n                    {\n                        rpExisting.m_sourceSet.addAll(rp.m_sourceSet);\n                    }\n                    else\n                    {\n//System.out.println(\"VIOLATION \" + ps.m_module + \" has \" + rp + \" instead of \" + rpExisting);\n                        throw new RuntimeException(\"Incompatible package sources.\");\n                    }\n                }\n                else\n                {\n                    usesMap.put(cap.getUses()[i], rp);\n                }\n            }\n        }\n\n        return usesMap;\n    }","id":33252,"modified_method":"private Map calculateUsesConstraints(PackageSource ps, Map moduleMap, Map usesMap, Map cycleMap, Map candidatesMap)\n    {\n//System.out.println(\"calculateUsesConstraints2(\"+ps.m_module+\")\");\n        // If we are in a cycle, then return for now.\n        if (cycleMap.get(ps) != null)\n        {\n            return usesMap;\n        }\n\n        // Record the package source in the cycle map.\n        cycleMap.put(ps, ps);\n\n        // Get all packages accessible from the module of the\n        // current package source.\n        Map pkgMap = getModulePackages(moduleMap, ps.m_module, candidatesMap);\n\n        // Get capability (i.e., package) of the package source.\n        Capability cap = (Capability) ps.m_capability;\n\n        // Loop through all \"used\" packages of the capability.\n        for (int i = 0; i < cap.getUses().length; i++)\n        {\n            // The package source module should have a resolved package\n            // for the \"used\" package in its set of accessible packages,\n            // since it claims to use it, so get the associated resolved\n            // package.\n            ResolvedPackage rp = (ResolvedPackage) pkgMap.get(cap.getUses()[i]);\n\n            // In general, the resolved package should not be null,\n            // but check for safety.\n            if (rp != null)\n            {\n                // First, iterate through all package sources for the resolved\n                // package associated with the current \"used\" package and calculate\n                // and combine the \"uses\" constraints for each package source.\n                for (Iterator srcIter = rp.m_sourceSet.iterator(); srcIter.hasNext(); )\n                {\n                    usesMap = calculateUsesConstraints(\n                        (PackageSource) srcIter.next(),\n                        moduleMap, usesMap, cycleMap, candidatesMap);\n                }\n\n                // Then, add the resolved package for the current \"used\" package\n                // as a \"uses\" constraint too; add it to an existing constraint\n                // list if the current \"used\" package is already in the uses map.\n                List constraintList = (List) usesMap.get(cap.getUses()[i]);\n                if (constraintList == null)\n                {\n                    constraintList = new ArrayList();\n                }\n                constraintList.add(rp);\n                usesMap.put(cap.getUses()[i], constraintList);\n            }\n        }\n\n        return usesMap;\n    }","commit_id":"9d428f74fa209ea6dd91f3a1ea0bc1c937bad14e","url":"https://github.com/apache/felix"},{"original_method":"private Map calculateModulePackages(IModule module, Map resolverMap)\n    {\n//System.out.println(\"calculateModulePackages(\"+module+\")\");\n        Map importedPackages = calculateImportedPackages(module, resolverMap);\n        Map exportedPackages = calculateExportedPackages(module);\n        Map requiredPackages = calculateRequiredPackages(module, resolverMap);\n\n        // Merge exported packages into required packages. If a package is both\n        // exported and required, then append the exported source to the end of\n        // the require package sources; otherwise just add it to the package map.\n        for (Iterator i = exportedPackages.entrySet().iterator(); i.hasNext(); )\n        {\n            Map.Entry entry = (Map.Entry) i.next();\n            ResolvedPackage rpReq = (ResolvedPackage) requiredPackages.get(entry.getKey());\n            if (rpReq != null)\n            {\n                ResolvedPackage rpExport = (ResolvedPackage) entry.getValue();\n                rpReq.m_sourceSet.addAll(rpExport.m_sourceSet);\n            }\n            else\n            {\n                requiredPackages.put(entry.getKey(), entry.getValue());\n            }\n        }\n\n        // Merge imported packages into required packages. Imports overwrite\n        // any required and/or exported package.\n        for (Iterator i = importedPackages.entrySet().iterator(); i.hasNext(); )\n        {\n            Map.Entry entry = (Map.Entry) i.next();\n            requiredPackages.put(entry.getKey(), entry.getValue());\n        }\n\n        return requiredPackages;\n    }","id":33253,"modified_method":"private Map calculateModulePackages(IModule module, Map candidatesMap)\n    {\n//System.out.println(\"calculateModulePackages(\"+module+\")\");\n        Map importedPackages = calculateImportedPackages(module, candidatesMap);\n        Map exportedPackages = calculateExportedPackages(module);\n        Map requiredPackages = calculateRequiredPackages(module, candidatesMap);\n\n        // Merge exported packages into required packages. If a package is both\n        // exported and required, then append the exported source to the end of\n        // the require package sources; otherwise just add it to the package map.\n        for (Iterator i = exportedPackages.entrySet().iterator(); i.hasNext(); )\n        {\n            Map.Entry entry = (Map.Entry) i.next();\n            ResolvedPackage rpReq = (ResolvedPackage) requiredPackages.get(entry.getKey());\n            if (rpReq != null)\n            {\n                ResolvedPackage rpExport = (ResolvedPackage) entry.getValue();\n                rpReq.m_sourceSet.addAll(rpExport.m_sourceSet);\n            }\n            else\n            {\n                requiredPackages.put(entry.getKey(), entry.getValue());\n            }\n        }\n\n        // Merge imported packages into required packages. Imports overwrite\n        // any required and/or exported package.\n        for (Iterator i = importedPackages.entrySet().iterator(); i.hasNext(); )\n        {\n            Map.Entry entry = (Map.Entry) i.next();\n            requiredPackages.put(entry.getKey(), entry.getValue());\n        }\n\n        return requiredPackages;\n    }","commit_id":"9d428f74fa209ea6dd91f3a1ea0bc1c937bad14e","url":"https://github.com/apache/felix"},{"original_method":"private Map calculateRequiredPackagesUnresolved(IModule module, Map resolverMap)\n    {\n//System.out.println(\"calculateRequiredPackagesUnresolved(\"+module+\")\");\n        Map pkgMap = new HashMap();\n\n        // Loop through all current candidates for module dependencies and\n        // merge re-exported packages.\n// TODO: RB - Right now assume that everything is re-exported, but this won't be true in the future.\n        List candSetList = (List) resolverMap.get(module);\n        for (int candSetIdx = 0; (candSetList != null) && (candSetIdx < candSetList.size()); candSetIdx++)\n        {\n            CandidateSet cs = (CandidateSet) candSetList.get(candSetIdx);\n            PackageSource ps = cs.m_candidates[cs.m_idx];\n\n            // If the capabaility is a module dependency, then flatten it to packages.\n            if (ps.m_capability.getNamespace().equals(ICapability.MODULE_NAMESPACE))\n            {\n                Map cycleMap = new HashMap();\n                cycleMap.put(module, module);\n                Map requireMap = calculateExportedAndReexportedPackages(ps, resolverMap, new HashMap(), cycleMap);\n\n                // Merge sources.\n                for (Iterator reqIter = requireMap.entrySet().iterator(); reqIter.hasNext(); )\n                {\n                    Map.Entry entry = (Map.Entry) reqIter.next();\n                    ResolvedPackage rp = (ResolvedPackage) pkgMap.get(entry.getKey());\n                    if (rp != null)\n                    {\n                        ResolvedPackage rpReq = (ResolvedPackage) entry.getValue();\n                        rp.m_sourceSet.addAll(rpReq.m_sourceSet);\n                    }\n                    else\n                    {\n                        pkgMap.put(entry.getKey(), entry.getValue());\n                    }\n                }\n            }\n        }\n\n        return pkgMap;\n    }","id":33254,"modified_method":"private Map calculateRequiredPackagesUnresolved(IModule module, Map candidatesMap)\n    {\n//System.out.println(\"calculateRequiredPackagesUnresolved(\"+module+\")\");\n        Map pkgMap = new HashMap();\n\n        // Loop through all current candidates for module dependencies and\n        // merge re-exported packages.\n// TODO: RB - Right now assume that everything is re-exported, but this won't be true in the future.\n        List candSetList = (List) candidatesMap.get(module);\n        for (int candSetIdx = 0; (candSetList != null) && (candSetIdx < candSetList.size()); candSetIdx++)\n        {\n            CandidateSet cs = (CandidateSet) candSetList.get(candSetIdx);\n            PackageSource ps = cs.m_candidates[cs.m_idx];\n\n            // If the capabaility is a module dependency, then flatten it to packages.\n            if (ps.m_capability.getNamespace().equals(ICapability.MODULE_NAMESPACE))\n            {\n                Map cycleMap = new HashMap();\n                cycleMap.put(module, module);\n                Map requireMap = calculateExportedAndReexportedPackages(ps, candidatesMap, new HashMap(), cycleMap);\n\n                // Merge sources.\n                for (Iterator reqIter = requireMap.entrySet().iterator(); reqIter.hasNext(); )\n                {\n                    Map.Entry entry = (Map.Entry) reqIter.next();\n                    ResolvedPackage rp = (ResolvedPackage) pkgMap.get(entry.getKey());\n                    if (rp != null)\n                    {\n                        ResolvedPackage rpReq = (ResolvedPackage) entry.getValue();\n                        rp.m_sourceSet.addAll(rpReq.m_sourceSet);\n                    }\n                    else\n                    {\n                        pkgMap.put(entry.getKey(), entry.getValue());\n                    }\n                }\n            }\n        }\n\n        return pkgMap;\n    }","commit_id":"9d428f74fa209ea6dd91f3a1ea0bc1c937bad14e","url":"https://github.com/apache/felix"},{"original_method":"private Map calculateRequiredPackages(IModule module, Map resolverMap)\n    {\n        return (resolverMap.get(module) == null)\n            ? calculateRequiredPackagesResolved(module)\n            : calculateRequiredPackagesUnresolved(module, resolverMap);      \n    }","id":33255,"modified_method":"private Map calculateRequiredPackages(IModule module, Map candidatesMap)\n    {\n        return (candidatesMap.get(module) == null)\n            ? calculateRequiredPackagesResolved(module)\n            : calculateRequiredPackagesUnresolved(module, candidatesMap);      \n    }","commit_id":"9d428f74fa209ea6dd91f3a1ea0bc1c937bad14e","url":"https://github.com/apache/felix"},{"original_method":"private boolean isClassSpaceConsistent(\n        IModule rootModule, Map moduleMap, Map cycleMap, Map resolverMap)\n    {\n//System.out.println(\"isClassSpaceConsistent(\"+rootModule+\")\");\n        if (cycleMap.get(rootModule) != null)\n        {\n            return true;\n        }\n\n        cycleMap.put(rootModule, rootModule);\n\n        // Get the package map for the root module.\n        Map pkgMap = getModulePackages(moduleMap, rootModule, resolverMap);\n\n        // Verify that all sources for all of the module's packages\n        // are consistent too.\n        for (Iterator iter = pkgMap.entrySet().iterator(); iter.hasNext(); )\n        {\n            Map.Entry entry = (Map.Entry) iter.next();\n            ResolvedPackage rp = (ResolvedPackage) entry.getValue();\n            for (Iterator srcIter = rp.m_sourceSet.iterator(); srcIter.hasNext(); )\n            {\n                PackageSource ps = (PackageSource) srcIter.next();\n                if (!isClassSpaceConsistent(ps.m_module, moduleMap, cycleMap, resolverMap))\n                {\n                    return false;\n                }\n            }\n        }\n\n        // Now we need to check the \"uses\" constraint of every package\n        // in the root module's packages to see if all implied package\n        // sources are compatible.\n        Map usesMap = calculateUsesConstraints(rootModule, moduleMap, resolverMap);\n\n        // Verify that none of the implied constraints in the uses map\n        // conflict with anything in the bundles package map.\n        for (Iterator iter = usesMap.entrySet().iterator(); iter.hasNext(); )\n        {\n            Map.Entry entry = (Map.Entry) iter.next();\n            ResolvedPackage rp = (ResolvedPackage) pkgMap.get(entry.getKey());\n\n            if (rp != null)\n            {\n                // Verify that package source implied by \"uses\" constraints\n                // is compatible with the package source of the module's\n                // package map.\n                ResolvedPackage rpUses = (ResolvedPackage) entry.getValue();\n                if (!rp.isSubset(rpUses) && !rpUses.isSubset(rp))\n                {\n                    m_logger.log(\n                        Logger.LOG_DEBUG,\n                        \"Constraint violation for \" + rootModule\n                        + \" detected; module can see \"\n                        + rp + \" and \" + rpUses);\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }","id":33256,"modified_method":"private boolean isClassSpaceConsistent(\n        IModule rootModule, Map moduleMap, Map cycleMap, Map candidatesMap)\n    {\n//System.out.println(\"isClassSpaceConsistent(\"+rootModule+\")\");\n        // If we are in a cycle, then assume true for now.\n        if (cycleMap.get(rootModule) != null)\n        {\n            return true;\n        }\n\n        // Record the root module in the cycle map.\n        cycleMap.put(rootModule, rootModule);\n\n        // Get the package map for the root module, which is a\n        // map of all packages accessible to the module and their\n        // associated package sources.\n        Map pkgMap = getModulePackages(moduleMap, rootModule, candidatesMap);\n\n        // Loop through all of the module's accessible packages and verify\n        // that all package sources are consistent.\n        for (Iterator iter = pkgMap.entrySet().iterator(); iter.hasNext(); )\n        {\n            Map.Entry entry = (Map.Entry) iter.next();\n            // Get the resolved package, which contains the set of all\n            // package sources for the given package.\n            ResolvedPackage rp = (ResolvedPackage) entry.getValue();\n            // Loop through each package source and test if it is consistent.\n            for (Iterator srcIter = rp.m_sourceSet.iterator(); srcIter.hasNext(); )\n            {\n                PackageSource ps = (PackageSource) srcIter.next();\n                if (!isClassSpaceConsistent(ps.m_module, moduleMap, cycleMap, candidatesMap))\n                {\n                    return false;\n                }\n            }\n        }\n\n        // Now we need to calculate the \"uses\" constraints of every package\n        // accessible to the module based on the current candidates.\n        Map usesMap = calculateUsesConstraints(rootModule, moduleMap, candidatesMap);\n\n        // Verify that none of the implied \"uses\" constraints in the uses map\n        // conflict with anything in the root module's package map.\n        for (Iterator iter = usesMap.entrySet().iterator(); iter.hasNext(); )\n        {\n            Map.Entry entry = (Map.Entry) iter.next();\n\n            // For the given \"used\" package, get that package from the\n            // root module's package map, if present.\n            ResolvedPackage rp = (ResolvedPackage) pkgMap.get(entry.getKey());\n\n            // If the \"used\" package is also visible to the root module,\n            // make sure there is no conflicts in the implied \"uses\"\n            // constraints.\n            if (rp != null)\n            {\n                // Clone the resolve package so we can modify it.\n                rp = (ResolvedPackage) rp.clone();\n\n                // Loop through all implied \"uses\" constraints for the current\n                // \"used\" package and verify that all package sources are\n                // compatible with the package source of the root module's\n                // package map.\n                List constraintList = (List) entry.getValue();\n                for (int constIdx = 0; constIdx < constraintList.size(); constIdx++)\n                {\n                    // Get a specific \"uses\" constraint for the current \"used\"\n                    // package.\n                    ResolvedPackage rpUses = (ResolvedPackage) constraintList.get(constIdx);\n                    // Determine if the implied \"uses\" constraint is compatible with\n                    // the root module's package sources for the given \"used\" package.\n                    // They are compatible if one is the subset of the other.\n                    if (rp.isSubset(rpUses) || rpUses.isSubset(rp))\n                    {\n                        // In case they are compatible, then create the union of\n                        // the root module's package sources and those of the\n                        // \"uses\" constraint for continued testing of the\n                        // remaining \"uses\" constraints.\n                        rp.m_sourceSet.addAll(rpUses.m_sourceSet);\n                    }\n                    else\n                    {\n                        m_logger.log(\n                            Logger.LOG_DEBUG,\n                            \"Constraint violation for \" + rootModule\n                            + \" detected; module can see \"\n                            + rp + \" and \" + rpUses);\n                        return false;\n                    }\n                }\n            }\n        }\n\n        return true;\n    }","commit_id":"9d428f74fa209ea6dd91f3a1ea0bc1c937bad14e","url":"https://github.com/apache/felix"},{"original_method":"private Map calculateExportedAndReexportedPackages(PackageSource psTarget, Map resolverMap, Map pkgMap, Map cycleMap)\n    {\n        return (resolverMap.get(psTarget.m_module) == null)\n            ? calculateExportedAndReexportedPackagesResolved(psTarget.m_module, pkgMap, cycleMap)\n            : calculateExportedAndReexportedPackagesUnresolved(psTarget, resolverMap, pkgMap, cycleMap);      \n    }","id":33257,"modified_method":"private Map calculateExportedAndReexportedPackages(PackageSource psTarget, Map candidatesMap, Map pkgMap, Map cycleMap)\n    {\n        return (candidatesMap.get(psTarget.m_module) == null)\n            ? calculateExportedAndReexportedPackagesResolved(psTarget.m_module, pkgMap, cycleMap)\n            : calculateExportedAndReexportedPackagesUnresolved(psTarget, candidatesMap, pkgMap, cycleMap);      \n    }","commit_id":"9d428f74fa209ea6dd91f3a1ea0bc1c937bad14e","url":"https://github.com/apache/felix"},{"original_method":"private Map createWires(Map resolverMap, IModule rootModule)\n    {\n        Map resolvedModuleWireMap =\n            populateWireMap(resolverMap, rootModule, new HashMap());\n        Iterator iter = resolvedModuleWireMap.entrySet().iterator();\n        while (iter.hasNext())\n        {\n            Map.Entry entry = (Map.Entry) iter.next();\n            IModule module = (IModule) entry.getKey();\n            IWire[] wires = (IWire[]) entry.getValue();\n\n            // Set the module's resolved and wiring attribute.\n            setResolved(module, true);\n            // Only add wires attribute if some exist; export\n            // only modules may not have wires.\n            if (wires.length > 0)\n            {\n                ((ModuleImpl) module).setWires(wires);\n            }\n\n            // Remove the wire's exporting module from the \"available\"\n            // package map and put it into the \"in use\" package map;\n            // these steps may be a no-op.\n            for (int wireIdx = 0;\n                (wires != null) && (wireIdx < wires.length);\n                wireIdx++)\n            {\nm_logger.log(Logger.LOG_DEBUG, \"WIRE: \" + wires[wireIdx]);\n                // Add the module of the wire to the \"in use\" package map.\n                ICapability[] inUseCaps = (ICapability[]) m_inUseCapMap.get(wires[wireIdx].getExporter());\n                inUseCaps = addCapabilityToArray(inUseCaps, wires[wireIdx].getCapability());\n                m_inUseCapMap.put(wires[wireIdx].getExporter(), inUseCaps);\n            }\n\n            // Also add the module's capabilities to the \"in use\" map\n            // if the capability is not matched by a requirement. If the\n            // capability is matched by a requirement, then it is handled\n            // above when adding the wired modules to the \"in use\" map.\n// TODO: RB - Bug here because a requirement for a package need not overlap the\n//            capability for that package and this assumes it does.\n            ICapability[] caps = module.getDefinition().getCapabilities();\n            IRequirement[] reqs = module.getDefinition().getRequirements();\n            for (int capIdx = 0; (caps != null) && (capIdx < caps.length); capIdx++)\n            {\n                boolean matched = false;\n                for (int reqIdx = 0;\n                    !matched && (reqs != null) && (reqIdx < reqs.length);\n                    reqIdx++)\n                {\n                    if (reqs[reqIdx].isSatisfied(caps[capIdx]))\n                    {\n                        matched = true;\n                    }\n                }\n                if (!matched)\n                {\n                    ICapability[] inUseCaps = (ICapability[]) m_inUseCapMap.get(module);\n                    inUseCaps = addCapabilityToArray(inUseCaps, caps[capIdx]);\n                    m_inUseCapMap.put(module, inUseCaps);\n                }\n            }\n        }\n\n        return resolvedModuleWireMap;\n    }","id":33258,"modified_method":"private Map createWires(Map candidatesMap, IModule rootModule)\n    {\n        Map resolvedModuleWireMap =\n            populateWireMap(candidatesMap, rootModule, new HashMap());\n        Iterator iter = resolvedModuleWireMap.entrySet().iterator();\n        while (iter.hasNext())\n        {\n            Map.Entry entry = (Map.Entry) iter.next();\n            IModule module = (IModule) entry.getKey();\n            IWire[] wires = (IWire[]) entry.getValue();\n\n            // Set the module's resolved and wiring attribute.\n            setResolved(module, true);\n            // Only add wires attribute if some exist; export\n            // only modules may not have wires.\n            if (wires.length > 0)\n            {\n                ((ModuleImpl) module).setWires(wires);\n            }\n\n            // Remove the wire's exporting module from the \"available\"\n            // package map and put it into the \"in use\" package map;\n            // these steps may be a no-op.\n            for (int wireIdx = 0;\n                (wires != null) && (wireIdx < wires.length);\n                wireIdx++)\n            {\nm_logger.log(Logger.LOG_DEBUG, \"WIRE: \" + wires[wireIdx]);\n                // Add the module of the wire to the \"in use\" package map.\n                ICapability[] inUseCaps = (ICapability[]) m_inUseCapMap.get(wires[wireIdx].getExporter());\n                inUseCaps = addCapabilityToArray(inUseCaps, wires[wireIdx].getCapability());\n                m_inUseCapMap.put(wires[wireIdx].getExporter(), inUseCaps);\n            }\n\n            // Also add the module's capabilities to the \"in use\" map\n            // if the capability is not matched by a requirement. If the\n            // capability is matched by a requirement, then it is handled\n            // above when adding the wired modules to the \"in use\" map.\n// TODO: RB - Bug here because a requirement for a package need not overlap the\n//            capability for that package and this assumes it does.\n            ICapability[] caps = module.getDefinition().getCapabilities();\n            IRequirement[] reqs = module.getDefinition().getRequirements();\n            for (int capIdx = 0; (caps != null) && (capIdx < caps.length); capIdx++)\n            {\n                boolean matched = false;\n                for (int reqIdx = 0;\n                    !matched && (reqs != null) && (reqIdx < reqs.length);\n                    reqIdx++)\n                {\n                    if (reqs[reqIdx].isSatisfied(caps[capIdx]))\n                    {\n                        matched = true;\n                    }\n                }\n                if (!matched)\n                {\n                    ICapability[] inUseCaps = (ICapability[]) m_inUseCapMap.get(module);\n                    inUseCaps = addCapabilityToArray(inUseCaps, caps[capIdx]);\n                    m_inUseCapMap.put(module, inUseCaps);\n                }\n            }\n        }\n\n        return resolvedModuleWireMap;\n    }","commit_id":"9d428f74fa209ea6dd91f3a1ea0bc1c937bad14e","url":"https://github.com/apache/felix"},{"original_method":"private Map calculateCandidateRequiredPackages(IModule module, PackageSource psTarget, Map resolverMap)\n    {\n//System.out.println(\"calculateCandidateRequiredPackages(\"+module+\")\");\n        Map pkgMap = new HashMap();\n\n        Map cycleMap = new HashMap();\n        cycleMap.put(module, module);\n        Map requiredMap = calculateExportedAndReexportedPackages(psTarget, resolverMap, new HashMap(), cycleMap);\n\n        // Merge sources.\n        for (Iterator reqIter = requiredMap.entrySet().iterator(); reqIter.hasNext(); )\n        {\n            Map.Entry entry = (Map.Entry) reqIter.next();\n            if (pkgMap.get(entry.getKey()) != null)\n            {\n                ResolvedPackage rp = (ResolvedPackage) pkgMap.get(entry.getKey());\n                ResolvedPackage rpReq = (ResolvedPackage) entry.getValue();\n                rp.m_sourceSet.addAll(rpReq.m_sourceSet);\n            }\n            else\n            {\n                pkgMap.put(entry.getKey(), entry.getValue());\n            }\n        }\n\n        return pkgMap;\n    }","id":33259,"modified_method":"private Map calculateCandidateRequiredPackages(IModule module, PackageSource psTarget, Map candidatesMap)\n    {\n//System.out.println(\"calculateCandidateRequiredPackages(\"+module+\")\");\n        Map pkgMap = new HashMap();\n\n        Map cycleMap = new HashMap();\n        cycleMap.put(module, module);\n        Map requiredMap = calculateExportedAndReexportedPackages(psTarget, candidatesMap, new HashMap(), cycleMap);\n\n        // Merge sources.\n        for (Iterator reqIter = requiredMap.entrySet().iterator(); reqIter.hasNext(); )\n        {\n            Map.Entry entry = (Map.Entry) reqIter.next();\n            if (pkgMap.get(entry.getKey()) != null)\n            {\n                ResolvedPackage rp = (ResolvedPackage) pkgMap.get(entry.getKey());\n                ResolvedPackage rpReq = (ResolvedPackage) entry.getValue();\n                rp.m_sourceSet.addAll(rpReq.m_sourceSet);\n            }\n            else\n            {\n                pkgMap.put(entry.getKey(), entry.getValue());\n            }\n        }\n\n        return pkgMap;\n    }","commit_id":"9d428f74fa209ea6dd91f3a1ea0bc1c937bad14e","url":"https://github.com/apache/felix"},{"original_method":"private Map populateWireMap(Map resolverMap, IModule importer, Map wireMap)\n    {\n        // If the module is already resolved or it is part of\n        // a cycle, then just return the wire map.\n        if (isResolved(importer) || (wireMap.get(importer) != null))\n        {\n            return wireMap;\n        }\n\n        List candSetList = (List) resolverMap.get(importer);\n        List moduleWires = new ArrayList();\n        List packageWires = new ArrayList();\n        IWire[] wires = new IWire[candSetList.size()];\n\n        // Put the module in the wireMap with an empty wire array;\n        // we do this early so we can use it to detect cycles.\n        wireMap.put(importer, wires);\n\n        // Loop through each candidate Set and create a wire\n        // for the selected candidate for the associated import.\n        for (int candSetIdx = 0; candSetIdx < candSetList.size(); candSetIdx++)\n        {\n            // Get the current candidate set.\n            CandidateSet cs = (CandidateSet) candSetList.get(candSetIdx);\n\n            // Create a wire for the current candidate based on the type\n            // of requirement it resolves.\n            if (cs.m_requirement.getNamespace().equals(ICapability.MODULE_NAMESPACE))\n            {\n                moduleWires.add(new R4WireModule(\n                    importer,\n                    cs.m_candidates[cs.m_idx].m_module,\n                    cs.m_candidates[cs.m_idx].m_capability,\n                    calculateCandidateRequiredPackages(importer, cs.m_candidates[cs.m_idx], resolverMap)));\n            }\n            else\n            {\n                packageWires.add(new R4Wire(\n                    importer,\n                    cs.m_candidates[cs.m_idx].m_module,\n                    cs.m_candidates[cs.m_idx].m_capability));\n            }\n\n            // Create any necessary wires for the selected candidate module.\n            wireMap = populateWireMap(\n                resolverMap, cs.m_candidates[cs.m_idx].m_module, wireMap);\n        }\n\n        packageWires.addAll(moduleWires);\n        wireMap.put(importer, packageWires.toArray(wires));\n\n        return wireMap;\n    }","id":33260,"modified_method":"private Map populateWireMap(Map candidatesMap, IModule importer, Map wireMap)\n    {\n        // If the module is already resolved or it is part of\n        // a cycle, then just return the wire map.\n        if (isResolved(importer) || (wireMap.get(importer) != null))\n        {\n            return wireMap;\n        }\n\n        List candSetList = (List) candidatesMap.get(importer);\n        List moduleWires = new ArrayList();\n        List packageWires = new ArrayList();\n        IWire[] wires = new IWire[candSetList.size()];\n\n        // Put the module in the wireMap with an empty wire array;\n        // we do this early so we can use it to detect cycles.\n        wireMap.put(importer, wires);\n\n        // Loop through each candidate Set and create a wire\n        // for the selected candidate for the associated import.\n        for (int candSetIdx = 0; candSetIdx < candSetList.size(); candSetIdx++)\n        {\n            // Get the current candidate set.\n            CandidateSet cs = (CandidateSet) candSetList.get(candSetIdx);\n\n            // Create a wire for the current candidate based on the type\n            // of requirement it resolves.\n            if (cs.m_requirement.getNamespace().equals(ICapability.MODULE_NAMESPACE))\n            {\n                moduleWires.add(new R4WireModule(\n                    importer,\n                    cs.m_candidates[cs.m_idx].m_module,\n                    cs.m_candidates[cs.m_idx].m_capability,\n                    calculateCandidateRequiredPackages(importer, cs.m_candidates[cs.m_idx], candidatesMap)));\n            }\n            else\n            {\n                packageWires.add(new R4Wire(\n                    importer,\n                    cs.m_candidates[cs.m_idx].m_module,\n                    cs.m_candidates[cs.m_idx].m_capability));\n            }\n\n            // Create any necessary wires for the selected candidate module.\n            wireMap = populateWireMap(\n                candidatesMap, cs.m_candidates[cs.m_idx].m_module, wireMap);\n        }\n\n        packageWires.addAll(moduleWires);\n        wireMap.put(importer, packageWires.toArray(wires));\n\n        return wireMap;\n    }","commit_id":"9d428f74fa209ea6dd91f3a1ea0bc1c937bad14e","url":"https://github.com/apache/felix"},{"original_method":"private Map calculateExportedAndReexportedPackagesUnresolved(PackageSource psTarget, Map resolverMap, Map pkgMap, Map cycleMap)\n    {\n//System.out.println(\"calculateExportedAndReexportedPackagesUnresolved(\"+psTarget.m_module+\")\");\n        if (cycleMap.get(psTarget.m_module) != null)\n        {\n            return pkgMap;\n        }\n\n        cycleMap.put(psTarget.m_module, psTarget.m_module);\n\n        // Loop through all current candidates for module dependencies and\n        // merge re-exported packages.\n// TODO: RB - Right now assume that everything is re-exported, but this won't be true in the future.\n        List candSetList = (List) resolverMap.get(psTarget.m_module);\n        for (int candSetIdx = 0; candSetIdx < candSetList.size(); candSetIdx++)\n        {\n            CandidateSet cs = (CandidateSet) candSetList.get(candSetIdx);\n            PackageSource ps = cs.m_candidates[cs.m_idx];\n\n            // If the candidate is resolving a module dependency, then\n            // flatten it to packages.\n            if (ps.m_capability.getNamespace().equals(ICapability.MODULE_NAMESPACE))\n            {\n                // Recursively calculate the required packages for the\n                // current candidate.\n                Map requiredMap = calculateExportedAndReexportedPackages(ps, resolverMap, new HashMap(), cycleMap);\n\n                // Merge the candidate's required packages with the existing packages.\n                for (Iterator reqIter = requiredMap.entrySet().iterator(); reqIter.hasNext(); )\n                {\n                    Map.Entry entry = (Map.Entry) reqIter.next();\n                    ResolvedPackage rp = (ResolvedPackage) pkgMap.get(entry.getKey());\n                    if (rp != null)\n                    {\n                        // Create the union of all package sources.\n                        ResolvedPackage rpReq = (ResolvedPackage) entry.getValue();\n                        rp.m_sourceSet.addAll(rpReq.m_sourceSet);\n                    }\n                    else\n                    {\n                        pkgMap.put(entry.getKey(), entry.getValue());\n                    }\n                }\n            }\n        }\n\n        // Loop through all export package capabilities and merge them\n        // into the package map adding the original target as a source.\n        ICapability[] candCaps = psTarget.m_module.getDefinition().getCapabilities();\n        for (int capIdx = 0; (candCaps != null) && (capIdx < candCaps.length); capIdx++)\n        {\n            if (candCaps[capIdx].getNamespace().equals(ICapability.PACKAGE_NAMESPACE))\n            {\n                String pkgName = (String)\n                    candCaps[capIdx].getProperties().get(ICapability.PACKAGE_PROPERTY);\n                ResolvedPackage rp = (ResolvedPackage) pkgMap.get(pkgName);\n                rp = (rp == null) ? new ResolvedPackage(pkgName) : rp;\n                rp.m_sourceSet.add(new PackageSource(psTarget.m_module, candCaps[capIdx]));\n                pkgMap.put(rp.m_name, rp);\n            }\n        }\n\n        return pkgMap;\n    }","id":33261,"modified_method":"private Map calculateExportedAndReexportedPackagesUnresolved(PackageSource psTarget, Map candidatesMap, Map pkgMap, Map cycleMap)\n    {\n//System.out.println(\"calculateExportedAndReexportedPackagesUnresolved(\"+psTarget.m_module+\")\");\n        if (cycleMap.get(psTarget.m_module) != null)\n        {\n            return pkgMap;\n        }\n\n        cycleMap.put(psTarget.m_module, psTarget.m_module);\n\n        // Loop through all current candidates for module dependencies and\n        // merge re-exported packages.\n// TODO: RB - Right now assume that everything is re-exported, but this won't be true in the future.\n        List candSetList = (List) candidatesMap.get(psTarget.m_module);\n        for (int candSetIdx = 0; candSetIdx < candSetList.size(); candSetIdx++)\n        {\n            CandidateSet cs = (CandidateSet) candSetList.get(candSetIdx);\n            PackageSource ps = cs.m_candidates[cs.m_idx];\n\n            // If the candidate is resolving a module dependency, then\n            // flatten it to packages.\n            if (ps.m_capability.getNamespace().equals(ICapability.MODULE_NAMESPACE))\n            {\n                // Recursively calculate the required packages for the\n                // current candidate.\n                Map requiredMap = calculateExportedAndReexportedPackages(ps, candidatesMap, new HashMap(), cycleMap);\n\n                // Merge the candidate's required packages with the existing packages.\n                for (Iterator reqIter = requiredMap.entrySet().iterator(); reqIter.hasNext(); )\n                {\n                    Map.Entry entry = (Map.Entry) reqIter.next();\n                    ResolvedPackage rp = (ResolvedPackage) pkgMap.get(entry.getKey());\n                    if (rp != null)\n                    {\n                        // Create the union of all package sources.\n                        ResolvedPackage rpReq = (ResolvedPackage) entry.getValue();\n                        rp.m_sourceSet.addAll(rpReq.m_sourceSet);\n                    }\n                    else\n                    {\n                        pkgMap.put(entry.getKey(), entry.getValue());\n                    }\n                }\n            }\n        }\n\n        // Loop through all export package capabilities and merge them\n        // into the package map adding the original target as a source.\n        ICapability[] candCaps = psTarget.m_module.getDefinition().getCapabilities();\n        for (int capIdx = 0; (candCaps != null) && (capIdx < candCaps.length); capIdx++)\n        {\n            if (candCaps[capIdx].getNamespace().equals(ICapability.PACKAGE_NAMESPACE))\n            {\n                String pkgName = (String)\n                    candCaps[capIdx].getProperties().get(ICapability.PACKAGE_PROPERTY);\n                ResolvedPackage rp = (ResolvedPackage) pkgMap.get(pkgName);\n                rp = (rp == null) ? new ResolvedPackage(pkgName) : rp;\n                rp.m_sourceSet.add(new PackageSource(psTarget.m_module, candCaps[capIdx]));\n                pkgMap.put(rp.m_name, rp);\n            }\n        }\n\n        return pkgMap;\n    }","commit_id":"9d428f74fa209ea6dd91f3a1ea0bc1c937bad14e","url":"https://github.com/apache/felix"},{"original_method":"public void resolve(IModule rootModule)\n        throws ResolveException\n    {\n        // If the module is already resolved, then we can just return.\n        if (isResolved(rootModule))\n        {\n            return;\n        }\n\n        // This variable maps an unresolved module to a list of candidate\n        // sets, where there is one candidate set for each requirement that\n        // must be resolved. A candidate set contains the potential canidates\n        // available to resolve the requirement and the currently selected\n        // candidate index.\n        Map resolverMap = new HashMap();\n\n        // This map will be used to hold the final wires for all\n        // resolved modules, which can then be used to fire resolved\n        // events outside of the synchronized block.\n        Map resolvedModuleWireMap = null;\n\n        // Synchronize on the module manager, because we don't want\n        // any modules being added or removed while we are in the\n        // middle of this operation.\n        synchronized (m_factory)\n        {\n            // The first step is to populate the resolver map. This\n            // will use the target module to populate the resolver map\n            // with all potential modules that need to be resolved as a\n            // result of resolving the target module. The key of the\n            // map is a potential module to be resolved and the value is\n            // a list of candidate sets, one for each of the module's\n            // requirements, where each candidate set contains the potential\n            // candidates for resolving the requirement. Not all modules in\n            // this map will be resolved, only the target module and\n            // any candidates selected to resolve its requirements and the\n            // transitive requirements this implies.\n            populateResolverMap(resolverMap, rootModule);\n\n            // The next step is to use the resolver map to determine if\n            // the class space for the root module is consistent. This\n            // is an iterative process that transitively walks the \"uses\"\n            // relationships of all currently selected potential candidates\n            // for resolving import packages checking for conflicts. If a\n            // conflict is found, it \"increments\" the configuration of\n            // currently selected potential candidates and tests them again.\n            // If this method returns, then it has found a consistent set\n            // of candidates; otherwise, a resolve exception is thrown if\n            // it exhausts all possible combinations and could not find a\n            // consistent class space.\n            findConsistentClassSpace(resolverMap, rootModule);\n\n            // The final step is to create the wires for the root module and\n            // transitively all modules that are to be resolved from the\n            // selected candidates for resolving the root module's imports.\n            // When this call returns, each module's wiring and resolved\n            // attributes are set. The resulting wiring map is used below\n            // to fire resolved events outside of the synchronized block.\n            // The resolved module wire map maps a module to its array of\n            // wires.\n            resolvedModuleWireMap = createWires(resolverMap, rootModule);\n\n//dumpUsedPackages();\n        } // End of synchronized block on module manager.\n\n        // Fire resolved events for all resolved modules;\n        // the resolved modules array will only be set if the resolve\n        // was successful after the root module was resolved.\n        if (resolvedModuleWireMap != null)\n        {\n            Iterator iter = resolvedModuleWireMap.entrySet().iterator();\n            while (iter.hasNext())\n            {\n                fireModuleResolved((IModule) ((Map.Entry) iter.next()).getKey());\n            }\n        }\n    }","id":33262,"modified_method":"public void resolve(IModule rootModule)\n        throws ResolveException\n    {\n        // If the module is already resolved, then we can just return.\n        if (isResolved(rootModule))\n        {\n            return;\n        }\n\n        // This variable maps an unresolved module to a list of candidate\n        // sets, where there is one candidate set for each requirement that\n        // must be resolved. A candidate set contains the potential canidates\n        // available to resolve the requirement and the currently selected\n        // candidate index.\n        Map candidatesMap = new HashMap();\n\n        // This map will be used to hold the final wires for all\n        // resolved modules, which can then be used to fire resolved\n        // events outside of the synchronized block.\n        Map resolvedModuleWireMap = null;\n\n        // Synchronize on the module manager, because we don't want\n        // any modules being added or removed while we are in the\n        // middle of this operation.\n        synchronized (m_factory)\n        {\n            // The first step is to populate the candidates map. This\n            // will use the target module to populate the candidates map\n            // with all potential modules that need to be resolved as a\n            // result of resolving the target module. The key of the\n            // map is a potential module to be resolved and the value is\n            // a list of candidate sets, one for each of the module's\n            // requirements, where each candidate set contains the potential\n            // candidates for resolving the requirement. Not all modules in\n            // this map will be resolved, only the target module and\n            // any candidates selected to resolve its requirements and the\n            // transitive requirements this implies.\n            populateCandidatesMap(candidatesMap, rootModule);\n\n            // The next step is to use the candidates map to determine if\n            // the class space for the root module is consistent. This\n            // is an iterative process that transitively walks the \"uses\"\n            // relationships of all packages visible from the root module\n            // checking for conflicts. If a conflict is found, it \"increments\"\n            // the configuration of currently selected potential candidates\n            // and tests them again. If this method returns, then it has found\n            // a consistent set of candidates; otherwise, a resolve exception\n            // is thrown if it exhausts all possible combinations and could\n            // not find a consistent class space.\n            findConsistentClassSpace(candidatesMap, rootModule);\n\n            // The final step is to create the wires for the root module and\n            // transitively all modules that are to be resolved from the\n            // selected candidates for resolving the root module's imports.\n            // When this call returns, each module's wiring and resolved\n            // attributes are set. The resulting wiring map is used below\n            // to fire resolved events outside of the synchronized block.\n            // The resolved module wire map maps a module to its array of\n            // wires.\n            resolvedModuleWireMap = createWires(candidatesMap, rootModule);\n\n//dumpUsedPackages();\n        } // End of synchronized block on module manager.\n\n        // Fire resolved events for all resolved modules;\n        // the resolved modules array will only be set if the resolve\n        // was successful after the root module was resolved.\n        if (resolvedModuleWireMap != null)\n        {\n            Iterator iter = resolvedModuleWireMap.entrySet().iterator();\n            while (iter.hasNext())\n            {\n                fireModuleResolved((IModule) ((Map.Entry) iter.next()).getKey());\n            }\n        }\n    }","commit_id":"9d428f74fa209ea6dd91f3a1ea0bc1c937bad14e","url":"https://github.com/apache/felix"},{"original_method":"private void findConsistentClassSpace(Map resolverMap, IModule rootModule)\n        throws ResolveException\n    {\n        List resolverList = null;\n\n        Map moduleMap = new HashMap();\n\n        // Test the current set of candidates to determine if they\n        // are consistent. Keep looping until we find a consistent\n        // set or an exception is thrown.\n        Map cycleMap = new HashMap();\n        while (!isClassSpaceConsistent(rootModule, moduleMap, cycleMap, resolverMap))\n        {\n            // The incrementCandidateConfiguration() method requires an\n            // ordered access to the resolver map, so we will create\n            // a reusable list once right here.\n            if (resolverList == null)\n            {\n                resolverList = new ArrayList();\n                for (Iterator iter = resolverMap.entrySet().iterator();\n                    iter.hasNext(); )\n                {\n                    resolverList.add((List) ((Map.Entry) iter.next()).getValue());\n                }\n            }\n\n            // Increment the candidate configuration so we can test again.\n            incrementCandidateConfiguration(resolverList);\n\n            // Clear the module map.\n            moduleMap.clear();\n\n            // Clear the cycle map.\n            cycleMap.clear();\n        }\n    }","id":33263,"modified_method":"private void findConsistentClassSpace(Map candidatesMap, IModule rootModule)\n        throws ResolveException\n    {\n        List candidatesList = null;\n\n        // The module map maps a module to a map of resolved\n        // packages that are accessible by the given module.\n        // The set of resolved packages is calculated from the\n        // current candidates of the candidates map and the\n        // module's metadata.\n        Map moduleMap = new HashMap();\n\n        // Reusable map used to test for cycles.\n        Map cycleMap = new HashMap();\n\n        // Test the current potential candidates to determine if they\n        // are consistent. Keep looping until we find a consistent\n        // set or an exception is thrown.\n        while (!isClassSpaceConsistent(rootModule, moduleMap, cycleMap, candidatesMap))\n        {\n            // The incrementCandidateConfiguration() method requires\n            // ordered access to the candidates map, so we will create\n            // a reusable list once right here.\n            if (candidatesList == null)\n            {\n                candidatesList = new ArrayList();\n                for (Iterator iter = candidatesMap.entrySet().iterator();\n                    iter.hasNext(); )\n                {\n                    candidatesList.add((List) ((Map.Entry) iter.next()).getValue());\n                }\n            }\n\n            // Increment the candidate configuration so we can test again.\n            incrementCandidateConfiguration(candidatesList);\n\n            // Clear the module map.\n            moduleMap.clear();\n\n            // Clear the cycle map.\n            cycleMap.clear();\n        }\n    }","commit_id":"9d428f74fa209ea6dd91f3a1ea0bc1c937bad14e","url":"https://github.com/apache/felix"},{"original_method":"private Map calculateImportedPackages(IModule module, Map resolverMap)\n    {\n        return (resolverMap.get(module) == null)\n            ? calculateImportedPackagesResolved(module)\n            : calculateImportedPackagesUnresolved(module, resolverMap);\n    }","id":33264,"modified_method":"private Map calculateImportedPackages(IModule module, Map candidatesMap)\n    {\n        return (candidatesMap.get(module) == null)\n            ? calculateImportedPackagesResolved(module)\n            : calculateImportedPackagesUnresolved(module, candidatesMap);\n    }","commit_id":"9d428f74fa209ea6dd91f3a1ea0bc1c937bad14e","url":"https://github.com/apache/felix"},{"original_method":"private Map calculateUsesConstraints(IModule rootModule, Map moduleMap, Map resolverMap)\n    {\n//System.out.println(\"calculateUsesConstraints(\"+rootModule+\")\");\n        Map usesMap = new HashMap();\n\n        // For each package reachable from the root module, calculate the uses\n        // constraints from all of the sources for that particular package.\n        Map pkgMap = getModulePackages(moduleMap, rootModule, resolverMap);\n        for (Iterator iter = pkgMap.entrySet().iterator(); iter.hasNext(); )\n        {\n            Map.Entry entry = (Map.Entry) iter.next();\n            ResolvedPackage rp = (ResolvedPackage) entry.getValue();\n            for (Iterator srcIter = rp.m_sourceSet.iterator(); srcIter.hasNext(); )\n            {\n                usesMap = calculateUsesConstraints(\n                    (PackageSource) srcIter.next(),\n                    moduleMap, usesMap, new HashMap(), resolverMap);\n            }\n        }\n        return usesMap;\n    }","id":33265,"modified_method":"private Map calculateUsesConstraints(IModule rootModule, Map moduleMap, Map candidatesMap)\n    {\n//System.out.println(\"calculateUsesConstraints(\"+rootModule+\")\");\n        // Map to store calculated uses constraints. This maps a\n        // package name to a list of resolved packages, where each\n        // resolved package represents a constraint on anyone\n        // importing the given package name. This map is returned\n        // by this method.\n        Map usesMap = new HashMap();\n\n        // Re-usable map to detect cycles.\n        Map cycleMap = new HashMap();\n\n        // Get all packages accessible by the root module.\n        Map pkgMap = getModulePackages(moduleMap, rootModule, candidatesMap);\n\n        // Each package accessible from the root module is potentially\n        // comprised of one or more modules, called package sources. The\n        // \"uses\" constraints implied by all package sources must be\n        // calculated and combined to determine the complete set of implied\n        // \"uses\" constraints for each package accessible by the root module.\n        for (Iterator iter = pkgMap.entrySet().iterator(); iter.hasNext(); )\n        {\n            Map.Entry entry = (Map.Entry) iter.next();\n            ResolvedPackage rp = (ResolvedPackage) entry.getValue();\n            for (Iterator srcIter = rp.m_sourceSet.iterator(); srcIter.hasNext(); )\n            {\n                usesMap = calculateUsesConstraints(\n                    (PackageSource) srcIter.next(),\n                    moduleMap, usesMap, cycleMap, candidatesMap);\n            }\n        }\n        return usesMap;\n    }","commit_id":"9d428f74fa209ea6dd91f3a1ea0bc1c937bad14e","url":"https://github.com/apache/felix"},{"original_method":"public CopySpec with(CopySpec... sourceSpecs) {\n        return delegate.with(sourceSpecs);\n    }","id":33266,"modified_method":"public CopySpec with(CopySpec... sourceSpecs) {\n        delegate.with(sourceSpecs);\n        return this;\n    }","commit_id":"025bc6d6409fa4865242e4f413ad7165da5c8546","url":"https://github.com/gradle/gradle"},{"original_method":"public CopySpec rename(String sourceRegEx, String replaceWith) {\n        return delegate.rename(sourceRegEx, replaceWith);\n    }","id":33267,"modified_method":"public CopySpec rename(String sourceRegEx, String replaceWith) {\n        delegate.rename(sourceRegEx, replaceWith);\n        return this;\n    }","commit_id":"025bc6d6409fa4865242e4f413ad7165da5c8546","url":"https://github.com/gradle/gradle"},{"original_method":"public CopySpec rename(Closure closure) {\n        return delegate.rename(closure);\n    }","id":33268,"modified_method":"public CopySpec rename(Closure closure) {\n        delegate.rename(closure);\n        return this;\n    }","commit_id":"025bc6d6409fa4865242e4f413ad7165da5c8546","url":"https://github.com/gradle/gradle"},{"original_method":"public CopySpec setIncludes(Iterable<String> includes) {\n        return delegate.setIncludes(includes);\n    }","id":33269,"modified_method":"public CopySpec setIncludes(Iterable<String> includes) {\n        delegate.setIncludes(includes);\n        return this;\n    }","commit_id":"025bc6d6409fa4865242e4f413ad7165da5c8546","url":"https://github.com/gradle/gradle"},{"original_method":"public CopySpec exclude(Closure excludeSpec) {\n        return delegate.exclude(excludeSpec);\n    }","id":33270,"modified_method":"public CopySpec exclude(Closure excludeSpec) {\n        delegate.exclude(excludeSpec);\n        return this;\n    }","commit_id":"025bc6d6409fa4865242e4f413ad7165da5c8546","url":"https://github.com/gradle/gradle"},{"original_method":"public CopyProcessingSpec rename(Pattern sourceRegEx, String replaceWith) {\n        return delegate.rename(sourceRegEx, replaceWith);\n    }","id":33271,"modified_method":"public CopyProcessingSpec rename(Pattern sourceRegEx, String replaceWith) {\n        delegate.rename(sourceRegEx, replaceWith);\n        return this;\n    }","commit_id":"025bc6d6409fa4865242e4f413ad7165da5c8546","url":"https://github.com/gradle/gradle"},{"original_method":"public CopySpec filesNotMatching(String pattern, Action<? super FileCopyDetails> action) {\n        return delegate.filesNotMatching(pattern, action);\n    }","id":33272,"modified_method":"public CopySpec filesNotMatching(String pattern, Action<? super FileCopyDetails> action) {\n        delegate.filesNotMatching(pattern, action);\n        return this;\n    }","commit_id":"025bc6d6409fa4865242e4f413ad7165da5c8546","url":"https://github.com/gradle/gradle"},{"original_method":"public CopySpec filter(Class<? extends FilterReader> filterType) {\n        return delegate.filter(filterType);\n    }","id":33273,"modified_method":"public CopySpec filter(Class<? extends FilterReader> filterType) {\n        delegate.filter(filterType);\n        return this;\n    }","commit_id":"025bc6d6409fa4865242e4f413ad7165da5c8546","url":"https://github.com/gradle/gradle"},{"original_method":"public CopySpec into(Object destPath) {\n        return delegate.into(destPath);\n    }","id":33274,"modified_method":"public CopySpec into(Object destPath) {\n        delegate.into(destPath);\n        return this;\n    }","commit_id":"025bc6d6409fa4865242e4f413ad7165da5c8546","url":"https://github.com/gradle/gradle"},{"original_method":"public CopySpec filesMatching(String pattern, Action<? super FileCopyDetails> action) {\n        return delegate.filesMatching(pattern, action);\n    }","id":33275,"modified_method":"public CopySpec filesMatching(String pattern, Action<? super FileCopyDetails> action) {\n        delegate.filesMatching(pattern, action);\n        return this;\n    }","commit_id":"025bc6d6409fa4865242e4f413ad7165da5c8546","url":"https://github.com/gradle/gradle"},{"original_method":"public CopyProcessingSpec setDirMode(Integer mode) {\n        return delegate.setDirMode(mode);\n    }","id":33276,"modified_method":"public CopyProcessingSpec setDirMode(Integer mode) {\n        delegate.setDirMode(mode);\n        return this;\n    }","commit_id":"025bc6d6409fa4865242e4f413ad7165da5c8546","url":"https://github.com/gradle/gradle"},{"original_method":"public CopySpec include(Spec<FileTreeElement> includeSpec) {\n        return delegate.include(includeSpec);\n    }","id":33277,"modified_method":"public CopySpec include(Spec<FileTreeElement> includeSpec) {\n        delegate.include(includeSpec);\n        return this;\n    }","commit_id":"025bc6d6409fa4865242e4f413ad7165da5c8546","url":"https://github.com/gradle/gradle"},{"original_method":"public CopySpec include(String... includes) {\n        return delegate.include(includes);\n    }","id":33278,"modified_method":"public CopySpec include(String... includes) {\n        delegate.include(includes);\n        return this;\n    }","commit_id":"025bc6d6409fa4865242e4f413ad7165da5c8546","url":"https://github.com/gradle/gradle"},{"original_method":"public CopySpec filter(Map<String, ?> properties, Class<? extends FilterReader> filterType) {\n        return delegate.filter(properties, filterType);\n    }","id":33279,"modified_method":"public CopySpec filter(Map<String, ?> properties, Class<? extends FilterReader> filterType) {\n        delegate.filter(properties, filterType);\n        return this;\n    }","commit_id":"025bc6d6409fa4865242e4f413ad7165da5c8546","url":"https://github.com/gradle/gradle"},{"original_method":"public CopyProcessingSpec setFileMode(Integer mode) {\n        return delegate.setFileMode(mode);\n    }","id":33280,"modified_method":"public CopyProcessingSpec setFileMode(Integer mode) {\n        delegate.setFileMode(mode);\n        return this;\n    }","commit_id":"025bc6d6409fa4865242e4f413ad7165da5c8546","url":"https://github.com/gradle/gradle"},{"original_method":"public CopySpec exclude(Spec<FileTreeElement> excludeSpec) {\n        return delegate.exclude(excludeSpec);\n    }","id":33281,"modified_method":"public CopySpec exclude(Spec<FileTreeElement> excludeSpec) {\n        delegate.exclude(excludeSpec);\n        return this;\n    }","commit_id":"025bc6d6409fa4865242e4f413ad7165da5c8546","url":"https://github.com/gradle/gradle"},{"original_method":"public CopySpec setExcludes(Iterable<String> excludes) {\n        return delegate.setExcludes(excludes);\n    }","id":33282,"modified_method":"public CopySpec setExcludes(Iterable<String> excludes) {\n        delegate.setExcludes(excludes);\n        return this;\n    }","commit_id":"025bc6d6409fa4865242e4f413ad7165da5c8546","url":"https://github.com/gradle/gradle"},{"original_method":"public CopySpec eachFile(Closure closure) {\n        return delegate.eachFile(closure);\n    }","id":33283,"modified_method":"public CopySpec eachFile(Closure closure) {\n        delegate.eachFile(closure);\n        return this;\n    }","commit_id":"025bc6d6409fa4865242e4f413ad7165da5c8546","url":"https://github.com/gradle/gradle"},{"original_method":"public CopySpec include(Iterable<String> includes) {\n        return delegate.include(includes);\n    }","id":33284,"modified_method":"public CopySpec include(Iterable<String> includes) {\n        delegate.include(includes);\n        return this;\n    }","commit_id":"025bc6d6409fa4865242e4f413ad7165da5c8546","url":"https://github.com/gradle/gradle"},{"original_method":"public CopySpec filter(Closure closure) {\n        return delegate.filter(closure);\n    }","id":33285,"modified_method":"public CopySpec filter(Closure closure) {\n        delegate.filter(closure);\n        return this;\n    }","commit_id":"025bc6d6409fa4865242e4f413ad7165da5c8546","url":"https://github.com/gradle/gradle"},{"original_method":"public CopySpec expand(Map<String, ?> properties) {\n        return delegate.expand(properties);\n    }","id":33286,"modified_method":"public CopySpec expand(Map<String, ?> properties) {\n        delegate.expand(properties);\n        return this;\n    }","commit_id":"025bc6d6409fa4865242e4f413ad7165da5c8546","url":"https://github.com/gradle/gradle"},{"original_method":"public CopySpec eachFile(Action<? super FileCopyDetails> action) {\n        return delegate.eachFile(action);\n    }","id":33287,"modified_method":"public CopySpec eachFile(Action<? super FileCopyDetails> action) {\n        delegate.eachFile(action);\n        return this;\n    }","commit_id":"025bc6d6409fa4865242e4f413ad7165da5c8546","url":"https://github.com/gradle/gradle"},{"original_method":"public CopySpec from(Object... sourcePaths) {\n        return delegate.from(sourcePaths);\n    }","id":33288,"modified_method":"public CopySpec from(Object... sourcePaths) {\n        delegate.from(sourcePaths);\n        return this;\n    }","commit_id":"025bc6d6409fa4865242e4f413ad7165da5c8546","url":"https://github.com/gradle/gradle"},{"original_method":"public CopySpec exclude(String... excludes) {\n        return delegate.exclude(excludes);\n    }","id":33289,"modified_method":"public CopySpec exclude(String... excludes) {\n        delegate.exclude(excludes);\n        return this;\n    }","commit_id":"025bc6d6409fa4865242e4f413ad7165da5c8546","url":"https://github.com/gradle/gradle"},{"original_method":"public CopySpec include(Closure includeSpec) {\n        return delegate.include(includeSpec);\n    }","id":33290,"modified_method":"public CopySpec include(Closure includeSpec) {\n        delegate.include(includeSpec);\n        return this;\n    }","commit_id":"025bc6d6409fa4865242e4f413ad7165da5c8546","url":"https://github.com/gradle/gradle"},{"original_method":"public CopySpec exclude(Iterable<String> excludes) {\n        return delegate.exclude(excludes);\n    }","id":33291,"modified_method":"public CopySpec exclude(Iterable<String> excludes) {\n        delegate.exclude(excludes);\n        return this;\n    }","commit_id":"025bc6d6409fa4865242e4f413ad7165da5c8546","url":"https://github.com/gradle/gradle"},{"original_method":"@NotNull\n  protected FluentIterable<T> rawIterableImpl() {\n    return preOrderTraversal(getRoot());\n  }","id":33292,"modified_method":"@NotNull\n  protected FluentIterable<T> rawIterableImpl() {\n    return preOrderTraversal(getRoots());\n  }","commit_id":"d6e845760a5b1910ac17cb210068c04104be2527","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public Self reset() {\n    Meta<T> meta = FilteredTraverser.<T>emptyMeta().exclude(myMeta.excludeFilter);\n    return newInstance(myMeta.rootNode == null ? meta : meta.withRoot(myMeta.rootNode));\n  }","id":33293,"modified_method":"@NotNull\n  public Self reset() {\n    return newInstance(FilteredTraverser.<T>emptyMeta().exclude(myMeta.excludeFilter).withRoots(myMeta.roots));\n  }","commit_id":"d6e845760a5b1910ac17cb210068c04104be2527","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Meta<T> expand(@NotNull Condition<? super T> filter) {\n      return new Meta<T>(rootNode, skipExpanded, Conditions.and2(expandFilter, filter), resultFilter, excludeFilter);\n    }","id":33294,"modified_method":"public Meta<T> expand(@NotNull Condition<? super T> filter) {\n      return new Meta<T>(roots, skipExpanded, Conditions.and2(expandFilter, filter), resultFilter, excludeFilter);\n    }","commit_id":"d6e845760a5b1910ac17cb210068c04104be2527","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Meta<T> skipExpanded(boolean skip) {\n      return new Meta<T>(rootNode, skip, expandFilter, resultFilter, excludeFilter);\n    }","id":33295,"modified_method":"public Meta<T> skipExpanded(boolean skip) {\n      return new Meta<T>(roots, skip, expandFilter, resultFilter, excludeFilter);\n    }","commit_id":"d6e845760a5b1910ac17cb210068c04104be2527","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public Self withRoot(@NotNull T root) {\n    return newInstance(myMeta.withRoot(root));\n  }","id":33296,"modified_method":"@NotNull\n  public Self withRoot(@NotNull T root) {\n    return newInstance(myMeta.withRoots(Collections.singleton(root)));\n  }","commit_id":"d6e845760a5b1910ac17cb210068c04104be2527","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static <T> Meta<T> emptyMeta() {\n    return new Meta<T>(null, false,\n                       Conditions.alwaysTrue(),\n                       Conditions.alwaysTrue(),\n                       Conditions.alwaysFalse());\n  }","id":33297,"modified_method":"protected static <T> Meta<T> emptyMeta() {\n    return new Meta<T>(EmptyIterable.<T>getInstance(), false,\n                       Conditions.alwaysTrue(),\n                       Conditions.alwaysTrue(),\n                       Conditions.alwaysFalse());\n  }","commit_id":"d6e845760a5b1910ac17cb210068c04104be2527","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Meta<T> exclude(Condition<? super T> filter) {\n      // exclude filter is always accumulated\n      return new Meta<T>(rootNode, skipExpanded, expandFilter, resultFilter, Conditions.or2(excludeFilter, filter));\n    }","id":33298,"modified_method":"public Meta<T> exclude(Condition<? super T> filter) {\n      // exclude filter is always accumulated\n      return new Meta<T>(roots, skipExpanded, expandFilter, resultFilter, Conditions.or2(excludeFilter, filter));\n    }","commit_id":"d6e845760a5b1910ac17cb210068c04104be2527","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public T getRoot() {\n    return ObjectUtils.assertNotNull(myMeta.rootNode);\n  }","id":33299,"modified_method":"@NotNull\n  public T getRoot() {\n    return myMeta.roots.iterator().next();\n  }","commit_id":"d6e845760a5b1910ac17cb210068c04104be2527","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public FluentIterable<T> children(@NotNull T node) {\n    if (node != myMeta.rootNode && !myMeta.expandFilter.value(node)) {\n      return FluentIterable.from(Collections.<T>emptyList());\n    }\n    return FluentIterable.from(childrenImpl(node)).filter(Conditions.not(myMeta.excludeFilter));\n  }","id":33300,"modified_method":"@NotNull\n  @Override\n  public FluentIterable<T> children(@NotNull T node) {\n    if (!myMeta.expandFilter.value(node) && !Conditions.oneOf(myMeta.roots).value(node)) {\n      return FluentIterable.from(Collections.<T>emptyList());\n    }\n    return FluentIterable.from(childrenImpl(node)).filter(Conditions.not(myMeta.excludeFilter));\n  }","commit_id":"d6e845760a5b1910ac17cb210068c04104be2527","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private Condition<? super T> newResultFilter() {\n    if (!myMeta.skipExpanded) return myMeta.resultFilter;\n    return Conditions.and2(Conditions.not(Conditions.or2(Conditions.is(myMeta.rootNode), myMeta.expandFilter)), myMeta.resultFilter);\n  }","id":33301,"modified_method":"@NotNull\n  private Condition<? super T> newResultFilter() {\n    if (!myMeta.skipExpanded) return myMeta.resultFilter;\n    return Conditions.and2(Conditions.not(Conditions.or2(Conditions.oneOf(myMeta.roots), myMeta.expandFilter)), myMeta.resultFilter);\n  }","commit_id":"d6e845760a5b1910ac17cb210068c04104be2527","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Meta<T> filter(@NotNull Condition<? super T> filter) {\n      return new Meta<T>(rootNode, skipExpanded, expandFilter, Conditions.and2(resultFilter, filter), excludeFilter);\n    }","id":33302,"modified_method":"public Meta<T> filter(@NotNull Condition<? super T> filter) {\n      return new Meta<T>(roots, skipExpanded, expandFilter, Conditions.and2(resultFilter, filter), excludeFilter);\n    }","commit_id":"d6e845760a5b1910ac17cb210068c04104be2527","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Meta(@Nullable T rootNode,\n                boolean skipExpanded,\n                @NotNull Condition<? super T> expandFilter,\n                @NotNull Condition<? super T> resultFilter,\n                @NotNull Condition<? super T> excludeFilter) {\n      this.rootNode = rootNode;\n      this.skipExpanded = skipExpanded;\n      this.expandFilter = expandFilter;\n      this.resultFilter = resultFilter;\n      this.excludeFilter = excludeFilter;\n    }","id":33303,"modified_method":"public Meta(@NotNull Iterable<? extends T> roots,\n                boolean skipExpanded,\n                @NotNull Condition<? super T> expandFilter,\n                @NotNull Condition<? super T> resultFilter,\n                @NotNull Condition<? super T> excludeFilter) {\n      this.roots = roots;\n      this.skipExpanded = skipExpanded;\n      this.expandFilter = expandFilter;\n      this.resultFilter = resultFilter;\n      this.excludeFilter = excludeFilter;\n    }","commit_id":"d6e845760a5b1910ac17cb210068c04104be2527","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static SyntaxTraverser<LighterASTNode> lightTraverser(PsiBuilder builder) {\n    FlyweightCapableTreeStructure<LighterASTNode> lightTree = builder.getLightTree();\n    Meta<LighterASTNode> meta = FilteredTraverser.<LighterASTNode>emptyMeta().withRoot(lightTree.getRoot());\n    return new LightASTTraverser(meta, builder.getOriginalText(), lightTree);\n  }","id":33304,"modified_method":"@NotNull\n  public static SyntaxTraverser<LighterASTNode> lightTraverser(PsiBuilder builder) {\n    FlyweightCapableTreeStructure<LighterASTNode> lightTree = builder.getLightTree();\n    Meta<LighterASTNode> meta = FilteredTraverser.<LighterASTNode>emptyMeta().withRoots(Collections.singletonList(lightTree.getRoot()));\n    return new LightASTTraverser(meta, builder.getOriginalText(), lightTree);\n  }","commit_id":"d6e845760a5b1910ac17cb210068c04104be2527","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Returns value of the property of the resource.\n     * \n     * @param propertyName the name of the property to read \n     * @return the value of the secure property of the resource\n     */\n    public String readProperty(String propertyName) {\n\n        String propVal = null;\n        try {\n            propVal = getCms().readPropertyObject(getParamResource(), propertyName, true).getValue();\n        } catch (CmsException e) {\n            if (OpenCms.getLog(this).isInfoEnabled()) {\n                OpenCms.getLog(this).info(e);\n            }\n        }\n        if (CmsStringUtil.isEmpty(propVal)) {\n            propVal = \"\";\n        }\n        return propVal;\n    }","id":33305,"modified_method":"/**\n     * Returns value of the property of the resource.\n     * \n     * @param propertyName the name of the property to read \n     * @return the value of the secure property of the resource\n     */\n    public String readProperty(String propertyName) {\n\n        String propVal = null;\n        try {\n            propVal = getCms().readPropertyObject(getParamResource(), propertyName, false).getValue();\n        } catch (CmsException e) {\n            if (OpenCms.getLog(this).isInfoEnabled()) {\n                OpenCms.getLog(this).info(e);\n            }\n        }\n        if (CmsStringUtil.isEmpty(propVal)) {\n            propVal = \"\";\n        }\n        return propVal;\n    }","commit_id":"8f2082421326d1e4f3d525d69a4d24407abf2e83","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Performs the Security and Export Change.<p>\n     * \n     * @throws JspException if including a JSP subelement is not successful\n     */\n    public void actionChangeSecureExport() throws JspException {\n\n        // save initialized instance of this class in request attribute for included sub-elements\n        getJsp().getRequest().setAttribute(C_SESSION_WORKPLACE_CLASS, this);\n\n        String filename = getParamResource();\n\n        try {\n            // lock resource if autolock is enabled\n            checkLock(getParamResource());\n\n            // write the properties\n            writeProperty(I_CmsConstants.C_PROPERTY_EXPORT, getParamExport());\n            writeProperty(I_CmsConstants.C_PROPERTY_EXPORTNAME, getParamExportname());\n            writeProperty(I_CmsConstants.C_PROPERTY_SECURE, getParamSecure());\n\n            // change the flag of the resource so that it is internal            \n            CmsResource resource = getCms().readResource(filename);\n            if (\"true\".equals(getParamIntern())) {\n                getCms().chflags(filename, resource.getFlags() | I_CmsConstants.C_RESOURCEFLAG_INTERNAL);\n            } else {\n                getCms().chflags(filename, resource.getFlags() & (~I_CmsConstants.C_RESOURCEFLAG_INTERNAL));\n            }\n\n            actionCloseDialog();\n        } catch (CmsException e) {\n            // error during change of settings, show error dialog\n            setParamErrorstack(e.getStackTraceAsString());\n            setParamMessage(key(\"error.message.\" + getParamDialogtype()));\n            setParamReasonSuggestion(getErrorSuggestionDefault());\n            getJsp().include(C_FILE_DIALOG_SCREEN_ERROR);\n\n        }\n\n    }","id":33306,"modified_method":"/**\n     * Performs the Security and Export Change.<p>\n     * \n     * @throws JspException if including a JSP subelement is not successful\n     */\n    public void actionChangeSecureExport() throws JspException {\n\n        // save initialized instance of this class in request attribute for included sub-elements\n        getJsp().getRequest().setAttribute(C_SESSION_WORKPLACE_CLASS, this);\n\n        String filename = getParamResource();\n\n        try {\n            // lock resource if autolock is enabled\n            checkLock(getParamResource());\n\n            // write the properties\n            writeProperty(I_CmsConstants.C_PROPERTY_EXPORT, getParamExport());\n            writeProperty(I_CmsConstants.C_PROPERTY_EXPORTNAME, getParamExportname());\n            writeProperty(I_CmsConstants.C_PROPERTY_SECURE, getParamSecure());\n\n            // change the flag of the resource so that it is internal            \n            CmsResource resource = getCms().readResource(filename);\n            if (resource.isInternal() && !Boolean.valueOf(getParamIntern()).booleanValue()) {\n                getCms().chflags(filename, resource.getFlags() & (~I_CmsConstants.C_RESOURCEFLAG_INTERNAL));\n            } else if (!resource.isInternal() && Boolean.valueOf(getParamIntern()).booleanValue()) {\n                getCms().chflags(filename, resource.getFlags() | I_CmsConstants.C_RESOURCEFLAG_INTERNAL);\n            }\n\n            actionCloseDialog();\n        } catch (CmsException e) {\n            // error during change of settings, show error dialog\n            setParamErrorstack(e.getStackTraceAsString());\n            setParamMessage(key(\"error.message.\" + getParamDialogtype()));\n            setParamReasonSuggestion(getErrorSuggestionDefault());\n            getJsp().include(C_FILE_DIALOG_SCREEN_ERROR);\n\n        }\n\n    }","commit_id":"8f2082421326d1e4f3d525d69a4d24407abf2e83","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Writes a property value for a resource.<p>\n     * \n     * @param propertyName the name of the property\n     * @param propertyValue the new value of the property\n     * @throws JspException  if including a JSP subelement is not successful\n     */\n    protected void writeProperty(String propertyName, String propertyValue) throws JspException {\n\n        try {\n            if (CmsStringUtil.isEmpty(propertyValue)) {\n                propertyValue = CmsProperty.C_DELETE_VALUE;\n            }\n\n            CmsProperty newProp = new CmsProperty();\n            newProp.setName(propertyName);\n            CmsProperty oldProp = getCms().readPropertyObject(getParamResource(), propertyName, false);\n            if (oldProp.isNullProperty()) {\n                // property value was not already set\n                if (OpenCms.getWorkplaceManager().isDefaultPropertiesOnStructure()) {\n                    newProp.setStructureValue(propertyValue);\n                } else {\n                    newProp.setResourceValue(propertyValue);\n                }\n            } else {\n                if (oldProp.getStructureValue() != null) {\n                    newProp.setStructureValue(propertyValue);\n                    newProp.setResourceValue(oldProp.getResourceValue());\n                } else {\n                    newProp.setResourceValue(propertyValue);\n                }\n            }\n            newProp.setAutoCreatePropertyDefinition(true);\n            getCms().writePropertyObject(getParamResource(), newProp);\n\n        } catch (CmsException e) {\n            // error during chnav, show error dialog\n            setParamErrorstack(e.getStackTraceAsString());\n            setParamMessage(key(\"error.message.\" + getParamDialogtype()));\n            setParamReasonSuggestion(getErrorSuggestionDefault());\n            getJsp().include(C_FILE_DIALOG_SCREEN_ERROR);\n\n        }\n    }","id":33307,"modified_method":"/**\n     * Writes a property value for a resource.<p>\n     * \n     * @param propertyName the name of the property\n     * @param propertyValue the new value of the property\n     * @throws JspException  if including a JSP subelement is not successful\n     */\n    protected void writeProperty(String propertyName, String propertyValue) throws JspException {\n\n        try {\n            if (CmsStringUtil.isEmpty(propertyValue)) {\n                propertyValue = CmsProperty.C_DELETE_VALUE;\n            }\n\n            CmsProperty newProp = new CmsProperty();\n            newProp.setName(propertyName);\n            CmsProperty oldProp = getCms().readPropertyObject(getParamResource(), propertyName, false);\n            if (oldProp.isNullProperty()) {\n                // property value was not already set\n                if (OpenCms.getWorkplaceManager().isDefaultPropertiesOnStructure()) {\n                    newProp.setStructureValue(propertyValue);\n                } else {\n                    newProp.setResourceValue(propertyValue);\n                }\n            } else {\n                if (oldProp.getStructureValue() != null) {\n                    newProp.setStructureValue(propertyValue);\n                    newProp.setResourceValue(oldProp.getResourceValue());\n                } else {\n                    newProp.setResourceValue(propertyValue);\n                }\n            }\n\n            newProp.setAutoCreatePropertyDefinition(true);\n\n            String oldStructureValue = oldProp.getStructureValue();\n            String newStructureValue = newProp.getStructureValue();\n            if (CmsStringUtil.isEmpty(oldStructureValue)) {\n                oldStructureValue = CmsProperty.C_DELETE_VALUE;\n            }\n            if (CmsStringUtil.isEmpty(newStructureValue)) {\n                newStructureValue = CmsProperty.C_DELETE_VALUE;\n            }\n\n            String oldResourceValue = oldProp.getResourceValue();\n            String newResourceValue = newProp.getResourceValue();\n            if (CmsStringUtil.isEmpty(oldResourceValue)) {\n                oldResourceValue = CmsProperty.C_DELETE_VALUE;\n            }\n            if (CmsStringUtil.isEmpty(newResourceValue)) {\n                newResourceValue = CmsProperty.C_DELETE_VALUE;\n            }\n\n            // change property only if it has been changed            \n            if (!oldResourceValue.equals(newResourceValue) || !oldStructureValue.equals(newStructureValue)) {\n                getCms().writePropertyObject(getParamResource(), newProp);\n            }\n\n        } catch (CmsException e) {\n            // error during chnav, show error dialog\n            setParamErrorstack(e.getStackTraceAsString());\n            setParamMessage(key(\"error.message.\" + getParamDialogtype()));\n            setParamReasonSuggestion(getErrorSuggestionDefault());\n            getJsp().include(C_FILE_DIALOG_SCREEN_ERROR);\n\n        }\n    }","commit_id":"8f2082421326d1e4f3d525d69a4d24407abf2e83","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the path under which the resource is accessable.\n     *  \n     * @return the path under which the resource is accessable\n     */\n    public String getResourceUrl() {\n\n        boolean secure = Boolean.valueOf(readProperty(I_CmsConstants.C_PROPERTY_SECURE)).booleanValue();\n        StringBuffer result = new StringBuffer();\n        CmsSite currentSite = CmsSiteManager.getCurrentSite(getCms());\n        if (currentSite == OpenCms.getSiteManager().getDefaultSite()) {\n            result.append(OpenCms.getSiteManager().getWorkplaceServer());\n        } else {\n            if (secure) {\n                result.append(currentSite.getSecureUrl());\n            } else {\n                result.append(currentSite.getUrl());\n            }\n        }\n        result.append(OpenCms.getLinkManager().substituteLink(getCms(), getParamResource()));\n\n        return result.toString();\n    }","id":33308,"modified_method":"/**\n     * Returns the path under which the resource is accessable.\n     *  \n     * @return the path under which the resource is accessable\n     */\n    public String getResourceUrl() {\n\n        CmsObject cms = getCms();\n        String address = \"\";\n        String vfsName = CmsLinkManager.getAbsoluteUri(getParamResource(), cms.getRequestContext().getUri());\n        String secureResource = \"\";\n        String exportedResource = \"\";\n        try {\n            secureResource = getCms().readPropertyObject(getParamResource(), I_CmsConstants.C_PROPERTY_SECURE, false)\n                .getValue();\n            exportedResource = getCms().readPropertyObject(getParamResource(), I_CmsConstants.C_PROPERTY_EXPORT, false)\n                .getValue();\n        } catch (CmsException e) {\n            if (OpenCms.getLog(this).isInfoEnabled()) {\n                OpenCms.getLog(this).info(e);\n            }\n        }\n        if (Boolean.valueOf(exportedResource).booleanValue()) {\n            address = OpenCms.getStaticExportManager().getRfsName(cms, vfsName);\n        } else {\n            address = OpenCms.getStaticExportManager().getVfsPrefix().concat(vfsName);\n        }\n        if (Boolean.valueOf(secureResource).booleanValue()) {\n            address = CmsSiteManager.getCurrentSite(cms).getSecureUrl().concat(address);\n        } else {\n            address = CmsSiteManager.getCurrentSite(cms).getUrl().concat(address);\n        }\n        return address;\n    }","commit_id":"8f2082421326d1e4f3d525d69a4d24407abf2e83","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Given a string a valid and visible tool path is computed.<p>\n     * \n     * @param wp the workplace object\n     * @param path the path to repair\n     * \n     * @return a valida and visible tool path\n     */\n    private String repairPath(CmsWorkplace wp, String path) {\n\n        // navigate until to reach a valid path\n        while (!validatePath(path, true)) {\n            path = getParent(wp, path);\n        }\n        // navigate to reach a visible path\n        CmsTool adminTool = resolveAdminTool(path);\n        I_CmsToolHandler handler = null;\n        if (adminTool != null) {\n            handler = resolveAdminTool(path).getHandler();\n        } else {\n            LOG.warn(Messages.get().key(wp.getLocale(), Messages.LOG_MISSING_ADMIN_TOOL_1, new Object[] {path}));\n        }\n\n        boolean handlerEnabled = false;\n        CmsObject cms = wp.getCms();\n        do {\n            if (handler != null) {\n                handlerEnabled = handler.isEnabled(cms);\n            } else {\n                LOG.warn(Messages.get().key(\n                    wp.getLocale(),\n                    Messages.LOG_MISSING_TOOL_HANDLER_2,\n                    new Object[] {resolveAdminTool(path), path}));\n                if (path.equals(\"/\")) {\n                    handlerEnabled = true;\n                }\n            }\n            if (handlerEnabled) {\n                break;\n            }\n            path = getParent(wp, path);\n            adminTool = resolveAdminTool(path);\n\n            if (adminTool != null) {\n                handler = resolveAdminTool(path).getHandler();\n            } else {\n                LOG.warn(Messages.get().key(wp.getLocale(), Messages.LOG_MISSING_ADMIN_TOOL_1, new Object[] {path}));\n            }\n\n        } while (true);\n\n        return path;\n    }","id":33309,"modified_method":"/**\n     * Given a string a valid and visible tool path is computed.<p>\n     * \n     * @param wp the workplace object\n     * @param path the path to repair\n     * \n     * @return a valida and visible tool path\n     */\n    private String repairPath(CmsWorkplace wp, String path) {\n\n        // navigate until to reach a valid path\n        while (!validatePath(path, true)) {\n            // log failure\n            LOG.warn(Messages.get().key(wp.getLocale(), Messages.LOG_MISSING_ADMIN_TOOL_1, new Object[] {path}));\n            // try parent\n            path = getParent(wp, path);\n        }\n        // navigate until to reach a valid tool\n        while (resolveAdminTool(path)==null) {\n            // log failure\n            LOG.warn(Messages.get().key(wp.getLocale(), Messages.LOG_MISSING_ADMIN_TOOL_1, new Object[] {path}));\n            // try parent\n            path = getParent(wp, path);\n        }\n        \n        // navegate until to reach a visible path\n        while (!resolveAdminTool(path).getHandler().isEnabled(wp.getCms())) {\n            LOG.warn(Messages.get().key(\n                wp.getLocale(),\n                Messages.LOG_MISSING_TOOL_HANDLER_2,\n                new Object[] {resolveAdminTool(path), path}));\n            path = getParent(wp, path);\n        }\n        \n        return path;\n    }","commit_id":"8656913f56fdc78815b1f7c700a91a34f36947fe","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Given a string a valid and visible tool path is computed.<p>\n     * \n     * @param wp the workplace object\n     * @param path the path to repair\n     * \n     * @return a valida and visible tool path\n     */\n    private String repairPath(CmsWorkplace wp, String path) {\n        \n        // navegate until to reach a valid path\n        while (!validatePath(path, true)) {            \n            path = getParent(wp, path);\n        }\n        // navegate until to reach a visible path\n        while (!resolveAdminTool(path).getHandler().isEnabled(wp.getCms())) {\n            path = getParent(wp, path);\n        }\n        return path;\n    }","id":33310,"modified_method":"/**\n     * Given a string a valid and visible tool path is computed.<p>\n     * \n     * @param wp the workplace object\n     * @param path the path to repair\n     * \n     * @return a valid and visible tool path\n     */\n    private String repairPath(CmsWorkplace wp, String path) {\n\n        // navigate until to reach a valid path\n        while (!validatePath(path, true)) {\n            path = getParent(wp, path);\n        }\n        // navigate to reach a visible path\n        CmsTool adminTool = resolveAdminTool(path);\n        I_CmsToolHandler handler = null;\n        if (adminTool != null) {\n            handler = resolveAdminTool(path).getHandler();\n        } else {\n            LOG.warn(Messages.get().key(wp.getLocale(), Messages.LOG_MISSING_ADMIN_TOOL_1, new Object[] {path}));\n        }\n\n        boolean handlerEnabled = false;\n        CmsObject cms = wp.getCms();\n        do {\n            if (handler != null) {\n                handlerEnabled = handler.isEnabled(cms);\n            } else {\n                LOG.warn(Messages.get().key(\n                    wp.getLocale(),\n                    Messages.LOG_MISSING_TOOL_HANDLER_2,\n                    new Object[] {resolveAdminTool(path), path}));\n                if (path.equals(\"/\")) {\n                    handlerEnabled = true;\n                }\n            }\n            if (handlerEnabled) {\n                break;\n            }\n            path = getParent(wp, path);\n            adminTool = resolveAdminTool(path);\n\n            if (adminTool != null) {\n                handler = resolveAdminTool(path).getHandler();\n            } else {\n                LOG.warn(Messages.get().key(wp.getLocale(), Messages.LOG_MISSING_ADMIN_TOOL_1, new Object[] {path}));\n            }\n\n        } while (true);\n\n        return path;\n    }","commit_id":"d17c67e13cf0f731a9ce2ffc4cb77cc680e8afc7","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public static boolean canCopy(PsiElement[] elements) {\n    if (elements.length > 0) {\n      for(CopyHandlerDelegate delegate: Extensions.getExtensions(CopyHandlerDelegate.EP_NAME)) {\n        if (delegate.canCopy(elements)) return true;\n      }\n    }\n    return false;\n  }","id":33311,"modified_method":"public static boolean canCopy(PsiElement[] elements) {\n    if (elements.length > 0) {\n      final CopyHandlerDelegate[] copyHandlers = Extensions.getExtensions(CopyHandlerDelegate.EP_NAME);\n      for(CopyHandlerDelegate delegate: copyHandlers) {\n        if (delegate.canCopy(elements)) return true;\n      }\n    }\n    return false;\n  }","commit_id":"f89d703b9d92c6b6c313abc1174d56bc48106db1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isCopyEnabled(DataContext dataContext) {\n      PsiElement[] elements = getValidSelectedElements();\n      return CopyHandler.canCopy(elements);\n    }","id":33312,"modified_method":"public boolean isCopyEnabled(DataContext dataContext) {\n      PsiElement[] elements = getValidSelectedElements();\n      return CopyHandler.canCopy(elements) || PsiCopyPasteManager.asFileList(elements) != null;\n    }","commit_id":"f89d703b9d92c6b6c313abc1174d56bc48106db1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static List<File> asFileList(final PsiElement[] elements) {\n    List<File> result = new ArrayList<File>();\n    for (PsiElement element : elements) {\n      final PsiFile psiFile = element.getContainingFile();\n      if (psiFile != null) {\n        VirtualFile vFile = psiFile.getVirtualFile();\n        if (vFile != null && vFile.getFileSystem() instanceof LocalFileSystem) {\n          result.add(new File(vFile.getPath()));\n        }\n      }\n    }\n    if (result.isEmpty()) {\n      return null;\n    }\n    return result;\n  }","id":33313,"modified_method":"public static List<File> asFileList(final PsiElement[] elements) {\n    List<File> result = new ArrayList<File>();\n    for (PsiElement element : elements) {\n      final PsiFileSystemItem psiFile;\n      if (element instanceof PsiFileSystemItem) {\n        psiFile = (PsiFileSystemItem)element;\n      }\n      else if (element instanceof PsiDirectoryContainer) {\n        final PsiDirectory[] directories = ((PsiDirectoryContainer)element).getDirectories();\n        psiFile = directories[0];\n      }\n      else {\n        psiFile = element.getContainingFile();\n      }\n      if (psiFile != null) {\n        VirtualFile vFile = psiFile.getVirtualFile();\n        if (vFile != null && vFile.getFileSystem() instanceof LocalFileSystem) {\n          result.add(new File(vFile.getPath()));\n        }\n      }\n    }\n    if (result.isEmpty()) {\n      return null;\n    }\n    return result;\n  }","commit_id":"f89d703b9d92c6b6c313abc1174d56bc48106db1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static Map<PsiFile, PsiClass[]> convertToTopLevelClasses(final PsiElement[] elements, String relativePath, Map<PsiFile, String> relativeMap) {\n    final Map<PsiFile, PsiClass[]> result = new HashMap<PsiFile, PsiClass[]>();\n    for (PsiElement element : elements) {\n      final PsiFile containingFile = element.getNavigationElement().getContainingFile();\n      if (!(containingFile instanceof PsiJavaFile &&\n            CollectHighlightsUtil.isOutsideSourceRoot(containingFile))) {\n        PsiClass[] topLevelClasses = getTopLevelClasses(element);\n        if (topLevelClasses == null) {\n          if (element instanceof PsiDirectory) {\n            final String name = ((PsiDirectory)element).getName();\n            final String path = relativePath != null ? (relativePath.length() > 0 ? (relativePath + \"/\") : \"\") + name : null;\n            final Map<PsiFile, PsiClass[]> map = convertToTopLevelClasses(element.getChildren(), path, relativeMap);\n            if (map == null) return null;\n            for (Map.Entry<PsiFile, PsiClass[]> entry : map.entrySet()) {\n              fillResultsMap(result, entry.getKey(), entry.getValue());\n            }\n            continue;\n          }\n          return null;\n        }\n        fillResultsMap(result, containingFile, topLevelClasses);\n        if (relativeMap != null) {\n          relativeMap.put(containingFile, relativePath);\n        }\n      }\n    }\n    return result.isEmpty() ? null : result;\n  }","id":33314,"modified_method":"@Nullable\n  private static Map<PsiFile, PsiClass[]> convertToTopLevelClasses(final PsiElement[] elements,\n                                                                   final boolean fromUpdate,\n                                                                   String relativePath,\n                                                                   Map<PsiFile, String> relativeMap) {\n    final Map<PsiFile, PsiClass[]> result = new HashMap<PsiFile, PsiClass[]>();\n    for (PsiElement element : elements) {\n      final PsiFile containingFile = element.getNavigationElement().getContainingFile();\n      if (!(containingFile instanceof PsiClassOwner &&\n            CollectHighlightsUtil.isOutsideSourceRoot(containingFile))) {\n        PsiClass[] topLevelClasses = getTopLevelClasses(element);\n        if (topLevelClasses == null) {\n          if (element instanceof PsiDirectory) {\n            if (!fromUpdate) {\n              final String name = ((PsiDirectory)element).getName();\n              final String path = relativePath != null ? (relativePath.length() > 0 ? (relativePath + \"/\") : \"\") + name : null;\n              final Map<PsiFile, PsiClass[]> map = convertToTopLevelClasses(element.getChildren(), fromUpdate, path, relativeMap);\n              if (map == null) return null;\n              for (Map.Entry<PsiFile, PsiClass[]> entry : map.entrySet()) {\n                fillResultsMap(result, entry.getKey(), entry.getValue());\n              }\n            }\n            continue;\n          }\n        }\n        fillResultsMap(result, containingFile, topLevelClasses);\n        if (relativeMap != null) {\n          relativeMap.put(containingFile, relativePath);\n        }\n      }\n    }\n    return result.isEmpty() ? null : result;\n  }","commit_id":"6d97d05e1ca7cd7ed3c714e002f796a9fc320a79","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean canCopyClass(PsiElement... elements) {\n    return convertToTopLevelClasses(elements, null, null) != null;\n  }","id":33315,"modified_method":"public static boolean canCopyClass(PsiElement... elements) {\n    return canCopyClass(false, elements);\n  }","commit_id":"6d97d05e1ca7cd7ed3c714e002f796a9fc320a79","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void doCopy(PsiElement[] elements, PsiDirectory defaultTargetDirectory) {\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(\"refactoring.copyClass\");\n    final HashMap<PsiFile, String> relativePathsMap = new HashMap<PsiFile, String>();\n    final Map<PsiFile, PsiClass[]> classes = convertToTopLevelClasses(elements, \"\", relativePathsMap);\n    assert classes != null;\n    if (defaultTargetDirectory == null) {\n      defaultTargetDirectory = classes.keySet().iterator().next().getContainingDirectory();\n    } else {\n      Project project = defaultTargetDirectory.getProject();\n      VirtualFile sourceRootForFile = ProjectRootManager.getInstance(project).getFileIndex()\n        .getSourceRootForFile(defaultTargetDirectory.getVirtualFile());\n      if (sourceRootForFile == null) {\n        final List<PsiElement> files = new ArrayList<PsiElement>();\n        for (int i = 0, elementsLength = elements.length; i < elementsLength; i++) {\n          PsiFile containingFile = elements[i].getContainingFile();\n          if (containingFile != null) {\n            files.add(containingFile);\n          } else if (elements[i] instanceof PsiDirectory) {\n            files.add(elements[i]);\n          }\n        }\n        CopyFilesOrDirectoriesHandler.copyAsFiles(files.toArray(new PsiElement[files.size()]), defaultTargetDirectory, project);\n        return;\n      }\n    }\n    Project project = defaultTargetDirectory.getProject();\n    Object targetDirectory = null;\n    String className = null;\n    if (classes.size() == 1 && classes.values().iterator().next().length == 1) {\n      final String commonPath = ArrayUtil.find(elements, classes.values().iterator().next()) == -1 ? normalizeRelativeMap(relativePathsMap) : null;\n      CopyClassDialog dialog = new CopyClassDialog(classes.values().iterator().next()[0], defaultTargetDirectory, project, false){\n        @Override\n        protected String getQualifiedName() {\n          if (commonPath != null && !commonPath.isEmpty()) {\n            return StringUtil.getQualifiedName(super.getQualifiedName(), commonPath.replaceAll(\"/\", \".\"));\n          }\n          return super.getQualifiedName();\n        }\n      };\n      dialog.setTitle(RefactoringBundle.message(\"copy.handler.copy.class\"));\n      dialog.show();\n      if (dialog.isOK()) {\n        targetDirectory = dialog.getTargetDirectory();\n        className = dialog.getClassName();\n        if (className == null || className.length() == 0) return;\n      }\n    } else {\n      if (ApplicationManager.getApplication().isUnitTestMode()) {\n        targetDirectory = defaultTargetDirectory;\n      } else {\n        defaultTargetDirectory = CopyFilesOrDirectoriesHandler.resolveDirectory(defaultTargetDirectory);\n        if (defaultTargetDirectory == null) return;\n        final CopyFilesOrDirectoriesDialog dialog = new CopyFilesOrDirectoriesDialog(PsiUtilCore.toPsiFileArray(classes.keySet()),\n                                                                               defaultTargetDirectory, project, false);\n        dialog.show();\n        if (dialog.isOK()) {\n          targetDirectory = dialog.getTargetDirectory();\n        }\n      }\n    }\n    if (targetDirectory != null) {\n      copyClassesImpl(className, project, classes, relativePathsMap, targetDirectory, defaultTargetDirectory, RefactoringBundle.message(\n        \"copy.handler.copy.class\"), false);\n    }\n  }","id":33316,"modified_method":"public void doCopy(PsiElement[] elements, PsiDirectory defaultTargetDirectory) {\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(\"refactoring.copyClass\");\n    final HashMap<PsiFile, String> relativePathsMap = new HashMap<PsiFile, String>();\n    final Map<PsiFile, PsiClass[]> classes = convertToTopLevelClasses(elements, false, \"\", relativePathsMap);\n    assert classes != null;\n    if (defaultTargetDirectory == null) {\n      defaultTargetDirectory = classes.keySet().iterator().next().getContainingDirectory();\n    } else {\n      Project project = defaultTargetDirectory.getProject();\n      VirtualFile sourceRootForFile = ProjectRootManager.getInstance(project).getFileIndex()\n        .getSourceRootForFile(defaultTargetDirectory.getVirtualFile());\n      if (sourceRootForFile == null) {\n        final List<PsiElement> files = new ArrayList<PsiElement>();\n        for (int i = 0, elementsLength = elements.length; i < elementsLength; i++) {\n          PsiFile containingFile = elements[i].getContainingFile();\n          if (containingFile != null) {\n            files.add(containingFile);\n          } else if (elements[i] instanceof PsiDirectory) {\n            files.add(elements[i]);\n          }\n        }\n        CopyFilesOrDirectoriesHandler.copyAsFiles(files.toArray(new PsiElement[files.size()]), defaultTargetDirectory, project);\n        return;\n      }\n    }\n    Project project = defaultTargetDirectory.getProject();\n    Object targetDirectory = null;\n    String className = null;\n    if (classes.size() == 1 && classes.values().iterator().next().length == 1) {\n      final String commonPath = ArrayUtil.find(elements, classes.values().iterator().next()) == -1 ? normalizeRelativeMap(relativePathsMap) : null;\n      CopyClassDialog dialog = new CopyClassDialog(classes.values().iterator().next()[0], defaultTargetDirectory, project, false){\n        @Override\n        protected String getQualifiedName() {\n          if (commonPath != null && !commonPath.isEmpty()) {\n            return StringUtil.getQualifiedName(super.getQualifiedName(), commonPath.replaceAll(\"/\", \".\"));\n          }\n          return super.getQualifiedName();\n        }\n      };\n      dialog.setTitle(RefactoringBundle.message(\"copy.handler.copy.class\"));\n      dialog.show();\n      if (dialog.isOK()) {\n        targetDirectory = dialog.getTargetDirectory();\n        className = dialog.getClassName();\n        if (className == null || className.length() == 0) return;\n      }\n    } else {\n      if (ApplicationManager.getApplication().isUnitTestMode()) {\n        targetDirectory = defaultTargetDirectory;\n      } else {\n        defaultTargetDirectory = CopyFilesOrDirectoriesHandler.resolveDirectory(defaultTargetDirectory);\n        if (defaultTargetDirectory == null) return;\n        final CopyFilesOrDirectoriesDialog dialog = new CopyFilesOrDirectoriesDialog(PsiUtilCore.toPsiFileArray(classes.keySet()),\n                                                                               defaultTargetDirectory, project, false);\n        dialog.show();\n        if (dialog.isOK()) {\n          targetDirectory = dialog.getTargetDirectory();\n        }\n      }\n    }\n    if (targetDirectory != null) {\n      copyClassesImpl(className, project, classes, relativePathsMap, targetDirectory, defaultTargetDirectory, RefactoringBundle.message(\n        \"copy.handler.copy.class\"), false);\n    }\n  }","commit_id":"6d97d05e1ca7cd7ed3c714e002f796a9fc320a79","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PsiElement doCopyClasses(final Map<PsiFile, PsiClass[]> fileToClasses,\n                                         HashMap<PsiFile, String> map, final String copyClassName,\n                                         final PsiDirectory targetDirectory,\n                                         final Project project) throws IncorrectOperationException {\n    PsiElement newElement = null;\n    final Map<PsiClass, PsiElement> oldToNewMap = new HashMap<PsiClass, PsiElement>();\n    for (final PsiClass[] psiClasses : fileToClasses.values()) {\n      for (PsiClass aClass : psiClasses) {\n        if (aClass instanceof SyntheticElement) {\n          continue;\n        }\n        oldToNewMap.put(aClass, null);\n      }\n    }\n    final PsiFile[] createdFiles = new PsiFile[fileToClasses.size()];\n    int foIdx = 0;\n    for (final Map.Entry<PsiFile, PsiClass[]> entry : fileToClasses.entrySet()) {\n      final PsiFile createdFile = copy(entry.getKey(), targetDirectory, copyClassName, map == null ? null : map.get(entry.getKey()));\n      final PsiClass[] sources = entry.getValue();\n\n      if (createdFile instanceof PsiClassOwner) {\n        for (final PsiClass destination : ((PsiClassOwner)createdFile).getClasses()) {\n          if (destination instanceof SyntheticElement) {\n            continue;\n          }\n          PsiClass source = findByName(sources, destination.getName());\n          if (source != null) {\n            final PsiClass copy = copy(source, copyClassName);\n            newElement = destination.replace(copy);\n            oldToNewMap.put(source, newElement);\n          }\n          else {\n            destination.delete();\n          }\n        }\n      }\n\n      createdFiles[foIdx++] = createdFile;\n    }\n\n    final Set<PsiElement> rebindExpressions = new HashSet<PsiElement>();\n    for (PsiElement element : oldToNewMap.values()) {\n      if (element == null) {\n        LOG.error(oldToNewMap.keySet());\n        continue;\n      }\n      decodeRefs(element, oldToNewMap, rebindExpressions);\n    }\n\n    final JavaCodeStyleManager codeStyleManager = JavaCodeStyleManager.getInstance(project);\n    for (PsiFile psiFile : createdFiles) {\n      if (psiFile instanceof PsiJavaFile) {\n        codeStyleManager.removeRedundantImports((PsiJavaFile)psiFile);\n      }\n    }\n    for (PsiElement expression : rebindExpressions) {\n      codeStyleManager.shortenClassReferences(expression);\n    }\n    new OptimizeImportsProcessor(project, createdFiles, null).run();\n    return newElement;\n  }","id":33317,"modified_method":"@Nullable\n  public static PsiElement doCopyClasses(final Map<PsiFile, PsiClass[]> fileToClasses,\n                                         HashMap<PsiFile, String> map, final String copyClassName,\n                                         final PsiDirectory targetDirectory,\n                                         final Project project) throws IncorrectOperationException {\n    PsiElement newElement = null;\n    final Map<PsiClass, PsiElement> oldToNewMap = new HashMap<PsiClass, PsiElement>();\n    for (final PsiClass[] psiClasses : fileToClasses.values()) {\n      if (psiClasses != null) {\n        for (PsiClass aClass : psiClasses) {\n          if (aClass instanceof SyntheticElement) {\n            continue;\n          }\n          oldToNewMap.put(aClass, null);\n        }\n      }\n    }\n    final PsiFile[] createdFiles = new PsiFile[fileToClasses.size()];\n    int foIdx = 0;\n    for (final Map.Entry<PsiFile, PsiClass[]> entry : fileToClasses.entrySet()) {\n      final PsiFile createdFile = copy(entry.getKey(), targetDirectory, copyClassName, map == null ? null : map.get(entry.getKey()));\n      final PsiClass[] sources = entry.getValue();\n\n      if (createdFile instanceof PsiClassOwner) {\n        for (final PsiClass destination : ((PsiClassOwner)createdFile).getClasses()) {\n          if (destination instanceof SyntheticElement) {\n            continue;\n          }\n          PsiClass source = findByName(sources, destination.getName());\n          if (source != null) {\n            final PsiClass copy = copy(source, copyClassName);\n            newElement = destination.replace(copy);\n            oldToNewMap.put(source, newElement);\n          }\n          else {\n            destination.delete();\n          }\n        }\n      }\n\n      createdFiles[foIdx++] = createdFile;\n    }\n\n    final Set<PsiElement> rebindExpressions = new HashSet<PsiElement>();\n    for (PsiElement element : oldToNewMap.values()) {\n      if (element == null) {\n        LOG.error(oldToNewMap.keySet());\n        continue;\n      }\n      decodeRefs(element, oldToNewMap, rebindExpressions);\n    }\n\n    final JavaCodeStyleManager codeStyleManager = JavaCodeStyleManager.getInstance(project);\n    for (PsiFile psiFile : createdFiles) {\n      if (psiFile instanceof PsiJavaFile) {\n        codeStyleManager.removeRedundantImports((PsiJavaFile)psiFile);\n      }\n    }\n    for (PsiElement expression : rebindExpressions) {\n      codeStyleManager.shortenClassReferences(expression);\n    }\n    new OptimizeImportsProcessor(project, createdFiles, null).run();\n    return newElement;\n  }","commit_id":"6d97d05e1ca7cd7ed3c714e002f796a9fc320a79","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean canCopy(PsiElement[] elements) {\n    return canCopyClass(elements);\n  }","id":33318,"modified_method":"@Override\n  public boolean canCopy(PsiElement[] elements, boolean fromUpdate) {\n    return canCopyClass(fromUpdate, elements);\n  }","commit_id":"6d97d05e1ca7cd7ed3c714e002f796a9fc320a79","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean canCopy(final PsiElement[] elements) {\n    HashSet<String> names = new HashSet<String>();\n    for (PsiElement element : elements) {\n      if (!(element instanceof PsiFileSystemItem)) return false;\n      if (!element.isValid()) return false;\n\n      String name = ((PsiFileSystemItem) element).getName();\n      if (names.contains(name)) {\n        return false;\n      }\n      names.add(name);\n    }\n\n    PsiElement[] filteredElements = PsiTreeUtil.filterAncestors(elements);\n    return filteredElements.length == elements.length;\n  }","id":33319,"modified_method":"@Override\n  public boolean canCopy(PsiElement[] elements, boolean fromUpdate) {\n    HashSet<String> names = new HashSet<String>();\n    for (PsiElement element : elements) {\n      if (!(element instanceof PsiFileSystemItem)) return false;\n      if (!element.isValid()) return false;\n\n      String name = ((PsiFileSystemItem) element).getName();\n      if (names.contains(name)) {\n        return false;\n      }\n      names.add(name);\n    }\n\n    PsiElement[] filteredElements = PsiTreeUtil.filterAncestors(elements);\n    return filteredElements.length == elements.length;\n  }","commit_id":"6d97d05e1ca7cd7ed3c714e002f796a9fc320a79","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean canCopy(PsiElement[] elements) {\n    if (elements.length > 0) {\n      final CopyHandlerDelegate[] copyHandlers = Extensions.getExtensions(CopyHandlerDelegate.EP_NAME);\n      for(CopyHandlerDelegate delegate: copyHandlers) {\n        if (delegate.canCopy(elements)) return true;\n      }\n    }\n    return false;\n  }","id":33320,"modified_method":"public static boolean canCopy(PsiElement[] elements) {\n    if (elements.length > 0) {\n      final CopyHandlerDelegate[] copyHandlers = Extensions.getExtensions(CopyHandlerDelegate.EP_NAME);\n      for(CopyHandlerDelegate delegate: copyHandlers) {\n        if (delegate instanceof CopyHandlerDelegateBase ? ((CopyHandlerDelegateBase)delegate).canCopy(elements, true) : delegate.canCopy(elements)) return true;\n      }\n    }\n    return false;\n  }","commit_id":"6d97d05e1ca7cd7ed3c714e002f796a9fc320a79","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testCopyScript() throws Throwable {\n    final String testName = getTestName(false);\n    myFixture.copyFileToProject(testName + \".groovy\", \"/foo/\" + testName + \".groovy\");\n\n    assertFalse(\n      CopyClassesHandler.canCopyClass(myFixture.getJavaFacade().findClass(\"foo.\" + testName, GlobalSearchScope.allScope(getProject()))));\n  }","id":33321,"modified_method":"public void testCopyScript() throws Throwable {\n    final String testName = getTestName(false);\n    myFixture.copyFileToProject(testName + \".groovy\", \"/foo/\" + testName + \".groovy\");\n\n    //would be copied as file\n    assertTrue(\n      CopyClassesHandler.canCopyClass(myFixture.getJavaFacade().findClass(\"foo.\" + testName, GlobalSearchScope.allScope(getProject()))));\n  }","commit_id":"6d97d05e1ca7cd7ed3c714e002f796a9fc320a79","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean canMove(PsiElement[] elements, PsiElement targetContainer) {\n    final PsiElement[] srcElements = adjustForMove(null, elements, targetContainer);\n    assert srcElements != null;\n\n    if (JavaMoveClassesOrPackagesHandler.nonFileSystemOrAllJava(srcElements)) return false;\n\n    return super.canMove(srcElements, targetContainer);\n  }","id":33322,"modified_method":"@Override\n  public boolean canMove(PsiElement[] elements, PsiElement targetContainer) {\n    final PsiElement[] srcElements = adjustForMove(null, elements, targetContainer);\n    assert srcElements != null;\n\n    return super.canMove(srcElements, targetContainer);\n  }","commit_id":"6d97d05e1ca7cd7ed3c714e002f796a9fc320a79","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean canClone(PsiElement[] elements) {\n    if (elements.length > 0) {\n      final CopyHandlerDelegate[] copyHandlers = Extensions.getExtensions(CopyHandlerDelegate.EP_NAME);\n      for (CopyHandlerDelegate delegate : copyHandlers) {\n        if (delegate.canCopy(elements)) {\n          if (delegate instanceof CopyHandlerDelegateBase && ((CopyHandlerDelegateBase)delegate).forbidToClone(elements, true)){\n            return false;\n          }\n          return true;\n        }\n      }\n    }\n    return false;\n  }","id":33323,"modified_method":"public static boolean canClone(PsiElement[] elements) {\n    if (elements.length > 0) {\n      final CopyHandlerDelegate[] copyHandlers = Extensions.getExtensions(CopyHandlerDelegate.EP_NAME);\n      for (CopyHandlerDelegate delegate : copyHandlers) {\n        if (delegate instanceof CopyHandlerDelegateBase ? ((CopyHandlerDelegateBase)delegate).canCopy(elements, true) : delegate.canCopy(elements)) {\n          if (delegate instanceof CopyHandlerDelegateBase && ((CopyHandlerDelegateBase)delegate).forbidToClone(elements, true)){\n            return false;\n          }\n          return true;\n        }\n      }\n    }\n    return false;\n  }","commit_id":"4da6b834fe55940c754a4cf5055d3eb5a43d17b3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Subscribe\n    public void handleTagDeleted(ContentTagDeletedEvent event) {\n        ContentTag deleted = event.getDeletedTag();\n        if (isCategoryTagName(deleted.getName())) {\n\n            Category deletedCat = CategoryManager.fromTagName(deleted.getName());\n            if (deletedCat != Category.ZERO) {\n                decrementCategoryCount(deletedCat);\n            }\n            fireChange(Collections.singleton(deleted.getId()), null);\n        }\n    }","id":33324,"modified_method":"@Subscribe\n    public void handleTagDeleted(ContentTagDeletedEvent event) {\n        ContentTag deleted = event.getDeletedTag();\n        if (isCategoryTagName(deleted.getName())) {\n\n            Category deletedCat = CategoryManager.fromTagName(deleted.getName());\n            if (deletedCat != Category.ZERO) {\n                decrementCategoryCount(deletedCat);\n            }\n            fireChange(Collections.singleton(deleted.getContent().getId()), null);\n        }\n    }","commit_id":"f1000486b79557d475334435a62e92d858d6344c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Subscribe\n    public void handleTagAdded(ContentTagAddedEvent event) {\n        ContentTag addedTag = event.getAddedTag();\n        if (isCategoryTagName(addedTag.getName())) {\n            final DrawableTagsManager tagsManager = controller.getTagsManager();\n            try {\n                //remove old category tag(s) if necessary\n                List<ContentTag> allContentTags = tagsManager.getContentTagsByContent(addedTag.getContent());\n\n                for (ContentTag ct : allContentTags) {\n                    if (ct.getId() != addedTag.getId()\n                            && CategoryManager.isCategoryTagName(ct.getName())) {\n                        try {\n                            tagsManager.deleteContentTag(ct);\n                        } catch (TskCoreException tskException) {\n                            LOGGER.log(Level.SEVERE, \"Failed to delete content tag. Unable to maintain categories in a consistent state.\", tskException);\n                        }\n                    }\n                }\n            } catch (TskCoreException tskException) {\n                LOGGER.log(Level.SEVERE, \"Failed to get content tags for content.  Unable to maintain category in a consistent state.\", tskException);\n            }\n            Category newCat = CategoryManager.fromTagName(addedTag.getName());\n            if (newCat != Category.ZERO) {\n                incrementCategoryCount(newCat);\n            }\n\n            fireChange(Collections.singleton(addedTag.getId()), newCat);\n        }\n    }","id":33325,"modified_method":"@Subscribe\n    public void handleTagAdded(ContentTagAddedEvent event) {\n        ContentTag addedTag = event.getAddedTag();\n        if (isCategoryTagName(addedTag.getName())) {\n            final DrawableTagsManager tagsManager = controller.getTagsManager();\n            try {\n                //remove old category tag(s) if necessary\n                List<ContentTag> allContentTags = tagsManager.getContentTagsByContent(addedTag.getContent());\n\n                for (ContentTag ct : allContentTags) {\n                    if (ct.getId() != addedTag.getId()\n                            && CategoryManager.isCategoryTagName(ct.getName())) {\n                        try {\n                            tagsManager.deleteContentTag(ct);\n                        } catch (TskCoreException tskException) {\n                            LOGGER.log(Level.SEVERE, \"Failed to delete content tag. Unable to maintain categories in a consistent state.\", tskException);\n                        }\n                    }\n                }\n            } catch (TskCoreException tskException) {\n                LOGGER.log(Level.SEVERE, \"Failed to get content tags for content.  Unable to maintain category in a consistent state.\", tskException);\n            }\n            Category newCat = CategoryManager.fromTagName(addedTag.getName());\n            if (newCat != Category.ZERO) {\n                incrementCategoryCount(newCat);\n            }\n\n            fireChange(Collections.singleton(addedTag.getContent().getId()), newCat);\n        }\n    }","commit_id":"f1000486b79557d475334435a62e92d858d6344c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public DeleteFollowUpTagAction(final ImageGalleryController controller, final DrawableFile<?> file) {\n        super(\"Delete Follow Up Tag\");\n        this.fileID = file.getId();\n        setEventHandler((ActionEvent t) -> {\n            new SwingWorker<Void, Void>() {\n\n                @Override\n                protected Void doInBackground() throws Exception {\n                    final DrawableTagsManager tagsManager = controller.getTagsManager();\n\n                    try {\n                        final TagName followUpTagName = tagsManager.getFollowUpTagName();\n                    \n                        List<ContentTag> contentTagsByContent = tagsManager.getContentTagsByContent(file);\n                        for (ContentTag ct : contentTagsByContent) {\n                            if (ct.getName().getDisplayName().equals(followUpTagName.getDisplayName())) {\n                                tagsManager.deleteContentTag(ct);\n                            }\n                        }\n                    } catch (TskCoreException ex) {\n                        LOGGER.log(Level.SEVERE, \"Failed to delete follow up tag.\", ex);\n                    }\n                    return null;\n                }\n            }.execute();\n        });\n    }","id":33326,"modified_method":"public DeleteFollowUpTagAction(final ImageGalleryController controller, final DrawableFile<?> file) {\n        super(\"Delete Follow Up Tag\");\n        setEventHandler((ActionEvent t) -> {\n            new SwingWorker<Void, Void>() {\n\n                @Override\n                protected Void doInBackground() throws Exception {\n                    final DrawableTagsManager tagsManager = controller.getTagsManager();\n\n                    try {\n                        final TagName followUpTagName = tagsManager.getFollowUpTagName();\n                    \n                        List<ContentTag> contentTagsByContent = tagsManager.getContentTagsByContent(file);\n                        for (ContentTag ct : contentTagsByContent) {\n                            if (ct.getName().getDisplayName().equals(followUpTagName.getDisplayName())) {\n                                tagsManager.deleteContentTag(ct);\n                            }\n                        }\n                    } catch (TskCoreException ex) {\n                        LOGGER.log(Level.SEVERE, \"Failed to delete follow up tag.\", ex);\n                    }\n                    return null;\n                }\n            }.execute();\n        });\n    }","commit_id":"f1000486b79557d475334435a62e92d858d6344c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void setFileHelper(Long newFileID) {\n        fileIDOpt = Optional.of(newFileID);\n        if (newFileID == null) {\n            Platform.runLater(() -> {\n                imageView.setImage(null);\n                tableView.getItems().clear();\n                getCategoryBorderRegion().setBorder(null);\n\n            });\n        } else {\n            updateUI();\n        }\n    }","id":33327,"modified_method":"@Override\n    synchronized protected void setFileHelper(Long newFileID) {\n        setFileIDOpt(Optional.ofNullable(newFileID));\n        if (newFileID == null) {\n            Platform.runLater(() -> {\n                imageView.setImage(null);\n                tableView.getItems().clear();\n                getCategoryBorderRegion().setBorder(null);\n\n            });\n        } else {\n            updateUI();\n        }\n    }","commit_id":"f1000486b79557d475334435a62e92d858d6344c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public void updateUI() {\n        getFile().ifPresent(file -> {\n            final Image icon = file.getThumbnail();\n            final ObservableList<Pair<DrawableAttribute<?>, ? extends Object>> attributesList = file.getAttributesList();\n\n            Platform.runLater(() -> {\n                imageView.setImage(icon);\n                tableView.getItems().setAll(attributesList);\n            });\n\n            updateCategoryBorder();\n        });\n\n    }","id":33328,"modified_method":"public void updateUI() {\n        getFile().ifPresent(file -> {\n            final Image icon = file.getThumbnail();\n            final ObservableList<Pair<DrawableAttribute<?>, ? extends Object>> attributesList = file.getAttributesList();\n\n            Platform.runLater(() -> {\n                imageView.setImage(icon);\n                tableView.getItems().clear();\n                tableView.getItems().setAll(attributesList);\n            });\n\n            updateCategory();\n        });\n    }","commit_id":"f1000486b79557d475334435a62e92d858d6344c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@FXML\n    @SuppressWarnings(\"unchecked\")\n    void initialize() {\n        assert attributeColumn != null : \"fx:id=\\\"attributeColumn\\\" was not injected: check your FXML file 'MetaDataPane.fxml'.\";\n        assert imageView != null : \"fx:id=\\\"imageView\\\" was not injected: check your FXML file 'MetaDataPane.fxml'.\";\n        assert tableView != null : \"fx:id=\\\"tableView\\\" was not injected: check your FXML file 'MetaDataPane.fxml'.\";\n        assert valueColumn != null : \"fx:id=\\\"valueColumn\\\" was not injected: check your FXML file 'MetaDataPane.fxml'.\";\n        getController().getTagsManager().registerListener(this);\n        getController().getCategoryManager().registerListener(this);\n\n        tableView.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);\n        tableView.setPlaceholder(new Label(\"Select a file to show its details here.\"));\n\n        attributeColumn.setCellValueFactory((param) -> new SimpleObjectProperty<>(param.getValue().getKey()));\n        attributeColumn.setCellFactory((param) -> new TableCell<Pair<DrawableAttribute<?>, ? extends Object>, DrawableAttribute<?>>() {\n            @Override\n            protected void updateItem(DrawableAttribute<?> item, boolean empty) {\n                super.updateItem(item, empty); //To change body of generated methods, choose Tools | Templates.\n                if (item != null) {\n                    setText(item.getDisplayName());\n                    setGraphic(new ImageView(item.getIcon()));\n                } else {\n                    setGraphic(null);\n                    setText(null);\n                }\n            }\n        });\n\n        attributeColumn.setPrefWidth(USE_COMPUTED_SIZE);\n\n        valueColumn.setCellValueFactory((p) -> {\n            return (p.getValue().getKey() == DrawableAttribute.TAGS)\n                    ? new SimpleStringProperty(((Collection<TagName>) p.getValue().getValue()).stream()\n                            .map(TagName::getDisplayName)\n                            .filter(Category::isNotCategoryName)\n                            .collect(Collectors.joining(\" ; \")))\n                    : new SimpleStringProperty(StringUtils.join((Iterable<?>) p.getValue().getValue(), \" ; \"));\n        });\n        valueColumn.setPrefWidth(USE_COMPUTED_SIZE);\n        valueColumn.setCellFactory((p) -> new TableCell<Pair<DrawableAttribute<?>, ? extends Object>, String>() {\n            @Override\n            public void updateItem(String item, boolean empty) {\n                super.updateItem(item, empty);\n                if (!isEmpty()) {\n                    Text text = new Text(item);\n                    text.wrappingWidthProperty().bind(getTableColumn().widthProperty());\n                    setGraphic(text);\n                } else {\n                    setGraphic(null);\n                }\n            }\n        });\n        tableView.getColumns().setAll(Arrays.asList(attributeColumn, valueColumn));\n\n        //listen for selection change\n        controller.getSelectionModel().lastSelectedProperty().addListener((observable, oldFileID, newFileID) -> {\n            setFile(newFileID);\n        });\n    }","id":33329,"modified_method":"@FXML\n    @SuppressWarnings(\"unchecked\")\n    void initialize() {\n        assert attributeColumn != null : \"fx:id=\\\"attributeColumn\\\" was not injected: check your FXML file 'MetaDataPane.fxml'.\";\n        assert imageView != null : \"fx:id=\\\"imageView\\\" was not injected: check your FXML file 'MetaDataPane.fxml'.\";\n        assert tableView != null : \"fx:id=\\\"tableView\\\" was not injected: check your FXML file 'MetaDataPane.fxml'.\";\n        assert valueColumn != null : \"fx:id=\\\"valueColumn\\\" was not injected: check your FXML file 'MetaDataPane.fxml'.\";\n        getController().getTagsManager().registerListener(this);\n        getController().getCategoryManager().registerListener(this);\n\n        tableView.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);\n        tableView.setPlaceholder(new Label(\"Select a file to show its details here.\"));\n\n        attributeColumn.setCellValueFactory((param) -> new SimpleObjectProperty<>(param.getValue().getKey()));\n        attributeColumn.setCellFactory((param) -> new TableCell<Pair<DrawableAttribute<?>, ? extends Object>, DrawableAttribute<?>>() {\n            @Override\n            protected void updateItem(DrawableAttribute<?> item, boolean empty) {\n                super.updateItem(item, empty); //To change body of generated methods, choose Tools | Templates.\n                if (item != null) {\n                    setText(item.getDisplayName());\n                    setGraphic(new ImageView(item.getIcon()));\n                } else {\n                    setGraphic(null);\n                    setText(null);\n                }\n            }\n        });\n\n        attributeColumn.setPrefWidth(USE_COMPUTED_SIZE);\n\n        valueColumn.setCellValueFactory((p) -> {\n            return (p.getValue().getKey() == DrawableAttribute.TAGS)\n                    ? new SimpleStringProperty(((Collection<TagName>) p.getValue().getValue()).stream()\n                            .map(TagName::getDisplayName)\n                            .filter(Category::isNotCategoryName)\n                            .collect(Collectors.joining(\" ; \")))\n                    : new SimpleStringProperty(StringUtils.join((Iterable<?>) p.getValue().getValue(), \" ; \"));\n        });\n        valueColumn.setPrefWidth(USE_COMPUTED_SIZE);\n        valueColumn.setCellFactory((p) -> new TableCell<Pair<DrawableAttribute<?>, ? extends Object>, String>() {\n            @Override\n            public void updateItem(String item, boolean empty) {\n                super.updateItem(item, empty);\n                if (!isEmpty()) {\n                    Text text = new Text(item);\n                    text.wrappingWidthProperty().bind(getTableColumn().widthProperty());\n                    setGraphic(text);\n                } else {\n                    setGraphic(null);\n                }\n            }\n        });\n        tableView.getColumns().setAll(Arrays.asList(attributeColumn, valueColumn));\n\n        //listen for selection change\n        getController().getSelectionModel().lastSelectedProperty().addListener((observable, oldFileID, newFileID) -> {\n            setFile(newFileID);\n        });\n    }","commit_id":"f1000486b79557d475334435a62e92d858d6344c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public MetaDataPane(ImageGalleryController controller) {\n        this.controller = controller;\n\n        FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource(\"MetaDataPane.fxml\"));\n        fxmlLoader.setRoot(this);\n        fxmlLoader.setController(this);\n\n        try {\n            fxmlLoader.load();\n        } catch (IOException exception) {\n            throw new RuntimeException(exception);\n        }\n    }","id":33330,"modified_method":"public MetaDataPane(ImageGalleryController controller) {\n        super(controller);\n\n        FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource(\"MetaDataPane.fxml\"));\n        fxmlLoader.setRoot(this);\n        fxmlLoader.setController(this);\n\n        try {\n            fxmlLoader.load();\n        } catch (IOException exception) {\n            throw new RuntimeException(exception);\n        }\n    }","commit_id":"f1000486b79557d475334435a62e92d858d6344c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@ThreadConfined(type = ThreadType.JFX)\n    private void cycleSlideShowImage(int d) {\n        stopVideo();\n        if (getFileID() != null) {\n            int index = getGroupPane().getGrouping().fileIds().indexOf(getFileID());\n            final int size = getGroupPane().getGrouping().fileIds().size();\n            index = (index + d) % size;\n            if (index < 0) {\n                index += size;\n            }\n            setFile(getGroupPane().getGrouping().fileIds().get(index));\n\n        } else {\n            setFile(getGroupPane().getGrouping().fileIds().get(0));\n        }\n    }","id":33331,"modified_method":"@ThreadConfined(type = ThreadType.JFX)\n    private void cycleSlideShowImage(int d) {\n        stopVideo();\n        if (getFileID().isPresent()) {\n            int index = getGroupPane().getGrouping().fileIds().indexOf(getFileID());\n            final int size = getGroupPane().getGrouping().fileIds().size();\n            index = (index + d) % size;\n            if (index < 0) {\n                index += size;\n            }\n            setFile(getGroupPane().getGrouping().fileIds().get(index));\n\n        } else {\n            setFile(getGroupPane().getGrouping().fileIds().get(0));\n        }\n    }","commit_id":"f1000486b79557d475334435a62e92d858d6344c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    @ThreadConfined(type = ThreadType.ANY)\n    public Category updateCategoryBorder() {\n        return getFile().map(file -> {\n            final Category category = file.getCategory();\n            final Border border1 = hasHashHit() && (category == Category.ZERO)\n                    ? HASH_BORDER\n                    : getCategoryBorder(category);\n            ToggleButton toggleForCategory = getToggleForCategory(category);\n            Platform.runLater(() -> {\n                getCategoryBorderRegion().setBorder(border1);\n                toggleForCategory.setSelected(true);\n            });\n            return category;\n        }).orElse(Category.ZERO);\n\n    }","id":33332,"modified_method":"@Override\n    @ThreadConfined(type = ThreadType.ANY)\n    public Category updateCategory() {\n        if (getFile().isPresent()) {\n            final Category category = super.updateCategory();\n            ToggleButton toggleForCategory = getToggleForCategory(category);\n            Platform.runLater(() -> {\n                toggleForCategory.setSelected(true);\n            });\n            return category;\n        } else {\n            return Category.ZERO;\n        }\n    }","commit_id":"f1000486b79557d475334435a62e92d858d6344c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Subscribe\n    public void handleTagDeleted(ContentTagDeletedEvent event) {\n        ContentTag deleted = event.getDeletedTag();\n        if (isCategoryTagName(deleted.getName())) {\n\n            Category deletedCat = CategoryManager.fromTagName(deleted.getName());\n            if (deletedCat != Category.ZERO) {\n                decrementCategoryCount(deletedCat);\n            }\n            fireChange(Collections.singleton(deleted.getId()), null);\n        }\n    }","id":33333,"modified_method":"@Subscribe\n    public void handleTagDeleted(ContentTagDeletedEvent event) {\n        ContentTag deleted = event.getDeletedTag();\n        if (isCategoryTagName(deleted.getName())) {\n\n            Category deletedCat = CategoryManager.fromTagName(deleted.getName());\n            if (deletedCat != Category.ZERO) {\n                decrementCategoryCount(deletedCat);\n            }\n            fireChange(Collections.singleton(deleted.getContent().getId()), null);\n        }\n    }","commit_id":"ff11258e9c750213fb897a29ddc8c63db1f9572f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Subscribe\n    public void handleTagAdded(ContentTagAddedEvent event) {\n        ContentTag addedTag = event.getAddedTag();\n        if (isCategoryTagName(addedTag.getName())) {\n            final DrawableTagsManager tagsManager = controller.getTagsManager();\n            try {\n                //remove old category tag(s) if necessary\n                List<ContentTag> allContentTags = tagsManager.getContentTagsByContent(addedTag.getContent());\n\n                for (ContentTag ct : allContentTags) {\n                    if (ct.getId() != addedTag.getId()\n                            && CategoryManager.isCategoryTagName(ct.getName())) {\n                        try {\n                            tagsManager.deleteContentTag(ct);\n                        } catch (TskCoreException tskException) {\n                            LOGGER.log(Level.SEVERE, \"Failed to delete content tag. Unable to maintain categories in a consistent state.\", tskException);\n                        }\n                    }\n                }\n            } catch (TskCoreException tskException) {\n                LOGGER.log(Level.SEVERE, \"Failed to get content tags for content.  Unable to maintain category in a consistent state.\", tskException);\n            }\n            Category newCat = CategoryManager.fromTagName(addedTag.getName());\n            if (newCat != Category.ZERO) {\n                incrementCategoryCount(newCat);\n            }\n\n            fireChange(Collections.singleton(addedTag.getId()), newCat);\n        }\n    }","id":33334,"modified_method":"@Subscribe\n    public void handleTagAdded(ContentTagAddedEvent event) {\n        ContentTag addedTag = event.getAddedTag();\n        if (isCategoryTagName(addedTag.getName())) {\n            final DrawableTagsManager tagsManager = controller.getTagsManager();\n            try {\n                //remove old category tag(s) if necessary\n                List<ContentTag> allContentTags = tagsManager.getContentTagsByContent(addedTag.getContent());\n\n                for (ContentTag ct : allContentTags) {\n                    if (ct.getId() != addedTag.getId()\n                            && CategoryManager.isCategoryTagName(ct.getName())) {\n                        try {\n                            tagsManager.deleteContentTag(ct);\n                        } catch (TskCoreException tskException) {\n                            LOGGER.log(Level.SEVERE, \"Failed to delete content tag. Unable to maintain categories in a consistent state.\", tskException);\n                        }\n                    }\n                }\n            } catch (TskCoreException tskException) {\n                LOGGER.log(Level.SEVERE, \"Failed to get content tags for content.  Unable to maintain category in a consistent state.\", tskException);\n            }\n            Category newCat = CategoryManager.fromTagName(addedTag.getName());\n            if (newCat != Category.ZERO) {\n                incrementCategoryCount(newCat);\n            }\n\n            fireChange(Collections.singleton(addedTag.getContent().getId()), newCat);\n        }\n    }","commit_id":"ff11258e9c750213fb897a29ddc8c63db1f9572f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public DeleteFollowUpTagAction(final ImageGalleryController controller, final DrawableFile<?> file) {\n        super(\"Delete Follow Up Tag\");\n        this.fileID = file.getId();\n        setEventHandler((ActionEvent t) -> {\n            new SwingWorker<Void, Void>() {\n\n                @Override\n                protected Void doInBackground() throws Exception {\n                    final DrawableTagsManager tagsManager = controller.getTagsManager();\n\n                    try {\n                        final TagName followUpTagName = tagsManager.getFollowUpTagName();\n                    \n                        List<ContentTag> contentTagsByContent = tagsManager.getContentTagsByContent(file);\n                        for (ContentTag ct : contentTagsByContent) {\n                            if (ct.getName().getDisplayName().equals(followUpTagName.getDisplayName())) {\n                                tagsManager.deleteContentTag(ct);\n                            }\n                        }\n                    } catch (TskCoreException ex) {\n                        LOGGER.log(Level.SEVERE, \"Failed to delete follow up tag.\", ex);\n                    }\n                    return null;\n                }\n            }.execute();\n        });\n    }","id":33335,"modified_method":"public DeleteFollowUpTagAction(final ImageGalleryController controller, final DrawableFile<?> file) {\n        super(\"Delete Follow Up Tag\");\n        setEventHandler((ActionEvent t) -> {\n            new SwingWorker<Void, Void>() {\n\n                @Override\n                protected Void doInBackground() throws Exception {\n                    final DrawableTagsManager tagsManager = controller.getTagsManager();\n\n                    try {\n                        final TagName followUpTagName = tagsManager.getFollowUpTagName();\n                    \n                        List<ContentTag> contentTagsByContent = tagsManager.getContentTagsByContent(file);\n                        for (ContentTag ct : contentTagsByContent) {\n                            if (ct.getName().getDisplayName().equals(followUpTagName.getDisplayName())) {\n                                tagsManager.deleteContentTag(ct);\n                            }\n                        }\n                    } catch (TskCoreException ex) {\n                        LOGGER.log(Level.SEVERE, \"Failed to delete follow up tag.\", ex);\n                    }\n                    return null;\n                }\n            }.execute();\n        });\n    }","commit_id":"ff11258e9c750213fb897a29ddc8c63db1f9572f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@FXML\n    @SuppressWarnings(\"unchecked\")\n    void initialize() {\n        assert attributeColumn != null : \"fx:id=\\\"attributeColumn\\\" was not injected: check your FXML file 'MetaDataPane.fxml'.\";\n        assert imageView != null : \"fx:id=\\\"imageView\\\" was not injected: check your FXML file 'MetaDataPane.fxml'.\";\n        assert tableView != null : \"fx:id=\\\"tableView\\\" was not injected: check your FXML file 'MetaDataPane.fxml'.\";\n        assert valueColumn != null : \"fx:id=\\\"valueColumn\\\" was not injected: check your FXML file 'MetaDataPane.fxml'.\";\n        getController().getTagsManager().registerListener(this);\n        getController().getCategoryManager().registerListener(this);\n\n        tableView.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);\n        tableView.setPlaceholder(new Label(\"Select a file to show its details here.\"));\n\n        attributeColumn.setCellValueFactory((param) -> new SimpleObjectProperty<>(param.getValue().getKey()));\n        attributeColumn.setCellFactory((param) -> new TableCell<Pair<DrawableAttribute<?>, ? extends Object>, DrawableAttribute<?>>() {\n            @Override\n            protected void updateItem(DrawableAttribute<?> item, boolean empty) {\n                super.updateItem(item, empty); //To change body of generated methods, choose Tools | Templates.\n                if (item != null) {\n                    setText(item.getDisplayName());\n                    setGraphic(new ImageView(item.getIcon()));\n                } else {\n                    setGraphic(null);\n                    setText(null);\n                }\n            }\n        });\n\n        attributeColumn.setPrefWidth(USE_COMPUTED_SIZE);\n\n        valueColumn.setCellValueFactory((p) -> {\n            return (p.getValue().getKey() == DrawableAttribute.TAGS)\n                    ? new SimpleStringProperty(((Collection<TagName>) p.getValue().getValue()).stream()\n                            .map(TagName::getDisplayName)\n                            .filter(Category::isNotCategoryName)\n                            .collect(Collectors.joining(\" ; \")))\n                    : new SimpleStringProperty(StringUtils.join((Iterable<?>) p.getValue().getValue(), \" ; \"));\n        });\n        valueColumn.setPrefWidth(USE_COMPUTED_SIZE);\n        valueColumn.setCellFactory((p) -> new TableCell<Pair<DrawableAttribute<?>, ? extends Object>, String>() {\n            @Override\n            public void updateItem(String item, boolean empty) {\n                super.updateItem(item, empty);\n                if (!isEmpty()) {\n                    Text text = new Text(item);\n                    text.wrappingWidthProperty().bind(getTableColumn().widthProperty());\n                    setGraphic(text);\n                } else {\n                    setGraphic(null);\n                }\n            }\n        });\n        tableView.getColumns().setAll(Arrays.asList(attributeColumn, valueColumn));\n\n        //listen for selection change\n        controller.getSelectionModel().lastSelectedProperty().addListener((observable, oldFileID, newFileID) -> {\n            setFile(newFileID);\n        });\n    }","id":33336,"modified_method":"@FXML\n    @SuppressWarnings(\"unchecked\")\n    void initialize() {\n        assert attributeColumn != null : \"fx:id=\\\"attributeColumn\\\" was not injected: check your FXML file 'MetaDataPane.fxml'.\";\n        assert imageView != null : \"fx:id=\\\"imageView\\\" was not injected: check your FXML file 'MetaDataPane.fxml'.\";\n        assert tableView != null : \"fx:id=\\\"tableView\\\" was not injected: check your FXML file 'MetaDataPane.fxml'.\";\n        assert valueColumn != null : \"fx:id=\\\"valueColumn\\\" was not injected: check your FXML file 'MetaDataPane.fxml'.\";\n        getController().getTagsManager().registerListener(this);\n        getController().getCategoryManager().registerListener(this);\n\n        tableView.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);\n        tableView.setPlaceholder(new Label(\"Select a file to show its details here.\"));\n\n        attributeColumn.setCellValueFactory((param) -> new SimpleObjectProperty<>(param.getValue().getKey()));\n        attributeColumn.setCellFactory((param) -> new TableCell<Pair<DrawableAttribute<?>, ? extends Object>, DrawableAttribute<?>>() {\n            @Override\n            protected void updateItem(DrawableAttribute<?> item, boolean empty) {\n                super.updateItem(item, empty); //To change body of generated methods, choose Tools | Templates.\n                if (item != null) {\n                    setText(item.getDisplayName());\n                    setGraphic(new ImageView(item.getIcon()));\n                } else {\n                    setGraphic(null);\n                    setText(null);\n                }\n            }\n        });\n\n        attributeColumn.setPrefWidth(USE_COMPUTED_SIZE);\n\n        valueColumn.setCellValueFactory((p) -> {\n            return (p.getValue().getKey() == DrawableAttribute.TAGS)\n                    ? new SimpleStringProperty(((Collection<TagName>) p.getValue().getValue()).stream()\n                            .map(TagName::getDisplayName)\n                            .filter(Category::isNotCategoryName)\n                            .collect(Collectors.joining(\" ; \")))\n                    : new SimpleStringProperty(StringUtils.join((Iterable<?>) p.getValue().getValue(), \" ; \"));\n        });\n        valueColumn.setPrefWidth(USE_COMPUTED_SIZE);\n        valueColumn.setCellFactory((p) -> new TableCell<Pair<DrawableAttribute<?>, ? extends Object>, String>() {\n            @Override\n            public void updateItem(String item, boolean empty) {\n                super.updateItem(item, empty);\n                if (!isEmpty()) {\n                    Text text = new Text(item);\n                    text.wrappingWidthProperty().bind(getTableColumn().widthProperty());\n                    setGraphic(text);\n                } else {\n                    setGraphic(null);\n                }\n            }\n        });\n        tableView.getColumns().setAll(Arrays.asList(attributeColumn, valueColumn));\n\n        //listen for selection change\n        getController().getSelectionModel().lastSelectedProperty().addListener((observable, oldFileID, newFileID) -> {\n            setFile(newFileID);\n        });\n    }","commit_id":"ff11258e9c750213fb897a29ddc8c63db1f9572f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public void updateUI() {\n        getFile().ifPresent(file -> {\n            final Image icon = file.getThumbnail();\n            final ObservableList<Pair<DrawableAttribute<?>, ? extends Object>> attributesList = file.getAttributesList();\n\n            Platform.runLater(() -> {\n                imageView.setImage(icon);\n                tableView.getItems().setAll(attributesList);\n            });\n\n            updateCategoryBorder();\n        });\n\n    }","id":33337,"modified_method":"public void updateUI() {\n        getFile().ifPresent(file -> {\n            final Image icon = file.getThumbnail();\n            final ObservableList<Pair<DrawableAttribute<?>, ? extends Object>> attributesList = file.getAttributesList();\n\n            Platform.runLater(() -> {\n                imageView.setImage(icon);\n                tableView.getItems().clear();\n                tableView.getItems().setAll(attributesList);\n            });\n\n            updateCategory();\n        });\n    }","commit_id":"ff11258e9c750213fb897a29ddc8c63db1f9572f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void setFileHelper(Long newFileID) {\n        fileIDOpt = Optional.of(newFileID);\n        if (newFileID == null) {\n            Platform.runLater(() -> {\n                imageView.setImage(null);\n                tableView.getItems().clear();\n                getCategoryBorderRegion().setBorder(null);\n\n            });\n        } else {\n            updateUI();\n        }\n    }","id":33338,"modified_method":"@Override\n    synchronized protected void setFileHelper(Long newFileID) {\n        setFileIDOpt(Optional.ofNullable(newFileID));\n        if (newFileID == null) {\n            Platform.runLater(() -> {\n                imageView.setImage(null);\n                tableView.getItems().clear();\n                getCategoryBorderRegion().setBorder(null);\n\n            });\n        } else {\n            updateUI();\n        }\n    }","commit_id":"ff11258e9c750213fb897a29ddc8c63db1f9572f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public MetaDataPane(ImageGalleryController controller) {\n        this.controller = controller;\n\n        FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource(\"MetaDataPane.fxml\"));\n        fxmlLoader.setRoot(this);\n        fxmlLoader.setController(this);\n\n        try {\n            fxmlLoader.load();\n        } catch (IOException exception) {\n            throw new RuntimeException(exception);\n        }\n    }","id":33339,"modified_method":"public MetaDataPane(ImageGalleryController controller) {\n        super(controller);\n\n        FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource(\"MetaDataPane.fxml\"));\n        fxmlLoader.setRoot(this);\n        fxmlLoader.setController(this);\n\n        try {\n            fxmlLoader.load();\n        } catch (IOException exception) {\n            throw new RuntimeException(exception);\n        }\n    }","commit_id":"ff11258e9c750213fb897a29ddc8c63db1f9572f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@ThreadConfined(type = ThreadType.JFX)\n    private void cycleSlideShowImage(int d) {\n        stopVideo();\n        if (getFileID() != null) {\n            int index = getGroupPane().getGrouping().fileIds().indexOf(getFileID());\n            final int size = getGroupPane().getGrouping().fileIds().size();\n            index = (index + d) % size;\n            if (index < 0) {\n                index += size;\n            }\n            setFile(getGroupPane().getGrouping().fileIds().get(index));\n\n        } else {\n            setFile(getGroupPane().getGrouping().fileIds().get(0));\n        }\n    }","id":33340,"modified_method":"@ThreadConfined(type = ThreadType.JFX)\n    private void cycleSlideShowImage(int d) {\n        stopVideo();\n        if (getFileID().isPresent()) {\n            int index = getGroupPane().getGrouping().fileIds().indexOf(getFileID());\n            final int size = getGroupPane().getGrouping().fileIds().size();\n            index = (index + d) % size;\n            if (index < 0) {\n                index += size;\n            }\n            setFile(getGroupPane().getGrouping().fileIds().get(index));\n\n        } else {\n            setFile(getGroupPane().getGrouping().fileIds().get(0));\n        }\n    }","commit_id":"ff11258e9c750213fb897a29ddc8c63db1f9572f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    @ThreadConfined(type = ThreadType.ANY)\n    public Category updateCategoryBorder() {\n        return getFile().map(file -> {\n            final Category category = file.getCategory();\n            final Border border1 = hasHashHit() && (category == Category.ZERO)\n                    ? HASH_BORDER\n                    : getCategoryBorder(category);\n            ToggleButton toggleForCategory = getToggleForCategory(category);\n            Platform.runLater(() -> {\n                getCategoryBorderRegion().setBorder(border1);\n                toggleForCategory.setSelected(true);\n            });\n            return category;\n        }).orElse(Category.ZERO);\n\n    }","id":33341,"modified_method":"@Override\n    @ThreadConfined(type = ThreadType.ANY)\n    public Category updateCategory() {\n        if (getFile().isPresent()) {\n            final Category category = super.updateCategory();\n            ToggleButton toggleForCategory = getToggleForCategory(category);\n            Platform.runLater(() -> {\n                toggleForCategory.setSelected(true);\n            });\n            return category;\n        } else {\n            return Category.ZERO;\n        }\n    }","commit_id":"ff11258e9c750213fb897a29ddc8c63db1f9572f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Subscribe\n    public void handleTagDeleted(ContentTagDeletedEvent event) {\n        ContentTag deleted = event.getDeletedTag();\n        if (isCategoryTagName(deleted.getName())) {\n\n            Category deletedCat = CategoryManager.fromTagName(deleted.getName());\n            if (deletedCat != Category.ZERO) {\n                decrementCategoryCount(deletedCat);\n            }\n            fireChange(Collections.singleton(deleted.getId()), null);\n        }\n    }","id":33342,"modified_method":"@Subscribe\n    public void handleTagDeleted(ContentTagDeletedEvent event) {\n        ContentTag deleted = event.getDeletedTag();\n        if (isCategoryTagName(deleted.getName())) {\n\n            Category deletedCat = CategoryManager.fromTagName(deleted.getName());\n            if (deletedCat != Category.ZERO) {\n                decrementCategoryCount(deletedCat);\n            }\n            fireChange(Collections.singleton(deleted.getContent().getId()), null);\n        }\n    }","commit_id":"d19dbbeaba4781910caef03699d530ad4c62031b","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Subscribe\n    public void handleTagAdded(ContentTagAddedEvent event) {\n        ContentTag addedTag = event.getAddedTag();\n        if (isCategoryTagName(addedTag.getName())) {\n            final DrawableTagsManager tagsManager = controller.getTagsManager();\n            try {\n                //remove old category tag(s) if necessary\n                List<ContentTag> allContentTags = tagsManager.getContentTagsByContent(addedTag.getContent());\n\n                for (ContentTag ct : allContentTags) {\n                    if (ct.getId() != addedTag.getId()\n                            && CategoryManager.isCategoryTagName(ct.getName())) {\n                        try {\n                            tagsManager.deleteContentTag(ct);\n                        } catch (TskCoreException tskException) {\n                            LOGGER.log(Level.SEVERE, \"Failed to delete content tag. Unable to maintain categories in a consistent state.\", tskException);\n                        }\n                    }\n                }\n            } catch (TskCoreException tskException) {\n                LOGGER.log(Level.SEVERE, \"Failed to get content tags for content.  Unable to maintain category in a consistent state.\", tskException);\n            }\n            Category newCat = CategoryManager.fromTagName(addedTag.getName());\n            if (newCat != Category.ZERO) {\n                incrementCategoryCount(newCat);\n            }\n\n            fireChange(Collections.singleton(addedTag.getId()), newCat);\n        }\n    }","id":33343,"modified_method":"@Subscribe\n    public void handleTagAdded(ContentTagAddedEvent event) {\n        ContentTag addedTag = event.getAddedTag();\n        if (isCategoryTagName(addedTag.getName())) {\n            final DrawableTagsManager tagsManager = controller.getTagsManager();\n            try {\n                //remove old category tag(s) if necessary\n                List<ContentTag> allContentTags = tagsManager.getContentTagsByContent(addedTag.getContent());\n\n                for (ContentTag ct : allContentTags) {\n                    if (ct.getId() != addedTag.getId()\n                            && CategoryManager.isCategoryTagName(ct.getName())) {\n                        try {\n                            tagsManager.deleteContentTag(ct);\n                        } catch (TskCoreException tskException) {\n                            LOGGER.log(Level.SEVERE, \"Failed to delete content tag. Unable to maintain categories in a consistent state.\", tskException);\n                        }\n                    }\n                }\n            } catch (TskCoreException tskException) {\n                LOGGER.log(Level.SEVERE, \"Failed to get content tags for content.  Unable to maintain category in a consistent state.\", tskException);\n            }\n            Category newCat = CategoryManager.fromTagName(addedTag.getName());\n            if (newCat != Category.ZERO) {\n                incrementCategoryCount(newCat);\n            }\n\n            fireChange(Collections.singleton(addedTag.getContent().getId()), newCat);\n        }\n    }","commit_id":"d19dbbeaba4781910caef03699d530ad4c62031b","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public DeleteFollowUpTagAction(final ImageGalleryController controller, final DrawableFile<?> file) {\n        super(\"Delete Follow Up Tag\");\n        this.fileID = file.getId();\n        setEventHandler((ActionEvent t) -> {\n            new SwingWorker<Void, Void>() {\n\n                @Override\n                protected Void doInBackground() throws Exception {\n                    final DrawableTagsManager tagsManager = controller.getTagsManager();\n\n                    try {\n                        final TagName followUpTagName = tagsManager.getFollowUpTagName();\n                    \n                        List<ContentTag> contentTagsByContent = tagsManager.getContentTagsByContent(file);\n                        for (ContentTag ct : contentTagsByContent) {\n                            if (ct.getName().getDisplayName().equals(followUpTagName.getDisplayName())) {\n                                tagsManager.deleteContentTag(ct);\n                            }\n                        }\n                    } catch (TskCoreException ex) {\n                        LOGGER.log(Level.SEVERE, \"Failed to delete follow up tag.\", ex);\n                    }\n                    return null;\n                }\n            }.execute();\n        });\n    }","id":33344,"modified_method":"public DeleteFollowUpTagAction(final ImageGalleryController controller, final DrawableFile<?> file) {\n        super(\"Delete Follow Up Tag\");\n        setEventHandler((ActionEvent t) -> {\n            new SwingWorker<Void, Void>() {\n\n                @Override\n                protected Void doInBackground() throws Exception {\n                    final DrawableTagsManager tagsManager = controller.getTagsManager();\n\n                    try {\n                        final TagName followUpTagName = tagsManager.getFollowUpTagName();\n                    \n                        List<ContentTag> contentTagsByContent = tagsManager.getContentTagsByContent(file);\n                        for (ContentTag ct : contentTagsByContent) {\n                            if (ct.getName().getDisplayName().equals(followUpTagName.getDisplayName())) {\n                                tagsManager.deleteContentTag(ct);\n                            }\n                        }\n                    } catch (TskCoreException ex) {\n                        LOGGER.log(Level.SEVERE, \"Failed to delete follow up tag.\", ex);\n                    }\n                    return null;\n                }\n            }.execute();\n        });\n    }","commit_id":"d19dbbeaba4781910caef03699d530ad4c62031b","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void setFileHelper(Long newFileID) {\n        fileIDOpt = Optional.of(newFileID);\n        if (newFileID == null) {\n            Platform.runLater(() -> {\n                imageView.setImage(null);\n                tableView.getItems().clear();\n                getCategoryBorderRegion().setBorder(null);\n\n            });\n        } else {\n            updateUI();\n        }\n    }","id":33345,"modified_method":"@Override\n    synchronized protected void setFileHelper(Long newFileID) {\n        setFileIDOpt(Optional.ofNullable(newFileID));\n        if (newFileID == null) {\n            Platform.runLater(() -> {\n                imageView.setImage(null);\n                tableView.getItems().clear();\n                getCategoryBorderRegion().setBorder(null);\n\n            });\n        } else {\n            updateUI();\n        }\n    }","commit_id":"d19dbbeaba4781910caef03699d530ad4c62031b","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public MetaDataPane(ImageGalleryController controller) {\n        this.controller = controller;\n\n        FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource(\"MetaDataPane.fxml\"));\n        fxmlLoader.setRoot(this);\n        fxmlLoader.setController(this);\n\n        try {\n            fxmlLoader.load();\n        } catch (IOException exception) {\n            throw new RuntimeException(exception);\n        }\n    }","id":33346,"modified_method":"public MetaDataPane(ImageGalleryController controller) {\n        super(controller);\n\n        FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource(\"MetaDataPane.fxml\"));\n        fxmlLoader.setRoot(this);\n        fxmlLoader.setController(this);\n\n        try {\n            fxmlLoader.load();\n        } catch (IOException exception) {\n            throw new RuntimeException(exception);\n        }\n    }","commit_id":"d19dbbeaba4781910caef03699d530ad4c62031b","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@FXML\n    @SuppressWarnings(\"unchecked\")\n    void initialize() {\n        assert attributeColumn != null : \"fx:id=\\\"attributeColumn\\\" was not injected: check your FXML file 'MetaDataPane.fxml'.\";\n        assert imageView != null : \"fx:id=\\\"imageView\\\" was not injected: check your FXML file 'MetaDataPane.fxml'.\";\n        assert tableView != null : \"fx:id=\\\"tableView\\\" was not injected: check your FXML file 'MetaDataPane.fxml'.\";\n        assert valueColumn != null : \"fx:id=\\\"valueColumn\\\" was not injected: check your FXML file 'MetaDataPane.fxml'.\";\n        getController().getTagsManager().registerListener(this);\n        getController().getCategoryManager().registerListener(this);\n\n        tableView.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);\n        tableView.setPlaceholder(new Label(\"Select a file to show its details here.\"));\n\n        attributeColumn.setCellValueFactory((param) -> new SimpleObjectProperty<>(param.getValue().getKey()));\n        attributeColumn.setCellFactory((param) -> new TableCell<Pair<DrawableAttribute<?>, ? extends Object>, DrawableAttribute<?>>() {\n            @Override\n            protected void updateItem(DrawableAttribute<?> item, boolean empty) {\n                super.updateItem(item, empty); //To change body of generated methods, choose Tools | Templates.\n                if (item != null) {\n                    setText(item.getDisplayName());\n                    setGraphic(new ImageView(item.getIcon()));\n                } else {\n                    setGraphic(null);\n                    setText(null);\n                }\n            }\n        });\n\n        attributeColumn.setPrefWidth(USE_COMPUTED_SIZE);\n\n        valueColumn.setCellValueFactory((p) -> {\n            return (p.getValue().getKey() == DrawableAttribute.TAGS)\n                    ? new SimpleStringProperty(((Collection<TagName>) p.getValue().getValue()).stream()\n                            .map(TagName::getDisplayName)\n                            .filter(Category::isNotCategoryName)\n                            .collect(Collectors.joining(\" ; \")))\n                    : new SimpleStringProperty(StringUtils.join((Iterable<?>) p.getValue().getValue(), \" ; \"));\n        });\n        valueColumn.setPrefWidth(USE_COMPUTED_SIZE);\n        valueColumn.setCellFactory((p) -> new TableCell<Pair<DrawableAttribute<?>, ? extends Object>, String>() {\n            @Override\n            public void updateItem(String item, boolean empty) {\n                super.updateItem(item, empty);\n                if (!isEmpty()) {\n                    Text text = new Text(item);\n                    text.wrappingWidthProperty().bind(getTableColumn().widthProperty());\n                    setGraphic(text);\n                } else {\n                    setGraphic(null);\n                }\n            }\n        });\n        tableView.getColumns().setAll(Arrays.asList(attributeColumn, valueColumn));\n\n        //listen for selection change\n        controller.getSelectionModel().lastSelectedProperty().addListener((observable, oldFileID, newFileID) -> {\n            setFile(newFileID);\n        });\n    }","id":33347,"modified_method":"@FXML\n    @SuppressWarnings(\"unchecked\")\n    void initialize() {\n        assert attributeColumn != null : \"fx:id=\\\"attributeColumn\\\" was not injected: check your FXML file 'MetaDataPane.fxml'.\";\n        assert imageView != null : \"fx:id=\\\"imageView\\\" was not injected: check your FXML file 'MetaDataPane.fxml'.\";\n        assert tableView != null : \"fx:id=\\\"tableView\\\" was not injected: check your FXML file 'MetaDataPane.fxml'.\";\n        assert valueColumn != null : \"fx:id=\\\"valueColumn\\\" was not injected: check your FXML file 'MetaDataPane.fxml'.\";\n        getController().getTagsManager().registerListener(this);\n        getController().getCategoryManager().registerListener(this);\n\n        tableView.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);\n        tableView.setPlaceholder(new Label(\"Select a file to show its details here.\"));\n\n        attributeColumn.setCellValueFactory((param) -> new SimpleObjectProperty<>(param.getValue().getKey()));\n        attributeColumn.setCellFactory((param) -> new TableCell<Pair<DrawableAttribute<?>, ? extends Object>, DrawableAttribute<?>>() {\n            @Override\n            protected void updateItem(DrawableAttribute<?> item, boolean empty) {\n                super.updateItem(item, empty); //To change body of generated methods, choose Tools | Templates.\n                if (item != null) {\n                    setText(item.getDisplayName());\n                    setGraphic(new ImageView(item.getIcon()));\n                } else {\n                    setGraphic(null);\n                    setText(null);\n                }\n            }\n        });\n\n        attributeColumn.setPrefWidth(USE_COMPUTED_SIZE);\n\n        valueColumn.setCellValueFactory((p) -> {\n            return (p.getValue().getKey() == DrawableAttribute.TAGS)\n                    ? new SimpleStringProperty(((Collection<TagName>) p.getValue().getValue()).stream()\n                            .map(TagName::getDisplayName)\n                            .filter(Category::isNotCategoryName)\n                            .collect(Collectors.joining(\" ; \")))\n                    : new SimpleStringProperty(StringUtils.join((Iterable<?>) p.getValue().getValue(), \" ; \"));\n        });\n        valueColumn.setPrefWidth(USE_COMPUTED_SIZE);\n        valueColumn.setCellFactory((p) -> new TableCell<Pair<DrawableAttribute<?>, ? extends Object>, String>() {\n            @Override\n            public void updateItem(String item, boolean empty) {\n                super.updateItem(item, empty);\n                if (!isEmpty()) {\n                    Text text = new Text(item);\n                    text.wrappingWidthProperty().bind(getTableColumn().widthProperty());\n                    setGraphic(text);\n                } else {\n                    setGraphic(null);\n                }\n            }\n        });\n        tableView.getColumns().setAll(Arrays.asList(attributeColumn, valueColumn));\n\n        //listen for selection change\n        getController().getSelectionModel().lastSelectedProperty().addListener((observable, oldFileID, newFileID) -> {\n            setFile(newFileID);\n        });\n    }","commit_id":"d19dbbeaba4781910caef03699d530ad4c62031b","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public void updateUI() {\n        getFile().ifPresent(file -> {\n            final Image icon = file.getThumbnail();\n            final ObservableList<Pair<DrawableAttribute<?>, ? extends Object>> attributesList = file.getAttributesList();\n\n            Platform.runLater(() -> {\n                imageView.setImage(icon);\n                tableView.getItems().setAll(attributesList);\n            });\n\n            updateCategoryBorder();\n        });\n\n    }","id":33348,"modified_method":"public void updateUI() {\n        getFile().ifPresent(file -> {\n            final Image icon = file.getThumbnail();\n            final ObservableList<Pair<DrawableAttribute<?>, ? extends Object>> attributesList = file.getAttributesList();\n\n            Platform.runLater(() -> {\n                imageView.setImage(icon);\n                tableView.getItems().clear();\n                tableView.getItems().setAll(attributesList);\n            });\n\n            updateCategory();\n        });\n    }","commit_id":"d19dbbeaba4781910caef03699d530ad4c62031b","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@ThreadConfined(type = ThreadType.JFX)\n    private void cycleSlideShowImage(int d) {\n        stopVideo();\n        if (getFileID() != null) {\n            int index = getGroupPane().getGrouping().fileIds().indexOf(getFileID());\n            final int size = getGroupPane().getGrouping().fileIds().size();\n            index = (index + d) % size;\n            if (index < 0) {\n                index += size;\n            }\n            setFile(getGroupPane().getGrouping().fileIds().get(index));\n\n        } else {\n            setFile(getGroupPane().getGrouping().fileIds().get(0));\n        }\n    }","id":33349,"modified_method":"@ThreadConfined(type = ThreadType.JFX)\n    private void cycleSlideShowImage(int d) {\n        stopVideo();\n        if (getFileID().isPresent()) {\n            int index = getGroupPane().getGrouping().fileIds().indexOf(getFileID());\n            final int size = getGroupPane().getGrouping().fileIds().size();\n            index = (index + d) % size;\n            if (index < 0) {\n                index += size;\n            }\n            setFile(getGroupPane().getGrouping().fileIds().get(index));\n\n        } else {\n            setFile(getGroupPane().getGrouping().fileIds().get(0));\n        }\n    }","commit_id":"d19dbbeaba4781910caef03699d530ad4c62031b","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    @ThreadConfined(type = ThreadType.ANY)\n    public Category updateCategoryBorder() {\n        return getFile().map(file -> {\n            final Category category = file.getCategory();\n            final Border border1 = hasHashHit() && (category == Category.ZERO)\n                    ? HASH_BORDER\n                    : getCategoryBorder(category);\n            ToggleButton toggleForCategory = getToggleForCategory(category);\n            Platform.runLater(() -> {\n                getCategoryBorderRegion().setBorder(border1);\n                toggleForCategory.setSelected(true);\n            });\n            return category;\n        }).orElse(Category.ZERO);\n\n    }","id":33350,"modified_method":"@Override\n    @ThreadConfined(type = ThreadType.ANY)\n    public Category updateCategory() {\n        if (getFile().isPresent()) {\n            final Category category = super.updateCategory();\n            ToggleButton toggleForCategory = getToggleForCategory(category);\n            Platform.runLater(() -> {\n                toggleForCategory.setSelected(true);\n            });\n            return category;\n        } else {\n            return Category.ZERO;\n        }\n    }","commit_id":"d19dbbeaba4781910caef03699d530ad4c62031b","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public ChangelistTable()\n   {\n      table_ = new CellTable<StatusAndPath>(\n            100, resources_);\n\n      dataProvider_ = new ListDataProvider<StatusAndPath>();\n      sortHandler_ = new ColumnSortEvent.ListHandler<StatusAndPath>(\n            dataProvider_.getList());\n      table_.addColumnSortHandler(sortHandler_);\n\n      selectionModel_ = new MultiSelectionModel<StatusAndPath>(\n            new ProvidesKey<StatusAndPath>()\n            {\n               @Override\n               public Object getKey(StatusAndPath item)\n               {\n                  return item.getPath();\n               }\n            });\n      table_.setSelectionModel(selectionModel_);\n      dataProvider_.addDataDisplay(table_);\n\n      configureTable();\n\n      table_.setSize(\"100%\", \"auto\");\n\n      layout_ = new LayoutPanel();\n      ScrollPanel scrollPanel = new ScrollPanel(table_);\n      layout_.add(scrollPanel);\n      layout_.setWidgetTopBottom(scrollPanel, 0, Unit.PX, 0, Unit.PX);\n      layout_.setWidgetLeftRight(scrollPanel, 0, Unit.PX, 0, Unit.PX);\n      progressPanel_ = new ProgressPanel();\n      progressPanel_.getElement().getStyle().setBackgroundColor(\"white\");\n      layout_.add(progressPanel_);\n      layout_.setWidgetTopBottom(progressPanel_, 0, Unit.PX, 0, Unit.PX);\n      layout_.setWidgetLeftRight(progressPanel_, 0, Unit.PX, 0, Unit.PX);\n\n      setProgress(true);\n\n      initWidget(layout_);\n   }","id":33351,"modified_method":"public ChangelistTable()\n   {\n      table_ = new StatusCellTable(100, resources_);\n\n      dataProvider_ = new ListDataProvider<StatusAndPath>();\n      sortHandler_ = new ColumnSortEvent.ListHandler<StatusAndPath>(\n            dataProvider_.getList());\n      table_.addColumnSortHandler(sortHandler_);\n\n      selectionModel_ = new MultiSelectionModel<StatusAndPath>(\n            new ProvidesKey<StatusAndPath>()\n            {\n               @Override\n               public Object getKey(StatusAndPath item)\n               {\n                  return item.getPath();\n               }\n            });\n      table_.setSelectionModel(selectionModel_);\n      dataProvider_.addDataDisplay(table_);\n\n      configureTable();\n\n      table_.setSize(\"100%\", \"auto\");\n\n      layout_ = new LayoutPanel();\n      ScrollPanel scrollPanel = new ScrollPanel(table_);\n      layout_.add(scrollPanel);\n      layout_.setWidgetTopBottom(scrollPanel, 0, Unit.PX, 0, Unit.PX);\n      layout_.setWidgetLeftRight(scrollPanel, 0, Unit.PX, 0, Unit.PX);\n      progressPanel_ = new ProgressPanel();\n      progressPanel_.getElement().getStyle().setBackgroundColor(\"white\");\n      layout_.add(progressPanel_);\n      layout_.setWidgetTopBottom(progressPanel_, 0, Unit.PX, 0, Unit.PX);\n      layout_.setWidgetLeftRight(progressPanel_, 0, Unit.PX, 0, Unit.PX);\n\n      setProgress(true);\n\n      initWidget(layout_);\n   }","commit_id":"9aa305725f5d11fa2440fae2eea8452238f19847","url":"https://github.com/rstudio/rstudio"},{"original_method":"public Result(String projectFile, \n                    String newDefaultProjectLocation)\n      {\n         projectFile_ = projectFile;\n         newDefaultProjectLocation_ = newDefaultProjectLocation;\n      }","id":33352,"modified_method":"public Result(String projectFile, \n                    String newDefaultProjectLocation,\n                    String gitRepoUrl)\n      {\n         projectFile_ = projectFile;\n         newDefaultProjectLocation_ = newDefaultProjectLocation;\n         gitRepoUrl_ = gitRepoUrl;\n      }","commit_id":"9aa305725f5d11fa2440fae2eea8452238f19847","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   protected NewProjectDialog.Result collectInput()\n   {\n      if (newDirButton_.getValue())\n      {\n         String name = txtProjectName_.getText().trim();\n         String dir = newProjectParent_.getText();\n         if (name.length() > 0 && dir.length() > 0)\n         {\n            String projDir = FileSystemItem.createDir(dir).completePath(name);\n            String projFile = projFileFromDir(projDir);\n            String newDefaultLocation = null;\n            if (!dir.equals(defaultNewProjectLocation_))\n               newDefaultLocation = dir;\n            return new Result(projFile, newDefaultLocation);\n         }\n         else\n         {\n            return null;\n         }\n      }\n      else\n      {\n         String dir = existingProjectDir_.getText();\n         if (dir.length() > 0)\n         {\n            return new Result(projFileFromDir(dir), null);\n         }\n         else\n         {\n            return null;\n         }\n      }\n   }","id":33353,"modified_method":"@Override\n   protected NewProjectDialog.Result collectInput()\n   {\n      if (newDirButton_.getValue())\n      {\n         String name = txtProjectName_.getText().trim();\n         String dir = newProjectParent_.getText();\n         if (name.length() > 0 && dir.length() > 0)\n         {\n            String projDir = FileSystemItem.createDir(dir).completePath(name);\n            String projFile = projFileFromDir(projDir);\n            String newDefaultLocation = null;\n            if (!dir.equals(defaultNewProjectLocation_))\n               newDefaultLocation = dir;\n            return new Result(projFile, newDefaultLocation, null);\n         }\n         else\n         {\n            return null;\n         }\n      }\n      else if (existingDirButton_.getValue())\n      {\n         String dir = existingProjectDir_.getText();\n         if (dir.length() > 0)\n         {\n            return new Result(projFileFromDir(dir), null, null);\n         }\n         else\n         {\n            return null;\n         }\n      }\n      else if (existingRepoButton_.getValue())\n      {\n         String url = txtRepoUrl_.getText().trim();\n         String dir = existingRepoDestDir_.getText().trim();\n         if (url.length() > 0 && dir.length() > 0)\n         {\n            return new Result(null, dir, url);\n         }\n         else\n         {\n            return null;\n         }\n      }\n      else\n      {\n         return null;\n      }\n   }","commit_id":"9aa305725f5d11fa2440fae2eea8452238f19847","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void manageEnabled()\n   {\n      boolean createNewDir = newDirButton_.getValue();\n      \n      txtProjectName_.setEnabled(createNewDir);\n      newProjectParent_.setEnabled(createNewDir);\n      existingProjectDir_.setEnabled(!createNewDir);\n      \n   }","id":33354,"modified_method":"private void manageEnabled()\n   {\n      boolean createNewDir = newDirButton_.getValue();\n      boolean existingDir = existingDirButton_.getValue();\n      boolean existingRepo = existingRepoButton_.getValue();\n      \n      txtProjectName_.setEnabled(createNewDir);\n      newProjectParent_.setEnabled(createNewDir);\n\n      existingProjectDir_.setEnabled(existingDir);\n\n      txtRepoUrl_.setEnabled(existingRepo);\n      existingRepoDestDir_.setEnabled(existingRepo);\n\n\n      Widget widgetToHide =\n            newDirControls_.isVisible() ? newDirControls_ :\n            existingDirControls_.isVisible() ? existingDirControls_ :\n            existingRepoControls_.isVisible() ? existingRepoControls_ :\n            null;\n      Widget widgetToShow =\n            createNewDir ? newDirControls_ :\n            existingDir ? existingDirControls_ :\n            existingRepo ? existingRepoControls_ :\n            null;\n      if (widgetToHide != widgetToShow)\n      {\n         ArrayList<Widget> fadeOut = new ArrayList<Widget>();\n         if (widgetToHide != null)\n            fadeOut.add(widgetToHide);\n         final ArrayList<Widget> fadeIn = new ArrayList<Widget>();\n         if (widgetToShow != null)\n            fadeIn.add(widgetToShow);\n\n         new FadeOutAnimation(fadeOut, new Command()\n         {\n            @Override\n            public void execute()\n            {\n               new FadeInAnimation(fadeIn, 1.0, new Command()\n               {\n                  @Override\n                  public void execute()\n                  {\n                     if (postAnimationCallback_ != null)\n                     {\n                        postAnimationCallback_.execute();\n                        postAnimationCallback_ = null;\n                     }\n                  }\n               }).run(300);\n            }\n         }).run(300);\n      }\n   }","commit_id":"9aa305725f5d11fa2440fae2eea8452238f19847","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   protected boolean validate(NewProjectDialog.Result input)\n   {\n      if (input == null)\n      {\n         if (newDirButton_.getValue())\n         {\n            if (txtProjectName_.getText().trim().length() == 0)\n            {\n               globalDisplay_.showMessage(\n                     MessageDialog.WARNING,\n                     \"Error\", \n                     \"You must specify a name for the new project directory.\",\n                     txtProjectName_);\n            }\n         }\n         else\n         {\n            if (existingProjectDir_.getText().trim().length() == 0)\n            {\n               globalDisplay_.showMessage(\n                     MessageDialog.WARNING,\n                     \"Error\", \n                     \"You must specify an existing working directory to \" +\n                     \"create the new project within.\");\n            }      \n         }\n         \n         return false;\n      }\n      else\n      {\n         return true;\n      }\n         \n   }","id":33355,"modified_method":"@Override\n   protected boolean validate(NewProjectDialog.Result input)\n   {\n      if (input == null)\n      {\n         if (newDirButton_.getValue())\n         {\n            if (txtProjectName_.getText().trim().length() == 0)\n            {\n               globalDisplay_.showMessage(\n                     MessageDialog.WARNING,\n                     \"Error\", \n                     \"You must specify a name for the new project directory.\",\n                     txtProjectName_);\n            }\n         }\n         else if (existingDirButton_.getValue())\n         {\n            if (existingProjectDir_.getText().trim().length() == 0)\n            {\n               globalDisplay_.showMessage(\n                     MessageDialog.WARNING,\n                     \"Error\", \n                     \"You must specify an existing working directory to \" +\n                     \"create the new project within.\");\n            }      \n         }\n         else if (existingRepoButton_.getValue())\n         {\n            if (txtRepoUrl_.getText().trim().length() == 0\n                  || existingRepoDestDir_.getText().trim().length() == 0)\n            {\n               globalDisplay_.showMessage(\n                     MessageDialog.WARNING,\n                     \"Error\",\n                     \"You must specify a git repository URL and existing \" +\n                     \"directory to create the new project within.\");\n            }\n         }\n         \n         return false;\n      }\n      else\n      {\n         return true;\n      }\n         \n   }","commit_id":"9aa305725f5d11fa2440fae2eea8452238f19847","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   protected Widget createMainWidget()\n   {\n      Styles styles = RESOURCES.styles();\n      \n      VerticalPanel verticalPanel = new VerticalPanel();\n      verticalPanel.addStyleName(styles.mainWidget());\n      \n      newDirButton_ = new RadioButton(\n            \"Type\", \n            \"Create a new empty project\");\n      newDirButton_.addStyleName(styles.projectTypeRadioButton());\n      newDirButton_.setValue(true);\n      newDirButton_.addValueChangeHandler(new ValueChangeHandler<Boolean>() {\n         @Override\n         public void onValueChange(ValueChangeEvent<Boolean> event)\n         {\n            manageEnabled();\n            \n            if (event.getValue())\n               txtProjectName_.setFocus(true);\n         }\n      });\n     \n      verticalPanel.add(newDirButton_); \n      \n      VerticalPanel emptyLocationPanel = new VerticalPanel();\n      emptyLocationPanel.addStyleName(styles.newProjectLocationPanel());\n      \n      // project name\n      lblNewProjectName_ = new Label(\"Project directory name:\");\n      emptyLocationPanel.add(lblNewProjectName_);\n      txtProjectName_ = new TextBox();\n      txtProjectName_.addStyleName(styles.projectNameTextBox());\n      emptyLocationPanel.add(txtProjectName_); \n      \n      // project dir\n      newProjectParent_ = new DirectoryChooserTextBox(\"Create in:\", \n                                                      txtProjectName_);\n      newProjectParent_.setText(defaultNewProjectLocation_.getPath());\n      \n      emptyLocationPanel.add(newProjectParent_);\n      \n      verticalPanel.add(emptyLocationPanel);\n      \n      verticalPanel.add(new HTML(\"<br/>\"));\n      \n      existingDirButton_ = new RadioButton(\n            \"Type\",\n            \"Create a project based on an existing working directory\");\n      existingDirButton_.addStyleName(styles.projectTypeRadioButton());\n      existingDirButton_.addValueChangeHandler(new ValueChangeHandler<Boolean>() {\n         @Override\n         public void onValueChange(ValueChangeEvent<Boolean> event)\n         {\n            manageEnabled();\n            \n            if (event.getValue() && existingProjectDir_.getText().length() == 0)\n            {\n               Scheduler.get().scheduleDeferred(new ScheduledCommand() {\n                  @Override\n                  public void execute()\n                  {\n                     existingProjectDir_.click();     \n                  }       \n               });          \n            }\n         }\n         \n      });\n     \n      verticalPanel.add(existingDirButton_);\n      \n      VerticalPanel existingLocationPanel = new VerticalPanel();\n      existingLocationPanel.addStyleName(styles.newProjectLocationPanel());\n      \n      existingProjectDir_ = new DirectoryChooserTextBox(\"Directory:\", null);\n      existingLocationPanel.add(existingProjectDir_);\n      verticalPanel.add(existingLocationPanel);\n      \n      manageEnabled();\n      \n      return verticalPanel;\n   }","id":33356,"modified_method":"@Override\n   protected Widget createMainWidget()\n   {\n      // project dir\n      newProjectParent_ = new DirectoryChooserTextBox(\"Create in:\",\n                                                      txtProjectName_);\n      newProjectParent_.setText(defaultNewProjectLocation_.getPath());\n\n      existingProjectDir_ = new DirectoryChooserTextBox(\"Directory:\", null);\n\n      existingRepoDestDir_ = new DirectoryChooserTextBox(\"Create in:\",\n                                                         txtRepoUrl_);\n      existingRepoDestDir_.setText(defaultNewProjectLocation_.getPath());\n\n      VerticalPanel verticalPanel =\n            GWT.<Binder>create(Binder.class).createAndBindUi(this);\n\n      // Comment out the next line to show git repo option\n      existingRepoButton_.setVisible(false);\n\n      newDirButton_.addValueChangeHandler(new ValueChangeHandler<Boolean>()\n      {\n         @Override\n         public void onValueChange(ValueChangeEvent<Boolean> event)\n         {\n            manageEnabled();\n\n            if (event.getValue())\n               postAnimationCallback_ = new Command()\n               {\n                  @Override\n                  public void execute()\n                  {\n                     txtProjectName_.setFocus(true);\n                  }\n               };\n         }\n      });\n\n      existingDirButton_.addValueChangeHandler(new ValueChangeHandler<Boolean>() {\n         @Override\n         public void onValueChange(ValueChangeEvent<Boolean> event)\n         {\n            manageEnabled();\n\n            if (event.getValue())\n               postAnimationCallback_ = new Command()\n               {\n                  @Override\n                  public void execute()\n                  {\n                     existingProjectDir_.focusButton();\n                  }\n               };\n         }\n      });\n\n      existingRepoButton_.addValueChangeHandler(new ValueChangeHandler<Boolean>()\n      {\n         @Override\n         public void onValueChange(ValueChangeEvent<Boolean> event)\n         {\n            manageEnabled();\n\n            if (event.getValue())\n               postAnimationCallback_ = new Command()\n               {\n                  @Override\n                  public void execute()\n                  {\n                     txtRepoUrl_.setFocus(true);\n                  }\n               };\n         }\n      });\n\n      manageEnabled();\n      \n      return verticalPanel;\n   }","commit_id":"9aa305725f5d11fa2440fae2eea8452238f19847","url":"https://github.com/rstudio/rstudio"},{"original_method":"private Toolbar createToolbar(DataItem dataItem, Styles styles)\n   {\n\n      Toolbar toolbar = new EditingTargetToolbar(commands_);\n      toolbar.addLeftWidget(commands_.popoutDoc().createToolbarButton());\n      toolbar.addLeftSeparator();\n      findButton_ = new ToolbarButton(\n              FindReplaceBar.getFindIcon(),\n              new ClickHandler() {\n                 public void onClick(ClickEvent event)\n                 {\n                    filtered_ = !filtered_;\n                    setFilterUIVisible(filtered_);\n                    findButton_.setLeftImage(filtered_ ? \n                          FindReplaceBar.getFindLatchedIcon() :\n                          FindReplaceBar.getFindIcon());\n                 }\n              });\n      toolbar.addLeftWidget(findButton_);\n      find_ = new FindTextBox(\"Find in data\");\n      find_.getElement().getStyle().setMarginBottom(2, Unit.PX);\n      find_.setIconVisible(true);\n      toolbar.addRightWidget(find_);\n      \n      find_.addValueChangeHandler(new ValueChangeHandler<String>()\n      {\n         @Override\n         public void onValueChange(ValueChangeEvent<String> arg0)\n         {\n            applySearch(getWindow(), arg0.getValue());\n         }\n      });\n      \n      return toolbar;\n   }","id":33357,"modified_method":"private Toolbar createToolbar(DataItem dataItem, Styles styles)\n   {\n\n      Toolbar toolbar = new EditingTargetToolbar(commands_);\n      toolbar.addLeftWidget(commands_.popoutDoc().createToolbarButton());\n      toolbar.addLeftSeparator();\n      findButton_ = new ToolbarButton(\n              FindReplaceBar.getFindIcon(),\n              new ClickHandler() {\n                 public void onClick(ClickEvent event)\n                 {\n                    filtered_ = !filtered_;\n                    setFilterUIVisible(filtered_);\n                    findButton_.setLeftImage(filtered_ ? \n                          FindReplaceBar.getFindLatchedIcon() :\n                          FindReplaceBar.getFindIcon());\n                 }\n              });\n      toolbar.addLeftWidget(findButton_);\n\n      SearchWidget searchWidget = new SearchWidget(new SuggestOracle() {\n         @Override\n         public void requestSuggestions(Request request, Callback callback)\n         {\n            // no suggestions\n            callback.onSuggestionsReady(\n                  request,\n                  new Response(new ArrayList<Suggestion>()));\n         }\n      });\n      searchWidget.addValueChangeHandler(new ValueChangeHandler<String>() {\n         @Override\n         public void onValueChange(ValueChangeEvent<String> event)\n         {\n            applySearch(getWindow(), event.getValue());\n         }\n      });\n\n      toolbar.addRightWidget(searchWidget);\n\n      return toolbar;\n   }","commit_id":"4da8d2645356d92ee87639003d42058592bae94d","url":"https://github.com/rstudio/rstudio"},{"original_method":"/**\r\n     * Constructs an CmsMultiSelectWidget with the in XSD schema declared configuration.<p>\r\n     * @param config The configuration string given from OpenCms XSD.\r\n     */\r\n    public CmsMultiSelectWidget(String config) {\r\n\r\n        // parse configuration and create a new CmsMultiSelectCell\r\n        CmsMultiSelectCell cell = new CmsMultiSelectCell(parse(config));\r\n        cell.setOpenerText(\"Select value\");\r\n        // Place the check above the box using a vertical panel.\r\n        CmsPaddedPanel panel = new CmsPaddedPanel(0);\r\n        // All composites must call initWidget() in their constructors.\r\n        initWidget(panel);\r\n        panel.add(m_selectBox);\r\n\r\n        m_selectBox.addOption(cell);\r\n\r\n        // add change handler to the multi select box\r\n        List<CmsCheckBox> checkboxes = m_selectBox.getCheckboxes();\r\n        Iterator<CmsCheckBox> it = checkboxes.iterator();\r\n        while (it.hasNext()) {\r\n            it.next().addValueChangeHandler(new ValueChangeHandler<Boolean>() {\r\n\r\n                public void onValueChange(ValueChangeEvent<Boolean> arg0) {\r\n\r\n                    fireChangeEvent();\r\n\r\n                }\r\n\r\n            });\r\n        }\r\n\r\n    }","id":33358,"modified_method":"/**\r\n     * Constructs an OptionalTextBox with the given caption on the check.<p>\r\n     * @param config the configuration string.\r\n     */\r\n    @SuppressWarnings(\"boxing\")\r\n    public CmsMultiSelectWidget(String config) {\r\n\r\n        // generate a list of all radio button.\r\n        Map<String, CmsPair<String, Boolean>> list = parse(config);\r\n        m_arrayCheckbox = new CmsCheckBox[list.size()];\r\n        int j = 0;\r\n        for (Map.Entry<String, CmsPair<String, Boolean>> entry : list.entrySet()) {\r\n            m_arrayCheckbox[j] = new CmsCheckBox(entry.getKey());\r\n            m_arrayCheckbox[j].setInternalValue(entry.getValue().getFirst());\r\n            if (entry.getValue().getSecond()) {\r\n                m_defaultCheckBox.add(m_arrayCheckbox[j]);\r\n            }\r\n            m_arrayCheckbox[j].addValueChangeHandler(new ValueChangeHandler<Boolean>() {\r\n\r\n                public void onValueChange(ValueChangeEvent<Boolean> event) {\r\n\r\n                    fireChangeEvent();\r\n\r\n                }\r\n\r\n            });\r\n            j++;\r\n        }\r\n        // add separate style to the panel.\r\n        m_panel.addStyleName(I_CmsLayoutBundle.INSTANCE.widgetCss().radioButtonPanel());\r\n        // iterate about all chechboxes.\r\n        for (int i = 0; i < m_arrayCheckbox.length; i++) {\r\n            // add a separate style each checkbox .\r\n            m_arrayCheckbox[i].addStyleName(I_CmsLayoutBundle.INSTANCE.widgetCss().checkboxlabel());\r\n            // add the checkbox to the panel.\r\n            m_panel.add(m_arrayCheckbox[i]);\r\n        }\r\n        // All composites must call initWidget() in their constructors.\r\n        initWidget(m_panel);\r\n\r\n    }","commit_id":"2f7f3d9bbaec64b29a81833ba06926a7a5c7ccfb","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * @see com.google.gwt.user.client.ui.HasValue#setValue(java.lang.Object)\r\n     */\r\n    public void setValue(String value) {\r\n\r\n        setValue(value, true);\r\n\r\n    }","id":33359,"modified_method":"/**\r\n     * @see com.google.gwt.user.client.ui.HasValue#setValue(java.lang.Object)\r\n     */\r\n    public void setValue(String value) {\r\n\r\n        setValue(value, false);\r\n\r\n    }","commit_id":"2f7f3d9bbaec64b29a81833ba06926a7a5c7ccfb","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * @see com.alkacon.acacia.client.widgets.I_EditWidget#setActive(boolean)\r\n     */\r\n    public void setActive(boolean active) {\r\n\r\n        m_active = active;\r\n        if (active) {\r\n            fireChangeEvent();\r\n        }\r\n\r\n    }","id":33360,"modified_method":"/**\r\n     * @see com.alkacon.acacia.client.widgets.I_EditWidget#setActive(boolean)\r\n     */\r\n    public void setActive(boolean active) {\r\n\r\n        // check if the value has changed. If there is no change do nothing.\r\n        if (m_active == active) {\r\n            return;\r\n        }\r\n        // set the new value.\r\n        m_active = active;\r\n        // Iterate about all checkboxes.\r\n        for (int i = 0; i < m_arrayCheckbox.length; i++) {\r\n            // set the checkbox active / inactive.\r\n            m_arrayCheckbox[i].setEnabled(active);\r\n            // if this widget is set inactive.\r\n            if (!active) {\r\n                // deselect all checkboxes.\r\n                m_arrayCheckbox[i].setChecked(active);\r\n            } else {\r\n                // select the default value if set.\r\n                if (m_defaultCheckBox != null) {\r\n                    Iterator<CmsCheckBox> it = m_defaultCheckBox.iterator();\r\n                    while (it.hasNext()) {\r\n                        it.next().setChecked(active);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // fire value change event.\r\n        if (active) {\r\n            fireChangeEvent();\r\n        }\r\n\r\n    }","commit_id":"2f7f3d9bbaec64b29a81833ba06926a7a5c7ccfb","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * Represents a value change event.<p>\r\n     * \r\n     */\r\n    public void fireChangeEvent() {\r\n\r\n        // generate save string\r\n        String values = m_selectBox.getFormValueAsString();\r\n        // save string\r\n        ValueChangeEvent.fire(this, values);\r\n\r\n    }","id":33361,"modified_method":"/**\r\n     * Represents a value change event.<p>\r\n     * \r\n     */\r\n    public void fireChangeEvent() {\r\n\r\n        ValueChangeEvent.fire(this, generateValue());\r\n    }","commit_id":"2f7f3d9bbaec64b29a81833ba06926a7a5c7ccfb","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * @see com.alkacon.acacia.client.widgets.I_EditWidget#onAttachWidget()\r\n     */\r\n    public void onAttachWidget() {\r\n\r\n        onAttach();\r\n    }","id":33362,"modified_method":"/**\r\n     * @see com.alkacon.acacia.client.widgets.I_EditWidget#onAttachWidget()\r\n     */\r\n    public void onAttachWidget() {\r\n\r\n        super.onAttach();\r\n    }","commit_id":"2f7f3d9bbaec64b29a81833ba06926a7a5c7ccfb","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * @see com.google.gwt.user.client.ui.HasValue#getValue()\r\n     */\r\n    public String getValue() {\r\n\r\n        return m_selectBox.getFormValueAsString();\r\n    }","id":33363,"modified_method":"/**\r\n     * @see com.google.gwt.user.client.ui.HasValue#getValue()\r\n     */\r\n    public String getValue() {\r\n\r\n        return generateValue();\r\n    }","commit_id":"2f7f3d9bbaec64b29a81833ba06926a7a5c7ccfb","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * @see com.google.gwt.user.client.ui.HasValue#setValue(java.lang.Object, boolean)\r\n     */\r\n    public void setValue(String value, boolean fireEvents) {\r\n\r\n        m_selectBox.setFormValueAsString(value);\r\n\r\n        if (fireEvents) {\r\n            fireChangeEvent();\r\n        }\r\n\r\n    }","id":33364,"modified_method":"/**\r\n     * @see com.google.gwt.user.client.ui.HasValue#setValue(java.lang.Object, boolean)\r\n     */\r\n    public void setValue(String value, boolean fireEvents) {\r\n\r\n        String[] values;\r\n        if ((value != null) && (value != \"\")) {\r\n            if (value.contains(\",\")) {\r\n                values = value.split(\",\");\r\n            } else {\r\n                values = new String[] {value};\r\n            }\r\n            for (int i = 0; i < m_arrayCheckbox.length; i++) {\r\n                m_arrayCheckbox[i].setChecked(false);\r\n                for (int j = 0; j < values.length; j++) {\r\n                    if (m_arrayCheckbox[i].getInternalValue().equals(values[j])) {\r\n                        m_arrayCheckbox[i].setChecked(true);\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        // fire change event.\r\n        if (fireEvents) {\r\n            fireChangeEvent();\r\n        }\r\n\r\n    }","commit_id":"2f7f3d9bbaec64b29a81833ba06926a7a5c7ccfb","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private void init()\n   {\n      addKeyPressHandler(new KeyPressHandler()\n      {\n         @Override\n         public void onKeyPress(KeyPressEvent event)\n         {\n            char charCode = event.getCharCode();\n            if (charCode >= '0' && charCode <= '9')\n               return;\n            if (Character.isLetterOrDigit(charCode))\n               event.preventDefault();\n         }\n      });\n   }","id":33365,"modified_method":"private void init()\n   {\n      addFocusHandler(new FocusHandler()\n      {\n         @Override\n         public void onFocus(FocusEvent event)\n         {\n            selectAll();\n         }\n      });\n\n      addKeyDownHandler(new KeyDownHandler()\n      {\n         @Override\n         public void onKeyDown(KeyDownEvent event)\n         {\n            int modifiers = KeyboardShortcut.getModifierValue(event.getNativeEvent());\n            if (modifiers == KeyboardShortcut.NONE\n                && (event.isUpArrow() || event.isDownArrow()))\n            {\n               event.preventDefault();\n               event.stopPropagation();\n\n               try\n               {\n                  int value = Integer.parseInt(getText());\n                  value += event.isUpArrow() ? 1 : -1;\n                  setValue(value + \"\", true);\n                  selectAll();\n               }\n               catch (NumberFormatException nfe)\n               {\n                  // just ignore\n               }\n            }\n         }\n      });\n\n      addKeyPressHandler(new KeyPressHandler()\n      {\n         @Override\n         public void onKeyPress(KeyPressEvent event)\n         {\n            char charCode = event.getCharCode();\n            if (charCode >= '0' && charCode <= '9')\n               return;\n            if (Character.isLetterOrDigit(charCode))\n               event.preventDefault();\n         }\n      });\n   }","commit_id":"7158e52d5417dc09433123b1ee9d84e76bc4d0d6","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void updatePageNumber()\n   {\n      view_.getToolbarDisplay().getPageNumber().setValue(PDFView.currentPage(),\n                                                         false);\n   }","id":33366,"modified_method":"private void updatePageNumber()\n   {\n      view_.getToolbarDisplay().getPageNumber().setValue(\n                                             PDFView.currentPage() + \"\", false);\n   }","commit_id":"7158e52d5417dc09433123b1ee9d84e76bc4d0d6","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Inject\n   public PDFViewerPresenter(Display view,\n                             EventBus eventBus,\n                             Binder binder,\n                             Commands commands,\n                             FileTypeRegistry fileTypeRegistry,\n                             CompilePdfServerOperations server,\n                             GlobalDisplay globalDisplay)\n   {\n      view_ = view;\n      fileTypeRegistry_ = fileTypeRegistry;\n      server_ = server;\n      globalDisplay_ = globalDisplay;\n      commands_ = commands;\n      \n      binder.bind(commands, this);\n      \n      eventBus.addHandler(CompilePdfStartedEvent.TYPE, this);\n      eventBus.addHandler(CompilePdfCompletedEvent.TYPE, this);\n      \n      Window.addWindowClosingHandler(new ClosingHandler() {\n\n         @Override\n         public void onWindowClosing(ClosingEvent event)\n         {\n            if (compileIsRunning_)\n               terminateRunningCompile();\n         }\n      });\n\n      view_.getToolbarDisplay().getPrevButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            PDFView.previousPage();\n         }\n      });\n      view_.getToolbarDisplay().getNextButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            PDFView.nextPage();\n         }\n      });\n      view_.getToolbarDisplay().getThumbnailsButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            view_.toggleThumbnails();\n         }\n      });\n      view_.getToolbarDisplay().getPageNumber().addValueChangeHandler(new ValueChangeHandler<Integer>()\n      {\n         @Override\n         public void onValueChange(ValueChangeEvent<Integer> event)\n         {\n            if (event.getValue() != null)\n               PDFView.goToPage(event.getValue());\n         }\n      });\n      view_.getToolbarDisplay().getZoomIn().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            PDFView.zoomIn();\n         }\n      });\n      view_.getToolbarDisplay().getZoomOut().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            PDFView.zoomOut();\n         }\n      });\n\n      releaseOnDismiss_.add(PDFView.addPageChangeHandler(new PageChangeEvent.Handler()\n      {\n         @Override\n         public void onPageChange(PageChangeEvent event)\n         {\n            updatePageNumber();\n         }\n      }));\n      releaseOnDismiss_.add(PDFView.addPDFLoadHandler(new PDFLoadEvent.Handler()\n      {\n         @Override\n         public void onPDFLoad(PDFLoadEvent event)\n         {\n            view_.getToolbarDisplay().setPageCount(PDFView.pageCount());\n         }\n      }));\n   }","id":33367,"modified_method":"@Inject\n   public PDFViewerPresenter(Display view,\n                             EventBus eventBus,\n                             Binder binder,\n                             Commands commands,\n                             FileTypeRegistry fileTypeRegistry,\n                             CompilePdfServerOperations server,\n                             GlobalDisplay globalDisplay)\n   {\n      view_ = view;\n      fileTypeRegistry_ = fileTypeRegistry;\n      server_ = server;\n      globalDisplay_ = globalDisplay;\n      commands_ = commands;\n      \n      binder.bind(commands, this);\n      \n      eventBus.addHandler(CompilePdfStartedEvent.TYPE, this);\n      eventBus.addHandler(CompilePdfCompletedEvent.TYPE, this);\n      \n      Window.addWindowClosingHandler(new ClosingHandler() {\n\n         @Override\n         public void onWindowClosing(ClosingEvent event)\n         {\n            if (compileIsRunning_)\n               terminateRunningCompile();\n         }\n      });\n\n      view_.getToolbarDisplay().getPrevButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            PDFView.previousPage();\n         }\n      });\n      view_.getToolbarDisplay().getNextButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            PDFView.nextPage();\n         }\n      });\n      view_.getToolbarDisplay().getThumbnailsButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            view_.toggleThumbnails();\n         }\n      });\n\n      final HasValue<String> pageNumber =\n                                      view_.getToolbarDisplay().getPageNumber();\n      pageNumber.addValueChangeHandler(new ValueChangeHandler<String>()\n      {\n         @Override\n         public void onValueChange(ValueChangeEvent<String> event)\n         {\n            String value = pageNumber.getValue();\n            try\n            {\n               int intVal = Integer.parseInt(value);\n               if (intVal != PDFView.currentPage()\n                   && intVal >= 1 && intVal <= PDFView.pageCount())\n               {\n                  PDFView.goToPage(intVal);\n                  view_.getToolbarDisplay().selectPageNumber();\n                  return;\n               }\n            }\n            catch (NullPointerException ignored)\n            {\n            }\n            catch (NumberFormatException ignored)\n            {\n            }\n\n            pageNumber.setValue(PDFView.currentPage() + \"\", false);\n         }\n      });\n      view_.getToolbarDisplay().getZoomIn().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            PDFView.zoomIn();\n         }\n      });\n      view_.getToolbarDisplay().getZoomOut().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            PDFView.zoomOut();\n         }\n      });\n\n      releaseOnDismiss_.add(PDFView.addPageChangeHandler(new PageChangeEvent.Handler()\n      {\n         @Override\n         public void onPageChange(PageChangeEvent event)\n         {\n            updatePageNumber();\n         }\n      }));\n      releaseOnDismiss_.add(PDFView.addPDFLoadHandler(new PDFLoadEvent.Handler()\n      {\n         @Override\n         public void onPDFLoad(PDFLoadEvent event)\n         {\n            view_.getToolbarDisplay().setPageCount(PDFView.pageCount());\n         }\n      }));\n   }","commit_id":"7158e52d5417dc09433123b1ee9d84e76bc4d0d6","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public HasValue<Integer> getPageNumber()\n   {\n      return pageSelect_;\n   }","id":33368,"modified_method":"@Override\n   public HasValue<String> getPageNumber()\n   {\n      return pageNumber_;\n   }","commit_id":"7158e52d5417dc09433123b1ee9d84e76bc4d0d6","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public void setPageCount(int pageCount)\n   {\n      pageBlock_.getStyle().clearDisplay();\n      pageSelect_.setPageCount(pageCount);\n      pageCountLabel_.setText(pageCount + \"\");\n   }","id":33369,"modified_method":"@Override\n   public void setPageCount(int pageCount)\n   {\n      pageBlock_.getStyle().clearDisplay();\n      pageCountLabel_.setText(pageCount + \"\");\n   }","commit_id":"7158e52d5417dc09433123b1ee9d84e76bc4d0d6","url":"https://github.com/rstudio/rstudio"},{"original_method":"public Mesh getMesh () {\t\t\r\n\t\tfloat[] verts = new float[getVertexSize() * numVertices];\r\n\t\tshort[] indices = new short[numIndices];\r\n\t\tVertexAttribute[] attributes = getVertexAttributes();\r\n\t\t\r\n\t\tfor(int i = 0; i < numIndices; i++) {\r\n\t\t\tVertexIndices vertex = triangles.get(i);\r\n\t\t\tif(vertex.index > Short.MAX_VALUE ||\r\n\t\t\t\tvertex.index < Short.MIN_VALUE) throw new GdxRuntimeException(\"index to big for short: \" + vertex.index);\r\n\t\t\tindices[i] = (short)vertex.index;\r\n\t\t}\t\t\t\r\n\t\t\r\n\t\tint idx = 0;\t\t\t\t\r\n\t\tint destOffset = 0;\r\n\t\t\r\n\t\tfor(int i = 0; i < vertices.size; i++) {\t\r\n\t\t\tVertexIndices vertex = vertices.get(i);\r\n\t\t\t\r\n\t\t\tfor(int j = 0; j < sources.length; j++) {\r\n\t\t\t\tSource source = sources[j];\r\n\t\t\t\tfloat[] data = source.data;\r\n\t\t\t\tint index = vertex.indices[j];\r\n\t\t\t\tint components = source.components;\t\t\t\r\n\t\t\t\tint sourceOffset = index * components;\r\n\t\t\t\t\r\n\t\t\t\tfor(int k = 0; k < components; k++) {\r\n\t\t\t\t\tverts[destOffset++] = data[sourceOffset++]; \r\n\t\t\t\t}\t\t\t\r\n\t\t\t}\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tMesh mesh = new Mesh(true, vertices.size, indices.length, attributes);\r\n\t\tmesh.setVertices(verts);\r\n\t\tmesh.setIndices(indices);\r\n\t\treturn mesh;\r\n\t}","id":33370,"modified_method":"public Mesh getMesh () {\t\t\r\n\t\tfloat[] verts = new float[getVertexSize() * numVertices];\r\n\t\tshort[] indices = new short[numIndices];\r\n\t\tVertexAttribute[] attributes = getVertexAttributes();\r\n\t\t\r\n\t\tfor(int i = 0; i < numIndices; i++) {\r\n\t\t\tVertexIndices vertex = triangles.get(i);\r\n\t\t\tif(vertex.index > Short.MAX_VALUE ||\r\n\t\t\t\tvertex.index < Short.MIN_VALUE) throw new GdxRuntimeException(\"index to big for short: \" + vertex.index);\r\n\t\t\tindices[i] = (short)vertex.index;\r\n\t\t}\t\t\t\r\n\t\t\r\n\t\tint idx = 0;\t\t\t\t\r\n\t\tint destOffset = 0;\r\n\t\t\r\n\t\tfor(int i = 0; i < vertices.size; i++) {\t\r\n\t\t\tVertexIndices vertex = vertices.get(i);\r\n\t\t\t\r\n\t\t\tfor(int j = 0; j < sources.length; j++) {\r\n\t\t\t\tSource source = sources[j];\r\n\t\t\t\tfloat[] data = source.data;\r\n\t\t\t\tint index = vertex.indices[j];\r\n\t\t\t\tint components = source.components;\t\t\t\r\n\t\t\t\tint sourceOffset = index * components;\r\n\t\t\t\t\r\n\t\t\t\tfor(int k = 0; k < components; k++) {\r\n\t\t\t\t\tif((attributes[j].usage == Usage.TextureCoordinates) && k == 1) {\r\n\t\t\t\t\t\tverts[destOffset++] = 1- data[sourceOffset++];\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tverts[destOffset++] = data[sourceOffset++];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\t\t\t\r\n\t\t\t}\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tMesh mesh = new Mesh(true, vertices.size, indices.length, attributes);\r\n\t\tmesh.setVertices(verts);\r\n\t\tmesh.setIndices(indices);\r\n\t\treturn mesh;\r\n\t}","commit_id":"273aefcecb51aca091b485ba1b113c0e250f7bc8","url":"https://github.com/libgdx/libgdx"},{"original_method":"public static void main(String[] argv) {\r\n//\t\tif(argv.length != 1 && argv.length != 2) {\r\n//\t\t\tSystem.out.println(\"StillModelViewer <filename> ?<texture-filename>\");\r\n//\t\t\tSystem.exit(-1);\r\n//\t\t}\r\n//\t\tnew JoglApplication(new StillModelViewer(argv[0], argv.length==2?argv[1]:null), \"StillModel Viewer\", 800, 480, false);\r\n\t\tnew JoglApplication(new StillModelViewer(\"data/goblin.dae\", null), \"StillModel Viewer\", 800, 480, false);\r\n\t}","id":33371,"modified_method":"public static void main(String[] argv) {\r\n//\t\tif(argv.length != 1 && argv.length != 2) {\r\n//\t\t\tSystem.out.println(\"StillModelViewer <filename> ?<texture-filename>\");\r\n//\t\t\tSystem.exit(-1);\r\n//\t\t}\r\n//\t\tnew JoglApplication(new StillModelViewer(argv[0], argv.length==2?argv[1]:null), \"StillModel Viewer\", 800, 480, false);\r\n\t\tnew JoglApplication(new StillModelViewer(\"data/blobbie_world_test.dae\", \"data/world_blobbie_blocks.png\"), \"StillModel Viewer\", 800, 480, false);\r\n\t}","commit_id":"273aefcecb51aca091b485ba1b113c0e250f7bc8","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override public void create () {\r\n\t\tlong start = System.nanoTime();\r\n\t\tif(fileName.endsWith(\".dae\")) model = ColladaLoader.loadStillModel(Gdx.files.internal(fileName));\r\n\t\telse if(fileName.endsWith(\".obj\")) model = new ObjLoader().loadObj(Gdx.files.internal(fileName));\r\n\t\telse throw new GdxRuntimeException(\"Unknown file format '\" + fileName + \"'\");\r\n\t\tGdx.app.log(\"StillModelViewer\", \"loading took: \" + (System.nanoTime() - start)/ 1000000000.0f);\r\n\t\t\r\n\t\tG3dExporter.export(model, Gdx.files.absolute(fileName + \".g3d\"));\t\t\r\n\t\tstart = System.nanoTime();\r\n\t\tmodel = G3dLoader.loadStillModel(Gdx.files.absolute(fileName + \".g3d\"));\r\n\t\tGdx.app.log(\"StillModelViewer\", \"loading binary took: \" + (System.nanoTime() - start)/ 1000000000.0f);\r\n\t\t\t\t\r\n\t\tif(textureFileName != null) texture = new Texture(Gdx.files.internal(textureFileName));\t\t\r\n\t\thasNormals = hasNormals();\r\n\t\t\r\n\t\tmodel.getBoundingBox(bounds);\r\n\t\tfloat len = bounds.getDimensions().len();\r\n\t\tSystem.out.println(\"bounds: \" + bounds);\t\t\t\r\n\t\t\r\n\t\tcam = new PerspectiveCamera(67, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());\r\n\t\tcam.position.set(bounds.getCenter().cpy().add(len, len, len));\r\n\t\tcam.lookAt(bounds.getCenter().x, bounds.getCenter().y, bounds.getCenter().z);\r\n\t\tcam.near = 0.1f;\r\n\t\tcam.far = 1000;\r\n\t\t\r\n\t\trenderer = new ImmediateModeRenderer();\r\n\t}","id":33372,"modified_method":"@Override public void create () {\r\n\t\tlong start = System.nanoTime();\r\n\t\tif(fileName.endsWith(\".dae\")) model = ColladaLoader.loadStillModel(Gdx.files.internal(fileName));\r\n\t\telse if(fileName.endsWith(\".obj\")) model = new ObjLoader().loadObj(Gdx.files.internal(fileName), true);\r\n\t\telse if(fileName.endsWith(\".g3d\")) model = G3dLoader.loadStillModel(Gdx.files.internal(fileName));\r\n\t\telse throw new GdxRuntimeException(\"Unknown file format '\" + fileName + \"'\");\r\n\t\tGdx.app.log(\"StillModelViewer\", \"loading took: \" + (System.nanoTime() - start)/ 1000000000.0f);\r\n\t\t\r\n\t\tif(!fileName.endsWith(\".g3d\")) {\r\n\t\t\tG3dExporter.export(model, Gdx.files.absolute(fileName + \".g3d\"));\t\t\r\n\t\t\tstart = System.nanoTime();\r\n\t\t\tmodel = G3dLoader.loadStillModel(Gdx.files.absolute(fileName + \".g3d\"));\r\n\t\t\tGdx.app.log(\"StillModelViewer\", \"loading binary took: \" + (System.nanoTime() - start)/ 1000000000.0f);\r\n\t\t}\r\n\t\t\t\t\r\n\t\tif(textureFileName != null) texture = new Texture(Gdx.files.internal(textureFileName), true);\t\t\r\n\t\thasNormals = hasNormals();\r\n\t\t\r\n\t\tmodel.getBoundingBox(bounds);\r\n\t\tfloat len = bounds.getDimensions().len();\r\n\t\tSystem.out.println(\"bounds: \" + bounds);\t\t\t\r\n\t\t\r\n\t\tcam = new PerspectiveCamera(60, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());\r\n\t\tcam.position.set(bounds.getCenter().cpy().add(len, len, len));\r\n\t\tcam.lookAt(bounds.getCenter().x, bounds.getCenter().y, bounds.getCenter().z);\r\n\t\tcam.near = 0.1f;\r\n\t\tcam.far = 1000;\r\n\t\t\r\n\t\trenderer = new ImmediateModeRenderer();\t\t\r\n\t}","commit_id":"273aefcecb51aca091b485ba1b113c0e250f7bc8","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override public void render () {\r\n\t\tGdx.gl.glClearColor(0.2f, 0.2f, 0.2f, 1.0f);\r\n\t\tGdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);\r\n\t\tGdx.gl.glEnable(GL10.GL_DEPTH_TEST);\t\t\r\n\t\t\r\n\t\tcam.update();\r\n\t\tcam.apply(Gdx.gl10);\t\t\r\n\t\t\r\n\t\tdrawAxes();\r\n\t\t\r\n\t\tif(hasNormals) {\r\n\t\t\tGdx.gl.glEnable(GL10.GL_LIGHTING);\r\n\t\t\tGdx.gl.glEnable(GL10.GL_COLOR_MATERIAL);\r\n\t\t\tGdx.gl.glEnable(GL10.GL_LIGHT0);\r\n\t\t\tGdx.gl10.glLightfv(GL10.GL_LIGHT0, GL10.GL_DIFFUSE, lightColor, 0);\r\n\t\t\tGdx.gl10.glLightfv(GL10.GL_LIGHT0, GL10.GL_POSITION, lightPosition, 0);\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tif(texture != null) {\r\n\t\t\tGdx.gl.glEnable(GL10.GL_TEXTURE_2D);\r\n\t\t\tGdx.gl.glEnable(GL10.GL_BLEND);\r\n\t\t\tGdx.gl.glBlendFunc(GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);\r\n\t\t\ttexture.bind();\r\n\t\t}\r\n\t\t\r\n\t\tangle += 45 * Gdx.graphics.getDeltaTime();\r\n\t\tGdx.gl10.glRotatef(angle, 0, 1, 0);\r\n\t\tmodel.render();\r\n\t\t\r\n\t\tif(texture != null) {\r\n\t\t\tGdx.gl.glDisable(GL10.GL_TEXTURE_2D);\r\n\t\t}\r\n\t\t\r\n\t\tif(hasNormals) {\r\n\t\t\tGdx.gl.glDisable(GL10.GL_LIGHTING);\r\n\t\t}\r\n\t}","id":33373,"modified_method":"@Override public void render () {\r\n\t\tGdx.gl.glClearColor(0.2f, 0.2f, 0.2f, 1.0f);\r\n\t\tGdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);\r\n\t\tGdx.gl.glEnable(GL10.GL_DEPTH_TEST);\t\t\r\n\r\n\t\t\r\n\t\tcam.position.set(0, 6, 85f);\r\n\t\tcam.direction.set(0,0,-1);\r\n\t\tcam.up.set(0,1,0);\t\t\r\n\t\tcam.update();\r\n\t\tcam.apply(Gdx.gl10);\t\t\r\n\t\t\r\n\t\tdrawAxes();\r\n\t\t\r\n\t\tGdx.gl.glEnable(GL10.GL_CULL_FACE);\r\n\t\t\r\n//\t\tif(hasNormals) {\r\n//\t\t\tGdx.gl.glEnable(GL10.GL_LIGHTING);\r\n//\t\t\tGdx.gl.glEnable(GL10.GL_COLOR_MATERIAL);\r\n//\t\t\tGdx.gl.glEnable(GL10.GL_LIGHT0);\r\n//\t\t\tGdx.gl10.glLightfv(GL10.GL_LIGHT0, GL10.GL_DIFFUSE, lightColor, 0);\r\n//\t\t\tGdx.gl10.glLightfv(GL10.GL_LIGHT0, GL10.GL_POSITION, lightPosition, 0);\t\t\t\r\n//\t\t}\r\n\t\t\r\n\t\tif(texture != null) {\r\n\t\t\tGdx.gl.glEnable(GL10.GL_TEXTURE_2D);\t\t\t\r\n\t\t\ttexture.bind();\r\n\t\t}\r\n\t\t\r\n//\t\tangle += 45 * Gdx.graphics.getDeltaTime();\r\n//\t\tGdx.gl10.glRotatef(angle, 0, 1, 0);\r\n\t\tmodel.render();\r\n\t\t\r\n\t\tif(texture != null) {\r\n\t\t\tGdx.gl.glDisable(GL10.GL_TEXTURE_2D);\r\n\t\t}\r\n\t\t\r\n//\t\tif(hasNormals) {\r\n//\t\t\tGdx.gl.glDisable(GL10.GL_LIGHTING);\r\n//\t\t}\r\n\t\t\r\n\t\tfps.log();\r\n\t}","commit_id":"273aefcecb51aca091b485ba1b113c0e250f7bc8","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** A method that creates a RDF from map file. T \n    *\n    * @param mapFile is pointer to vue map file \n    * @param outputFile RDF output file\n    * @throws java.lang.Exception\n    */\n\tpublic void createRDF(String  mapFile, String outputFile) throws Exception { \n\t\t\n\t}","id":33374,"modified_method":"/** A method that creates a RDF from map file. T \n    *\n    * @param mapFile is pointer to vue map file \n    * @param outputFile RDF output file\n    * @throws java.lang.Exception\n    */\n\tpublic void createRDF(String  mapFile, String outputFile) throws Exception {\n\t    LWMap map = OpenAction.loadMap(mapFile);\n\t\tRDFIndex index = new  RDFIndex();\n\t\tindex.index(map);\n\t\tFileWriter writer = new FileWriter(new File(outputFile));\n        index.write(writer);\n        writer.close();\n\t}","commit_id":"3a8cdee0f78428e091ae41c73405cba61201ea24","url":"https://github.com/VUE/VUE"},{"original_method":"/** A method that creates a VPK from map file. T \n    *\n    * @param mapFile is pointer to vue map file \n    * @param outputFile VPK output file\n    * @throws java.lang.Exception\n    */\n\tpublic void createVPK(String  mapFile, String outputFile) throws Exception { \n\t\t\n\t}","id":33375,"modified_method":"/** A method that creates a VPK from map file. T \n    *\n    * @param mapFile is pointer to vue map file \n    * @param outputFile VPK output file\n    * @throws java.lang.Exception\n    */\n\tpublic void createVPK(String  mapFile, String outputFile) throws Exception { \n\t\tLWMap map = OpenAction.loadMap(mapFile);\n\t\tArchive.writeArchive(map, new File(outputFile));\n\t}","commit_id":"3a8cdee0f78428e091ae41c73405cba61201ea24","url":"https://github.com/VUE/VUE"},{"original_method":"public static void main(String[] args) throws Exception {\n        String inputFile = args[0];\n        String outputFile = args[1];\n        Export exporter = new Export();\n        int option = 0;\n        if(args.length == 3 && args[2] != null) {\n        \t option = Integer.parseInt(args[2]);\n         \n        }  \n        \texporter.export(inputFile, outputFile,option);\n       \n       }","id":33376,"modified_method":"public static void main(String[] args) throws Exception {\n\t\tExport exporter = new Export();    \n\t\tif(args.length < 2) {\n\t\t\texporter.printHelp();\n\t\t\tSystem.exit(0);\n\t\t}\n\t\tif(args[0] != null ) {\n\t\t\tif(args[0].equalsIgnoreCase(\"-h\") || args[0].equalsIgnoreCase(\"--help\")) {\n\t\t\t\texporter.printHelp();\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t}\n        String inputFile = args[0];\n        String outputFile = args[1];\n        int option = 0;\n        if(args.length == 3 && args[2] != null) {\n        \ttry {\n        \t\toption = Integer.parseInt(args[2]);\n        \t\texporter.export(inputFile, outputFile,option);\n        \t} catch(Exception ex) {\n        \t\texporter.export(inputFile,outputFile,args[2]);\n        \t}\n        }  \n        \texporter.export(inputFile, outputFile,0);\n       \n       }","commit_id":"3a8cdee0f78428e091ae41c73405cba61201ea24","url":"https://github.com/VUE/VUE"},{"original_method":"public void printHelp() {\n\t\t\n\t}","id":33377,"modified_method":"public void printHelp() {\n\t\tSystem.out.println(\"Usage: java -jar VUEExport.jar <input file(vue map)> <output file> [option]\");\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"The arguments  are:\");\n\t\tSystem.out.println(\"-h or --help  : prints this informaion\");\n\t\tSystem.out.println(\"<input file>  : this is a vue map of the type .vue or .vpk extention\" );\n\t\tSystem.out.println(\"<output file> : location to output file\" );\n\t\tSystem.out.println(\"[option]      : a number or format of the output from the following list\");\n\t\tSystem.out.println(\"   \t\t\t     0, jpeg or no option - saves to jpeg format\" );\n\t\tSystem.out.println(\"   \t\t\t     1, png - saves to png format\" );\n\t\tSystem.out.println(\"   \t\t\t     2, pdf - saves to pdf format\" );\n\t\tSystem.out.println(\"   \t\t\t     3, html - saves to html format\" );\n\t\tSystem.out.println(\"   \t\t\t     4, svg - saves to svg format\" );\n\t\tSystem.out.println(\"   \t\t\t     5, rdf - saves to rdf format\" );\n\t\tSystem.out.println(\"   \t\t\t     6, vpk - saves to vpk format\" );\n\t\t\n\t}","commit_id":"3a8cdee0f78428e091ae41c73405cba61201ea24","url":"https://github.com/VUE/VUE"},{"original_method":"/**\n     * Given arguments specifying an SSTable, and optionally an output file,\n     * export the contents of the SSTable to JSON.\n     *  \n     * @param args command lines arguments\n     * @throws IOException on failure to open/read/write files or output streams\n     */\n    public static void main(String[] args) throws IOException\n    {\n        String usage = String.format(\"Usage: %s [-f outfile] <sstable>%n\", SSTableExport.class.getName());\n        \n        CommandLineParser parser = new PosixParser();\n        try\n        {\n            cmd = parser.parse(options, args);\n        } catch (ParseException e1)\n        {\n            System.err.println(e1.getMessage());\n            System.err.println(usage);\n            System.exit(1);\n        }\n        \n        String outFile = cmd.getOptionValue(OUTFILE_OPTION);\n        \n        if (cmd.getArgs().length != 1)\n        {\n            System.err.println(\"You must supply exactly one sstable\");\n            System.err.println(usage);\n            System.exit(1);\n        }\n        \n        if (outFile != null)\n        {\n            export(cmd.getArgs()[0], outFile);\n        }\n        else\n        {\n            export(cmd.getArgs()[0]);\n        }\n        System.exit(0);\n    }","id":33378,"modified_method":"/**\n     * Given arguments specifying an SSTable, and optionally an output file,\n     * export the contents of the SSTable to JSON.\n     *  \n     * @param args command lines arguments\n     * @throws IOException on failure to open/read/write files or output streams\n     */\n    public static void main(String[] args) throws IOException\n    {\n        String usage = String.format(\"Usage: %s [-f outfile] <sstable> [-k key [-k key [...]]]%n\",\n                SSTableExport.class.getName());\n        \n        CommandLineParser parser = new PosixParser();\n        try\n        {\n            cmd = parser.parse(options, args);\n        } catch (ParseException e1)\n        {\n            System.err.println(e1.getMessage());\n            System.err.println(usage);\n            System.exit(1);\n        }\n        \n        String outFile = cmd.getOptionValue(OUTFILE_OPTION);\n\n        if (cmd.getArgs().length != 1)\n        {\n            System.err.println(\"You must supply exactly one sstable\");\n            System.err.println(usage);\n            System.exit(1);\n        }\n        \n        String[] keys = cmd.getOptionValues(KEY_OPTION);\n        \n        if (outFile != null)\n        {\n            if ((keys != null) && (keys.length > 0))\n                export(cmd.getArgs()[0], outFile, keys);\n            else\n                export(cmd.getArgs()[0], outFile);\n        }\n        else\n        {\n            if ((keys != null) && (keys.length > 0))\n                export(cmd.getArgs()[0], System.out, keys);\n            else\n                export(cmd.getArgs()[0]);\n        }\n        System.exit(0);\n    }","commit_id":"dcdb8e1b85e934bbdf945b9c70fa6970feb754ce","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Exports the requested uri and at the same time writes the uri to the response output stream\n     * if required.<p>\n     * \n     * @param req the current request\n     * @param res the current response\n     * @param cms an initialized cms context (should be initialized with the \"Guest\" user only)\n     * @param data the static export data set\n     * @throws CmsException in case of errors accessing the VFS\n     * @throws ServletException in case of errors accessing the servlet \n     * @throws IOException in case of erros writing to the export output stream\n     */\n    public void export(HttpServletRequest req, HttpServletResponse res, CmsObject cms, CmsStaticExportData data) \n    throws CmsException, IOException, ServletException {\n\n        CmsFile file;\n        // TODO: Check if setting site root to \"/\" still works with HTML pages that contain links\n        cms.getRequestContext().setSiteRoot(\"/\");\n        String vfsName = data.getVfsName();\n        String rfsName = data.getRfsName();\n        CmsResource resource = data.getResource();\n        String oldUri = null;\n        \n        // this flag signals if the export method is used for \"export on demand\" or \n        // \"export on publish\". \n        // if no request and result stream are available, it was called during \"export on publish\"\n        boolean exportOnDemand = ((req != null) && (res != null));\n                        \n        if (OpenCms.getLog(this).isDebugEnabled()) {\n            OpenCms.getLog(this).debug(\"Static export starting for resource \" + data);\n        }\n        \n        // read vfs resource\n        if (resource.isFile()) {\n            file = cms.readFile(vfsName);\n        } else {\n            file = CmsFile.upgrade(OpenCmsCore.getInstance().initResource(cms, vfsName, req, res), cms);\n            vfsName = vfsName + file.getName();\n            rfsName += C_EXPORT_DEFAULT_FILE;\n        }\n\n        // check loader id for resource\n        int loaderId = file.getLoaderId();\n        I_CmsResourceLoader loader = OpenCms.getLoaderManager().getLoader(loaderId);\n        if ((loader == null) || (! loader.isStaticExportEnabled())) {\n            throw new CmsException(\"Unable to export VFS file \" + vfsName + \", loader with id \" + loaderId + \" does not support static export\");\n        }\n\n        FileOutputStream exportStream = null;\n        File exportFile = null;\n        String exportFileName = CmsLinkManager.normalizeRfsPath(getExportPath() + rfsName.substring(1));\n        \n        // only export those resource where the export property is set\n        if (OpenCms.getLinkManager().exportRequired(cms, vfsName)) {\n            // make sure all required parent folder exist\n            createExportFolder(rfsName);\n            \n            // generate export file instance and output stream\n            exportFile = new File(exportFileName);                 \n        }\n\n        // ensure we have exactly the same setup as if called \"the usual way\"\n        // we only have to do this in case of the static export on demand\n        if (exportOnDemand) {        \n            String mimetype = OpenCms.getLoaderManager().getMimeType(file.getName(), cms.getRequestContext().getEncoding());\n            res.setContentType(mimetype);\n            oldUri = cms.getRequestContext().getUri();\n            cms.getRequestContext().setUri(vfsName);\n        }\n                                        \n        // do the export\n        byte[] result = loader.export(cms, file, req, res);\n                \n        // release unused resources\n        file = null;\n        \n        if (result != null) {\n            // write new exported file content\n            try {\n                exportStream = new FileOutputStream(exportFile);\n                exportStream.write(result);\n                exportStream.close();\n            } catch (Throwable t) {\n                throw new CmsException(\"Creation of static export output stream failed for RFS file \" + exportFileName);\n            }\n            // update the file with the modification date from the server\n            if (req != null) {\n                Long dateLastModified = (Long)req.getAttribute(I_CmsConstants.C_HEADER_OPENCMS_EXPORT);\n                if (dateLastModified != null) {\n                    exportFile.setLastModified((dateLastModified.longValue() / 1000) * 1000);\n                }                                      \n            }            \n        }       \n       \n        // restore context\n        // we only have to do this in case of the static export on demand\n        if (exportOnDemand) {  \n            cms.getRequestContext().setUri(oldUri);\n        }\n                \n        // log export success \n        if (OpenCms.getLog(this).isInfoEnabled()) {\n            OpenCms.getLog(this).info(\"Static exported vfs file '\" + vfsName + \"' to rfs file '\" + exportFileName + \"'\");\n        }\n        \n    }","id":33379,"modified_method":"/**\n     * Exports the requested uri and at the same time writes the uri to the response output stream\n     * if required.<p>\n     * \n     * @param req the current request\n     * @param res the current response\n     * @param cms an initialized cms context (should be initialized with the \"Guest\" user only)\n     * @param data the static export data set\n     * @return status code of the export operation, status codes are the same as http status codes (200,303,304)\n     * @throws CmsException in case of errors accessing the VFS\n     * @throws ServletException in case of errors accessing the servlet \n     * @throws IOException in case of erros writing to the export output stream\n     */\n    public int export(HttpServletRequest req, HttpServletResponse res, CmsObject cms, CmsStaticExportData data) \n    throws CmsException, IOException, ServletException {\n\n        int status = -1;\n                \n        CmsFile file;\n        // TODO: Check if setting site root to \"/\" still works with HTML pages that contain links\n        cms.getRequestContext().setSiteRoot(\"/\");\n        String vfsName = data.getVfsName();\n        String rfsName = data.getRfsName();\n        CmsResource resource = data.getResource();\n        String oldUri = null;\n               \n        // this flag signals if the export method is used for \"export on demand\" or \n        // \"export on publish\". \n        // if no request and result stream are available, it was called during \"export on publish\"\n        boolean exportOnDemand = ((req != null) && (res != null));\n                        \n        if (OpenCms.getLog(this).isDebugEnabled()) {\n            OpenCms.getLog(this).debug(\"Static export starting for resource \" + data);\n        }\n        \n        // read vfs resource\n        if (resource.isFile()) {\n            file = cms.readFile(vfsName);\n        } else {\n            file = CmsFile.upgrade(OpenCmsCore.getInstance().initResource(cms, vfsName, req, res), cms);\n            vfsName = vfsName + file.getName();\n            rfsName += C_EXPORT_DEFAULT_FILE;\n        }\n       \n        // check loader id for resource\n        int loaderId = file.getLoaderId();\n        I_CmsResourceLoader loader = OpenCms.getLoaderManager().getLoader(loaderId);\n        if ((loader == null) || (! loader.isStaticExportEnabled())) {\n            throw new CmsException(\"Unable to export VFS file \" + vfsName + \", loader with id \" + loaderId + \" does not support static export\");\n        }\n\n        FileOutputStream exportStream = null;\n        File exportFile = null;\n        String exportFileName = CmsLinkManager.normalizeRfsPath(getExportPath() + rfsName.substring(1));\n        \n        // only export those resource where the export property is set\n        if (OpenCms.getLinkManager().exportRequired(cms, vfsName)) {\n            // make sure all required parent folder exist\n            createExportFolder(rfsName);\n            status = HttpServletResponse.SC_OK;\n            // generate export file instance and output stream\n            exportFile = new File(exportFileName);                 \n        } else {\n            // the resource was not used for export, so return HttpServletResponse.SC_SEE_OTHER\n            // as a signal for not exported resource\n            status = HttpServletResponse.SC_SEE_OTHER;\n        }\n\n        // ensure we have exactly the same setup as if called \"the usual way\"\n        // we only have to do this in case of the static export on demand\n        if (exportOnDemand) {        \n            String mimetype = OpenCms.getLoaderManager().getMimeType(file.getName(), cms.getRequestContext().getEncoding());\n            res.setContentType(mimetype);\n            oldUri = cms.getRequestContext().getUri();\n            cms.getRequestContext().setUri(vfsName);\n        }\n                                        \n        // do the export\n        byte[] result = loader.export(cms, file, req, res);\n                \n        // release unused resources\n        file = null;\n        \n        if (result != null) {\n            if (exportFile != null) {\n                // write new exported file content\n                try {\n                    exportStream = new FileOutputStream(exportFile);\n                    exportStream.write(result);\n                    exportStream.close();\n                    // the resource was exported, so return status ok\n                    status = HttpServletResponse.SC_OK;\n                    \n                } catch (Throwable t) {\n                    throw new CmsException(\"Creation of static export output stream failed for RFS file \" + exportFileName);\n                }\n                // update the file with the modification date from the server\n                if (req != null) {\n                    Long dateLastModified = (Long)req.getAttribute(I_CmsConstants.C_HEADER_OPENCMS_EXPORT);\n                    if (dateLastModified != null) {\n                        exportFile.setLastModified((dateLastModified.longValue() / 1000) * 1000);\n                    }                                      \n                } else {\n                    // otherweise take the last modification date form the OpenCms resource\n                    exportFile.setLastModified((resource.getDateLastModified() / 1000) *1000);\n                }\n            }\n        } else {\n            // the resource was not written because it was not modified. \n            // set the status to not modified\n            status = HttpServletResponse.SC_NOT_MODIFIED;\n        }\n       \n        // restore context\n        // we only have to do this in case of the static export on demand\n        if (exportOnDemand) {  \n            cms.getRequestContext().setUri(oldUri);\n        }\n                \n        // log export success \n        if (OpenCms.getLog(this).isInfoEnabled()) {\n            OpenCms.getLog(this).info(\"Static exported vfs file '\" + vfsName + \"' to rfs file '\" + exportFileName + \"'\");\n        }\n        \n        return status;\n    }","commit_id":"0b9e093fb5b2c85534e37349cf5f34aece2186de","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Initializes the static export manager with the OpenCms system configuration.<p>\n     * \n     * @param configuration the OpenCms configuration\n     * @param cms an OpenCms context object (not used in static export manager)\n     * @return the initialized site manager\n     */\n    public static CmsStaticExportManager initialize(ExtendedProperties configuration, CmsObject cms) {\n        CmsStaticExportManager exportManager = new CmsStaticExportManager();\n        \n        if (OpenCms.getLog(CmsLog.CHANNEL_INIT).isDebugEnabled()) {\n            OpenCms.getLog(CmsLog.CHANNEL_INIT).debug(\"Created static export manager\" + ((cms != null)?(\" with CmsObject \" + cms):\"\"));\n        }\n        \n        // set if the static export is enabled or not\n        exportManager.setStaticExportEnabled(\"true\".equalsIgnoreCase(configuration.getString(\"staticexport.enabled\", \"false\")));\n\n         // set if the static export is set to export on publish or export on demand\n        exportManager.setStaticExportOnPublish(\"true\".equalsIgnoreCase(configuration.getString(\"staticexport.onpublish\", \"false\")));\n\n        // set the default value for the \"export\" property\n        exportManager.setExportPropertyDefault(\"true\".equalsIgnoreCase(configuration.getString(\"staticexport.export_default\", \"false\")));\n        \n        // set the export URL\n        exportManager.setExportUrl(configuration.getString(\"staticexport.url\", \"http://127.0.0.1:8080/opencms/handle404\"));\n        \n        // set the export suffixes\n        String[] exportSuffixes = configuration.getStringArray(\"staticexport.export_suffixes\");\n        if (exportSuffixes == null) {\n            exportSuffixes = new String[0];\n        }\n        exportManager.setExportSuffixes(exportSuffixes);\n        \n        // set the path for the export\n        exportManager.setExportPath(OpenCms.getSystemInfo().getAbsoluteRfsPathRelativeToWebApplication(configuration.getString(\"staticexport.export_path\", \"export\")));\n\n        // replace the \"magic\" names                 \n        String servletName = OpenCms.getSystemInfo().getServletPath(); \n        String contextName = OpenCms.getSystemInfo().getContextPath();\n        \n        // set the \"magic\" names in the extended properties\n        configuration.setProperty(\"CONTEXT_NAME\", contextName);\n        configuration.setProperty(\"SERVLET_NAME\", servletName);\n        \n        // set the export URL\n        exportManager.setExportUrl(configuration.getString(\"staticexport.url\", \"http://127.0.0.1:8080/opencms/handle404\"));\n        \n        \n        // get the export prefix variables for rfs and vfs\n        String rfsPrefix = configuration.getString(\"staticexport.prefix_rfs\", contextName + \"/export\");\n        String vfsPrefix = configuration.getString(\"staticexport.prefix_vfs\", contextName + servletName);\n        \n        // set the export prefix variables for rfs and vfs\n        exportManager.setRfsPrefix(rfsPrefix);\n        exportManager.setVfsPrefix(vfsPrefix);    \n        \n        // set if links in the export should be relative or not\n        exportManager.setExportRelativeLinks(configuration.getBoolean(\"staticexport.relative_links\", false)); \n\n        // initialize \"exportname\" folders\n        exportManager.setExportnames();\n        \n        if (OpenCms.getLog(CmsLog.CHANNEL_INIT).isInfoEnabled()) {\n            OpenCms.getLog(CmsLog.CHANNEL_INIT).info(\". Static export        : \" + (exportManager.isStaticExportEnabled()?\"enabled\":\"disabled\"));\n            if (exportManager.isStaticExportEnabled()) {\n                OpenCms.getLog(CmsLog.CHANNEL_INIT).info(\". Export default       : \" + exportManager.getExportPropertyDefault());\n                OpenCms.getLog(CmsLog.CHANNEL_INIT).info(\". Export path          : \" + exportManager.getExportPath());\n                OpenCms.getLog(CmsLog.CHANNEL_INIT).info(\". Export rfs prefix    : \" + exportManager.getRfsPrefix());\n                OpenCms.getLog(CmsLog.CHANNEL_INIT).info(\". Export vfs prefix    : \" + exportManager.getVfsPrefix());\n                OpenCms.getLog(CmsLog.CHANNEL_INIT).info(\". Export link style    : \" + (exportManager.relativLinksInExport()?\"relative\":\"absolute\"));                \n            }\n        }               \n        \n        // initialize specific static export headers\n        String[] exportHeaders = null;\n        try {\n            exportHeaders = configuration.getStringArray(\"staticexport.headers\");\n            for (int i = 0; i < exportHeaders.length; i++) {\n                if (CmsStringSubstitution.split(exportHeaders[i], \":\").length == 2) {\n                    if (OpenCms.getLog(CmsLog.CHANNEL_INIT).isInfoEnabled()) {\n                        OpenCms.getLog(CmsLog.CHANNEL_INIT).info(\". Export headers       : \" + exportHeaders[i]);\n                    }\n                } else {\n                    if (OpenCms.getLog(CmsLog.CHANNEL_INIT).isWarnEnabled()) {\n                        OpenCms.getLog(CmsLog.CHANNEL_INIT).warn(\". Export headers       : \" + \"invalid header: \" + exportHeaders[i] + \", using default headers\");\n                    }\n                    exportHeaders = null;\n                    break;\n                }\n            }\n        } catch (Exception e) {\n            if (OpenCms.getLog(CmsLog.CHANNEL_INIT).isWarnEnabled()) {\n                OpenCms.getLog(CmsLog.CHANNEL_INIT).warn(\". Export headers       : non-critical error \" + e.toString());\n            }\n        }\n        exportManager.setExportHeaders(exportHeaders);\n        \n        return exportManager;\n    }","id":33380,"modified_method":"/**\n     * Initializes the static export manager with the OpenCms system configuration.<p>\n     * \n     * @param configuration the OpenCms configuration\n     * @param cms an OpenCms context object (not used in static export manager)\n     * @return the initialized site manager\n     */\n    public static CmsStaticExportManager initialize(ExtendedProperties configuration, CmsObject cms) {\n        CmsStaticExportManager exportManager = new CmsStaticExportManager();\n        \n        if (OpenCms.getLog(CmsLog.CHANNEL_INIT).isDebugEnabled()) {\n            OpenCms.getLog(CmsLog.CHANNEL_INIT).debug(\"Created static export manager\" + ((cms != null)?(\" with CmsObject \" + cms):\"\"));\n        }\n        \n        // set if the static export is enabled or not\n        exportManager.setStaticExportEnabled(\"true\".equalsIgnoreCase(configuration.getString(\"staticexport.enabled\", \"false\")));\n\n         // set if the static export is set to export on publish or export on demand\n        exportManager.setStaticExportOnPublish(\"true\".equalsIgnoreCase(configuration.getString(\"staticexport.onpublish\", \"false\")));\n\n        // set the default value for the \"export\" property\n        exportManager.setExportPropertyDefault(\"true\".equalsIgnoreCase(configuration.getString(\"staticexport.export_default\", \"false\")));\n\n        // set if the quick plain export is enabled or not\n        exportManager.setQuickPlainExport(\"true\".equalsIgnoreCase(configuration.getString(\"staticexport.quick_plain_export\", \"true\")));\n               \n        // set the export URL\n        exportManager.setExportUrl(configuration.getString(\"staticexport.url\", \"http://127.0.0.1:8080/opencms/handle404\"));\n        \n        // set the export suffixes\n        String[] exportSuffixes = configuration.getStringArray(\"staticexport.export_suffixes\");\n        if (exportSuffixes == null) {\n            exportSuffixes = new String[0];\n        }\n        exportManager.setExportSuffixes(exportSuffixes);\n        \n        \n        // set the static export folders in the vfs\n        String[] exportVfsFolders = configuration.getStringArray(\"staticexport.vfs_folders\");\n        if (exportVfsFolders == null) {\n            exportVfsFolders = new String[0];\n        }\n        exportManager.setExportVfsFolders(exportVfsFolders);\n      \n        \n        // set the path for the export\n        exportManager.setExportPath(OpenCms.getSystemInfo().getAbsoluteRfsPathRelativeToWebApplication(configuration.getString(\"staticexport.export_path\", \"export\")));\n\n        // replace the \"magic\" names                 \n        String servletName = OpenCms.getSystemInfo().getServletPath(); \n        String contextName = OpenCms.getSystemInfo().getContextPath();\n        \n        // set the \"magic\" names in the extended properties\n        configuration.setProperty(\"CONTEXT_NAME\", contextName);\n        configuration.setProperty(\"SERVLET_NAME\", servletName);\n        \n        // set the export URL\n        exportManager.setExportUrl(configuration.getString(\"staticexport.url\", \"http://127.0.0.1:8080/opencms/handle404\"));\n        \n        \n        // get the export prefix variables for rfs and vfs\n        String rfsPrefix = configuration.getString(\"staticexport.prefix_rfs\", contextName + \"/export\");\n        String vfsPrefix = configuration.getString(\"staticexport.prefix_vfs\", contextName + servletName);\n        \n        // set the export prefix variables for rfs and vfs\n        exportManager.setRfsPrefix(rfsPrefix);\n        exportManager.setVfsPrefix(vfsPrefix);    \n        \n        // set if links in the export should be relative or not\n        exportManager.setExportRelativeLinks(configuration.getBoolean(\"staticexport.relative_links\", false)); \n\n        // initialize \"exportname\" folders\n        exportManager.setExportnames();\n        \n        if (OpenCms.getLog(CmsLog.CHANNEL_INIT).isInfoEnabled()) {\n            OpenCms.getLog(CmsLog.CHANNEL_INIT).info(\". Static export        : \" + (exportManager.isStaticExportEnabled()?\"enabled\":\"disabled\"));\n            if (exportManager.isStaticExportEnabled()) {\n                OpenCms.getLog(CmsLog.CHANNEL_INIT).info(\". Export default       : \" + exportManager.getExportPropertyDefault());\n                OpenCms.getLog(CmsLog.CHANNEL_INIT).info(\". Export path          : \" + exportManager.getExportPath());\n                OpenCms.getLog(CmsLog.CHANNEL_INIT).info(\". Export rfs prefix    : \" + exportManager.getRfsPrefix());\n                OpenCms.getLog(CmsLog.CHANNEL_INIT).info(\". Export vfs prefix    : \" + exportManager.getVfsPrefix());\n                OpenCms.getLog(CmsLog.CHANNEL_INIT).info(\". Export link style    : \" + (exportManager.relativLinksInExport()?\"relative\":\"absolute\"));                \n            }\n        }               \n        \n        // initialize specific static export headers\n        String[] exportHeaders = null;\n        try {\n            exportHeaders = configuration.getStringArray(\"staticexport.headers\");\n            for (int i = 0; i < exportHeaders.length; i++) {\n                if (CmsStringSubstitution.split(exportHeaders[i], \":\").length == 2) {\n                    if (OpenCms.getLog(CmsLog.CHANNEL_INIT).isInfoEnabled()) {\n                        OpenCms.getLog(CmsLog.CHANNEL_INIT).info(\". Export headers       : \" + exportHeaders[i]);\n                    }\n                } else {\n                    if (OpenCms.getLog(CmsLog.CHANNEL_INIT).isWarnEnabled()) {\n                        OpenCms.getLog(CmsLog.CHANNEL_INIT).warn(\". Export headers       : \" + \"invalid header: \" + exportHeaders[i] + \", using default headers\");\n                    }\n                    exportHeaders = null;\n                    break;\n                }\n            }\n        } catch (Exception e) {\n            if (OpenCms.getLog(CmsLog.CHANNEL_INIT).isWarnEnabled()) {\n                OpenCms.getLog(CmsLog.CHANNEL_INIT).warn(\". Export headers       : non-critical error \" + e.toString());\n            }\n        }\n        exportManager.setExportHeaders(exportHeaders);\n        \n        return exportManager;\n    }","commit_id":"0b9e093fb5b2c85534e37349cf5f34aece2186de","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Starts the static export on publish.<p>\n     * \n     * Exports all modified resources after a publish process into the real FS.<p>\n     *  \n     * @param cms the current cms object\n     * @param publishHistoryId the publichHistoryId of the published project\n     * @param report an I_CmsReport instance to print output message, or null to write messages to the log file   \n     * @throws CmsException in case of errors accessing the VFS\n     * @throws IOException in case of erros writing to the export output stream\n     * @throws ServletException in case of errors accessing the servlet \n     */\n    public synchronized void exportOnPublish(CmsObject cms, CmsUUID publishHistoryId, I_CmsReport report)\n        throws CmsException, IOException, ServletException {\n            \n        // first export all non-template resources, this can be taken from the publish history\n        List publishedResources = cms.readPublishedResources(publishHistoryId);\n        exportNonTemplateResources(cms, publishedResources, report);\n        \n        exportTemplateResources(cms, report);\n        // exportNonVfsResources(cms, publishedResources);\n             \n        // delete all resources deleted during the publish process\n        scrubExportFolders(publishHistoryId, true);       \n    }","id":33381,"modified_method":"/**\n     * Starts the static export on publish.<p>\n     * \n     * Exports all modified resources after a publish process into the real FS.<p>\n     *  \n     * @param cms the current cms object\n     * @param publishHistoryId the publichHistoryId of the published project\n     * @param report an I_CmsReport instance to print output message, or null to write messages to the log file   \n     * @throws CmsException in case of errors accessing the VFS\n     * @throws IOException in case of erros writing to the export output stream\n     * @throws ServletException in case of errors accessing the servlet \n     */\n    public synchronized void exportOnPublish(CmsObject cms, CmsUUID publishHistoryId, I_CmsReport report)\n        throws CmsException, IOException, ServletException {\n        \n        boolean templatesFound;\n        \n        // export must be done in the context of the export user    \n        CmsObject cmsExportObject = OpenCms.initCmsObject(OpenCms.getDefaultUsers().getUserExport());\n        \n        // first export all non-template resources, this can be taken from the publish history\n        List publishedResources = cms.readPublishedResources(publishHistoryId);\n        templatesFound = exportNonTemplateResources(cmsExportObject, publishedResources, report);\n\n        // we do only have to process the tempaltes resources if some of them were published or the\n        // override switch was set in the OpenCms configuration\n        \n        if ((templatesFound) || (!getQuickPlainExport())) {\n            exportTemplateResources(cmsExportObject, report);\n            // exportNonVfsResources(cms, publishedResources);\n        }\n        \n        // delete all resources deleted during the publish process\n        scrubExportFolders(publishHistoryId, true);       \n    }","commit_id":"0b9e093fb5b2c85534e37349cf5f34aece2186de","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Exports all template resources found in a list of published resources.<p>\n     * \n     * @param cms the current cms object\n     * @param report an I_CmsReport instance to print output message, or null to write messages to the log file    \n     * @throws CmsException in case of errors accessing the VFS\n     */\n    private void exportTemplateResources(CmsObject cms, I_CmsReport report) throws CmsException {\n\n        String rfsName;\n        String url;\n\n        // get all template resources which are potential candidates for an static export\n        List publishedTemplateResources = cms.readStaticExportResources(false);\n        int size = publishedTemplateResources.size();\n        int count = 1;\n\n        report.println(report.key(\"report.staticexport.templateresources_begin\"), I_CmsReport.C_FORMAT_HEADLINE);\n\n        // now loop through all of them and request them from the server\n        Iterator i = publishedTemplateResources.iterator();\n        \n        try {\n            cms.getRequestContext().saveSiteRoot();\n            cms.getRequestContext().setSiteRoot(\"/\");\n\n            while (i.hasNext()) {\n                rfsName = (String)i.next();\n\n                report.print(\"(\" + count++ + \" / \" + size + \") \", I_CmsReport.C_FORMAT_NOTE);\n                report.print(report.key(\"report.exporting\"), I_CmsReport.C_FORMAT_NOTE);\n                report.print(rfsName);\n                report.print(report.key(\"report.dots\"));\n\n                url = getExportUrl() + getRfsPrefix() + rfsName;\n\n                // we have created an url, so request the resource\n                if (url != null) {\n                    try {\n                        // setup connections\n                        URL export = new URL(url);\n                        HttpURLConnection.setFollowRedirects(false);\n                        HttpURLConnection urlcon = (HttpURLConnection)export.openConnection();\n                        // set request type to GET\n                        urlcon.setRequestMethod(\"GET\");\n                        // add special export header\n                        urlcon.setRequestProperty(I_CmsConstants.C_HEADER_OPENCMS_EXPORT, \"true\");\n                        // get the last modified date and add it to the request\n                        String exportFileName = CmsLinkManager.normalizeRfsPath(getExportPath() + rfsName.substring(1));\n                        File exportFile = new File(exportFileName);\n                        if (exportFile != null) {\n                            long dateLastModified = exportFile.lastModified();\n                            urlcon.setIfModifiedSince(dateLastModified);                   \n                        }\n                        \n                        // now perform the request\n                        urlcon.connect();\n                        int result = urlcon.getResponseCode();\n                        urlcon.disconnect();\n                        \n                        // write the report\n                        if (result == HttpServletResponse.SC_OK) { \n                            report.println(report.key(\"report.ok\"), I_CmsReport.C_FORMAT_OK);\n                        } else if (result == HttpServletResponse.SC_NOT_MODIFIED) {\n                            report.println(report.key(\"search.indexing_file_skipped\"), I_CmsReport.C_FORMAT_NOTE);\n                        } else {\n                            report.println(String.valueOf(result), I_CmsReport.C_FORMAT_OK);\n                        }\n                    } catch (IOException e) {\n                        report.println(e);\n                    }\n                }\n            }\n        } finally {\n            cms.getRequestContext().restoreSiteRoot();\n        }\n        report.println(report.key(\"report.staticexport.templateresources_end\"), I_CmsReport.C_FORMAT_HEADLINE);\n\n    }","id":33382,"modified_method":"/**\n     * Exports all template resources found in a list of published resources.<p>\n     * \n     * @param cms the current cms object\n     * @param report an I_CmsReport instance to print output message, or null to write messages to the log file    \n     * @throws CmsException in case of errors accessing the VFS\n     */\n    private void exportTemplateResources(CmsObject cms, I_CmsReport report) throws CmsException {\n\n        String rfsName;\n        String url;\n\n        // get all template resources which are potential candidates for an static export\n        List publishedTemplateResources = cms.readStaticExportResources(false);\n        int size = publishedTemplateResources.size();\n        int count = 1;\n\n\n        if (OpenCms.getLog(this).isDebugEnabled()) {\n            OpenCms.getLog(this).debug(\"Starting export of template resources. \"+size+\" possible canditates in list.\");\n        }\n        \n        \n        report.println(report.key(\"report.staticexport.templateresources_begin\"), I_CmsReport.C_FORMAT_HEADLINE);\n\n        // now loop through all of them and request them from the server\n        Iterator i = publishedTemplateResources.iterator();\n        \n        try {\n            cms.getRequestContext().saveSiteRoot();\n            cms.getRequestContext().setSiteRoot(\"/\");\n\n            while (i.hasNext()) {\n                rfsName = (String)i.next();\n\n                report.print(\"(\" + count++ + \" / \" + size + \") \", I_CmsReport.C_FORMAT_NOTE);\n                report.print(report.key(\"report.exporting\"), I_CmsReport.C_FORMAT_NOTE);\n                report.print(rfsName);\n                report.print(report.key(\"report.dots\"));\n\n                url = getExportUrl() + getRfsPrefix() + rfsName;\n\n                if (OpenCms.getLog(this).isDebugEnabled()) {\n                    OpenCms.getLog(this).debug(\"Sending request for \"+rfsName+\" with url (\"+url+\")...\");\n                }\n                \n                // we have created an url, so request the resource\n                if (url != null) {\n                    try {\n                        // setup connections\n                        URL export = new URL(url);\n                        HttpURLConnection.setFollowRedirects(false);\n                        HttpURLConnection urlcon = (HttpURLConnection)export.openConnection();\n                        // set request type to GET\n                        urlcon.setRequestMethod(\"GET\");\n                        // add special export header\n                        urlcon.setRequestProperty(I_CmsConstants.C_HEADER_OPENCMS_EXPORT, \"true\");\n                        // get the last modified date and add it to the request\n                        String exportFileName = CmsLinkManager.normalizeRfsPath(getExportPath() + rfsName.substring(1));\n                        File exportFile = new File(exportFileName);\n                        if (exportFile != null) {\n                            long dateLastModified = exportFile.lastModified();\n                            urlcon.setIfModifiedSince(dateLastModified);                   \n                        }\n                        \n                        // now perform the request\n                        urlcon.connect();\n                        int status = urlcon.getResponseCode();\n                        urlcon.disconnect();\n                        \n                        if (OpenCms.getLog(this).isInfoEnabled()) {\n                         OpenCms.getLog(this).info(\"Requested \"+rfsName+\" with url (\"+url+\") [STATUS\"+status+\"]\");\n                        }\n                        \n                        // write the report\n                        if (status == HttpServletResponse.SC_OK) { \n                            report.println(report.key(\"report.ok\"), I_CmsReport.C_FORMAT_OK);\n                        } else if (status == HttpServletResponse.SC_NOT_MODIFIED) {\n                            report.println(report.key(\"report.skipped\"), I_CmsReport.C_FORMAT_NOTE);\n                        } else if (status == HttpServletResponse.SC_SEE_OTHER) {\n                            report.println(report.key(\"report.ignored\"), I_CmsReport.C_FORMAT_NOTE);\n                        } else {\n                            report.println(String.valueOf(status), I_CmsReport.C_FORMAT_OK);\n                        }\n                    } catch (IOException e) {\n                        report.println(e);\n                    }\n                }\n            }\n        } finally {\n            cms.getRequestContext().restoreSiteRoot();\n        }\n        report.println(report.key(\"report.staticexport.templateresources_end\"), I_CmsReport.C_FORMAT_HEADLINE);\n\n    }","commit_id":"0b9e093fb5b2c85534e37349cf5f34aece2186de","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Exports all non template resources found in a list of published resources.<p>\n     * \n     * @param cms the current cms object\n     * @param publishedResources the list of published resources\n     * @param report an I_CmsReport instance to print output message, or null to write messages to the log file\n     * @throws CmsException in case of errors accessing the VFS\n     * @throws IOException in case of erros writing to the export output stream\n     * @throws ServletException in case of errors accessing the servlet \n     */\n    private void exportNonTemplateResources(CmsObject cms, List publishedResources, I_CmsReport report) \n        throws CmsException, IOException, ServletException {\n       \n        String vfsName=null;\n        List resourcesToExport = new ArrayList();\n\n        int count = 1;\n\n        report.println(report.key(\"report.staticexport.nontemplateresources_begin\"), I_CmsReport.C_FORMAT_HEADLINE);                        \n        \n        // loop through all resources\n        Iterator i = publishedResources.iterator();\n      \n        while (i.hasNext()) {   \n            CmsPublishedResource pupRes = (CmsPublishedResource)i.next();          \n            \n            vfsName = pupRes.getRootPath();\n            \n            // only export VFS files. COS data and foldersis handled elsewhere \n            if (pupRes.isVfsResource() && (pupRes.isFile())) {\n                // get the export data object. if null is returned, this resource cannot be\n                // exported.\n                CmsStaticExportData exportData = getExportData(vfsName, cms);\n              \n                //\n                if (exportData != null) {\n                    // check loader for current resource if it must be processed before exported\n                    I_CmsResourceLoader loader = OpenCms.getLoaderManager().getLoader(exportData.getResource().getLoaderId());\n                    if (! loader.isStaticExportProcessable()) {\n                        // this resource must not be process, so export it if its not marked as deleted\n                        if (pupRes.getState() != I_CmsConstants.C_STATE_DELETED) {\n                            // mark the resource for export to the real file system     \n                            resourcesToExport.add(exportData);\n                        } \n                    } else {\n                        // the resource is a template resource. so store the name of it in the DB\n                        // for further use.                       \n                        cms.writeStaticExportPublishedResource(exportData.getRfsName(), 0, \"\");                            \n                    }              \n                }                    \n            }\n        }\n        \n        // now do the export\n        i = resourcesToExport.iterator();\n        int size = resourcesToExport.size();\n        while (i.hasNext()) {\n            CmsStaticExportData exportData = (CmsStaticExportData)i.next();\n            report.print(\"(\"+ count++ +\" / \" + size + \") \", I_CmsReport.C_FORMAT_NOTE);\n            report.print(report.key(\"report.exporting\"), I_CmsReport.C_FORMAT_NOTE);\n            report.print(exportData.getVfsName());\n            report.print(report.key(\"report.dots\"));\n            export(null, null, cms, exportData);\n            report.println(report.key(\"report.ok\"), I_CmsReport.C_FORMAT_OK);\n        }\n        \n        resourcesToExport = null;\n        \n        report.println(report.key(\"report.staticexport.nontemplateresources_end\"), I_CmsReport.C_FORMAT_HEADLINE);       \n       \n    }","id":33383,"modified_method":"/**\n     * Exports all non template resources found in a list of published resources.<p>\n     * \n     * @param cms the current cms object\n     * @param publishedResources the list of published resources\n     * @param report an I_CmsReport instance to print output message, or null to write messages to the log file\n     * @return true if some template resources were found whil looping the list of published resources\n     * @throws CmsException in case of errors accessing the VFS\n     * @throws IOException in case of erros writing to the export output stream\n     * @throws ServletException in case of errors accessing the servlet \n     */\n    private boolean exportNonTemplateResources(CmsObject cms, List publishedResources, I_CmsReport report) \n        throws CmsException, IOException, ServletException {\n                   \n        String vfsName = null;\n        List resourcesToExport = new ArrayList();\n        boolean templatesFound = false;\n\n        int count = 1;\n\n        report.println(report.key(\"report.staticexport.nontemplateresources_begin\"), I_CmsReport.C_FORMAT_HEADLINE);                        \n        \n        // loop through all resources\n        Iterator i = publishedResources.iterator();\n\n        if (OpenCms.getLog(this).isDebugEnabled()) {\n            OpenCms.getLog(this).debug(\"Starting export of non-template resources. \"+publishedResources.size()+\" possible canditates in list.\");\n        }\n        \n        while (i.hasNext()) {   \n            CmsPublishedResource pupRes = (CmsPublishedResource)i.next();          \n            \n            vfsName = pupRes.getRootPath();\n            \n            // only export VFS files. COS data and foldersis handled elsewhere \n            if (pupRes.isVfsResource() && (pupRes.isFile())) {\n                // get the export data object. if null is returned, this resource cannot be\n                // exported.\n                CmsStaticExportData exportData = getExportData(vfsName, cms);\n              \n                //\n                if (exportData != null) {\n                    // check loader for current resource if it must be processed before exported\n                    I_CmsResourceLoader loader = OpenCms.getLoaderManager().getLoader(exportData.getResource().getLoaderId());\n                    if (! loader.isStaticExportProcessable()) {\n                        // this resource must not be process, so export it if its not marked as deleted\n                        if (pupRes.getState() != I_CmsConstants.C_STATE_DELETED) {\n                            // mark the resource for export to the real file system     \n                            resourcesToExport.add(exportData);\n                        } \n                    } else {\n                        // the resource is a template resource. so store the name of it in the DB\n                        // for further use.                       \n                        templatesFound = true;\n                        cms.writeStaticExportPublishedResource(exportData.getRfsName(), 0, \"\");                            \n                    }              \n                }                    \n            }\n        }\n                \n        // now do the export\n        i = resourcesToExport.iterator();\n        int size = resourcesToExport.size();\n        \n        if (OpenCms.getLog(this).isDebugEnabled()) {\n            OpenCms.getLog(this).debug(\"Found \"+size+\" resources to export\");\n        }\n        \n        while (i.hasNext()) {\n            CmsStaticExportData exportData = (CmsStaticExportData)i.next();\n            \n            if (OpenCms.getLog(this).isDebugEnabled()) {\n                OpenCms.getLog(this).debug(\"Exporting \"+exportData.getVfsName()+\" -> \"+exportData.getRfsName()+\"...\");\n            }\n            \n            report.print(\"(\"+ count++ +\" / \" + size + \") \", I_CmsReport.C_FORMAT_NOTE);\n            report.print(report.key(\"report.exporting\"), I_CmsReport.C_FORMAT_NOTE);\n            report.print(exportData.getVfsName());\n            report.print(report.key(\"report.dots\"));\n            int status = export(null, null, cms, exportData);\n            if (status == HttpServletResponse.SC_OK) {\n                report.println(report.key(\"report.ok\"), I_CmsReport.C_FORMAT_OK);\n            } else {\n                report.println(report.key(\"report.ignored\"), I_CmsReport.C_FORMAT_NOTE);\n            }\n            if (OpenCms.getLog(this).isInfoEnabled()) {\n                OpenCms.getLog(this).info(\"Export \"+exportData.getVfsName()+\" -> \"+exportData.getRfsName()+\" [STATUS \"+status+\"]\");\n            }\n        }\n        \n        resourcesToExport = null;\n        \n        report.println(report.key(\"report.staticexport.nontemplateresources_end\"), I_CmsReport.C_FORMAT_HEADLINE);\n        \n        return templatesFound;\n       \n    }","commit_id":"0b9e093fb5b2c85534e37349cf5f34aece2186de","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.main.I_CmsRequestHandler#handle(HttpServletRequest, HttpServletResponse, String)\n     */\n    public void handle(HttpServletRequest req, HttpServletResponse res, String name) throws IOException, ServletException {\n        int errorCode;\n        try {\n            errorCode = Integer.valueOf(name).intValue();\n        } catch (NumberFormatException nf) {\n            res.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n            return;\n        }\n        switch (errorCode) {\n            case 404:\n                String path = req.getPathInfo();                                     \n                CmsObject cms = null;            \n                CmsStaticExportData exportData = null;\n                try {\n                    cms = OpenCmsCore.getInstance().initCmsObject(req, res, OpenCms.getDefaultUsers().getUserExport(), null);            \n                    exportData = OpenCms.getStaticExportManager().getExportData(req, cms);\n                } catch (CmsException e) {\n                    // unlikley to happen \n                    if (OpenCms.getLog(this).isWarnEnabled()) {                    \n                        OpenCms.getLog(this).warn(\"Error initializing CmsObject in \" + name + \" handler for '\" + path + \"'\", e);\n                    }\n                }\n                if (exportData != null) {\n                   synchronized (this) {\n                        try {\n                            OpenCms.getStaticExportManager().export(req, res, cms, exportData);\n                        } catch (Throwable t) {\n                            if (OpenCms.getLog(this).isWarnEnabled()) {                    \n                                OpenCms.getLog(this).warn(\"Error exporting \" + exportData, t);\n                            }\n                            openErrorHandler(req, res, errorCode);\n                        }\n                    }\n                } else {\n                    openErrorHandler(req, res, errorCode);\n                }\n                break;\n            default:\n                openErrorHandler(req, res, errorCode);\n        }                 \n    }","id":33384,"modified_method":"/**\n     * @see org.opencms.main.I_CmsRequestHandler#handle(HttpServletRequest, HttpServletResponse, String)\n     */\n    public void handle(HttpServletRequest req, HttpServletResponse res, String name) throws IOException, ServletException {\n        int errorCode;\n        try {\n            errorCode = Integer.valueOf(name).intValue();\n        } catch (NumberFormatException nf) {\n            res.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n            return;\n        }\n        switch (errorCode) {\n            case 404:\n                String path = req.getPathInfo();                                     \n                CmsObject cms = null;            \n                CmsStaticExportData exportData = null;\n                try {\n                    cms = OpenCmsCore.getInstance().initCmsObject(req, res, OpenCms.getDefaultUsers().getUserExport(), null);            \n                    exportData = OpenCms.getStaticExportManager().getExportData(req, cms);\n                } catch (CmsException e) {\n                    // unlikley to happen \n                    if (OpenCms.getLog(this).isWarnEnabled()) {                    \n                        OpenCms.getLog(this).warn(\"Error initializing CmsObject in \" + name + \" handler for '\" + path + \"'\", e);\n                    }\n                }\n                if (exportData != null) {\n                   synchronized (this) {\n                        try {\n                            // export the resource and set the response status according to the result \n                            // of the export operation\n                            res.setStatus(OpenCms.getStaticExportManager().export(req, res, cms, exportData));\n                        } catch (Throwable t) {\n                            if (OpenCms.getLog(this).isWarnEnabled()) {                    \n                                OpenCms.getLog(this).warn(\"Error exporting \" + exportData, t);\n                            }\n                            openErrorHandler(req, res, errorCode);\n                        }\n                    }\n                } else {\n                    openErrorHandler(req, res, errorCode);\n                }\n                break;\n            default:\n                openErrorHandler(req, res, errorCode);\n        }                 \n    }","commit_id":"0b9e093fb5b2c85534e37349cf5f34aece2186de","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/** override if there is a custom menu item */\n    protected Object runCustomChooser() {\n        return null;\n    }","id":33385,"modified_method":"/** @param values can be property values or actions (or even a mixture) */\n    protected void buildMenu(Object[] valuesOrActions)\n    {\n        buildMenu(valuesOrActions, null, false); \n    }","commit_id":"f21e1e6cbdcfec19c398e30ef3dfb5c3df47b920","url":"https://github.com/VUE/VUE"},{"original_method":"/**\n     * @param values can be property values or actions\n     * @param names is optional\n     * @param createCustom - add a \"Custom\" menu item that calls runCustomChooser\n     *\n     * The ability to pass in an array of actions is a convenience to create\n     * the needed JMenuItem's using the Action.NAME & Action.SMALL_ICON & MenuButton.ValueKey\n     * values stored in the action. The action is not actually fired when the menu\n     * item is selected (this used to be the case, but no longer).\n     * The action's will be expected to hava a value under the key\n     * MenuButton.ValueKey representing the value of the object.  (This only\n     * works for actions that set specific values every time they fire).\n     *\n     * OLD:\n     * If values are actions, the default handleValueSelection won't ever\n     * do anything as a value wasn't set on the JMenuItem -- it's assumed\n     * that the action is handling the value change.  In this case override\n     * handleMenuSelection to change the buttons appearance after a selection change.\n     */\n    protected void buildMenu(T[] values, String[] names, boolean createCustom)\n    {\n        mPopup = new JPopupMenu();\n\t\t\t\n        //final String valueKey = getPropertyName() + \".value\"; // propertyName usually not set at this point!\n            \n        final ActionListener menuItemAction =\n            new ActionListener() {\n                public void actionPerformed(ActionEvent e) {\n                    handleMenuSelection(e);\n                }};\n            \n        for (int i = 0; i < values.length; i++) {\n            JMenuItem item;\n            T value;\n            Icon icon = null;\n            if (values[i] instanceof Action) {\n                Action a = (Action) values[i];\n                item = new JMenuItem((String) a.getValue(Action.NAME));\n                value = (T) a.getValue(ValueKey);\n                icon = (Icon) a.getValue(Action.SMALL_ICON);\n            } else {\n                item = new JMenuItem();\n                value = values[i];\n            }\n            item.putClientProperty(ValueKey, value);\n            if (icon == null)\n                icon = makeIcon(value);\n            if (icon != null)\n                item.setIcon(icon);\n            if (names != null)\n                item.setText(names[i]);\n            item.addActionListener(menuItemAction);\n            mPopup.add(item);\n        }\n\n        if (createCustom) {\n            JMenuItem item = new JMenuItem(\"Custom...\"); // todo: more control over this item\n            item.addActionListener(new ActionListener() {\n                    public void actionPerformed(ActionEvent e) { handleValueSelection(runCustomChooser()); }});\n            mPopup.add(item);\n        }\n\n        mEmptySelection = new JMenuItem();\n        mEmptySelection.setVisible(false);\n        mPopup.add(mEmptySelection);\n    }","id":33386,"modified_method":"/**\n     * @param values can be property values or actions\n     * @param names is optional\n     * @param createCustom - add a \"Custom\" menu item that calls runCustomChooser\n     *\n     * The ability to pass in an array of actions is a convenience to create\n     * the needed JMenuItem's using the Action.NAME & Action.SMALL_ICON & MenuButton.ValueKey\n     * values stored in the action. The action is not actually fired when the menu\n     * item is selected (this used to be the case, but no longer).\n     * The action's will be expected to hava a value under the key\n     * MenuButton.ValueKey representing the value of the object.  (This only\n     * works for actions that set specific values every time they fire).\n     *\n     * OLD:\n     * If values are actions, the default handleValueSelection won't ever\n     * do anything as a value wasn't set on the JMenuItem -- it's assumed\n     * that the action is handling the value change.  In this case override\n     * handleMenuSelection to change the buttons appearance after a selection change.\n     */\n    protected void buildMenu(Object[] values, String[] names, boolean createCustom)\n    {\n        mPopup = new JPopupMenu();\n\t\t\t\n        //final String valueKey = getPropertyName() + \".value\"; // propertyName usually not set at this point!\n            \n        final ActionListener menuItemAction =\n            new ActionListener() {\n                public void actionPerformed(ActionEvent e) {\n                    handleMenuSelection(e);\n                }};\n            \n        for (int i = 0; i < values.length; i++) {\n            JMenuItem item;\n            T value;\n            Icon icon = null;\n            if (values[i] instanceof Action) {\n                Action a = (Action) values[i];\n                item = new JMenuItem((String) a.getValue(Action.NAME));\n                value = (T) a.getValue(ValueKey);\n                icon = (Icon) a.getValue(Action.SMALL_ICON);\n            } else {\n                item = new JMenuItem();\n                value = (T) values[i];\n            }\n            item.putClientProperty(ValueKey, value);\n            if (icon == null)\n                icon = makeIcon(value);\n            if (icon != null)\n                item.setIcon(icon);\n            if (names != null)\n                item.setText(names[i]);\n            item.addActionListener(menuItemAction);\n            mPopup.add(item);\n        }\n\n        if (createCustom) {\n            JMenuItem item = new JMenuItem(\"Custom...\"); // todo: more control over this item\n            item.addActionListener(new ActionListener() {\n                    public void actionPerformed(ActionEvent e) { handleValueSelection(runCustomChooser()); }});\n            mPopup.add(item);\n        }\n\n        mEmptySelection = new JMenuItem();\n        mEmptySelection.setVisible(false);\n        mPopup.add(mEmptySelection);\n    }","commit_id":"f21e1e6cbdcfec19c398e30ef3dfb5c3df47b920","url":"https://github.com/VUE/VUE"},{"original_method":"/** @return the currently selected value (interface LWEditor) */\n    public T produceValue() {\n        return mCurrentValue;\n    }","id":33387,"modified_method":"/** @return the currently selected value (interface LWEditor) */\n    public T produceValue() {\n        if (DEBUG.TOOL) System.out.println(this + \" produceValue \" + mCurrentValue);\n        return mCurrentValue;\n    }","commit_id":"f21e1e6cbdcfec19c398e30ef3dfb5c3df47b920","url":"https://github.com/VUE/VUE"},{"original_method":"protected void buildMenu(Class<T> enumType)\n    {\n        T[] values = enumType.getEnumConstants();\n        String[] names = new String[values.length];\n        int i = 0;\n        for (T e : values)\n            names[i++] = e.toString();\n        buildMenu(values, names, false);\n    }","id":33388,"modified_method":"protected void buildMenu(Class<T> enumType)\n    {\n        T[] values = enumType.getEnumConstants();\n        if (values == null)\n            throw new Error(\"no enum constants for (not an enum?) \" + enumType);\n        String[] names = new String[values.length];\n        int i = 0;\n        for (T e : values)\n            names[i++] = e.toString();\n        buildMenu(values, names, false);\n    }","commit_id":"f21e1e6cbdcfec19c398e30ef3dfb5c3df47b920","url":"https://github.com/VUE/VUE"},{"original_method":"private void _setIcon(Icon i) {\n        /*\n            super.setIcon(i);\n            super.setRolloverIcon(new VueButtonIcon(i, VueButtonIcon.ROLLOVER));\n        */\n        /*\n          final int pad = 7;\n          Dimension d = new Dimension(i.getIconWidth()+pad, i.getIconHeight()+pad);\n          if (d.width < 21) d.width = 21; // todo: config\n          if (d.height < 21) d.height = 21; // todo: config\n        */\n        //if (DEBUG.BOXES||DEBUG.TOOL) System.out.println(this + \" _setIcon \" + i);\n        Dimension d = getButtonSize();\n        if (true || !GUI.isMacAqua()) {\n            VueButtonIcon.installGenerated(this, new MenuProxyIcon(i), d);\n            //System.out.println(this + \" *** installed generated, setPreferredSize \" + d);\n        }\n        setPreferredSize(d);\n    }","id":33389,"modified_method":"private void _setIcon(Icon i) {\n        /*\n            super.setIcon(i);\n            super.setRolloverIcon(new VueButtonIcon(i, VueButtonIcon.ROLLOVER));\n        */\n        /*\n          final int pad = 7;\n          Dimension d = new Dimension(i.getIconWidth()+pad, i.getIconHeight()+pad);\n          if (d.width < 21) d.width = 21; // todo: config\n          if (d.height < 21) d.height = 21; // todo: config\n        */\n        //if (DEBUG.BOXES||DEBUG.TOOL) System.out.println(this + \" _setIcon \" + i);\n        Dimension d = getButtonSize();\n        if (true || !GUI.isMacAqua()) {\n            if (false)\n                VueButtonIcon.installGenerated(this, i, d);\n            else\n                VueButtonIcon.installGenerated(this, new MenuProxyIcon(i), d);\n            //System.out.println(this + \" *** installed generated, setPreferredSize \" + d);\n        }\n        setPreferredSize(d);\n    }","commit_id":"f21e1e6cbdcfec19c398e30ef3dfb5c3df47b920","url":"https://github.com/VUE/VUE"},{"original_method":"static void init(AbstractButton b, String key)\n    {\n        if (key == null) {\n            // from an action init w/no action command\n            VueButtonIcon.installGenerated(b, b.getIcon(), null);\n        } else {\n            installResourceConfiguration(b, key);\n        }\n\n        b.setFocusable(false);\n        b.setName(key);\n        \n        if (false && GUI.isOceanTheme()) {\n            //b.setRolloverEnabled(true);\n            // todo: need some kind of border, but then will need\n            // to change rollover icon (or maybe change border\n            // on rollover instead of changing icon)\n            b.setBorder(new LineBorder(Color.blue));\n        } else {\n            b.setBorder(null);\n            b.setBorderPainted(false);\n            b.setOpaque(false);\n        }\n\n        if (b.getIcon() != null) {\n            Dimension imageSize = new Dimension(b.getIcon().getIconWidth(), b.getIcon().getIconHeight());\n            //System.out.println(b + \" icon size is \" + VueUtil.out(imageSize));\n            b.setPreferredSize(imageSize);\n        } else {\n            //if (DEBUG.Enabled) System.out.println(b + \" init\");\n        }\n\n        //setBackground(Color.white);\n        //setBackground(Color.red);\n        if (DEBUG.INIT) System.out.println(\"Created new \" + b);\n        //if (true||DEBUG.SELECTION&&DEBUG.META) new Throwable().printStackTrace();\n    }","id":33390,"modified_method":"private static void init(AbstractButton b, String key)\n    {\n        //System.out.println(GUI.name(b) + \"\\tINIT0 \" + key + \"\\tTTT[\" + b.getToolTipText() + \"]\");\n        \n        if (key == null) {\n            // from an action init w/no action command\n            if (b.getName() == null)\n                b.setName(b.getText());\n            if (b.getToolTipText() == null || b.getToolTipText().length() < 1) {\n                b.setToolTipText(b.getText()); \n               if (DEBUG.Enabled) System.out.println(GUI.name(b) + \" lazy setToolTipText \" + b.getText());\n            }\n            VueButtonIcon.installGenerated(b, b.getIcon(), null);\n        } else {\n            b.setName(key);\n            installResourceConfiguration(b, key);\n        }\n\n        b.setRolloverEnabled(true);\n\n        //System.out.println(GUI.name(b) + \"\\tINIT1 \" + key + \"\\tTTT[\" + b.getToolTipText() + \"]\");\n        \n        b.setFocusable(false);\n        \n        if (false && GUI.isOceanTheme()) {\n            //b.setRolloverEnabled(true);\n            // todo: need some kind of border, but then will need\n            // to change rollover icon (or maybe change border\n            // on rollover instead of changing icon)\n            b.setBorder(new LineBorder(Color.blue));\n        } else {\n            b.setBorder(null);\n            b.setBorderPainted(false);\n            b.setOpaque(false);\n        }\n\n        if (b.getIcon() != null) {\n            Dimension imageSize = new Dimension(b.getIcon().getIconWidth(), b.getIcon().getIconHeight());\n            //System.out.println(b + \" icon size is \" + VueUtil.out(imageSize));\n            b.setPreferredSize(imageSize);\n        } else {\n            //if (DEBUG.Enabled) System.out.println(b + \" init\");\n        }\n\n        //setBackground(Color.white);\n        //setBackground(Color.red);\n        if (DEBUG.INIT) System.out.println(\"Created new \" + b);\n        //if (true||DEBUG.SELECTION&&DEBUG.META) new Throwable().printStackTrace();\n    }","commit_id":"b13e4cc2cbf2ad0779f227249297a367c83ab17b","url":"https://github.com/VUE/VUE"},{"original_method":"public BackwardForwardPanel() {\n\t\tsuper(new GridLayout(1, 2, 1, 0));\n\n\t\tVueButton\tbackwardButton = createButton(Actions.ViewBackward, VueResources.getIcon(\"Back.raw\")),\n\t\t\t\t\tforwardButton = createButton(Actions.ViewForward, VueResources.getIcon(\"Forward.raw\"));\n\n\t\tadd(backwardButton);\n\t\tadd(forwardButton);\n\n\t\tif (DEBUG.BOXES) {\n\t\t\tthis.setBackground(Color.MAGENTA);\n\t\t}\n\t}","id":33391,"modified_method":"public BackwardForwardPanel() {\n\t\tsuper(new GridLayout(1, 2, 0, 0));\n\n\n\t\tVueButton\tbackwardButton = createButton(Actions.ViewBackward, VueResources.getIcon(\"Back.raw\")),\n\t\t\t\t\tforwardButton = createButton(Actions.ViewForward, VueResources.getIcon(\"Forward.raw\"));\n\n\t\tadd(backwardButton);\n\t\tadd(forwardButton);\n\n\t\tif (DEBUG.BOXES) {\n\t\t\tthis.setBackground(Color.MAGENTA);\n\t\t}\n\t}","commit_id":"a1f1fc28bd7032a02d04ee25b276b4e470acb9a7","url":"https://github.com/VUE/VUE"},{"original_method":"protected VueButton createButton(Action action, Icon icon) {\n\t\tVueButton\tnewButton = new VueButton(action);\n\t\tDimension\tbuttonSize = new Dimension(icon.getIconWidth() + 8, icon.getIconHeight() + 8);\n\n\t\tnewButton.setMinimumSize(buttonSize);\n\t\tnewButton.setMaximumSize(buttonSize);\n\t\tnewButton.setPreferredSize(buttonSize);\n\n\t\tnewButton.setAsToolbarButton(true);\n\n\t\tVueButtonIcon.installGenerated(newButton, icon, null);\n\n\t\treturn newButton;\n\t}","id":33392,"modified_method":"protected VueButton createButton(Action action, Icon icon) {\n\t\tVueButton\tnewButton = new VueButton(action);\n\n\t\tVueButtonIcon.installGenerated(newButton, icon, null);\n\n\t\tIcon\t\tinstalledIcon = newButton.getIcon();\n\t\tDimension\tbuttonSize = new Dimension(installedIcon.getIconWidth(), installedIcon.getIconHeight());\n\n\t\tnewButton.setMinimumSize(buttonSize);\n\t\tnewButton.setMaximumSize(buttonSize);\n\t\tnewButton.setPreferredSize(buttonSize);\n\n\t\tnewButton.setAsToolbarButton(true);\n\n\t\treturn newButton;\n\t}","commit_id":"a1f1fc28bd7032a02d04ee25b276b4e470acb9a7","url":"https://github.com/VUE/VUE"},{"original_method":"protected TextRange surroundExpression(GrExpression expression) {\n    GrIfStatement ifStatement = (GrIfStatement) GroovyPsiElementFactory.getInstance(expression.getProject()).createTopElementFromText(\"if(a){4\\n}\");\n    replaceToOldExpression((GrExpression)ifStatement.getCondition(), expression);\n    ifStatement = (GrIfStatement) expression.replaceWithStatement(ifStatement);\n    GrStatement thenBranch = ifStatement.getThenBranch();\n\n    assert thenBranch instanceof GrBlockStatement;\n    GrStatement[] statements = ((GrBlockStatement) thenBranch).getBlock().getStatements();\n    assert statements.length > 0;\n\n    GrStatement statement = statements[0];\n    int endOffset = statement.getTextRange().getStartOffset();\n    statement.getNode().getTreeParent().removeChild(statement.getNode());\n\n    return new TextRange(endOffset, endOffset);\n  }","id":33393,"modified_method":"protected TextRange surroundExpression(GrExpression expression) {\n    GrIfStatement ifStatement = (GrIfStatement) GroovyPsiElementFactory.getInstance(expression.getProject()).createTopElementFromText(\"if(a){4\\n}\");\n    replaceToOldExpression((GrExpression)ifStatement.getCondition(), expression);\n    ifStatement = expression.replaceWithStatement(ifStatement);\n    GrStatement thenBranch = ifStatement.getThenBranch();\n\n    assert thenBranch instanceof GrBlockStatement;\n    GrStatement[] statements = ((GrBlockStatement) thenBranch).getBlock().getStatements();\n    assert statements.length > 0;\n\n    GrStatement statement = statements[0];\n    int endOffset = statement.getTextRange().getStartOffset();\n    statement.getNode().getTreeParent().removeChild(statement.getNode());\n\n    return new TextRange(endOffset, endOffset);\n  }","commit_id":"afae8cca23a8c804597ead41cb81d47f308f0ff7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected TextRange surroundExpression(GrExpression expression) {\n    GrWhileStatement whileStatement = (GrWhileStatement) GroovyPsiElementFactory.getInstance(expression.getProject()).createTopElementFromText(\"while(a){4\\n}\");\n    replaceToOldExpression((GrExpression)whileStatement.getCondition(), expression);\n    whileStatement = (GrWhileStatement) expression.replaceWithStatement(whileStatement);\n    GrStatement body = whileStatement.getBody();\n\n    assert body instanceof GrBlockStatement;\n    GrStatement[] statements = ((GrBlockStatement) body).getBlock().getStatements();\n    assert statements.length > 0;\n\n    GrStatement statement = statements[0];\n    int offset = statement.getTextRange().getStartOffset();\n    statement.getNode().getTreeParent().removeChild(statement.getNode());\n\n    return new TextRange(offset, offset);\n  }","id":33394,"modified_method":"protected TextRange surroundExpression(GrExpression expression) {\n    GrWhileStatement whileStatement = (GrWhileStatement) GroovyPsiElementFactory.getInstance(expression.getProject()).createTopElementFromText(\"while(a){4\\n}\");\n    replaceToOldExpression((GrExpression)whileStatement.getCondition(), expression);\n    whileStatement = expression.replaceWithStatement(whileStatement);\n    GrStatement body = whileStatement.getBody();\n\n    assert body instanceof GrBlockStatement;\n    GrStatement[] statements = ((GrBlockStatement) body).getBlock().getStatements();\n    assert statements.length > 0;\n\n    GrStatement statement = statements[0];\n    int offset = statement.getTextRange().getStartOffset();\n    statement.getNode().getTreeParent().removeChild(statement.getNode());\n\n    return new TextRange(offset, offset);\n  }","commit_id":"afae8cca23a8c804597ead41cb81d47f308f0ff7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected TextRange surroundExpression(GrExpression expression) {\n    GrMethodCallExpression call = (GrMethodCallExpression) GroovyPsiElementFactory.getInstance(expression.getProject()).createTopElementFromText(\"with(a){4\\n}\");\n    replaceToOldExpression(call.getExpressionArguments()[0], expression);\n    call = (GrMethodCallExpression) expression.replaceWithStatement(call);\n    GrClosableBlock block = call.getClosureArguments()[0];\n\n    GrStatement statementInBody = block.getStatements()[0];\n    int offset = statementInBody.getTextRange().getStartOffset();\n\n    statementInBody.getParent().getNode().removeChild(statementInBody.getNode());\n\n    return new TextRange(offset, offset);\n  }","id":33395,"modified_method":"protected TextRange surroundExpression(GrExpression expression) {\n    GrMethodCallExpression call = (GrMethodCallExpression) GroovyPsiElementFactory.getInstance(expression.getProject()).createTopElementFromText(\"with(a){4\\n}\");\n    replaceToOldExpression(call.getExpressionArguments()[0], expression);\n    call = expression.replaceWithStatement(call);\n    GrClosableBlock block = call.getClosureArguments()[0];\n\n    GrStatement statementInBody = block.getStatements()[0];\n    int offset = statementInBody.getTextRange().getStartOffset();\n\n    statementInBody.getParent().getNode().removeChild(statementInBody.getNode());\n\n    return new TextRange(offset, offset);\n  }","commit_id":"afae8cca23a8c804597ead41cb81d47f308f0ff7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Replaces an expression occurrence by appropriate variable declaration\n   */\n  private GrVariable replaceOnlyExpression(@NotNull GrExpression expr,\n                                           GrExpression selectedExpr,\n                                           @NotNull PsiElement context,\n                                           @NotNull GrVariableDeclaration definition) throws IncorrectOperationException {\n    if (context.equals(expr.getParent()) &&\n        !GroovyRefactoringUtil.isLoopOrForkStatement(context)) {\n      definition = (GrVariableDeclaration) expr.replaceWithStatement(definition);\n      if (expr.equals(selectedExpr)) {\n        refreshPositionMarker(definition);\n      }\n\n      return definition.getVariables()[0];\n    }\n    return null;\n  }","id":33396,"modified_method":"/**\n   * Replaces an expression occurrence by appropriate variable declaration\n   */\n  private GrVariable replaceOnlyExpression(@NotNull GrExpression expr,\n                                           GrExpression selectedExpr,\n                                           @NotNull PsiElement context,\n                                           @NotNull GrVariableDeclaration definition) throws IncorrectOperationException {\n    if (context.equals(expr.getParent()) &&\n        !(context instanceof GrLoopStatement) && !(context instanceof GrClosableBlock)) {\n      definition = expr.replaceWithStatement(definition);\n      if (expr.equals(selectedExpr)) {\n        refreshPositionMarker(definition);\n      }\n\n      return definition.getVariables()[0];\n    }\n    return null;\n  }","commit_id":"02743ba4bf60144c3afdb6438f3dcca4ed67440e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private GrVariable insertVariableDefinition(GroovyPsiElement tempContainer, GrExpression selectedExpr,\n                                              PsiElement[] occurrences, boolean replaceAllOccurrences,\n                                              GrVariableDeclaration varDecl, GroovyPsiElementFactory factory) throws IncorrectOperationException {\n    LOG.assertTrue(occurrences.length > 0);\n    GrStatement anchorElement = (GrStatement)GroovyRefactoringUtil.calculatePositionToInsertBefore(tempContainer, selectedExpr, occurrences, replaceAllOccurrences);\n    LOG.assertTrue(anchorElement != null);\n    PsiElement realContainer;\n    if (anchorElement.equals(tempContainer)) {\n      realContainer = tempContainer.getParent();\n    } else {\n      realContainer = tempContainer;\n    }\n\n    assert GroovyRefactoringUtil.isAppropriateContainerForIntroduceVariable(realContainer);\n\n    if (!GroovyRefactoringUtil.isLoopOrForkStatement(realContainer)) {\n      if (realContainer instanceof GrStatementOwner) {\n        GrStatementOwner block = (GrStatementOwner) realContainer;\n        varDecl = (GrVariableDeclaration) block.addStatementBefore(varDecl, (GrStatement) anchorElement);\n      }\n    } else {\n      GrStatement tempStatement = ((GrStatement) anchorElement);\n      // To replace branch body correctly\n      boolean inThenIfBranch = realContainer instanceof GrIfStatement &&\n          anchorElement.equals(((GrIfStatement) realContainer).getThenBranch());\n      String refId = varDecl.getVariables()[0].getName();\n      GrBlockStatement newBody;\n      if (tempStatement.equals(selectedExpr)) {\n        newBody = factory.createBlockStatement(varDecl);\n      } else {\n        replaceExpressionOccurrencesInStatement(tempStatement, selectedExpr, refId, replaceAllOccurrences);\n        newBody = factory.createBlockStatement(varDecl, tempStatement);\n      }\n\n      varDecl = (GrVariableDeclaration) newBody.getBlock().getStatements()[0];\n\n      GrCodeBlock tempBlock = newBody.getBlock();\n      if (realContainer instanceof GrLoopStatement) {\n        tempBlock = ((GrBlockStatement) ((GrLoopStatement) realContainer).replaceBody(newBody)).getBlock();\n      } else if (realContainer instanceof GrIfStatement) {\n        GrIfStatement ifStatement = ((GrIfStatement) realContainer);\n        if (inThenIfBranch) {\n          tempBlock = ((GrBlockStatement) ifStatement.replaceThenBranch(newBody)).getBlock();\n        } else {\n          tempBlock = ((GrBlockStatement) ifStatement.replaceElseBranch(newBody)).getBlock();\n        }\n      }\n\n      refreshPositionMarker(tempBlock.getStatements()[tempBlock.getStatements().length - 1]);\n    }\n\n    return varDecl.getVariables()[0];\n  }","id":33397,"modified_method":"private GrVariable insertVariableDefinition(GroovyPsiElement tempContainer, GrExpression selectedExpr,\n                                              PsiElement[] occurrences, boolean replaceAllOccurrences,\n                                              GrVariableDeclaration varDecl, GroovyPsiElementFactory factory) throws IncorrectOperationException {\n    LOG.assertTrue(occurrences.length > 0);\n    GrStatement anchorElement = (GrStatement)GroovyRefactoringUtil.calculatePositionToInsertBefore(tempContainer, selectedExpr, occurrences, replaceAllOccurrences);\n    LOG.assertTrue(anchorElement != null);\n    PsiElement realContainer = anchorElement.getParent();\n\n    assert GroovyRefactoringUtil.isAppropriateContainerForIntroduceVariable(realContainer);\n\n    if (!(realContainer instanceof GrLoopStatement)) {\n      if (realContainer instanceof GrStatementOwner) {\n        GrStatementOwner block = (GrStatementOwner) realContainer;\n        varDecl = (GrVariableDeclaration) block.addStatementBefore(varDecl, (GrStatement) anchorElement);\n      }\n    } else {\n      GrStatement tempStatement = anchorElement;\n      // To replace branch body correctly\n      boolean inThenIfBranch = realContainer instanceof GrIfStatement &&\n          anchorElement.equals(((GrIfStatement) realContainer).getThenBranch());\n      String refId = varDecl.getVariables()[0].getName();\n      GrBlockStatement newBody;\n      if (tempStatement.equals(selectedExpr)) {\n        newBody = factory.createBlockStatement(varDecl);\n      } else {\n        replaceExpressionOccurrencesInStatement(tempStatement, selectedExpr, refId, replaceAllOccurrences);\n        newBody = factory.createBlockStatement(varDecl, tempStatement);\n      }\n\n      varDecl = (GrVariableDeclaration) newBody.getBlock().getStatements()[0];\n\n      GrCodeBlock tempBlock = newBody.getBlock();\n      if (realContainer instanceof GrLoopStatement) {\n        tempBlock = ((GrBlockStatement) ((GrLoopStatement) realContainer).replaceBody(newBody)).getBlock();\n      } else if (realContainer instanceof GrIfStatement) {\n        GrIfStatement ifStatement = ((GrIfStatement) realContainer);\n        if (inThenIfBranch) {\n          tempBlock = ((GrBlockStatement) ifStatement.replaceThenBranch(newBody)).getBlock();\n        } else {\n          tempBlock = ((GrBlockStatement) ifStatement.replaceElseBranch(newBody)).getBlock();\n        }\n      }\n\n      refreshPositionMarker(tempBlock.getStatements()[tempBlock.getStatements().length - 1]);\n    }\n\n    return varDecl.getVariables()[0];\n  }","commit_id":"02743ba4bf60144c3afdb6438f3dcca4ed67440e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PsiElement getEnclosingContainer(PsiElement place) {\n    PsiElement parent = place.getParent();\n    while (parent != null &&\n        !(parent instanceof GrDeclarationHolder) &&\n        !isLoopOrForkStatement(parent)) {\n      parent = parent.getParent();\n    }\n    return parent;\n  }","id":33398,"modified_method":"@Nullable\n  public static PsiElement getEnclosingContainer(PsiElement place) {\n    PsiElement parent = place.getParent();\n    while (true) {\n      if (parent == null) {\n        return null;\n      }\n      if (parent instanceof GrDeclarationHolder && !(parent instanceof GrClosableBlock && parent.getParent() instanceof GrString)) {\n        return parent;\n      }\n      if (parent instanceof GrLoopStatement) {\n        return parent;\n      }\n\n      parent = parent.getParent();\n    }\n  }","commit_id":"02743ba4bf60144c3afdb6438f3dcca4ed67440e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isAppropriateContainerForIntroduceVariable(PsiElement tempContainer) {\n    return tempContainer instanceof GrOpenBlock ||\n        tempContainer instanceof GrClosableBlock ||\n        tempContainer instanceof GroovyFileBase ||\n        tempContainer instanceof GrCaseSection ||\n        isLoopOrForkStatement(tempContainer);\n  }","id":33399,"modified_method":"public static boolean isAppropriateContainerForIntroduceVariable(PsiElement tempContainer) {\n    return tempContainer instanceof GrOpenBlock ||\n        tempContainer instanceof GrClosableBlock ||\n        tempContainer instanceof GroovyFileBase ||\n        tempContainer instanceof GrCaseSection || tempContainer instanceof GrLoopStatement;\n  }","commit_id":"02743ba4bf60144c3afdb6438f3dcca4ed67440e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static PsiElement[] getExpressionOccurrences(@NotNull PsiElement expr, @NotNull PsiElement scope) {\n    ArrayList<PsiElement> occurrences = new ArrayList<PsiElement>();\n    Comparator<PsiElement> comparator = new Comparator<PsiElement>() {\n      public int compare(PsiElement element1, PsiElement element2) {\n        if (element1.equals(element2)) return 0;\n\n        if (element1 instanceof GrParameter &&\n            element2 instanceof GrParameter) {\n          final String name1 = ((GrParameter) element1).getName();\n          final String name2 = ((GrParameter) element2).getName();\n          if (name1 != null && name2 != null) {\n            return name1.compareTo(name2);\n          }\n        }\n        return 1;\n      }\n    };\n\n    if (isLoopOrForkStatement(scope)) {\n      PsiElement son = expr;\n      while (son.getParent() != null && !isLoopOrForkStatement(son.getParent())) {\n        son = son.getParent();\n      }\n      assert scope.equals(son.getParent());\n      collectOccurrences(expr, son, occurrences, comparator);\n    } else {\n      collectOccurrences(expr, scope, occurrences, comparator);\n    }\n    return occurrences.toArray(new PsiElement[occurrences.size()]);\n  }","id":33400,"modified_method":"public static PsiElement[] getExpressionOccurrences(@NotNull PsiElement expr, @NotNull PsiElement scope) {\n    ArrayList<PsiElement> occurrences = new ArrayList<PsiElement>();\n    Comparator<PsiElement> comparator = new Comparator<PsiElement>() {\n      public int compare(PsiElement element1, PsiElement element2) {\n        if (element1.equals(element2)) return 0;\n\n        if (element1 instanceof GrParameter &&\n            element2 instanceof GrParameter) {\n          final String name1 = ((GrParameter) element1).getName();\n          final String name2 = ((GrParameter) element2).getName();\n          if (name1 != null && name2 != null) {\n            return name1.compareTo(name2);\n          }\n        }\n        return 1;\n      }\n    };\n\n    if (scope instanceof GrLoopStatement) {\n      PsiElement son = expr;\n      while (son.getParent() != null && !(son.getParent() instanceof GrLoopStatement)) {\n        son = son.getParent();\n      }\n      assert scope.equals(son.getParent());\n      collectOccurrences(expr, son, occurrences, comparator);\n    } else {\n      collectOccurrences(expr, scope, occurrences, comparator);\n    }\n    return occurrences.toArray(new PsiElement[occurrences.size()]);\n  }","commit_id":"02743ba4bf60144c3afdb6438f3dcca4ed67440e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    PsiClassType type = PsiManager.getInstance(project).getElementFactory().createTypeByFQClassName(\"Object\", GlobalSearchScope.allScope(project));\n    GrVariableDeclaration decl = GroovyPsiElementFactory.getInstance(project).createVariableDeclaration(ArrayUtil.EMPTY_STRING_ARRAY,\n        null, type, myRefExpression.getReferenceName());\n    int offset = myRefExpression.getTextRange().getStartOffset();\n    GrStatement anchor = findAnchor(file, offset);\n\n    TypeConstraint[] constraints = GroovyExpectedTypesUtil.calculateTypeConstraints(myRefExpression);\n    if (anchor.equals(myRefExpression)) {\n      decl = (GrVariableDeclaration) myRefExpression.replaceWithStatement(decl);\n    } else {\n      decl = myOwner.addVariableDeclarationBefore(decl, anchor);\n    }\n    GrTypeElement typeElement = decl.getTypeElementGroovy();\n    assert typeElement != null;\n    ChooseTypeExpression expr = new ChooseTypeExpression(constraints, PsiManager.getInstance(project));\n    TemplateBuilder builder = new TemplateBuilder(decl);\n    builder.replaceElement(typeElement, expr);\n    decl = CodeInsightUtil.forcePsiPostprocessAndRestoreElement(decl);\n    Template template = builder.buildTemplate();\n\n    Editor newEditor = positionCursor(project, myOwner.getContainingFile(), decl);\n    TextRange range = decl.getTextRange();\n    newEditor.getDocument().deleteString(range.getStartOffset(), range.getEndOffset());\n\n    TemplateManager manager = TemplateManager.getInstance(project);\n    manager.startTemplate(newEditor, template);\n  }","id":33401,"modified_method":"public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    PsiClassType type = PsiManager.getInstance(project).getElementFactory().createTypeByFQClassName(\"Object\", GlobalSearchScope.allScope(project));\n    GrVariableDeclaration decl = GroovyPsiElementFactory.getInstance(project).createVariableDeclaration(ArrayUtil.EMPTY_STRING_ARRAY,\n        null, type, myRefExpression.getReferenceName());\n    int offset = myRefExpression.getTextRange().getStartOffset();\n    GrStatement anchor = findAnchor(file, offset);\n\n    TypeConstraint[] constraints = GroovyExpectedTypesUtil.calculateTypeConstraints(myRefExpression);\n    if (anchor.equals(myRefExpression)) {\n      decl = myRefExpression.replaceWithStatement(decl);\n    } else {\n      decl = myOwner.addVariableDeclarationBefore(decl, anchor);\n    }\n    GrTypeElement typeElement = decl.getTypeElementGroovy();\n    assert typeElement != null;\n    ChooseTypeExpression expr = new ChooseTypeExpression(constraints, PsiManager.getInstance(project));\n    TemplateBuilder builder = new TemplateBuilder(decl);\n    builder.replaceElement(typeElement, expr);\n    decl = CodeInsightUtil.forcePsiPostprocessAndRestoreElement(decl);\n    Template template = builder.buildTemplate();\n\n    Editor newEditor = positionCursor(project, myOwner.getContainingFile(), decl);\n    TextRange range = decl.getTextRange();\n    newEditor.getDocument().deleteString(range.getStartOffset(), range.getEndOffset());\n\n    TemplateManager manager = TemplateManager.getInstance(project);\n    manager.startTemplate(newEditor, template);\n  }","commit_id":"c7e91dba3b1ad8abd1a2e0c0c6d5c2a3efba2ec8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GrStatement replaceWithStatement(@NotNull GrStatement newStmt) {\n    PsiElement parent = getParent();\n    if (parent == null) {\n      throw new PsiInvalidElementAccessException(this);\n    }\n    ASTNode parentNode = parent.getNode();\n    ASTNode newNode = newStmt.getNode();\n    parentNode.replaceChild(this.getNode(), newNode);\n    return (GrStatement) newNode.getPsi();\n  }","id":33402,"modified_method":"public <T extends GrStatement> T replaceWithStatement(@NotNull T newStmt) {\n    PsiElement parent = getParent();\n    if (parent == null) {\n      throw new PsiInvalidElementAccessException(this);\n    }\n    ASTNode parentNode = parent.getNode();\n    ASTNode newNode = newStmt.getNode();\n    parentNode.replaceChild(this.getNode(), newNode);\n    return (T) newNode.getPsi();\n  }","commit_id":"c7e91dba3b1ad8abd1a2e0c0c6d5c2a3efba2ec8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected TextRange surroundExpression(GrExpression expression) {\n    GrIfStatement ifStatement = (GrIfStatement) GroovyPsiElementFactory.getInstance(expression.getProject()).createTopElementFromText(\"if(a){4\\n} else{\\n}\");\n    replaceToOldExpression((GrExpression) ifStatement.getCondition(), expression);\n    expression.replaceWithStatement(ifStatement);\n    GrStatement psiElement = ifStatement.getThenBranch();\n\n\n    assert psiElement instanceof GrBlockStatement;\n    GrStatement[] statements = ((GrBlockStatement) psiElement).getBlock().getStatements();\n    assert statements.length > 0;\n\n    GrStatement statement = statements[0];\n    int endOffset = statement.getTextRange().getStartOffset();\n    statement.getNode().getTreeParent().removeChild(statement.getNode());\n\n    return new TextRange(endOffset, endOffset);\n  }","id":33403,"modified_method":"protected TextRange surroundExpression(GrExpression expression) {\n    GrIfStatement ifStatement = (GrIfStatement) GroovyPsiElementFactory.getInstance(expression.getProject()).createTopElementFromText(\"if(a){4\\n} else{\\n}\");\n    replaceToOldExpression((GrExpression) ifStatement.getCondition(), expression);\n    ifStatement = expression.replaceWithStatement(ifStatement);\n    GrStatement psiElement = ifStatement.getThenBranch();\n\n\n    assert psiElement instanceof GrBlockStatement;\n    GrStatement[] statements = ((GrBlockStatement) psiElement).getBlock().getStatements();\n    assert statements.length > 0;\n\n    GrStatement statement = statements[0];\n    int endOffset = statement.getTextRange().getStartOffset();\n    statement.getNode().getTreeParent().removeChild(statement.getNode());\n\n    return new TextRange(endOffset, endOffset);\n  }","commit_id":"c7e91dba3b1ad8abd1a2e0c0c6d5c2a3efba2ec8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected TextRange surroundExpression(GrExpression expression) {\n    GrParenthesizedExpression result = (GrParenthesizedExpression) GroovyPsiElementFactory.getInstance(expression.getProject()).createExpressionFromText(\"(a)\");\n    replaceToOldExpression(result.getOperand(), expression);\n    expression.replaceWithExpression(result, true);\n    return new TextRange(result.getTextRange().getEndOffset(), result.getTextRange().getEndOffset());\n  }","id":33404,"modified_method":"protected TextRange surroundExpression(GrExpression expression) {\n    GrParenthesizedExpression result = (GrParenthesizedExpression) GroovyPsiElementFactory.getInstance(expression.getProject()).createExpressionFromText(\"(a)\");\n    replaceToOldExpression(result.getOperand(), expression);\n    result = (GrParenthesizedExpression) expression.replaceWithExpression(result, true);\n    return new TextRange(result.getTextRange().getEndOffset(), result.getTextRange().getEndOffset());\n  }","commit_id":"c7e91dba3b1ad8abd1a2e0c0c6d5c2a3efba2ec8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected TextRange surroundExpression(GrExpression expression) {\n    GrParenthesizedExpression parenthesized = (GrParenthesizedExpression) GroovyPsiElementFactory.getInstance(expression.getProject()).createTopElementFromText(\"((Type)a)\");\n    GrTypeCastExpression typeCast = (GrTypeCastExpression) parenthesized.getOperand();\n    replaceToOldExpression(typeCast.getOperand(), expression);\n    GrTypeElement typeElement = typeCast.getCastTypeElement();\n    int endOffset = typeElement.getTextRange().getStartOffset();\n\n    typeCast.getNode().removeChild(typeElement.getNode());\n    expression.replaceWithExpression(parenthesized, true);\n\n    return new TextRange(endOffset, endOffset);\n  }","id":33405,"modified_method":"protected TextRange surroundExpression(GrExpression expression) {\n    GrParenthesizedExpression parenthesized = (GrParenthesizedExpression) GroovyPsiElementFactory.getInstance(expression.getProject()).createTopElementFromText(\"((Type)a)\");\n    parenthesized = (GrParenthesizedExpression) expression.replaceWithExpression(parenthesized, true);\n    GrTypeCastExpression typeCast = (GrTypeCastExpression) parenthesized.getOperand();\n    replaceToOldExpression(typeCast.getOperand(), expression);\n    GrTypeElement typeElement = typeCast.getCastTypeElement();\n    int endOffset = typeElement.getTextRange().getStartOffset();\n\n    typeCast.getNode().removeChild(typeElement.getNode());\n    return new TextRange(endOffset, endOffset);\n  }","commit_id":"c7e91dba3b1ad8abd1a2e0c0c6d5c2a3efba2ec8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected TextRange surroundExpression(GrExpression expression) {\n    GrWhileStatement whileStatement = (GrWhileStatement) GroovyPsiElementFactory.getInstance(expression.getProject()).createTopElementFromText(\"while(a){4\\n}\");\n    replaceToOldExpression((GrExpression)whileStatement.getCondition(), expression);\n    expression.replaceWithStatement(whileStatement);\n    GrStatement body = whileStatement.getBody();\n\n    assert body instanceof GrBlockStatement;\n    GrStatement[] statements = ((GrBlockStatement) body).getBlock().getStatements();\n    assert statements.length > 0;\n\n    GrStatement statement = statements[0];\n    int offset = statement.getTextRange().getStartOffset();\n    statement.getNode().getTreeParent().removeChild(statement.getNode());\n\n    return new TextRange(offset, offset);\n  }","id":33406,"modified_method":"protected TextRange surroundExpression(GrExpression expression) {\n    GrWhileStatement whileStatement = (GrWhileStatement) GroovyPsiElementFactory.getInstance(expression.getProject()).createTopElementFromText(\"while(a){4\\n}\");\n    replaceToOldExpression((GrExpression)whileStatement.getCondition(), expression);\n    whileStatement = (GrWhileStatement) expression.replaceWithStatement(whileStatement);\n    GrStatement body = whileStatement.getBody();\n\n    assert body instanceof GrBlockStatement;\n    GrStatement[] statements = ((GrBlockStatement) body).getBlock().getStatements();\n    assert statements.length > 0;\n\n    GrStatement statement = statements[0];\n    int offset = statement.getTextRange().getStartOffset();\n    statement.getNode().getTreeParent().removeChild(statement.getNode());\n\n    return new TextRange(offset, offset);\n  }","commit_id":"c7e91dba3b1ad8abd1a2e0c0c6d5c2a3efba2ec8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected TextRange surroundExpression(GrExpression expression) {\n    GrMethodCallExpression call = (GrMethodCallExpression) GroovyPsiElementFactory.getInstance(expression.getProject()).createTopElementFromText(\"with(a){4\\n}\");\n    replaceToOldExpression(call.getExpressionArguments()[0], expression);\n    expression.replaceWithStatement(call);\n    GrClosableBlock block = call.getClosureArguments()[0];\n\n    GrStatement statementInBody = block.getStatements()[0];\n    int offset = statementInBody.getTextRange().getStartOffset();\n\n    statementInBody.getParent().getNode().removeChild(statementInBody.getNode());\n\n    return new TextRange(offset, offset);\n  }","id":33407,"modified_method":"protected TextRange surroundExpression(GrExpression expression) {\n    GrMethodCallExpression call = (GrMethodCallExpression) GroovyPsiElementFactory.getInstance(expression.getProject()).createTopElementFromText(\"with(a){4\\n}\");\n    replaceToOldExpression(call.getExpressionArguments()[0], expression);\n    call = (GrMethodCallExpression) expression.replaceWithStatement(call);\n    GrClosableBlock block = call.getClosureArguments()[0];\n\n    GrStatement statementInBody = block.getStatements()[0];\n    int offset = statementInBody.getTextRange().getStartOffset();\n\n    statementInBody.getParent().getNode().removeChild(statementInBody.getNode());\n\n    return new TextRange(offset, offset);\n  }","commit_id":"c7e91dba3b1ad8abd1a2e0c0c6d5c2a3efba2ec8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object transform(Object src, String encoding, UMOEventContext context)\n            throws TransformerException\n    {\n        String endpoint = (String)context.getProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, null);\n        if (endpoint == null) {\n            throw new TransformerException(new Message(\n                    Messages.EVENT_PROPERTY_X_NOT_SET_CANT_PROCESS_REQUEST,\n                    MuleProperties.MULE_ENDPOINT_PROPERTY), this);\n        }\n        String method = (String)context.getProperty(HttpConnector.HTTP_METHOD_PROPERTY, \"POST\");\n        try {\n            URI uri = new URI(endpoint);\n            HttpMethod httpMethod = null;\n\n            if (HttpConstants.METHOD_GET.equals(method)) {\n                httpMethod = new GetMethod(uri.toString());\n                setHeaders(httpMethod, context);\n                String paramName = (String)context.getProperty(\n                        HttpConnector.HTTP_GET_BODY_PARAM_PROPERTY,\n                        HttpConnector.DEFAULT_HTTP_GET_BODY_PARAM_PROPERTY);\n                String query = uri.getQuery();\n                if (!(src instanceof NullPayload) && !StringUtils.EMPTY.equals(src)) {\n                    if (query == null) {\n                        query = paramName + \"=\" + src.toString();\n                    }\n                    else {\n                        query += \"&\" + paramName + \"=\" + src.toString();\n                    }\n                }\n                httpMethod.setQueryString(query);\n\n            }\n            else {\n                PostMethod postMethod = new PostMethod(uri.toString());\n                setHeaders(postMethod, context);\n                String paramName = (String)context\n                        .getProperty(HttpConnector.HTTP_POST_BODY_PARAM_PROPERTY);\n                // postMethod.setRequestContentLength(PostMethod.CONTENT_LENGTH_AUTO);\n                if (paramName == null) {\n                    // Call method to manage the parameter array\n                    addParameters(uri.getQuery(), postMethod);\n                    // Dont set a POST payload if the body is a Null Payload.\n                    // This way client calls\n                    // can control if a POST body is posted explicitly\n                    if (!(context.getMessage().getPayload() instanceof NullPayload)) {\n                        if (src instanceof String) {\n                            if (encoding != null) {\n                                postMethod.setRequestEntity(new ByteArrayRequestEntity(src.toString()\n                                        .getBytes(encoding)));\n                            }\n                            else {\n                                postMethod.setRequestEntity(new ByteArrayRequestEntity(src.toString()\n                                        .getBytes()));\n                            }\n                        }\n                        else if (src instanceof InputStream) {\n                            postMethod.setRequestEntity(new InputStreamRequestEntity((InputStream)src));\n                        }\n                        else {\n                            byte[] buffer = (byte[])serializableToByteArray.doTransform(src, encoding);\n                            postMethod.setRequestEntity(new ByteArrayRequestEntity(buffer));\n                        }\n                    }\n                }\n                else {\n                    postMethod.addParameter(paramName, src.toString());\n                }\n\n                httpMethod = postMethod;\n\n            }\n\n            return httpMethod;\n        }\n        catch (Exception e) {\n            throw new TransformerException(this, e);\n        }\n    }","id":33408,"modified_method":"public Object transform(Object src, String encoding, UMOEventContext context)\n            throws TransformerException\n    {\n        String endpoint = (String)context.getProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, null);\n        if (endpoint == null) {\n            throw new TransformerException(new Message(\n                    Messages.EVENT_PROPERTY_X_NOT_SET_CANT_PROCESS_REQUEST,\n                    MuleProperties.MULE_ENDPOINT_PROPERTY), this);\n        }\n        String method = (String)context.getProperty(HttpConnector.HTTP_METHOD_PROPERTY, \"POST\");\n        try {\n            URI uri = new URI(endpoint);\n            HttpMethod httpMethod = null;\n\n            if (HttpConstants.METHOD_GET.equals(method)) {\n                httpMethod = new GetMethod(uri.toString());\n                setHeaders(httpMethod, context);\n                String paramName = (String)context.getProperty(\n                        HttpConnector.HTTP_GET_BODY_PARAM_PROPERTY,\n                        HttpConnector.DEFAULT_HTTP_GET_BODY_PARAM_PROPERTY);\n                String query = uri.getQuery();\n                if (!(src instanceof NullPayload) && !StringUtils.EMPTY.equals(src)) {\n                    if (query == null) {\n                        query = paramName + \"=\" + src.toString();\n                    }\n                    else {\n                        query += \"&\" + paramName + \"=\" + src.toString();\n                    }\n                }\n                httpMethod.setQueryString(query);\n\n            }\n            else {\n                PostMethod postMethod = new PostMethod(uri.toString());\n                setHeaders(postMethod, context);\n                String paramName = (String)context\n                        .getProperty(HttpConnector.HTTP_POST_BODY_PARAM_PROPERTY);\n                // postMethod.setRequestContentLength(PostMethod.CONTENT_LENGTH_AUTO);\n                if (paramName == null) {\n                    // Call method to manage the parameter array\n                    addParameters(uri.getQuery(), postMethod);\n                    // Dont set a POST payload if the body is a Null Payload.\n                    // This way client calls\n                    // can control if a POST body is posted explicitly\n                    if (!(context.getMessage().getPayload() instanceof NullPayload)) {\n                    \t// See if we have a MIME type set\n                    \tString mimeType = context.getStringProperty(HttpConstants.HEADER_CONTENT_TYPE, null);\n                    \t\n                        if (src instanceof String) {\n                        \t// Ensure that we strip the encoding information from the encoding type\n                        \tint parameterIndex = mimeType != null ? mimeType.indexOf(\";\") : -1;\n                        \tif (parameterIndex > 0) {\n                        \t\tmimeType = mimeType.substring(0,parameterIndex);\n                            }\n                        \tif (mimeType == null) mimeType = HttpConstants.DEFAULT_CONTENT_TYPE;\n                            if (encoding == null) encoding = MuleManager.getConfiguration().getEncoding();\n                            postMethod.setRequestEntity(new StringRequestEntity(src.toString(), mimeType, encoding));\n                        }\n                        else if (src instanceof InputStream) {\n                        \t// Danger here! We don't know if the contents is really text or not \n                        \tif (mimeType == null) mimeType = HttpConstants.DEFAULT_CONTENT_TYPE;\n                            postMethod.setRequestEntity(new InputStreamRequestEntity((InputStream)src, mimeType));\n                        }\n                        else {\n                        \t// Danger here! We don't know if the contents is really text or not \n                        \tif (mimeType == null) mimeType = HttpConstants.DEFAULT_CONTENT_TYPE;\n                            byte[] buffer = (byte[])serializableToByteArray.doTransform(src, encoding);\n                            postMethod.setRequestEntity(new ByteArrayRequestEntity(buffer, mimeType));\n                        }\n                    }\n                }\n                else {\n                    postMethod.addParameter(paramName, src.toString());\n                }\n\n                httpMethod = postMethod;\n\n            }\n\n            return httpMethod;\n        }\n        catch (Exception e) {\n            throw new TransformerException(this, e);\n        }\n    }","commit_id":"8d3d25ed6c0c86378748648268dd4bfd0229f51e","url":"https://github.com/mulesoft/mule"},{"original_method":"public POSTFunction( XQueryContext context )\n    {\n        super( context, signature );\n    }","id":33409,"modified_method":"public POSTFunction(XQueryContext context, FunctionSignature signature)\n    {\n        super(context, signature);\n    }","commit_id":"87faf8474810d08dca718ab29ca44109a46ad423","url":"https://github.com/eXist-db/exist"},{"original_method":"public Sequence eval( Sequence[] args, Sequence contextSequence ) throws XPathException\n    {\n        Sequence    response   = null;\n\t\tbyte[]      reqPayload = null;\n\t\tString\t\tmime\t   = \"text/xml; charset=utf-8\";\n        \n        // must be a URL\n        if( args[0].isEmpty() ) {\n            return( Sequence.EMPTY_SEQUENCE );\n        }\n        \n        //get the url\n        String url                  = args[0].itemAt( 0 ).getStringValue();\n        \n        //get the payload\n        Item payload                = args[1].itemAt( 0 );\n        \n        //get the persist cookies\n        boolean persistCookies      = args[2].effectiveBooleanValue();\n\t\t\n\t\tif( Type.subTypeOf( payload.getType(), Type.NODE ) ) {\n        \n\t        //serialize the node to SAX\n\t        ByteArrayOutputStream baos  = new ByteArrayOutputStream();\n\t        OutputStreamWriter osw      = null;\n\t        try {\n\t            osw = new OutputStreamWriter( baos, \"UTF-8\" );\n\t        } catch (UnsupportedEncodingException e) {\n\t            throw new XPathException(getASTNode(), \"Internal error\");\n\t        }\n\t        SAXSerializer sax           = new SAXSerializer(osw, new Properties());\n\t        \n\t        try {\n\t            payload.toSAX( context.getBroker(), sax, new Properties() );\n\t            osw.flush();\n\t            osw.close();\n\t        }\n\t        catch( Exception e ) {\n\t            e.printStackTrace();\n\t        } \n\t\t\t\n\t\t\treqPayload = baos.toByteArray();\n\t\t} else {\n\t\t\treqPayload = payload.getStringValue().getBytes();\n\t\t\tmime = \"text/text; charset=utf-8\";\n\t\t}\n\t\t\n        //setup POST request\n        PostMethod post         = new PostMethod( url );\n        RequestEntity entity    = new ByteArrayRequestEntity( reqPayload, mime );\n        \n        post.setRequestEntity( entity );\n        \n        //setup POST Request Headers\n        if( !args[3].isEmpty() ) {\n            setHeaders( post, ((NodeValue)args[3].itemAt(0)).getNode() );\n        }\n        \n        try {\n            //execute the request\n            response = doRequest( context, post, persistCookies );\n\n        }\n        catch( IOException ioe ) {\n            throw( new XPathException(getASTNode(), ioe ) );\n        }\n        finally {\n            post.releaseConnection();\n        }\n        \n        return( response );\n    }","id":33410,"modified_method":"public Sequence eval(Sequence[] args, Sequence contextSequence) throws XPathException\n    {\n        Sequence response = null;\n        \n        // must be a URL\n        if(args[0].isEmpty())\n        {\n            return(Sequence.EMPTY_SEQUENCE);\n        }\n        \n        //get the url\n        String url = args[0].itemAt(0).getStringValue();\n        \n        //get the payload\n        \n        Item payload = args[1].itemAt(0);\n        \n        //get the persist cookies\n        boolean persistCookies = args[2].effectiveBooleanValue();\n\t\t\n        PostMethod post = new PostMethod(url);\n        if(isCalledAs(\"post\"))\n        {\n        \tRequestEntity entity = null;\n    \t\tif(Type.subTypeOf(payload.getType(), Type.NODE))\n    \t\t{\n    \t        //serialize the node to SAX\n    \t        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    \t        OutputStreamWriter osw = null;\n    \t        try\n    \t        {\n    \t            osw = new OutputStreamWriter(baos, \"UTF-8\");\n    \t        }\n    \t        catch(UnsupportedEncodingException e)\n    \t        {\n    \t            throw new XPathException(getASTNode(), e.getMessage());\n    \t        }\n    \t        \n    \t        SAXSerializer sax = new SAXSerializer(osw, new Properties());\n    \t        \n    \t        try\n    \t        {\n    \t            payload.toSAX(context.getBroker(), sax, new Properties());\n    \t            osw.flush();\n    \t            osw.close();\n    \t        }\n    \t        catch(Exception e)\n    \t        {\n    \t        \tthrow new XPathException(getASTNode(), e.getMessage());\n    \t        } \n    \t\t\t\n    \t\t\tbyte reqPayload[] = baos.toByteArray();\n    \t\t\tentity = new ByteArrayRequestEntity(reqPayload, \"text/xml; charset=utf-8\");\n    \t\t}\n    \t\telse\n    \t\t{\n    \t\t\ttry\n    \t\t\t{\n    \t\t\t\tentity = new StringRequestEntity(payload.getStringValue(), \"text/text; charset=utf-8\", \"UTF-8\");\n    \t\t\t}\n    \t\t\tcatch(UnsupportedEncodingException uee)\n    \t\t\t{\n    \t\t\t\tuee.printStackTrace();\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tpost.setRequestEntity(entity);\n        }\n        else if(isCalledAs(\"post-form\"))\n        {\n\t\t\tNode nPayload = ((NodeValue)payload).getNode();\n\t\t\tif (nPayload instanceof Element && nPayload.getNamespaceURI().equals(HTTPClientModule.NAMESPACE_URI) && nPayload.getLocalName().equals(\"fields\"))\n\t\t\t{\n\t\t\t\tNameValuePair[] nvPairs = parseFields((Element)nPayload);\n\t\t\t\tpost.setRequestBody(nvPairs);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new XPathException(getASTNode(), \"fields must be provided\");\n\t\t\t}\n\n        }\n        else\n        {\n        \treturn(Sequence.EMPTY_SEQUENCE);\n        }\n        \n        \n        //setup POST Request Headers\n        if(!args[3].isEmpty())\n        {\n            setHeaders(post, ((NodeValue)args[3].itemAt(0)).getNode());\n        }\n        \n        try\n        {\n            //execute the request\n            response = doRequest(context, post, persistCookies);\n\n        }\n        catch(IOException ioe)\n        {\n            throw new XPathException(getASTNode(), ioe);\n        }\n        finally\n        {\n            post.releaseConnection();\n        }\n        \n        return(response);\n    }","commit_id":"87faf8474810d08dca718ab29ca44109a46ad423","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * Creates an instance of <tt>ChatContactListPanel<\/tt>.\n     */\n    public ChatRoomMemberListPanel(ChatPanel chat)\n    {\n        super(new BorderLayout());\n\n        this.memberList = new DefaultContactList();\n\n        // this.chatPanel = chat;\n\n        this.memberList.setModel(memberListModel);\n        this.memberList.setCellRenderer(new ChatContactCellRenderer());\n\n        JScrollPane contactsScrollPane = new SCScrollPane();\n        contactsScrollPane.setHorizontalScrollBarPolicy(\n            JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n\n        contactsScrollPane.getViewport().add(memberList);\n        contactsScrollPane.getViewport().setOpaque(false);\n        contactsScrollPane.setOpaque(false);\n\n        this.add(contactsScrollPane);\n    }","id":33411,"modified_method":"/**\n     * Creates an instance of <tt>ChatContactListPanel<\/tt>.\n     */\n    public ChatRoomMemberListPanel(ChatPanel chat)\n    {\n        super(new BorderLayout());\n\n        // this.chatPanel = chat;\n\n        this.memberList.setModel(memberListModel);\n        this.memberList.setCellRenderer(new ChatContactCellRenderer());\n\n        JScrollPane contactsScrollPane = new SCScrollPane();\n        contactsScrollPane.setHorizontalScrollBarPolicy(\n            JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n        contactsScrollPane.setOpaque(false);\n\n        JViewport viewport = contactsScrollPane.getViewport();\n        viewport.setOpaque(false);\n        viewport.add(memberList);\n\n        this.add(contactsScrollPane);\n    }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void run()\n        {\n            if (!ConfigurationManager.isMoveContactConfirmationRequested())\n            {\n                // we move the specified contact\n                mainFrame.getContactList().moveContact(\n                    srcContact, destGroup);\n\n                return;\n            }\n\n            String message = GuiActivator.getResources().getI18NString(\n                \"service.gui.MOVE_SUBCONTACT_QUESTION\",\n                new String[]{   srcContact.getDisplayName(),\n                                destGroup.getGroupName()});\n\n            MessageDialog dialog = new MessageDialog(\n                    mainFrame,\n                    GuiActivator.getResources()\n                        .getI18NString(\"service.gui.MOVE_CONTACT\"),\n                    message,\n                    GuiActivator.getResources()\n                        .getI18NString(\"service.gui.MOVE\"));\n\n            int returnCode = dialog.showDialog();\n\n            if (returnCode == MessageDialog.OK_RETURN_CODE)\n            {\n                // we move the specified contact\n                mainFrame.getContactList().moveContact(\n                    srcContact, destGroup);\n            }\n            else if (returnCode == MessageDialog.OK_DONT_ASK_CODE)\n            {\n                ConfigurationManager.setMoveContactConfirmationRequested(false);\n                // we move the specified contact\n                mainFrame.getContactList().moveContact(\n                    srcContact, destGroup);\n            }\n        }","id":33412,"modified_method":"public void run()\n        {\n            if (!ConfigurationManager.isMoveContactConfirmationRequested())\n            {\n                // we move the specified contact\n                mainFrame.getContactList().moveContact(\n                    srcContact, destGroup);\n\n                return;\n            }\n\n            String message = GuiActivator.getResources().getI18NString(\n                \"service.gui.MOVE_SUBCONTACT_QUESTION\",\n                new String[]{   srcContact.getDisplayName(),\n                                destGroup.getGroupName()});\n\n            MessageDialog dialog = new MessageDialog(\n                    mainFrame,\n                    GuiActivator.getResources()\n                        .getI18NString(\"service.gui.MOVE_CONTACT\"),\n                    message,\n                    GuiActivator.getResources()\n                        .getI18NString(\"service.gui.MOVE\"));\n\n            switch (dialog.showDialog())\n            {\n            case MessageDialog.OK_DONT_ASK_CODE:\n                ConfigurationManager.setMoveContactConfirmationRequested(false);\n                // do fall through\n\n            case MessageDialog.OK_RETURN_CODE:\n                // we move the specified contact\n                mainFrame.getContactList().moveContact(\n                    srcContact, destGroup);\n                break;\n            }\n        }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Removes a listener previously added with <tt>addContactListListener<\/tt>.\n     *\n     * @param listener the listener to remove\n     */\n    public void removeExcContactListListener(ContactListListener listener)\n    {\n        synchronized (excContactListListeners)\n        {\n            this.excContactListListeners.remove(listener);\n        }\n    }","id":33413,"modified_method":"/**\n     * Removes a listener previously added with <tt>addContactListListener<\/tt>.\n     *\n     * @param listener the listener to remove\n     */\n    public void removeExcContactListListener(ContactListListener listener)\n    {\n        synchronized (excContactListListeners)\n        {\n            excContactListListeners.remove(listener);\n        }\n    }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the Meta Contact Group corresponding to the given MetaUID.\n     *\n     * @param metaUID An identifier of a group.\n     * @return The Meta Contact Group corresponding to the given MetaUID.\n     */\n    public MetaContactGroup getGroupByID(String metaUID)\n    {\n        Iterator i = contactListService.getRoot().getSubgroups();\n        while (i.hasNext())\n        {\n            MetaContactGroup group = (MetaContactGroup) i.next();\n\n            if (group.getMetaUID().equals(metaUID))\n            {\n                return group;\n            }\n        }\n        return null;\n    }","id":33414,"modified_method":"/**\n     * Returns the Meta Contact Group corresponding to the given MetaUID.\n     *\n     * @param metaUID An identifier of a group.\n     * @return The Meta Contact Group corresponding to the given MetaUID.\n     */\n    public MetaContactGroup getGroupByID(String metaUID)\n    {\n        Iterator<MetaContactGroup> i\n            = contactListService.getRoot().getSubgroups();\n        while (i.hasNext())\n        {\n            MetaContactGroup group = i.next();\n\n            if (group.getMetaUID().equals(metaUID))\n                return group;\n        }\n        return null;\n    }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the next list element that starts with a prefix.\n     *\n     * @param prefix the string to test for a match\n     * @param startIndex the index for starting the search\n     * @param bias the search direction, either Position.Bias.Forward or\n     *            Position.Bias.Backward.\n     * @return the index of the next list element that starts with the prefix;\n     *         otherwise -1\n     */\n    public int getNextMatch(String prefix, int startIndex, Position.Bias bias)\n    {\n        int max = listModel.getSize();\n\n        if (prefix == null)\n        {\n            throw new IllegalArgumentException();\n        }\n\n        if (startIndex < 0 || startIndex >= max)\n        {\n            throw new IllegalArgumentException();\n        }\n\n        prefix = prefix.toUpperCase();\n\n        // start search from the next element after the selected element\n        int increment = (bias == Position.Bias.Forward) ? 1 : -1;\n        int index = startIndex;\n        do\n        {\n            Object o = listModel.getElementAt(index);\n\n            if (o != null)\n            {\n                String contactName = null;\n\n                if (o instanceof MetaContact)\n                {\n                    contactName = ((MetaContact) o).getDisplayName()\n                        .toUpperCase();\n                }\n\n                if (contactName != null && contactName.startsWith(prefix))\n                {\n                    return index;\n                }\n            }\n            index = (index + increment + max) % max;\n        } while (index != startIndex);\n        return -1;\n    }","id":33415,"modified_method":"/**\n     * Returns the next list element that starts with a prefix.\n     *\n     * @param prefix the string to test for a match\n     * @param startIndex the index for starting the search\n     * @param bias the search direction, either Position.Bias.Forward or\n     *            Position.Bias.Backward.\n     * @return the index of the next list element that starts with the prefix;\n     *         otherwise -1\n     */\n    public int getNextMatch(String prefix, int startIndex, Position.Bias bias)\n    {\n        int max = listModel.getSize();\n\n        if (prefix == null)\n            throw new IllegalArgumentException(\"prefix\");\n        if (startIndex < 0 || startIndex >= max)\n            throw new IllegalArgumentException(\"startIndex\");\n\n        prefix = prefix.toUpperCase();\n\n        // start search from the next element after the selected element\n        int increment = (bias == Position.Bias.Forward) ? 1 : -1;\n        int index = startIndex;\n        do\n        {\n            Object o = listModel.getElementAt(index);\n\n            if (o != null)\n            {\n                String contactName = null;\n\n                if (o instanceof MetaContact)\n                {\n                    contactName = ((MetaContact) o).getDisplayName()\n                        .toUpperCase();\n                }\n\n                if (contactName != null && contactName.startsWith(prefix))\n                {\n                    return index;\n                }\n            }\n            index = (index + increment + max) % max;\n        } while (index != startIndex);\n        return -1;\n    }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Adds a listener for <tt>ContactListEvent<\/tt>s.\n     *\n     * @param listener the listener to add\n     */\n    public void addExcContactListListener(ContactListListener listener)\n    {\n        synchronized (excContactListListeners)\n        {\n            if (!excContactListListeners.contains(listener))\n                this.excContactListListeners.add(listener);\n        }\n    }","id":33416,"modified_method":"/**\n     * Adds a listener for <tt>ContactListEvent<\/tt>s.\n     *\n     * @param listener the listener to add\n     */\n    public void addExcContactListListener(ContactListListener listener)\n    {\n        synchronized (excContactListListeners)\n        {\n            if (!excContactListListeners.contains(listener))\n                excContactListListeners.add(listener);\n        }\n    }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void run()\n        {\n            if (!ConfigurationManager.isMoveContactConfirmationRequested())\n            {\n                // we move the specified contact\n                mainFrame.getContactList().moveMetaContact(\n                    srcContact, destGroup);\n\n                return;\n            }\n\n            String message = GuiActivator.getResources().getI18NString(\n                \"service.gui.MOVE_SUBCONTACT_QUESTION\",\n                new String[]{   srcContact.getDisplayName(),\n                                destGroup.getGroupName()});\n\n            MessageDialog dialog = new MessageDialog(\n                    mainFrame,\n                    GuiActivator.getResources()\n                        .getI18NString(\"service.gui.MOVE_CONTACT\"),\n                    message,\n                    GuiActivator.getResources()\n                        .getI18NString(\"service.gui.MOVE\"));\n\n            int returnCode = dialog.showDialog();\n\n            if (returnCode == MessageDialog.OK_RETURN_CODE)\n            {\n                // we move the specified contact\n                mainFrame.getContactList().moveMetaContact(\n                    srcContact, destGroup);\n            }\n            else if (returnCode == MessageDialog.OK_DONT_ASK_CODE)\n            {\n                ConfigurationManager.setMoveContactConfirmationRequested(false);\n                // we move the specified contact\n                mainFrame.getContactList().moveMetaContact(\n                    srcContact, destGroup);\n            }\n        }","id":33417,"modified_method":"public void run()\n        {\n            if (!ConfigurationManager.isMoveContactConfirmationRequested())\n            {\n                // we move the specified contact\n                mainFrame.getContactList().moveMetaContact(\n                    srcContact, destGroup);\n\n                return;\n            }\n\n            String message = GuiActivator.getResources().getI18NString(\n                \"service.gui.MOVE_SUBCONTACT_QUESTION\",\n                new String[]{   srcContact.getDisplayName(),\n                                destGroup.getGroupName()});\n\n            MessageDialog dialog = new MessageDialog(\n                    mainFrame,\n                    GuiActivator.getResources()\n                        .getI18NString(\"service.gui.MOVE_CONTACT\"),\n                    message,\n                    GuiActivator.getResources()\n                        .getI18NString(\"service.gui.MOVE\"));\n\n            switch (dialog.showDialog())\n            {\n            case MessageDialog.OK_DONT_ASK_CODE:\n                ConfigurationManager.setMoveContactConfirmationRequested(false);\n                // do fall through\n\n            case MessageDialog.OK_RETURN_CODE:\n                // we move the specified contact\n                mainFrame.getContactList().moveMetaContact(\n                    srcContact, destGroup);\n                break;\n            }\n        }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void run()\n        {\n            if (!ConfigurationManager.isMoveContactConfirmationRequested())\n            {\n                // we move the specified contact\n                mainFrame.getContactList().moveContact(\n                    srcContact, destMetaContact);\n\n                return;\n            }\n\n            String message = GuiActivator.getResources().getI18NString(\n                \"service.gui.MOVE_SUBCONTACT_QUESTION\",\n                new String[]{   srcContact.getDisplayName(),\n                                destMetaContact.getDisplayName()});\n\n            MessageDialog dialog = new MessageDialog(\n                    mainFrame,\n                    GuiActivator.getResources()\n                        .getI18NString(\"service.gui.MOVE_CONTACT\"),\n                    message,\n                    GuiActivator.getResources()\n                        .getI18NString(\"service.gui.MOVE\"));\n\n            int returnCode = dialog.showDialog();\n\n            if (returnCode == MessageDialog.OK_RETURN_CODE)\n            {\n                // we move the specified contact\n                mainFrame.getContactList().moveContact(\n                    srcContact, destMetaContact);\n            }\n            else if (returnCode == MessageDialog.OK_DONT_ASK_CODE)\n            {\n                ConfigurationManager.setMoveContactConfirmationRequested(false);\n                // we move the specified contact\n                mainFrame.getContactList().moveContact(\n                    srcContact, destMetaContact);\n            }\n        }","id":33418,"modified_method":"public void run()\n        {\n            if (!ConfigurationManager.isMoveContactConfirmationRequested())\n            {\n                // we move the specified contact\n                mainFrame.getContactList().moveContact(\n                    srcContact, destMetaContact);\n\n                return;\n            }\n\n            String message = GuiActivator.getResources().getI18NString(\n                \"service.gui.MOVE_SUBCONTACT_QUESTION\",\n                new String[]{   srcContact.getDisplayName(),\n                                destMetaContact.getDisplayName()});\n\n            MessageDialog dialog = new MessageDialog(\n                    mainFrame,\n                    GuiActivator.getResources()\n                        .getI18NString(\"service.gui.MOVE_CONTACT\"),\n                    message,\n                    GuiActivator.getResources()\n                        .getI18NString(\"service.gui.MOVE\"));\n\n            switch (dialog.showDialog())\n            {\n            case MessageDialog.OK_DONT_ASK_CODE:\n                ConfigurationManager.setMoveContactConfirmationRequested(false);\n                // do fall through\n\n            case MessageDialog.OK_RETURN_CODE:\n                // we move the specified contact\n                mainFrame.getContactList().moveContact(\n                    srcContact, destMetaContact);\n                break;\n            }\n        }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Adds a listener for <tt>ContactListEvent<\/tt>s.\n     *\n     * @param listener the listener to add\n     */\n    public void addContactListListener(ContactListListener listener)\n    {\n        synchronized (contactListListeners)\n        {\n            if (!contactListListeners.contains(listener))\n                this.contactListListeners.add(listener);\n        }\n    }","id":33419,"modified_method":"/**\n     * Adds a listener for <tt>ContactListEvent<\/tt>s.\n     *\n     * @param listener the listener to add\n     */\n    public void addContactListListener(ContactListListener listener)\n    {\n        synchronized (contactListListeners)\n        {\n            if (!contactListListeners.contains(listener))\n                contactListListeners.add(listener);\n        }\n    }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Handles the <tt>ProtoContactEvent<\/tt>. Refreshes the list when a\n     * protocol contact has been added.\n     */\n    public void protoContactAdded(ProtoContactEvent evt)\n    {\n        MetaContact parentMetaContact = evt.getNewParent();\n\n        this.refreshContact(parentMetaContact);\n    }","id":33420,"modified_method":"/**\n     * Handles the <tt>ProtoContactEvent<\/tt>. Refreshes the list when a\n     * protocol contact has been added.\n     */\n    public void protoContactAdded(ProtoContactEvent evt)\n    {\n        this.refreshContact(evt.getNewParent());\n    }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Refreshes all the contact list.\n     */\n    public void removeContact(MetaContactEvent event)\n    {\n        MetaContact metaContact = event.getSourceMetaContact();\n        synchronized (contentToRefresh)\n        {\n            if (metaContact != null && !contentToRefresh.contains(event))\n            {\n\n                contentToRefresh.put(event, REMOVE_OPERATION);\n                contentToRefresh.notifyAll();\n            }\n        }\n    }","id":33421,"modified_method":"/**\n     * Refreshes all the contact list.\n     */\n    public void removeContact(MetaContactEvent event)\n    {\n        synchronized (contentToRefresh)\n        {\n            if (event.getSourceMetaContact() != null\n                    && !contentToRefresh.containsKey(event))\n            {\n                contentToRefresh.put(event, REMOVE_OPERATION);\n                contentToRefresh.notifyAll();\n            }\n        }\n    }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Initialize all listeners.\n     */\n    private void initListeners()\n    {\n        this.contactListService.addMetaContactListListener(this);\n\n        this.addMouseListener(this);\n        this.addMouseMotionListener(this);\n\n        this.addFocusListener(new FocusAdapter()\n        {\n            public void focusLost(FocusEvent e)\n            {\n                if (draggedElement != null)\n                {\n                    draggedElement.setVisible(false);\n                    draggedElement = null;\n                }\n            }\n        });\n\n        CListKeySearchListener keyListener\n            = new CListKeySearchListener(this);\n\n        this.addKeyListener(keyListener);\n\n        this.addKeyListener(new KeyAdapter()\n        {\n            public void keyPressed(KeyEvent e)\n            {\n                if (e.getKeyCode() == KeyEvent.VK_ESCAPE)\n                {\n                    if (draggedElement != null)\n                    {\n                        draggedElement.setVisible(false);\n                        draggedElement = null;\n                    }\n                }\n            }\n        });\n\n        this.addListSelectionListener(new ListSelectionListener()\n        {\n            public void valueChanged(ListSelectionEvent e)\n            {\n                if (!e.getValueIsAdjusting())\n                {\n                    currentlySelectedObject = getSelectedValue();\n                }\n            }\n        });\n    }","id":33422,"modified_method":"/**\n     * Initialize all listeners.\n     */\n    private void initListeners()\n    {\n        this.contactListService.addMetaContactListListener(this);\n\n        this.addMouseListener(this);\n        this.addMouseMotionListener(this);\n\n        this.addFocusListener(new FocusAdapter()\n        {\n            public void focusLost(FocusEvent e)\n            {\n                if (draggedElement != null)\n                {\n                    draggedElement.setVisible(false);\n                    draggedElement = null;\n                }\n            }\n        });\n\n        this.addKeyListener(new CListKeySearchListener(this));\n\n        this.addKeyListener(new KeyAdapter()\n        {\n            public void keyPressed(KeyEvent e)\n            {\n                if ((e.getKeyCode() == KeyEvent.VK_ESCAPE)\n                        && (draggedElement != null))\n                {\n                    draggedElement.setVisible(false);\n                    draggedElement = null;\n                }\n            }\n        });\n\n        this.addListSelectionListener(new ListSelectionListener()\n        {\n            public void valueChanged(ListSelectionEvent e)\n            {\n                if (!e.getValueIsAdjusting())\n                {\n                    currentlySelectedObject = getSelectedValue();\n                }\n            }\n        });\n    }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates the corresponding ContactListEvent and notifies all\n     * <tt>ContactListListener<\/tt>s that a contact is selected.\n     *\n     * @param sourceContact the contact that this event is about\n     * @param protocolContact the protocol contact the this event is about\n     * @param eventID the id indicating the exact type of the event to fire.\n     */\n    public void fireContactListEvent(MetaContact sourceContact,\n        Contact protocolContact, int eventID)\n    {\n        ContactListEvent evt = new ContactListEvent(sourceContact,\n            protocolContact, eventID);\n\n        synchronized (contactListListeners)\n        {\n            Iterator listeners = this.contactListListeners.iterator();\n\n            while (listeners.hasNext())\n            {\n                ContactListListener listener = (ContactListListener) listeners\n                    .next();\n                switch (evt.getEventID())\n                {\n                case ContactListEvent.CONTACT_SELECTED:\n                    listener.contactClicked(evt);\n                    break;\n                case ContactListEvent.PROTOCOL_CONTACT_SELECTED:\n                    listener.protocolContactClicked(evt);\n                    break;\n                default:\n                    logger.error(\"Unknown event type \" + evt.getEventID());\n                }\n            }\n        }\n    }","id":33423,"modified_method":"/**\n     * Creates the corresponding ContactListEvent and notifies all\n     * <tt>ContactListListener<\/tt>s that a contact is selected.\n     *\n     * @param sourceContact the contact that this event is about\n     * @param protocolContact the protocol contact the this event is about\n     * @param eventID the id indicating the exact type of the event to fire.\n     */\n    public void fireContactListEvent(MetaContact sourceContact,\n        Contact protocolContact, int eventID)\n    {\n        fireContactListEvent(\n            contactListListeners,\n            new ContactListEvent(sourceContact, protocolContact, eventID));\n    }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * If we were performing a drag'n drop operation when the mouse is released,\n     * complete it by moving the <tt>Contact<\/tt> and/or <tt>MetaContact<\/tt> enclosed\n     * by the <tt>draggedElement<\/tt> from that <tt>MetaContact<\/tt>\n     * to the <tt>MetaContactGroup<\/tt> or <tt>MetaContact<\/tt> on which\n     * the drop occurs.\n     */\n    public void mouseReleased(MouseEvent e)\n    {\n        int selectedIndex = this.locationToIndex(e.getPoint());\n\n        Object dest = listModel.getElementAt(selectedIndex);\n\n        if (draggedElement != null)\n        {\n            if (dest instanceof MetaContact)\n            {\n                MetaContact contactDest = (MetaContact) dest;\n                if (draggedElement.getMetaContact() != contactDest)\n                {\n                    if (draggedElement.getContact() != null)\n                    {\n                        new MoveContactToMetaContactThread(\n                                draggedElement.getContact(),\n                                contactDest).start();\n                    }\n                    else\n                    {\n                        // we move all contacts from this meta contact\n                        Iterator i = draggedElement.\n                            getMetaContact().getContacts();\n\n                        while(i.hasNext())\n                        {\n                            Contact contact = (Contact) i.next();\n                            new MoveContactToMetaContactThread(\n                                contact,\n                                contactDest).start();\n                        }\n\n                    }\n                }\n            }\n            else if (dest instanceof MetaContactGroup)\n            {\n                MetaContactGroup contactDest = (MetaContactGroup) dest;\n                if (draggedElement.getContact() != null)\n                {\n                    // there is a specific contact moved. if this contact\n                    // has fellow in its meta contact parent, we move only\n                    // this contact. Otherwise we move the whole meta contact\n                    // as this contact is the only one inside it.\n                    if (draggedElement.getMetaContact().getContactCount() > 1)\n                    {\n                        new MoveContactToGroupThread(\n                            draggedElement.getContact(),\n                            contactDest).start();\n                    }\n                    else if (!contactDest.contains(\n                        draggedElement.getMetaContact()))\n                    {\n                        new MoveMetaContactThread(\n                            draggedElement.getMetaContact(),\n                            contactDest).start();\n                    }\n                }\n                else if (!contactDest.contains(draggedElement.getMetaContact()))\n                {\n                    try\n                    {\n                        new MoveMetaContactThread(\n                            draggedElement.getMetaContact(),\n                            contactDest).start();\n                    }\n                    catch (Exception ex)\n                    {\n                        new ErrorDialog(\n                                mainFrame,\n                                GuiActivator.getResources().getI18NString(\n                                    \"service.gui.MOVE_TO_GROUP\"),\n                                GuiActivator.getResources().getI18NString(\n                                    \"service.gui.MOVE_CONTACT_ERROR\"),\n                                ex).showDialog();\n                    }\n                }\n            }\n\n            draggedElement.setVisible(false);\n            draggedElement = null;\n        }\n\n        setCursor(Cursor\n            .getPredefinedCursor((dest instanceof MetaContactGroup) ? Cursor.HAND_CURSOR\n                : Cursor.DEFAULT_CURSOR));\n    }","id":33424,"modified_method":"/**\n     * If we were performing a drag'n drop operation when the mouse is released,\n     * complete it by moving the <tt>Contact<\/tt> and/or <tt>MetaContact<\/tt> enclosed\n     * by the <tt>draggedElement<\/tt> from that <tt>MetaContact<\/tt>\n     * to the <tt>MetaContactGroup<\/tt> or <tt>MetaContact<\/tt> on which\n     * the drop occurs.\n     */\n    public void mouseReleased(MouseEvent e)\n    {\n        int selectedIndex = this.locationToIndex(e.getPoint());\n\n        Object dest = listModel.getElementAt(selectedIndex);\n\n        if (draggedElement != null)\n        {\n            if (dest instanceof MetaContact)\n            {\n                MetaContact contactDest = (MetaContact) dest;\n                if (draggedElement.getMetaContact() != contactDest)\n                {\n                    if (draggedElement.getContact() != null)\n                    {\n                        new MoveContactToMetaContactThread(\n                                draggedElement.getContact(),\n                                contactDest).start();\n                    }\n                    else\n                    {\n                        // we move all contacts from this meta contact\n                        Iterator<Contact> i\n                            = draggedElement.getMetaContact().getContacts();\n                        while(i.hasNext())\n                        {\n                            Contact contact = i.next();\n\n                            new MoveContactToMetaContactThread(\n                                contact,\n                                contactDest).start();\n                        }\n\n                    }\n                }\n            }\n            else if (dest instanceof MetaContactGroup)\n            {\n                MetaContactGroup contactDest = (MetaContactGroup) dest;\n                if (draggedElement.getContact() != null)\n                {\n                    // there is a specific contact moved. if this contact\n                    // has fellow in its meta contact parent, we move only\n                    // this contact. Otherwise we move the whole meta contact\n                    // as this contact is the only one inside it.\n                    if (draggedElement.getMetaContact().getContactCount() > 1)\n                    {\n                        new MoveContactToGroupThread(\n                            draggedElement.getContact(),\n                            contactDest).start();\n                    }\n                    else if (!contactDest.contains(\n                        draggedElement.getMetaContact()))\n                    {\n                        new MoveMetaContactThread(\n                            draggedElement.getMetaContact(),\n                            contactDest).start();\n                    }\n                }\n                else if (!contactDest.contains(draggedElement.getMetaContact()))\n                {\n                    try\n                    {\n                        new MoveMetaContactThread(\n                            draggedElement.getMetaContact(),\n                            contactDest).start();\n                    }\n                    catch (Exception ex)\n                    {\n                        new ErrorDialog(\n                                mainFrame,\n                                GuiActivator.getResources().getI18NString(\n                                    \"service.gui.MOVE_TO_GROUP\"),\n                                GuiActivator.getResources().getI18NString(\n                                    \"service.gui.MOVE_CONTACT_ERROR\"),\n                                ex).showDialog();\n                    }\n                }\n            }\n\n            draggedElement.setVisible(false);\n            draggedElement = null;\n        }\n\n        setCursor(Cursor\n            .getPredefinedCursor((dest instanceof MetaContactGroup) ? Cursor.HAND_CURSOR\n                : Cursor.DEFAULT_CURSOR));\n    }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Handles the <tt>ProtoContactEvent<\/tt>. Refreshes the list when a\n     * protocol contact has been moved.\n     */\n    public void protoContactMoved(ProtoContactEvent evt)\n    {\n        MetaContact oldParentMetaContact = evt.getOldParent();\n        MetaContact newParentMetaContact = evt.getNewParent();\n\n        this.refreshContact(oldParentMetaContact);\n        this.refreshContact(newParentMetaContact);\n    }","id":33425,"modified_method":"/**\n     * Handles the <tt>ProtoContactEvent<\/tt>. Refreshes the list when a\n     * protocol contact has been moved.\n     */\n    public void protoContactMoved(ProtoContactEvent evt)\n    {\n        this.refreshContact(evt.getOldParent());\n        this.refreshContact(evt.getNewParent());\n    }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates the corresponding ContactListEvent and notifies all\n     * <tt>ContactListListener<\/tt>s that a contact is selected.\n     *\n     * @param source the contact that this event is about.\n     * @param eventID the id indicating the exact type of the event to fire.\n     * @param clickCount the number of clicks accompanying the event.\n     */\n    public void fireContactListEvent(Object source, int eventID, int clickCount)\n    {\n        ContactListEvent evt = new ContactListEvent(source, eventID, clickCount);\n\n        if (excContactListListeners.size() > 0)\n        {\n            synchronized (excContactListListeners)\n            {\n                Iterator listeners = new Vector(this.excContactListListeners)\n                    .iterator();\n\n                while (listeners.hasNext())\n                {\n                    ContactListListener listener\n                        = (ContactListListener) listeners.next();\n\n                    switch (evt.getEventID())\n                    {\n                        case ContactListEvent.CONTACT_SELECTED:\n                            listener.contactClicked(evt);\n                            break;\n                        case ContactListEvent.PROTOCOL_CONTACT_SELECTED:\n                            listener.protocolContactClicked(evt);\n                            break;\n                        case ContactListEvent.GROUP_SELECTED:\n                            listener.groupSelected(evt);\n                            break;\n                        default:\n                            logger.error(\"Unknown event type \"\n                                + evt.getEventID());\n                    }\n                }\n            }\n        }\n        else\n        {\n            synchronized (contactListListeners)\n            {\n                Iterator listeners = this.contactListListeners.iterator();\n\n                while (listeners.hasNext())\n                {\n                    ContactListListener listener = (ContactListListener) listeners\n                        .next();\n                    switch (evt.getEventID())\n                    {\n                    case ContactListEvent.CONTACT_SELECTED:\n                        listener.contactClicked(evt);\n                        break;\n                    case ContactListEvent.PROTOCOL_CONTACT_SELECTED:\n                        listener.protocolContactClicked(evt);\n                        break;\n                    case ContactListEvent.GROUP_SELECTED:\n                        listener.groupSelected(evt);\n                        break;\n                    default:\n                        logger.error(\"Unknown event type \" + evt.getEventID());\n                    }\n                }\n            }\n        }\n    }","id":33426,"modified_method":"/**\n     * Creates the corresponding ContactListEvent and notifies all\n     * <tt>ContactListListener<\/tt>s that a contact is selected.\n     *\n     * @param source the contact that this event is about.\n     * @param eventID the id indicating the exact type of the event to fire.\n     * @param clickCount the number of clicks accompanying the event.\n     */\n    public void fireContactListEvent(Object source, int eventID, int clickCount)\n    {\n        ContactListEvent evt = new ContactListEvent(source, eventID, clickCount);\n\n        synchronized (excContactListListeners)\n        {\n            if (excContactListListeners.size() > 0)\n            {\n                fireContactListEvent(\n                    new Vector<ContactListListener>(excContactListListeners),\n                    evt);\n                return;\n            }\n        }\n\n        fireContactListEvent(contactListListeners, evt);\n    }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Removes the given <tt>MetaContact<\/tt> from the list of active contacts.\n     *\n     * @param metaContact the <tt>MetaContact<\/tt> to remove.\n     */\n    public void removeActiveContact(MetaContact metaContact)\n    {\n        synchronized (activeContacts)\n        {\n            if(activeContacts.contains(metaContact))\n                this.activeContacts.remove(metaContact);\n\n            if(activeContacts.size() == 0)\n                GuiActivator.getSystrayService().setSystrayIcon(\n                   SystrayService.SC_IMG_TYPE);\n        }\n\n        this.refreshContact(metaContact);\n    }","id":33427,"modified_method":"/**\n     * Removes the given <tt>MetaContact<\/tt> from the list of active contacts.\n     *\n     * @param metaContact the <tt>MetaContact<\/tt> to remove.\n     */\n    public void removeActiveContact(MetaContact metaContact)\n    {\n        synchronized (activeContacts)\n        {\n            activeContacts.remove(metaContact);\n\n            if(activeContacts.size() == 0)\n                GuiActivator.getSystrayService().setSystrayIcon(\n                   SystrayService.SC_IMG_TYPE);\n        }\n\n        this.refreshContact(metaContact);\n    }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void run()\n        {\n            try\n            {\n                Map copyContentToRefresh = null;\n\n                while (refreshEnabled)\n                {\n\n                    synchronized (contentToRefresh)\n                    {\n                        if (contentToRefresh.isEmpty())\n                            contentToRefresh.wait();\n\n                        copyContentToRefresh = new Hashtable(contentToRefresh);\n                        contentToRefresh.clear();\n                    }\n\n                    Iterator i = copyContentToRefresh.entrySet().iterator();\n                    while (i.hasNext())\n                    {\n                        Map.Entry groupEntry = (Map.Entry) i.next();\n\n                        String operation = (String) groupEntry.getValue();\n\n                        Object o = groupEntry.getKey();\n\n                        if (o instanceof MetaContactGroup)\n                        {\n\n                            MetaContactGroup group = (MetaContactGroup) o;\n\n                            SwingUtilities.invokeLater(new RefreshGroup(group,\n                                operation));\n                        }\n                        else if (o instanceof MetaContact)\n                        {\n\n                            MetaContact contact = (MetaContact) o;\n\n                            SwingUtilities.invokeLater(new RefreshContact(\n                                contact, contact.getParentMetaContactGroup(),\n                                operation));\n                        }\n                        else if (o instanceof MetaContactEvent)\n                        {\n\n                            MetaContactEvent event = (MetaContactEvent) o;\n                            MetaContact contact = event.getSourceMetaContact();\n                            MetaContactGroup parentGroup = event\n                                .getParentGroup();\n\n                            SwingUtilities.invokeLater(new RefreshContact(\n                                contact, parentGroup, operation));\n                        }\n                    }\n                }\n            }\n            catch (InterruptedException e)\n            {\n                e.printStackTrace();\n            }\n        }","id":33428,"modified_method":"public void run()\n        {\n            try\n            {\n                while (refreshEnabled)\n                {\n                    Map<Object, String> copyContentToRefresh;\n\n                    synchronized (contentToRefresh)\n                    {\n                        if (contentToRefresh.isEmpty())\n                            contentToRefresh.wait();\n\n                        copyContentToRefresh = new Hashtable<Object, String>(contentToRefresh);\n                        contentToRefresh.clear();\n                    }\n\n                    for (Map.Entry<Object, String> groupEntry : copyContentToRefresh.entrySet())\n                    {\n                        String operation = groupEntry.getValue();\n                        Object o = groupEntry.getKey();\n\n                        if (o instanceof MetaContactGroup)\n                        {\n                            MetaContactGroup group = (MetaContactGroup) o;\n\n                            SwingUtilities.invokeLater(new RefreshGroup(group,\n                                operation));\n                        }\n                        else if (o instanceof MetaContact)\n                        {\n                            MetaContact contact = (MetaContact) o;\n\n                            SwingUtilities.invokeLater(new RefreshContact(\n                                contact, contact.getParentMetaContactGroup(),\n                                operation));\n                        }\n                        else if (o instanceof MetaContactEvent)\n                        {\n                            MetaContactEvent event = (MetaContactEvent) o;\n                            MetaContact contact = event.getSourceMetaContact();\n                            MetaContactGroup parentGroup = event\n                                .getParentGroup();\n\n                            SwingUtilities.invokeLater(new RefreshContact(\n                                contact, parentGroup, operation));\n                        }\n                    }\n                }\n            }\n            catch (InterruptedException e)\n            {\n                e.printStackTrace();\n            }\n        }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Removes all contacts from the list of active contacts.\n     */\n    public void removeAllActiveContacts()\n    {\n        synchronized (activeContacts)\n        {\n            if(activeContacts.size() > 0)\n            {\n                this.activeContacts.removeAllElements();\n\n                GuiActivator.getSystrayService().setSystrayIcon(\n                   SystrayService.SC_IMG_TYPE);\n            }\n        }\n\n        this.refreshAll();\n    }","id":33429,"modified_method":"/**\n     * Removes all contacts from the list of active contacts.\n     */\n    public void removeAllActiveContacts()\n    {\n        synchronized (activeContacts)\n        {\n            if(activeContacts.size() > 0)\n            {\n                activeContacts.clear();\n\n                GuiActivator.getSystrayService().setSystrayIcon(\n                   SystrayService.SC_IMG_TYPE);\n            }\n        }\n\n        this.refreshAll();\n    }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Checks if the given contact is currently active.\n     *\n     * @param metaContact the <tt>MetaContact<\/tt> to verify\n     * @return TRUE if the given <tt>MetaContact<\/tt> is active, FALSE -\n     * otherwise\n     */\n    public boolean isMetaContactActive(MetaContact metaContact)\n    {\n        synchronized (activeContacts)\n        {\n            return this.activeContacts.contains(metaContact);\n        }\n    }","id":33430,"modified_method":"/**\n     * Checks if the given contact is currently active.\n     *\n     * @param metaContact the <tt>MetaContact<\/tt> to verify\n     * @return TRUE if the given <tt>MetaContact<\/tt> is active, FALSE -\n     * otherwise\n     */\n    public boolean isMetaContactActive(MetaContact metaContact)\n    {\n        synchronized (activeContacts)\n        {\n            return activeContacts.contains(metaContact);\n        }\n    }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Removes a listener previously added with <tt>addContactListListener<\/tt>.\n     *\n     * @param listener the listener to remove\n     */\n    public void removeContactListListener(ContactListListener listener)\n    {\n        synchronized (contactListListeners)\n        {\n            this.contactListListeners.remove(listener);\n        }\n    }","id":33431,"modified_method":"/**\n     * Removes a listener previously added with <tt>addContactListListener<\/tt>.\n     *\n     * @param listener the listener to remove\n     */\n    public void removeContactListListener(ContactListListener listener)\n    {\n        synchronized (contactListListeners)\n        {\n            contactListListeners.remove(listener);\n        }\n    }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Adds the given <tt>MetaContact<\/tt> to the list of active contacts.\n     *\n     * @param metaContact the <tt>MetaContact<\/tt> to add.\n     */\n    public void addActiveContact(MetaContact metaContact)\n    {\n        synchronized (activeContacts)\n        {\n            SystrayService stray = GuiActivator.getSystrayService();\n            if(activeContacts.size() == 0 && stray != null)\n                stray.setSystrayIcon(SystrayService.ENVELOPE_IMG_TYPE);\n\n            if(!activeContacts.contains(metaContact))\n                this.activeContacts.add(metaContact);\n        }\n\n        this.refreshContact(metaContact);\n    }","id":33432,"modified_method":"/**\n     * Adds the given <tt>MetaContact<\/tt> to the list of active contacts.\n     *\n     * @param metaContact the <tt>MetaContact<\/tt> to add.\n     */\n    public void addActiveContact(MetaContact metaContact)\n    {\n        synchronized (activeContacts)\n        {\n            if(activeContacts.size() == 0)\n            {\n                SystrayService stray = GuiActivator.getSystrayService();\n\n                if (stray != null)\n                    stray.setSystrayIcon(SystrayService.ENVELOPE_IMG_TYPE);\n            }\n\n            if(!activeContacts.contains(metaContact))\n                activeContacts.add(metaContact);\n        }\n\n        this.refreshContact(metaContact);\n    }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the index of the given MetaContact.\n     *\n     * @param contact The MetaContact to search for.\n     * @return The index of the given MetaContact.\n     */\n    private int indexOf(MetaContact contact)\n    {\n        int index = -1;\n\n        if (showOffline || isContactOnline(contact))\n        {\n            int currentIndex = 0;\n            MetaContactGroup parentGroup = this.contactList\n                .findParentMetaContactGroup(contact);\n\n            if (parentGroup != null && !this.isGroupClosed(parentGroup))\n            {\n\n                currentIndex += this.indexOf(parentGroup);\n\n                currentIndex += parentGroup.indexOf(contact) + 1;\n\n                index = currentIndex;\n            }\n        }\n        return index;\n    }","id":33433,"modified_method":"/**\n     * Returns the index of the given MetaContact.\n     *\n     * @param contact The MetaContact to search for.\n     * @return The index of the given MetaContact.\n     */\n    private int indexOf(MetaContact contact)\n    {\n        int index = -1;\n\n        if (showOffline || isContactOnline(contact))\n        {\n            MetaContactGroup parentGroup\n                = this.contactList.findParentMetaContactGroup(contact);\n\n            if (parentGroup != null && !this.isGroupClosed(parentGroup))\n            {\n                index = this.indexOf(parentGroup)\n                        + (parentGroup.indexOf(contact) + 1);\n            }\n        }\n        return index;\n    }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Recursively searches the given group in depth for the element at the\n     * given index.\n     *\n     * @param group the group in which we search\n     * @param currentIndex the index, where we currently are\n     * @param searchedIndex the index to search for\n     * @return The element at the given index, if we find it, otherwise null.\n     */\n    private Object getElementAt(MetaContactGroup group, int currentIndex,\n        int searchedIndex)\n    {\n\n        Object element = null;\n        if (currentIndex == searchedIndex)\n        {\n            // the current index is the index of the group so if this is the\n            // searched index we return the group\n            element = group;\n        }\n        else\n        {\n            // if the group is closed don't count its children\n            if (!isGroupClosed(group))\n            {\n                int childCount = countChildContacts(group);\n\n                if (searchedIndex <= (currentIndex + childCount))\n                {\n                    // if the searched index is lower than or equal to\n                    // the greater child index in this group then our element is\n                    // here\n                    MetaContact contact = group.getMetaContact(searchedIndex\n                        - currentIndex - 1);\n\n                    if (showOffline || isContactOnline(contact))\n                        element = contact;\n                }\n                else\n                {\n                    // if we haven't found the contact we search the subgroups\n                    currentIndex += childCount;\n                    Iterator subgroups = group.getSubgroups();\n\n                    while (subgroups.hasNext())\n                    {\n                        MetaContactGroup subgroup = (MetaContactGroup) subgroups\n                            .next();\n\n                        if(showOffline || containsOnlineContacts(subgroup))\n                            element = getElementAt(subgroup, currentIndex + 1,\n                                searchedIndex);\n\n                        if (element != null)\n                            break;\n                        else\n                        {\n                            // if we haven't found the element on this iteration\n                            // we update the current index and we continue\n                            if (showOffline || containsOnlineContacts(subgroup))\n                            {\n                                if (!isGroupClosed(subgroup))\n                                    currentIndex += countChildContacts(subgroup) + 1;\n                                else\n                                    currentIndex++;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return element;\n    }","id":33434,"modified_method":"/**\n     * Recursively searches the given group in depth for the element at the\n     * given index.\n     *\n     * @param group the group in which we search\n     * @param currentIndex the index, where we currently are\n     * @param searchedIndex the index to search for\n     * @return The element at the given index, if we find it, otherwise null.\n     */\n    private Object getElementAt(MetaContactGroup group, int currentIndex,\n            int searchedIndex)\n    {\n        Object element = null;\n        if (currentIndex == searchedIndex)\n        {\n            // the current index is the index of the group so if this is the\n            // searched index we return the group\n            element = group;\n        }\n        else\n        {\n            // if the group is closed don't count its children\n            if (!isGroupClosed(group))\n            {\n                int childCount = countChildContacts(group);\n\n                if (searchedIndex <= (currentIndex + childCount))\n                {\n                    // if the searched index is lower than or equal to\n                    // the greater child index in this group then our element is\n                    // here\n                    MetaContact contact = group.getMetaContact(searchedIndex\n                        - currentIndex - 1);\n\n                    if (showOffline || isContactOnline(contact))\n                        element = contact;\n                }\n                else\n                {\n                    // if we haven't found the contact we search the subgroups\n                    currentIndex += childCount;\n\n                    Iterator<MetaContactGroup> subgroups = group.getSubgroups();\n                    while (subgroups.hasNext())\n                    {\n                        MetaContactGroup subgroup = subgroups.next();\n\n                        if(showOffline || containsOnlineContacts(subgroup))\n                            element = getElementAt(subgroup, currentIndex + 1,\n                                searchedIndex);\n\n                        if (element != null)\n                            break;\n\n                        // if we haven't found the element on this iteration\n                        // we update the current index and we continue\n                        else if (showOffline || containsOnlineContacts(subgroup))\n                        {\n                            if (!isGroupClosed(subgroup))\n                                currentIndex += countChildContacts(subgroup) + 1;\n                            else\n                                currentIndex++;\n                        }\n                    }\n                }\n            }\n        }\n        return element;\n    }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Checks whether the group is closed.\n     *\n     * @param group The group to check.\n     * @return True if the group is closed, false - otherwise.\n     */\n    public boolean isGroupClosed(MetaContactGroup group)\n    {\n        if (this.closedGroups.contains(group))\n            return true;\n        else\n            return false;\n    }","id":33435,"modified_method":"/**\n     * Checks whether the group is closed.\n     *\n     * @param group The group to check.\n     * @return True if the group is closed, false - otherwise.\n     */\n    public boolean isGroupClosed(MetaContactGroup group)\n    {\n        return this.closedGroups.contains(group);\n    }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Checks if the given group contains online contacts.\n     *\n     * @param group the group to check for online contacts\n     * @return TRUE if the given group contains online contacts, FALSE otherwise\n     */\n    private boolean containsOnlineContacts(MetaContactGroup group)\n    {\n        Iterator childContacts = group.getChildContacts();\n        while (childContacts.hasNext())\n        {\n            MetaContact contact = (MetaContact) childContacts.next();\n\n            if (isContactOnline(contact))\n                return true;\n        }\n\n        return false;\n    }","id":33436,"modified_method":"/**\n     * Checks if the given group contains online contacts.\n     *\n     * @param group the group to check for online contacts\n     * @return TRUE if the given group contains online contacts, FALSE otherwise\n     */\n    private boolean containsOnlineContacts(MetaContactGroup group)\n    {\n        Iterator<MetaContact> childContacts = group.getChildContacts();\n        while (childContacts.hasNext())\n        {\n            MetaContact contact = childContacts.next();\n\n            if (isContactOnline(contact))\n                return true;\n        }\n\n        return false;\n    }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Goes through all subgroups and contacts and determines the final size of\n     * the contact list.\n     *0\n     * @param group The group which to be measured.\n     * @return The size of the contactlist\n     */\n    private int getContactListSize(MetaContactGroup group)\n    {\n        int size = 0;\n\n        if (!isGroupClosed(group))\n        {\n            if (showOffline)\n            {\n                size = group.countChildContacts();\n                //count the group itself\n                if(!group.equals(rootGroup))\n                    size++;\n            }\n            else\n            {\n                Iterator i = group.getChildContacts();\n                while (i.hasNext())\n                {\n                    MetaContact contact = (MetaContact) i.next();\n\n                    if (isContactOnline(contact))\n                        size++;\n                }\n\n                //count the group itself only if it contains any online contacts\n                if(!group.equals(rootGroup) && size > 0)\n                    size++;\n            }\n\n            Iterator subgroups = group.getSubgroups();\n\n            while (subgroups.hasNext())\n            {\n                MetaContactGroup subGroup = (MetaContactGroup) subgroups.next();\n                size += getContactListSize(subGroup);\n            }\n        }\n        else\n        {\n            // If offline contacts are shown we just count the closed group;\n            if(showOffline)\n            {\n                //count the closed group\n                size++;\n            }\n            else\n            {\n                // If offline contacts are not shown we'll count the group\n                // only if it contains online contacts.\n                if( containsOnlineContacts(group))\n                    size++;\n            }\n        }\n\n        return size;\n    }","id":33437,"modified_method":"/**\n     * Goes through all subgroups and contacts and determines the final size of\n     * the contact list.\n     *0\n     * @param group The group which to be measured.\n     * @return The size of the contactlist\n     */\n    private int getContactListSize(MetaContactGroup group)\n    {\n        int size = 0;\n\n        if (!isGroupClosed(group))\n        {\n            if (showOffline)\n            {\n                size = group.countChildContacts();\n                //count the group itself\n                if(!group.equals(rootGroup))\n                    size++;\n            }\n            else\n            {\n                Iterator<MetaContact> i = group.getChildContacts();\n                while (i.hasNext())\n                {\n                    MetaContact contact = i.next();\n\n                    if (isContactOnline(contact))\n                        size++;\n                }\n\n                //count the group itself only if it contains any online contacts\n                if(!group.equals(rootGroup) && size > 0)\n                    size++;\n            }\n\n            Iterator<MetaContactGroup> subgroups = group.getSubgroups();\n            while (subgroups.hasNext())\n            {\n                MetaContactGroup subGroup = subgroups.next();\n\n                size += getContactListSize(subGroup);\n            }\n        }\n        else\n        {\n            // If offline contacts are shown we just count the closed group;\n            if(showOffline)\n            {\n                //count the closed group\n                size++;\n            }\n            else\n            {\n                // If offline contacts are not shown we'll count the group\n                // only if it contains online contacts.\n                if( containsOnlineContacts(group))\n                    size++;\n            }\n        }\n\n        return size;\n    }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Closes the given group by hiding all containing contacts.\n     *\n     * @param group The group to close.\n     */\n    public void closeGroup(MetaContactGroup group)\n    {\n        if (!isGroupClosed(group)\n            && !isGroupEmpty(group))\n        {\n            if (showOffline || containsOnlineContacts(group))\n            {\n                contentRemoved(this.indexOf(group.getMetaContact(0)),\n                    this.indexOf(group.getMetaContact(\n                        countContactsAndSubgroups(group) - 1)));\n            }\n\n            this.closedGroups.add(group);\n\n            ConfigurationManager.storeContactListGroupStatus(\n                group.getMetaUID(),\n                true);\n        }\n    }","id":33438,"modified_method":"/**\n     * Closes the given group by hiding all containing contacts.\n     *\n     * @param group The group to close.\n     */\n    public void closeGroup(MetaContactGroup group)\n    {\n        if (!isGroupClosed(group)\n            && !isGroupEmpty(group))\n        {\n            if (showOffline || containsOnlineContacts(group))\n            {\n                contentRemoved(\n                    indexOf(group.getMetaContact(0)),\n                    indexOf(\n                        group.getMetaContact(\n                            countContactsAndSubgroups(group) - 1)));\n            }\n\n            this.closedGroups.add(group);\n\n            ConfigurationManager.storeContactListGroupStatus(\n                group.getMetaUID(),\n                true);\n        }\n    }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the index of the given MetaContactGroup.\n     *\n     * @param group The given MetaContactGroup to search for.\n     * @return The index of the given MetaContactGroup.\n     */\n    private int indexOf(MetaContactGroup group)\n    {\n        int index = -1;\n\n        if (showOffline || containsOnlineContacts(group))\n        {\n            int currentIndex = 0;\n            MetaContactGroup parentGroup = this.contactList\n                .findParentMetaContactGroup(group);\n\n            if (parentGroup != null && !this.isGroupClosed(parentGroup))\n            {\n\n                currentIndex += this.indexOf(parentGroup);\n\n                currentIndex += countChildContacts(parentGroup);\n\n                currentIndex += parentGroup.indexOf(group) + 1;\n\n                for (int i = 0; i < parentGroup.indexOf(group); i++)\n                {\n                    MetaContactGroup subGroup = parentGroup\n                        .getMetaContactSubgroup(i);\n\n                    currentIndex += countContactsAndSubgroups(subGroup);\n                }\n                index = currentIndex;\n            }\n        }\n        return index;\n    }","id":33439,"modified_method":"/**\n     * Returns the index of the given MetaContactGroup.\n     *\n     * @param group The given MetaContactGroup to search for.\n     * @return The index of the given MetaContactGroup.\n     */\n    private int indexOf(MetaContactGroup group)\n    {\n        int index = -1;\n\n        if (showOffline || containsOnlineContacts(group))\n        {\n            MetaContactGroup parentGroup\n                = this.contactList.findParentMetaContactGroup(group);\n\n            if (parentGroup != null && !this.isGroupClosed(parentGroup))\n            {\n                int indexOfGroupInParentGroup = parentGroup.indexOf(group);\n\n                index = this.indexOf(parentGroup)\n                        + countChildContacts(parentGroup)\n                        + (indexOfGroupInParentGroup + 1);\n\n                for (int i = 0; i < indexOfGroupInParentGroup; i++)\n                {\n                    MetaContactGroup siblingGroup\n                        = parentGroup.getMetaContactSubgroup(i);\n\n                    index += countContactsAndSubgroups(siblingGroup);\n                }\n            }\n        }\n        return index;\n    }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the object at the given index.\n     *\n     * @param index The index.\n     * @return The object at the given index.\n     */\n    public Object getElementAt(int index)\n    {\n        Object element = this.getElementAt(this.rootGroup, -1, index);\n\n        return element;\n    }","id":33440,"modified_method":"/**\n     * Returns the object at the given index.\n     *\n     * @param index The index.\n     * @return The object at the given index.\n     */\n    public Object getElementAt(int index)\n    {\n        return this.getElementAt(this.rootGroup, -1, index);\n    }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the size of this list model.\n     *\n     * @return The size of this list model.\n     */\n    public int getSize()\n    {\n        int size = this.getContactListSize(rootGroup);\n\n        return size;\n    }","id":33441,"modified_method":"/**\n     * Returns the size of this list model.\n     *\n     * @return The size of this list model.\n     */\n    public int getSize()\n    {\n        return this.getContactListSize(rootGroup);\n    }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"private void initGroupsStatus(MetaContactGroup group)\n    {\n        boolean isClosed = ConfigurationManager\n            .getContactListGroupStatus(group.getMetaUID());\n\n        if (isClosed)\n        {\n            closedGroups.add(group);\n        }\n\n        Iterator subgroups = group.getSubgroups();\n\n        while (subgroups.hasNext())\n        {\n            MetaContactGroup subgroup = (MetaContactGroup) subgroups.next();\n            \n            this.initGroupsStatus(subgroup);\n        }\n    }","id":33442,"modified_method":"private void initGroupsStatus(MetaContactGroup group)\n    {\n        boolean isClosed = ConfigurationManager\n            .getContactListGroupStatus(group.getMetaUID());\n\n        if (isClosed)\n        {\n            closedGroups.add(group);\n        }\n\n        Iterator<MetaContactGroup> subgroups = group.getSubgroups();\n        while (subgroups.hasNext())\n        {\n            MetaContactGroup subgroup = subgroups.next();\n            \n            this.initGroupsStatus(subgroup);\n        }\n    }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Counts group child contacts depending on the showOffline option.\n     *\n     * @param group the parent group to count for\n     * @return child contacts count for the given group\n     */\n    public int countChildContacts(MetaContactGroup group)\n    {\n        if (showOffline)\n            return group.countChildContacts();\n        else\n        {\n            int count = 0;\n            Iterator i = group.getChildContacts();\n\n            while (i.hasNext())\n            {\n                MetaContact metaContact = (MetaContact) i.next();\n\n                if (isContactOnline(metaContact))\n                {\n                    count++;\n                }\n                else\n                {\n                    break;\n                }\n            }\n            return count;\n        }\n    }","id":33443,"modified_method":"/**\n     * Counts group child contacts depending on the showOffline option.\n     *\n     * @param group the parent group to count for\n     * @return child contacts count for the given group\n     */\n    public int countChildContacts(MetaContactGroup group)\n    {\n        if (showOffline)\n            return group.countChildContacts();\n        else\n        {\n            int count = 0;\n            Iterator<MetaContact> i = group.getChildContacts();\n\n            while (i.hasNext() && isContactOnline(i.next()))\n                count++;\n\n            return count;\n        }\n    }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the number of all children of the given MetaContactGroup. Counts\n     * in depth all subgroups and child contacts.\n     *\n     * @param parentGroup The parent MetaContactGroup.\n     * @return The number of all children of the given MetaContactGroup\n     */\n    public int countContactsAndSubgroups(MetaContactGroup parentGroup)\n    {\n\n        int count = 0;\n\n        if (parentGroup != null && !this.isGroupClosed(parentGroup))\n        {\n            if (showOffline)\n            {\n                count = parentGroup.countChildContacts();\n            }\n            else\n            {\n                Iterator i = parentGroup.getChildContacts();\n                while (i.hasNext())\n                {\n                    MetaContact contact = (MetaContact) i.next();\n                    if (isContactOnline(contact))\n                        count++;\n                }\n            }\n\n            Iterator subgroups = parentGroup.getSubgroups();\n\n            while (subgroups.hasNext())\n            {\n                MetaContactGroup subgroup = (MetaContactGroup) subgroups.next();\n\n                count += countContactsAndSubgroups(subgroup);\n            }\n        }\n        return count;\n    }","id":33444,"modified_method":"/**\n     * Returns the number of all children of the given MetaContactGroup. Counts\n     * in depth all subgroups and child contacts.\n     *\n     * @param parentGroup The parent MetaContactGroup.\n     * @return The number of all children of the given MetaContactGroup\n     */\n    public int countContactsAndSubgroups(MetaContactGroup parentGroup)\n    {\n        int count = 0;\n\n        if (parentGroup != null && !this.isGroupClosed(parentGroup))\n        {\n            if (showOffline)\n            {\n                count = parentGroup.countChildContacts();\n            }\n            else\n            {\n                Iterator<MetaContact> i = parentGroup.getChildContacts();\n                while (i.hasNext())\n                {\n                    MetaContact contact = (MetaContact) i.next();\n\n                    if (isContactOnline(contact))\n                        count++;\n                }\n            }\n\n            Iterator<MetaContactGroup> subgroups = parentGroup.getSubgroups();\n            while (subgroups.hasNext())\n            {\n                MetaContactGroup subgroup = subgroups.next();\n\n                count += countContactsAndSubgroups(subgroup);\n            }\n        }\n        return count;\n    }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns TRUE if the given meta contact is online, FALSE otherwise.\n     *\n     * @param contact the meta contact\n     * @return TRUE if the given meta contact is online, FALSE otherwise\n     */\n    public boolean isContactOnline(MetaContact contact)\n    {\n        // If for some reason the default contact is null we return false.\n        if(contact.getDefaultContact() == null)\n            return false;\n\n        // Lays on the fact that the default contact is the most connected.\n        if (contact.getDefaultContact().getPresenceStatus()\n                .getStatus() >= PresenceStatus.ONLINE_THRESHOLD)\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    }","id":33445,"modified_method":"/**\n     * Returns TRUE if the given meta contact is online, FALSE otherwise.\n     *\n     * @param contact the meta contact\n     * @return TRUE if the given meta contact is online, FALSE otherwise\n     */\n    public boolean isContactOnline(MetaContact contact)\n    {\n        // If for some reason the default contact is null we return false.\n        Contact defaultContact = contact.getDefaultContact();\n        if(defaultContact == null)\n            return false;\n\n        // Lays on the fact that the default contact is the most connected.\n        return\n            defaultContact.getPresenceStatus().getStatus()\n                >= PresenceStatus.ONLINE_THRESHOLD;\n    }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates a customized tooltip for this contact list.\n     *\n     * @return The customized tooltip.\n     */\n    public JToolTip createToolTip()\n    {\n        Point currentMouseLocation = MouseInfo.getPointerInfo().getLocation();\n\n        SwingUtilities.convertPointFromScreen(currentMouseLocation, this);\n\n        int index = this.locationToIndex(currentMouseLocation);\n\n        Object element = getModel().getElementAt(index);\n\n        ExtendedTooltip tip = new ExtendedTooltip();\n        if (element instanceof MetaContact)\n        {\n            MetaContact metaContact = (MetaContact) element;\n\n            byte[] avatarImage = metaContact.getAvatar();\n\n            if (avatarImage != null && avatarImage.length > 0)\n                tip.setImage(new ImageIcon(avatarImage));\n\n            tip.setTitle(metaContact.getDisplayName());\n\n            Iterator<Contact> i = metaContact.getContacts();\n\n            while (i.hasNext())\n            {\n                Contact protocolContact = (Contact) i.next();\n\n                Image protocolStatusIcon\n                    = ImageLoader.getBytesInImage(\n                            protocolContact.getPresenceStatus().getStatusIcon());\n\n                String contactAddress = protocolContact.getAddress();\n                //String statusMessage = protocolContact.getStatusMessage();\n\n                tip.addLine(new ImageIcon(protocolStatusIcon),\n                                        contactAddress);\n            }\n        }\n        else if (element instanceof MetaContactGroup)\n        {\n            MetaContactGroup metaGroup = (MetaContactGroup) element;\n\n            tip.setTitle(metaGroup.getGroupName());\n        }\n        else if (element instanceof ChatContact)\n        {\n            ChatContact chatContact = (ChatContact) element;\n\n            ImageIcon avatarImage = chatContact.getAvatar();\n\n            if (avatarImage != null)\n                tip.setImage(avatarImage);\n\n            tip.setTitle(chatContact.getName());\n        }\n\n        tip.setComponent(this);\n\n        return tip;\n    }","id":33446,"modified_method":"/**\n     * Creates a customized tooltip for this contact list.\n     *\n     * @return The customized tooltip.\n     */\n    public JToolTip createToolTip()\n    {\n        Point currentMouseLocation = MouseInfo.getPointerInfo().getLocation();\n\n        SwingUtilities.convertPointFromScreen(currentMouseLocation, this);\n\n        int index = this.locationToIndex(currentMouseLocation);\n\n        Object element = getModel().getElementAt(index);\n\n        ExtendedTooltip tip = new ExtendedTooltip();\n        if (element instanceof MetaContact)\n        {\n            MetaContact metaContact = (MetaContact) element;\n\n            byte[] avatarImage = metaContact.getAvatar();\n\n            if (avatarImage != null && avatarImage.length > 0)\n                tip.setImage(new ImageIcon(avatarImage));\n\n            tip.setTitle(metaContact.getDisplayName());\n\n            Iterator<Contact> i = metaContact.getContacts();\n\n            while (i.hasNext())\n            {\n                Contact protocolContact = i.next();\n\n                Image protocolStatusIcon\n                    = ImageLoader.getBytesInImage(\n                            protocolContact.getPresenceStatus().getStatusIcon());\n\n                String contactAddress = protocolContact.getAddress();\n                //String statusMessage = protocolContact.getStatusMessage();\n\n                tip.addLine(new ImageIcon(protocolStatusIcon),\n                                        contactAddress);\n            }\n        }\n        else if (element instanceof MetaContactGroup)\n        {\n            MetaContactGroup metaGroup = (MetaContactGroup) element;\n\n            tip.setTitle(metaGroup.getGroupName());\n        }\n        else if (element instanceof ChatContact)\n        {\n            ChatContact chatContact = (ChatContact) element;\n\n            ImageIcon avatarImage = chatContact.getAvatar();\n\n            if (avatarImage != null)\n                tip.setImage(avatarImage);\n\n            tip.setTitle(chatContact.getName());\n        }\n\n        tip.setComponent(this);\n\n        return tip;\n    }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the general status of the given MetaContact. Detects the status\n     * using the priority status table. The priority is defined on the\n     * \"availablity\" factor and here the most \"available\" status is returned.\n     *\n     * @param metaContact The metaContact fot which the status is asked.\n     * @return PresenceStatus The most \"available\" status from all subcontact\n     *         statuses.\n     */\n    public PresenceStatus getMetaContactStatus(MetaContact metaContact)\n    {\n        PresenceStatus status = null;\n        Iterator i = metaContact.getContacts();\n        while (i.hasNext()) {\n            Contact protoContact = (Contact) i.next();\n            PresenceStatus contactStatus = protoContact.getPresenceStatus();\n\n            if (status == null) {\n                status = contactStatus;\n            } else {\n                status = (contactStatus.compareTo(status) > 0) ? contactStatus\n                        : status;\n            }\n        }\n        return status;\n    }","id":33447,"modified_method":"/**\n     * Returns the general status of the given MetaContact. Detects the status\n     * using the priority status table. The priority is defined on the\n     * \"availability\" factor and here the most \"available\" status is returned.\n     *\n     * @param metaContact The metaContact for which the status is asked.\n     * @return PresenceStatus The most \"available\" status from all subcontact\n     *         statuses.\n     */\n    public PresenceStatus getMetaContactStatus(MetaContact metaContact)\n    {\n        PresenceStatus status = null;\n        Iterator<Contact> i = metaContact.getContacts();\n        while (i.hasNext()) {\n            Contact protoContact = i.next();\n            PresenceStatus contactStatus = protoContact.getPresenceStatus();\n\n            if (status == null) {\n                status = contactStatus;\n            } else {\n                status = (contactStatus.compareTo(status) > 0) ? contactStatus\n                        : status;\n            }\n        }\n        return status;\n    }","commit_id":"efa279d7820467b04f47bcbd6bc311875fbcdf0b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/** {@inheritDoc} */\n    public SortedMap<Text, HRegionLocation>\n    getTableServers(Text tableName) throws IOException {\n      \n      if (tableName == null || tableName.getLength() == 0) {\n        throw new IllegalArgumentException(\n            \"table name cannot be null or zero length\");\n      }\n\n      if (closedTables.contains(tableName)) {\n        throw new IllegalStateException(\"table closed: \" + tableName);\n      }\n      \n      SortedMap<Text, HRegionLocation> tableServers  =\n        tablesToServers.get(tableName);\n      \n      if (tableServers == null ) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"No servers for \" + tableName + \". Doing a find...\");\n        }\n        // We don't know where the table is.\n        // Load the information from meta.\n        tableServers = findServersForTable(tableName);\n      }\n      SortedMap<Text, HRegionLocation> servers =\n        new TreeMap<Text, HRegionLocation>();\n\n      servers.putAll(tableServers);\n      return servers;\n    }","id":33448,"modified_method":"/** {@inheritDoc} */\n    public SortedMap<Text, HRegionLocation>\n    getTableServers(Text tableName) throws IOException {\n      \n      if (tableName == null || tableName.getLength() == 0) {\n        throw new IllegalArgumentException(\n            \"table name cannot be null or zero length\");\n      }\n\n      closedTables.remove(tableName);\n      \n      SortedMap<Text, HRegionLocation> tableServers  =\n        tablesToServers.get(tableName);\n      \n      if (tableServers == null ) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"No servers for \" + tableName + \". Doing a find...\");\n        }\n        // We don't know where the table is.\n        // Load the information from meta.\n        tableServers = findServersForTable(tableName);\n      }\n      SortedMap<Text, HRegionLocation> servers =\n        new TreeMap<Text, HRegionLocation>();\n\n      servers.putAll(tableServers);\n      return servers;\n    }","commit_id":"4fa87a0cbbf6927df54853aa4f46c9174aa63344","url":"https://github.com/apache/hbase"},{"original_method":"/** {@inheritDoc} */\n    public SortedMap<Text, HRegionLocation>\n    reloadTableServers(final Text tableName) throws IOException {\n      \n      if (closedTables.contains(tableName)) {\n        throw new IllegalStateException(\"table closed: \" + tableName);\n      }\n\n      SortedMap<Text, HRegionLocation> servers =\n        new TreeMap<Text, HRegionLocation>();\n      \n      // Reload information for the whole table\n\n      servers.putAll(findServersForTable(tableName));\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Result of findTable: \" + servers.toString());\n      }\n      \n      return servers;\n    }","id":33449,"modified_method":"/** {@inheritDoc} */\n    public SortedMap<Text, HRegionLocation>\n    reloadTableServers(final Text tableName) throws IOException {\n      \n      closedTables.remove(tableName);\n\n      SortedMap<Text, HRegionLocation> servers =\n        new TreeMap<Text, HRegionLocation>();\n      \n      // Reload information for the whole table\n\n      servers.putAll(findServersForTable(tableName));\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Result of findTable: \" + servers.toString());\n      }\n      \n      return servers;\n    }","commit_id":"4fa87a0cbbf6927df54853aa4f46c9174aa63344","url":"https://github.com/apache/hbase"},{"original_method":"/** {@inheritDoc} */\n    public void close(Text tableName) {\n      if (tableName == null || tableName.getLength() == 0) {\n        throw new IllegalArgumentException(\n            \"table name cannot be null or zero length\");\n      }\n      \n      if (closedTables.contains(tableName)) {\n        throw new IllegalStateException(\"table closed: \" + tableName);\n      }\n\n      SortedMap<Text, HRegionLocation> tableServers =\n        tablesToServers.remove(tableName);\n\n      if (tableServers == null) {\n        throw new IllegalArgumentException(\"table was not opened: \" + tableName);\n      }\n      \n      closedTables.add(tableName);\n      \n      // Shut down connections to the HRegionServers\n\n      synchronized (this.servers) {\n        for (HRegionLocation r: tableServers.values()) {\n          this.servers.remove(r.getServerAddress().toString());\n        }\n      }\n    }","id":33450,"modified_method":"/** {@inheritDoc} */\n    public void close(Text tableName) {\n      if (tableName == null || tableName.getLength() == 0) {\n        throw new IllegalArgumentException(\n            \"table name cannot be null or zero length\");\n      }\n      \n      if (closedTables.contains(tableName)) {\n        throw new IllegalStateException(\"table already closed: \" + tableName);\n      }\n\n      SortedMap<Text, HRegionLocation> tableServers =\n        tablesToServers.remove(tableName);\n\n      if (tableServers == null) {\n        throw new IllegalArgumentException(\"table not open: \" + tableName);\n      }\n      \n      closedTables.add(tableName);\n      \n      // Shut down connections to the HRegionServers\n\n      synchronized (this.servers) {\n        for (HRegionLocation r: tableServers.values()) {\n          this.servers.remove(r.getServerAddress().toString());\n        }\n      }\n    }","commit_id":"4fa87a0cbbf6927df54853aa4f46c9174aa63344","url":"https://github.com/apache/hbase"},{"original_method":"/** \n   * Get the specified number of versions of the specified row and column with\n   * the specified timestamp.\n   *\n   * @param row         - row key\n   * @param column      - column name\n   * @param timestamp   - timestamp\n   * @param numVersions - number of versions to retrieve\n   * @return            - array of values that match the above criteria\n   * @throws IOException\n   */\n  public byte[][] get(Text row, Text column, long timestamp, int numVersions)\n  throws IOException {\n    byte [][] values = null;\n    for (int tries = 0; tries < numRetries; tries++) {\n      HRegionLocation r = getRegionLocation(row);\n      HRegionInterface server =\n        connection.getHRegionConnection(r.getServerAddress());\n      \n      try {\n        values = server.get(r.getRegionInfo().getRegionName(), row, column,\n            timestamp, numVersions);\n        \n        break;\n    \n      } catch (IOException e) {\n        if (tries == numRetries - 1) {\n          // No more tries\n          if (e instanceof RemoteException) {\n            e = RemoteExceptionHandler.decodeRemoteException((RemoteException) e);\n          }\n          throw e;\n        }\n        tableServers = connection.reloadTableServers(tableName);\n      }\n      try {\n        Thread.sleep(this.pause);\n        \n      } catch (InterruptedException x) {\n        // continue\n      }\n    }\n\n    if (values != null) {\n      ArrayList<byte[]> bytes = new ArrayList<byte[]>();\n      for (int i = 0 ; i < values.length; i++) {\n        bytes.add(values[i]);\n      }\n      return bytes.toArray(new byte[values.length][]);\n    }\n    return null;\n  }","id":33451,"modified_method":"/** \n   * Get the specified number of versions of the specified row and column with\n   * the specified timestamp.\n   *\n   * @param row         - row key\n   * @param column      - column name\n   * @param timestamp   - timestamp\n   * @param numVersions - number of versions to retrieve\n   * @return            - array of values that match the above criteria\n   * @throws IOException\n   */\n  public byte[][] get(Text row, Text column, long timestamp, int numVersions)\n  throws IOException {\n    checkClosed();\n    byte [][] values = null;\n    for (int tries = 0; tries < numRetries; tries++) {\n      HRegionLocation r = getRegionLocation(row);\n      HRegionInterface server =\n        connection.getHRegionConnection(r.getServerAddress());\n      \n      try {\n        values = server.get(r.getRegionInfo().getRegionName(), row, column,\n            timestamp, numVersions);\n        \n        break;\n    \n      } catch (IOException e) {\n        if (tries == numRetries - 1) {\n          // No more tries\n          if (e instanceof RemoteException) {\n            e = RemoteExceptionHandler.decodeRemoteException((RemoteException) e);\n          }\n          throw e;\n        }\n        tableServers = connection.reloadTableServers(tableName);\n      }\n      try {\n        Thread.sleep(this.pause);\n        \n      } catch (InterruptedException x) {\n        // continue\n      }\n    }\n\n    if (values != null) {\n      ArrayList<byte[]> bytes = new ArrayList<byte[]>();\n      for (int i = 0 ; i < values.length; i++) {\n        bytes.add(values[i]);\n      }\n      return bytes.toArray(new byte[values.length][]);\n    }\n    return null;\n  }","commit_id":"4fa87a0cbbf6927df54853aa4f46c9174aa63344","url":"https://github.com/apache/hbase"},{"original_method":"private boolean nextScanner() throws IOException {\n      if (this.scannerId != -1L) {\n        this.server.close(this.scannerId);\n        this.scannerId = -1L;\n      }\n      this.currentRegion += 1;\n      if (this.currentRegion == this.regions.length()) {\n        close();\n        return false;\n      }\n      try {\n        for (int tries = 0; tries < numRetries; tries++) {\n          HRegionLocation r = this.regions.get(currentRegion);\n          this.server =\n            connection.getHRegionConnection(r.getServerAddress());\n          \n          try {\n            if (this.filter == null) {\n              this.scannerId =\n                this.server.openScanner(r.getRegionInfo().getRegionName(),\n                    this.columns, currentRegion == 0 ? this.startRow\n                        : EMPTY_START_ROW, scanTime, null);\n              \n            } else {\n              this.scannerId =\n                this.server.openScanner(r.getRegionInfo().getRegionName(),\n                    this.columns, currentRegion == 0 ? this.startRow\n                        : EMPTY_START_ROW, scanTime, filter);\n            }\n\n            break;\n        \n          } catch (IOException e) {\n            if (tries == numRetries - 1) {\n              // No more tries\n              if (e instanceof RemoteException) {\n                e = RemoteExceptionHandler.decodeRemoteException((RemoteException) e);\n              }\n              throw e;\n            }\n            tableServers = connection.reloadTableServers(tableName);\n            loadRegions();\n          }\n        }\n\n      } catch (IOException e) {\n        close();\n        if (e instanceof RemoteException) {\n          e = RemoteExceptionHandler.decodeRemoteException((RemoteException) e);\n        }\n        throw e;\n      }\n      return true;\n    }","id":33452,"modified_method":"private boolean nextScanner() throws IOException {\n      checkClosed();\n      if (this.scannerId != -1L) {\n        this.server.close(this.scannerId);\n        this.scannerId = -1L;\n      }\n      this.currentRegion += 1;\n      if (this.currentRegion == this.regions.length()) {\n        close();\n        return false;\n      }\n      try {\n        for (int tries = 0; tries < numRetries; tries++) {\n          HRegionLocation r = this.regions.get(currentRegion);\n          this.server =\n            connection.getHRegionConnection(r.getServerAddress());\n          \n          try {\n            if (this.filter == null) {\n              this.scannerId =\n                this.server.openScanner(r.getRegionInfo().getRegionName(),\n                    this.columns, currentRegion == 0 ? this.startRow\n                        : EMPTY_START_ROW, scanTime, null);\n              \n            } else {\n              this.scannerId =\n                this.server.openScanner(r.getRegionInfo().getRegionName(),\n                    this.columns, currentRegion == 0 ? this.startRow\n                        : EMPTY_START_ROW, scanTime, filter);\n            }\n\n            break;\n        \n          } catch (IOException e) {\n            if (tries == numRetries - 1) {\n              // No more tries\n              if (e instanceof RemoteException) {\n                e = RemoteExceptionHandler.decodeRemoteException((RemoteException) e);\n              }\n              throw e;\n            }\n            tableServers = connection.reloadTableServers(tableName);\n            loadRegions();\n          }\n        }\n\n      } catch (IOException e) {\n        close();\n        if (e instanceof RemoteException) {\n          e = RemoteExceptionHandler.decodeRemoteException((RemoteException) e);\n        }\n        throw e;\n      }\n      return true;\n    }","commit_id":"4fa87a0cbbf6927df54853aa4f46c9174aa63344","url":"https://github.com/apache/hbase"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public boolean next(HStoreKey key, TreeMap<Text, byte[]> results) throws IOException {\n      if (this.closed) {\n        return false;\n      }\n      KeyedData[] values = null;\n      do {\n        values = this.server.next(this.scannerId);\n      } while (values != null && values.length == 0 && nextScanner());\n\n      if (values != null && values.length != 0) {\n        for (int i = 0; i < values.length; i++) {\n          key.setRow(values[i].getKey().getRow());\n          key.setVersion(values[i].getKey().getTimestamp());\n          key.setColumn(EMPTY_COLUMN);\n          results.put(values[i].getKey().getColumn(), values[i].getData());\n        }\n      }\n      return values == null ? false : values.length != 0;\n    }","id":33453,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public boolean next(HStoreKey key, TreeMap<Text, byte[]> results) throws IOException {\n      checkClosed();\n      if (this.closed) {\n        return false;\n      }\n      KeyedData[] values = null;\n      do {\n        values = this.server.next(this.scannerId);\n      } while (values != null && values.length == 0 && nextScanner());\n\n      if (values != null && values.length != 0) {\n        for (int i = 0; i < values.length; i++) {\n          key.setRow(values[i].getKey().getRow());\n          key.setVersion(values[i].getKey().getTimestamp());\n          key.setColumn(EMPTY_COLUMN);\n          results.put(values[i].getKey().getColumn(), values[i].getData());\n        }\n      }\n      return values == null ? false : values.length != 0;\n    }","commit_id":"4fa87a0cbbf6927df54853aa4f46c9174aa63344","url":"https://github.com/apache/hbase"},{"original_method":"/** \n   * Delete the value for a column\n   *\n   * @param lockid              - lock id returned from startUpdate\n   * @param column              - name of column whose value is to be deleted\n   * @throws IOException\n   */\n  public void delete(long lockid, Text column) throws IOException {\n    if (batch != null) {\n      batch.delete(lockid, column);\n      return;\n    }\n    \n    if (lockid != currentLockId) {\n      throw new IllegalArgumentException(\"invalid lockid\");\n    }\n    try {\n      this.currentServer.delete(this.currentRegion, this.clientid, lockid,\n        column);\n    } catch (IOException e) {\n      try {\n        this.currentServer.abort(this.currentRegion, this.clientid, lockid);\n      } catch(IOException e2) {\n        LOG.warn(e2);\n      }\n      this.currentServer = null;\n      this.currentRegion = null;\n      if (e instanceof RemoteException) {\n        e = RemoteExceptionHandler.decodeRemoteException((RemoteException) e);\n      }\n      throw e;\n    }\n  }","id":33454,"modified_method":"/** \n   * Delete the value for a column\n   *\n   * @param lockid              - lock id returned from startUpdate\n   * @param column              - name of column whose value is to be deleted\n   * @throws IOException\n   */\n  public void delete(long lockid, Text column) throws IOException {\n    checkClosed();\n    if (batch != null) {\n      batch.delete(lockid, column);\n      return;\n    }\n    \n    if (lockid != currentLockId) {\n      throw new IllegalArgumentException(\"invalid lockid\");\n    }\n    try {\n      this.currentServer.delete(this.currentRegion, this.clientid, lockid,\n        column);\n    } catch (IOException e) {\n      try {\n        this.currentServer.abort(this.currentRegion, this.clientid, lockid);\n      } catch(IOException e2) {\n        LOG.warn(e2);\n      }\n      this.currentServer = null;\n      this.currentRegion = null;\n      if (e instanceof RemoteException) {\n        e = RemoteExceptionHandler.decodeRemoteException((RemoteException) e);\n      }\n      throw e;\n    }\n  }","commit_id":"4fa87a0cbbf6927df54853aa4f46c9174aa63344","url":"https://github.com/apache/hbase"},{"original_method":"/** \n   * Change a value for the specified column.\n   * Runs {@link #abort(long)} if exception thrown.\n   *\n   * @param lockid lock id returned from startUpdate\n   * @param column column whose value is being set\n   * @param val new value for column\n   * @throws IOException\n   */\n  public void put(long lockid, Text column, byte val[]) throws IOException {\n    if (val == null) {\n      throw new IllegalArgumentException(\"value cannot be null\");\n    }\n    if (batch != null) {\n      batch.put(lockid, column, val);\n      return;\n    }\n    \n    if (lockid != currentLockId) {\n      throw new IllegalArgumentException(\"invalid lockid\");\n    }\n    try {\n      this.currentServer.put(this.currentRegion, this.clientid, lockid, column,\n        val);\n    } catch (IOException e) {\n      try {\n        this.currentServer.abort(this.currentRegion, this.clientid, lockid);\n      } catch (IOException e2) {\n        LOG.warn(e2);\n      }\n      this.currentServer = null;\n      this.currentRegion = null;\n      if (e instanceof RemoteException) {\n        e = RemoteExceptionHandler.decodeRemoteException((RemoteException) e);\n      }\n      throw e;\n    }\n  }","id":33455,"modified_method":"/** \n   * Change a value for the specified column.\n   * Runs {@link #abort(long)} if exception thrown.\n   *\n   * @param lockid lock id returned from startUpdate\n   * @param column column whose value is being set\n   * @param val new value for column\n   * @throws IOException\n   */\n  public void put(long lockid, Text column, byte val[]) throws IOException {\n    checkClosed();\n    if (val == null) {\n      throw new IllegalArgumentException(\"value cannot be null\");\n    }\n    if (batch != null) {\n      batch.put(lockid, column, val);\n      return;\n    }\n    \n    if (lockid != currentLockId) {\n      throw new IllegalArgumentException(\"invalid lockid\");\n    }\n    try {\n      this.currentServer.put(this.currentRegion, this.clientid, lockid, column,\n        val);\n    } catch (IOException e) {\n      try {\n        this.currentServer.abort(this.currentRegion, this.clientid, lockid);\n      } catch (IOException e2) {\n        LOG.warn(e2);\n      }\n      this.currentServer = null;\n      this.currentRegion = null;\n      if (e instanceof RemoteException) {\n        e = RemoteExceptionHandler.decodeRemoteException((RemoteException) e);\n      }\n      throw e;\n    }\n  }","commit_id":"4fa87a0cbbf6927df54853aa4f46c9174aa63344","url":"https://github.com/apache/hbase"},{"original_method":"/** @return the connection */\n  HConnection getConnection() {\n    return connection;\n  }","id":33456,"modified_method":"/** @return the connection */\n  public HConnection getConnection() {\n    checkClosed();\n    return connection;\n  }","commit_id":"4fa87a0cbbf6927df54853aa4f46c9174aa63344","url":"https://github.com/apache/hbase"},{"original_method":"/** \n   * Abort a row mutation\n   *\n   * @param lockid              - lock id returned from startUpdate\n   * @throws IOException\n   */\n  public synchronized void abort(long lockid) throws IOException {\n    if (batch != null) {\n      abortBatch(lockid);\n      return;\n    }\n\n    if (lockid != currentLockId) {\n      throw new IllegalArgumentException(\"invalid lockid\");\n    }\n    \n    try {\n      try {\n        this.currentServer.abort(this.currentRegion, this.clientid, lockid);\n      } catch (IOException e) {\n        this.currentServer = null;\n        this.currentRegion = null;\n        if (e instanceof RemoteException) {\n          e = RemoteExceptionHandler.decodeRemoteException((RemoteException) e);\n        }\n        throw e;\n      }\n    } finally {\n      currentLockId = -1L;\n    }\n  }","id":33457,"modified_method":"/** \n   * Abort a row mutation\n   *\n   * @param lockid              - lock id returned from startUpdate\n   * @throws IOException\n   */\n  public synchronized void abort(long lockid) throws IOException {\n    checkClosed();\n    if (batch != null) {\n      abortBatch(lockid);\n      return;\n    }\n\n    if (lockid != currentLockId) {\n      throw new IllegalArgumentException(\"invalid lockid\");\n    }\n    \n    try {\n      try {\n        this.currentServer.abort(this.currentRegion, this.clientid, lockid);\n      } catch (IOException e) {\n        this.currentServer = null;\n        this.currentRegion = null;\n        if (e instanceof RemoteException) {\n          e = RemoteExceptionHandler.decodeRemoteException((RemoteException) e);\n        }\n        throw e;\n      }\n    } finally {\n      currentLockId = -1L;\n    }\n  }","commit_id":"4fa87a0cbbf6927df54853aa4f46c9174aa63344","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Renew lease on update\n   * \n   * @param lockid              - lock id returned from startUpdate\n   * @throws IOException\n   */\n  public synchronized void renewLease(long lockid) throws IOException {\n    if (batch != null) {\n      return;\n    }\n\n    if (lockid != currentLockId) {\n      throw new IllegalArgumentException(\"invalid lockid\");\n    }\n    try {\n      this.currentServer.renewLease(lockid, this.clientid);\n    } catch (IOException e) {\n      try {\n        this.currentServer.abort(this.currentRegion, this.clientid, lockid);\n      } catch (IOException e2) {\n        LOG.warn(e2);\n      }\n      this.currentServer = null;\n      this.currentRegion = null;\n      if (e instanceof RemoteException) {\n        e = RemoteExceptionHandler.decodeRemoteException((RemoteException) e);\n      }\n      throw e;\n    }\n  }","id":33458,"modified_method":"/**\n   * Renew lease on update\n   * \n   * @param lockid              - lock id returned from startUpdate\n   * @throws IOException\n   */\n  public synchronized void renewLease(long lockid) throws IOException {\n    checkClosed();\n    if (batch != null) {\n      return;\n    }\n\n    if (lockid != currentLockId) {\n      throw new IllegalArgumentException(\"invalid lockid\");\n    }\n    try {\n      this.currentServer.renewLease(lockid, this.clientid);\n    } catch (IOException e) {\n      try {\n        this.currentServer.abort(this.currentRegion, this.clientid, lockid);\n      } catch (IOException e2) {\n        LOG.warn(e2);\n      }\n      this.currentServer = null;\n      this.currentRegion = null;\n      if (e instanceof RemoteException) {\n        e = RemoteExceptionHandler.decodeRemoteException((RemoteException) e);\n      }\n      throw e;\n    }\n  }","commit_id":"4fa87a0cbbf6927df54853aa4f46c9174aa63344","url":"https://github.com/apache/hbase"},{"original_method":"/** \n   * Get all the data for the specified row\n   * \n   * @param row         - row key\n   * @return            - map of colums to values\n   * @throws IOException\n   */\n  public SortedMap<Text, byte[]> getRow(Text row) throws IOException {\n    KeyedData[] value = null;\n    for (int tries = 0; tries < numRetries; tries++) {\n      HRegionLocation r = getRegionLocation(row);\n      HRegionInterface server =\n        connection.getHRegionConnection(r.getServerAddress());\n      \n      try {\n        value = server.getRow(r.getRegionInfo().getRegionName(), row);\n        break;\n        \n      } catch (IOException e) {\n        if (tries == numRetries - 1) {\n          // No more tries\n          if (e instanceof RemoteException) {\n            e = RemoteExceptionHandler.decodeRemoteException((RemoteException) e);\n          }\n          throw e;\n        }\n        tableServers = connection.reloadTableServers(tableName);\n      }\n      try {\n        Thread.sleep(this.pause);\n        \n      } catch (InterruptedException x) {\n        // continue\n      }\n    }\n    TreeMap<Text, byte[]> results = new TreeMap<Text, byte[]>();\n    if (value != null && value.length != 0) {\n      for (int i = 0; i < value.length; i++) {\n        results.put(value[i].getKey().getColumn(), value[i].getData());\n      }\n    }\n    return results;\n  }","id":33459,"modified_method":"/** \n   * Get all the data for the specified row\n   * \n   * @param row         - row key\n   * @return            - map of colums to values\n   * @throws IOException\n   */\n  public SortedMap<Text, byte[]> getRow(Text row) throws IOException {\n    checkClosed();\n    KeyedData[] value = null;\n    for (int tries = 0; tries < numRetries; tries++) {\n      HRegionLocation r = getRegionLocation(row);\n      HRegionInterface server =\n        connection.getHRegionConnection(r.getServerAddress());\n      \n      try {\n        value = server.getRow(r.getRegionInfo().getRegionName(), row);\n        break;\n        \n      } catch (IOException e) {\n        if (tries == numRetries - 1) {\n          // No more tries\n          if (e instanceof RemoteException) {\n            e = RemoteExceptionHandler.decodeRemoteException((RemoteException) e);\n          }\n          throw e;\n        }\n        tableServers = connection.reloadTableServers(tableName);\n      }\n      try {\n        Thread.sleep(this.pause);\n        \n      } catch (InterruptedException x) {\n        // continue\n      }\n    }\n    TreeMap<Text, byte[]> results = new TreeMap<Text, byte[]>();\n    if (value != null && value.length != 0) {\n      for (int i = 0; i < value.length; i++) {\n        results.put(value[i].getKey().getColumn(), value[i].getData());\n      }\n    }\n    return results;\n  }","commit_id":"4fa87a0cbbf6927df54853aa4f46c9174aa63344","url":"https://github.com/apache/hbase"},{"original_method":"/** \n   * Get a scanner on the current table starting at the specified row.\n   * Return the specified columns.\n   *\n   * @param columns array of columns to return\n   * @param startRow starting row in table to scan\n   * @param timestamp only return results whose timestamp <= this value\n   * @param filter a row filter using row-key regexp and/or column data filter.\n   * @return scanner\n   * @throws IOException\n   */\n  public HScannerInterface obtainScanner(Text[] columns,\n      Text startRow, long timestamp, RowFilterInterface filter)\n  throws IOException {\n    \n    return new ClientScanner(columns, startRow, timestamp, filter);\n  }","id":33460,"modified_method":"/** \n   * Get a scanner on the current table starting at the specified row.\n   * Return the specified columns.\n   *\n   * @param columns array of columns to return\n   * @param startRow starting row in table to scan\n   * @param timestamp only return results whose timestamp <= this value\n   * @param filter a row filter using row-key regexp and/or column data filter.\n   * @return scanner\n   * @throws IOException\n   */\n  public HScannerInterface obtainScanner(Text[] columns,\n      Text startRow, long timestamp, RowFilterInterface filter)\n  throws IOException {\n    \n    checkClosed();\n    return new ClientScanner(columns, startRow, timestamp, filter);\n  }","commit_id":"4fa87a0cbbf6927df54853aa4f46c9174aa63344","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Find region location hosting passed row using cached info\n   * @param row Row to find.\n   * @return Location of row.\n   */\n  HRegionLocation getRegionLocation(Text row) {\n    if (this.tableServers == null) {\n      throw new IllegalStateException(\"Must open table first\");\n    }\n    \n    // Only one server will have the row we are looking for\n    Text serverKey = (this.tableServers.containsKey(row)) ?\n        row : this.tableServers.headMap(row).lastKey();\n    return this.tableServers.get(serverKey);\n  }","id":33461,"modified_method":"/**\n   * Find region location hosting passed row using cached info\n   * @param row Row to find.\n   * @return Location of row.\n   */\n  HRegionLocation getRegionLocation(Text row) {\n    checkClosed();\n    if (this.tableServers == null) {\n      throw new IllegalStateException(\"Must open table first\");\n    }\n    \n    // Only one server will have the row we are looking for\n    Text serverKey = (this.tableServers.containsKey(row)) ?\n        row : this.tableServers.headMap(row).lastKey();\n    return this.tableServers.get(serverKey);\n  }","commit_id":"4fa87a0cbbf6927df54853aa4f46c9174aa63344","url":"https://github.com/apache/hbase"},{"original_method":"/** \n   * Start a batch of row insertions/updates.\n   * \n   * No changes are committed until the call to commitBatchUpdate returns.\n   * A call to abortBatchUpdate will abandon the entire batch.\n   *\n   * @param row name of row to be updated\n   * @return lockid to be used in subsequent put, delete and commit calls\n   */\n  public synchronized long startBatchUpdate(final Text row) {\n    if (batch != null || currentLockId != -1L) {\n      throw new IllegalStateException(\"update in progress\");\n    }\n    batch = new BatchUpdate();\n    return batch.startUpdate(row);\n  }","id":33462,"modified_method":"/** \n   * Start a batch of row insertions/updates.\n   * \n   * No changes are committed until the call to commitBatchUpdate returns.\n   * A call to abortBatchUpdate will abandon the entire batch.\n   *\n   * @param row name of row to be updated\n   * @return lockid to be used in subsequent put, delete and commit calls\n   */\n  public synchronized long startBatchUpdate(final Text row) {\n    checkClosed();\n    checkUpdateInProgress();\n    batch = new BatchUpdate();\n    return batch.startUpdate(row);\n  }","commit_id":"4fa87a0cbbf6927df54853aa4f46c9174aa63344","url":"https://github.com/apache/hbase"},{"original_method":"/** \n   * Start an atomic row insertion/update.  No changes are committed until the \n   * call to commit() returns. A call to abort() will abandon any updates in progress.\n   *\n   * Callers to this method are given a lease for each unique lockid; before the\n   * lease expires, either abort() or commit() must be called. If it is not \n   * called, the system will automatically call abort() on the client's behalf.\n   *\n   * The client can gain extra time with a call to renewLease().\n   * Start an atomic row insertion or update\n   * \n   * @param row Name of row to start update against.\n   * @return Row lockid.\n   * @throws IOException\n   */\n  public synchronized long startUpdate(final Text row) throws IOException {\n    if (currentLockId != -1L || batch != null) {\n      throw new IllegalStateException(\"update in progress\");\n    }\n    for (int tries = 0; tries < numRetries; tries++) {\n      IOException e = null;\n      HRegionLocation info = getRegionLocation(row);\n      try {\n        currentServer =\n          connection.getHRegionConnection(info.getServerAddress());\n\n        currentRegion = info.getRegionInfo().getRegionName();\n        clientid = rand.nextLong();\n        currentLockId = currentServer.startUpdate(currentRegion, clientid, row);\n\n        break;\n\n      } catch (IOException ex) {\n        e = ex;\n      }\n      if (tries < numRetries - 1) {\n        try {\n          Thread.sleep(this.pause);\n\n        } catch (InterruptedException ex) {\n        }\n        try {\n          tableServers = connection.reloadTableServers(tableName);\n\n        } catch (IOException ex) {\n          e = ex;\n        }\n      } else {\n        if (e instanceof RemoteException) {\n          e = RemoteExceptionHandler.decodeRemoteException((RemoteException) e);\n        }\n        throw e;\n      }\n    }\n    return currentLockId;\n  }","id":33463,"modified_method":"/** \n   * Start an atomic row insertion/update.  No changes are committed until the \n   * call to commit() returns. A call to abort() will abandon any updates in progress.\n   *\n   * Callers to this method are given a lease for each unique lockid; before the\n   * lease expires, either abort() or commit() must be called. If it is not \n   * called, the system will automatically call abort() on the client's behalf.\n   *\n   * The client can gain extra time with a call to renewLease().\n   * Start an atomic row insertion or update\n   * \n   * @param row Name of row to start update against.\n   * @return Row lockid.\n   * @throws IOException\n   */\n  public synchronized long startUpdate(final Text row) throws IOException {\n    checkClosed();\n    checkUpdateInProgress();\n    for (int tries = 0; tries < numRetries; tries++) {\n      IOException e = null;\n      HRegionLocation info = getRegionLocation(row);\n      try {\n        currentServer =\n          connection.getHRegionConnection(info.getServerAddress());\n\n        currentRegion = info.getRegionInfo().getRegionName();\n        clientid = rand.nextLong();\n        currentLockId = currentServer.startUpdate(currentRegion, clientid, row);\n\n        break;\n\n      } catch (IOException ex) {\n        e = ex;\n      }\n      if (tries < numRetries - 1) {\n        try {\n          Thread.sleep(this.pause);\n\n        } catch (InterruptedException ex) {\n        }\n        try {\n          tableServers = connection.reloadTableServers(tableName);\n\n        } catch (IOException ex) {\n          e = ex;\n        }\n      } else {\n        if (e instanceof RemoteException) {\n          e = RemoteExceptionHandler.decodeRemoteException((RemoteException) e);\n        }\n        throw e;\n      }\n    }\n    return currentLockId;\n  }","commit_id":"4fa87a0cbbf6927df54853aa4f46c9174aa63344","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Gets the starting row key for every region in the currently open table\n   * @return Array of region starting row keys\n   */\n  public Text[] getStartKeys() {\n    if (closed) {\n      throw new IllegalStateException(\"table is closed\");\n    }\n    Text[] keys = new Text[tableServers.size()];\n    int i = 0;\n    for(Text key: tableServers.keySet()){\n      keys[i++] = key;\n    }\n    return keys;\n  }","id":33464,"modified_method":"/**\n   * Gets the starting row key for every region in the currently open table\n   * @return Array of region starting row keys\n   */\n  public Text[] getStartKeys() {\n    checkClosed();\n    Text[] keys = new Text[tableServers.size()];\n    int i = 0;\n    for(Text key: tableServers.keySet()){\n      keys[i++] = key;\n    }\n    return keys;\n  }","commit_id":"4fa87a0cbbf6927df54853aa4f46c9174aa63344","url":"https://github.com/apache/hbase"},{"original_method":"/** \n   * Get the specified number of versions of the specified row and column\n   * \n   * @param row         - row key\n   * @param column      - column name\n   * @param numVersions - number of versions to retrieve\n   * @return            - array byte values\n   * @throws IOException\n   */\n  public byte[][] get(Text row, Text column, int numVersions) throws IOException {\n    byte [][] values = null;\n    for (int tries = 0; tries < numRetries; tries++) {\n      HRegionLocation r = getRegionLocation(row);\n      HRegionInterface server = \n        connection.getHRegionConnection(r.getServerAddress());\n      \n      try {\n        values = server.get(r.getRegionInfo().getRegionName(), row, column,\n            numVersions);\n        \n        break;\n        \n      } catch (IOException e) {\n        if (tries == numRetries - 1) {\n          // No more tries\n          if (e instanceof RemoteException) {\n            e = RemoteExceptionHandler.decodeRemoteException((RemoteException) e);\n          }\n          throw e;\n        }\n        tableServers = connection.reloadTableServers(tableName);\n      }\n      try {\n        Thread.sleep(this.pause);\n        \n      } catch (InterruptedException x) {\n        // continue\n      }\n    }\n\n    if (values != null) {\n      ArrayList<byte[]> bytes = new ArrayList<byte[]>();\n      for (int i = 0 ; i < values.length; i++) {\n        bytes.add(values[i]);\n      }\n      return bytes.toArray(new byte[values.length][]);\n    }\n    return null;\n  }","id":33465,"modified_method":"/** \n   * Get the specified number of versions of the specified row and column\n   * \n   * @param row         - row key\n   * @param column      - column name\n   * @param numVersions - number of versions to retrieve\n   * @return            - array byte values\n   * @throws IOException\n   */\n  public byte[][] get(Text row, Text column, int numVersions) throws IOException {\n    checkClosed();\n    byte [][] values = null;\n    for (int tries = 0; tries < numRetries; tries++) {\n      HRegionLocation r = getRegionLocation(row);\n      HRegionInterface server = \n        connection.getHRegionConnection(r.getServerAddress());\n      \n      try {\n        values = server.get(r.getRegionInfo().getRegionName(), row, column,\n            numVersions);\n        \n        break;\n        \n      } catch (IOException e) {\n        if (tries == numRetries - 1) {\n          // No more tries\n          if (e instanceof RemoteException) {\n            e = RemoteExceptionHandler.decodeRemoteException((RemoteException) e);\n          }\n          throw e;\n        }\n        tableServers = connection.reloadTableServers(tableName);\n      }\n      try {\n        Thread.sleep(this.pause);\n        \n      } catch (InterruptedException x) {\n        // continue\n      }\n    }\n\n    if (values != null) {\n      ArrayList<byte[]> bytes = new ArrayList<byte[]>();\n      for (int i = 0 ; i < values.length; i++) {\n        bytes.add(values[i]);\n      }\n      return bytes.toArray(new byte[values.length][]);\n    }\n    return null;\n  }","commit_id":"4fa87a0cbbf6927df54853aa4f46c9174aa63344","url":"https://github.com/apache/hbase"},{"original_method":"/** \n   * Finalize a batch mutation\n   *\n   * @param lockid lock id returned by startBatchUpdate\n   * @param timestamp time to associate with all the changes\n   * @throws IOException\n   */\n  public synchronized void commitBatch(final long lockid, final long timestamp)\n  throws IOException {\n\n    if (batch == null) {\n      throw new IllegalStateException(\"no batch update in progress\");\n    }\n    if (batch.getLockid() != lockid) {\n      throw new IllegalArgumentException(\"invalid lock id \" + lockid);\n    }\n    \n    try {\n      for (int tries = 0; tries < numRetries; tries++) {\n        HRegionLocation r = getRegionLocation(batch.getRow());\n        HRegionInterface server =\n          connection.getHRegionConnection(r.getServerAddress());\n\n        try {\n          server.batchUpdate(r.getRegionInfo().getRegionName(), timestamp, batch);\n          break;\n\n        } catch (IOException e) {\n          if (tries < numRetries -1) {\n            tableServers = connection.reloadTableServers(tableName);\n\n          } else {\n            if (e instanceof RemoteException) {\n              e = RemoteExceptionHandler.decodeRemoteException((RemoteException) e);\n            }\n            throw e;\n          }\n        }\n        try {\n          Thread.sleep(pause);\n\n        } catch (InterruptedException e) {\n        }\n      }\n    } finally {\n      batch = null;\n    }\n  }","id":33466,"modified_method":"/** \n   * Finalize a batch mutation\n   *\n   * @param lockid lock id returned by startBatchUpdate\n   * @param timestamp time to associate with all the changes\n   * @throws IOException\n   */\n  public synchronized void commitBatch(final long lockid, final long timestamp)\n  throws IOException {\n\n    checkClosed();\n    if (batch == null) {\n      throw new IllegalStateException(\"no batch update in progress\");\n    }\n    if (batch.getLockid() != lockid) {\n      throw new IllegalArgumentException(\"invalid lock id \" + lockid);\n    }\n    \n    try {\n      for (int tries = 0; tries < numRetries; tries++) {\n        HRegionLocation r = getRegionLocation(batch.getRow());\n        HRegionInterface server =\n          connection.getHRegionConnection(r.getServerAddress());\n\n        try {\n          server.batchUpdate(r.getRegionInfo().getRegionName(), timestamp, batch);\n          break;\n\n        } catch (IOException e) {\n          if (tries < numRetries -1) {\n            tableServers = connection.reloadTableServers(tableName);\n\n          } else {\n            if (e instanceof RemoteException) {\n              e = RemoteExceptionHandler.decodeRemoteException((RemoteException) e);\n            }\n            throw e;\n          }\n        }\n        try {\n          Thread.sleep(pause);\n\n        } catch (InterruptedException e) {\n        }\n      }\n    } finally {\n      batch = null;\n    }\n  }","commit_id":"4fa87a0cbbf6927df54853aa4f46c9174aa63344","url":"https://github.com/apache/hbase"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public void close() throws IOException {\n      if (this.scannerId != -1L) {\n        this.server.close(this.scannerId);\n        this.scannerId = -1L;\n      }\n      this.server = null;\n      this.closed = true;\n    }","id":33467,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public void close() throws IOException {\n      checkClosed();\n      if (this.scannerId != -1L) {\n        this.server.close(this.scannerId);\n        this.scannerId = -1L;\n      }\n      this.server = null;\n      this.closed = true;\n    }","commit_id":"4fa87a0cbbf6927df54853aa4f46c9174aa63344","url":"https://github.com/apache/hbase"},{"original_method":"/** \n   * Get a single value for the specified row and column\n   *\n   * @param row row key\n   * @param column column name\n   * @return value for specified row/column\n   * @throws IOException\n   */\n  public byte[] get(Text row, Text column) throws IOException {\n    byte [] value = null;\n    for(int tries = 0; tries < numRetries; tries++) {\n      HRegionLocation r = getRegionLocation(row);\n      HRegionInterface server =\n        connection.getHRegionConnection(r.getServerAddress());\n      \n      try {\n        value = server.get(r.getRegionInfo().getRegionName(), row, column);\n        break;\n        \n      } catch (IOException e) {\n        if (tries == numRetries - 1) {\n          if (e instanceof RemoteException) {\n            e = RemoteExceptionHandler.decodeRemoteException((RemoteException) e);\n          }\n          throw e;\n        }\n        tableServers = connection.reloadTableServers(tableName);\n      }\n      try {\n        Thread.sleep(this.pause);\n        \n      } catch (InterruptedException x) {\n        // continue\n      }\n    }\n    return value;\n  }","id":33468,"modified_method":"/** \n   * Get a single value for the specified row and column\n   *\n   * @param row row key\n   * @param column column name\n   * @return value for specified row/column\n   * @throws IOException\n   */\n  public byte[] get(Text row, Text column) throws IOException {\n    checkClosed();\n    byte [] value = null;\n    for(int tries = 0; tries < numRetries; tries++) {\n      HRegionLocation r = getRegionLocation(row);\n      HRegionInterface server =\n        connection.getHRegionConnection(r.getServerAddress());\n      \n      try {\n        value = server.get(r.getRegionInfo().getRegionName(), row, column);\n        break;\n        \n      } catch (IOException e) {\n        if (tries == numRetries - 1) {\n          if (e instanceof RemoteException) {\n            e = RemoteExceptionHandler.decodeRemoteException((RemoteException) e);\n          }\n          throw e;\n        }\n        tableServers = connection.reloadTableServers(tableName);\n      }\n      try {\n        Thread.sleep(this.pause);\n        \n      } catch (InterruptedException x) {\n        // continue\n      }\n    }\n    return value;\n  }","commit_id":"4fa87a0cbbf6927df54853aa4f46c9174aa63344","url":"https://github.com/apache/hbase"},{"original_method":"/** \n   * Finalize a row mutation\n   *\n   * @param lockid              - lock id returned from startUpdate\n   * @param timestamp           - time to associate with the change\n   * @throws IOException\n   */\n  public synchronized void commit(long lockid, long timestamp) throws IOException {\n    if (batch != null) {\n      commitBatch(lockid, timestamp);\n      return;\n    }\n\n    if (lockid != currentLockId) {\n      throw new IllegalArgumentException(\"invalid lockid\");\n    }\n\n    try {\n      try {\n        this.currentServer.commit(this.currentRegion, this.clientid, lockid,\n            timestamp);\n\n      } catch (IOException e) {\n        this.currentServer = null;\n        this.currentRegion = null;\n        if(e instanceof RemoteException) {\n          e = RemoteExceptionHandler.decodeRemoteException((RemoteException) e);\n        }\n        throw e;\n      }\n    } finally {\n      currentLockId = -1L;\n    }\n  }","id":33469,"modified_method":"/** \n   * Finalize a row mutation\n   *\n   * @param lockid              - lock id returned from startUpdate\n   * @param timestamp           - time to associate with the change\n   * @throws IOException\n   */\n  public synchronized void commit(long lockid, long timestamp) throws IOException {\n    checkClosed();\n    if (batch != null) {\n      commitBatch(lockid, timestamp);\n      return;\n    }\n\n    if (lockid != currentLockId) {\n      throw new IllegalArgumentException(\"invalid lockid\");\n    }\n\n    try {\n      try {\n        this.currentServer.commit(this.currentRegion, this.clientid, lockid,\n            timestamp);\n\n      } catch (IOException e) {\n        this.currentServer = null;\n        this.currentRegion = null;\n        if(e instanceof RemoteException) {\n          e = RemoteExceptionHandler.decodeRemoteException((RemoteException) e);\n        }\n        throw e;\n      }\n    } finally {\n      currentLockId = -1L;\n    }\n  }","commit_id":"4fa87a0cbbf6927df54853aa4f46c9174aa63344","url":"https://github.com/apache/hbase"},{"original_method":"private void loadRegions() {\n      Text firstServer = null;\n      if (this.startRow == null || this.startRow.getLength() == 0) {\n        firstServer = tableServers.firstKey();\n\n      } else if(tableServers.containsKey(startRow)) {\n        firstServer = startRow;\n\n      } else {\n        firstServer = tableServers.headMap(startRow).lastKey();\n      }\n      Collection<HRegionLocation> info =\n        tableServers.tailMap(firstServer).values();\n      \n      this.regions = new AtomicReferenceArray<HRegionLocation>(\n          info.toArray(new HRegionLocation[info.size()]));\n    }","id":33470,"modified_method":"private void loadRegions() {\n      checkClosed();\n      Text firstServer = null;\n      if (this.startRow == null || this.startRow.getLength() == 0) {\n        firstServer = tableServers.firstKey();\n\n      } else if(tableServers.containsKey(startRow)) {\n        firstServer = startRow;\n\n      } else {\n        firstServer = tableServers.headMap(startRow).lastKey();\n      }\n      Collection<HRegionLocation> info =\n        tableServers.tailMap(firstServer).values();\n      \n      this.regions = new AtomicReferenceArray<HRegionLocation>(\n          info.toArray(new HRegionLocation[info.size()]));\n    }","commit_id":"4fa87a0cbbf6927df54853aa4f46c9174aa63344","url":"https://github.com/apache/hbase"},{"original_method":"/** \n   * Abort a batch mutation\n   * @param lockid lock id returned by startBatchUpdate\n   */\n  public synchronized void abortBatch(final long lockid) {\n    if (batch == null) {\n      throw new IllegalStateException(\"no batch update in progress\");\n    }\n    if (batch.getLockid() != lockid) {\n      throw new IllegalArgumentException(\"invalid lock id \" + lockid);\n    }\n    batch = null;\n  }","id":33471,"modified_method":"/** \n   * Abort a batch mutation\n   * @param lockid lock id returned by startBatchUpdate\n   */\n  public synchronized void abortBatch(final long lockid) {\n    checkClosed();\n    if (batch == null) {\n      throw new IllegalStateException(\"no batch update in progress\");\n    }\n    if (batch.getLockid() != lockid) {\n      throw new IllegalArgumentException(\"invalid lock id \" + lockid);\n    }\n    batch = null;\n  }","commit_id":"4fa87a0cbbf6927df54853aa4f46c9174aa63344","url":"https://github.com/apache/hbase"},{"original_method":"/**\n         * Constructs the CGI environment to be supplied to the invoked CGI\n         * script; relies heavily on Servlet API methods and findCGI\n         *\n         * @param    req request associated with the CGI\n         *           Invocation\n         *\n         * @return   true if environment was set OK, false if there\n         *           was a problem and no environment was set\n         */\n        protected boolean setCGIEnvironment(HttpServletRequest req) throws IOException {\n\n            /*\n             * This method is slightly ugly; c'est la vie.\n             * \"You cannot stop [ugliness], you can only hope to contain [it]\"\n             * (apologies to Marv Albert regarding MJ)\n             */\n\n            Hashtable<String,String> envp = new Hashtable<>();\n\n            // Add the shell environment variables (if any)\n            envp.putAll(shellEnv);\n\n            // Add the CGI environment variables\n            String sPathInfoOrig = null;\n            String sPathInfoCGI = null;\n            String sPathTranslatedCGI = null;\n            String sCGIFullPath = null;\n            String sCGIScriptName = null;\n            String sCGIFullName = null;\n            String sCGIName = null;\n            String[] sCGINames;\n\n\n            sPathInfoOrig = this.pathInfo;\n            sPathInfoOrig = sPathInfoOrig == null ? \"\" : sPathInfoOrig;\n\n            if (webAppRootDir == null ) {\n                // The app has not been deployed in exploded form\n                webAppRootDir = tmpDir.toString();\n                expandCGIScript();\n            }\n\n            sCGINames = findCGI(sPathInfoOrig,\n                                webAppRootDir,\n                                contextPath,\n                                servletPath,\n                                cgiPathPrefix);\n\n            sCGIFullPath = sCGINames[0];\n            sCGIScriptName = sCGINames[1];\n            sCGIFullName = sCGINames[2];\n            sCGIName = sCGINames[3];\n\n            if (sCGIFullPath == null\n                || sCGIScriptName == null\n                || sCGIFullName == null\n                || sCGIName == null) {\n                return false;\n            }\n\n            envp.put(\"SERVER_SOFTWARE\", \"TOMCAT\");\n\n            envp.put(\"SERVER_NAME\", nullsToBlanks(req.getServerName()));\n\n            envp.put(\"GATEWAY_INTERFACE\", \"CGI/1.1\");\n\n            envp.put(\"SERVER_PROTOCOL\", nullsToBlanks(req.getProtocol()));\n\n            int port = req.getServerPort();\n            Integer iPort =\n                (port == 0 ? Integer.valueOf(-1) : Integer.valueOf(port));\n            envp.put(\"SERVER_PORT\", iPort.toString());\n\n            envp.put(\"REQUEST_METHOD\", nullsToBlanks(req.getMethod()));\n\n            envp.put(\"REQUEST_URI\", nullsToBlanks(req.getRequestURI()));\n\n\n            /*-\n             * PATH_INFO should be determined by using sCGIFullName:\n             * 1) Let sCGIFullName not end in a \"/\" (see method findCGI)\n             * 2) Let sCGIFullName equal the pathInfo fragment which\n             *    corresponds to the actual cgi script.\n             * 3) Thus, PATH_INFO = request.getPathInfo().substring(\n             *                      sCGIFullName.length())\n             *\n             * (see method findCGI, where the real work is done)\n             *\n             */\n            if (pathInfo == null\n                || (pathInfo.substring(sCGIFullName.length()).length() <= 0)) {\n                sPathInfoCGI = \"\";\n            } else {\n                sPathInfoCGI = pathInfo.substring(sCGIFullName.length());\n            }\n            envp.put(\"PATH_INFO\", sPathInfoCGI);\n\n\n            /*-\n             * PATH_TRANSLATED must be determined after PATH_INFO (and the\n             * implied real cgi-script) has been taken into account.\n             *\n             * The following example demonstrates:\n             *\n             * servlet info   = /servlet/cgigw/dir1/dir2/cgi1/trans1/trans2\n             * cgifullpath    = /servlet/cgigw/dir1/dir2/cgi1\n             * path_info      = /trans1/trans2\n             * webAppRootDir  = servletContext.getRealPath(\"/\")\n             *\n             * path_translated = servletContext.getRealPath(\"/trans1/trans2\")\n             *\n             * That is, PATH_TRANSLATED = webAppRootDir + sPathInfoCGI\n             * (unless sPathInfoCGI is null or blank, then the CGI\n             * specification dictates that the PATH_TRANSLATED metavariable\n             * SHOULD NOT be defined.\n             *\n             */\n            if (sPathInfoCGI != null && !(\"\".equals(sPathInfoCGI))) {\n                sPathTranslatedCGI = context.getRealPath(sPathInfoCGI);\n            }\n            if (sPathTranslatedCGI == null || \"\".equals(sPathTranslatedCGI)) {\n                //NOOP\n            } else {\n                envp.put(\"PATH_TRANSLATED\", nullsToBlanks(sPathTranslatedCGI));\n            }\n\n\n            envp.put(\"SCRIPT_NAME\", nullsToBlanks(sCGIScriptName));\n\n            envp.put(\"QUERY_STRING\", nullsToBlanks(req.getQueryString()));\n\n            envp.put(\"REMOTE_HOST\", nullsToBlanks(req.getRemoteHost()));\n\n            envp.put(\"REMOTE_ADDR\", nullsToBlanks(req.getRemoteAddr()));\n\n            envp.put(\"AUTH_TYPE\", nullsToBlanks(req.getAuthType()));\n\n            envp.put(\"REMOTE_USER\", nullsToBlanks(req.getRemoteUser()));\n\n            envp.put(\"REMOTE_IDENT\", \"\"); //not necessary for full compliance\n\n            envp.put(\"CONTENT_TYPE\", nullsToBlanks(req.getContentType()));\n\n\n            /* Note CGI spec says CONTENT_LENGTH must be NULL (\"\") or undefined\n             * if there is no content, so we cannot put 0 or -1 in as per the\n             * Servlet API spec.\n             */\n            int contentLength = req.getContentLength();\n            String sContentLength = (contentLength <= 0 ? \"\" :\n                (Integer.valueOf(contentLength)).toString());\n            envp.put(\"CONTENT_LENGTH\", sContentLength);\n\n\n            Enumeration<String> headers = req.getHeaderNames();\n            String header = null;\n            while (headers.hasMoreElements()) {\n                header = null;\n                header = headers.nextElement().toUpperCase(Locale.ENGLISH);\n                //REMIND: rewrite multiple headers as if received as single\n                //REMIND: change character set\n                //REMIND: I forgot what the previous REMIND means\n                if (\"AUTHORIZATION\".equalsIgnoreCase(header) ||\n                    \"PROXY_AUTHORIZATION\".equalsIgnoreCase(header)) {\n                    //NOOP per CGI specification section 11.2\n                } else {\n                    envp.put(\"HTTP_\" + header.replace('-', '_'),\n                             req.getHeader(header));\n                }\n            }\n\n            File fCGIFullPath = new File(sCGIFullPath);\n            command = fCGIFullPath.getCanonicalPath();\n\n            envp.put(\"X_TOMCAT_SCRIPT_PATH\", command);  //for kicks\n\n            envp.put(\"SCRIPT_FILENAME\", command);  //for PHP\n\n            this.env = envp;\n\n            return true;\n\n        }","id":33472,"modified_method":"/**\n         * Constructs the CGI environment to be supplied to the invoked CGI\n         * script; relies heavily on Servlet API methods and findCGI\n         *\n         * @param    req request associated with the CGI\n         *           Invocation\n         *\n         * @return   true if environment was set OK, false if there\n         *           was a problem and no environment was set\n         */\n        protected boolean setCGIEnvironment(HttpServletRequest req) throws IOException {\n\n            /*\n             * This method is slightly ugly; c'est la vie.\n             * \"You cannot stop [ugliness], you can only hope to contain [it]\"\n             * (apologies to Marv Albert regarding MJ)\n             */\n\n            Hashtable<String,String> envp = new Hashtable<>();\n\n            // Add the shell environment variables (if any)\n            envp.putAll(shellEnv);\n\n            // Add the CGI environment variables\n            String sPathInfoOrig = null;\n            String sPathInfoCGI = null;\n            String sPathTranslatedCGI = null;\n            String sCGIFullPath = null;\n            String sCGIScriptName = null;\n            String sCGIFullName = null;\n            String sCGIName = null;\n            String[] sCGINames;\n\n\n            sPathInfoOrig = this.pathInfo;\n            sPathInfoOrig = sPathInfoOrig == null ? \"\" : sPathInfoOrig;\n\n            if (webAppRootDir == null ) {\n                // The app has not been deployed in exploded form\n                webAppRootDir = tmpDir.toString();\n                expandCGIScript();\n            }\n\n            sCGINames = findCGI(sPathInfoOrig,\n                                webAppRootDir,\n                                contextPath,\n                                servletPath,\n                                cgiPathPrefix);\n\n            sCGIFullPath = sCGINames[0];\n            sCGIScriptName = sCGINames[1];\n            sCGIFullName = sCGINames[2];\n            sCGIName = sCGINames[3];\n\n            if (sCGIFullPath == null\n                || sCGIScriptName == null\n                || sCGIFullName == null\n                || sCGIName == null) {\n                return false;\n            }\n\n            envp.put(\"SERVER_SOFTWARE\", \"TOMCAT\");\n\n            envp.put(\"SERVER_NAME\", nullsToBlanks(req.getServerName()));\n\n            envp.put(\"GATEWAY_INTERFACE\", \"CGI/1.1\");\n\n            envp.put(\"SERVER_PROTOCOL\", nullsToBlanks(req.getProtocol()));\n\n            int port = req.getServerPort();\n            Integer iPort =\n                (port == 0 ? Integer.valueOf(-1) : Integer.valueOf(port));\n            envp.put(\"SERVER_PORT\", iPort.toString());\n\n            envp.put(\"REQUEST_METHOD\", nullsToBlanks(req.getMethod()));\n\n            envp.put(\"REQUEST_URI\", nullsToBlanks(req.getRequestURI()));\n\n\n            /*-\n             * PATH_INFO should be determined by using sCGIFullName:\n             * 1) Let sCGIFullName not end in a \"/\" (see method findCGI)\n             * 2) Let sCGIFullName equal the pathInfo fragment which\n             *    corresponds to the actual cgi script.\n             * 3) Thus, PATH_INFO = request.getPathInfo().substring(\n             *                      sCGIFullName.length())\n             *\n             * (see method findCGI, where the real work is done)\n             *\n             */\n            if (pathInfo == null\n                || (pathInfo.substring(sCGIFullName.length()).length() <= 0)) {\n                sPathInfoCGI = \"\";\n            } else {\n                sPathInfoCGI = pathInfo.substring(sCGIFullName.length());\n            }\n            envp.put(\"PATH_INFO\", sPathInfoCGI);\n\n\n            /*-\n             * PATH_TRANSLATED must be determined after PATH_INFO (and the\n             * implied real cgi-script) has been taken into account.\n             *\n             * The following example demonstrates:\n             *\n             * servlet info   = /servlet/cgigw/dir1/dir2/cgi1/trans1/trans2\n             * cgifullpath    = /servlet/cgigw/dir1/dir2/cgi1\n             * path_info      = /trans1/trans2\n             * webAppRootDir  = servletContext.getRealPath(\"/\")\n             *\n             * path_translated = servletContext.getRealPath(\"/trans1/trans2\")\n             *\n             * That is, PATH_TRANSLATED = webAppRootDir + sPathInfoCGI\n             * (unless sPathInfoCGI is null or blank, then the CGI\n             * specification dictates that the PATH_TRANSLATED metavariable\n             * SHOULD NOT be defined.\n             *\n             */\n            if (sPathInfoCGI != null && !(\"\".equals(sPathInfoCGI))) {\n                sPathTranslatedCGI = context.getRealPath(sPathInfoCGI);\n            }\n            if (sPathTranslatedCGI == null || \"\".equals(sPathTranslatedCGI)) {\n                //NOOP\n            } else {\n                envp.put(\"PATH_TRANSLATED\", nullsToBlanks(sPathTranslatedCGI));\n            }\n\n\n            envp.put(\"SCRIPT_NAME\", nullsToBlanks(sCGIScriptName));\n\n            envp.put(\"QUERY_STRING\", nullsToBlanks(req.getQueryString()));\n\n            envp.put(\"REMOTE_HOST\", nullsToBlanks(req.getRemoteHost()));\n\n            envp.put(\"REMOTE_ADDR\", nullsToBlanks(req.getRemoteAddr()));\n\n            envp.put(\"AUTH_TYPE\", nullsToBlanks(req.getAuthType()));\n\n            envp.put(\"REMOTE_USER\", nullsToBlanks(req.getRemoteUser()));\n\n            envp.put(\"REMOTE_IDENT\", \"\"); //not necessary for full compliance\n\n            envp.put(\"CONTENT_TYPE\", nullsToBlanks(req.getContentType()));\n\n\n            /* Note CGI spec says CONTENT_LENGTH must be NULL (\"\") or undefined\n             * if there is no content, so we cannot put 0 or -1 in as per the\n             * Servlet API spec.\n             */\n            int contentLength = req.getContentLength();\n            String sContentLength = (contentLength <= 0 ? \"\" :\n                Integer.toString(contentLength));\n            envp.put(\"CONTENT_LENGTH\", sContentLength);\n\n\n            Enumeration<String> headers = req.getHeaderNames();\n            String header = null;\n            while (headers.hasMoreElements()) {\n                header = null;\n                header = headers.nextElement().toUpperCase(Locale.ENGLISH);\n                //REMIND: rewrite multiple headers as if received as single\n                //REMIND: change character set\n                //REMIND: I forgot what the previous REMIND means\n                if (\"AUTHORIZATION\".equalsIgnoreCase(header) ||\n                    \"PROXY_AUTHORIZATION\".equalsIgnoreCase(header)) {\n                    //NOOP per CGI specification section 11.2\n                } else {\n                    envp.put(\"HTTP_\" + header.replace('-', '_'),\n                             req.getHeader(header));\n                }\n            }\n\n            File fCGIFullPath = new File(sCGIFullPath);\n            command = fCGIFullPath.getCanonicalPath();\n\n            envp.put(\"X_TOMCAT_SCRIPT_PATH\", command);  //for kicks\n\n            envp.put(\"SCRIPT_FILENAME\", command);  //for PHP\n\n            this.env = envp;\n\n            return true;\n\n        }","commit_id":"768973783ec67c156bc0e804070c16af87818af0","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Log the interesting request parameters, invoke the next Filter in the\n     * sequence, and log the interesting response parameters.\n     *\n     * @param request  The servlet request to be processed\n     * @param response The servlet response to be created\n     * @param chain    The filter chain being processed\n     *\n     * @exception IOException if an input/output error occurs\n     * @exception ServletException if a servlet error occurs\n     */\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response,\n            FilterChain chain)\n        throws IOException, ServletException {\n\n        HttpServletRequest hRequest = null;\n        HttpServletResponse hResponse = null;\n\n        if (request instanceof HttpServletRequest) {\n            hRequest = (HttpServletRequest) request;\n        }\n        if (response instanceof HttpServletResponse) {\n            hResponse = (HttpServletResponse) response;\n        }\n\n        // Log pre-service information\n        doLog(\"START TIME        \", getTimestamp());\n\n        if (hRequest == null) {\n            doLog(\"        requestURI\", NON_HTTP_REQ_MSG);\n            doLog(\"          authType\", NON_HTTP_REQ_MSG);\n        } else {\n            doLog(\"        requestURI\", hRequest.getRequestURI());\n            doLog(\"          authType\", hRequest.getAuthType());\n        }\n\n        doLog(\" characterEncoding\", request.getCharacterEncoding());\n        doLog(\"     contentLength\",\n                Integer.valueOf(request.getContentLength()).toString());\n        doLog(\"       contentType\", request.getContentType());\n\n        if (hRequest == null) {\n            doLog(\"       contextPath\", NON_HTTP_REQ_MSG);\n            doLog(\"            cookie\", NON_HTTP_REQ_MSG);\n            doLog(\"            header\", NON_HTTP_REQ_MSG);\n        } else {\n            doLog(\"       contextPath\", hRequest.getContextPath());\n            Cookie cookies[] = hRequest.getCookies();\n            if (cookies != null) {\n                for (int i = 0; i < cookies.length; i++) {\n                    doLog(\"            cookie\", cookies[i].getName() +\n                            \"=\" + cookies[i].getValue());\n                }\n            }\n            Enumeration<String> hnames = hRequest.getHeaderNames();\n            while (hnames.hasMoreElements()) {\n                String hname = hnames.nextElement();\n                Enumeration<String> hvalues = hRequest.getHeaders(hname);\n                while (hvalues.hasMoreElements()) {\n                    String hvalue = hvalues.nextElement();\n                    doLog(\"            header\", hname + \"=\" + hvalue);\n                }\n            }\n        }\n\n        doLog(\"            locale\", request.getLocale().toString());\n\n        if (hRequest == null) {\n            doLog(\"            method\", NON_HTTP_REQ_MSG);\n        } else {\n            doLog(\"            method\", hRequest.getMethod());\n        }\n\n        Enumeration<String> pnames = request.getParameterNames();\n        while (pnames.hasMoreElements()) {\n            String pname = pnames.nextElement();\n            String pvalues[] = request.getParameterValues(pname);\n            StringBuilder result = new StringBuilder(pname);\n            result.append('=');\n            for (int i = 0; i < pvalues.length; i++) {\n                if (i > 0) {\n                    result.append(\", \");\n                }\n                result.append(pvalues[i]);\n            }\n            doLog(\"         parameter\", result.toString());\n        }\n\n        if (hRequest == null) {\n            doLog(\"          pathInfo\", NON_HTTP_REQ_MSG);\n        } else {\n            doLog(\"          pathInfo\", hRequest.getPathInfo());\n        }\n\n        doLog(\"          protocol\", request.getProtocol());\n\n        if (hRequest == null) {\n            doLog(\"       queryString\", NON_HTTP_REQ_MSG);\n        } else {\n            doLog(\"       queryString\", hRequest.getQueryString());\n        }\n\n        doLog(\"        remoteAddr\", request.getRemoteAddr());\n        doLog(\"        remoteHost\", request.getRemoteHost());\n\n        if (hRequest == null) {\n            doLog(\"        remoteUser\", NON_HTTP_REQ_MSG);\n            doLog(\"requestedSessionId\", NON_HTTP_REQ_MSG);\n        } else {\n            doLog(\"        remoteUser\", hRequest.getRemoteUser());\n            doLog(\"requestedSessionId\", hRequest.getRequestedSessionId());\n        }\n\n        doLog(\"            scheme\", request.getScheme());\n        doLog(\"        serverName\", request.getServerName());\n        doLog(\"        serverPort\",\n                Integer.valueOf(request.getServerPort()).toString());\n\n        if (hRequest == null) {\n            doLog(\"       servletPath\", NON_HTTP_REQ_MSG);\n        } else {\n            doLog(\"       servletPath\", hRequest.getServletPath());\n        }\n\n        doLog(\"          isSecure\",\n                Boolean.valueOf(request.isSecure()).toString());\n        doLog(\"------------------\",\n                \"--------------------------------------------\");\n\n        // Perform the request\n        chain.doFilter(request, response);\n\n        // Log post-service information\n        doLog(\"------------------\",\n                \"--------------------------------------------\");\n        if (hRequest == null) {\n            doLog(\"          authType\", NON_HTTP_REQ_MSG);\n        } else {\n            doLog(\"          authType\", hRequest.getAuthType());\n        }\n\n        doLog(\"       contentType\", response.getContentType());\n\n        if (hResponse == null) {\n            doLog(\"            header\", NON_HTTP_RES_MSG);\n        } else {\n            Iterable<String> rhnames = hResponse.getHeaderNames();\n            for (String rhname : rhnames) {\n                Iterable<String> rhvalues = hResponse.getHeaders(rhname);\n                for (String rhvalue : rhvalues) {\n                    doLog(\"            header\", rhname + \"=\" + rhvalue);\n                }\n            }\n        }\n\n        if (hRequest == null) {\n            doLog(\"        remoteUser\", NON_HTTP_REQ_MSG);\n        } else {\n            doLog(\"        remoteUser\", hRequest.getRemoteUser());\n        }\n\n        if (hResponse == null) {\n            doLog(\"        remoteUser\", NON_HTTP_RES_MSG);\n        } else {\n            doLog(\"            status\",\n                    Integer.valueOf(hResponse.getStatus()).toString());\n        }\n\n        doLog(\"END TIME          \", getTimestamp());\n        doLog(\"==================\",\n                \"============================================\");\n    }","id":33473,"modified_method":"/**\n     * Log the interesting request parameters, invoke the next Filter in the\n     * sequence, and log the interesting response parameters.\n     *\n     * @param request  The servlet request to be processed\n     * @param response The servlet response to be created\n     * @param chain    The filter chain being processed\n     *\n     * @exception IOException if an input/output error occurs\n     * @exception ServletException if a servlet error occurs\n     */\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response,\n            FilterChain chain)\n        throws IOException, ServletException {\n\n        HttpServletRequest hRequest = null;\n        HttpServletResponse hResponse = null;\n\n        if (request instanceof HttpServletRequest) {\n            hRequest = (HttpServletRequest) request;\n        }\n        if (response instanceof HttpServletResponse) {\n            hResponse = (HttpServletResponse) response;\n        }\n\n        // Log pre-service information\n        doLog(\"START TIME        \", getTimestamp());\n\n        if (hRequest == null) {\n            doLog(\"        requestURI\", NON_HTTP_REQ_MSG);\n            doLog(\"          authType\", NON_HTTP_REQ_MSG);\n        } else {\n            doLog(\"        requestURI\", hRequest.getRequestURI());\n            doLog(\"          authType\", hRequest.getAuthType());\n        }\n\n        doLog(\" characterEncoding\", request.getCharacterEncoding());\n        doLog(\"     contentLength\",\n                Integer.toString(request.getContentLength()));\n        doLog(\"       contentType\", request.getContentType());\n\n        if (hRequest == null) {\n            doLog(\"       contextPath\", NON_HTTP_REQ_MSG);\n            doLog(\"            cookie\", NON_HTTP_REQ_MSG);\n            doLog(\"            header\", NON_HTTP_REQ_MSG);\n        } else {\n            doLog(\"       contextPath\", hRequest.getContextPath());\n            Cookie cookies[] = hRequest.getCookies();\n            if (cookies != null) {\n                for (int i = 0; i < cookies.length; i++) {\n                    doLog(\"            cookie\", cookies[i].getName() +\n                            \"=\" + cookies[i].getValue());\n                }\n            }\n            Enumeration<String> hnames = hRequest.getHeaderNames();\n            while (hnames.hasMoreElements()) {\n                String hname = hnames.nextElement();\n                Enumeration<String> hvalues = hRequest.getHeaders(hname);\n                while (hvalues.hasMoreElements()) {\n                    String hvalue = hvalues.nextElement();\n                    doLog(\"            header\", hname + \"=\" + hvalue);\n                }\n            }\n        }\n\n        doLog(\"            locale\", request.getLocale().toString());\n\n        if (hRequest == null) {\n            doLog(\"            method\", NON_HTTP_REQ_MSG);\n        } else {\n            doLog(\"            method\", hRequest.getMethod());\n        }\n\n        Enumeration<String> pnames = request.getParameterNames();\n        while (pnames.hasMoreElements()) {\n            String pname = pnames.nextElement();\n            String pvalues[] = request.getParameterValues(pname);\n            StringBuilder result = new StringBuilder(pname);\n            result.append('=');\n            for (int i = 0; i < pvalues.length; i++) {\n                if (i > 0) {\n                    result.append(\", \");\n                }\n                result.append(pvalues[i]);\n            }\n            doLog(\"         parameter\", result.toString());\n        }\n\n        if (hRequest == null) {\n            doLog(\"          pathInfo\", NON_HTTP_REQ_MSG);\n        } else {\n            doLog(\"          pathInfo\", hRequest.getPathInfo());\n        }\n\n        doLog(\"          protocol\", request.getProtocol());\n\n        if (hRequest == null) {\n            doLog(\"       queryString\", NON_HTTP_REQ_MSG);\n        } else {\n            doLog(\"       queryString\", hRequest.getQueryString());\n        }\n\n        doLog(\"        remoteAddr\", request.getRemoteAddr());\n        doLog(\"        remoteHost\", request.getRemoteHost());\n\n        if (hRequest == null) {\n            doLog(\"        remoteUser\", NON_HTTP_REQ_MSG);\n            doLog(\"requestedSessionId\", NON_HTTP_REQ_MSG);\n        } else {\n            doLog(\"        remoteUser\", hRequest.getRemoteUser());\n            doLog(\"requestedSessionId\", hRequest.getRequestedSessionId());\n        }\n\n        doLog(\"            scheme\", request.getScheme());\n        doLog(\"        serverName\", request.getServerName());\n        doLog(\"        serverPort\",\n                Integer.toString(request.getServerPort()));\n\n        if (hRequest == null) {\n            doLog(\"       servletPath\", NON_HTTP_REQ_MSG);\n        } else {\n            doLog(\"       servletPath\", hRequest.getServletPath());\n        }\n\n        doLog(\"          isSecure\",\n                Boolean.valueOf(request.isSecure()).toString());\n        doLog(\"------------------\",\n                \"--------------------------------------------\");\n\n        // Perform the request\n        chain.doFilter(request, response);\n\n        // Log post-service information\n        doLog(\"------------------\",\n                \"--------------------------------------------\");\n        if (hRequest == null) {\n            doLog(\"          authType\", NON_HTTP_REQ_MSG);\n        } else {\n            doLog(\"          authType\", hRequest.getAuthType());\n        }\n\n        doLog(\"       contentType\", response.getContentType());\n\n        if (hResponse == null) {\n            doLog(\"            header\", NON_HTTP_RES_MSG);\n        } else {\n            Iterable<String> rhnames = hResponse.getHeaderNames();\n            for (String rhname : rhnames) {\n                Iterable<String> rhvalues = hResponse.getHeaders(rhname);\n                for (String rhvalue : rhvalues) {\n                    doLog(\"            header\", rhname + \"=\" + rhvalue);\n                }\n            }\n        }\n\n        if (hRequest == null) {\n            doLog(\"        remoteUser\", NON_HTTP_REQ_MSG);\n        } else {\n            doLog(\"        remoteUser\", hRequest.getRemoteUser());\n        }\n\n        if (hResponse == null) {\n            doLog(\"        remoteUser\", NON_HTTP_RES_MSG);\n        } else {\n            doLog(\"            status\",\n                    Integer.toString(hResponse.getStatus()));\n        }\n\n        doLog(\"END TIME          \", getTimestamp());\n        doLog(\"==================\",\n                \"============================================\");\n    }","commit_id":"768973783ec67c156bc0e804070c16af87818af0","url":"https://github.com/apache/tomcat"},{"original_method":"@Test\n\tpublic void testFinishResponse() throws IOException {\n\t\tfinal AtomicLong contentLengthReference = new AtomicLong();\n\t\tfinal AtomicReference<String> locationReference =\n\t\t\tnew AtomicReference<>();\n\t\tfinal AtomicReference<String> messageReference =\n\t\t\tnew AtomicReference<>();\n\t\tfinal AtomicInteger statusReference = new AtomicInteger();\n\n\t\tStubHttpServletResponse stubHttpServletResponse =\n\t\t\tnew StubHttpServletResponse() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void addHeader(String name, String value) {\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean isCommitted() {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void resetBuffer() {\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void sendError(int status) {\n\t\t\t\t\tstatusReference.set(status);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void sendError(int status, String errorMessage) {\n\t\t\t\t\tstatusReference.set(status);\n\t\t\t\t\tmessageReference.set(errorMessage);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void sendRedirect(String location) {\n\t\t\t\t\tlocationReference.set(location);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void setCharacterEncoding(String characterEncoding) {\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void setContentLength(int contentLength) {\n\t\t\t\t\tcontentLengthReference.set(contentLength);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void setContentType(String contentType) {\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void setHeader(String name, String value) {\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void setLocale(Locale locale) {\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void setStatus(int status) {\n\t\t\t\t\tstatusReference.set(status);\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * @deprecated As of 7.0.0\n\t\t\t\t */\n\t\t\t\t@Deprecated\n\t\t\t\t@Override\n\t\t\t\tpublic void setStatus(int status, String message) {\n\t\t\t\t\tstatusReference.set(status);\n\t\t\t\t\tmessageReference.set(message);\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t// Clean\n\n\t\tMetaInfoCacheServletResponse metaInfoCacheServletResponse =\n\t\t\tnew MetaInfoCacheServletResponse(stubHttpServletResponse);\n\n\t\tmetaInfoCacheServletResponse.finishResponse();\n\n\t\t// Transfer headers\n\n\t\tMetaInfoCacheServletResponse innerMetaInfoCacheServletResponse =\n\t\t\tnew MetaInfoCacheServletResponse(stubHttpServletResponse);\n\t\tMetaInfoCacheServletResponse outerMetaInfoCacheServletResponse =\n\t\t\tnew MetaInfoCacheServletResponse(innerMetaInfoCacheServletResponse);\n\n\t\tinnerMetaInfoCacheServletResponse.addHeader(\"name1\", \"value3\");\n\t\tinnerMetaInfoCacheServletResponse.addHeader(\"name2\", \"value3\");\n\n\t\touterMetaInfoCacheServletResponse.addHeader(\"name1\", \"value1\");\n\t\touterMetaInfoCacheServletResponse.addHeader(\"name1\", \"value2\");\n\t\touterMetaInfoCacheServletResponse.addHeader(\"name2\", \"value1\");\n\n\t\touterMetaInfoCacheServletResponse.finishResponse();\n\n\t\tMap<String, Set<Header>> headers =\n\t\t\tinnerMetaInfoCacheServletResponse.getHeaders();\n\n\t\tAssert.assertEquals(2, headers.size());\n\n\t\tSet<Header> headers1 = headers.get(\"name1\");\n\n\t\tAssert.assertEquals(2, headers1.size());\n\t\tAssert.assertTrue(headers1.contains(new Header(\"value1\")));\n\t\tAssert.assertTrue(headers1.contains(new Header(\"value2\")));\n\n\t\tSet<Header> headers2 = headers.get(\"name2\");\n\n\t\tAssert.assertEquals(1, headers2.size());\n\t\tAssert.assertTrue(headers2.contains(new Header(\"value1\")));\n\n\t\t// Send redirect\n\n\t\tMetaInfoCacheServletResponse fromMetaInfoCacheServletResponse =\n\t\t\tnew MetaInfoCacheServletResponse(stubHttpServletResponse);\n\n\t\tfromMetaInfoCacheServletResponse.sendRedirect(\"testURL\");\n\n\t\tMetaInfoCacheServletResponse toMetaInfoCacheServletResponse =\n\t\t\tnew MetaInfoCacheServletResponse(stubHttpServletResponse);\n\n\t\tfromMetaInfoCacheServletResponse.setResponse(\n\t\t\ttoMetaInfoCacheServletResponse);\n\n\t\tlocationReference.set(null);\n\n\t\tfromMetaInfoCacheServletResponse.finishResponse();\n\n\t\tAssert.assertEquals(\"testURL\", locationReference.get());\n\n\t\t// Send error\n\n\t\tfromMetaInfoCacheServletResponse = new MetaInfoCacheServletResponse(\n\t\t\tstubHttpServletResponse);\n\n\t\tfromMetaInfoCacheServletResponse.sendError(400, \"Bad Page\");\n\n\t\ttoMetaInfoCacheServletResponse = new MetaInfoCacheServletResponse(\n\t\t\tstubHttpServletResponse);\n\n\t\tfromMetaInfoCacheServletResponse.setResponse(\n\t\t\ttoMetaInfoCacheServletResponse);\n\n\t\tmessageReference.set(null);\n\t\tstatusReference.set(0);\n\n\t\tfromMetaInfoCacheServletResponse.finishResponse();\n\n\t\tAssert.assertEquals(\"Bad Page\", messageReference.get());\n\t\tAssert.assertEquals(400, statusReference.get());\n\n\t\t// Normal\n\n\t\tfromMetaInfoCacheServletResponse = new MetaInfoCacheServletResponse(\n\t\t\tstubHttpServletResponse);\n\n\t\tfromMetaInfoCacheServletResponse.setContentLength(2048);\n\t\tfromMetaInfoCacheServletResponse.setContentType(\n\t\t\tContentTypes.TEXT_HTML_UTF8);\n\t\tfromMetaInfoCacheServletResponse.setLocale(LocaleUtil.US);\n\t\tfromMetaInfoCacheServletResponse.setStatus(302, \"moved\");\n\n\t\ttoMetaInfoCacheServletResponse = new MetaInfoCacheServletResponse(\n\t\t\tstubHttpServletResponse);\n\n\t\tfromMetaInfoCacheServletResponse.setResponse(\n\t\t\ttoMetaInfoCacheServletResponse);\n\n\t\tcontentLengthReference.set(0);\n\t\tmessageReference.set(null);\n\t\tstatusReference.set(0);\n\n\t\tfromMetaInfoCacheServletResponse.finishResponse();\n\n\t\tAssert.assertEquals(\n\t\t\tStringPool.UTF8,\n\t\t\ttoMetaInfoCacheServletResponse.getCharacterEncoding());\n\t\tAssert.assertEquals(\n\t\t\tContentTypes.TEXT_HTML,\n\t\t\ttoMetaInfoCacheServletResponse.getContentType());\n\t\tAssert.assertEquals(\n\t\t\tLocaleUtil.US, toMetaInfoCacheServletResponse.getLocale());\n\t\tAssert.assertEquals(2048, contentLengthReference.get());\n\t\tAssert.assertEquals(\"moved\", messageReference.get());\n\t\tAssert.assertEquals(302, statusReference.get());\n\n\t\t// Finish response after commit\n\n\t\tfromMetaInfoCacheServletResponse = new MetaInfoCacheServletResponse(\n\t\t\tstubHttpServletResponse);\n\n\t\tfromMetaInfoCacheServletResponse.sendRedirect(\"testURL\");\n\n\t\ttoMetaInfoCacheServletResponse = new MetaInfoCacheServletResponse(\n\t\t\tstubHttpServletResponse);\n\n\t\tfromMetaInfoCacheServletResponse.setResponse(\n\t\t\ttoMetaInfoCacheServletResponse);\n\n\t\tlocationReference.set(null);\n\n\t\ttoMetaInfoCacheServletResponse.flushBuffer();\n\n\t\tfromMetaInfoCacheServletResponse.finishResponse();\n\n\t\tAssert.assertNull(locationReference.get());\n\t}","id":33474,"modified_method":"@Test\n\tpublic void testFinishResponse() throws IOException {\n\t\tfinal AtomicLong contentLengthReference = new AtomicLong();\n\t\tfinal AtomicReference<String> locationReference =\n\t\t\tnew AtomicReference<>();\n\t\tfinal AtomicReference<String> messageReference =\n\t\t\tnew AtomicReference<>();\n\t\tfinal AtomicInteger statusReference = new AtomicInteger();\n\n\t\tStubHttpServletResponse stubHttpServletResponse =\n\t\t\tnew StubHttpServletResponse() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void addHeader(String name, String value) {\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean isCommitted() {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void reset() {\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void resetBuffer() {\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void sendError(int status) {\n\t\t\t\t\tstatusReference.set(status);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void sendError(int status, String errorMessage) {\n\t\t\t\t\tstatusReference.set(status);\n\t\t\t\t\tmessageReference.set(errorMessage);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void sendRedirect(String location) {\n\t\t\t\t\tlocationReference.set(location);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void setCharacterEncoding(String characterEncoding) {\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void setContentLength(int contentLength) {\n\t\t\t\t\tcontentLengthReference.set(contentLength);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void setContentType(String contentType) {\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void setHeader(String name, String value) {\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void setLocale(Locale locale) {\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void setStatus(int status) {\n\t\t\t\t\tstatusReference.set(status);\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * @deprecated As of 7.0.0\n\t\t\t\t */\n\t\t\t\t@Deprecated\n\t\t\t\t@Override\n\t\t\t\tpublic void setStatus(int status, String message) {\n\t\t\t\t\tstatusReference.set(status);\n\t\t\t\t\tmessageReference.set(message);\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t// Clean\n\n\t\tMetaInfoCacheServletResponse metaInfoCacheServletResponse =\n\t\t\tnew MetaInfoCacheServletResponse(stubHttpServletResponse);\n\n\t\tmetaInfoCacheServletResponse.finishResponse(true);\n\n\t\t// Transfer headers\n\n\t\tMetaInfoCacheServletResponse innerMetaInfoCacheServletResponse =\n\t\t\tnew MetaInfoCacheServletResponse(stubHttpServletResponse);\n\t\tMetaInfoCacheServletResponse outerMetaInfoCacheServletResponse =\n\t\t\tnew MetaInfoCacheServletResponse(innerMetaInfoCacheServletResponse);\n\n\t\tinnerMetaInfoCacheServletResponse.addHeader(\"name1\", \"value3\");\n\t\tinnerMetaInfoCacheServletResponse.addHeader(\"name2\", \"value3\");\n\n\t\touterMetaInfoCacheServletResponse.addHeader(\"name1\", \"value1\");\n\t\touterMetaInfoCacheServletResponse.addHeader(\"name1\", \"value2\");\n\t\touterMetaInfoCacheServletResponse.addHeader(\"name2\", \"value1\");\n\n\t\touterMetaInfoCacheServletResponse.finishResponse(false);\n\n\t\tMap<String, Set<Header>> headers =\n\t\t\tinnerMetaInfoCacheServletResponse.getHeaders();\n\n\t\tAssert.assertEquals(2, headers.size());\n\n\t\tSet<Header> headers1 = headers.get(\"name1\");\n\n\t\tAssert.assertEquals(3, headers1.size());\n\t\tAssert.assertTrue(headers1.contains(new Header(\"value1\")));\n\t\tAssert.assertTrue(headers1.contains(new Header(\"value2\")));\n\t\tAssert.assertTrue(headers1.contains(new Header(\"value3\")));\n\n\t\tSet<Header> headers2 = headers.get(\"name2\");\n\n\t\tAssert.assertEquals(2, headers2.size());\n\t\tAssert.assertTrue(headers2.contains(new Header(\"value1\")));\n\t\tAssert.assertTrue(headers2.contains(new Header(\"value3\")));\n\n\t\touterMetaInfoCacheServletResponse.finishResponse(true);\n\n\t\theaders = innerMetaInfoCacheServletResponse.getHeaders();\n\n\t\tAssert.assertEquals(2, headers.size());\n\n\t\theaders1 = headers.get(\"name1\");\n\n\t\tAssert.assertEquals(2, headers1.size());\n\t\tAssert.assertTrue(headers1.contains(new Header(\"value1\")));\n\t\tAssert.assertTrue(headers1.contains(new Header(\"value2\")));\n\n\t\theaders2 = headers.get(\"name2\");\n\n\t\tAssert.assertEquals(1, headers2.size());\n\t\tAssert.assertTrue(headers2.contains(new Header(\"value1\")));\n\n\t\t// Send redirect\n\n\t\tMetaInfoCacheServletResponse fromMetaInfoCacheServletResponse =\n\t\t\tnew MetaInfoCacheServletResponse(stubHttpServletResponse);\n\n\t\tfromMetaInfoCacheServletResponse.sendRedirect(\"testURL\");\n\n\t\tMetaInfoCacheServletResponse toMetaInfoCacheServletResponse =\n\t\t\tnew MetaInfoCacheServletResponse(stubHttpServletResponse);\n\n\t\tfromMetaInfoCacheServletResponse.setResponse(\n\t\t\ttoMetaInfoCacheServletResponse);\n\n\t\tlocationReference.set(null);\n\n\t\tfromMetaInfoCacheServletResponse.finishResponse(true);\n\n\t\tAssert.assertEquals(\"testURL\", locationReference.get());\n\n\t\t// Send error\n\n\t\tfromMetaInfoCacheServletResponse = new MetaInfoCacheServletResponse(\n\t\t\tstubHttpServletResponse);\n\n\t\tfromMetaInfoCacheServletResponse.sendError(400, \"Bad Page\");\n\n\t\ttoMetaInfoCacheServletResponse = new MetaInfoCacheServletResponse(\n\t\t\tstubHttpServletResponse);\n\n\t\tfromMetaInfoCacheServletResponse.setResponse(\n\t\t\ttoMetaInfoCacheServletResponse);\n\n\t\tmessageReference.set(null);\n\t\tstatusReference.set(0);\n\n\t\tfromMetaInfoCacheServletResponse.finishResponse(true);\n\n\t\tAssert.assertEquals(\"Bad Page\", messageReference.get());\n\t\tAssert.assertEquals(400, statusReference.get());\n\n\t\t// Normal\n\n\t\tfromMetaInfoCacheServletResponse = new MetaInfoCacheServletResponse(\n\t\t\tstubHttpServletResponse);\n\n\t\tfromMetaInfoCacheServletResponse.setContentLength(2048);\n\t\tfromMetaInfoCacheServletResponse.setContentType(\n\t\t\tContentTypes.TEXT_HTML_UTF8);\n\t\tfromMetaInfoCacheServletResponse.setLocale(LocaleUtil.US);\n\t\tfromMetaInfoCacheServletResponse.setStatus(302, \"moved\");\n\n\t\ttoMetaInfoCacheServletResponse = new MetaInfoCacheServletResponse(\n\t\t\tstubHttpServletResponse);\n\n\t\tfromMetaInfoCacheServletResponse.setResponse(\n\t\t\ttoMetaInfoCacheServletResponse);\n\n\t\tcontentLengthReference.set(0);\n\t\tmessageReference.set(null);\n\t\tstatusReference.set(0);\n\n\t\tfromMetaInfoCacheServletResponse.finishResponse(true);\n\n\t\tAssert.assertEquals(\n\t\t\tStringPool.UTF8,\n\t\t\ttoMetaInfoCacheServletResponse.getCharacterEncoding());\n\t\tAssert.assertEquals(\n\t\t\tContentTypes.TEXT_HTML,\n\t\t\ttoMetaInfoCacheServletResponse.getContentType());\n\t\tAssert.assertEquals(\n\t\t\tLocaleUtil.US, toMetaInfoCacheServletResponse.getLocale());\n\t\tAssert.assertEquals(2048, contentLengthReference.get());\n\t\tAssert.assertEquals(\"moved\", messageReference.get());\n\t\tAssert.assertEquals(302, statusReference.get());\n\n\t\t// Finish response after commit\n\n\t\tfromMetaInfoCacheServletResponse = new MetaInfoCacheServletResponse(\n\t\t\tstubHttpServletResponse);\n\n\t\tfromMetaInfoCacheServletResponse.sendRedirect(\"testURL\");\n\n\t\ttoMetaInfoCacheServletResponse = new MetaInfoCacheServletResponse(\n\t\t\tstubHttpServletResponse);\n\n\t\tfromMetaInfoCacheServletResponse.setResponse(\n\t\t\ttoMetaInfoCacheServletResponse);\n\n\t\tlocationReference.set(null);\n\n\t\ttoMetaInfoCacheServletResponse.flushBuffer();\n\n\t\tfromMetaInfoCacheServletResponse.finishResponse(true);\n\n\t\tAssert.assertNull(locationReference.get());\n\t}","commit_id":"4f4c55fb096d2b668269b36829d4326281daeff6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testPopulate() throws IOException, PortalResiliencyException {\n\n\t\t// Exception\n\n\t\tSPIAgentResponse spiAgentResponse = new SPIAgentResponse(\n\t\t\t_SERVLET_CONTEXT_NAME);\n\n\t\tException exception = new Exception();\n\n\t\tspiAgentResponse.setException(exception);\n\n\t\ttry {\n\t\t\tspiAgentResponse.populate(\n\t\t\t\tnew MockHttpServletRequest(), new MockHttpServletResponse());\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PortalResiliencyException pre) {\n\t\t\tAssert.assertEquals(\"SPI exception\", pre.getMessage());\n\t\t\tAssert.assertSame(exception, pre.getCause());\n\t\t}\n\n\t\t// Not a portal resiliency response\n\n\t\tspiAgentResponse.setException(null);\n\n\t\tspiAgentResponse.populate(\n\t\t\tnew MockHttpServletRequest(), new MockHttpServletResponse());\n\n\t\t// Distributed request attributes, without type setting\n\n\t\tspiAgentResponse.portalResiliencyResponse = true;\n\n\t\tMap<String, Serializable> distributedRequestAttributes =\n\t\t\tnew HashMap<>();\n\n\t\tdistributedRequestAttributes.put(\n\t\t\tRequestAttributes.ATTRIBUTE_1, RequestAttributes.ATTRIBUTE_1);\n\t\tdistributedRequestAttributes.put(\n\t\t\tRequestAttributes.ATTRIBUTE_3, RequestAttributes.ATTRIBUTE_3);\n\n\t\tspiAgentResponse.distributedRequestAttributes =\n\t\t\tdistributedRequestAttributes;\n\n\t\tMap<String, Serializable> deltaSessionAttributes = new HashMap<>();\n\n\t\tdeltaSessionAttributes.put(_SESSION_ATTRIBUTE_1, _SESSION_ATTRIBUTE_1);\n\t\tdeltaSessionAttributes.put(_SESSION_ATTRIBUTE_2, _SESSION_ATTRIBUTE_2);\n\n\t\tspiAgentResponse.deltaSessionAttributes = deltaSessionAttributes;\n\n\t\tMetaInfoCacheServletResponse metaInfoCacheServletResponse =\n\t\t\tnew MetaInfoCacheServletResponse(new MockHttpServletResponse());\n\n\t\tspiAgentResponse.metaData = metaInfoCacheServletResponse.getMetaData();\n\n\t\tspiAgentResponse.threadLocalDistributors =\n\t\t\tnew ThreadLocalDistributor[0];\n\n\t\tMockHttpServletRequest mockHttpServletRequest =\n\t\t\tnew MockHttpServletRequest();\n\n\t\tspiAgentResponse.populate(\n\t\t\tmockHttpServletRequest, new MockHttpServletResponse());\n\n\t\tEnumeration<String> requestAttributeNameEnumeration =\n\t\t\tmockHttpServletRequest.getAttributeNames();\n\n\t\tList<String> requestAttributeNames = ListUtil.fromEnumeration(\n\t\t\trequestAttributeNameEnumeration);\n\n\t\tAssert.assertEquals(2, requestAttributeNames.size());\n\t\tAssert.assertTrue(\n\t\t\trequestAttributeNames.contains(RequestAttributes.ATTRIBUTE_1));\n\t\tAssert.assertTrue(\n\t\t\trequestAttributeNames.contains(RequestAttributes.ATTRIBUTE_3));\n\t\tAssert.assertEquals(\n\t\t\tRequestAttributes.ATTRIBUTE_1,\n\t\t\tmockHttpServletRequest.getAttribute(RequestAttributes.ATTRIBUTE_1));\n\t\tAssert.assertEquals(\n\t\t\tRequestAttributes.ATTRIBUTE_1,\n\t\t\tmockHttpServletRequest.getAttribute(RequestAttributes.ATTRIBUTE_1));\n\n\t\t// Distributed request attributes, with type setting\n\n\t\tdistributedRequestAttributes.clear();\n\n\t\tString typeSetting = \"typeSetting\";\n\n\t\tdistributedRequestAttributes.put(\n\t\t\tWebKeys.SPI_AGENT_LAYOUT_TYPE_SETTINGS, typeSetting);\n\n\t\tmockHttpServletRequest.setAttribute(WebKeys.LAYOUT, new LayoutImpl());\n\n\t\tspiAgentResponse.populate(\n\t\t\tmockHttpServletRequest, new MockHttpServletResponse());\n\n\t\tLayout layout = (Layout)mockHttpServletRequest.getAttribute(\n\t\t\tWebKeys.LAYOUT);\n\n\t\tAssert.assertEquals(typeSetting, layout.getTypeSettings());\n\n\t\t// Successfully output byte data\n\n\t\tbyte[] outputData = new byte[10];\n\n\t\tspiAgentResponse.byteData = outputData;\n\n\t\tBufferCacheServletResponse bufferCacheServletResponse =\n\t\t\tnew BufferCacheServletResponse(new MockHttpServletResponse());\n\n\t\tspiAgentResponse.populate(\n\t\t\tmockHttpServletRequest, bufferCacheServletResponse);\n\n\t\tByteBuffer byteBuffer = bufferCacheServletResponse.getByteBuffer();\n\n\t\tAssert.assertSame(outputData, byteBuffer.array());\n\n\t\t// Unable to output byte data\n\n\t\tfinal IOException ioException = new IOException();\n\n\t\tHttpServletResponse httpServletResponse =\n\t\t\tnew StubHttpServletResponse() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean isCommitted() {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void flushBuffer() throws IOException {\n\t\t\t\t\tthrow ioException;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void setContentLength(int contentLength) {\n\t\t\t\t}\n\n\t\t\t};\n\n\t\ttry {\n\t\t\tspiAgentResponse.populate(\n\t\t\t\tmockHttpServletRequest, httpServletResponse);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PortalResiliencyException pre) {\n\t\t\tAssert.assertSame(ioException, pre.getCause());\n\t\t}\n\n\t\t// Successfully output string data\n\n\t\tString stringData = \"stringData\";\n\n\t\tspiAgentResponse.stringData = stringData;\n\n\t\tbufferCacheServletResponse = new BufferCacheServletResponse(\n\t\t\tnew MockHttpServletResponse());\n\n\t\tspiAgentResponse.populate(\n\t\t\tmockHttpServletRequest, bufferCacheServletResponse);\n\n\t\tCharBuffer charBuffer = bufferCacheServletResponse.getCharBuffer();\n\n\t\tAssert.assertEquals(stringData, charBuffer.toString());\n\n\t\t// Unable to output string data\n\n\t\ttry {\n\t\t\tspiAgentResponse.populate(\n\t\t\t\tmockHttpServletRequest, httpServletResponse);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PortalResiliencyException pre) {\n\t\t\tAssert.assertSame(ioException, pre.getCause());\n\t\t}\n\t}","id":33475,"modified_method":"@Test\n\tpublic void testPopulate() throws IOException, PortalResiliencyException {\n\n\t\t// Exception\n\n\t\tSPIAgentResponse spiAgentResponse = new SPIAgentResponse(\n\t\t\t_SERVLET_CONTEXT_NAME);\n\n\t\tException exception = new Exception();\n\n\t\tspiAgentResponse.setException(exception);\n\n\t\ttry {\n\t\t\tspiAgentResponse.populate(\n\t\t\t\tnew MockHttpServletRequest(), new MockHttpServletResponse());\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PortalResiliencyException pre) {\n\t\t\tAssert.assertEquals(\"SPI exception\", pre.getMessage());\n\t\t\tAssert.assertSame(exception, pre.getCause());\n\t\t}\n\n\t\t// Not a portal resiliency response\n\n\t\tspiAgentResponse.setException(null);\n\n\t\tspiAgentResponse.populate(\n\t\t\tnew MockHttpServletRequest(), new MockHttpServletResponse());\n\n\t\t// Distributed request attributes, without type setting\n\n\t\tspiAgentResponse.portalResiliencyResponse = true;\n\n\t\tMap<String, Serializable> distributedRequestAttributes =\n\t\t\tnew HashMap<>();\n\n\t\tdistributedRequestAttributes.put(\n\t\t\tRequestAttributes.ATTRIBUTE_1, RequestAttributes.ATTRIBUTE_1);\n\t\tdistributedRequestAttributes.put(\n\t\t\tRequestAttributes.ATTRIBUTE_3, RequestAttributes.ATTRIBUTE_3);\n\n\t\tspiAgentResponse.distributedRequestAttributes =\n\t\t\tdistributedRequestAttributes;\n\n\t\tMap<String, Serializable> deltaSessionAttributes = new HashMap<>();\n\n\t\tdeltaSessionAttributes.put(_SESSION_ATTRIBUTE_1, _SESSION_ATTRIBUTE_1);\n\t\tdeltaSessionAttributes.put(_SESSION_ATTRIBUTE_2, _SESSION_ATTRIBUTE_2);\n\n\t\tspiAgentResponse.deltaSessionAttributes = deltaSessionAttributes;\n\n\t\tMetaInfoCacheServletResponse metaInfoCacheServletResponse =\n\t\t\tnew MetaInfoCacheServletResponse(new MockHttpServletResponse());\n\n\t\tspiAgentResponse.metaData = metaInfoCacheServletResponse.getMetaData();\n\n\t\tspiAgentResponse.threadLocalDistributors =\n\t\t\tnew ThreadLocalDistributor[0];\n\n\t\tMockHttpServletRequest mockHttpServletRequest =\n\t\t\tnew MockHttpServletRequest();\n\n\t\tspiAgentResponse.populate(\n\t\t\tmockHttpServletRequest, new MockHttpServletResponse());\n\n\t\tEnumeration<String> requestAttributeNameEnumeration =\n\t\t\tmockHttpServletRequest.getAttributeNames();\n\n\t\tList<String> requestAttributeNames = ListUtil.fromEnumeration(\n\t\t\trequestAttributeNameEnumeration);\n\n\t\tAssert.assertEquals(2, requestAttributeNames.size());\n\t\tAssert.assertTrue(\n\t\t\trequestAttributeNames.contains(RequestAttributes.ATTRIBUTE_1));\n\t\tAssert.assertTrue(\n\t\t\trequestAttributeNames.contains(RequestAttributes.ATTRIBUTE_3));\n\t\tAssert.assertEquals(\n\t\t\tRequestAttributes.ATTRIBUTE_1,\n\t\t\tmockHttpServletRequest.getAttribute(RequestAttributes.ATTRIBUTE_1));\n\t\tAssert.assertEquals(\n\t\t\tRequestAttributes.ATTRIBUTE_1,\n\t\t\tmockHttpServletRequest.getAttribute(RequestAttributes.ATTRIBUTE_1));\n\n\t\t// Distributed request attributes, with type setting\n\n\t\tdistributedRequestAttributes.clear();\n\n\t\tString typeSetting = \"typeSetting\";\n\n\t\tdistributedRequestAttributes.put(\n\t\t\tWebKeys.SPI_AGENT_LAYOUT_TYPE_SETTINGS, typeSetting);\n\n\t\tmockHttpServletRequest.setAttribute(WebKeys.LAYOUT, new LayoutImpl());\n\n\t\tspiAgentResponse.populate(\n\t\t\tmockHttpServletRequest, new MockHttpServletResponse());\n\n\t\tLayout layout = (Layout)mockHttpServletRequest.getAttribute(\n\t\t\tWebKeys.LAYOUT);\n\n\t\tAssert.assertEquals(typeSetting, layout.getTypeSettings());\n\n\t\t// Successfully output byte data\n\n\t\tbyte[] outputData = new byte[10];\n\n\t\tspiAgentResponse.byteData = outputData;\n\n\t\tBufferCacheServletResponse bufferCacheServletResponse =\n\t\t\tnew BufferCacheServletResponse(new MockHttpServletResponse());\n\n\t\tspiAgentResponse.populate(\n\t\t\tmockHttpServletRequest, bufferCacheServletResponse);\n\n\t\tByteBuffer byteBuffer = bufferCacheServletResponse.getByteBuffer();\n\n\t\tAssert.assertSame(outputData, byteBuffer.array());\n\n\t\t// Unable to output byte data\n\n\t\tfinal IOException ioException = new IOException();\n\n\t\tHttpServletResponse httpServletResponse =\n\t\t\tnew StubHttpServletResponse() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean isCommitted() {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void flushBuffer() throws IOException {\n\t\t\t\t\tthrow ioException;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void reset() {\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void setContentLength(int contentLength) {\n\t\t\t\t}\n\n\t\t\t};\n\n\t\ttry {\n\t\t\tspiAgentResponse.populate(\n\t\t\t\tmockHttpServletRequest, httpServletResponse);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PortalResiliencyException pre) {\n\t\t\tAssert.assertSame(ioException, pre.getCause());\n\t\t}\n\n\t\t// Successfully output string data\n\n\t\tString stringData = \"stringData\";\n\n\t\tspiAgentResponse.stringData = stringData;\n\n\t\tbufferCacheServletResponse = new BufferCacheServletResponse(\n\t\t\tnew MockHttpServletResponse());\n\n\t\tspiAgentResponse.populate(\n\t\t\tmockHttpServletRequest, bufferCacheServletResponse);\n\n\t\tCharBuffer charBuffer = bufferCacheServletResponse.getCharBuffer();\n\n\t\tAssert.assertEquals(stringData, charBuffer.toString());\n\n\t\t// Unable to output string data\n\n\t\ttry {\n\t\t\tspiAgentResponse.populate(\n\t\t\t\tmockHttpServletRequest, httpServletResponse);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PortalResiliencyException pre) {\n\t\t\tAssert.assertSame(ioException, pre.getCause());\n\t\t}\n\t}","commit_id":"4f4c55fb096d2b668269b36829d4326281daeff6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void run()\n\t{\n\t\ttry\n\t\t{\n\t\t\tlogBasic(\"Starting to run...\");\n\t\t\twhile (processRow(meta, data) && !isStopped());\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tlogError(\"Unexpected error : \"+e.toString());\n            logError(Const.getStackTracker(e));\n            setErrors(1);\n\t\t\tstopAll();\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tdispose(meta, data);\n\t\t\tlogSummary();\n\t\t\tmarkStop();\n\t\t}\n\t}","id":33476,"modified_method":"public void run()\n\t{\n\t\ttry\n\t\t{\n\t\t\tlogBasic(Messages.getString(\"RowGenerator.Log.StartToRun\"));\n\t\t\twhile (processRow(meta, data) && !isStopped());\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tlogError(\"Unexpected error : \"+e.toString());\n            logError(Const.getStackTracker(e));\n            setErrors(1);\n\t\t\tstopAll();\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tdispose(meta, data);\n\t\t\tlogSummary();\n\t\t\tmarkStop();\n\t\t}\n\t}","commit_id":"ccc6bbdd4ae0d7452c05f2579fff788917dea6d7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n        meta=(RowGeneratorMeta)smi;\n        data=(RowGeneratorData)sdi;\n\n\t\tRow r=null;\n\t\tboolean retval=true;\n\t\t\n\t\tif (linesWritten<meta.getRowLimit())\n\t\t{\n\t\t\tr=new Row(data.constants); // Copy the data, otherwise it gets manipulated aferwards.\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsetOutputDone();  // signal end to receiver(s)\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tputRow(r);\n\n        if (log.isRowLevel()) log.logRowlevel(toString(), \"Wrote row #\"+linesWritten+\" : \"+r);\n\t\tif ((linesWritten>0) && (linesWritten%Const.ROWS_UPDATE)==0) logBasic(\"Linenr \"+linesWritten);\n\t\t\n\t\treturn retval;\n\t}","id":33477,"modified_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n        meta=(RowGeneratorMeta)smi;\n        data=(RowGeneratorData)sdi;\n\n\t\tRow r=null;\n\t\tboolean retval=true;\n\t\t\n\t\tif (linesWritten<data.rowLimit)\n\t\t{\n\t\t\tr=new Row(data.constants); // Copy the data, otherwise it gets manipulated aferwards.\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsetOutputDone();  // signal end to receiver(s)\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tputRow(r);\n\n        if (log.isRowLevel())\n        {\n            log.logRowlevel(toString(), Messages.getString(\"RowGenerator.Log.Wrote.Row\", Long.toString(linesWritten), r.toString()) );\n        }\n\t\tif ((linesWritten>0) && (linesWritten%Const.ROWS_UPDATE)==0) \n        {\n            logBasic( Messages.getString(\"RowGenerator.Log.LineNr\", Long.toString(linesWritten) ) );\n        }\n\t\t\n\t\treturn retval;\n\t}","commit_id":"ccc6bbdd4ae0d7452c05f2579fff788917dea6d7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean init(StepMetaInterface smi, StepDataInterface sdi)\n    {\n        meta=(RowGeneratorMeta)smi;\n        data=(RowGeneratorData)sdi;\n        \n        if (super.init(smi, sdi))\n        {\n            // Create a row (constants) with all the values in it...\n            ArrayList remarks = new ArrayList(); // stores the errors...\n            data.constants = buildRow(meta, data, remarks);\n            if (remarks.size()==0) \n            { \n                return true;\n            }\n            else\n            {\n                for (int i=0;i<remarks.size();i++)\n                {\n                    CheckResult cr = (CheckResult) remarks.get(i);\n                    log.logError(getStepname(), cr.getText());\n                }\n            }\n        }\n        return false;\n    }","id":33478,"modified_method":"public boolean init(StepMetaInterface smi, StepDataInterface sdi)\n    {\n        meta=(RowGeneratorMeta)smi;\n        data=(RowGeneratorData)sdi;\n        \n        if (super.init(smi, sdi))\n        {\n            // Determine the number of rows to generate...\n            data.rowLimit = Const.toLong(StringUtil.environmentSubstitute(meta.getRowLimit()), -1L);\n            \n            if (data.rowLimit<0L) // Unable to parse\n            {\n                logError(Messages.getString(\"RowGenerator.Wrong.RowLimit.Number\"));\n                return false; // fail\n            }\n            \n            // Create a row (constants) with all the values in it...\n            ArrayList remarks = new ArrayList(); // stores the errors...\n            data.constants = buildRow(meta, data, remarks);\n            if (remarks.size()==0) \n            { \n                return true;\n            }\n            else\n            {\n                for (int i=0;i<remarks.size();i++)\n                {\n                    CheckResult cr = (CheckResult) remarks.get(i);\n                    logError(cr.getText());\n                }\n            }\n        }\n        return false;\n    }","commit_id":"ccc6bbdd4ae0d7452c05f2579fff788917dea6d7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public static final Row buildRow(RowGeneratorMeta meta, RowGeneratorData data, ArrayList remarks)\n    {\n        Row r=new Row();\n        Value value;\n\n        for (int i=0;i<meta.getFieldName().length;i++)\n        {\n            int valtype = Value.getType(meta.getFieldType()[i]); \n            if (meta.getFieldName()[i]!=null)\n            {\n                value=new Value(meta.getFieldName()[i], valtype); // build a value!\n                value.setLength(meta.getFieldLength()[i], meta.getFieldPrecision()[i]);\n                String stringValue = meta.getValue()[i];\n                \n                // If the value is empty: consider it to be NULL.\n                if (stringValue==null || stringValue.length()==0)\n                {\n                    value.setNull();\n                }\n                else\n                {\n                    switch(value.getType())\n                    {\n                    case Value.VALUE_TYPE_NUMBER:\n                        try\n                        {\n                            if (meta.getFieldFormat()[i]!=null || meta.getDecimal()[i] !=null ||\n                            meta.getGroup()[i]       !=null || meta.getCurrency()[i]!=null    \n                            )\n                            {\n                                if (meta.getFieldFormat()[i]!=null && meta.getFieldFormat()[i].length()>=1) data.df.applyPattern(meta.getFieldFormat()[i]);\n                                if (meta.getDecimal()[i] !=null && meta.getDecimal()[i].length()>=1) data.dfs.setDecimalSeparator( meta.getDecimal()[i].charAt(0) );\n                                if (meta.getGroup()[i]   !=null && meta.getGroup()[i].length()>=1) data.dfs.setGroupingSeparator( meta.getGroup()[i].charAt(0) );\n                                if (meta.getCurrency()[i]!=null && meta.getCurrency()[i].length()>=1) data.dfs.setCurrencySymbol( meta.getCurrency()[i] );\n                                \n                                data.df.setDecimalFormatSymbols(data.dfs);\n                            }\n                            \n                            value.setValue( data.nf.parse(stringValue).doubleValue() );\n                        }\n                        catch(Exception e)\n                        {\n                            String message = \"Couldn't parse number field [\"+value.getName()+\"] with value [\"+stringValue+\"] -->\"+e.toString();\n                            remarks.add(new CheckResult(CheckResult.TYPE_RESULT_ERROR, message, null));\n                        }\n                        break;\n                    case Value.VALUE_TYPE_STRING:\n                        value.setValue(stringValue);\n                        break;\n                    case Value.VALUE_TYPE_DATE:\n                        try\n                        {\n                            if (meta.getFieldFormat()[i]!=null)\n                            {\n                                data.daf.applyPattern(meta.getFieldFormat()[i]);\n                                data.daf.setDateFormatSymbols(data.dafs);\n                            }\n                            \n                            value.setValue( data.daf.parse(stringValue) );\n                        }\n                        catch(Exception e)\n                        {\n                            String message = \"Couldn't parse date field [\"+value.getName()+\"] with value [\"+stringValue+\"] -->\"+e.toString();\n                            remarks.add(new CheckResult(CheckResult.TYPE_RESULT_ERROR, message, null));\n                        }\n                        break;\n                        \n                    case Value.VALUE_TYPE_INTEGER:\n                        try\n                        {\n                            value.setValue( Long.parseLong(stringValue) );\n                        }\n                        catch(Exception e)\n                        {\n                            String message = \"Couldn't parse Integer field [\"+value.getName()+\"] with value [\"+stringValue+\"] -->\"+e.toString();\n                            remarks.add(new CheckResult(CheckResult.TYPE_RESULT_ERROR, message, null));\n                        }\n                        break;\n    \n                    case Value.VALUE_TYPE_BIGNUMBER:\n                        try\n                        {\n                            value.setValue( new BigDecimal(stringValue) );\n                        }\n                        catch(Exception e)\n                        {\n                            String message = \"Couldn't parse BigNumber field [\"+value.getName()+\"] with value [\"+stringValue+\"] -->\"+e.toString();\n                            remarks.add(new CheckResult(CheckResult.TYPE_RESULT_ERROR, message, null));\n                        }\n                        break;\n                        \n                    case Value.VALUE_TYPE_BOOLEAN:\n                        value.setValue( \"Y\".equalsIgnoreCase(stringValue) || \"TRUE\".equalsIgnoreCase(stringValue));\n                        break;\n                        \n                    default:\n                        String message = Messages.getString(\"RowGenerator.CheckResult.SpecifyTypeError\");\n                        remarks.add(new CheckResult(CheckResult.TYPE_RESULT_ERROR, message, null));\n                    }\n                }\n                // Now add value to the row!\n                // This is in fact a copy from the fields row, but now with data.\n                r.addValue(value); \n            }\n        }\n        \n        return r;\n    }","id":33479,"modified_method":"public static final Row buildRow(RowGeneratorMeta meta, RowGeneratorData data, ArrayList remarks)\n    {\n        Row r=new Row();\n        Value value;\n\n        for (int i=0;i<meta.getFieldName().length;i++)\n        {\n            int valtype = Value.getType(meta.getFieldType()[i]); \n            if (meta.getFieldName()[i]!=null)\n            {\n                value=new Value(meta.getFieldName()[i], valtype); // build a value!\n                value.setLength(meta.getFieldLength()[i], meta.getFieldPrecision()[i]);\n                String stringValue = meta.getValue()[i];\n                \n                // If the value is empty: consider it to be NULL.\n                if (stringValue==null || stringValue.length()==0)\n                {\n                    value.setNull();\n                }\n                else\n                {\n                    switch(value.getType())\n                    {\n                    case Value.VALUE_TYPE_NUMBER:\n                        try\n                        {\n                            if (meta.getFieldFormat()[i]!=null || meta.getDecimal()[i] !=null ||\n                            meta.getGroup()[i]       !=null || meta.getCurrency()[i]!=null    \n                            )\n                            {\n                                if (meta.getFieldFormat()[i]!=null && meta.getFieldFormat()[i].length()>=1) data.df.applyPattern(meta.getFieldFormat()[i]);\n                                if (meta.getDecimal()[i] !=null && meta.getDecimal()[i].length()>=1) data.dfs.setDecimalSeparator( meta.getDecimal()[i].charAt(0) );\n                                if (meta.getGroup()[i]   !=null && meta.getGroup()[i].length()>=1) data.dfs.setGroupingSeparator( meta.getGroup()[i].charAt(0) );\n                                if (meta.getCurrency()[i]!=null && meta.getCurrency()[i].length()>=1) data.dfs.setCurrencySymbol( meta.getCurrency()[i] );\n                                \n                                data.df.setDecimalFormatSymbols(data.dfs);\n                            }\n                            \n                            value.setValue( data.nf.parse(stringValue).doubleValue() );\n                        }\n                        catch(Exception e)\n                        {\n                            String message = Messages.getString(\"RowGenerator.BuildRow.Error.Parsing.Number\", value.getName(), stringValue, e.toString() );\n                            remarks.add(new CheckResult(CheckResult.TYPE_RESULT_ERROR, message, null));\n                        }\n                        break;\n                    case Value.VALUE_TYPE_STRING:\n                        value.setValue(stringValue);\n                        break;\n                    case Value.VALUE_TYPE_DATE:\n                        try\n                        {\n                            if (meta.getFieldFormat()[i]!=null)\n                            {\n                                data.daf.applyPattern(meta.getFieldFormat()[i]);\n                                data.daf.setDateFormatSymbols(data.dafs);\n                            }\n                            \n                            value.setValue( data.daf.parse(stringValue) );\n                        }\n                        catch(Exception e)\n                        {\n                            String message = Messages.getString(\"RowGenerator.BuildRow.Error.Parsing.Date\", value.getName(), stringValue, e.toString() );\n                            remarks.add(new CheckResult(CheckResult.TYPE_RESULT_ERROR, message, null));\n                        }\n                        break;\n                        \n                    case Value.VALUE_TYPE_INTEGER:\n                        try\n                        {\n                            value.setValue( Long.parseLong(stringValue) );\n                        }\n                        catch(Exception e)\n                        {\n                            String message = Messages.getString(\"RowGenerator.BuildRow.Error.Parsing.Integer\", value.getName(), stringValue, e.toString() );\n                            remarks.add(new CheckResult(CheckResult.TYPE_RESULT_ERROR, message, null));\n                        }\n                        break;\n    \n                    case Value.VALUE_TYPE_BIGNUMBER:\n                        try\n                        {\n                            value.setValue( new BigDecimal(stringValue) );\n                        }\n                        catch(Exception e)\n                        {\n                            String message = Messages.getString(\"RowGenerator.BuildRow.Error.Parsing.BigNumber\", value.getName(), stringValue, e.toString() );\n                            remarks.add(new CheckResult(CheckResult.TYPE_RESULT_ERROR, message, null));\n                        }\n                        break;\n                        \n                    case Value.VALUE_TYPE_BOOLEAN:\n                        value.setValue( \"Y\".equalsIgnoreCase(stringValue) || \"TRUE\".equalsIgnoreCase(stringValue));\n                        break;\n                        \n                    default:\n                        String message = Messages.getString(\"RowGenerator.CheckResult.SpecifyTypeError\");\n                        remarks.add(new CheckResult(CheckResult.TYPE_RESULT_ERROR, message, null));\n                    }\n                }\n                // Now add value to the row!\n                // This is in fact a copy from the fields row, but now with data.\n                r.addValue(value); \n            }\n        }\n        \n        return r;\n    }","commit_id":"ccc6bbdd4ae0d7452c05f2579fff788917dea6d7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n     * Preview the data generated by this step.\n     * This generates a transformation using this step & a dummy and previews it.\n     *\n     */\n    private void preview()\n    {\n        // Create the excel reader step...\n        RowGeneratorMeta oneMeta = new RowGeneratorMeta();\n        getInfo(oneMeta);\n        \n        TransMeta previewMeta = TransPreviewFactory.generatePreviewTransformation(oneMeta, wStepname.getText());\n        \n        EnterNumberDialog numberDialog = new EnterNumberDialog(shell, props, 500, Messages.getString(\"System.Dialog.EnterPreviewSize.Title\"), Messages.getString(\"System.Dialog.EnterPreviewSize.Message\"));\n        int previewSize = numberDialog.open();\n        if (previewSize>0)\n        {\n            TransPreviewProgressDialog progressDialog = new TransPreviewProgressDialog(shell, previewMeta, new String[] { wStepname.getText() }, new int[] { previewSize } );\n            progressDialog.open();\n\n            Trans trans = progressDialog.getTrans();\n            String loggingText = progressDialog.getLoggingText();\n\n            if (!progressDialog.isCancelled())\n            {\n                if (trans.getResult()!=null && trans.getResult().getNrErrors()>0)\n                {\n                \tEnterTextDialog etd = new EnterTextDialog(shell, Messages.getString(\"System.Dialog.PreviewError.Title\"),  \n                \t\t\tMessages.getString(\"System.Dialog.PreviewError.Message\"), loggingText, true );\n                \tetd.setReadOnly();\n                \tetd.open();\n                }\n            }\n            \n            PreviewRowsDialog prd =new PreviewRowsDialog(shell, SWT.NONE, wStepname.getText(), progressDialog.getPreviewRows(wStepname.getText()), loggingText);\n            prd.open();\n        }\n    }","id":33480,"modified_method":"/**\n     * Preview the data generated by this step.\n     * This generates a transformation using this step & a dummy and previews it.\n     *\n     */\n    private void preview()\n    {\n        // Create the excel reader step...\n        RowGeneratorMeta oneMeta = new RowGeneratorMeta();\n        try\n        {\n            getInfo(oneMeta);\n        }\n        catch(KettleException e)\n        {\n            new ErrorDialog(shell, props, Messages.getString(\"RowGeneratorDialog.Illegal.Dialog.Settings.Title\"), Messages.getString(\"RowGeneratorDialog.Illegal.Dialog.Settings.Message\"), e);\n            return;\n        }\n        \n        TransMeta previewMeta = TransPreviewFactory.generatePreviewTransformation(oneMeta, wStepname.getText());\n        \n        EnterNumberDialog numberDialog = new EnterNumberDialog(shell, props, 500, Messages.getString(\"System.Dialog.EnterPreviewSize.Title\"), Messages.getString(\"System.Dialog.EnterPreviewSize.Message\"));\n        int previewSize = numberDialog.open();\n        if (previewSize>0)\n        {\n            TransPreviewProgressDialog progressDialog = new TransPreviewProgressDialog(shell, previewMeta, new String[] { wStepname.getText() }, new int[] { previewSize } );\n            progressDialog.open();\n\n            Trans trans = progressDialog.getTrans();\n            String loggingText = progressDialog.getLoggingText();\n\n            if (!progressDialog.isCancelled())\n            {\n                if (trans.getResult()!=null && trans.getResult().getNrErrors()>0)\n                {\n                \tEnterTextDialog etd = new EnterTextDialog(shell, Messages.getString(\"System.Dialog.PreviewError.Title\"),  \n                \t\t\tMessages.getString(\"System.Dialog.PreviewError.Message\"), loggingText, true );\n                \tetd.setReadOnly();\n                \tetd.open();\n                }\n            }\n            \n            PreviewRowsDialog prd =new PreviewRowsDialog(shell, SWT.NONE, wStepname.getText(), progressDialog.getPreviewRows(wStepname.getText()), loggingText);\n            prd.open();\n        }\n    }","commit_id":"ccc6bbdd4ae0d7452c05f2579fff788917dea6d7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void getInfo(RowGeneratorMeta meta)\n    {\n        meta.setRowLimit( Const.toLong(wLimit.getText(), 0L) );\n        \n        int nrfields = wFields.nrNonEmpty();\n\n        meta.allocate(nrfields);\n\n        for (int i=0;i<nrfields;i++)\n        {\n            TableItem item = wFields.getNonEmpty(i);\n            \n            meta.getFieldName()[i]   = item.getText(1);\n            meta.getFieldType()[i]   = item.getText(2);\n            meta.getFieldFormat()[i] = item.getText(3);\n            String slength = item.getText(4);\n            String sprec   = item.getText(5);\n            meta.getCurrency()[i] = item.getText(6);\n            meta.getDecimal()[i]  = item.getText(7);\n            meta.getGroup()[i]    = item.getText(8);\n            meta.getValue()[i]        = item.getText(9);\n            \n            meta.getFieldLength()[i]    = Const.toInt( slength, -1);\n            meta.getFieldPrecision()[i] = Const.toInt( sprec  , -1);\n        }\n    }","id":33481,"modified_method":"private void getInfo(RowGeneratorMeta meta) throws KettleException\n    {\n        meta.setRowLimit( wLimit.getText() );\n        \n        int nrfields = wFields.nrNonEmpty();\n\n        meta.allocate(nrfields);\n\n        for (int i=0;i<nrfields;i++)\n        {\n            TableItem item = wFields.getNonEmpty(i);\n            \n            meta.getFieldName()[i]   = item.getText(1);\n            meta.getFieldType()[i]   = item.getText(2);\n            meta.getFieldFormat()[i] = item.getText(3);\n            String slength = item.getText(4);\n            String sprec   = item.getText(5);\n            meta.getCurrency()[i] = item.getText(6);\n            meta.getDecimal()[i]  = item.getText(7);\n            meta.getGroup()[i]    = item.getText(8);\n            meta.getValue()[i]        = item.getText(9);\n            \n            meta.getFieldLength()[i]    = Const.toInt( slength, -1);\n            meta.getFieldPrecision()[i] = Const.toInt( sprec  , -1);\n        }\n        \n        // Performs checks...\n        long longLimit = Const.toLong(StringUtil.environmentSubstitute( wLimit.getText()), -1L );\n        if (longLimit<0)\n        {\n            throw new KettleException( Messages.getString(\"RowGeneratorDialog.Wrong.RowLimit.Number\") );\n        }\n        \n\n    }","commit_id":"ccc6bbdd4ae0d7452c05f2579fff788917dea6d7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n\t * Copy information from the meta-data input to the dialog fields.\n\t */ \n\tpublic void getData()\n\t{\n\t\tint i;\n\t\tlog.logDebug(toString(), \"getting fields info...\");\n\t\t\n\t\twLimit.setText(\"\"+(int)input.getRowLimit());\n\n\t\tfor (i=0;i<input.getFieldName().length;i++)\n\t\t{\n\t\t\tif (input.getFieldName()[i]!=null)\n\t\t\t{\n\t\t\t\tTableItem item = wFields.table.getItem(i);\n\t\t\t\titem.setText(1, input.getFieldName()[i]);\n\t\t\t\tlog.logDebug(toString(), \"field #\"+i+\" --> fieldType[i]=\"+input.getFieldType()[i]);\n\t\t\t\tString type   = input.getFieldType()[i];\n\t\t\t\tString format = input.getFieldFormat()[i];\n\t\t\t\tString length = \"\"+input.getFieldLength()[i];\n\t\t\t\tString prec   = \"\"+input.getFieldPrecision()[i];\n\t\t\t\tString curr   = input.getCurrency()[i];\n\t\t\t\tString group  = input.getGroup()[i];\n\t\t\t\tString decim  = input.getDecimal()[i];\n\t\t\t\tString def    = input.getValue()[i];\n\t\t\t\tif (type  !=null) item.setText(2, type  ); else item.setText(2, \"\");\n\t\t\t\tif (format!=null) item.setText(3, format); else item.setText(3, \"\");\n\t\t\t\tif (length!=null) item.setText(4, length); else item.setText(4, \"\");\n\t\t\t\tif (prec  !=null) item.setText(5, prec  ); else item.setText(5, \"\");\n\t\t\t\tif (curr  !=null) item.setText(6, curr  ); else item.setText(6, \"\");\n\t\t\t\tif (decim !=null) item.setText(7, decim ); else item.setText(7, \"\");\n\t\t\t\tif (group !=null) item.setText(8, group ); else item.setText(8, \"\");\n\t\t\t\tif (def   !=null) item.setText(9, def   ); else item.setText(9, \"\");\n\t\t\t}\n\t\t}\n        \n        wFields.setRowNums();\n        wFields.optWidth(true);\n\t\t\n\t\twStepname.selectAll();\n\t}","id":33482,"modified_method":"/**\n\t * Copy information from the meta-data input to the dialog fields.\n\t */ \n\tpublic void getData()\n\t{\n\t\tint i;\n\t\tlog.logDebug(toString(), \"getting fields info...\");\n\t\t\n\t\twLimit.setText(input.getRowLimit());\n\n\t\tfor (i=0;i<input.getFieldName().length;i++)\n\t\t{\n\t\t\tif (input.getFieldName()[i]!=null)\n\t\t\t{\n\t\t\t\tTableItem item = wFields.table.getItem(i);\n\t\t\t\titem.setText(1, input.getFieldName()[i]);\n\t\t\t\tlog.logDebug(toString(), \"field #\"+i+\" --> fieldType[i]=\"+input.getFieldType()[i]);\n\t\t\t\tString type   = input.getFieldType()[i];\n\t\t\t\tString format = input.getFieldFormat()[i];\n\t\t\t\tString length = \"\"+input.getFieldLength()[i];\n\t\t\t\tString prec   = \"\"+input.getFieldPrecision()[i];\n\t\t\t\tString curr   = input.getCurrency()[i];\n\t\t\t\tString group  = input.getGroup()[i];\n\t\t\t\tString decim  = input.getDecimal()[i];\n\t\t\t\tString def    = input.getValue()[i];\n\t\t\t\tif (type  !=null) item.setText(2, type  ); else item.setText(2, \"\");\n\t\t\t\tif (format!=null) item.setText(3, format); else item.setText(3, \"\");\n\t\t\t\tif (length!=null) item.setText(4, length); else item.setText(4, \"\");\n\t\t\t\tif (prec  !=null) item.setText(5, prec  ); else item.setText(5, \"\");\n\t\t\t\tif (curr  !=null) item.setText(6, curr  ); else item.setText(6, \"\");\n\t\t\t\tif (decim !=null) item.setText(7, decim ); else item.setText(7, \"\");\n\t\t\t\tif (group !=null) item.setText(8, group ); else item.setText(8, \"\");\n\t\t\t\tif (def   !=null) item.setText(9, def   ); else item.setText(9, \"\");\n\t\t\t}\n\t\t}\n        \n        wFields.setRowNums();\n        wFields.optWidth(true);\n\t\t\n\t\twStepname.selectAll();\n\t}","commit_id":"ccc6bbdd4ae0d7452c05f2579fff788917dea6d7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void ok()\n\t{\n\t\tstepname = wStepname.getText(); // return value\n\t\tgetInfo(input);\n\t\tdispose();\n\t}","id":33483,"modified_method":"private void ok()\n\t{\n\t\tstepname = wStepname.getText(); // return value\n        try\n        {\n            getInfo(new RowGeneratorMeta()); // to see if there is an exception\n            getInfo(input); // to put the content on the input structure for real if all is well.\n            dispose();\n        }\n        catch(KettleException e)\n        {\n            new ErrorDialog(shell, props, Messages.getString(\"RowGeneratorDialog.Illegal.Dialog.Settings.Title\"), Messages.getString(\"RowGeneratorDialog.Illegal.Dialog.Settings.Message\"), e);\n        }\n\t}","commit_id":"ccc6bbdd4ae0d7452c05f2579fff788917dea6d7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void readData(Node stepnode)\n\t\tthrows KettleXMLException\n\t{\n\t\ttry\n\t\t{\n\t\t\tint nrfields;\n\t\t\tString lim;\n\t\t\t\t\t\n\t\t\tNode fields = XMLHandler.getSubNode(stepnode, \"fields\");\n\t\t\tnrfields=XMLHandler.countNodes(fields, \"field\");\n\t\n\t\t\tallocate(nrfields);\n\t\t\t\n\t\t\tString slength, sprecision;\n\t\t\t\n\t\t\tfor (int i=0;i<nrfields;i++)\n\t\t\t{\n\t\t\t\tNode fnode = XMLHandler.getSubNodeByNr(fields, \"field\", i);\n\t\t\t\t\n\t\t\t\tfieldName[i]   = XMLHandler.getTagValue(fnode, \"name\");\n\t\t\t\tfieldType[i]   = XMLHandler.getTagValue(fnode, \"type\");\n\t\t\t\tfieldFormat[i] = XMLHandler.getTagValue(fnode, \"format\");\n\t\t\t\tcurrency[i] = XMLHandler.getTagValue(fnode, \"currency\");\n\t\t\t\tdecimal[i]  = XMLHandler.getTagValue(fnode, \"decimal\");\n\t\t\t\tgroup[i]    = XMLHandler.getTagValue(fnode, \"group\");\n\t\t\t\tvalue[i]        = XMLHandler.getTagValue(fnode, \"nullif\");\n\t\t\t\tslength         = XMLHandler.getTagValue(fnode, \"length\");\n\t\t\t\tsprecision      = XMLHandler.getTagValue(fnode, \"precision\");\n\t\t\t\t\n\t\t\t\tfieldLength[i]    = Const.toInt(slength, -1);\n\t\t\t\tfieldPrecision[i] = Const.toInt(sprecision, -1);\n\t\t\t}\n\t\t\t\n\t\t\t// Is there a limit on the number of rows we process?\n\t\t\tlim=XMLHandler.getTagValue(stepnode, \"limit\");\n\t\t\trowLimit = Const.toLong(lim, 0);\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleXMLException(\"Unable to load step info from XML\", e);\n\t\t}\n\t}","id":33484,"modified_method":"private void readData(Node stepnode) throws KettleXMLException\n\t{\n\t\ttry\n\t\t{\n\t\t\tNode fields = XMLHandler.getSubNode(stepnode, \"fields\");\n\t\t\tint nrfields=XMLHandler.countNodes(fields, \"field\");\n\t\n\t\t\tallocate(nrfields);\n\t\t\t\n\t\t\tString slength, sprecision;\n\t\t\t\n\t\t\tfor (int i=0;i<nrfields;i++)\n\t\t\t{\n\t\t\t\tNode fnode = XMLHandler.getSubNodeByNr(fields, \"field\", i);\n\t\t\t\t\n\t\t\t\tfieldName[i]   = XMLHandler.getTagValue(fnode, \"name\");\n\t\t\t\tfieldType[i]   = XMLHandler.getTagValue(fnode, \"type\");\n\t\t\t\tfieldFormat[i] = XMLHandler.getTagValue(fnode, \"format\");\n\t\t\t\tcurrency[i] = XMLHandler.getTagValue(fnode, \"currency\");\n\t\t\t\tdecimal[i]  = XMLHandler.getTagValue(fnode, \"decimal\");\n\t\t\t\tgroup[i]    = XMLHandler.getTagValue(fnode, \"group\");\n\t\t\t\tvalue[i]        = XMLHandler.getTagValue(fnode, \"nullif\");\n\t\t\t\tslength         = XMLHandler.getTagValue(fnode, \"length\");\n\t\t\t\tsprecision      = XMLHandler.getTagValue(fnode, \"precision\");\n\t\t\t\t\n\t\t\t\tfieldLength[i]    = Const.toInt(slength, -1);\n\t\t\t\tfieldPrecision[i] = Const.toInt(sprecision, -1);\n\t\t\t}\n\t\t\t\n\t\t\t// Is there a limit on the number of rows we process?\n            rowLimit=XMLHandler.getTagValue(stepnode, \"limit\");\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleXMLException(\"Unable to load step info from XML\", e);\n\t\t}\n\t}","commit_id":"ccc6bbdd4ae0d7452c05f2579fff788917dea6d7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void check(ArrayList remarks, StepMeta stepMeta, Row prev, String input[], String output[], Row info)\n\t{\n\t\tCheckResult cr;\n\t\tif (prev!=null && prev.size()>0)\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, Messages.getString(\"owGeneratorMeta.CheckResult.NoInputStreamsError\"), stepMeta);\n\t\t\tremarks.add(cr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, Messages.getString(\"RowGeneratorMeta.CheckResult.NoInputStreamOk\"), stepMeta);\n\t\t\tremarks.add(cr);\n\t\t\t\n\t\t\tif (rowLimit==0.0)\n\t\t\t{\n\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_WARNING, Messages.getString(\"RowGeneratorMeta.CheckResult.WarnNoRows\"), stepMeta);\n\t\t\t\tremarks.add(cr);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, Messages.getString(\"RowGeneratorMeta.CheckResult.WillReturnRows\", \"\"+(long)rowLimit), stepMeta);\n\t\t\t\tremarks.add(cr);\n\t\t\t}\n\t\t}\n\n\t\t// See if we have input streams leading to this step!\n\t\tif (input.length>0)\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, Messages.getString(\"RowGeneratorMeta.CheckResult.NoInputError\"), stepMeta);\n\t\t\tremarks.add(cr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, Messages.getString(\"RowGeneratorMeta.CheckResult.NoInputOk\"), stepMeta);\n\t\t\tremarks.add(cr);\n\t\t}\n        \n        // Check the constants...\n        RowGeneratorData data = new RowGeneratorData();\n        RowGeneratorMeta meta = (RowGeneratorMeta) stepMeta.getStepMetaInterface();\n        RowGenerator.buildRow(meta, data, remarks);\n\n\t}","id":33485,"modified_method":"public void check(ArrayList remarks, StepMeta stepMeta, Row prev, String input[], String output[], Row info)\n\t{\n\t\tCheckResult cr;\n\t\tif (prev!=null && prev.size()>0)\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, Messages.getString(\"owGeneratorMeta.CheckResult.NoInputStreamsError\"), stepMeta);\n\t\t\tremarks.add(cr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, Messages.getString(\"RowGeneratorMeta.CheckResult.NoInputStreamOk\"), stepMeta);\n\t\t\tremarks.add(cr);\n\t\t\t\n            String strLimit = StringUtil.environmentSubstitute(rowLimit);\n\t\t\tif (Const.toLong(strLimit, -1L)<=0)\n\t\t\t{\n\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_WARNING, Messages.getString(\"RowGeneratorMeta.CheckResult.WarnNoRows\"), stepMeta);\n\t\t\t\tremarks.add(cr);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, Messages.getString(\"RowGeneratorMeta.CheckResult.WillReturnRows\", strLimit), stepMeta);\n\t\t\t\tremarks.add(cr);\n\t\t\t}\n\t\t}\n\n\t\t// See if we have input streams leading to this step!\n\t\tif (input.length>0)\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, Messages.getString(\"RowGeneratorMeta.CheckResult.NoInputError\"), stepMeta);\n\t\t\tremarks.add(cr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, Messages.getString(\"RowGeneratorMeta.CheckResult.NoInputOk\"), stepMeta);\n\t\t\tremarks.add(cr);\n\t\t}\n        \n        // Check the constants...\n        RowGeneratorData data = new RowGeneratorData();\n        RowGeneratorMeta meta = (RowGeneratorMeta) stepMeta.getStepMetaInterface();\n        RowGenerator.buildRow(meta, data, remarks);\n\n\t}","commit_id":"ccc6bbdd4ae0d7452c05f2579fff788917dea6d7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n     * @return Returns the rowLimit.\n     */\n    public long getRowLimit()\n    {\n        return rowLimit;\n    }","id":33486,"modified_method":"/**\n     * @return Returns the rowLimit.\n     */\n    public String getRowLimit()\n    {\n        return rowLimit;\n    }","commit_id":"ccc6bbdd4ae0d7452c05f2579fff788917dea6d7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n     * @param rowLimit The rowLimit to set.\n     */\n    public void setRowLimit(long rowLimit)\n    {\n        this.rowLimit = rowLimit;\n    }","id":33487,"modified_method":"/**\n     * @param rowLimit The rowLimit to set.\n     */\n    public void setRowLimit(String rowLimit)\n    {\n        this.rowLimit = rowLimit;\n    }","commit_id":"ccc6bbdd4ae0d7452c05f2579fff788917dea6d7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void readRep(Repository rep, long id_step, ArrayList databases, Hashtable counters)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tint nrfields = rep.countNrStepAttributes(id_step, \"field_name\");\n\t\t\t\n\t\t\tallocate(nrfields);\n\t\n\t\t\tfor (int i=0;i<nrfields;i++)\n\t\t\t{\n\t\t\t\tfieldName[i]      =       rep.getStepAttributeString (id_step, i, \"field_name\");\n\t\t\t\tfieldType[i]      =       rep.getStepAttributeString (id_step, i, \"field_type\");\n\t\n\t\t\t\tfieldFormat[i]    =       rep.getStepAttributeString (id_step, i, \"field_format\");\n\t\t\t\tcurrency[i]    =       rep.getStepAttributeString (id_step, i, \"field_currency\");\n\t\t\t\tdecimal[i]     =       rep.getStepAttributeString (id_step, i, \"field_decimal\");\n\t\t\t\tgroup[i]       =       rep.getStepAttributeString (id_step, i, \"field_group\");\n\t\t\t\tvalue[i]           =       rep.getStepAttributeString (id_step, i, \"field_nullif\");\n\t\t\t\tfieldLength[i]    =  (int)rep.getStepAttributeInteger(id_step, i, \"field_length\");\n\t\t\t\tfieldPrecision[i] =  (int)rep.getStepAttributeInteger(id_step, i, \"field_precision\");\n\t\t\t}\n\t\t\t\n\t\t\trowLimit = (int)rep.getStepAttributeInteger(id_step, \"limit\");\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleException(\"Unexpected error reading step information from the repository\", e);\n\t\t}\n\t}","id":33488,"modified_method":"public void readRep(Repository rep, long id_step, ArrayList databases, Hashtable counters)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tint nrfields = rep.countNrStepAttributes(id_step, \"field_name\");\n\t\t\t\n\t\t\tallocate(nrfields);\n\t\n\t\t\tfor (int i=0;i<nrfields;i++)\n\t\t\t{\n\t\t\t\tfieldName[i]      =       rep.getStepAttributeString (id_step, i, \"field_name\");\n\t\t\t\tfieldType[i]      =       rep.getStepAttributeString (id_step, i, \"field_type\");\n\t\n\t\t\t\tfieldFormat[i]    =       rep.getStepAttributeString (id_step, i, \"field_format\");\n\t\t\t\tcurrency[i]    =       rep.getStepAttributeString (id_step, i, \"field_currency\");\n\t\t\t\tdecimal[i]     =       rep.getStepAttributeString (id_step, i, \"field_decimal\");\n\t\t\t\tgroup[i]       =       rep.getStepAttributeString (id_step, i, \"field_group\");\n\t\t\t\tvalue[i]           =       rep.getStepAttributeString (id_step, i, \"field_nullif\");\n\t\t\t\tfieldLength[i]    =  (int)rep.getStepAttributeInteger(id_step, i, \"field_length\");\n\t\t\t\tfieldPrecision[i] =  (int)rep.getStepAttributeInteger(id_step, i, \"field_precision\");\n\t\t\t}\n\t\t\t\n            long longLimit = rep.getStepAttributeInteger(id_step, \"limit\");\n            if (longLimit<=0)\n            {\n                rowLimit = rep.getStepAttributeString(id_step, \"limit\");\n            }\n            else\n            {\n                rowLimit = Long.toString(longLimit);\n            }\n\t\t\t \n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleException(\"Unexpected error reading step information from the repository\", e);\n\t\t}\n\t}","commit_id":"ccc6bbdd4ae0d7452c05f2579fff788917dea6d7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void setDefault()\n\t{\n\t\tint i, nrfields=0;\n\t\n\t\tallocate(nrfields);\n\t\t\t\n\t\tfor (i=0;i<nrfields;i++)\n\t\t{\n\t\t\tfieldName[i]      = \"field\"+i;\t\t\t\t\n\t\t\tfieldType[i]      = \"Number\";\n\t\t\tfieldFormat[i]    = \"0,000,000.00;-0,000,000.00\";\n\t\t\tfieldLength[i]    = 9;\n\t\t\tfieldPrecision[i] = 2;\n\t\t\tcurrency[i]    = \"\";\n\t\t\tdecimal[i]     = \",\";\n\t\t\tgroup[i]       = \".\";\n\t\t\tvalue[i]       = \"-\";\n\t\t}\n\t\t\t\n\t\trowLimit=10;\n\t}","id":33489,"modified_method":"public void setDefault()\n\t{\n\t\tint i, nrfields=0;\n\t\n\t\tallocate(nrfields);\n\t\t\t\n\t\tfor (i=0;i<nrfields;i++)\n\t\t{\n\t\t\tfieldName[i]      = \"field\"+i;\t\t\t\t\n\t\t\tfieldType[i]      = \"Number\";\n\t\t\tfieldFormat[i]    = \"0,000,000.00;-0,000,000.00\";\n\t\t\tfieldLength[i]    = 9;\n\t\t\tfieldPrecision[i] = 2;\n\t\t\tcurrency[i]    = \"\";\n\t\t\tdecimal[i]     = \",\";\n\t\t\tgroup[i]       = \".\";\n\t\t\tvalue[i]       = \"-\";\n\t\t}\n\t\t\t\n\t\trowLimit=\"10\";\n\t}","commit_id":"ccc6bbdd4ae0d7452c05f2579fff788917dea6d7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean init(StepMetaInterface smi, StepDataInterface sdi)\n\t{\n\t\tmeta=(TableInputMeta)smi;\n\t\tdata=(TableInputData)sdi;\n\n\t\tif (super.init(smi, sdi))\n\t\t{\n\t\t\t// Verify some basic things first...\n\t\t\t//\n\t\t\tboolean passed=true;\n\t\t\tif (Const.isEmpty(meta.getSQL())) {\n\t\t\t\tlogError(BaseMessages.getString(PKG, \"TableInput.Exception.SQLIsNeeded\"));\n\t\t\t\tpassed=false;\n\t\t\t}\n\n\t\t\tif (meta.getDatabaseMeta()==null) {\n\t\t\t\tlogError(BaseMessages.getString(PKG, \"TableInput.Exception.DatabaseConnectionsIsNeeded\"));\n\t\t\t\tpassed=false;\n\t\t\t}\n\t\t\tif (!passed) return false;\n\n\t\t\tdata.db=new Database(this, meta.getDatabaseMeta());\n\t\t\tdata.db.shareVariablesWith(this);\n\t\t\t\n\t\t\tdata.db.setQueryLimit(meta.getRowLimit());\n\n\t\t\ttry\n\t\t\t{\n                if (getTransMeta().isUsingUniqueConnections())\n                {\n                    synchronized (getTrans()) { data.db.connect(getTrans().getThreadName(), getPartitionID()); }\n                }\n                else\n                {\n                    data.db.connect(getPartitionID());\n                }\n\n                if (meta.getDatabaseMeta().isRequiringTransactionsOnQueries())\n                {\n                    data.db.setCommit(100); // needed for PGSQL it seems...\n                }\n                if (log.isDetailed()) logDetailed(\"Connected to database...\");\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch(KettleException e)\n\t\t\t{\n\t\t\t\tlogError(\"An error occurred, processing will be stopped: \"+e.getMessage());\n\t\t\t\tsetErrors(1);\n\t\t\t\tstopAll();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}","id":33490,"modified_method":"public boolean init(StepMetaInterface smi, StepDataInterface sdi)\n\t{\n\t\tmeta=(TableInputMeta)smi;\n\t\tdata=(TableInputData)sdi;\n\n\t\tif (super.init(smi, sdi))\n\t\t{\n\t\t\t// Verify some basic things first...\n\t\t\t//\n\t\t\tboolean passed=true;\n\t\t\tif (Const.isEmpty(meta.getSQL())) {\n\t\t\t\tlogError(BaseMessages.getString(PKG, \"TableInput.Exception.SQLIsNeeded\"));\n\t\t\t\tpassed=false;\n\t\t\t}\n\n\t\t\tif (meta.getDatabaseMeta()==null) {\n\t\t\t\tlogError(BaseMessages.getString(PKG, \"TableInput.Exception.DatabaseConnectionsIsNeeded\"));\n\t\t\t\tpassed=false;\n\t\t\t}\n\t\t\tif (!passed) return false;\n\n\t\t\tdata.db=new Database(this, meta.getDatabaseMeta());\n\t\t\tdata.db.shareVariablesWith(this);\n\t\t\t\n\t\t\tdata.db.setQueryLimit(Const.toInt(environmentSubstitute(meta.getRowLimit()),0));\n\n\t\t\ttry\n\t\t\t{\n                if (getTransMeta().isUsingUniqueConnections())\n                {\n                    synchronized (getTrans()) { data.db.connect(getTrans().getThreadName(), getPartitionID()); }\n                }\n                else\n                {\n                    data.db.connect(getPartitionID());\n                }\n\n                if (meta.getDatabaseMeta().isRequiringTransactionsOnQueries())\n                {\n                    data.db.setCommit(100); // needed for PGSQL it seems...\n                }\n                if (log.isDetailed()) logDetailed(\"Connected to database...\");\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch(KettleException e)\n\t\t\t{\n\t\t\t\tlogError(\"An error occurred, processing will be stopped: \"+e.getMessage());\n\t\t\t\tsetErrors(1);\n\t\t\t\tstopAll();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}","commit_id":"e669627921522f2690252f98e5e189a6ba9143ec","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n\t * Copy information from the meta-data input to the dialog fields.\n\t */ \n\tpublic void getData()\n\t{\n\t\tif (input.getSQL() != null) wSQL.setText(input.getSQL());\n\t\tif (input.getDatabaseMeta() != null) wConnection.setText(input.getDatabaseMeta().getName());\n\t\twLimit.setText(\"\"+(int)input.getRowLimit()); //$NON-NLS-1$\n\t\t\n        if (input.getLookupStepname() != null)\n        {\n            wDatefrom.setText(input.getLookupStepname());\n            wEachRow.setSelection(input.isExecuteEachInputRow());\n        }\n        else\n        {\n            wEachRow.setEnabled(false);\n            wlEachRow.setEnabled(false);\n        }\n        \n        wVariables.setSelection(input.isVariableReplacementActive());\n        wLazyConversion.setSelection(input.isLazyConversionActive());\n               \n\t\twStepname.selectAll();\n        setSQLToolTip();\n\t}","id":33491,"modified_method":"/**\n\t * Copy information from the meta-data input to the dialog fields.\n\t */ \n\tpublic void getData()\n\t{\n\t\tif (input.getSQL() != null) wSQL.setText(input.getSQL());\n\t\tif (input.getDatabaseMeta() != null) wConnection.setText(input.getDatabaseMeta().getName());\n\t\twLimit.setText(input.getRowLimit()); //$NON-NLS-1$\n\t\t\n        if (input.getLookupStepname() != null)\n        {\n            wDatefrom.setText(input.getLookupStepname());\n            wEachRow.setSelection(input.isExecuteEachInputRow());\n        }\n        else\n        {\n            wEachRow.setEnabled(false);\n            wlEachRow.setEnabled(false);\n        }\n        \n        wVariables.setSelection(input.isVariableReplacementActive());\n        wLazyConversion.setSelection(input.isLazyConversionActive());\n               \n\t\twStepname.selectAll();\n        setSQLToolTip();\n\t}","commit_id":"e669627921522f2690252f98e5e189a6ba9143ec","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\n \t\tprops.setLook(shell);\n        setShellImage(shell, input);\n\n\t\tModifyListener lsMod = new ModifyListener() \n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e) \n\t\t\t{\n\t\t\t\tchangedInDialog = false; // for prompting if dialog is simply closed\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = input.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(BaseMessages.getString(PKG, \"TableInputDialog.TableInput\")); //$NON-NLS-1$\n\t\t\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n        // Stepname line\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(BaseMessages.getString(PKG, \"TableInputDialog.StepName\")); //$NON-NLS-1$\n \t\tprops.setLook(wlStepname);\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top  = new FormAttachment(0, margin);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\n\t\t// Connection line\n\t\twConnection = addConnectionLine(shell, wStepname, middle, margin);\n\t\tif (input.getDatabaseMeta()==null && transMeta.nrDatabases()==1) wConnection.select(0);\n\t\twConnection.addModifyListener(lsMod);\n\n\t\t// Some buttons\n\t\twOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(BaseMessages.getString(PKG, \"System.Button.OK\")); //$NON-NLS-1$\n        wPreview=new Button(shell, SWT.PUSH);\n        wPreview.setText(BaseMessages.getString(PKG, \"System.Button.Preview\")); //$NON-NLS-1$\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(BaseMessages.getString(PKG, \"System.Button.Cancel\")); //$NON-NLS-1$\n\n\t\tsetButtonPositions(new Button[] { wOK, wCancel , wPreview }, margin, null);\n\n\t\t// Limit input ...\n\t\twlLimit=new Label(shell, SWT.RIGHT);\n\t\twlLimit.setText(BaseMessages.getString(PKG, \"TableInputDialog.LimitSize\")); //$NON-NLS-1$\n \t\tprops.setLook(wlLimit);\n\t\tfdlLimit=new FormData();\n\t\tfdlLimit.left = new FormAttachment(0, 0);\n\t\tfdlLimit.right= new FormAttachment(middle, -margin);\n\t\tfdlLimit.bottom = new FormAttachment(wOK, -2*margin);\n\t\twlLimit.setLayoutData(fdlLimit);\n\t\twLimit=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wLimit);\n\t\twLimit.addModifyListener(lsMod);\n\t\tfdLimit=new FormData();\n\t\tfdLimit.left = new FormAttachment(middle, 0);\n\t\tfdLimit.right= new FormAttachment(100, 0);\n\t\tfdLimit.bottom = new FormAttachment(wOK, -2*margin);\n\t\twLimit.setLayoutData(fdLimit);\n\n        // Execute for each row?\n        wlEachRow = new Label(shell, SWT.RIGHT);\n        wlEachRow.setText(BaseMessages.getString(PKG, \"TableInputDialog.ExecuteForEachRow\")); //$NON-NLS-1$\n        props.setLook(wlEachRow);\n        fdlEachRow = new FormData();\n        fdlEachRow.left = new FormAttachment(0, 0);\n        fdlEachRow.right = new FormAttachment(middle, -margin);\n        fdlEachRow.bottom = new FormAttachment(wLimit, -margin);\n        wlEachRow.setLayoutData(fdlEachRow);\n        wEachRow = new Button(shell, SWT.CHECK);\n        props.setLook(wEachRow);\n        fdEachRow = new FormData();\n        fdEachRow.left = new FormAttachment(middle, 0);\n        fdEachRow.right = new FormAttachment(100, 0);\n        fdEachRow.bottom = new FormAttachment(wLimit, -margin);\n        wEachRow.setLayoutData(fdEachRow);\n        SelectionAdapter lsSelMod = new SelectionAdapter()\r\n        {\r\n            public void widgetSelected(SelectionEvent arg0)\r\n            {\r\n                input.setChanged();\r\n            }\r\n        };\r\n        wEachRow.addSelectionListener(lsSelMod);\r\n\r\n\n\n\t\t// Read date from...\n\t\twlDatefrom=new Label(shell, SWT.RIGHT);\n\t\twlDatefrom.setText(BaseMessages.getString(PKG, \"TableInputDialog.InsertDataFromStep\")); //$NON-NLS-1$\n \t\tprops.setLook(wlDatefrom);\n\t\tfdlDatefrom=new FormData();\n\t\tfdlDatefrom.left = new FormAttachment(0, 0);\n\t\tfdlDatefrom.right= new FormAttachment(middle, -margin);\n\t\tfdlDatefrom.bottom = new FormAttachment(wEachRow, -margin);\n\t\twlDatefrom.setLayoutData(fdlDatefrom);\n\t\twDatefrom=new CCombo(shell, SWT.BORDER );\n \t\tprops.setLook(wDatefrom);\n\n\t\tfor (int i=0;i<transMeta.findNrPrevSteps(stepname);i++)\n\t\t{\n\t\t\tStepMeta stepMeta = transMeta.findPrevStep(stepname, i);\n\t\t\twDatefrom.add(stepMeta.getName());\n\t\t}\n\t\t\n\t\twDatefrom.addModifyListener(lsMod);\n\t\tfdDatefrom=new FormData();\n\t\tfdDatefrom.left = new FormAttachment(middle, 0);\n\t\tfdDatefrom.right= new FormAttachment(100, 0);\n\t\tfdDatefrom.bottom = new FormAttachment(wEachRow, -margin);\n\t\twDatefrom.setLayoutData(fdDatefrom);\n\n        // Replace variables in SQL?\n\t\t//\n        wlVariables = new Label(shell, SWT.RIGHT);\n        wlVariables.setText(BaseMessages.getString(PKG, \"TableInputDialog.ReplaceVariables\")); //$NON-NLS-1$\n        props.setLook(wlVariables);\n        fdlVariables = new FormData();\n        fdlVariables.left = new FormAttachment(0, 0);\n        fdlVariables.right = new FormAttachment(middle, -margin);\n        fdlVariables.bottom = new FormAttachment(wDatefrom, -margin);\n        wlVariables.setLayoutData(fdlVariables);\n        wVariables = new Button(shell, SWT.CHECK);\n        props.setLook(wVariables);\n        fdVariables = new FormData();\n        fdVariables.left = new FormAttachment(middle, 0);\n        fdVariables.right = new FormAttachment(100, 0);\n        fdVariables.bottom = new FormAttachment(wDatefrom, -margin);\n        wVariables.setLayoutData(fdVariables);\n        wVariables.addSelectionListener(new SelectionAdapter() { public void widgetSelected(SelectionEvent arg0) { input.setChanged();setSQLToolTip(); } });\n\n        // Lazy conversion?\n\t\t//\n        wlLazyConversion = new Label(shell, SWT.RIGHT);\n        wlLazyConversion.setText(BaseMessages.getString(PKG, \"TableInputDialog.LazyConversion\")); //$NON-NLS-1$\n        props.setLook(wlLazyConversion);\n        fdlLazyConversion = new FormData();\n        fdlLazyConversion.left = new FormAttachment(0, 0);\n        fdlLazyConversion.right = new FormAttachment(middle, -margin);\n        fdlLazyConversion.bottom = new FormAttachment(wVariables, -margin);\n        wlLazyConversion.setLayoutData(fdlLazyConversion);\n        wLazyConversion = new Button(shell, SWT.CHECK);\n        props.setLook(wLazyConversion);\n        fdLazyConversion = new FormData();\n        fdLazyConversion.left = new FormAttachment(middle, 0);\n        fdLazyConversion.right = new FormAttachment(100, 0);\n        fdLazyConversion.bottom = new FormAttachment(wVariables, -margin);\n        wLazyConversion.setLayoutData(fdLazyConversion);\n        wLazyConversion.addSelectionListener(new SelectionAdapter() { public void widgetSelected(SelectionEvent arg0) { input.setChanged();setSQLToolTip(); } });\n\r\n\t\twlPosition=new Label(shell, SWT.NONE); \r\n\t\tprops.setLook(wlPosition);\r\n\t\tfdlPosition=new FormData();\r\n\t\tfdlPosition.left  = new FormAttachment(0,0);\r\n\t\tfdlPosition.right = new FormAttachment(100, 0);\r\n\t\tfdlPosition.bottom = new FormAttachment(wLazyConversion, -margin);\r\n\t\twlPosition.setLayoutData(fdlPosition);\r\n\t\t\r\n\t\t\n\t\t// Table line...\n\t\twlSQL=new Label(shell, SWT.NONE);\n\t\twlSQL.setText(BaseMessages.getString(PKG, \"TableInputDialog.SQL\")); //$NON-NLS-1$\n \t\tprops.setLook(wlSQL);\n\t\tfdlSQL=new FormData();\n\t\tfdlSQL.left = new FormAttachment(0, 0);\n\t\tfdlSQL.top  = new FormAttachment(wConnection, margin*2);\n\t\twlSQL.setLayoutData(fdlSQL);\n\n\t\twbTable=new Button(shell, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbTable);\n\t\twbTable.setText(BaseMessages.getString(PKG, \"TableInputDialog.GetSQLAndSelectStatement\")); //$NON-NLS-1$\n\t\tfdbTable=new FormData();\n\t\tfdbTable.right = new FormAttachment(100, 0);\n\t\tfdbTable.top   = new FormAttachment(wConnection, margin*2);\n\t\twbTable.setLayoutData(fdbTable);\n\n\t\twSQL=new StyledTextComp(shell, SWT.MULTI | SWT.LEFT | SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL, \"\");\n \t\tprops.setLook(wSQL, Props.WIDGET_STYLE_FIXED);\n\t\twSQL.addModifyListener(lsMod);\n\t\tfdSQL=new FormData();\n\t\tfdSQL.left  = new FormAttachment(0, 0);\n\t\tfdSQL.top   = new FormAttachment(wbTable, margin );\n\t\tfdSQL.right = new FormAttachment(100, 0);\n\t\tfdSQL.bottom= new FormAttachment(wlPosition, -margin );\n\t\twSQL.setLayoutData(fdSQL);\n\t\twSQL.addModifyListener(new ModifyListener()\n            {\n                public void modifyText(ModifyEvent arg0)\n                {\n                    setSQLToolTip();\r\n                    setPosition(); \n                }\n            }\n        );\n\r\n\t\t\r\n\t\twSQL.addKeyListener(new KeyAdapter(){\r\n\t\t\tpublic void keyPressed(KeyEvent e) { setPosition(); }\r\n\t\t\tpublic void keyReleased(KeyEvent e) { setPosition(); }\r\n\t\t\t} \r\n\t\t);\r\n\t\twSQL.addFocusListener(new FocusAdapter(){\r\n\t\t\tpublic void focusGained(FocusEvent e) { setPosition(); }\r\n\t\t\tpublic void focusLost(FocusEvent e) { setPosition(); }\r\n\t\t\t}\r\n\t\t);\r\n\t\twSQL.addMouseListener(new MouseAdapter(){\r\n\t\t\tpublic void mouseDoubleClick(MouseEvent e) { setPosition(); }\r\n\t\t\tpublic void mouseDown(MouseEvent e) { setPosition(); }\r\n\t\t\tpublic void mouseUp(MouseEvent e) { setPosition(); }\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t\t// Text Higlighting\r\n\t\tlineStyler = new SQLValuesHighlight();\r\n\t\twSQL.addLineStyleListener(lineStyler);\r\n\t\t\n\t\t// Add listeners\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel();  } };\n        lsPreview  = new Listener() { public void handleEvent(Event e) { preview(); } };\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();      } };\n\t\tlsbTable   = new Listener() { public void handleEvent(Event e) { getSQL();  } };\n        lsDateform = new Listener() { public void handleEvent(Event e) { setFags(); } };\n        \n\t\twCancel.addListener  (SWT.Selection, lsCancel);\n        wPreview.addListener (SWT.Selection, lsPreview);\n\t\twOK.addListener      (SWT.Selection, lsOK    );\n\t\twbTable.addListener  (SWT.Selection, lsbTable);\n        wDatefrom.addListener(SWT.Selection, lsDateform);\n        wDatefrom.addListener(SWT.FocusOut,  lsDateform);\n\n\t\t\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\t\t\n\t\twStepname.addSelectionListener( lsDef );\n\t\twLimit.addSelectionListener( lsDef );\n\t\t\n\t\t\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { checkCancel(e); } } );\n\t\t\n\t\tgetData();\n\t\tchangedInDialog = false; // for prompting if dialog is simply closed\n\t\tinput.setChanged(changed);\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\t\t\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","id":33492,"modified_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\n \t\tprops.setLook(shell);\n        setShellImage(shell, input);\n\n\t\tModifyListener lsMod = new ModifyListener() \n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e) \n\t\t\t{\n\t\t\t\tchangedInDialog = false; // for prompting if dialog is simply closed\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = input.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(BaseMessages.getString(PKG, \"TableInputDialog.TableInput\")); //$NON-NLS-1$\n\t\t\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n        // Stepname line\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(BaseMessages.getString(PKG, \"TableInputDialog.StepName\")); //$NON-NLS-1$\n \t\tprops.setLook(wlStepname);\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top  = new FormAttachment(0, margin);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\n\t\t// Connection line\n\t\twConnection = addConnectionLine(shell, wStepname, middle, margin);\n\t\tif (input.getDatabaseMeta()==null && transMeta.nrDatabases()==1) wConnection.select(0);\n\t\twConnection.addModifyListener(lsMod);\n\n\t\t// Some buttons\n\t\twOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(BaseMessages.getString(PKG, \"System.Button.OK\")); //$NON-NLS-1$\n        wPreview=new Button(shell, SWT.PUSH);\n        wPreview.setText(BaseMessages.getString(PKG, \"System.Button.Preview\")); //$NON-NLS-1$\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(BaseMessages.getString(PKG, \"System.Button.Cancel\")); //$NON-NLS-1$\n\n\t\tsetButtonPositions(new Button[] { wOK, wCancel , wPreview }, margin, null);\n\n\t\t// Limit input ...\n\t\twlLimit=new Label(shell, SWT.RIGHT);\n\t\twlLimit.setText(BaseMessages.getString(PKG, \"TableInputDialog.LimitSize\")); //$NON-NLS-1$\n \t\tprops.setLook(wlLimit);\n\t\tfdlLimit=new FormData();\n\t\tfdlLimit.left = new FormAttachment(0, 0);\n\t\tfdlLimit.right= new FormAttachment(middle, -margin);\n\t\tfdlLimit.bottom = new FormAttachment(wOK, -2*margin);\n\t\twlLimit.setLayoutData(fdlLimit);\n\t\twLimit=new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wLimit);\n\t\twLimit.addModifyListener(lsMod);\n\t\tfdLimit=new FormData();\n\t\tfdLimit.left = new FormAttachment(middle, 0);\n\t\tfdLimit.right= new FormAttachment(100, 0);\n\t\tfdLimit.bottom = new FormAttachment(wOK, -2*margin);\n\t\twLimit.setLayoutData(fdLimit);\n\n        // Execute for each row?\n        wlEachRow = new Label(shell, SWT.RIGHT);\n        wlEachRow.setText(BaseMessages.getString(PKG, \"TableInputDialog.ExecuteForEachRow\")); //$NON-NLS-1$\n        props.setLook(wlEachRow);\n        fdlEachRow = new FormData();\n        fdlEachRow.left = new FormAttachment(0, 0);\n        fdlEachRow.right = new FormAttachment(middle, -margin);\n        fdlEachRow.bottom = new FormAttachment(wLimit, -margin);\n        wlEachRow.setLayoutData(fdlEachRow);\n        wEachRow = new Button(shell, SWT.CHECK);\n        props.setLook(wEachRow);\n        fdEachRow = new FormData();\n        fdEachRow.left = new FormAttachment(middle, 0);\n        fdEachRow.right = new FormAttachment(100, 0);\n        fdEachRow.bottom = new FormAttachment(wLimit, -margin);\n        wEachRow.setLayoutData(fdEachRow);\n        SelectionAdapter lsSelMod = new SelectionAdapter()\r\n        {\r\n            public void widgetSelected(SelectionEvent arg0)\r\n            {\r\n                input.setChanged();\r\n            }\r\n        };\r\n        wEachRow.addSelectionListener(lsSelMod);\r\n\r\n\n\n\t\t// Read date from...\n\t\twlDatefrom=new Label(shell, SWT.RIGHT);\n\t\twlDatefrom.setText(BaseMessages.getString(PKG, \"TableInputDialog.InsertDataFromStep\")); //$NON-NLS-1$\n \t\tprops.setLook(wlDatefrom);\n\t\tfdlDatefrom=new FormData();\n\t\tfdlDatefrom.left = new FormAttachment(0, 0);\n\t\tfdlDatefrom.right= new FormAttachment(middle, -margin);\n\t\tfdlDatefrom.bottom = new FormAttachment(wEachRow, -margin);\n\t\twlDatefrom.setLayoutData(fdlDatefrom);\n\t\twDatefrom=new CCombo(shell, SWT.BORDER );\n \t\tprops.setLook(wDatefrom);\n\n\t\tfor (int i=0;i<transMeta.findNrPrevSteps(stepname);i++)\n\t\t{\n\t\t\tStepMeta stepMeta = transMeta.findPrevStep(stepname, i);\n\t\t\twDatefrom.add(stepMeta.getName());\n\t\t}\n\t\t\n\t\twDatefrom.addModifyListener(lsMod);\n\t\tfdDatefrom=new FormData();\n\t\tfdDatefrom.left = new FormAttachment(middle, 0);\n\t\tfdDatefrom.right= new FormAttachment(100, 0);\n\t\tfdDatefrom.bottom = new FormAttachment(wEachRow, -margin);\n\t\twDatefrom.setLayoutData(fdDatefrom);\n\n        // Replace variables in SQL?\n\t\t//\n        wlVariables = new Label(shell, SWT.RIGHT);\n        wlVariables.setText(BaseMessages.getString(PKG, \"TableInputDialog.ReplaceVariables\")); //$NON-NLS-1$\n        props.setLook(wlVariables);\n        fdlVariables = new FormData();\n        fdlVariables.left = new FormAttachment(0, 0);\n        fdlVariables.right = new FormAttachment(middle, -margin);\n        fdlVariables.bottom = new FormAttachment(wDatefrom, -margin);\n        wlVariables.setLayoutData(fdlVariables);\n        wVariables = new Button(shell, SWT.CHECK);\n        props.setLook(wVariables);\n        fdVariables = new FormData();\n        fdVariables.left = new FormAttachment(middle, 0);\n        fdVariables.right = new FormAttachment(100, 0);\n        fdVariables.bottom = new FormAttachment(wDatefrom, -margin);\n        wVariables.setLayoutData(fdVariables);\n        wVariables.addSelectionListener(new SelectionAdapter() { public void widgetSelected(SelectionEvent arg0) { input.setChanged();setSQLToolTip(); } });\n\n        // Lazy conversion?\n\t\t//\n        wlLazyConversion = new Label(shell, SWT.RIGHT);\n        wlLazyConversion.setText(BaseMessages.getString(PKG, \"TableInputDialog.LazyConversion\")); //$NON-NLS-1$\n        props.setLook(wlLazyConversion);\n        fdlLazyConversion = new FormData();\n        fdlLazyConversion.left = new FormAttachment(0, 0);\n        fdlLazyConversion.right = new FormAttachment(middle, -margin);\n        fdlLazyConversion.bottom = new FormAttachment(wVariables, -margin);\n        wlLazyConversion.setLayoutData(fdlLazyConversion);\n        wLazyConversion = new Button(shell, SWT.CHECK);\n        props.setLook(wLazyConversion);\n        fdLazyConversion = new FormData();\n        fdLazyConversion.left = new FormAttachment(middle, 0);\n        fdLazyConversion.right = new FormAttachment(100, 0);\n        fdLazyConversion.bottom = new FormAttachment(wVariables, -margin);\n        wLazyConversion.setLayoutData(fdLazyConversion);\n        wLazyConversion.addSelectionListener(new SelectionAdapter() { public void widgetSelected(SelectionEvent arg0) { input.setChanged();setSQLToolTip(); } });\n\r\n\t\twlPosition=new Label(shell, SWT.NONE); \r\n\t\tprops.setLook(wlPosition);\r\n\t\tfdlPosition=new FormData();\r\n\t\tfdlPosition.left  = new FormAttachment(0,0);\r\n\t\tfdlPosition.right = new FormAttachment(100, 0);\r\n\t\tfdlPosition.bottom = new FormAttachment(wLazyConversion, -margin);\r\n\t\twlPosition.setLayoutData(fdlPosition);\r\n\t\t\r\n\t\t\n\t\t// Table line...\n\t\twlSQL=new Label(shell, SWT.NONE);\n\t\twlSQL.setText(BaseMessages.getString(PKG, \"TableInputDialog.SQL\")); //$NON-NLS-1$\n \t\tprops.setLook(wlSQL);\n\t\tfdlSQL=new FormData();\n\t\tfdlSQL.left = new FormAttachment(0, 0);\n\t\tfdlSQL.top  = new FormAttachment(wConnection, margin*2);\n\t\twlSQL.setLayoutData(fdlSQL);\n\n\t\twbTable=new Button(shell, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbTable);\n\t\twbTable.setText(BaseMessages.getString(PKG, \"TableInputDialog.GetSQLAndSelectStatement\")); //$NON-NLS-1$\n\t\tfdbTable=new FormData();\n\t\tfdbTable.right = new FormAttachment(100, 0);\n\t\tfdbTable.top   = new FormAttachment(wConnection, margin*2);\n\t\twbTable.setLayoutData(fdbTable);\n\n\t\twSQL=new StyledTextComp(shell, SWT.MULTI | SWT.LEFT | SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL, \"\");\n \t\tprops.setLook(wSQL, Props.WIDGET_STYLE_FIXED);\n\t\twSQL.addModifyListener(lsMod);\n\t\tfdSQL=new FormData();\n\t\tfdSQL.left  = new FormAttachment(0, 0);\n\t\tfdSQL.top   = new FormAttachment(wbTable, margin );\n\t\tfdSQL.right = new FormAttachment(100, 0);\n\t\tfdSQL.bottom= new FormAttachment(wlPosition, -margin );\n\t\twSQL.setLayoutData(fdSQL);\n\t\twSQL.addModifyListener(new ModifyListener()\n            {\n                public void modifyText(ModifyEvent arg0)\n                {\n                    setSQLToolTip();\r\n                    setPosition(); \n                }\n            }\n        );\n\r\n\t\t\r\n\t\twSQL.addKeyListener(new KeyAdapter(){\r\n\t\t\tpublic void keyPressed(KeyEvent e) { setPosition(); }\r\n\t\t\tpublic void keyReleased(KeyEvent e) { setPosition(); }\r\n\t\t\t} \r\n\t\t);\r\n\t\twSQL.addFocusListener(new FocusAdapter(){\r\n\t\t\tpublic void focusGained(FocusEvent e) { setPosition(); }\r\n\t\t\tpublic void focusLost(FocusEvent e) { setPosition(); }\r\n\t\t\t}\r\n\t\t);\r\n\t\twSQL.addMouseListener(new MouseAdapter(){\r\n\t\t\tpublic void mouseDoubleClick(MouseEvent e) { setPosition(); }\r\n\t\t\tpublic void mouseDown(MouseEvent e) { setPosition(); }\r\n\t\t\tpublic void mouseUp(MouseEvent e) { setPosition(); }\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t\t// Text Higlighting\r\n\t\tlineStyler = new SQLValuesHighlight();\r\n\t\twSQL.addLineStyleListener(lineStyler);\r\n\t\t\n\t\t// Add listeners\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel();  } };\n        lsPreview  = new Listener() { public void handleEvent(Event e) { preview(); } };\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();      } };\n\t\tlsbTable   = new Listener() { public void handleEvent(Event e) { getSQL();  } };\n        lsDateform = new Listener() { public void handleEvent(Event e) { setFags(); } };\n        \n\t\twCancel.addListener  (SWT.Selection, lsCancel);\n        wPreview.addListener (SWT.Selection, lsPreview);\n\t\twOK.addListener      (SWT.Selection, lsOK    );\n\t\twbTable.addListener  (SWT.Selection, lsbTable);\n        wDatefrom.addListener(SWT.Selection, lsDateform);\n        wDatefrom.addListener(SWT.FocusOut,  lsDateform);\n\n\t\t\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\t\t\n\t\twStepname.addSelectionListener( lsDef );\n\t\twLimit.addSelectionListener( lsDef );\n\t\t\n\t\t\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { checkCancel(e); } } );\n\t\t\n\t\tgetData();\n\t\tchangedInDialog = false; // for prompting if dialog is simply closed\n\t\tinput.setChanged(changed);\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\t\t\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","commit_id":"e669627921522f2690252f98e5e189a6ba9143ec","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void getInfo(TableInputMeta meta, boolean preview)\n    {\r\n        meta.setSQL(preview && !Const.isEmpty(wSQL.getSelectionText())?wSQL.getSelectionText():wSQL.getText());\n        meta.setDatabaseMeta( transMeta.findDatabase(wConnection.getText()) );\n        meta.setRowLimit( Const.toInt(wLimit.getText(), 0) );\n        meta.setLookupFromStep( transMeta.findStep( wDatefrom.getText() ) );\n        meta.setExecuteEachInputRow(wEachRow.getSelection());\n        meta.setVariableReplacementActive(wVariables.getSelection());\n        meta.setLazyConversionActive(wLazyConversion.getSelection());\n    }","id":33493,"modified_method":"private void getInfo(TableInputMeta meta, boolean preview)\n    {\r\n        meta.setSQL(preview && !Const.isEmpty(wSQL.getSelectionText())?wSQL.getSelectionText():wSQL.getText());\n        meta.setDatabaseMeta( transMeta.findDatabase(wConnection.getText()) );\n        meta.setRowLimit( wLimit.getText() );\n        meta.setLookupFromStep( transMeta.findStep( wDatefrom.getText() ) );\n        meta.setExecuteEachInputRow(wEachRow.getSelection());\n        meta.setVariableReplacementActive(wVariables.getSelection());\n        meta.setLazyConversionActive(wLazyConversion.getSelection());\n    }","commit_id":"e669627921522f2690252f98e5e189a6ba9143ec","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void readRep(Repository rep, ObjectId id_step, List<DatabaseMeta> databases, Map<String, Counter> counters) throws KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tdatabaseMeta = rep.loadDatabaseMetaFromStepAttribute(id_step, \"id_connection\", databases);  //$NON-NLS-1$\r\n\t\t\t\n\t\t\tsql                       =      rep.getStepAttributeString (id_step, \"sql\");\n\t\t\trowLimit                  = (int)rep.getStepAttributeInteger(id_step, \"limit\");\n\t\t\tlookupFromStepname        =      rep.getStepAttributeString (id_step, \"lookup\"); \n            executeEachInputRow       =      rep.getStepAttributeBoolean(id_step, \"execute_each_row\");\n            variableReplacementActive =      rep.getStepAttributeBoolean(id_step, \"variables_active\");\n            lazyConversionActive      =      rep.getStepAttributeBoolean(id_step, \"lazy_conversion_active\");\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleException(\"Unexpected error reading step information from the repository\", e);\n\t\t}\n\t}","id":33494,"modified_method":"public void readRep(Repository rep, ObjectId id_step, List<DatabaseMeta> databases, Map<String, Counter> counters) throws KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tdatabaseMeta = rep.loadDatabaseMetaFromStepAttribute(id_step, \"id_connection\", databases);  //$NON-NLS-1$\r\n\t\t\t\n\t\t\tsql                       =      rep.getStepAttributeString (id_step, \"sql\");\r\n\t\t\tString rowLimit = rep.getStepAttributeString(id_step, \"limit\");\r\n\t\t\tif (rowLimit==null) {\r\n\t\t\t\trowLimit = Long.toString( rep.getStepAttributeInteger(id_step, \"limit\") );\r\n\t\t\t}\n\t\t\tlookupFromStepname        =      rep.getStepAttributeString (id_step, \"lookup\"); \n            executeEachInputRow       =      rep.getStepAttributeBoolean(id_step, \"execute_each_row\");\n            variableReplacementActive =      rep.getStepAttributeBoolean(id_step, \"variables_active\");\n            lazyConversionActive      =      rep.getStepAttributeBoolean(id_step, \"lazy_conversion_active\");\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleException(\"Unexpected error reading step information from the repository\", e);\n\t\t}\n\t}","commit_id":"e669627921522f2690252f98e5e189a6ba9143ec","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n\t * @return Returns the rowLimit.\n\t */\n\tpublic int getRowLimit()\n\t{\n\t\treturn rowLimit;\n\t}","id":33495,"modified_method":"/**\n\t * @return Returns the rowLimit.\n\t */\n\tpublic String getRowLimit()\n\t{\n\t\treturn rowLimit;\n\t}","commit_id":"e669627921522f2690252f98e5e189a6ba9143ec","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n\t * @param rowLimit The rowLimit to set.\n\t */\n\tpublic void setRowLimit(int rowLimit)\n\t{\n\t\tthis.rowLimit = rowLimit;\n\t}","id":33496,"modified_method":"/**\n\t * @param rowLimit The rowLimit to set.\n\t */\n\tpublic void setRowLimit(String rowLimit)\n\t{\n\t\tthis.rowLimit = rowLimit;\n\t}","commit_id":"e669627921522f2690252f98e5e189a6ba9143ec","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void readData(Node stepnode, List<? extends SharedObjectInterface> databases)\n\t\tthrows KettleXMLException\n\t{\n\t\ttry\n\t\t{\n\t\t\tdatabaseMeta              = DatabaseMeta.findDatabase(databases, XMLHandler.getTagValue(stepnode, \"connection\"));\n\t\t\tsql                       = XMLHandler.getTagValue(stepnode, \"sql\");\n\t\t\trowLimit                  = Const.toInt(XMLHandler.getTagValue(stepnode, \"limit\"), 0);\n\t\t\tlookupFromStepname        = XMLHandler.getTagValue(stepnode, \"lookup\");\n            executeEachInputRow       = \"Y\".equals(XMLHandler.getTagValue(stepnode, \"execute_each_row\"));\n            variableReplacementActive = \"Y\".equals(XMLHandler.getTagValue(stepnode, \"variables_active\"));\n            lazyConversionActive      = \"Y\".equals(XMLHandler.getTagValue(stepnode, \"lazy_conversion_active\"));\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleXMLException(\"Unable to load step info from XML\", e);\n\t\t}\n\t}","id":33497,"modified_method":"private void readData(Node stepnode, List<? extends SharedObjectInterface> databases)\n\t\tthrows KettleXMLException\n\t{\n\t\ttry\n\t\t{\n\t\t\tdatabaseMeta              = DatabaseMeta.findDatabase(databases, XMLHandler.getTagValue(stepnode, \"connection\"));\n\t\t\tsql                       = XMLHandler.getTagValue(stepnode, \"sql\");\n\t\t\trowLimit                  = XMLHandler.getTagValue(stepnode, \"limit\");\n\t\t\tlookupFromStepname        = XMLHandler.getTagValue(stepnode, \"lookup\");\n            executeEachInputRow       = \"Y\".equals(XMLHandler.getTagValue(stepnode, \"execute_each_row\"));\n            variableReplacementActive = \"Y\".equals(XMLHandler.getTagValue(stepnode, \"variables_active\"));\n            lazyConversionActive      = \"Y\".equals(XMLHandler.getTagValue(stepnode, \"lazy_conversion_active\"));\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleXMLException(\"Unable to load step info from XML\", e);\n\t\t}\n\t}","commit_id":"e669627921522f2690252f98e5e189a6ba9143ec","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void setDefault()\n\t{\n\t\tdatabaseMeta = null;\n\t\tsql        = \"SELECT <values> FROM <table name> WHERE <conditions>\";\n\t\trowLimit   = 0;\n\t}","id":33498,"modified_method":"public void setDefault()\n\t{\n\t\tdatabaseMeta = null;\n\t\tsql        = \"SELECT <values> FROM <table name> WHERE <conditions>\";\n\t\trowLimit   = \"0\";\n\t}","commit_id":"e669627921522f2690252f98e5e189a6ba9143ec","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean processRow( StepMetaInterface smi, StepDataInterface sdi ) throws KettleException {\n    meta = (CubeInputMeta) smi;\n    data = (CubeInputData) sdi;\n\n    try {\n      Object[] r = data.meta.readData( data.dis );\n      putRow( data.meta, r ); // fill the rowset(s). (sleeps if full)\n      incrementLinesInput();\n\n      if ( meta.getRowLimit() > 0 && getLinesInput() >= meta.getRowLimit() ) // finished!\n      {\n        setOutputDone();\n        return false;\n      }\n    } catch ( KettleEOFException eof ) {\n      setOutputDone();\n      return false;\n    } catch ( SocketTimeoutException e ) {\n      throw new KettleException( e ); // shouldn't happen on files\n    }\n\n    if ( checkFeedback( getLinesInput() ) ) {\n      if ( log.isBasic() ) {\n        logBasic( BaseMessages.getString( PKG, \"CubeInput.Log.LineNumber\" ) + getLinesInput() );\n      }\n    }\n\n    return true;\n  }","id":33499,"modified_method":"public boolean processRow( StepMetaInterface smi, StepDataInterface sdi ) throws KettleException {\n\n    if ( first ) {\n      first = false;\n      meta = (CubeInputMeta) smi;\n      data = (CubeInputData) sdi;\n      realRowLimit = Const.toInt( environmentSubstitute( meta.getRowLimit() ), 0 );\n    }\n    \n\n    try {\n      Object[] r = data.meta.readData( data.dis );\n      putRow( data.meta, r ); // fill the rowset(s). (sleeps if full)\n      incrementLinesInput();\n\n      if ( realRowLimit > 0 && getLinesInput() >= realRowLimit ) // finished!\n      {\n        setOutputDone();\n        return false;\n      }\n    } catch ( KettleEOFException eof ) {\n      setOutputDone();\n      return false;\n    } catch ( SocketTimeoutException e ) {\n      throw new KettleException( e ); // shouldn't happen on files\n    }\n\n    if ( checkFeedback( getLinesInput() ) ) {\n      if ( log.isBasic() ) {\n        logBasic( BaseMessages.getString( PKG, \"CubeInput.Log.LineNumber\" ) + getLinesInput() );\n      }\n    }\n\n    return true;\n  }","commit_id":"ae32049501e43e5ee96c4e09a8b23c2da5816b3f","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void ok() {\n    if ( Const.isEmpty( wStepname.getText() ) ) {\n      return;\n    }\n\n    stepname = wStepname.getText(); // return value\n    // copy info to Meta class (input)\n    input.setFilename( wFilename.getText() );\n    input.setRowLimit( Const.toInt( wLimit.getText(), 0 ) );\n    input.setAddResultFile( wAddResult.getSelection() );\n\n    dispose();\n  }","id":33500,"modified_method":"private void ok() {\n    if ( Const.isEmpty( wStepname.getText() ) ) {\n      return;\n    }\n\n    stepname = wStepname.getText(); // return value\n    // copy info to Meta class (input)\n    input.setFilename( wFilename.getText() );\n    input.setRowLimit( wLimit.getText() );\n    input.setAddResultFile( wAddResult.getSelection() );\n\n    dispose();\n  }","commit_id":"ae32049501e43e5ee96c4e09a8b23c2da5816b3f","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void setDefault() {\n    filename = \"file\";\n    rowLimit = 0;\n    addfilenameresult = false;\n  }","id":33501,"modified_method":"public void setDefault() {\n    filename = \"file\";\n    rowLimit = \"0\";\n    addfilenameresult = false;\n  }","commit_id":"ae32049501e43e5ee96c4e09a8b23c2da5816b3f","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n   * @param rowLimit\n   *          The rowLimit to set.\n   */\n  public void setRowLimit( int rowLimit ) {\n    this.rowLimit = rowLimit;\n  }","id":33502,"modified_method":"/**\n   * @param rowLimit\n   *          The rowLimit to set.\n   */\n  @Deprecated\n  public void setRowLimit( int rowLimit ) {\n    this.rowLimit = String.valueOf( rowLimit );\n  }","commit_id":"ae32049501e43e5ee96c4e09a8b23c2da5816b3f","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void readData( Node stepnode ) throws KettleXMLException {\n    try {\n      filename = XMLHandler.getTagValue( stepnode, \"file\", \"name\" );\n      rowLimit = Const.toInt( XMLHandler.getTagValue( stepnode, \"limit\" ), 0 );\n      addfilenameresult = \"Y\".equalsIgnoreCase( XMLHandler.getTagValue( stepnode, \"addfilenameresult\" ) );\n\n    } catch ( Exception e ) {\n      throw new KettleXMLException(\n        BaseMessages.getString( PKG, \"CubeInputMeta.Exception.UnableToLoadStepInfo\" ), e );\n    }\n  }","id":33503,"modified_method":"private void readData( Node stepnode ) throws KettleXMLException {\n    try {\n      filename = XMLHandler.getTagValue( stepnode, \"file\", \"name\" );\n      rowLimit = XMLHandler.getTagValue( stepnode, \"limit\" );\n      addfilenameresult = \"Y\".equalsIgnoreCase( XMLHandler.getTagValue( stepnode, \"addfilenameresult\" ) );\n\n    } catch ( Exception e ) {\n      throw new KettleXMLException(\n        BaseMessages.getString( PKG, \"CubeInputMeta.Exception.UnableToLoadStepInfo\" ), e );\n    }\n  }","commit_id":"ae32049501e43e5ee96c4e09a8b23c2da5816b3f","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n   * @return Returns the rowLimit.\n   */\n  public int getRowLimit() {\n    return rowLimit;\n  }","id":33504,"modified_method":"/**\n   * @return Returns the rowLimit.\n   */\n  public String getRowLimit() {\n    return rowLimit;\n  }","commit_id":"ae32049501e43e5ee96c4e09a8b23c2da5816b3f","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void readRep( Repository rep, IMetaStore metaStore, ObjectId id_step, List<DatabaseMeta> databases ) throws KettleException {\n    try {\n      filename = rep.getStepAttributeString( id_step, \"file_name\" );\n      rowLimit = (int) rep.getStepAttributeInteger( id_step, \"limit\" );\n      addfilenameresult = rep.getStepAttributeBoolean( id_step, \"addfilenameresult\" );\n\n    } catch ( Exception e ) {\n      throw new KettleException( BaseMessages.getString(\n        PKG, \"CubeInputMeta.Exception.UnexpectedErrorWhileReadingStepInfo\" ), e );\n    }\n  }","id":33505,"modified_method":"public void readRep( Repository rep, IMetaStore metaStore, ObjectId id_step, List<DatabaseMeta> databases ) throws KettleException {\n    try {\n      filename = rep.getStepAttributeString( id_step, \"file_name\" );\n      try {\n        rowLimit = rep.getStepAttributeString( id_step, \"limit\" );\n      } catch ( KettleException readOldAttributeType ) {\n        // PDI-12897\n        rowLimit = String.valueOf( rep.getStepAttributeInteger( id_step, \"limit\" ) );\n      }\n      addfilenameresult = rep.getStepAttributeBoolean( id_step, \"addfilenameresult\" );\n\n    } catch ( Exception e ) {\n      throw new KettleException( BaseMessages.getString(\n        PKG, \"CubeInputMeta.Exception.UnexpectedErrorWhileReadingStepInfo\" ), e );\n    }\n  }","commit_id":"ae32049501e43e5ee96c4e09a8b23c2da5816b3f","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void encode(XMLEncoder encoder) throws XMLStreamException {\n\t\tencoder.pushXMLDictionary(_dictionary);\n\t\tencoder.writeElement(REPOSITORY_INFO_TYPE_ELEMENT, getType()._stringValue.getBytes());\n\t\tencoder.writeElement(REPOSITORY_INFO_VERSION_ELEMENT, _version.getBytes());\n\t\tencoder.writeElement(REPOSITORY_VERSION_ELEMENT, _repoVersion.getBytes());\n\t\tencoder.writeElement(GLOBAL_PREFIX_ELEMENT, _globalPrefix.getBytes());\n\t\tencoder.writeElement(LOCAL_NAME_ELEMENT, _localName.getBytes());\n\t\tencoder.popXMLDictionary();\n\t\tif (_names.size() > 0) {\n\t\t\tfor (ContentName name : _names)\n\t\t\t\tname.encode(encoder);\n\t\t}\n\t}","id":33506,"modified_method":"public void encode(XMLEncoder encoder) throws XMLStreamException {\n\t\tif (!validate()) {\n\t\t\tthrow new XMLStreamException(\"Cannot encode \" + this.getClass().getName() + \": field values missing.\");\n\t\t}\n\t\tencoder.writeStartElement(REPOSITORY_INFO_ELEMENT);\n\t\tencoder.writeElement(REPOSITORY_INFO_TYPE_ELEMENT, getType().toString());\n\t\tencoder.writeElement(REPOSITORY_INFO_VERSION_ELEMENT, _version);\n\t\tencoder.writeElement(REPOSITORY_VERSION_ELEMENT, _repoVersion);\n\t\t// Should these be names?\n\t\tencoder.writeElement(GLOBAL_PREFIX_ELEMENT, _globalPrefix);\n\t\tencoder.writeElement(LOCAL_NAME_ELEMENT, _localName);\n\t\tif (_names.size() > 0) {\n\t\t\tfor (ContentName name : _names)\n\t\t\t\tname.encode(encoder);\n\t\t}\n\t\tencoder.writeEndElement();\n\t}","commit_id":"ddd26dc0d78e7944319273c470627559c2dd723d","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public void decode(XMLDecoder decoder) throws XMLStreamException {\n\t\tdecoder.pushXMLDictionary(_dictionary);\n\t\tif (!decoder.peekStartElement(REPOSITORY_INFO_TYPE_ELEMENT)) {\n\t\t\t_type = RepoInfoType.UNKNOWN;\n\t\t\treturn;\n\t\t}\n\t\t_type = RepoInfoType.valueFromString(new String(decoder.readBinaryElement(REPOSITORY_INFO_TYPE_ELEMENT)));\n\t\t_version = new String(decoder.readBinaryElement(REPOSITORY_INFO_VERSION_ELEMENT));\n\t\t_repoVersion = new String(decoder.readBinaryElement(REPOSITORY_VERSION_ELEMENT));\n\t\t_globalPrefix = new String(decoder.readBinaryElement(GLOBAL_PREFIX_ELEMENT));\n\t\t_localName = new String(decoder.readBinaryElement(LOCAL_NAME_ELEMENT));\n\t\tdecoder.popXMLDictionary();\n\t\twhile (decoder.peekStartElement(ContentName.CONTENT_NAME_ELEMENT)) {\n\t\t\tContentName name = new ContentName();\n\t\t\tname.decode(decoder);\n\t\t\t_names.add(name);\n\t\t}\n\t}","id":33507,"modified_method":"public void decode(XMLDecoder decoder) throws XMLStreamException {\n\t\tdecoder.readStartElement(REPOSITORY_INFO_ELEMENT);\n\t\tif (!decoder.peekStartElement(REPOSITORY_INFO_TYPE_ELEMENT)) {\n\t\t\t// This is a bad idea. It silently leaves a wad of stuff on the stream.\n\t\t\t// Better to throw an exception so caller knows something is wrong.\n\t\t\t// If you want to punt, need to skip rest of object. Isn't useful,\n\t\t\t// version should come first, and be checked.\n\t\t\t_type = RepoInfoType.UNKNOWN;\n\t\t\treturn;\n\t\t}\n\t\t_type = RepoInfoType.valueFromString(decoder.readUTF8Element(REPOSITORY_INFO_TYPE_ELEMENT));\n\t\t_version = decoder.readUTF8Element(REPOSITORY_INFO_VERSION_ELEMENT);\n\t\t_repoVersion = decoder.readUTF8Element(REPOSITORY_VERSION_ELEMENT);\n\t\t_globalPrefix = decoder.readUTF8Element(GLOBAL_PREFIX_ELEMENT);\n\t\t_localName = decoder.readUTF8Element(LOCAL_NAME_ELEMENT);\n\t\twhile (decoder.peekStartElement(ContentName.CONTENT_NAME_ELEMENT)) {\n\t\t\tContentName name = new ContentName();\n\t\t\tname.decode(decoder);\n\t\t\t_names.add(name);\n\t\t}\n\t\tdecoder.readEndElement();\n\t}","commit_id":"ddd26dc0d78e7944319273c470627559c2dd723d","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public List<Issue> createIssues(final IProgressMonitor monitor) {\n\t\tfinal List<Issue> issues = xtextDocument\n\t\t\t\t.readOnly(new IUnitOfWork<List<Issue>, XtextResource>() {\n\t\t\t\t\tpublic List<Issue> exec(XtextResource resource) throws Exception {\n\t\t\t\t\t\treturn resourceValidator.validate(resource, getCheckMode(), new CancelIndicator() {\n\t\t\t\t\t\t\tpublic boolean isCanceled() {\n\t\t\t\t\t\t\t\treturn monitor.isCanceled();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\treturn issues;\n\t}","id":33508,"modified_method":"public List<Issue> createIssues(final IProgressMonitor monitor) {\n\t\tfinal List<Issue> issues = xtextDocument\n\t\t\t\t.readOnly(new IUnitOfWork<List<Issue>, XtextResource>() {\n\t\t\t\t\tpublic List<Issue> exec(XtextResource resource) throws Exception {\n\t\t\t\t\t\tif (resource == null)\n\t\t\t\t\t\t\treturn Collections.emptyList();\n\t\t\t\t\t\treturn resourceValidator.validate(resource, getCheckMode(), new CancelIndicator() {\n\t\t\t\t\t\t\tpublic boolean isCanceled() {\n\t\t\t\t\t\t\t\treturn monitor.isCanceled();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\treturn issues;\n\t}","commit_id":"15f793f1179a5b7c05ea34b2811695d4234d4997","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\t\tpublic <T> T modify(IUnitOfWork<T, XtextResource> work) {\n\t\t\ttry {\n\t\t\t\tvalidationJob.cancel();\n\t\t\t\treturn super.modify(work);\n\t\t\t} catch (RuntimeException e) {\n\t\t\t\ttry {\n\t\t\t\t\tgetState().reparse(get());\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t}\n\t\t\t\tthrow e;\n\t\t\t} finally {\n\t\t\t\tcheckAndUpdateAnnotations();\n\t\t\t}\n\t\t}","id":33509,"modified_method":"@Override\n\t\tpublic <T> T modify(IUnitOfWork<T, XtextResource> work) {\n\t\t\ttry {\n\t\t\t\tvalidationJob.cancel();\n\t\t\t\treturn super.modify(work);\n\t\t\t} catch (RuntimeException e) {\n\t\t\t\ttry {\n\t\t\t\t\tXtextResource state = getState();\n\t\t\t\t\tif (state != null)\n\t\t\t\t\t\tstate.reparse(get());\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t}\n\t\t\t\tthrow e;\n\t\t\t} finally {\n\t\t\t\tcheckAndUpdateAnnotations();\n\t\t\t}\n\t\t}","commit_id":"15f793f1179a5b7c05ea34b2811695d4234d4997","url":"https://github.com/eclipse/xtext"},{"original_method":"private static void reparseRangeInternal(PsiFile file, int startOffset, int endOffset, int lengthShift, char[] newFileText){\n    Set<String> oldTaglibPrefixes = null;\n    if(file.getLanguage() == StdLanguages.JSP){\n      oldTaglibPrefixes = ((JspFileViewProvider)file.getViewProvider()).getKnownTaglibPrefixes();\n    }\n    try{\n      file.getViewProvider().beforeContentsSynchronized();\n      final PsiFileImpl fileImpl = (PsiFileImpl)file;\n      Project project = fileImpl.getProject();\n      final CharTable charTable = fileImpl.getTreeElement().getCharTable();\n      // hack\n      final int textLength = file.getTextLength() + lengthShift;\n\n      final FileElement treeFileElement = fileImpl.getTreeElement();\n\n      final ASTNode leafAtStart = treeFileElement.findLeafElementAt(startOffset);\n      final ASTNode leafAtEnd = treeFileElement.findLeafElementAt(endOffset);\n      ASTNode parent = leafAtStart != null && leafAtEnd != null ? TreeUtil.findCommonParent(leafAtStart, leafAtEnd) : treeFileElement;\n\n      int minErrorLevel = Integer.MAX_VALUE;\n      ASTNode bestReparseable = null;\n      ASTNode prevReparseable = null;\n      boolean theOnlyReparseable = false;\n\n      while(parent != null && !(parent instanceof FileElement)){\n        if(parent.getElementType() instanceof IChameleonElementType){\n          final TextRange textRange = parent.getTextRange();\n          final IChameleonElementType reparseable = (IChameleonElementType)parent.getElementType();\n          boolean languageChanged = false;\n          if(prevReparseable != null){\n            languageChanged = prevReparseable.getElementType().getLanguage() != reparseable.getLanguage();\n          }\n\n          final String newTextStr = StringFactory.createStringFromConstantArray(newFileText, textRange.getStartOffset(), textRange.getLength() + lengthShift);\n          if(reparseable.isParsable(newTextStr, project)){\n            final ChameleonElement chameleon =\n              (ChameleonElement)Factory.createSingleLeafElement(reparseable, newFileText, textRange.getStartOffset(),\n                                                                textRange.getEndOffset() + lengthShift, charTable, file.getManager(), fileImpl);\n            ChangeUtil.replaceAllChildren((CompositeElement)parent, reparseable.parseContents(chameleon).getTreeParent());\n            return;\n          }\n          else if(reparseable instanceof IErrorCounterChameleonElementType){\n            int currentErrorLevel = ((IErrorCounterChameleonElementType)reparseable).getErrorsCount(newTextStr, project);\n            if(currentErrorLevel == IErrorCounterChameleonElementType.FATAL_ERROR){\n              prevReparseable = parent;\n            }\n            else if(Math.abs(currentErrorLevel) < Math.abs(minErrorLevel)){\n              theOnlyReparseable = bestReparseable == null;\n              bestReparseable = parent;\n              minErrorLevel = currentErrorLevel;\n              if (languageChanged) break;\n            }\n          }\n          // invalid content;\n        }\n        parent = parent.getTreeParent();\n      }\n\n      if(bestReparseable != null && !theOnlyReparseable){\n        // best reparseable available\n        final ASTNode treeElement = bestReparseable;\n        final TextRange textRange = treeElement.getTextRange();\n        final ChameleonElement chameleon =\n          (ChameleonElement)Factory.createLeafElement(bestReparseable.getElementType(), newFileText, textRange.getStartOffset(),\n                                                      textRange.getEndOffset() + lengthShift, -1, treeFileElement.getCharTable());\n        chameleon.putUserData(CharTable.CHAR_TABLE_KEY, treeFileElement.getCharTable());\n        chameleon.setTreeParent((CompositeElement)parent);\n        treeElement.replaceAllChildrenToChildrenOf(chameleon.transform(treeFileElement.getCharTable(), fileImpl.createLexer(), project).getTreeParent());\n      }\n      else{\n        //boolean leafChangeOptimized = false;\n        //Document document = PsiDocumentManager.getInstance(project).getDocument(fileImpl);\n        //if (document != null) {\n        //  int changedOffset;\n        //  synchronized (document) {\n        //    Integer offset = document.getUserData(LexerEditorHighlighter.CHANGED_TOKEN_START_OFFSET);\n        //    changedOffset = offset == null ? -1 : offset.intValue();\n        //    document.putUserData(LexerEditorHighlighter.CHANGED_TOKEN_START_OFFSET, null);\n        //  }\n        //  leafChangeOptimized = changedOffset != -1 && optimizeLeafChange(treeFileElement, newFileText, startOffset, endOffset, lengthShift, changedOffset);\n        //}\n        //if (leafChangeOptimized) {\n        //  return;\n        //}\n\n        // file reparse\n        FileType fileType = file.getFileType();\n        if (file instanceof PsiPlainTextFile){\n          fileType = StdFileTypes.PLAIN_TEXT;\n        }\n\n        final Grammar grammarByFileType = GrammarUtil.getGrammarByFileType(fileType);\n        if(grammarByFileType != null){\n          Set<String> newTaglibPrefixes = null;\n          if(file.getLanguage() == StdLanguages.JSP){\n            newTaglibPrefixes = ((JspFileViewProvider)file.getViewProvider()).getKnownTaglibPrefixes();\n          }\n          if(newTaglibPrefixes == null || newTaglibPrefixes.equals(oldTaglibPrefixes))\n            ParsingUtil.reparse(grammarByFileType, treeFileElement.getCharTable(), treeFileElement, newFileText, startOffset, endOffset, lengthShift,\n                                file.getViewProvider());\n          else makeFullParse(parent, newFileText, textLength, fileImpl, fileType);\n        }\n        else{\n          makeFullParse(parent, newFileText, textLength, fileImpl, fileType);\n        }\n      }\n    }\n    finally{\n      file.getViewProvider().contentsSynchronized();\n    }\n  }","id":33510,"modified_method":"private static void reparseRangeInternal(PsiFile file, int startOffset, int endOffset, int lengthShift, char[] newFileText){\n    Set<String> oldTaglibPrefixes = null;\n    if(file.getLanguage() == StdLanguages.JSP){\n      oldTaglibPrefixes = ((JspFileViewProvider)file.getViewProvider()).getKnownTaglibPrefixes();\n    }\n    try{\n      file.getViewProvider().beforeContentsSynchronized();\n      final PsiFileImpl fileImpl = (PsiFileImpl)file;\n      Project project = fileImpl.getProject();\n      final CharTable charTable = fileImpl.getTreeElement().getCharTable();\n      // hack\n      final int textLength = file.getTextLength() + lengthShift;\n\n      final FileElement treeFileElement = fileImpl.getTreeElement();\n\n      final ASTNode leafAtStart = treeFileElement.findLeafElementAt(startOffset);\n      final ASTNode leafAtEnd = treeFileElement.findLeafElementAt(endOffset);\n      ASTNode parent = leafAtStart != null && leafAtEnd != null ? TreeUtil.findCommonParent(leafAtStart, leafAtEnd) : treeFileElement;\n\n      int minErrorLevel = Integer.MAX_VALUE;\n      ASTNode bestReparseable = null;\n      ASTNode prevReparseable = null;\n      boolean theOnlyReparseable = false;\n      boolean unparseableChameleonDetected = false;\n\n      while(parent != null && !(parent instanceof FileElement)){\n        if(parent.getElementType() instanceof IChameleonElementType){\n          final TextRange textRange = parent.getTextRange();\n          final IChameleonElementType reparseable = (IChameleonElementType)parent.getElementType();\n          boolean languageChanged = false;\n          if(prevReparseable != null){\n            languageChanged = prevReparseable.getElementType().getLanguage() != reparseable.getLanguage();\n          }\n\n          final String newTextStr = StringFactory.createStringFromConstantArray(newFileText, textRange.getStartOffset(), textRange.getLength() + lengthShift);\n          if(reparseable.isParsable(newTextStr, project)){\n            unparseableChameleonDetected = false;\n\n            final ChameleonElement chameleon =\n              (ChameleonElement)Factory.createSingleLeafElement(reparseable, newFileText, textRange.getStartOffset(),\n                                                                textRange.getEndOffset() + lengthShift, charTable, file.getManager(), fileImpl);\n            ChangeUtil.replaceAllChildren((CompositeElement)parent, reparseable.parseContents(chameleon).getTreeParent());\n            return;\n          }\n          else if(reparseable instanceof IErrorCounterChameleonElementType){\n            unparseableChameleonDetected = false;\n\n            int currentErrorLevel = ((IErrorCounterChameleonElementType)reparseable).getErrorsCount(newTextStr, project);\n            if(currentErrorLevel == IErrorCounterChameleonElementType.FATAL_ERROR){\n              prevReparseable = parent;\n            }\n            else if(Math.abs(currentErrorLevel) < Math.abs(minErrorLevel)){\n              theOnlyReparseable = bestReparseable == null;\n              bestReparseable = parent;\n              minErrorLevel = currentErrorLevel;\n              if (languageChanged) break;\n            }\n          }\n          else {\n            unparseableChameleonDetected = true;\n          }\n          // invalid content;\n        }\n        parent = parent.getTreeParent();\n      }\n\n      if(bestReparseable != null && !theOnlyReparseable){\n        // best reparseable available\n        final ASTNode treeElement = bestReparseable;\n        final TextRange textRange = treeElement.getTextRange();\n        final ChameleonElement chameleon =\n          (ChameleonElement)Factory.createLeafElement(bestReparseable.getElementType(), newFileText, textRange.getStartOffset(),\n                                                      textRange.getEndOffset() + lengthShift, -1, treeFileElement.getCharTable());\n        chameleon.putUserData(CharTable.CHAR_TABLE_KEY, treeFileElement.getCharTable());\n        chameleon.setTreeParent((CompositeElement)parent);\n        treeElement.replaceAllChildrenToChildrenOf(chameleon.transform(treeFileElement.getCharTable(), fileImpl.createLexer(), project).getTreeParent());\n      }\n      else{\n        //boolean leafChangeOptimized = false;\n        //Document document = PsiDocumentManager.getInstance(project).getDocument(fileImpl);\n        //if (document != null) {\n        //  int changedOffset;\n        //  synchronized (document) {\n        //    Integer offset = document.getUserData(LexerEditorHighlighter.CHANGED_TOKEN_START_OFFSET);\n        //    changedOffset = offset == null ? -1 : offset.intValue();\n        //    document.putUserData(LexerEditorHighlighter.CHANGED_TOKEN_START_OFFSET, null);\n        //  }\n        //  leafChangeOptimized = changedOffset != -1 && optimizeLeafChange(treeFileElement, newFileText, startOffset, endOffset, lengthShift, changedOffset);\n        //}\n        //if (leafChangeOptimized) {\n        //  return;\n        //}\n\n        // file reparse\n        FileType fileType = file.getFileType();\n        if (file instanceof PsiPlainTextFile){\n          fileType = StdFileTypes.PLAIN_TEXT;\n        }\n\n        final Grammar grammarByFileType = GrammarUtil.getGrammarByFileType(fileType);\n        if(grammarByFileType != null){\n          Set<String> newTaglibPrefixes = null;\n          if(file.getLanguage() == StdLanguages.JSP){\n            newTaglibPrefixes = ((JspFileViewProvider)file.getViewProvider()).getKnownTaglibPrefixes();\n          }\n\n          if (!unparseableChameleonDetected && (newTaglibPrefixes == null || newTaglibPrefixes.equals(oldTaglibPrefixes))) {\n            ParsingUtil.reparse(grammarByFileType, treeFileElement.getCharTable(), treeFileElement, newFileText, startOffset, endOffset,\n                                lengthShift, file.getViewProvider());\n          }\n          else {\n            ParsingUtil.reparse(grammarByFileType, treeFileElement.getCharTable(), treeFileElement, newFileText, 0, textLength,\n                                lengthShift, file.getViewProvider());\n          }\n        }\n        else{\n          makeFullParse(parent, newFileText, textLength, fileImpl, fileType);\n        }\n      }\n    }\n    finally{\n      file.getViewProvider().contentsSynchronized();\n    }\n  }","commit_id":"0b99499e4c508e6a4575a65ec2d733c32f24fc2e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public CompositeLanguageFileViewProvider clone() {\n    final CompositeLanguageFileViewProvider viewProvider = cloneInner();\n    final PsiFileImpl psiFile = (PsiFileImpl)viewProvider.getPsi(getBaseLanguage());\n\n    // copying main tree\n    final FileElement treeClone = (FileElement)psiFile.calcTreeElement().clone(); // base language tree clone\n    psiFile.setTreeElementPointer(treeClone); // should not use setTreeElement here because cloned file still have VirtualFile (SCR17963)\n    treeClone.setPsiElement(psiFile);\n\n    final XmlText[] xmlTexts = JspImplUtil.gatherTexts((XmlFile)psiFile);\n    for (Map.Entry<Language, PsiFile> entry : myRoots.entrySet()) {\n      final PsiFile root = entry.getValue();\n      if (root instanceof PsiFileImpl && root != psiFile) {\n        final PsiFileImpl copy = (PsiFileImpl)viewProvider.getPsi(entry.getKey());\n        JspImplUtil.copyRoot((PsiFileImpl)root, xmlTexts, copy);\n      }\n    }\n    return viewProvider;\n  }","id":33511,"modified_method":"public CompositeLanguageFileViewProvider clone() {\n    final CompositeLanguageFileViewProvider viewProvider = cloneInner();\n    final PsiFileImpl psiFile = (PsiFileImpl)viewProvider.getPsi(getBaseLanguage());\n\n    // copying main tree\n    final FileElement treeClone = (FileElement)psiFile.calcTreeElement().clone(); // base language tree clone\n    psiFile.setTreeElementPointer(treeClone); // should not use setTreeElement here because cloned file still have VirtualFile (SCR17963)\n    treeClone.setPsiElement(psiFile);\n\n    final XmlText[] xmlTexts = JspImplUtil.gatherTexts((XmlFile)psiFile);\n    for (Map.Entry<Language, PsiFile> entry : myRoots.entrySet()) {\n      final PsiFile root = entry.getValue();\n      if (root instanceof PsiFileImpl && root != psiFile) {\n        final PsiFileImpl copy = (PsiFileImpl)viewProvider.getPsi(entry.getKey());\n        if (copy == null) continue; // Unreleivant language due to partial parsing.\n        JspImplUtil.copyRoot((PsiFileImpl)root, xmlTexts, copy);\n      }\n    }\n    return viewProvider;\n  }","commit_id":"0b99499e4c508e6a4575a65ec2d733c32f24fc2e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n\t * Introduced in 2.7 to allow read-only transactions to be cancelable. The default implementation disables\n\t * concurrent reads on the model. To re-enable concurrent reads, return a new {@link Object} on each call.\n\t * \n\t * Caveat: Concurrent read is problematic in EMF because proxy resolution and resource un-/loading are considered\n\t * read-only but actually change the model. This yields serious race conditions. Consider using \n\t * {@link CancelableUnitOfWork}s instead.\n\t * \n\t * @since 2.7\n\t */\n\tprotected Object getResourceLock() {\n\t\tif (resource != null) {\n\t\t\treturn (resource instanceof ISynchronizable<?>) \n\t\t\t\t\t? ((ISynchronizable<?>) resource).getLock() \n\t\t\t\t\t\t\t: resource;\n\t\t} else {\n\t\t\treturn this;\n\t\t}\n\t}","id":33512,"modified_method":"/**\n\t * Introduced in 2.7 to allow read-only transactions to be cancelable. The default implementation disables\n\t * concurrent reads on the model. To re-enable concurrent reads, return a new {@link Object} on each call.\n\t * \n\t * Caveat: Concurrent read is problematic in EMF because proxy resolution and resource un-/loading are considered\n\t * read-only but actually change the model. This yields serious race conditions. Consider using \n\t * {@link CancelableUnitOfWork}s instead.\n\t * \n\t * @since 2.7\n\t */\n\tprotected Object getResourceLock() {\n\t\treturn getResourceLock(resource);\n\t}","commit_id":"909d1bc602350a0febc8e3feb82340ce9378ae96","url":"https://github.com/eclipse/xtext"},{"original_method":"public <T> T modify(IUnitOfWork<T, XtextResource> work) {\n\t\t\tboolean isCancelable = work instanceof CancelableUnitOfWork;\n\t\t\ttry {\n\t\t\t\tXtextResource state = getState();\n\t\t\t\ttry {\n\t\t\t\t\tsynchronized (getResourceLock()) {\n\t\t\t\t\t\tacquireWriteLock();\n\t\t\t\t\t\tT exec = null;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tpotentialUpdaterCount.incrementAndGet();\n\t\t\t\t\t\t\tstate = getState();\n\t\t\t\t\t\t\tif (log.isDebugEnabled())\n\t\t\t\t\t\t\t\tlog.debug(\"write - \" + Thread.currentThread().getName());\n\t\t\t\t\t\t\texec = outdatedStateManager.exec(work, state);\n\t\t\t\t\t\t\treturn exec;\n\t\t\t\t\t\t} catch (RuntimeException e) {\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\tthrow new WrappedException(e);\n\t\t\t\t\t\t} catch (OperationCanceledError e) {\n\t\t\t\t\t\t\tthrow e.getWrapped();\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t// downgrade lock to read lock \n\t\t\t\t\t\t\t\tacquireReadLock();\n\t\t\t\t\t\t\t\treleaseWriteLock();\n\t\t\t\t\t\t\t\tensureThatStateIsNotReturned(exec, work);\n\t\t\t\t\t\t\t\tif(potentialUpdaterCount.decrementAndGet() == 0 && !(work instanceof ReconcilingUnitOfWork)) {\n\t\t\t\t\t\t\t\t\t// changes of a ReconcilingUnitOfWork will be handled when the resulting document changes are applied\n\t\t\t\t\t\t\t\t\tnotifyModelListeners(state);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (RuntimeException e) {\n\t\t\t\t\t\t\t\tif (operationCanceledManager.isOperationCanceledException(e)) {\n\t\t\t\t\t\t\t\t\tif (isCancelable)\n\t\t\t\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\treleaseReadLock();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (RuntimeException e) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (state != null)\n\t\t\t\t\t\t\tstate.reparse(get());\n\t\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\t}\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif(!(work instanceof ReconcilingUnitOfWork))\n\t\t\t\t\tcheckAndUpdateAnnotations();\n\t\t\t}\n\t\t}","id":33513,"modified_method":"public <T> T modify(IUnitOfWork<T, XtextResource> work) {\n\t\t\tboolean isCancelable = work instanceof CancelableUnitOfWork;\n\t\t\ttry {\n\t\t\t\tXtextResource state = getState();\n\t\t\t\ttry {\n\t\t\t\t\tsynchronized (getResourceLock()) {\n\t\t\t\t\t\tacquireWriteLock();\n\t\t\t\t\t\tT exec = null;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tpotentialUpdaterCount.incrementAndGet();\n\t\t\t\t\t\t\tstate = getState();\n\t\t\t\t\t\t\tif (log.isDebugEnabled())\n\t\t\t\t\t\t\t\tlog.debug(\"write - \" + Thread.currentThread().getName());\n\t\t\t\t\t\t\texec = outdatedStateManager.exec(work, state);\n\t\t\t\t\t\t\treturn exec;\n\t\t\t\t\t\t} catch (RuntimeException e) {\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\tthrow new WrappedException(e);\n\t\t\t\t\t\t} catch (OperationCanceledError e) {\n\t\t\t\t\t\t\tthrow e.getWrapped();\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t// downgrade lock to read lock \n\t\t\t\t\t\t\t\tacquireReadLock();\n\t\t\t\t\t\t\t\treleaseWriteLock();\n\t\t\t\t\t\t\t\tensureThatStateIsNotReturned(exec, work);\n\t\t\t\t\t\t\t\tif(potentialUpdaterCount.decrementAndGet() == 0 && !(work instanceof ReconcilingUnitOfWork)) {\n\t\t\t\t\t\t\t\t\t// changes of a ReconcilingUnitOfWork will be handled when the resulting document changes are applied\n\t\t\t\t\t\t\t\t\tnotifyModelListeners(state);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (RuntimeException e) {\n\t\t\t\t\t\t\t\tif (operationCanceledManager.isOperationCanceledException(e)) {\n\t\t\t\t\t\t\t\t\tif (isCancelable)\n\t\t\t\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\treleaseReadLock();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (RuntimeException e) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (state != null) {\n\t\t\t\t\t\t\tsynchronized (getResourceLock(state)) {\n\t\t\t\t\t\t\t\tacquireWriteLock();\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tstate.reparse(get());\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\treleaseWriteLock();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\t}\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif(!(work instanceof ReconcilingUnitOfWork))\n\t\t\t\t\tcheckAndUpdateAnnotations();\n\t\t\t}\n\t\t}","commit_id":"909d1bc602350a0febc8e3feb82340ce9378ae96","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n     * Retract the <code>FactHandleImpl<\/code>. If the handle has any\n     * <code>ReteTuple<\/code> matches and those tuples now have no\n     * other match, retract tuple\n     *\n     * @param handle\n     *            the <codeFactHandleImpl<\/code> being retracted\n     * @param context\n     *            The <code>PropagationContext<\/code>\n     * @param workingMemory\n     *            The working memory session.\n     */\n    public void retractObject(final InternalFactHandle handle,\n                              final PropagationContext context,\n                              final InternalWorkingMemory workingMemory) {\n        final BetaMemory memory = (BetaMemory) workingMemory.getNodeMemory( this );\n        if ( !memory.getRightTupleMemory().remove( handle ) ) {\n            return;\n        }\n\n        final Iterator it = memory.getLeftTupleMemory().iterator( handle );\n        this.constraints.updateFromFactHandle( memory.getContext(),\n                                               workingMemory,\n                                               handle );\n        for ( LeftTuple tuple = (LeftTuple) it.next(); tuple != null; tuple = (LeftTuple) it.next() ) {\n            if ( this.constraints.isAllowedCachedRight( memory.getContext(),\n                                                        tuple ) ) {\n                if ( tuple.getMatch() == handle ) {\n                    // reset the match\n                    tuple.setMatch( null );\n\n                    // find next match, remember it and break.\n                    final Iterator tupleIt = memory.getRightTupleMemory().iterator( tuple );\n                    this.constraints.updateFromTuple( memory.getContext(),\n                                                      workingMemory,\n                                                      tuple );\n\n                    for ( FactEntry entry = (FactEntry) tupleIt.next(); entry != null; entry = (FactEntry) tupleIt.next() ) {\n                        final InternalFactHandle rightHandle = entry.getFactHandle();\n                        if ( this.constraints.isAllowedCachedLeft( memory.getContext(),\n                                                                   rightHandle ) ) {\n                            tuple.setMatch( rightHandle );\n                            break;\n                        }\n                    }\n\n                    this.constraints.resetTuple( memory.getContext() );\n\n                    // if there is now no new tuple match then propagate assert.\n                    if ( tuple.getMatch() == null ) {\n                        this.sink.propagateRetractLeftTuple( tuple,\n                                                             context,\n                                                             workingMemory );\n                    }\n                }\n\n            }\n        }\n\n        this.constraints.resetFactHandle( memory.getContext() );\n    }","id":33514,"modified_method":"/**\n     * Retract the <code>FactHandleImpl<\/code>. If the handle has any\n     * <code>ReteTuple<\/code> matches and those tuples now have no\n     * other match, retract tuple\n     *\n     * @param handle\n     *            the <codeFactHandleImpl<\/code> being retracted\n     * @param context\n     *            The <code>PropagationContext<\/code>\n     * @param workingMemory\n     *            The working memory session.\n     */\n    public void retractRightTuple(final RightTuple rightTuple,\n                              final PropagationContext context,\n                              final InternalWorkingMemory workingMemory) {\n//        final BetaMemory memory = (BetaMemory) workingMemory.getNodeMemory( this );\n//        if ( !memory.getRightTupleMemory().remove( handle ) ) {\n//            return;\n//        }\n//\n//        final Iterator it = memory.getLeftTupleMemory().iterator( handle );\n//        this.constraints.updateFromFactHandle( memory.getContext(),\n//                                               workingMemory,\n//                                               handle );\n//        for ( LeftTuple tuple = (LeftTuple) it.next(); tuple != null; tuple = (LeftTuple) it.next() ) {\n//            if ( this.constraints.isAllowedCachedRight( memory.getContext(),\n//                                                        tuple ) ) {\n//                if ( tuple.getMatch() == handle ) {\n//                    // reset the match\n//                    tuple.setMatch( null );\n//\n//                    // find next match, remember it and break.\n//                    final Iterator tupleIt = memory.getRightTupleMemory().iterator( tuple );\n//                    this.constraints.updateFromTuple( memory.getContext(),\n//                                                      workingMemory,\n//                                                      tuple );\n//\n//                    for ( FactEntry entry = (FactEntry) tupleIt.next(); entry != null; entry = (FactEntry) tupleIt.next() ) {\n//                        final InternalFactHandle rightHandle = entry.getFactHandle();\n//                        if ( this.constraints.isAllowedCachedLeft( memory.getContext(),\n//                                                                   rightHandle ) ) {\n//                            tuple.setMatch( rightHandle );\n//                            break;\n//                        }\n//                    }\n//\n//                    this.constraints.resetTuple( memory.getContext() );\n//\n//                    // if there is now no new tuple match then propagate assert.\n//                    if ( tuple.getMatch() == null ) {\n//                        this.sink.propagateRetractLeftTuple( tuple,\n//                                                             context,\n//                                                             workingMemory );\n//                    }\n//                }\n//\n//            }\n//        }\n//\n//        this.constraints.resetFactHandle( memory.getContext() );\n        // assign now, so we can remove from memory before doing any possible propagations\n        final RightTuple rootBlocker = (RightTuple) rightTuple.getPrevious();\n\n        final BetaMemory memory = (BetaMemory) workingMemory.getNodeMemory( this );\n        memory.getRightTupleMemory().remove( rightTuple );\n\n        if ( rightTuple.getBlocked() == null ) {\n            return;\n        }\n\n        for ( LeftTuple leftTuple = (LeftTuple) rightTuple.getBlocked(); leftTuple != null; ) {\n            LeftTuple temp = leftTuple.getBlockedNext();\n\n            leftTuple.setBlocker( null );\n            leftTuple.setBlockedPrevious( null );\n            leftTuple.setBlockedNext( null );\n\n            this.constraints.updateFromTuple( memory.getContext(),\n                                              workingMemory,\n                                              leftTuple );\n\n            // we know that older tuples have been checked so continue previously\n            for ( RightTuple newBlocker = rootBlocker; newBlocker != null; newBlocker = (RightTuple) newBlocker.getPrevious() ) {\n                if ( this.constraints.isAllowedCachedLeft( memory.getContext(),\n                                                           newBlocker.getFactHandle() ) ) {\n                    leftTuple.setBlocker( newBlocker );\n\n                    LeftTuple blockedPrevious = newBlocker.getBlocked();\n                    if ( blockedPrevious != null ) {\n                        leftTuple.setBlockedNext( blockedPrevious );\n                        blockedPrevious.setBlockedPrevious( leftTuple );\n                    }\n                    newBlocker.setBlocked( leftTuple );\n\n                    break;\n                }\n            }\n\n            if ( leftTuple.getBlocker() == null ) {\n                // was previous blocked and not in memory, so add\n                memory.getLeftTupleMemory().add( leftTuple );\n\n                this.sink.propagateRetractLeftTuple( leftTuple,\n                                                    context,\n                                                    workingMemory );\n            }\n\n            leftTuple = temp;\n        }\n        this.constraints.resetTuple( memory.getContext() );        \n    }","commit_id":"5722e7a27def4adf597c4d7b04fcc904cbfe8eab","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Updates the given sink propagating all previously propagated tuples to it\n     *\n     */\n    public void updateSink(final LeftTupleSink sink,\n                           final PropagationContext context,\n                           final InternalWorkingMemory workingMemory) {\n        final BetaMemory memory = (BetaMemory) workingMemory.getNodeMemory( this );\n\n        final Iterator tupleIter = memory.getLeftTupleMemory().iterator();\n        for ( LeftTuple tuple = (LeftTuple) tupleIter.next(); tuple != null; tuple = (LeftTuple) tupleIter.next() ) {\n            if ( tuple.getMatch() != null ) {\n                sink.assertLeftTuple( new LeftTuple( tuple ),\n                                      context,\n                                      workingMemory );\n            }\n        }\n    }","id":33515,"modified_method":"/**\n     * Updates the given sink propagating all previously propagated tuples to it\n     *\n     */\n    public void updateSink(final LeftTupleSink sink,\n                           final PropagationContext context,\n                           final InternalWorkingMemory workingMemory) {\n//        final BetaMemory memory = (BetaMemory) workingMemory.getNodeMemory( this );\n//\n//        final Iterator tupleIter = memory.getLeftTupleMemory().iterator();\n//        for ( LeftTuple tuple = (LeftTuple) tupleIter.next(); tuple != null; tuple = (LeftTuple) tupleIter.next() ) {\n//            if ( tuple.getMatch() != null ) {\n//                sink.assertLeftTuple( new LeftTuple( tuple ),\n//                                      context,\n//                                      workingMemory );\n//            }\n//        }\n        // @FIXME\n    }","commit_id":"5722e7a27def4adf597c4d7b04fcc904cbfe8eab","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Assert a new <code>ReteTuple<\/code> from the left input. It iterates\n     * over the right <code>FactHandleImpl<\/code>'s and if any match is found,\n     * a copy of the <code>ReteTuple<\/code> is made and propagated.\n     *\n     * @param tuple\n     *            The <code>Tuple<\/code> being asserted.\n     * @param context\n     *            The <code>PropagationContext<\/code>\n     * @param workingMemory\n     *            The working memory session.\n     */\n    public void assertLeftTuple(final LeftTuple leftTuple,\n                                final PropagationContext context,\n                                final InternalWorkingMemory workingMemory) {\n        final BetaMemory memory = (BetaMemory) workingMemory.getNodeMemory( this );\n\n        if ( this.tupleMemoryEnabled ) {\n            memory.getLeftTupleMemory().add( leftTuple );\n        }\n\n        final Iterator it = memory.getRightTupleMemory().iterator( leftTuple );\n        this.constraints.updateFromTuple( memory.getContext(),\n                                          workingMemory,\n                                          leftTuple );\n        for ( FactEntry entry = (FactEntry) it.next(); entry != null; entry = (FactEntry) it.next() ) {\n            final InternalFactHandle handle = entry.getFactHandle();\n            if ( this.constraints.isAllowedCachedLeft( memory.getContext(),\n                                                       handle ) ) {\n                leftTuple.setMatch( handle );\n                break;\n            }\n        }\n\n        this.constraints.resetTuple( memory.getContext() );\n\n        if ( leftTuple.getMatch() != null ) {\n            this.sink.propagateAssertLeftTuple( leftTuple,\n                                                context,\n                                                workingMemory );\n        }\n    }","id":33516,"modified_method":"/**\n     * Assert a new <code>ReteTuple<\/code> from the left input. It iterates\n     * over the right <code>FactHandleImpl<\/code>'s and if any match is found,\n     * a copy of the <code>ReteTuple<\/code> is made and propagated.\n     *\n     * @param tuple\n     *            The <code>Tuple<\/code> being asserted.\n     * @param context\n     *            The <code>PropagationContext<\/code>\n     * @param workingMemory\n     *            The working memory session.\n     */\n    public void assertLeftTuple(final LeftTuple leftTuple,\n                                final PropagationContext context,\n                                final InternalWorkingMemory workingMemory) {        \n        final BetaMemory memory = (BetaMemory) workingMemory.getNodeMemory( this );\n        \n        this.constraints.updateFromTuple( memory.getContext(),\n                                          workingMemory,\n                                          leftTuple );\n\n        for ( RightTuple rightTuple = memory.getRightTupleMemory().getLast( leftTuple ); rightTuple != null; rightTuple = (RightTuple) rightTuple.getPrevious() ) {\n            if ( this.constraints.isAllowedCachedLeft( memory.getContext(),\n                                                       rightTuple.getFactHandle() ) ) {\n\n                leftTuple.setBlocker( rightTuple );\n\n                LeftTuple blockedPrevious = rightTuple.getBlocked();\n                if ( blockedPrevious != null ) {\n                    leftTuple.setBlockedNext( blockedPrevious );\n                    blockedPrevious.setBlockedPrevious( leftTuple );\n                }\n                rightTuple.setBlocked( leftTuple );\n\n                break;\n            }\n        }\n\n        this.constraints.resetTuple( memory.getContext() );\n\n        if ( leftTuple.getBlocker() != null ) {\n            // only add it to node memory if still need Objects to attempt to match\n            if ( this.tupleMemoryEnabled ) {\n                memory.getLeftTupleMemory().add( leftTuple );\n            }\n\n            this.sink.propagateAssertLeftTuple( leftTuple,\n                                                context,\n                                                workingMemory );\n        }        \n    }","commit_id":"5722e7a27def4adf597c4d7b04fcc904cbfe8eab","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Assert a new <code>FactHandleImpl<\/code> from the right input. If it\n     * matches any left ReteTuple's that had no matches before, propagate\n     * tuple as an assertion.\n     *\n     * @param factHandle\n     *            The <code>FactHandleImpl<\/code> being asserted.\n     * @param context\n     *            The <code>PropagationContext<\/code>\n     * @param workingMemory\n     *            The working memory session.\n     */\n    public void assertObject(final InternalFactHandle factHandle,\n                             final PropagationContext context,\n                             final InternalWorkingMemory workingMemory) {\n        final BetaMemory memory = (BetaMemory) workingMemory.getNodeMemory( this );\n        memory.getRightTupleMemory().add( factHandle );\n\n        if ( !this.tupleMemoryEnabled ) {\n            // do nothing here, as we know there are no left tuples at this stage in sequential mode.\n            return;\n        }\n\n        final Iterator it = memory.getLeftTupleMemory().iterator( factHandle );\n        this.constraints.updateFromFactHandle( memory.getContext(),\n                                               workingMemory,\n                                               factHandle );\n        for ( LeftTuple tuple = (LeftTuple) it.next(); tuple != null; tuple = (LeftTuple) it.next() ) {\n            if ( this.constraints.isAllowedCachedRight( memory.getContext(),\n                                                        tuple ) && tuple.getMatch() == null ) {\n                tuple.setMatch( factHandle );\n                this.sink.propagateAssertLeftTuple( tuple,\n                                                    context,\n                                                    workingMemory );\n            }\n        }\n\n        this.constraints.resetFactHandle( memory.getContext() );\n    }","id":33517,"modified_method":"/**\n     * Assert a new <code>FactHandleImpl<\/code> from the right input. If it\n     * matches any left ReteTuple's that had no matches before, propagate\n     * tuple as an assertion.\n     *\n     * @param factHandle\n     *            The <code>FactHandleImpl<\/code> being asserted.\n     * @param context\n     *            The <code>PropagationContext<\/code>\n     * @param workingMemory\n     *            The working memory session.\n     */\n    public void assertObject(final InternalFactHandle factHandle,\n                             final PropagationContext context,\n                             final InternalWorkingMemory workingMemory) {\n//        final BetaMemory memory = (BetaMemory) workingMemory.getNodeMemory( this );\n//        memory.getRightTupleMemory().add( factHandle );\n//\n//        if ( !this.tupleMemoryEnabled ) {\n//            // do nothing here, as we know there are no left tuples at this stage in sequential mode.\n//            return;\n//        }\n//\n//        final Iterator it = memory.getLeftTupleMemory().iterator( factHandle );\n//        this.constraints.updateFromFactHandle( memory.getContext(),\n//                                               workingMemory,\n//                                               factHandle );\n//        for ( LeftTuple tuple = (LeftTuple) it.next(); tuple != null; tuple = (LeftTuple) it.next() ) {\n//            if ( this.constraints.isAllowedCachedRight( memory.getContext(),\n//                                                        tuple ) && tuple.getMatch() == null ) {\n//                tuple.setMatch( factHandle );\n//                this.sink.propagateAssertLeftTuple( tuple,\n//                                                    context,\n//                                                    workingMemory );\n//            }\n//        }\n//\n//        this.constraints.resetFactHandle( memory.getContext() );\n        \n        final RightTuple rightTuple = new RightTuple( factHandle,\n                                                      this );\n\n        final BetaMemory memory = (BetaMemory) workingMemory.getNodeMemory( this );\n        memory.getRightTupleMemory().add( rightTuple );\n\n        if ( !this.tupleMemoryEnabled ) {\n            // do nothing here, as we know there are no left tuples at this stage in sequential mode.\n            return;\n        }\n\n        this.constraints.updateFromFactHandle( memory.getContext(),\n                                               workingMemory,\n                                               factHandle );\n        for ( LeftTuple leftTuple = memory.getLeftTupleMemory().getFirst( rightTuple ); leftTuple != null; ) {\n            // preserve next now, in case we remove this leftTuple \n            LeftTuple temp = (LeftTuple) leftTuple.getNext();\n\n            // we know that only unblocked LeftTuples are  still in the memory\n            if ( this.constraints.isAllowedCachedRight( memory.getContext(),\n                                                        leftTuple ) ) {\n                leftTuple.setBlocker( rightTuple );\n\n                LeftTuple blockedPrevious = rightTuple.getBlocked();\n                if ( blockedPrevious != null ) {\n                    leftTuple.setBlockedNext( blockedPrevious );\n                    blockedPrevious.setBlockedPrevious( leftTuple );\n                }\n                rightTuple.setBlocked( leftTuple );\n\n                // this is now blocked so remove from memory\n                memory.getLeftTupleMemory().remove( leftTuple );\n\n                if ( leftTuple.getBetaChildren() != null ) {\n                    this.sink.propagateAssertLeftTuple( leftTuple,\n                                                         context,\n                                                         workingMemory );\n                }\n            }\n\n            leftTuple = temp;\n        }\n\n        this.constraints.resetFactHandle( memory.getContext() );        \n    }","commit_id":"5722e7a27def4adf597c4d7b04fcc904cbfe8eab","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Retract the\n     * <code>ReteTuple<code>, any resulting propagated joins are also retracted.\n     *\n     * @param leftTuple\n     *            The tuple being retracted\n     * @param context\n     *            The <code>PropagationContext<\/code>\n     * @param workingMemory\n     *            The working memory session.\n     */\n    public void retractLeftTuple(final LeftTuple leftTuple,\n                                 final PropagationContext context,\n                                 final InternalWorkingMemory workingMemory) {\n        final BetaMemory memory = (BetaMemory) workingMemory.getNodeMemory( this );\n\n        // Must use the tuple in memory as it has the tuple matches count\n        final LeftTuple tuple = memory.getLeftTupleMemory().remove( leftTuple );\n        if ( tuple == null ) {\n            return;\n        }\n\n        if ( tuple.getMatch() != null ) {\n            this.sink.propagateRetractLeftTuple( tuple,\n                                                 context,\n                                                 workingMemory );\n        }\n    }","id":33518,"modified_method":"/**\n     * Retract the\n     * <code>ReteTuple<code>, any resulting propagated joins are also retracted.\n     *\n     * @param leftTuple\n     *            The tuple being retracted\n     * @param context\n     *            The <code>PropagationContext<\/code>\n     * @param workingMemory\n     *            The working memory session.\n     */\n    public void retractLeftTuple(final LeftTuple leftTuple,\n                                 final PropagationContext context,\n                                 final InternalWorkingMemory workingMemory) {\n//        final BetaMemory memory = (BetaMemory) workingMemory.getNodeMemory( this );\n//\n//        // Must use the tuple in memory as it has the tuple matches count\n//        final LeftTuple tuple = memory.getLeftTupleMemory().remove( leftTuple );\n//        if ( tuple == null ) {\n//            return;\n//        }\n//\n//        if ( tuple.getMatch() != null ) {\n//            this.sink.propagateRetractLeftTuple( tuple,\n//                                                 context,\n//                                                 workingMemory );\n//        }\n        \n        RightTuple blocker = leftTuple.getBlocker();\n        if ( blocker != null ) {\n            final BetaMemory memory = (BetaMemory) workingMemory.getNodeMemory( this );\n            memory.getLeftTupleMemory().remove( leftTuple );\n\n            this.sink.propagateRetractLeftTuple( leftTuple,\n                                                 context,\n                                                 workingMemory );\n            \n            LeftTuple previous = (LeftTuple) leftTuple.getBlockedPrevious();\n            LeftTuple next = (LeftTuple) leftTuple.getBlockedNext();\n            if ( previous != null && next != null ) {\n                //remove  from middle\n                previous.setBlockedNext( next );\n                next.setBlockedPrevious( previous );\n            } else if ( next != null ) {\n                //remove from first\n                blocker.setBlocked( next );\n                next.setBlockedPrevious( null );\n            } else if ( previous != null ) {\n                //remove from end\n                previous.setBlockedNext( null );\n            } else {\n                blocker.setBlocked( null );\n            }\n        }        \n    }","commit_id":"5722e7a27def4adf597c4d7b04fcc904cbfe8eab","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\r\n     * <pre>\r\n     *\r\n     *\r\n     *                (Cheese (price ?price1 )\r\n     *                (Cheese (price ?price2&amp;:(= ?price2 (* 2 ?price1) )\r\n     *\r\n     *\r\n     * <\/pre>\r\n     *\r\n     * @throws IntrospectionException\r\n     */\r\n    public void testPredicateConstraint() throws IntrospectionException {\r\n        final ReteooRuleBase ruleBase = (ReteooRuleBase) RuleBaseFactory.newRuleBase();\r\n        final InternalWorkingMemory workingMemory = (InternalWorkingMemory) ruleBase.newStatefulSession();\r\n\r\n        final FieldExtractor priceExtractor = cache.getExtractor( Cheese.class,\r\n                                                                  \"price\",\r\n                                                                  getClass().getClassLoader() );\r\n\r\n        Pattern pattern = new Pattern( 0,\r\n                                       new ClassObjectType( Cheese.class ) );\r\n\r\n        // Bind the extractor to a decleration\r\n        // Declarations know the pattern they derive their value form\r\n        final Declaration price1Declaration = new Declaration( \"price1\",\r\n                                                               priceExtractor,\r\n                                                               pattern );\r\n\r\n        pattern = new Pattern( 1,\r\n                               new ClassObjectType( Cheese.class ) );\r\n\r\n        // Bind the extractor to a decleration\r\n        // Declarations know the pattern they derive their value form\r\n        final Declaration price2Declaration = new Declaration( \"price2\",\r\n                                                               priceExtractor,\r\n                                                               pattern );\r\n\r\n        final PredicateExpression evaluator = new PredicateExpression() {\r\n\r\n            /**\r\n             *\r\n             */\r\n            private static final long serialVersionUID = 400L;\r\n\r\n            public boolean evaluate(Object object,\r\n                                    Tuple tuple,\r\n                                    Declaration[] previousDeclarations,\r\n                                    Declaration[] localDeclarations,\r\n                                    WorkingMemory workingMemory,\r\n                                    Object context ) {\r\n                int price1 = previousDeclarations[0].getIntValue( (InternalWorkingMemory) workingMemory,\r\n                                                                  workingMemory.getObject( tuple.get( previousDeclarations[0] ) ) );\r\n                int price2 = localDeclarations[0].getIntValue( (InternalWorkingMemory) workingMemory,\r\n                                                               object );\r\n\r\n                return (price2 == (price1 * 2));\r\n\r\n            }\r\n\r\n            public Object createContext() {\r\n                return null;\r\n            }\r\n\r\n            public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\r\n            }\r\n\r\n            public void writeExternal(ObjectOutput out) throws IOException {\r\n            }\r\n        };\r\n\r\n        final PredicateConstraint constraint1 = new PredicateConstraint( evaluator,\r\n                                                                         new Declaration[]{price1Declaration},\r\n                                                                         new Declaration[]{price2Declaration},\r\n                                                                         new String[]{} );\r\n\r\n        final Cheese cheddar0 = new Cheese( \"cheddar\",\r\n                                            5 );\r\n        final FactHandle f0 = workingMemory.insert( cheddar0 );\r\n        InstrumentedReteTuple tuple = new InstrumentedReteTuple( f0 );\r\n\r\n        final Cheese cheddar1 = new Cheese( \"cheddar\",\r\n                                            10 );\r\n        final InternalFactHandle f1 = (InternalFactHandle) workingMemory.insert( cheddar1 );\r\n\r\n        tuple = new InstrumentedReteTuple( tuple,\r\n                                           f1 );\r\n\r\n        final PredicateContextEntry context = (PredicateContextEntry) constraint1.createContextEntry();\r\n        context.updateFromTuple( workingMemory,\r\n                                 tuple );\r\n        assertTrue( constraint1.isAllowedCachedLeft( context,\r\n                                                     f1 ) );\r\n    }","id":33519,"modified_method":"/**\r\n     * <pre>\r\n     *\r\n     *\r\n     *                (Cheese (price ?price1 )\r\n     *                (Cheese (price ?price2&amp;:(= ?price2 (* 2 ?price1) )\r\n     *\r\n     *\r\n     * <\/pre>\r\n     *\r\n     * @throws IntrospectionException\r\n     */\r\n    public void testPredicateConstraint() throws IntrospectionException {\r\n        final ReteooRuleBase ruleBase = (ReteooRuleBase) RuleBaseFactory.newRuleBase();\r\n        final InternalWorkingMemory workingMemory = (InternalWorkingMemory) ruleBase.newStatefulSession();\r\n\r\n        final FieldExtractor priceExtractor = cache.getExtractor( Cheese.class,\r\n                                                                  \"price\",\r\n                                                                  getClass().getClassLoader() );\r\n\r\n        Pattern pattern = new Pattern( 0,\r\n                                       new ClassObjectType( Cheese.class ) );\r\n\r\n        // Bind the extractor to a decleration\r\n        // Declarations know the pattern they derive their value form\r\n        final Declaration price1Declaration = new Declaration( \"price1\",\r\n                                                               priceExtractor,\r\n                                                               pattern );\r\n\r\n        pattern = new Pattern( 1,\r\n                               new ClassObjectType( Cheese.class ) );\r\n\r\n        // Bind the extractor to a decleration\r\n        // Declarations know the pattern they derive their value form\r\n        final Declaration price2Declaration = new Declaration( \"price2\",\r\n                                                               priceExtractor,\r\n                                                               pattern );\r\n\r\n        final PredicateExpression evaluator = new PredicateExpression() {\r\n\r\n            /**\r\n             *\r\n             */\r\n            private static final long serialVersionUID = 400L;\r\n\r\n            public boolean evaluate(Object object,\r\n                                    Tuple tuple,\r\n                                    Declaration[] previousDeclarations,\r\n                                    Declaration[] localDeclarations,\r\n                                    WorkingMemory workingMemory,\r\n                                    Object context) {\r\n                int price1 = previousDeclarations[0].getIntValue( (InternalWorkingMemory) workingMemory,\r\n                                                                  workingMemory.getObject( tuple.get( previousDeclarations[0] ) ) );\r\n                int price2 = localDeclarations[0].getIntValue( (InternalWorkingMemory) workingMemory,\r\n                                                               object );\r\n\r\n                return (price2 == (price1 * 2));\r\n\r\n            }\r\n\r\n            public Object createContext() {\r\n                return null;\r\n            }\r\n\r\n            public void readExternal(ObjectInput in) throws IOException,\r\n                                                    ClassNotFoundException {\r\n            }\r\n\r\n            public void writeExternal(ObjectOutput out) throws IOException {\r\n            }\r\n        };\r\n\r\n        final PredicateConstraint constraint1 = new PredicateConstraint( evaluator,\r\n                                                                         new Declaration[]{price1Declaration},\r\n                                                                         new Declaration[]{price2Declaration},\r\n                                                                         new String[]{} );\r\n\r\n        final Cheese cheddar0 = new Cheese( \"cheddar\",\r\n                                            5 );\r\n        final InternalFactHandle f0 = (InternalFactHandle) workingMemory.insert( cheddar0 );\r\n        LeftTuple tuple = new LeftTuple( f0,\r\n                                         null );\r\n\r\n        final Cheese cheddar1 = new Cheese( \"cheddar\",\r\n                                            10 );\r\n        final InternalFactHandle f1 = (InternalFactHandle) workingMemory.insert( cheddar1 );\r\n\r\n        tuple = new LeftTuple( tuple,\r\n                               new RightTuple( f1,\r\n                                               null ),\r\n                               null );\r\n\r\n        final PredicateContextEntry context = (PredicateContextEntry) constraint1.createContextEntry();\r\n        context.updateFromTuple( workingMemory,\r\n                                 tuple );\r\n        assertTrue( constraint1.isAllowedCachedLeft( context,\r\n                                                     f1 ) );\r\n    }","commit_id":"c5099885b7dd94766eb24424ba14e4c00c75b1dc","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\r\n     * <pre>\r\n     *\r\n     *\r\n     *                (Cheese (price ?price )\r\n     *                (Cheese (price =(* 2 ?price) )\r\n     *                (Cheese (price &gt;(* 2 ?price) )\r\n     *\r\n     *\r\n     * <\/pre>\r\n     *\r\n     * @throws IntrospectionException\r\n     */\r\n    public void testReturnValueConstraint() throws IntrospectionException {\r\n        final ReteooRuleBase ruleBase = (ReteooRuleBase) RuleBaseFactory.newRuleBase();\r\n        final InternalWorkingMemory workingMemory = (InternalWorkingMemory) ruleBase.newStatefulSession();\r\n\r\n        final FieldExtractor priceExtractor = cache.getExtractor( Cheese.class,\r\n                                                                  \"price\",\r\n                                                                  getClass().getClassLoader() );\r\n\r\n        final Pattern pattern = new Pattern( 0,\r\n                                             new ClassObjectType( Cheese.class ) );\r\n\r\n        // Bind the extractor to a decleration\r\n        // Declarations know the pattern they derive their value form\r\n        final Declaration priceDeclaration = new Declaration( \"price1\",\r\n                                                              priceExtractor,\r\n                                                              pattern );\r\n\r\n        final ReturnValueExpression isDoubleThePrice = new ReturnValueExpression() {\r\n            /**\r\n             *\r\n             */\r\n            private static final long serialVersionUID = 400L;\r\n\r\n            public FieldValue evaluate(Object object,\r\n                                       Tuple tuple, // ?price\r\n                                       Declaration[] previousDeclarations,\r\n                                       Declaration[] localDeclarations,\r\n                                       WorkingMemory workingMemory,\r\n                                       Object context ) {\r\n                int price = ((Number) previousDeclarations[0].getValue( (InternalWorkingMemory) workingMemory,\r\n                                                                        workingMemory.getObject( tuple.get( previousDeclarations[0] ) ) )).intValue();\r\n                return FieldFactory.getFieldValue( 2 * price );\r\n\r\n            }\r\n\r\n            public Object createContext() {\r\n                return null;\r\n            }\r\n            public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\r\n\r\n            }\r\n\r\n            public void writeExternal(ObjectOutput out) throws IOException {\r\n\r\n            }\r\n        };\r\n\r\n        final ReturnValueRestriction restriction1 = new ReturnValueRestriction( priceExtractor,\r\n                                                                                isDoubleThePrice,\r\n                                                                                new Declaration[]{priceDeclaration},\r\n                                                                                new Declaration[0],\r\n                                                                                new String[0],\r\n                                                                                equals.getEvaluator( ValueType.INTEGER_TYPE, Operator.EQUAL ) );\r\n\r\n        final ReturnValueConstraint constraint1 = new ReturnValueConstraint( priceExtractor,\r\n                                                                             restriction1 );\r\n\r\n        final ReturnValueRestriction restriction2 = new ReturnValueRestriction( priceExtractor,\r\n                                                                                isDoubleThePrice,\r\n                                                                                new Declaration[]{priceDeclaration},\r\n                                                                                new Declaration[0],\r\n                                                                                new String[0],\r\n                                                                                comparables.getEvaluator( ValueType.INTEGER_TYPE, Operator.GREATER ) );\r\n\r\n        final ReturnValueConstraint constraint2 = new ReturnValueConstraint( priceExtractor,\r\n                                                                             restriction2 );\r\n\r\n        final Cheese cheddar0 = new Cheese( \"cheddar\",\r\n                                            5 );\r\n        final FactHandle f0 = workingMemory.insert( cheddar0 );\r\n\r\n        InstrumentedReteTuple tuple = new InstrumentedReteTuple( f0 );\r\n\r\n        final Cheese cheddar1 = new Cheese( \"cheddar\",\r\n                                            10 );\r\n        final InternalFactHandle f1 = (InternalFactHandle) workingMemory.insert( cheddar1 );\r\n        tuple = new InstrumentedReteTuple( tuple,\r\n                                           f1 );\r\n\r\n        final ReturnValueContextEntry context1 = (ReturnValueContextEntry) constraint1.createContextEntry();\r\n        context1.updateFromTuple( workingMemory,\r\n                                  tuple );\r\n        assertTrue( constraint1.isAllowedCachedLeft( context1,\r\n                                                     f1 ) );\r\n\r\n        final ReturnValueContextEntry context2 = (ReturnValueContextEntry) constraint2.createContextEntry();\r\n        context2.updateFromTuple( workingMemory,\r\n                                  tuple );\r\n        assertFalse( constraint2.isAllowedCachedLeft( context2,\r\n                                                      f1 ) );\r\n\r\n        final Cheese cheddar2 = new Cheese( \"cheddar\",\r\n                                            11 );\r\n\r\n        final InternalFactHandle f2 = (InternalFactHandle) workingMemory.insert( cheddar2 );\r\n\r\n        assertTrue( constraint2.isAllowedCachedLeft( context2,\r\n                                                     f2 ) );\r\n    }","id":33520,"modified_method":"/**\r\n     * <pre>\r\n     *\r\n     *\r\n     *                (Cheese (price ?price )\r\n     *                (Cheese (price =(* 2 ?price) )\r\n     *                (Cheese (price &gt;(* 2 ?price) )\r\n     *\r\n     *\r\n     * <\/pre>\r\n     *\r\n     * @throws IntrospectionException\r\n     */\r\n    public void testReturnValueConstraint() throws IntrospectionException {\r\n        final ReteooRuleBase ruleBase = (ReteooRuleBase) RuleBaseFactory.newRuleBase();\r\n        final InternalWorkingMemory workingMemory = (InternalWorkingMemory) ruleBase.newStatefulSession();\r\n\r\n        final FieldExtractor priceExtractor = cache.getExtractor( Cheese.class,\r\n                                                                  \"price\",\r\n                                                                  getClass().getClassLoader() );\r\n\r\n        final Pattern pattern = new Pattern( 0,\r\n                                             new ClassObjectType( Cheese.class ) );\r\n\r\n        // Bind the extractor to a decleration\r\n        // Declarations know the pattern they derive their value form\r\n        final Declaration priceDeclaration = new Declaration( \"price1\",\r\n                                                              priceExtractor,\r\n                                                              pattern );\r\n\r\n        final ReturnValueExpression isDoubleThePrice = new ReturnValueExpression() {\r\n            /**\r\n             *\r\n             */\r\n            private static final long serialVersionUID = 400L;\r\n\r\n            public FieldValue evaluate(Object object,\r\n                                       Tuple tuple, // ?price\r\n                                       Declaration[] previousDeclarations,\r\n                                       Declaration[] localDeclarations,\r\n                                       WorkingMemory workingMemory,\r\n                                       Object context) {\r\n                int price = ((Number) previousDeclarations[0].getValue( (InternalWorkingMemory) workingMemory,\r\n                                                                        workingMemory.getObject( tuple.get( previousDeclarations[0] ) ) )).intValue();\r\n                return FieldFactory.getFieldValue( 2 * price );\r\n\r\n            }\r\n\r\n            public Object createContext() {\r\n                return null;\r\n            }\r\n\r\n            public void readExternal(ObjectInput in) throws IOException,\r\n                                                    ClassNotFoundException {\r\n\r\n            }\r\n\r\n            public void writeExternal(ObjectOutput out) throws IOException {\r\n\r\n            }\r\n        };\r\n\r\n        final ReturnValueRestriction restriction1 = new ReturnValueRestriction( priceExtractor,\r\n                                                                                isDoubleThePrice,\r\n                                                                                new Declaration[]{priceDeclaration},\r\n                                                                                new Declaration[0],\r\n                                                                                new String[0],\r\n                                                                                equals.getEvaluator( ValueType.INTEGER_TYPE,\r\n                                                                                                     Operator.EQUAL ) );\r\n\r\n        final ReturnValueConstraint constraint1 = new ReturnValueConstraint( priceExtractor,\r\n                                                                             restriction1 );\r\n\r\n        final ReturnValueRestriction restriction2 = new ReturnValueRestriction( priceExtractor,\r\n                                                                                isDoubleThePrice,\r\n                                                                                new Declaration[]{priceDeclaration},\r\n                                                                                new Declaration[0],\r\n                                                                                new String[0],\r\n                                                                                comparables.getEvaluator( ValueType.INTEGER_TYPE,\r\n                                                                                                          Operator.GREATER ) );\r\n\r\n        final ReturnValueConstraint constraint2 = new ReturnValueConstraint( priceExtractor,\r\n                                                                             restriction2 );\r\n\r\n        final Cheese cheddar0 = new Cheese( \"cheddar\",\r\n                                            5 );\r\n        final InternalFactHandle f0 = (InternalFactHandle) workingMemory.insert( cheddar0 );\r\n\r\n        LeftTuple tuple = new LeftTuple( f0,\r\n                                         null );\r\n\r\n        final Cheese cheddar1 = new Cheese( \"cheddar\",\r\n                                            10 );\r\n        final InternalFactHandle f1 = (InternalFactHandle) workingMemory.insert( cheddar1 );\r\n        tuple = new LeftTuple( tuple,\r\n                               new RightTuple( f1,\r\n                                               null ),\r\n                               null );\r\n\r\n        final ReturnValueContextEntry context1 = (ReturnValueContextEntry) constraint1.createContextEntry();\r\n        context1.updateFromTuple( workingMemory,\r\n                                  tuple );\r\n        assertTrue( constraint1.isAllowedCachedLeft( context1,\r\n                                                     f1 ) );\r\n\r\n        final ReturnValueContextEntry context2 = (ReturnValueContextEntry) constraint2.createContextEntry();\r\n        context2.updateFromTuple( workingMemory,\r\n                                  tuple );\r\n        assertFalse( constraint2.isAllowedCachedLeft( context2,\r\n                                                      f1 ) );\r\n\r\n        final Cheese cheddar2 = new Cheese( \"cheddar\",\r\n                                            11 );\r\n\r\n        final InternalFactHandle f2 = (InternalFactHandle) workingMemory.insert( cheddar2 );\r\n\r\n        assertTrue( constraint2.isAllowedCachedLeft( context2,\r\n                                                     f2 ) );\r\n    }","commit_id":"c5099885b7dd94766eb24424ba14e4c00c75b1dc","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\r\n     * Assert a new <code>FactHandleImpl<\/code> from the right input. If it\r\n     * matches any left ReteTuple's that already has propagations then those\r\n     * propagations are retracted.\r\n     *\r\n     * @param factHandle\r\n     *            The <code>FactHandleImpl<\/code> being asserted.\r\n     * @param context\r\n     *            The <code>PropagationContext<\/code>\r\n     * @param workingMemory\r\n     *            The working memory seesion.\r\n     */\r\n    public void assertObject(final InternalFactHandle factHandle,\r\n                             final PropagationContext context,\r\n                             final InternalWorkingMemory workingMemory) {\r\n        final RightTuple rightTuple = new RightTuple( factHandle,\r\n                                                      this );\r\n\r\n        final BetaMemory memory = (BetaMemory) workingMemory.getNodeMemory( this );\r\n        memory.getRightTupleMemory().add( rightTuple );\r\n\r\n        if ( !this.tupleMemoryEnabled ) {\r\n            // do nothing here, as we know there are no left tuples at this stage in sequential mode.\r\n            return;\r\n        }\r\n\r\n        this.constraints.updateFromFactHandle( memory.getContext(),\r\n                                               workingMemory,\r\n                                               factHandle );\r\n        for ( LeftTuple leftTuple = memory.getLeftTupleMemory().getFirst( rightTuple ); leftTuple != null; ) {\r\n            // preserve next now, in case we remove this leftTuple \r\n            LeftTuple temp = (LeftTuple) leftTuple.getNext();\r\n\r\n            // we know that only unblocked LeftTuples are  still in the memory\r\n            if ( this.constraints.isAllowedCachedRight( memory.getContext(),\r\n                                                        leftTuple ) ) {\r\n                leftTuple.setBlocker( rightTuple );\r\n\r\n                LeftTuple blockedPrevious = rightTuple.getBlocked();\r\n                if ( blockedPrevious != null ) {\r\n                    leftTuple.setBlockedNext( blockedPrevious );\r\n                    blockedPrevious.setBlockedPrevious( leftTuple );\r\n                }\r\n                rightTuple.setBlocked( leftTuple );\r\n\r\n                // this is now blocked so remove from memory\r\n                memory.getLeftTupleMemory().remove( leftTuple );\r\n\r\n                if ( leftTuple.getBetaChildren() != null ) {\r\n                    this.sink.propagateRetractLeftTuple( leftTuple,\r\n                                                         context,\r\n                                                         workingMemory );\r\n                }\r\n            }\r\n\r\n            leftTuple = temp;\r\n        }\r\n\r\n        this.constraints.resetFactHandle( memory.getContext() );\r\n    }","id":33521,"modified_method":"/**\r\n     * Assert a new <code>FactHandleImpl<\/code> from the right input. If it\r\n     * matches any left ReteTuple's that already has propagations then those\r\n     * propagations are retracted.\r\n     *\r\n     * @param factHandle\r\n     *            The <code>FactHandleImpl<\/code> being asserted.\r\n     * @param context\r\n     *            The <code>PropagationContext<\/code>\r\n     * @param workingMemory\r\n     *            The working memory seesion.\r\n     */\r\n    public void assertObject(final InternalFactHandle factHandle,\r\n                             final PropagationContext context,\r\n                             final InternalWorkingMemory workingMemory) {\r\n        final RightTuple rightTuple = new RightTuple( factHandle,\r\n                                                      this );\r\n\r\n        final BetaMemory memory = (BetaMemory) workingMemory.getNodeMemory( this );\r\n        memory.getRightTupleMemory().add( rightTuple );\r\n\r\n        if ( !this.tupleMemoryEnabled ) {\r\n            // do nothing here, as we know there are no left tuples at this stage in sequential mode.\r\n            return;\r\n        }\r\n\r\n        this.constraints.updateFromFactHandle( memory.getContext(),\r\n                                               workingMemory,\r\n                                               factHandle );\r\n        for ( LeftTuple leftTuple = memory.getLeftTupleMemory().getFirst( rightTuple ); leftTuple != null; ) {\r\n            // preserve next now, in case we remove this leftTuple \r\n            LeftTuple temp = (LeftTuple) leftTuple.getNext();\r\n\r\n            // we know that only unblocked LeftTuples are  still in the memory\r\n            if ( this.constraints.isAllowedCachedRight( memory.getContext(),\r\n                                                        leftTuple ) ) {\r\n                leftTuple.setBlocker( rightTuple );\r\n\r\n                LeftTuple blockedPrevious = rightTuple.getBlocked();\r\n                if ( blockedPrevious != null ) {\r\n                    leftTuple.setBlockedNext( blockedPrevious );\r\n                    blockedPrevious.setBlockedPrevious( leftTuple );\r\n                }\r\n                rightTuple.setBlocked( leftTuple );\r\n\r\n                // this is now blocked so remove from memory\r\n                memory.getLeftTupleMemory().remove( leftTuple );\r\n\r\n                this.sink.propagateRetractLeftTuple( leftTuple,\r\n                                                     context,\r\n                                                     workingMemory );\r\n            }\r\n\r\n            leftTuple = temp;\r\n        }\r\n\r\n        this.constraints.resetFactHandle( memory.getContext() );\r\n    }","commit_id":"c5099885b7dd94766eb24424ba14e4c00c75b1dc","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\r\n     * Assert a new <code>Tuple<\/code>.\r\n     *\r\n     * @param tuple\r\n     *            The <code>Tuple<\/code> being asserted.\r\n     * @param workingMemory\r\n     *            The working memory seesion.\r\n     * @throws AssertionException\r\n     *             If an error occurs while asserting.\r\n     */\r\n    public void assertLeftTuple(final LeftTuple tuple,\r\n                                final PropagationContext context,\r\n                                final InternalWorkingMemory workingMemory) {\r\n        final EvalMemory memory = (EvalMemory) workingMemory.getNodeMemory( this );\r\n\r\n        final boolean allowed = this.condition.isAllowed( tuple,\r\n                                                          workingMemory,\r\n                                                          memory.context );\r\n\r\n        if ( allowed ) {\r\n            if ( this.tupleMemoryEnabled ) {\r\n                memory.tupleMemory.add( tuple );\r\n            }\r\n\r\n            this.sink.propagateAssertLeftTuple( tuple,\r\n                                                context,\r\n                                                workingMemory );\r\n        }\r\n    }","id":33522,"modified_method":"/**\r\n     * Assert a new <code>Tuple<\/code>.\r\n     *\r\n     * @param leftTuple\r\n     *            The <code>Tuple<\/code> being asserted.\r\n     * @param workingMemory\r\n     *            The working memory seesion.\r\n     * @throws AssertionException\r\n     *             If an error occurs while asserting.\r\n     */\r\n    public void assertLeftTuple(final LeftTuple leftTuple,\r\n                                final PropagationContext context,\r\n                                final InternalWorkingMemory workingMemory) {\r\n        final EvalMemory memory = (EvalMemory) workingMemory.getNodeMemory( this );\r\n\r\n        final boolean allowed = this.condition.isAllowed( leftTuple,\r\n                                                          workingMemory,\r\n                                                          memory.context );\r\n\r\n        if ( allowed ) {\r\n            if ( this.tupleMemoryEnabled ) {\r\n                memory.tupleMemory.add( leftTuple );\r\n            }\r\n\r\n            this.sink.propagateAssertLeftTuple( leftTuple,\r\n                                                context,\r\n                                                workingMemory );\r\n        }\r\n    }","commit_id":"a2fd19828c9f14a3599bfd5a186c7652791a633a","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void retractLeftTuple(final LeftTuple tuple,\r\n                                 final PropagationContext context,\r\n                                 final InternalWorkingMemory workingMemory) {\r\n        final EvalMemory memory = (EvalMemory) workingMemory.getNodeMemory( this );\r\n\r\n        // can we improve that?\r\n        final LeftTuple memTuple = memory.tupleMemory.remove( tuple );\r\n        if ( memTuple != null ) {\r\n            this.sink.propagateRetractLeftTuple( memTuple,\r\n                                                 context,\r\n                                                 workingMemory );\r\n        }\r\n    }","id":33523,"modified_method":"public void retractLeftTuple(final LeftTuple leftTuple,\r\n                                 final PropagationContext context,\r\n                                 final InternalWorkingMemory workingMemory) {\r\n        final EvalMemory memory = (EvalMemory) workingMemory.getNodeMemory( this );\r\n\r\n        memory.tupleMemory.remove( leftTuple );\r\n        this.sink.propagateRetractLeftTuple( leftTuple,\r\n                                             context,\r\n                                             workingMemory );\r\n    }","commit_id":"a2fd19828c9f14a3599bfd5a186c7652791a633a","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public Object createMemory(final RuleBaseConfiguration config) {\r\n        return new EvalMemory( this.tupleMemoryEnabled,\r\n                               this.condition.createContext() );\r\n    }","id":33524,"modified_method":"public Object createMemory(final RuleBaseConfiguration config) {\r\n        return new EvalMemory( this.condition.createContext() );\r\n    }","commit_id":"3e16227adb647b4ef58376d255e544e930ed06f0","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void modifyLeftTuple(LeftTuple leftTuple,\r\n                                PropagationContext context,\r\n                                InternalWorkingMemory workingMemory) {\r\n        final EvalMemory memory = (EvalMemory) workingMemory.getNodeMemory( this );\r\n        boolean wasPropagated = false;\r\n\r\n        if ( memory.tupleMemory.contains( leftTuple ) ) {\r\n            memory.tupleMemory.remove( leftTuple );\r\n            wasPropagated = true;\r\n        }\r\n        final boolean allowed = this.condition.isAllowed( leftTuple,\r\n                                                          workingMemory,\r\n                                                          memory.context );\r\n\r\n        if ( allowed ) {\r\n            // re-add tuple to the end of the list\r\n            memory.tupleMemory.add( leftTuple );\r\n            if ( wasPropagated ) {\r\n                // modify\r\n                this.sink.propagateModifyChildLeftTuple( leftTuple,\r\n                                                         context,\r\n                                                         workingMemory,\r\n                                                         this.tupleMemoryEnabled );\r\n            } else {\r\n                // assert\r\n                this.sink.propagateAssertLeftTuple( leftTuple,\r\n                                                    context,\r\n                                                    workingMemory,\r\n                                                    this.tupleMemoryEnabled );\r\n            }\r\n        } else {\r\n            if( wasPropagated ) {\r\n                // retract\r\n                this.sink.propagateRetractLeftTuple( leftTuple,\r\n                                                     context,\r\n                                                     workingMemory );\r\n            }\r\n            // else do nothing\r\n        }\r\n    }","id":33525,"modified_method":"public void modifyLeftTuple(LeftTuple leftTuple,\r\n                                PropagationContext context,\r\n                                InternalWorkingMemory workingMemory) {\r\n        final EvalMemory memory = (EvalMemory) workingMemory.getNodeMemory( this );\r\n        boolean wasPropagated = leftTuple.firstChild != null;\r\n\r\n        final boolean allowed = this.condition.isAllowed( leftTuple,\r\n                                                          workingMemory,\r\n                                                          memory.context );\r\n\r\n        if ( allowed ) {\r\n            if ( wasPropagated ) {\r\n                // modify\r\n                this.sink.propagateModifyChildLeftTuple( leftTuple,\r\n                                                         context,\r\n                                                         workingMemory,\r\n                                                         this.tupleMemoryEnabled );\r\n            } else {\r\n                // assert\r\n                this.sink.propagateAssertLeftTuple( leftTuple,\r\n                                                    context,\r\n                                                    workingMemory,\r\n                                                    this.tupleMemoryEnabled );\r\n            }\r\n        } else {\r\n            if ( wasPropagated ) {\r\n                // retract\r\n                this.sink.propagateRetractLeftTuple( leftTuple,\r\n                                                     context,\r\n                                                     workingMemory );\r\n            }\r\n            // else do nothing\r\n        }\r\n    }","commit_id":"3e16227adb647b4ef58376d255e544e930ed06f0","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void updateSink(final LeftTupleSink sink,\r\n                           final PropagationContext context,\r\n                           final InternalWorkingMemory workingMemory) {\r\n\r\n        final EvalMemory memory = (EvalMemory) workingMemory.getNodeMemory( this );\r\n\r\n        final Iterator it = memory.tupleMemory.iterator();\r\n        for ( LeftTuple tuple = (LeftTuple) it.next(); tuple != null; tuple = (LeftTuple) it.next() ) {\r\n            sink.assertLeftTuple( tuple,\r\n                                  context,\r\n                                  workingMemory );\r\n        }\r\n    }","id":33526,"modified_method":"public void updateSink(final LeftTupleSink sink,\r\n                           final PropagationContext context,\r\n                           final InternalWorkingMemory workingMemory) {\r\n        final LeftTupleSinkUpdateAdapter adapter = new LeftTupleSinkUpdateAdapter( this,\r\n                                                                                   sink,\r\n                                                                                   condition );\r\n        this.tupleSource.updateSink( adapter,\r\n                                     context,\r\n                                     workingMemory );\r\n    }","commit_id":"3e16227adb647b4ef58376d255e544e930ed06f0","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void writeExternal(ObjectOutput out) throws IOException {\r\n            out.writeObject( tupleMemory );\r\n            out.writeObject( context );\r\n        }","id":33527,"modified_method":"public void writeExternal(ObjectOutput out) throws IOException {\r\n            out.writeObject( context );\r\n        }","commit_id":"3e16227adb647b4ef58376d255e544e930ed06f0","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\r\n     * Assert a new <code>Tuple<\/code>.\r\n     *\r\n     * @param leftTuple\r\n     *            The <code>Tuple<\/code> being asserted.\r\n     * @param workingMemory\r\n     *            The working memory seesion.\r\n     * @throws AssertionException\r\n     *             If an error occurs while asserting.\r\n     */\r\n    public void assertLeftTuple(final LeftTuple leftTuple,\r\n                                final PropagationContext context,\r\n                                final InternalWorkingMemory workingMemory) {\r\n        final EvalMemory memory = (EvalMemory) workingMemory.getNodeMemory( this );\r\n\r\n        final boolean allowed = this.condition.isAllowed( leftTuple,\r\n                                                          workingMemory,\r\n                                                          memory.context );\r\n\r\n        if ( allowed ) {\r\n            if ( this.tupleMemoryEnabled ) {\r\n                memory.tupleMemory.add( leftTuple );\r\n            }\r\n\r\n            this.sink.propagateAssertLeftTuple( leftTuple,\r\n                                                context,\r\n                                                workingMemory,\r\n                                                this.tupleMemoryEnabled );\r\n        }\r\n    }","id":33528,"modified_method":"/**\r\n     * Assert a new <code>Tuple<\/code>.\r\n     *\r\n     * @param leftTuple\r\n     *            The <code>Tuple<\/code> being asserted.\r\n     * @param workingMemory\r\n     *            The working memory seesion.\r\n     * @throws AssertionException\r\n     *             If an error occurs while asserting.\r\n     */\r\n    public void assertLeftTuple(final LeftTuple leftTuple,\r\n                                final PropagationContext context,\r\n                                final InternalWorkingMemory workingMemory) {\r\n        final EvalMemory memory = (EvalMemory) workingMemory.getNodeMemory( this );\r\n\r\n        final boolean allowed = this.condition.isAllowed( leftTuple,\r\n                                                          workingMemory,\r\n                                                          memory.context );\r\n\r\n        if ( allowed ) {\r\n            this.sink.propagateAssertLeftTuple( leftTuple,\r\n                                                context,\r\n                                                workingMemory,\r\n                                                this.tupleMemoryEnabled );\r\n        }\r\n    }","commit_id":"3e16227adb647b4ef58376d255e544e930ed06f0","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public EvalMemory(final boolean tupleMemoryEnabled,\r\n                          final Object context) {\r\n            this.context = context;\r\n            if ( tupleMemoryEnabled ) {\r\n                this.tupleMemory = new LeftTupleList();\r\n            }\r\n        }","id":33529,"modified_method":"public EvalMemory(final Object context) {\r\n            this.context = context;\r\n        }","commit_id":"3e16227adb647b4ef58376d255e544e930ed06f0","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void readExternal(ObjectInput in) throws IOException,\r\n                                                ClassNotFoundException {\r\n            tupleMemory = (LeftTupleList) in.readObject();\r\n            context = in.readObject();\r\n        }","id":33530,"modified_method":"public void readExternal(ObjectInput in) throws IOException,\r\n                                                ClassNotFoundException {\r\n            context = in.readObject();\r\n        }","commit_id":"3e16227adb647b4ef58376d255e544e930ed06f0","url":"https://github.com/droolsjbpm/drools"},{"original_method":"protected void doRemove(final RuleRemovalContext context,\r\n                            final ReteooBuilder builder,\r\n                            final BaseNode node,\r\n                            final InternalWorkingMemory[] workingMemories) {\r\n        context.visitTupleSource( this );\r\n        if ( !node.isInUse() ) {\r\n            removeTupleSink( (LeftTupleSink) node );\r\n        }\r\n\r\n        if ( !this.isInUse() ) {\r\n            for ( int i = 0, length = workingMemories.length; i < length; i++ ) {\r\n                EvalMemory memory = (EvalMemory) workingMemories[i].getNodeMemory( this );\r\n                Iterator it = memory.getLeftTupleMemory().iterator();\r\n                for ( LeftTuple leftTuple = (LeftTuple) it.next(); leftTuple != null; leftTuple = (LeftTuple) it.next() ) {\r\n                    leftTuple.unlinkFromLeftParent();\r\n                    leftTuple.unlinkFromRightParent();\r\n                }\r\n                workingMemories[i].clearNodeMemory( this );\r\n            }\r\n        }\r\n\r\n        if ( !context.alreadyVisited( this.tupleSource ) ) {\r\n            this.tupleSource.remove( context,\r\n                                     builder,\r\n                                     this,\r\n                                     workingMemories );\r\n        }\r\n    }","id":33531,"modified_method":"protected void doRemove(final RuleRemovalContext context,\r\n                            final ReteooBuilder builder,\r\n                            final BaseNode node,\r\n                            final InternalWorkingMemory[] workingMemories) {\r\n        context.visitTupleSource( this );\r\n        if ( !node.isInUse() ) {\r\n            removeTupleSink( (LeftTupleSink) node );\r\n        }\r\n\r\n        if ( !this.isInUse() ) {\r\n            for ( int i = 0, length = workingMemories.length; i < length; i++ ) {\r\n                workingMemories[i].clearNodeMemory( this );\r\n            }\r\n        }\r\n\r\n        if ( !context.alreadyVisited( this.tupleSource ) ) {\r\n            this.tupleSource.remove( context,\r\n                                     builder,\r\n                                     this,\r\n                                     workingMemories );\r\n        }\r\n    }","commit_id":"3e16227adb647b4ef58376d255e544e930ed06f0","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void retractLeftTuple(final LeftTuple leftTuple,\r\n                                 final PropagationContext context,\r\n                                 final InternalWorkingMemory workingMemory) {\r\n        final EvalMemory memory = (EvalMemory) workingMemory.getNodeMemory( this );\r\n\r\n        memory.tupleMemory.remove( leftTuple );\r\n        this.sink.propagateRetractLeftTuple( leftTuple,\r\n                                             context,\r\n                                             workingMemory );\r\n    }","id":33532,"modified_method":"public void retractLeftTuple(final LeftTuple leftTuple,\r\n                                 final PropagationContext context,\r\n                                 final InternalWorkingMemory workingMemory) {\r\n        if ( leftTuple.firstChild != null ) {\r\n            this.sink.propagateRetractLeftTuple( leftTuple,\r\n                                                 context,\r\n                                                 workingMemory );\r\n        }\r\n    }","commit_id":"3e16227adb647b4ef58376d255e544e930ed06f0","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testAssertedAllowedThenRetract() throws FactException {\r\n        final MockEvalCondition eval = new MockEvalCondition( true );\r\n\r\n        // Create a test node that always returns false \r\n        final EvalConditionNode node = new EvalConditionNode( 1,\r\n                                                              new MockTupleSource( 15 ),\r\n                                                              eval,\r\n                                                              buildContext );\r\n\r\n        final MockLeftTupleSink sink = new MockLeftTupleSink();\r\n        node.addTupleSink( sink );\r\n\r\n        // Create the Tuple\r\n        final DefaultFactHandle f0 = new DefaultFactHandle( 0,\r\n                                                            \"stilton\" );\r\n        final LeftTuple tuple0 = new LeftTuple( f0,\r\n                                                sink,\r\n                                                true );\r\n\r\n        // Tuple should pass and propagate \r\n        node.assertLeftTuple( tuple0,\r\n                              this.context,\r\n                              this.workingMemory );\r\n\r\n        // we create and retract two tuples, checking the linkedtuples is null for JBRULES-246 \"NPE on retract()\"        \r\n        // Create the Tuple\r\n        final DefaultFactHandle f1 = new DefaultFactHandle( 1,\r\n                                                            \"cheddar\" );\r\n        final LeftTuple tuple1 = new LeftTuple( f1,\r\n                                                sink,\r\n                                                true );\r\n\r\n        // Tuple should pass and propagate \r\n        node.assertLeftTuple( tuple1,\r\n                              this.context,\r\n                              this.workingMemory );\r\n\r\n        // Check memory was populated\r\n        final EvalMemory memory = (EvalMemory) this.workingMemory.getNodeMemory( node );\r\n\r\n        assertEquals( 2,\r\n                      memory.tupleMemory.size() );\r\n        assertTrue( memory.tupleMemory.contains( tuple0 ) );\r\n        assertTrue( memory.tupleMemory.contains( tuple1 ) );\r\n\r\n        // make sure assertions were propagated\r\n        assertEquals( 2,\r\n                      sink.getAsserted().size() );\r\n\r\n        // Now test that the fact is retracted correctly\r\n        node.retractLeftTuple( tuple0,\r\n                               this.context,\r\n                               this.workingMemory );\r\n\r\n        // Now test that the fact is retracted correctly\r\n        assertEquals( 1,\r\n                      memory.tupleMemory.size() );\r\n\r\n        assertTrue( memory.tupleMemory.contains( tuple1 ) );\r\n\r\n        // make sure retractions were propagated\r\n        assertEquals( 1,\r\n                      sink.getRetracted().size() );\r\n\r\n        // Now test that the fact is retracted correctly\r\n        node.retractLeftTuple( tuple1,\r\n                               this.context,\r\n                               this.workingMemory );\r\n\r\n        // Now test that the fact is retracted correctly\r\n        assertEquals( 0,\r\n                      memory.tupleMemory.size() );\r\n\r\n        // make sure retractions were propagated\r\n        assertEquals( 2,\r\n                      sink.getRetracted().size() );\r\n    }","id":33533,"modified_method":"public void testAssertedAllowedThenRetract() throws FactException {\r\n        final MockEvalCondition eval = new MockEvalCondition( true );\r\n\r\n        // Create a test node that always returns false \r\n        final EvalConditionNode node = new EvalConditionNode( 1,\r\n                                                              new MockTupleSource( 15 ),\r\n                                                              eval,\r\n                                                              buildContext );\r\n\r\n        final MockLeftTupleSink sink = new MockLeftTupleSink();\r\n        node.addTupleSink( sink );\r\n\r\n        // Create the Tuple\r\n        final DefaultFactHandle f0 = new DefaultFactHandle( 0,\r\n                                                            \"stilton\" );\r\n        final LeftTuple tuple0 = new LeftTuple( f0,\r\n                                                sink,\r\n                                                true );\r\n\r\n        // Tuple should pass and propagate \r\n        node.assertLeftTuple( tuple0,\r\n                              this.context,\r\n                              this.workingMemory );\r\n\r\n        // we create and retract two tuples, checking the linkedtuples is null for JBRULES-246 \"NPE on retract()\"        \r\n        // Create the Tuple\r\n        final DefaultFactHandle f1 = new DefaultFactHandle( 1,\r\n                                                            \"cheddar\" );\r\n        final LeftTuple tuple1 = new LeftTuple( f1,\r\n                                                sink,\r\n                                                true );\r\n\r\n        // Tuple should pass and propagate \r\n        node.assertLeftTuple( tuple1,\r\n                              this.context,\r\n                              this.workingMemory );\r\n\r\n        // make sure assertions were propagated\r\n        assertEquals( 2,\r\n                      sink.getAsserted().size() );\r\n\r\n        // Now test that the fact is retracted correctly\r\n        node.retractLeftTuple( tuple0,\r\n                               this.context,\r\n                               this.workingMemory );\r\n\r\n        // make sure retractions were propagated\r\n        assertEquals( 1,\r\n                      sink.getRetracted().size() );\r\n\r\n        // Now test that the fact is retracted correctly\r\n        node.retractLeftTuple( tuple1,\r\n                               this.context,\r\n                               this.workingMemory );\r\n\r\n        // make sure retractions were propagated\r\n        assertEquals( 2,\r\n                      sink.getRetracted().size() );\r\n    }","commit_id":"3e16227adb647b4ef58376d255e544e930ed06f0","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testAssertedNotAllowed() throws FactException {\r\n        final MockEvalCondition eval = new MockEvalCondition( false );\r\n\r\n        // Create a test node that always returns false \r\n        final EvalConditionNode node = new EvalConditionNode( 1,\r\n                                                              new MockTupleSource( 15 ),\r\n                                                              eval,\r\n                                                              buildContext );\r\n\r\n        final MockLeftTupleSink sink = new MockLeftTupleSink();\r\n        node.addTupleSink( sink );\r\n\r\n        // Create the Tuple\r\n        final DefaultFactHandle f0 = new DefaultFactHandle( 0,\r\n                                                            \"stilton\" );\r\n        final LeftTuple tuple0 = new LeftTuple( f0,\r\n                                                sink,\r\n                                                true );\r\n\r\n        // Tuple should fail and not propagate\r\n        node.assertLeftTuple( tuple0,\r\n                              this.context,\r\n                              this.workingMemory );\r\n\r\n        // Create the Tuple\r\n        final DefaultFactHandle f1 = new DefaultFactHandle( 1,\r\n                                                            \"cheddar\" );\r\n        final LeftTuple tuple1 = new LeftTuple( f1,\r\n                                                sink,\r\n                                                true );\r\n\r\n        // Tuple should fail and not propagate \r\n        node.assertLeftTuple( tuple1,\r\n                              this.context,\r\n                              this.workingMemory );\r\n\r\n        // Check memory was not populated\r\n        final EvalMemory memory = (EvalMemory) this.workingMemory.getNodeMemory( node );\r\n\r\n        assertEquals( 0,\r\n                      memory.tupleMemory.size() );\r\n\r\n        // test no propagations\r\n        assertEquals( 0,\r\n                      sink.getAsserted().size() );\r\n        assertEquals( 0,\r\n                      sink.getRetracted().size() );\r\n    }","id":33534,"modified_method":"public void testAssertedNotAllowed() throws FactException {\r\n        final MockEvalCondition eval = new MockEvalCondition( false );\r\n\r\n        // Create a test node that always returns false \r\n        final EvalConditionNode node = new EvalConditionNode( 1,\r\n                                                              new MockTupleSource( 15 ),\r\n                                                              eval,\r\n                                                              buildContext );\r\n\r\n        final MockLeftTupleSink sink = new MockLeftTupleSink();\r\n        node.addTupleSink( sink );\r\n\r\n        // Create the Tuple\r\n        final DefaultFactHandle f0 = new DefaultFactHandle( 0,\r\n                                                            \"stilton\" );\r\n        final LeftTuple tuple0 = new LeftTuple( f0,\r\n                                                sink,\r\n                                                true );\r\n\r\n        // Tuple should fail and not propagate\r\n        node.assertLeftTuple( tuple0,\r\n                              this.context,\r\n                              this.workingMemory );\r\n\r\n        // Create the Tuple\r\n        final DefaultFactHandle f1 = new DefaultFactHandle( 1,\r\n                                                            \"cheddar\" );\r\n        final LeftTuple tuple1 = new LeftTuple( f1,\r\n                                                sink,\r\n                                                true );\r\n\r\n        // Tuple should fail and not propagate \r\n        node.assertLeftTuple( tuple1,\r\n                              this.context,\r\n                              this.workingMemory );\r\n\r\n        // Check memory was not populated\r\n        final EvalMemory memory = (EvalMemory) this.workingMemory.getNodeMemory( node );\r\n\r\n        // test no propagations\r\n        assertEquals( 0,\r\n                      sink.getAsserted().size() );\r\n        assertEquals( 0,\r\n                      sink.getRetracted().size() );\r\n    }","commit_id":"3e16227adb647b4ef58376d255e544e930ed06f0","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\r\n     * If a eval allows an incoming Object, then the Object MUST be\r\n     * propagated. This tests that the memory is updated\r\n     * \r\n     * @throws FactException\r\n     */\r\n    public void testDoRemove() throws FactException {\r\n        final MockEvalCondition eval = new MockEvalCondition( true );\r\n\r\n        final EvalConditionNode parent = new EvalConditionNode( 1,\r\n                                                                new MockTupleSource( 15 ),\r\n                                                                eval,\r\n                                                                buildContext );\r\n\r\n        // Create a test node that always returns false \r\n        final EvalConditionNode node = new EvalConditionNode( 2,\r\n                                                              parent,\r\n                                                              eval,\r\n                                                              buildContext );\r\n\r\n        parent.addTupleSink( node );\r\n\r\n        final MockLeftTupleSink sink = new MockLeftTupleSink();\r\n        node.addTupleSink( sink );\r\n\r\n        // Create the Tuple\r\n        final DefaultFactHandle f0 = new DefaultFactHandle( 0,\r\n                                                            \"stilton\" );\r\n        // an eval node always has at least a LIAN before it, so, tuples that reach it \r\n        // always have at least one tuple parent\r\n        final LeftTuple parentTuple = new LeftTuple( f0,\r\n                                                     null,\r\n                                                     true );\r\n        final LeftTuple tuple0 = new LeftTuple( parentTuple,\r\n                                                sink,\r\n                                                true );\r\n\r\n        // Tuple should pass and propagate \r\n        node.assertLeftTuple( tuple0,\r\n                              this.context,\r\n                              this.workingMemory );\r\n\r\n        // Check memory was populated\r\n        EvalMemory memory = (EvalMemory) this.workingMemory.getNodeMemory( node );\r\n\r\n        assertEquals( 1,\r\n                      memory.tupleMemory.size() );\r\n\r\n        assertTrue( memory.tupleMemory.contains( tuple0 ) );\r\n\r\n        // make sure assertions were propagated\r\n        assertEquals( 1,\r\n                      sink.getAsserted().size() );\r\n\r\n        RuleRemovalContext removalContext = new RuleRemovalContext();\r\n        InternalWorkingMemory[] workingMemories = new InternalWorkingMemory[]{this.workingMemory};\r\n\r\n        // This use to throw ClassCastException JBRULES-1719\r\n        node.remove( removalContext,\r\n                     this.ruleBase.getReteooBuilder(),\r\n                     sink,\r\n                     workingMemories );\r\n\r\n        memory = (EvalMemory) this.workingMemory.getNodeMemory( node );\r\n\r\n        assertEquals( 0,\r\n                      memory.tupleMemory.size() );\r\n\r\n        assertFalse( memory.tupleMemory.contains( tuple0 ) );\r\n    }","id":33535,"modified_method":"/**\r\n     * If a eval allows an incoming Object, then the Object MUST be\r\n     * propagated. This tests that the memory is updated\r\n     * \r\n     * @throws FactException\r\n     */\r\n    public void testDoRemove() throws FactException {\r\n        final MockEvalCondition eval = new MockEvalCondition( true );\r\n\r\n        final EvalConditionNode parent = new EvalConditionNode( 1,\r\n                                                                new MockTupleSource( 15 ),\r\n                                                                eval,\r\n                                                                buildContext );\r\n\r\n        // Create a test node that always returns false \r\n        final EvalConditionNode node = new EvalConditionNode( 2,\r\n                                                              parent,\r\n                                                              eval,\r\n                                                              buildContext );\r\n\r\n        parent.addTupleSink( node );\r\n\r\n        final MockLeftTupleSink sink = new MockLeftTupleSink();\r\n        node.addTupleSink( sink );\r\n\r\n        // Create the Tuple\r\n        final DefaultFactHandle f0 = new DefaultFactHandle( 0,\r\n                                                            \"stilton\" );\r\n        // an eval node always has at least a LIAN before it, so, tuples that reach it \r\n        // always have at least one tuple parent\r\n        final LeftTuple parentTuple = new LeftTuple( f0,\r\n                                                     null,\r\n                                                     true );\r\n        final LeftTuple tuple0 = new LeftTuple( parentTuple,\r\n                                                sink,\r\n                                                true );\r\n\r\n        // Tuple should pass and propagate \r\n        node.assertLeftTuple( tuple0,\r\n                              this.context,\r\n                              this.workingMemory );\r\n\r\n        // make sure assertions were propagated\r\n        assertEquals( 1,\r\n                      sink.getAsserted().size() );\r\n\r\n        RuleRemovalContext removalContext = new RuleRemovalContext();\r\n        InternalWorkingMemory[] workingMemories = new InternalWorkingMemory[]{this.workingMemory};\r\n\r\n        // This use to throw ClassCastException JBRULES-1719\r\n        node.remove( removalContext,\r\n                     this.ruleBase.getReteooBuilder(),\r\n                     sink,\r\n                     workingMemories );\r\n    }","commit_id":"3e16227adb647b4ef58376d255e544e930ed06f0","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testMemory() {\r\n        final ReteooWorkingMemory workingMemory = new ReteooWorkingMemory( 1,\r\n                                                                           (ReteooRuleBase) RuleBaseFactory.newRuleBase() );\r\n\r\n        final MockTupleSource source = new MockTupleSource( 12 );\r\n\r\n        final EvalConditionNode node = new EvalConditionNode( 18,\r\n                                                              source,\r\n                                                              new MockEvalCondition( true ),\r\n                                                              buildContext );\r\n\r\n        final EvalMemory memory = (EvalMemory) workingMemory.getNodeMemory( node );\r\n\r\n        assertNotNull( memory.tupleMemory );\r\n    }","id":33536,"modified_method":"public void testMemory() {\r\n        final ReteooWorkingMemory workingMemory = new ReteooWorkingMemory( 1,\r\n                                                                           (ReteooRuleBase) RuleBaseFactory.newRuleBase() );\r\n\r\n        final MockTupleSource source = new MockTupleSource( 12 );\r\n\r\n        final EvalConditionNode node = new EvalConditionNode( 18,\r\n                                                              source,\r\n                                                              new MockEvalCondition( true ),\r\n                                                              buildContext );\r\n\r\n        final EvalMemory memory = (EvalMemory) workingMemory.getNodeMemory( node );\r\n\r\n        assertNotNull( memory );\r\n    }","commit_id":"3e16227adb647b4ef58376d255e544e930ed06f0","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\r\n     * If a eval allows an incoming Object, then the Object MUST be\r\n     * propagated. This tests that the memory is updated\r\n     * \r\n     * @throws FactException\r\n     */\r\n    public void testAssertedAllowed() throws FactException {\r\n        final MockEvalCondition eval = new MockEvalCondition( true );\r\n\r\n        // Create a test node that always returns false \r\n        final EvalConditionNode node = new EvalConditionNode( 1,\r\n                                                              new MockTupleSource( 15 ),\r\n                                                              eval,\r\n                                                              buildContext );\r\n\r\n        final MockLeftTupleSink sink = new MockLeftTupleSink();\r\n        node.addTupleSink( sink );\r\n\r\n        // Create the Tuple\r\n        final DefaultFactHandle f0 = new DefaultFactHandle( 0,\r\n                                                            \"stilton\" );\r\n        final LeftTuple tuple0 = new LeftTuple( f0,\r\n                                                sink,\r\n                                                true );\r\n\r\n        // Tuple should pass and propagate \r\n        node.assertLeftTuple( tuple0,\r\n                              this.context,\r\n                              this.workingMemory );\r\n\r\n        // Create the Tuple\r\n        final DefaultFactHandle f1 = new DefaultFactHandle( 1,\r\n                                                            \"cheddar\" );\r\n        final LeftTuple tuple1 = new LeftTuple( f1,\r\n                                                sink,\r\n                                                true );\r\n\r\n        // Tuple should pass and propagate \r\n        node.assertLeftTuple( tuple1,\r\n                              this.context,\r\n                              this.workingMemory );\r\n\r\n        // Check memory was populated\r\n        final EvalMemory memory = (EvalMemory) this.workingMemory.getNodeMemory( node );\r\n\r\n        assertEquals( 2,\r\n                      memory.tupleMemory.size() );\r\n\r\n        assertTrue( memory.tupleMemory.contains( tuple0 ) );\r\n        assertTrue( memory.tupleMemory.contains( tuple1 ) );\r\n\r\n        // make sure assertions were propagated\r\n        assertEquals( 2,\r\n                      sink.getAsserted().size() );\r\n    }","id":33537,"modified_method":"/**\r\n     * If a eval allows an incoming Object, then the Object MUST be\r\n     * propagated. This tests that the memory is updated\r\n     * \r\n     * @throws FactException\r\n     */\r\n    public void testAssertedAllowed() throws FactException {\r\n        final MockEvalCondition eval = new MockEvalCondition( true );\r\n\r\n        // Create a test node that always returns false \r\n        final EvalConditionNode node = new EvalConditionNode( 1,\r\n                                                              new MockTupleSource( 15 ),\r\n                                                              eval,\r\n                                                              buildContext );\r\n\r\n        final MockLeftTupleSink sink = new MockLeftTupleSink();\r\n        node.addTupleSink( sink );\r\n\r\n        // Create the Tuple\r\n        final DefaultFactHandle f0 = new DefaultFactHandle( 0,\r\n                                                            \"stilton\" );\r\n        final LeftTuple tuple0 = new LeftTuple( f0,\r\n                                                sink,\r\n                                                true );\r\n\r\n        // Tuple should pass and propagate \r\n        node.assertLeftTuple( tuple0,\r\n                              this.context,\r\n                              this.workingMemory );\r\n\r\n        // Create the Tuple\r\n        final DefaultFactHandle f1 = new DefaultFactHandle( 1,\r\n                                                            \"cheddar\" );\r\n        final LeftTuple tuple1 = new LeftTuple( f1,\r\n                                                sink,\r\n                                                true );\r\n\r\n        // Tuple should pass and propagate \r\n        node.assertLeftTuple( tuple1,\r\n                              this.context,\r\n                              this.workingMemory );\r\n\r\n        // make sure assertions were propagated\r\n        assertEquals( 2,\r\n                      sink.getAsserted().size() );\r\n    }","commit_id":"3e16227adb647b4ef58376d255e544e930ed06f0","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Override\r\n    protected void doVisit(NetworkNode node,\r\n                           Stack<NetworkNode> nodeStack,\r\n                           StatefulKnowledgeSessionInfo info) {\r\n        EvalConditionNode ecn = (EvalConditionNode) node;\r\n        DefaultNodeInfo ni = (DefaultNodeInfo) info.getNodeInfo( node );\r\n        final EvalMemory memory = (EvalMemory) info.getSession().getNodeMemory( ecn );\r\n        \r\n        ni.setMemoryEnabled( ecn.isLeftTupleMemoryEnabled() );\r\n        \r\n        if( ecn.isLeftTupleMemoryEnabled() ) {\r\n            ni.setTupleMemorySize( memory.getLeftTupleMemory().size() );\r\n        }\r\n\r\n    }","id":33538,"modified_method":"@Override\r\n    protected void doVisit(NetworkNode node,\r\n                           Stack<NetworkNode> nodeStack,\r\n                           StatefulKnowledgeSessionInfo info) {\r\n        DefaultNodeInfo ni = (DefaultNodeInfo) info.getNodeInfo( node );\r\n        ni.setMemoryEnabled( false );\r\n    }","commit_id":"3e16227adb647b4ef58376d255e544e930ed06f0","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public static void readLeftTuple(LeftTuple parentLeftTuple,\r\n                                     MarshallerReaderContext context) throws IOException,\r\n                                                                     ClassNotFoundException {\r\n        ObjectInputStream stream = context.stream;\r\n        InternalWorkingMemory wm = context.wm;\r\n        Map<Integer, BaseNode> sinks = context.sinks;\r\n\r\n        LeftTupleSink sink = parentLeftTuple.getLeftTupleSink();\r\n\r\n        switch ( sink.getType() ) {\r\n            case NodeTypeEnums.JoinNode : {\r\n                BetaMemory memory = (BetaMemory) context.wm.getNodeMemory( (BetaNode) sink );\r\n                memory.getLeftTupleMemory().add( parentLeftTuple );\r\n\r\n                while ( stream.readShort() == PersisterEnums.RIGHT_TUPLE ) {\r\n                    LeftTupleSink childSink = (LeftTupleSink) sinks.get( stream.readInt() );\r\n                    int factHandleId = stream.readInt();\r\n                    RightTupleKey key = new RightTupleKey( factHandleId,\r\n                                                           sink );\r\n                    RightTuple rightTuple = context.rightTuples.get( key );\r\n                    LeftTuple childLeftTuple = new LeftTuple( parentLeftTuple,\r\n                                                              rightTuple,\r\n                                                              childSink,\r\n                                                              true );\r\n                    readLeftTuple( childLeftTuple,\r\n                                   context );\r\n                }\r\n                break;\r\n\r\n            }\r\n            case NodeTypeEnums.EvalConditionNode : {\r\n                final EvalMemory memory = (EvalMemory) context.wm.getNodeMemory( (EvalConditionNode) sink );\r\n                memory.tupleMemory.add( parentLeftTuple );\r\n                while ( stream.readShort() == PersisterEnums.LEFT_TUPLE ) {\r\n                    LeftTupleSink childSink = (LeftTupleSink) sinks.get( stream.readInt() );\r\n                    LeftTuple childLeftTuple = new LeftTuple( parentLeftTuple,\r\n                                                              childSink,\r\n                                                              true );\r\n                    readLeftTuple( childLeftTuple,\r\n                                   context );\r\n                }\r\n                break;\r\n            }\r\n            case NodeTypeEnums.NotNode : \r\n            case NodeTypeEnums.ForallNotNode : {\r\n                BetaMemory memory = (BetaMemory) context.wm.getNodeMemory( (BetaNode) sink );\r\n                int type = stream.readShort();\r\n                if ( type == PersisterEnums.LEFT_TUPLE_NOT_BLOCKED ) {\r\n                    memory.getLeftTupleMemory().add( parentLeftTuple );\r\n\r\n                    while ( stream.readShort() == PersisterEnums.LEFT_TUPLE ) {\r\n                        LeftTupleSink childSink = (LeftTupleSink) sinks.get( stream.readInt() );\r\n                        LeftTuple childLeftTuple = new LeftTuple( parentLeftTuple,\r\n                                                                  childSink,\r\n                                                                  true );\r\n                        readLeftTuple( childLeftTuple,\r\n                                       context );\r\n                    }\r\n\r\n                } else {\r\n                    int factHandleId = stream.readInt();\r\n                    RightTupleKey key = new RightTupleKey( factHandleId,\r\n                                                           sink );\r\n                    RightTuple rightTuple = context.rightTuples.get( key );\r\n\r\n                    parentLeftTuple.setBlocker( rightTuple );\r\n                    rightTuple.addBlocked( parentLeftTuple );\r\n                }\r\n                break;\r\n            }\r\n            case NodeTypeEnums.ExistsNode : {\r\n                BetaMemory memory = (BetaMemory) context.wm.getNodeMemory( (BetaNode) sink );\r\n                int type = stream.readShort();\r\n                if ( type == PersisterEnums.LEFT_TUPLE_NOT_BLOCKED ) {\r\n                    memory.getLeftTupleMemory().add( parentLeftTuple );\r\n                } else {\r\n                    int factHandleId = stream.readInt();\r\n                    RightTupleKey key = new RightTupleKey( factHandleId,\r\n                                                           sink );\r\n                    RightTuple rightTuple = context.rightTuples.get( key );\r\n\r\n                    parentLeftTuple.setBlocker( rightTuple );\r\n                    rightTuple.addBlocked( parentLeftTuple );\r\n\r\n                    while ( stream.readShort() == PersisterEnums.LEFT_TUPLE ) {\r\n                        LeftTupleSink childSink = (LeftTupleSink) sinks.get( stream.readInt() );\r\n                        LeftTuple childLeftTuple = new LeftTuple( parentLeftTuple,\r\n                                                                  childSink,\r\n                                                                  true );\r\n                        readLeftTuple( childLeftTuple,\r\n                                       context );\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            case NodeTypeEnums.AccumulateNode : {\r\n                // accumulate nodes generate new facts on-demand and need special procedures when de-serializing from persistent storage\r\n                AccumulateMemory memory = (AccumulateMemory) context.wm.getNodeMemory( (BetaNode) sink );\r\n                memory.betaMemory.getLeftTupleMemory().add( parentLeftTuple );\r\n\r\n                AccumulateContext accctx = new AccumulateContext();\r\n                memory.betaMemory.getCreatedHandles().put( parentLeftTuple,\r\n                                                           accctx,\r\n                                                           false );\r\n                // first we de-serialize the generated fact handle\r\n                InternalFactHandle handle = readFactHandle( context );\r\n                accctx.result = new RightTuple( handle,\r\n                                                (RightTupleSink) sink );\r\n\r\n                // then we de-serialize the associated accumulation context\r\n                accctx.context = (Serializable) stream.readObject();\r\n                // then we de-serialize the boolean propagated flag\r\n                accctx.propagated = stream.readBoolean();\r\n\r\n                // then we de-serialize all the propagated tuples\r\n                short head = -1;\r\n                while ( (head = stream.readShort()) != PersisterEnums.END ) {\r\n                    switch ( head ) {\r\n                        case PersisterEnums.RIGHT_TUPLE : {\r\n                            int factHandleId = stream.readInt();\r\n                            RightTupleKey key = new RightTupleKey( factHandleId,\r\n                                                                   sink );\r\n                            RightTuple rightTuple = context.rightTuples.get( key );\r\n                            // just wiring up the match record\r\n                            new LeftTuple( parentLeftTuple,\r\n                                           rightTuple,\r\n                                           sink,\r\n                                           true );\r\n                            break;\r\n                        }\r\n                        case PersisterEnums.LEFT_TUPLE : {\r\n                            LeftTupleSink childSink = (LeftTupleSink) sinks.get( stream.readInt() );\r\n                            LeftTuple childLeftTuple = new LeftTuple( parentLeftTuple,\r\n                                                                      accctx.result,\r\n                                                                      childSink,\r\n                                                                      true );\r\n                            readLeftTuple( childLeftTuple,\r\n                                           context );\r\n                            break;\r\n                        }\r\n                        default : {\r\n                            throw new RuntimeDroolsException( \"Marshalling error. This is a bug. Please contact the development team.\" );\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            case NodeTypeEnums.CollectNode : {\r\n                // accumulate nodes generate new facts on-demand and need special procedures when de-serializing from persistent storage\r\n                CollectMemory memory = (CollectMemory) context.wm.getNodeMemory( (BetaNode) sink );\r\n                memory.betaMemory.getLeftTupleMemory().add( parentLeftTuple );\r\n\r\n                CollectContext colctx = new CollectContext();\r\n                memory.betaMemory.getCreatedHandles().put( parentLeftTuple,\r\n                                                           colctx,\r\n                                                           false );\r\n                // first we de-serialize the generated fact handle\r\n                InternalFactHandle handle = readFactHandle( context );\r\n                colctx.resultTuple = new RightTuple( handle,\r\n                                                     (RightTupleSink) sink );\r\n\r\n                // then we de-serialize the boolean propagated flag\r\n                colctx.propagated = stream.readBoolean();\r\n\r\n                // then we de-serialize all the propagated tuples\r\n                short head = -1;\r\n                while ( (head = stream.readShort()) != PersisterEnums.END ) {\r\n                    switch ( head ) {\r\n                        case PersisterEnums.RIGHT_TUPLE : {\r\n                            int factHandleId = stream.readInt();\r\n                            RightTupleKey key = new RightTupleKey( factHandleId,\r\n                                                                   sink );\r\n                            RightTuple rightTuple = context.rightTuples.get( key );\r\n                            // just wiring up the match record\r\n                            new LeftTuple( parentLeftTuple,\r\n                                           rightTuple,\r\n                                           sink,\r\n                                           true );\r\n                            break;\r\n                        }\r\n                        case PersisterEnums.LEFT_TUPLE : {\r\n                            LeftTupleSink childSink = (LeftTupleSink) sinks.get( stream.readInt() );\r\n                            LeftTuple childLeftTuple = new LeftTuple( parentLeftTuple,\r\n                                                                      colctx.resultTuple,\r\n                                                                      childSink,\r\n                                                                      true );\r\n                            readLeftTuple( childLeftTuple,\r\n                                           context );\r\n                            break;\r\n                        }\r\n                        default : {\r\n                            throw new RuntimeDroolsException( \"Marshalling error. This is a bug. Please contact the development team.\" );\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            case NodeTypeEnums.RightInputAdaterNode : {\r\n                // RIANs generate new fact handles on-demand to wrap tuples and need special procedures when de-serializing from persistent storage\r\n                ObjectHashMap memory = (ObjectHashMap) context.wm.getNodeMemory( (NodeMemory) sink );\r\n                // create fact handle\r\n                int id = stream.readInt();\r\n                long recency = stream.readLong();\r\n                InternalFactHandle handle = new DefaultFactHandle( id,\r\n                                                                   parentLeftTuple,\r\n                                                                   recency );\r\n                memory.put( parentLeftTuple, handle );\r\n                \r\n                readRightTuples( handle, context );\r\n                \r\n                stream.readShort(); // Persistence.END\r\n                break;\r\n            }\r\n            case NodeTypeEnums.RuleTerminalNode : {\r\n                int pos = context.terminalTupleMap.size();\r\n                context.terminalTupleMap.put( pos,\r\n                                              parentLeftTuple );\r\n                break;\r\n            }\r\n        }\r\n    }","id":33539,"modified_method":"public static void readLeftTuple(LeftTuple parentLeftTuple,\r\n                                     MarshallerReaderContext context) throws IOException,\r\n                                                                     ClassNotFoundException {\r\n        ObjectInputStream stream = context.stream;\r\n        InternalWorkingMemory wm = context.wm;\r\n        Map<Integer, BaseNode> sinks = context.sinks;\r\n\r\n        LeftTupleSink sink = parentLeftTuple.getLeftTupleSink();\r\n\r\n        switch ( sink.getType() ) {\r\n            case NodeTypeEnums.JoinNode : {\r\n                BetaMemory memory = (BetaMemory) context.wm.getNodeMemory( (BetaNode) sink );\r\n                memory.getLeftTupleMemory().add( parentLeftTuple );\r\n\r\n                while ( stream.readShort() == PersisterEnums.RIGHT_TUPLE ) {\r\n                    LeftTupleSink childSink = (LeftTupleSink) sinks.get( stream.readInt() );\r\n                    int factHandleId = stream.readInt();\r\n                    RightTupleKey key = new RightTupleKey( factHandleId,\r\n                                                           sink );\r\n                    RightTuple rightTuple = context.rightTuples.get( key );\r\n                    LeftTuple childLeftTuple = new LeftTuple( parentLeftTuple,\r\n                                                              rightTuple,\r\n                                                              childSink,\r\n                                                              true );\r\n                    readLeftTuple( childLeftTuple,\r\n                                   context );\r\n                }\r\n                break;\r\n\r\n            }\r\n            case NodeTypeEnums.EvalConditionNode : {\r\n                while ( stream.readShort() == PersisterEnums.LEFT_TUPLE ) {\r\n                    LeftTupleSink childSink = (LeftTupleSink) sinks.get( stream.readInt() );\r\n                    LeftTuple childLeftTuple = new LeftTuple( parentLeftTuple,\r\n                                                              childSink,\r\n                                                              true );\r\n                    readLeftTuple( childLeftTuple,\r\n                                   context );\r\n                }\r\n                break;\r\n            }\r\n            case NodeTypeEnums.NotNode : \r\n            case NodeTypeEnums.ForallNotNode : {\r\n                BetaMemory memory = (BetaMemory) context.wm.getNodeMemory( (BetaNode) sink );\r\n                int type = stream.readShort();\r\n                if ( type == PersisterEnums.LEFT_TUPLE_NOT_BLOCKED ) {\r\n                    memory.getLeftTupleMemory().add( parentLeftTuple );\r\n\r\n                    while ( stream.readShort() == PersisterEnums.LEFT_TUPLE ) {\r\n                        LeftTupleSink childSink = (LeftTupleSink) sinks.get( stream.readInt() );\r\n                        LeftTuple childLeftTuple = new LeftTuple( parentLeftTuple,\r\n                                                                  childSink,\r\n                                                                  true );\r\n                        readLeftTuple( childLeftTuple,\r\n                                       context );\r\n                    }\r\n\r\n                } else {\r\n                    int factHandleId = stream.readInt();\r\n                    RightTupleKey key = new RightTupleKey( factHandleId,\r\n                                                           sink );\r\n                    RightTuple rightTuple = context.rightTuples.get( key );\r\n\r\n                    parentLeftTuple.setBlocker( rightTuple );\r\n                    rightTuple.addBlocked( parentLeftTuple );\r\n                }\r\n                break;\r\n            }\r\n            case NodeTypeEnums.ExistsNode : {\r\n                BetaMemory memory = (BetaMemory) context.wm.getNodeMemory( (BetaNode) sink );\r\n                int type = stream.readShort();\r\n                if ( type == PersisterEnums.LEFT_TUPLE_NOT_BLOCKED ) {\r\n                    memory.getLeftTupleMemory().add( parentLeftTuple );\r\n                } else {\r\n                    int factHandleId = stream.readInt();\r\n                    RightTupleKey key = new RightTupleKey( factHandleId,\r\n                                                           sink );\r\n                    RightTuple rightTuple = context.rightTuples.get( key );\r\n\r\n                    parentLeftTuple.setBlocker( rightTuple );\r\n                    rightTuple.addBlocked( parentLeftTuple );\r\n\r\n                    while ( stream.readShort() == PersisterEnums.LEFT_TUPLE ) {\r\n                        LeftTupleSink childSink = (LeftTupleSink) sinks.get( stream.readInt() );\r\n                        LeftTuple childLeftTuple = new LeftTuple( parentLeftTuple,\r\n                                                                  childSink,\r\n                                                                  true );\r\n                        readLeftTuple( childLeftTuple,\r\n                                       context );\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            case NodeTypeEnums.AccumulateNode : {\r\n                // accumulate nodes generate new facts on-demand and need special procedures when de-serializing from persistent storage\r\n                AccumulateMemory memory = (AccumulateMemory) context.wm.getNodeMemory( (BetaNode) sink );\r\n                memory.betaMemory.getLeftTupleMemory().add( parentLeftTuple );\r\n\r\n                AccumulateContext accctx = new AccumulateContext();\r\n                memory.betaMemory.getCreatedHandles().put( parentLeftTuple,\r\n                                                           accctx,\r\n                                                           false );\r\n                // first we de-serialize the generated fact handle\r\n                InternalFactHandle handle = readFactHandle( context );\r\n                accctx.result = new RightTuple( handle,\r\n                                                (RightTupleSink) sink );\r\n\r\n                // then we de-serialize the associated accumulation context\r\n                accctx.context = (Serializable) stream.readObject();\r\n                // then we de-serialize the boolean propagated flag\r\n                accctx.propagated = stream.readBoolean();\r\n\r\n                // then we de-serialize all the propagated tuples\r\n                short head = -1;\r\n                while ( (head = stream.readShort()) != PersisterEnums.END ) {\r\n                    switch ( head ) {\r\n                        case PersisterEnums.RIGHT_TUPLE : {\r\n                            int factHandleId = stream.readInt();\r\n                            RightTupleKey key = new RightTupleKey( factHandleId,\r\n                                                                   sink );\r\n                            RightTuple rightTuple = context.rightTuples.get( key );\r\n                            // just wiring up the match record\r\n                            new LeftTuple( parentLeftTuple,\r\n                                           rightTuple,\r\n                                           sink,\r\n                                           true );\r\n                            break;\r\n                        }\r\n                        case PersisterEnums.LEFT_TUPLE : {\r\n                            LeftTupleSink childSink = (LeftTupleSink) sinks.get( stream.readInt() );\r\n                            LeftTuple childLeftTuple = new LeftTuple( parentLeftTuple,\r\n                                                                      accctx.result,\r\n                                                                      childSink,\r\n                                                                      true );\r\n                            readLeftTuple( childLeftTuple,\r\n                                           context );\r\n                            break;\r\n                        }\r\n                        default : {\r\n                            throw new RuntimeDroolsException( \"Marshalling error. This is a bug. Please contact the development team.\" );\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            case NodeTypeEnums.CollectNode : {\r\n                // accumulate nodes generate new facts on-demand and need special procedures when de-serializing from persistent storage\r\n                CollectMemory memory = (CollectMemory) context.wm.getNodeMemory( (BetaNode) sink );\r\n                memory.betaMemory.getLeftTupleMemory().add( parentLeftTuple );\r\n\r\n                CollectContext colctx = new CollectContext();\r\n                memory.betaMemory.getCreatedHandles().put( parentLeftTuple,\r\n                                                           colctx,\r\n                                                           false );\r\n                // first we de-serialize the generated fact handle\r\n                InternalFactHandle handle = readFactHandle( context );\r\n                colctx.resultTuple = new RightTuple( handle,\r\n                                                     (RightTupleSink) sink );\r\n\r\n                // then we de-serialize the boolean propagated flag\r\n                colctx.propagated = stream.readBoolean();\r\n\r\n                // then we de-serialize all the propagated tuples\r\n                short head = -1;\r\n                while ( (head = stream.readShort()) != PersisterEnums.END ) {\r\n                    switch ( head ) {\r\n                        case PersisterEnums.RIGHT_TUPLE : {\r\n                            int factHandleId = stream.readInt();\r\n                            RightTupleKey key = new RightTupleKey( factHandleId,\r\n                                                                   sink );\r\n                            RightTuple rightTuple = context.rightTuples.get( key );\r\n                            // just wiring up the match record\r\n                            new LeftTuple( parentLeftTuple,\r\n                                           rightTuple,\r\n                                           sink,\r\n                                           true );\r\n                            break;\r\n                        }\r\n                        case PersisterEnums.LEFT_TUPLE : {\r\n                            LeftTupleSink childSink = (LeftTupleSink) sinks.get( stream.readInt() );\r\n                            LeftTuple childLeftTuple = new LeftTuple( parentLeftTuple,\r\n                                                                      colctx.resultTuple,\r\n                                                                      childSink,\r\n                                                                      true );\r\n                            readLeftTuple( childLeftTuple,\r\n                                           context );\r\n                            break;\r\n                        }\r\n                        default : {\r\n                            throw new RuntimeDroolsException( \"Marshalling error. This is a bug. Please contact the development team.\" );\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            case NodeTypeEnums.RightInputAdaterNode : {\r\n                // RIANs generate new fact handles on-demand to wrap tuples and need special procedures when de-serializing from persistent storage\r\n                ObjectHashMap memory = (ObjectHashMap) context.wm.getNodeMemory( (NodeMemory) sink );\r\n                // create fact handle\r\n                int id = stream.readInt();\r\n                long recency = stream.readLong();\r\n                InternalFactHandle handle = new DefaultFactHandle( id,\r\n                                                                   parentLeftTuple,\r\n                                                                   recency );\r\n                memory.put( parentLeftTuple, handle );\r\n                \r\n                readRightTuples( handle, context );\r\n                \r\n                stream.readShort(); // Persistence.END\r\n                break;\r\n            }\r\n            case NodeTypeEnums.RuleTerminalNode : {\r\n                int pos = context.terminalTupleMap.size();\r\n                context.terminalTupleMap.put( pos,\r\n                                              parentLeftTuple );\r\n                break;\r\n            }\r\n        }\r\n    }","commit_id":"3e16227adb647b4ef58376d255e544e930ed06f0","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public ReteDslTestEngine() {\r\n\r\n        this.reteTesterHelper = new ReteTesterHelper();\r\n\r\n        this.steps = new HashMap<String, Object>();\r\n\r\n        this.steps.put( OBJECT_TYPE_NODE,\r\n                        new ObjectTypeNodeStep( this.reteTesterHelper ) );\r\n        this.steps.put( LEFT_INPUT_ADAPTER_NODE,\r\n                        new LeftInputAdapterNodeStep( this.reteTesterHelper ) );\r\n        this.steps.put( BINDING,\r\n                        new BindingStep( this.reteTesterHelper ) );\r\n        this.steps.put( JOIN_NODE,\r\n                        new JoinNodeStep( this.reteTesterHelper ) );\r\n        this.steps.put( NOT_NODE,\r\n                        new NotNodeStep( this.reteTesterHelper ) );\r\n        this.steps.put( EXISTS_NODE,\r\n                        new ExistsNodeStep( this.reteTesterHelper ) );\r\n        this.steps.put( COLLECT_NODE,\r\n                        new CollectNodeStep( this.reteTesterHelper ) );\r\n        this.steps.put( ACCUMULATE_NODE,\r\n                        new AccumulateNodeStep( this.reteTesterHelper ) );\r\n        this.steps.put( RULE_TERMINAL_NODE,\r\n                        new RuleTerminalNodeStep( this.reteTesterHelper ) );\r\n        this.steps.put( RIGHT_INPUT_ADAPTER_NODE,\r\n                        new RIANodeStep( this.reteTesterHelper ) );\r\n        this.steps.put( FACTS,\r\n                        new FactsStep( this.reteTesterHelper ) );\r\n        this.steps.put( WITH,\r\n                        new WithStep( this.reteTesterHelper ) );\r\n        this.steps.put( LEFT_TUPLE_SINK_STEP,\r\n                        new LeftTupleSinkStep( this.reteTesterHelper ) );\r\n        this.steps.put( BETA_NODE_STEP,\r\n                        new BetaNodeStep( this.reteTesterHelper ) );\r\n    }","id":33540,"modified_method":"public ReteDslTestEngine() {\r\n\r\n        this.reteTesterHelper = new ReteTesterHelper();\r\n\r\n        this.steps = new HashMap<String, Object>();\r\n\r\n        this.steps.put( OBJECT_TYPE_NODE,\r\n                        new ObjectTypeNodeStep( this.reteTesterHelper ) );\r\n        this.steps.put( LEFT_INPUT_ADAPTER_NODE,\r\n                        new LeftInputAdapterNodeStep( this.reteTesterHelper ) );\r\n        this.steps.put( BINDING,\r\n                        new BindingStep( this.reteTesterHelper ) );\r\n        this.steps.put( JOIN_NODE,\r\n                        new JoinNodeStep( this.reteTesterHelper ) );\r\n        this.steps.put( NOT_NODE,\r\n                        new NotNodeStep( this.reteTesterHelper ) );\r\n        this.steps.put( EXISTS_NODE,\r\n                        new ExistsNodeStep( this.reteTesterHelper ) );\r\n        this.steps.put( COLLECT_NODE,\r\n                        new CollectNodeStep( this.reteTesterHelper ) );\r\n        this.steps.put( ACCUMULATE_NODE,\r\n                        new AccumulateNodeStep( this.reteTesterHelper ) );\r\n        this.steps.put( RULE_TERMINAL_NODE,\r\n                        new RuleTerminalNodeStep( this.reteTesterHelper ) );\r\n        this.steps.put( EVAL_NODE,\r\n                        new EvalNodeStep( this.reteTesterHelper ) );\r\n        this.steps.put( RIGHT_INPUT_ADAPTER_NODE,\r\n                        new RIANodeStep( this.reteTesterHelper ) );\r\n        this.steps.put( FACTS,\r\n                        new FactsStep( this.reteTesterHelper ) );\r\n        this.steps.put( WITH,\r\n                        new WithStep( this.reteTesterHelper ) );\r\n        this.steps.put( LEFT_TUPLE_SINK_STEP,\r\n                        new LeftTupleSinkStep( this.reteTesterHelper ) );\r\n        this.steps.put( BETA_NODE_STEP,\r\n                        new BetaNodeStep( this.reteTesterHelper ) );\r\n    }","commit_id":"3e16227adb647b4ef58376d255e544e930ed06f0","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private static List<RestTestCandidate> collectTestCandidates(int id, int count) throws RestTestParseException, IOException {\n        String[] paths = resolvePathsProperty(REST_TESTS_SUITE, DEFAULT_TESTS_PATH);\n        Map<String, Set<Path>> yamlSuites = FileUtils.findYamlSuites(DEFAULT_TESTS_PATH, paths);\n\n        List<RestTestCandidate> testCandidates = Lists.newArrayList();\n        RestTestSuiteParser restTestSuiteParser = new RestTestSuiteParser();\n        //yaml suites are grouped by directory (effectively by api)\n        for (String api : yamlSuites.keySet()) {\n            List<Path> yamlFiles = Lists.newArrayList(yamlSuites.get(api));\n            for (Path yamlFile : yamlFiles) {\n                String key = api + yamlFile.getFileName().toString();\n                if (mustExecute(key, id, count)) {\n                    RestTestSuite restTestSuite = restTestSuiteParser.parse(api, yamlFile);\n                    for (TestSection testSection : restTestSuite.getTestSections()) {\n                        testCandidates.add(new RestTestCandidate(restTestSuite, testSection));\n                    }\n                }\n            }\n        }\n\n        //sort the candidates so they will always be in the same order before being shuffled, for repeatability\n        Collections.sort(testCandidates, new Comparator<RestTestCandidate>() {\n            @Override\n            public int compare(RestTestCandidate o1, RestTestCandidate o2) {\n                return o1.getTestPath().compareTo(o2.getTestPath());\n            }\n        });\n\n        return testCandidates;\n    }","id":33541,"modified_method":"private static List<RestTestCandidate> collectTestCandidates(int id, int count) throws RestTestParseException, IOException {\n        List<RestTestCandidate> testCandidates = Lists.newArrayList();\n        FileSystem fileSystem = getFileSystem();\n        // don't make a try-with, getFileSystem returns null\n        // ... and you can't close() the default filesystem\n        try {\n            String[] paths = resolvePathsProperty(REST_TESTS_SUITE, DEFAULT_TESTS_PATH);\n            Map<String, Set<Path>> yamlSuites = FileUtils.findYamlSuites(fileSystem, DEFAULT_TESTS_PATH, paths);\n            RestTestSuiteParser restTestSuiteParser = new RestTestSuiteParser();\n            //yaml suites are grouped by directory (effectively by api)\n            for (String api : yamlSuites.keySet()) {\n                List<Path> yamlFiles = Lists.newArrayList(yamlSuites.get(api));\n                for (Path yamlFile : yamlFiles) {\n                    String key = api + yamlFile.getFileName().toString();\n                    if (mustExecute(key, id, count)) {\n                        RestTestSuite restTestSuite = restTestSuiteParser.parse(api, yamlFile);\n                        for (TestSection testSection : restTestSuite.getTestSections()) {\n                            testCandidates.add(new RestTestCandidate(restTestSuite, testSection));\n                        }\n                    }\n                }\n            }\n        } finally {\n            IOUtils.close(fileSystem);\n        }\n\n        //sort the candidates so they will always be in the same order before being shuffled, for repeatability\n        Collections.sort(testCandidates, new Comparator<RestTestCandidate>() {\n            @Override\n            public int compare(RestTestCandidate o1, RestTestCandidate o2) {\n                return o1.getTestPath().compareTo(o2.getTestPath());\n            }\n        });\n\n        return testCandidates;\n    }","commit_id":"97ffb2b4fdcc811c664c0971bf2281274ac7775b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@BeforeClass\n    public static void initExecutionContext() throws IOException, RestException {\n        String[] specPaths = resolvePathsProperty(REST_TESTS_SPEC, DEFAULT_SPEC_PATH);\n        RestSpec restSpec = RestSpec.parseFrom(DEFAULT_SPEC_PATH, specPaths);\n        validateSpec(restSpec);\n        restTestExecutionContext = new RestTestExecutionContext(restSpec);\n    }","id":33542,"modified_method":"@BeforeClass\n    public static void initExecutionContext() throws IOException, RestException {\n        String[] specPaths = resolvePathsProperty(REST_TESTS_SPEC, DEFAULT_SPEC_PATH);\n        RestSpec restSpec = null;\n        FileSystem fileSystem = getFileSystem();\n        // don't make a try-with, getFileSystem returns null\n        // ... and you can't close() the default filesystem\n        try {\n            restSpec = RestSpec.parseFrom(fileSystem, DEFAULT_SPEC_PATH, specPaths);\n        } finally {\n            IOUtils.close(fileSystem);\n        }\n        validateSpec(restSpec);\n        restTestExecutionContext = new RestTestExecutionContext(restSpec);\n    }","commit_id":"97ffb2b4fdcc811c664c0971bf2281274ac7775b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Returns the json files found within the directory provided as argument.\n     * Files are looked up in the classpath first, then outside of it if not found.\n     */\n    public static Set<Path> findJsonSpec(String optionalPathPrefix, String path) throws IOException {\n        Path dir = resolveFile(optionalPathPrefix, path, null);\n\n        if (!Files.isDirectory(dir)) {\n            throw new NotDirectoryException(path);\n        }\n\n        Set<Path> jsonFiles = new HashSet<>();\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir)) {\n            for (Path item : stream) {\n                if (item.toString().endsWith(JSON_SUFFIX)) {\n                    jsonFiles.add(item);\n                }\n            }\n        }\n\n        if (jsonFiles.isEmpty()) {\n            throw new NoSuchFileException(path, null, \"no json files found\");\n        }\n\n        return jsonFiles;\n    }","id":33543,"modified_method":"/**\n     * Returns the json files found within the directory provided as argument.\n     * Files are looked up in the classpath, or optionally from {@code fileSystem} if its not null.\n     */\n    public static Set<Path> findJsonSpec(FileSystem fileSystem, String optionalPathPrefix, String path) throws IOException {\n        Path dir = resolveFile(fileSystem, optionalPathPrefix, path, null);\n\n        if (!Files.isDirectory(dir)) {\n            throw new NotDirectoryException(path);\n        }\n\n        Set<Path> jsonFiles = new HashSet<>();\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir)) {\n            for (Path item : stream) {\n                if (item.toString().endsWith(JSON_SUFFIX)) {\n                    jsonFiles.add(item);\n                }\n            }\n        }\n\n        if (jsonFiles.isEmpty()) {\n            throw new NoSuchFileException(path, null, \"no json files found\");\n        }\n\n        return jsonFiles;\n    }","commit_id":"97ffb2b4fdcc811c664c0971bf2281274ac7775b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private static Path resolveFile(String optionalPathPrefix, String path, String optionalFileSuffix) throws IOException {\n        //try within classpath with and without file suffix (as it could be a single test suite)\n        URL resource = findResource(path, optionalFileSuffix);\n        if (resource == null) {\n            //try within classpath with optional prefix: /rest-api-spec/test (or /rest-api-spec/api) is optional\n            String newPath = optionalPathPrefix + \"/\" + path;\n            resource = findResource(newPath, optionalFileSuffix);\n            if (resource == null) {\n                //if it wasn't on classpath we look outside of the classpath\n                Path file = findFile(path, optionalFileSuffix);\n                if (!Files.exists(file)) {\n                    throw new NoSuchFileException(path);\n                }\n                return file;\n            }\n        }\n\n        try {\n            return PathUtils.get(resource.toURI());\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }","id":33544,"modified_method":"private static Path resolveFile(FileSystem fileSystem, String optionalPathPrefix, String path, String optionalFileSuffix) throws IOException {\n        if (fileSystem != null) {\n            Path file = findFile(fileSystem, path, optionalFileSuffix);\n            if (!lenientExists(file)) {\n                // try with optional prefix: /rest-api-spec/test (or /rest-api-spec/api) is optional\n                String newPath = optionalPathPrefix + \"/\" + path;\n                file = findFile(fileSystem, newPath, optionalFileSuffix);\n                if (!lenientExists(file)) {\n                    throw new NoSuchFileException(path);\n                }\n            }\n            return file;\n        } else {\n            //try within classpath\n            URL resource = findResource(path, optionalFileSuffix);\n            if (resource == null) {\n                //try within classpath with optional prefix: /rest-api-spec/test (or /rest-api-spec/api) is optional\n                String newPath = optionalPathPrefix + \"/\" + path;\n                resource = findResource(newPath, optionalFileSuffix);\n                if (resource == null) {\n                    throw new NoSuchFileException(path);\n                }\n            }\n            try {\n                return PathUtils.get(resource.toURI());\n            } catch (Exception e) {\n                // some filesystems have REALLY useless exceptions here.\n                // ZipFileSystem I am looking at you.\n                throw new RuntimeException(\"couldn't retrieve URL: \" + resource, e);\n            }\n        }\n    }","commit_id":"97ffb2b4fdcc811c664c0971bf2281274ac7775b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private static Path findFile(String path, String optionalFileSuffix) {\n        Path file = PathUtils.get(path);\n        if (!Files.exists(file)) {\n            file = PathUtils.get(path + optionalFileSuffix);\n        }\n        return file;\n    }","id":33545,"modified_method":"private static Path findFile(FileSystem fileSystem, String path, String optionalFileSuffix) {\n        Path file = fileSystem.getPath(path);\n        if (!lenientExists(file)) {\n            file = fileSystem.getPath(path + optionalFileSuffix);\n        }\n        return file;\n    }","commit_id":"97ffb2b4fdcc811c664c0971bf2281274ac7775b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Returns the yaml files found within the paths provided.\n     * Each input path can either be a single file (the .yaml suffix is optional) or a directory.\n     * Each path is looked up in the classpath first, then outside of it if not found yet.\n     */\n    public static Map<String, Set<Path>> findYamlSuites(final String optionalPathPrefix, final String... paths) throws IOException {\n        Map<String, Set<Path>> yamlSuites = Maps.newHashMap();\n        for (String path : paths) {\n            collectFiles(resolveFile(optionalPathPrefix, path, YAML_SUFFIX), YAML_SUFFIX, yamlSuites);\n        }\n        return yamlSuites;\n    }","id":33546,"modified_method":"/**\n     * Returns the yaml files found within the paths provided.\n     * Each input path can either be a single file (the .yaml suffix is optional) or a directory.\n     * Each path is looked up in the classpath, or optionally from {@code fileSystem} if its not null.\n     */\n    public static Map<String, Set<Path>> findYamlSuites(FileSystem fileSystem, String optionalPathPrefix, final String... paths) throws IOException {\n        Map<String, Set<Path>> yamlSuites = Maps.newHashMap();\n        for (String path : paths) {\n            collectFiles(resolveFile(fileSystem, optionalPathPrefix, path, YAML_SUFFIX), YAML_SUFFIX, yamlSuites);\n        }\n        return yamlSuites;\n    }","commit_id":"97ffb2b4fdcc811c664c0971bf2281274ac7775b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testLoadSingleYamlSuite() throws Exception {\n        Map<String,Set<Path>> yamlSuites = FileUtils.findYamlSuites(\"/rest-api-spec/test\", \"/rest-api-spec/test/get/10_basic\");\n        assertSingleFile(yamlSuites, \"get\", \"10_basic.yaml\");\n\n        //the path prefix is optional\n        yamlSuites = FileUtils.findYamlSuites(\"/rest-api-spec/test\", \"get/10_basic.yaml\");\n        assertSingleFile(yamlSuites, \"get\", \"10_basic.yaml\");\n\n        //extension .yaml is optional\n        yamlSuites = FileUtils.findYamlSuites(\"/rest-api-spec/test\", \"get/10_basic\");\n        assertSingleFile(yamlSuites, \"get\", \"10_basic.yaml\");\n    }","id":33547,"modified_method":"@Test\n    public void testLoadSingleYamlSuite() throws Exception {\n        Map<String,Set<Path>> yamlSuites = FileUtils.findYamlSuites(null, \"/rest-api-spec/test\", \"/rest-api-spec/test/get/10_basic\");\n        assertSingleFile(yamlSuites, \"get\", \"10_basic.yaml\");\n\n        //the path prefix is optional\n        yamlSuites = FileUtils.findYamlSuites(null, \"/rest-api-spec/test\", \"get/10_basic.yaml\");\n        assertSingleFile(yamlSuites, \"get\", \"10_basic.yaml\");\n\n        //extension .yaml is optional\n        yamlSuites = FileUtils.findYamlSuites(null, \"/rest-api-spec/test\", \"get/10_basic\");\n        assertSingleFile(yamlSuites, \"get\", \"10_basic.yaml\");\n    }","commit_id":"97ffb2b4fdcc811c664c0971bf2281274ac7775b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testLoadMultipleYamlSuites() throws Exception {\n        //single directory\n        Map<String,Set<Path>> yamlSuites = FileUtils.findYamlSuites(\"/rest-api-spec/test\", \"get\");\n        assertThat(yamlSuites, notNullValue());\n        assertThat(yamlSuites.size(), equalTo(1));\n        assertThat(yamlSuites.containsKey(\"get\"), equalTo(true));\n        assertThat(yamlSuites.get(\"get\").size(), greaterThan(1));\n\n        //multiple directories\n        yamlSuites = FileUtils.findYamlSuites(\"/rest-api-spec/test\", \"get\", \"index\");\n        assertThat(yamlSuites, notNullValue());\n        assertThat(yamlSuites.size(), equalTo(2));\n        assertThat(yamlSuites.containsKey(\"get\"), equalTo(true));\n        assertThat(yamlSuites.get(\"get\").size(), greaterThan(1));\n        assertThat(yamlSuites.containsKey(\"index\"), equalTo(true));\n        assertThat(yamlSuites.get(\"index\").size(), greaterThan(1));\n\n        //multiple paths, which can be both directories or yaml test suites (with optional file extension)\n        yamlSuites = FileUtils.findYamlSuites(\"/rest-api-spec/test\", \"indices.optimize/10_basic\", \"index\");\n        assertThat(yamlSuites, notNullValue());\n        assertThat(yamlSuites.size(), equalTo(2));\n        assertThat(yamlSuites.containsKey(\"indices.optimize\"), equalTo(true));\n        assertThat(yamlSuites.get(\"indices.optimize\").size(), equalTo(1));\n        assertSingleFile(yamlSuites.get(\"indices.optimize\"), \"indices.optimize\", \"10_basic.yaml\");\n        assertThat(yamlSuites.containsKey(\"index\"), equalTo(true));\n        assertThat(yamlSuites.get(\"index\").size(), greaterThan(1));\n\n        //files can be loaded from classpath and from file system too\n        Path dir = createTempDir();\n        Path file = dir.resolve(\"test_loading.yaml\");\n        Files.createFile(file);\n\n        //load from directory outside of the classpath\n        yamlSuites = FileUtils.findYamlSuites(\"/rest-api-spec/test\", \"get/10_basic\", dir.toAbsolutePath().toString());\n        assertThat(yamlSuites, notNullValue());\n        assertThat(yamlSuites.size(), equalTo(2));\n        assertThat(yamlSuites.containsKey(\"get\"), equalTo(true));\n        assertThat(yamlSuites.get(\"get\").size(), equalTo(1));\n        assertSingleFile(yamlSuites.get(\"get\"), \"get\", \"10_basic.yaml\");\n        assertThat(yamlSuites.containsKey(dir.getFileName().toString()), equalTo(true));\n        assertSingleFile(yamlSuites.get(dir.getFileName().toString()), dir.getFileName().toString(), file.getFileName().toString());\n\n        //load from external file (optional extension)\n        yamlSuites = FileUtils.findYamlSuites(\"/rest-api-spec/test\", \"get/10_basic\", dir.resolve(\"test_loading\").toAbsolutePath().toString());\n        assertThat(yamlSuites, notNullValue());\n        assertThat(yamlSuites.size(), equalTo(2));\n        assertThat(yamlSuites.containsKey(\"get\"), equalTo(true));\n        assertThat(yamlSuites.get(\"get\").size(), equalTo(1));\n        assertSingleFile(yamlSuites.get(\"get\"), \"get\", \"10_basic.yaml\");\n        assertThat(yamlSuites.containsKey(dir.getFileName().toString()), equalTo(true));\n        assertSingleFile(yamlSuites.get(dir.getFileName().toString()), dir.getFileName().toString(), file.getFileName().toString());\n    }","id":33548,"modified_method":"@Test\n    public void testLoadMultipleYamlSuites() throws Exception {\n        //single directory\n        Map<String,Set<Path>> yamlSuites = FileUtils.findYamlSuites(null, \"/rest-api-spec/test\", \"get\");\n        assertThat(yamlSuites, notNullValue());\n        assertThat(yamlSuites.size(), equalTo(1));\n        assertThat(yamlSuites.containsKey(\"get\"), equalTo(true));\n        assertThat(yamlSuites.get(\"get\").size(), greaterThan(1));\n\n        //multiple directories\n        yamlSuites = FileUtils.findYamlSuites(null, \"/rest-api-spec/test\", \"get\", \"index\");\n        assertThat(yamlSuites, notNullValue());\n        assertThat(yamlSuites.size(), equalTo(2));\n        assertThat(yamlSuites.containsKey(\"get\"), equalTo(true));\n        assertThat(yamlSuites.get(\"get\").size(), greaterThan(1));\n        assertThat(yamlSuites.containsKey(\"index\"), equalTo(true));\n        assertThat(yamlSuites.get(\"index\").size(), greaterThan(1));\n\n        //multiple paths, which can be both directories or yaml test suites (with optional file extension)\n        yamlSuites = FileUtils.findYamlSuites(null, \"/rest-api-spec/test\", \"indices.optimize/10_basic\", \"index\");\n        assertThat(yamlSuites, notNullValue());\n        assertThat(yamlSuites.size(), equalTo(2));\n        assertThat(yamlSuites.containsKey(\"indices.optimize\"), equalTo(true));\n        assertThat(yamlSuites.get(\"indices.optimize\").size(), equalTo(1));\n        assertSingleFile(yamlSuites.get(\"indices.optimize\"), \"indices.optimize\", \"10_basic.yaml\");\n        assertThat(yamlSuites.containsKey(\"index\"), equalTo(true));\n        assertThat(yamlSuites.get(\"index\").size(), greaterThan(1));\n\n        //files can be loaded from classpath and from file system too\n        Path dir = createTempDir();\n        Path file = dir.resolve(\"test_loading.yaml\");\n        Files.createFile(file);\n\n        //load from directory outside of the classpath\n        yamlSuites = FileUtils.findYamlSuites(dir.getFileSystem(), \"/rest-api-spec/test\", dir.toAbsolutePath().toString());\n        assertThat(yamlSuites, notNullValue());\n        assertThat(yamlSuites.size(), equalTo(1));\n        assertThat(yamlSuites.containsKey(dir.getFileName().toString()), equalTo(true));\n        assertSingleFile(yamlSuites.get(dir.getFileName().toString()), dir.getFileName().toString(), file.getFileName().toString());\n\n        //load from external file (optional extension)\n        yamlSuites = FileUtils.findYamlSuites(dir.getFileSystem(), \"/rest-api-spec/test\", dir.resolve(\"test_loading\").toAbsolutePath().toString());\n        assertThat(yamlSuites, notNullValue());\n        assertThat(yamlSuites.size(), equalTo(1));\n        assertThat(yamlSuites.containsKey(dir.getFileName().toString()), equalTo(true));\n        assertSingleFile(yamlSuites.get(dir.getFileName().toString()), dir.getFileName().toString(), file.getFileName().toString());\n    }","commit_id":"97ffb2b4fdcc811c664c0971bf2281274ac7775b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Parses the complete set of REST spec available under the provided directories\n     */\n    public static RestSpec parseFrom(String optionalPathPrefix, String... paths) throws IOException {\n        RestSpec restSpec = new RestSpec();\n        for (String path : paths) {\n            for (Path jsonFile : FileUtils.findJsonSpec(optionalPathPrefix, path)) {\n                try (InputStream stream = Files.newInputStream(jsonFile)) {\n                    XContentParser parser = JsonXContent.jsonXContent.createParser(stream);\n                    RestApi restApi = new RestApiParser().parse(parser);\n                    restSpec.addApi(restApi);\n                } catch (Throwable ex) {\n                    throw new IOException(\"Can't parse rest spec file: [\" + jsonFile + \"]\", ex);\n                }\n            }\n        }\n        return restSpec;\n    }","id":33549,"modified_method":"/**\n     * Parses the complete set of REST spec available under the provided directories\n     */\n    public static RestSpec parseFrom(FileSystem fileSystem, String optionalPathPrefix, String... paths) throws IOException {\n        RestSpec restSpec = new RestSpec();\n        for (String path : paths) {\n            for (Path jsonFile : FileUtils.findJsonSpec(fileSystem, optionalPathPrefix, path)) {\n                try (InputStream stream = Files.newInputStream(jsonFile)) {\n                    XContentParser parser = JsonXContent.jsonXContent.createParser(stream);\n                    RestApi restApi = new RestApiParser().parse(parser);\n                    restSpec.addApi(restApi);\n                } catch (Throwable ex) {\n                    throw new IOException(\"Can't parse rest spec file: [\" + jsonFile + \"]\", ex);\n                }\n            }\n        }\n        return restSpec;\n    }","commit_id":"97ffb2b4fdcc811c664c0971bf2281274ac7775b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@BeforeClass\n    public static void initExecutionContext() throws IOException, RestException {\n        String[] specPaths = resolvePathsProperty(REST_TESTS_SPEC, DEFAULT_SPEC_PATH);\n        RestSpec restSpec = RestSpec.parseFrom(DEFAULT_SPEC_PATH, specPaths);\n        validateSpec(restSpec);\n        restTestExecutionContext = new RestTestExecutionContext(restSpec);\n    }","id":33550,"modified_method":"@BeforeClass\n    public static void initExecutionContext() throws IOException, RestException {\n        String[] specPaths = resolvePathsProperty(REST_TESTS_SPEC, DEFAULT_SPEC_PATH);\n        RestSpec restSpec = null;\n        FileSystem fileSystem = getFileSystem();\n        // don't make a try-with, getFileSystem returns null\n        // ... and you can't close() the default filesystem\n        try {\n            restSpec = RestSpec.parseFrom(fileSystem, DEFAULT_SPEC_PATH, specPaths);\n        } finally {\n            IOUtils.close(fileSystem);\n        }\n        validateSpec(restSpec);\n        restTestExecutionContext = new RestTestExecutionContext(restSpec);\n    }","commit_id":"fc73540aacc0e73a2fe878dbf4f25ae59bcb485e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private static List<RestTestCandidate> collectTestCandidates(int id, int count) throws RestTestParseException, IOException {\n        String[] paths = resolvePathsProperty(REST_TESTS_SUITE, DEFAULT_TESTS_PATH);\n        Map<String, Set<Path>> yamlSuites = FileUtils.findYamlSuites(DEFAULT_TESTS_PATH, paths);\n\n        List<RestTestCandidate> testCandidates = Lists.newArrayList();\n        RestTestSuiteParser restTestSuiteParser = new RestTestSuiteParser();\n        //yaml suites are grouped by directory (effectively by api)\n        for (String api : yamlSuites.keySet()) {\n            List<Path> yamlFiles = Lists.newArrayList(yamlSuites.get(api));\n            for (Path yamlFile : yamlFiles) {\n                String key = api + yamlFile.getFileName().toString();\n                if (mustExecute(key, id, count)) {\n                    RestTestSuite restTestSuite = restTestSuiteParser.parse(api, yamlFile);\n                    for (TestSection testSection : restTestSuite.getTestSections()) {\n                        testCandidates.add(new RestTestCandidate(restTestSuite, testSection));\n                    }\n                }\n            }\n        }\n\n        //sort the candidates so they will always be in the same order before being shuffled, for repeatability\n        Collections.sort(testCandidates, new Comparator<RestTestCandidate>() {\n            @Override\n            public int compare(RestTestCandidate o1, RestTestCandidate o2) {\n                return o1.getTestPath().compareTo(o2.getTestPath());\n            }\n        });\n\n        return testCandidates;\n    }","id":33551,"modified_method":"private static List<RestTestCandidate> collectTestCandidates(int id, int count) throws RestTestParseException, IOException {\n        List<RestTestCandidate> testCandidates = Lists.newArrayList();\n        FileSystem fileSystem = getFileSystem();\n        // don't make a try-with, getFileSystem returns null\n        // ... and you can't close() the default filesystem\n        try {\n            String[] paths = resolvePathsProperty(REST_TESTS_SUITE, DEFAULT_TESTS_PATH);\n            Map<String, Set<Path>> yamlSuites = FileUtils.findYamlSuites(fileSystem, DEFAULT_TESTS_PATH, paths);\n            RestTestSuiteParser restTestSuiteParser = new RestTestSuiteParser();\n            //yaml suites are grouped by directory (effectively by api)\n            for (String api : yamlSuites.keySet()) {\n                List<Path> yamlFiles = Lists.newArrayList(yamlSuites.get(api));\n                for (Path yamlFile : yamlFiles) {\n                    String key = api + yamlFile.getFileName().toString();\n                    if (mustExecute(key, id, count)) {\n                        RestTestSuite restTestSuite = restTestSuiteParser.parse(api, yamlFile);\n                        for (TestSection testSection : restTestSuite.getTestSections()) {\n                            testCandidates.add(new RestTestCandidate(restTestSuite, testSection));\n                        }\n                    }\n                }\n            }\n        } finally {\n            IOUtils.close(fileSystem);\n        }\n\n        //sort the candidates so they will always be in the same order before being shuffled, for repeatability\n        Collections.sort(testCandidates, new Comparator<RestTestCandidate>() {\n            @Override\n            public int compare(RestTestCandidate o1, RestTestCandidate o2) {\n                return o1.getTestPath().compareTo(o2.getTestPath());\n            }\n        });\n\n        return testCandidates;\n    }","commit_id":"fc73540aacc0e73a2fe878dbf4f25ae59bcb485e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private static Path findFile(String path, String optionalFileSuffix) {\n        Path file = PathUtils.get(path);\n        if (!Files.exists(file)) {\n            file = PathUtils.get(path + optionalFileSuffix);\n        }\n        return file;\n    }","id":33552,"modified_method":"private static Path findFile(FileSystem fileSystem, String path, String optionalFileSuffix) {\n        Path file = fileSystem.getPath(path);\n        if (!lenientExists(file)) {\n            file = fileSystem.getPath(path + optionalFileSuffix);\n        }\n        return file;\n    }","commit_id":"fc73540aacc0e73a2fe878dbf4f25ae59bcb485e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Returns the json files found within the directory provided as argument.\n     * Files are looked up in the classpath first, then outside of it if not found.\n     */\n    public static Set<Path> findJsonSpec(String optionalPathPrefix, String path) throws IOException {\n        Path dir = resolveFile(optionalPathPrefix, path, null);\n\n        if (!Files.isDirectory(dir)) {\n            throw new NotDirectoryException(path);\n        }\n\n        Set<Path> jsonFiles = new HashSet<>();\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir)) {\n            for (Path item : stream) {\n                if (item.toString().endsWith(JSON_SUFFIX)) {\n                    jsonFiles.add(item);\n                }\n            }\n        }\n\n        if (jsonFiles.isEmpty()) {\n            throw new NoSuchFileException(path, null, \"no json files found\");\n        }\n\n        return jsonFiles;\n    }","id":33553,"modified_method":"/**\n     * Returns the json files found within the directory provided as argument.\n     * Files are looked up in the classpath, or optionally from {@code fileSystem} if its not null.\n     */\n    public static Set<Path> findJsonSpec(FileSystem fileSystem, String optionalPathPrefix, String path) throws IOException {\n        Path dir = resolveFile(fileSystem, optionalPathPrefix, path, null);\n\n        if (!Files.isDirectory(dir)) {\n            throw new NotDirectoryException(path);\n        }\n\n        Set<Path> jsonFiles = new HashSet<>();\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir)) {\n            for (Path item : stream) {\n                if (item.toString().endsWith(JSON_SUFFIX)) {\n                    jsonFiles.add(item);\n                }\n            }\n        }\n\n        if (jsonFiles.isEmpty()) {\n            throw new NoSuchFileException(path, null, \"no json files found\");\n        }\n\n        return jsonFiles;\n    }","commit_id":"fc73540aacc0e73a2fe878dbf4f25ae59bcb485e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private static Path resolveFile(String optionalPathPrefix, String path, String optionalFileSuffix) throws IOException {\n        //try within classpath with and without file suffix (as it could be a single test suite)\n        URL resource = findResource(path, optionalFileSuffix);\n        if (resource == null) {\n            //try within classpath with optional prefix: /rest-api-spec/test (or /rest-api-spec/api) is optional\n            String newPath = optionalPathPrefix + \"/\" + path;\n            resource = findResource(newPath, optionalFileSuffix);\n            if (resource == null) {\n                //if it wasn't on classpath we look outside of the classpath\n                Path file = findFile(path, optionalFileSuffix);\n                if (!Files.exists(file)) {\n                    throw new NoSuchFileException(path);\n                }\n                return file;\n            }\n        }\n\n        try {\n            return PathUtils.get(resource.toURI());\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }","id":33554,"modified_method":"private static Path resolveFile(FileSystem fileSystem, String optionalPathPrefix, String path, String optionalFileSuffix) throws IOException {\n        if (fileSystem != null) {\n            Path file = findFile(fileSystem, path, optionalFileSuffix);\n            if (!lenientExists(file)) {\n                // try with optional prefix: /rest-api-spec/test (or /rest-api-spec/api) is optional\n                String newPath = optionalPathPrefix + \"/\" + path;\n                file = findFile(fileSystem, newPath, optionalFileSuffix);\n                if (!lenientExists(file)) {\n                    throw new NoSuchFileException(path);\n                }\n            }\n            return file;\n        } else {\n            //try within classpath\n            URL resource = findResource(path, optionalFileSuffix);\n            if (resource == null) {\n                //try within classpath with optional prefix: /rest-api-spec/test (or /rest-api-spec/api) is optional\n                String newPath = optionalPathPrefix + \"/\" + path;\n                resource = findResource(newPath, optionalFileSuffix);\n                if (resource == null) {\n                    throw new NoSuchFileException(path);\n                }\n            }\n            try {\n                return PathUtils.get(resource.toURI());\n            } catch (Exception e) {\n                // some filesystems have REALLY useless exceptions here.\n                // ZipFileSystem I am looking at you.\n                throw new RuntimeException(\"couldn't retrieve URL: \" + resource, e);\n            }\n        }\n    }","commit_id":"fc73540aacc0e73a2fe878dbf4f25ae59bcb485e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Returns the yaml files found within the paths provided.\n     * Each input path can either be a single file (the .yaml suffix is optional) or a directory.\n     * Each path is looked up in the classpath first, then outside of it if not found yet.\n     */\n    public static Map<String, Set<Path>> findYamlSuites(final String optionalPathPrefix, final String... paths) throws IOException {\n        Map<String, Set<Path>> yamlSuites = Maps.newHashMap();\n        for (String path : paths) {\n            collectFiles(resolveFile(optionalPathPrefix, path, YAML_SUFFIX), YAML_SUFFIX, yamlSuites);\n        }\n        return yamlSuites;\n    }","id":33555,"modified_method":"/**\n     * Returns the yaml files found within the paths provided.\n     * Each input path can either be a single file (the .yaml suffix is optional) or a directory.\n     * Each path is looked up in the classpath, or optionally from {@code fileSystem} if its not null.\n     */\n    public static Map<String, Set<Path>> findYamlSuites(FileSystem fileSystem, String optionalPathPrefix, final String... paths) throws IOException {\n        Map<String, Set<Path>> yamlSuites = Maps.newHashMap();\n        for (String path : paths) {\n            collectFiles(resolveFile(fileSystem, optionalPathPrefix, path, YAML_SUFFIX), YAML_SUFFIX, yamlSuites);\n        }\n        return yamlSuites;\n    }","commit_id":"fc73540aacc0e73a2fe878dbf4f25ae59bcb485e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testLoadMultipleYamlSuites() throws Exception {\n        //single directory\n        Map<String,Set<Path>> yamlSuites = FileUtils.findYamlSuites(\"/rest-api-spec/test\", \"get\");\n        assertThat(yamlSuites, notNullValue());\n        assertThat(yamlSuites.size(), equalTo(1));\n        assertThat(yamlSuites.containsKey(\"get\"), equalTo(true));\n        assertThat(yamlSuites.get(\"get\").size(), greaterThan(1));\n\n        //multiple directories\n        yamlSuites = FileUtils.findYamlSuites(\"/rest-api-spec/test\", \"get\", \"index\");\n        assertThat(yamlSuites, notNullValue());\n        assertThat(yamlSuites.size(), equalTo(2));\n        assertThat(yamlSuites.containsKey(\"get\"), equalTo(true));\n        assertThat(yamlSuites.get(\"get\").size(), greaterThan(1));\n        assertThat(yamlSuites.containsKey(\"index\"), equalTo(true));\n        assertThat(yamlSuites.get(\"index\").size(), greaterThan(1));\n\n        //multiple paths, which can be both directories or yaml test suites (with optional file extension)\n        yamlSuites = FileUtils.findYamlSuites(\"/rest-api-spec/test\", \"indices.optimize/10_basic\", \"index\");\n        assertThat(yamlSuites, notNullValue());\n        assertThat(yamlSuites.size(), equalTo(2));\n        assertThat(yamlSuites.containsKey(\"indices.optimize\"), equalTo(true));\n        assertThat(yamlSuites.get(\"indices.optimize\").size(), equalTo(1));\n        assertSingleFile(yamlSuites.get(\"indices.optimize\"), \"indices.optimize\", \"10_basic.yaml\");\n        assertThat(yamlSuites.containsKey(\"index\"), equalTo(true));\n        assertThat(yamlSuites.get(\"index\").size(), greaterThan(1));\n\n        //files can be loaded from classpath and from file system too\n        Path dir = createTempDir();\n        Path file = dir.resolve(\"test_loading.yaml\");\n        Files.createFile(file);\n\n        //load from directory outside of the classpath\n        yamlSuites = FileUtils.findYamlSuites(\"/rest-api-spec/test\", \"get/10_basic\", dir.toAbsolutePath().toString());\n        assertThat(yamlSuites, notNullValue());\n        assertThat(yamlSuites.size(), equalTo(2));\n        assertThat(yamlSuites.containsKey(\"get\"), equalTo(true));\n        assertThat(yamlSuites.get(\"get\").size(), equalTo(1));\n        assertSingleFile(yamlSuites.get(\"get\"), \"get\", \"10_basic.yaml\");\n        assertThat(yamlSuites.containsKey(dir.getFileName().toString()), equalTo(true));\n        assertSingleFile(yamlSuites.get(dir.getFileName().toString()), dir.getFileName().toString(), file.getFileName().toString());\n\n        //load from external file (optional extension)\n        yamlSuites = FileUtils.findYamlSuites(\"/rest-api-spec/test\", \"get/10_basic\", dir.resolve(\"test_loading\").toAbsolutePath().toString());\n        assertThat(yamlSuites, notNullValue());\n        assertThat(yamlSuites.size(), equalTo(2));\n        assertThat(yamlSuites.containsKey(\"get\"), equalTo(true));\n        assertThat(yamlSuites.get(\"get\").size(), equalTo(1));\n        assertSingleFile(yamlSuites.get(\"get\"), \"get\", \"10_basic.yaml\");\n        assertThat(yamlSuites.containsKey(dir.getFileName().toString()), equalTo(true));\n        assertSingleFile(yamlSuites.get(dir.getFileName().toString()), dir.getFileName().toString(), file.getFileName().toString());\n    }","id":33556,"modified_method":"@Test\n    public void testLoadMultipleYamlSuites() throws Exception {\n        //single directory\n        Map<String,Set<Path>> yamlSuites = FileUtils.findYamlSuites(null, \"/rest-api-spec/test\", \"get\");\n        assertThat(yamlSuites, notNullValue());\n        assertThat(yamlSuites.size(), equalTo(1));\n        assertThat(yamlSuites.containsKey(\"get\"), equalTo(true));\n        assertThat(yamlSuites.get(\"get\").size(), greaterThan(1));\n\n        //multiple directories\n        yamlSuites = FileUtils.findYamlSuites(null, \"/rest-api-spec/test\", \"get\", \"index\");\n        assertThat(yamlSuites, notNullValue());\n        assertThat(yamlSuites.size(), equalTo(2));\n        assertThat(yamlSuites.containsKey(\"get\"), equalTo(true));\n        assertThat(yamlSuites.get(\"get\").size(), greaterThan(1));\n        assertThat(yamlSuites.containsKey(\"index\"), equalTo(true));\n        assertThat(yamlSuites.get(\"index\").size(), greaterThan(1));\n\n        //multiple paths, which can be both directories or yaml test suites (with optional file extension)\n        yamlSuites = FileUtils.findYamlSuites(null, \"/rest-api-spec/test\", \"indices.optimize/10_basic\", \"index\");\n        assertThat(yamlSuites, notNullValue());\n        assertThat(yamlSuites.size(), equalTo(2));\n        assertThat(yamlSuites.containsKey(\"indices.optimize\"), equalTo(true));\n        assertThat(yamlSuites.get(\"indices.optimize\").size(), equalTo(1));\n        assertSingleFile(yamlSuites.get(\"indices.optimize\"), \"indices.optimize\", \"10_basic.yaml\");\n        assertThat(yamlSuites.containsKey(\"index\"), equalTo(true));\n        assertThat(yamlSuites.get(\"index\").size(), greaterThan(1));\n\n        //files can be loaded from classpath and from file system too\n        Path dir = createTempDir();\n        Path file = dir.resolve(\"test_loading.yaml\");\n        Files.createFile(file);\n\n        //load from directory outside of the classpath\n        yamlSuites = FileUtils.findYamlSuites(dir.getFileSystem(), \"/rest-api-spec/test\", dir.toAbsolutePath().toString());\n        assertThat(yamlSuites, notNullValue());\n        assertThat(yamlSuites.size(), equalTo(1));\n        assertThat(yamlSuites.containsKey(dir.getFileName().toString()), equalTo(true));\n        assertSingleFile(yamlSuites.get(dir.getFileName().toString()), dir.getFileName().toString(), file.getFileName().toString());\n\n        //load from external file (optional extension)\n        yamlSuites = FileUtils.findYamlSuites(dir.getFileSystem(), \"/rest-api-spec/test\", dir.resolve(\"test_loading\").toAbsolutePath().toString());\n        assertThat(yamlSuites, notNullValue());\n        assertThat(yamlSuites.size(), equalTo(1));\n        assertThat(yamlSuites.containsKey(dir.getFileName().toString()), equalTo(true));\n        assertSingleFile(yamlSuites.get(dir.getFileName().toString()), dir.getFileName().toString(), file.getFileName().toString());\n    }","commit_id":"fc73540aacc0e73a2fe878dbf4f25ae59bcb485e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testLoadSingleYamlSuite() throws Exception {\n        Map<String,Set<Path>> yamlSuites = FileUtils.findYamlSuites(\"/rest-api-spec/test\", \"/rest-api-spec/test/get/10_basic\");\n        assertSingleFile(yamlSuites, \"get\", \"10_basic.yaml\");\n\n        //the path prefix is optional\n        yamlSuites = FileUtils.findYamlSuites(\"/rest-api-spec/test\", \"get/10_basic.yaml\");\n        assertSingleFile(yamlSuites, \"get\", \"10_basic.yaml\");\n\n        //extension .yaml is optional\n        yamlSuites = FileUtils.findYamlSuites(\"/rest-api-spec/test\", \"get/10_basic\");\n        assertSingleFile(yamlSuites, \"get\", \"10_basic.yaml\");\n    }","id":33557,"modified_method":"@Test\n    public void testLoadSingleYamlSuite() throws Exception {\n        Map<String,Set<Path>> yamlSuites = FileUtils.findYamlSuites(null, \"/rest-api-spec/test\", \"/rest-api-spec/test/get/10_basic\");\n        assertSingleFile(yamlSuites, \"get\", \"10_basic.yaml\");\n\n        //the path prefix is optional\n        yamlSuites = FileUtils.findYamlSuites(null, \"/rest-api-spec/test\", \"get/10_basic.yaml\");\n        assertSingleFile(yamlSuites, \"get\", \"10_basic.yaml\");\n\n        //extension .yaml is optional\n        yamlSuites = FileUtils.findYamlSuites(null, \"/rest-api-spec/test\", \"get/10_basic\");\n        assertSingleFile(yamlSuites, \"get\", \"10_basic.yaml\");\n    }","commit_id":"fc73540aacc0e73a2fe878dbf4f25ae59bcb485e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Parses the complete set of REST spec available under the provided directories\n     */\n    public static RestSpec parseFrom(String optionalPathPrefix, String... paths) throws IOException {\n        RestSpec restSpec = new RestSpec();\n        for (String path : paths) {\n            for (Path jsonFile : FileUtils.findJsonSpec(optionalPathPrefix, path)) {\n                try (InputStream stream = Files.newInputStream(jsonFile)) {\n                    XContentParser parser = JsonXContent.jsonXContent.createParser(stream);\n                    RestApi restApi = new RestApiParser().parse(parser);\n                    restSpec.addApi(restApi);\n                } catch (Throwable ex) {\n                    throw new IOException(\"Can't parse rest spec file: [\" + jsonFile + \"]\", ex);\n                }\n            }\n        }\n        return restSpec;\n    }","id":33558,"modified_method":"/**\n     * Parses the complete set of REST spec available under the provided directories\n     */\n    public static RestSpec parseFrom(FileSystem fileSystem, String optionalPathPrefix, String... paths) throws IOException {\n        RestSpec restSpec = new RestSpec();\n        for (String path : paths) {\n            for (Path jsonFile : FileUtils.findJsonSpec(fileSystem, optionalPathPrefix, path)) {\n                try (InputStream stream = Files.newInputStream(jsonFile)) {\n                    XContentParser parser = JsonXContent.jsonXContent.createParser(stream);\n                    RestApi restApi = new RestApiParser().parse(parser);\n                    restSpec.addApi(restApi);\n                } catch (Throwable ex) {\n                    throw new IOException(\"Can't parse rest spec file: [\" + jsonFile + \"]\", ex);\n                }\n            }\n        }\n        return restSpec;\n    }","commit_id":"fc73540aacc0e73a2fe878dbf4f25ae59bcb485e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@NotNull\n  public ResolveResult[] multiResolve(final boolean incompleteCode) {\n    final PsiPackage parentPackage = getContext();\n    if (parentPackage != null) {\n      final Collection<PsiPackage> packages = myReferenceSet.resolvePackageName(parentPackage, getValue());\n      return PsiElementResolveResult.createResults(packages);\n    }\n    return ResolveResult.EMPTY_ARRAY;\n  }","id":33559,"modified_method":"@NotNull\n  public ResolveResult[] multiResolve(final boolean incompleteCode) {\n    final Collection<PsiPackage> packages = new HashSet<PsiPackage>();\n    for (PsiPackage parentPackage : getContext()) {\n      packages.addAll(myReferenceSet.resolvePackageName(parentPackage, getValue()));\n    }\n    return PsiElementResolveResult.createResults(packages);\n  }","commit_id":"a9ebb95a4919e06da0222f281cd9bb50c8fb9501","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private PsiPackage getContext() {\n    return myIndex == 0 ? JavaPsiFacade.getInstance(getElement().getProject()).findPackage(\"\") :\n           (PsiPackage)myReferenceSet.getReference(myIndex - 1).resolve();\n  }","id":33560,"modified_method":"@NotNull\n  private Set<PsiPackage> getContext() {\n    if (myIndex == 0) return Collections.singleton(JavaPsiFacade.getInstance(getElement().getProject()).findPackage(\"\"));\n    Set<PsiPackage> psiPackages = new HashSet<PsiPackage>();\n    for (ResolveResult resolveResult : myReferenceSet.getReference(myIndex - 1).multiResolve(false)) {\n      PsiElement psiElement = resolveResult.getElement();\n      if (psiElement instanceof PsiPackage) {\n        psiPackages.add((PsiPackage)psiElement);\n      }\n    }\n    ;\n    return psiPackages;\n  }","commit_id":"a9ebb95a4919e06da0222f281cd9bb50c8fb9501","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public Object[] getVariants() {\n    final PsiPackage psiPackage = getContext();\n    if (psiPackage == null) return ArrayUtil.EMPTY_OBJECT_ARRAY;\n    final PsiPackage[] psiPackages = psiPackage.getSubPackages();\n    final Object[] variants = new Object[psiPackages.length];\n    System.arraycopy(psiPackages, 0, variants, 0, variants.length);\n    return variants;\n  }","id":33561,"modified_method":"@NotNull\n  public Object[] getVariants() {\n    Set<PsiPackage> subPackages = new HashSet<PsiPackage>();\n    for (PsiPackage psiPackage : getContext()) {\n         subPackages.addAll(Arrays.asList(psiPackage.getSubPackages()));\n    }\n\n    return subPackages.toArray();\n  }","commit_id":"a9ebb95a4919e06da0222f281cd9bb50c8fb9501","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Object[] processPackage(final PsiPackage aPackage) {\n    final PsiPackage[] subPackages = aPackage.getSubPackages();\n    final PsiClass[] classes = aPackage.getClasses();\n    final Map<CustomizableReferenceProvider.CustomizationKey, Object> options = getOptions();\n    if (options != null) {\n      final ArrayList<Object> list = new ArrayList<Object>(Arrays.asList(subPackages));\n      final boolean instantiatable = JavaClassReferenceProvider.INSTANTIATABLE.getBooleanValue(options);\n      final boolean concrete = JavaClassReferenceProvider.CONCRETE.getBooleanValue(options);\n      final boolean notInterface = JavaClassReferenceProvider.NOT_INTERFACE.getBooleanValue(options);\n      for (PsiClass clazz: classes) {\n        if (isClassAccepted(clazz, instantiatable, concrete, notInterface)) {\n          list.add(clazz);\n        }\n      }\n      return list.toArray();\n    }\n    return ArrayUtil.mergeArrays(subPackages, classes, Object.class);\n  }","id":33562,"modified_method":"private Object[] processPackage(final PsiPackage aPackage) {\n    final ArrayList<Object> list = new ArrayList<Object>();\n    final int startOffset = StringUtil.isEmpty(aPackage.getName()) ? 0 : aPackage.getName().length() + 1;\n    for (final PsiPackage subPackage : aPackage.getSubPackages()) {\n      final String shortName = subPackage.getQualifiedName().substring(startOffset);\n      if (JavaPsiFacade.getInstance(subPackage.getProject()).getNameHelper().isIdentifier(shortName)) {\n        list.add(subPackage);\n      }\n    }\n\n    final PsiClass[] classes = aPackage.getClasses();\n    final Map<CustomizableReferenceProvider.CustomizationKey, Object> options = getOptions();\n    if (options != null) {\n      final boolean instantiatable = JavaClassReferenceProvider.INSTANTIATABLE.getBooleanValue(options);\n      final boolean concrete = JavaClassReferenceProvider.CONCRETE.getBooleanValue(options);\n      final boolean notInterface = JavaClassReferenceProvider.NOT_INTERFACE.getBooleanValue(options);\n      for (PsiClass clazz: classes) {\n        if (isClassAccepted(clazz, instantiatable, concrete, notInterface)) {\n          list.add(clazz);\n        }\n      }\n    } else {\n      list.addAll(Arrays.asList(classes));\n    }\n    return list.toArray();\n  }","commit_id":"7fb552f4f7df3dbe04ecfa0d5afc62e58822f462","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static boolean processSubPackages(final PsiPackage pkg, final Processor<PsiPackage> processor) {\n    if (!processor.process(pkg)) return false;\n\n    return ContainerUtil.process(pkg.getSubPackages(), processor);\n  }","id":33563,"modified_method":"protected static boolean processSubPackages(final PsiPackage pkg, final Processor<PsiPackage> processor) {\n    if (!processor.process(pkg)) return false;\n\n    for (final PsiPackage aPackage : pkg.getSubPackages()) {\n      if (!processSubPackages(aPackage, processor)) return false;\n    }\n    return true;\n  }","commit_id":"3ed0fef7fe31a86600482f70504ed705c2092552","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void withArguments(Action<List<String>> action) {\n        argActions.add(action);\n    }","id":33564,"modified_method":"public void withArguments(Action<? super List<String>>  action) {\n        argActions.add(action);\n    }","commit_id":"2b39bdf0be681e6319dab5adc13cd32aa8bd70cf","url":"https://github.com/gradle/gradle"},{"original_method":"private T newConfiguredGccTool(T defaultTool) {\n        GccCommandLineToolConfigurationInternal gccToolInternal = (GccCommandLineToolConfigurationInternal) defaultTool;\n        DefaultGccCommandLineToolConfiguration platformTool = new DefaultGccCommandLineToolConfiguration(defaultTool.getName(), gccToolInternal.getToolType(), defaultTool.getExecutable());\n        Action<List<String>> argAction = gccToolInternal.getArgAction();\n        platformTool.withArguments(argAction);\n        return (T) platformTool;\n    }","id":33565,"modified_method":"private T newConfiguredGccTool(T defaultTool) {\n        GccCommandLineToolConfigurationInternal gccToolInternal = (GccCommandLineToolConfigurationInternal) defaultTool;\n        DefaultGccCommandLineToolConfiguration platformTool = getInstantiator().newInstance(DefaultGccCommandLineToolConfiguration.class, defaultTool.getName(), gccToolInternal.getToolType(), defaultTool.getExecutable());\n        Action<List<String>> argAction = gccToolInternal.getArgAction();\n        platformTool.withArguments(argAction);\n        return (T) platformTool;\n    }","commit_id":"2b39bdf0be681e6319dab5adc13cd32aa8bd70cf","url":"https://github.com/gradle/gradle"},{"original_method":"public VisualCppToolChain(String name, OperatingSystem operatingSystem, FileResolver fileResolver, ExecActionFactory execActionFactory,\n                              VisualStudioLocator visualStudioLocator, WindowsSdkLocator windowsSdkLocator, Instantiator instantiator) {\n        super(CommandLineToolConfigurationInternal.class, name, operatingSystem, fileResolver, instantiator);\n\n        add(new DefaultCommandLineToolConfiguration(\"cCompiler\"));\n        add(new DefaultCommandLineToolConfiguration(\"cppCompiler\"));\n        add(new DefaultCommandLineToolConfiguration(\"linker\"));\n        add(new DefaultCommandLineToolConfiguration(\"staticLibArchiver\"));\n\n        this.name = name;\n        this.operatingSystem = operatingSystem;\n        this.fileResolver = fileResolver;\n        this.execActionFactory = execActionFactory;\n        this.visualStudioLocator = visualStudioLocator;\n        this.windowsSdkLocator = windowsSdkLocator;\n    }","id":33566,"modified_method":"public VisualCppToolChain(String name, OperatingSystem operatingSystem, FileResolver fileResolver, ExecActionFactory execActionFactory,\n                              VisualStudioLocator visualStudioLocator, WindowsSdkLocator windowsSdkLocator, Instantiator instantiator) {\n        super(CommandLineToolConfigurationInternal.class, name, operatingSystem, fileResolver, instantiator);\n\n        add(instantiator.newInstance(DefaultCommandLineToolConfiguration.class, \"cCompiler\"));\n        add(instantiator.newInstance(DefaultCommandLineToolConfiguration.class, \"cppCompiler\"));\n        add(instantiator.newInstance(DefaultCommandLineToolConfiguration.class, \"linker\"));\n        add(instantiator.newInstance(DefaultCommandLineToolConfiguration.class, \"staticLibArchiver\"));\n\n        this.name = name;\n        this.operatingSystem = operatingSystem;\n        this.fileResolver = fileResolver;\n        this.execActionFactory = execActionFactory;\n        this.visualStudioLocator = visualStudioLocator;\n        this.windowsSdkLocator = windowsSdkLocator;\n    }","commit_id":"2b39bdf0be681e6319dab5adc13cd32aa8bd70cf","url":"https://github.com/gradle/gradle"},{"original_method":"public PhoneGapCommandLine(@NotNull String path, @Nullable String dir) {\n    myWorkDir = dir;\n    myPath = path;\n    try {\n      version = executeAndReturnResult(myPath, \"--version\").replace(\"\\\"\", \"\").trim();\n    }\n    catch (Exception e) {\n      version = null;\n      LOGGER.debug(e.getMessage(), e);\n      myIsCorrect = false;\n    }\n  }","id":33567,"modified_method":"public PhoneGapCommandLine(@NotNull String path, @Nullable String dir) {\n    myWorkDir = dir;\n    myPath = path;\n    try {\n      version = getInnerVersion(myPath, \"--version\").replace(\"\\\"\", \"\").trim();\n    }\n    catch (Exception e) {\n      version = null;\n      LOGGER.debug(e.getMessage(), e);\n      myIsCorrect = false;\n    }\n  }","commit_id":"0e66c1c8af3f0b2fdd5788e052ed95239b024a92","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public boolean isOld() {\n    if (StringUtil.isEmpty(version)) return false;\n\n    String[] split = version.split(\"\\\\.\");\n    int first = Integer.parseInt(split[0]);\n    if (first > 3) return false;\n    if (first == 3) {\n      return (split.length < 2 || Integer.parseInt(split[1]) < 5);\n    }\n\n    return first < 3;\n  }","id":33568,"modified_method":"public boolean isOld() {\n    if (StringUtil.isEmpty(version)) return false;\n\n    try {\n      String[] split = version.split(\"\\\\.\");\n      int first = Integer.parseInt(split[0]);\n      if (first > 3) return false;\n      if (first == 3) {\n        return (split.length < 2 || Integer.parseInt(split[1]) < 5);\n      }\n      return first < 3;\n    }\n    catch (RuntimeException e) {\n      LOGGER.debug(e.getMessage(), e);\n    }\n    return false;\n  }","commit_id":"0e66c1c8af3f0b2fdd5788e052ed95239b024a92","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void setUpListener() {\n    final JTextField textField = myExecutablePath.getChildComponent().getTextEditor();\n    final Ref<String> prevExecutablePathRef = Ref.create(StringUtil.notNullize(textField.getText()));\n    textField.getDocument().addDocumentListener(new DocumentAdapter() {\n      @Override\n      protected void textChanged(DocumentEvent e) {\n        String executablePath = StringUtil.notNullize(textField.getText());\n        String prevExecutablePath = prevExecutablePathRef.get();\n        if (!prevExecutablePath.equals(executablePath)) {\n          PhoneGapCommandLine line = getCommandLine();\n          phoneGapPluginsView.setupService(line);\n          setVersion(line);\n          prevExecutablePathRef.set(executablePath);\n        }\n      }\n    });\n  }","id":33569,"modified_method":"public void setUpListener() {\n    final JTextField textField = myExecutablePath.getChildComponent().getTextEditor();\n    final Ref<String> prevExecutablePathRef = Ref.create(StringUtil.notNullize(textField.getText()));\n    textField.getDocument().addDocumentListener(new DocumentAdapter() {\n      @Override\n      protected void textChanged(DocumentEvent e) {\n        String executablePath = StringUtil.notNullize(textField.getText());\n        String prevExecutablePath = prevExecutablePathRef.get();\n        if (!prevExecutablePath.equals(executablePath)) {\n          phoneGapPluginsView.setupService(myExecutablePath.getText(), myProject.getBasePath(), getVersionCallback());\n          prevExecutablePathRef.set(executablePath);\n        }\n      }\n    });\n  }","commit_id":"0e66c1c8af3f0b2fdd5788e052ed95239b024a92","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  @Override\n  public JComponent createComponent() {\n\n    if (myWrapper == null) {\n      myExecutablePath = PhoneGapUIUtil.createPhoneGapExecutableTextField(myProject);\n      myVersion = new JBLabel();\n      myUIController = new UIController();\n      myUIController.reset(mySettings.getState());\n      phoneGapPluginsView = new PhoneGapPluginsView(myProject);\n      JPanel panel = FormBuilder.createFormBuilder()\n        .addLabeledComponent(\"PhoneGap/Cordova executable path:\", myExecutablePath)\n        .addLabeledComponent(\"Phonegap/Cordova version:\", myVersion)\n        .addComponent(phoneGapPluginsView.getPanel()).getPanel();\n      myWrapper = new JPanel(new BorderLayout());\n      myWrapper.add(panel, BorderLayout.NORTH);\n      setUpListener();\n      if (!StringUtil.isEmpty(myExecutablePath.getText())) {\n        PhoneGapCommandLine line = getCommandLine();\n        phoneGapPluginsView.setupService(line);\n        setVersion(line);\n      }\n    }\n\n    return myWrapper;\n  }","id":33570,"modified_method":"@Nullable\n  @Override\n  public JComponent createComponent() {\n\n    if (myWrapper == null) {\n      myExecutablePath = PhoneGapUIUtil.createPhoneGapExecutableTextField(myProject);\n      myVersion = new JBLabel();\n      myUIController = new UIController();\n      myUIController.reset(mySettings.getState());\n      phoneGapPluginsView = new PhoneGapPluginsView(myProject);\n      JPanel panel = FormBuilder.createFormBuilder()\n        .addLabeledComponent(\"PhoneGap/Cordova executable path:\", myExecutablePath)\n        .addLabeledComponent(\"Phonegap/Cordova version:\", myVersion)\n        .addComponent(phoneGapPluginsView.getPanel()).getPanel();\n      myWrapper = new JPanel(new BorderLayout());\n      myWrapper.add(panel, BorderLayout.NORTH);\n      setUpListener();\n      if (!StringUtil.isEmpty(myExecutablePath.getText())) {\n        phoneGapPluginsView.setupService(myExecutablePath.getText(), myProject.getBasePath(), getVersionCallback());\n      }\n    }\n\n    return myWrapper;\n  }","commit_id":"0e66c1c8af3f0b2fdd5788e052ed95239b024a92","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static boolean isExcluded(String name) {\n    return \"_updated\".equals(name);\n  }","id":33571,"modified_method":"private static boolean isExcludedProperty(String name) {\n    return \"_updated\".equals(name);\n  }","commit_id":"0e66c1c8af3f0b2fdd5788e052ed95239b024a92","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static Map<String, PhoneGapRepoPackage> listNoCache() {\n    HttpURLConnection urlConnection = null;\n    Map<String, PhoneGapRepoPackage> result = ContainerUtil.newHashMap();\n    try {\n      urlConnection = HttpConfigurable.getInstance().openHttpConnection(PLUGINS_URL);\n      int timeout = (int)TimeUnit.SECONDS.toMillis(30);\n      urlConnection.setConnectTimeout(timeout);\n      urlConnection.setReadTimeout(timeout);\n      urlConnection.connect();\n\n      InputStream rawStream = urlConnection.getInputStream();\n      int contentLength = urlConnection.getContentLength();\n      final ByteArrayOutputStream out = new ByteArrayOutputStream();\n      NetUtils.copyStreamContent(null, rawStream, out, contentLength);\n\n      JsonParser jsonParser = new JsonParser();\n      final JsonElement jsonElement = jsonParser.parse(out.toString());\n\n      JsonObject object = jsonElement.getAsJsonObject();\n      for (Map.Entry<String, JsonElement> entry : object.entrySet()) {\n        if (!isExcluded(entry.getKey())) {\n          result.put(entry.getKey(), new PhoneGapRepoPackage(entry.getKey(), entry.getValue().getAsJsonObject()));\n        }\n      }\n    }\n    catch (Exception e) {\n      throw new RuntimeException(e.getMessage(), e);\n    }\n    finally {\n      if (urlConnection != null) {\n        urlConnection.disconnect();\n      }\n    }\n    return result;\n  }","id":33572,"modified_method":"private static Map<String, PhoneGapRepoPackage> listNoCache() {\n    HttpURLConnection urlConnection = null;\n    Map<String, PhoneGapRepoPackage> result = ContainerUtil.newHashMap();\n    try {\n      urlConnection = HttpConfigurable.getInstance().openHttpConnection(PLUGINS_URL);\n      int timeout = (int)TimeUnit.SECONDS.toMillis(30);\n      urlConnection.setConnectTimeout(timeout);\n      urlConnection.setReadTimeout(timeout);\n      urlConnection.connect();\n\n      InputStream rawStream = urlConnection.getInputStream();\n      int contentLength = urlConnection.getContentLength();\n      final ByteArrayOutputStream out = new ByteArrayOutputStream();\n      NetUtils.copyStreamContent(null, rawStream, out, contentLength);\n\n      JsonParser jsonParser = new JsonParser();\n      final JsonElement jsonElement = jsonParser.parse(out.toString());\n\n      JsonObject object = jsonElement.getAsJsonObject();\n      for (Map.Entry<String, JsonElement> entry : object.entrySet()) {\n        if (!isExcludedProperty(entry.getKey())) {\n          result.put(entry.getKey(), new PhoneGapRepoPackage(entry.getKey(), entry.getValue().getAsJsonObject()));\n        }\n      }\n    }\n    catch (Exception e) {\n      throw new RuntimeException(e.getMessage(), e);\n    }\n    finally {\n      if (urlConnection != null) {\n        urlConnection.disconnect();\n      }\n    }\n    return result;\n  }","commit_id":"0e66c1c8af3f0b2fdd5788e052ed95239b024a92","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  @Override\n  public SettingsEditor<? extends RunConfiguration> getConfigurationEditor() {\n    return new PhoneGapConfigurationEditor(getProject());\n  }","id":33573,"modified_method":"@NotNull\n  @Override\n  public SettingsEditor<? extends RunConfiguration> getConfigurationEditor() {\n    return new PhoneGapRunConfigurationEditor(getProject());\n  }","commit_id":"0e66c1c8af3f0b2fdd5788e052ed95239b024a92","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  @Override\n  protected ProcessHandler startProcess() throws ExecutionException {\n    String projectDir = this.project.getBasePath();\n    if (PhoneGapSettings.PHONEGAP_PLATFORM_RIPPLE.equals(this.phoneGapRunConfiguration.getPlatform())) { // ripple emu\n      // if server.js is missing\n      // Create server.js\n      try {\n        File serverScript = new File(projectDir + \"/\" + \"server.js\");\n        if (!serverScript.exists()) {\n          writeScript(serverScript);\n        }\n      }\n      catch (Exception e) {\n        throw new RuntimeException(e.getMessage(), e);\n      }\n\n      GeneralCommandLine commandLine = new GeneralCommandLine(\"node\", \"server.js\");\n      commandLine.setWorkDirectory(projectDir);\n      return KillableColoredProcessHandler.create(commandLine);\n    }\n    else { // Android or iOS\n      GeneralCommandLine commandLine = new GeneralCommandLine(\n        phoneGapRunConfiguration.getExecutable(),\n        phoneGapRunConfiguration.getCommand(),\n        phoneGapRunConfiguration.getPlatform());\n\n      // Change working dir to project dir\n      commandLine.setWorkDirectory(projectDir);\n\n      return new OSProcessHandler(commandLine);\n    }\n  }","id":33574,"modified_method":"@NotNull\n  @Override\n  protected ProcessHandler startProcess() throws ExecutionException {\n    String projectDir = this.project.getBasePath();\n    if (PhoneGapCommandLine.COMMAND_RIPPLE.equals(this.phoneGapRunConfiguration.getCommand())) {\n      return runRipple(projectDir);\n    }\n    else {\n      String executable = phoneGapRunConfiguration.getExecutable();\n      assert executable != null;\n      PhoneGapCommandLine line = new PhoneGapCommandLine(executable, project.getBasePath());\n      String command = phoneGapRunConfiguration.getCommand();\n      assert command != null;\n      String platform = phoneGapRunConfiguration.getPlatform();\n      assert platform != null;\n      return line.runCommand(command, platform);\n    }\n  }","commit_id":"0e66c1c8af3f0b2fdd5788e052ed95239b024a92","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  public static List<String> getDefaultPaths() {\n    List<String> paths = ContainerUtil.newArrayList();\n    ContainerUtil.addIfNotNull(paths, getCordovaDefaultPath());\n    ContainerUtil.addIfNotNull(paths, getPhonegapDefaultPath());\n    return paths;\n  }","id":33575,"modified_method":"@NotNull\n  public static List<String> getDefaultPaths() {\n    List<String> paths = ContainerUtil.newArrayList();\n    ContainerUtil.addIfNotNull(paths, getPath(PhoneGapCommandLine.PLATFORM_PHONEGAP));\n    ContainerUtil.addIfNotNull(paths, getPath(PhoneGapCommandLine.PLATFORM_IONIC));\n    ContainerUtil.addIfNotNull(paths, getPath(PhoneGapCommandLine.PLATFORM_CORDOVA));\n    return paths;\n  }","commit_id":"0e66c1c8af3f0b2fdd5788e052ed95239b024a92","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void withArguments(Action<List<String>> action) {\n        argActions.add(action);\n    }","id":33576,"modified_method":"public void withArguments(Action<? super List<String>>  action) {\n        argActions.add(action);\n    }","commit_id":"a270f22f0676f2ff20e046207c949a906c023873","url":"https://github.com/gradle/gradle"},{"original_method":"private T newConfiguredGccTool(T defaultTool) {\n        GccCommandLineToolConfigurationInternal gccToolInternal = (GccCommandLineToolConfigurationInternal) defaultTool;\n        DefaultGccCommandLineToolConfiguration platformTool = new DefaultGccCommandLineToolConfiguration(defaultTool.getName(), gccToolInternal.getToolType(), defaultTool.getExecutable());\n        Action<List<String>> argAction = gccToolInternal.getArgAction();\n        platformTool.withArguments(argAction);\n        return (T) platformTool;\n    }","id":33577,"modified_method":"private T newConfiguredGccTool(T defaultTool) {\n        GccCommandLineToolConfigurationInternal gccToolInternal = (GccCommandLineToolConfigurationInternal) defaultTool;\n        DefaultGccCommandLineToolConfiguration platformTool = getInstantiator().newInstance(DefaultGccCommandLineToolConfiguration.class, defaultTool.getName(), gccToolInternal.getToolType(), defaultTool.getExecutable());\n        Action<List<String>> argAction = gccToolInternal.getArgAction();\n        platformTool.withArguments(argAction);\n        return (T) platformTool;\n    }","commit_id":"a270f22f0676f2ff20e046207c949a906c023873","url":"https://github.com/gradle/gradle"},{"original_method":"public VisualCppToolChain(String name, OperatingSystem operatingSystem, FileResolver fileResolver, ExecActionFactory execActionFactory,\n                              VisualStudioLocator visualStudioLocator, WindowsSdkLocator windowsSdkLocator, Instantiator instantiator) {\n        super(CommandLineToolConfigurationInternal.class, name, operatingSystem, fileResolver, instantiator);\n\n        add(new DefaultCommandLineToolConfiguration(\"cCompiler\"));\n        add(new DefaultCommandLineToolConfiguration(\"cppCompiler\"));\n        add(new DefaultCommandLineToolConfiguration(\"linker\"));\n        add(new DefaultCommandLineToolConfiguration(\"staticLibArchiver\"));\n\n        this.name = name;\n        this.operatingSystem = operatingSystem;\n        this.fileResolver = fileResolver;\n        this.execActionFactory = execActionFactory;\n        this.visualStudioLocator = visualStudioLocator;\n        this.windowsSdkLocator = windowsSdkLocator;\n    }","id":33578,"modified_method":"public VisualCppToolChain(String name, OperatingSystem operatingSystem, FileResolver fileResolver, ExecActionFactory execActionFactory,\n                              VisualStudioLocator visualStudioLocator, WindowsSdkLocator windowsSdkLocator, Instantiator instantiator) {\n        super(CommandLineToolConfigurationInternal.class, name, operatingSystem, fileResolver, instantiator);\n\n        add(instantiator.newInstance(DefaultCommandLineToolConfiguration.class, \"cCompiler\"));\n        add(instantiator.newInstance(DefaultCommandLineToolConfiguration.class, \"cppCompiler\"));\n        add(instantiator.newInstance(DefaultCommandLineToolConfiguration.class, \"linker\"));\n        add(instantiator.newInstance(DefaultCommandLineToolConfiguration.class, \"staticLibArchiver\"));\n\n        this.name = name;\n        this.operatingSystem = operatingSystem;\n        this.fileResolver = fileResolver;\n        this.execActionFactory = execActionFactory;\n        this.visualStudioLocator = visualStudioLocator;\n        this.windowsSdkLocator = windowsSdkLocator;\n    }","commit_id":"a270f22f0676f2ff20e046207c949a906c023873","url":"https://github.com/gradle/gradle"},{"original_method":"public void execute(final OHttpRequest iRequest) throws Exception {\r\n\t\tString[] urlParts = checkSyntax(iRequest.url, 2, \"Syntax error: database/<database>\");\r\n\r\n\t\t// if (iRequest.sessionId == null) {\r\n\t\t// sendTextContent(iRequest, OHttpUtils.STATUS_AUTH_CODE, OHttpUtils.STATUS_AUTH_DESCRIPTION,\r\n\t\t// \"WWW-Authenticate: Basic realm=\\\"Secure Area\\\"\", OHttpUtils.CONTENT_TEXT_PLAIN, \"401 Unauthorized.\");\r\n\t\t// return;\r\n\t\t// }\r\n\r\n\t\tiRequest.data.commandInfo = \"Database info\";\r\n\t\tiRequest.data.commandDetail = urlParts[1];\r\n\r\n\t\tODatabaseDocumentTx db = null;\r\n\r\n\t\ttry {\r\n\t\t\tdb = OSharedDocumentDatabase.acquireDatabase(urlParts[1]);\r\n\r\n\t\t\tfinal StringWriter buffer = new StringWriter();\r\n\t\t\tfinal OJSONWriter json = new OJSONWriter(buffer);\r\n\r\n\t\t\tjson.beginObject();\r\n\t\t\tif (db.getMetadata().getSchema().getClasses() != null) {\r\n\t\t\t\tjson.beginCollection(1, false, \"classes\");\r\n\t\t\t\tfor (OClass cls : db.getMetadata().getSchema().getClasses()) {\r\n\t\t\t\t\tjson.beginObject(2, true, null);\r\n\t\t\t\t\tjson.writeAttribute(3, true, \"id\", cls.getId());\r\n\t\t\t\t\tjson.writeAttribute(3, true, \"name\", cls.getName());\r\n\t\t\t\t\tjson.writeAttribute(3, true, \"clusters\", cls.getClusterIds());\r\n\t\t\t\t\tjson.writeAttribute(3, true, \"defaultCluster\", cls.getDefaultClusterId());\r\n\t\t\t\t\tjson.writeAttribute(3, false, \"records\", db.countClass(cls.getName()));\r\n\r\n\t\t\t\t\tif (cls.properties() != null && cls.properties().size() > 0) {\r\n\t\t\t\t\t\tjson.beginCollection(3, true, \"properties\");\r\n\t\t\t\t\t\tfor (OProperty prop : cls.properties()) {\r\n\t\t\t\t\t\t\tjson.beginObject(4, true, null);\r\n\t\t\t\t\t\t\tjson.writeAttribute(4, true, \"id\", prop.getId());\r\n\t\t\t\t\t\t\tjson.writeAttribute(4, true, \"name\", prop.getName());\r\n\t\t\t\t\t\t\tif (prop.getLinkedClass() != null)\r\n\t\t\t\t\t\t\t\tjson.writeAttribute(4, true, \"linkedClass\", prop.getLinkedClass().getName());\r\n\t\t\t\t\t\t\tif (prop.getLinkedType() != null)\r\n\t\t\t\t\t\t\t\tjson.writeAttribute(4, true, \"linkedType\", prop.getLinkedType());\r\n\t\t\t\t\t\t\tjson.writeAttribute(4, true, \"type\", prop.getType().toString());\r\n\t\t\t\t\t\t\tjson.writeAttribute(4, true, \"min\", prop.getMin());\r\n\t\t\t\t\t\t\tjson.writeAttribute(4, true, \"max\", prop.getMax());\r\n\t\t\t\t\t\t\tjson.endObject(3, true);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tjson.endCollection(1, true);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tjson.endObject(1, false);\r\n\t\t\t\t}\r\n\t\t\t\tjson.endCollection(1, true);\r\n\t\t\t}\r\n\r\n\t\t\tif (db.getClusterNames() != null) {\r\n\t\t\t\tjson.beginCollection(1, false, \"clusters\");\r\n\t\t\t\tfor (String clusterName : db.getClusterNames()) {\r\n\t\t\t\t\tjson.beginObject(2, true, null);\r\n\t\t\t\t\tjson.writeAttribute(3, false, \"id\", db.getClusterIdByName(clusterName));\r\n\t\t\t\t\tjson.writeAttribute(3, false, \"name\", clusterName);\r\n\t\t\t\t\tjson.writeAttribute(3, false, \"type\", db.getClusterIdByName(clusterName) > -1 ? \"Physical\" : \"Logical\");\r\n\t\t\t\t\tjson.writeAttribute(3, false, \"records\", db.countClusterElements(clusterName));\r\n\t\t\t\t\tjson.endObject(2, false);\r\n\t\t\t\t}\r\n\t\t\t\tjson.endCollection(1, true);\r\n\t\t\t}\r\n\r\n\t\t\tjson.beginCollection(1, false, \"users\");\r\n\t\t\tfor (OUser user : db.getMetadata().getSecurity().getUsers()) {\r\n\t\t\t\tjson.beginObject(2, true, null);\r\n\t\t\t\tjson.writeAttribute(3, false, \"name\", user.getName());\r\n\t\t\t\tjson.writeAttribute(3, false, \"roles\", user.getRoles() != null ? Arrays.toString(user.getRoles().toArray()) : \"null\");\r\n\t\t\t\tjson.endObject(2, false);\r\n\t\t\t}\r\n\t\t\tjson.endCollection(1, true);\r\n\r\n\t\t\tjson.beginCollection(1, false, \"roles\");\r\n\t\t\tfor (ORole role : db.getMetadata().getSecurity().getRoles()) {\r\n\t\t\t\tjson.beginObject(2, true, null);\r\n\t\t\t\tjson.writeAttribute(3, false, \"name\", role.getName());\r\n\t\t\t\tjson.writeAttribute(3, false, \"ACL\", \"not supported yet\");\r\n\t\t\t\tjson.endObject(2, false);\r\n\t\t\t}\r\n\t\t\tjson.endCollection(1, true);\r\n\r\n\t\t\tjson.endObject();\r\n\r\n\t\t\tsendTextContent(iRequest, OHttpUtils.STATUS_OK_CODE, \"OK\", null, OHttpUtils.CONTENT_TEXT_PLAIN, buffer.toString());\r\n\t\t} finally {\r\n\t\t\tif (db != null)\r\n\t\t\t\tOSharedDocumentDatabase.releaseDatabase(db);\r\n\t\t}\r\n\t}","id":33579,"modified_method":"public void execute(final OHttpRequest iRequest) throws Exception {\r\n\t\tString[] urlParts = checkSyntax(iRequest.url, 2, \"Syntax error: database/<database>\");\r\n\r\n\t\tiRequest.data.commandInfo = \"Database info\";\r\n\t\tiRequest.data.commandDetail = urlParts[1];\r\n\r\n\t\tODatabaseDocumentTx db = null;\r\n\r\n\t\ttry {\r\n\t\t\tdb = OSharedDocumentDatabase.acquireDatabase(urlParts[1]);\r\n\r\n\t\t\tfinal StringWriter buffer = new StringWriter();\r\n\t\t\tfinal OJSONWriter json = new OJSONWriter(buffer);\r\n\r\n\t\t\tjson.beginObject();\r\n\t\t\tif (db.getMetadata().getSchema().getClasses() != null) {\r\n\t\t\t\tjson.beginCollection(1, false, \"classes\");\r\n\t\t\t\tfor (OClass cls : db.getMetadata().getSchema().getClasses()) {\r\n\t\t\t\t\texportClass(db, json, cls);\r\n\t\t\t\t}\r\n\t\t\t\tjson.endCollection(1, true);\r\n\t\t\t}\r\n\r\n\t\t\tif (db.getClusterNames() != null) {\r\n\t\t\t\tjson.beginCollection(1, false, \"clusters\");\r\n\t\t\t\tfor (String clusterName : db.getClusterNames()) {\r\n\t\t\t\t\tjson.beginObject(2, true, null);\r\n\t\t\t\t\tjson.writeAttribute(3, false, \"id\", db.getClusterIdByName(clusterName));\r\n\t\t\t\t\tjson.writeAttribute(3, false, \"name\", clusterName);\r\n\t\t\t\t\tjson.writeAttribute(3, false, \"type\", db.getClusterIdByName(clusterName) > -1 ? \"Physical\" : \"Logical\");\r\n\t\t\t\t\tjson.writeAttribute(3, false, \"records\", db.countClusterElements(clusterName));\r\n\t\t\t\t\tjson.endObject(2, false);\r\n\t\t\t\t}\r\n\t\t\t\tjson.endCollection(1, true);\r\n\t\t\t}\r\n\r\n\t\t\tjson.beginCollection(1, false, \"users\");\r\n\t\t\tfor (OUser user : db.getMetadata().getSecurity().getUsers()) {\r\n\t\t\t\tjson.beginObject(2, true, null);\r\n\t\t\t\tjson.writeAttribute(3, false, \"name\", user.getName());\r\n\t\t\t\tjson.writeAttribute(3, false, \"roles\", user.getRoles() != null ? Arrays.toString(user.getRoles().toArray()) : \"null\");\r\n\t\t\t\tjson.endObject(2, false);\r\n\t\t\t}\r\n\t\t\tjson.endCollection(1, true);\r\n\r\n\t\t\tjson.beginCollection(1, false, \"roles\");\r\n\t\t\tfor (ORole role : db.getMetadata().getSecurity().getRoles()) {\r\n\t\t\t\tjson.beginObject(2, true, null);\r\n\t\t\t\tjson.writeAttribute(3, false, \"name\", role.getName());\r\n\t\t\t\tjson.writeAttribute(3, false, \"ACL\", \"not supported yet\");\r\n\t\t\t\tjson.endObject(2, false);\r\n\t\t\t}\r\n\t\t\tjson.endCollection(1, true);\r\n\r\n\t\t\tjson.endObject();\r\n\r\n\t\t\tsendTextContent(iRequest, OHttpUtils.STATUS_OK_CODE, \"OK\", null, OHttpUtils.CONTENT_TEXT_PLAIN, buffer.toString());\r\n\t\t} finally {\r\n\t\t\tif (db != null)\r\n\t\t\t\tOSharedDocumentDatabase.releaseDatabase(db);\r\n\t\t}\r\n\t}","commit_id":"280f03b61bd4538d0383e04d7d9ba10dec708b7c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unchecked\")\r\n\tpublic void execute(final OHttpRequest iRequest) throws Exception {\r\n\t\tString[] urlParts = checkSyntax(\r\n\t\t\t\tiRequest.url,\r\n\t\t\t\t3,\r\n\t\t\t\t\"Syntax error: query/sql/<query-text>[/<limit>]<br/>Limit is optional and is setted to 20 by default. Set expressely to 0 to have no limits.\");\r\n\r\n\t\tfinal int limit = urlParts.length > 3 ? Integer.parseInt(urlParts[3]) : 20;\r\n\t\tfinal String text = urlParts[2].trim();\r\n\r\n\t\tiRequest.data.commandInfo = \"Query\";\r\n\t\tiRequest.data.commandDetail = text;\r\n\r\n\t\tif (!text.toLowerCase().startsWith(\"select\"))\r\n\t\t\tthrow new IllegalArgumentException(\"Only SQL Select are valid using HTTP GET\");\r\n\r\n\t\tODatabaseDocumentTx db = null;\r\n\r\n\t\tfinal List<ORecord<?>> response;\r\n\r\n\t\ttry {\r\n\t\t\tdb = OSharedDocumentDatabase.acquireDatabase(urlParts[1]);\r\n\r\n\t\t\tresponse = (List<ORecord<?>>) db.command(new OSQLSynchQuery<ORecordSchemaAware<?>>(text, limit)).execute();\r\n\r\n\t\t} finally {\r\n\t\t\tif (db != null)\r\n\t\t\t\tOSharedDocumentDatabase.releaseDatabase(db);\r\n\t\t}\r\n\r\n\t\tsendRecordsContent(iRequest, response);\r\n\t}","id":33580,"modified_method":"@SuppressWarnings(\"unchecked\")\r\n\tpublic void execute(final OHttpRequest iRequest) throws Exception {\r\n\t\tString[] urlParts = checkSyntax(\r\n\t\t\t\tiRequest.url,\r\n\t\t\t\t4,\r\n\t\t\t\t\"Syntax error: query/sql/<query-text>[/<limit>]<br/>Limit is optional and is setted to 20 by default. Set expressely to 0 to have no limits.\");\r\n\r\n\t\tfinal int limit = urlParts.length > 4 ? Integer.parseInt(urlParts[4]) : 20;\r\n\t\tfinal String text = urlParts[3].trim();\r\n\r\n\t\tiRequest.data.commandInfo = \"Query\";\r\n\t\tiRequest.data.commandDetail = text;\r\n\r\n\t\tif (!text.toLowerCase().startsWith(\"select\"))\r\n\t\t\tthrow new IllegalArgumentException(\"Only SQL Select are valid using HTTP GET\");\r\n\r\n\t\tODatabaseDocumentTx db = null;\r\n\r\n\t\tfinal List<ORecord<?>> response;\r\n\r\n\t\ttry {\r\n\t\t\tdb = OSharedDocumentDatabase.acquireDatabase(urlParts[2]);\r\n\r\n\t\t\tresponse = (List<ORecord<?>>) db.command(new OSQLSynchQuery<ORecordSchemaAware<?>>(text, limit)).execute();\r\n\r\n\t\t} finally {\r\n\t\t\tif (db != null)\r\n\t\t\t\tOSharedDocumentDatabase.releaseDatabase(db);\r\n\t\t}\r\n\r\n\t\tsendRecordsContent(iRequest, response);\r\n\t}","commit_id":"280f03b61bd4538d0383e04d7d9ba10dec708b7c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void execute(final OHttpRequest iRequest) throws Exception {\r\n\t\tcheckSyntax(iRequest.url, 1, \"Syntax error: server\");\r\n\r\n\t\tiRequest.data.commandInfo = \"Server status\";\r\n\r\n\t\ttry {\r\n\t\t\tStringWriter jsonBuffer = new StringWriter();\r\n\t\t\tOJSONWriter json = new OJSONWriter(jsonBuffer);\r\n\r\n\t\t\tjson.beginObject();\r\n\r\n\t\t\tjson.beginCollection(1, true, \"connections\");\r\n\t\t\tOClientConnection[] conns = OServerMain.server().getManagedServer().getConnections();\r\n\t\t\tfor (OClientConnection c : conns) {\r\n\t\t\t\tjson.beginObject(2);\r\n\t\t\t\twriteField(json, 2, \"id\", c.id);\r\n\t\t\t\twriteField(json, 2, \"id\", c.id);\r\n\t\t\t\twriteField(json, 2, \"remoteAddress\", c.protocol.getChannel() != null ? c.protocol.getChannel().toString() : \"Disconnected\");\r\n\t\t\t\twriteField(json, 2, \"db\", c.database);\r\n\t\t\t\twriteField(json, 2, \"protocol\", c.protocol.getName());\r\n\t\t\t\twriteField(json, 2, \"totalRequests\", c.protocol.getData().totalRequests);\r\n\t\t\t\twriteField(json, 2, \"commandInfo\", c.protocol.getData().commandInfo);\r\n\t\t\t\twriteField(json, 2, \"commandDetail\", c.protocol.getData().commandDetail);\r\n\t\t\t\twriteField(json, 2, \"lastCommandOn\", dateTimeFormat.format(new Date(c.protocol.getData().lastCommandReceived)));\r\n\t\t\t\twriteField(json, 2, \"lastCommandInfo\", c.protocol.getData().lastCommandInfo);\r\n\t\t\t\twriteField(json, 2, \"lastCommandDetail\", c.protocol.getData().lastCommandDetail);\r\n\t\t\t\twriteField(json, 2, \"lastExecutionTime\", c.protocol.getData().lastCommandExecutionTime);\r\n\t\t\t\twriteField(json, 2, \"totalWorkingTime\", c.protocol.getData().totalCommandExecutionTime);\r\n\t\t\t\twriteField(json, 2, \"connectedOn\", dateTimeFormat.format(new Date(c.since)));\r\n\t\t\t\tjson.endObject(2);\r\n\t\t\t}\r\n\t\t\tjson.endCollection(1, false);\r\n\r\n\t\t\tjson.beginCollection(1, true, \"dbs\");\r\n\t\t\tMap<String, OResourcePool<String, ODatabaseDocumentTx>> dbPool = OSharedDocumentDatabase.getDatabasePools();\r\n\t\t\tfor (Entry<String, OResourcePool<String, ODatabaseDocumentTx>> entry : dbPool.entrySet()) {\r\n\t\t\t\tfor (ODatabaseDocumentTx db : entry.getValue().getResources()) {\r\n\r\n\t\t\t\t\tjson.beginObject(2);\r\n\t\t\t\t\twriteField(json, 2, \"db\", db.getName());\r\n\t\t\t\t\twriteField(json, 2, \"open\", !db.isClosed());\r\n\t\t\t\t\twriteField(json, 2, \"storage\", db.getStorage().getClass().getSimpleName());\r\n\t\t\t\t\tjson.endObject(2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tjson.endCollection(1, false);\r\n\r\n\t\t\tjson.beginCollection(1, true, \"storages\");\r\n\t\t\tOStorage[] storages = OServerMain.server().getManagedServer().getOpenedStorages();\r\n\t\t\tfor (OStorage s : storages) {\r\n\t\t\t\tjson.beginObject(2);\r\n\t\t\t\twriteField(json, 2, \"name\", s.getName());\r\n\t\t\t\twriteField(json, 2, \"type\", s.getClass().getSimpleName());\r\n\t\t\t\twriteField(json, 2, \"path\", s instanceof OStorageLocal ? ((OStorageLocal) s).getStoragePath() : \"\");\r\n\t\t\t\twriteField(json, 2, \"activeUsers\", s.getUsers());\r\n\t\t\t\tjson.endObject(2);\r\n\t\t\t}\r\n\t\t\tjson.endCollection(1, false);\r\n\r\n\t\t\tjson.beginObject(1, true, \"profiler\");\r\n\t\t\tjson.beginCollection(2, true, \"stats\");\r\n\t\t\tfor (Entry<String, Long> s : OProfiler.getInstance().getStatistics()) {\r\n\t\t\t\tjson.beginObject(3);\r\n\t\t\t\twriteField(json, 3, \"name\", s.getKey());\r\n\t\t\t\twriteField(json, 3, \"value\", s.getValue());\r\n\t\t\t\tjson.endObject(3);\r\n\t\t\t}\r\n\t\t\tjson.endCollection(2, false);\r\n\t\t\tjson.beginCollection(2, true, \"chronos\");\r\n\t\t\tfor (Entry<String, Chrono> c : OProfiler.getInstance().getChronos()) {\r\n\t\t\t\tjson.beginObject(3);\r\n\t\t\t\twriteField(json, 3, \"name\", c.getKey());\r\n\t\t\t\twriteField(json, 3, \"total\", c.getValue().items);\r\n\t\t\t\twriteField(json, 3, \"averageElapsed\", c.getValue().averageElapsed);\r\n\t\t\t\twriteField(json, 3, \"minElapsed\", c.getValue().minElapsed);\r\n\t\t\t\twriteField(json, 3, \"maxElapsed\", c.getValue().maxElapsed);\r\n\t\t\t\twriteField(json, 3, \"lastElapsed\", c.getValue().lastElapsed);\r\n\t\t\t\twriteField(json, 3, \"totalElapsed\", c.getValue().totalElapsed);\r\n\t\t\t\tjson.endObject(3);\r\n\t\t\t}\r\n\t\t\tjson.endCollection(2, false);\r\n\t\t\tjson.endObject(1);\r\n\r\n\t\t\tjson.endObject();\r\n\r\n\t\t\tsendTextContent(iRequest, OHttpUtils.STATUS_OK_CODE, \"OK\", null, OHttpUtils.CONTENT_TEXT_PLAIN, jsonBuffer.toString());\r\n\r\n\t\t} finally {\r\n\t\t}\r\n\t}","id":33581,"modified_method":"public void execute(final OHttpRequest iRequest) throws Exception {\r\n\t\tcheckSyntax(iRequest.url, 1, \"Syntax error: server\");\r\n\r\n\t\tiRequest.data.commandInfo = \"Server status\";\r\n\r\n\t\ttry {\r\n\t\t\tStringWriter jsonBuffer = new StringWriter();\r\n\t\t\tOJSONWriter json = new OJSONWriter(jsonBuffer);\r\n\r\n\t\t\tjson.beginObject();\r\n\r\n\t\t\tjson.beginCollection(1, true, \"connections\");\r\n\t\t\tOClientConnection[] conns = OServerMain.server().getManagedServer().getConnections();\r\n\t\t\tfor (OClientConnection c : conns) {\r\n\t\t\t\tjson.beginObject(2);\r\n\t\t\t\twriteField(json, 2, \"id\", c.id);\r\n\t\t\t\twriteField(json, 2, \"id\", c.id);\r\n\t\t\t\twriteField(json, 2, \"remoteAddress\", c.protocol.getChannel() != null ? c.protocol.getChannel().toString() : \"Disconnected\");\r\n\t\t\t\twriteField(json, 2, \"db\", c.database != null ? c.database.getName() : \"-\");\r\n\t\t\t\twriteField(json, 2, \"protocol\", c.protocol.getName());\r\n\t\t\t\twriteField(json, 2, \"totalRequests\", c.protocol.getData().totalRequests);\r\n\t\t\t\twriteField(json, 2, \"commandInfo\", c.protocol.getData().commandInfo);\r\n\t\t\t\twriteField(json, 2, \"commandDetail\", c.protocol.getData().commandDetail);\r\n\t\t\t\twriteField(json, 2, \"lastCommandOn\", dateTimeFormat.format(new Date(c.protocol.getData().lastCommandReceived)));\r\n\t\t\t\twriteField(json, 2, \"lastCommandInfo\", c.protocol.getData().lastCommandInfo);\r\n\t\t\t\twriteField(json, 2, \"lastCommandDetail\", c.protocol.getData().lastCommandDetail);\r\n\t\t\t\twriteField(json, 2, \"lastExecutionTime\", c.protocol.getData().lastCommandExecutionTime);\r\n\t\t\t\twriteField(json, 2, \"totalWorkingTime\", c.protocol.getData().totalCommandExecutionTime);\r\n\t\t\t\twriteField(json, 2, \"connectedOn\", dateTimeFormat.format(new Date(c.since)));\r\n\t\t\t\tjson.endObject(2);\r\n\t\t\t}\r\n\t\t\tjson.endCollection(1, false);\r\n\r\n\t\t\tjson.beginCollection(1, true, \"dbs\");\r\n\t\t\tMap<String, OResourcePool<String, ODatabaseDocumentTx>> dbPool = OSharedDocumentDatabase.getDatabasePools();\r\n\t\t\tfor (Entry<String, OResourcePool<String, ODatabaseDocumentTx>> entry : dbPool.entrySet()) {\r\n\t\t\t\tfor (ODatabaseDocumentTx db : entry.getValue().getResources()) {\r\n\r\n\t\t\t\t\tjson.beginObject(2);\r\n\t\t\t\t\twriteField(json, 2, \"db\", db.getName());\r\n\t\t\t\t\twriteField(json, 2, \"open\", !db.isClosed());\r\n\t\t\t\t\twriteField(json, 2, \"storage\", db.getStorage().getClass().getSimpleName());\r\n\t\t\t\t\tjson.endObject(2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tjson.endCollection(1, false);\r\n\r\n\t\t\tjson.beginCollection(1, true, \"storages\");\r\n\t\t\tOStorage[] storages = OServerMain.server().getManagedServer().getOpenedStorages();\r\n\t\t\tfor (OStorage s : storages) {\r\n\t\t\t\tjson.beginObject(2);\r\n\t\t\t\twriteField(json, 2, \"name\", s.getName());\r\n\t\t\t\twriteField(json, 2, \"type\", s.getClass().getSimpleName());\r\n\t\t\t\twriteField(json, 2, \"path\", s instanceof OStorageLocal ? ((OStorageLocal) s).getStoragePath() : \"\");\r\n\t\t\t\twriteField(json, 2, \"activeUsers\", s.getUsers());\r\n\t\t\t\tjson.endObject(2);\r\n\t\t\t}\r\n\t\t\tjson.endCollection(1, false);\r\n\r\n\t\t\tjson.beginObject(1, true, \"profiler\");\r\n\t\t\tjson.beginCollection(2, true, \"stats\");\r\n\t\t\tfor (Entry<String, Long> s : OProfiler.getInstance().getStatistics()) {\r\n\t\t\t\tjson.beginObject(3);\r\n\t\t\t\twriteField(json, 3, \"name\", s.getKey());\r\n\t\t\t\twriteField(json, 3, \"value\", s.getValue());\r\n\t\t\t\tjson.endObject(3);\r\n\t\t\t}\r\n\t\t\tjson.endCollection(2, false);\r\n\t\t\tjson.beginCollection(2, true, \"chronos\");\r\n\t\t\tfor (Entry<String, Chrono> c : OProfiler.getInstance().getChronos()) {\r\n\t\t\t\tjson.beginObject(3);\r\n\t\t\t\twriteField(json, 3, \"name\", c.getKey());\r\n\t\t\t\twriteField(json, 3, \"total\", c.getValue().items);\r\n\t\t\t\twriteField(json, 3, \"averageElapsed\", c.getValue().averageElapsed);\r\n\t\t\t\twriteField(json, 3, \"minElapsed\", c.getValue().minElapsed);\r\n\t\t\t\twriteField(json, 3, \"maxElapsed\", c.getValue().maxElapsed);\r\n\t\t\t\twriteField(json, 3, \"lastElapsed\", c.getValue().lastElapsed);\r\n\t\t\t\twriteField(json, 3, \"totalElapsed\", c.getValue().totalElapsed);\r\n\t\t\t\tjson.endObject(3);\r\n\t\t\t}\r\n\t\t\tjson.endCollection(2, false);\r\n\t\t\tjson.endObject(1);\r\n\r\n\t\t\tjson.endObject();\r\n\r\n\t\t\tsendTextContent(iRequest, OHttpUtils.STATUS_OK_CODE, \"OK\", null, OHttpUtils.CONTENT_TEXT_PLAIN, jsonBuffer.toString());\r\n\r\n\t\t} finally {\r\n\t\t}\r\n\t}","commit_id":"280f03b61bd4538d0383e04d7d9ba10dec708b7c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void execute(final OHttpRequest iRequest) throws Exception {\r\n\t\tiRequest.data.commandInfo = \"Get static content\";\r\n\t\tiRequest.data.commandDetail = iRequest.url;\r\n\r\n\t\tInputStream bufferedFile = null;\r\n\t\ttry {\r\n\t\t\tString url = OHttpUtils.URL_SEPARATOR.equals(iRequest.url) ? url = \"/www/index.htm\" : iRequest.url;\r\n\t\t\turl = WWW_PATH + url.substring(\"www\".length() + 1, url.length());\r\n\t\t\tfinal File inputFile = new File(url);\r\n\t\t\tif (!inputFile.exists()) {\r\n\t\t\t\tsendStatus(iRequest, 404, \"File not found\");\r\n\t\t\t\tiRequest.channel.flush();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tString type = null;\r\n\t\t\tif (url.endsWith(\".htm\") || url.endsWith(\".html\"))\r\n\t\t\t\ttype = \"text/html\";\r\n\t\t\telse if (url.endsWith(\".png\"))\r\n\t\t\t\ttype = \"image/png\";\r\n\t\t\telse if (url.endsWith(\".jpeg\"))\r\n\t\t\t\ttype = \"image/jpeg\";\r\n\t\t\telse if (url.endsWith(\".js\"))\r\n\t\t\t\ttype = \"application/x-javascript\";\r\n\t\t\telse if (url.endsWith(\".css\"))\r\n\t\t\t\ttype = \"text/css\";\r\n\r\n\t\t\tbufferedFile = new BufferedInputStream(new FileInputStream(inputFile));\r\n\r\n\t\t\tsendBinaryContent(iRequest, OHttpUtils.STATUS_OK_CODE, OHttpUtils.STATUS_OK_DESCRIPTION, type, bufferedFile, inputFile\r\n\t\t\t\t\t.length());\r\n\r\n\t\t} catch (IOException e) {\r\n\t\t\te.printStackTrace();\r\n\r\n\t\t} finally {\r\n\t\t\tif (bufferedFile != null)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tbufferedFile.close();\r\n\t\t\t\t} catch (IOException e) {\r\n\t\t\t\t}\r\n\t\t}\r\n\t}","id":33582,"modified_method":"public void execute(final OHttpRequest iRequest) throws Exception {\r\n\t\tiRequest.data.commandInfo = \"Get static content\";\r\n\t\tiRequest.data.commandDetail = iRequest.url;\r\n\r\n\t\tif (cache == null) {\r\n\t\t\t// CREATE THE CACHE IF ENABLED\r\n\t\t\tfor (OStorageEntryConfiguration entry : OServerMain.server().getConfiguration().properties) {\r\n\t\t\t\tif (CACHE_PAR.equals(entry.name)) {\r\n\t\t\t\t\tif (Boolean.parseBoolean(entry.value))\r\n\t\t\t\t\t\tcache = new HashMap<String, OStaticContentCachedEntry>();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tInputStream is = null;\r\n\t\tlong contentSize = 0;\r\n\t\tString type = null;\r\n\r\n\t\ttry {\r\n\t\t\tString url = OHttpUtils.URL_SEPARATOR.equals(iRequest.url) ? url = \"/www/index.htm\" : iRequest.url;\r\n\t\t\turl = WWW_PATH + url.substring(\"www\".length() + 1, url.length());\r\n\r\n\t\t\tif (cache != null) {\r\n\t\t\t\tsynchronized (cache) {\r\n\t\t\t\t\tfinal OStaticContentCachedEntry cachedEntry = cache.get(url);\r\n\t\t\t\t\tif (cachedEntry != null) {\r\n\t\t\t\t\t\tis = new ByteArrayInputStream(cachedEntry.content);\r\n\t\t\t\t\t\tcontentSize = cachedEntry.size;\r\n\t\t\t\t\t\ttype = cachedEntry.type;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (is == null) {\r\n\t\t\t\tfinal File inputFile = new File(url);\r\n\t\t\t\tif (!inputFile.exists()) {\r\n\t\t\t\t\tsendStatus(iRequest, 404, \"File not found\");\r\n\t\t\t\t\tiRequest.channel.flush();\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (url.endsWith(\".htm\") || url.endsWith(\".html\"))\r\n\t\t\t\t\ttype = \"text/html\";\r\n\t\t\t\telse if (url.endsWith(\".png\"))\r\n\t\t\t\t\ttype = \"image/png\";\r\n\t\t\t\telse if (url.endsWith(\".jpeg\"))\r\n\t\t\t\t\ttype = \"image/jpeg\";\r\n\t\t\t\telse if (url.endsWith(\".js\"))\r\n\t\t\t\t\ttype = \"application/x-javascript\";\r\n\t\t\t\telse if (url.endsWith(\".css\"))\r\n\t\t\t\t\ttype = \"text/css\";\r\n\r\n\t\t\t\tis = new BufferedInputStream(new FileInputStream(inputFile));\r\n\t\t\t\tcontentSize = inputFile.length();\r\n\r\n\t\t\t\tif (cache != null) {\r\n\t\t\t\t\t// READ AL THE STREAM AND CACHE IT IN MEMORY\r\n\t\t\t\t\tbyte[] buffer = new byte[(int) contentSize];\r\n\t\t\t\t\tfor (int i = 0; i < contentSize; ++i)\r\n\t\t\t\t\t\tbuffer[i] = (byte) is.read();\r\n\r\n\t\t\t\t\tOStaticContentCachedEntry cachedEntry = new OStaticContentCachedEntry();\r\n\t\t\t\t\tcachedEntry.content = buffer;\r\n\t\t\t\t\tcachedEntry.size = contentSize;\r\n\t\t\t\t\tcachedEntry.type = type;\r\n\r\n\t\t\t\t\tcache.put(url, cachedEntry);\r\n\r\n\t\t\t\t\tis = new ByteArrayInputStream(cachedEntry.content);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tsendBinaryContent(iRequest, OHttpUtils.STATUS_OK_CODE, OHttpUtils.STATUS_OK_DESCRIPTION, type, is, contentSize);\r\n\r\n\t\t} catch (IOException e) {\r\n\t\t\te.printStackTrace();\r\n\r\n\t\t} finally {\r\n\t\t\tif (is != null)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tis.close();\r\n\t\t\t\t} catch (IOException e) {\r\n\t\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"280f03b61bd4538d0383e04d7d9ba10dec708b7c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void execute(final OHttpRequest iRequest) throws Exception {\r\n\t\tString[] urlParts = checkSyntax(iRequest.url, 2, \"Syntax error: document/<database>\");\r\n\r\n\t\tiRequest.data.commandInfo = \"Create document\";\r\n\r\n\t\tODatabaseDocumentTx db = null;\r\n\t\tODocument doc = new ODocument().fromJSON(iRequest.content);\r\n\t\ttry {\r\n\t\t\tdb = OSharedDocumentDatabase.acquireDatabase(urlParts[1]);\r\n\r\n\t\t\tdoc.save(db);\r\n\r\n\t\t} finally {\r\n\t\t\tif (db != null)\r\n\t\t\t\tOSharedDocumentDatabase.releaseDatabase(db);\r\n\t\t}\r\n\r\n\t\tsendTextContent(iRequest, OHttpUtils.STATUS_OK_CODE, OHttpUtils.STATUS_OK_DESCRIPTION, null, OHttpUtils.CONTENT_TEXT_PLAIN,\r\n\t\t\t\t\"Record \" + doc.getIdentity() + \" created successfully.\");\r\n\t}","id":33583,"modified_method":"public void execute(final OHttpRequest iRequest) throws Exception {\r\n\t\tString[] urlParts = checkSyntax(iRequest.url, 2, \"Syntax error: document/<database>\");\r\n\r\n\t\tiRequest.data.commandInfo = \"Create document\";\r\n\r\n\t\tODatabaseDocumentTx db = null;\r\n\t\tODocument doc = new ODocument().fromJSON(iRequest.content);\r\n\t\ttry {\r\n\t\t\tdb = OSharedDocumentDatabase.acquireDatabase(urlParts[1]);\r\n\r\n\t\t\tdoc.save(db);\r\n\r\n\t\t} finally {\r\n\t\t\tif (db != null)\r\n\t\t\t\tOSharedDocumentDatabase.releaseDatabase(db);\r\n\t\t}\r\n\r\n\t\tsendTextContent(iRequest, 201, OHttpUtils.STATUS_OK_DESCRIPTION, null, OHttpUtils.CONTENT_TEXT_PLAIN, \"Record \"\r\n\t\t\t\t+ doc.getIdentity() + \" created successfully.\");\r\n\t}","commit_id":"280f03b61bd4538d0383e04d7d9ba10dec708b7c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n   * Standard process action method.\n   * @param ae ActionEvent\n   * @throws AbortProcessingException\n   */\n  public void processAction(ActionEvent ae) throws AbortProcessingException {\n\n    //boolean correct=false;\n\n    log.debug(\"ItemAdd LISTENER.\");\n\n    ItemAuthorBean itemauthorbean = (ItemAuthorBean) ContextUtil.lookupBean(\"itemauthor\");\n    ItemBean item = itemauthorbean.getCurrentItem();\n    String iText = ContextUtil.stringWYSIWYG(item.getItemText());\n    String iInstruction = ContextUtil.stringWYSIWYG(item.getInstruction());\n    String iType = item.getItemType();\n    String err=\"\";\n    FacesContext context=FacesContext.getCurrentInstance();\n   \n    // SAK-6050\n    // if((!iType.equals(TypeFacade.MATCHING.toString())&&((iText==null)||(iText.replaceAll(\"<.*?>\", \"\").trim().equals(\"\"))))|| (iType.equals(TypeFacade.MATCHING.toString()) && ((iInstruction==null)||(iInstruction.replaceAll(\"<.*?>\", \"\").trim().equals(\"\"))))){\n    if((!iType.equals(TypeFacade.MATCHING.toString())&&((iText==null)||(iText.toLowerCase().replaceAll(\"<^[^(img)]*?>\", \"\").trim().equals(\"\"))))|| (iType.equals(TypeFacade.MATCHING.toString()) && ((iInstruction==null)||(iInstruction.toLowerCase().replaceAll(\"<^[^(img)]*?>\", \"\").trim().equals(\"\"))))){ \n\t\n \n\tString emptyText_err = ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AuthorMessages\",\"emptyText_error\");     \n\tcontext.addMessage(null,new FacesMessage(emptyText_err));\n\treturn;\n\n    }   \n   \n    if(iType.equals(TypeFacade.MULTIPLE_CHOICE.toString()))\n\tcheckMC(true);\n\n    if(iType.equals(TypeFacade.MULTIPLE_CORRECT.toString()))\n\tcheckMC(false);\n    if(iType.equals(TypeFacade.MATCHING.toString()))\n        {   \n            ArrayList l=item.getMatchItemBeanList();\n\t    if (l==null || l.size()==0){\n\t\tString noPairMatching_err=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AuthorMessages\",\"noMatchingPair_error\");\n\t\tcontext.addMessage(null,new FacesMessage(noPairMatching_err));\n\t\terror=true;\n\t    }\n\t}\n    if(error)\n\treturn;\n    \n    if(iType.equals(TypeFacade.FILL_IN_BLANK.toString())){\n\t\n    \tif(isErrorFIB()){\n    \t\terr=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AuthorMessages\",\"pool_missingBracket_error\");\n    \t\tcontext.addMessage(null,new FacesMessage(err));\n    \t\titem.setOutcome(\"fillInBlackItem\");\n    \t\titem.setPoolOutcome(\"fillInBlackItem\");\n    \t\treturn;\n    \t}\n    }\n    \n    if(iType.equals(TypeFacade.FILL_IN_NUMERIC.toString())){\n    \t\n    \tif(isErrorFIN()){\n    \t    err=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AuthorMessages\",\"pool_missingBracket_error\");\n    \t    context.addMessage(null,new FacesMessage(err));\n    \t    item.setOutcome(\"fillInNumericItem\");\n    \t    item.setPoolOutcome(\"fillInNumericItem\");\n    \t    return;\n\n    \t}\n    }\n    \n    if(iType.equals(TypeFacade.AUDIO_RECORDING.toString())){\n    \tif (Integer.parseInt(item.getTimeAllowed()) < 1) {\n    \t\terr=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AuthorMessages\",\"submissions_allowed_error\");\n    \t    context.addMessage(null,new FacesMessage(err));\n    \t    item.setOutcome(\"audioRecItem\");\n    \t    item.setPoolOutcome(\"audioRecItem\");\n    \t    return;\n    \t}\n    }\n\t\n    if (!saveItem(itemauthorbean)){\n\tthrow new RuntimeException(\"failed to saveItem.\");\n    }\n    item.setOutcome(\"editAssessment\");\n    item.setPoolOutcome(\"editPool\");\n    itemauthorbean.setItemTypeString(\"\");\n  }","id":33584,"modified_method":"/**\n   * Standard process action method.\n   * @param ae ActionEvent\n   * @throws AbortProcessingException\n   */\n  public void processAction(ActionEvent ae) throws AbortProcessingException {\n\n    //boolean correct=false;\n\n    log.debug(\"ItemAdd LISTENER.\");\n\n    ItemAuthorBean itemauthorbean = (ItemAuthorBean) ContextUtil.lookupBean(\"itemauthor\");\n    ItemBean item = itemauthorbean.getCurrentItem();\n    String iText = ContextUtil.stringWYSIWYG(item.getItemText());\n    String iInstruction = ContextUtil.stringWYSIWYG(item.getInstruction());\n    String iType = item.getItemType();\n    String err=\"\";\n    FacesContext context=FacesContext.getCurrentInstance();\n   \n    // SAK-6050\n    // if((!iType.equals(TypeFacade.MATCHING.toString())&&((iText==null)||(iText.replaceAll(\"<.*?>\", \"\").trim().equals(\"\"))))|| (iType.equals(TypeFacade.MATCHING.toString()) && ((iInstruction==null)||(iInstruction.replaceAll(\"<.*?>\", \"\").trim().equals(\"\"))))){\n    if((!iType.equals(TypeFacade.MATCHING.toString())&&((iText==null)||(iText.toLowerCase().replaceAll(\"<^[^(img)]*?>\", \"\").trim().equals(\"\"))))|| (iType.equals(TypeFacade.MATCHING.toString()) && ((iInstruction==null)||(iInstruction.toLowerCase().replaceAll(\"<^[^(img)]*?>\", \"\").trim().equals(\"\"))))){ \n\t\n \n\tString emptyText_err = ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AuthorMessages\",\"emptyText_error\");     \n\tcontext.addMessage(null,new FacesMessage(emptyText_err));\n\treturn;\n\n    }   \n   \n    if(iType.equals(TypeFacade.MULTIPLE_CHOICE.toString()))\n\tcheckMC(true);\n\n    if(iType.equals(TypeFacade.MULTIPLE_CORRECT.toString()))\n\tcheckMC(false);\n    if(iType.equals(TypeFacade.MATCHING.toString()))\n        {   \n            ArrayList l=item.getMatchItemBeanList();\n\t    if (l==null || l.size()==0){\n\t\tString noPairMatching_err=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AuthorMessages\",\"noMatchingPair_error\");\n\t\tcontext.addMessage(null,new FacesMessage(noPairMatching_err));\n\t\terror=true;\n\t    }\n\t}\n    if(error)\n\treturn;\n    \n    if(iType.equals(TypeFacade.FILL_IN_BLANK.toString())){\n\t\n    \tif(isErrorFIB()){\n    \t\terr=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AuthorMessages\",\"pool_missingBracket_error\");\n    \t\tcontext.addMessage(null,new FacesMessage(err));\n    \t\titem.setOutcome(\"fillInBlackItem\");\n    \t\titem.setPoolOutcome(\"fillInBlackItem\");\n    \t\treturn;\n    \t}\n    }\n    \n    if(iType.equals(TypeFacade.FILL_IN_NUMERIC.toString())){\n    \t\n    \tif(isErrorFIN()){\n    \t    err=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AuthorMessages\",\"pool_missingBracket_error\");\n    \t    context.addMessage(null,new FacesMessage(err));\n    \t    item.setOutcome(\"fillInNumericItem\");\n    \t    item.setPoolOutcome(\"fillInNumericItem\");\n    \t    return;\n\n    \t}\n    }\n    \n    if(iType.equals(TypeFacade.AUDIO_RECORDING.toString())){\n    \ttry {\n\t   \t\tString timeAllowed = item.getTimeAllowed().trim();\n\t   \t\tint intTimeAllowed = Integer.parseInt(timeAllowed);\n\t   \t\tif (intTimeAllowed < 1) {\n\t   \t\t\tthrow new RuntimeException();\n\t   \t\t}\n    \t}\n\t\tcatch (RuntimeException e){\n\t\t\terr=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AuthorMessages\",\"submissions_allowed_error\");\n    \t    context.addMessage(null,new FacesMessage(err));\n    \t    item.setOutcome(\"audioRecItem\");\n    \t    item.setPoolOutcome(\"audioRecItem\");\n    \t    return;\n\t\t}    \t\n    }\n\t\n    if (!saveItem(itemauthorbean)){\n\tthrow new RuntimeException(\"failed to saveItem.\");\n    }\n    item.setOutcome(\"editAssessment\");\n    item.setPoolOutcome(\"editPool\");\n    itemauthorbean.setItemTypeString(\"\");\n  }","commit_id":"c82b318099a5463ef7e6630ae88aca80d4511050","url":"https://github.com/sakaiproject/sakai"},{"original_method":"private void handleNearCache(Node node) {\n        final String name = getAttribute(node, \"name\");\n        final NearCacheConfig nearCacheConfig = new NearCacheConfig();\n        for (Node child : new IterableNodeList(node.getChildNodes())) {\n            final String nodeName = cleanNodeName(child);\n            if (\"max-size\".equals(nodeName)) {\n                nearCacheConfig.setMaxSize(Integer.parseInt(getTextContent(child)));\n            } else if (\"time-to-live-seconds\".equals(nodeName)) {\n                nearCacheConfig.setTimeToLiveSeconds(Integer.parseInt(getTextContent(child)));\n            } else if (\"max-idle-seconds\".equals(nodeName)) {\n                nearCacheConfig.setMaxIdleSeconds(Integer.parseInt(getTextContent(child)));\n            } else if (\"eviction-policy\".equals(nodeName)) {\n                nearCacheConfig.setEvictionPolicy(getTextContent(child));\n            } else if (\"in-memory-format\".equals(nodeName)) {\n                nearCacheConfig.setInMemoryFormat(InMemoryFormat.valueOf(getTextContent(child)));\n            } else if (\"invalidate-on-change\".equals(nodeName)) {\n                nearCacheConfig.setInvalidateOnChange(Boolean.parseBoolean(getTextContent(child)));\n            } else if (\"cache-local-entries\".equals(nodeName)) {\n                nearCacheConfig.setCacheLocalEntries(Boolean.parseBoolean(getTextContent(child)));\n            } else if (\"local-update-policy\".equals(nodeName)) {\n                String value = getTextContent(child);\n                NearCacheConfig.LocalUpdatePolicy policy = NearCacheConfig.LocalUpdatePolicy.valueOf(value);\n                nearCacheConfig.setLocalUpdatePolicy(policy);\n            }\n        }\n        clientConfig.addNearCacheConfig(name, nearCacheConfig);\n    }","id":33585,"modified_method":"private void handleNearCache(Node node) {\n        final String name = getAttribute(node, \"name\");\n        final NearCacheConfig nearCacheConfig = new NearCacheConfig();\n        for (Node child : new IterableNodeList(node.getChildNodes())) {\n            final String nodeName = cleanNodeName(child);\n            String value = getTextContent(child).trim();\n            if (\"max-size\".equals(nodeName)) {\n                nearCacheConfig.setMaxSize(Integer.parseInt(value));\n            } else if (\"time-to-live-seconds\".equals(nodeName)) {\n                nearCacheConfig.setTimeToLiveSeconds(Integer.parseInt(value));\n            } else if (\"max-idle-seconds\".equals(nodeName)) {\n                nearCacheConfig.setMaxIdleSeconds(Integer.parseInt(value));\n            } else if (\"eviction-policy\".equals(nodeName)) {\n                nearCacheConfig.setEvictionPolicy(value);\n            } else if (\"in-memory-format\".equals(nodeName)) {\n                nearCacheConfig.setInMemoryFormat(InMemoryFormat.valueOf(upperCaseInternal(value)));\n            } else if (\"invalidate-on-change\".equals(nodeName)) {\n                nearCacheConfig.setInvalidateOnChange(Boolean.parseBoolean(value));\n            } else if (\"cache-local-entries\".equals(nodeName)) {\n                nearCacheConfig.setCacheLocalEntries(Boolean.parseBoolean(value));\n            } else if (\"local-update-policy\".equals(nodeName)) {\n                NearCacheConfig.LocalUpdatePolicy policy = NearCacheConfig.LocalUpdatePolicy.valueOf(value);\n                nearCacheConfig.setLocalUpdatePolicy(policy);\n            }\n        }\n        clientConfig.addNearCacheConfig(name, nearCacheConfig);\n    }","commit_id":"bdcf24e4beb0249ce55dcdd1d71dd737b555f855","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Returns the move handle.<p>\n     * \n     * @return the move handle\n     */\n    protected MoveHandle getMoveHandle() {\n\n        return m_moveHandle;\n    }","id":33586,"modified_method":"/**\n     * Returns the move handle.<p>\n     * \n     * @return the move handle\n     */\n    protected I_CmsDragHandle getMoveHandle() {\n\n        return m_moveHandle;\n    }","commit_id":"61b73f43804c2a4751cd2116de070bd7f09ca133","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.gwt.client.ui.CmsListItem#initMoveHandle(org.opencms.gwt.client.dnd.CmsDNDHandler)\n     */\n    @Override\n    public boolean initMoveHandle(CmsDNDHandler dndHandler) {\n\n        if (super.initMoveHandle(dndHandler)) {\n            // move handle should always be visible\n            getMoveHandle().addStyleName(\n                org.opencms.gwt.client.ui.css.I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().permaVisible());\n            return true;\n        }\n        return false;\n    }","id":33587,"modified_method":"/**\n     * @see org.opencms.gwt.client.ui.CmsListItem#initMoveHandle(org.opencms.gwt.client.dnd.CmsDNDHandler)\n     */\n    @Override\n    public boolean initMoveHandle(CmsDNDHandler dndHandler) {\n\n        if (super.initMoveHandle(dndHandler)) {\n            // move handle should always be visible\n            getMoveHandle().getElement().addClassName(\n                org.opencms.gwt.client.ui.css.I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().permaVisible());\n            return true;\n        }\n        return false;\n    }","commit_id":"61b73f43804c2a4751cd2116de070bd7f09ca133","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.gwt.client.ui.CmsListItem#initMoveHandle(org.opencms.gwt.client.dnd.CmsDNDHandler)\n     */\n    @Override\n    public boolean initMoveHandle(CmsDNDHandler dndHandler) {\n\n        if (super.initMoveHandle(dndHandler)) {\n            // move handle should always be visible\n            getMoveHandle().addStyleName(\n                org.opencms.gwt.client.ui.css.I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().permaVisible());\n            return true;\n        }\n        return false;\n    }","id":33588,"modified_method":"/**\n     * @see org.opencms.gwt.client.ui.CmsListItem#initMoveHandle(org.opencms.gwt.client.dnd.CmsDNDHandler)\n     */\n    @Override\n    public boolean initMoveHandle(CmsDNDHandler dndHandler) {\n\n        if (super.initMoveHandle(dndHandler)) {\n            // move handle should always be visible\n            getMoveHandle().getElement().addClassName(\n                org.opencms.gwt.client.ui.css.I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().permaVisible());\n            return true;\n        }\n        return false;\n    }","commit_id":"61b73f43804c2a4751cd2116de070bd7f09ca133","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.gwt.client.ui.CmsListItem#initMoveHandle(org.opencms.gwt.client.dnd.CmsDNDHandler)\n     */\n    @Override\n    public boolean initMoveHandle(CmsDNDHandler dndHandler) {\n\n        if (super.initMoveHandle(dndHandler)) {\n            // move handle should always be visible\n            getMoveHandle().addStyleName(\n                org.opencms.gwt.client.ui.css.I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().permaVisible());\n            return true;\n        }\n        return false;\n    }","id":33589,"modified_method":"/**\n     * @see org.opencms.gwt.client.ui.CmsListItem#initMoveHandle(org.opencms.gwt.client.dnd.CmsDNDHandler)\n     */\n    @Override\n    public boolean initMoveHandle(CmsDNDHandler dndHandler) {\n\n        if (super.initMoveHandle(dndHandler)) {\n            // move handle should always be visible\n            getMoveHandle().getElement().addClassName(\n                org.opencms.gwt.client.ui.css.I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().permaVisible());\n            return true;\n        }\n        return false;\n    }","commit_id":"61b73f43804c2a4751cd2116de070bd7f09ca133","url":"https://github.com/alkacon/opencms-core"},{"original_method":"@Override @DB\n    public SnapshotVO createSnapshotImpl(Long volumeId, Long policyId, Long snapshotId) throws ResourceAllocationException {\n    \tVolumeVO v = _volsDao.findById(volumeId);\n    \tif ( v != null && _volsDao.getHypervisorType(v.getId()).equals(HypervisorType.KVM)) {\n    \t\t/*KVM needs to lock on the vm of volume, because it takes snapshot on behalf of vm, not volume*/\n    \t\tUserVmVO uservm = _vmDao.findById(v.getInstanceId());\n    \t\tif (uservm != null) {\n    \t\t\tUserVmVO vm = _vmDao.acquireInLockTable(uservm.getId(), 10);\n    \t\t\tif (vm == null) {\n    \t\t\t\tthrow new CloudRuntimeException(\"Creating snapshot failed due to volume:\" + volumeId + \" is being used, try it later \");\n    \t\t\t}\n    \t\t}\n    \t}\n        Long poolId = v.getPoolId();\n        if (poolId == null) {\n            throw new CloudRuntimeException(\"Volume: \" + volumeId + \" is empty, don't need to create a snapshot\");\n        }\n        VolumeVO volume = _volsDao.acquireInLockTable(volumeId, 10);       \n        if( volume == null ) {\n            volume = _volsDao.findById(volumeId);\n            if( volume == null ){\n                throw new CloudRuntimeException(\"Creating snapshot failed due to volume:\" + volumeId + \" doesn't exist\");\n            } else {\n                throw new CloudRuntimeException(\"Creating snapshot failed due to volume:\" + volumeId + \" is being used, try it later \");\n            }\n        }\n        \n        if (_volsDao.getHypervisorType(volume.getId()).equals(HypervisorType.KVM)) {\n        \tStoragePoolVO storagePool = _storagePoolDao.findById(volume.getPoolId());\n        \tClusterVO cluster = _clusterDao.findById(storagePool.getClusterId());\n        \tList<HostVO> hosts = _hostDao.listByCluster(cluster.getId());\n        \tif (hosts != null && !hosts.isEmpty()) {\n        \t\tHostVO host = hosts.get(0);\n        \t\tif (!hostSupportSnapsthot(host)) {\n                    throw new CloudRuntimeException(\"KVM Snapshot is not supported on cluster: \" + host.getId());\n                }\n        \t}\n        }\n        \n        //if volume is attached to a vm in destroyed or expunging state; disallow\n        if(v.getInstanceId() != null) {\n            UserVmVO userVm = _vmDao.findById(v.getInstanceId());\n            if(userVm != null) {\n                if(userVm.getState().equals(State.Destroyed) || userVm.getState().equals(State.Expunging)) {\n                    throw new CloudRuntimeException(\"Creating snapshot failed due to volume:\" + volumeId + \" is associated with vm:\"+userVm.getInstanceName()+\" which is in \"+userVm.getState().toString()+\" state\");\n                }\n            }\n        }\n        \n        SnapshotVO snapshot = null;\n        boolean backedUp = false;\n        try {\n\t    \tsnapshot = createSnapshotOnPrimary(volume, policyId, snapshotId);\n\t        if (snapshot != null && snapshot.getStatus() == Snapshot.Status.CreatedOnPrimary ) {\n                snapshotId = snapshot.getId();\n\t            backedUp = backupSnapshotToSecondaryStorage(snapshot);\n\t            if (!backedUp) {\n\t                throw new CloudRuntimeException(\"Created snapshot: \" + snapshotId + \" on primary but failed to backup on secondary\");\n\t            }\n\t        }\n        } catch (Exception e){\n            throw new CloudRuntimeException(\"Creating snapshot failed due to \" + e.toString());\n        } finally {\n            // Cleanup jobs to do after the snapshot has been created.\n        \tif( snapshotId != null) {\n        \t\tpostCreateSnapshot(volumeId, snapshotId, policyId, backedUp);\n        \t}\n        \t_volsDao.releaseFromLockTable(volumeId);\n        }\n\n        return snapshot;\n    }","id":33590,"modified_method":"@Override @DB\n    public SnapshotVO createSnapshotImpl(Long volumeId, Long policyId, Long snapshotId) throws ResourceAllocationException {\n    \tVolumeVO v = _volsDao.findById(volumeId);\n    \tif ( v != null && _volsDao.getHypervisorType(v.getId()).equals(HypervisorType.KVM)) {\n    \t\t/*KVM needs to lock on the vm of volume, because it takes snapshot on behalf of vm, not volume*/\n    \t\tUserVmVO uservm = _vmDao.findById(v.getInstanceId());\n    \t\tif (uservm != null) {\n    \t\t\tUserVmVO vm = _vmDao.acquireInLockTable(uservm.getId(), 10);\n    \t\t\tif (vm == null) {\n    \t\t\t\tthrow new CloudRuntimeException(\"Creating snapshot failed due to volume:\" + volumeId + \" is being used, try it later \");\n    \t\t\t}\n    \t\t}\n    \t}\n        Long poolId = v.getPoolId();\n        if (poolId == null) {\n            throw new CloudRuntimeException(\"Volume: \" + volumeId + \" is empty, don't need to create a snapshot\");\n        }\n        VolumeVO volume = _volsDao.acquireInLockTable(volumeId, 10);       \n        if( volume == null ) {\n            volume = _volsDao.findById(volumeId);\n            if( volume == null ){\n                throw new CloudRuntimeException(\"Creating snapshot failed due to volume:\" + volumeId + \" doesn't exist\");\n            } else {\n                throw new CloudRuntimeException(\"Creating snapshot failed due to volume:\" + volumeId + \" is being used, try it later \");\n            }\n        }\n        \n        if (_volsDao.getHypervisorType(volume.getId()).equals(HypervisorType.KVM)) {\n        \tStoragePoolVO storagePool = _storagePoolDao.findById(volume.getPoolId());\n        \tClusterVO cluster = _clusterDao.findById(storagePool.getClusterId());\n        \tList<HostVO> hosts = _hostDao.listByCluster(cluster.getId());\n        \tif (hosts != null && !hosts.isEmpty()) {\n        \t\tHostVO host = hosts.get(0);\n        \t\tif (!hostSupportSnapsthot(host)) {\n                    throw new CloudRuntimeException(\"KVM Snapshot is not supported on cluster: \" + host.getId());\n                }\n        \t}\n        }\n        \n        //if volume is attached to a vm in destroyed or expunging state; disallow\n        if(v.getInstanceId() != null) {\n            UserVmVO userVm = _vmDao.findById(v.getInstanceId());\n            if(userVm != null) {\n                if(userVm.getState().equals(State.Destroyed) || userVm.getState().equals(State.Expunging)) {\n                    throw new CloudRuntimeException(\"Creating snapshot failed due to volume:\" + volumeId + \" is associated with vm:\"+userVm.getInstanceName()+\" is in \"+userVm.getState().toString()+\" state\");\n                }\n            }\n        }\n        \n        SnapshotVO snapshot = null;\n        boolean backedUp = false;\n        try {\n\t    \tsnapshot = createSnapshotOnPrimary(volume, policyId, snapshotId);\n\t        if (snapshot != null && snapshot.getStatus() == Snapshot.Status.CreatedOnPrimary ) {\n                snapshotId = snapshot.getId();\n\t            backedUp = backupSnapshotToSecondaryStorage(snapshot);\n\t            if (!backedUp) {\n\t                throw new CloudRuntimeException(\"Created snapshot: \" + snapshotId + \" on primary but failed to backup on secondary\");\n\t            }\n\t        }\n        } catch (Exception e){\n            throw new CloudRuntimeException(\"Creating snapshot failed due to \" + e.toString());\n        } finally {\n            // Cleanup jobs to do after the snapshot has been created.\n        \tif( snapshotId != null) {\n        \t\tpostCreateSnapshot(volumeId, snapshotId, policyId, backedUp);\n        \t}\n        \t_volsDao.releaseFromLockTable(volumeId);\n        }\n\n        return snapshot;\n    }","commit_id":"b2260059827e39c30d038351b8b51892fd740b7f","url":"https://github.com/apache/cloudstack"},{"original_method":"private void updateVmStateForFailedVmCreation(Long vmId) {\n\t\tUserVmVO vm = _vmDao.findById(vmId);\n\t\tif(vm != null){\n\t\t\tif(vm.getState().equals(State.Stopped)){\n\t\t\t\t_itMgr.stateTransitTo(vm, VirtualMachine.Event.OperationFailed, null);\n\t\t\t}\n\t\t}\n\t}","id":33591,"modified_method":"private void updateVmStateForFailedVmCreation(Long vmId) {\n\t\tUserVmVO vm = _vmDao.findById(vmId);\n\t\tif(vm != null){\n\t\t\tif(vm.getState().equals(State.Stopped)){\n\t\t\t\t_itMgr.stateTransitTo(vm, VirtualMachine.Event.OperationFailed, null);\n\t\t\t\t//destroy associated volumes for vm in error state\n\t\t\t\tList<VolumeVO> volumesForThisVm = _volsDao.findByInstance(vm.getId());\n\t\t\t\tfor(VolumeVO volume : volumesForThisVm) {\n\t\t\t\t    try {\n                        _storageMgr.destroyVolume(volume);\n                    } catch (ConcurrentOperationException e) {\n                        s_logger.warn(\"Unable to delete volume:\"+volume.getId()+\" for vm:\"+vmId+\" whilsts transitioning to error state\");\n                    }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"b2260059827e39c30d038351b8b51892fd740b7f","url":"https://github.com/apache/cloudstack"},{"original_method":"public Commands deltaSync(long hostId, Map<String, State> newStates) {\n        Map<Long, AgentVmInfo> states = convertToInfos(newStates);\n        Commands commands = new Commands(OnError.Continue);\n\n        for (Map.Entry<Long, AgentVmInfo> entry : states.entrySet()) {\n            AgentVmInfo info = entry.getValue();\n\n            VMInstanceVO vm = info.vm;\n\n            Command command = null;\n            if (vm != null) {\n                HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n                command = compareState(vm, info, false, hvGuru.trackVmHostChange());\n            } else {\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"Cleaning up a VM that is no longer found: \" + info.name);\n                }\n                command = cleanup(info.name);\n            }\n\n            if (command != null) {\n                commands.addCommand(command);\n            }\n        }\n\n        return commands;\n    }","id":33592,"modified_method":"public Commands deltaSync(long hostId, Map<String, State> newStates) {\n        Map<Long, AgentVmInfo> states = convertToInfos(newStates);\n        Commands commands = new Commands(OnError.Continue);\n\n        for (Map.Entry<Long, AgentVmInfo> entry : states.entrySet()) {\n            AgentVmInfo info = entry.getValue();\n\n            VMInstanceVO vm = info.vm;\n\n            Command command = null;\n            if (vm != null) {\n                HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n                command = compareState(hostId, vm, info, false, hvGuru.trackVmHostChange());\n            } else {\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"Cleaning up a VM that is no longer found: \" + info.name);\n                }\n                command = cleanup(info.name);\n            }\n\n            if (command != null) {\n                commands.addCommand(command);\n            }\n        }\n\n        return commands;\n    }","commit_id":"50c1652172df6849796ade17016664ee40f3426a","url":"https://github.com/apache/cloudstack"},{"original_method":"/**\n     * compareState does as its name suggests and compares the states between management server and agent. It returns whether\n     * something should be cleaned up\n     * \n     */\n    protected Command compareState(VMInstanceVO vm, final AgentVmInfo info, final boolean fullSync, boolean nativeHA) {\n        State agentState = info.state;\n        final String agentName = info.name;\n        final State serverState = vm.getState();\n        final String serverName = vm.getInstanceName();\n\n        VirtualMachineGuru<VMInstanceVO> vmGuru = getVmGuru(vm);\n\n        Command command = null;\n\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"VM \" + serverName + \": server state = \" + serverState + \" and agent state = \" + agentState);\n        }\n\n        if (agentState == State.Error) {\n            agentState = State.Stopped;\n\n            short alertType = AlertManager.ALERT_TYPE_USERVM;\n            if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n                alertType = AlertManager.ALERT_TYPE_DOMAIN_ROUTER;\n            } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n                alertType = AlertManager.ALERT_TYPE_CONSOLE_PROXY;\n            }\n\n            HostPodVO podVO = _podDao.findById(vm.getPodIdToDeployIn());\n            DataCenterVO dcVO = _dcDao.findById(vm.getDataCenterIdToDeployIn());\n            HostVO hostVO = _hostDao.findById(vm.getHostId());\n\n            String hostDesc = \"name: \" + hostVO.getName() + \" (id:\" + hostVO.getId() + \"), availability zone: \" + dcVO.getName() + \", pod: \" + podVO.getName();\n            _alertMgr.sendAlert(alertType, vm.getDataCenterIdToDeployIn(), vm.getPodIdToDeployIn(), \"VM (name: \" + vm.getInstanceName() + \", id: \" + vm.getId() + \") stopped on host \" + hostDesc + \" due to storage failure\",\n                    \"Virtual Machine \" + vm.getInstanceName() + \" (id: \" + vm.getId() + \") running on host [\" + vm.getHostId() + \"] stopped due to storage failure.\");\n        }\n\n        // if (serverState == State.Migrating) {\n        // s_logger.debug(\"Skipping vm in migrating state: \" + vm);\n        // return null;\n        // }\n\n        if (agentState == serverState) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Both states are \" + agentState + \" for \" + vm);\n            }\n            assert (agentState == State.Stopped || agentState == State.Running) : \"If the states we send up is changed, this must be changed.\";\n            if (agentState == State.Running) {\n                try {\n                    stateTransitTo(vm, VirtualMachine.Event.AgentReportRunning, vm.getHostId());\n                } catch (NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n                // FIXME: What if someone comes in and sets it to stopping? Then what?\n                return null;\n            }\n            s_logger.debug(\"State matches but the agent said stopped so let's send a cleanup command anyways.\");\n            return cleanup(agentName);\n        }\n\n        if (agentState == State.Shutdowned) {\n            if (serverState == State.Running || serverState == State.Starting || serverState == State.Stopping) {\n                try {\n                    advanceStop(vm, true, _accountMgr.getSystemUser(), _accountMgr.getSystemAccount());\n                } catch (AgentUnavailableException e) {\n                    assert (false) : \"How do we hit this with forced on?\";\n                    return null;\n                } catch (OperationTimedoutException e) {\n                    assert (false) : \"How do we hit this with forced on?\";\n                    return null;\n                } catch (ConcurrentOperationException e) {\n                    assert (false) : \"How do we hit this with forced on?\";\n                    return null;\n                }\n            } else {\n                s_logger.debug(\"Sending cleanup to a shutdowned vm: \" + agentName);\n                command = cleanup(agentName);\n            }\n        } else if (agentState == State.Stopped) {\n            // This state means the VM on the agent was detected previously\n            // and now is gone. This is slightly different than if the VM\n            // was never completed but we still send down a Stop Command\n            // to ensure there's cleanup.\n            if (serverState == State.Running) {\n                // Our records showed that it should be running so let's restart it.\n                _haMgr.scheduleRestart(vm, false);\n            } else if (serverState == State.Stopping) {\n                _haMgr.scheduleStop(vm, vm.getHostId(), WorkType.ForceStop);\n                s_logger.debug(\"Scheduling a check stop for VM in stopping mode: \" + vm);\n            } else if (serverState == State.Starting) {\n                s_logger.debug(\"Ignoring VM in starting mode: \" + vm.getInstanceName());\n                _haMgr.scheduleRestart(vm, false);\n            }\n            command = cleanup(agentName);\n        } else if (agentState == State.Running) {\n            if (serverState == State.Starting) {\n                if (fullSync) {\n                    s_logger.debug(\"VM state is starting on full sync so updating it to running\");\n                    vm = findById(vm.getType(), vm.getId());\n                    try {\n                        stateTransitTo(vm, Event.AgentReportRunning, vm.getHostId());\n                    } catch (NoTransitionException e1) {\n                        s_logger.warn(e1.getMessage());\n                    }\n                    s_logger.debug(\"VM's \" + vm + \" state is starting on full sync so updating it to Running\");\n                    vm = vmGuru.findById(vm.getId());\n\n                    VirtualMachineProfile<VMInstanceVO> profile = new VirtualMachineProfileImpl<VMInstanceVO>(vm);\n                    List<NicVO> nics = _nicsDao.listByVmId(profile.getId());\n                    for (NicVO nic : nics) {\n                        Network network = _networkMgr.getNetwork(nic.getNetworkId());\n                        NicProfile nicProfile = new NicProfile(nic, network, nic.getBroadcastUri(), nic.getIsolationUri(), null);\n                        profile.addNic(nicProfile);\n                    }\n\n                    Commands cmds = new Commands(OnError.Stop);\n                    s_logger.debug(\"Finalizing commands that need to be send to complete Start process for the vm \" + vm);\n\n                    if (vmGuru.finalizeCommandsOnStart(cmds, profile)) {\n                        if (cmds.size() != 0) {\n                            try {\n                                _agentMgr.send(vm.getHostId(), cmds);\n                            } catch (OperationTimedoutException e) {\n                                s_logger.error(\"Exception during update for running vm: \" + vm, e);\n                                return null;\n                            } catch (ResourceUnavailableException e) {\n                                s_logger.error(\"Exception during update for running vm: \" + vm, e);\n                                return null;\n                            }\n                        }\n\n                        if (vmGuru.finalizeStart(profile, vm.getHostId(), cmds, null)) {\n                            try {\n                                stateTransitTo(vm, Event.AgentReportRunning, vm.getHostId());\n                            } catch (NoTransitionException e) {\n                                s_logger.warn(e.getMessage());\n                            }\n                        } else {\n                            s_logger.error(\"Exception during update for running vm: \" + vm);\n                            return null;\n                        }\n                    } else {\n                        s_logger.error(\"Unable to finalize commands on start for vm: \" + vm);\n                        return null;\n                    }\n\n                }\n            } else if (serverState == State.Stopping) {\n                s_logger.debug(\"Scheduling a stop command for \" + vm);\n                _haMgr.scheduleStop(vm, vm.getHostId(), WorkType.Stop);\n            } else {\n                s_logger.debug(\"VM state is in stopped so stopping it on the agent\");\n                command = cleanup(agentName);\n            }\n        }\n        return command;\n    }","id":33593,"modified_method":"/**\n     * compareState does as its name suggests and compares the states between management server and agent. It returns whether\n     * something should be cleaned up\n     * \n     */\n    protected Command compareState(long hostId, VMInstanceVO vm, final AgentVmInfo info, final boolean fullSync, boolean nativeHA) {\n        State agentState = info.state;\n        final String agentName = info.name;\n        final State serverState = vm.getState();\n        final String serverName = vm.getInstanceName();\n\n        VirtualMachineGuru<VMInstanceVO> vmGuru = getVmGuru(vm);\n\n        Command command = null;\n\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"VM \" + serverName + \": server state = \" + serverState + \" and agent state = \" + agentState);\n        }\n\n        if (agentState == State.Error) {\n            agentState = State.Stopped;\n\n            short alertType = AlertManager.ALERT_TYPE_USERVM;\n            if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n                alertType = AlertManager.ALERT_TYPE_DOMAIN_ROUTER;\n            } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n                alertType = AlertManager.ALERT_TYPE_CONSOLE_PROXY;\n            }\n\n            HostPodVO podVO = _podDao.findById(vm.getPodIdToDeployIn());\n            DataCenterVO dcVO = _dcDao.findById(vm.getDataCenterIdToDeployIn());\n            HostVO hostVO = _hostDao.findById(vm.getHostId());\n\n            String hostDesc = \"name: \" + hostVO.getName() + \" (id:\" + hostVO.getId() + \"), availability zone: \" + dcVO.getName() + \", pod: \" + podVO.getName();\n            _alertMgr.sendAlert(alertType, vm.getDataCenterIdToDeployIn(), vm.getPodIdToDeployIn(), \"VM (name: \" + vm.getInstanceName() + \", id: \" + vm.getId() + \") stopped on host \" + hostDesc + \" due to storage failure\",\n                    \"Virtual Machine \" + vm.getInstanceName() + \" (id: \" + vm.getId() + \") running on host [\" + vm.getHostId() + \"] stopped due to storage failure.\");\n        }\n\n        // if (serverState == State.Migrating) {\n        // s_logger.debug(\"Skipping vm in migrating state: \" + vm);\n        // return null;\n        // }\n\n        if (agentState == serverState) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Both states are \" + agentState + \" for \" + vm);\n            }\n            assert (agentState == State.Stopped || agentState == State.Running) : \"If the states we send up is changed, this must be changed.\";\n            if (agentState == State.Running) {\n                try {\n                \tif(nativeHA)\n                \t\tstateTransitTo(vm, VirtualMachine.Event.AgentReportRunning, hostId);\n                \telse\n                \t\tstateTransitTo(vm, VirtualMachine.Event.AgentReportRunning, vm.getHostId());\n                } catch (NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n                // FIXME: What if someone comes in and sets it to stopping? Then what?\n                return null;\n            }\n            s_logger.debug(\"State matches but the agent said stopped so let's send a cleanup command anyways.\");\n            return cleanup(agentName);\n        }\n\n        if (agentState == State.Shutdowned) {\n            if (serverState == State.Running || serverState == State.Starting || serverState == State.Stopping) {\n                try {\n                    advanceStop(vm, true, _accountMgr.getSystemUser(), _accountMgr.getSystemAccount());\n                } catch (AgentUnavailableException e) {\n                    assert (false) : \"How do we hit this with forced on?\";\n                    return null;\n                } catch (OperationTimedoutException e) {\n                    assert (false) : \"How do we hit this with forced on?\";\n                    return null;\n                } catch (ConcurrentOperationException e) {\n                    assert (false) : \"How do we hit this with forced on?\";\n                    return null;\n                }\n            } else {\n                s_logger.debug(\"Sending cleanup to a shutdowned vm: \" + agentName);\n                command = cleanup(agentName);\n            }\n        } else if (agentState == State.Stopped) {\n            // This state means the VM on the agent was detected previously\n            // and now is gone. This is slightly different than if the VM\n            // was never completed but we still send down a Stop Command\n            // to ensure there's cleanup.\n            if (serverState == State.Running) {\n                // Our records showed that it should be running so let's restart it.\n                _haMgr.scheduleRestart(vm, false);\n            } else if (serverState == State.Stopping) {\n                _haMgr.scheduleStop(vm, vm.getHostId(), WorkType.ForceStop);\n                s_logger.debug(\"Scheduling a check stop for VM in stopping mode: \" + vm);\n            } else if (serverState == State.Starting) {\n                s_logger.debug(\"Ignoring VM in starting mode: \" + vm.getInstanceName());\n                _haMgr.scheduleRestart(vm, false);\n            }\n            command = cleanup(agentName);\n        } else if (agentState == State.Running) {\n            if (serverState == State.Starting) {\n                if (fullSync) {\n                    s_logger.debug(\"VM state is starting on full sync so updating it to running\");\n                    vm = findById(vm.getType(), vm.getId());\n                    try {\n                        stateTransitTo(vm, Event.AgentReportRunning, vm.getHostId());\n                    } catch (NoTransitionException e1) {\n                        s_logger.warn(e1.getMessage());\n                    }\n                    s_logger.debug(\"VM's \" + vm + \" state is starting on full sync so updating it to Running\");\n                    vm = vmGuru.findById(vm.getId());\n\n                    VirtualMachineProfile<VMInstanceVO> profile = new VirtualMachineProfileImpl<VMInstanceVO>(vm);\n                    List<NicVO> nics = _nicsDao.listByVmId(profile.getId());\n                    for (NicVO nic : nics) {\n                        Network network = _networkMgr.getNetwork(nic.getNetworkId());\n                        NicProfile nicProfile = new NicProfile(nic, network, nic.getBroadcastUri(), nic.getIsolationUri(), null);\n                        profile.addNic(nicProfile);\n                    }\n\n                    Commands cmds = new Commands(OnError.Stop);\n                    s_logger.debug(\"Finalizing commands that need to be send to complete Start process for the vm \" + vm);\n\n                    if (vmGuru.finalizeCommandsOnStart(cmds, profile)) {\n                        if (cmds.size() != 0) {\n                            try {\n                                _agentMgr.send(vm.getHostId(), cmds);\n                            } catch (OperationTimedoutException e) {\n                                s_logger.error(\"Exception during update for running vm: \" + vm, e);\n                                return null;\n                            } catch (ResourceUnavailableException e) {\n                                s_logger.error(\"Exception during update for running vm: \" + vm, e);\n                                return null;\n                            }\n                        }\n\n                        if (vmGuru.finalizeStart(profile, vm.getHostId(), cmds, null)) {\n                            try {\n                                stateTransitTo(vm, Event.AgentReportRunning, vm.getHostId());\n                            } catch (NoTransitionException e) {\n                                s_logger.warn(e.getMessage());\n                            }\n                        } else {\n                            s_logger.error(\"Exception during update for running vm: \" + vm);\n                            return null;\n                        }\n                    } else {\n                        s_logger.error(\"Unable to finalize commands on start for vm: \" + vm);\n                        return null;\n                    }\n\n                }\n            } else if (serverState == State.Stopping) {\n                s_logger.debug(\"Scheduling a stop command for \" + vm);\n                _haMgr.scheduleStop(vm, vm.getHostId(), WorkType.Stop);\n            } else {\n                s_logger.debug(\"VM state is in stopped so stopping it on the agent\");\n                command = cleanup(agentName);\n            }\n        }\n        return command;\n    }","commit_id":"50c1652172df6849796ade17016664ee40f3426a","url":"https://github.com/apache/cloudstack"},{"original_method":"public Commands fullSync(final long hostId, final Map<String, State> newStates) {\n        Commands commands = new Commands(OnError.Continue);\n        final List<? extends VMInstanceVO> vms = _vmDao.listByHostId(hostId);\n        s_logger.debug(\"Found \" + vms.size() + \" VMs for host \" + hostId);\n\n        Map<Long, AgentVmInfo> infos = convertToInfos(newStates);\n\n        for (VMInstanceVO vm : vms) {\n            AgentVmInfo info = infos.remove(vm.getId());\n\n            VMInstanceVO castedVm = null;\n            if (info == null) {\n                info = new AgentVmInfo(vm.getInstanceName(), getVmGuru(vm), vm, State.Stopped);\n                castedVm = info.guru.findById(vm.getId());\n            } else {\n                castedVm = info.vm;\n            }\n            \n            HypervisorGuru hvGuru = _hvGuruMgr.getGuru(castedVm.getHypervisorType());\n\n            Command command = compareState(castedVm, info, true, hvGuru.trackVmHostChange());\n            if (command != null) {\n                commands.addCommand(command);\n            }\n        }\n\n        for (final AgentVmInfo left : infos.values()) {\n            for (VirtualMachineGuru<? extends VMInstanceVO> vmGuru : _vmGurus.values()) {\n                VMInstanceVO vm = vmGuru.findByName(left.name);\n                if (vm == null) {\n                    s_logger.warn(\"Stopping a VM that we have no record of: \" + left.name);\n                    commands.addCommand(cleanup(left.name));\n                } else {\n                    HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n                    if(hvGuru.trackVmHostChange()) {\n\t                    Command command = compareState(vm, left, true, true);\n\t                    if (command != null) {\n\t                        commands.addCommand(command);\n\t                    }\n                    } else {\n                        s_logger.warn(\"Stopping a VM that we have no record of: \" + left.name);\n                        commands.addCommand(cleanup(left.name));\n                    }\n                }\n            }\n        }\n\n        return commands;\n    }","id":33594,"modified_method":"public Commands fullSync(final long hostId, final Map<String, State> newStates) {\n        Commands commands = new Commands(OnError.Continue);\n        final List<? extends VMInstanceVO> vms = _vmDao.listByHostId(hostId);\n        s_logger.debug(\"Found \" + vms.size() + \" VMs for host \" + hostId);\n\n        Map<Long, AgentVmInfo> infos = convertToInfos(newStates);\n\n        for (VMInstanceVO vm : vms) {\n            AgentVmInfo info = infos.remove(vm.getId());\n\n            VMInstanceVO castedVm = null;\n            if (info == null) {\n                info = new AgentVmInfo(vm.getInstanceName(), getVmGuru(vm), vm, State.Stopped);\n                castedVm = info.guru.findById(vm.getId());\n            } else {\n                castedVm = info.vm;\n            }\n            \n            HypervisorGuru hvGuru = _hvGuruMgr.getGuru(castedVm.getHypervisorType());\n\n            Command command = compareState(hostId, castedVm, info, true, hvGuru.trackVmHostChange());\n            if (command != null) {\n                commands.addCommand(command);\n            }\n        }\n\n        for (final AgentVmInfo left : infos.values()) {\n            for (VirtualMachineGuru<? extends VMInstanceVO> vmGuru : _vmGurus.values()) {\n                VMInstanceVO vm = vmGuru.findByName(left.name);\n                if (vm == null) {\n                    s_logger.warn(\"Stopping a VM that we have no record of: \" + left.name);\n                    commands.addCommand(cleanup(left.name));\n                } else {\n                    HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n                    if(hvGuru.trackVmHostChange()) {\n\t                    Command command = compareState(hostId, vm, left, true, true);\n\t                    if (command != null) {\n\t                        commands.addCommand(command);\n\t                    }\n                    } else {\n                        s_logger.warn(\"Stopping a VM that we have no record of: \" + left.name);\n                        commands.addCommand(cleanup(left.name));\n                    }\n                }\n            }\n        }\n\n        return commands;\n    }","commit_id":"50c1652172df6849796ade17016664ee40f3426a","url":"https://github.com/apache/cloudstack"},{"original_method":"public Commands deltaSync(long hostId, Map<String, State> newStates) {\n        Map<Long, AgentVmInfo> states = convertToInfos(newStates);\n        Commands commands = new Commands(OnError.Continue);\n\n        for (Map.Entry<Long, AgentVmInfo> entry : states.entrySet()) {\n            AgentVmInfo info = entry.getValue();\n\n            VMInstanceVO vm = info.vm;\n\n            Command command = null;\n            if (vm != null) {\n                HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n                command = compareState(vm, info, false, hvGuru.trackVmHostChange());\n            } else {\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"Cleaning up a VM that is no longer found: \" + info.name);\n                }\n                command = cleanup(info.name);\n            }\n\n            if (command != null) {\n                commands.addCommand(command);\n            }\n        }\n\n        return commands;\n    }","id":33595,"modified_method":"public Commands deltaSync(long hostId, Map<String, State> newStates) {\n        Map<Long, AgentVmInfo> states = convertToInfos(newStates);\n        Commands commands = new Commands(OnError.Continue);\n\n        for (Map.Entry<Long, AgentVmInfo> entry : states.entrySet()) {\n            AgentVmInfo info = entry.getValue();\n\n            VMInstanceVO vm = info.vm;\n\n            Command command = null;\n            if (vm != null) {\n                HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n                command = compareState(hostId, vm, info, false, hvGuru.trackVmHostChange());\n            } else {\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"Cleaning up a VM that is no longer found: \" + info.name);\n                }\n                command = cleanup(info.name);\n            }\n\n            if (command != null) {\n                commands.addCommand(command);\n            }\n        }\n\n        return commands;\n    }","commit_id":"7279dad925f67e561d70e9392fdfe1d38238e4fb","url":"https://github.com/apache/cloudstack"},{"original_method":"public Commands fullSync(final long hostId, final Map<String, State> newStates) {\n        Commands commands = new Commands(OnError.Continue);\n        final List<? extends VMInstanceVO> vms = _vmDao.listByHostId(hostId);\n        s_logger.debug(\"Found \" + vms.size() + \" VMs for host \" + hostId);\n\n        Map<Long, AgentVmInfo> infos = convertToInfos(newStates);\n\n        for (VMInstanceVO vm : vms) {\n            AgentVmInfo info = infos.remove(vm.getId());\n\n            VMInstanceVO castedVm = null;\n            if (info == null) {\n                info = new AgentVmInfo(vm.getInstanceName(), getVmGuru(vm), vm, State.Stopped);\n                castedVm = info.guru.findById(vm.getId());\n            } else {\n                castedVm = info.vm;\n            }\n            \n            HypervisorGuru hvGuru = _hvGuruMgr.getGuru(castedVm.getHypervisorType());\n\n            Command command = compareState(castedVm, info, true, hvGuru.trackVmHostChange());\n            if (command != null) {\n                commands.addCommand(command);\n            }\n        }\n\n        for (final AgentVmInfo left : infos.values()) {\n            for (VirtualMachineGuru<? extends VMInstanceVO> vmGuru : _vmGurus.values()) {\n                VMInstanceVO vm = vmGuru.findByName(left.name);\n                if (vm == null) {\n                    s_logger.warn(\"Stopping a VM that we have no record of: \" + left.name);\n                    commands.addCommand(cleanup(left.name));\n                } else {\n                    HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n                    if(hvGuru.trackVmHostChange()) {\n\t                    Command command = compareState(vm, left, true, true);\n\t                    if (command != null) {\n\t                        commands.addCommand(command);\n\t                    }\n                    } else {\n                        s_logger.warn(\"Stopping a VM that we have no record of: \" + left.name);\n                        commands.addCommand(cleanup(left.name));\n                    }\n                }\n            }\n        }\n\n        return commands;\n    }","id":33596,"modified_method":"public Commands fullSync(final long hostId, final Map<String, State> newStates) {\n        Commands commands = new Commands(OnError.Continue);\n        final List<? extends VMInstanceVO> vms = _vmDao.listByHostId(hostId);\n        s_logger.debug(\"Found \" + vms.size() + \" VMs for host \" + hostId);\n\n        Map<Long, AgentVmInfo> infos = convertToInfos(newStates);\n\n        for (VMInstanceVO vm : vms) {\n            AgentVmInfo info = infos.remove(vm.getId());\n\n            VMInstanceVO castedVm = null;\n            if (info == null) {\n                info = new AgentVmInfo(vm.getInstanceName(), getVmGuru(vm), vm, State.Stopped);\n                castedVm = info.guru.findById(vm.getId());\n            } else {\n                castedVm = info.vm;\n            }\n            \n            HypervisorGuru hvGuru = _hvGuruMgr.getGuru(castedVm.getHypervisorType());\n\n            Command command = compareState(hostId, castedVm, info, true, hvGuru.trackVmHostChange());\n            if (command != null) {\n                commands.addCommand(command);\n            }\n        }\n\n        for (final AgentVmInfo left : infos.values()) {\n            for (VirtualMachineGuru<? extends VMInstanceVO> vmGuru : _vmGurus.values()) {\n                VMInstanceVO vm = vmGuru.findByName(left.name);\n                if (vm == null) {\n                    s_logger.warn(\"Stopping a VM that we have no record of: \" + left.name);\n                    commands.addCommand(cleanup(left.name));\n                } else {\n                    HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n                    if(hvGuru.trackVmHostChange()) {\n\t                    Command command = compareState(hostId, vm, left, true, true);\n\t                    if (command != null) {\n\t                        commands.addCommand(command);\n\t                    }\n                    } else {\n                        s_logger.warn(\"Stopping a VM that we have no record of: \" + left.name);\n                        commands.addCommand(cleanup(left.name));\n                    }\n                }\n            }\n        }\n\n        return commands;\n    }","commit_id":"7279dad925f67e561d70e9392fdfe1d38238e4fb","url":"https://github.com/apache/cloudstack"},{"original_method":"/**\n     * compareState does as its name suggests and compares the states between management server and agent. It returns whether\n     * something should be cleaned up\n     * \n     */\n    protected Command compareState(VMInstanceVO vm, final AgentVmInfo info, final boolean fullSync, boolean nativeHA) {\n        State agentState = info.state;\n        final String agentName = info.name;\n        final State serverState = vm.getState();\n        final String serverName = vm.getInstanceName();\n\n        VirtualMachineGuru<VMInstanceVO> vmGuru = getVmGuru(vm);\n\n        Command command = null;\n\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"VM \" + serverName + \": server state = \" + serverState + \" and agent state = \" + agentState);\n        }\n\n        if (agentState == State.Error) {\n            agentState = State.Stopped;\n\n            short alertType = AlertManager.ALERT_TYPE_USERVM;\n            if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n                alertType = AlertManager.ALERT_TYPE_DOMAIN_ROUTER;\n            } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n                alertType = AlertManager.ALERT_TYPE_CONSOLE_PROXY;\n            }\n\n            HostPodVO podVO = _podDao.findById(vm.getPodIdToDeployIn());\n            DataCenterVO dcVO = _dcDao.findById(vm.getDataCenterIdToDeployIn());\n            HostVO hostVO = _hostDao.findById(vm.getHostId());\n\n            String hostDesc = \"name: \" + hostVO.getName() + \" (id:\" + hostVO.getId() + \"), availability zone: \" + dcVO.getName() + \", pod: \" + podVO.getName();\n            _alertMgr.sendAlert(alertType, vm.getDataCenterIdToDeployIn(), vm.getPodIdToDeployIn(), \"VM (name: \" + vm.getInstanceName() + \", id: \" + vm.getId() + \") stopped on host \" + hostDesc + \" due to storage failure\",\n                    \"Virtual Machine \" + vm.getInstanceName() + \" (id: \" + vm.getId() + \") running on host [\" + vm.getHostId() + \"] stopped due to storage failure.\");\n        }\n\n        // if (serverState == State.Migrating) {\n        // s_logger.debug(\"Skipping vm in migrating state: \" + vm);\n        // return null;\n        // }\n\n        if (agentState == serverState) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Both states are \" + agentState + \" for \" + vm);\n            }\n            assert (agentState == State.Stopped || agentState == State.Running) : \"If the states we send up is changed, this must be changed.\";\n            if (agentState == State.Running) {\n                try {\n                    stateTransitTo(vm, VirtualMachine.Event.AgentReportRunning, vm.getHostId());\n                } catch (NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n                // FIXME: What if someone comes in and sets it to stopping? Then what?\n                return null;\n            }\n            s_logger.debug(\"State matches but the agent said stopped so let's send a cleanup command anyways.\");\n            return cleanup(agentName);\n        }\n\n        if (agentState == State.Shutdowned) {\n            if (serverState == State.Running || serverState == State.Starting || serverState == State.Stopping) {\n                try {\n                    advanceStop(vm, true, _accountMgr.getSystemUser(), _accountMgr.getSystemAccount());\n                } catch (AgentUnavailableException e) {\n                    assert (false) : \"How do we hit this with forced on?\";\n                    return null;\n                } catch (OperationTimedoutException e) {\n                    assert (false) : \"How do we hit this with forced on?\";\n                    return null;\n                } catch (ConcurrentOperationException e) {\n                    assert (false) : \"How do we hit this with forced on?\";\n                    return null;\n                }\n            } else {\n                s_logger.debug(\"Sending cleanup to a shutdowned vm: \" + agentName);\n                command = cleanup(agentName);\n            }\n        } else if (agentState == State.Stopped) {\n            // This state means the VM on the agent was detected previously\n            // and now is gone. This is slightly different than if the VM\n            // was never completed but we still send down a Stop Command\n            // to ensure there's cleanup.\n            if (serverState == State.Running) {\n                // Our records showed that it should be running so let's restart it.\n                _haMgr.scheduleRestart(vm, false);\n            } else if (serverState == State.Stopping) {\n                _haMgr.scheduleStop(vm, vm.getHostId(), WorkType.ForceStop);\n                s_logger.debug(\"Scheduling a check stop for VM in stopping mode: \" + vm);\n            } else if (serverState == State.Starting) {\n                s_logger.debug(\"Ignoring VM in starting mode: \" + vm.getInstanceName());\n                _haMgr.scheduleRestart(vm, false);\n            }\n            command = cleanup(agentName);\n        } else if (agentState == State.Running) {\n            if (serverState == State.Starting) {\n                if (fullSync) {\n                    s_logger.debug(\"VM state is starting on full sync so updating it to running\");\n                    vm = findById(vm.getType(), vm.getId());\n                    try {\n                        stateTransitTo(vm, Event.AgentReportRunning, vm.getHostId());\n                    } catch (NoTransitionException e1) {\n                        s_logger.warn(e1.getMessage());\n                    }\n                    s_logger.debug(\"VM's \" + vm + \" state is starting on full sync so updating it to Running\");\n                    vm = vmGuru.findById(vm.getId());\n\n                    VirtualMachineProfile<VMInstanceVO> profile = new VirtualMachineProfileImpl<VMInstanceVO>(vm);\n                    List<NicVO> nics = _nicsDao.listByVmId(profile.getId());\n                    for (NicVO nic : nics) {\n                        Network network = _networkMgr.getNetwork(nic.getNetworkId());\n                        NicProfile nicProfile = new NicProfile(nic, network, nic.getBroadcastUri(), nic.getIsolationUri(), null);\n                        profile.addNic(nicProfile);\n                    }\n\n                    Commands cmds = new Commands(OnError.Stop);\n                    s_logger.debug(\"Finalizing commands that need to be send to complete Start process for the vm \" + vm);\n\n                    if (vmGuru.finalizeCommandsOnStart(cmds, profile)) {\n                        if (cmds.size() != 0) {\n                            try {\n                                _agentMgr.send(vm.getHostId(), cmds);\n                            } catch (OperationTimedoutException e) {\n                                s_logger.error(\"Exception during update for running vm: \" + vm, e);\n                                return null;\n                            } catch (ResourceUnavailableException e) {\n                                s_logger.error(\"Exception during update for running vm: \" + vm, e);\n                                return null;\n                            }\n                        }\n\n                        if (vmGuru.finalizeStart(profile, vm.getHostId(), cmds, null)) {\n                            try {\n                                stateTransitTo(vm, Event.AgentReportRunning, vm.getHostId());\n                            } catch (NoTransitionException e) {\n                                s_logger.warn(e.getMessage());\n                            }\n                        } else {\n                            s_logger.error(\"Exception during update for running vm: \" + vm);\n                            return null;\n                        }\n                    } else {\n                        s_logger.error(\"Unable to finalize commands on start for vm: \" + vm);\n                        return null;\n                    }\n\n                }\n            } else if (serverState == State.Stopping) {\n                s_logger.debug(\"Scheduling a stop command for \" + vm);\n                _haMgr.scheduleStop(vm, vm.getHostId(), WorkType.Stop);\n            } else {\n                s_logger.debug(\"VM state is in stopped so stopping it on the agent\");\n                command = cleanup(agentName);\n            }\n        }\n        return command;\n    }","id":33597,"modified_method":"/**\n     * compareState does as its name suggests and compares the states between management server and agent. It returns whether\n     * something should be cleaned up\n     * \n     */\n    protected Command compareState(long hostId, VMInstanceVO vm, final AgentVmInfo info, final boolean fullSync, boolean nativeHA) {\n        State agentState = info.state;\n        final String agentName = info.name;\n        final State serverState = vm.getState();\n        final String serverName = vm.getInstanceName();\n\n        VirtualMachineGuru<VMInstanceVO> vmGuru = getVmGuru(vm);\n\n        Command command = null;\n\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"VM \" + serverName + \": server state = \" + serverState + \" and agent state = \" + agentState);\n        }\n\n        if (agentState == State.Error) {\n            agentState = State.Stopped;\n\n            short alertType = AlertManager.ALERT_TYPE_USERVM;\n            if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n                alertType = AlertManager.ALERT_TYPE_DOMAIN_ROUTER;\n            } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n                alertType = AlertManager.ALERT_TYPE_CONSOLE_PROXY;\n            }\n\n            HostPodVO podVO = _podDao.findById(vm.getPodIdToDeployIn());\n            DataCenterVO dcVO = _dcDao.findById(vm.getDataCenterIdToDeployIn());\n            HostVO hostVO = _hostDao.findById(vm.getHostId());\n\n            String hostDesc = \"name: \" + hostVO.getName() + \" (id:\" + hostVO.getId() + \"), availability zone: \" + dcVO.getName() + \", pod: \" + podVO.getName();\n            _alertMgr.sendAlert(alertType, vm.getDataCenterIdToDeployIn(), vm.getPodIdToDeployIn(), \"VM (name: \" + vm.getInstanceName() + \", id: \" + vm.getId() + \") stopped on host \" + hostDesc + \" due to storage failure\",\n                    \"Virtual Machine \" + vm.getInstanceName() + \" (id: \" + vm.getId() + \") running on host [\" + vm.getHostId() + \"] stopped due to storage failure.\");\n        }\n\n        // if (serverState == State.Migrating) {\n        // s_logger.debug(\"Skipping vm in migrating state: \" + vm);\n        // return null;\n        // }\n\n        if (agentState == serverState) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Both states are \" + agentState + \" for \" + vm);\n            }\n            assert (agentState == State.Stopped || agentState == State.Running) : \"If the states we send up is changed, this must be changed.\";\n            if (agentState == State.Running) {\n                try {\n                \tif(nativeHA)\n                \t\tstateTransitTo(vm, VirtualMachine.Event.AgentReportRunning, hostId);\n                \telse\n                \t\tstateTransitTo(vm, VirtualMachine.Event.AgentReportRunning, vm.getHostId());\n                } catch (NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n                // FIXME: What if someone comes in and sets it to stopping? Then what?\n                return null;\n            }\n            s_logger.debug(\"State matches but the agent said stopped so let's send a cleanup command anyways.\");\n            return cleanup(agentName);\n        }\n\n        if (agentState == State.Shutdowned) {\n            if (serverState == State.Running || serverState == State.Starting || serverState == State.Stopping) {\n                try {\n                    advanceStop(vm, true, _accountMgr.getSystemUser(), _accountMgr.getSystemAccount());\n                } catch (AgentUnavailableException e) {\n                    assert (false) : \"How do we hit this with forced on?\";\n                    return null;\n                } catch (OperationTimedoutException e) {\n                    assert (false) : \"How do we hit this with forced on?\";\n                    return null;\n                } catch (ConcurrentOperationException e) {\n                    assert (false) : \"How do we hit this with forced on?\";\n                    return null;\n                }\n            } else {\n                s_logger.debug(\"Sending cleanup to a shutdowned vm: \" + agentName);\n                command = cleanup(agentName);\n            }\n        } else if (agentState == State.Stopped) {\n            // This state means the VM on the agent was detected previously\n            // and now is gone. This is slightly different than if the VM\n            // was never completed but we still send down a Stop Command\n            // to ensure there's cleanup.\n            if (serverState == State.Running) {\n                // Our records showed that it should be running so let's restart it.\n                _haMgr.scheduleRestart(vm, false);\n            } else if (serverState == State.Stopping) {\n                _haMgr.scheduleStop(vm, vm.getHostId(), WorkType.ForceStop);\n                s_logger.debug(\"Scheduling a check stop for VM in stopping mode: \" + vm);\n            } else if (serverState == State.Starting) {\n                s_logger.debug(\"Ignoring VM in starting mode: \" + vm.getInstanceName());\n                _haMgr.scheduleRestart(vm, false);\n            }\n            command = cleanup(agentName);\n        } else if (agentState == State.Running) {\n            if (serverState == State.Starting) {\n                if (fullSync) {\n                    s_logger.debug(\"VM state is starting on full sync so updating it to running\");\n                    vm = findById(vm.getType(), vm.getId());\n                    try {\n                        stateTransitTo(vm, Event.AgentReportRunning, vm.getHostId());\n                    } catch (NoTransitionException e1) {\n                        s_logger.warn(e1.getMessage());\n                    }\n                    s_logger.debug(\"VM's \" + vm + \" state is starting on full sync so updating it to Running\");\n                    vm = vmGuru.findById(vm.getId());\n\n                    VirtualMachineProfile<VMInstanceVO> profile = new VirtualMachineProfileImpl<VMInstanceVO>(vm);\n                    List<NicVO> nics = _nicsDao.listByVmId(profile.getId());\n                    for (NicVO nic : nics) {\n                        Network network = _networkMgr.getNetwork(nic.getNetworkId());\n                        NicProfile nicProfile = new NicProfile(nic, network, nic.getBroadcastUri(), nic.getIsolationUri(), null);\n                        profile.addNic(nicProfile);\n                    }\n\n                    Commands cmds = new Commands(OnError.Stop);\n                    s_logger.debug(\"Finalizing commands that need to be send to complete Start process for the vm \" + vm);\n\n                    if (vmGuru.finalizeCommandsOnStart(cmds, profile)) {\n                        if (cmds.size() != 0) {\n                            try {\n                                _agentMgr.send(vm.getHostId(), cmds);\n                            } catch (OperationTimedoutException e) {\n                                s_logger.error(\"Exception during update for running vm: \" + vm, e);\n                                return null;\n                            } catch (ResourceUnavailableException e) {\n                                s_logger.error(\"Exception during update for running vm: \" + vm, e);\n                                return null;\n                            }\n                        }\n\n                        if (vmGuru.finalizeStart(profile, vm.getHostId(), cmds, null)) {\n                            try {\n                                stateTransitTo(vm, Event.AgentReportRunning, vm.getHostId());\n                            } catch (NoTransitionException e) {\n                                s_logger.warn(e.getMessage());\n                            }\n                        } else {\n                            s_logger.error(\"Exception during update for running vm: \" + vm);\n                            return null;\n                        }\n                    } else {\n                        s_logger.error(\"Unable to finalize commands on start for vm: \" + vm);\n                        return null;\n                    }\n\n                }\n            } else if (serverState == State.Stopping) {\n                s_logger.debug(\"Scheduling a stop command for \" + vm);\n                _haMgr.scheduleStop(vm, vm.getHostId(), WorkType.Stop);\n            } else {\n                s_logger.debug(\"VM state is in stopped so stopping it on the agent\");\n                command = cleanup(agentName);\n            }\n        }\n        return command;\n    }","commit_id":"7279dad925f67e561d70e9392fdfe1d38238e4fb","url":"https://github.com/apache/cloudstack"},{"original_method":"public void init()\n\t{\n\t\ttry\n\t\t{\n\t\t\tfinal String appletClassName = getParameter(\"appletClassName\");\n\t\t\tContainer container = getContentPane();\n\t\t\tClass c = Class.forName(appletClassName);\n\t\t\tif (c != null)\n\t\t\t{\n\t\t\t\tapplet = (IApplet)c.newInstance();\n\t\t\t\tapplet.init(this, container, getModel());\n\t\t\t}\n\t\t}\n\t\tcatch (ClassNotFoundException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\tcatch (IllegalAccessException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\tcatch (InstantiationException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}","id":33598,"modified_method":"public void init()\n\t{\n\t\ttry\n\t\t{\n\t\t\tfinal String appletClassName = getParameter(\"appletClassName\");\n\t\t\tContainer container = getContentPane();\n\t\t\tClass c = Class.forName(appletClassName);\n\t\t\tif (c != null)\n\t\t\t{\n\t\t\t\tapplet = (IApplet)c.newInstance();\n\t\t\t\tapplet.init(this, container, getModel());\n\t\t\t}\n\t\t}\n\t\tcatch (ClassNotFoundException e)\n\t\t{\n\t\t\tSystem.out.println(\"** Unable to initialize.\");\n\t\t\te.printStackTrace();\n\t\t}\n\t\tcatch (IllegalAccessException e)\n\t\t{\n\t\t\tSystem.out.println(\"** Unable to initialize.\");\n\t\t\te.printStackTrace();\n\t\t}\n\t\tcatch (InstantiationException e)\n\t\t{\n\t\t\tSystem.out.println(\"** Unable to initialize.\");\n\t\t\te.printStackTrace();\n\t\t}\n\t}","commit_id":"e0fb35332c28008e6c182d4315a7581413dc138a","url":"https://github.com/apache/wicket"},{"original_method":"public void setModel(Object model)\n\t{\n\t\ttry\n\t\t{\n\t\t\tURL url = new URL(getDocumentBase() + getParameter(\"setModelUrl\"));\n\n\t\t\t// create a boundary string\n\t\t\tString boundary = MultiPartFormOutputStream.createBoundary();\n\t\t\tURLConnection connection = MultiPartFormOutputStream.createConnection(url);\n\t\t\tconnection.setRequestProperty(\"Accept\", \"*/*\");\n\t\t\tconnection.setRequestProperty(\"Content-Type\", MultiPartFormOutputStream\n\t\t\t\t\t.getContentType(boundary));\n\n\t\t\t// set some other request headers...\n\t\t\tconnection.setRequestProperty(\"Connection\", \"Keep-Alive\");\n\t\t\tconnection.setRequestProperty(\"Cache-Control\", \"no-cache\");\n\n\t\t\t// no need to connect cuz getOutputStream() does it\n\t\t\tMultiPartFormOutputStream out = new MultiPartFormOutputStream(connection\n\t\t\t\t\t.getOutputStream(), boundary);\n\n\t\t\t// upload a file\n\t\t\tByteArrayOutputStream modelOut = new ByteArrayOutputStream();\n\t\t\tnew ObjectOutputStream(modelOut).writeObject(model);\n\t\t\tout.writeFile(\"model\", \"application/x-wicket-model\", \"model\", modelOut.toByteArray());\n\t\t\tout.close();\n\n\t\t\t// read response from server\n\t\t\tBufferedReader in = new BufferedReader(new InputStreamReader(connection\n\t\t\t\t\t.getInputStream()));\n\t\t\tString line = \"\";\n\t\t\twhile ((line = in.readLine()) != null)\n\t\t\t{\n\t\t\t\tSystem.out.println(line);\n\t\t\t}\n\t\t\tin.close();\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}","id":33599,"modified_method":"public void setModel(final Object model)\n\t{\n\t\ttry\n\t\t{\n\t\t\tfinal URL url = new URL(getDocumentBase() + getParameter(\"setModelUrl\"));\n\n\t\t\t// Create a boundary string\n\t\t\tfinal String boundary = MultiPartFormOutputStream.createBoundary();\n\t\t\tURLConnection connection = MultiPartFormOutputStream.createConnection(url);\n\t\t\tconnection.setRequestProperty(\"Accept\", \"*/*\");\n\t\t\tconnection.setRequestProperty(\"Content-Type\", MultiPartFormOutputStream\n\t\t\t\t\t.getContentType(boundary));\n\n\t\t\t// Set some other request headers...\n\t\t\tconnection.setRequestProperty(\"Connection\", \"Keep-Alive\");\n\t\t\tconnection.setRequestProperty(\"Cache-Control\", \"no-cache\");\n\n\t\t\t// Upload a file\n\t\t\tfinal MultiPartFormOutputStream out = new MultiPartFormOutputStream(connection\n\t\t\t\t\t.getOutputStream(), boundary);\n\t\t\ttry\n\t\t\t{\n\t\t\t\tout.writeFile(\"model\", \"application/x-wicket-model\", \"model\", Objects2\n\t\t\t\t\t\t.objectToByteArray(model));\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tout.close();\n\t\t\t}\n\n\t\t\t// Read response from server\n\t\t\tfinal BufferedReader in = new BufferedReader(new InputStreamReader(connection\n\t\t\t\t\t.getInputStream()));\n\t\t\ttry\n\t\t\t{\n\t\t\t\tString line = \"\";\n\t\t\t\twhile ((line = in.readLine()) != null)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(line);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tin.close();\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tSystem.out.println(\"** Unable to set model.\");\n\t\t\te.printStackTrace();\n\t\t}\n\t}","commit_id":"e0fb35332c28008e6c182d4315a7581413dc138a","url":"https://github.com/apache/wicket"},{"original_method":"public Object getModel()\n\t{\n\t\ttry\n\t\t{\n\t\t\tfinal String url = getDocumentBase() + getParameter(\"getModelUrl\");\n\t\t\tInputStream in = new URL(url).openStream();\n\t\t\treturn new ObjectInputStream(in).readObject();\n\t\t}\n\t\tcatch (ClassNotFoundException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}","id":33600,"modified_method":"public Object getModel()\n\t{\n\t\ttry\n\t\t{\n\t\t\tfinal String url = getDocumentBase() + getParameter(\"getModelUrl\");\n\t\t\tfinal InputStream in = new URL(url).openStream();\n\t\t\ttry\n\t\t\t{\n\t\t\t\treturn new ObjectInputStream(in).readObject();\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tin.close();\n\t\t\t}\n\t\t}\n\t\tcatch (ClassNotFoundException e)\n\t\t{\n\t\t\tSystem.out.println(\"** Unable to get model.\");\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\tSystem.out.println(\"** Unable to get model.\");\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}","commit_id":"e0fb35332c28008e6c182d4315a7581413dc138a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor\n\t * \n\t * @param id\n\t *            The component's id\n\t * @param minimum\n\t *            The minimum value for this spinner\n\t * @param maximum\n\t *            The maximum value for this spinner\n\t * @param stepSize\n\t *            The step size for this spinner\n\t */\n\tpublic NumberSpinner(String id, Number minimum, Number maximum, Number stepSize)\n\t{\n\t\tsuper(id, NumberSpinnerApplet.class);\n\t\tappletModel = new SpinnerNumberModel();\n\t\tappletModel.setValue((Comparable)getModelObject());\n\t\tappletModel.setMaximum((Comparable)maximum);\n\t\tappletModel.setMinimum((Comparable)minimum);\n\t\tappletModel.setStepSize(stepSize);\n\t\tsetAppletModel(appletModel);\n\t}","id":33601,"modified_method":"/**\n\t * Constructor\n\t * \n\t * @param id\n\t *            The component's id\n\t * @param minimum\n\t *            The minimum value for this spinner\n\t * @param maximum\n\t *            The maximum value for this spinner\n\t * @param stepSize\n\t *            The step size for this spinner\n\t */\n\tpublic NumberSpinner(String id, Number minimum, Number maximum, Number stepSize)\n\t{\n\t\tsuper(id, NumberSpinnerApplet.class);\n\t\tappletModel = new SpinnerNumberModel();\n\t\tappletModel.setValue(getModelObject());\n\t\tappletModel.setMaximum((Comparable)maximum);\n\t\tappletModel.setMinimum((Comparable)minimum);\n\t\tappletModel.setStepSize(stepSize);\n\t\tsetAppletModel(appletModel);\n\t}","commit_id":"e0fb35332c28008e6c182d4315a7581413dc138a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.markup.html.applet.IApplet#getModel()\n\t */\n\tpublic Object getModel()\n\t{\n\t\tmodel = (SpinnerNumberModel)spinner.getModel();\n\t\treturn spinner.getValue();\n\t}","id":33602,"modified_method":"/**\n\t * @see wicket.markup.html.applet.IApplet#getModel()\n\t */\n\tpublic Object getModel()\n\t{\n\t\treturn (SpinnerNumberModel)spinner.getModel();\n\t}","commit_id":"e0fb35332c28008e6c182d4315a7581413dc138a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Serializes an object into a byte array.\n\t * \n\t * @param object\n\t *            The object\n\t * @return The serialized object\n\t */\n\t// FIXME General: Belongs in Objects.java\n\tpublic static byte[] objectToByteArray(Object object)\n\t{\n\t\ttry\n\t\t{\n\t\t\tfinal ByteArrayOutputStream out = new ByteArrayOutputStream();\n\t\t\tnew ObjectOutputStream(out).writeObject(object);\n\t\t\tout.close();\n\t\t\treturn out.toByteArray();\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}","id":33603,"modified_method":"/**\n\t * Serializes an object into a byte array.\n\t * \n\t * @param object\n\t *            The object\n\t * @return The serialized object\n\t */\n\t// FIXME General: Belongs in Objects.java\n\tpublic static byte[] objectToByteArray(Object object)\n\t{\n\t\ttry\n\t\t{\n\t\t\tfinal ByteArrayOutputStream out = new ByteArrayOutputStream();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tnew ObjectOutputStream(out).writeObject(object);\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tout.close();\n\t\t\t}\n\t\t\treturn out.toByteArray();\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}","commit_id":"e0fb35332c28008e6c182d4315a7581413dc138a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * De-serializes an object from a byte array.\n\t * \n\t * @param data\n\t *            The serialized object\n\t * @return The object\n\t */\n\t// FIXME General: Belongs in Objects.java\n\tpublic static Object byteArrayToObject(final byte[] data)\n\t{\n\t\ttry\n\t\t{\n\t\t\tfinal ByteArrayInputStream in = new ByteArrayInputStream(data);\n\t\t\tfinal Object object = new ObjectInputStream(in).readObject();\n\t\t\tin.close();\n\t\t\treturn object;\n\t\t}\n\t\tcatch (ClassNotFoundException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}","id":33604,"modified_method":"/**\n\t * De-serializes an object from a byte array.\n\t * \n\t * @param data\n\t *            The serialized object\n\t * @return The object\n\t */\n\t// FIXME General: Belongs in Objects.java\n\tpublic static Object byteArrayToObject(final byte[] data)\n\t{\n\t\ttry\n\t\t{\n\t\t\tfinal ByteArrayInputStream in = new ByteArrayInputStream(data);\n\t\t\ttry\n\t\t\t{\n\t\t\t\treturn new ObjectInputStream(in).readObject();\t\t\t\t\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tin.close();\n\t\t\t}\n\t\t}\n\t\tcatch (ClassNotFoundException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}","commit_id":"e0fb35332c28008e6c182d4315a7581413dc138a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see javax.swing.event.TreeModelListener#treeNodesInserted(javax.swing.event.TreeModelEvent)\n\t */\n\tpublic final void treeNodesInserted(TreeModelEvent e)\n\t{\n\t\t// get the parent node of inserted nodes\n\t\tTreeNode parent = (TreeNode)e.getTreePath().getLastPathComponent();\n\n\t\tif (isNodeVisible(parent) && isNodeExpanded(parent))\n\t\t{\n\t\t\tTreeItem parentItem = (TreeItem)nodeToItemMap.get(parent);\n\t\t\t\n\t\t\tif (parentItem.getChildren().isEmpty()) \n\t\t\t{\n\t\t\t\tinvalidateNode(parent, true);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < e.getChildren().length; ++i)\n\t\t\t{\n\t\t\t\tTreeNode node = (TreeNode)e.getChildren()[i];\n\t\t\t\tint index = e.getChildIndices()[i];\n\t\t\t\tTreeItem item = newTreeItem(node, parentItem.getLevel() + 1);\n\t\t\t\titemContainer.add(item);\n\t\t\t\tparentItem.getChildren().add(index, item);\n\n\t\t\t\tmarkTheLastButOneChildDirty(parentItem, item);\n\n\t\t\t\tdirtyItems.add(item);\n\t\t\t\tdirtyItemsCreateDOM.add(item);\n\t\t\t}\n\t\t}\n\t}","id":33605,"modified_method":"/**\n\t * @see javax.swing.event.TreeModelListener#treeNodesInserted(javax.swing.event.TreeModelEvent)\n\t */\n\tpublic final void treeNodesInserted(TreeModelEvent e)\n\t{\n\t\t// get the parent node of inserted nodes\n\t\tObject parent = e.getTreePath().getLastPathComponent();\n\n\t\tif (isNodeVisible(parent) && isNodeExpanded(parent))\n\t\t{\n\t\t\tTreeItem parentItem = (TreeItem)nodeToItemMap.get(parent);\n\n\t\t\tif (parentItem.getChildren().isEmpty())\n\t\t\t{\n\t\t\t\tinvalidateNode(parent, true);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < e.getChildren().length; ++i)\n\t\t\t{\n\t\t\t\tObject node = e.getChildren()[i];\n\t\t\t\tint index = e.getChildIndices()[i];\n\t\t\t\tTreeItem item = newTreeItem(node, parentItem.getLevel() + 1);\n\t\t\t\titemContainer.add(item);\n\t\t\t\tparentItem.getChildren().add(index, item);\n\n\t\t\t\tmarkTheLastButOneChildDirty(parentItem, item);\n\n\t\t\t\tif (!dirtyItems.contains(item))\n\t\t\t\t\tdirtyItems.add(item);\n\n\t\t\t\tif (!dirtyItemsCreateDOM.contains(item))\n\t\t\t\t\tdirtyItemsCreateDOM.add(item);\n\t\t\t}\n\t\t}\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see org.apache.wicket.MarkupContainer#onDetach()\n\t */\n\tpublic void onDetach()\n\t{\n\t\tattached = false;\n\t\tsuper.onDetach();\n\t}","id":33606,"modified_method":"/**\n\t * @see org.apache.wicket.MarkupContainer#onDetach()\n\t */\n\t@Override\n\tpublic void onDetach()\n\t{\n\t\tattached = false;\n\t\tsuper.onDetach();\n\t\tif (getTreeState() instanceof IDetachable)\n\t\t{\n\t\t\t((IDetachable)getTreeState()).detach();\n\t\t}\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see org.apache.wicket.markup.html.tree.ITreeStateListener#nodeCollapsed(javax.swing.tree.TreeNode)\n\t */\n\tpublic final void nodeCollapsed(TreeNode node)\n\t{\n\t\tif (isNodeVisible(node) == true)\n\t\t{\n\t\t\tinvalidateNodeWithChildren(node);\n\t\t}\n\t}","id":33607,"modified_method":"/**\n\t * @see org.apache.wicket.markup.html.tree.ITreeStateListener#nodeCollapsed(javax.swing.tree.TreeNode)\n\t */\n\tpublic final void nodeCollapsed(Object node)\n\t{\n\t\tif (isNodeVisible(node) == true)\n\t\t{\n\t\t\tinvalidateNodeWithChildren(node);\n\t\t}\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t\t * Construct.\n\t\t * \n\t\t * @param id\n\t\t *            The component id\n\t\t * @param node\n\t\t *            tree node\n\t\t * @param level\n\t\t *            current level\n\t\t */\n\t\tpublic TreeItem(String id, final TreeNode node, int level)\n\t\t{\n\t\t\tsuper(id, new Model((Serializable)node));\n\n\t\t\tnodeToItemMap.put(node, this);\n\t\t\tthis.level = level;\n\t\t\tsetOutputMarkupId(true);\n\n\t\t\t// if this isn't a root item in rootless mode\n\t\t\tif (level != -1)\n\t\t\t{\n\t\t\t\tpopulateTreeItem(this, level);\n\t\t\t}\n\t\t}","id":33608,"modified_method":"/**\n\t\t * Construct.\n\t\t * \n\t\t * @param id\n\t\t *            The component id\n\t\t * @param node\n\t\t *            tree node\n\t\t * @param level\n\t\t *            current level\n\t\t */\n\t\tpublic TreeItem(String id, final Object node, int level)\n\t\t{\n\t\t\tsuper(id, new Model((Serializable)node));\n\n\t\t\tnodeToItemMap.put(node, this);\n\t\t\tthis.level = level;\n\t\t\tsetOutputMarkupId(true);\n\n\t\t\t// if this isn't a root item in rootless mode\n\t\t\tif (level != -1)\n\t\t\t{\n\t\t\t\tpopulateTreeItem(this, level);\n\t\t\t}\n\t\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Creates a tree item for given node with specified id.\n\t * \n\t * @param node\n\t *            The tree node\n\t * @param level\n\t *            The level\n\t * @param id\n\t *            the component id\n\t * @return The new tree item\n\t */\n\tprivate final TreeItem newTreeItem(TreeNode node, int level, String id)\n\t{\n\t\treturn new TreeItem(id, node, level);\n\t}","id":33609,"modified_method":"/**\n\t * Creates a tree item for given node with specified id.\n\t * \n\t * @param node\n\t *            The tree node\n\t * @param level\n\t *            The level\n\t * @param id\n\t *            the component id\n\t * @return The new tree item\n\t */\n\tprivate final TreeItem newTreeItem(Object node, int level, String id)\n\t{\n\t\treturn new TreeItem(id, node, level);\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Invalidates single node (without children). On the next render, this node will be updated.\n\t * Node will not be rebuilt, unless forceRebuild is true.\n\t * \n\t * @param node\n\t *            The node to invalidate\n\t * @param forceRebuild\n\t */\n\tprivate final void invalidateNode(TreeNode node, boolean forceRebuild)\n\t{\n\t\tif (dirtyAll == false)\n\t\t{\n\t\t\t// get item for this node\n\t\t\tTreeItem item = (TreeItem)nodeToItemMap.get(node);\n\n\t\t\tif (item != null)\n\t\t\t{\n\t\t\t\tboolean createDOM = false;\n\n\t\t\t\tif (forceRebuild)\n\t\t\t\t{\n\t\t\t\t\t// recreate the item\n\t\t\t\t\tint level = item.getLevel();\n\t\t\t\t\tList children = item.getChildren();\n\t\t\t\t\tString id = item.getId();\n\n\t\t\t\t\t// store the parent of old item\n\t\t\t\t\tTreeItem parent = item.getParentItem();\n\n\t\t\t\t\t// if the old item has a parent, store it's index\n\t\t\t\t\tint index = parent != null ? parent.getChildren().indexOf(item) : -1;\n\n\t\t\t\t\tcreateDOM = dirtyItemsCreateDOM.contains(item);\n\n\t\t\t\t\tdirtyItems.remove(item);\n\t\t\t\t\tdirtyItemsCreateDOM.remove(item);\n\n\t\t\t\t\titem.remove();\n\n\t\t\t\t\titem = newTreeItem(node, level, id);\n\t\t\t\t\titemContainer.add(item);\n\n\t\t\t\t\titem.setChildren(children);\n\n\t\t\t\t\t// was the item an root item?\n\t\t\t\t\tif (parent == null)\n\t\t\t\t\t{\n\t\t\t\t\t\trootItem = item;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tparent.getChildren().set(index, item);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdirtyItems.add(item);\n\t\t\t\tif (createDOM)\n\t\t\t\t{\n\t\t\t\t\tdirtyItemsCreateDOM.add(item);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":33610,"modified_method":"/**\n\t * Invalidates single node (without children). On the next render, this node will be updated.\n\t * Node will not be rebuilt, unless forceRebuild is true.\n\t * \n\t * @param node\n\t *            The node to invalidate\n\t * @param forceRebuild\n\t */\n\tprivate final void invalidateNode(Object node, boolean forceRebuild)\n\t{\n\t\tif (dirtyAll == false)\n\t\t{\n\t\t\t// get item for this node\n\t\t\tTreeItem item = (TreeItem)nodeToItemMap.get(node);\n\n\t\t\tif (item != null)\n\t\t\t{\n\t\t\t\tboolean createDOM = false;\n\n\t\t\t\tif (forceRebuild)\n\t\t\t\t{\n\t\t\t\t\t// recreate the item\n\t\t\t\t\tint level = item.getLevel();\n\t\t\t\t\tList children = item.getChildren();\n\t\t\t\t\tString id = item.getId();\n\n\t\t\t\t\t// store the parent of old item\n\t\t\t\t\tTreeItem parent = item.getParentItem();\n\n\t\t\t\t\t// if the old item has a parent, store it's index\n\t\t\t\t\tint index = parent != null ? parent.getChildren().indexOf(item) : -1;\n\n\t\t\t\t\tcreateDOM = dirtyItemsCreateDOM.contains(item);\n\n\t\t\t\t\tdirtyItems.remove(item);\n\t\t\t\t\tdirtyItemsCreateDOM.remove(item);\n\n\t\t\t\t\titem.remove();\n\n\t\t\t\t\titem = newTreeItem(node, level, id);\n\t\t\t\t\titemContainer.add(item);\n\n\t\t\t\t\titem.setChildren(children);\n\n\t\t\t\t\t// was the item an root item?\n\t\t\t\t\tif (parent == null)\n\t\t\t\t\t{\n\t\t\t\t\t\trootItem = item;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tparent.getChildren().set(index, item);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!dirtyItems.contains(item))\n\t\t\t\t\tdirtyItems.add(item);\n\n\t\t\t\tif (createDOM && !dirtyItemsCreateDOM.contains(item))\n\t\t\t\t{\n\t\t\t\t\tdirtyItemsCreateDOM.add(item);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Creates a tree item for given node.\n\t * \n\t * @param node\n\t *            The tree node\n\t * @param level\n\t *            The level\n\t * @return The new tree item\n\t */\n\tprivate final TreeItem newTreeItem(TreeNode node, int level)\n\t{\n\t\treturn new TreeItem(\"\" + idCounter++, node, level);\n\t}","id":33611,"modified_method":"/**\n\t * Creates a tree item for given node.\n\t * \n\t * @param node\n\t *            The tree node\n\t * @param level\n\t *            The level\n\t * @return The new tree item\n\t */\n\tprivate final TreeItem newTreeItem(Object node, int level)\n\t{\n\t\treturn new TreeItem(\"\" + idCounter++, node, level);\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see javax.swing.event.TreeModelListener#treeNodesChanged(javax.swing.event.TreeModelEvent)\n\t */\n\tpublic final void treeNodesChanged(TreeModelEvent e)\n\t{\n\t\t// has root node changed?\n\t\tif (e.getChildren() == null)\n\t\t{\n\t\t\tif (rootItem != null)\n\t\t\t{\n\t\t\t\tinvalidateNode((TreeNode)rootItem.getModelObject(), true);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// go through all changed nodes\n\t\t\tObject[] children = e.getChildren();\n\t\t\tif (children != null)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < children.length; i++)\n\t\t\t\t{\n\t\t\t\t\tTreeNode node = (TreeNode)children[i];\n\t\t\t\t\tif (isNodeVisible(node))\n\t\t\t\t\t{\n\t\t\t\t\t\t// if the nodes is visible invalidate it\n\t\t\t\t\t\tinvalidateNode(node, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":33612,"modified_method":"/**\n\t * @see javax.swing.event.TreeModelListener#treeNodesChanged(javax.swing.event.TreeModelEvent)\n\t */\n\tpublic final void treeNodesChanged(TreeModelEvent e)\n\t{\n\t\t// has root node changed?\n\t\tif (e.getChildren() == null)\n\t\t{\n\t\t\tif (rootItem != null)\n\t\t\t{\n\t\t\t\tinvalidateNode(rootItem.getModelObject(), true);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// go through all changed nodes\n\t\t\tObject[] children = e.getChildren();\n\t\t\tif (children != null)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < children.length; i++)\n\t\t\t\t{\n\t\t\t\t\tObject node = children[i];\n\t\t\t\t\tif (isNodeVisible(node))\n\t\t\t\t\t{\n\t\t\t\t\t\t// if the nodes is visible invalidate it\n\t\t\t\t\t\tinvalidateNode(node, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Sets whether the root of the tree should be visible.\n\t * \n\t * @param rootLess\n\t *            whether the root should be visible\n\t */\n\tpublic void setRootLess(boolean rootLess)\n\t{\n\t\tif (this.rootLess != rootLess)\n\t\t{\n\t\t\tthis.rootLess = rootLess;\n\t\t\tinvalidateAll();\n\n\t\t\t// if the tree is in rootless mode, make sure the root node is\n\t\t\t// expanded\n\t\t\tif (rootLess == true && getModelObject() != null)\n\t\t\t{\n\t\t\t\tgetTreeState().expandNode((TreeNode)((TreeModel)getModelObject()).getRoot());\n\t\t\t}\n\t\t}\n\t}","id":33613,"modified_method":"/**\n\t * Sets whether the root of the tree should be visible.\n\t * \n\t * @param rootLess\n\t *            whether the root should be visible\n\t */\n\tpublic void setRootLess(boolean rootLess)\n\t{\n\t\tif (this.rootLess != rootLess)\n\t\t{\n\t\t\tthis.rootLess = rootLess;\n\t\t\tinvalidateAll();\n\n\t\t\t// if the tree is in rootless mode, make sure the root node is\n\t\t\t// expanded\n\t\t\tif (rootLess == true && getModelObject() != null)\n\t\t\t{\n\t\t\t\tgetTreeState().expandNode(((TreeModel)getModelObject()).getRoot());\n\t\t\t}\n\t\t}\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Returns whether the given node is expanded.\n\t * \n\t * @param node\n\t *            The node to inspect\n\t * @return true if the node is expanded, false otherwise\n\t */\n\tprotected final boolean isNodeExpanded(TreeNode node)\n\t{\n\t\t// In root less mode the root node is always expanded\n\t\tif (isRootLess() && rootItem != null && rootItem.getModelObject().equals(node))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\treturn getTreeState().isNodeExpanded(node);\n\t}","id":33614,"modified_method":"/**\n\t * Returns whether the given node is expanded.\n\t * \n\t * @param node\n\t *            The node to inspect\n\t * @return true if the node is expanded, false otherwise\n\t */\n\tprotected final boolean isNodeExpanded(Object node)\n\t{\n\t\t// In root less mode the root node is always expanded\n\t\tif (isRootLess() && rootItem != null && rootItem.getModelObject().equals(node))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\treturn getTreeState().isNodeExpanded(node);\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Marks the last but one visible child node of the given item as dirty, if give child is the\n\t * last item of parent.\n\t * \n\t * We need this to refresh the previous visible item in case the inserted / deleted item was\n\t * last. The reason is that the line shape of previous item changes from L to |- .\n\t * \n\t * @param parent\n\t * @param child\n\t */\n\tprivate void markTheLastButOneChildDirty(TreeItem parent, TreeItem child)\n\t{\n\t\tif (parent.getChildren().indexOf(child) == parent.getChildren().size() - 1)\n\t\t{\n\t\t\t// go through the children backwards, start at the last but one\n\t\t\t// item\n\t\t\tfor (int i = parent.getChildren().size() - 2; i >= 0; --i)\n\t\t\t{\n\t\t\t\tTreeItem item = (TreeItem)parent.getChildren().get(i);\n\n\t\t\t\t// invalidate the node and it's children, so that they are\n\t\t\t\t// redrawn\n\t\t\t\tinvalidateNodeWithChildren((TreeNode)item.getModelObject());\n\n\t\t\t}\n\t\t}\n\t}","id":33615,"modified_method":"/**\n\t * Marks the last but one visible child node of the given item as dirty, if give child is the\n\t * last item of parent.\n\t * \n\t * We need this to refresh the previous visible item in case the inserted / deleted item was\n\t * last. The reason is that the line shape of previous item changes from L to |- .\n\t * \n\t * @param parent\n\t * @param child\n\t */\n\tprivate void markTheLastButOneChildDirty(TreeItem parent, TreeItem child)\n\t{\n\t\tif (parent.getChildren().indexOf(child) == parent.getChildren().size() - 1)\n\t\t{\n\t\t\t// go through the children backwards, start at the last but one\n\t\t\t// item\n\t\t\tfor (int i = parent.getChildren().size() - 2; i >= 0; --i)\n\t\t\t{\n\t\t\t\tTreeItem item = (TreeItem)parent.getChildren().get(i);\n\n\t\t\t\t// invalidate the node and it's children, so that they are\n\t\t\t\t// redrawn\n\t\t\t\tinvalidateNodeWithChildren(item.getModelObject());\n\n\t\t\t}\n\t\t}\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Builds (recursively) TreeItems for the given Iterator of TreeNodes.\n\t * \n\t * @param nodes\n\t *            The nodes to build tree items for\n\t * @param level\n\t *            The current level\n\t * @return List with new tree items\n\t */\n\tprivate final List buildTreeItems(Iterator nodes, int level)\n\t{\n\t\tList result = new ArrayList();\n\n\t\t// for each node\n\t\twhile (nodes.hasNext())\n\t\t{\n\t\t\tTreeNode node = (TreeNode)nodes.next();\n\t\t\t// create tree item\n\t\t\tTreeItem item = newTreeItem(node, level);\n\t\t\titemContainer.add(item);\n\n\t\t\t// builds it children (recursively)\n\t\t\tbuildItemChildren(item);\n\n\t\t\t// add item to result\n\t\t\tresult.add(item);\n\t\t}\n\n\t\treturn result;\n\t}","id":33616,"modified_method":"/**\n\t * Builds (recursively) TreeItems for the given Iterator of TreeNodes.\n\t * \n\t * @param nodes\n\t *            The nodes to build tree items for\n\t * @param level\n\t *            The current level\n\t * @return List with new tree items\n\t */\n\tprivate final List buildTreeItems(Iterator nodes, int level)\n\t{\n\t\tList result = new ArrayList();\n\n\t\t// for each node\n\t\twhile (nodes.hasNext())\n\t\t{\n\t\t\tObject node = nodes.next();\n\t\t\t// create tree item\n\t\t\tTreeItem item = newTreeItem(node, level);\n\t\t\titemContainer.add(item);\n\n\t\t\t// builds it children (recursively)\n\t\t\tbuildItemChildren(item);\n\n\t\t\t// add item to result\n\t\t\tresult.add(item);\n\t\t}\n\n\t\treturn result;\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Builds the children for given TreeItem. It recursively traverses children of it's TreeNode\n\t * and creates TreeItem for every visible TreeNode.\n\t * \n\t * @param item\n\t *            The parent tree item\n\t */\n\tprivate final void buildItemChildren(TreeItem item)\n\t{\n\t\tList items;\n\n\t\t// if the node is expanded\n\t\tif (isNodeExpanded((TreeNode)item.getModelObject()))\n\t\t{\n\t\t\t// build the items for children of the items' treenode.\n\t\t\titems = buildTreeItems(nodeChildren((TreeNode)item.getModelObject()),\n\t\t\t\titem.getLevel() + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// it's not expanded, just set children to an empty list\n\t\t\titems = new ArrayList(0);\n\t\t}\n\n\t\titem.setChildren(items);\n\t}","id":33617,"modified_method":"/**\n\t * Builds the children for given TreeItem. It recursively traverses children of it's TreeNode\n\t * and creates TreeItem for every visible TreeNode.\n\t * \n\t * @param item\n\t *            The parent tree item\n\t */\n\tprivate final void buildItemChildren(TreeItem item)\n\t{\n\t\tList items;\n\n\t\t// if the node is expanded\n\t\tif (isNodeExpanded(item.getModelObject()))\n\t\t{\n\t\t\t// build the items for children of the items' treenode.\n\t\t\titems = buildTreeItems(nodeChildren(item.getModelObject()), item.getLevel() + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// it's not expanded, just set children to an empty list\n\t\t\titems = new ArrayList(0);\n\t\t}\n\n\t\titem.setChildren(items);\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Return the representation of node children as Iterator interface.\n\t * \n\t * @param node\n\t *            The tree node\n\t * @return iterable presentation of node children\n\t */\n\tprivate final Iterator nodeChildren(TreeNode node)\n\t{\n\t\treturn toIterator(node.children());\n\t}","id":33618,"modified_method":"/**\n\t * Return the representation of node children as Iterator interface.\n\t * \n\t * @param node\n\t *            The tree node\n\t * @return iterable presentation of node children\n\t */\n\tpublic final Iterator<Object> nodeChildren(Object node)\n\t{\n\t\tTreeModel model = getTreeModel();\n\t\tint count = model.getChildCount(node);\n\t\tList<Object> nodes = new ArrayList<Object>(count);\n\t\tfor (int i = 0; i < count; ++i)\n\t\t{\n\t\t\tnodes.add(model.getChild(node, i));\n\t\t}\n\t\treturn nodes.iterator();\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t\t * @return parent item\n\t\t */\n\t\tpublic TreeItem getParentItem()\n\t\t{\n\t\t\treturn (TreeItem)nodeToItemMap.get(getParentNode((TreeNode)getModelObject()));\n\t\t}","id":33619,"modified_method":"/**\n\t\t * @return parent item\n\t\t */\n\t\tpublic TreeItem getParentItem()\n\t\t{\n\t\t\treturn (TreeItem)nodeToItemMap.get(getParentNode(getModelObject()));\n\t\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Invalidates node and it's children. On the next render, the node and children will be\n\t * updated. Node children will be rebuilt.\n\t * \n\t * @param node\n\t *            The node to invalidate\n\t */\n\tprivate final void invalidateNodeWithChildren(TreeNode node)\n\t{\n\t\tif (dirtyAll == false)\n\t\t{\n\t\t\t// get item for this node\n\t\t\tTreeItem item = (TreeItem)nodeToItemMap.get(node);\n\n\t\t\t// is the item visible?\n\t\t\tif (item != null)\n\t\t\t{\n\t\t\t\t// go though item children and remove every one of them\n\t\t\t\tvisitItemChildren(item, new IItemCallback()\n\t\t\t\t{\n\t\t\t\t\tpublic void visitItem(TreeItem item)\n\t\t\t\t\t{\n\t\t\t\t\t\tremoveItem(item);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// set children to null so that they get rebuild\n\t\t\t\titem.setChildren(null);\n\n\t\t\t\t// add item to dirty items\n\t\t\t\tdirtyItems.add(item);\n\t\t\t}\n\t\t}\n\t}","id":33620,"modified_method":"/**\n\t * Invalidates node and it's children. On the next render, the node and children will be\n\t * updated. Node children will be rebuilt.\n\t * \n\t * @param node\n\t *            The node to invalidate\n\t */\n\tprivate final void invalidateNodeWithChildren(Object node)\n\t{\n\t\tif (dirtyAll == false)\n\t\t{\n\t\t\t// get item for this node\n\t\t\tTreeItem item = (TreeItem)nodeToItemMap.get(node);\n\n\t\t\t// is the item visible?\n\t\t\tif (item != null)\n\t\t\t{\n\t\t\t\t// go though item children and remove every one of them\n\t\t\t\tvisitItemChildren(item, new IItemCallback()\n\t\t\t\t{\n\t\t\t\t\tpublic void visitItem(TreeItem item)\n\t\t\t\t\t{\n\t\t\t\t\t\tremoveItem(item);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// set children to null so that they get rebuild\n\t\t\t\titem.setChildren(null);\n\n\t\t\t\tif (!dirtyItems.contains(item))\n\t\t\t\t{\n\t\t\t\t\t// add item to dirty items\n\t\t\t\t\tdirtyItems.add(item);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Returns the component associated with given node, or null, if node is not visible. This is\n\t * useful in situations when you want to touch the node element in html.\n\t * \n\t * @param node\n\t *            Tree node\n\t * @return Component associated with given node, or null if node is not visible.\n\t */\n\tpublic Component getNodeComponent(TreeNode node)\n\t{\n\t\treturn (Component)nodeToItemMap.get(node);\n\t}","id":33621,"modified_method":"/**\n\t * Returns the component associated with given node, or null, if node is not visible. This is\n\t * useful in situations when you want to touch the node element in html.\n\t * \n\t * @param node\n\t *            Tree node\n\t * @return Component associated with given node, or null if node is not visible.\n\t */\n\tpublic Component getNodeComponent(Object node)\n\t{\n\t\treturn (Component)nodeToItemMap.get(node);\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * INTERNAL\n\t * \n\t * @param node\n\t */\n\tpublic final void markNodeDirty(TreeNode node)\n\t{\n\t\tinvalidateNode(node, false);\n\t}","id":33622,"modified_method":"/**\n\t * INTERNAL\n\t * \n\t * @param node\n\t */\n\tpublic final void markNodeDirty(Object node)\n\t{\n\t\tinvalidateNode(node, false);\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"private void onBeforeRenderInternal()\n\t{\n\t\tif (attached == false)\n\t\t{\n\t\t\tonBeforeAttach();\n\n\t\t\tcheckModel();\n\n\t\t\t// Do we have to rebuild the whole tree?\n\t\t\tif (dirtyAll && rootItem != null)\n\t\t\t{\n\t\t\t\tclearAllItem();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// rebuild children of dirty nodes that need it\n\t\t\t\trebuildDirty();\n\t\t\t}\n\n\t\t\t// is root item created? (root item is null if the items have not\n\t\t\t// been created yet, or the whole tree was dirty and clearAllITem\n\t\t\t// has been called\n\t\t\tif (rootItem == null)\n\t\t\t{\n\t\t\t\tTreeNode rootNode = (TreeNode)((TreeModel)getModelObject()).getRoot();\n\t\t\t\tif (rootNode != null)\n\t\t\t\t{\n\t\t\t\t\tif (isRootLess())\n\t\t\t\t\t{\n\t\t\t\t\t\trootItem = newTreeItem(rootNode, -1);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\trootItem = newTreeItem(rootNode, 0);\n\t\t\t\t\t}\n\t\t\t\t\titemContainer.add(rootItem);\n\t\t\t\t\tbuildItemChildren(rootItem);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tattached = true;\n\t\t}\n\t}","id":33623,"modified_method":"private void onBeforeRenderInternal()\n\t{\n\t\tif (attached == false)\n\t\t{\n\t\t\tonBeforeAttach();\n\n\t\t\tcheckModel();\n\n\t\t\t// Do we have to rebuild the whole tree?\n\t\t\tif (dirtyAll && rootItem != null)\n\t\t\t{\n\t\t\t\tclearAllItem();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// rebuild children of dirty nodes that need it\n\t\t\t\trebuildDirty();\n\t\t\t}\n\n\t\t\t// is root item created? (root item is null if the items have not\n\t\t\t// been created yet, or the whole tree was dirty and clearAllITem\n\t\t\t// has been called\n\t\t\tif (rootItem == null)\n\t\t\t{\n\t\t\t\tObject rootNode = ((TreeModel)getModelObject()).getRoot();\n\t\t\t\tif (rootNode != null)\n\t\t\t\t{\n\t\t\t\t\tif (isRootLess())\n\t\t\t\t\t{\n\t\t\t\t\t\trootItem = newTreeItem(rootNode, -1);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\trootItem = newTreeItem(rootNode, 0);\n\t\t\t\t\t}\n\t\t\t\t\titemContainer.add(rootItem);\n\t\t\t\t\tbuildItemChildren(rootItem);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tattached = true;\n\t\t}\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see javax.swing.event.TreeModelListener#treeStructureChanged(javax.swing.event.TreeModelEvent)\n\t */\n\tpublic final void treeStructureChanged(TreeModelEvent e)\n\t{\n\t\t// get the parent node of changed nodes\n\t\tTreeNode node = (TreeNode)e.getTreePath().getLastPathComponent();\n\n\t\t// has the tree root changed?\n\t\tif (e.getTreePath().getPathCount() == 1)\n\t\t{\n\t\t\tinvalidateAll();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tinvalidateNodeWithChildren(node);\n\t\t}\n\t}","id":33624,"modified_method":"/**\n\t * @see javax.swing.event.TreeModelListener#treeStructureChanged(javax.swing.event.TreeModelEvent)\n\t */\n\tpublic final void treeStructureChanged(TreeModelEvent e)\n\t{\n\t\t// get the parent node of changed nodes\n\t\tObject node = e.getTreePath().getLastPathComponent();\n\n\t\t// has the tree root changed?\n\t\tif (e.getTreePath().getPathCount() == 1)\n\t\t{\n\t\t\tinvalidateAll();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tinvalidateNodeWithChildren(node);\n\t\t}\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Returns parent node of given node.\n\t * @param node\n\t * @return\n\t */\n\tprotected TreeNode getParentNode(TreeNode node)\n\t{\n\t\treturn node.getParent();\n\t}","id":33625,"modified_method":"/**\n\t * Returns parent node of given node.\n\t * \n\t * @param node\n\t * @return\n\t */\n\tpublic Object getParentNode(Object node)\n\t{\n\t\tif (getModelObject() instanceof ExtendedTreeModel)\n\t\t{\n\t\t\treturn ((ExtendedTreeModel)getModelObject()).getParent(node);\n\t\t}\n\t\telse if (node instanceof TreeNode)\n\t\t{\n\t\t\treturn ((TreeNode)node).getParent();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\"Couldn't determine node parent. Either the tree model must implement ParentTreeModel or Node must implement TreeNode.\");\n\t\t}\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see org.apache.wicket.markup.html.tree.ITreeStateListener#nodeUnselected(javax.swing.tree.TreeNode)\n\t */\n\tpublic final void nodeUnselected(TreeNode node)\n\t{\n\t\tif (isNodeVisible(node))\n\t\t{\n\t\t\tinvalidateNode(node, isForceRebuildOnSelectionChange());\n\t\t}\n\t}","id":33626,"modified_method":"/**\n\t * @see org.apache.wicket.markup.html.tree.ITreeStateListener#nodeUnselected(javax.swing.tree.TreeNode)\n\t */\n\tpublic final void nodeUnselected(Object node)\n\t{\n\t\tif (isNodeVisible(node))\n\t\t{\n\t\t\tinvalidateNode(node, isForceRebuildOnSelectionChange());\n\t\t}\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see org.apache.wicket.markup.html.tree.ITreeStateListener#nodeSelected(javax.swing.tree.TreeNode)\n\t */\n\tpublic final void nodeSelected(TreeNode node)\n\t{\n\t\tif (isNodeVisible(node))\n\t\t{\n\t\t\tinvalidateNode(node, isForceRebuildOnSelectionChange());\n\t\t}\n\t}","id":33627,"modified_method":"/**\n\t * @see org.apache.wicket.markup.html.tree.ITreeStateListener#nodeSelected(javax.swing.tree.TreeNode)\n\t */\n\tpublic final void nodeSelected(Object node)\n\t{\n\t\tif (isNodeVisible(node))\n\t\t{\n\t\t\tinvalidateNode(node, isForceRebuildOnSelectionChange());\n\t\t}\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Returns whether the given node is visible, e.g. all it's parents are expanded.\n\t * \n\t * @param node\n\t *            The node to inspect\n\t * @return true if the node is visible, false otherwise\n\t */\n\tprivate final boolean isNodeVisible(TreeNode node)\n\t{\n\t\twhile (getParentNode(node) != null)\n\t\t{\n\t\t\tif (isNodeExpanded(node.getParent()) == false)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tnode = node.getParent();\n\t\t}\n\t\treturn true;\n\t}","id":33628,"modified_method":"/**\n\t * Returns whether the given node is visible, e.g. all it's parents are expanded.\n\t * \n\t * @param node\n\t *            The node to inspect\n\t * @return true if the node is visible, false otherwise\n\t */\n\tprivate final boolean isNodeVisible(Object node)\n\t{\n\t\tObject parent = getParentNode(node);\n\t\twhile (parent != null)\n\t\t{\n\t\t\tif (isNodeExpanded(parent) == false)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tparent = getParentNode(parent);\n\t\t}\n\t\treturn true;\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see javax.swing.event.TreeModelListener#treeNodesRemoved(javax.swing.event.TreeModelEvent)\n\t */\n\tpublic final void treeNodesRemoved(TreeModelEvent e)\n\t{\n\t\t// get the parent node of inserted nodes\n\t\tTreeNode parent = (TreeNode)e.getTreePath().getLastPathComponent();\n\t\tTreeItem parentItem = (TreeItem)nodeToItemMap.get(parent);\n\n\t\tif (isNodeVisible(parent) && isNodeExpanded(parent))\n\t\t{\n\t\t\tboolean nonEmpty = !parentItem.getChildren().isEmpty();\n\t\t\tfor (int i = 0; i < e.getChildren().length; ++i)\n\t\t\t{\n\t\t\t\tTreeNode node = (TreeNode)e.getChildren()[i];\n\n\t\t\t\tTreeItem item = (TreeItem)nodeToItemMap.get(node);\n\t\t\t\tif (item != null)\n\t\t\t\t{\n\t\t\t\t\tmarkTheLastButOneChildDirty(parentItem, item);\n\n\t\t\t\t\tparentItem.getChildren().remove(item);\n\n\t\t\t\t\t// go though item children and remove every one of them\n\t\t\t\t\tvisitItemChildren(item, new IItemCallback()\n\t\t\t\t\t{\n\t\t\t\t\t\tpublic void visitItem(TreeItem item)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tremoveItem(item);\n\n\t\t\t\t\t\t\t// deselect the node\n\t\t\t\t\t\t\tgetTreeState().selectNode((TreeNode)item.getModelObject(), false);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tremoveItem(item);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nonEmpty && parentItem.getChildren().isEmpty())\n\t\t\t{\n\t\t\t\tinvalidateNode(parent, true);\n\t\t\t}\n\t\t}\n\t}","id":33629,"modified_method":"/**\n\t * @see javax.swing.event.TreeModelListener#treeNodesRemoved(javax.swing.event.TreeModelEvent)\n\t */\n\tpublic final void treeNodesRemoved(TreeModelEvent e)\n\t{\n\t\t// get the parent node of inserted nodes\n\t\tObject parent = e.getTreePath().getLastPathComponent();\n\t\tTreeItem parentItem = (TreeItem)nodeToItemMap.get(parent);\n\n\t\tif (isNodeVisible(parent) && isNodeExpanded(parent))\n\t\t{\n\t\t\tboolean nonEmpty = !parentItem.getChildren().isEmpty();\n\t\t\tfor (int i = 0; i < e.getChildren().length; ++i)\n\t\t\t{\n\t\t\t\tObject node = e.getChildren()[i];\n\n\t\t\t\tTreeItem item = (TreeItem)nodeToItemMap.get(node);\n\t\t\t\tif (item != null)\n\t\t\t\t{\n\t\t\t\t\tmarkTheLastButOneChildDirty(parentItem, item);\n\n\t\t\t\t\tparentItem.getChildren().remove(item);\n\n\t\t\t\t\t// go though item children and remove every one of them\n\t\t\t\t\tvisitItemChildren(item, new IItemCallback()\n\t\t\t\t\t{\n\t\t\t\t\t\tpublic void visitItem(TreeItem item)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tremoveItem(item);\n\n\t\t\t\t\t\t\t// deselect the node\n\t\t\t\t\t\t\tgetTreeState().selectNode(item.getModelObject(), false);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tremoveItem(item);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nonEmpty && parentItem.getChildren().isEmpty())\n\t\t\t{\n\t\t\t\tinvalidateNode(parent, true);\n\t\t\t}\n\t\t}\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see org.apache.wicket.markup.html.tree.ITreeStateListener#nodeExpanded(javax.swing.tree.TreeNode)\n\t */\n\tpublic final void nodeExpanded(TreeNode node)\n\t{\n\t\tif (isNodeVisible(node) == true)\n\t\t{\n\t\t\tinvalidateNodeWithChildren(node);\n\t\t}\n\t}","id":33630,"modified_method":"/**\n\t * @see org.apache.wicket.markup.html.tree.ITreeStateListener#nodeExpanded(javax.swing.tree.TreeNode)\n\t */\n\tpublic final void nodeExpanded(Object node)\n\t{\n\t\tif (isNodeVisible(node) == true)\n\t\t{\n\t\t\tinvalidateNodeWithChildren(node);\n\t\t}\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Creates a link of type specified by current linkType. When the links is clicked it calls the\n\t * specified callback.\n\t * \n\t * @param id\n\t *            The component id\n\t * @param callback\n\t *            The link call back\n\t * @return The link component\n\t */\n\tpublic MarkupContainer newLink(String id, final ILinkCallback callback)\n\t{\n\t\tif (getLinkType() == LinkType.REGULAR)\n\t\t{\n\t\t\treturn new Link(id)\n\t\t\t{\n\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t/**\n\t\t\t\t * @see org.apache.wicket.markup.html.link.Link#onClick()\n\t\t\t\t */\n\t\t\t\tpublic void onClick()\n\t\t\t\t{\n\t\t\t\t\tcallback.onClick(null);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\telse if (getLinkType() == LinkType.AJAX)\n\t\t{\n\t\t\treturn new AjaxLink(id)\n\t\t\t{\n\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t/**\n\t\t\t\t * @see org.apache.wicket.ajax.markup.html.AjaxLink#onClick(org.apache.wicket.ajax.AjaxRequestTarget)\n\t\t\t\t */\n\t\t\t\tpublic void onClick(AjaxRequestTarget target)\n\t\t\t\t{\n\t\t\t\t\tcallback.onClick(target);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn new AjaxFallbackLink(id)\n\t\t\t{\n\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t/**\n\t\t\t\t * @see org.apache.wicket.ajax.markup.html.AjaxFallbackLink#onClick(org.apache.wicket.ajax.AjaxRequestTarget)\n\t\t\t\t */\n\t\t\t\tpublic void onClick(AjaxRequestTarget target)\n\t\t\t\t{\n\t\t\t\t\tcallback.onClick(target);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}","id":33631,"modified_method":"/**\n\t * Creates a link of type specified by current linkType. When the links is clicked it calls the\n\t * specified callback.\n\t * \n\t * @param id\n\t *            The component id\n\t * @param callback\n\t *            The link call back\n\t * @return The link component\n\t */\n\tpublic MarkupContainer newLink(String id, final ILinkCallback callback)\n\t{\n\t\tif (getLinkType() == LinkType.REGULAR)\n\t\t{\n\t\t\treturn new Link(id)\n\t\t\t{\n\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t/**\n\t\t\t\t * @see org.apache.wicket.markup.html.link.Link#onClick()\n\t\t\t\t */\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick()\n\t\t\t\t{\n\t\t\t\t\tcallback.onClick(null);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\telse if (getLinkType() == LinkType.AJAX)\n\t\t{\n\t\t\treturn new AjaxLink(id)\n\t\t\t{\n\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t/**\n\t\t\t\t * @see org.apache.wicket.ajax.markup.html.AjaxLink#onClick(org.apache.wicket.ajax.AjaxRequestTarget)\n\t\t\t\t */\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(AjaxRequestTarget target)\n\t\t\t\t{\n\t\t\t\t\tcallback.onClick(target);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn new AjaxFallbackLink(id)\n\t\t\t{\n\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t/**\n\t\t\t\t * @see org.apache.wicket.ajax.markup.html.AjaxFallbackLink#onClick(org.apache.wicket.ajax.AjaxRequestTarget)\n\t\t\t\t */\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(AjaxRequestTarget target)\n\t\t\t\t{\n\t\t\t\t\tcallback.onClick(target);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Returns whether the provided node is last child of it's parent.\n\t * \n\t * @param node\n\t *            The node\n\t * @return whether the provided node is the last child\n\t */\n\tprivate static boolean isNodeLast(TreeNode node)\n\t{\n\t\tTreeNode parent = node.getParent();\n\t\tif (parent == null)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn parent.getChildAt(parent.getChildCount() - 1).equals(node);\n\t\t}\n\t}","id":33632,"modified_method":"/**\n\t * Returns whether the provided node is last child of it's parent.\n\t * \n\t * @param node\n\t *            The node\n\t * @return whether the provided node is the last child\n\t */\n\tprivate boolean isNodeLast(Object node)\n\t{\n\t\tObject parent = getParentNode(node);\n\t\tif (parent == null)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn getChildAt(parent, getChildCount(parent) - 1).equals(node);\n\t\t}\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t\t * Construct.\n\t\t * \n\t\t * @param node\n\t\t * @param level\n\t\t */\n\t\tpublic JunctionBorder(TreeNode node, int level)\n\t\t{\n\t\t\tthis.node = node;\n\t\t\tthis.level = level;\n\t\t}","id":33633,"modified_method":"/**\n\t\t * Construct.\n\t\t * \n\t\t * @param node\n\t\t * @param level\n\t\t */\n\t\tpublic JunctionBorder(Object node, int level)\n\t\t{\n\t\t\tthis.node = node;\n\t\t\tthis.level = level;\n\t\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Callback function called after user clicked on an junction link. The node has already been\n\t * expanded/collapsed (depending on previous status).\n\t * \n\t * @param target\n\t *            Request target - may be null on non-ajax call\n\t * \n\t * @param node\n\t *            Node for which this callback is relevant\n\t */\n\tprotected void onJunctionLinkClicked(AjaxRequestTarget target, TreeNode node)\n\t{\n\t}","id":33634,"modified_method":"/**\n\t * Callback function called after user clicked on an junction link. The node has already been\n\t * expanded/collapsed (depending on previous status).\n\t * \n\t * @param target\n\t *            Request target - may be null on non-ajax call\n\t * \n\t * @param node\n\t *            Node for which this callback is relevant\n\t */\n\tprotected void onJunctionLinkClicked(AjaxRequestTarget target, Object node)\n\t{\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Creates the junction link for given node. Also (optionally) creates the junction image. If\n\t * the node is a leaf (it has no children), the created junction link is non-functional.\n\t * \n\t * @param parent\n\t *            parent component of the link\n\t * @param id\n\t *            wicket:id of the component\n\t * @param node\n\t *            tree node for which the link should be created.\n\t * @return The link component\n\t */\n\tprotected Component newJunctionLink(MarkupContainer parent, final String id, final TreeNode node)\n\t{\n\t\tfinal MarkupContainer junctionLink;\n\n\t\tif (node.isLeaf() == false)\n\t\t{\n\t\t\tjunctionLink = newLink(id, new ILinkCallback()\n\t\t\t{\n\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\tpublic void onClick(AjaxRequestTarget target)\n\t\t\t\t{\n\t\t\t\t\tif (isNodeExpanded(node))\n\t\t\t\t\t{\n\t\t\t\t\t\tgetTreeState().collapseNode(node);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tgetTreeState().expandNode(node);\n\t\t\t\t\t}\n\t\t\t\t\tonJunctionLinkClicked(target, node);\n\t\t\t\t\tupdateTree(target);\n\t\t\t\t}\n\t\t\t});\n\t\t\tjunctionLink.add(new AbstractBehavior()\n\t\t\t{\n\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\tpublic void onComponentTag(Component component, ComponentTag tag)\n\t\t\t\t{\n\t\t\t\t\tif (isNodeExpanded(node))\n\t\t\t\t\t{\n\t\t\t\t\t\ttag.put(\"class\", \"junction-open\");\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttag.put(\"class\", \"junction-closed\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tjunctionLink = new WebMarkupContainer(id)\n\t\t\t{\n\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t/**\n\t\t\t\t * @see org.apache.wicket.Component#onComponentTag(org.apache.wicket.markup.ComponentTag)\n\t\t\t\t */\n\t\t\t\tprotected void onComponentTag(ComponentTag tag)\n\t\t\t\t{\n\t\t\t\t\tsuper.onComponentTag(tag);\n\t\t\t\t\ttag.setName(\"span\");\n\t\t\t\t\ttag.put(\"class\", \"junction-corner\");\n\t\t\t\t}\n\t\t\t};\n\n\t\t}\n\n\t\treturn junctionLink;\n\t}","id":33635,"modified_method":"/**\n\t * Creates the junction link for given node. Also (optionally) creates the junction image. If\n\t * the node is a leaf (it has no children), the created junction link is non-functional.\n\t * \n\t * @param parent\n\t *            parent component of the link\n\t * @param id\n\t *            wicket:id of the component\n\t * @param node\n\t *            tree node for which the link should be created.\n\t * @return The link component\n\t */\n\tprotected Component newJunctionLink(MarkupContainer parent, final String id, final Object node)\n\t{\n\t\tfinal MarkupContainer junctionLink;\n\n\t\tif (isLeaf(node) == false)\n\t\t{\n\t\t\tjunctionLink = newLink(id, new ILinkCallback()\n\t\t\t{\n\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\tpublic void onClick(AjaxRequestTarget target)\n\t\t\t\t{\n\t\t\t\t\tif (isNodeExpanded(node))\n\t\t\t\t\t{\n\t\t\t\t\t\tgetTreeState().collapseNode(node);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tgetTreeState().expandNode(node);\n\t\t\t\t\t}\n\t\t\t\t\tonJunctionLinkClicked(target, node);\n\t\t\t\t\tupdateTree(target);\n\t\t\t\t}\n\t\t\t});\n\t\t\tjunctionLink.add(new AbstractBehavior()\n\t\t\t{\n\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t@Override\n\t\t\t\tpublic void onComponentTag(Component component, ComponentTag tag)\n\t\t\t\t{\n\t\t\t\t\tif (isNodeExpanded(node))\n\t\t\t\t\t{\n\t\t\t\t\t\ttag.put(\"class\", \"junction-open\");\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttag.put(\"class\", \"junction-closed\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tjunctionLink = new WebMarkupContainer(id)\n\t\t\t{\n\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t/**\n\t\t\t\t * @see org.apache.wicket.Component#onComponentTag(org.apache.wicket.markup.ComponentTag)\n\t\t\t\t */\n\t\t\t\t@Override\n\t\t\t\tprotected void onComponentTag(ComponentTag tag)\n\t\t\t\t{\n\t\t\t\t\tsuper.onComponentTag(tag);\n\t\t\t\t\ttag.setName(\"span\");\n\t\t\t\t\ttag.put(\"class\", \"junction-corner\");\n\t\t\t\t}\n\t\t\t};\n\n\t\t}\n\n\t\treturn junctionLink;\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see org.apache.wicket.markup.html.tree.AbstractTree#populateTreeItem(org.apache.wicket.markup.html.WebMarkupContainer,\n\t *      int)\n\t */\n\tprotected void populateTreeItem(WebMarkupContainer item, int level)\n\t{\n\t\t// add junction link\n\t\tTreeNode node = (TreeNode)item.getModelObject();\n\t\tComponent junctionLink = newJunctionLink(item, JUNCTION_LINK_ID, node);\n\t\tjunctionLink.setComponentBorder(new JunctionBorder(node, level));\n\t\titem.add(junctionLink);\n\n\t\t// add node component\n\t\tComponent nodeComponent = newNodeComponent(NODE_COMPONENT_ID, item.getModel());\n\t\titem.add(nodeComponent);\n\n\t\t// add behavior that conditionally adds the \"selected\" CSS class name\n\t\titem.add(new AbstractBehavior()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void onComponentTag(Component component, ComponentTag tag)\n\t\t\t{\n\t\t\t\tTreeNode node = (TreeNode)component.getModelObject();\n\t\t\t\tif (getTreeState().isNodeSelected(node))\n\t\t\t\t{\n\t\t\t\t\tCharSequence oldClass = tag.getString(\"class\");\n\t\t\t\t\tif (Strings.isEmpty(oldClass))\n\t\t\t\t\t{\n\t\t\t\t\t\ttag.put(\"class\", getSelectedClass());\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttag.put(\"class\", oldClass + \" \" + getSelectedClass());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}","id":33636,"modified_method":"/**\n\t * @see org.apache.wicket.markup.html.tree.AbstractTree#populateTreeItem(org.apache.wicket.markup.html.WebMarkupContainer,\n\t *      int)\n\t */\n\t@Override\n\tprotected void populateTreeItem(WebMarkupContainer item, int level)\n\t{\n\t\t// add junction link\n\t\tObject node = item.getModelObject();\n\t\tComponent junctionLink = newJunctionLink(item, JUNCTION_LINK_ID, node);\n\t\tjunctionLink.setComponentBorder(new JunctionBorder(node, level));\n\t\titem.add(junctionLink);\n\n\t\t// add node component\n\t\tComponent nodeComponent = newNodeComponent(NODE_COMPONENT_ID, item.getModel());\n\t\titem.add(nodeComponent);\n\n\t\t// add behavior that conditionally adds the \"selected\" CSS class name\n\t\titem.add(new AbstractBehavior()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic void onComponentTag(Component component, ComponentTag tag)\n\t\t\t{\n\t\t\t\tObject node = component.getModelObject();\n\t\t\t\tif (getTreeState().isNodeSelected(node))\n\t\t\t\t{\n\t\t\t\t\tCharSequence oldClass = tag.getString(\"class\");\n\t\t\t\t\tif (Strings.isEmpty(oldClass))\n\t\t\t\t\t{\n\t\t\t\t\t\ttag.put(\"class\", getSelectedClass());\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttag.put(\"class\", oldClass + \" \" + getSelectedClass());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"public void renderBefore(Component component)\n\t\t{\n\t\t\tResponse response = RequestCycle.get().getResponse();\n\t\t\tTreeNode parent = node.getParent();\n\n\t\t\tCharSequence classes[] = new CharSequence[level];\n\t\t\tfor (int i = 0; i < level; ++i)\n\t\t\t{\n\t\t\t\tif (parent == null || isNodeLast(parent))\n\t\t\t\t{\n\t\t\t\t\tclasses[i] = \"spacer\";\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tclasses[i] = \"line\";\n\t\t\t\t}\n\n\t\t\t\tparent = parent.getParent();\n\t\t\t}\n\n\t\t\tfor (int i = level - 1; i >= 0; --i)\n\t\t\t{\n\t\t\t\tresponse.write(\"<td class=\\\"\" + classes[i] + \"\\\"><span><\/span><\/td>\");\n\t\t\t}\n\n\t\t\tif (isNodeLast(node))\n\t\t\t{\n\t\t\t\tresponse.write(\"<td class=\\\"half-line\\\">\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresponse.write(\"<td class=\\\"line\\\">\");\n\t\t\t}\n\t\t}","id":33637,"modified_method":"public void renderBefore(Component component)\n\t\t{\n\t\t\tResponse response = RequestCycle.get().getResponse();\n\t\t\tObject parent = getParentNode(node);\n\n\t\t\tCharSequence classes[] = new CharSequence[level];\n\t\t\tfor (int i = 0; i < level; ++i)\n\t\t\t{\n\t\t\t\tif (parent == null || isNodeLast(parent))\n\t\t\t\t{\n\t\t\t\t\tclasses[i] = \"spacer\";\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tclasses[i] = \"line\";\n\t\t\t\t}\n\n\t\t\t\tparent = getParentNode(parent);\n\t\t\t}\n\n\t\t\tfor (int i = level - 1; i >= 0; --i)\n\t\t\t{\n\t\t\t\tresponse.write(\"<td class=\\\"\" + classes[i] + \"\\\"><span><\/span><\/td>\");\n\t\t\t}\n\n\t\t\tif (isNodeLast(node))\n\t\t\t{\n\t\t\t\tresponse.write(\"<td class=\\\"half-line\\\">\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresponse.write(\"<td class=\\\"line\\\">\");\n\t\t\t}\n\t\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Sets the type of links on tree items. After the link type is changed, the whole tree is\n\t * rebuild and re-rendered.\n\t * \n\t * @param linkType\n\t *            type of links\n\t */\n\tpublic void setLinkType(LinkType linkType)\n\t{\n\t\tif (this.linkType != linkType)\n\t\t{\n\t\t\tthis.linkType = linkType;\n\t\t\tinvalidateAll();\n\t\t}\n\t}","id":33638,"modified_method":"/**\n\t * Sets the type of links on tree items. After the link type is changed, the whole tree must be\n\t * rebuilt (call invalidateAll).\n\t * \n\t * @param linkType\n\t *            type of links\n\t */\n\tpublic void setLinkType(LinkType linkType)\n\t{\n\t\tif (this.linkType != linkType)\n\t\t{\n\t\t\tthis.linkType = linkType;\n\t\t}\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see org.apache.wicket.markup.html.tree.ITreeState#expandNode(javax.swing.tree.TreeNode)\n\t */\n\tpublic void expandNode(TreeNode node)\n\t{\n\t\tif (nodesCollapsed == false)\n\t\t{\n\t\t\tnodes.add(node);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnodes.remove(node);\n\t\t}\n\n\t\tObject[] listenersCopy = listeners.toArray();\n\t\tfor (int i = 0; i < listenersCopy.length; i++)\n\t\t{\n\t\t\tITreeStateListener l = (ITreeStateListener)listenersCopy[i];\n\t\t\tl.nodeExpanded(node);\n\t\t}\n\t}","id":33639,"modified_method":"public void expandNode(Object node)\n\t{\n\t\tif (nodesCollapsed == false)\n\t\t{\n\t\t\tnodes.add(node);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnodes.remove(node);\n\t\t}\n\n\t\tObject[] listenersCopy = listeners.toArray();\n\t\tfor (int i = 0; i < listenersCopy.length; i++)\n\t\t{\n\t\t\tITreeStateListener l = (ITreeStateListener)listenersCopy[i];\n\t\t\tl.nodeExpanded(node);\n\t\t}\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see org.apache.wicket.markup.html.tree.ITreeState#selectNode(javax.swing.tree.TreeNode,\n\t *      boolean)\n\t */\n\tpublic void selectNode(TreeNode node, boolean selected)\n\t{\n\t\tif (isAllowSelectMultiple() == false && selectedNodes.size() > 0)\n\t\t{\n\t\t\tfor (Iterator i = selectedNodes.iterator(); i.hasNext();)\n\t\t\t{\n\t\t\t\tTreeNode current = (TreeNode)i.next();\n\t\t\t\tif (current.equals(node) == false)\n\t\t\t\t{\n\t\t\t\t\ti.remove();\n\t\t\t\t\tObject[] listenersCopy = listeners.toArray();\n\t\t\t\t\tfor (int j = 0; j < listenersCopy.length; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tITreeStateListener l = (ITreeStateListener)listenersCopy[j];\n\t\t\t\t\t\tl.nodeUnselected(current);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (selected == true && selectedNodes.contains(node) == false)\n\t\t{\n\n\t\t\tselectedNodes.add(node);\n\t\t\tObject[] listenersCopy = listeners.toArray();\n\t\t\tfor (int i = 0; i < listenersCopy.length; i++)\n\t\t\t{\n\t\t\t\tITreeStateListener l = (ITreeStateListener)listenersCopy[i];\n\t\t\t\tl.nodeSelected(node);\n\t\t\t}\n\t\t}\n\t\telse if (selected == false && selectedNodes.contains(node) == true)\n\t\t{\n\t\t\tselectedNodes.remove(node);\n\t\t\tObject[] listenersCopy = listeners.toArray();\n\t\t\tfor (int i = 0; i < listenersCopy.length; i++)\n\t\t\t{\n\t\t\t\tITreeStateListener l = (ITreeStateListener)listenersCopy[i];\n\t\t\t\tl.nodeUnselected(node);\n\t\t\t}\n\t\t}\n\t}","id":33640,"modified_method":"public void selectNode(Object node, boolean selected)\n\t{\n\t\tif (isAllowSelectMultiple() == false && selectedNodes.size() > 0)\n\t\t{\n\t\t\tfor (Iterator i = selectedNodes.iterator(); i.hasNext();)\n\t\t\t{\n\t\t\t\tObject current = i.next();\n\t\t\t\tif (current.equals(node) == false)\n\t\t\t\t{\n\t\t\t\t\ti.remove();\n\t\t\t\t\tObject[] listenersCopy = listeners.toArray();\n\t\t\t\t\tfor (int j = 0; j < listenersCopy.length; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tITreeStateListener l = (ITreeStateListener)listenersCopy[j];\n\t\t\t\t\t\tl.nodeUnselected(current);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (selected == true && selectedNodes.contains(node) == false)\n\t\t{\n\n\t\t\tselectedNodes.add(node);\n\t\t\tObject[] listenersCopy = listeners.toArray();\n\t\t\tfor (int i = 0; i < listenersCopy.length; i++)\n\t\t\t{\n\t\t\t\tITreeStateListener l = (ITreeStateListener)listenersCopy[i];\n\t\t\t\tl.nodeSelected(node);\n\t\t\t}\n\t\t}\n\t\telse if (selected == false && selectedNodes.contains(node) == true)\n\t\t{\n\t\t\tselectedNodes.remove(node);\n\t\t\tObject[] listenersCopy = listeners.toArray();\n\t\t\tfor (int i = 0; i < listenersCopy.length; i++)\n\t\t\t{\n\t\t\t\tITreeStateListener l = (ITreeStateListener)listenersCopy[i];\n\t\t\t\tl.nodeUnselected(node);\n\t\t\t}\n\t\t}\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see org.apache.wicket.markup.html.tree.ITreeState#isNodeExpanded(javax.swing.tree.TreeNode)\n\t */\n\tpublic boolean isNodeExpanded(TreeNode node)\n\t{\n\t\tif (nodesCollapsed == false)\n\t\t{\n\t\t\treturn nodes.contains(node);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn nodes.contains(node) == false;\n\t\t}\n\t}","id":33641,"modified_method":"public boolean isNodeExpanded(Object node)\n\t{\n\t\tif (nodesCollapsed == false)\n\t\t{\n\t\t\treturn nodes.contains(node);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn nodes.contains(node) == false;\n\t\t}\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see org.apache.wicket.markup.html.tree.ITreeState#collapseNode(javax.swing.tree.TreeNode)\n\t */\n\tpublic void collapseNode(TreeNode node)\n\t{\n\t\tif (nodesCollapsed == true)\n\t\t{\n\t\t\tnodes.add(node);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnodes.remove(node);\n\t\t}\n\n\t\tObject[] listenersCopy = listeners.toArray();\n\t\tfor (int i = 0; i < listenersCopy.length; i++)\n\t\t{\n\t\t\tITreeStateListener l = (ITreeStateListener)listenersCopy[i];\n\t\t\tl.nodeCollapsed(node);\n\t\t}\n\t}","id":33642,"modified_method":"public void collapseNode(Object node)\n\t{\n\t\tif (nodesCollapsed == true)\n\t\t{\n\t\t\tnodes.add(node);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnodes.remove(node);\n\t\t}\n\n\t\tObject[] listenersCopy = listeners.toArray();\n\t\tfor (int i = 0; i < listenersCopy.length; i++)\n\t\t{\n\t\t\tITreeStateListener l = (ITreeStateListener)listenersCopy[i];\n\t\t\tl.nodeCollapsed(node);\n\t\t}\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see org.apache.wicket.markup.html.tree.ITreeState#isNodeSelected(javax.swing.tree.TreeNode)\n\t */\n\tpublic boolean isNodeSelected(TreeNode node)\n\t{\n\t\treturn selectedNodes.contains(node);\n\t}","id":33643,"modified_method":"public boolean isNodeSelected(Object node)\n\t{\n\t\treturn selectedNodes.contains(node);\n\t}","commit_id":"3f9425918507731efed21ef9e3c7c32f135c237a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see FormComponent#getModelValue()\n\t */\n\tpublic final String getModelValue()\n\t{\n\t\t// Get the list of selected values\n\t\tfinal Collection selectedValues = (Collection)getModelObject();\n\t\tfinal AppendingStringBuffer buffer = new AppendingStringBuffer();\n\t\tif (selectedValues != null)\n\t\t{\n\t\t\tfinal List choices = getChoices();\n\t\t\tfor (final Iterator iterator = selectedValues.iterator(); iterator.hasNext();)\n\t\t\t{\n\t\t\t\tfinal Object object = iterator.next();\n\n\t\t\t\tint index = choices.indexOf(object);\n\t\t\t\tbuffer.append(getChoiceRenderer().getIdValue(object, index));\n\t\t\t\tbuffer.append(VALUE_SEPARATOR);\n\t\t\t}\n\t\t}\n\t\treturn buffer.toString();\n\t}","id":33644,"modified_method":"/**\n\t * @see FormComponent#getModelValue()\n\t */\n\tpublic final String getModelValue()\n\t{\n\t\t// Get the list of selected values\n\t\tObject modelObject = getModelObject();\n\t\tif (! (modelObject instanceof Collection))\n\t\t\tthrow new WicketRuntimeException(\"Model object for a ListMultipleChoice must be a Collection (found \" + modelObject.getClass() + \")\");\n\t\tfinal Collection selectedValues = (Collection)modelObject;\n\t\tfinal AppendingStringBuffer buffer = new AppendingStringBuffer();\n\t\tif (selectedValues != null)\n\t\t{\n\t\t\tfinal List choices = getChoices();\n\t\t\tfor (final Iterator iterator = selectedValues.iterator(); iterator.hasNext();)\n\t\t\t{\n\t\t\t\tfinal Object object = iterator.next();\n\n\t\t\t\tint index = choices.indexOf(object);\n\t\t\t\tbuffer.append(getChoiceRenderer().getIdValue(object, index));\n\t\t\t\tbuffer.append(VALUE_SEPARATOR);\n\t\t\t}\n\t\t}\n\t\treturn buffer.toString();\n\t}","commit_id":"406f3b0969166753441b0b211a23e38d9aeccecf","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see FormComponent#updateModel()\n\t */\n\tpublic void updateModel()\n\t{\n\t\tCollection selectedValues = (Collection)getModelObject();\n\t\tif (selectedValues != null)\n\t\t{\n\t\t\tmodelChanging();\n\t\t\tselectedValues.clear();\n\t\t\tselectedValues.addAll((Collection)getConvertedInput());\n\t\t\tmodelChanged();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tselectedValues = (Collection)getConvertedInput();\n\t\t\tsetModelObject(selectedValues);\n\t\t}\n\t}","id":33645,"modified_method":"/**\n\t * @see FormComponent#updateModel()\n\t */\n\tpublic void updateModel()\n\t{\n\t\tCollection selectedValues = (Collection)getModelObject();\n\t\tif (selectedValues != null)\n\t\t{\n\t\t\tif (getModelObject() != selectedValues)\n\t\t\t\tthrow new WicketRuntimeException(\"Updating a ListMultipleChoice works by modifying the underlying model object in-place, so please make sure that getObject() always returns the same Collection instance!\");\n\t\t\tmodelChanging();\n\t\t\tselectedValues.clear();\n\t\t\tselectedValues.addAll((Collection)getConvertedInput());\n\t\t\tmodelChanged();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tselectedValues = (Collection)getConvertedInput();\n\t\t\tsetModelObject(selectedValues);\n\t\t}\n\t}","commit_id":"406f3b0969166753441b0b211a23e38d9aeccecf","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Evaluates the template and returns the result.\n\t * \n\t * @param templateReader\n\t *            used to read the template\n\t * @return the result of evaluating the velocity template\n\t */\n\tprivate String evaluateVelocityTemplate(Reader templateReader)\n\t{\n\t\tif (evaluatedTemplate == null)\n\t\t{\n\t\t\t// Get model as a map\n\t\t\tfinal Map map = (Map)getModelObject();\n\n\t\t\t// create a Velocity context object using the model if set\n\t\t\tfinal VelocityContext ctx = new VelocityContext(map);\n\n\t\t\t// create a writer for capturing the Velocity output\n\t\t\tStringWriter writer = new StringWriter();\n\n\t\t\t// string to be used as the template name for log messages in case\n\t\t\t// of error\n\t\t\tfinal String logTag = getId();\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// execute the velocity script and capture the output in writer\n\t\t\t\tVelocity.evaluate(ctx, writer, logTag, templateReader);\n\n\t\t\t\t// replace the tag's body the Velocity output\n\t\t\t\tevaluatedTemplate = writer.toString();\n\n\t\t\t\tif (escapeHtml())\n\t\t\t\t{\n\t\t\t\t\t// encode the result in order to get valid html output that\n\t\t\t\t\t// does not break the rest of the page\n\t\t\t\t\tevaluatedTemplate = Strings.escapeMarkup(evaluatedTemplate).toString();\n\t\t\t\t}\n\t\t\t\treturn evaluatedTemplate;\n\t\t\t}\n\t\t\tcatch (IOException e)\n\t\t\t{\n\t\t\t\tonException(e);\n\t\t\t}\n\t\t\tcatch (ParseErrorException e)\n\t\t\t{\n\t\t\t\tonException(e);\n\t\t\t}\n\t\t\tcatch (MethodInvocationException e)\n\t\t\t{\n\t\t\t\tonException(e);\n\t\t\t}\n\t\t\tcatch (ResourceNotFoundException e)\n\t\t\t{\n\t\t\t\tonException(e);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\treturn evaluatedTemplate;\n\t}","id":33646,"modified_method":"/**\n\t * Evaluates the template and returns the result.\n\t * \n\t * @param templateReader\n\t *            used to read the template\n\t * @return the result of evaluating the velocity template\n\t */\n\tprivate String evaluateVelocityTemplate(Reader templateReader)\n\t{\n\t\tif (evaluatedTemplate == null)\n\t\t{\n\t\t\t// Get model as a map\n\t\t\tfinal Map map = getModelObject();\n\n\t\t\t// create a Velocity context object using the model if set\n\t\t\tfinal VelocityContext ctx = new VelocityContext(map);\n\n\t\t\t// create a writer for capturing the Velocity output\n\t\t\tStringWriter writer = new StringWriter();\n\n\t\t\t// string to be used as the template name for log messages in case\n\t\t\t// of error\n\t\t\tfinal String logTag = getId();\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// execute the velocity script and capture the output in writer\n\t\t\t\tVelocity.evaluate(ctx, writer, logTag, templateReader);\n\n\t\t\t\t// replace the tag's body the Velocity output\n\t\t\t\tevaluatedTemplate = writer.toString();\n\n\t\t\t\tif (escapeHtml())\n\t\t\t\t{\n\t\t\t\t\t// encode the result in order to get valid html output that\n\t\t\t\t\t// does not break the rest of the page\n\t\t\t\t\tevaluatedTemplate = Strings.escapeMarkup(evaluatedTemplate).toString();\n\t\t\t\t}\n\t\t\t\treturn evaluatedTemplate;\n\t\t\t}\n\t\t\tcatch (IOException e)\n\t\t\t{\n\t\t\t\tonException(e);\n\t\t\t}\n\t\t\tcatch (ParseErrorException e)\n\t\t\t{\n\t\t\t\tonException(e);\n\t\t\t}\n\t\t\tcatch (MethodInvocationException e)\n\t\t\t{\n\t\t\t\tonException(e);\n\t\t\t}\n\t\t\tcatch (ResourceNotFoundException e)\n\t\t\t{\n\t\t\t\tonException(e);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\treturn evaluatedTemplate;\n\t}","commit_id":"96859687c9aab9c895ff0dbd9e0de45a0ee8b5b4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Convenience factory method to create a {@link VelocityPanel} instance with a given\n\t * {@link IStringResourceStream template resource}.\n\t * \n\t * @param id\n\t *            Component id\n\t * @param model\n\t *            optional model for variable substituation.\n\t * @param templateResource\n\t *            The template resource\n\t * @return an instance of {@link VelocityPanel}\n\t */\n\tpublic static VelocityPanel forTemplateResource(String id, IModel model,\n\t\t\tfinal IStringResourceStream templateResource)\n\t{\n\t\tif (templateResource == null)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"argument templateResource must be not null\");\n\t\t}\n\n\t\treturn new VelocityPanel(id, model)\n\t\t{\n\t\t\tprotected IStringResourceStream getTemplateResource()\n\t\t\t{\n\t\t\t\treturn templateResource;\n\t\t\t}\n\t\t};\n\t}","id":33647,"modified_method":"/**\n\t * Convenience factory method to create a {@link VelocityPanel} instance with a given\n\t * {@link IStringResourceStream template resource}.\n\t * \n\t * @param id\n\t *            Component id\n\t * @param model\n\t *            optional model for variable substitution.\n\t * @param templateResource\n\t *            The template resource\n\t * @return an instance of {@link VelocityPanel}\n\t */\n\tpublic static VelocityPanel forTemplateResource(String id, IModel<Map> model,\n\t\t\tfinal IStringResourceStream templateResource)\n\t{\n\t\tif (templateResource == null)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"argument templateResource must be not null\");\n\t\t}\n\n\t\treturn new VelocityPanel(id, model)\n\t\t{\n\t\t\t@Override\n\t\t\tprotected IStringResourceStream getTemplateResource()\n\t\t\t{\n\t\t\t\treturn templateResource;\n\t\t\t}\n\t\t};\n\t}","commit_id":"96859687c9aab9c895ff0dbd9e0de45a0ee8b5b4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see org.apache.wicket.markup.IMarkupCacheKeyProvider#getCacheKey(org.apache.wicket.MarkupContainer,\n\t *      java.lang.Class)\n\t */\n\tpublic final String getCacheKey(MarkupContainer container, Class containerClass)\n\t{\n\t\t// don't cache the evaluated template\n\t\treturn null;\n\t}","id":33648,"modified_method":"/**\n\t * @see org.apache.wicket.markup.IMarkupCacheKeyProvider#getCacheKey(org.apache.wicket.MarkupContainer,\n\t *      java.lang.Class)\n\t */\n\tpublic final String getCacheKey(MarkupContainer< ? > container, Class< ? > containerClass)\n\t{\n\t\t// don't cache the evaluated template\n\t\treturn null;\n\t}","commit_id":"96859687c9aab9c895ff0dbd9e0de45a0ee8b5b4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see org.apache.wicket.markup.IMarkupResourceStreamProvider#getMarkupResourceStream(org.apache.wicket.MarkupContainer,\n\t *      java.lang.Class)\n\t */\n\tpublic final IResourceStream getMarkupResourceStream(MarkupContainer container,\n\t\t\tClass containerClass)\n\t{\n\t\tReader reader = getTemplateReader();\n\t\tif (reader == null)\n\t\t{\n\t\t\tthrow new WicketRuntimeException(\"could not find velocity template for panel: \" + this);\n\t\t}\n\n\t\t// evaluate the template and return a new StringResourceStream\n\t\tStringBuffer sb = new StringBuffer();\n\t\tsb.append(\"<wicket:panel>\");\n\t\tsb.append(evaluateVelocityTemplate(reader));\n\t\tsb.append(\"<\/wicket:panel>\");\n\t\treturn new StringResourceStream(sb.toString());\n\t}","id":33649,"modified_method":"/**\n\t * @see org.apache.wicket.markup.IMarkupResourceStreamProvider#getMarkupResourceStream(org.apache.wicket.MarkupContainer,\n\t *      java.lang.Class)\n\t */\n\tpublic final IResourceStream getMarkupResourceStream(MarkupContainer< ? > container,\n\t\t\tClass< ? > containerClass)\n\t{\n\t\tReader reader = getTemplateReader();\n\t\tif (reader == null)\n\t\t{\n\t\t\tthrow new WicketRuntimeException(\"could not find velocity template for panel: \" + this);\n\t\t}\n\n\t\t// evaluate the template and return a new StringResourceStream\n\t\tStringBuffer sb = new StringBuffer();\n\t\tsb.append(\"<wicket:panel>\");\n\t\tsb.append(evaluateVelocityTemplate(reader));\n\t\tsb.append(\"<\/wicket:panel>\");\n\t\treturn new StringResourceStream(sb.toString());\n\t}","commit_id":"96859687c9aab9c895ff0dbd9e0de45a0ee8b5b4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Construct.\n\t * \n\t * @param id\n\t *            Component id\n\t * @param templateResource\n\t *            The velocity template as a string resource\n\t * @param model\n\t *            Model with variables that can be substituted by Velocity. Must return a\n\t *            {@link Map}.\n\t */\n\tpublic VelocityPanel(final String id, final IModel/* <Map> */model)\n\t{\n\t\tsuper(id, model);\n\t}","id":33650,"modified_method":"/**\n\t * Construct.\n\t * \n\t * @param id\n\t *            Component id\n\t * @param templateResource\n\t *            The velocity template as a string resource\n\t * @param model\n\t *            Model with variables that can be substituted by Velocity.\n\t */\n\tpublic VelocityPanel(final String id, final IModel<Map> model)\n\t{\n\t\tsuper(id, model);\n\t}","commit_id":"96859687c9aab9c895ff0dbd9e0de45a0ee8b5b4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @param id\n\t *            Component id\n\t * @param choicesModel\n\t *            Model representing collection of all available choices\n\t * @param choiceRenderer\n\t *            Render used to render choices. This must use unique IDs for the objects, not the\n\t *            index.\n\t * @param rows\n\t *            Number of choices to be visible on the screen with out scrolling\n\t * @param allowOrder\n\t *            Allow user to move selections up and down\n\t */\n\tpublic Palette(String id, IModel choicesModel, IChoiceRenderer choiceRenderer, int rows,\n\t\tboolean allowOrder)\n\t{\n\t\tthis(id, null, choicesModel, choiceRenderer, rows, allowOrder);\n\t}","id":33651,"modified_method":"/**\n\t * @param id\n\t *            Component id\n\t * @param model\n\t *            Model representing collection of user's selections\n\t * @param choicesModel\n\t *            Model representing collection of all available choices\n\t * @param choiceRenderer\n\t *            Render used to render choices. This must use unique IDs for the objects, not the\n\t *            index.\n\t * @param rows\n\t *            Number of choices to be visible on the screen with out scrolling\n\t * @param allowOrder\n\t *            Allow user to move selections up and down\n\t */\n\tpublic Palette(String id, IModel<Collection<T>> model,\n\t\tIModel<Collection< ? extends T>> choicesModel, IChoiceRenderer<T> choiceRenderer, int rows,\n\t\tboolean allowOrder)\n\t{\n\t\tsuper(id, model);\n\n\t\tthis.choicesModel = choicesModel;\n\t\tthis.choiceRenderer = choiceRenderer;\n\t\tthis.rows = rows;\n\t\tthis.allowOrder = allowOrder;\n\t}","commit_id":"04b68e914813a11546e9fe8568de19c26e0179fe","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @return collection representing selected items\n\t */\n\tpublic Collection getModelCollection()\n\t{\n\t\treturn (Collection)getModelObject();\n\t}","id":33652,"modified_method":"/**\n\t * @return collection representing selected items\n\t */\n\tpublic Collection getModelCollection()\n\t{\n\t\treturn getModelObject();\n\t}","commit_id":"04b68e914813a11546e9fe8568de19c26e0179fe","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * factory method for the remove component\n\t * \n\t * @return remove component\n\t */\n\tprotected Component newRemoveComponent()\n\t{\n\t\treturn new PaletteButton(\"removeButton\")\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tprotected void onComponentTag(ComponentTag tag)\n\t\t\t{\n\t\t\t\tsuper.onComponentTag(tag);\n\t\t\t\ttag.getAttributes().put(\"onclick\", Palette.this.getRemoveOnClickJS());\n\t\t\t}\n\t\t}.add(new Image(\"image\", REMOVE_IMAGE));\n\t}","id":33653,"modified_method":"/**\n\t * factory method for the remove component\n\t * \n\t * @return remove component\n\t */\n\tprotected Component newRemoveComponent()\n\t{\n\t\treturn new PaletteButton(\"removeButton\")\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tprotected void onComponentTag(ComponentTag tag)\n\t\t\t{\n\t\t\t\tsuper.onComponentTag(tag);\n\t\t\t\ttag.getAttributes().put(\"onclick\", Palette.this.getRemoveOnClickJS());\n\t\t\t}\n\t\t}.add(new Image(\"image\", REMOVE_IMAGE));\n\t}","commit_id":"04b68e914813a11546e9fe8568de19c26e0179fe","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @return collection representing all available items\n\t */\n\tpublic Collection getChoices()\n\t{\n\t\treturn (Collection)choicesModel.getObject();\n\t}","id":33654,"modified_method":"/**\n\t * @return collection representing all available items\n\t */\n\tpublic Collection getChoices()\n\t{\n\t\treturn choicesModel.getObject();\n\t}","commit_id":"04b68e914813a11546e9fe8568de19c26e0179fe","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * factory method for the selected items component\n\t * \n\t * @return selected items component\n\t */\n\tprotected Component newSelectionComponent()\n\t{\n\t\treturn new Selection(\"selection\", this)\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tprotected Map getAdditionalAttributes(Object choice)\n\t\t\t{\n\t\t\t\treturn Palette.this.getAdditionalAttributesForSelection(choice);\n\t\t\t}\n\t\t};\n\t}","id":33655,"modified_method":"/**\n\t * factory method for the selected items component\n\t * \n\t * @return selected items component\n\t */\n\tprotected Component newSelectionComponent()\n\t{\n\t\treturn new Selection(\"selection\", this)\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tprotected Map getAdditionalAttributes(Object choice)\n\t\t\t{\n\t\t\t\treturn Palette.this.getAdditionalAttributesForSelection(choice);\n\t\t\t}\n\t\t};\n\t}","commit_id":"04b68e914813a11546e9fe8568de19c26e0179fe","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @param id\n\t *            Component id\n\t * @param model\n\t *            Model representing collection of user's selections\n\t * @param choicesModel\n\t *            Model representing collection of all available choices\n\t * @param choiceRenderer\n\t *            Render used to render choices. This must use unique IDs for the objects, not the\n\t *            index.\n\t * @param rows\n\t *            Number of choices to be visible on the screen with out scrolling\n\t * @param allowOrder\n\t *            Allow user to move selections up and down\n\t */\n\tpublic Palette(String id, IModel model, IModel choicesModel, IChoiceRenderer choiceRenderer,\n\t\tint rows, boolean allowOrder)\n\t{\n\t\tsuper(id, model);\n\n\t\tthis.choicesModel = choicesModel;\n\t\tthis.choiceRenderer = choiceRenderer;\n\t\tthis.rows = rows;\n\t\tthis.allowOrder = allowOrder;\n\t}","id":33656,"modified_method":"/**\n\t * @param id\n\t *            Component id\n\t * @param choicesModel\n\t *            Model representing collection of all available choices\n\t * @param choiceRenderer\n\t *            Render used to render choices. This must use unique IDs for the objects, not the\n\t *            index.\n\t * @param rows\n\t *            Number of choices to be visible on the screen with out scrolling\n\t * @param allowOrder\n\t *            Allow user to move selections up and down\n\t */\n\tpublic Palette(String id, IModel<Collection< ? extends T>> choicesModel,\n\t\tIChoiceRenderer<T> choiceRenderer, int rows, boolean allowOrder)\n\t{\n\t\tthis(id, null, choicesModel, choiceRenderer, rows, allowOrder);\n\t}","commit_id":"04b68e914813a11546e9fe8568de19c26e0179fe","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * factory method for the addcomponent\n\t * \n\t * @return add component\n\t */\n\tprotected Component newAddComponent()\n\t{\n\t\treturn new PaletteButton(\"addButton\")\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tprotected void onComponentTag(ComponentTag tag)\n\t\t\t{\n\t\t\t\tsuper.onComponentTag(tag);\n\t\t\t\ttag.getAttributes().put(\"onclick\", Palette.this.getAddOnClickJS());\n\t\t\t}\n\t\t}.add(new Image(\"image\", ADD_IMAGE));\n\t}","id":33657,"modified_method":"/**\n\t * factory method for the addcomponent\n\t * \n\t * @return add component\n\t */\n\tprotected Component newAddComponent()\n\t{\n\t\treturn new PaletteButton(\"addButton\")\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tprotected void onComponentTag(ComponentTag tag)\n\t\t\t{\n\t\t\t\tsuper.onComponentTag(tag);\n\t\t\t\ttag.getAttributes().put(\"onclick\", Palette.this.getAddOnClickJS());\n\t\t\t}\n\t\t}.add(new Image(\"image\", ADD_IMAGE));\n\t}","commit_id":"04b68e914813a11546e9fe8568de19c26e0179fe","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * factory method for the available items component\n\t * \n\t * @return available items component\n\t */\n\tprotected Component newChoicesComponent()\n\t{\n\t\treturn new Choices(\"choices\", this)\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tprotected Map getAdditionalAttributes(Object choice)\n\t\t\t{\n\t\t\t\treturn Palette.this.getAdditionalAttributesForChoices(choice);\n\t\t\t}\n\t\t};\n\t}","id":33658,"modified_method":"/**\n\t * factory method for the available items component\n\t * \n\t * @return available items component\n\t */\n\tprotected Component newChoicesComponent()\n\t{\n\t\treturn new Choices(\"choices\", this)\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tprotected Map getAdditionalAttributes(Object choice)\n\t\t\t{\n\t\t\t\treturn Palette.this.getAdditionalAttributesForChoices(choice);\n\t\t\t}\n\t\t};\n\t}","commit_id":"04b68e914813a11546e9fe8568de19c26e0179fe","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * factory method for the move up component\n\t * \n\t * @return move up component\n\t */\n\tprotected Component newUpComponent()\n\t{\n\t\treturn new PaletteButton(\"moveUpButton\")\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tprotected void onComponentTag(ComponentTag tag)\n\t\t\t{\n\t\t\t\tsuper.onComponentTag(tag);\n\t\t\t\ttag.getAttributes().put(\"onclick\", Palette.this.getUpOnClickJS());\n\t\t\t}\n\t\t}.add(new Image(\"image\", UP_IMAGE));\n\t}","id":33659,"modified_method":"/**\n\t * factory method for the move up component\n\t * \n\t * @return move up component\n\t */\n\tprotected Component newUpComponent()\n\t{\n\t\treturn new PaletteButton(\"moveUpButton\")\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tprotected void onComponentTag(ComponentTag tag)\n\t\t\t{\n\t\t\t\tsuper.onComponentTag(tag);\n\t\t\t\ttag.getAttributes().put(\"onclick\", Palette.this.getUpOnClickJS());\n\t\t\t}\n\t\t}.add(new Image(\"image\", UP_IMAGE));\n\t}","commit_id":"04b68e914813a11546e9fe8568de19c26e0179fe","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * The model object is assumed to be a Collection, and it is modified in-place. Then\n\t * {@link Model#setObject(Object)} is called with the same instance: it allows the Model to be\n\t * notified of changes even when {@link Model#getObject()} returns a different\n\t * {@link Collection} at every invocation.\n\t * \n\t * @see FormComponent#updateModel()\n\t */\n\tprotected final void updateModel()\n\t{\n\t\t// prepare model\n\t\tCollection model = (Collection)getModelObject();\n\t\tmodel.clear();\n\n\t\t// update model\n\t\tIterator it = getRecorderComponent().getSelectedChoices();\n\n\t\twhile (it.hasNext())\n\t\t{\n\t\t\tfinal Object selectedChoice = it.next();\n\t\t\tmodel.add(selectedChoice);\n\t\t}\n\n\t\tgetModel().setObject(model);\n\t}","id":33660,"modified_method":"/**\n\t * The model object is assumed to be a Collection, and it is modified in-place. Then\n\t * {@link Model#setObject(Object)} is called with the same instance: it allows the Model to be\n\t * notified of changes even when {@link Model#getObject()} returns a different\n\t * {@link Collection} at every invocation.\n\t * \n\t * @see FormComponent#updateModel()\n\t */\n\tprotected final void updateModel()\n\t{\n\t\t// prepare model\n\t\tCollection<T> model = getModelObject();\n\t\tmodel.clear();\n\n\t\t// update model\n\t\tIterator<T> it = getRecorderComponent().getSelectedChoices();\n\n\t\twhile (it.hasNext())\n\t\t{\n\t\t\tfinal T selectedChoice = it.next();\n\t\t\tmodel.add(selectedChoice);\n\t\t}\n\n\t\tgetModel().setObject(model);\n\t}","commit_id":"04b68e914813a11546e9fe8568de19c26e0179fe","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * factory method for the move down component\n\t * \n\t * @return move down component\n\t */\n\tprotected Component newDownComponent()\n\t{\n\t\treturn new PaletteButton(\"moveDownButton\")\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tprotected void onComponentTag(ComponentTag tag)\n\t\t\t{\n\t\t\t\tsuper.onComponentTag(tag);\n\t\t\t\ttag.getAttributes().put(\"onclick\", Palette.this.getDownOnClickJS());\n\t\t\t}\n\t\t}.add(new Image(\"image\", DOWN_IMAGE));\n\t}","id":33661,"modified_method":"/**\n\t * factory method for the move down component\n\t * \n\t * @return move down component\n\t */\n\tprotected Component newDownComponent()\n\t{\n\t\treturn new PaletteButton(\"moveDownButton\")\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tprotected void onComponentTag(ComponentTag tag)\n\t\t\t{\n\t\t\t\tsuper.onComponentTag(tag);\n\t\t\t\ttag.getAttributes().put(\"onclick\", Palette.this.getDownOnClickJS());\n\t\t\t}\n\t\t}.add(new Image(\"image\", DOWN_IMAGE));\n\t}","commit_id":"04b68e914813a11546e9fe8568de19c26e0179fe","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * factory method to create the tracker component\n\t * \n\t * @return tracker component\n\t */\n\tprotected Recorder newRecorderComponent()\n\t{\n\t\t// create component that will keep track of selections\n\t\treturn new Recorder(\"recorder\", this)\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void updateModel()\n\t\t\t{\n\t\t\t\tsuper.updateModel();\n\t\t\t\tPalette.this.updateModel();\n\t\t\t}\n\t\t};\n\t}","id":33662,"modified_method":"/**\n\t * factory method to create the tracker component\n\t * \n\t * @return tracker component\n\t */\n\tprotected Recorder newRecorderComponent()\n\t{\n\t\t// create component that will keep track of selections\n\t\treturn new Recorder(\"recorder\", this)\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic void updateModel()\n\t\t\t{\n\t\t\t\tsuper.updateModel();\n\t\t\t\tPalette.this.updateModel();\n\t\t\t}\n\t\t};\n\t}","commit_id":"04b68e914813a11546e9fe8568de19c26e0179fe","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.extensions.markup.html.repeater.data.table.IColumn#getHeader(MarkupContainer, java.lang.String)\n\t */\n\tpublic Component<String> getHeader(MarkupContainer parent, String componentId)\n\t{\n\t\treturn (Component) new Label(parent, componentId, getDisplayModel());\n\t}","id":33663,"modified_method":"/**\n\t * @see wicket.extensions.markup.html.repeater.data.table.IColumn#getHeader(MarkupContainer, java.lang.String)\n\t */\n\tpublic Component<String> getHeader(MarkupContainer parent, String componentId)\n\t{\n\t\treturn new Label(parent, componentId, getDisplayModel());\n\t}","commit_id":"a578246ebc86092a7c2aacbe16c6436c99092cc3","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor\n\t * \n\t * @param parent\n\t *            The parent of this component The parent of this component.\n\t * @param id\n\t *            component id\n\t * @param columns\n\t *            list of columns\n\t * @param dataProvider\n\t *            data provider\n\t * @param rowsPerPage\n\t *            number of rows per page\n\t */\n\tpublic DefaultDataTable(MarkupContainer parent, final String id, final List<IColumn<T>> columns,\n\t\t\tSortableDataProvider<T> dataProvider, int rowsPerPage)\n\t{\n\t\tthis(parent, id, (IColumn<T>[])columns.toArray(new IColumn[columns.size()]), dataProvider,\n\t\t\t\trowsPerPage);\n\t}","id":33664,"modified_method":"/**\n\t * Constructor\n\t * \n\t * @param parent\n\t *            The parent of this component The parent of this component.\n\t * @param id\n\t *            component id\n\t * @param columns\n\t *            list of columns\n\t * @param dataProvider\n\t *            data provider\n\t * @param rowsPerPage\n\t *            number of rows per page\n\t */\n\tpublic DefaultDataTable(MarkupContainer parent, final String id, final List<IColumn<T>> columns,\n\t\t\tSortableDataProvider<T> dataProvider, int rowsPerPage)\n\t{\n\t\tthis(parent, id, columns.toArray(new IColumn[columns.size()]), dataProvider,\n\t\t\t\trowsPerPage);\n\t}","commit_id":"a578246ebc86092a7c2aacbe16c6436c99092cc3","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor\n\t * \n\t * @param parent\n\t *            parent component\n\t * @param id\n\t *            component id\n\t * \n\t * @param table\n\t *            data table this toolbar will be attached to\n\t * @param stateLocator\n\t *            locator for the ISortState implementation used by sortable\n\t *            headers\n\t */\n\tpublic HeadersToolbar(MarkupContainer parent, final String id, final DataTable table,\n\t\t\tfinal ISortStateLocator stateLocator)\n\t{\n\t\tsuper(parent, id, table);\n\n\t\tnew RefreshingView(this, \"headers\")\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tprotected Iterator getItemModels()\n\t\t\t{\n\t\t\t\treturn new ArrayIteratorAdapter(table.getColumns())\n\t\t\t\t{\n\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected IModel model(Object object, int index)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new Model((IColumn)object);\n\t\t\t\t\t}\n\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void populateItem(Item item)\n\t\t\t{\n\t\t\t\titem.setRenderBodyOnly(true);\n\n\n\t\t\t\tIColumn column = (IColumn)item.getModelObject();\n\t\t\t\tWebMarkupContainer header = null;\n\t\t\t\tif (column.isSortable())\n\t\t\t\t{\n\t\t\t\t\theader = newSortableHeader(item, \"header\", column.getSortProperty(),\n\t\t\t\t\t\t\tstateLocator);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\theader = new WebMarkupContainer(item, \"header\");\n\t\t\t\t}\n\n\t\t\t\t//TODO General: ivaynberg: rename ICOlumn.getHeader() to newHeader()\n\t\t\t\tcolumn.getHeader(header, \"label\");\n\n\t\t\t}\n\n\t\t};\n\n\t}","id":33665,"modified_method":"/**\n\t * Constructor\n\t * \n\t * @param parent\n\t *            parent component\n\t * @param id\n\t *            component id\n\t * \n\t * @param table\n\t *            data table this toolbar will be attached to\n\t * @param stateLocator\n\t *            locator for the ISortState implementation used by sortable\n\t *            headers\n\t */\n\tpublic HeadersToolbar(MarkupContainer parent, final String id, final DataTable table,\n\t\t\tfinal ISortStateLocator stateLocator)\n\t{\n\t\tsuper(parent, id, table);\n\n\t\tnew RefreshingView(this, \"headers\")\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tprotected Iterator getItemModels()\n\t\t\t{\n\t\t\t\treturn new ArrayIteratorAdapter(table.getColumns())\n\t\t\t\t{\n\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected IModel model(Object object, int index)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new Model(object);\n\t\t\t\t\t}\n\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void populateItem(Item item)\n\t\t\t{\n\t\t\t\titem.setRenderBodyOnly(true);\n\n\n\t\t\t\tIColumn column = (IColumn)item.getModelObject();\n\t\t\t\tWebMarkupContainer header = null;\n\t\t\t\tif (column.isSortable())\n\t\t\t\t{\n\t\t\t\t\theader = newSortableHeader(item, \"header\", column.getSortProperty(),\n\t\t\t\t\t\t\tstateLocator);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\theader = new WebMarkupContainer(item, \"header\");\n\t\t\t\t}\n\n\t\t\t\t//TODO General: ivaynberg: rename ICOlumn.getHeader() to newHeader()\n\t\t\t\tcolumn.getHeader(header, \"label\");\n\n\t\t\t}\n\n\t\t};\n\n\t}","commit_id":"a578246ebc86092a7c2aacbe16c6436c99092cc3","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @return index of the selected tab\n\t */\n\tpublic final int getSelectedTab()\n\t{\n\t\treturn ((Integer)getModelObject()).intValue();\n\t}","id":33666,"modified_method":"/**\n\t * @return index of the selected tab\n\t */\n\tpublic final int getSelectedTab()\n\t{\n\t\treturn (getModelObject()).intValue();\n\t}","commit_id":"a578246ebc86092a7c2aacbe16c6436c99092cc3","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * sets the selected tab\n\t * \n\t * @param index\n\t *            index of the tab to select\n\t * \n\t */\n\tpublic final void setSelectedTab(int index)\n\t{\n\t\tif (index < 0 || index >= tabs.size())\n\t\t{\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t}\n\n\t\tsetModelObject(new Integer(index));\n\n\t\tITab tab = (ITab)tabs.get(index);\n\n\t\tPanel panel = tab.getPanel(this, TAB_PANEL_ID);\n\n\t\tif (panel == null)\n\t\t{\n\t\t\tthrow new WicketRuntimeException(\"ITab.getPanel() returned null. TabbedPanel [\"\n\t\t\t\t\t+ getPath() + \"] ITab index [\" + index + \"]\");\n\n\t\t}\n\n\t\tif (!panel.getId().equals(TAB_PANEL_ID))\n\t\t{\n\t\t\tthrow new WicketRuntimeException(\n\t\t\t\t\t\"ITab.getPanel() returned a panel with invalid id [\"\n\t\t\t\t\t\t\t+ panel.getId()\n\t\t\t\t\t\t\t+ \"]. You must always return a panel with id equal to the provided panelId parameter. TabbedPanel [\"\n\t\t\t\t\t\t\t+ getPath() + \"] ITab index [\" + index + \"]\");\n\t\t}\n\n\t\tpanel.reAttach();\n\t}","id":33667,"modified_method":"/**\n\t * sets the selected tab\n\t * \n\t * @param index\n\t *            index of the tab to select\n\t * \n\t */\n\tpublic final void setSelectedTab(int index)\n\t{\n\t\tif (index < 0 || index >= tabs.size())\n\t\t{\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t}\n\n\t\tsetModelObject(new Integer(index));\n\n\t\tITab tab = tabs.get(index);\n\n\t\tPanel panel = tab.getPanel(this, TAB_PANEL_ID);\n\n\t\tif (panel == null)\n\t\t{\n\t\t\tthrow new WicketRuntimeException(\"ITab.getPanel() returned null. TabbedPanel [\"\n\t\t\t\t\t+ getPath() + \"] ITab index [\" + index + \"]\");\n\n\t\t}\n\n\t\tif (!panel.getId().equals(TAB_PANEL_ID))\n\t\t{\n\t\t\tthrow new WicketRuntimeException(\n\t\t\t\t\t\"ITab.getPanel() returned a panel with invalid id [\"\n\t\t\t\t\t\t\t+ panel.getId()\n\t\t\t\t\t\t\t+ \"]. You must always return a panel with id equal to the provided panelId parameter. TabbedPanel [\"\n\t\t\t\t\t\t\t+ getPath() + \"] ITab index [\" + index + \"]\");\n\t\t}\n\n\t\tpanel.reAttach();\n\t}","commit_id":"a578246ebc86092a7c2aacbe16c6436c99092cc3","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor\n\t * \n\t * @param parent\n\t *            The parent of this component The parent of this component.\n\t * @param id\n\t *            component id\n\t * @param tabs\n\t *            list of ITab objects used to represent tabs\n\t */\n\tpublic TabbedPanel(MarkupContainer parent, final String id, List<? extends ITab> tabs)\n\t{\n\t\tsuper(parent, id, new Model<Integer>(new Integer(-1)));\n\n\t\tif (tabs == null)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"argument [tabs] cannot be null\");\n\t\t}\n\n\t\tif (tabs.size() < 1)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"argument [tabs] must contain a list of at least one tab\");\n\t\t}\n\n\t\tthis.tabs = tabs;\n\n\t\tfinal IModel<Integer> tabCount = new AbstractReadOnlyModel<Integer>()\n\t\t{\n\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Integer getObject()\n\t\t\t{\n\t\t\t\treturn TabbedPanel.this.tabs.size();\n\t\t\t}\n\t\t};\n\n\t\t// add the loop used to generate tab names\n\t\tnew Loop(this, \"tabs\", tabCount)\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tprotected void populateItem(LoopItem item)\n\t\t\t{\n\t\t\t\tfinal int index = item.getIteration();\n\t\t\t\tfinal ITab tab = ((ITab)TabbedPanel.this.tabs.get(index));\n\t\t\t\tfinal int selected = getSelectedTab();\n\n\t\t\t\tfinal WebMarkupContainer titleLink = newLink(item, \"link\", index);\n\n\t\t\t\tnew Label(titleLink, \"title\", tab.getTitle());\n\n\t\t\t\titem.add(new SimpleAttributeModifier(\"class\", \"selected\")\n\t\t\t\t{\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean isEnabled()\n\t\t\t\t\t{\n\t\t\t\t\t\treturn index == selected;\n\t\t\t\t\t}\n\n\t\t\t\t});\n\t\t\t\tif (item.getIteration() == getIterations() - 1)\n\t\t\t\t{\n\t\t\t\t\titem.add(new AttributeAppender(\"class\", true, new Model<String>(\"last\"), \" \"));\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\t// select the first tab by default\n\t\tsetSelectedTab(0);\n\n\t}","id":33668,"modified_method":"/**\n\t * Constructor\n\t * \n\t * @param parent\n\t *            The parent of this component The parent of this component.\n\t * @param id\n\t *            component id\n\t * @param tabs\n\t *            list of ITab objects used to represent tabs\n\t */\n\tpublic TabbedPanel(MarkupContainer parent, final String id, List<? extends ITab> tabs)\n\t{\n\t\tsuper(parent, id, new Model<Integer>(new Integer(-1)));\n\n\t\tif (tabs == null)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"argument [tabs] cannot be null\");\n\t\t}\n\n\t\tif (tabs.size() < 1)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"argument [tabs] must contain a list of at least one tab\");\n\t\t}\n\n\t\tthis.tabs = tabs;\n\n\t\tfinal IModel<Integer> tabCount = new AbstractReadOnlyModel<Integer>()\n\t\t{\n\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Integer getObject()\n\t\t\t{\n\t\t\t\treturn TabbedPanel.this.tabs.size();\n\t\t\t}\n\t\t};\n\n\t\t// add the loop used to generate tab names\n\t\tnew Loop(this, \"tabs\", tabCount)\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tprotected void populateItem(LoopItem item)\n\t\t\t{\n\t\t\t\tfinal int index = item.getIteration();\n\t\t\t\tfinal ITab tab = (TabbedPanel.this.tabs.get(index));\n\t\t\t\tfinal int selected = getSelectedTab();\n\n\t\t\t\tfinal WebMarkupContainer titleLink = newLink(item, \"link\", index);\n\n\t\t\t\tnew Label(titleLink, \"title\", tab.getTitle());\n\n\t\t\t\titem.add(new SimpleAttributeModifier(\"class\", \"selected\")\n\t\t\t\t{\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean isEnabled()\n\t\t\t\t\t{\n\t\t\t\t\t\treturn index == selected;\n\t\t\t\t\t}\n\n\t\t\t\t});\n\t\t\t\tif (item.getIteration() == getIterations() - 1)\n\t\t\t\t{\n\t\t\t\t\titem.add(new AttributeAppender(\"class\", true, new Model<String>(\"last\"), \" \"));\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\t// select the first tab by default\n\t\tsetSelectedTab(0);\n\n\t}","commit_id":"a578246ebc86092a7c2aacbe16c6436c99092cc3","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * A constructor which uses the index and the list provided to create a\n\t * ListItem. This constructor is the default one.\n\t * \n\t * @param index\n\t *            The index of the item\n\t * @param model\n\t *            The model object of the item\n\t */\n\tpublic ListItem(final int index, final IModel model)\n\t{\n\t\tsuper(Integer.toString(index), model);\n\t\tthis.index = index;\n\t}","id":33669,"modified_method":"/**\n\t * A constructor which uses the index and the list provided to create a\n\t * ListItem. This constructor is the default one.\n\t * \n\t * @param index\n\t *            The index of the item\n\t * @param model\n\t *            The model object of the item\n\t */\n\tpublic ListItem(final int index, final IModel<V> model)\n\t{\n\t\tsuper(Integer.toString(index), model);\n\t\tthis.index = index;\n\t}","commit_id":"eaead9e10d5b72ff9388d84aaace11674a56ff14","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Construct\n\t * \n\t * @param listView\n\t *            The ListView\n\t * @param index\n\t *            The index of this model\n\t */\n\tpublic ListItemModel(final ListView listView, final int index)\n\t{\n\t\tthis.listView = listView;\n\t\tthis.index = index;\n\t\tattach();\n\t}","id":33670,"modified_method":"/**\n\t * Construct\n\t * \n\t * @param listView\n\t *            The ListView\n\t * @param index\n\t *            The index of this model\n\t */\n\tpublic ListItemModel(final ListView<V> listView, final int index)\n\t{\n\t\tthis.listView = listView;\n\t\tthis.index = index;\n\t\tattach();\n\t}","commit_id":"eaead9e10d5b72ff9388d84aaace11674a56ff14","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.model.AbstractDetachableModel#onGetObject(wicket.Component)\n\t */\n\tprotected Object onGetObject(final Component component)\n\t{\n\t\treturn object;\n\t}","id":33671,"modified_method":"/**\n\t * @see wicket.model.AbstractDetachableModel#onGetObject(wicket.Component)\n\t */\n\t@Override\n\tprotected V onGetObject(final Component component)\n\t{\n\t\treturn object;\n\t}","commit_id":"eaead9e10d5b72ff9388d84aaace11674a56ff14","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.model.AbstractDetachableModel#onAttach()\n\t */\n\tprotected void onAttach()\n\t{\n\t\t// Re-attach the model object based on index and ListView model object\n\t\tthis.object = ((List)listView.getModelObject()).get(index);\n\t}","id":33672,"modified_method":"/**\n\t * @see wicket.model.AbstractDetachableModel#onAttach()\n\t */\n\t@Override\n\tprotected void onAttach()\n\t{\n\t\t// Re-attach the model object based on index and ListView model object\n\t\tthis.object = listView.getModelObject().get(index);\n\t}","commit_id":"eaead9e10d5b72ff9388d84aaace11674a56ff14","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.model.AbstractDetachableModel#onSetObject(wicket.Component,\n\t *      java.lang.Object)\n\t */\n\tprotected void onSetObject(final Component component, final Object object)\n\t{\n\t\tthis.object = object;\n\t}","id":33673,"modified_method":"/**\n\t * @see wicket.model.AbstractDetachableModel#onSetObject(wicket.Component,\n\t *      java.lang.Object)\n\t */\n\t@Override\n\tprotected void onSetObject(final Component component, final V object)\n\t{\n\t\tthis.object = object;\n\t}","commit_id":"eaead9e10d5b72ff9388d84aaace11674a56ff14","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Sets the model as the provided list and removes all children, so that the\n\t * next render will be using the contents of the model.\n\t * \n\t * @param list\n\t *            The list for the new model. The list must implement\n\t *            {@link Serializable}.\n\t * @return This for chaining\n\t */\n\tpublic Component setList(List list)\n\t{\n\t\treturn setModel(new Model((Serializable)list));\n\t}","id":33674,"modified_method":"/**\n\t * Sets the model as the provided list and removes all children, so that the\n\t * next render will be using the contents of the model.\n\t * \n\t * @param list\n\t *            The list for the new model. The list must implement\n\t *            {@link Serializable}.\n\t * @return This for chaining\n\t */\n\tpublic Component setList(List<V> list)\n\t{\n\t\treturn setModel(new Model((Serializable)list));\n\t}","commit_id":"eaead9e10d5b72ff9388d84aaace11674a56ff14","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Gets the list of items in the listView. This method is final because it\n\t * is not designed to be overridden. If it were allowed to be overridden,\n\t * the values returned by getModelObject() and getList() might not coincide.\n\t * \n\t * @return The list of items in this list view.\n\t */\n\tpublic final List<Object> getList()\n\t{\n\t\tfinal List<Object> list = (List<Object>)getModelObject();\n\t\tif (list == null)\n\t\t{\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\treturn list;\n\t}","id":33675,"modified_method":"/**\n\t * Gets the list of items in the listView. This method is final because it\n\t * is not designed to be overridden. If it were allowed to be overridden,\n\t * the values returned by getModelObject() and getList() might not coincide.\n\t * \n\t * @return The list of items in this list view.\n\t */\n\tpublic final List<V> getList()\n\t{\n\t\tfinal List<V> list = getModelObject();\n\t\tif (list == null)\n\t\t{\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\treturn list;\n\t}","commit_id":"eaead9e10d5b72ff9388d84aaace11674a56ff14","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Sets the model and removes all current children, so that the next render\n\t * will be using the contents of the model.\n\t * \n\t * @param model\n\t *            The new model\n\t * @return This for chaining\n\t * \n\t * @see wicket.MarkupContainer#setModel(wicket.model.IModel)\n\t */\n\tpublic Component setModel(IModel model)\n\t{\n\t\t// remove all children; this has no effect when the list\n\t\t// didn't render before, as in that case the list view\n\t\t// does not yet have any children\n\t\tremoveAll();\n\t\treturn super.setModel(model);\n\t}","id":33676,"modified_method":"/**\n\t * Sets the model and removes all current children, so that the next render\n\t * will be using the contents of the model.\n\t * \n\t * @param model\n\t *            The new model\n\t * @return This for chaining\n\t * \n\t * @see wicket.MarkupContainer#setModel(wicket.model.IModel)\n\t */\n\t@Override\n\tpublic Component setModel(IModel<List<V>> model)\n\t{\n\t\t// remove all children; this has no effect when the list\n\t\t// didn't render before, as in that case the list view\n\t\t// does not yet have any children\n\t\tremoveAll();\n\t\treturn super.setModel(model);\n\t}","commit_id":"eaead9e10d5b72ff9388d84aaace11674a56ff14","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Returns a link that will move the given item \"down\" (towards the end) in\n\t * the listView.\n\t * \n\t * @param id\n\t *            Name of move-down link component to create\n\t * @param item\n\t * @return The link component\n\t */\n\tpublic final Link moveDownLink(final String id, final ListItem item)\n\t{\n\t\treturn new Link(id)\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t/**\n\t\t\t * @see wicket.Component#onAttach()\n\t\t\t */\n\t\t\tprotected void onAttach()\n\t\t\t{\n\t\t\t\tsetAutoEnable(false);\n\t\t\t\tif (getList().indexOf(item.getModelObject()) == (getList().size() - 1))\n\t\t\t\t{\n\t\t\t\t\tsetEnabled(false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * @see wicket.markup.html.link.Link#onClick()\n\t\t\t */\n\t\t\tpublic void onClick()\n\t\t\t{\n\t\t\t\tfinal int index = getList().indexOf(item.getModelObject());\n\t\t\t\tif (index != -1)\n\t\t\t\t{\n\t\t\t\t\taddStateChange(new Change()\n\t\t\t\t\t{\n\t\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t\tfinal int oldIndex = index;\n\n\t\t\t\t\t\tpublic void undo()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tCollections.swap(getList(), oldIndex + 1, oldIndex);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t});\n\n\t\t\t\t\t// Swap list items and invalidate listView\n\t\t\t\t\tCollections.swap(getList(), index, index + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}","id":33677,"modified_method":"/**\n\t * Returns a link that will move the given item \"down\" (towards the end) in\n\t * the listView.\n\t * \n\t * @param id\n\t *            Name of move-down link component to create\n\t * @param item\n\t * @return The link component\n\t */\n\tpublic final Link moveDownLink(final String id, final ListItem<V> item)\n\t{\n\t\treturn new Link(id)\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t/**\n\t\t\t * @see wicket.Component#onAttach()\n\t\t\t */\n\t\t\tprotected void onAttach()\n\t\t\t{\n\t\t\t\tsetAutoEnable(false);\n\t\t\t\tif (getList().indexOf(item.getModelObject()) == (getList().size() - 1))\n\t\t\t\t{\n\t\t\t\t\tsetEnabled(false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * @see wicket.markup.html.link.Link#onClick()\n\t\t\t */\n\t\t\tpublic void onClick()\n\t\t\t{\n\t\t\t\tfinal int index = getList().indexOf(item.getModelObject());\n\t\t\t\tif (index != -1)\n\t\t\t\t{\n\t\t\t\t\taddStateChange(new Change()\n\t\t\t\t\t{\n\t\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t\tfinal int oldIndex = index;\n\n\t\t\t\t\t\tpublic void undo()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tCollections.swap(getList(), oldIndex + 1, oldIndex);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t});\n\n\t\t\t\t\t// Swap list items and invalidate listView\n\t\t\t\t\tCollections.swap(getList(), index, index + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}","commit_id":"eaead9e10d5b72ff9388d84aaace11674a56ff14","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Returns a link that will remove this ListItem from the ListView that\n\t * holds it.\n\t * \n\t * @param id\n\t *            Name of remove link component to create\n\t * @param item\n\t * @return The link component\n\t */\n\tpublic final Link removeLink(final String id, final ListItem item)\n\t{\n\t\treturn new Link(id)\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t/**\n\t\t\t * @see wicket.markup.html.link.Link#onClick()\n\t\t\t */\n\t\t\tpublic void onClick()\n\t\t\t{\n\t\t\t\taddStateChange(new Change()\n\t\t\t\t{\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\tfinal Object removedObject = item.getModelObject();\n\t\t\t\t\tfinal int oldIndex = getList().indexOf(item.getModelObject());\n\n\t\t\t\t\tpublic void undo()\n\t\t\t\t\t{\n\t\t\t\t\t\tgetList().add(oldIndex, removedObject);\n\t\t\t\t\t}\n\n\t\t\t\t});\n\n\t\t\t\titem.modelChanging();\n\n\t\t\t\t// Remove item and invalidate listView\n\t\t\t\tgetList().remove(item.getModelObject());\n\n\t\t\t\tListView.this.modelChanged();\n\t\t\t}\n\t\t};\n\t}","id":33678,"modified_method":"/**\n\t * Returns a link that will remove this ListItem from the ListView that\n\t * holds it.\n\t * \n\t * @param id\n\t *            Name of remove link component to create\n\t * @param item\n\t * @return The link component\n\t */\n\tpublic final Link removeLink(final String id, final ListItem<V> item)\n\t{\n\t\treturn new Link(id)\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t/**\n\t\t\t * @see wicket.markup.html.link.Link#onClick()\n\t\t\t */\n\t\t\tpublic void onClick()\n\t\t\t{\n\t\t\t\taddStateChange(new Change()\n\t\t\t\t{\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\tfinal V removedObject = item.getModelObject();\n\t\t\t\t\tfinal int oldIndex = getList().indexOf(item.getModelObject());\n\n\t\t\t\t\tpublic void undo()\n\t\t\t\t\t{\n\t\t\t\t\t\tgetList().add(oldIndex, removedObject);\n\t\t\t\t\t}\n\n\t\t\t\t});\n\n\t\t\t\titem.modelChanging();\n\n\t\t\t\t// Remove item and invalidate listView\n\t\t\t\tgetList().remove(item.getModelObject());\n\n\t\t\t\tListView.this.modelChanged();\n\t\t\t}\n\t\t};\n\t}","commit_id":"eaead9e10d5b72ff9388d84aaace11674a56ff14","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Subclasses may provide their own ListItemModel with extended\n\t * functionality. The default ListItemModel works fine with mostly static\n\t * lists where index remains valid. In cases where the underlying list\n\t * changes a lot (many users using the application), it may not longer be\n\t * appropriate. In that case your own ListItemModel implementation should\n\t * use an id (e.g. the database' record id) to identify and load the list\n\t * item model object.\n\t * \n\t * @param listViewModel\n\t *            The ListView's model\n\t * @param index\n\t *            The list item index\n\t * @return The ListItemModel created\n\t */\n\tprotected IModel getListItemModel(final IModel listViewModel, final int index)\n\t{\n\t\treturn new ListItemModel(this, index);\n\t}","id":33679,"modified_method":"/**\n\t * Subclasses may provide their own ListItemModel with extended\n\t * functionality. The default ListItemModel works fine with mostly static\n\t * lists where index remains valid. In cases where the underlying list\n\t * changes a lot (many users using the application), it may not longer be\n\t * appropriate. In that case your own ListItemModel implementation should\n\t * use an id (e.g. the database' record id) to identify and load the list\n\t * item model object.\n\t * \n\t * @param listViewModel\n\t *            The ListView's model\n\t * @param index\n\t *            The list item index\n\t * @return The ListItemModel created\n\t */\n\tprotected IModel<V> getListItemModel(final IModel<List<V>> listViewModel, final int index)\n\t{\n\t\treturn new ListItemModel<V>(this, index);\n\t}","commit_id":"eaead9e10d5b72ff9388d84aaace11674a56ff14","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.Component#Component(String, IModel)\n\t */\n\tpublic ListView(final String id, final IModel<List> model)\n\t{\n\t\tsuper(id, model);\n\n\t\tif (model == null)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Null models are not allowed. If you have no model, you may prefer a Loop instead\");\n\t\t}\n\n\t\t// A reasonable default for viewSize can not be determined right now,\n\t\t// because list items might be added or removed until ListView\n\t\t// gets rendered.\n\t}","id":33680,"modified_method":"/**\n\t * @see wicket.Component#Component(String, IModel)\n\t */\n\tpublic ListView(final String id, final IModel<List<V>> model)\n\t{\n\t\tsuper(id, model);\n\n\t\tif (model == null)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Null models are not allowed. If you have no model, you may prefer a Loop instead\");\n\t\t}\n\n\t\t// A reasonable default for viewSize can not be determined right now,\n\t\t// because list items might be added or removed until ListView\n\t\t// gets rendered.\n\t}","commit_id":"eaead9e10d5b72ff9388d84aaace11674a56ff14","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Returns a link that will move the given item \"up\" (towards the beginning)\n\t * in the listView.\n\t * \n\t * @param id\n\t *            Name of move-up link component to create\n\t * @param item\n\t * @return The link component\n\t */\n\tpublic final Link moveUpLink(final String id, final ListItem item)\n\t{\n\t\treturn new Link(id)\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t/**\n\t\t\t * @see wicket.Component#onAttach()\n\t\t\t */\n\t\t\tprotected void onAttach()\n\t\t\t{\n\t\t\t\tsetAutoEnable(false);\n\t\t\t\tif (getList().indexOf(item.getModelObject()) == 0)\n\t\t\t\t{\n\t\t\t\t\tsetEnabled(false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * @see wicket.markup.html.link.Link#onClick()\n\t\t\t */\n\t\t\tpublic void onClick()\n\t\t\t{\n\t\t\t\tfinal int index = getList().indexOf(item.getModelObject());\n\t\t\t\tif (index != -1)\n\t\t\t\t{\n\n\t\t\t\t\taddStateChange(new Change()\n\t\t\t\t\t{\n\t\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t\tfinal int oldIndex = index;\n\n\t\t\t\t\t\tpublic void undo()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tCollections.swap(getList(), oldIndex - 1, oldIndex);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t});\n\n\t\t\t\t\t// Swap items and invalidate listView\n\t\t\t\t\tCollections.swap(getList(), index, index - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}","id":33681,"modified_method":"/**\n\t * Returns a link that will move the given item \"up\" (towards the beginning)\n\t * in the listView.\n\t * \n\t * @param id\n\t *            Name of move-up link component to create\n\t * @param item\n\t * @return The link component\n\t */\n\tpublic final Link moveUpLink(final String id, final ListItem<V> item)\n\t{\n\t\treturn new Link(id)\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t/**\n\t\t\t * @see wicket.Component#onAttach()\n\t\t\t */\n\t\t\tprotected void onAttach()\n\t\t\t{\n\t\t\t\tsetAutoEnable(false);\n\t\t\t\tif (getList().indexOf(item.getModelObject()) == 0)\n\t\t\t\t{\n\t\t\t\t\tsetEnabled(false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * @see wicket.markup.html.link.Link#onClick()\n\t\t\t */\n\t\t\tpublic void onClick()\n\t\t\t{\n\t\t\t\tfinal int index = getList().indexOf(item.getModelObject());\n\t\t\t\tif (index != -1)\n\t\t\t\t{\n\n\t\t\t\t\taddStateChange(new Change()\n\t\t\t\t\t{\n\t\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t\tfinal int oldIndex = index;\n\n\t\t\t\t\t\tpublic void undo()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tCollections.swap(getList(), oldIndex - 1, oldIndex);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t});\n\n\t\t\t\t\t// Swap items and invalidate listView\n\t\t\t\t\tCollections.swap(getList(), index, index - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}","commit_id":"eaead9e10d5b72ff9388d84aaace11674a56ff14","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Create a new ListItem for list item at index.\n\t * \n\t * @param index\n\t * @return ListItem\n\t */\n\tprotected ListItem newItem(final int index)\n\t{\n\t\treturn new ListItem(index, getListItemModel(getModel(), index));\n\t}","id":33682,"modified_method":"/**\n\t * Create a new ListItem for list item at index.\n\t * \n\t * @param index\n\t * @return ListItem\n\t */\n\tprotected ListItem<V> newItem(final int index)\n\t{\n\t\treturn new ListItem<V>(index, getListItemModel(getModel(), index));\n\t}","commit_id":"eaead9e10d5b72ff9388d84aaace11674a56ff14","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @param id\n\t *            See Component\n\t * @param list\n\t *            List to cast to Serializable\n\t * @see wicket.Component#Component(String, IModel)\n\t */\n\tpublic ListView(final String id, final List list)\n\t{\n\t\tthis(id, new Model<List>(list));\n\t}","id":33683,"modified_method":"/**\n\t * @param id\n\t *            See Component\n\t * @param list\n\t *            List to cast to Serializable\n\t * @see wicket.Component#Component(String, IModel)\n\t */\n\tpublic ListView(final String id, final List<V> list)\n\t{\n\t\tthis(id, new Model<List<V>>(list));\n\t}","commit_id":"eaead9e10d5b72ff9388d84aaace11674a56ff14","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @return Iterator that iterates through children in the order they were\n\t *         added\n\t */\n\tpublic final Iterator iterator()\n\t{\n\t\treturn new Iterator()\n\t\t{\n\t\t\tint index = 0;\n\n\t\t\tpublic boolean hasNext()\n\t\t\t{\n\t\t\t\treturn index < children_size();\n\t\t\t}\n\n\t\t\tpublic Object next()\n\t\t\t{\n\t\t\t\treturn children_get(index++);\n\t\t\t}\n\n\t\t\tpublic void remove()\n\t\t\t{\n\t\t\t\tremovedComponent(children_remove(--index));\n\t\t\t}\n\t\t};\n\t}","id":33684,"modified_method":"/**\n\t * @return Iterator that iterates through children in the order they were\n\t *         added\n\t */\n\tpublic final Iterator<Component> iterator()\n\t{\n\t\treturn new Iterator<Component>()\n\t\t{\n\t\t\tint index = 0;\n\n\t\t\tpublic boolean hasNext()\n\t\t\t{\n\t\t\t\treturn index < children_size();\n\t\t\t}\n\n\t\t\tpublic Component next()\n\t\t\t{\n\t\t\t\treturn children_get(index++);\n\t\t\t}\n\n\t\t\tpublic void remove()\n\t\t\t{\n\t\t\t\tremovedComponent(children_remove(--index));\n\t\t\t}\n\t\t};\n\t}","commit_id":"eaead9e10d5b72ff9388d84aaace11674a56ff14","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.Component#setModel(wicket.model.IModel)\n\t */\n\tpublic Component setModel(final IModel model)\n\t{\n\t\tfinal IModel previous = getModel();\n\t\tsuper.setModel(model);\n\t\tif (previous instanceof ICompoundModel)\n\t\t{\n\t\t\tvisitChildren(new IVisitor<Component<V>>()\n\t\t\t{\n\n\t\t\t\tpublic Object component(Component<V> component)\n\t\t\t\t{\n\t\t\t\t\tIModel compModel = component.getModel();\n\t\t\t\t\tif (compModel == previous)\n\t\t\t\t\t{\n\t\t\t\t\t\tcomponent.setModel(null);\n\t\t\t\t\t}\n\t\t\t\t\telse if (compModel == model)\n\t\t\t\t\t{\n\t\t\t\t\t\tcomponent.modelChanged();\n\t\t\t\t\t}\n\t\t\t\t\treturn IVisitor.CONTINUE_TRAVERSAL;\n\t\t\t\t}\n\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}","id":33685,"modified_method":"/**\n\t * @see wicket.Component#setModel(wicket.model.IModel)\n\t */\n\t@Override\n\tpublic Component setModel(final IModel<V> model)\n\t{\n\t\tfinal IModel<V> previous = getModel();\n\t\tsuper.setModel(model);\n\t\tif (previous instanceof ICompoundModel)\n\t\t{\n\t\t\tvisitChildren(new IVisitor<Component<V>>()\n\t\t\t{\n\n\t\t\t\tpublic Object component(Component<V> component)\n\t\t\t\t{\n\t\t\t\t\tIModel compModel = component.getModel();\n\t\t\t\t\tif (compModel == previous)\n\t\t\t\t\t{\n\t\t\t\t\t\tcomponent.setModel(null);\n\t\t\t\t\t}\n\t\t\t\t\telse if (compModel == model)\n\t\t\t\t\t{\n\t\t\t\t\t\tcomponent.modelChanged();\n\t\t\t\t\t}\n\t\t\t\t\treturn IVisitor.CONTINUE_TRAVERSAL;\n\t\t\t\t}\n\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}","commit_id":"eaead9e10d5b72ff9388d84aaace11674a56ff14","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor.\n\t * \n\t * @param id\n\t *            the component id.\n\t * @param filter\n\t *            the component for which the messages need to be filtered.\n\t */\n\tpublic ComponentFeedbackPanel(String id, Component filter)\n\t{\n\t\tsuper(id, new ComponentFeedbackMessageFilter(filter));\n\t}","id":33686,"modified_method":"/**\n\t * Constructor.\n\t * \n\t * @param id\n\t * \t\tthe component id.\n\t * @param filter\n\t * \t\tthe component for which the messages need to be filtered.\n\t */\n\tpublic ComponentFeedbackPanel(String id, Component<?> filter)\n\t{\n\t\tsuper(id, new ComponentFeedbackMessageFilter(filter));\n\t}","commit_id":"de3f1002add187c0adeab06c76c95aa1ac684c35","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see PackageResourceReference#PackageResourceReference(Application, Class, String, Locale,\n\t *      String)\n\t */\n\tpublic CompressedPackageResourceReference(Application application, Class scope, String name,\n\t\t\tLocale locale, String style)\n\t{\n\t\tsuper(application, scope, name, locale, style);\n\t}","id":33687,"modified_method":"/**\n\t * @see PackageResourceReference#PackageResourceReference(Application, Class, String, Locale,\n\t * \tString)\n\t */\n\tpublic CompressedPackageResourceReference(Application application, Class<?> scope, String name,\n\t\tLocale locale, String style)\n\t{\n\t\tsuper(application, scope, name, locale, style);\n\t}","commit_id":"de3f1002add187c0adeab06c76c95aa1ac684c35","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see PackageResourceReference#PackageResourceReference(Application, Class, String)\n\t */\n\tpublic CompressedPackageResourceReference(Application application, Class scope, String name)\n\t{\n\t\tsuper(application, scope, name);\n\t}","id":33688,"modified_method":"/**\n\t * @see PackageResourceReference#PackageResourceReference(Application, Class, String)\n\t */\n\tpublic CompressedPackageResourceReference(Application application, Class<?> scope, String name)\n\t{\n\t\tsuper(application, scope, name);\n\t}","commit_id":"de3f1002add187c0adeab06c76c95aa1ac684c35","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see PackageResourceReference#PackageResourceReference(Class, String)\n\t */\n\tpublic CompressedPackageResourceReference(Class scope, String name)\n\t{\n\t\tsuper(scope, name);\n\t}","id":33689,"modified_method":"/**\n\t * @see PackageResourceReference#PackageResourceReference(Class, String)\n\t */\n\tpublic CompressedPackageResourceReference(Class<?> scope, String name)\n\t{\n\t\tsuper(scope, name);\n\t}","commit_id":"de3f1002add187c0adeab06c76c95aa1ac684c35","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see ResourceReference#ResourceReference(Class, String)\n\t */\n\tpublic CompressedResourceReference(Class scope, String name)\n\t{\n\t\tsuper(scope, name);\n\t}","id":33690,"modified_method":"/**\n\t * @see ResourceReference#ResourceReference(Class, String)\n\t */\n\tpublic CompressedResourceReference(Class<?> scope, String name)\n\t{\n\t\tsuper(scope, name);\n\t}","commit_id":"de3f1002add187c0adeab06c76c95aa1ac684c35","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see ResourceReference#ResourceReference(Class scope, String name, Locale locale, String\n\t *      style)\n\t */\n\tpublic CompressedResourceReference(Class scope, String name, Locale locale, String style)\n\t{\n\t\tsuper(scope, name, locale, style);\n\t}","id":33691,"modified_method":"/**\n\t * @see ResourceReference#ResourceReference(Class scope, String name, Locale locale, String\n\t * \tstyle)\n\t */\n\tpublic CompressedResourceReference(Class<?> scope, String name, Locale locale, String style)\n\t{\n\t\tsuper(scope, name, locale, style);\n\t}","commit_id":"de3f1002add187c0adeab06c76c95aa1ac684c35","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Gets the currently collected messages for this panel.\n\t * \n\t * @return the currently collected messages for this panel, possibly empty\n\t */\n\tprotected final List getCurrentMessages()\n\t{\n\t\tfinal List messages = (List)messageListView.getModelObject();\n\t\treturn Collections.unmodifiableList(messages);\n\t}","id":33692,"modified_method":"/**\n\t * Gets the currently collected messages for this panel.\n\t * \n\t * @return the currently collected messages for this panel, possibly empty\n\t */\n\tprotected final List<FeedbackMessage> getCurrentMessages()\n\t{\n\t\tfinal List<FeedbackMessage> messages = messageListView.getModelObject();\n\t\treturn Collections.unmodifiableList(messages);\n\t}","commit_id":"de3f1002add187c0adeab06c76c95aa1ac684c35","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t\t * @see org.apache.wicket.markup.html.list.ListView#populateItem(org.apache.wicket.markup.html.list.ListItem)\n\t\t */\n\t\t@Override\n\t\tprotected void populateItem(final ListItem listItem)\n\t\t{\n\t\t\tfinal FeedbackMessage message = (FeedbackMessage)listItem.getModelObject();\n\t\t\tmessage.markRendered();\n\t\t\tfinal IModel<String> replacementModel = new Model<String>()\n\t\t\t{\n\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t/**\n\t\t\t\t * Returns feedbackPanel + the message level, eg 'feedbackPanelERROR'. This is used\n\t\t\t\t * as the class of the li / span elements.\n\t\t\t\t * \n\t\t\t\t * @see org.apache.wicket.model.IModel#getObject()\n\t\t\t\t */\n\t\t\t\t@Override\n\t\t\t\tpublic String getObject()\n\t\t\t\t{\n\t\t\t\t\treturn getCSSClass(message);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tfinal Component label = newMessageDisplayComponent(\"message\", message);\n\t\t\tfinal AttributeModifier levelModifier = new AttributeModifier(\"class\", replacementModel);\n\t\t\tlabel.add(levelModifier);\n\t\t\tlistItem.add(levelModifier);\n\t\t\tlistItem.add(label);\n\t\t}","id":33693,"modified_method":"/**\n\t\t * @see\n\t\t * \torg.apache.wicket.markup.html.list.ListView#populateItem(org.apache.wicket.markup.html\n\t\t * \t.list.ListItem)\n\t\t */\n\t\t@Override\n\t\tprotected void populateItem(final ListItem<FeedbackMessage> listItem)\n\t\t{\n\t\t\tfinal FeedbackMessage message = listItem.getModelObject();\n\t\t\tmessage.markRendered();\n\t\t\tfinal IModel<String> replacementModel = new Model<String>()\n\t\t\t{\n\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t/**\n\t\t\t\t * Returns feedbackPanel + the message level, eg 'feedbackPanelERROR'. This is used\n\t\t\t\t * as the class of the li / span elements.\n\t\t\t\t * \n\t\t\t\t * @see org.apache.wicket.model.IModel#getObject()\n\t\t\t\t */\n\t\t\t\t@Override\n\t\t\t\tpublic String getObject()\n\t\t\t\t{\n\t\t\t\t\treturn getCSSClass(message);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tfinal Component<?> label = newMessageDisplayComponent(\"message\", message);\n\t\t\tfinal AttributeModifier levelModifier = new AttributeModifier(\"class\", replacementModel);\n\t\t\tlabel.add(levelModifier);\n\t\t\tlistItem.add(levelModifier);\n\t\t\tlistItem.add(label);\n\t\t}","commit_id":"de3f1002add187c0adeab06c76c95aa1ac684c35","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Generates a component that is used to display the message inside the feedback panel. This\n\t * component must handle being attached to <code>span<\/code> tags.\n\t * \n\t * By default a {@link Label} is used.\n\t * \n\t * Note that the created component is expected to respect feedback panel's\n\t * {@link #getEscapeModelStrings()} value\n\t * \n\t * @param id\n\t *            parent id\n\t * @param message\n\t *            feedback message\n\t * @return component used to display the message\n\t */\n\tprotected Component newMessageDisplayComponent(String id, FeedbackMessage message)\n\t{\n\t\tLabel label = new Label(id, message.getMessage().toString());\n\t\tlabel.setEscapeModelStrings(FeedbackPanel.this.getEscapeModelStrings());\n\t\treturn label;\n\t}","id":33694,"modified_method":"/**\n\t * Generates a component that is used to display the message inside the feedback panel. This\n\t * component must handle being attached to <code>span<\/code> tags.\n\t * \n\t * By default a {@link Label} is used.\n\t * \n\t * Note that the created component is expected to respect feedback panel's {@link\n\t * #getEscapeModelStrings()} value\n\t * \n\t * @param id\n\t * \t\tparent id\n\t * @param message\n\t * \t\tfeedback message\n\t * @return component used to display the message\n\t */\n\tprotected Component<?> newMessageDisplayComponent(String id, FeedbackMessage message)\n\t{\n\t\tLabel<String> label = new Label<String>(id, message.getMessage().toString());\n\t\tlabel.setEscapeModelStrings(FeedbackPanel.this.getEscapeModelStrings());\n\t\treturn label;\n\t}","commit_id":"de3f1002add187c0adeab06c76c95aa1ac684c35","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Search messages that this panel will render, and see if there is any message of the given\n\t * level.\n\t * \n\t * @param level\n\t *            the level, see FeedbackMessage\n\t * @return whether there is any message for this panel of the given level\n\t */\n\tpublic final boolean anyMessage(int level)\n\t{\n\t\tList msgs = getCurrentMessages();\n\n\t\tfor (Iterator i = msgs.iterator(); i.hasNext();)\n\t\t{\n\t\t\tFeedbackMessage msg = (FeedbackMessage)i.next();\n\t\t\tif (msg.isLevel(level))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","id":33695,"modified_method":"/**\n\t * Search messages that this panel will render, and see if there is any message of the given\n\t * level.\n\t * \n\t * @param level\n\t * \t\tthe level, see FeedbackMessage\n\t * @return whether there is any message for this panel of the given level\n\t */\n\tpublic final boolean anyMessage(int level)\n\t{\n\t\tList<FeedbackMessage> msgs = getCurrentMessages();\n\n\t\tfor (FeedbackMessage msg : msgs)\n\t\t{\n\t\t\tif (msg.isLevel(level))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"de3f1002add187c0adeab06c76c95aa1ac684c35","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see org.apache.wicket.Component#Component(String)\n\t * \n\t * @param id\n\t * @param filter\n\t */\n\tpublic FeedbackPanel(final String id, IFeedbackMessageFilter filter)\n\t{\n\t\tsuper(id);\n\t\tWebMarkupContainer messagesContainer = new WebMarkupContainer(\"feedbackul\")\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic boolean isVisible()\n\t\t\t{\n\t\t\t\treturn anyMessage();\n\t\t\t}\n\t\t};\n\t\tadd(messagesContainer);\n\t\tmessageListView = new MessageListView(\"messages\");\n\t\tmessageListView.setVersioned(false);\n\t\tmessagesContainer.add(messageListView);\n\n\t\tif (filter != null)\n\t\t{\n\t\t\tsetFilter(filter);\n\t\t}\n\t}","id":33696,"modified_method":"/**\n\t * @see org.apache.wicket.Component#Component(String)\n\t * \n\t * @param id\n\t * @param filter\n\t */\n\tpublic FeedbackPanel(final String id, IFeedbackMessageFilter filter)\n\t{\n\t\tsuper(id);\n\t\tWebMarkupContainer<?> messagesContainer = new WebMarkupContainer<Void>(\"feedbackul\")\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic boolean isVisible()\n\t\t\t{\n\t\t\t\treturn anyMessage();\n\t\t\t}\n\t\t};\n\t\tadd(messagesContainer);\n\t\tmessageListView = new MessageListView(\"messages\");\n\t\tmessageListView.setVersioned(false);\n\t\tmessagesContainer.add(messageListView);\n\n\t\tif (filter != null)\n\t\t{\n\t\t\tsetFilter(filter);\n\t\t}\n\t}","commit_id":"de3f1002add187c0adeab06c76c95aa1ac684c35","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Sets the comparator used for sorting the messages.\n\t * \n\t * @param sortingComparator\n\t *            comparator used for sorting the messages.\n\t */\n\tpublic final void setSortingComparator(Comparator sortingComparator)\n\t{\n\t\tgetFeedbackMessagesModel().setSortingComparator(sortingComparator);\n\t}","id":33697,"modified_method":"/**\n\t * Sets the comparator used for sorting the messages.\n\t * \n\t * @param sortingComparator\n\t * \t\tcomparator used for sorting the messages.\n\t */\n\tpublic final void setSortingComparator(Comparator<FeedbackMessage> sortingComparator)\n\t{\n\t\tgetFeedbackMessagesModel().setSortingComparator(sortingComparator);\n\t}","commit_id":"de3f1002add187c0adeab06c76c95aa1ac684c35","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Construct.\n\t * \n\t * @param id\n\t *            component id\n\t * @param resourceReference\n\t *            resource reference. The model must provide an instance of\n\t *            {@link ResourceReference}\n\t */\n\tpublic JavaScriptReference(String id, IModel resourceReference)\n\t{\n\t\tsuper(id, resourceReference, \"src\");\n\t}","id":33698,"modified_method":"/**\n\t * Construct.\n\t * \n\t * @param id\n\t * \t\tcomponent id\n\t * @param resourceReference\n\t * \t\tresource reference. The model must provide an instance of {@link ResourceReference}\n\t */\n\tpublic JavaScriptReference(String id, IModel<ResourceReference> resourceReference)\n\t{\n\t\tsuper(id, resourceReference, \"src\");\n\t}","commit_id":"de3f1002add187c0adeab06c76c95aa1ac684c35","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Construct.\n\t * \n\t * @param id\n\t *            component id\n\t * @param referer\n\t *            the class that is referring; is used as the relative root for getting the resource\n\t * @param file\n\t *            reference as a string. The model must provide an instance of {@link String}\n\t */\n\tpublic JavaScriptReference(String id, Class referer, IModel file)\n\t{\n\t\tsuper(id, referer, file, \"src\");\n\t}","id":33699,"modified_method":"/**\n\t * Construct.\n\t * \n\t * @param id\n\t * \t\tcomponent id\n\t * @param referer\n\t * \t\tthe class that is referring; is used as the relative root for getting the resource\n\t * @param file\n\t * \t\treference as a string. The model must provide an instance of {@link String}\n\t */\n\tpublic JavaScriptReference(String id, Class<?> referer, IModel<String> file)\n\t{\n\t\tsuper(id, referer, file, \"src\");\n\t}","commit_id":"de3f1002add187c0adeab06c76c95aa1ac684c35","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see org.apache.wicket.markup.html.resources.PackagedResourceReference#createPackageResourceReference(org.apache.wicket.Application,\n\t *      java.lang.Class, java.lang.String)\n\t */\n\tprotected ResourceReference createPackageResourceReference(Application app, Class scope,\n\t\t\tString name)\n\t{\n\t\tCompressedResourceReference compressedResourceReference = new CompressedResourceReference(\n\t\t\t\tscope, name);\n\t\tcompressedResourceReference.bind(app);\n\t\treturn compressedResourceReference;\n\t}","id":33700,"modified_method":"/**\n\t * @see org.apache.wicket.markup.html.resources.PackagedResourceReference#\n\t * \tcreatePackageResourceReference(org.apache.wicket.Application, java.lang.Class,\n\t * \tjava.lang.String)\n\t */\n\t@Override\n\tprotected ResourceReference createPackageResourceReference(Application app, Class<?> scope,\n\t\tString name)\n\t{\n\t\tCompressedResourceReference compressedResourceReference = new CompressedResourceReference(\n\t\t\tscope, name);\n\t\tcompressedResourceReference.bind(app);\n\t\treturn compressedResourceReference;\n\t}","commit_id":"de3f1002add187c0adeab06c76c95aa1ac684c35","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Construct.\n\t * \n\t * @param id\n\t *            component id\n\t * @param referer\n\t *            the class that is referring; is used as the relative root for getting the resource\n\t * @param file\n\t *            reference as a string\n\t */\n\tpublic JavaScriptReference(String id, Class referer, String file)\n\t{\n\t\tsuper(id, referer, file, \"src\");\n\t}","id":33701,"modified_method":"/**\n\t * Construct.\n\t * \n\t * @param id\n\t * \t\tcomponent id\n\t * @param referer\n\t * \t\tthe class that is referring; is used as the relative root for getting the resource\n\t * @param file\n\t * \t\treference as a string\n\t */\n\tpublic JavaScriptReference(String id, Class<?> referer, String file)\n\t{\n\t\tsuper(id, referer, file, \"src\");\n\t}","commit_id":"de3f1002add187c0adeab06c76c95aa1ac684c35","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Creates a new javascript resource reference.\n\t * \n\t * @param scope\n\t * @param name\n\t * @param locale\n\t * @param style\n\t */\n\tpublic JavascriptResourceReference(Class scope, String name, Locale locale, String style)\n\t{\n\t\tsuper(scope, name, locale, style);\n\t}","id":33702,"modified_method":"/**\n\t * Creates a new javascript resource reference.\n\t * \n\t * @param scope\n\t * @param name\n\t * @param locale\n\t * @param style\n\t */\n\tpublic JavascriptResourceReference(Class<?> scope, String name, Locale locale, String style)\n\t{\n\t\tsuper(scope, name, locale, style);\n\t}","commit_id":"de3f1002add187c0adeab06c76c95aa1ac684c35","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Creates a new javascript resource reference.\n\t * \n\t * @param scope\n\t * @param name\n\t */\n\tpublic JavascriptResourceReference(Class scope, String name)\n\t{\n\t\tsuper(scope, name);\n\t}","id":33703,"modified_method":"/**\n\t * Creates a new javascript resource reference.\n\t * \n\t * @param scope\n\t * @param name\n\t */\n\tpublic JavascriptResourceReference(Class<?> scope, String name)\n\t{\n\t\tsuper(scope, name);\n\t}","commit_id":"de3f1002add187c0adeab06c76c95aa1ac684c35","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Construct.\n\t * \n\t * @param id\n\t *            component id\n\t * @param referer\n\t *            the class that is referring; is used as the relative root for getting the resource\n\t * @param file\n\t *            relative location of the packaged file\n\t * @param attributeToReplace\n\t *            the attribute to replace of the target tag\n\t */\n\tpublic PackagedResourceReference(final String id, final Class referer, final String file,\n\t\tfinal String attributeToReplace)\n\t{\n\t\tthis(id, referer, new Model<String>(file), attributeToReplace);\n\t}","id":33704,"modified_method":"/**\n\t * Construct.\n\t * \n\t * @param id\n\t * \t\tcomponent id\n\t * @param referer\n\t * \t\tthe class that is referring; is used as the relative root for getting the resource\n\t * @param file\n\t * \t\trelative location of the packaged file\n\t * @param attributeToReplace\n\t * \t\tthe attribute to replace of the target tag\n\t */\n\tpublic PackagedResourceReference(final String id, final Class<?> referer, final String file,\n\t\tfinal String attributeToReplace)\n\t{\n\t\tthis(id, referer, new Model<String>(file), attributeToReplace);\n\t}","commit_id":"de3f1002add187c0adeab06c76c95aa1ac684c35","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Creates new package resource reference.\n\t * \n\t * @param app\n\t * @param scope\n\t * @param name\n\t * @return created resource reference\n\t */\n\tprotected ResourceReference createPackageResourceReference(Application app, Class scope,\n\t\tString name)\n\t{\n\t\tResourceReference resourceReference = new ResourceReference(scope, name);\n\t\tresourceReference.bind(app);\n\t\treturn resourceReference;\n\t}","id":33705,"modified_method":"/**\n\t * Creates new package resource reference.\n\t * \n\t * @param app\n\t * @param scope\n\t * @param name\n\t * @return created resource reference\n\t */\n\tprotected ResourceReference createPackageResourceReference(Application app, Class<?> scope,\n\t\tString name)\n\t{\n\t\tResourceReference resourceReference = new ResourceReference(scope, name);\n\t\tresourceReference.bind(app);\n\t\treturn resourceReference;\n\t}","commit_id":"de3f1002add187c0adeab06c76c95aa1ac684c35","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Construct.\n\t * \n\t * @param id\n\t *            component id\n\t * @param referer\n\t *            the class that is referring; is used as the relative root for getting the resource\n\t * @param file\n\t *            model that supplies the relative location of the packaged file. Must return an\n\t *            instance of {@link String}\n\t * @param attributeToReplace\n\t *            the attribute to replace of the target tag\n\t */\n\tpublic PackagedResourceReference(final String id, final Class referer, final IModel<String> file,\n\t\tfinal String attributeToReplace)\n\t{\n\t\tsuper(id);\n\n\t\tif (referer == null)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"Referer may not be null\");\n\t\t}\n\t\tif (file == null)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"File may not be null\");\n\t\t}\n\t\tif (attributeToReplace == null)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"AttributeToReplace may not be null\");\n\t\t}\n\n\t\tIModel<String> srcReplacement = new Model<String>()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic String getObject()\n\t\t\t{\n        String str = file.getObject();\n\t\t\t\tif (str == null)\n\t\t\t\t{\n\t\t\t\t\tthrow new IllegalArgumentException(\"The model must provide a non-null object\");\n\t\t\t\t}\n        // can this check be safely removed?\n        if (!(str instanceof String))\n\t\t\t\t{\n\t\t\t\t\tthrow new IllegalArgumentException(\"The model must provide a string\");\n\t\t\t\t}\n\t\t\t\tString f = getConverter(String.class).convertToString(str, getLocale());\n\t\t\t\tResourceReference ref = new ResourceReference(referer, f, getLocale(), getStyle());\n\t\t\t\tCharSequence url = urlFor(ref);\n\t\t\t\treturn url != null ? url.toString() : null;\n\t\t\t}\n\t\t};\n\t\tadd(new AttributeModifier(attributeToReplace, true, srcReplacement));\n\t}","id":33706,"modified_method":"/**\n\t * Construct.\n\t * \n\t * @param id\n\t * \t\tcomponent id\n\t * @param referer\n\t * \t\tthe class that is referring; is used as the relative root for getting the resource\n\t * @param file\n\t * \t\tmodel that supplies the relative location of the packaged file. Must return an instance\n\t * \t\tof {@link String}\n\t * @param attributeToReplace\n\t * \t\tthe attribute to replace of the target tag\n\t */\n\tpublic PackagedResourceReference(final String id, final Class<?> referer,\n\t\tfinal IModel<String> file, final String attributeToReplace)\n\t{\n\t\tsuper(id);\n\n\t\tif (referer == null)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"Referer may not be null\");\n\t\t}\n\t\tif (file == null)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"File may not be null\");\n\t\t}\n\t\tif (attributeToReplace == null)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"AttributeToReplace may not be null\");\n\t\t}\n\n\t\tIModel<String> srcReplacement = new Model<String>()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic String getObject()\n\t\t\t{\n\t\t\t\tString str = file.getObject();\n\t\t\t\tif (str == null)\n\t\t\t\t{\n\t\t\t\t\tthrow new IllegalArgumentException(\"The model must provide a non-null object\");\n\t\t\t\t}\n\t\t\t\t// can this check be safely removed?\n\t\t\t\tif (!(str instanceof String))\n\t\t\t\t{\n\t\t\t\t\tthrow new IllegalArgumentException(\"The model must provide a string\");\n\t\t\t\t}\n\t\t\t\tString f = getConverter(String.class).convertToString(str, getLocale());\n\t\t\t\tResourceReference ref = new ResourceReference(referer, f, getLocale(), getStyle());\n\t\t\t\tCharSequence url = urlFor(ref);\n\t\t\t\treturn url != null ? url.toString() : null;\n\t\t\t}\n\t\t};\n\t\tadd(new AttributeModifier(attributeToReplace, true, srcReplacement));\n\t}","commit_id":"de3f1002add187c0adeab06c76c95aa1ac684c35","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Construct.\n\t * \n\t * @param id\n\t *            component id\n\t * @param referer\n\t *            the class that is referring; is used as the relative root for getting the resource\n\t * @param file\n\t *            reference. The model must provide an instance of {@link String}\n\t */\n\tpublic StyleSheetReference(String id, Class referer, IModel file)\n\t{\n\t\tsuper(id, referer, file, \"href\");\n\t}","id":33707,"modified_method":"/**\n\t * Construct.\n\t * \n\t * @param id\n\t * \t\tcomponent id\n\t * @param referer\n\t * \t\tthe class that is referring; is used as the relative root for getting the resource\n\t * @param file\n\t * \t\treference. The model must provide an instance of {@link String}\n\t */\n\tpublic StyleSheetReference(String id, Class<?> referer, IModel<String> file)\n\t{\n\t\tsuper(id, referer, file, \"href\");\n\t}","commit_id":"de3f1002add187c0adeab06c76c95aa1ac684c35","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Construct.\n\t * \n\t * @param id\n\t *            component id\n\t * @param referer\n\t *            the class that is referring; is used as the relative root for getting the resource\n\t * @param file\n\t *            reference as a string\n\t */\n\tpublic StyleSheetReference(String id, Class referer, String file)\n\t{\n\t\tsuper(id, referer, file, \"href\");\n\t}","id":33708,"modified_method":"/**\n\t * Construct.\n\t * \n\t * @param id\n\t * \t\tcomponent id\n\t * @param referer\n\t * \t\tthe class that is referring; is used as the relative root for getting the resource\n\t * @param file\n\t * \t\treference as a string\n\t */\n\tpublic StyleSheetReference(String id, Class<?> referer, String file)\n\t{\n\t\tsuper(id, referer, file, \"href\");\n\t}","commit_id":"de3f1002add187c0adeab06c76c95aa1ac684c35","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Construct.\n\t * \n\t * @param id\n\t *            component id\n\t * @param resourceReference\n\t *            resource reference. The model must provide an instance of\n\t *            {@link ResourceReference}\n\t */\n\tpublic StyleSheetReference(String id, IModel resourceReference)\n\t{\n\t\tsuper(id, resourceReference, \"href\");\n\t}","id":33709,"modified_method":"/**\n\t * Construct.\n\t * \n\t * @param id\n\t * \t\tcomponent id\n\t * @param resourceReference\n\t * \t\tresource reference. The model must provide an instance of {@link ResourceReference}\n\t */\n\tpublic StyleSheetReference(String id, IModel<ResourceReference> resourceReference)\n\t{\n\t\tsuper(id, resourceReference, \"href\");\n\t}","commit_id":"de3f1002add187c0adeab06c76c95aa1ac684c35","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @return collection representing selected items\n\t */\n\tpublic Collection getModelCollection()\n\t{\n\t\treturn (Collection)getModelObject();\n\t}","id":33710,"modified_method":"/**\n\t * @return collection representing selected items\n\t */\n\tpublic Collection getModelCollection()\n\t{\n\t\treturn getModelObject();\n\t}","commit_id":"a67a3c73cc7db556579b06be63f6c84e739c72dc","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Gives overriding classes the option of adding (or even changing/\n\t * removing) configuration properties for the javascript widget. See <a\n\t * href=\"http://developer.yahoo.com/yui/calendar/\">the widget's\n\t * documentation<\/a> for the available options. If you want to override/\n\t * remove properties, you obviously should call\n\t * {@link super#setWidgetProperties(Properties)} first.\n\t * \n\t * @param widgetProperties\n\t *            the current widget properties\n\t */\n\tprotected void configureWidgetProperties(Map widgetProperties)\n\t{\n\t\twidgetProperties.put(\"close\", Boolean.TRUE);\n\t\t// TODO localize\n\t\twidgetProperties.put(\"title\", \"Select a date:\");\n\n\t\tDate date = (Date)component.getModelObject();\n\t\tif (date != null)\n\t\t{\n\t\t\twidgetProperties.put(\"selected\", AbstractCalendar.FORMAT_DATE.format(date));\n\t\t\twidgetProperties.put(\"pagedate\", AbstractCalendar.FORMAT_PAGEDATE.format(date));\n\t\t}\n\t}","id":33711,"modified_method":"/**\n\t * Gives overriding classes the option of adding (or even changing/\n\t * removing) configuration properties for the javascript widget. See <a\n\t * href=\"http://developer.yahoo.com/yui/calendar/\">the widget's\n\t * documentation<\/a> for the available options. If you want to override/\n\t * remove properties, you obviously should call\n\t * {@link super#setWidgetProperties(Properties)} first.\n\t * \n\t * @param widgetProperties\n\t *            the current widget properties\n\t */\n\tprotected void configureWidgetProperties(Map widgetProperties)\n\t{\n\t\twidgetProperties.put(\"close\", Boolean.TRUE);\n\t\t// TODO localize\n\t\twidgetProperties.put(\"title\", \"Select a date:\");\n\n\t\tObject modelObject = component.getModelObject();\n\t\t// null and cast check\n\t\tif (modelObject instanceof Date)\n\t\t{\n\t\t\tDate date = (Date)modelObject;\n\t\t\twidgetProperties.put(\"selected\", AbstractCalendar.FORMAT_DATE.format(date));\n\t\t\twidgetProperties.put(\"pagedate\", AbstractCalendar.FORMAT_PAGEDATE.format(date));\n\t\t}\n\t}","commit_id":"01a26df4a6422a124813e5fa030bf4a79a63ff55","url":"https://github.com/apache/wicket"},{"original_method":"public void invokeBusinessLogic( MessageContext msgContext, MessageContext newMsgContext ) throws AxisFault\n    {\n        String methodName = this.findOperation( msgContext );\n        Class serviceMethodArgType = this.findArgumentClass( methodName );\n\n        SOAPFactory factory = this.getSOAPFactory( msgContext );\n        OMElement msgBodyOm = msgContext.getEnvelope().getBody().getFirstElement();\n\n        String bindingName = this.findBindingName( msgBodyOm );\n        EucalyptusMessage wrappedParam = this.bindMessage( methodName, serviceMethodArgType, msgBodyOm, bindingName );\n\n        HttpRequest httprequest = ( HttpRequest ) msgContext.getProperty( GenericHttpDispatcher.HTTP_REQUEST );\n        if ( httprequest == null )\n        {\n          this.verifyUser( msgContext, wrappedParam );\n        }\n        else\n        {\n          bindingName = httprequest.getBindingName();\n          Policy p = new Policy();\n          newMsgContext.setProperty( RampartMessageData.KEY_RAMPART_POLICY, p );\n          //:: fixes the handling of certain kinds of client brain damage :://\n          if ( httprequest.isPureClient() ) {\n            if ( wrappedParam instanceof ModifyImageAttributeType ) {\n              ModifyImageAttributeType pure = ( ( ModifyImageAttributeType ) wrappedParam );\n              pure.setImageId( pure.getImageId().replaceFirst( \"a\", \"e\" ) );\n            } else if ( wrappedParam instanceof DescribeImageAttributeType ) {\n              DescribeImageAttributeType pure = ( ( DescribeImageAttributeType ) wrappedParam );\n              pure.setImageId( pure.getImageId().replaceFirst( \"^a\", \"e\" ) );\n            } else if ( wrappedParam instanceof ResetImageAttributeType ) {\n              ResetImageAttributeType pure = ( ( ResetImageAttributeType ) wrappedParam );\n              pure.setImageId( pure.getImageId().replaceFirst( \"^a\", \"e\" ) );\n            } else if ( wrappedParam instanceof DescribeImagesType ) {\n              ArrayList<String> strs = Lists.newArrayList();\n              for ( String imgId : ( ( DescribeImagesType ) wrappedParam ).getImagesSet() ) {\n                strs.add( imgId.replaceFirst( \"^a\", \"e\" ) );\n              }\n              ( ( DescribeImagesType ) wrappedParam ).setImagesSet( strs );\n            } else if ( wrappedParam instanceof DeregisterImageType ) {\n              DeregisterImageType pure = ( ( DeregisterImageType ) wrappedParam );\n              pure.setImageId( pure.getImageId().replaceFirst( \"^a\", \"e\" ) );\n            } else if ( wrappedParam instanceof RunInstancesType ) {\n              RunInstancesType pure = ((RunInstancesType) wrappedParam);\n              pure.setImageId( pure.getImageId().replaceFirst( \"^a\", \"e\" ) );\n              pure.setKernelId( pure.getKernelId().replaceFirst( \"^a\", \"e\" )  );\n              pure.setRamdiskId( pure.getRamdiskId().replaceFirst( \"^a\", \"e\" ) );\n            }\n          }\n\n        }\n\n        MuleMessage message = this.invokeService( methodName, wrappedParam );\n\n        if ( message == null )\n            throw new AxisFault( \"Received a NULL response. This is a bug -- it should NEVER happen.\" );\n\n        this.checkException( message );\n\n        if( httprequest != null ) {\n          //:: fixes the handling of certain kinds of client brain damage :://\n          if ( httprequest.isPureClient() ) {\n            if ( message.getPayload() instanceof DescribeImagesResponseType ) {\n              DescribeImagesResponseType purify = ( DescribeImagesResponseType ) message.getPayload();\n              for ( ImageDetails img : purify.getImagesSet() ) {\n                img.setImageId( img.getImageId().replaceFirst(\"^e\",\"a\" ));\n                if( img.getKernelId() != null ) img.setKernelId( img.getKernelId().replaceFirst(\"^e\",\"a\" ));\n                if( img.getRamdiskId() != null ) img.setRamdiskId( img.getRamdiskId().replaceFirst(\"^e\",\"a\" ));\n              }\n            } else if ( message.getPayload() instanceof DescribeInstancesResponseType ) {\n              DescribeInstancesResponseType purify = ( DescribeInstancesResponseType ) message.getPayload();\n              for( ReservationInfoType rsvInfo : purify.getReservationSet() ) {\n                for( RunningInstancesItemType r : rsvInfo.getInstancesSet() ) {\n                  r.setImageId( r.getImageId().replaceFirst( \"^e\", \"a\" ) );\n                  if( r.getKernel() != null ) r.setKernel( r.getKernel().replaceFirst( \"^e\", \"a\" ) );\n                  if( r.getRamdisk() != null ) r.setRamdisk( r.getRamdisk().replaceFirst( \"^e\", \"a\" ) );\n                }\n              }\n            }\n\n          }\n        }\n\n        if ( newMsgContext != null )\n        {\n            SOAPEnvelope envelope = generateMessage( methodName, factory, bindingName, message.getPayload() );\n            newMsgContext.setEnvelope( envelope );\n        }\n\n        newMsgContext.setProperty( Axis2HttpWorker.REAL_HTTP_REQUEST, msgContext.getProperty( Axis2HttpWorker.REAL_HTTP_REQUEST ) );\n        newMsgContext.setProperty( Axis2HttpWorker.REAL_HTTP_RESPONSE, msgContext.getProperty( Axis2HttpWorker.REAL_HTTP_RESPONSE ) );\n\n        LOG.info(\"Returning reply: \" + message.getPayload());\n\n        if(message.getPayload() instanceof WalrusErrorMessageType) {\n            WalrusErrorMessageType errorMessage = (WalrusErrorMessageType) message.getPayload();\n            msgContext.setProperty(Axis2HttpWorker.HTTP_STATUS, errorMessage.getHttpCode());\n            newMsgContext.setProperty(Axis2HttpWorker.HTTP_STATUS, errorMessage.getHttpCode());\n            //This selects the data formatter\n            newMsgContext.setProperty( \"messageType\", \"application/walrus\" );\n            return;\n        }\n\n        Boolean putType = (Boolean) msgContext.getProperty(WalrusProperties.STREAMING_HTTP_PUT);\n        Boolean getType = (Boolean) msgContext.getProperty(WalrusProperties.STREAMING_HTTP_GET);\n\n        if(getType != null || putType != null) {\n            WalrusDataResponseType reply = (WalrusDataResponseType) message.getPayload();\n            AxisHttpResponse response = ( AxisHttpResponse ) msgContext.getProperty( Axis2HttpWorker.REAL_HTTP_RESPONSE );\n            response.addHeader( new BasicHeader( \"Last-Modified\", reply.getLastModified()));\n            response.addHeader( new BasicHeader( \"ETag\", '\\\"' + reply.getEtag() + '\\\"'));\n            if(getType != null) {\n                newMsgContext.setProperty(WalrusProperties.STREAMING_HTTP_GET, getType);\n                WalrusDataRequestType request = (WalrusDataRequestType) wrappedParam;\n                Boolean isCompressed = request.getIsCompressed();\n                if(isCompressed == null)\n                    isCompressed = false;\n                if(isCompressed) {\n                    newMsgContext.setProperty(\"GET_COMPRESSED\", isCompressed);\n                } else {\n                    Long contentLength = reply.getSize();\n                    response.addHeader(new BasicHeader(HTTP.CONTENT_LEN, String.valueOf(contentLength)));\n                }\n                List<MetaDataEntry> metaData = reply.getMetaData();\n                for(MetaDataEntry metaDataEntry: metaData) {\n                    response.addHeader(new BasicHeader(WalrusProperties.AMZ_META_HEADER_PREFIX + metaDataEntry.getName(), metaDataEntry.getValue()));\n                }\n                if(getType.equals(Boolean.TRUE)) {\n                    newMsgContext.setProperty(\"GET_KEY\", request.getBucket() + \".\" + request.getKey());\n                    newMsgContext.setProperty(\"GET_RANDOM_KEY\", request.getRandomKey());\n                }\n                //This selects the data formatter\n                newMsgContext.setProperty( \"messageType\", \"application/walrus\" );\n            } else if(putType != null) {\n                if(reply instanceof PostObjectResponseType) {\n                    PostObjectResponseType postReply = (PostObjectResponseType) reply;\n                    String redirectUrl = postReply.getRedirectUrl();\n                    if(redirectUrl != null) {\n                        response.addHeader(new BasicHeader(\"Location\", redirectUrl));\n                        msgContext.setProperty(Axis2HttpWorker.HTTP_STATUS, HttpStatus.SC_SEE_OTHER);\n                        newMsgContext.setProperty(Axis2HttpWorker.HTTP_STATUS, HttpStatus.SC_SEE_OTHER);\n                        newMsgContext.setProperty( \"messageType\", \"application/walrus\" );\n                    } else {\n                        Integer successCode = postReply.getSuccessCode();\n                        if(successCode != null) {\n                            newMsgContext.setProperty(Axis2HttpWorker.HTTP_STATUS, successCode);\n                            if(successCode == 201) {\n                                return;\n                            } else {\n                                newMsgContext.setProperty( \"messageType\", \"application/walrus\" );\n                                return;\n                            }\n\n                        }\n                    }\n                }\n                response.addHeader(new BasicHeader(HTTP.CONTENT_LEN, String.valueOf(0)));\n            }\n        }\n\n    }","id":33712,"modified_method":"public void invokeBusinessLogic( MessageContext msgContext, MessageContext newMsgContext ) throws AxisFault\n    {\n        String methodName = this.findOperation( msgContext );\n        Class serviceMethodArgType = this.findArgumentClass( methodName );\n\n        SOAPFactory factory = this.getSOAPFactory( msgContext );\n        OMElement msgBodyOm = msgContext.getEnvelope().getBody().getFirstElement();\n\n        String bindingName = this.findBindingName( msgBodyOm );\n        EucalyptusMessage wrappedParam = this.bindMessage( methodName, serviceMethodArgType, msgBodyOm, bindingName );\n\n        HttpRequest httprequest = ( HttpRequest ) msgContext.getProperty( GenericHttpDispatcher.HTTP_REQUEST );\n        if ( httprequest == null )\n        {\n          this.verifyUser( msgContext, wrappedParam );\n        }\n        else\n        {\n          bindingName = httprequest.getBindingName();\n          Policy p = new Policy();\n          newMsgContext.setProperty( RampartMessageData.KEY_RAMPART_POLICY, p );\n          //:: fixes the handling of certain kinds of client brain damage :://\n          if ( httprequest.isPureClient() ) {\n            if ( wrappedParam instanceof ModifyImageAttributeType ) {\n              ModifyImageAttributeType pure = ( ( ModifyImageAttributeType ) wrappedParam );\n              pure.setImageId( pure.getImageId().replaceFirst( \"a\", \"e\" ).toLowerCase( ) );\n            } else if ( wrappedParam instanceof DescribeImageAttributeType ) {\n              DescribeImageAttributeType pure = ( ( DescribeImageAttributeType ) wrappedParam );\n              pure.setImageId( pure.getImageId().replaceFirst( \"^a\", \"e\" ).toLowerCase( ) );\n            } else if ( wrappedParam instanceof ResetImageAttributeType ) {\n              ResetImageAttributeType pure = ( ( ResetImageAttributeType ) wrappedParam );\n              pure.setImageId( pure.getImageId().replaceFirst( \"^a\", \"e\" ).toLowerCase( ) );\n            } else if ( wrappedParam instanceof DescribeImagesType ) {\n              ArrayList<String> strs = Lists.newArrayList();\n              for ( String imgId : ( ( DescribeImagesType ) wrappedParam ).getImagesSet() ) {\n                strs.add( imgId.replaceFirst( \"^a\", \"e\" ).toLowerCase( ) );\n              }\n              ( ( DescribeImagesType ) wrappedParam ).setImagesSet( strs );\n            } else if ( wrappedParam instanceof DeregisterImageType ) {\n              DeregisterImageType pure = ( ( DeregisterImageType ) wrappedParam );\n              pure.setImageId( pure.getImageId().replaceFirst( \"^a\", \"e\" ).toLowerCase( ) );\n            } else if ( wrappedParam instanceof RunInstancesType ) {\n              RunInstancesType pure = ((RunInstancesType) wrappedParam);\n              pure.setImageId( pure.getImageId().replaceFirst( \"^a\", \"e\" ).toLowerCase( ) );\n              pure.setKernelId( pure.getKernelId().replaceFirst( \"^a\", \"e\" ).toLowerCase( )  );\n              pure.setRamdiskId( pure.getRamdiskId().replaceFirst( \"^a\", \"e\" ).toLowerCase( ) );\n            }\n          }\n\n        }\n\n        MuleMessage message = this.invokeService( methodName, wrappedParam );\n\n        if ( message == null )\n            throw new AxisFault( \"Received a NULL response. This is a bug -- it should NEVER happen.\" );\n\n        this.checkException( message );\n\n        if( httprequest != null ) {\n          //:: fixes the handling of certain kinds of client brain damage :://\n          if ( httprequest.isPureClient() ) {\n            if ( message.getPayload() instanceof DescribeImagesResponseType ) {\n              DescribeImagesResponseType purify = ( DescribeImagesResponseType ) message.getPayload();\n              for ( ImageDetails img : purify.getImagesSet() ) {\n                img.setImageId( img.getImageId().replaceFirst(\"^e\",\"a\" ).toLowerCase( ) );\n                if( img.getKernelId() != null ) img.setKernelId( img.getKernelId().replaceFirst(\"^e\",\"a\" ).toLowerCase( ) );\n                if( img.getRamdiskId() != null ) img.setRamdiskId( img.getRamdiskId().replaceFirst(\"^e\",\"a\" ).toLowerCase( ) );\n              }\n            } else if ( message.getPayload() instanceof DescribeInstancesResponseType ) {\n              DescribeInstancesResponseType purify = ( DescribeInstancesResponseType ) message.getPayload();\n              for( ReservationInfoType rsvInfo : purify.getReservationSet() ) {\n                for( RunningInstancesItemType r : rsvInfo.getInstancesSet() ) {\n                  r.setImageId( r.getImageId().replaceFirst( \"^e\", \"a\" ).toLowerCase( ) );\n                  if( r.getKernel() != null ) r.setKernel( r.getKernel().replaceFirst( \"^e\", \"a\" ).toLowerCase( ) );\n                  if( r.getRamdisk() != null ) r.setRamdisk( r.getRamdisk().replaceFirst( \"^e\", \"a\" ).toLowerCase( ) );\n                }\n              }\n            }\n\n          }\n        }\n\n        if ( newMsgContext != null )\n        {\n            SOAPEnvelope envelope = generateMessage( methodName, factory, bindingName, message.getPayload() );\n            newMsgContext.setEnvelope( envelope );\n        }\n\n        newMsgContext.setProperty( Axis2HttpWorker.REAL_HTTP_REQUEST, msgContext.getProperty( Axis2HttpWorker.REAL_HTTP_REQUEST ) );\n        newMsgContext.setProperty( Axis2HttpWorker.REAL_HTTP_RESPONSE, msgContext.getProperty( Axis2HttpWorker.REAL_HTTP_RESPONSE ) );\n\n        LOG.info(\"Returning reply: \" + message.getPayload());\n\n        if(message.getPayload() instanceof WalrusErrorMessageType) {\n            WalrusErrorMessageType errorMessage = (WalrusErrorMessageType) message.getPayload();\n            msgContext.setProperty(Axis2HttpWorker.HTTP_STATUS, errorMessage.getHttpCode());\n            newMsgContext.setProperty(Axis2HttpWorker.HTTP_STATUS, errorMessage.getHttpCode());\n            //This selects the data formatter\n            newMsgContext.setProperty( \"messageType\", \"application/walrus\" );\n            return;\n        }\n\n        Boolean putType = (Boolean) msgContext.getProperty(WalrusProperties.STREAMING_HTTP_PUT);\n        Boolean getType = (Boolean) msgContext.getProperty(WalrusProperties.STREAMING_HTTP_GET);\n\n        if(getType != null || putType != null) {\n            WalrusDataResponseType reply = (WalrusDataResponseType) message.getPayload();\n            AxisHttpResponse response = ( AxisHttpResponse ) msgContext.getProperty( Axis2HttpWorker.REAL_HTTP_RESPONSE );\n            response.addHeader( new BasicHeader( \"Last-Modified\", reply.getLastModified()));\n            response.addHeader( new BasicHeader( \"ETag\", '\\\"' + reply.getEtag() + '\\\"'));\n            if(getType != null) {\n                newMsgContext.setProperty(WalrusProperties.STREAMING_HTTP_GET, getType);\n                WalrusDataRequestType request = (WalrusDataRequestType) wrappedParam;\n                Boolean isCompressed = request.getIsCompressed();\n                if(isCompressed == null)\n                    isCompressed = false;\n                if(isCompressed) {\n                    newMsgContext.setProperty(\"GET_COMPRESSED\", isCompressed);\n                } else {\n                    Long contentLength = reply.getSize();\n                    response.addHeader(new BasicHeader(HTTP.CONTENT_LEN, String.valueOf(contentLength)));\n                }\n                List<MetaDataEntry> metaData = reply.getMetaData();\n                for(MetaDataEntry metaDataEntry: metaData) {\n                    response.addHeader(new BasicHeader(WalrusProperties.AMZ_META_HEADER_PREFIX + metaDataEntry.getName(), metaDataEntry.getValue()));\n                }\n                if(getType.equals(Boolean.TRUE)) {\n                    newMsgContext.setProperty(\"GET_KEY\", request.getBucket() + \".\" + request.getKey());\n                    newMsgContext.setProperty(\"GET_RANDOM_KEY\", request.getRandomKey());\n                }\n                //This selects the data formatter\n                newMsgContext.setProperty( \"messageType\", \"application/walrus\" );\n            } else if(putType != null) {\n                if(reply instanceof PostObjectResponseType) {\n                    PostObjectResponseType postReply = (PostObjectResponseType) reply;\n                    String redirectUrl = postReply.getRedirectUrl();\n                    if(redirectUrl != null) {\n                        response.addHeader(new BasicHeader(\"Location\", redirectUrl));\n                        msgContext.setProperty(Axis2HttpWorker.HTTP_STATUS, HttpStatus.SC_SEE_OTHER);\n                        newMsgContext.setProperty(Axis2HttpWorker.HTTP_STATUS, HttpStatus.SC_SEE_OTHER);\n                        newMsgContext.setProperty( \"messageType\", \"application/walrus\" );\n                    } else {\n                        Integer successCode = postReply.getSuccessCode();\n                        if(successCode != null) {\n                            newMsgContext.setProperty(Axis2HttpWorker.HTTP_STATUS, successCode);\n                            if(successCode == 201) {\n                                return;\n                            } else {\n                                newMsgContext.setProperty( \"messageType\", \"application/walrus\" );\n                                return;\n                            }\n\n                        }\n                    }\n                }\n                response.addHeader(new BasicHeader(HTTP.CONTENT_LEN, String.valueOf(0)));\n            }\n        }\n\n    }","commit_id":"bc943aefe937d1ab0f943144e640ca88cf7b749f","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void prepareRequest( final MessageContext messageContext ) throws AxisFault {\n    try {\n      HttpRequest httpRequest = new HttpRequest();\n      EndpointReference endpoint = messageContext.getTo();\n      //:: fixes trailing '/' added by some clients :://\n      if( endpoint.getAddress().contains( \"Eucalyptus/\" ) ) {\n        endpoint.setAddress( endpoint.getAddress().replaceAll( \"Eucalyptus/\", \"Eucalyptus\" ) );\n        httpRequest.setPureClient( true );\n      }\n      //:: fixes handling of arguments in POST :://\n      if( (messageContext.getProperty( HTTPConstants.HTTP_METHOD )).equals( HTTPConstants.HTTP_METHOD_POST )) {\n        BufferedReader in = new BufferedReader( new InputStreamReader( ( InputStream ) messageContext.getProperty( MessageContext.TRANSPORT_IN ) ) );\n        String postLine = in.readLine();\n        endpoint.setAddress( endpoint.getAddress() + (endpoint.getAddress().contains( \"?\" ) ? \"&\" : \"?\" ) + postLine );\n      }\n      URL url = new URL( \"http://my.flavourite.host.com\" + endpoint.getAddress() );\n      httpRequest.setHostAddr( (String) messageContext.getProperty( MessageContext.TRANSPORT_ADDR ) );\n      httpRequest.setRequestURL( messageContext.getTo().getAddress() );\n\n      //:: mangle the service path :://\n      String serviceContextPath = messageContext.getConfigurationContext().getServiceContextPath();\n      String serviceBasePath = url.toURI().getPath().substring( serviceContextPath.length() );\n\n      String serviceName = serviceBasePath.split( \"/\" )[ 1 ];\n      httpRequest.setService( serviceName );\n\n      String serviceAddress = serviceContextPath + \"/\" + serviceName;\n      httpRequest.setServicePath( serviceAddress );\n\n      messageContext.setTo( endpoint );\n\n      //:: extract query parameters :://\n      String restQuery = url.toURI().getQuery();\n      Map<String, String> httpParams = new HashMap<String, String>();\n      if ( restQuery != null )\n        for ( String p : restQuery.split( \"&\" ) ) {\n          String[] splitParam = p.split( \"=\" );\n          httpParams.put( splitParam[ 0 ], splitParam.length == 2 ? splitParam[ 1 ] : null );\n        }\n      httpRequest.setParameters( httpParams );\n\n      //:: extract the additional path components :://\n      String restPath = url.toURI().getPath().replaceAll( serviceAddress, \"\" );\n      httpRequest.setOperationPath( restPath );\n\n      //:: set the input stream for later use :://\n      httpRequest.setInStream( ( InputStream ) messageContext.getProperty( MessageContext.TRANSPORT_IN ) );\n\n      //:: get the HTTP headers :://\n      httpRequest.setHeaders( ( Map<String, String> ) messageContext.getProperty( MessageContext.TRANSPORT_HEADERS ) );\n\n      //:: and set the HTTP method type of the request :://\n      httpRequest.setHttpMethod( ( String ) messageContext.getProperty( HTTPConstants.HTTP_METHOD ) );\n\n      //:: remove the security phase since we arent doing WS-Security :://\n      if ( messageContext.getExecutionChain().size() > 2 )\n        messageContext.getExecutionChain().remove( 2 );\n\n      //:: store the httprequest in the msgctx :://\n      messageContext.setProperty( HTTP_REQUEST, httpRequest );\n    }\n    catch ( Exception e ) {\n      LOG.error( e, e );\n      throw AxisFault.makeFault( e );\n    }\n  }","id":33713,"modified_method":"private void prepareRequest( final MessageContext messageContext ) throws AxisFault {\n    try {\n      HttpRequest httpRequest = new HttpRequest();\n      EndpointReference endpoint = messageContext.getTo();\n      //:: fixes trailing '/' added by some clients :://\n      if( endpoint.getAddress().endsWith( \"Eucalyptus/\" ) ) {\n        endpoint.setAddress( endpoint.getAddress().replaceAll( \"Eucalyptus/\", \"Eucalyptus\" ) );\n        httpRequest.setPureClient( true );\n      }\n\n      //:: fixes handling of arguments in POST :://\n      if( (messageContext.getProperty( HTTPConstants.HTTP_METHOD )).equals( HTTPConstants.HTTP_METHOD_POST )) {\n        BufferedReader in = new BufferedReader( new InputStreamReader( ( InputStream ) messageContext.getProperty( MessageContext.TRANSPORT_IN ) ) );\n        String postLine = in.readLine();\n        endpoint.setAddress( endpoint.getAddress() + (endpoint.getAddress().contains( \"?\" ) ? \"&\" : \"?\" ) + postLine );\n      }\n      URL url = new URL( \"http://my.flavourite.host.com\" + endpoint.getAddress() );\n      httpRequest.setHostAddr( (String) messageContext.getProperty( MessageContext.TRANSPORT_ADDR ) );\n      httpRequest.setRequestURL( messageContext.getTo().getAddress() );\n\n      //:: mangle the service path :://\n      String serviceContextPath = messageContext.getConfigurationContext().getServiceContextPath();\n      String serviceBasePath = url.toURI().getPath().substring( serviceContextPath.length() );\n\n      String serviceName = serviceBasePath.split( \"/\" )[ 1 ];\n      httpRequest.setService( serviceName );\n\n      String serviceAddress = serviceContextPath + \"/\" + serviceName;\n      httpRequest.setServicePath( serviceAddress );\n\n      messageContext.setTo( endpoint );\n\n      //:: extract query parameters :://\n      String restQuery = url.toURI().getQuery();\n      Map<String, String> httpParams = new HashMap<String, String>();\n      if ( restQuery != null )\n        for ( String p : restQuery.split( \"&\" ) ) {\n          String[] splitParam = p.split( \"=\" );\n          httpParams.put( splitParam[ 0 ], splitParam.length == 2 ? splitParam[ 1 ] : null );\n        }\n      httpRequest.setParameters( httpParams );\n\n      //:: extract the additional path components :://\n      String restPath = url.toURI().getPath().replaceAll( serviceAddress, \"\" );\n      httpRequest.setOperationPath( restPath );\n\n      //:: set the input stream for later use :://\n      httpRequest.setInStream( ( InputStream ) messageContext.getProperty( MessageContext.TRANSPORT_IN ) );\n\n      //:: get the HTTP headers :://\n      httpRequest.setHeaders( ( Map<String, String> ) messageContext.getProperty( MessageContext.TRANSPORT_HEADERS ) );\n\n      //:: and set the HTTP method type of the request :://\n      httpRequest.setHttpMethod( ( String ) messageContext.getProperty( HTTPConstants.HTTP_METHOD ) );\n\n      //:: remove the security phase since we arent doing WS-Security :://\n      if ( messageContext.getExecutionChain().size() > 2 )\n        messageContext.getExecutionChain().remove( 2 );\n\n      //:: store the httprequest in the msgctx :://\n      messageContext.setProperty( HTTP_REQUEST, httpRequest );\n    }\n    catch ( Exception e ) {\n      LOG.error( e, e );\n      throw AxisFault.makeFault( e );\n    }\n  }","commit_id":"bc943aefe937d1ab0f943144e640ca88cf7b749f","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public AxisOperation findOperation( AxisService service, MessageContext messageContext ) throws AxisFault {\n    if ( !( this instanceof RESTfulDispatcher ) ) return null;\n\n    RESTfulDispatcher dispatcher = ( RESTfulDispatcher ) this;\n\n    HttpRequest httpRequest = ( HttpRequest ) messageContext.getProperty( HTTP_REQUEST );\n    if ( httpRequest == null ) return null; // bail out to avoid messing with the message context.\n\n    //:: test if this dispatcher accepts this request type :://\n    if ( !dispatcher.accepts( httpRequest, messageContext ) ) return null;\n\n    String maybeVersion = httpRequest.getParameters().get( Axis2QueryDispatcher.RequiredQueryParams.Version.toString() );\n    String nameSpace = dispatcher.getNamespace();\n    if ( maybeVersion != null )\n      nameSpace = nameSpace.replaceAll( dispatcher.getBinding().getName(), maybeVersion );\n    //:: set the operation name... this looks ugly... sigh :://\n      String operationName;\n      try {\n        operationName = dispatcher.getOperation( httpRequest, messageContext );\n      } catch(Exception ex) {\n          throw new AxisFault(\"Could not process operation\\n\" + ex.getMessage());\n      }\n    httpRequest.setOperation( operationName );\n    httpRequest.setBindingName( BindingUtil.sanitizeNamespace( dispatcher.getNamespace() ) );\n\n    QuerySecurityHandler securityHandler = dispatcher.getSecurityHandler();\n    UserInfo user = securityHandler.authenticate( httpRequest );\n\n    //:: setup & verify the operation  :://\n    if ( httpRequest.getOperation() == null )\n      throw new AxisFault( \"Protocol failure: Could not identify the operation component of the request.\" ); //this is a dispatcher failure, shouldn't have \"accept()\"ed the request\n\n    //:: find the operation :://\n    AxisOperation operation = service.getOperationByAction( httpRequest.getOperation() );\n    if ( operation == null )\n      throw new AxisFault( \"Failed to process the request: Operation doesnt exist: \" + httpRequest.getOperation() ); //this is a user failure, incorrectly specified Operation perhaps?\n\n    //:: consume the request and turn it into a SOAP envelope :://\n    QueryBinding binding = dispatcher.getBinding();\n    OMElement msg = binding.bind( user, httpRequest, messageContext );\n    messageContext.getEnvelope().getBody().addChild( msg );\n\n    //:: massage rampart so it doesnt interfere :://\n    Policy p = new Policy();\n    messageContext.setProperty( RampartMessageData.KEY_RAMPART_POLICY, p );\n\n    return operation;\n  }","id":33714,"modified_method":"public AxisOperation findOperation( AxisService service, MessageContext messageContext ) throws AxisFault {\n    if ( !( this instanceof RESTfulDispatcher ) ) return null;\n\n    RESTfulDispatcher dispatcher = ( RESTfulDispatcher ) this;\n\n    HttpRequest httpRequest = ( HttpRequest ) messageContext.getProperty( HTTP_REQUEST );\n    if ( httpRequest == null ) return null; // bail out to avoid messing with the message context.\n\n    //:: test if this dispatcher accepts this request type :://\n    if ( !dispatcher.accepts( httpRequest, messageContext ) ) return null;\n\n    String maybeVersion = httpRequest.getParameters().get( Axis2QueryDispatcher.RequiredQueryParams.Version.toString() );\n    String nameSpace = dispatcher.getNamespace();\n    if ( maybeVersion != null )\n      nameSpace = nameSpace.replaceAll( dispatcher.getBinding().getName(), maybeVersion );\n    //:: set the operation name... this looks ugly... sigh :://\n      String operationName;\n      try {\n        operationName = dispatcher.getOperation( httpRequest, messageContext );\n      } catch(Exception ex) {\n          throw new AxisFault(\"Could not process operation\\n\" + ex.getMessage());\n      }\n    httpRequest.setOperation( operationName );\n    httpRequest.setBindingName( BindingUtil.sanitizeNamespace( dispatcher.getNamespace() ) );\n\n    QuerySecurityHandler securityHandler = dispatcher.getSecurityHandler();\n    UserInfo user = securityHandler.authenticate( httpRequest );\n\n    //:: setup & verify the operation  :://\n    if ( httpRequest.getOperation() == null )\n      throw new AxisFault( \"Protocol failure: Could not identify the operation component of the request.\" ); //this is a dispatcher failure, shouldn't have \"accept()\"ed the request\n\n    //:: find the operation :://\n    AxisOperation operation = service.getOperationByAction( httpRequest.getOperation().replaceAll(\"/*\",\"\") );\n    if ( operation == null )\n      throw new AxisFault( \"Failed to process the request: Operation doesnt exist: \" + httpRequest.getOperation() ); //this is a user failure, incorrectly specified Operation perhaps?\n\n    //:: consume the request and turn it into a SOAP envelope :://\n    QueryBinding binding = dispatcher.getBinding();\n    OMElement msg = binding.bind( user, httpRequest, messageContext );\n    messageContext.getEnvelope().getBody().addChild( msg );\n\n    //:: massage rampart so it doesnt interfere :://\n    Policy p = new Policy();\n    messageContext.setProperty( RampartMessageData.KEY_RAMPART_POLICY, p );\n\n    return operation;\n  }","commit_id":"bc943aefe937d1ab0f943144e640ca88cf7b749f","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DirectoryReport getHtml() {\n        return getByName(\"html\");\n    }","id":33715,"modified_method":"public DirectoryReport getHtml() {\n        return (DirectoryReport)getByName(\"html\");\n    }","commit_id":"ac13c1c69ed3272a21ce5be8a429b55feee11356","url":"https://github.com/gradle/gradle"},{"original_method":"public ConfigureableReport getHtml() {\n        return getByName(\"html\");\n    }","id":33716,"modified_method":"public DirectoryReport getHtml() {\n        return (DirectoryReport)getByName(\"html\");\n    }","commit_id":"ac13c1c69ed3272a21ce5be8a429b55feee11356","url":"https://github.com/gradle/gradle"},{"original_method":"public ConfigureableReport getXml() {\n        return getByName(\"xml\");\n    }","id":33717,"modified_method":"public SingleFileReport getXml() {\n        return (SingleFileReport)getByName(\"xml\");\n    }","commit_id":"ac13c1c69ed3272a21ce5be8a429b55feee11356","url":"https://github.com/gradle/gradle"},{"original_method":"public ConfigureableReport getCsv() {\n        return getByName(\"csv\");\n    }","id":33718,"modified_method":"public SingleFileReport getCsv() {\n        return (SingleFileReport)getByName(\"csv\");\n    }","commit_id":"ac13c1c69ed3272a21ce5be8a429b55feee11356","url":"https://github.com/gradle/gradle"},{"original_method":"public SingleFileReport getHtml() {\n        return getByName(\"html\");\n    }","id":33719,"modified_method":"public CheckstyleHtmlReport getHtml() {\n        return (CheckstyleHtmlReport) getByName(\"html\");\n    }","commit_id":"12de2045fea546a8f63f55e0a30ddc90454d8936","url":"https://github.com/gradle/gradle"},{"original_method":"public CheckstyleReportsImpl(Task task) {\n        super(SingleFileReport.class, task);\n\n        add(TaskGeneratedSingleFileReport.class, \"html\", task);\n        add(TaskGeneratedSingleFileReport.class, \"xml\", task);\n    }","id":33720,"modified_method":"public CheckstyleReportsImpl(Task task) {\n        super(SingleFileReport.class, task);\n\n        add(CheckstyleHtmlReportImpl.class, \"html\", task);\n        add(TaskGeneratedSingleFileReport.class, \"xml\", task);\n    }","commit_id":"12de2045fea546a8f63f55e0a30ddc90454d8936","url":"https://github.com/gradle/gradle"},{"original_method":"public SingleFileReport getHtml() {\n        return getByName(\"html\");\n    }","id":33721,"modified_method":"public FindBugsHtmlReport getHtml() {\n        return (FindBugsHtmlReport) getByName(\"html\");\n    }","commit_id":"7caec7fd5379db1a804dc4a37b7fc488a98aaf3d","url":"https://github.com/gradle/gradle"},{"original_method":"public FindBugsReportsImpl(Task task) {\n        super(SingleFileReport.class, task);\n\n        add(FindBugsXmlReportImpl.class, \"xml\", task);\n        add(TaskGeneratedSingleFileReport.class, \"html\", task);\n        add(TaskGeneratedSingleFileReport.class, \"text\", task);\n        add(TaskGeneratedSingleFileReport.class, \"emacs\", task);\n    }","id":33722,"modified_method":"public FindBugsReportsImpl(Task task) {\n        super(SingleFileReport.class, task);\n\n        add(FindBugsXmlReportImpl.class, \"xml\", task);\n        add(FindBugsHtmlReportImpl.class, \"html\", task);\n        add(TaskGeneratedSingleFileReport.class, \"text\", task);\n        add(TaskGeneratedSingleFileReport.class, \"emacs\", task);\n    }","commit_id":"7caec7fd5379db1a804dc4a37b7fc488a98aaf3d","url":"https://github.com/gradle/gradle"},{"original_method":"public FindBugsSpec build() {\n        ArrayList<String> args = new ArrayList<String>();\n        args.add(\"-pluginList\");\n        args.add(pluginsList==null ? \"\" : pluginsList.getAsPath());\n        args.add(\"-sortByClass\");\n        args.add(\"-timestampNow\");\n        args.add(\"-progress\");\n\n        if (reports != null && !reports.getEnabled().isEmpty()) {\n            if (reports.getEnabled().size() == 1) {\n                FindBugsReportsImpl reportsImpl = (FindBugsReportsImpl) reports;\n                String outputArg = \"-\" + reportsImpl.getFirstEnabled().getName();\n                if (reportsImpl.getFirstEnabled() instanceof FindBugsXmlReportImpl) {\n                    FindBugsXmlReportImpl r = (FindBugsXmlReportImpl)reportsImpl.getFirstEnabled();\n                    if (r.isWithMessages()) {\n                        outputArg += \":withMessages\";\n                    }\n                }\n                args.add(outputArg);\n                args.add(\"-outputFile\");\n                args.add(reportsImpl.getFirstEnabled().getDestination().getAbsolutePath());\n            } else {\n                throw new InvalidUserDataException(\"FindBugs tasks can only have one report enabled, however more than one report was enabled. You need to disable all but one of them.\");\n            }\n        }\n\n        if (has(sources)) {\n            args.add(\"-sourcepath\");\n            args.add(sources.getAsPath());\n        }\n\n        if (has(classpath)) {\n            args.add(\"-auxclasspath\");\n\n            // Filter unexisting files as FindBugs can't handle them.\n            args.add(classpath.filter(new Spec<File>() {\n                public boolean isSatisfiedBy(File element) {\n                    return element.exists();\n                }\n            }).getAsPath());\n        }\n\n        if (has(effort)) {\n            args.add(String.format(\"-effort:%s\", effort));\n        }\n\n        if (has(reportLevel)) {\n            args.add(String.format(\"-%s\", reportLevel));\n        }\n\n        if (has(visitors)) {\n            args.add(\"-visitors\");\n            args.add(CollectionUtils.join(\",\", visitors));\n        }\n\n        if (has(omitVisitors)) {\n            args.add(\"-omitVisitors\");\n            args.add(CollectionUtils.join(\",\", omitVisitors));\n        }\n\n        if (has(excludeFilter)) {\n            args.add(\"-exclude\");\n            args.add(excludeFilter.getPath());\n        }\n\n        if (has(includeFilter)) {\n            args.add(\"-include\");\n            args.add(includeFilter.getPath());\n        }\n\n        if (has(excludeBugsFilter)) {\n            args.add(\"-excludeBugs\");\n            args.add(excludeBugsFilter.getPath());\n        }\n\n        if (has(extraArgs)) {\n            args.addAll(extraArgs);\n        }\n\n        for (File classFile : classes.getFiles()) {\n            args.add(classFile.getAbsolutePath());\n        }\n\n        return new FindBugsSpec(args, maxHeapSize, debugEnabled);\n    }","id":33723,"modified_method":"public FindBugsSpec build() {\n        ArrayList<String> args = new ArrayList<String>();\n        args.add(\"-pluginList\");\n        args.add(pluginsList==null ? \"\" : pluginsList.getAsPath());\n        args.add(\"-sortByClass\");\n        args.add(\"-timestampNow\");\n        args.add(\"-progress\");\n\n        if (reports != null && !reports.getEnabled().isEmpty()) {\n            if (reports.getEnabled().size() == 1) {\n                FindBugsReportsImpl reportsImpl = (FindBugsReportsImpl) reports;\n                String outputArg = \"-\" + reportsImpl.getFirstEnabled().getName();\n                if (reportsImpl.getFirstEnabled() instanceof FindBugsXmlReportImpl) {\n                    FindBugsXmlReportImpl r = (FindBugsXmlReportImpl) reportsImpl.getFirstEnabled();\n                    if (r.isWithMessages()) {\n                        outputArg += \":withMessages\";\n                    }\n                } else if (reportsImpl.getFirstEnabled() instanceof FindBugsHtmlReportImpl) {\n                    FindBugsHtmlReportImpl r = (FindBugsHtmlReportImpl) reportsImpl.getFirstEnabled();\n                    if (!Strings.isNullOrEmpty(r.getStylesheet())) {\n                        outputArg += ':' + r.getStylesheet();\n                    }\n                }\n                args.add(outputArg);\n                args.add(\"-outputFile\");\n                args.add(reportsImpl.getFirstEnabled().getDestination().getAbsolutePath());\n            } else {\n                throw new InvalidUserDataException(\"FindBugs tasks can only have one report enabled, however more than one report was enabled. You need to disable all but one of them.\");\n            }\n        }\n\n        if (has(sources)) {\n            args.add(\"-sourcepath\");\n            args.add(sources.getAsPath());\n        }\n\n        if (has(classpath)) {\n            args.add(\"-auxclasspath\");\n\n            // Filter unexisting files as FindBugs can't handle them.\n            args.add(classpath.filter(new Spec<File>() {\n                public boolean isSatisfiedBy(File element) {\n                    return element.exists();\n                }\n            }).getAsPath());\n        }\n\n        if (has(effort)) {\n            args.add(String.format(\"-effort:%s\", effort));\n        }\n\n        if (has(reportLevel)) {\n            args.add(String.format(\"-%s\", reportLevel));\n        }\n\n        if (has(visitors)) {\n            args.add(\"-visitors\");\n            args.add(CollectionUtils.join(\",\", visitors));\n        }\n\n        if (has(omitVisitors)) {\n            args.add(\"-omitVisitors\");\n            args.add(CollectionUtils.join(\",\", omitVisitors));\n        }\n\n        if (has(excludeFilter)) {\n            args.add(\"-exclude\");\n            args.add(excludeFilter.getPath());\n        }\n\n        if (has(includeFilter)) {\n            args.add(\"-include\");\n            args.add(includeFilter.getPath());\n        }\n\n        if (has(excludeBugsFilter)) {\n            args.add(\"-excludeBugs\");\n            args.add(excludeBugsFilter.getPath());\n        }\n\n        if (has(extraArgs)) {\n            args.addAll(extraArgs);\n        }\n\n        for (File classFile : classes.getFiles()) {\n            args.add(classFile.getAbsolutePath());\n        }\n\n        return new FindBugsSpec(args, maxHeapSize, debugEnabled);\n    }","commit_id":"7caec7fd5379db1a804dc4a37b7fc488a98aaf3d","url":"https://github.com/gradle/gradle"},{"original_method":"/** {@inheritDoc} */\n    public void handleResponse(InetAddress address, ICMPEchoPacket packet) {\n        EventBuilder eb = new EventBuilder(EventConstants.NEW_SUSPECT_INTERFACE_EVENT_UEI, EVENT_SOURCE_VALUE);\n        eb.setInterface(address);\n\n        try {\n            eb.setHost(InetAddress.getLocalHost().getHostName());\n        } catch (UnknownHostException uhE) {\n            eb.setHost(\"unresolved.host\");\n            log().warn(\"Failed to resolve local hostname\", uhE);\n        }\n\n        eb.addParam(\"RTT\", packet.getReceivedTime() - packet.getSentTime());\n\n        try {\n            EventIpcManagerFactory.getIpcManager().sendNow(eb.getEvent());\n\n            if (log().isDebugEnabled()) {\n                log().debug(\"Sent event: \" + EventConstants.NEW_SUSPECT_INTERFACE_EVENT_UEI);\n            }\n        } catch (Throwable t) {\n            log().warn(\"run: unexpected throwable exception caught during send to middleware\", t);\n        }\n\n    }","id":33724,"modified_method":"/** {@inheritDoc} */\n    public void handleResponse(InetAddress address, ICMPEchoPacket packet) {\n        EventBuilder eb = new EventBuilder(EventConstants.NEW_SUSPECT_INTERFACE_EVENT_UEI, EVENT_SOURCE_VALUE);\n        eb.setInterface(address);\n\n        try {\n            eb.setHost(InetAddress.getLocalHost().getHostName());\n        } catch (UnknownHostException uhE) {\n            eb.setHost(\"unresolved.host\");\n            log().warn(\"Failed to resolve local hostname\", uhE);\n        }\n\n        eb.addParam(\"RTT\", packet.getReceivedTimeNanos() - packet.getSentTimeNanos());\n\n        try {\n            EventIpcManagerFactory.getIpcManager().sendNow(eb.getEvent());\n\n            if (log().isDebugEnabled()) {\n                log().debug(\"Sent event: \" + EventConstants.NEW_SUSPECT_INTERFACE_EVENT_UEI);\n            }\n        } catch (Throwable t) {\n            log().warn(\"run: unexpected throwable exception caught during send to middleware\", t);\n        }\n\n    }","commit_id":"5c5b1e254b5585b477b8d36ef059719981dc4650","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public int getIdentifier() {\n        return getUnsignedShort(4);\n    }","id":33725,"modified_method":"public long getIdentifier() {\n        return getUnsignedShort(4);\n    }","commit_id":"5c5b1e254b5585b477b8d36ef059719981dc4650","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public int getIdentifier() {\n        return getUnsignedShort(4);\n    }","id":33726,"modified_method":"public long getIdentifier() {\n        return getUnsignedShort(4);\n    }","commit_id":"5c5b1e254b5585b477b8d36ef059719981dc4650","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public int getSequenceId() {\n        return m_delegate.getSequenceId();\n    }","id":33727,"modified_method":"@Override\n    public int getSequenceNumber() {\n        return m_delegate.getSequenceId();\n    }","commit_id":"5c5b1e254b5585b477b8d36ef059719981dc4650","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public long getReceivedTime() {\n        return m_delegate.getReceivedTime();\n    }","id":33728,"modified_method":"@Override\n    public long getReceivedTimeNanos() {\n        return m_delegate.getReceivedTime();\n    }","commit_id":"5c5b1e254b5585b477b8d36ef059719981dc4650","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public long getSentTime() {\n        return m_delegate.getSentTime();\n    }","id":33729,"modified_method":"@Override\n    public long getSentTimeNanos() {\n        return m_delegate.getSentTime();\n    }","commit_id":"5c5b1e254b5585b477b8d36ef059719981dc4650","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testICMPPacketGets() throws Exception {\n        \n        IPPacket pkt = new IPPacket(ip, 0, ip.length);\n        assertThat(pkt.getProtocol(), is(equalTo(Protocol.ICMP)));\n        \n        // payload 64 bytes: ICMP header (8 bytes) followed by byte values 1, 2, 3, ... 55, 56 \n        ByteBuffer payload = pkt.getPayload();\n        ICMPPacket icmpPacket = new ICMPPacket(payload);\n        assertThat(icmpPacket.getType(), is(equalTo(Type.EchoReply)));\n        assertThat(icmpPacket.getCode(), is(equalTo(0)));\n        assertThat(icmpPacket.getChecksum(), is(equalTo(24310)));\n        assertThat(icmpPacket.getChecksum(), is(equalTo(icmpPacket.computeChecksum())));\n        \n        ICMPEchoPacket echoReply = new ICMPEchoPacket(icmpPacket);\n        assertThat(echoReply.getIdentifier(), is(equalTo(43260)));\n        assertThat(echoReply.getSequenceNumber(), is(equalTo(250)));\n        \n        ByteBuffer content = echoReply.getContentBuffer();\n        for(int i = 0; i < 56; i++) {\n            assertThat(content.get(i), is(equalTo((byte)i)));\n        }\n        \n    }","id":33730,"modified_method":"@Test\n    public void testICMPPacketGets() throws Exception {\n        \n        IPPacket pkt = new IPPacket(ip, 0, ip.length);\n        assertThat(pkt.getProtocol(), is(equalTo(Protocol.ICMP)));\n        \n        // payload 64 bytes: ICMP header (8 bytes) followed by byte values 1, 2, 3, ... 55, 56 \n        ByteBuffer payload = pkt.getPayload();\n        ICMPPacket icmpPacket = new ICMPPacket(payload);\n        assertThat(icmpPacket.getType(), is(equalTo(Type.EchoReply)));\n        assertThat(icmpPacket.getCode(), is(equalTo(0)));\n        assertThat(icmpPacket.getChecksum(), is(equalTo(24310)));\n        assertThat(icmpPacket.getChecksum(), is(equalTo(icmpPacket.computeChecksum())));\n        \n        ICMPEchoPacket echoReply = new ICMPEchoPacket(icmpPacket);\n        assertThat(echoReply.getIdentifier(), is(equalTo(43260L)));\n        assertThat(echoReply.getSequenceNumber(), is(equalTo(250)));\n        \n        ByteBuffer content = echoReply.getContentBuffer();\n        for(int i = 0; i < 56; i++) {\n            assertThat(content.get(i), is(equalTo((byte)i)));\n        }\n        \n    }","commit_id":"5c5b1e254b5585b477b8d36ef059719981dc4650","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n    public void handleTimeout(InetAddress address, ICMPEchoPacket packet) {\n        m_responseTimes[packet.getSequenceId()] = null;\n        bs.signalAll();\n    }","id":33731,"modified_method":"/** {@inheritDoc} */\n    public void handleTimeout(InetAddress address, ICMPEchoPacket packet) {\n        m_responseTimes[packet.getSequenceNumber()] = null;\n        bs.signalAll();\n    }","commit_id":"5c5b1e254b5585b477b8d36ef059719981dc4650","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n    public void handleResponse(InetAddress address, ICMPEchoPacket packet) {\n        m_responseTimes[packet.getSequenceId()] = packet.getPingRTT();\n        bs.signalAll();\n    }","id":33732,"modified_method":"/** {@inheritDoc} */\n    public void handleResponse(InetAddress address, ICMPEchoPacket packet) {\n        m_responseTimes[packet.getSequenceNumber()] = packet.elapsedTime(TimeUnit.NANOSECONDS);\n        bs.signalAll();\n    }","commit_id":"5c5b1e254b5585b477b8d36ef059719981dc4650","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n    public void handleError(InetAddress address, ICMPEchoPacket packet, Throwable t) {\n        m_responseTimes[packet.getSequenceId()] = null;\n        bs.signalAll();\n    }","id":33733,"modified_method":"/** {@inheritDoc} */\n    public void handleError(InetAddress address, ICMPEchoPacket packet, Throwable t) {\n        m_responseTimes[packet.getSequenceNumber()] = null;\n        bs.signalAll();\n    }","commit_id":"5c5b1e254b5585b477b8d36ef059719981dc4650","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Thread pingThead(final V4Pinger listener, final int id, final int count) {\n        return new Thread() {\n            public void run() {\n                try {\n                    Thread.sleep(id/10);\n                    listener.ping(InetAddress.getByName(\"127.0.0.1\"), id, count, 1000);\n                } catch(Throwable e) {\n                    e.printStackTrace();\n                }\n            }\n        };\n    }","id":33734,"modified_method":"private Thread pingThead(final V4Pinger listener, final int id, final int count) {\n        return new Thread() {\n            public void run() {\n                try {\n                    Thread.sleep(id/10);\n                    listener.ping((Inet4Address)InetAddress.getByName(\"127.0.0.1\"), id, count, 1000);\n                } catch(Throwable e) {\n                    e.printStackTrace();\n                }\n            }\n        };\n    }","commit_id":"5c5b1e254b5585b477b8d36ef059719981dc4650","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testMultiThreadSocketUse() throws Exception {\n        int pingCount = 10;\n        V4Pinger listener = new V4Pinger();\n        try {\n        listener.start();\n        \n        listener.ping(InetAddress.getByName(\"127.0.0.1\"), 1000, pingCount, 1000);\n        \n        } finally {\n            listener.stop();\n            listener.closeSocket();\n            \n        }\n    }","id":33735,"modified_method":"@Test\n    public void testMultiThreadSocketUse() throws Exception {\n        int pingCount = 10;\n        V4Pinger listener = new V4Pinger();\n        try {\n        listener.start();\n        \n        listener.ping((Inet4Address)InetAddress.getByName(\"127.0.0.1\"), 1000, pingCount, 1000);\n        \n        } finally {\n            listener.stop();\n            listener.closeSocket();\n            \n        }\n    }","commit_id":"5c5b1e254b5585b477b8d36ef059719981dc4650","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * Ping a remote host, using the default number of retries and timeouts.\n\t *\n\t * @param host the host to ping\n\t * @return the round-trip time of the packet\n\t * @throws IOException if any.\n\t * @throws InterruptedException if any.\n\t * @throws java.lang.Exception if any.\n\t */\n\tpublic Long ping(InetAddress host) throws Exception {\n        SinglePingResponseCallback cb = new SinglePingResponseCallback(host);\n        ping(host, DEFAULT_TIMEOUT, DEFAULT_RETRIES, (short)1, cb);\n        cb.waitFor();\n        return cb.getResponseTime();\n\t}","id":33736,"modified_method":"/**\n\t * Ping a remote host, using the default number of retries and timeouts.\n\t *\n\t * @param host the host to ping\n\t * @return the round-trip time of the packet\n\t * @throws IOException if any.\n\t * @throws InterruptedException if any.\n\t * @throws java.lang.Exception if any.\n\t */\n\tpublic Long ping(InetAddress host) throws Exception {\n        return ping(host, DEFAULT_TIMEOUT, DEFAULT_RETRIES);\n\t}","commit_id":"5c5b1e254b5585b477b8d36ef059719981dc4650","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n    public void handleTimeout(InetAddress address, ICMPEchoPacket packet) {\n        info(\"timed out pinging address \" + address + \", thread \" + packet.getTID() + \", seq \" + packet.getSequenceId());\n        bs.signalAll();\n    }","id":33737,"modified_method":"/** {@inheritDoc} */\n    public void handleTimeout(InetAddress address, ICMPEchoPacket packet) {\n        info(\"timed out pinging address \" + address + \", thread \" + packet.getIdentifier() + \", seq \" + packet.getSequenceNumber());\n        bs.signalAll();\n    }","commit_id":"5c5b1e254b5585b477b8d36ef059719981dc4650","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n    public void handleResponse(InetAddress address, ICMPEchoPacket packet) {\n        info(\"got response for address \" + address + \", thread \" + packet.getTID() + \", seq \" + packet.getSequenceId() + \" with a responseTime \"+packet.getPingRTT());\n        responseTime = packet.getPingRTT();\n        bs.signalAll();\n    }","id":33738,"modified_method":"/** {@inheritDoc} */\n    public void handleResponse(InetAddress address, ICMPEchoPacket packet) {\n        info(\"got response for address \" + address + \", thread \" + packet.getIdentifier() + \", seq \" + packet.getSequenceNumber() + \" with a responseTime \"+packet.elapsedTime(TimeUnit.NANOSECONDS));\n        responseTime = packet.elapsedTime(TimeUnit.NANOSECONDS);\n        bs.signalAll();\n    }","commit_id":"5c5b1e254b5585b477b8d36ef059719981dc4650","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void ping(InetAddress addr, int id, int count, int interval) throws InterruptedException {\n        NativeDatagramSocket socket = getPingSocket();\n        for(int i = 0; i <= count; i++) {\n            PingRequest request = new PingRequest(id, i);\n            request.send(socket, addr);\n            Thread.sleep(interval);\n        }\n        \n        //round-trip cnt/min/avg/max/stddev = 10/0.053/0.137/0.233/0.038 ms\n        printf(\"round-trip %s ms\\n\", m_metric.getSummary(TimeUnit.MILLISECONDS));\n\n    }","id":33739,"modified_method":"public void ping(Inet4Address addr, int id, int count, int interval) throws InterruptedException {\n        NativeDatagramSocket socket = getPingSocket();\n        for(int i = 0; i <= count; i++) {\n            PingRequest request = new PingRequest(id, i);\n            request.send(socket, addr);\n            Thread.sleep(interval);\n        }\n        \n        //round-trip cnt/min/avg/max/stddev = 10/0.053/0.137/0.233/0.038 ms\n        printf(\"round-trip %s ms\\n\", m_metric.getSummary(TimeUnit.MILLISECONDS));\n\n    }","commit_id":"5c5b1e254b5585b477b8d36ef059719981dc4650","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void ping(InetAddress addr, int id, int count, int interval) throws InterruptedException {\n        NativeDatagramSocket socket = getPingSocket();\n        for(int i = 0; i <= count; i++) {\n            PingRequest request = new PingRequest(id, i);\n            request.send(socket, addr);\n            Thread.sleep(interval);\n        }\n        \n        //round-trip cnt/min/avg/max/stddev = 10/0.053/0.137/0.233/0.038 ms\n        printf(\"round-trip %s ms\\n\", m_metric.getSummary(TimeUnit.MILLISECONDS));\n\n    }","id":33740,"modified_method":"public void ping(Inet6Address addr, int id, int count, int interval) throws InterruptedException {\n        NativeDatagramSocket socket = getPingSocket();\n        for(int i = 0; i <= count; i++) {\n            PingRequest request = new PingRequest(id, i);\n            request.send(socket, addr);\n            Thread.sleep(interval);\n        }\n        \n        //round-trip cnt/min/avg/max/stddev = 10/0.053/0.137/0.233/0.038 ms\n        printf(\"round-trip %s ms\\n\", m_metric.getSummary(TimeUnit.MILLISECONDS));\n\n    }","commit_id":"5c5b1e254b5585b477b8d36ef059719981dc4650","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public SingleFileReport getXml() {\n        return getByName(\"xml\");\n    }","id":33741,"modified_method":"public FindBugsXmlReport getXml() {\n        return (FindBugsXmlReport) getByName(\"xml\");\n    }","commit_id":"76767a86be32d02ef51d1e1fe708cf3032ed6dc0","url":"https://github.com/gradle/gradle"},{"original_method":"public FindBugsReportsImpl(Task task) {\n        super(SingleFileReport.class, task);\n\n        add(TaskGeneratedSingleFileReport.class, \"xml\", task);\n        add(TaskGeneratedSingleFileReport.class, \"html\", task);\n    }","id":33742,"modified_method":"public FindBugsReportsImpl(Task task) {\n        super(SingleFileReport.class, task);\n\n        add(FindBugsXmlReportImpl.class, \"xml\", task);\n        add(TaskGeneratedSingleFileReport.class, \"html\", task);\n        add(TaskGeneratedSingleFileReport.class, \"text\", task);\n        add(TaskGeneratedSingleFileReport.class, \"emacs\", task);\n    }","commit_id":"76767a86be32d02ef51d1e1fe708cf3032ed6dc0","url":"https://github.com/gradle/gradle"},{"original_method":"public FindBugsSpec build() {\n        ArrayList<String> args = new ArrayList<String>();\n        args.add(\"-pluginList\");\n        args.add(pluginsList==null ? \"\" : pluginsList.getAsPath());\n        args.add(\"-sortByClass\");\n        args.add(\"-timestampNow\");\n        args.add(\"-progress\");\n\n        if (reports != null && !reports.getEnabled().isEmpty()) {\n            if (reports.getEnabled().size() == 1) {\n                FindBugsReportsImpl reportsImpl = (FindBugsReportsImpl) reports;\n                args.add(\"-\" + reportsImpl.getFirstEnabled().getName());\n                args.add(\"-outputFile\");\n                args.add(reportsImpl.getFirstEnabled().getDestination().getAbsolutePath());\n            } else {\n                throw new InvalidUserDataException(\"FindBugs tasks can only have one report enabled, however both the XML and HTML report are enabled. You need to disable one of them.\");\n            }\n        }\n\n        if (has(sources)) {\n            args.add(\"-sourcepath\");\n            args.add(sources.getAsPath());\n        }\n\n        if (has(classpath)) {\n            args.add(\"-auxclasspath\");\n\n            // Filter unexisting files as FindBugs can't handle them.\n            args.add(classpath.filter(new Spec<File>() {\n                public boolean isSatisfiedBy(File element) {\n                    return element.exists();\n                }\n            }).getAsPath());\n        }\n\n        if (has(effort)) {\n            args.add(String.format(\"-effort:%s\", effort));\n        }\n\n        if (has(reportLevel)) {\n            args.add(String.format(\"-%s\", reportLevel));\n        }\n\n        if (has(visitors)) {\n            args.add(\"-visitors\");\n            args.add(CollectionUtils.join(\",\", visitors));\n        }\n\n        if (has(omitVisitors)) {\n            args.add(\"-omitVisitors\");\n            args.add(CollectionUtils.join(\",\", omitVisitors));\n        }\n\n        if (has(excludeFilter)) {\n            args.add(\"-exclude\");\n            args.add(excludeFilter.getPath());\n        }\n\n        if (has(includeFilter)) {\n            args.add(\"-include\");\n            args.add(includeFilter.getPath());\n        }\n\n        for (File classFile : classes.getFiles()) {\n            args.add(classFile.getAbsolutePath());\n        }\n        \n        return new FindBugsSpec(args, maxHeapSize, debugEnabled);\n    }","id":33743,"modified_method":"public FindBugsSpec build() {\n        ArrayList<String> args = new ArrayList<String>();\n        args.add(\"-pluginList\");\n        args.add(pluginsList==null ? \"\" : pluginsList.getAsPath());\n        args.add(\"-sortByClass\");\n        args.add(\"-timestampNow\");\n        args.add(\"-progress\");\n\n        if (reports != null && !reports.getEnabled().isEmpty()) {\n            if (reports.getEnabled().size() == 1) {\n                FindBugsReportsImpl reportsImpl = (FindBugsReportsImpl) reports;\n                String outputArg = \"-\" + reportsImpl.getFirstEnabled().getName();\n                if (reportsImpl.getFirstEnabled() instanceof FindBugsXmlReportImpl) {\n                    FindBugsXmlReportImpl r = (FindBugsXmlReportImpl)reportsImpl.getFirstEnabled();\n                    if (r.isWithMessages()) {\n                        outputArg += \":withMessages\";\n                    }\n                }\n                args.add(outputArg);\n                args.add(\"-outputFile\");\n                args.add(reportsImpl.getFirstEnabled().getDestination().getAbsolutePath());\n            } else {\n                throw new InvalidUserDataException(\"FindBugs tasks can only have one report enabled, however more than one report was enabled. You need to disable all but one of them.\");\n            }\n        }\n\n        if (has(sources)) {\n            args.add(\"-sourcepath\");\n            args.add(sources.getAsPath());\n        }\n\n        if (has(classpath)) {\n            args.add(\"-auxclasspath\");\n\n            // Filter unexisting files as FindBugs can't handle them.\n            args.add(classpath.filter(new Spec<File>() {\n                public boolean isSatisfiedBy(File element) {\n                    return element.exists();\n                }\n            }).getAsPath());\n        }\n\n        if (has(effort)) {\n            args.add(String.format(\"-effort:%s\", effort));\n        }\n\n        if (has(reportLevel)) {\n            args.add(String.format(\"-%s\", reportLevel));\n        }\n\n        if (has(visitors)) {\n            args.add(\"-visitors\");\n            args.add(CollectionUtils.join(\",\", visitors));\n        }\n\n        if (has(omitVisitors)) {\n            args.add(\"-omitVisitors\");\n            args.add(CollectionUtils.join(\",\", omitVisitors));\n        }\n\n        if (has(excludeFilter)) {\n            args.add(\"-exclude\");\n            args.add(excludeFilter.getPath());\n        }\n\n        if (has(includeFilter)) {\n            args.add(\"-include\");\n            args.add(includeFilter.getPath());\n        }\n\n        for (File classFile : classes.getFiles()) {\n            args.add(classFile.getAbsolutePath());\n        }\n        \n        return new FindBugsSpec(args, maxHeapSize, debugEnabled);\n    }","commit_id":"76767a86be32d02ef51d1e1fe708cf3032ed6dc0","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * Create a microscheduler given the reads and reference.\n     *\n     * @param walker  the walker to execute with\n     * @param reads   The reads.\n     * @param reference The reference.\n     * @param rods    the rods to include in the traversal\n     * @param threadAllocation the allocation of threads to use in the underlying traversal\n     */\n    protected MicroScheduler(final GenomeAnalysisEngine engine,\n                             final Walker walker,\n                             final SAMDataSource reads,\n                             final IndexedFastaSequenceFile reference,\n                             final Collection<ReferenceOrderedDataSource> rods,\n                             final ThreadAllocation threadAllocation) {\n        this.engine = engine;\n        this.reads = reads;\n        this.reference = reference;\n        this.rods = rods;\n\n        final File progressLogFile = engine.getArguments() == null ? null : engine.getArguments().performanceLog;\n\n        // Creates uninitialized TraversalEngines appropriate for walker and threadAllocation,\n        // and adds it to the list of created engines for later shutdown.\n        for ( int i = 0; i < threadAllocation.getNumDataThreads(); i++ ) {\n            final TraversalEngine traversalEngine = createTraversalEngine(walker, threadAllocation);\n            allCreatedTraversalEngines.add(traversalEngine);\n            availableTraversalEngines.add(traversalEngine);\n        }\n\n        // Create our progress meter\n        this.progressMeter = new ProgressMeter(progressLogFile,\n                availableTraversalEngines.peek().getTraversalUnits(),\n                engine.getRegionsOfGenomeBeingProcessed());\n\n        // Now that we have a progress meter, go through and initialize the traversal engines\n        for ( final TraversalEngine traversalEngine : allCreatedTraversalEngines )\n            traversalEngine.initialize(engine, progressMeter);\n\n        // JMX does not allow multiple instances with the same ObjectName to be registered with the same platform MXBean.\n        // To get around this limitation and since we have no job identifier at this point, register a simple counter that\n        // will count the number of instances of this object that have been created in this JVM.\n        int thisInstance = instanceNumber++;\n        mBeanServer = ManagementFactory.getPlatformMBeanServer();\n        try {\n            mBeanName = new ObjectName(\"org.broadinstitute.sting.gatk.executive:type=MicroScheduler,instanceNumber=\"+thisInstance);\n            mBeanServer.registerMBean(this, mBeanName);\n        }\n        catch (JMException ex) {\n            throw new ReviewedStingException(\"Unable to register microscheduler with JMX\", ex);\n        }\n    }","id":33744,"modified_method":"/**\n     * Create a microscheduler given the reads and reference.\n     *\n     * @param walker  the walker to execute with\n     * @param reads   The reads.\n     * @param reference The reference.\n     * @param rods    the rods to include in the traversal\n     * @param threadAllocation the allocation of threads to use in the underlying traversal\n     */\n    protected MicroScheduler(final GenomeAnalysisEngine engine,\n                             final Walker walker,\n                             final SAMDataSource reads,\n                             final IndexedFastaSequenceFile reference,\n                             final Collection<ReferenceOrderedDataSource> rods,\n                             final ThreadAllocation threadAllocation) {\n        this.engine = engine;\n        this.reads = reads;\n        this.reference = reference;\n        this.rods = rods;\n\n        final File progressLogFile = engine.getArguments() == null ? null : engine.getArguments().performanceLog;\n\n        // Creates uninitialized TraversalEngines appropriate for walker and threadAllocation,\n        // and adds it to the list of created engines for later shutdown.\n        for ( int i = 0; i < threadAllocation.getNumDataThreads(); i++ ) {\n            final TraversalEngine traversalEngine = createTraversalEngine(walker, threadAllocation);\n            allCreatedTraversalEngines.add(traversalEngine);\n            availableTraversalEngines.add(traversalEngine);\n        }\n\n        // Create our progress meter\n        this.progressMeter = new ProgressMeter(progressLogFile,\n                availableTraversalEngines.peek().getTraversalUnits(),\n                engine.getRegionsOfGenomeBeingProcessed());\n\n        // Now that we have a progress meter, go through and initialize the traversal engines\n        for ( final TraversalEngine traversalEngine : allCreatedTraversalEngines )\n            traversalEngine.initialize(engine, walker, progressMeter);\n\n        // JMX does not allow multiple instances with the same ObjectName to be registered with the same platform MXBean.\n        // To get around this limitation and since we have no job identifier at this point, register a simple counter that\n        // will count the number of instances of this object that have been created in this JVM.\n        int thisInstance = instanceNumber++;\n        mBeanServer = ManagementFactory.getPlatformMBeanServer();\n        try {\n            mBeanName = new ObjectName(\"org.broadinstitute.sting.gatk.executive:type=MicroScheduler,instanceNumber=\"+thisInstance);\n            mBeanServer.registerMBean(this, mBeanName);\n        }\n        catch (JMException ex) {\n            throw new ReviewedStingException(\"Unable to register microscheduler with JMX\", ex);\n        }\n    }","commit_id":"c00bd3c6a34e96c0f0fcc71a8da50492f39d89c5","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * For testing only.  Does not initialize the progress meter\n     *\n     * @param engine\n     */\n    protected void initialize(final GenomeAnalysisEngine engine) {\n        initialize(engine, null);\n    }","id":33745,"modified_method":"/**\n     * For testing only.  Does not initialize the progress meter\n     *\n     * @param engine\n     */\n    protected void initialize(final GenomeAnalysisEngine engine, final Walker walker) {\n        initialize(engine, walker, null);\n    }","commit_id":"c00bd3c6a34e96c0f0fcc71a8da50492f39d89c5","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Initialize the traversal engine.  After this point traversals can be run over the data\n     *\n     * @param engine GenomeAnalysisEngine for this traversal\n     * @param progressMeter An optional (null == optional) meter to track our progress\n     */\n    public void initialize(final GenomeAnalysisEngine engine, final ProgressMeter progressMeter) {\n        if ( engine == null )\n            throw new ReviewedStingException(\"BUG: GenomeAnalysisEngine cannot be null!\");\n\n        this.engine = engine;\n        this.progressMeter = progressMeter;\n    }","id":33746,"modified_method":"/**\n     * Initialize the traversal engine.  After this point traversals can be run over the data\n     *\n     * @param engine GenomeAnalysisEngine for this traversal\n     * @param progressMeter An optional (null == optional) meter to track our progress\n     */\n    public void initialize(final GenomeAnalysisEngine engine, final Walker walker, final ProgressMeter progressMeter) {\n        if ( engine == null )\n            throw new ReviewedStingException(\"BUG: GenomeAnalysisEngine cannot be null!\");\n\n        this.engine = engine;\n        this.progressMeter = progressMeter;\n    }","commit_id":"c00bd3c6a34e96c0f0fcc71a8da50492f39d89c5","url":"https://github.com/broadgsa/gatk"},{"original_method":"private T callWalkerMapOnActiveRegions(final ActiveRegionWalker<M, T> walker, T sum, final boolean forceRegionsToBeActive) {\n        // Since we've traversed sufficiently past this point (or this contig!) in the workQueue we can unload those regions and process them\n        // TODO can implement parallel traversal here\n        while( workQueue.peek() != null ) {\n            final GenomeLoc extendedLoc = workQueue.peek().getExtendedLoc();\n            if ( forceRegionsToBeActive || regionCompletelyWithinDeadZone(extendedLoc, false) ) {\n                final ActiveRegion activeRegion = workQueue.remove();\n                logger.warn(\"Processing active region \" + activeRegion + \" dead zone \" + getStartOfLiveRegion());\n                sum = processActiveRegion( activeRegion, sum, walker );\n            } else {\n                break;\n            }\n        }\n\n        return sum;\n    }","id":33747,"modified_method":"private T callWalkerMapOnActiveRegions(final ActiveRegionWalker<M, T> walker, T sum, final boolean forceRegionsToBeActive) {\n        // Since we've traversed sufficiently past this point (or this contig!) in the workQueue we can unload those regions and process them\n        // TODO can implement parallel traversal here\n        while( workQueue.peek() != null ) {\n            final GenomeLoc extendedLoc = workQueue.peek().getExtendedLoc();\n            if ( forceRegionsToBeActive || regionCompletelyWithinDeadZone(extendedLoc, false) ) {\n                final ActiveRegion activeRegion = workQueue.remove();\n                if ( DEBUG ) logger.warn(\"Processing active region \" + activeRegion + \" dead zone \" + getStartOfLiveRegion());\n                sum = processActiveRegion( activeRegion, sum, walker );\n            } else {\n                break;\n            }\n        }\n\n        return sum;\n    }","commit_id":"c00bd3c6a34e96c0f0fcc71a8da50492f39d89c5","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected boolean regionCompletelyWithinDeadZone(final GenomeLoc region, final boolean includeExtension) {\n        return (region.getStop() < (getStartOfLiveRegion().getStart() - (includeExtension ? activeRegionExtension : 0)))\n                || ! region.onSameContig(getStartOfLiveRegion());\n    }","id":33748,"modified_method":"protected boolean regionCompletelyWithinDeadZone(final GenomeLoc region, final boolean includeExtension) {\n        return (region.getStop() < (getStartOfLiveRegion().getStart() - (includeExtension ? getActiveRegionExtension() : 0)))\n                || ! region.onSameContig(getStartOfLiveRegion());\n    }","commit_id":"c00bd3c6a34e96c0f0fcc71a8da50492f39d89c5","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected ActiveRegion getBestRegion(final ActiveRegion activeRegion, final GenomeLoc readLoc) {\n        ActiveRegion bestRegion = activeRegion;\n        long maxOverlap = activeRegion.getLocation().sizeOfOverlap( readLoc );\n        for( final ActiveRegion otherRegionToTest : workQueue ) {\n            if( otherRegionToTest.getLocation().sizeOfOverlap(readLoc) >= maxOverlap ) {\n                maxOverlap = otherRegionToTest.getLocation().sizeOfOverlap( readLoc );\n                bestRegion = otherRegionToTest;\n            }\n        }\n        return bestRegion;\n    }","id":33749,"modified_method":"protected ActiveRegion getBestRegion(final ActiveRegion activeRegion, final GenomeLoc readLoc) {\n        long minStart = activeRegion.getLocation().getStart();\n        ActiveRegion bestRegion = activeRegion;\n\n        for( final ActiveRegion otherRegionToTest : workQueue ) {\n            if( otherRegionToTest.getLocation().getStart() < minStart ) {\n                minStart = otherRegionToTest.getLocation().getStart();\n                bestRegion = otherRegionToTest;\n            }\n        }\n\n        return bestRegion;\n    }","commit_id":"c00bd3c6a34e96c0f0fcc71a8da50492f39d89c5","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Take the individual isActive calls and integrate them into contiguous active regions and\n     * add these blocks of work to the work queue\n     * band-pass filter the list of isActive probabilities and turn into active regions\n     *\n     * @param profile\n     * @param activeRegions\n     * @param activeRegionExtension\n     * @param maxRegionSize\n     * @return\n     */\n    protected ActivityProfile incorporateActiveRegions(final ActivityProfile profile,\n                                                       final List<ActiveRegion> activeRegions,\n                                                       final int activeRegionExtension,\n                                                       final int maxRegionSize) {\n        if ( profile.isEmpty() )\n            throw new IllegalStateException(\"trying to incorporate an empty active profile \" + profile);\n\n        final ActivityProfile bandPassFiltered = profile.bandPassFilter();\n        activeRegions.addAll(bandPassFiltered.createActiveRegions( activeRegionExtension, maxRegionSize ));\n        return new ActivityProfile( engine.getGenomeLocParser(), profile.hasPresetRegions() );\n    }","id":33750,"modified_method":"/**\n     * Take the individual isActive calls and integrate them into contiguous active regions and\n     * add these blocks of work to the work queue\n     * band-pass filter the list of isActive probabilities and turn into active regions\n     *\n     * @param profile\n     * @param activeRegions\n     * @return\n     */\n    protected ActivityProfile incorporateActiveRegions(final ActivityProfile profile,\n                                                       final List<ActiveRegion> activeRegions) {\n        if ( profile.isEmpty() )\n            throw new IllegalStateException(\"trying to incorporate an empty active profile \" + profile);\n\n        final ActivityProfile bandPassFiltered = profile.bandPassFilter();\n        activeRegions.addAll(bandPassFiltered.createActiveRegions( getActiveRegionExtension(), getMaxRegionSize() ));\n        return new ActivityProfile( engine.getGenomeLocParser(), profile.hasPresetRegions() );\n    }","commit_id":"c00bd3c6a34e96c0f0fcc71a8da50492f39d89c5","url":"https://github.com/broadgsa/gatk"},{"original_method":"private final void addToRegion(final ActiveRegion region, final GATKSAMRecord read) {\n        if ( ! region.getReads().contains(read) )\n            region.add(read);\n    }","id":33751,"modified_method":"private boolean readIsDead(final GATKSAMRecord read, final GenomeLoc readLoc, final ActiveRegion activeRegion) {\n        return readLoc.getStop() < activeRegion.getLocation().getStart() && regionCompletelyWithinDeadZone(readLoc, true);\n    }","commit_id":"c00bd3c6a34e96c0f0fcc71a8da50492f39d89c5","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public T traverse( final ActiveRegionWalker<M,T> walker,\n                       final LocusShardDataProvider dataProvider,\n                       T sum) {\n        logger.debug(String.format(\"TraverseActiveRegions.traverse: Shard is %s\", dataProvider));\n\n        final LocusView locusView = new AllLocusView(dataProvider);\n\n        final LocusReferenceView referenceView = new LocusReferenceView( walker, dataProvider );\n        activeRegionExtension = walker.getClass().getAnnotation(ActiveRegionExtension.class).extension();\n        maxRegionSize = walker.getClass().getAnnotation(ActiveRegionExtension.class).maxRegion();\n\n        final List<ActiveRegion> activeRegions = new LinkedList<ActiveRegion>();\n        ActivityProfile profile = new ActivityProfile(engine.getGenomeLocParser(), walker.hasPresetActiveRegions() );\n\n        ReferenceOrderedView referenceOrderedDataView = getReferenceOrderedView(walker, dataProvider, locusView);\n\n        // We keep processing while the next reference location is within the interval\n        GenomeLoc prevLoc = null;\n        while( locusView.hasNext() ) {\n            final AlignmentContext locus = locusView.next();\n            final GenomeLoc location = locus.getLocation();\n\n            // Grab all the previously unseen reads from this pileup and add them to the massive read list\n            // Note that this must occur before we leave because we are outside the intervals because\n            // reads may occur outside our intervals but overlap them in the future\n            final Collection<SAMRecord> reads = locusView.getLIBS().transferReadsFromAllPreviousPileups();\n            for( final SAMRecord read : reads ) {\n                notifyOfCurrentPosition((GATKSAMRecord)read);\n                myReads.add((GATKSAMRecord)read);\n            }\n\n            // skip this location -- it's not part of our engine intervals\n            if ( outsideEngineIntervals(location) )\n                continue;\n\n            if ( prevLoc != null && location.getStart() != prevLoc.getStop() + 1 ) {\n                // we've move across some interval boundary, restart profile\n                profile = incorporateActiveRegions(profile, activeRegions, activeRegionExtension, maxRegionSize);\n            }\n\n            dataProvider.getShard().getReadMetrics().incrementNumIterations();\n\n            // create reference context. Note that if we have a pileup of \"extended events\", the context will\n            // hold the (longest) stretch of deleted reference bases (if deletions are present in the pileup).\n            final ReferenceContext refContext = referenceView.getReferenceContext(location);\n\n            // Iterate forward to get all reference ordered data covering this location\n            final RefMetaDataTracker tracker = referenceOrderedDataView.getReferenceOrderedDataAtLocus(locus.getLocation(), refContext);\n\n            // Call the walkers isActive function for this locus and add them to the list to be integrated later\n            profile.add(walkerActiveProb(walker, tracker, refContext, locus, location));\n\n            prevLoc = location;\n\n            printProgress(locus.getLocation());\n        }\n\n        updateCumulativeMetrics(dataProvider.getShard());\n\n        if ( ! profile.isEmpty() )\n            incorporateActiveRegions(profile, activeRegions, activeRegionExtension, maxRegionSize);\n\n        // add active regions to queue of regions to process\n        // first check if can merge active regions over shard boundaries\n        if( !activeRegions.isEmpty() ) {\n            if( !workQueue.isEmpty() ) {\n                final ActiveRegion last = workQueue.getLast();\n                final ActiveRegion first = activeRegions.get(0);\n                if( last.isActive == first.isActive && last.getLocation().contiguousP(first.getLocation()) && last.getLocation().size() + first.getLocation().size() <= maxRegionSize ) {\n                    workQueue.removeLast();\n                    activeRegions.remove(first);\n                    workQueue.add( new ActiveRegion(last.getLocation().union(first.getLocation()), first.isActive, this.engine.getGenomeLocParser(), activeRegionExtension) );\n                }\n            }\n            workQueue.addAll( activeRegions );\n        }\n\n        logger.debug(\"Integrated \" + profile.size() + \" isActive calls into \" + activeRegions.size() + \" regions.\" );\n\n        // now go and process all of the active regions\n        sum = processActiveRegions(walker, sum, false);\n\n        return sum;\n    }","id":33752,"modified_method":"@Override\n    public T traverse( final ActiveRegionWalker<M,T> walker,\n                       final LocusShardDataProvider dataProvider,\n                       T sum) {\n        if ( DEBUG ) logger.warn(String.format(\"TraverseActiveRegions.traverse: Shard is %s\", dataProvider));\n\n        final HashSet<GATKSAMRecord> maybeDuplicatedReads = new HashSet<GATKSAMRecord>();\n        // TODO -- there's got to be a better way to know this\n        if ( lastShard != dataProvider.getShard() ) {\n            maybeDuplicatedReads.addAll(myReads);\n            logger.info(\"Crossing shard boundary requires us to check for duplicates against \" + maybeDuplicatedReads.size() +  \" reads\");\n            if ( DEBUG ) logger.warn(\"Clearing myReads\");\n        }\n        lastShard = dataProvider.getShard();\n\n        final LocusView locusView = new AllLocusView(dataProvider);\n\n        final LocusReferenceView referenceView = new LocusReferenceView( walker, dataProvider );\n\n        final List<ActiveRegion> activeRegions = new LinkedList<ActiveRegion>();\n        ActivityProfile profile = new ActivityProfile(engine.getGenomeLocParser(), walker.hasPresetActiveRegions() );\n\n        ReferenceOrderedView referenceOrderedDataView = getReferenceOrderedView(walker, dataProvider, locusView);\n\n        // We keep processing while the next reference location is within the interval\n        GenomeLoc prevLoc = null;\n        while( locusView.hasNext() ) {\n            final AlignmentContext locus = locusView.next();\n            final GenomeLoc location = locus.getLocation();\n\n            // Grab all the previously unseen reads from this pileup and add them to the massive read list\n            // Note that this must occur before we leave because we are outside the intervals because\n            // reads may occur outside our intervals but overlap them in the future\n            final Collection<SAMRecord> reads = locusView.getLIBS().transferReadsFromAllPreviousPileups();\n            for( final SAMRecord read : reads ) {\n                notifyOfCurrentPosition((GATKSAMRecord)read);\n                // most of the time maybeDuplicatedReads is empty\n                // TODO -- I believe that because of the ordering of reads that as soon as we don't find a read in the\n                // TODO -- potential list of duplicates we can clear the hashset\n                if ( ! maybeDuplicatedReads.isEmpty() && maybeDuplicatedReads.contains(read) ) {\n                    if ( DEBUG ) logger.warn(\"Skipping duplicated \" + read.getReadName());\n                } else {\n                    if ( DEBUG ) logger.warn(\"Adding read \" + read.getReadName() + \" at \" + engine.getGenomeLocParser().createGenomeLoc(read) + \" from provider \" + dataProvider);\n                    myReads.add((GATKSAMRecord)read);\n                }\n            }\n\n            // skip this location -- it's not part of our engine intervals\n            if ( outsideEngineIntervals(location) )\n                continue;\n\n            if ( prevLoc != null && location.getStart() != prevLoc.getStop() + 1 ) {\n                // we've move across some interval boundary, restart profile\n                profile = incorporateActiveRegions(profile, activeRegions);\n            }\n\n            dataProvider.getShard().getReadMetrics().incrementNumIterations();\n\n            // create reference context. Note that if we have a pileup of \"extended events\", the context will\n            // hold the (longest) stretch of deleted reference bases (if deletions are present in the pileup).\n            final ReferenceContext refContext = referenceView.getReferenceContext(location);\n\n            // Iterate forward to get all reference ordered data covering this location\n            final RefMetaDataTracker tracker = referenceOrderedDataView.getReferenceOrderedDataAtLocus(locus.getLocation(), refContext);\n\n            // Call the walkers isActive function for this locus and add them to the list to be integrated later\n            profile.add(walkerActiveProb(walker, tracker, refContext, locus, location));\n\n            prevLoc = location;\n\n            printProgress(locus.getLocation());\n        }\n\n        updateCumulativeMetrics(dataProvider.getShard());\n\n        if ( ! profile.isEmpty() )\n            incorporateActiveRegions(profile, activeRegions);\n\n        // add active regions to queue of regions to process\n        // first check if can merge active regions over shard boundaries\n        if( !activeRegions.isEmpty() ) {\n            if( !workQueue.isEmpty() ) {\n                final ActiveRegion last = workQueue.getLast();\n                final ActiveRegion first = activeRegions.get(0);\n                if( last.isActive == first.isActive && last.getLocation().contiguousP(first.getLocation()) && last.getLocation().size() + first.getLocation().size() <= getMaxRegionSize() ) {\n                    workQueue.removeLast();\n                    activeRegions.remove(first);\n                    workQueue.add( new ActiveRegion(last.getLocation().union(first.getLocation()), first.isActive, this.engine.getGenomeLocParser(), getActiveRegionExtension()) );\n                }\n            }\n            workQueue.addAll( activeRegions );\n        }\n\n        logger.debug(\"Integrated \" + profile.size() + \" isActive calls into \" + activeRegions.size() + \" regions.\" );\n\n        // now go and process all of the active regions\n        sum = processActiveRegions(walker, sum, false);\n\n        return sum;\n    }","commit_id":"c00bd3c6a34e96c0f0fcc71a8da50492f39d89c5","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    protected T processActiveRegion(final ActiveRegion activeRegion, final T sum, final ActiveRegionWalker<M, T> walker) {\n        final Iterator<GATKSAMRecord> liveReads = myReads.iterator();\n        while ( liveReads.hasNext() ) {\n            final GATKSAMRecord read = liveReads.next();\n            final GenomeLoc readLoc = this.engine.getGenomeLocParser().createGenomeLoc( read );\n\n            if( activeRegion.getLocation().overlapsP( readLoc ) ) {\n                // TODO -- this test assumes that we've successfully defined all regions that might be\n                // TODO -- the primary home for read.  Doesn't seem safe to me\n                // The region which the highest amount of overlap is chosen as the primary region for the read (tie breaking is done as right most region)\n                final ActiveRegion bestRegion = getBestRegion(activeRegion, readLoc);\n                addToRegion(bestRegion, read);\n\n                // The read is also added to all other regions in which it overlaps but marked as non-primary\n\n                if( walker.wantsNonPrimaryReads() ) {\n                    if( !bestRegion.equals(activeRegion) ) {\n                        addToRegion(activeRegion, read);\n                    }\n                    for( final ActiveRegion otherRegionToTest : workQueue ) {\n                        if( !bestRegion.equals(otherRegionToTest) ) {\n                            // check for non-primary vs. extended\n                            if ( otherRegionToTest.getLocation().overlapsP( readLoc ) ) {\n                                addToRegion(otherRegionToTest, read);\n                            } else if ( walker.wantsExtendedReads() && otherRegionToTest.getExtendedLoc().overlapsP( readLoc ) ) {\n                                addToRegion(otherRegionToTest, read);\n                            }\n                        }\n                    }\n                }\n                // check for non-primary vs. extended\n            } else if( walker.wantsExtendedReads() && activeRegion.getExtendedLoc().overlapsP( readLoc )) {\n                activeRegion.add( read );\n            }\n\n            if ( regionCompletelyWithinDeadZone(readLoc, true) ) {\n                logger.info(\"Removing read \" + read.getReadName() + \" at \" + readLoc + \" with dead zone start \" + getStartOfLiveRegion());\n                liveReads.remove();\n            }\n        }\n\n        logger.debug(\">> Map call with \" + activeRegion.getReads().size() + \" \" + (activeRegion.isActive ? \"active\" : \"inactive\") + \" reads @ \" + activeRegion.getLocation() + \" with full extent: \" + activeRegion.getReferenceLoc());\n        final M x = walker.map(activeRegion, null);\n        return walker.reduce( x, sum );\n    }","id":33753,"modified_method":"@Override\n    protected T processActiveRegion(final ActiveRegion activeRegion, final T sum, final ActiveRegionWalker<M, T> walker) {\n        final Iterator<GATKSAMRecord> liveReads = myReads.iterator();\n        while ( liveReads.hasNext() ) {\n            boolean killed = false;\n            final GATKSAMRecord read = liveReads.next();\n            final GenomeLoc readLoc = this.engine.getGenomeLocParser().createGenomeLoc( read );\n\n            if( activeRegion.getLocation().overlapsP( readLoc ) ) {\n                activeRegion.add(read);\n\n                if ( ! walker.wantsNonPrimaryReads() ) {\n                    if ( DEBUG ) logger.warn(\"Removing read \" + read.getReadName() + \" at \" + readLoc + \" with dead zone start \" + getStartOfLiveRegion());\n                    liveReads.remove();\n                    killed = true;\n                }\n            } else if( walker.wantsExtendedReads() && activeRegion.getExtendedLoc().overlapsP( readLoc )) {\n                activeRegion.add( read );\n            }\n\n            if ( ! killed && readIsDead(read, readLoc, activeRegion) ) {\n                if ( DEBUG ) logger.warn(\"Removing read \" + read.getReadName() + \" at \" + readLoc + \" with dead zone start \" + getStartOfLiveRegion());\n                liveReads.remove();\n            }\n        }\n\n        logger.debug(\">> Map call with \" + activeRegion.getReads().size() + \" \" + (activeRegion.isActive ? \"active\" : \"inactive\") + \" reads @ \" + activeRegion.getLocation() + \" with full extent: \" + activeRegion.getReferenceLoc());\n        final M x = walker.map(activeRegion, null);\n        return walker.reduce( x, sum );\n    }","commit_id":"c00bd3c6a34e96c0f0fcc71a8da50492f39d89c5","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public T traverse( final ActiveRegionWalker<M,T> walker,\n                       final LocusShardDataProvider dataProvider,\n                       T sum) {\n        logger.debug(String.format(\"TraverseActiveRegions.traverse: Shard is %s\", dataProvider));\n\n        final LocusView locusView = new AllLocusView(dataProvider);\n\n        final LocusReferenceView referenceView = new LocusReferenceView( walker, dataProvider );\n        activeRegionExtension = walker.getClass().getAnnotation(ActiveRegionExtension.class).extension();\n        maxRegionSize = walker.getClass().getAnnotation(ActiveRegionExtension.class).maxRegion();\n\n        int minStart = Integer.MAX_VALUE;\n        final List<ActiveRegion> activeRegions = new LinkedList<ActiveRegion>();\n        ActivityProfile profile = new ActivityProfile(engine.getGenomeLocParser(), walker.hasPresetActiveRegions() );\n\n        ReferenceOrderedView referenceOrderedDataView = getReferenceOrderedView(walker, dataProvider, locusView);\n\n        // We keep processing while the next reference location is within the interval\n        GenomeLoc prevLoc = null;\n        while( locusView.hasNext() ) {\n            final AlignmentContext locus = locusView.next();\n            final GenomeLoc location = locus.getLocation();\n\n            // Grab all the previously unseen reads from this pileup and add them to the massive read list\n            // Note that this must occur before we leave because we are outside the intervals because\n            // reads may occur outside our intervals but overlap them in the future\n            // TODO -- this whole HashSet logic should be changed to a linked list of reads with\n            // TODO -- subsequent pass over them to find the ones overlapping the active regions\n            for( final PileupElement p : locus.getBasePileup() ) {\n                final GATKSAMRecord read = p.getRead();\n                if( !myReads.contains(read) ) {\n                    myReads.add(read);\n                }\n\n                // If this is the last pileup for this shard calculate the minimum alignment start so that we know\n                // which active regions in the work queue are now safe to process\n                minStart = Math.min(minStart, read.getAlignmentStart());\n            }\n\n            // skip this location -- it's not part of our engine intervals\n            if ( outsideEngineIntervals(location) )\n                continue;\n\n            if ( prevLoc != null && location.getStart() != prevLoc.getStop() + 1 ) {\n                // we've move across some interval boundary, restart profile\n                profile = incorporateActiveRegions(profile, activeRegions, activeRegionExtension, maxRegionSize);\n            }\n\n            dataProvider.getShard().getReadMetrics().incrementNumIterations();\n\n            // create reference context. Note that if we have a pileup of \"extended events\", the context will\n            // hold the (longest) stretch of deleted reference bases (if deletions are present in the pileup).\n            final ReferenceContext refContext = referenceView.getReferenceContext(location);\n\n            // Iterate forward to get all reference ordered data covering this location\n            final RefMetaDataTracker tracker = referenceOrderedDataView.getReferenceOrderedDataAtLocus(locus.getLocation(), refContext);\n\n            // Call the walkers isActive function for this locus and add them to the list to be integrated later\n            profile.add(walkerActiveProb(walker, tracker, refContext, locus, location));\n\n            prevLoc = location;\n\n            printProgress(locus.getLocation());\n        }\n\n        updateCumulativeMetrics(dataProvider.getShard());\n\n        if ( ! profile.isEmpty() )\n            incorporateActiveRegions(profile, activeRegions, activeRegionExtension, maxRegionSize);\n\n        // add active regions to queue of regions to process\n        // first check if can merge active regions over shard boundaries\n        if( !activeRegions.isEmpty() ) {\n            if( !workQueue.isEmpty() ) {\n                final ActiveRegion last = workQueue.getLast();\n                final ActiveRegion first = activeRegions.get(0);\n                if( last.isActive == first.isActive && last.getLocation().contiguousP(first.getLocation()) && last.getLocation().size() + first.getLocation().size() <= maxRegionSize ) {\n                    workQueue.removeLast();\n                    activeRegions.remove(first);\n                    workQueue.add( new ActiveRegion(last.getLocation().union(first.getLocation()), first.isActive, this.engine.getGenomeLocParser(), activeRegionExtension) );\n                }\n            }\n            workQueue.addAll( activeRegions );\n        }\n\n        logger.debug(\"Integrated \" + profile.size() + \" isActive calls into \" + activeRegions.size() + \" regions.\" );\n\n        // set the dead zone to the min.  This is incorrect but necessary because of the way we handle things in processActiveRegion\n        notifyOfCurrentPosition(engine.getGenomeLocParser().createGenomeLoc(dataProvider.getLocus().getContig(), minStart));\n        // now go and process all of the active regions\n        sum = processActiveRegions(walker, sum, false);\n\n        return sum;\n    }","id":33754,"modified_method":"@Override\n    public T traverse( final ActiveRegionWalker<M,T> walker,\n                       final LocusShardDataProvider dataProvider,\n                       T sum) {\n        logger.debug(String.format(\"TraverseActiveRegions.traverse: Shard is %s\", dataProvider));\n\n        final LocusView locusView = new AllLocusView(dataProvider);\n\n        final LocusReferenceView referenceView = new LocusReferenceView( walker, dataProvider );\n\n        int minStart = Integer.MAX_VALUE;\n        final List<ActiveRegion> activeRegions = new LinkedList<ActiveRegion>();\n        ActivityProfile profile = new ActivityProfile(engine.getGenomeLocParser(), walker.hasPresetActiveRegions() );\n\n        ReferenceOrderedView referenceOrderedDataView = getReferenceOrderedView(walker, dataProvider, locusView);\n\n        // We keep processing while the next reference location is within the interval\n        GenomeLoc prevLoc = null;\n        while( locusView.hasNext() ) {\n            final AlignmentContext locus = locusView.next();\n            final GenomeLoc location = locus.getLocation();\n\n            // Grab all the previously unseen reads from this pileup and add them to the massive read list\n            // Note that this must occur before we leave because we are outside the intervals because\n            // reads may occur outside our intervals but overlap them in the future\n            // TODO -- this whole HashSet logic should be changed to a linked list of reads with\n            // TODO -- subsequent pass over them to find the ones overlapping the active regions\n            for( final PileupElement p : locus.getBasePileup() ) {\n                final GATKSAMRecord read = p.getRead();\n                if( !myReads.contains(read) ) {\n                    myReads.add(read);\n                }\n\n                // If this is the last pileup for this shard calculate the minimum alignment start so that we know\n                // which active regions in the work queue are now safe to process\n                minStart = Math.min(minStart, read.getAlignmentStart());\n            }\n\n            // skip this location -- it's not part of our engine intervals\n            if ( outsideEngineIntervals(location) )\n                continue;\n\n            if ( prevLoc != null && location.getStart() != prevLoc.getStop() + 1 ) {\n                // we've move across some interval boundary, restart profile\n                profile = incorporateActiveRegions(profile, activeRegions);\n            }\n\n            dataProvider.getShard().getReadMetrics().incrementNumIterations();\n\n            // create reference context. Note that if we have a pileup of \"extended events\", the context will\n            // hold the (longest) stretch of deleted reference bases (if deletions are present in the pileup).\n            final ReferenceContext refContext = referenceView.getReferenceContext(location);\n\n            // Iterate forward to get all reference ordered data covering this location\n            final RefMetaDataTracker tracker = referenceOrderedDataView.getReferenceOrderedDataAtLocus(locus.getLocation(), refContext);\n\n            // Call the walkers isActive function for this locus and add them to the list to be integrated later\n            profile.add(walkerActiveProb(walker, tracker, refContext, locus, location));\n\n            prevLoc = location;\n\n            printProgress(locus.getLocation());\n        }\n\n        updateCumulativeMetrics(dataProvider.getShard());\n\n        if ( ! profile.isEmpty() )\n            incorporateActiveRegions(profile, activeRegions);\n\n        // add active regions to queue of regions to process\n        // first check if can merge active regions over shard boundaries\n        if( !activeRegions.isEmpty() ) {\n            if( !workQueue.isEmpty() ) {\n                final ActiveRegion last = workQueue.getLast();\n                final ActiveRegion first = activeRegions.get(0);\n                if( last.isActive == first.isActive && last.getLocation().contiguousP(first.getLocation()) && last.getLocation().size() + first.getLocation().size() <= getMaxRegionSize() ) {\n                    workQueue.removeLast();\n                    activeRegions.remove(first);\n                    workQueue.add( new ActiveRegion(last.getLocation().union(first.getLocation()), first.isActive, this.engine.getGenomeLocParser(), getActiveRegionExtension()) );\n                }\n            }\n            workQueue.addAll( activeRegions );\n        }\n\n        logger.debug(\"Integrated \" + profile.size() + \" isActive calls into \" + activeRegions.size() + \" regions.\" );\n\n        // set the dead zone to the min.  This is incorrect but necessary because of the way we handle things in processActiveRegion\n        notifyOfCurrentPosition(engine.getGenomeLocParser().createGenomeLoc(dataProvider.getLocus().getContig(), minStart));\n        // now go and process all of the active regions\n        sum = processActiveRegions(walker, sum, false);\n\n        return sum;\n    }","commit_id":"c00bd3c6a34e96c0f0fcc71a8da50492f39d89c5","url":"https://github.com/broadgsa/gatk"},{"original_method":"private Map<GenomeLoc, ActiveRegion> getActiveRegions(TraverseActiveRegions t, DummyActiveRegionWalker walker, List<GenomeLoc> intervals) {\n        for (LocusShardDataProvider dataProvider : createDataProviders(t, intervals, testBAM))\n            t.traverse(walker, dataProvider, 0);\n\n        t.endTraversal(walker, 0);\n\n        return walker.mappedActiveRegions;\n    }","id":33755,"modified_method":"private Map<GenomeLoc, ActiveRegion> getActiveRegions(TraverseActiveRegions t, DummyActiveRegionWalker walker, List<GenomeLoc> intervals) {\n        for (LocusShardDataProvider dataProvider : createDataProviders(t, walker, intervals, testBAM))\n            t.traverse(walker, dataProvider, 0);\n\n        t.endTraversal(walker, 0);\n\n        return walker.mappedActiveRegions;\n    }","commit_id":"c00bd3c6a34e96c0f0fcc71a8da50492f39d89c5","url":"https://github.com/broadgsa/gatk"},{"original_method":"private List<LocusShardDataProvider> createDataProviders(TraverseActiveRegions t, List<GenomeLoc> intervals, String bamFile) {\n        GenomeAnalysisEngine engine = new GenomeAnalysisEngine();\n        engine.setGenomeLocParser(genomeLocParser);\n        t.initialize(engine);\n\n        Collection<SAMReaderID> samFiles = new ArrayList<SAMReaderID>();\n        SAMReaderID readerID = new SAMReaderID(new File(bamFile), new Tags());\n        samFiles.add(readerID);\n\n        SAMDataSource dataSource = new SAMDataSource(samFiles, new ThreadAllocation(), null, genomeLocParser,\n                false,\n                SAMFileReader.ValidationStringency.STRICT,\n                null,\n                null,\n                new ValidationExclusion(),\n                new ArrayList<ReadFilter>(),\n                new ArrayList<ReadTransformer>(),\n                false, (byte)30, false, t instanceof TraverseActiveRegionsOptimized);\n\n        List<LocusShardDataProvider> providers = new ArrayList<LocusShardDataProvider>();\n        for (Shard shard : dataSource.createShardIteratorOverIntervals(new GenomeLocSortedSet(genomeLocParser, intervals), new LocusShardBalancer())) {\n            for (WindowMaker.WindowMakerIterator window : new WindowMaker(shard, genomeLocParser, dataSource.seek(shard), shard.getGenomeLocs())) {\n                providers.add(new LocusShardDataProvider(shard, shard.getReadProperties(), genomeLocParser, window.getLocus(), window, reference, new ArrayList<ReferenceOrderedDataSource>()));\n            }\n        }\n\n        return providers;\n    }","id":33756,"modified_method":"private List<LocusShardDataProvider> createDataProviders(TraverseActiveRegions t, final Walker walker, List<GenomeLoc> intervals, String bamFile) {\n        GenomeAnalysisEngine engine = new GenomeAnalysisEngine();\n        engine.setGenomeLocParser(genomeLocParser);\n        t.initialize(engine, walker);\n\n        Collection<SAMReaderID> samFiles = new ArrayList<SAMReaderID>();\n        SAMReaderID readerID = new SAMReaderID(new File(bamFile), new Tags());\n        samFiles.add(readerID);\n\n        SAMDataSource dataSource = new SAMDataSource(samFiles, new ThreadAllocation(), null, genomeLocParser,\n                false,\n                SAMFileReader.ValidationStringency.STRICT,\n                null,\n                null,\n                new ValidationExclusion(),\n                new ArrayList<ReadFilter>(),\n                new ArrayList<ReadTransformer>(),\n                false, (byte)30, false, t instanceof TraverseActiveRegionsOptimized);\n\n        List<LocusShardDataProvider> providers = new ArrayList<LocusShardDataProvider>();\n        for (Shard shard : dataSource.createShardIteratorOverIntervals(new GenomeLocSortedSet(genomeLocParser, intervals), new LocusShardBalancer())) {\n            for (WindowMaker.WindowMakerIterator window : new WindowMaker(shard, genomeLocParser, dataSource.seek(shard), shard.getGenomeLocs())) {\n                providers.add(new LocusShardDataProvider(shard, shard.getReadProperties(), genomeLocParser, window.getLocus(), window, reference, new ArrayList<ReferenceOrderedDataSource>()));\n            }\n        }\n\n        return providers;\n    }","commit_id":"c00bd3c6a34e96c0f0fcc71a8da50492f39d89c5","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test(enabled = true && ! DEBUG, dataProvider = \"TraversalEngineProvider\")\n    public void testPrimaryReadMapping(TraverseActiveRegions t) {\n        DummyActiveRegionWalker walker = new DummyActiveRegionWalker();\n\n        // Contract: Each read has the Primary state in a single region (or none)\n        // This is the region of maximum overlap for the read (earlier if tied)\n\n        // simple: Primary in 1:1-999\n        // overlap_equal: Primary in 1:1-999\n        // overlap_unequal: Primary in 1:1-999\n        // boundary_equal: Non-Primary in 1:1000-1999, Primary in 1:2000-2999\n        // boundary_unequal: Primary in 1:1000-1999, Non-Primary in 1:2000-2999\n        // boundary_1_pre: Primary in 1:1000-1999, Non-Primary in 1:2000-2999\n        // boundary_1_post: Non-Primary in 1:1000-1999, Primary in 1:2000-2999\n        // extended_and_np: Non-Primary in 1:1-999, Primary in 1:1000-1999, Extended in 1:2000-2999\n        // outside_intervals: none\n        // shard_boundary_1_pre: Primary in 1:14908-16384, Non-Primary in 1:16385-16927\n        // shard_boundary_1_post: Non-Primary in 1:14908-16384, Primary in 1:16385-16927\n        // shard_boundary_equal: Non-Primary in 1:14908-16384, Primary in 1:16385-16927\n        // simple20: Primary in 20:10000-10100\n\n        Map<GenomeLoc, ActiveRegion> activeRegions = getActiveRegions(t, walker, intervals);\n        ActiveRegion region;\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"1\", 1, 999));\n        verifyReadMapping(region, \"simple\", \"overlap_equal\", \"overlap_unequal\");\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"1\", 1000, 1999));\n        verifyReadMapping(region, \"boundary_unequal\", \"extended_and_np\", \"boundary_1_pre\");\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"1\", 2000, 2999));\n        verifyReadMapping(region, \"boundary_equal\", \"boundary_1_post\");\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"1\", 14908, 16384));\n        verifyReadMapping(region, \"shard_boundary_1_pre\");\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"1\", 16385, 16927));\n        verifyReadMapping(region, \"shard_boundary_1_post\", \"shard_boundary_equal\");\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"20\", 10000, 10100));\n        verifyReadMapping(region, \"simple20\");\n    }","id":33757,"modified_method":"@Test(enabled = true && ! DEBUG, dataProvider = \"TraversalEngineProvider\")\n    public void testPrimaryReadMapping(TraverseActiveRegions t) {\n        DummyActiveRegionWalker walker = new DummyActiveRegionWalker();\n\n        // Contract: Each read has the Primary state in a single region (or none)\n        // This is the region of maximum overlap for the read (earlier if tied)\n\n        // simple: Primary in 1:1-999\n        // overlap_equal: Primary in 1:1-999\n        // overlap_unequal: Primary in 1:1-999\n        // boundary_equal: Primary in 1:1000-1999, Non-Primary in 1:2000-2999\n        // boundary_unequal: Primary in 1:1000-1999, Non-Primary in 1:2000-2999\n        // boundary_1_pre: Primary in 1:1000-1999, Non-Primary in 1:2000-2999\n        // boundary_1_post: Primary in 1:1000-1999, Non-Primary in 1:2000-2999\n        // extended_and_np: Primary in 1:1-999, Non-Primary in 1:1000-1999, Extended in 1:2000-2999\n        // outside_intervals: none\n        // shard_boundary_1_pre: Primary in 1:14908-16384, Non-Primary in 1:16385-16927\n        // shard_boundary_1_post: Primary in 1:14908-16384, Non-Primary in 1:16385-16927\n        // shard_boundary_equal: Primary in 1:14908-16384, Non-Primary in 1:16385-16927\n        // simple20: Primary in 20:10000-10100\n\n        Map<GenomeLoc, ActiveRegion> activeRegions = getActiveRegions(t, walker, intervals);\n        ActiveRegion region;\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"1\", 1, 999));\n        verifyReadMapping(region, \"simple\", \"overlap_equal\", \"overlap_unequal\", \"extended_and_np\");\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"1\", 1000, 1999));\n        verifyReadMapping(region, \"boundary_unequal\", \"boundary_1_pre\", \"boundary_equal\", \"boundary_1_post\");\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"1\", 2000, 2999));\n        verifyReadMapping(region);\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"1\", 14908, 16384));\n        verifyReadMapping(region, \"shard_boundary_1_pre\", \"shard_boundary_1_post\", \"shard_boundary_equal\");\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"1\", 16385, 16927));\n        verifyReadMapping(region);\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"20\", 10000, 10100));\n        verifyReadMapping(region, \"simple20\");\n    }","commit_id":"c00bd3c6a34e96c0f0fcc71a8da50492f39d89c5","url":"https://github.com/broadgsa/gatk"},{"original_method":"private List<GenomeLoc> getIsActiveIntervals(final TraverseActiveRegions t, DummyActiveRegionWalker walker, List<GenomeLoc> intervals) {\n        List<GenomeLoc> activeIntervals = new ArrayList<GenomeLoc>();\n        for (LocusShardDataProvider dataProvider : createDataProviders(t, intervals, testBAM)) {\n            t.traverse(walker, dataProvider, 0);\n            activeIntervals.addAll(walker.isActiveCalls);\n        }\n\n        return activeIntervals;\n    }","id":33758,"modified_method":"private List<GenomeLoc> getIsActiveIntervals(final TraverseActiveRegions t, DummyActiveRegionWalker walker, List<GenomeLoc> intervals) {\n        List<GenomeLoc> activeIntervals = new ArrayList<GenomeLoc>();\n        for (LocusShardDataProvider dataProvider : createDataProviders(t, walker, intervals, testBAM)) {\n            t.traverse(walker, dataProvider, 0);\n            activeIntervals.addAll(walker.isActiveCalls);\n        }\n\n        return activeIntervals;\n    }","commit_id":"c00bd3c6a34e96c0f0fcc71a8da50492f39d89c5","url":"https://github.com/broadgsa/gatk"},{"original_method":"@BeforeMethod\n    public void doBefore() {\n        header = ArtificialSAMUtils.createArtificialSamHeader(1, 1, 1000);\n        genomeLocParser =new GenomeLocParser(header.getSequenceDictionary());\n\n        engine = new GenomeAnalysisEngine();\n        engine.setReferenceDataSource(refFile);\n        engine.setGenomeLocParser(genomeLocParser);\n        \n        obj.initialize(engine);\n    }","id":33759,"modified_method":"@BeforeMethod\n    public void doBefore() {\n        header = ArtificialSAMUtils.createArtificialSamHeader(1, 1, 1000);\n        genomeLocParser =new GenomeLocParser(header.getSequenceDictionary());\n\n        engine = new GenomeAnalysisEngine();\n        engine.setReferenceDataSource(refFile);\n        engine.setGenomeLocParser(genomeLocParser);\n        \n        obj.initialize(engine, null);\n    }","commit_id":"c00bd3c6a34e96c0f0fcc71a8da50492f39d89c5","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * This function does the setup of our parser, before each method call.\n     * <p/>\n     * Called before every test case method.\n     */\n    @BeforeMethod\n    public void doForEachTest() {\n        output = new File(\"testOut.txt\");\n        FileOutputStream out = null;\n        PrintStream ps; // declare a print stream object\n\n        try {\n            out = new FileOutputStream(output);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n            fail(\"Couldn't open the output file\");\n        }\n\n        bamList = new ArrayList<SAMReaderID>();\n        bamList.add(bam);\n        countReadWalker = new CountReads();\n        \n        traversalEngine = new TraverseReadsNano(1);\n        traversalEngine.initialize(engine);\n    }","id":33760,"modified_method":"/**\n     * This function does the setup of our parser, before each method call.\n     * <p/>\n     * Called before every test case method.\n     */\n    @BeforeMethod\n    public void doForEachTest() {\n        output = new File(\"testOut.txt\");\n        FileOutputStream out = null;\n        PrintStream ps; // declare a print stream object\n\n        try {\n            out = new FileOutputStream(output);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n            fail(\"Couldn't open the output file\");\n        }\n\n        bamList = new ArrayList<SAMReaderID>();\n        bamList.add(bam);\n        countReadWalker = new CountReads();\n        \n        traversalEngine = new TraverseReadsNano(1);\n        traversalEngine.initialize(engine, countReadWalker);\n    }","commit_id":"c00bd3c6a34e96c0f0fcc71a8da50492f39d89c5","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testExtendedReadMapping() {\n        DummyActiveRegionWalker walker = new DummyActiveRegionWalker(\n                EnumSet.of(ActiveRegionReadState.PRIMARY, ActiveRegionReadState.NONPRIMARY, ActiveRegionReadState.EXTENDED));\n\n        // Contract: Each read has the Primary state in a single region (or none)\n        // This is the region of maximum overlap for the read (earlier if tied)\n\n        // Contract: Each read has the Non-Primary state in all other regions it overlaps\n        // Contract: Each read has the Extended state in regions where it only overlaps if the region is extended\n\n        // simple: Primary in 1:1-999\n        // overlap_equal: Primary in 1:1-999\n        // overlap_unequal: Primary in 1:1-999\n        // boundary_equal: Non-Primary in 1:1000-1999, Primary in 1:2000-2999\n        // boundary_unequal: Primary in 1:1000-1999, Non-Primary in 1:2000-2999\n        // extended_and_np: Non-Primary in 1:1-999, Primary in 1:1000-1999, Extended in 1:2000-2999\n        // outside_intervals: none\n        // simple20: Primary in 20:10000-10100\n\n        Map<GenomeLoc, ActiveRegion> activeRegions = getActiveRegions(walker, intervals);\n        ActiveRegion region;\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"1\", 1, 999));\n        verifyReadMapping(region, \"simple\", \"overlap_equal\", \"overlap_unequal\", \"extended_and_np\");\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"1\", 1000, 1999));\n        verifyReadMapping(region, \"boundary_equal\", \"boundary_unequal\", \"extended_and_np\");\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"1\", 2000, 2999));\n        verifyReadMapping(region, \"boundary_equal\", \"boundary_unequal\", \"extended_and_np\");\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"20\", 10000, 10100));\n        verifyReadMapping(region, \"simple20\");\n    }","id":33761,"modified_method":"@Test\n    public void testExtendedReadMapping() {\n        DummyActiveRegionWalker walker = new DummyActiveRegionWalker(\n                EnumSet.of(ActiveRegionReadState.PRIMARY, ActiveRegionReadState.NONPRIMARY, ActiveRegionReadState.EXTENDED));\n\n        // Contract: Each read has the Primary state in a single region (or none)\n        // This is the region of maximum overlap for the read (earlier if tied)\n\n        // Contract: Each read has the Non-Primary state in all other regions it overlaps\n        // Contract: Each read has the Extended state in regions where it only overlaps if the region is extended\n\n        // simple: Primary in 1:1-999\n        // overlap_equal: Primary in 1:1-999\n        // overlap_unequal: Primary in 1:1-999\n        // boundary_equal: Non-Primary in 1:1000-1999, Primary in 1:2000-2999\n        // boundary_unequal: Primary in 1:1000-1999, Non-Primary in 1:2000-2999\n        // boundary_1_pre: Primary in 1:1000-1999, Non-Primary in 1:2000-2999\n        // boundary_1_post: Non-Primary in 1:1000-1999, Primary in 1:2000-2999\n        // extended_and_np: Non-Primary in 1:1-999, Primary in 1:1000-1999, Extended in 1:2000-2999\n        // outside_intervals: none\n        // simple20: Primary in 20:10000-10100\n\n        Map<GenomeLoc, ActiveRegion> activeRegions = getActiveRegions(walker, intervals);\n        ActiveRegion region;\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"1\", 1, 999));\n        verifyReadMapping(region, \"simple\", \"overlap_equal\", \"overlap_unequal\", \"extended_and_np\");\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"1\", 1000, 1999));\n        verifyReadMapping(region, \"boundary_equal\", \"boundary_unequal\", \"extended_and_np\", \"boundary_1_pre\", \"boundary_1_post\");\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"1\", 2000, 2999));\n        verifyReadMapping(region, \"boundary_equal\", \"boundary_unequal\", \"extended_and_np\", \"boundary_1_pre\", \"boundary_1_post\");\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"20\", 10000, 10100));\n        verifyReadMapping(region, \"simple20\");\n    }","commit_id":"5c2c68d4e833c000204bd1c07cdd04fcc8fe448e","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testNonPrimaryReadMapping() {\n        DummyActiveRegionWalker walker = new DummyActiveRegionWalker(\n                EnumSet.of(ActiveRegionReadState.PRIMARY, ActiveRegionReadState.NONPRIMARY));\n\n        // Contract: Each read has the Primary state in a single region (or none)\n        // This is the region of maximum overlap for the read (earlier if tied)\n\n        // Contract: Each read has the Non-Primary state in all other regions it overlaps\n\n        // simple: Primary in 1:1-999\n        // overlap_equal: Primary in 1:1-999\n        // overlap_unequal: Primary in 1:1-999\n        // boundary_equal: Non-Primary in 1:1000-1999, Primary in 1:2000-2999\n        // boundary_unequal: Primary in 1:1000-1999, Non-Primary in 1:2000-2999\n        // extended_and_np: Non-Primary in 1:1-999, Primary in 1:1000-1999, Extended in 1:2000-2999\n        // outside_intervals: none\n        // simple20: Primary in 20:10000-10100\n\n        Map<GenomeLoc, ActiveRegion> activeRegions = getActiveRegions(walker, intervals);\n        ActiveRegion region;\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"1\", 1, 999));\n        verifyReadMapping(region, \"simple\", \"overlap_equal\", \"overlap_unequal\", \"extended_and_np\");\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"1\", 1000, 1999));\n        verifyReadMapping(region, \"boundary_equal\", \"boundary_unequal\", \"extended_and_np\");\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"1\", 2000, 2999));\n        verifyReadMapping(region, \"boundary_equal\", \"boundary_unequal\");\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"20\", 10000, 10100));\n        verifyReadMapping(region, \"simple20\");\n    }","id":33762,"modified_method":"@Test\n    public void testNonPrimaryReadMapping() {\n        DummyActiveRegionWalker walker = new DummyActiveRegionWalker(\n                EnumSet.of(ActiveRegionReadState.PRIMARY, ActiveRegionReadState.NONPRIMARY));\n\n        // Contract: Each read has the Primary state in a single region (or none)\n        // This is the region of maximum overlap for the read (earlier if tied)\n\n        // Contract: Each read has the Non-Primary state in all other regions it overlaps\n\n        // simple: Primary in 1:1-999\n        // overlap_equal: Primary in 1:1-999\n        // overlap_unequal: Primary in 1:1-999\n        // boundary_equal: Non-Primary in 1:1000-1999, Primary in 1:2000-2999\n        // boundary_unequal: Primary in 1:1000-1999, Non-Primary in 1:2000-2999\n        // boundary_1_pre: Primary in 1:1000-1999, Non-Primary in 1:2000-2999\n        // boundary_1_post: Non-Primary in 1:1000-1999, Primary in 1:2000-2999\n        // extended_and_np: Non-Primary in 1:1-999, Primary in 1:1000-1999, Extended in 1:2000-2999\n        // outside_intervals: none\n        // simple20: Primary in 20:10000-10100\n\n        Map<GenomeLoc, ActiveRegion> activeRegions = getActiveRegions(walker, intervals);\n        ActiveRegion region;\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"1\", 1, 999));\n        verifyReadMapping(region, \"simple\", \"overlap_equal\", \"overlap_unequal\", \"extended_and_np\");\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"1\", 1000, 1999));\n        verifyReadMapping(region, \"boundary_equal\", \"boundary_unequal\", \"extended_and_np\", \"boundary_1_pre\", \"boundary_1_post\");\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"1\", 2000, 2999));\n        verifyReadMapping(region, \"boundary_equal\", \"boundary_unequal\", \"boundary_1_pre\", \"boundary_1_post\");\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"20\", 10000, 10100));\n        verifyReadMapping(region, \"simple20\");\n    }","commit_id":"5c2c68d4e833c000204bd1c07cdd04fcc8fe448e","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testPrimaryReadMapping() {\n        DummyActiveRegionWalker walker = new DummyActiveRegionWalker();\n\n        // Contract: Each read has the Primary state in a single region (or none)\n        // This is the region of maximum overlap for the read (earlier if tied)\n\n        // simple: Primary in 1:1-999\n        // overlap_equal: Primary in 1:1-999\n        // overlap_unequal: Primary in 1:1-999\n        // boundary_equal: Non-Primary in 1:1000-1999, Primary in 1:2000-2999\n        // boundary_unequal: Primary in 1:1000-1999, Non-Primary in 1:2000-2999\n        // extended_and_np: Non-Primary in 1:1-999, Primary in 1:1000-1999, Extended in 1:2000-2999\n        // outside_intervals: none\n        // simple20: Primary in 20:10000-10100\n\n        Map<GenomeLoc, ActiveRegion> activeRegions = getActiveRegions(walker, intervals);\n        ActiveRegion region;\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"1\", 1, 999));\n        verifyReadMapping(region, \"simple\", \"overlap_equal\", \"overlap_unequal\");\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"1\", 1000, 1999));\n        verifyReadMapping(region, \"boundary_unequal\", \"extended_and_np\");\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"1\", 2000, 2999));\n        verifyReadMapping(region, \"boundary_equal\");\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"20\", 10000, 10100));\n        verifyReadMapping(region, \"simple20\");\n    }","id":33763,"modified_method":"@Test\n    public void testPrimaryReadMapping() {\n        DummyActiveRegionWalker walker = new DummyActiveRegionWalker();\n\n        // Contract: Each read has the Primary state in a single region (or none)\n        // This is the region of maximum overlap for the read (earlier if tied)\n\n        // simple: Primary in 1:1-999\n        // overlap_equal: Primary in 1:1-999\n        // overlap_unequal: Primary in 1:1-999\n        // boundary_equal: Non-Primary in 1:1000-1999, Primary in 1:2000-2999\n        // boundary_unequal: Primary in 1:1000-1999, Non-Primary in 1:2000-2999\n        // boundary_1_pre: Primary in 1:1000-1999, Non-Primary in 1:2000-2999\n        // boundary_1_post: Non-Primary in 1:1000-1999, Primary in 1:2000-2999\n        // extended_and_np: Non-Primary in 1:1-999, Primary in 1:1000-1999, Extended in 1:2000-2999\n        // outside_intervals: none\n        // simple20: Primary in 20:10000-10100\n\n        Map<GenomeLoc, ActiveRegion> activeRegions = getActiveRegions(walker, intervals);\n        ActiveRegion region;\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"1\", 1, 999));\n        verifyReadMapping(region, \"simple\", \"overlap_equal\", \"overlap_unequal\");\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"1\", 1000, 1999));\n        verifyReadMapping(region, \"boundary_unequal\", \"extended_and_np\", \"boundary_1_pre\");\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"1\", 2000, 2999));\n        verifyReadMapping(region, \"boundary_equal\", \"boundary_1_post\");\n\n        region = activeRegions.get(genomeLocParser.createGenomeLoc(\"20\", 10000, 10100));\n        verifyReadMapping(region, \"simple20\");\n    }","commit_id":"5c2c68d4e833c000204bd1c07cdd04fcc8fe448e","url":"https://github.com/broadgsa/gatk"},{"original_method":"@BeforeClass\n    private void init() throws FileNotFoundException {\n        reference = new CachingIndexedFastaSequenceFile(new File(hg19Reference));\n        dictionary = reference.getSequenceDictionary();\n        genomeLocParser = new GenomeLocParser(dictionary);\n\n        // TODO: test shard boundaries\n\n        intervals = new ArrayList<GenomeLoc>();\n        intervals.add(genomeLocParser.createGenomeLoc(\"1\", 10, 20));\n        intervals.add(genomeLocParser.createGenomeLoc(\"1\", 1, 999));\n        intervals.add(genomeLocParser.createGenomeLoc(\"1\", 1000, 1999));\n        intervals.add(genomeLocParser.createGenomeLoc(\"1\", 2000, 2999));\n        intervals.add(genomeLocParser.createGenomeLoc(\"1\", 10000, 20000));\n        intervals.add(genomeLocParser.createGenomeLoc(\"2\", 1, 100));\n        intervals.add(genomeLocParser.createGenomeLoc(\"20\", 10000, 10100));\n        intervals = IntervalUtils.sortAndMergeIntervals(genomeLocParser, intervals, IntervalMergingRule.OVERLAPPING_ONLY).toList();\n\n        List<GATKSAMRecord> reads = new ArrayList<GATKSAMRecord>();\n        reads.add(buildSAMRecord(\"simple\", \"1\", 100, 200));\n        reads.add(buildSAMRecord(\"overlap_equal\", \"1\", 10, 20));\n        reads.add(buildSAMRecord(\"overlap_unequal\", \"1\", 10, 21));\n        reads.add(buildSAMRecord(\"boundary_equal\", \"1\", 1990, 2009));\n        reads.add(buildSAMRecord(\"boundary_unequal\", \"1\", 1990, 2008));\n        reads.add(buildSAMRecord(\"extended_and_np\", \"1\", 990, 1990));\n        reads.add(buildSAMRecord(\"outside_intervals\", \"1\", 5000, 6000));\n        reads.add(buildSAMRecord(\"simple20\", \"20\", 10025, 10075));\n\n        createBAM(reads);\n    }","id":33764,"modified_method":"@BeforeClass\n    private void init() throws FileNotFoundException {\n        reference = new CachingIndexedFastaSequenceFile(new File(hg19Reference));\n        dictionary = reference.getSequenceDictionary();\n        genomeLocParser = new GenomeLocParser(dictionary);\n\n        // TODO: test shard boundaries\n\n        intervals = new ArrayList<GenomeLoc>();\n        intervals.add(genomeLocParser.createGenomeLoc(\"1\", 10, 20));\n        intervals.add(genomeLocParser.createGenomeLoc(\"1\", 1, 999));\n        intervals.add(genomeLocParser.createGenomeLoc(\"1\", 1000, 1999));\n        intervals.add(genomeLocParser.createGenomeLoc(\"1\", 2000, 2999));\n        intervals.add(genomeLocParser.createGenomeLoc(\"1\", 10000, 20000));\n        intervals.add(genomeLocParser.createGenomeLoc(\"2\", 1, 100));\n        intervals.add(genomeLocParser.createGenomeLoc(\"20\", 10000, 10100));\n        intervals = IntervalUtils.sortAndMergeIntervals(genomeLocParser, intervals, IntervalMergingRule.OVERLAPPING_ONLY).toList();\n\n        List<GATKSAMRecord> reads = new ArrayList<GATKSAMRecord>();\n        reads.add(buildSAMRecord(\"simple\", \"1\", 100, 200));\n        reads.add(buildSAMRecord(\"overlap_equal\", \"1\", 10, 20));\n        reads.add(buildSAMRecord(\"overlap_unequal\", \"1\", 10, 21));\n        reads.add(buildSAMRecord(\"boundary_equal\", \"1\", 1990, 2009));\n        reads.add(buildSAMRecord(\"boundary_unequal\", \"1\", 1990, 2008));\n        reads.add(buildSAMRecord(\"boundary_1_pre\", \"1\", 1950, 2000));\n        reads.add(buildSAMRecord(\"boundary_1_post\", \"1\", 1999, 2050));\n        reads.add(buildSAMRecord(\"extended_and_np\", \"1\", 990, 1990));\n        reads.add(buildSAMRecord(\"outside_intervals\", \"1\", 5000, 6000));\n        reads.add(buildSAMRecord(\"simple20\", \"20\", 10025, 10075));\n\n        createBAM(reads);\n    }","commit_id":"5c2c68d4e833c000204bd1c07cdd04fcc8fe448e","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n   * Tests that the {@link AlertSummaryRenderer} correctly transforms the alert\n   * data.\n   *\n   * @throws Exception\n   */\n  @Test\n  public void testGetClusterSummary() throws Exception {\n    expect(m_dao.findCurrentByCluster(captureLong(new Capture<Long>()))).andReturn(\n        getMockEntitiesManyStates()).anyTimes();\n\n    replay(m_dao);\n\n    Request request = PropertyHelper.getReadRequest(\n        AlertResourceProvider.ALERT_ID, AlertResourceProvider.ALERT_DEFINITION_NAME,\n        AlertResourceProvider.ALERT_LABEL, AlertResourceProvider.ALERT_STATE,\n        AlertResourceProvider.ALERT_ORIGINAL_TIMESTAMP);\n\n    Predicate predicate = new PredicateBuilder().property(\n        AlertResourceProvider.ALERT_CLUSTER_NAME).equals(\"c1\").toPredicate();\n\n    AlertResourceProvider provider = createProvider();\n    Set<Resource> results = provider.getResources(request, predicate);\n\n    verify(m_dao);\n\n    AlertSummaryRenderer renderer = new AlertSummaryRenderer();\n    ResultImpl result = new ResultImpl(true);\n    TreeNode<Resource> resources = result.getResultTree();\n\n    AtomicInteger alertResourceId = new AtomicInteger(1);\n    for (Resource resource : results) {\n      resources.addChild(resource, \"Alert \" + alertResourceId.getAndIncrement());\n    }\n\n    Result summary = renderer.finalizeResult(result);\n    Assert.assertNotNull(summary);\n\n    // pull out the alerts_summary child set by the renderer\n    TreeNode<Resource> summaryResultTree = summary.getResultTree();\n    TreeNode<Resource> summaryResources = summaryResultTree.getChild(\"alerts_summary\");\n\n    Resource summaryResource = summaryResources.getObject();\n\n    Integer okCount = (Integer) summaryResource.getPropertyValue(\"alerts_summary/OK/count\");\n    Integer warningCount = (Integer) summaryResource.getPropertyValue(\"alerts_summary/WARNING/count\");\n    Integer criticalCount = (Integer) summaryResource.getPropertyValue(\"alerts_summary/CRITICAL/count\");\n    Integer unknownCount = (Integer) summaryResource.getPropertyValue(\"alerts_summary/UNKNOWN/count\");\n\n    Assert.assertEquals(10, okCount.intValue());\n    Assert.assertEquals(2, warningCount.intValue());\n    Assert.assertEquals(1, criticalCount.intValue());\n    Assert.assertEquals(3, unknownCount.intValue());\n  }","id":33765,"modified_method":"/**\n   * Tests that the {@link AlertSummaryRenderer} correctly transforms the alert\n   * data.\n   *\n   * @throws Exception\n   */\n  @Test\n  public void testGetClusterSummary() throws Exception {\n    expect(m_dao.findCurrentByCluster(captureLong(new Capture<Long>()))).andReturn(\n        getMockEntitiesManyStates()).anyTimes();\n\n    replay(m_dao);\n\n    Request request = PropertyHelper.getReadRequest(\n        AlertResourceProvider.ALERT_ID, AlertResourceProvider.ALERT_DEFINITION_NAME,\n        AlertResourceProvider.ALERT_LABEL, AlertResourceProvider.ALERT_STATE,\n        AlertResourceProvider.ALERT_ORIGINAL_TIMESTAMP);\n\n    Predicate predicate = new PredicateBuilder().property(\n        AlertResourceProvider.ALERT_CLUSTER_NAME).equals(\"c1\").toPredicate();\n\n    AlertResourceProvider provider = createProvider();\n    Set<Resource> results = provider.getResources(request, predicate);\n\n    verify(m_dao);\n\n    AlertSummaryRenderer renderer = new AlertSummaryRenderer();\n    ResultImpl result = new ResultImpl(true);\n    TreeNode<Resource> resources = result.getResultTree();\n\n    AtomicInteger alertResourceId = new AtomicInteger(1);\n    for (Resource resource : results) {\n      resources.addChild(resource, \"Alert \" + alertResourceId.getAndIncrement());\n    }\n\n    Result summary = renderer.finalizeResult(result);\n    Assert.assertNotNull(summary);\n\n    // pull out the alerts_summary child set by the renderer\n    TreeNode<Resource> summaryResultTree = summary.getResultTree();\n    TreeNode<Resource> summaryResources = summaryResultTree.getChild(\"alerts_summary\");\n\n    Resource summaryResource = summaryResources.getObject();\n    AlertStateSummary alertStateSummary = (AlertStateSummary) summaryResource.getPropertyValue(\"alerts_summary\");\n\n    Assert.assertEquals(10, alertStateSummary.Ok.Count);\n    Assert.assertEquals(2, alertStateSummary.Warning.Count);\n    Assert.assertEquals(1, alertStateSummary.Critical.Count);\n    Assert.assertEquals(3, alertStateSummary.Unknown.Count);\n  }","commit_id":"acf4de18438aca9f6a05c4b0a9a1c5ac4d2c8f1d","url":"https://github.com/apache/ambari"},{"original_method":"private AlertResourceProvider createProvider() {\n    return new AlertResourceProvider(m_amc);\n  }","id":33766,"modified_method":"/**\n   * @return\n   */\n  private AlertResourceProvider createProvider() {\n    return new AlertResourceProvider(m_amc);\n  }","commit_id":"acf4de18438aca9f6a05c4b0a9a1c5ac4d2c8f1d","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * {@inheritDoc}\n   * <p/>\n   * Additionally adds {@link AlertResourceProvider#ALERT_ID} and\n   * {@link AlertResourceProvider#ALERT_DEFINITION_NAME}.\n   */\n  @Override\n  protected void addRequiredAlertProperties(Set<String> properties) {\n    super.addRequiredAlertProperties(properties);\n\n    properties.add(AlertResourceProvider.ALERT_ID);\n    properties.add(AlertResourceProvider.ALERT_DEFINITION_NAME);\n  }","id":33767,"modified_method":"/**\n   * {@inheritDoc}\n   * <p/>\n   * Additionally adds {@link AlertResourceProvider#ALERT_ID} and\n   * {@link AlertResourceProvider#ALERT_DEFINITION_NAME}.\n   */\n  @Override\n  protected void addRequiredAlertProperties(Set<String> properties) {\n    super.addRequiredAlertProperties(properties);\n\n    properties.add(AlertResourceProvider.ALERT_ID);\n    properties.add(AlertResourceProvider.ALERT_DEFINITION_NAME);\n    properties.add(AlertResourceProvider.ALERT_MAINTENANCE_STATE);\n  }","commit_id":"acf4de18438aca9f6a05c4b0a9a1c5ac4d2c8f1d","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * {@inheritDoc}\n   * <p/>\n   * This will iterate over all of the nodes in the result tree and combine\n   * their {@link AlertResourceProvider#ALERT_STATE} into a single summary\n   * structure.\n   */\n  @Override\n  public Result finalizeResult(Result queryResult) {\n    TreeNode<Resource> resultTree = queryResult.getResultTree();\n    Map<String, AlertDefinitionSummary> summaries = new HashMap<String, AlertDefinitionSummary>();\n\n    // iterate over all returned flattened alerts and build the summary info\n    for (TreeNode<Resource> node : resultTree.getChildren()) {\n      Resource resource = node.getObject();\n\n      Long definitionId = (Long) resource.getPropertyValue(AlertResourceProvider.ALERT_DEFINITION_ID);\n      String definitionName = (String) resource.getPropertyValue(AlertResourceProvider.ALERT_DEFINITION_NAME);\n      AlertState state = (AlertState) resource.getPropertyValue(AlertResourceProvider.ALERT_STATE);\n      Long originalTimestampObject = (Long) resource.getPropertyValue(AlertResourceProvider.ALERT_ORIGINAL_TIMESTAMP);\n\n      // NPE sanity\n      if (null == state) {\n        state = AlertState.UNKNOWN;\n      }\n\n      // NPE sanity\n      long originalTimestamp = 0;\n      if (null != originalTimestampObject) {\n        originalTimestamp = originalTimestampObject.longValue();\n      }\n\n      // create the group summary info if it doesn't exist yet\n      AlertDefinitionSummary groupSummaryInfo = summaries.get(definitionName);\n      if (null == groupSummaryInfo) {\n        groupSummaryInfo = new AlertDefinitionSummary();\n        groupSummaryInfo.Id = definitionId;\n        groupSummaryInfo.Name = definitionName;\n\n        summaries.put(definitionName, groupSummaryInfo);\n      }\n\n      // set and increment the correct values based on state\n      switch (state) {\n        case CRITICAL: {\n          groupSummaryInfo.State.Critical.Count++;\n\n          if (originalTimestamp > groupSummaryInfo.State.Critical.Timestamp) {\n            groupSummaryInfo.State.Critical.Timestamp = originalTimestamp;\n          }\n\n          break;\n        }\n        case OK: {\n          groupSummaryInfo.State.Ok.Count++;\n\n          if (originalTimestamp > groupSummaryInfo.State.Ok.Timestamp) {\n            groupSummaryInfo.State.Ok.Timestamp = originalTimestamp;\n          }\n\n          break;\n        }\n        case WARNING: {\n          groupSummaryInfo.State.Warning.Count++;\n\n          if (originalTimestamp > groupSummaryInfo.State.Warning.Timestamp) {\n            groupSummaryInfo.State.Warning.Timestamp = originalTimestamp;\n          }\n\n          break;\n        }\n        default:\n        case UNKNOWN: {\n          groupSummaryInfo.State.Unknown.Count++;\n\n          if (originalTimestamp > groupSummaryInfo.State.Unknown.Timestamp) {\n            groupSummaryInfo.State.Unknown.Timestamp = originalTimestamp;\n          }\n\n          break;\n        }\n      }\n    }\n\n    Set<Entry<String, AlertDefinitionSummary>> entrySet = summaries.entrySet();\n    List<AlertDefinitionSummary> groupedResources = new ArrayList<AlertDefinitionSummary>(\n        entrySet.size());\n\n    // iterate over all summary groups, adding them to the final list\n    for (Entry<String, AlertDefinitionSummary> entry : entrySet) {\n      groupedResources.add(entry.getValue());\n    }\n\n    Result groupedSummary = new ResultImpl(true);\n    TreeNode<Resource> summaryTree = groupedSummary.getResultTree();\n\n    Resource resource = new ResourceImpl(Resource.Type.Alert);\n    summaryTree.addChild(resource, ALERTS_SUMMARY_GROUP);\n\n    resource.setProperty(ALERTS_SUMMARY_GROUP, groupedResources);\n    return groupedSummary;\n  }","id":33768,"modified_method":"/**\n   * {@inheritDoc}\n   * <p/>\n   * This will iterate over all of the nodes in the result tree and combine\n   * their {@link AlertResourceProvider#ALERT_STATE} into a single summary\n   * structure.\n   */\n  @Override\n  public Result finalizeResult(Result queryResult) {\n    TreeNode<Resource> resultTree = queryResult.getResultTree();\n    Map<String, AlertDefinitionSummary> summaries = new HashMap<String, AlertDefinitionSummary>();\n\n    // iterate over all returned flattened alerts and build the summary info\n    for (TreeNode<Resource> node : resultTree.getChildren()) {\n      Resource resource = node.getObject();\n\n      Long definitionId = (Long) resource.getPropertyValue(AlertResourceProvider.ALERT_DEFINITION_ID);\n      String definitionName = (String) resource.getPropertyValue(AlertResourceProvider.ALERT_DEFINITION_NAME);\n      AlertState state = (AlertState) resource.getPropertyValue(AlertResourceProvider.ALERT_STATE);\n      Long originalTimestampObject = (Long) resource.getPropertyValue(AlertResourceProvider.ALERT_ORIGINAL_TIMESTAMP);\n      MaintenanceState maintenanceState = (MaintenanceState) resource.getPropertyValue(AlertResourceProvider.ALERT_MAINTENANCE_STATE);\n\n      // NPE sanity\n      if (null == state) {\n        state = AlertState.UNKNOWN;\n      }\n\n      // NPE sanity\n      long originalTimestamp = 0;\n      if (null != originalTimestampObject) {\n        originalTimestamp = originalTimestampObject.longValue();\n      }\n\n      // NPE sanity\n      boolean isMaintenanceModeEnabled = false;\n      if (null != maintenanceState && maintenanceState != MaintenanceState.OFF) {\n        isMaintenanceModeEnabled = true;\n      }\n\n      // create the group summary info if it doesn't exist yet\n      AlertDefinitionSummary groupSummaryInfo = summaries.get(definitionName);\n      if (null == groupSummaryInfo) {\n        groupSummaryInfo = new AlertDefinitionSummary();\n        groupSummaryInfo.Id = definitionId;\n        groupSummaryInfo.Name = definitionName;\n\n        summaries.put(definitionName, groupSummaryInfo);\n      }\n\n      // set and increment the correct values based on state\n      final AlertStateValues alertStateValues;\n      switch (state) {\n        case CRITICAL: {\n          alertStateValues = groupSummaryInfo.State.Critical;\n          break;\n        }\n        case OK: {\n          alertStateValues = groupSummaryInfo.State.Ok;\n          break;\n        }\n        case WARNING: {\n          alertStateValues = groupSummaryInfo.State.Warning;\n          break;\n        }\n        default:\n        case UNKNOWN: {\n          alertStateValues = groupSummaryInfo.State.Unknown;\n          break;\n        }\n      }\n\n      // update the maintenance count if in MM is enabled, otherwise the\n      // regular count\n      if (isMaintenanceModeEnabled) {\n        alertStateValues.MaintenanceCount++;\n      } else {\n        alertStateValues.Count++;\n      }\n\n      // track the most recent timestamp if state change\n      if (originalTimestamp > alertStateValues.Timestamp) {\n        alertStateValues.Timestamp = originalTimestamp;\n      }\n    }\n\n    Set<Entry<String, AlertDefinitionSummary>> entrySet = summaries.entrySet();\n    List<AlertDefinitionSummary> groupedResources = new ArrayList<AlertDefinitionSummary>(\n        entrySet.size());\n\n    // iterate over all summary groups, adding them to the final list\n    for (Entry<String, AlertDefinitionSummary> entry : entrySet) {\n      groupedResources.add(entry.getValue());\n    }\n\n    Result groupedSummary = new ResultImpl(true);\n    TreeNode<Resource> summaryTree = groupedSummary.getResultTree();\n\n    Resource resource = new ResourceImpl(Resource.Type.Alert);\n    summaryTree.addChild(resource, ALERTS_SUMMARY_GROUP);\n\n    resource.setProperty(ALERTS_SUMMARY_GROUP, groupedResources);\n    return groupedSummary;\n  }","commit_id":"acf4de18438aca9f6a05c4b0a9a1c5ac4d2c8f1d","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Adds properties to the backend request that are required by this renderer.\n   * This method currently adds {@link AlertResourceProvider#ALERT_STATE} and\n   * {@link AlertResourceProvider#ALERT_ORIGINAL_TIMESTAMP}.\n   *\n   * @param properties\n   *          the properties collection to add to.\n   */\n  protected void addRequiredAlertProperties(Set<String> properties) {\n    properties.add(AlertResourceProvider.ALERT_STATE);\n    properties.add(AlertResourceProvider.ALERT_ORIGINAL_TIMESTAMP);\n  }","id":33769,"modified_method":"/**\n   * Adds properties to the backend request that are required by this renderer.\n   * This method currently adds {@link AlertResourceProvider#ALERT_STATE} and\n   * {@link AlertResourceProvider#ALERT_ORIGINAL_TIMESTAMP}.\n   *\n   * @param properties\n   *          the properties collection to add to.\n   */\n  protected void addRequiredAlertProperties(Set<String> properties) {\n    properties.add(AlertResourceProvider.ALERT_STATE);\n    properties.add(AlertResourceProvider.ALERT_ORIGINAL_TIMESTAMP);\n    properties.add(AlertResourceProvider.ALERT_MAINTENANCE_STATE);\n  }","commit_id":"acf4de18438aca9f6a05c4b0a9a1c5ac4d2c8f1d","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * {@inheritDoc}\n   * <p/>\n   * This will iterate over all of the nodes in the result tree and combine\n   * their {@link AlertResourceProvider#ALERT_STATE} into a single summary\n   * structure.\n   */\n  @Override\n  public Result finalizeResult(Result queryResult) {\n    TreeNode<Resource> resultTree = queryResult.getResultTree();\n    Result summary = new ResultImpl(true);\n\n    // counts\n    int ok = 0;\n    int warning = 0;\n    int critical = 0;\n    int unknown = 0;\n\n    // keeps track of the most recent state change\n    // (not the most recent alert received)\n    long mostRecentOK = 0;\n    long mostRecentWarning = 0;\n    long mostRecentCritical = 0;\n    long mostRecentUnknown = 0;\n\n    // iterate over all returned flattened alerts and build the summary info\n    for (TreeNode<Resource> node : resultTree.getChildren()) {\n      Resource resource = node.getObject();\n      AlertState state = (AlertState) resource.getPropertyValue(AlertResourceProvider.ALERT_STATE);\n      Long originalTimestampObject = (Long) resource.getPropertyValue(AlertResourceProvider.ALERT_ORIGINAL_TIMESTAMP);\n\n      // NPE sanity\n      if (null == state) {\n        state = AlertState.UNKNOWN;\n      }\n\n      // NPE sanity\n      long originalTimestamp = 0;\n      if (null != originalTimestampObject) {\n        originalTimestamp = originalTimestampObject.longValue();\n      }\n\n      switch (state) {\n        case CRITICAL: {\n          critical++;\n\n          if (originalTimestamp > mostRecentCritical) {\n            mostRecentCritical = originalTimestamp;\n          }\n\n          break;\n        }\n        case OK: {\n          ok++;\n\n          if (originalTimestamp > mostRecentOK) {\n            mostRecentOK = originalTimestamp;\n          }\n\n          break;\n        }\n        case WARNING: {\n          warning++;\n\n          if (originalTimestamp > mostRecentWarning) {\n            mostRecentWarning = originalTimestamp;\n          }\n\n          break;\n        }\n        default:\n        case UNKNOWN: {\n          unknown++;\n\n          if (originalTimestamp > mostRecentUnknown) {\n            mostRecentUnknown = originalTimestamp;\n          }\n\n          break;\n        }\n      }\n    }\n\n    Resource resource = new ResourceImpl(Resource.Type.Alert);\n    resource.setProperty(OK_COUNT_PROPERTY, ok);\n    resource.setProperty(WARN_COUNT_PROPERTY, warning);\n    resource.setProperty(CRITICAL_COUNT_PROPERTY, critical);\n    resource.setProperty(UNKNOWN_COUNT_PROPERTY, unknown);\n\n    resource.setProperty(OK_TIMESTAMP_PROPERTY, mostRecentOK);\n    resource.setProperty(WARN_TIMESTAMP_PROPERTY, mostRecentWarning);\n    resource.setProperty(CRITICAL_TIMESTAMP_PROPERTY, mostRecentCritical);\n    resource.setProperty(UNKNOWN_TIMESTAMP_PROPERTY, mostRecentUnknown);\n\n    TreeNode<Resource> summaryTree = summary.getResultTree();\n    summaryTree.addChild(resource, \"alerts_summary\");\n\n    return summary;\n  }","id":33770,"modified_method":"/**\n   * {@inheritDoc}\n   * <p/>\n   * This will iterate over all of the nodes in the result tree and combine\n   * their {@link AlertResourceProvider#ALERT_STATE} into a single summary\n   * structure.\n   */\n  @Override\n  public Result finalizeResult(Result queryResult) {\n    TreeNode<Resource> resultTree = queryResult.getResultTree();\n    AlertStateSummary alertSummary = new AlertStateSummary();\n\n    // iterate over all returned flattened alerts and build the summary info\n    for (TreeNode<Resource> node : resultTree.getChildren()) {\n      Resource resource = node.getObject();\n      AlertState state = (AlertState) resource.getPropertyValue(AlertResourceProvider.ALERT_STATE);\n      Long originalTimestampObject = (Long) resource.getPropertyValue(AlertResourceProvider.ALERT_ORIGINAL_TIMESTAMP);\n      MaintenanceState maintenanceState = (MaintenanceState) resource.getPropertyValue(AlertResourceProvider.ALERT_MAINTENANCE_STATE);\n\n      // NPE sanity\n      if (null == state) {\n        state = AlertState.UNKNOWN;\n      }\n\n      // NPE sanity\n      long originalTimestamp = 0;\n      if (null != originalTimestampObject) {\n        originalTimestamp = originalTimestampObject.longValue();\n      }\n\n      // NPE sanity\n      boolean isMaintenanceModeEnabled = false;\n      if (null != maintenanceState && maintenanceState != MaintenanceState.OFF) {\n        isMaintenanceModeEnabled = true;\n      }\n\n      final AlertStateValues alertStateValues;\n      switch (state) {\n        case CRITICAL: {\n          alertStateValues = alertSummary.Critical;\n          break;\n        }\n        case OK: {\n          alertStateValues = alertSummary.Ok;\n          break;\n        }\n        case WARNING: {\n          alertStateValues = alertSummary.Warning;\n          break;\n        }\n        default:\n        case UNKNOWN: {\n          alertStateValues = alertSummary.Unknown;\n          break;\n        }\n      }\n\n      if (isMaintenanceModeEnabled) {\n        alertStateValues.MaintenanceCount++;\n      } else {\n        alertStateValues.Count++;\n      }\n\n      if (originalTimestamp > alertStateValues.Timestamp) {\n        alertStateValues.Timestamp = originalTimestamp;\n      }\n    }\n\n    Result summary = new ResultImpl(true);\n    Resource resource = new ResourceImpl(Resource.Type.Alert);\n    TreeNode<Resource> summaryTree = summary.getResultTree();\n    summaryTree.addChild(resource, \"alerts_summary\");\n    resource.setProperty(\"alerts_summary\", alertSummary);\n\n    return summary;\n  }","commit_id":"acf4de18438aca9f6a05c4b0a9a1c5ac4d2c8f1d","url":"https://github.com/apache/ambari"},{"original_method":"private boolean isDomainAssociation() {\n        return (Collection.class.isAssignableFrom(this.type) || Map.class.isAssignableFrom(this.type)) && this.referencedPropertyType != null;\n    }","id":33771,"modified_method":"private boolean isDomainAssociation() {\n\t\treturn (Collection.class.isAssignableFrom(type) || Map.class.isAssignableFrom(type)) &&\n\t\t\treferencedPropertyType != null;\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public boolean isIdentity() {\n\t\treturn this.identity;\n\t}","id":33772,"modified_method":"public boolean isIdentity() {\n\t\treturn identity;\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public int getFetchMode() {\n\t\treturn this.fetchMode ;\n\t}","id":33773,"modified_method":"public int getFetchMode() {\n\t\treturn fetchMode ;\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public String toString() {\n        String assType = null;\n        if(isManyToMany()) {\n            assType = \"many-to-many\";\n        }\n        else if(isOneToMany()) {\n            assType = \"one-to-many\";\n        }\n        else if(isOneToOne()) {\n            assType = \"one-to-one\";\n        }\n        else if(isManyToOne()) {\n            assType = \"many-to-one\";\n        }\n        else if(isEmbedded()) {\n            assType = \"embedded\";\n        }\n        return new ToStringBuilder(this)\n                        .append(\"name\", this.name)\n                        .append(\"type\", this.type)\n                        .append(\"persistent\", isPersistent())\n                        .append(\"optional\", isOptional())\n                        .append(\"association\", isAssociation())\n                        .append(\"bidirectional\", isBidirectional())\n                        .append(\"association-type\", assType)\n                        .toString();\n    }","id":33774,"modified_method":"@Override\n\tpublic String toString() {\n\t\tString assType = null;\n\t\tif (isManyToMany()) {\n\t\t\tassType = \"many-to-many\";\n\t\t}\n\t\telse if (isOneToMany()) {\n\t\t\tassType = \"one-to-many\";\n\t\t}\n\t\telse if (isOneToOne()) {\n\t\t\tassType = \"one-to-one\";\n\t\t}\n\t\telse if (isManyToOne()) {\n\t\t\tassType = \"many-to-one\";\n\t\t}\n\t\telse if (isEmbedded()) {\n\t\t\tassType = \"embedded\";\n\t\t}\n\t\treturn new ToStringBuilder(this)\n\t\t           .append(\"name\", name)\n\t\t           .append(\"type\", type)\n\t\t           .append(\"persistent\", isPersistent())\n\t\t           .append(\"optional\", isOptional())\n\t\t           .append(\"association\", isAssociation())\n\t\t           .append(\"bidirectional\", isBidirectional())\n\t\t           .append(\"association-type\", assType)\n\t\t           .toString();\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public GrailsDomainClass getComponent() {\n        return this.component;\n    }","id":33775,"modified_method":"public GrailsDomainClass getComponent() {\n\t\treturn component;\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public boolean isPersistent() {\n\t\treturn this.persistant;\n\t}","id":33776,"modified_method":"public boolean isPersistent() {\n\t\treturn persistant;\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public ComponentDomainClass(Class type) {\n            super(type, \"\");\n\n            PropertyDescriptor[] descriptors = getPropertyDescriptors();\n\n            List tmp = getPropertyValue(GrailsDomainClassProperty.TRANSIENT, List.class);\n            if(tmp!=null) this.transients = tmp;\n            this.properties = createDomainClassProperties(this,descriptors);\n            this.constraints = GrailsDomainConfigurationUtil.evaluateConstraints(getClazz(), properties);\n            DomainClassGrailsPlugin.registerConstraintsProperty(getMetaClass(), this);\n        }","id":33777,"modified_method":"@SuppressWarnings(\"unchecked\")\n\t\tpublic ComponentDomainClass(Class<?> type) {\n\t\t\tsuper(type, \"\");\n\n\t\t\tPropertyDescriptor[] descriptors = getPropertyDescriptors();\n\n\t\t\tList tmp = getPropertyValue(GrailsDomainClassProperty.TRANSIENT, List.class);\n\t\t\tif (tmp!=null) transients = tmp;\n\t\t\tproperties = createDomainClassProperties(this,descriptors);\n\t\t\tconstraints = GrailsDomainConfigurationUtil.evaluateConstraints(getClazz(), properties);\n\t\t\tDomainClassGrailsPlugin.registerConstraintsProperty(getMetaClass(), this);\n\t\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n\t * Checks whether this property is transient\n\t * \n\t * @param transientProps The transient properties\n\t */\n\tprivate void checkIfTransient(List transientProps) {\n\t\tif(transientProps != null) {\n            for(Iterator i = transientProps.iterator();i.hasNext();) {\n\n                // make sure its a string otherwise ignore. Note: Again maybe a warning?\n                Object currentObj = i.next();\n                if(currentObj instanceof String) {\n                    String propertyName = (String)currentObj;\n                    // if the property name is on the not persistant list\n                    // then set persistant to false\n                    if(propertyName.equals( this.name )) {\n                        this.persistant = false;\n                        break;\n                    }\n                }\n            }\n        }\n\t}","id":33778,"modified_method":"/**\n\t * Checks whether this property is transient\n\t *\n\t * @param transientProps The transient properties\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprivate void checkIfTransient(List transientProps) {\n\t\tif (transientProps == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (Object currentObj : transientProps) {\n\t\t\t// make sure its a string otherwise ignore. Note: Again maybe a warning?\n\t\t\tif (currentObj instanceof String) {\n\t\t\t\tString propertyName = (String)currentObj;\n\t\t\t\t// if the property name is on the not persistant list\n\t\t\t\t// then set persistant to false\n\t\t\t\tif (propertyName.equals(name)) {\n\t\t\t\t\tpersistant = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public void setEmbedded(boolean isEmbedded) {\n        this.embedded = isEmbedded;\n        if(isEmbedded) {\n            this.component = new ComponentDomainClass(getType());\n        }\n    }","id":33779,"modified_method":"public void setEmbedded(boolean isEmbedded) {\n\t\tembedded = isEmbedded;\n\t\tif (isEmbedded) {\n\t\t\tcomponent = new ComponentDomainClass(getType());\n\t\t}\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public boolean isManyToMany() {\n\t\treturn this.manyToMany;\n\t}","id":33780,"modified_method":"public boolean isManyToMany() {\n\t\treturn manyToMany;\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public void refreshConstraints() {\n            GrailsDomainClassProperty[] props = getPersistentProperties();\n            this.constraints = GrailsDomainConfigurationUtil.evaluateConstraints(\n                    getClazz(),\n                    props);\n        }","id":33781,"modified_method":"public void refreshConstraints() {\n\t\t\tGrailsDomainClassProperty[] props = getPersistentProperties();\n\t\t\tconstraints = GrailsDomainConfigurationUtil.evaluateConstraints(\n\t\t\t\t\tgetClazz(),\n\t\t\t\t\tprops);\n\t\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public void setOwningSide(boolean b) {\n\t\tthis.owningSide = b;\n\t}","id":33782,"modified_method":"public void setOwningSide(boolean b) {\n\t\towningSide = b;\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public boolean isManyToOne() {\n\t\treturn this.manyToOne;\n\t}","id":33783,"modified_method":"public boolean isManyToOne() {\n\t\treturn manyToOne;\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public void setReferencePropertyName(String name) {\n\t\tthis.referencePropertyName = name;\n\t}","id":33784,"modified_method":"public void setReferencePropertyName(String name) {\n\t\treferencePropertyName = name;\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public String getReferencedPropertyName() {\n\t\treturn this.referencePropertyName;\n\t}","id":33785,"modified_method":"public String getReferencedPropertyName() {\n\t\treturn referencePropertyName;\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public GrailsDomainClassProperty getOtherSide() {\n\t\treturn this.otherSide;\n\t}","id":33786,"modified_method":"public GrailsDomainClassProperty getOtherSide() {\n\t\treturn otherSide;\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n\t * Sets the referenced property type of this property\n\t */\n\tprotected void setReferencedPropertyType(Class referencedPropertyType) {\n\t\tthis.referencedPropertyType = referencedPropertyType;\n\t}","id":33787,"modified_method":"/**\n\t * Sets the referenced property type of this property\n\t */\n\tprotected void setReferencedPropertyType(Class<?> referencedPropertyType) {\n\t\tthis.referencedPropertyType = referencedPropertyType;\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public Class getReferencedPropertyType() {\n\t\tif(isDomainAssociation()) {\n\t\t\treturn this.referencedPropertyType;\n\t\t}\n\t\telse {\n\t\t\treturn getType();\n\t\t}\n\t}","id":33788,"modified_method":"@SuppressWarnings(\"unchecked\")\n\tpublic Class getReferencedPropertyType() {\n\t\tif (isDomainAssociation()) {\n\t\t\treturn referencedPropertyType;\n\t\t}\n\n\t\treturn getType();\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public String getName() {\n\t\treturn this.name;\n\t}","id":33789,"modified_method":"public String getName() {\n\t\treturn name;\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public GrailsDomainClass getReferencedDomainClass() {\n\t\treturn this.referencedDomainClass;\n\t}","id":33790,"modified_method":"public GrailsDomainClass getReferencedDomainClass() {\n\t\treturn referencedDomainClass;\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"private GrailsDomainClassProperty[] createDomainClassProperties(ComponentDomainClass type, PropertyDescriptor[] descriptors) {\n            List properties = new ArrayList();\n            for (int i = 0; i < descriptors.length; i++) {\n                PropertyDescriptor descriptor = descriptors[i];\n                if(isPersistentProperty(descriptor)) {\n                    properties.add(new DefaultGrailsDomainClassProperty(type,descriptor));\n                }\n            }\n            return (GrailsDomainClassProperty[])properties.toArray(new GrailsDomainClassProperty[properties.size()]);\n        }","id":33791,"modified_method":"private GrailsDomainClassProperty[] createDomainClassProperties(\n\t\t\t\tComponentDomainClass type, PropertyDescriptor[] descriptors) {\n\n\t\t\tList<DefaultGrailsDomainClassProperty> props = new ArrayList<DefaultGrailsDomainClassProperty>();\n\t\t\tfor (int i = 0; i < descriptors.length; i++) {\n\t\t\t\tPropertyDescriptor descriptor = descriptors[i];\n\t\t\t\tif (isPersistentProperty(descriptor)) {\n\t\t\t\t\tprops.add(new DefaultGrailsDomainClassProperty(type,descriptor));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn props.toArray(new GrailsDomainClassProperty[props.size()]);\n\t\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public Map getAssociationMap() {\n            return Collections.EMPTY_MAP;\n        }","id":33792,"modified_method":"@SuppressWarnings(\"unchecked\")\n\t\tpublic Map getAssociationMap() {\n\t\t\treturn Collections.emptyMap();\n\t\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public Set getSubClasses() {\n            return Collections.EMPTY_SET;\n        }","id":33793,"modified_method":"@SuppressWarnings(\"unchecked\")\n\t\tpublic Set getSubClasses() {\n\t\t\treturn Collections.emptySet();\n\t\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public Map getMappedBy() {\n            return Collections.EMPTY_MAP;\n        }","id":33794,"modified_method":"@SuppressWarnings(\"unchecked\")\n\t\tpublic Map getMappedBy() {\n\t\t\treturn Collections.emptyMap();\n\t\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public Map getConstrainedProperties() {\n            return this.constraints;\n        }","id":33795,"modified_method":"@SuppressWarnings(\"unchecked\")\n\t\tpublic Map getConstrainedProperties() {\n\t\t\treturn constraints;\n\t\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public void setOtherSide(GrailsDomainClassProperty property) {\n        if(!this.equals(property)) {\n            setBidirectional(true);\n            if(isOneToOne() && property.isOneToMany()) {\n                setOneToOne(false);\n                setManyToOne(true);\n            }\n        }\n        this.otherSide = property;\n\t}","id":33796,"modified_method":"public void setOtherSide(GrailsDomainClassProperty property) {\n\t\tif (!equals(property)) {\n\t\t\tsetBidirectional(true);\n\t\t\tif (isOneToOne() && property.isOneToMany()) {\n\t\t\t\tsetOneToOne(false);\n\t\t\t\tsetManyToOne(true);\n\t\t\t}\n\t\t}\n\t\totherSide = property;\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public Class getType() {\n\t\treturn this.type;\n\t}","id":33797,"modified_method":"@SuppressWarnings(\"unchecked\")\n\tpublic Class getType() {\n\t\treturn type;\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public String getTypePropertyName() {\t\n\t\tString shortTypeName = ClassUtils.getShortClassName( this.type );\n\t\treturn shortTypeName.substring(0,1).toLowerCase(Locale.ENGLISH) + shortTypeName.substring(1);\n\t}","id":33798,"modified_method":"public String getTypePropertyName() {\n\t\tString shortTypeName = ClassUtils.getShortClassName(type);\n\t\treturn shortTypeName.substring(0,1).toLowerCase(Locale.ENGLISH) + shortTypeName.substring(1);\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public GrailsDomainClass getDomainClass() {\n\t\treturn this.domainClass;\n\t}","id":33799,"modified_method":"public GrailsDomainClass getDomainClass() {\n\t\treturn domainClass;\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public boolean isBidirectional() {\n\t\treturn this.bidirectional;\n\t}","id":33800,"modified_method":"public boolean isBidirectional() {\n\t\treturn bidirectional;\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Overriddent equals to take into account inherited properties\n     * e.g. childClass.propertyName is equal to parentClass.propertyName if the types match and\n     * childClass.property.isInherited\n     *\n     * @param o the Object to compare this property to\n     * @return boolean indicating equality of the two objects\n     */\n    public boolean equals(Object o) {\n        if(o == null){\n            return false;\n        }\n        if(o instanceof GrailsDomainClassProperty){\n            if(!super.equals(o)){\n                GrailsDomainClassProperty otherProp = (GrailsDomainClassProperty) o;\n                boolean namesMatch = otherProp.getName().equals(getName());\n                boolean typesMatch = otherProp.getReferencedPropertyType().equals(getReferencedPropertyType());\n                Class myActualClass = getDomainClass().getClazz();\n                Class otherActualClass = otherProp.getDomainClass().getClazz() ;\n                boolean classMatch = otherActualClass.isAssignableFrom(myActualClass) ||\n                        myActualClass.isAssignableFrom(otherActualClass);\n                return namesMatch && typesMatch && classMatch;\n            }else{\n                return true;\n            }\n        }else{\n          return false;\n        }\n    }","id":33801,"modified_method":"/**\n\t * Overriddent equals to take into account inherited properties\n\t * e.g. childClass.propertyName is equal to parentClass.propertyName if the types match and\n\t * childClass.property.isInherited\n\t *\n\t * @param o the Object to compare this property to\n\t * @return boolean indicating equality of the two objects\n\t */\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (o == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (o instanceof GrailsDomainClassProperty) {\n\t\t\tif (!super.equals(o)){\n\t\t\t\tGrailsDomainClassProperty otherProp = (GrailsDomainClassProperty) o;\n\t\t\t\tboolean namesMatch = otherProp.getName().equals(getName());\n\t\t\t\tboolean typesMatch = otherProp.getReferencedPropertyType().equals(getReferencedPropertyType());\n\t\t\t\tClass<?> myActualClass = getDomainClass().getClazz();\n\t\t\t\tClass<?> otherActualClass = otherProp.getDomainClass().getClazz() ;\n\t\t\t\tboolean classMatch = otherActualClass.isAssignableFrom(myActualClass) ||\n\t\t\t\t\tmyActualClass.isAssignableFrom(otherActualClass);\n\t\t\t\treturn namesMatch && typesMatch && classMatch;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Evaluates the fetchmode \n     *\n     */\n\tprivate void establishFetchMode() {\n\n        Map fetchMap = (Map) domainClass.getPropertyValue(GrailsDomainClassProperty.FETCH_MODE, Map.class);\n\t\tif(fetchMap != null && fetchMap.containsKey(this.name)) {\n\t\t\tif(\"eager\".equals(fetchMap.get(this.name))) {\n\t\t\t\tthis.fetchMode = FETCH_EAGER;\t\t\t\t\n\t\t\t}\n\t\t}\n\t}","id":33802,"modified_method":"/**\n\t * Evaluates the fetchmode.\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprivate void establishFetchMode() {\n\t\tMap fetchMap = domainClass.getPropertyValue(GrailsDomainClassProperty.FETCH_MODE, Map.class);\n\t\tif (fetchMap != null && fetchMap.containsKey(name)) {\n\t\t\tif (\"eager\".equals(fetchMap.get(name))) {\n\t\t\t\tfetchMode = FETCH_EAGER;\n\t\t\t}\n\t\t}\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public boolean isOneToMany() {\n\t\treturn this.oneToMany;\n\t}","id":33803,"modified_method":"public boolean isOneToMany() {\n\t\treturn oneToMany;\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public void setBasicCollectionType(boolean b) {\n        this.basicCollectionType = b;\n    }","id":33804,"modified_method":"public void setBasicCollectionType(boolean b) {\n\t\tbasicCollectionType = b;\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public String getNaturalName() {\n        return this.naturalName;\n    }","id":33805,"modified_method":"public String getNaturalName() {\n\t\treturn naturalName;\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public boolean isInherited() {\n\t\treturn this.inherited;\n\t}","id":33806,"modified_method":"public boolean isInherited() {\n\t\treturn inherited;\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n\t * returns list of current domainclass and all of it's superclasses\n\t * \n\t * @param domainClass\n\t * @return\n\t */\n\tprivate List<GrailsDomainClass> resolveAllDomainClassesInHierarchy(GrailsDomainClass domainClass) {\n\t\tList<GrailsDomainClass> allClasses = new ArrayList<GrailsDomainClass>();\n\t\tGrailsApplication application = ApplicationHolder.getApplication();\n\t\tGrailsDomainClass currentDomainClass=domainClass;\t\t\n\t\twhile(currentDomainClass != null) {\n\t\t\tallClasses.add(currentDomainClass);\n\t\t\tif(application != null) {\n\t\t\t\tcurrentDomainClass = (GrailsDomainClass) application.getArtefact(DomainClassArtefactHandler.TYPE, currentDomainClass.getClazz().getSuperclass().getName());\n\t\t\t} else {\n\t\t\t\tcurrentDomainClass = null;\n\t\t\t}\n\t\t}\n\t\treturn allClasses;\n\t}","id":33807,"modified_method":"/**\n\t * returns list of current domainclass and all of its superclasses.\n\t *\n\t * @return\n\t */\n\tprivate List<GrailsDomainClass> resolveAllDomainClassesInHierarchy() {\n\t\tList<GrailsDomainClass> allClasses = new ArrayList<GrailsDomainClass>();\n\t\tGrailsApplication application = ApplicationHolder.getApplication();\n\t\tGrailsDomainClass currentDomainClass = domainClass;\n\t\twhile (currentDomainClass != null) {\n\t\t\tallClasses.add(currentDomainClass);\n\t\t\tif (application != null) {\n\t\t\t\tcurrentDomainClass = (GrailsDomainClass)application.getArtefact(\n\t\t\t\t\t\tDomainClassArtefactHandler.TYPE, currentDomainClass.getClazz().getSuperclass().getName());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcurrentDomainClass = null;\n\t\t\t}\n\t\t}\n\t\treturn allClasses;\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public boolean isOwningSide() {\n\t\treturn isHasOne() || this.owningSide;\n\t}","id":33808,"modified_method":"public boolean isOwningSide() {\n\t\treturn isHasOne() || owningSide;\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public boolean isOwningClass(Class domainClass) {\n            return domainClass != null && domainClass.equals(getDomainClass().getClazz());\n        }","id":33809,"modified_method":"@SuppressWarnings(\"unchecked\")\n\t\tpublic boolean isOwningClass(Class dc) {\n\t\t\treturn dc != null && dc.equals(getDomainClass().getClazz());\n\t\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public DefaultGrailsDomainClassProperty(GrailsDomainClass domainClass, PropertyDescriptor descriptor)  {\n        this.domainClass = domainClass;\n        // persistant by default\n        this.persistant = true;\n        this.name = descriptor.getName();\n        this.naturalName = GrailsNameUtils.getNaturalName(descriptor.getName());\n        this.type = descriptor.getPropertyType();\n        this.identity = descriptor.getName().equals( IDENTITY );\n\n\n        // establish if property is persistant\n        if(domainClass != null) {\n            // figure out if this property is inherited\n            if(!domainClass.isRoot()) {\n                this.inherited = GrailsClassUtils.isPropertyInherited(domainClass.getClazz(), this.name);\n            }\n            List transientProps = getTransients(domainClass);\n            checkIfTransient(transientProps);\n\n            establishFetchMode();\n\n        }\n    }","id":33810,"modified_method":"/**\n\t * Constructor.\n\t * @param domainClass\n\t * @param descriptor\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic DefaultGrailsDomainClassProperty(GrailsDomainClass domainClass, PropertyDescriptor descriptor) {\n\t\tthis.domainClass = domainClass;\n\t\tname = descriptor.getName();\n\t\tnaturalName = GrailsNameUtils.getNaturalName(descriptor.getName());\n\t\ttype = descriptor.getPropertyType();\n\t\tidentity = descriptor.getName().equals(IDENTITY);\n\n\t\t// establish if property is persistant\n\t\tif (domainClass != null) {\n\t\t\t// figure out if this property is inherited\n\t\t\tif (!domainClass.isRoot()) {\n\t\t\t\tinherited = GrailsClassUtils.isPropertyInherited(domainClass.getClazz(), name);\n\t\t\t}\n\t\t\tList transientProps = getTransients();\n\t\t\tcheckIfTransient(transientProps);\n\n\t\t\testablishFetchMode();\n\t\t}\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n\t * Retrieves the transient properties\n\t * \n\t * @param domainClass The owning domain class\n\t * @return A list of transient properties\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprivate List getTransients(GrailsDomainClass domainClass) {\n\t\tList allTransientProps = new ArrayList();\n\t\tList<GrailsDomainClass> allClasses = resolveAllDomainClassesInHierarchy(domainClass);\n\n\t\tfor(GrailsDomainClass currentDomainClass : allClasses) {\n\t\t\tList transientProps = (List)currentDomainClass.getPropertyValue( TRANSIENT, List.class );\n\t\t\tif(transientProps != null) {\n\t\t\t\tallTransientProps.addAll(transientProps);\n\t\t\t}\n\t\n\t        // Undocumented feature alert! Steve insisted on this :-)\n\t        List evanescent = (List)currentDomainClass.getPropertyValue(EVANESCENT, List.class );\n\t        if(evanescent != null) {\n\t        \tallTransientProps.addAll(evanescent);\n\t        }\n\t\t}\n\t\treturn allTransientProps;\n\t}","id":33811,"modified_method":"/**\n\t * Retrieves the transient properties\n\t *\n\t * @return A list of transient properties\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprivate List getTransients() {\n\t\tList allTransientProps = new ArrayList();\n\t\tList<GrailsDomainClass> allClasses = resolveAllDomainClassesInHierarchy();\n\n\t\tfor (GrailsDomainClass currentDomainClass : allClasses) {\n\t\t\tList transientProps = currentDomainClass.getPropertyValue(TRANSIENT, List.class);\n\t\t\tif (transientProps != null) {\n\t\t\t\tallTransientProps.addAll(transientProps);\n\t\t\t}\n\n\t\t\t// Undocumented feature alert! Steve insisted on this :-)\n\t\t\tList evanescent = currentDomainClass.getPropertyValue(EVANESCENT, List.class);\n\t\t\tif (evanescent != null) {\n\t\t\t\tallTransientProps.addAll(evanescent);\n\t\t\t}\n\t\t}\n\t\treturn allTransientProps;\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public boolean isCircular() {\n\t\tif(this.otherSide != null) {\n            if(this.otherSide.getDomainClass().getClazz().isAssignableFrom(this.domainClass.getClazz()))            \n\t\t\t\treturn true;\n\t\t}\n        else if(this.getReferencedPropertyType().isAssignableFrom(this.domainClass.getClazz())) {\n            return true;\n        }\n\t\treturn false;\n\t}","id":33812,"modified_method":"@SuppressWarnings(\"unchecked\")\n\tpublic boolean isCircular() {\n\t\tif (otherSide != null) {\n\t\t\tif (otherSide.getDomainClass().getClazz().isAssignableFrom(domainClass.getClazz())) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse if (getReferencedPropertyType().isAssignableFrom(domainClass.getClazz())) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"public boolean isOneToOne() {\n\t\treturn this.oneToOne;\n\t}","id":33813,"modified_method":"public boolean isOneToOne() {\n\t\treturn oneToOne;\n\t}","commit_id":"ae0fd8a5a29ccb153a49ee2a1a3004501b45a2df","url":"https://github.com/grails/grails-core"},{"original_method":"List<ServiceInfo> getDependentServices(String stackName, String version, String serviceName) {\n    return null;\n  }","id":33814,"modified_method":"public ServiceInfo getServiceInfo(String stackName, String version, String serviceName) {\n    ServiceInfo serviceInfoResult = null;\n    List<ServiceInfo> services = null;\n    StackInfo stack = getStackInfo(stackName, version);\n    if (stack == null) return null;\n    services = stack.getServices();\n    if (services != null)\n      for (ServiceInfo service : services) {\n        if (serviceName.equals(service.getName())) {\n          serviceInfoResult = service;\n          break;\n        }\n      }\n    return serviceInfoResult;\n  }","commit_id":"030ef999f141152ef567bb930ad57ae55e128399","url":"https://github.com/apache/ambari"},{"original_method":"public static void main(String[] args) throws Exception {\n    AmbariMetaInfo metadata = new AmbariMetaInfo();\n//    System.out.println( new Configuration().getMetadataPath() );\n  }","id":33815,"modified_method":"public static void main(String[] args) throws Exception {\n    AmbariMetaInfo metadata = new AmbariMetaInfo();\n\n//    //Get Stack\n//    StackInfo stack = metadata.getStackInfo(\"HDP\",\"0.1\");\n//    System.out.println(\"stack = \" + stack);\n\n//    //Get services\n//    List<ServiceInfo>services = metadata.getSupportedServices(\"HDP\",\"0.1\");\n//    for(ServiceInfo service : services){\n//      System.out.println(\"service = \" + service);\n//    }\n\n//    //Get ServiceInfo\n//    ServiceInfo si = metadata.getServiceInfo(\"HDP\",\"0.1\", \"HDFS\");\n//    System.out.println(\"si = \" + si);\n\n    //Get supported Configs\n    Map<String,Map<String, String> > configsAll = metadata.getSupportedConfigs(\"HDP\",\"0.1\", \"HDFS\");\n    Set<String>filesKeys  = configsAll.keySet();\n    for(String file: filesKeys){\n      System.out.println(\"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\file = \" + file);\n      Map<String,String> configs = configsAll.get(file);\n      Set<String> propertyKeys = configs.keySet();\n      for(String property : propertyKeys ){\n        System.out.println(\"name = \" + property+ \"\\t value=\" + configs.get(property));\n      }\n\n    }\n\n//    System.out.println( new Configuration().getMetadataPath() );\n  }","commit_id":"030ef999f141152ef567bb930ad57ae55e128399","url":"https://github.com/apache/ambari"},{"original_method":"Map<String, Map<String, String>> getSupportedConfigs(String stackName, String version, String serviceName) {\n    return null;\n  }","id":33816,"modified_method":"public Map<String, Map<String, String>> getSupportedConfigs(String stackName, String version, String serviceName) {\n    Map<String, Map<String, String>> propertiesResult =  new HashMap<String, Map<String, String> >();\n\n    ServiceInfo service = getServiceInfo(stackName, version, serviceName);\n    if (service != null)\n      if (serviceName.equals(service.getName())) {\n        List<PropertyInfo> properties = service.getProperties();\n        if (properties != null)\n          for (PropertyInfo propertyInfo : properties) {\n            Map<String, String> fileProperties = propertiesResult.get( propertyInfo.getFilename() );\n            if(fileProperties == null){\n              fileProperties = new HashMap<String, String>();\n              fileProperties.put(propertyInfo.getName(), propertyInfo.getValue() );\n              propertiesResult.put(propertyInfo.getFilename(), fileProperties  );\n\n            }else{\n              fileProperties.put(propertyInfo.getName(), propertyInfo.getValue() );\n            }\n\n          }\n      }\n\n    return propertiesResult;\n  }","commit_id":"030ef999f141152ef567bb930ad57ae55e128399","url":"https://github.com/apache/ambari"},{"original_method":"List<ServiceInfo> getSupportedServices(String stackName, String version) {\n    return null;\n  }","id":33817,"modified_method":"public List<ServiceInfo> getSupportedServices(String stackName, String version) {\n      List<ServiceInfo> servicesResulr = null;\n      StackInfo stack = getStackInfo(stackName , version);\n      if( stack!= null )\n        servicesResulr = stack.getServices();\n      return servicesResulr;\n    }","commit_id":"030ef999f141152ef567bb930ad57ae55e128399","url":"https://github.com/apache/ambari"},{"original_method":"List<StackInfo> getSupportedStack() {\n    return null;\n  }","id":33818,"modified_method":"List<StackInfo> getSupportedStack() {\n    return stacksResult;\n  }","commit_id":"030ef999f141152ef567bb930ad57ae55e128399","url":"https://github.com/apache/ambari"},{"original_method":"public List<RepositoryInfo> getRepository(File repositoryFile) {\n\n    List<RepositoryInfo> repositorysInfo = new ArrayList<RepositoryInfo>();\n    try {\n\n      DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n      DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n      Document doc = dBuilder.parse(repositoryFile);\n      doc.getDocumentElement().normalize();\n\n      NodeList propertyNodes = doc.getElementsByTagName(REPOSITORY_XML_MAIN_BLOCK_NAME);\n\n      for (int index = 0; index < propertyNodes.getLength(); index++) {\n\n        Node node = propertyNodes.item(index);\n        if (node.getNodeType() == Node.ELEMENT_NODE) {\n\n          Element property = (Element) node;\n          RepositoryInfo repositoryInfo = new RepositoryInfo();\n          repositoryInfo.setUrl(getTagValue(REPOSITORY_XML_PROPERTY_URL, property));\n          repositoryInfo.setOs(getTagValue(REPOSITORY_XML_PROPERTY_OS, property));\n          repositoryInfo.setDescription(getTagValue(REPOSITORY_XML_PROPERTY_DESCRIPTION, property));\n          repositorysInfo.add(repositoryInfo);\n        }\n      }\n\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n\n    return repositorysInfo;\n  }","id":33819,"modified_method":"private List<RepositoryInfo> getRepository(File repositoryFile) {\n\n    List<RepositoryInfo> repositorysInfo = new ArrayList<RepositoryInfo>();\n    try {\n\n      DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n      DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n      Document doc = dBuilder.parse(repositoryFile);\n      doc.getDocumentElement().normalize();\n\n      NodeList propertyNodes = doc.getElementsByTagName(REPOSITORY_XML_MAIN_BLOCK_NAME);\n\n      for (int index = 0; index < propertyNodes.getLength(); index++) {\n\n        Node node = propertyNodes.item(index);\n        if (node.getNodeType() == Node.ELEMENT_NODE) {\n\n          Element property = (Element) node;\n          RepositoryInfo repositoryInfo = new RepositoryInfo();\n          repositoryInfo.setUrl(getTagValue(REPOSITORY_XML_PROPERTY_URL, property));\n          repositoryInfo.setOs(getTagValue(REPOSITORY_XML_PROPERTY_OS, property));\n          repositoryInfo.setDescription(getTagValue(REPOSITORY_XML_PROPERTY_DESCRIPTION, property));\n          repositorysInfo.add(repositoryInfo);\n        }\n      }\n\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n\n    return repositorysInfo;\n  }","commit_id":"030ef999f141152ef567bb930ad57ae55e128399","url":"https://github.com/apache/ambari"},{"original_method":"private List<PropertyInfo> getProperties(File propertyFile) {\n\n    List<PropertyInfo> resultPropertyList = new ArrayList<PropertyInfo>();\n    try {\n      DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n      DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n      Document doc = dBuilder.parse(propertyFile);\n      doc.getDocumentElement().normalize();\n\n\n      NodeList propertyNodes = doc.getElementsByTagName(PROPERTY_XML_MAIN_BLOCK_NAME);\n\n      for (int index = 0; index < propertyNodes.getLength(); index++) {\n\n        Node node = propertyNodes.item(index);\n        if (node.getNodeType() == Node.ELEMENT_NODE) {\n\n          Element property = (Element) node;\n          PropertyInfo propertyInfo = new PropertyInfo();\n          propertyInfo.setName(getTagValue(PROPERTY_XML_PROPERTY_NAME, property));\n          propertyInfo.setValue(getTagValue(PROPERTY_XML_PROPERTY_VALUE, property));\n          propertyInfo.setDescription(getTagValue(PROPERTY_XML_PROPERTY_DESCRIPTION, property));\n\n          if (propertyInfo.getName() == null || propertyInfo.getValue() == null)\n            continue;\n\n          resultPropertyList.add(propertyInfo);\n        }\n      }\n    } catch (Exception e) {\n      e.printStackTrace();\n      return null;\n    }\n    return resultPropertyList;\n  }","id":33820,"modified_method":"private List<PropertyInfo> getProperties(File propertyFile) {\n\n    List<PropertyInfo> resultPropertyList = new ArrayList<PropertyInfo>();\n    try {\n      DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n      DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n      Document doc = dBuilder.parse(propertyFile);\n      doc.getDocumentElement().normalize();\n\n\n      NodeList propertyNodes = doc.getElementsByTagName(PROPERTY_XML_MAIN_BLOCK_NAME);\n\n      for (int index = 0; index < propertyNodes.getLength(); index++) {\n\n        Node node = propertyNodes.item(index);\n        if (node.getNodeType() == Node.ELEMENT_NODE) {\n\n          Element property = (Element) node;\n          PropertyInfo propertyInfo = new PropertyInfo();\n          propertyInfo.setName(getTagValue(PROPERTY_XML_PROPERTY_NAME, property));\n          propertyInfo.setValue(getTagValue(PROPERTY_XML_PROPERTY_VALUE, property));\n          propertyInfo.setDescription(getTagValue(PROPERTY_XML_PROPERTY_DESCRIPTION, property));\n          propertyInfo.setFilename( propertyFile.getName() );\n\n          if (propertyInfo.getName() == null || propertyInfo.getValue() == null)\n            continue;\n\n          resultPropertyList.add(propertyInfo);\n        }\n      }\n    } catch (Exception e) {\n      e.printStackTrace();\n      return null;\n    }\n    return resultPropertyList;\n  }","commit_id":"030ef999f141152ef567bb930ad57ae55e128399","url":"https://github.com/apache/ambari"},{"original_method":"public static synchronized ClusterController getClusterController() {\n    if (controller == null) {\n      try {\n        Class implClass = Class.forName(PROVIDER_MODULE_CLASS);\n        ProviderModule providerModule = (ProviderModule) implClass.newInstance();\n        return new ClusterControllerImpl(providerModule);\n\n      } catch (Exception e) {\n        throw new IllegalStateException(\"Can't create provider module \" + PROVIDER_MODULE_CLASS, e);\n      }\n    }\n    return controller;\n  }","id":33821,"modified_method":"public static synchronized ClusterController getClusterController() {\n    if (controller == null) {\n      try {\n        Class implClass = Class.forName(PROVIDER_MODULE_CLASS);\n        ProviderModule providerModule = (ProviderModule) implClass.newInstance();\n        controller = new ClusterControllerImpl(providerModule);\n\n      } catch (Exception e) {\n        throw new IllegalStateException(\"Can't create provider module \" + PROVIDER_MODULE_CLASS, e);\n      }\n    }\n    return controller;\n  }","commit_id":"030ef999f141152ef567bb930ad57ae55e128399","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  public Schema getSchema(Resource.Type type) {\n    Schema schema;\n\n    synchronized (schemas) {\n      schema = schemas.get(type);\n      if (schema == null) {\n        schema = new SchemaImpl(resourceProviders.get(type), propertyProviders.get(type));\n        schemas.put(Resource.Type.Cluster, schema);\n      }\n    }\n    return schema;\n  }","id":33822,"modified_method":"@Override\n  public Schema getSchema(Resource.Type type) {\n    Schema schema;\n\n    synchronized (schemas) {\n      schema = schemas.get(type);\n      if (schema == null) {\n        schema = new SchemaImpl(resourceProviders.get(type), propertyProviders.get(type));\n        schemas.put(type, schema);\n      }\n    }\n    return schema;\n  }","commit_id":"030ef999f141152ef567bb930ad57ae55e128399","url":"https://github.com/apache/ambari"},{"original_method":"private void createResourceProvider(Resource.Type type, AmbariManagementController managementController) {\n    resourceProviders.put( type , ResourceProviderImpl.getResourceProvider(\n        type,\n        PropertyHelper.getPropertyIds(type, \"DB\"),\n        PropertyHelper.getKeyPropertyIds(type), managementController));\n  }","id":33823,"modified_method":"private void createResourceProvider(Resource.Type type, AmbariManagementController managementController) {\n    resourceProviders.put( type , ResourceProviderImpl.getResourceProvider(\n        type,\n        PropertyHelper.getPropertyIds(type),\n        PropertyHelper.getKeyPropertyIds(type), managementController));\n  }","commit_id":"030ef999f141152ef567bb930ad57ae55e128399","url":"https://github.com/apache/ambari"},{"original_method":"private void createPropertyProviders(Resource.Type type) {\n    List<PropertyProvider> providers = new LinkedList<PropertyProvider>();\n    if (type == Resource.Type.HostComponent) {\n      providers.add(new JMXPropertyProvider(\n          PropertyHelper.getPropertyIds(type, \"JMX\"),\n          new URLStreamProvider(),\n          hostMapping));\n\n      providers.add(new GangliaPropertyProvider(\n          PropertyHelper.getPropertyIds(type, \"GANGLIA\"),\n          new URLStreamProvider(),\n          gangliaCollectorHostName));\n    }\n    propertyProviders.put(type, providers);\n  }","id":33824,"modified_method":"private void createPropertyProviders(Resource.Type type) {\n    List<PropertyProvider> providers = new LinkedList<PropertyProvider>();\n    if (type == Resource.Type.HostComponent) {\n      providers.add(new JMXPropertyProvider(\n          PropertyHelper.getJMXPropertyIds(type),\n          new URLStreamProvider(),\n          hostMapping));\n\n      providers.add(new GangliaPropertyProvider(\n          PropertyHelper.getGangliaPropertyIds(type),\n          new URLStreamProvider(),\n          gangliaCollectorHostName,\n          PropertyHelper.getPropertyId(\"host_name\", \"HostRoles\"),\n          PropertyHelper.getPropertyId(\"component_name\", \"HostRoles\")));\n    }\n    propertyProviders.put(type, providers);\n  }","commit_id":"030ef999f141152ef567bb930ad57ae55e128399","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Get the spec to locate the Ganglia stream from the given\n   * request info.\n   *\n   * @param gangliaCluster  the ganglia cluster name\n   * @param host            the host name\n   * @param metric          the metric\n   * @param startTime       the start time of the temporal data\n   * @param endTime         the end time of the temporal data\n   * @param step            the step for the temporal data\n   *\n   * @return the spec\n   */\n  protected String getSpec(String gangliaCluster,\n                                  String host,\n                                  String metric,\n                                  long startTime,\n                                  long endTime,\n                                  long step) {\n\n    StringBuilder sb = new StringBuilder();\n\n    sb.append(\"http://\").\n       append(gangliaCollectorHostName).\n       append(\"/ganglia/graph.php?c=\").\n       append(gangliaCluster).\n       append(\"&h=\").\n       append(host == null ? \"\" : host).\n       append(\"&m=\").\n       append(metric);\n\n    if (startTime != -1) {\n      sb.append(\"&cs=\").append(startTime);\n    }\n    if (endTime != -1) {\n      sb.append(\"&ce=\").append(endTime);\n    }\n    if (step != -1) {\n      sb.append(\"&step=\").append(step);\n    }\n    sb.append(\"&json=1\");\n\n    return sb.toString();\n  }","id":33825,"modified_method":"/**\n   * Get the spec to locate the Ganglia stream from the given\n   * request info.\n   *\n   * @param gangliaCluster  the ganglia cluster name\n   * @param host            the host name\n   * @param metric          the metric\n   * @param temporalInfo    the temporal data; may be null\n   *\n   * @return the spec\n   */\n  protected String getSpec(String gangliaCluster,\n                                  String host,\n                                  String metric,\n                                  TemporalInfo temporalInfo) {\n\n    StringBuilder sb = new StringBuilder();\n\n    sb.append(\"http://\").\n        append(gangliaCollectorHostName).\n        append(\"/ganglia/graph.php?c=\").\n        append(gangliaCluster);\n\n    if(host != null) {\n      sb.append(\"&h=\").append(host);\n    }\n\n    sb.append(\"&m=\").append(metric);\n\n    if (temporalInfo == null) {\n      sb.append(\"&r=day\");\n    } else {\n      long startTime = temporalInfo.getStartTime();\n      if (startTime != -1) {\n        sb.append(\"&cs=\").append(startTime);\n      }\n\n      long endTime = temporalInfo.getEndTime();\n      if (endTime != -1) {\n        sb.append(\"&ce=\").append(endTime);\n      }\n\n      long step = temporalInfo.getStep();\n      if (step != -1) {\n        sb.append(\"&step=\").append(step);\n      }\n    }\n\n    sb.append(\"&json=1\");\n\n    return sb.toString();\n  }","commit_id":"030ef999f141152ef567bb930ad57ae55e128399","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Populate a resource by obtaining the requested Ganglia metrics.\n   *\n   * @param resource  the resource to be populated\n   * @param request   the request\n   * @param predicate the predicate\n   *\n   * @return true if the resource was successfully populated with the requested properties\n   *\n   * @throws AmbariException thrown if the resource cannot be populated\n   */\n  private boolean populateResource(Resource resource, Request request, Predicate predicate) throws AmbariException{\n\n    if (getPropertyIds().isEmpty()) {\n      return true;\n    }\n    Set<PropertyId> ids = PropertyHelper.getRequestPropertyIds(getPropertyIds(), request, predicate);\n\n    String hostName           = PropertyHelper.fixHostName((String) resource.getPropertyValue(HOST_COMPONENT_HOST_NAME_PROPERTY_ID));\n    String componentName      = (String) resource.getPropertyValue(HOST_COMPONENT_COMPONENT_NAME_PROPERTY_ID);\n    String gangliaClusterName = GANGLIA_CLUSTER_NAMES.get(componentName);\n\n    if (gangliaClusterName == null) {\n      return true;\n    }\n\n    for (PropertyId propertyId : ids) {\n\n// TODO : ignoring category for now..\n//      String category = propertyId.getCategory();\n//      String property = (category == null || category.length() == 0 ? \"\" : category + \".\") +\n//          propertyId.getName();\n      String property = propertyId.getName();\n\n      TemporalInfo temporalInfo = request.getTemporalInfo(propertyId);\n      String spec = getSpec(gangliaClusterName, hostName, property,\n          temporalInfo.getStartTime(), temporalInfo.getEndTime(), temporalInfo.getStep());\n\n      try {\n        List<GangliaMetric> properties = new ObjectMapper().readValue(streamProvider.readFrom(spec),\n            new TypeReference<List<GangliaMetric>>() {\n        });\n        resource.setProperty(propertyId, getTemporalValue(properties.get(0)));\n      } catch (IOException e) {\n        throw new AmbariException(\"Can't get metrics : \" + property, e);\n      }\n    }\n    return true;\n  }","id":33826,"modified_method":"/**\n   * Populate a resource by obtaining the requested Ganglia RESOURCE_METRICS.\n   *\n   * @param resource  the resource to be populated\n   * @param request   the request\n   * @param predicate the predicate\n   *\n   * @return true if the resource was successfully populated with the requested properties\n   *\n   * @throws AmbariException thrown if the resource cannot be populated\n   */\n  private boolean populateResource(Resource resource, Request request, Predicate predicate) throws AmbariException{\n\n    if (getPropertyIds().isEmpty()) {\n      return true;\n    }\n\n    String componentName      = (String) resource.getPropertyValue(componentNamePropertyId);\n    String gangliaClusterName = GANGLIA_CLUSTER_NAMES.get(componentName);\n    Map<PropertyId, String> metrics = componentMetrics.get(componentName);\n\n    if (metrics == null || gangliaClusterName == null) {\n      return true;\n    }\n\n    String hostName = hostNamePropertyId == null ?\n        null : PropertyHelper.fixHostName((String) resource.getPropertyValue(hostNamePropertyId));\n\n    Set<PropertyId> ids = PropertyHelper.getRequestPropertyIds(getPropertyIds(), request, predicate);\n\n    for (PropertyId propertyId : ids) {\n\n      String metricName = metrics.get(propertyId);\n\n      if (metricName != null) {\n        boolean temporal = propertyId.isTemporal();\n\n        String spec = getSpec(gangliaClusterName, hostName, metricName,\n            temporal ? request.getTemporalInfo(propertyId) : null);\n\n        try {\n          List<GangliaMetric> properties = new ObjectMapper().readValue(streamProvider.readFrom(spec),\n              new TypeReference<List<GangliaMetric>>() {});\n\n          if (properties != null) {\n            resource.setProperty(propertyId, getValue(properties.get(0), temporal));\n          }\n        } catch (IOException e) {\n          throw new AmbariException(\"Can't get metric : \" + metricName, e);\n        }\n      }\n    }\n    return true;\n  }","commit_id":"030ef999f141152ef567bb930ad57ae55e128399","url":"https://github.com/apache/ambari"},{"original_method":"public GangliaPropertyProvider(Set<PropertyId> propertyIds,\n                                 StreamProvider streamProvider,\n                                 String gangliaCollectorHostName) {\n    this.propertyIds              = propertyIds;\n    this.streamProvider           = streamProvider;\n    this.gangliaCollectorHostName = gangliaCollectorHostName;\n  }","id":33827,"modified_method":"public GangliaPropertyProvider(Map<String, Map<PropertyId, String>> componentMetrics,\n                                 StreamProvider streamProvider,\n                                 String gangliaCollectorHostName,\n                                 PropertyId hostNamePropertyId,\n                                 PropertyId componentNamePropertyId) {\n    this.componentMetrics         = componentMetrics;\n    this.streamProvider           = streamProvider;\n    this.gangliaCollectorHostName = gangliaCollectorHostName;\n    this.hostNamePropertyId       = hostNamePropertyId;\n    this.componentNamePropertyId  = componentNamePropertyId;\n\n    propertyIds = new HashSet<PropertyId>();\n    for (Map.Entry<String, Map<PropertyId, String>> entry : componentMetrics.entrySet()) {\n      propertyIds.addAll(entry.getValue().keySet());\n    }\n  }","commit_id":"030ef999f141152ef567bb930ad57ae55e128399","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Get a string representation of the temporal data from the given metric.\n   *\n   * @param metric  the metric\n   *\n   * @return the string representation of the temporal data\n   */\n  private String getTemporalValue(GangliaMetric metric) {\n    double[][] dataPoints = metric.getDatapoints();\n\n    boolean first = true;\n    StringBuilder stringBuilder = new StringBuilder();\n    stringBuilder.append(\"[\");\n    for (double[] m : dataPoints) {\n      if (!first) {\n        stringBuilder.append(\",\");\n      }\n      stringBuilder.append(\"[\");\n      stringBuilder.append(m[0]);\n      stringBuilder.append(\",\");\n      stringBuilder.append((long) m[1]);\n      stringBuilder.append(\"]\");\n      first = false;\n    }\n    stringBuilder.append(\"]\");\n    return stringBuilder.toString();\n  }","id":33828,"modified_method":"/**\n   * Get value from the given metric.\n   *\n   * @param metric     the metric\n   * @param isTemporal indicates whether or not this a temporal metric\n   *\n   * @return the string representation of the temporal data\n   */\n  private Object getValue(GangliaMetric metric, boolean isTemporal) {\n    double[][] dataPoints = metric.getDatapoints();\n\n    if (!isTemporal) {\n      int valuePosition = dataPoints.length - 1;\n      // discard last data point ... seems to always be zero\n      if (valuePosition > 0) {\n        valuePosition--;\n      }\n      return dataPoints[valuePosition][0];\n    }\n\n    boolean first = true;\n    StringBuilder stringBuilder = new StringBuilder();\n    stringBuilder.append(\"[\");\n    for (double[] m : dataPoints) {\n      if (!first) {\n        stringBuilder.append(\",\");\n      }\n      stringBuilder.append(\"[\");\n      stringBuilder.append(m[0]);\n      stringBuilder.append(\",\");\n      stringBuilder.append((long) m[1]);\n      stringBuilder.append(\"]\");\n      first = false;\n    }\n    stringBuilder.append(\"]\");\n    return stringBuilder.toString();\n  }","commit_id":"030ef999f141152ef567bb930ad57ae55e128399","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testGetResources() throws Exception {\n    Set< PropertyId > propertyIds     = PropertyHelper.getPropertyIds(Resource.Type.HostComponent, \"GANGLIA\");\n    TestStreamProvider streamProvider  = new TestStreamProvider();\n\n    GangliaPropertyProvider propertyProvider = new GangliaPropertyProvider(propertyIds,\n        streamProvider,\n        \"ec2-23-23-71-42.compute-1.amazonaws.com\");\n\n    // namenode\n    Resource resource = new ResourceImpl(Resource.Type.HostComponent);\n\n    resource.setProperty(GangliaPropertyProvider.HOST_COMPONENT_HOST_NAME_PROPERTY_ID, \"domU-12-31-39-0E-34-E1.compute-1.internal\");\n    resource.setProperty(GangliaPropertyProvider.HOST_COMPONENT_COMPONENT_NAME_PROPERTY_ID, \"NAMENODE\");\n\n    // only ask for one property\n    Request  request = PropertyHelper.getReadRequest(Collections.singleton(PROPERTY_ID));\n\n    Assert.assertEquals(1, propertyProvider.populateResources(Collections.singleton(resource), request, null).size());\n\n    Assert.assertEquals(\"http://ec2-23-23-71-42.compute-1.amazonaws.com/ganglia/graph.php?c=HDPNameNode&h=domU-12-31-39-0E-34-E1.compute-1.internal&m=bytes_out&json=1\",\n        streamProvider.getLastSpec());\n\n    Assert.assertEquals(3, PropertyHelper.getProperties(resource).size());\n    Assert.assertNotNull(resource.getPropertyValue(PROPERTY_ID));\n  }","id":33829,"modified_method":"@Test\n  public void testGetResources() throws Exception {\n    TestStreamProvider streamProvider  = new TestStreamProvider();\n\n    GangliaPropertyProvider propertyProvider = new GangliaPropertyProvider(\n        PropertyHelper.getGangliaPropertyIds(Resource.Type.HostComponent),\n        streamProvider,\n        \"ec2-23-23-71-42.compute-1.amazonaws.com\",\n        HOST_NAME_PROPERTY_ID,\n        COMPONENT_NAME_PROPERTY_ID);\n\n    // namenode\n    Resource resource = new ResourceImpl(Resource.Type.HostComponent);\n\n    resource.setProperty(HOST_NAME_PROPERTY_ID, \"domU-12-31-39-0E-34-E1.compute-1.internal\");\n    resource.setProperty(COMPONENT_NAME_PROPERTY_ID, \"NAMENODE\");\n\n    // only ask for one property\n    Request  request = PropertyHelper.getReadRequest(Collections.singleton(PROPERTY_ID));\n\n    Assert.assertEquals(1, propertyProvider.populateResources(Collections.singleton(resource), request, null).size());\n\n    Assert.assertEquals(\"http://ec2-23-23-71-42.compute-1.amazonaws.com/ganglia/graph.php?c=HDPNameNode&h=domU-12-31-39-0E-34-E1.compute-1.internal&m=bytes_out&json=1\",\n        streamProvider.getLastSpec());\n\n    Assert.assertEquals(3, PropertyHelper.getProperties(resource).size());\n    Assert.assertNotNull(resource.getPropertyValue(PROPERTY_ID));\n  }","commit_id":"030ef999f141152ef567bb930ad57ae55e128399","url":"https://github.com/apache/ambari"},{"original_method":"private void createResourceProvider(Resource.Type type) {\n    resourceProviders.put( type, new JDBCResourceProvider(DBHelper.CONNECTION_FACTORY, type,\n        PropertyHelper.getPropertyIds(type, \"DB\"),\n        PropertyHelper.getKeyPropertyIds(type)));\n  }","id":33830,"modified_method":"private void createResourceProvider(Resource.Type type) {\n    resourceProviders.put( type, new JDBCResourceProvider(DBHelper.CONNECTION_FACTORY, type,\n        PropertyHelper.getPropertyIds(type),\n        PropertyHelper.getKeyPropertyIds(type)));\n  }","commit_id":"030ef999f141152ef567bb930ad57ae55e128399","url":"https://github.com/apache/ambari"},{"original_method":"private void createPropertyProviders(Resource.Type type) {\n    List<PropertyProvider> providers = new LinkedList<PropertyProvider>();\n    if (type == Resource.Type.HostComponent) {\n      providers.add(new JMXPropertyProvider(\n          PropertyHelper.getPropertyIds(type, \"JMX\"),\n          new URLStreamProvider(),\n          hostMapping));\n\n      providers.add(new GangliaPropertyProvider(\n          PropertyHelper.getPropertyIds(type, \"GANGLIA\"),\n          new URLStreamProvider(),\n          gangliaCollectorHostName));\n    }\n    propertyProviders.put(type, providers);\n  }","id":33831,"modified_method":"private void createPropertyProviders(Resource.Type type) {\n    List<PropertyProvider> providers = new LinkedList<PropertyProvider>();\n\n\n    if (type == Resource.Type.Component) {\n      providers.add(new GangliaPropertyProvider(\n          PropertyHelper.getGangliaPropertyIds(type),\n          new URLStreamProvider(),\n          gangliaCollectorHostName,\n          null,\n          PropertyHelper.getPropertyId(\"component_name\", \"ServiceComponentInfo\")));\n    }\n\n    if (type == Resource.Type.HostComponent) {\n      providers.add(new JMXPropertyProvider(\n          PropertyHelper.getJMXPropertyIds(type),\n          new URLStreamProvider(),\n          hostMapping));\n\n      providers.add(new GangliaPropertyProvider(\n          PropertyHelper.getGangliaPropertyIds(type),\n          new URLStreamProvider(),\n          gangliaCollectorHostName,\n          PropertyHelper.getPropertyId(\"host_name\", \"HostRoles\"),\n          PropertyHelper.getPropertyId(\"component_name\", \"HostRoles\")));\n    }\n    propertyProviders.put(type, providers);\n  }","commit_id":"030ef999f141152ef567bb930ad57ae55e128399","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Populate a resource by obtaining the requested JMX properties.\n   *\n   * @param resource  the resource to be populated\n   * @param request   the request\n   * @param predicate the predicate\n   *\n   * @return true if the resource was successfully populated with the requested properties\n   *\n   * @throws AmbariException thrown if the resource cannot be populated\n   */\n  private boolean populateResource(Resource resource,\n                                   Request request,\n                                   Predicate predicate)\n      throws AmbariException {\n\n    if (getPropertyIds().isEmpty()) {\n      return true;\n    }\n\n    Set<PropertyId> ids = PropertyHelper.getRequestPropertyIds(getPropertyIds(), request, predicate);\n\n    String hostName = hostMapping.get( resource.getPropertyValue(HOST_COMPONENT_HOST_NAME_PROPERTY_ID));\n    String port     = JMX_PORTS.get(resource.getPropertyValue(HOST_COMPONENT_COMPONENT_NAME_PROPERTY_ID));\n\n    if (hostName == null || port == null) {\n      return true;\n    }\n\n    String spec = getSpec(hostName + \":\" + port);\n\n    try {\n      JMXMetricHolder metricHolder = new ObjectMapper().readValue(streamProvider.readFrom(spec), JMXMetricHolder.class);\n\n      Map<String, Map<String, Object>> categories = new HashMap<String, Map<String, Object>>();\n\n      for (Map<String, Object> bean : metricHolder.getBeans()) {\n        String category = getCategory(bean);\n        if (category != null) {\n          categories.put(category, bean);\n        }\n      }\n\n      for (PropertyId propertyId : ids) {\n        String category = propertyId.getCategory();\n\n        // strip off 'metrics/' from the category\n        if (category.startsWith(\"metrics/\")) {\n          category = category.substring(8);\n        }\n\n        Map<String, Object> properties = categories.get(category);\n        String name = propertyId.getName();\n        if (properties != null && properties.containsKey(name)) {\n          resource.setProperty(propertyId, properties.get(name));\n        }\n      }\n    } catch (IOException e) {\n      throw new AmbariException(\"Can't get metrics : \" + spec, e);\n    }\n\n    return true;\n  }","id":33832,"modified_method":"/**\n   * Populate a resource by obtaining the requested JMX properties.\n   *\n   * @param resource  the resource to be populated\n   * @param request   the request\n   * @param predicate the predicate\n   *\n   * @return true if the resource was successfully populated with the requested properties\n   *\n   * @throws AmbariException thrown if the resource cannot be populated\n   */\n  private boolean populateResource(Resource resource,\n                                   Request request,\n                                   Predicate predicate)\n      throws AmbariException {\n\n    if (getPropertyIds().isEmpty()) {\n      return true;\n    }\n\n    Set<PropertyId> ids = PropertyHelper.getRequestPropertyIds(getPropertyIds(), request, predicate);\n\n    String hostName      = hostMapping.get(resource.getPropertyValue(HOST_COMPONENT_HOST_NAME_PROPERTY_ID));\n    String componentName = (String) resource.getPropertyValue(HOST_COMPONENT_COMPONENT_NAME_PROPERTY_ID);\n    String port          = JMX_PORTS.get(componentName);\n\n    Map<PropertyId, String> metrics = componentMetrics.get(componentName);\n\n    if (metrics == null || hostName == null || port == null) {\n      return true;\n    }\n\n    String spec = getSpec(hostName + \":\" + port);\n\n    try {\n      JMXMetricHolder metricHolder = new ObjectMapper().readValue(streamProvider.readFrom(spec), JMXMetricHolder.class);\n\n      Map<String, Map<String, Object>> categories = new HashMap<String, Map<String, Object>>();\n\n      for (Map<String, Object> bean : metricHolder.getBeans()) {\n        String category = getCategory(bean);\n        if (category != null) {\n          categories.put(category, bean);\n        }\n      }\n\n      for (PropertyId propertyId : ids) {\n\n        String metricName = metrics.get(propertyId);\n\n        if (metricName != null) {\n\n          String property = metricName;\n          String category = \"\";\n\n          int i = property.lastIndexOf('.');\n          if (i != -1){\n            category = property.substring(0, i);\n            property = property.substring(i + 1);\n          }\n\n          Map<String, Object> properties = categories.get(category);\n          if (properties != null && properties.containsKey(property)) {\n            resource.setProperty(propertyId, properties.get(property));\n          }\n        }\n      }\n    } catch (IOException e) {\n      throw new AmbariException(\"Can't get metrics : \" + spec, e);\n    }\n\n    return true;\n  }","commit_id":"030ef999f141152ef567bb930ad57ae55e128399","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Create a JMX property provider.\n   *\n   * @param propertyIds     the property ids provided by this provider\n   * @param streamProvider  the stream provider\n   * @param hostMapping     the host mapping\n   */\n  public JMXPropertyProvider(Set<PropertyId> propertyIds,\n                              StreamProvider streamProvider,\n                              Map<String, String> hostMapping) {\n    this.propertyIds    = propertyIds;\n    this.streamProvider = streamProvider;\n    this.hostMapping    = hostMapping;\n  }","id":33833,"modified_method":"/**\n   * Create a JMX property provider.\n   *\n   * @param componentMetrics the map of supported metrics\n   * @param streamProvider   the stream provider\n   * @param hostMapping      the host mapping\n   */\n  public JMXPropertyProvider(Map<String, Map<PropertyId, String>> componentMetrics, StreamProvider streamProvider,\n                             Map<String, String> hostMapping) {\n    this.componentMetrics = componentMetrics;\n    this.streamProvider   = streamProvider;\n    this.hostMapping      = hostMapping;\n\n    propertyIds = new HashSet<PropertyId>();\n    for (Map.Entry<String, Map<PropertyId, String>> entry : componentMetrics.entrySet()) {\n      propertyIds.addAll(entry.getValue().keySet());\n    }\n  }","commit_id":"030ef999f141152ef567bb930ad57ae55e128399","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testGetResources() throws Exception {\n\n    Set< PropertyId >   propertyIds    = PropertyHelper.getPropertyIds(Resource.Type.HostComponent, \"JMX\");\n    TestStreamProvider  streamProvider = new TestStreamProvider();\n    Map<String, String> hostMap        = TestHostMappingProvider.getHostMap();\n\n    JMXPropertyProvider propertyProvider = new JMXPropertyProvider(propertyIds,\n        streamProvider,\n        hostMap);\n\n    // namenode\n    Resource resource = new ResourceImpl(Resource.Type.HostComponent);\n\n    resource.setProperty(JMXPropertyProvider.HOST_COMPONENT_HOST_NAME_PROPERTY_ID, \"domu-12-31-39-0e-34-e1.compute-1.internal\");\n    resource.setProperty(JMXPropertyProvider.HOST_COMPONENT_COMPONENT_NAME_PROPERTY_ID, \"NAMENODE\");\n\n    // request with an empty set should get all supported properties\n    Request request = PropertyHelper.getReadRequest(Collections.<PropertyId>emptySet());\n\n    Assert.assertEquals(1, propertyProvider.populateResources(Collections.singleton(resource), request, null).size());\n\n    Assert.assertEquals(propertyProvider.getSpec(\"ec2-50-17-129-192.compute-1.amazonaws.com:50070\"), streamProvider.getLastSpec());\n\n    // see test/resources/hdfs_namenode_jmx.json for values\n    Assert.assertEquals(1084287,  resource.getPropertyValue(PropertyHelper.getPropertyId(\"ReceivedBytes\", \"metrics/rpc\")));\n    Assert.assertEquals(173,      resource.getPropertyValue(PropertyHelper.getPropertyId(\"CreateFileOps\", \"metrics/dfs\")));\n    Assert.assertEquals(405.8686, resource.getPropertyValue(PropertyHelper.getPropertyId(\"memHeapUsedM\",  \"metrics/jvm\")));\n\n\n    // datanode\n    resource = new ResourceImpl(Resource.Type.HostComponent);\n\n    resource.setProperty(JMXPropertyProvider.HOST_COMPONENT_HOST_NAME_PROPERTY_ID, \"domu-12-31-39-14-ee-b3.compute-1.internal\");\n    resource.setProperty(JMXPropertyProvider.HOST_COMPONENT_COMPONENT_NAME_PROPERTY_ID, \"DATANODE\");\n\n    // request with an empty set should get all supported properties\n    request = PropertyHelper.getReadRequest(Collections.<PropertyId>emptySet());\n\n    propertyProvider.populateResources(Collections.singleton(resource), request, null);\n\n    Assert.assertEquals(propertyProvider.getSpec(\"ec2-23-23-71-42.compute-1.amazonaws.com:50075\"), streamProvider.getLastSpec());\n\n    // see test/resources/hdfs_datanode_jmx.json for values\n    Assert.assertEquals(0,  resource.getPropertyValue(PropertyHelper.getPropertyId(\"ReceivedBytes\", \"metrics/rpc\")));\n    Assert.assertEquals(16.870667, resource.getPropertyValue(PropertyHelper.getPropertyId(\"memHeapUsedM\",  \"metrics/jvm\")));\n\n\n    // jobtracker\n    resource = new ResourceImpl(Resource.Type.HostComponent);\n\n    resource.setProperty(JMXPropertyProvider.HOST_COMPONENT_HOST_NAME_PROPERTY_ID, \"domu-12-31-39-14-ee-b3.compute-1.internal\");\n    resource.setProperty(JMXPropertyProvider.HOST_COMPONENT_COMPONENT_NAME_PROPERTY_ID, \"JOBTRACKER\");\n\n    // only ask for one property\n    request = PropertyHelper.getReadRequest(Collections.singleton(PropertyHelper.getPropertyId(\"threadsWaiting\", \"metrics/jvm\")));\n\n    propertyProvider.populateResources(Collections.singleton(resource), request, null);\n\n    Assert.assertEquals(propertyProvider.getSpec(\"ec2-23-23-71-42.compute-1.amazonaws.com:50030\"), streamProvider.getLastSpec());\n\n    // see test/resources/mapreduce_jobtracker_jmx.json for values\n    // resource should now contain 3 properties... host name, component name, and jvm.threadsWaiting (from request)\n    Assert.assertEquals(3, PropertyHelper.getProperties(resource).size());\n    Assert.assertEquals(59, resource.getPropertyValue(PropertyHelper.getPropertyId(\"threadsWaiting\", \"metrics/jvm\")));\n    Assert.assertNull(resource.getPropertyValue(PropertyHelper.getPropertyId(\"gcCount\", \"metrics/jvm\")));\n  }","id":33834,"modified_method":"@Test\n  public void testGetResources() throws Exception {\n\n    TestStreamProvider  streamProvider = new TestStreamProvider();\n    Map<String, String> hostMap        = TestHostMappingProvider.getHostMap();\n\n    JMXPropertyProvider propertyProvider = new JMXPropertyProvider(\n        PropertyHelper.getJMXPropertyIds(Resource.Type.HostComponent),\n        streamProvider,\n        hostMap);\n\n    // namenode\n    Resource resource = new ResourceImpl(Resource.Type.HostComponent);\n\n    resource.setProperty(JMXPropertyProvider.HOST_COMPONENT_HOST_NAME_PROPERTY_ID, \"domu-12-31-39-0e-34-e1.compute-1.internal\");\n    resource.setProperty(JMXPropertyProvider.HOST_COMPONENT_COMPONENT_NAME_PROPERTY_ID, \"NAMENODE\");\n\n    // request with an empty set should get all supported properties\n    Request request = PropertyHelper.getReadRequest(Collections.<PropertyId>emptySet());\n\n    Assert.assertEquals(1, propertyProvider.populateResources(Collections.singleton(resource), request, null).size());\n\n    Assert.assertEquals(propertyProvider.getSpec(\"ec2-50-17-129-192.compute-1.amazonaws.com:50070\"), streamProvider.getLastSpec());\n\n    // see test/resources/hdfs_namenode_jmx.json for values\n    Assert.assertEquals(1084287,  resource.getPropertyValue(PropertyHelper.getPropertyId(\"ReceivedBytes\", \"metrics/rpc\")));\n    Assert.assertEquals(173,      resource.getPropertyValue(PropertyHelper.getPropertyId(\"CreateFileOps\", \"metrics/dfs/namenode\")));\n    Assert.assertEquals(405.8686, resource.getPropertyValue(PropertyHelper.getPropertyId(\"memHeapUsedM\",  \"metrics/jvm\")));\n\n\n    // datanode\n    resource = new ResourceImpl(Resource.Type.HostComponent);\n\n    resource.setProperty(JMXPropertyProvider.HOST_COMPONENT_HOST_NAME_PROPERTY_ID, \"domu-12-31-39-14-ee-b3.compute-1.internal\");\n    resource.setProperty(JMXPropertyProvider.HOST_COMPONENT_COMPONENT_NAME_PROPERTY_ID, \"DATANODE\");\n\n    // request with an empty set should get all supported properties\n    request = PropertyHelper.getReadRequest(Collections.<PropertyId>emptySet());\n\n    propertyProvider.populateResources(Collections.singleton(resource), request, null);\n\n    Assert.assertEquals(propertyProvider.getSpec(\"ec2-23-23-71-42.compute-1.amazonaws.com:50075\"), streamProvider.getLastSpec());\n\n    // see test/resources/hdfs_datanode_jmx.json for values\n    Assert.assertEquals(0,  resource.getPropertyValue(PropertyHelper.getPropertyId(\"ReceivedBytes\", \"metrics/rpc\")));\n    Assert.assertEquals(16.870667, resource.getPropertyValue(PropertyHelper.getPropertyId(\"memHeapUsedM\",  \"metrics/jvm\")));\n\n\n    // jobtracker\n    resource = new ResourceImpl(Resource.Type.HostComponent);\n\n    resource.setProperty(JMXPropertyProvider.HOST_COMPONENT_HOST_NAME_PROPERTY_ID, \"domu-12-31-39-14-ee-b3.compute-1.internal\");\n    resource.setProperty(JMXPropertyProvider.HOST_COMPONENT_COMPONENT_NAME_PROPERTY_ID, \"JOBTRACKER\");\n\n    // only ask for one property\n    request = PropertyHelper.getReadRequest(Collections.singleton(PropertyHelper.getPropertyId(\"threadsWaiting\", \"metrics/jvm\")));\n\n    propertyProvider.populateResources(Collections.singleton(resource), request, null);\n\n    Assert.assertEquals(propertyProvider.getSpec(\"ec2-23-23-71-42.compute-1.amazonaws.com:50030\"), streamProvider.getLastSpec());\n\n    // see test/resources/mapreduce_jobtracker_jmx.json for values\n    // resource should now contain 3 properties... host name, component name, and jvm.threadsWaiting (from request)\n    Assert.assertEquals(3, PropertyHelper.getProperties(resource).size());\n    Assert.assertEquals(59, resource.getPropertyValue(PropertyHelper.getPropertyId(\"threadsWaiting\", \"metrics/jvm\")));\n    Assert.assertNull(resource.getPropertyValue(PropertyHelper.getPropertyId(\"gcCount\", \"metrics/jvm\")));\n  }","commit_id":"030ef999f141152ef567bb930ad57ae55e128399","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Get the set of property ids required to satisfy the given request.\n   *\n   * @param providerPropertyIds  the provider property ids\n   * @param request              the request\n   * @param predicate            the predicate\n   *\n   * @return the set of property ids needed to satisfy the request\n   */\n  public static Set<PropertyId> getRequestPropertyIds(Set<PropertyId> providerPropertyIds,\n                                                      Request request,\n                                                      Predicate predicate) {\n    Set<PropertyId> propertyIds         = request.getPropertyIds();\n    Set<PropertyId> requestPropertyIds  = propertyIds == null ? null : new HashSet<PropertyId>(propertyIds);\n\n    providerPropertyIds = new HashSet<PropertyId>(providerPropertyIds);\n\n    // if no properties are specified, then return them all\n    if (requestPropertyIds == null || requestPropertyIds.isEmpty()) {\n//      // strip out the temporal properties, they must be asked for explicitly\n//      Iterator<PropertyId> iter = providerPropertyIds.iterator();\n//      while (iter.hasNext()) {\n//        PropertyId propertyId = iter.next();\n//        if (propertyId.isTemporal()) {\n//          iter.remove();\n//        }\n//      }\n      return providerPropertyIds;\n    }\n\n    if (predicate != null) {\n      requestPropertyIds.addAll(PredicateHelper.getPropertyIds(predicate));\n    }\n    requestPropertyIds.retainAll(providerPropertyIds);\n    return requestPropertyIds;\n  }","id":33835,"modified_method":"/**\n   * Get the set of property ids required to satisfy the given request.\n   *\n   * @param providerPropertyIds  the provider property ids\n   * @param request              the request\n   * @param predicate            the predicate\n   *\n   * @return the set of property ids needed to satisfy the request\n   */\n  public static Set<PropertyId> getRequestPropertyIds(Set<PropertyId> providerPropertyIds,\n                                                      Request request,\n                                                      Predicate predicate) {\n    Set<PropertyId> propertyIds         = request.getPropertyIds();\n    Set<PropertyId> requestPropertyIds  = propertyIds == null ? null : new HashSet<PropertyId>(propertyIds);\n\n    providerPropertyIds = new HashSet<PropertyId>(providerPropertyIds);\n\n    // if no properties are specified, then return them all\n    if (requestPropertyIds == null || requestPropertyIds.isEmpty()) {\n      // strip out the temporal properties, they must be asked for explicitly\n      Iterator<PropertyId> iter = providerPropertyIds.iterator();\n      while (iter.hasNext()) {\n        PropertyId propertyId = iter.next();\n        if (propertyId.isTemporal()) {\n          iter.remove();\n        }\n      }\n      return providerPropertyIds;\n    }\n\n    if (predicate != null) {\n      requestPropertyIds.addAll(PredicateHelper.getPropertyIds(predicate));\n    }\n    requestPropertyIds.retainAll(providerPropertyIds);\n    return requestPropertyIds;\n  }","commit_id":"030ef999f141152ef567bb930ad57ae55e128399","url":"https://github.com/apache/ambari"},{"original_method":"public static Set<PropertyId> getPropertyIds(Resource.Type resourceType, String providerKey) {\n\n    Map<String, Set<PropertyId>> propertyIds = PROPERTY_IDS.get(resourceType);\n    if (propertyIds != null) {\n      return propertyIds.get(providerKey);\n    }\n    return Collections.emptySet();\n  }","id":33836,"modified_method":"public static Set<PropertyId> getPropertyIds(Resource.Type resourceType) {\n    Set<PropertyId> propertyIds = PROPERTY_IDS.get(resourceType);\n    return propertyIds == null ? Collections.<PropertyId>emptySet() : propertyIds;\n  }","commit_id":"030ef999f141152ef567bb930ad57ae55e128399","url":"https://github.com/apache/ambari"},{"original_method":"private static Map<Resource.Type, Map<String, Set<PropertyId>>> readPropertyIds(String filename) {\n    ObjectMapper mapper = new ObjectMapper();\n\n    try {\n      return mapper.readValue(ClassLoader.getSystemResourceAsStream(filename), new TypeReference<Map<Resource.Type, Map<String, Set<PropertyIdImpl>>>>() {\n      });\n    } catch (IOException e) {\n      throw new IllegalStateException(\"Can't read properties file \" + filename, e);\n    }\n  }","id":33837,"modified_method":"private static Map<Resource.Type, Set<PropertyId>> readPropertyIds(String filename) {\n    ObjectMapper mapper = new ObjectMapper();\n\n    try {\n      return mapper.readValue(ClassLoader.getSystemResourceAsStream(filename), new TypeReference<Map<Resource.Type, Set<PropertyIdImpl>>>() {\n      });\n    } catch (IOException e) {\n      throw new IllegalStateException(\"Can't read properties file \" + filename, e);\n    }\n  }","commit_id":"030ef999f141152ef567bb930ad57ae55e128399","url":"https://github.com/apache/ambari"},{"original_method":"@Ignore\n  @Test\n  public void testGetPropertyIds() throws Exception {\n\n\n    Set<PropertyId> propertyIds = PropertyHelper.getPropertyIds(Resource.Type.HostComponent, \"DB\");\n\n    propertyIds = PropertyHelper.getPropertyIds(Resource.Type.HostComponent, \"JMX\");\n\n\n    propertyIds = PropertyHelper.getPropertyIds(Resource.Type.HostComponent, \"GANGLIA\");\n\n  }","id":33838,"modified_method":"@Ignore\n  @Test\n  public void testGetPropertyIds() throws Exception {\n\n\n    Set<PropertyId> propertyIds = PropertyHelper.getPropertyIds(Resource.Type.HostComponent);\n\n    propertyIds = PropertyHelper.getPropertyIds(Resource.Type.HostComponent);\n\n\n    propertyIds = PropertyHelper.getPropertyIds(Resource.Type.HostComponent);\n\n  }","commit_id":"030ef999f141152ef567bb930ad57ae55e128399","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testUpdateClusterResources() throws Exception{\n    Resource.Type type = Resource.Type.Cluster;\n\n    AmbariManagementController managementController = createMock(AmbariManagementController.class);\n    TrackActionResponse response = createNiceMock(TrackActionResponse.class);\n\n    Set<ClusterResponse> nameResponse = new HashSet<ClusterResponse>();\n    nameResponse.add(new ClusterResponse(102L, \"Cluster102\", null));\n\n    // set expectations\n    expect(managementController.getClusters(Matchers.clusterRequest(null, \"Cluster102\", null, null))).andReturn(nameResponse).once();\n    expect(managementController.updateCluster(Matchers.clusterRequest(102L, null, \"4.02\", null))).andReturn(response).once();\n    expect(managementController.updateCluster(Matchers.clusterRequest(103L, null, \"4.02\", null))).andReturn(response).once();\n\n    // replay\n    replay(managementController, response);\n\n    ResourceProvider provider = ResourceProviderImpl.getResourceProvider(\n        type,\n        PropertyHelper.getPropertyIds(type, \"DB\"),\n        PropertyHelper.getKeyPropertyIds(type),\n        managementController);\n\n    Map<PropertyId, Object> properties = new LinkedHashMap<PropertyId, Object>();\n\n    properties.put(ResourceProviderImpl.CLUSTER_VERSION_PROPERTY_ID, \"4.02\");\n\n    // create the request\n    Request request = PropertyHelper.getUpdateRequest(properties);\n\n    // update the cluster named Cluster102\n    Predicate  predicate = new PredicateBuilder().property(ResourceProviderImpl.CLUSTER_NAME_PROPERTY_ID).equals(\"Cluster102\").toPredicate();\n    provider.updateResources(request, predicate);\n\n    // update the cluster where id == 103\n    predicate = new PredicateBuilder().property(ResourceProviderImpl.CLUSTER_ID_PROPERTY_ID).equals(103L).toPredicate();\n    provider.updateResources(request, predicate);\n\n    // verify\n    verify(managementController, response);\n  }","id":33839,"modified_method":"@Test\n  public void testUpdateClusterResources() throws Exception{\n    Resource.Type type = Resource.Type.Cluster;\n\n    AmbariManagementController managementController = createMock(AmbariManagementController.class);\n    TrackActionResponse response = createNiceMock(TrackActionResponse.class);\n\n    Set<ClusterResponse> nameResponse = new HashSet<ClusterResponse>();\n    nameResponse.add(new ClusterResponse(102L, \"Cluster102\", null));\n\n    // set expectations\n    expect(managementController.getClusters(Matchers.clusterRequest(null, \"Cluster102\", null, null))).andReturn(nameResponse).once();\n    expect(managementController.updateCluster(Matchers.clusterRequest(102L, null, \"4.02\", null))).andReturn(response).once();\n    expect(managementController.updateCluster(Matchers.clusterRequest(103L, null, \"4.02\", null))).andReturn(response).once();\n\n    // replay\n    replay(managementController, response);\n\n    ResourceProvider provider = ResourceProviderImpl.getResourceProvider(\n        type,\n        PropertyHelper.getPropertyIds(type),\n        PropertyHelper.getKeyPropertyIds(type),\n        managementController);\n\n    Map<PropertyId, Object> properties = new LinkedHashMap<PropertyId, Object>();\n\n    properties.put(ResourceProviderImpl.CLUSTER_VERSION_PROPERTY_ID, \"4.02\");\n\n    // create the request\n    Request request = PropertyHelper.getUpdateRequest(properties);\n\n    // update the cluster named Cluster102\n    Predicate  predicate = new PredicateBuilder().property(ResourceProviderImpl.CLUSTER_NAME_PROPERTY_ID).equals(\"Cluster102\").toPredicate();\n    provider.updateResources(request, predicate);\n\n    // update the cluster where id == 103\n    predicate = new PredicateBuilder().property(ResourceProviderImpl.CLUSTER_ID_PROPERTY_ID).equals(103L).toPredicate();\n    provider.updateResources(request, predicate);\n\n    // verify\n    verify(managementController, response);\n  }","commit_id":"030ef999f141152ef567bb930ad57ae55e128399","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testCreateClusterResources() throws Exception{\n    Resource.Type type = Resource.Type.Cluster;\n\n    AmbariManagementController managementController = createMock(AmbariManagementController.class);\n    TrackActionResponse response = createNiceMock(TrackActionResponse.class);\n\n    managementController.createCluster(Matchers.clusterRequest(null, \"Cluster100\", \"4.02\", null));\n    managementController.createCluster(Matchers.clusterRequest(99L, null, \"4.03\", null));\n\n    // replay\n    replay(managementController, response);\n\n    ResourceProvider provider = ResourceProviderImpl.getResourceProvider(\n        type,\n        PropertyHelper.getPropertyIds(type, \"DB\"),\n        PropertyHelper.getKeyPropertyIds(type),\n        managementController);\n\n    // add the property map to a set for the request.  add more maps for multiple creates\n    Set<Map<PropertyId, Object>> propertySet = new LinkedHashSet<Map<PropertyId, Object>>();\n\n    // Cluster 1: create a map of properties for the request\n    Map<PropertyId, Object> properties = new LinkedHashMap<PropertyId, Object>();\n\n    // add the cluster name to the properties map\n    properties.put(ResourceProviderImpl.CLUSTER_NAME_PROPERTY_ID, \"Cluster100\");\n\n    // add the version to the properties map\n    properties.put(ResourceProviderImpl.CLUSTER_VERSION_PROPERTY_ID, \"4.02\");\n\n    propertySet.add(properties);\n\n    // Cluster 2: create a map of properties for the request\n    properties = new LinkedHashMap<PropertyId, Object>();\n\n    // add the cluster id to the properties map\n    properties.put(ResourceProviderImpl.CLUSTER_ID_PROPERTY_ID, 99L);\n\n    // add the version to the properties map\n    properties.put(ResourceProviderImpl.CLUSTER_VERSION_PROPERTY_ID, \"4.03\");\n\n    propertySet.add(properties);\n\n    // create the request\n    Request request = PropertyHelper.getCreateRequest(propertySet);\n\n    provider.createResources(request);\n\n    // verify\n    verify(managementController, response);\n  }","id":33840,"modified_method":"@Test\n  public void testCreateClusterResources() throws Exception{\n    Resource.Type type = Resource.Type.Cluster;\n\n    AmbariManagementController managementController = createMock(AmbariManagementController.class);\n    TrackActionResponse response = createNiceMock(TrackActionResponse.class);\n\n    managementController.createCluster(Matchers.clusterRequest(null, \"Cluster100\", \"4.02\", null));\n    managementController.createCluster(Matchers.clusterRequest(99L, null, \"4.03\", null));\n\n    // replay\n    replay(managementController, response);\n\n    ResourceProvider provider = ResourceProviderImpl.getResourceProvider(\n        type,\n        PropertyHelper.getPropertyIds(type),\n        PropertyHelper.getKeyPropertyIds(type),\n        managementController);\n\n    // add the property map to a set for the request.  add more maps for multiple creates\n    Set<Map<PropertyId, Object>> propertySet = new LinkedHashSet<Map<PropertyId, Object>>();\n\n    // Cluster 1: create a map of properties for the request\n    Map<PropertyId, Object> properties = new LinkedHashMap<PropertyId, Object>();\n\n    // add the cluster name to the properties map\n    properties.put(ResourceProviderImpl.CLUSTER_NAME_PROPERTY_ID, \"Cluster100\");\n\n    // add the version to the properties map\n    properties.put(ResourceProviderImpl.CLUSTER_VERSION_PROPERTY_ID, \"4.02\");\n\n    propertySet.add(properties);\n\n    // Cluster 2: create a map of properties for the request\n    properties = new LinkedHashMap<PropertyId, Object>();\n\n    // add the cluster id to the properties map\n    properties.put(ResourceProviderImpl.CLUSTER_ID_PROPERTY_ID, 99L);\n\n    // add the version to the properties map\n    properties.put(ResourceProviderImpl.CLUSTER_VERSION_PROPERTY_ID, \"4.03\");\n\n    propertySet.add(properties);\n\n    // create the request\n    Request request = PropertyHelper.getCreateRequest(propertySet);\n\n    provider.createResources(request);\n\n    // verify\n    verify(managementController, response);\n  }","commit_id":"030ef999f141152ef567bb930ad57ae55e128399","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testUpdateServiceResources() throws Exception{\n    Resource.Type type = Resource.Type.Service;\n\n    AmbariManagementController managementController = createMock(AmbariManagementController.class);\n    TrackActionResponse response = createNiceMock(TrackActionResponse.class);\n\n    // set expectations\n    expect(managementController.updateServices(anyObject(Set.class))).andReturn(response).once();\n\n    // replay\n    replay(managementController, response);\n\n    ResourceProvider provider = ResourceProviderImpl.getResourceProvider(\n        type,\n        PropertyHelper.getPropertyIds(type, \"DB\"),\n        PropertyHelper.getKeyPropertyIds(type),\n        managementController);\n\n    // add the property map to a set for the request.\n    Map<PropertyId, Object> properties = new LinkedHashMap<PropertyId, Object>();\n\n    properties.put(ResourceProviderImpl.SERVICE_SERVICE_STATE_PROPERTY_ID, \"DEPLOYED\");\n\n    // create the request\n    Request request = PropertyHelper.getUpdateRequest(properties);\n\n    // update the service named Service102\n    Predicate  predicate = new PredicateBuilder().property(ResourceProviderImpl.SERVICE_CLUSTER_NAME_PROPERTY_ID).equals(\"Cluster100\").\n        and().property(ResourceProviderImpl.SERVICE_SERVICE_NAME_PROPERTY_ID).equals(\"Service102\").toPredicate();\n    provider.updateResources(request, predicate);\n\n    // verify\n    verify(managementController, response);\n  }","id":33841,"modified_method":"@Test\n  public void testUpdateServiceResources() throws Exception{\n    Resource.Type type = Resource.Type.Service;\n\n    AmbariManagementController managementController = createMock(AmbariManagementController.class);\n    TrackActionResponse response = createNiceMock(TrackActionResponse.class);\n\n    // set expectations\n    expect(managementController.updateServices(anyObject(Set.class))).andReturn(response).once();\n\n    // replay\n    replay(managementController, response);\n\n    ResourceProvider provider = ResourceProviderImpl.getResourceProvider(\n        type,\n        PropertyHelper.getPropertyIds(type),\n        PropertyHelper.getKeyPropertyIds(type),\n        managementController);\n\n    // add the property map to a set for the request.\n    Map<PropertyId, Object> properties = new LinkedHashMap<PropertyId, Object>();\n\n    properties.put(ResourceProviderImpl.SERVICE_SERVICE_STATE_PROPERTY_ID, \"DEPLOYED\");\n\n    // create the request\n    Request request = PropertyHelper.getUpdateRequest(properties);\n\n    // update the service named Service102\n    Predicate  predicate = new PredicateBuilder().property(ResourceProviderImpl.SERVICE_CLUSTER_NAME_PROPERTY_ID).equals(\"Cluster100\").\n        and().property(ResourceProviderImpl.SERVICE_SERVICE_NAME_PROPERTY_ID).equals(\"Service102\").toPredicate();\n    provider.updateResources(request, predicate);\n\n    // verify\n    verify(managementController, response);\n  }","commit_id":"030ef999f141152ef567bb930ad57ae55e128399","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testCreateServiceResources() throws Exception{\n    Resource.Type type = Resource.Type.Service;\n\n    AmbariManagementController managementController = createMock(AmbariManagementController.class);\n    TrackActionResponse response = createNiceMock(TrackActionResponse.class);\n\n//    Set<ServiceRequest> requests = new HashSet<ServiceRequest>();\n//    requests.add(Matchers.serviceRequest(\"Cluster100\", \"Service100\", null, \"DEPLOYED\"));\n    managementController.createServices(anyObject(Set.class));\n\n    // replay\n    replay(managementController, response);\n\n    ResourceProvider provider = ResourceProviderImpl.getResourceProvider(\n        type,\n        PropertyHelper.getPropertyIds(type, \"DB\"),\n        PropertyHelper.getKeyPropertyIds(type),\n        managementController);\n\n    // add the property map to a set for the request.  add more maps for multiple creates\n    Set<Map<PropertyId, Object>> propertySet = new LinkedHashSet<Map<PropertyId, Object>>();\n\n    // Service 1: create a map of properties for the request\n    Map<PropertyId, Object> properties = new LinkedHashMap<PropertyId, Object>();\n\n    // add properties to the request map\n    properties.put(ResourceProviderImpl.SERVICE_CLUSTER_NAME_PROPERTY_ID, \"Cluster100\");\n    properties.put(ResourceProviderImpl.SERVICE_SERVICE_NAME_PROPERTY_ID, \"Service100\");\n    properties.put(ResourceProviderImpl.SERVICE_SERVICE_STATE_PROPERTY_ID, \"DEPLOYED\");\n\n    propertySet.add(properties);\n\n    // create the request\n    Request request = PropertyHelper.getCreateRequest(propertySet);\n\n    provider.createResources(request);\n\n    // verify\n    verify(managementController, response);\n  }","id":33842,"modified_method":"@Test\n  public void testCreateServiceResources() throws Exception{\n    Resource.Type type = Resource.Type.Service;\n\n    AmbariManagementController managementController = createMock(AmbariManagementController.class);\n    TrackActionResponse response = createNiceMock(TrackActionResponse.class);\n\n//    Set<ServiceRequest> requests = new HashSet<ServiceRequest>();\n//    requests.add(Matchers.serviceRequest(\"Cluster100\", \"Service100\", null, \"DEPLOYED\"));\n    managementController.createServices(anyObject(Set.class));\n\n    // replay\n    replay(managementController, response);\n\n    ResourceProvider provider = ResourceProviderImpl.getResourceProvider(\n        type,\n        PropertyHelper.getPropertyIds(type),\n        PropertyHelper.getKeyPropertyIds(type),\n        managementController);\n\n    // add the property map to a set for the request.  add more maps for multiple creates\n    Set<Map<PropertyId, Object>> propertySet = new LinkedHashSet<Map<PropertyId, Object>>();\n\n    // Service 1: create a map of properties for the request\n    Map<PropertyId, Object> properties = new LinkedHashMap<PropertyId, Object>();\n\n    // add properties to the request map\n    properties.put(ResourceProviderImpl.SERVICE_CLUSTER_NAME_PROPERTY_ID, \"Cluster100\");\n    properties.put(ResourceProviderImpl.SERVICE_SERVICE_NAME_PROPERTY_ID, \"Service100\");\n    properties.put(ResourceProviderImpl.SERVICE_SERVICE_STATE_PROPERTY_ID, \"DEPLOYED\");\n\n    propertySet.add(properties);\n\n    // create the request\n    Request request = PropertyHelper.getCreateRequest(propertySet);\n\n    provider.createResources(request);\n\n    // verify\n    verify(managementController, response);\n  }","commit_id":"030ef999f141152ef567bb930ad57ae55e128399","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testGetClusterResources() throws Exception{\n    Resource.Type type = Resource.Type.Cluster;\n\n    AmbariManagementController managementController = createMock(AmbariManagementController.class);\n\n    Set<ClusterResponse> allResponse = new HashSet<ClusterResponse>();\n    allResponse.add(new ClusterResponse(100L, \"Cluster100\", null));\n    allResponse.add(new ClusterResponse(101L, \"Cluster101\", null));\n    allResponse.add(new ClusterResponse(102L, \"Cluster102\", null));\n    allResponse.add(new ClusterResponse(103L, \"Cluster103\", null));\n    allResponse.add(new ClusterResponse(104L, \"Cluster104\", null));\n\n    Set<ClusterResponse> nameResponse = new HashSet<ClusterResponse>();\n    nameResponse.add(new ClusterResponse(102L, \"Cluster102\", null));\n\n    Set<ClusterResponse> idResponse = new HashSet<ClusterResponse>();\n    idResponse.add(new ClusterResponse(103L, \"Cluster103\", null));\n\n    // set expectations\n    expect(managementController.getClusters(Matchers.clusterRequest(null, null, null, null))).andReturn(allResponse).once();\n    expect(managementController.getClusters(Matchers.clusterRequest(null, \"Cluster102\", null, null))).andReturn(nameResponse).once();\n    expect(managementController.getClusters(Matchers.clusterRequest(103L, null, null, null))).andReturn(idResponse).once();\n\n    // replay\n    replay(managementController);\n\n    ResourceProvider provider = ResourceProviderImpl.getResourceProvider(\n        type,\n        PropertyHelper.getPropertyIds(type, \"DB\"),\n        PropertyHelper.getKeyPropertyIds(type),\n        managementController);\n\n    Set<PropertyId> propertyIds = new HashSet<PropertyId>();\n\n    propertyIds.add(ResourceProviderImpl.CLUSTER_ID_PROPERTY_ID);\n    propertyIds.add(ResourceProviderImpl.CLUSTER_NAME_PROPERTY_ID);\n\n    // create the request\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    // get all ... no predicate\n    Set<Resource> resources = provider.getResources(request, null);\n\n    Assert.assertEquals(5, resources.size());\n    for (Resource resource : resources) {\n      Long id = (Long) resource.getPropertyValue(ResourceProviderImpl.CLUSTER_ID_PROPERTY_ID);\n      String name = (String) resource.getPropertyValue(ResourceProviderImpl.CLUSTER_NAME_PROPERTY_ID);\n      Assert.assertEquals(name, \"Cluster\" + id);\n    }\n\n    // get cluster named Cluster102\n    Predicate  predicate = new PredicateBuilder().property(ResourceProviderImpl.CLUSTER_NAME_PROPERTY_ID).equals(\"Cluster102\").toPredicate();\n    resources = provider.getResources(request, predicate);\n\n    Assert.assertEquals(1, resources.size());\n    Assert.assertEquals(102L, resources.iterator().next().getPropertyValue(ResourceProviderImpl.CLUSTER_ID_PROPERTY_ID));\n    Assert.assertEquals(\"Cluster102\", resources.iterator().next().getPropertyValue(ResourceProviderImpl.CLUSTER_NAME_PROPERTY_ID));\n\n    // get cluster with id == 103\n    predicate = new PredicateBuilder().property(ResourceProviderImpl.CLUSTER_ID_PROPERTY_ID).equals(103L).toPredicate();\n    resources = provider.getResources(request, predicate);\n\n    Assert.assertEquals(1, resources.size());\n    Assert.assertEquals(103L, resources.iterator().next().getPropertyValue(ResourceProviderImpl.CLUSTER_ID_PROPERTY_ID));\n    Assert.assertEquals(\"Cluster103\", resources.iterator().next().getPropertyValue(ResourceProviderImpl.CLUSTER_NAME_PROPERTY_ID));\n\n    // verify\n    verify(managementController);\n  }","id":33843,"modified_method":"@Test\n  public void testGetClusterResources() throws Exception{\n    Resource.Type type = Resource.Type.Cluster;\n\n    AmbariManagementController managementController = createMock(AmbariManagementController.class);\n\n    Set<ClusterResponse> allResponse = new HashSet<ClusterResponse>();\n    allResponse.add(new ClusterResponse(100L, \"Cluster100\", null));\n    allResponse.add(new ClusterResponse(101L, \"Cluster101\", null));\n    allResponse.add(new ClusterResponse(102L, \"Cluster102\", null));\n    allResponse.add(new ClusterResponse(103L, \"Cluster103\", null));\n    allResponse.add(new ClusterResponse(104L, \"Cluster104\", null));\n\n    Set<ClusterResponse> nameResponse = new HashSet<ClusterResponse>();\n    nameResponse.add(new ClusterResponse(102L, \"Cluster102\", null));\n\n    Set<ClusterResponse> idResponse = new HashSet<ClusterResponse>();\n    idResponse.add(new ClusterResponse(103L, \"Cluster103\", null));\n\n    // set expectations\n    expect(managementController.getClusters(Matchers.clusterRequest(null, null, null, null))).andReturn(allResponse).once();\n    expect(managementController.getClusters(Matchers.clusterRequest(null, \"Cluster102\", null, null))).andReturn(nameResponse).once();\n    expect(managementController.getClusters(Matchers.clusterRequest(103L, null, null, null))).andReturn(idResponse).once();\n\n    // replay\n    replay(managementController);\n\n    ResourceProvider provider = ResourceProviderImpl.getResourceProvider(\n        type,\n        PropertyHelper.getPropertyIds(type),\n        PropertyHelper.getKeyPropertyIds(type),\n        managementController);\n\n    Set<PropertyId> propertyIds = new HashSet<PropertyId>();\n\n    propertyIds.add(ResourceProviderImpl.CLUSTER_ID_PROPERTY_ID);\n    propertyIds.add(ResourceProviderImpl.CLUSTER_NAME_PROPERTY_ID);\n\n    // create the request\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    // get all ... no predicate\n    Set<Resource> resources = provider.getResources(request, null);\n\n    Assert.assertEquals(5, resources.size());\n    for (Resource resource : resources) {\n      Long id = (Long) resource.getPropertyValue(ResourceProviderImpl.CLUSTER_ID_PROPERTY_ID);\n      String name = (String) resource.getPropertyValue(ResourceProviderImpl.CLUSTER_NAME_PROPERTY_ID);\n      Assert.assertEquals(name, \"Cluster\" + id);\n    }\n\n    // get cluster named Cluster102\n    Predicate  predicate = new PredicateBuilder().property(ResourceProviderImpl.CLUSTER_NAME_PROPERTY_ID).equals(\"Cluster102\").toPredicate();\n    resources = provider.getResources(request, predicate);\n\n    Assert.assertEquals(1, resources.size());\n    Assert.assertEquals(102L, resources.iterator().next().getPropertyValue(ResourceProviderImpl.CLUSTER_ID_PROPERTY_ID));\n    Assert.assertEquals(\"Cluster102\", resources.iterator().next().getPropertyValue(ResourceProviderImpl.CLUSTER_NAME_PROPERTY_ID));\n\n    // get cluster with id == 103\n    predicate = new PredicateBuilder().property(ResourceProviderImpl.CLUSTER_ID_PROPERTY_ID).equals(103L).toPredicate();\n    resources = provider.getResources(request, predicate);\n\n    Assert.assertEquals(1, resources.size());\n    Assert.assertEquals(103L, resources.iterator().next().getPropertyValue(ResourceProviderImpl.CLUSTER_ID_PROPERTY_ID));\n    Assert.assertEquals(\"Cluster103\", resources.iterator().next().getPropertyValue(ResourceProviderImpl.CLUSTER_NAME_PROPERTY_ID));\n\n    // verify\n    verify(managementController);\n  }","commit_id":"030ef999f141152ef567bb930ad57ae55e128399","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testGetServiceResources() throws Exception{\n    Resource.Type type = Resource.Type.Service;\n\n    AmbariManagementController managementController = createMock(AmbariManagementController.class);\n\n    Set<ServiceResponse> allResponse = new HashSet<ServiceResponse>();\n    allResponse.add(new ServiceResponse(100L, \"Cluster100\", \"Service100\", null, \"4.02\", null));\n    allResponse.add(new ServiceResponse(100L, \"Cluster100\", \"Service101\", null, \"4.02\", null));\n    allResponse.add(new ServiceResponse(100L, \"Cluster100\", \"Service102\", null, \"4.02\", null));\n    allResponse.add(new ServiceResponse(100L, \"Cluster100\", \"Service103\", null, \"4.02\", null));\n    allResponse.add(new ServiceResponse(100L, \"Cluster100\", \"Service104\", null, \"4.02\", null));\n\n    Set<ServiceResponse> nameResponse = new HashSet<ServiceResponse>();\n    nameResponse.add(new ServiceResponse(100L, \"Cluster100\", \"Service102\", null, \"4.02\", null));\n\n    Set<ServiceResponse> stateResponse = new HashSet<ServiceResponse>();\n    stateResponse.add(new ServiceResponse(100L, \"Cluster100\", \"Service100\", null, \"4.02\", null));\n    stateResponse.add(new ServiceResponse(100L, \"Cluster100\", \"Service102\", null, \"4.02\", null));\n    stateResponse.add(new ServiceResponse(100L, \"Cluster100\", \"Service104\", null, \"4.02\", null));\n\n    // set expectations\n    expect(managementController.getServices(Matchers.serviceRequest(null, null, null, null))).andReturn(allResponse).once();\n    expect(managementController.getServices(Matchers.serviceRequest(null, \"Service102\", null, null))).andReturn(nameResponse).once();\n    expect(managementController.getServices(Matchers.serviceRequest(null, null, null, \"DEPLOYED\"))).andReturn(stateResponse).once();\n\n    // replay\n    replay(managementController);\n\n    ResourceProvider provider = ResourceProviderImpl.getResourceProvider(\n        type,\n        PropertyHelper.getPropertyIds(type, \"DB\"),\n        PropertyHelper.getKeyPropertyIds(type),\n        managementController);\n\n    Set<PropertyId> propertyIds = new HashSet<PropertyId>();\n\n    propertyIds.add(ResourceProviderImpl.SERVICE_CLUSTER_NAME_PROPERTY_ID);\n    propertyIds.add(ResourceProviderImpl.SERVICE_SERVICE_NAME_PROPERTY_ID);\n\n    // create the request\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    // get all ... no predicate\n    Set<Resource> resources = provider.getResources(request, null);\n\n    Assert.assertEquals(5, resources.size());\n    Set<String> names = new HashSet<String>();\n    for (Resource resource : resources) {\n      String clusterName = (String) resource.getPropertyValue(ResourceProviderImpl.SERVICE_CLUSTER_NAME_PROPERTY_ID);\n      Assert.assertEquals(\"Cluster100\", clusterName);\n      names.add((String) resource.getPropertyValue(ResourceProviderImpl.SERVICE_SERVICE_NAME_PROPERTY_ID));\n    }\n    // Make sure that all of the response objects got moved into resources\n    for (ServiceResponse serviceResponse : allResponse ) {\n      Assert.assertTrue(names.contains(serviceResponse.getServiceName()));\n    }\n\n    // get service named Service102\n    Predicate  predicate = new PredicateBuilder().property(ResourceProviderImpl.SERVICE_SERVICE_NAME_PROPERTY_ID).equals(\"Service102\").toPredicate();\n    resources = provider.getResources(request, predicate);\n\n    Assert.assertEquals(1, resources.size());\n    Assert.assertEquals(\"Cluster100\", resources.iterator().next().getPropertyValue(ResourceProviderImpl.SERVICE_CLUSTER_NAME_PROPERTY_ID));\n    Assert.assertEquals(\"Service102\", resources.iterator().next().getPropertyValue(ResourceProviderImpl.SERVICE_SERVICE_NAME_PROPERTY_ID));\n\n    // get services where state == \"DEPLOYED\"\n    predicate = new PredicateBuilder().property(ResourceProviderImpl.SERVICE_SERVICE_STATE_PROPERTY_ID).equals(\"DEPLOYED\").toPredicate();\n    resources = provider.getResources(request, predicate);\n\n    Assert.assertEquals(3, resources.size());\n    names = new HashSet<String>();\n    for (Resource resource : resources) {\n      String clusterName = (String) resource.getPropertyValue(ResourceProviderImpl.SERVICE_CLUSTER_NAME_PROPERTY_ID);\n      Assert.assertEquals(\"Cluster100\", clusterName);\n      names.add((String) resource.getPropertyValue(ResourceProviderImpl.SERVICE_SERVICE_NAME_PROPERTY_ID));\n    }\n    // Make sure that all of the response objects got moved into resources\n    for (ServiceResponse serviceResponse : stateResponse ) {\n      Assert.assertTrue(names.contains(serviceResponse.getServiceName()));\n    }\n\n    // verify\n    verify(managementController);\n  }","id":33844,"modified_method":"@Test\n  public void testGetServiceResources() throws Exception{\n    Resource.Type type = Resource.Type.Service;\n\n    AmbariManagementController managementController = createMock(AmbariManagementController.class);\n\n    Set<ServiceResponse> allResponse = new HashSet<ServiceResponse>();\n    allResponse.add(new ServiceResponse(100L, \"Cluster100\", \"Service100\", null, \"4.02\", null));\n    allResponse.add(new ServiceResponse(100L, \"Cluster100\", \"Service101\", null, \"4.02\", null));\n    allResponse.add(new ServiceResponse(100L, \"Cluster100\", \"Service102\", null, \"4.02\", null));\n    allResponse.add(new ServiceResponse(100L, \"Cluster100\", \"Service103\", null, \"4.02\", null));\n    allResponse.add(new ServiceResponse(100L, \"Cluster100\", \"Service104\", null, \"4.02\", null));\n\n    Set<ServiceResponse> nameResponse = new HashSet<ServiceResponse>();\n    nameResponse.add(new ServiceResponse(100L, \"Cluster100\", \"Service102\", null, \"4.02\", null));\n\n    Set<ServiceResponse> stateResponse = new HashSet<ServiceResponse>();\n    stateResponse.add(new ServiceResponse(100L, \"Cluster100\", \"Service100\", null, \"4.02\", null));\n    stateResponse.add(new ServiceResponse(100L, \"Cluster100\", \"Service102\", null, \"4.02\", null));\n    stateResponse.add(new ServiceResponse(100L, \"Cluster100\", \"Service104\", null, \"4.02\", null));\n\n    // set expectations\n    expect(managementController.getServices(Matchers.serviceRequest(null, null, null, null))).andReturn(allResponse).once();\n    expect(managementController.getServices(Matchers.serviceRequest(null, \"Service102\", null, null))).andReturn(nameResponse).once();\n    expect(managementController.getServices(Matchers.serviceRequest(null, null, null, \"DEPLOYED\"))).andReturn(stateResponse).once();\n\n    // replay\n    replay(managementController);\n\n    ResourceProvider provider = ResourceProviderImpl.getResourceProvider(\n        type,\n        PropertyHelper.getPropertyIds(type),\n        PropertyHelper.getKeyPropertyIds(type),\n        managementController);\n\n    Set<PropertyId> propertyIds = new HashSet<PropertyId>();\n\n    propertyIds.add(ResourceProviderImpl.SERVICE_CLUSTER_NAME_PROPERTY_ID);\n    propertyIds.add(ResourceProviderImpl.SERVICE_SERVICE_NAME_PROPERTY_ID);\n\n    // create the request\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    // get all ... no predicate\n    Set<Resource> resources = provider.getResources(request, null);\n\n    Assert.assertEquals(5, resources.size());\n    Set<String> names = new HashSet<String>();\n    for (Resource resource : resources) {\n      String clusterName = (String) resource.getPropertyValue(ResourceProviderImpl.SERVICE_CLUSTER_NAME_PROPERTY_ID);\n      Assert.assertEquals(\"Cluster100\", clusterName);\n      names.add((String) resource.getPropertyValue(ResourceProviderImpl.SERVICE_SERVICE_NAME_PROPERTY_ID));\n    }\n    // Make sure that all of the response objects got moved into resources\n    for (ServiceResponse serviceResponse : allResponse ) {\n      Assert.assertTrue(names.contains(serviceResponse.getServiceName()));\n    }\n\n    // get service named Service102\n    Predicate  predicate = new PredicateBuilder().property(ResourceProviderImpl.SERVICE_SERVICE_NAME_PROPERTY_ID).equals(\"Service102\").toPredicate();\n    resources = provider.getResources(request, predicate);\n\n    Assert.assertEquals(1, resources.size());\n    Assert.assertEquals(\"Cluster100\", resources.iterator().next().getPropertyValue(ResourceProviderImpl.SERVICE_CLUSTER_NAME_PROPERTY_ID));\n    Assert.assertEquals(\"Service102\", resources.iterator().next().getPropertyValue(ResourceProviderImpl.SERVICE_SERVICE_NAME_PROPERTY_ID));\n\n    // get services where state == \"DEPLOYED\"\n    predicate = new PredicateBuilder().property(ResourceProviderImpl.SERVICE_SERVICE_STATE_PROPERTY_ID).equals(\"DEPLOYED\").toPredicate();\n    resources = provider.getResources(request, predicate);\n\n    Assert.assertEquals(3, resources.size());\n    names = new HashSet<String>();\n    for (Resource resource : resources) {\n      String clusterName = (String) resource.getPropertyValue(ResourceProviderImpl.SERVICE_CLUSTER_NAME_PROPERTY_ID);\n      Assert.assertEquals(\"Cluster100\", clusterName);\n      names.add((String) resource.getPropertyValue(ResourceProviderImpl.SERVICE_SERVICE_NAME_PROPERTY_ID));\n    }\n    // Make sure that all of the response objects got moved into resources\n    for (ServiceResponse serviceResponse : stateResponse ) {\n      Assert.assertTrue(names.contains(serviceResponse.getServiceName()));\n    }\n\n    // verify\n    verify(managementController);\n  }","commit_id":"030ef999f141152ef567bb930ad57ae55e128399","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testDeleteClusterResources() throws Exception{\n    Resource.Type type = Resource.Type.Cluster;\n\n    AmbariManagementController managementController = createMock(AmbariManagementController.class);\n    TrackActionResponse response = createNiceMock(TrackActionResponse.class);\n\n    Set<ClusterResponse> nameResponse = new HashSet<ClusterResponse>();\n    nameResponse.add(new ClusterResponse(102L, \"Cluster102\", null));\n\n    // set expectations\n    expect(managementController.getClusters(Matchers.clusterRequest(null, \"Cluster102\", null, null))).andReturn(nameResponse).once();\n    managementController.deleteCluster(Matchers.clusterRequest(102L, null, null, null));\n    managementController.deleteCluster(Matchers.clusterRequest(103L, null, null, null));\n\n    // replay\n    replay(managementController, response);\n\n    ResourceProvider provider = ResourceProviderImpl.getResourceProvider(\n        type,\n        PropertyHelper.getPropertyIds(type, \"DB\"),\n        PropertyHelper.getKeyPropertyIds(type),\n        managementController);\n\n    // delete the cluster named Cluster102\n    Predicate  predicate = new PredicateBuilder().property(ResourceProviderImpl.CLUSTER_NAME_PROPERTY_ID).equals(\"Cluster102\").toPredicate();\n    provider.deleteResources(predicate);\n\n    // delete the cluster where id == 103\n    predicate = new PredicateBuilder().property(ResourceProviderImpl.CLUSTER_ID_PROPERTY_ID).equals(103L).toPredicate();\n    provider.deleteResources(predicate);\n\n    // verify\n    verify(managementController, response);\n  }","id":33845,"modified_method":"@Test\n  public void testDeleteClusterResources() throws Exception{\n    Resource.Type type = Resource.Type.Cluster;\n\n    AmbariManagementController managementController = createMock(AmbariManagementController.class);\n    TrackActionResponse response = createNiceMock(TrackActionResponse.class);\n\n    Set<ClusterResponse> nameResponse = new HashSet<ClusterResponse>();\n    nameResponse.add(new ClusterResponse(102L, \"Cluster102\", null));\n\n    // set expectations\n    expect(managementController.getClusters(Matchers.clusterRequest(null, \"Cluster102\", null, null))).andReturn(nameResponse).once();\n    managementController.deleteCluster(Matchers.clusterRequest(102L, null, null, null));\n    managementController.deleteCluster(Matchers.clusterRequest(103L, null, null, null));\n\n    // replay\n    replay(managementController, response);\n\n    ResourceProvider provider = ResourceProviderImpl.getResourceProvider(\n        type,\n        PropertyHelper.getPropertyIds(type),\n        PropertyHelper.getKeyPropertyIds(type),\n        managementController);\n\n    // delete the cluster named Cluster102\n    Predicate  predicate = new PredicateBuilder().property(ResourceProviderImpl.CLUSTER_NAME_PROPERTY_ID).equals(\"Cluster102\").toPredicate();\n    provider.deleteResources(predicate);\n\n    // delete the cluster where id == 103\n    predicate = new PredicateBuilder().property(ResourceProviderImpl.CLUSTER_ID_PROPERTY_ID).equals(103L).toPredicate();\n    provider.deleteResources(predicate);\n\n    // verify\n    verify(managementController, response);\n  }","commit_id":"030ef999f141152ef567bb930ad57ae55e128399","url":"https://github.com/apache/ambari"},{"original_method":"private String getPropertyValueAsString(final BeanWrapper bean, final String propertyName) {\n        return (String) bean.convertIfNecessary(bean.getPropertyValue(propertyName), String.class);\n    }","id":33846,"modified_method":"private String getPropertyValueAsString(final BeanWrapper bean, final String propertyName) {\n        Object value = bean.getPropertyValue(propertyName);\n        try {\n            return bean.convertIfNecessary(value, String.class);\n        } catch (ConversionNotSupportedException e) {\n            if (value instanceof InetAddress) {\n                return InetAddressUtils.toIpAddrString((InetAddress) value);\n            } else {\n                throw e;\n            }\n        }\n    }","commit_id":"f7c582b81df0a1a958d08b76b877da3281150d5e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n  public boolean evaluate(Resource resource) {\n    String propertyValue  = (String) resource.getPropertyValue(getPropertyId());\n    matcher.reset(propertyValue != null ? propertyValue : emptyString);\n\n    return patternExpr == null ?\n      propertyValue == null :\n      propertyValue != null && matcher.matches();\n  }","id":33847,"modified_method":"@Override\n  public boolean evaluate(Resource resource) {\n    Object propertyValue =  resource.getPropertyValue(getPropertyId());\n    matcher.reset(propertyValue != null ? propertyValue.toString() : emptyString);\n\n    return patternExpr == null ?\n      propertyValue == null :\n      propertyValue != null && matcher.matches();\n  }","commit_id":"c36bbc564347cfbff6fe24583693045cac510d3e","url":"https://github.com/apache/ambari"},{"original_method":"/**\n\t * Determines whether the focus will not be restored when the event is blur. By default this is\n\t * true, as we don't want to re-focus component on blur event.\n\t * \n\t * @return\n\t */\n\tprotected boolean disableFocusOnBlur()\n\t{\n\t\treturn true;\n\t}","id":33848,"modified_method":"/**\n\t * Determines whether the focus will not be restored when the event is blur. By default this is\n\t * true, as we don't want to re-focus component on blur event.\n\t * \n\t * @return <code>true<\/code> if refocusing should be disabled, <code>false<\/code> otherwise\n\t */\n\tprotected boolean disableFocusOnBlur()\n\t{\n\t\treturn true;\n\t}","commit_id":"3b2436f52f94d9ffb1bb52b0ca662c289ccf4225","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * \n\t * @return\n\t */\n\tprotected Form< ? > getForm()\n\t{\n\t\tif (form == null)\n\t\t{\n\t\t\t// try to find form in the hierarchy of owning component\n\t\t\tComponent< ? > component = getComponent();\n\t\t\tform = (Form< ? >)component.findParent(Form.class);\n\t\t\tif (form == null)\n\t\t\t{\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"form was not specified in the constructor and cannot \"\n\t\t\t\t\t\t+ \"be found in the hierarchy of the component this behavior \"\n\t\t\t\t\t\t+ \"is attached to\");\n\t\t\t}\n\t\t}\n\t\treturn form;\n\t}","id":33849,"modified_method":"/**\n\t * \n\t * @return Form that will be submitted by this behavior\n\t */\n\tprotected Form< ? > getForm()\n\t{\n\t\tif (form == null)\n\t\t{\n\t\t\t// try to find form in the hierarchy of owning component\n\t\t\tComponent< ? > component = getComponent();\n\t\t\tform = component.findParent(Form.class);\n\t\t\tif (form == null)\n\t\t\t{\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"form was not specified in the constructor and cannot \"\n\t\t\t\t\t\t+ \"be found in the hierarchy of the component this behavior \"\n\t\t\t\t\t\t+ \"is attached to\");\n\t\t\t}\n\t\t}\n\t\treturn form;\n\t}","commit_id":"3b2436f52f94d9ffb1bb52b0ca662c289ccf4225","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see Component#onComponentTag(ComponentTag)\n\t * @param tag\n\t *            the abstraction representing html tag of this component\n\t */\n\t@Override\n\tprotected void onComponentTag(final ComponentTag tag)\n\t{\n\t\t// must be attached to <option .../> tag\n\t\tcheckComponentTag(tag, \"option\");\n\n\t\tSelect select = (Select)findParent(Select.class);\n\t\tif (select == null)\n\t\t{\n\t\t\tthrow new WicketRuntimeException(\n\t\t\t\t\t\"SelectOption component [\"\n\t\t\t\t\t\t\t+ getPath()\n\t\t\t\t\t\t\t+ \"] cannot find its parent Select. All SelectOption components must be a child of or below in the hierarchy of a Select component.\");\n\t\t}\n\n\t\t// assign name and value\n\t\ttag.put(\"value\", getPath());\n\n\n\t\tif (select.isSelected(this))\n\t\t{\n\t\t\ttag.put(\"selected\", \"true\");\n\t\t}\n\n\t\t// Default handling for component tag\n\t\tsuper.onComponentTag(tag);\n\t}","id":33850,"modified_method":"/**\n\t * @see Component#onComponentTag(ComponentTag)\n\t * @param tag\n\t *            the abstraction representing html tag of this component\n\t */\n\t@Override\n\tprotected void onComponentTag(final ComponentTag tag)\n\t{\n\t\t// must be attached to <option .../> tag\n\t\tcheckComponentTag(tag, \"option\");\n\n\t\tSelect select = findParent(Select.class);\n\t\tif (select == null)\n\t\t{\n\t\t\tthrow new WicketRuntimeException(\n\t\t\t\t\t\"SelectOption component [\"\n\t\t\t\t\t\t\t+ getPath()\n\t\t\t\t\t\t\t+ \"] cannot find its parent Select. All SelectOption components must be a child of or below in the hierarchy of a Select component.\");\n\t\t}\n\n\t\t// assign name and value\n\t\ttag.put(\"value\", getPath());\n\n\n\t\tif (select.isSelected(this))\n\t\t{\n\t\t\ttag.put(\"selected\", \"true\");\n\t\t}\n\n\t\t// Default handling for component tag\n\t\tsuper.onComponentTag(tag);\n\t}","commit_id":"7a201a14053ef05a2be810f77dc8f23ec39fe44f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.extensions.wizard.IWizardModel#previous()\n\t */\n\tpublic void previous()\n\t{\n\t\tIWizardStep step = (IWizardStep)history.pop();\n\t\tsetActiveStep(step);\n\t}","id":33851,"modified_method":"/**\n\t * @see wicket.extensions.wizard.IWizardModel#previous()\n\t */\n\tpublic void previous()\n\t{\n\t\tIWizardStep step = history.pop();\n\t\tsetActiveStep(step);\n\t}","commit_id":"7a201a14053ef05a2be810f77dc8f23ec39fe44f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Adds a component to the list of components to be rendered\n\t * \n\t * @param markupId\n\t *            id of client-side dom element that will be updated\n\t * \n\t * @param component\n\t *            component to be rendered\n\t */\n\tpublic final void addComponent(Component component, String markupId)\n\t{\n\t\tif (Strings.isEmpty(markupId))\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"markupId cannot be empty\");\n\t\t}\n\t\tif (component == null)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"component cannot be null\");\n\t\t}\n\t\telse if (component instanceof Page)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"component cannot be a page\");\n\t\t}\n\t\telse if (component instanceof AbstractRepeater)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"Component \" +\n\t\t\t\t\tcomponent.getClass().getName() +\n\t\t\t\t\t\" has been added to the target. This component is a repeater and cannot be repainted via ajax directly. Instead add its parent or another markup container higher in the hierarchy.\");\n\t\t}\n\n\t\tmarkupIdToComponent.put(markupId, component);\n\t}","id":33852,"modified_method":"/**\n\t * Adds a component to the list of components to be rendered\n\t * \n\t * @param markupId\n\t *            id of client-side dom element that will be updated\n\t * \n\t * @param component\n\t *            component to be rendered\n\t */\n\tpublic final void addComponent(Component component, String markupId)\n\t{\n\t\tif (Strings.isEmpty(markupId))\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"markupId cannot be empty\");\n\t\t}\n\t\tif (component == null)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"component cannot be null\");\n\t\t}\n\t\telse if (component instanceof Page)\n\t\t{\n\t\t\tif (component != page)\n\t\t\t{\n\t\t\t\tthrow new IllegalArgumentException(\"component cannot be a page\");\n\t\t\t}\n\t\t}\n\t\telse if (component instanceof AbstractRepeater)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"Component \" +\n\t\t\t\t\tcomponent.getClass().getName() +\n\t\t\t\t\t\" has been added to the target. This component is a repeater and cannot be repainted via ajax directly. Instead add its parent or another markup container higher in the hierarchy.\");\n\t\t}\n\n\t\tmarkupIdToComponent.put(markupId, component);\n\t}","commit_id":"55dc67e36edf1963c29332aae3ea15d86cd42133","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see org.apache.wicket.IRequestTarget#respond(org.apache.wicket.RequestCycle)\n\t */\n\tpublic final void respond(final RequestCycle requestCycle)\n\t{\n\t\tfor (ITargetRespondListener listener : respondListeners)\n\t\t{\n\t\t\tlistener.onTargetRespond(this);\n\t\t}\n\n\t\tfinal Application app = Application.get();\n\n\t\t// Determine encoding\n\t\tfinal String encoding = app.getRequestCycleSettings().getResponseRequestEncoding();\n\n\t\t// Set content type based on markup type for page\n\t\tfinal WebResponse response = (WebResponse)requestCycle.getResponse();\n\t\tresponse.setCharacterEncoding(encoding);\n\t\tresponse.setContentType(\"text/xml; charset=\" + encoding);\n\n\t\t// Make sure it is not cached by a client\n\t\tresponse.setHeader(\"Expires\", \"Mon, 26 Jul 1997 05:00:00 GMT\");\n\t\tresponse.setHeader(\"Cache-Control\", \"no-cache, must-revalidate\");\n\t\tresponse.setHeader(\"Pragma\", \"no-cache\");\n\n\t\tresponse.write(\"<?xml version=\\\"1.0\\\" encoding=\\\"\");\n\t\tresponse.write(encoding);\n\t\tresponse.write(\"\\\"?>\");\n\t\tresponse.write(\"<ajax-response>\");\n\n\t\t// invoke onbeforerespond event on listeners\n\t\tfireOnBeforeRespondListeners();\n\n\t\t// normal behavior\n\t\tIterator<String> it = prependJavascripts.iterator();\n\t\twhile (it.hasNext())\n\t\t{\n\t\t\tString js = it.next();\n\t\t\trespondInvocation(response, js);\n\t\t}\n\n\t\t// process added components\n\t\trespondComponents(response);\n\n\t\tfireOnAfterRespondListeners(response);\n\n\t\t// execute the dom ready javascripts as first javascripts\n\t\t// after component replacement\n\t\tit = domReadyJavascripts.iterator();\n\t\twhile (it.hasNext())\n\t\t{\n\t\t\tString js = it.next();\n\t\t\trespondInvocation(response, js);\n\t\t}\n\t\tit = appendJavascripts.iterator();\n\t\twhile (it.hasNext())\n\t\t{\n\t\t\tString js = it.next();\n\t\t\trespondInvocation(response, js);\n\t\t}\n\n\t\tresponse.write(\"<\/ajax-response>\");\n\t}","id":33853,"modified_method":"/**\n\t * @see org.apache.wicket.IRequestTarget#respond(org.apache.wicket.RequestCycle)\n\t */\n\tpublic final void respond(final RequestCycle requestCycle)\n\t{\n\t\tfinal WebResponse response = (WebResponse)requestCycle.getResponse();\n\n\t\tif (markupIdToComponent.values().contains(page))\n\t\t{\n\t\t\t// the page itself has been added to the request target, we simply issue a redirect back\n\t\t\t// to the page\n\t\t\tfinal String url = requestCycle.urlFor(page).toString();\n\t\t\tresponse.redirect(url);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (ITargetRespondListener listener : respondListeners)\n\t\t{\n\t\t\tlistener.onTargetRespond(this);\n\t\t}\n\n\t\tfinal Application app = Application.get();\n\n\t\t// Determine encoding\n\t\tfinal String encoding = app.getRequestCycleSettings().getResponseRequestEncoding();\n\n\t\t// Set content type based on markup type for page\n\t\tresponse.setCharacterEncoding(encoding);\n\t\tresponse.setContentType(\"text/xml; charset=\" + encoding);\n\n\t\t// Make sure it is not cached by a client\n\t\tresponse.setHeader(\"Expires\", \"Mon, 26 Jul 1997 05:00:00 GMT\");\n\t\tresponse.setHeader(\"Cache-Control\", \"no-cache, must-revalidate\");\n\t\tresponse.setHeader(\"Pragma\", \"no-cache\");\n\n\t\tresponse.write(\"<?xml version=\\\"1.0\\\" encoding=\\\"\");\n\t\tresponse.write(encoding);\n\t\tresponse.write(\"\\\"?>\");\n\t\tresponse.write(\"<ajax-response>\");\n\n\t\t// invoke onbeforerespond event on listeners\n\t\tfireOnBeforeRespondListeners();\n\n\t\t// normal behavior\n\t\tIterator<String> it = prependJavascripts.iterator();\n\t\twhile (it.hasNext())\n\t\t{\n\t\t\tString js = it.next();\n\t\t\trespondInvocation(response, js);\n\t\t}\n\n\t\t// process added components\n\t\trespondComponents(response);\n\n\t\tfireOnAfterRespondListeners(response);\n\n\t\t// execute the dom ready javascripts as first javascripts\n\t\t// after component replacement\n\t\tit = domReadyJavascripts.iterator();\n\t\twhile (it.hasNext())\n\t\t{\n\t\t\tString js = it.next();\n\t\t\trespondInvocation(response, js);\n\t\t}\n\t\tit = appendJavascripts.iterator();\n\t\twhile (it.hasNext())\n\t\t{\n\t\t\tString js = it.next();\n\t\t\trespondInvocation(response, js);\n\t\t}\n\n\t\tresponse.write(\"<\/ajax-response>\");\n\t}","commit_id":"55dc67e36edf1963c29332aae3ea15d86cd42133","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * \n\t * @param response\n\t * @param markupId\n\t *            id of client-side dom element\n\t * @param component\n\t *            component to render\n\t */\n\tprivate void respondComponent(final Response response, final String markupId,\n\t\tfinal Component component)\n\t{\n\t\tif (component.getRenderBodyOnly() == true)\n\t\t{\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\"Ajax render cannot be called on component that has setRenderBodyOnly enabled. Component: \" +\n\t\t\t\t\tcomponent.toString());\n\t\t}\n\n\t\tcomponent.setOutputMarkupId(true);\n\n\t\t// substitute our encoding response for the real one so we can capture\n\t\t// component's markup in a manner safe for transport inside CDATA block\n\t\tfinal Response originalResponse = response;\n\t\tencodingBodyResponse.reset();\n\t\tRequestCycle.get().setResponse(encodingBodyResponse);\n\n\t\t// Initialize temporary variables\n\t\tfinal Page page = (Page)component.findParent(Page.class);\n\t\tif (page == null)\n\t\t{\n\t\t\t// dont throw an exception but just ignore this component, somehow\n\t\t\t// it got\n\t\t\t// removed from the page.\n\t\t\t// throw new IllegalStateException(\n\t\t\t// \"Ajax request attempted on a component that is not associated\n\t\t\t// with a Page\");\n\t\t\tLOG.debug(\"component: \" + component + \" with markupid: \" + markupId +\n\t\t\t\t\" not rendered because it was already removed from page\");\n\t\t\treturn;\n\t\t}\n\n\t\tpage.startComponentRender(component);\n\n\t\tcomponent.prepareForRender();\n\n\t\t// render any associated headers of the component\n\t\trespondHeaderContribution(response, component);\n\n\t\tcomponent.renderComponent();\n\n\t\tpage.endComponentRender(component);\n\n\t\t// Restore original response\n\t\tRequestCycle.get().setResponse(originalResponse);\n\n\t\tresponse.write(\"<component id=\\\"\");\n\t\tresponse.write(markupId);\n\t\tresponse.write(\"\\\" \");\n\t\tif (encodingBodyResponse.isContentsEncoded())\n\t\t{\n\t\t\tresponse.write(\" encoding=\\\"\");\n\t\t\tresponse.write(getEncodingName());\n\t\t\tresponse.write(\"\\\" \");\n\t\t}\n\t\tresponse.write(\"><![CDATA[\");\n\t\tresponse.write(encodingBodyResponse.getContents());\n\t\tresponse.write(\"]]><\/component>\");\n\n\t\tencodingBodyResponse.reset();\n\t}","id":33854,"modified_method":"/**\n\t * \n\t * @param response\n\t * @param markupId\n\t *            id of client-side dom element\n\t * @param component\n\t *            component to render\n\t */\n\tprivate void respondComponent(final Response response, final String markupId,\n\t\tfinal Component component)\n\t{\n\t\tif (component.getRenderBodyOnly() == true)\n\t\t{\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\"Ajax render cannot be called on component that has setRenderBodyOnly enabled. Component: \" +\n\t\t\t\t\tcomponent.toString());\n\t\t}\n\n\t\tcomponent.setOutputMarkupId(true);\n\n\t\t// substitute our encoding response for the real one so we can capture\n\t\t// component's markup in a manner safe for transport inside CDATA block\n\t\tfinal Response originalResponse = response;\n\t\tencodingBodyResponse.reset();\n\t\tRequestCycle.get().setResponse(encodingBodyResponse);\n\n\t\t// Initialize temporary variables\n\t\tfinal Page page = component.findParent(Page.class);\n\t\tif (page == null)\n\t\t{\n\t\t\t// dont throw an exception but just ignore this component, somehow\n\t\t\t// it got\n\t\t\t// removed from the page.\n\t\t\t// throw new IllegalStateException(\n\t\t\t// \"Ajax request attempted on a component that is not associated\n\t\t\t// with a Page\");\n\t\t\tLOG.debug(\"component: \" + component + \" with markupid: \" + markupId +\n\t\t\t\t\" not rendered because it was already removed from page\");\n\t\t\treturn;\n\t\t}\n\n\t\tpage.startComponentRender(component);\n\n\t\tcomponent.prepareForRender();\n\n\t\t// render any associated headers of the component\n\t\trespondHeaderContribution(response, component);\n\n\t\tcomponent.renderComponent();\n\n\t\tpage.endComponentRender(component);\n\n\t\t// Restore original response\n\t\tRequestCycle.get().setResponse(originalResponse);\n\n\t\tresponse.write(\"<component id=\\\"\");\n\t\tresponse.write(markupId);\n\t\tresponse.write(\"\\\" \");\n\t\tif (encodingBodyResponse.isContentsEncoded())\n\t\t{\n\t\t\tresponse.write(\" encoding=\\\"\");\n\t\t\tresponse.write(getEncodingName());\n\t\t\tresponse.write(\"\\\" \");\n\t\t}\n\t\tresponse.write(\"><![CDATA[\");\n\t\tresponse.write(encodingBodyResponse.getContents());\n\t\tresponse.write(\"]]><\/component>\");\n\n\t\tencodingBodyResponse.reset();\n\t}","commit_id":"55dc67e36edf1963c29332aae3ea15d86cd42133","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * The FileUploadField will close any input streams you have opened in its FileUpload by\n\t * default. If you wish to manage the stream yourself (e.g. you want to use it in another\n\t * thread) then you can override this method to prevent this behavior.\n\t * \n\t * @return\n\t */\n\tprotected boolean forceCloseStreamsOnDetach()\n\t{\n\t\treturn true;\n\t}","id":33855,"modified_method":"/**\n\t * The FileUploadField will close any input streams you have opened in its FileUpload by\n\t * default. If you wish to manage the stream yourself (e.g. you want to use it in another\n\t * thread) then you can override this method to prevent this behavior.\n\t * \n\t * @return <code>true<\/code> if stream should be closed at the end of request\n\t */\n\tprotected boolean forceCloseStreamsOnDetach()\n\t{\n\t\treturn true;\n\t}","commit_id":"9e3f2ae589a49e1db0af374196fd70f88429788b","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see org.apache.wicket.markup.html.form.AbstractChoice#AbstractChoice(String, IModel,\n\t *      IModel,IChoiceRenderer)\n\t */\n\tpublic ListChoice(String id, IModel<T> model, IModel<List<? extends T>> choices,\n\t\tIChoiceRenderer<T> renderer, int maxRows)\n\t{\n\t\tsuper(id, model, choices, renderer);\n\t\tthis.maxRows = maxRows;\n\t}","id":33856,"modified_method":"/**\n\t * @param id\n\t * @param model\n\t * @param choices\n\t * @param renderer\n\t * @param maxRows\n\t * @see org.apache.wicket.markup.html.form.AbstractChoice#AbstractChoice(String, IModel,\n\t *      IModel,IChoiceRenderer)\n\t */\n\tpublic ListChoice(String id, IModel<T> model, IModel<List<? extends T>> choices,\n\t\tIChoiceRenderer<T> renderer, int maxRows)\n\t{\n\t\tsuper(id, model, choices, renderer);\n\t\tthis.maxRows = maxRows;\n\t}","commit_id":"9e3f2ae589a49e1db0af374196fd70f88429788b","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see org.apache.wicket.Component#onComponentTagBody(MarkupStream, ComponentTag)\n\t */\n\t@Override\n\tprotected final void onComponentTagBody(final MarkupStream markupStream,\n\t\tfinal ComponentTag openTag)\n\t{\n\t\t// Iterate through choices\n\t\tfinal List< ? extends T> choices = getChoices();\n\n\t\t// Buffer to hold generated body\n\t\tfinal AppendingStringBuffer buffer = new AppendingStringBuffer((choices.size() + 1) * 70);\n\n\t\t// The selected value\n\t\tfinal String selected = getValue();\n\n\t\t// Loop through choices\n\t\tfor (int index = 0; index < choices.size(); index++)\n\t\t{\n\t\t\t// Get next choice\n\t\t\tfinal T choice = choices.get(index);\n\n      T displayValue = (T) getChoiceRenderer().getDisplayValue(choice);\n      Class<T> objectClass = (Class<T>) (displayValue == null ? null : displayValue.getClass());\n\n\t\t\t// Get label for choice\n\t\t\tString label = \"\";\n\n\t\t\tif (objectClass != null && objectClass != String.class)\n\t\t\t{\n        final IConverter<T> converter = getConverter(objectClass);\n\n        if(!converter.getClass().isAssignableFrom(objectClass))\n          throw new IllegalArgumentException(\"converter can not convert \" + objectClass.getName() + \" to string\");\n\n        label = converter.convertToString(displayValue, getLocale());\n\t\t\t}\n\t\t\telse if (displayValue != null)\n\t\t\t{\n\t\t\t\tlabel = displayValue.toString();\n\t\t\t}\n\n\t\t\t// If there is a display value for the choice, then we know that the\n\t\t\t// choice is automatic in some way. If label is /null/ then we know\n\t\t\t// that the choice is a manually created radio tag at some random\n\t\t\t// location in the page markup!\n\t\t\tif (label != null)\n\t\t\t{\n\t\t\t\t// Append option suffix\n\t\t\t\tbuffer.append(getPrefix());\n\n\t\t\t\tString id = getChoiceRenderer().getIdValue(choice, index);\n\t\t\t\tfinal String idAttr = getInputName() + \"_\" + id;\n\n\t\t\t\t// Add radio tag\n\t\t\t\tbuffer.append(\"<input name=\\\"\")\n\t\t\t\t\t.append(getInputName())\n\t\t\t\t\t.append(\"\\\"\")\n\t\t\t\t\t.append(\" type=\\\"radio\\\"\")\n\t\t\t\t\t.append((isSelected(choice, index, selected) ? \" checked=\\\"checked\\\"\" : \"\"))\n\t\t\t\t\t.append((isEnabled() ? \"\" : \" disabled=\\\"disabled\\\"\"))\n\t\t\t\t\t.append(\" value=\\\"\")\n\t\t\t\t\t.append(id)\n\t\t\t\t\t.append(\"\\\" id=\\\"\")\n\t\t\t\t\t.append(idAttr)\n\t\t\t\t\t.append(\"\\\"\");\n\n\t\t\t\t// Should a roundtrip be made (have onSelectionChanged called)\n\t\t\t\t// when the option is clicked?\n\t\t\t\tif (wantOnSelectionChangedNotifications())\n\t\t\t\t{\n\t\t\t\t\tCharSequence url = urlFor(IOnChangeListener.INTERFACE);\n\n\t\t\t\t\tForm form = (Form)findParent(Form.class);\n\t\t\t\t\tif (form != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tRequestContext rc = RequestContext.get();\n\t\t\t\t\t\tif (rc.isPortletRequest())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// restore url back to real wicket path as its going to be interpreted\n\t\t\t\t\t\t\t// by the form itself\n\t\t\t\t\t\t\turl = ((PortletRequestContext)rc).getLastEncodedPath();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbuffer.append(\" onclick=\\\"\").append(form.getJsForInterfaceUrl(url)).append(\n\t\t\t\t\t\t\t\";\\\"\");\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// TODO: following doesn't work with portlets, should be posted to a dynamic\n\t\t\t\t\t\t// hidden form\n\t\t\t\t\t\t// with an ActionURL or something\n\t\t\t\t\t\t// NOTE: do not encode the url as that would give\n\t\t\t\t\t\t// invalid JavaScript\n\t\t\t\t\t\tbuffer.append(\" onclick=\\\"window.location.href='\")\n\t\t\t\t\t\t\t.append(url)\n\t\t\t\t\t\t\t.append(\n\t\t\t\t\t\t\t\t(url.toString().indexOf('?') > -1 ? \"&amp;\" : \"?\") + getInputName())\n\t\t\t\t\t\t\t.append(\"=\")\n\t\t\t\t\t\t\t.append(id)\n\t\t\t\t\t\t\t.append(\"';\\\"\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbuffer.append(\"/>\");\n\n\t\t\t\t// Add label for radio button\n\t\t\t\tString display = label;\n\t\t\t\tif (localizeDisplayValues())\n\t\t\t\t{\n\t\t\t\t\tdisplay = getLocalizer().getString(label, this, label);\n\t\t\t\t}\n\t\t\t\tCharSequence escaped = Strings.escapeMarkup(display, false, true);\n\t\t\t\tbuffer.append(\"<label for=\\\"\").append(idAttr).append(\"\\\">\").append(escaped).append(\n\t\t\t\t\t\"<\/label>\");\n\n\t\t\t\t// Append option suffix\n\t\t\t\tbuffer.append(getSuffix());\n\t\t\t}\n\t\t}\n\n\t\t// Replace body\n\t\treplaceComponentTagBody(markupStream, openTag, buffer);\n\t}","id":33857,"modified_method":"/**\n\t * @see org.apache.wicket.Component#onComponentTagBody(MarkupStream, ComponentTag)\n\t */\n\t@Override\n\tprotected final void onComponentTagBody(final MarkupStream markupStream,\n\t\tfinal ComponentTag openTag)\n\t{\n\t\t// Iterate through choices\n\t\tfinal List<? extends T> choices = getChoices();\n\n\t\t// Buffer to hold generated body\n\t\tfinal AppendingStringBuffer buffer = new AppendingStringBuffer((choices.size() + 1) * 70);\n\n\t\t// The selected value\n\t\tfinal String selected = getValue();\n\n\t\t// Loop through choices\n\t\tfor (int index = 0; index < choices.size(); index++)\n\t\t{\n\t\t\t// Get next choice\n\t\t\tfinal T choice = choices.get(index);\n\n\t\t\tObject displayValue = getChoiceRenderer().getDisplayValue(choice);\n\t\t\tClass<?> objectClass = (displayValue == null ? null : displayValue.getClass());\n\n\t\t\t// Get label for choice\n\t\t\tString label = \"\";\n\n\t\t\tif (objectClass != null && objectClass != String.class)\n\t\t\t{\n\t\t\t\tfinal IConverter<Object> converter = (IConverter<Object>)getConverter(objectClass);\n\n\t\t\t\tif (!converter.getClass().isAssignableFrom(objectClass))\n\t\t\t\t{\n\t\t\t\t\tthrow new IllegalArgumentException(\"converter can not convert \" +\n\t\t\t\t\t\tobjectClass.getName() + \" to string\");\n\t\t\t\t}\n\n\t\t\t\tlabel = converter.convertToString(displayValue, getLocale());\n\t\t\t}\n\t\t\telse if (displayValue != null)\n\t\t\t{\n\t\t\t\tlabel = displayValue.toString();\n\t\t\t}\n\n\t\t\t// If there is a display value for the choice, then we know that the\n\t\t\t// choice is automatic in some way. If label is /null/ then we know\n\t\t\t// that the choice is a manually created radio tag at some random\n\t\t\t// location in the page markup!\n\t\t\tif (label != null)\n\t\t\t{\n\t\t\t\t// Append option suffix\n\t\t\t\tbuffer.append(getPrefix());\n\n\t\t\t\tString id = getChoiceRenderer().getIdValue(choice, index);\n\t\t\t\tfinal String idAttr = getInputName() + \"_\" + id;\n\n\t\t\t\t// Add radio tag\n\t\t\t\tbuffer.append(\"<input name=\\\"\")\n\t\t\t\t\t.append(getInputName())\n\t\t\t\t\t.append(\"\\\"\")\n\t\t\t\t\t.append(\" type=\\\"radio\\\"\")\n\t\t\t\t\t.append((isSelected(choice, index, selected) ? \" checked=\\\"checked\\\"\" : \"\"))\n\t\t\t\t\t.append((isEnabled() ? \"\" : \" disabled=\\\"disabled\\\"\"))\n\t\t\t\t\t.append(\" value=\\\"\")\n\t\t\t\t\t.append(id)\n\t\t\t\t\t.append(\"\\\" id=\\\"\")\n\t\t\t\t\t.append(idAttr)\n\t\t\t\t\t.append(\"\\\"\");\n\n\t\t\t\t// Should a roundtrip be made (have onSelectionChanged called)\n\t\t\t\t// when the option is clicked?\n\t\t\t\tif (wantOnSelectionChangedNotifications())\n\t\t\t\t{\n\t\t\t\t\tCharSequence url = urlFor(IOnChangeListener.INTERFACE);\n\n\t\t\t\t\tForm<?> form = findParent(Form.class);\n\t\t\t\t\tif (form != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tRequestContext rc = RequestContext.get();\n\t\t\t\t\t\tif (rc.isPortletRequest())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// restore url back to real wicket path as its going to be interpreted\n\t\t\t\t\t\t\t// by the form itself\n\t\t\t\t\t\t\turl = ((PortletRequestContext)rc).getLastEncodedPath();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbuffer.append(\" onclick=\\\"\").append(form.getJsForInterfaceUrl(url)).append(\n\t\t\t\t\t\t\t\";\\\"\");\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// TODO: following doesn't work with portlets, should be posted to a dynamic\n\t\t\t\t\t\t// hidden form\n\t\t\t\t\t\t// with an ActionURL or something\n\t\t\t\t\t\t// NOTE: do not encode the url as that would give\n\t\t\t\t\t\t// invalid JavaScript\n\t\t\t\t\t\tbuffer.append(\" onclick=\\\"window.location.href='\")\n\t\t\t\t\t\t\t.append(url)\n\t\t\t\t\t\t\t.append(\n\t\t\t\t\t\t\t\t(url.toString().indexOf('?') > -1 ? \"&amp;\" : \"?\") + getInputName())\n\t\t\t\t\t\t\t.append(\"=\")\n\t\t\t\t\t\t\t.append(id)\n\t\t\t\t\t\t\t.append(\"';\\\"\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbuffer.append(\"/>\");\n\n\t\t\t\t// Add label for radio button\n\t\t\t\tString display = label;\n\t\t\t\tif (localizeDisplayValues())\n\t\t\t\t{\n\t\t\t\t\tdisplay = getLocalizer().getString(label, this, label);\n\t\t\t\t}\n\t\t\t\tCharSequence escaped = Strings.escapeMarkup(display, false, true);\n\t\t\t\tbuffer.append(\"<label for=\\\"\").append(idAttr).append(\"\\\">\").append(escaped).append(\n\t\t\t\t\t\"<\/label>\");\n\n\t\t\t\t// Append option suffix\n\t\t\t\tbuffer.append(getSuffix());\n\t\t\t}\n\t\t}\n\n\t\t// Replace body\n\t\treplaceComponentTagBody(markupStream, openTag, buffer);\n\t}","commit_id":"9e3f2ae589a49e1db0af374196fd70f88429788b","url":"https://github.com/apache/wicket"},{"original_method":"public List<AclData> listACLbyNetwork(Network network){\n        List<AclData> aclList = new ArrayList<AclData>();\n\n        List<FirewallRuleVO> fwRules;\n        fwRules = _fwRulesDao.listByNetworkAndPurposeAndNotRevoked(network.getId(), Purpose.Firewall);\n        List<FirewallRulesCidrsVO> fwCidrList = null;\n        SubnetUtils utils;\n\n        for(FirewallRuleVO rule: fwRules){\n            AclData acl = new AclData();\n            acl.setId(rule.getUuid());\n            acl.setPriority((int)rule.getId()); // CloudStack Firewall interface does not have priority\n            acl.setIpProto(rule.getProtocol());\n            String cidr = null;\n            Integer port = rule.getSourcePortStart();\n            fwCidrList = _fwCidrsDao.listByFirewallRuleId(rule.getId());\n            if(fwCidrList != null){\n                if(fwCidrList.size()>1 || rule.getSourcePortEnd()!=port){\n                    continue;\n                } else {\n                    cidr = fwCidrList.get(0).getCidr();\n                }\n            }\n            if (cidr == null || cidr.equalsIgnoreCase(\"0.0.0.0/0\")) {\n                cidr = \"\";\n            } else {\n                utils = new SubnetUtils(cidr);\n                if(!utils.getInfo().getNetworkAddress().equals(utils.getInfo().getAddress())){\n                    continue;\n                }\n            }\n            acl.setSource(acl.new AclNetwork(cidr, port));\n            acl.setAction(\"permit\");\n\n            aclList.add(acl);\n        }\n\n        List<NetworkACLItemVO> aclItems;\n        List<NetworkACLItemCidrsVO> aclCidrList;\n\n        if (network.getNetworkACLId() != null){\n            aclItems = _aclItemDao.listByACL(network.getNetworkACLId());\n            for(NetworkACLItem item: aclItems){\n                AclData acl = new AclData();\n                acl.setId(item.getUuid());\n                acl.setPriority(item.getNumber());\n                acl.setIpProto(item.getProtocol());\n                String cidr = null; // currently BCF supports single cidr policy\n                Integer port = item.getSourcePortStart(); // currently BCF supports single port policy\n                aclCidrList = _aclItemCidrsDao.listByNetworkACLItemId(item.getId());\n                if(aclCidrList != null){\n                    if(aclCidrList.size()>1 || item.getSourcePortEnd()!=port){\n                        continue;\n                    } else {\n                        cidr = aclCidrList.get(0).getCidr();\n                    }\n                }\n                if (cidr == null || cidr.equalsIgnoreCase(\"0.0.0.0/0\")) {\n                    cidr = \"\";\n                } else {\n                    utils = new SubnetUtils(cidr);\n                    if(!utils.getInfo().getNetworkAddress().equals(utils.getInfo().getAddress())){\n                        continue;\n                    }\n                }\n                acl.setSource(acl.new AclNetwork(cidr, port));\n                acl.setAction(item.getAction().name());\n\n                aclList.add(acl);\n            }\n        }\n\n        return aclList;\n    }","id":33858,"modified_method":"public List<AclData> listACLbyNetwork(Network network){\n        List<AclData> aclList = new ArrayList<AclData>();\n\n        List<FirewallRuleVO> fwRules;\n        fwRules = _fwRulesDao.listByNetworkAndPurposeAndNotRevoked(network.getId(), Purpose.Firewall);\n        List<FirewallRulesCidrsVO> fwCidrList = null;\n        SubnetUtils utils;\n\n        for(FirewallRuleVO rule: fwRules){\n            AclData acl = new AclData();\n            acl.setId(rule.getUuid());\n            acl.setPriority((int)rule.getId()); // CloudStack Firewall interface does not have priority\n            acl.setIpProto(rule.getProtocol());\n            String cidr = null;\n            Integer port = rule.getSourcePortStart();\n            fwCidrList = _fwCidrsDao.listByFirewallRuleId(rule.getId());\n            if(fwCidrList != null){\n                if (fwCidrList.size() > 1 || !rule.getSourcePortEnd().equals(port)) {\n                    continue;\n                } else {\n                    cidr = fwCidrList.get(0).getCidr();\n                }\n            }\n            if (cidr == null || cidr.equalsIgnoreCase(\"0.0.0.0/0\")) {\n                cidr = \"\";\n            } else {\n                utils = new SubnetUtils(cidr);\n                if(!utils.getInfo().getNetworkAddress().equals(utils.getInfo().getAddress())){\n                    continue;\n                }\n            }\n            acl.setSource(acl.new AclNetwork(cidr, port));\n            acl.setAction(\"permit\");\n\n            aclList.add(acl);\n        }\n\n        List<NetworkACLItemVO> aclItems;\n        List<NetworkACLItemCidrsVO> aclCidrList;\n\n        if (network.getNetworkACLId() != null){\n            aclItems = _aclItemDao.listByACL(network.getNetworkACLId());\n            for(NetworkACLItem item: aclItems){\n                AclData acl = new AclData();\n                acl.setId(item.getUuid());\n                acl.setPriority(item.getNumber());\n                acl.setIpProto(item.getProtocol());\n                String cidr = null; // currently BCF supports single cidr policy\n                Integer port = item.getSourcePortStart(); // currently BCF supports single port policy\n                aclCidrList = _aclItemCidrsDao.listByNetworkACLItemId(item.getId());\n                if(aclCidrList != null){\n                    if (aclCidrList.size() > 1 || !item.getSourcePortEnd().equals(port)) {\n                        continue;\n                    } else {\n                        cidr = aclCidrList.get(0).getCidr();\n                    }\n                }\n                if (cidr == null || cidr.equalsIgnoreCase(\"0.0.0.0/0\")) {\n                    cidr = \"\";\n                } else {\n                    utils = new SubnetUtils(cidr);\n                    if(!utils.getInfo().getNetworkAddress().equals(utils.getInfo().getAddress())){\n                        continue;\n                    }\n                }\n                acl.setSource(acl.new AclNetwork(cidr, port));\n                acl.setAction(item.getAction().name());\n\n                aclList.add(acl);\n            }\n        }\n\n        return aclList;\n    }","commit_id":"6f2fb9236490a45c120a0d767eae6833a03cc456","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public boolean applyFWRules(Network network,\n            List<? extends FirewallRule> rules)\n            throws ResourceUnavailableException {\n        SubnetUtils utils;\n        String cidr = null;\n        List<String> cidrList;\n        for(FirewallRule r: rules){\n            if(r.getState()==FirewallRule.State.Revoke){\n                continue;\n            }\n            cidrList = r.getSourceCidrList();\n            if(cidrList != null){\n                if(cidrList.size()>1 || r.getSourcePortEnd()!=r.getSourcePortStart()){\n                    throw new ResourceUnavailableException(\"One CIDR and one port only please.\",\n                            Network.class, network.getId());\n                } else {\n                    cidr = cidrList.get(0);\n                }\n            }\n            if (cidr == null || cidr.equalsIgnoreCase(\"0.0.0.0/0\")) {\n                cidr = \"\";\n            } else {\n                utils = new SubnetUtils(cidr);\n                if(!utils.getInfo().getNetworkAddress().equals(utils.getInfo().getAddress())){\n                    throw new ResourceUnavailableException(\"Invalid CIDR in Firewall rule.\",\n                            Network.class, network.getId());\n                }\n            }\n        }\n        updateBcfRouter(network);\n        return true;\n    }","id":33859,"modified_method":"@Override\n    public boolean applyFWRules(Network network,\n            List<? extends FirewallRule> rules)\n            throws ResourceUnavailableException {\n        SubnetUtils utils;\n        String cidr = null;\n        List<String> cidrList;\n        for(FirewallRule r: rules){\n            if(r.getState()==FirewallRule.State.Revoke){\n                continue;\n            }\n            cidrList = r.getSourceCidrList();\n            if(cidrList != null){\n                if (cidrList.size() > 1 || !r.getSourcePortEnd().equals(r.getSourcePortStart())) {\n                    throw new ResourceUnavailableException(\"One CIDR and one port only please.\",\n                            Network.class, network.getId());\n                } else {\n                    cidr = cidrList.get(0);\n                }\n            }\n            if (cidr == null || cidr.equalsIgnoreCase(\"0.0.0.0/0\")) {\n                cidr = \"\";\n            } else {\n                utils = new SubnetUtils(cidr);\n                if(!utils.getInfo().getNetworkAddress().equals(utils.getInfo().getAddress())){\n                    throw new ResourceUnavailableException(\"Invalid CIDR in Firewall rule.\",\n                            Network.class, network.getId());\n                }\n            }\n        }\n        updateBcfRouter(network);\n        return true;\n    }","commit_id":"d3a98ab0d00c787cb0fe2b53d532de65c873f4fb","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public boolean applyNetworkACLs(Network network,\n            List<? extends NetworkACLItem> rules)\n            throws ResourceUnavailableException {\n        SubnetUtils utils;\n        String cidr = null;\n        List<String> cidrList;\n        for(NetworkACLItem r: rules){\n            if(r.getState()==NetworkACLItem.State.Revoke){\n                continue;\n            }\n            cidrList = r.getSourceCidrList();\n            if(cidrList != null){\n                if(cidrList.size()>1 || r.getSourcePortEnd()!=r.getSourcePortStart()){\n                    throw new ResourceUnavailableException(\"One CIDR and one port only please.\",\n                            Network.class, network.getId());\n                } else {\n                    cidr = cidrList.get(0);\n                }\n            }\n            if (cidr == null || cidr.equalsIgnoreCase(\"0.0.0.0/0\")) {\n                cidr = \"\";\n            } else {\n                utils = new SubnetUtils(cidr);\n                if(!utils.getInfo().getNetworkAddress().equals(utils.getInfo().getAddress())){\n                    throw new ResourceUnavailableException(\"Invalid CIDR in Network ACL rule.\",\n                            Network.class, network.getId());\n                }\n            }\n        }\n        updateBcfRouter(network);\n        return true;\n    }","id":33860,"modified_method":"@Override\n    public boolean applyNetworkACLs(Network network,\n            List<? extends NetworkACLItem> rules)\n            throws ResourceUnavailableException {\n        SubnetUtils utils;\n        String cidr = null;\n        List<String> cidrList;\n        for(NetworkACLItem r: rules){\n            if(r.getState()==NetworkACLItem.State.Revoke){\n                continue;\n            }\n            cidrList = r.getSourceCidrList();\n            if(cidrList != null){\n                if (cidrList.size() > 1 || !r.getSourcePortEnd().equals(r.getSourcePortStart())) {\n                    throw new ResourceUnavailableException(\"One CIDR and one port only please.\",\n                            Network.class, network.getId());\n                } else {\n                    cidr = cidrList.get(0);\n                }\n            }\n            if (cidr == null || cidr.equalsIgnoreCase(\"0.0.0.0/0\")) {\n                cidr = \"\";\n            } else {\n                utils = new SubnetUtils(cidr);\n                if(!utils.getInfo().getNetworkAddress().equals(utils.getInfo().getAddress())){\n                    throw new ResourceUnavailableException(\"Invalid CIDR in Network ACL rule.\",\n                            Network.class, network.getId());\n                }\n            }\n        }\n        updateBcfRouter(network);\n        return true;\n    }","commit_id":"d3a98ab0d00c787cb0fe2b53d532de65c873f4fb","url":"https://github.com/apache/cloudstack"},{"original_method":"public List<RefactoringParticipant.Change<SNodeReference, SNodeReference>> getChanges(final SNodeReference initialState, final SRepository repository, final List<RefactoringParticipant.Option> selectedOptions, final SearchScope searchScope, final ProgressMonitor progressMonitor, final Iterable<RefactoringParticipant.ParticipantState> parents) {\n    if (!((isApplicable(initialState, repository))) || !(ListSequence.fromList(selectedOptions).contains(OPTION))) {\n      return ListSequence.fromList(new ArrayList<RefactoringParticipant.Change<SNodeReference, SNodeReference>>());\n    } else {\n      final SNode sourceConcept = SNodeOperations.cast(initialState.resolve(repository), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\"));\n      Language sourceLanguage = ((Language) SNodeOperations.getModel(sourceConcept).getModule());\n\n      Map<LanguageAspect, List<SNode>> aspectsMap = MoveConceptUtil.getAspectNodes(sourceLanguage, Sequence.<SNode>singleton(sourceConcept));\n\n      int participantSize = Sequence.fromIterable(new ExtensionPoint<MoveNodeRefactoringParticipant<?, ?>>(\"jetbrains.mps.ide.platform.MoveNodeParticipantEP\").getObjects()).count();\n      Iterable<SNode> aspects = Sequence.fromIterable(MapSequence.fromMap(aspectsMap).values()).translate(new ITranslator2<List<SNode>, SNode>() {\n        public Iterable<SNode> translate(List<SNode> x) {\n          return x;\n        }\n      });\n      progressMonitor.start(\"\", participantSize * Sequence.fromIterable(aspects).foldLeft(0, new ILeftCombinator<SNode, Integer>() {\n        public Integer combine(Integer s, SNode it) {\n          return s + ListSequence.fromList(SNodeOperations.getNodeDescendants(it, null, true, new SAbstractConcept[]{})).count();\n        }\n      }));\n\n      return MapSequence.fromMap(aspectsMap).translate(new ITranslator2<IMapping<LanguageAspect, List<SNode>>, RefactoringParticipant.Change<SNodeReference, SNodeReference>>() {\n        public Iterable<RefactoringParticipant.Change<SNodeReference, SNodeReference>> translate(final IMapping<LanguageAspect, List<SNode>> mapping) {\n          return ListSequence.fromList(mapping.value()).select(new ISelector<SNode, RefactoringParticipant.Change<SNodeReference, SNodeReference>>() {\n            public RefactoringParticipant.Change<SNodeReference, SNodeReference> select(final SNode aspect) {\n\n              List<SNode> descendants = SNodeOperations.getNodeDescendants(aspect, null, true, new SAbstractConcept[]{});\n\n              final List<Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>>> childparticipantStates = ListSequence.fromList(descendants).translate(new ITranslator2<SNode, Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>>>() {\n                public Iterable<Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>>> translate(final SNode node) {\n                  return Sequence.fromIterable(new ExtensionPoint<MoveNodeRefactoringParticipant<?, ?>>(\"jetbrains.mps.ide.platform.MoveNodeParticipantEP\").getObjects()).select(new ISelector<MoveNodeRefactoringParticipant<?, ?>, Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>>>() {\n                    public Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>> select(MoveNodeRefactoringParticipant<?, ?> participant) {\n                      RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode> participantState = RecursiveParticipant.RecursiveParticipantState.create(participant, ListSequence.fromListAndArray(new ArrayList<SNode>(), node), parents);\n                      participantState.findChanges(repository, selectedOptions, searchScope, progressMonitor.subTask(1));\n                      return MultiTuple.<SNode,RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>>from(node, participantState);\n                    }\n                  });\n                }\n              }).toListSequence();\n\n              final SearchResults results = new SearchResults();\n              results.addAll(new SearchResults(SetSequence.fromSetAndArray(new HashSet<SNode>(), sourceConcept), ListSequence.fromListAndArray(new ArrayList<SearchResult<SNode>>(), new SearchResult<SNode>(aspect, \"concept aspect\"))));\n              ListSequence.fromList(childparticipantStates).select(new ISelector<Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>>, List<? extends RefactoringParticipant.Change<?, ?>>>() {\n                public List<? extends RefactoringParticipant.Change<?, ?>> select(Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>> it) {\n                  return (List<? extends RefactoringParticipant.Change<?, ?>>) ListSequence.fromList(it._1().getChanges()).first();\n                }\n              }).visitAll(new IVisitor<List<? extends RefactoringParticipant.Change<?, ?>>>() {\n                public void visit(List<? extends RefactoringParticipant.Change<?, ?>> it) {\n                  ListSequence.fromList(it).select(new ISelector<RefactoringParticipant.Change<?, ?>, SearchResults>() {\n                    public SearchResults select(RefactoringParticipant.Change<?, ?> it1) {\n                      return it1.getSearchResults();\n                    }\n                  }).visitAll(new IVisitor<SearchResults>() {\n                    public void visit(SearchResults it1) {\n                      results.addAll(it1);\n                    }\n                  });\n                }\n              });\n\n\n              // todo: do not keep nodes but only node references \n\n              RefactoringParticipant.Change<SNodeReference, SNodeReference> change = new RefactoringParticipant.Change<SNodeReference, SNodeReference>() {\n                public SearchResults getSearchResults() {\n                  return results;\n                }\n                public boolean needsToPreserveOldNode() {\n                  return ListSequence.fromList(childparticipantStates).select(new ISelector<Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>>, List<? extends RefactoringParticipant.Change<?, ?>>>() {\n                    public List<? extends RefactoringParticipant.Change<?, ?>> select(Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>> it) {\n                      return (List<? extends RefactoringParticipant.Change<?, ?>>) ListSequence.fromList(it._1().getChanges()).first();\n                    }\n                  }).any(new IWhereFilter<List<? extends RefactoringParticipant.Change<?, ?>>>() {\n                    public boolean accept(List<? extends RefactoringParticipant.Change<?, ?>> it) {\n                      return ListSequence.fromList(it).any(new IWhereFilter<RefactoringParticipant.Change<?, ?>>() {\n                        public boolean accept(RefactoringParticipant.Change<?, ?> it1) {\n                          return it1.needsToPreserveOldNode();\n                        }\n                      });\n                    }\n                  });\n                }\n                public void confirm(SNodeReference finalState, final SRepository repository, final RefactoringSession refactoringSession) {\n                  SNode targetConcept = SNodeOperations.cast(finalState.resolve(repository), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\"));\n                  Language targetLanguage = ((Language) SNodeOperations.getModel(targetConcept).getModule());\n                  NodeLocation.NodeLocationRootWithAspectModelCreation newLocation = new NodeLocation.NodeLocationRootWithAspectModelCreation(targetLanguage, mapping.key());\n\n                  List<SNode> copied = MoveNodesDefault.CopyMapObject.getCopyMap(refactoringSession).copy(ListSequence.fromListAndArray(new ArrayList<SNode>(), aspect), ListSequence.fromListAndArray(new ArrayList<Boolean>(), needsToPreserveOldNode() || MoveNodesDefault.CopyMapObject.getCopyMap(refactoringSession).whetherKeepNode(sourceConcept)));\n                  final Map<SNode, SNode> copyMap = MoveNodesDefault.CopyMapObject.getCopyMap(refactoringSession).getCopyMap();\n                  newLocation.insertNode(repository, ListSequence.fromList(copied).first());\n                  ListSequence.fromList(childparticipantStates).visitAll(new IVisitor<Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>>>() {\n                    public void visit(Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>> pis) {\n                      pis._1().doRefactor(ListSequence.fromListAndArray(new ArrayList<SNode>(), MapSequence.fromMap(copyMap).get(pis._0())), repository, refactoringSession);\n                    }\n                  });\n                }\n              };\n              return (RefactoringParticipant.Change<SNodeReference, SNodeReference>) change;\n            }\n          });\n        }\n      }).toListSequence();\n    }\n  }","id":33861,"modified_method":"public List<RefactoringParticipant.Change<SNodeReference, SNodeReference>> getChanges(final SNodeReference initialState, final SRepository repository, final List<RefactoringParticipant.Option> selectedOptions, final SearchScope searchScope, final ProgressMonitor progressMonitor, final Iterable<RefactoringParticipant.ParticipantState> parents) {\n    if (!((isApplicable(initialState, repository))) || !(ListSequence.fromList(selectedOptions).contains(OPTION))) {\n      return ListSequence.fromList(new ArrayList<RefactoringParticipant.Change<SNodeReference, SNodeReference>>());\n    } else {\n      final SNode sourceConcept = SNodeOperations.cast(initialState.resolve(repository), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\"));\n      Language sourceLanguage = ((Language) SNodeOperations.getModel(sourceConcept).getModule());\n\n      Map<LanguageAspect, List<SNode>> aspectsMap = MoveConceptUtil.getAspectNodes(sourceLanguage, Sequence.<SNode>singleton(sourceConcept));\n\n      int participantSize = Sequence.fromIterable(new ExtensionPoint<MoveNodeRefactoringParticipant<?, ?>>(\"jetbrains.mps.ide.platform.MoveNodeParticipantEP\").getObjects()).count();\n      Iterable<SNode> aspects = Sequence.fromIterable(MapSequence.fromMap(aspectsMap).values()).translate(new ITranslator2<List<SNode>, SNode>() {\n        public Iterable<SNode> translate(List<SNode> x) {\n          return x;\n        }\n      });\n      progressMonitor.start(\"\", participantSize * Sequence.fromIterable(aspects).foldLeft(0, new ILeftCombinator<SNode, Integer>() {\n        public Integer combine(Integer s, SNode it) {\n          return s + ListSequence.fromList(SNodeOperations.getNodeDescendants(it, null, true, new SAbstractConcept[]{})).count();\n        }\n      }));\n\n      return MapSequence.fromMap(aspectsMap).translate(new ITranslator2<IMapping<LanguageAspect, List<SNode>>, RefactoringParticipant.Change<SNodeReference, SNodeReference>>() {\n        public Iterable<RefactoringParticipant.Change<SNodeReference, SNodeReference>> translate(final IMapping<LanguageAspect, List<SNode>> mapping) {\n          return ListSequence.fromList(mapping.value()).select(new ISelector<SNode, RefactoringParticipant.Change<SNodeReference, SNodeReference>>() {\n            public RefactoringParticipant.Change<SNodeReference, SNodeReference> select(final SNode aspect) {\n\n              List<SNode> descendants = SNodeOperations.getNodeDescendants(aspect, null, true, new SAbstractConcept[]{});\n\n              final List<Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>>> childparticipantStates = ListSequence.fromList(descendants).translate(new ITranslator2<SNode, Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>>>() {\n                public Iterable<Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>>> translate(final SNode node) {\n                  return Sequence.fromIterable(new ExtensionPoint<MoveNodeRefactoringParticipant<?, ?>>(\"jetbrains.mps.ide.platform.MoveNodeParticipantEP\").getObjects()).select(new ISelector<MoveNodeRefactoringParticipant<?, ?>, Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>>>() {\n                    public Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>> select(MoveNodeRefactoringParticipant<?, ?> participant) {\n                      RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode> participantState = RecursiveParticipant.RecursiveParticipantState.create(participant, ListSequence.fromListAndArray(new ArrayList<SNode>(), node), parents);\n                      participantState.findChanges(repository, selectedOptions, searchScope, progressMonitor.subTask(1));\n                      return MultiTuple.<SNode,RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>>from(node, participantState);\n                    }\n                  });\n                }\n              }).toListSequence();\n\n              final SearchResults results = new SearchResults();\n              results.addAll(new SearchResults(SetSequence.fromSetAndArray(new HashSet<SNode>(), sourceConcept), ListSequence.fromListAndArray(new ArrayList<SearchResult<SNode>>(), new SearchResult<SNode>(aspect, \"concept aspect\"))));\n              ListSequence.fromList(childparticipantStates).select(new ISelector<Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>>, List<? extends RefactoringParticipant.Change<?, ?>>>() {\n                public List<? extends RefactoringParticipant.Change<?, ?>> select(Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>> it) {\n                  return (List<? extends RefactoringParticipant.Change<?, ?>>) ListSequence.fromList(it._1().getChanges()).first();\n                }\n              }).visitAll(new IVisitor<List<? extends RefactoringParticipant.Change<?, ?>>>() {\n                public void visit(List<? extends RefactoringParticipant.Change<?, ?>> it) {\n                  ListSequence.fromList(it).select(new ISelector<RefactoringParticipant.Change<?, ?>, SearchResults>() {\n                    public SearchResults select(RefactoringParticipant.Change<?, ?> it1) {\n                      return it1.getSearchResults();\n                    }\n                  }).visitAll(new IVisitor<SearchResults>() {\n                    public void visit(SearchResults it1) {\n                      results.addAll(it1);\n                    }\n                  });\n                }\n              });\n\n\n              // todo: do not keep nodes but only node references \n\n              RefactoringParticipant.Change<SNodeReference, SNodeReference> change = new RefactoringParticipant.Change<SNodeReference, SNodeReference>() {\n                public SearchResults getSearchResults() {\n                  return results;\n                }\n                public boolean needsToPreserveOldNode() {\n                  return ListSequence.fromList(childparticipantStates).select(new ISelector<Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>>, List<? extends RefactoringParticipant.Change<?, ?>>>() {\n                    public List<? extends RefactoringParticipant.Change<?, ?>> select(Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>> it) {\n                      return (List<? extends RefactoringParticipant.Change<?, ?>>) ListSequence.fromList(it._1().getChanges()).first();\n                    }\n                  }).any(new IWhereFilter<List<? extends RefactoringParticipant.Change<?, ?>>>() {\n                    public boolean accept(List<? extends RefactoringParticipant.Change<?, ?>> it) {\n                      return ListSequence.fromList(it).any(new IWhereFilter<RefactoringParticipant.Change<?, ?>>() {\n                        public boolean accept(RefactoringParticipant.Change<?, ?> it1) {\n                          return it1.needsToPreserveOldNode();\n                        }\n                      });\n                    }\n                  });\n                }\n                public void confirm(SNodeReference finalState, final SRepository repository, final RefactoringSession refactoringSession) {\n                  SNode targetConcept = SNodeOperations.cast(finalState.resolve(repository), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\"));\n                  Language targetLanguage = ((Language) SNodeOperations.getModel(targetConcept).getModule());\n                  NodeLocation.NodeLocationRootWithAspectModelCreation newLocation = new NodeLocation.NodeLocationRootWithAspectModelCreation(targetLanguage, mapping.key());\n\n                  List<SNode> copied = MoveNodesDefault.CopyMapObject.getCopyMap(refactoringSession).copy(ListSequence.fromListAndArray(new ArrayList<SNode>(), aspect));\n                  if (!(needsToPreserveOldNode()) && SNodeOperations.getModel(sourceConcept) == null) {\n                    SNodeOperations.detachNode(aspect);\n                  }\n\n                  final Map<SNode, SNode> copyMap = MoveNodesDefault.CopyMapObject.getCopyMap(refactoringSession).getCopyMap();\n                  newLocation.insertNode(repository, ListSequence.fromList(copied).first());\n                  ListSequence.fromList(childparticipantStates).visitAll(new IVisitor<Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>>>() {\n                    public void visit(Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>> pis) {\n                      pis._1().doRefactor(ListSequence.fromListAndArray(new ArrayList<SNode>(), MapSequence.fromMap(copyMap).get(pis._0())), repository, refactoringSession);\n                    }\n                  });\n                }\n              };\n              return (RefactoringParticipant.Change<SNodeReference, SNodeReference>) change;\n            }\n          });\n        }\n      }).toListSequence();\n    }\n  }","commit_id":"73e38dc0d6a171d29a92581f5670d802740087a9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public MoveNodesRefactoring get() {\n      return new MoveFeatureUp(\"Move Link Up\", \"link\", new _FunctionTypes._return_P1_E0<Boolean, SNode>() {\n        public Boolean invoke(SNode conceptFeature) {\n          return SNodeOperations.hasRole(conceptFeature, MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6bL, \"linkDeclaration\")) && SPropertyOperations.hasValue(SNodeOperations.cast(conceptFeature, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, \"jetbrains.mps.lang.structure.structure.LinkDeclaration\")), MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf980556927L, \"metaClass\"), \"reference\", \"reference\");\n        }\n      });\n    }","id":33862,"modified_method":"public MoveNodesRefactoring get() {\n      return new MoveFeatureUp(\"Move Link Up\", \"link\", new _FunctionTypes._return_P1_E0<Boolean, SNode>() {\n        public Boolean invoke(SNode conceptFeature) {\n          return SNodeOperations.hasRole(conceptFeature, MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6bL, \"linkDeclaration\")) && SPropertyOperations.hasValue(SNodeOperations.cast(conceptFeature, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, \"jetbrains.mps.lang.structure.structure.LinkDeclaration\")), MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf980556927L, \"metaClass\"), \"reference\", \"reference\");\n        }\n      }, new _FunctionTypes._return_P2_E0<SNode, SNode, SNode>() {\n        public SNode invoke(final SNode node, SNode concept) {\n          return ListSequence.fromList(SLinkOperations.getChildren(concept, MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6bL, \"linkDeclaration\"))).where(new IWhereFilter<SNode>() {\n            public boolean accept(SNode it) {\n              return SPropertyOperations.hasValue(it, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf980556927L, \"metaClass\"), \"reference\", \"reference\") && eq_g4dz8g_a0a0a0a0a0a0a0a0a3a0a0b01(SPropertyOperations.getString(it, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98052f333L, \"role\")), SPropertyOperations.getString(SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, \"jetbrains.mps.lang.structure.structure.LinkDeclaration\")), MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98052f333L, \"role\")));\n            }\n          }).first();\n        }\n      });\n    }","commit_id":"73e38dc0d6a171d29a92581f5670d802740087a9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void apply(final MPSProject project, List<SNode> nodesToMove) {\n    final String featureKind = this.getKind();\n\n    if (ListSequence.fromList(nodesToMove).count() > 1) {\n      Messages.showErrorDialog(project.getProject(), \"Moving multiple concept elements is not supported.\\n\" + \"Please, select single \" + featureKind + \".\", \"Select single \" + featureKind + \".\");\n      return;\n    }\n\n    SNode feature = SNodeOperations.cast(ListSequence.fromList(nodesToMove).first(), MetaAdapterFactory.getInterfaceConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x11d2ea63881L, \"jetbrains.mps.lang.structure.structure.IStructureDeprecatable\"));\n    final SNode targetConcept = MoveUpDialog.getConcept(project, feature, featureKind);\n    if (targetConcept == null) {\n      return;\n    }\n\n    MoveNodesDefault.doMove(project, MapSequence.<SNodeReference, NodeLocation>fromMapAndKeysArray(new HashMap<SNodeReference, NodeLocation>(), feature.getReference()).withValues(new NodeLocation.NodeLocationChild(targetConcept, feature.getContainmentLink())), null);\n  }","id":33863,"modified_method":"public void apply(final MPSProject project, List<SNode> nodesToMove) {\n    final String featureKind = this.myKind;\n\n    if (ListSequence.fromList(nodesToMove).count() > 1) {\n      Messages.showErrorDialog(project.getProject(), \"Moving multiple concept elements is not supported.\\n\" + \"Please, select single \" + featureKind + \".\", \"Select single \" + featureKind + \".\");\n      return;\n    }\n\n    SNode feature = SNodeOperations.cast(ListSequence.fromList(nodesToMove).first(), MetaAdapterFactory.getInterfaceConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x11d2ea63881L, \"jetbrains.mps.lang.structure.structure.IStructureDeprecatable\"));\n    final SNode targetConcept = MoveUpDialog.getConcept(project, feature, featureKind);\n    if (targetConcept == null) {\n      return;\n    }\n\n    boolean merge = false;\n\n    SNode mergeTarget = myNeedToMerge.invoke(feature, targetConcept);\n    if (mergeTarget != null) {\n      int wantToMerge;\n      wantToMerge = Messages.showYesNoCancelDialog(project.getProject(), \"Target concept already has \" + myKind + \" with the same name. Do you want to merge?\", \"Do you want to merge?\", null);\n      if (wantToMerge == Messages.YES) {\n        merge = true;\n      } else if (wantToMerge == Messages.NO) {\n        merge = false;\n      } else {\n        return;\n      }\n    }\n\n    if (merge) {\n      MoveNodesDefault.doMove(project, MapSequence.<SNodeReference, MoveNodesDefault.NodeProcessor>fromMapAndKeysArray(new HashMap<SNodeReference, MoveNodesDefault.NodeProcessor>(), feature.getReference()).withValues(new MoveNodesDefault.MergingNodeProcessor(mergeTarget.getReference(), project)), null);\n    } else {\n      MoveNodesDefault.doMove(project, MapSequence.<SNodeReference, MoveNodesDefault.NodeProcessor>fromMapAndKeysArray(new HashMap<SNodeReference, MoveNodesDefault.NodeProcessor>(), feature.getReference()).withValues(new MoveNodesDefault.CopyingNodeProcessor(new NodeLocation.NodeLocationChild(targetConcept, feature.getContainmentLink()), project)), null);\n    }\n  }","commit_id":"73e38dc0d6a171d29a92581f5670d802740087a9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public MoveNodesRefactoring get() {\n      return new MoveFeatureUp(\"Move Property Up\", \"property\", new _FunctionTypes._return_P1_E0<Boolean, SNode>() {\n        public Boolean invoke(SNode conceptFeature) {\n          return SNodeOperations.hasRole(conceptFeature, MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6cL, \"propertyDeclaration\"));\n        }\n      });\n    }","id":33864,"modified_method":"public MoveNodesRefactoring get() {\n      return new MoveFeatureUp(\"Move Property Up\", \"property\", new _FunctionTypes._return_P1_E0<Boolean, SNode>() {\n        public Boolean invoke(SNode conceptFeature) {\n          return SNodeOperations.hasRole(conceptFeature, MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6cL, \"propertyDeclaration\"));\n        }\n      }, new _FunctionTypes._return_P2_E0<SNode, SNode, SNode>() {\n        public SNode invoke(final SNode node, SNode concept) {\n          return ListSequence.fromList(SLinkOperations.getChildren(concept, MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6cL, \"propertyDeclaration\"))).where(new IWhereFilter<SNode>() {\n            public boolean accept(SNode it) {\n              return eq_g4dz8g_a0a0a0a0a0a0a0a0d0a0a1i(SPropertyOperations.getString(it, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\")), SPropertyOperations.getString(SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086bL, \"jetbrains.mps.lang.structure.structure.PropertyDeclaration\")), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\")));\n            }\n          }).first();\n        }\n      });\n    }","commit_id":"73e38dc0d6a171d29a92581f5670d802740087a9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public MoveNodesRefactoring get() {\n      return new MoveFeatureUp(\"Move Link Up\", \"link\", new _FunctionTypes._return_P1_E0<Boolean, SNode>() {\n        public Boolean invoke(SNode conceptFeature) {\n          return SNodeOperations.hasRole(conceptFeature, MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6bL, \"linkDeclaration\")) && SPropertyOperations.hasValue(SNodeOperations.cast(conceptFeature, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, \"jetbrains.mps.lang.structure.structure.LinkDeclaration\")), MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf980556927L, \"metaClass\"), \"aggregation\", \"reference\");\n        }\n      });\n    }","id":33865,"modified_method":"public MoveNodesRefactoring get() {\n      return new MoveFeatureUp(\"Move Link Up\", \"link\", new _FunctionTypes._return_P1_E0<Boolean, SNode>() {\n        public Boolean invoke(SNode conceptFeature) {\n          return SNodeOperations.hasRole(conceptFeature, MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6bL, \"linkDeclaration\")) && SPropertyOperations.hasValue(SNodeOperations.cast(conceptFeature, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, \"jetbrains.mps.lang.structure.structure.LinkDeclaration\")), MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf980556927L, \"metaClass\"), \"aggregation\", \"reference\");\n        }\n      }, new _FunctionTypes._return_P2_E0<SNode, SNode, SNode>() {\n        public SNode invoke(final SNode node, SNode concept) {\n          return ListSequence.fromList(SLinkOperations.getChildren(concept, MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6bL, \"linkDeclaration\"))).where(new IWhereFilter<SNode>() {\n            public boolean accept(SNode it) {\n              return SPropertyOperations.hasValue(it, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf980556927L, \"metaClass\"), \"aggregation\", \"reference\") && eq_g4dz8g_a0a0a0a0a0a0a0a0a3a0a0b9(SPropertyOperations.getString(it, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98052f333L, \"role\")), SPropertyOperations.getString(SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, \"jetbrains.mps.lang.structure.structure.LinkDeclaration\")), MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98052f333L, \"role\")));\n            }\n          }).first();\n        }\n      });\n    }","commit_id":"73e38dc0d6a171d29a92581f5670d802740087a9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public MoveFeatureUp(String name, String kind, _FunctionTypes._return_P1_E0<? extends Boolean, ? super SNode> applicableToConceptFeature) {\n    myName = name;\n    myKind = kind;\n    myApplicableToConceptFeature = applicableToConceptFeature;\n  }","id":33866,"modified_method":"public MoveFeatureUp(String name, String kind, _FunctionTypes._return_P1_E0<? extends Boolean, ? super SNode> applicableToConceptFeature, _FunctionTypes._return_P2_E0<? extends SNode, ? super SNode, ? super SNode> needToMerge) {\n    myName = name;\n    myKind = kind;\n    myApplicableToConceptFeature = applicableToConceptFeature;\n    myNeedToMerge = needToMerge;\n  }","commit_id":"73e38dc0d6a171d29a92581f5670d802740087a9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void apply(final MPSProject project, final List<SNode> nodesToMove) {\n\n    final Wrappers._T<SModel> currentModel = new Wrappers._T<SModel>();\n    final Wrappers._T<SContainmentLink> role = new Wrappers._T<SContainmentLink>();\n    project.getRepository().getModelAccess().runReadAction(new Runnable() {\n      public void run() {\n        currentModel.value = SNodeOperations.getModel(ListSequence.fromList(nodesToMove).first());\n        role.value = ListSequence.fromList(nodesToMove).first().getContainmentLink();\n      }\n    });\n    final SContainmentLink finalRole = role.value;\n    final NodeLocation newLocation = MoveNodesDialog.getSelectedObject(project.getProject(), currentModel.value, new MoveNodesDialog.ModelFilter(\"Choose Node or Model\") {\n      @Override\n      public boolean check(final NodeLocation selectedObject, SModel model) {\n        if (selectedObject == null) {\n          return false;\n        }\n        if (selectedObject instanceof NodeLocation.NodeLocationChild) {\n          if (finalRole == null) {\n            return false;\n          }\n          final Wrappers._T<Collection<SContainmentLink>> containmentLinks = new Wrappers._T<Collection<SContainmentLink>>();\n          project.getRepository().getModelAccess().runReadAction(new Runnable() {\n            public void run() {\n              containmentLinks.value = ((NodeLocation.NodeLocationChild) selectedObject).getNode().resolve(project.getRepository()).getConcept().getContainmentLinks();\n            }\n          });\n          return CollectionSequence.fromCollection(containmentLinks.value).contains(finalRole);\n        } else {\n          return true;\n        }\n      }\n    });\n    if (newLocation instanceof NodeLocation.NodeLocationChild) {\n      ((NodeLocation.NodeLocationChild) newLocation).setRole(role.value);\n    }\n    if (newLocation == null) {\n      return;\n    }\n    Map<SNodeReference, NodeLocation> moveMap = MapSequence.fromMap(new HashMap<SNodeReference, NodeLocation>());\n    for (SNode node : ListSequence.fromList(nodesToMove)) {\n      MapSequence.fromMap(moveMap).put(node.getReference(), newLocation);\n    }\n    doMove(project, moveMap, null);\n  }","id":33867,"modified_method":"public void apply(final MPSProject project, final List<SNode> nodesToMove) {\n\n    final Wrappers._T<SModel> currentModel = new Wrappers._T<SModel>();\n    final Wrappers._T<SContainmentLink> role = new Wrappers._T<SContainmentLink>();\n    project.getRepository().getModelAccess().runReadAction(new Runnable() {\n      public void run() {\n        currentModel.value = SNodeOperations.getModel(ListSequence.fromList(nodesToMove).first());\n        role.value = ListSequence.fromList(nodesToMove).first().getContainmentLink();\n      }\n    });\n    final SContainmentLink finalRole = role.value;\n    final NodeLocation newLocation = MoveNodesDialog.getSelectedObject(project.getProject(), currentModel.value, new MoveNodesDialog.ModelFilter(\"Choose Node or Model\") {\n      @Override\n      public boolean check(final NodeLocation selectedObject, SModel model) {\n        if (selectedObject == null) {\n          return false;\n        }\n        if (selectedObject instanceof NodeLocation.NodeLocationChild) {\n          if (finalRole == null) {\n            return false;\n          }\n          final Wrappers._T<Collection<SContainmentLink>> containmentLinks = new Wrappers._T<Collection<SContainmentLink>>();\n          project.getRepository().getModelAccess().runReadAction(new Runnable() {\n            public void run() {\n              containmentLinks.value = ((NodeLocation.NodeLocationChild) selectedObject).getNode().resolve(project.getRepository()).getConcept().getContainmentLinks();\n            }\n          });\n          return CollectionSequence.fromCollection(containmentLinks.value).contains(finalRole);\n        } else {\n          return true;\n        }\n      }\n    });\n    if (newLocation instanceof NodeLocation.NodeLocationChild) {\n      ((NodeLocation.NodeLocationChild) newLocation).setRole(role.value);\n    }\n    if (newLocation == null) {\n      return;\n    }\n    Map<SNodeReference, MoveNodesDefault.NodeProcessor> moveMap = MapSequence.fromMap(new HashMap<SNodeReference, MoveNodesDefault.NodeProcessor>());\n    MoveNodesDefault.NodeProcessor processor = new MoveNodesDefault.CopyingNodeProcessor(newLocation, project);\n    for (SNode node : ListSequence.fromList(nodesToMove)) {\n      MapSequence.fromMap(moveMap).put(node.getReference(), processor);\n    }\n    doMove(project, moveMap, null);\n  }","commit_id":"73e38dc0d6a171d29a92581f5670d802740087a9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void doMove(final MPSProject project, final List<ToMoveItem> toMove, _FunctionTypes._void_P1_E0<? super RefactoringSession> callBack) {\n    Map<SNodeReference, NodeLocation> moveMap = MapSequence.fromMap(new HashMap<SNodeReference, NodeLocation>());\n    for (ToMoveItem nodesToMove : ListSequence.fromList(toMove)) {\n      for (SNode node : ListSequence.fromList(nodesToMove.nodes())) {\n        MapSequence.fromMap(moveMap).put(node.getReference(), nodesToMove.newLocation());\n      }\n    }\n    doMove(project, moveMap, callBack);\n  }","id":33868,"modified_method":"public static void doMove(final MPSProject project, final List<ToMoveItem> toMove, _FunctionTypes._void_P1_E0<? super RefactoringSession> callBack) {\n    Map<SNodeReference, MoveNodesDefault.NodeProcessor> moveMap = MapSequence.fromMap(new HashMap<SNodeReference, MoveNodesDefault.NodeProcessor>());\n    for (ToMoveItem nodesToMove : ListSequence.fromList(toMove)) {\n      MoveNodesDefault.NodeProcessor processor = new MoveNodesDefault.CopyingNodeProcessor(nodesToMove.newLocation(), project);\n      for (SNode node : ListSequence.fromList(nodesToMove.nodes())) {\n        MapSequence.fromMap(moveMap).put(node.getReference(), processor);\n      }\n    }\n    doMove(project, moveMap, callBack);\n  }","commit_id":"73e38dc0d6a171d29a92581f5670d802740087a9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void doMove(final MPSProject project, final Map<SNodeReference, NodeLocation> moveMap, final _FunctionTypes._void_P1_E0<? super RefactoringSession> initRefactoringSession) {\n\n    project.getRepository().getModelAccess().runReadAction(new Runnable() {\n      public void run() {\n        for (IMapping<SNodeReference, NodeLocation> moving : MapSequence.fromMap(moveMap)) {\n          SNode node = resolveNode(moving.key(), project);\n          if (!(moving.value().canInsert(project.getRepository(), node))) {\n            throw new IllegalArgumentException();\n          }\n        }\n      }\n    });\n\n    final Map<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, SNode, SNode>> changes = MapSequence.fromMap(new HashMap<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, SNode, SNode>>());\n    final Map<SNodeReference, SNodeReference> nodeRoots = MapSequence.fromMap(new HashMap<SNodeReference, SNodeReference>());\n    final Wrappers._T<List<SNodeReference>> allNodes = new Wrappers._T<List<SNodeReference>>();\n    final Wrappers._T<List<RefactoringParticipant.Option>> options = new Wrappers._T<List<RefactoringParticipant.Option>>();\n    project.getRepository().getModelAccess().runReadAction(new Runnable() {\n      public void run() {\n        for (SNodeReference nodeToMove : SetSequence.fromSet(MapSequence.fromMap(moveMap).keySet())) {\n          for (SNodeReference descendant : ListSequence.fromList(SNodeOperations.getNodeDescendants(resolveNode(nodeToMove, project), null, true, new SAbstractConcept[]{})).select(new ISelector<SNode, SNodeReference>() {\n            public SNodeReference select(SNode it) {\n              return it.getReference();\n            }\n          })) {\n            MapSequence.fromMap(nodeRoots).put(descendant, nodeToMove);\n          }\n        }\n        allNodes.value = SetSequence.fromSet(MapSequence.fromMap(nodeRoots).keySet()).toListSequence();\n        for (MoveNodeRefactoringParticipant<?, ?> participant : Sequence.fromIterable(new ExtensionPoint<MoveNodeRefactoringParticipant<?, ?>>(\"jetbrains.mps.ide.platform.MoveNodeParticipantEP\").getObjects()).toListSequence()) {\n          RefactoringParticipant.ParticipantState<?, ?, SNode, SNode> participantState;\n          MapSequence.fromMap(changes).put(participant, RefactoringParticipant.ParticipantState.create(participant, ListSequence.fromList(allNodes.value).select(new ISelector<SNodeReference, SNode>() {\n            public SNode select(SNodeReference it) {\n              return resolveNode(it, project);\n            }\n          }).toListSequence()));\n        }\n        options.value = MapSequence.fromMap(changes).translate(new ITranslator2<IMapping<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, SNode, SNode>>, RefactoringParticipant.Option>() {\n          public Iterable<RefactoringParticipant.Option> translate(IMapping<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, SNode, SNode>> it) {\n            return it.value().getAvaliableOptions(project.getRepository());\n          }\n        }).distinct().sort(new ISelector<RefactoringParticipant.Option, String>() {\n          public String select(RefactoringParticipant.Option it) {\n            return it.getDescription();\n          }\n        }, true).toListSequence();\n      }\n    });\n\n    List<Integer> selectedOptionIndices;\n    if (ListSequence.fromList(options.value).isNotEmpty()) {\n      selectedOptionIndices = SelectOptionsDialog.selectOptions(ProjectHelper.toIdeaProject(project), ListSequence.fromList(options.value).select(new ISelector<RefactoringParticipant.Option, String>() {\n        public String select(RefactoringParticipant.Option it) {\n          return it.getDescription();\n        }\n      }).toListSequence(), \"Refactoring Options\");\n    } else {\n      selectedOptionIndices = ListSequence.fromList(new ArrayList<Integer>());\n    }\n    if (selectedOptionIndices == null) {\n      return;\n    }\n    final List<RefactoringParticipant.Option> selectedOptions = ListSequence.fromList(selectedOptionIndices).select(new ISelector<Integer, RefactoringParticipant.Option>() {\n      public RefactoringParticipant.Option select(Integer i) {\n        return ListSequence.fromList(options.value).getElement(i);\n      }\n    }).toListSequence();\n\n    final Wrappers._boolean cancelled = new Wrappers._boolean(false);\n    ProgressManager.getInstance().run(new Task.Modal(project.getProject(), \"Refactoring\", true) {\n      public void run(@NotNull ProgressIndicator progressIndicator) {\n        final ProgressMonitorAdapter progressMonitor = new ProgressMonitorAdapter(progressIndicator);\n        project.getRepository().getModelAccess().runReadAction(new Runnable() {\n          public void run() {\n            int steps = MapSequence.fromMap(changes).count();\n            progressMonitor.start(\"Searching for usages\", steps);\n            for (IMapping<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, SNode, SNode>> participantState : MapSequence.fromMap(changes)) {\n              participantState.value().findChanges(project.getRepository(), selectedOptions, project.getScope(), progressMonitor.subTask(1, SubProgressKind.AS_COMMENT));\n              if (progressMonitor.isCanceled()) {\n                cancelled.value = true;\n                break;\n              }\n            }\n            progressMonitor.done();\n          }\n        });\n      }\n    });\n\n    if (cancelled.value) {\n      return;\n    }\n\n    SearchResults searchResults = new SearchResults();\n    final Map<SNodeReference, Boolean> shouldKeep = MapSequence.fromMap(new HashMap<SNodeReference, Boolean>());\n\n    for (SNodeReference node : SetSequence.fromSet(MapSequence.fromMap(moveMap).keySet())) {\n      MapSequence.fromMap(shouldKeep).put(node, false);\n    }\n    for (IMapping<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, SNode, SNode>> participantState : MapSequence.fromMap(changes)) {\n      List<? extends List<? extends RefactoringParticipant.Change<?, ?>>> nodesChanges = participantState.value().getChanges();\n      for (int i = 0; i < ListSequence.fromList(allNodes.value).count(); i++) {\n        for (RefactoringParticipant.Change<?, ?> change : ListSequence.fromList(ListSequence.fromList(nodesChanges).getElement(i))) {\n          MapSequence.fromMap(shouldKeep).putValue(MapSequence.fromMap(nodeRoots).get(ListSequence.fromList(allNodes.value).getElement(i)), MapSequence.fromMap(shouldKeep).get(MapSequence.fromMap(nodeRoots).get(ListSequence.fromList(allNodes.value).getElement(i))) || (change.needsToPreserveOldNode()));\n          searchResults.addAll(change.getSearchResults());\n        }\n      }\n    }\n\n    RefactoringAccessEx.getInstance().showRefactoringView(project.getProject(), new RefactoringViewAction() {\n      public void performAction(RefactoringViewItem refactoringViewItem) {\n        project.getRepository().getModelAccess().executeCommand(new Runnable() {\n          public void run() {\n            RefactoringSessionImpl refactoringSession = new RefactoringSessionImpl();\n            if (initRefactoringSession != null) {\n              initRefactoringSession.invoke(refactoringSession);\n            }\n\n\n            final Map<SNode, SNode> copyMap = MoveNodesDefault.CopyMapObject.getCopyMap(refactoringSession).getCopyMap();\n            final Map<SNodeReference, SNode> resolveMap = MapSequence.fromMap(new HashMap<SNodeReference, SNode>());\n            List<SNodeReference> nodesToMove = ListSequence.fromList(new ArrayList<SNodeReference>());\n            for (SNodeReference nodeRef : SetSequence.fromSet(MapSequence.fromMap(nodeRoots).keySet())) {\n              MapSequence.fromMap(resolveMap).put(nodeRef, resolveNode(nodeRef, project));\n            }\n            for (SNodeReference nodeRef : SetSequence.fromSet(MapSequence.fromMap(moveMap).keySet())) {\n              ListSequence.fromList(nodesToMove).addElement(nodeRef);\n            }\n\n            MoveNodesDefault.CopyMapObject.getCopyMap(refactoringSession).copy(ListSequence.fromList(nodesToMove).select(new ISelector<SNodeReference, SNode>() {\n              public SNode select(SNodeReference it) {\n                return MapSequence.fromMap(resolveMap).get(it);\n              }\n            }).toListSequence(), ListSequence.fromList(nodesToMove).select(new ISelector<SNodeReference, Boolean>() {\n              public Boolean select(SNodeReference it) {\n                return MapSequence.fromMap(shouldKeep).get(it);\n              }\n            }).toListSequence());\n\n            {\n              Iterator<SNodeReference> oldNode_it = ListSequence.fromList(nodesToMove).iterator();\n              SNodeReference oldNode_var;\n              while (oldNode_it.hasNext()) {\n                oldNode_var = oldNode_it.next();\n                MapSequence.fromMap(moveMap).get(oldNode_var).insertNode(project.getRepository(), MapSequence.fromMap(copyMap).get(MapSequence.fromMap(resolveMap).get(oldNode_var)));\n              }\n            }\n\n            for (IMapping<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, SNode, SNode>> participantState : MapSequence.fromMap(changes)) {\n              participantState.value().doRefactor(ListSequence.fromList(allNodes.value).select(new ISelector<SNodeReference, SNode>() {\n                public SNode select(SNodeReference it) {\n                  return MapSequence.fromMap(copyMap).get(MapSequence.fromMap(resolveMap).get(it));\n                }\n              }).toListSequence(), project.getRepository(), refactoringSession);\n            }\n            try {\n              refactoringSession.commit();\n            } catch (RuntimeException exception) {\n              if (LOG.isEnabledFor(Level.ERROR)) {\n                LOG.error(\"Exception during refactoring: \", exception);\n              }\n            }\n          }\n        });\n        refactoringViewItem.close();\n      }\n    }, searchResults, false, \"Move nodes\");\n  }","id":33869,"modified_method":"public static void doMove(final MPSProject project, final Map<SNodeReference, MoveNodesDefault.NodeProcessor> moveMap, final _FunctionTypes._void_P1_E0<? super RefactoringSession> initRefactoringSession) {\n\n    project.getRepository().getModelAccess().runReadAction(new Runnable() {\n      public void run() {\n        for (IMapping<SNodeReference, MoveNodesDefault.NodeProcessor> moving : MapSequence.fromMap(moveMap)) {\n          SNode node = resolveNode(moving.key(), project);\n          if (!(moving.value().isValid(node))) {\n            throw new IllegalArgumentException();\n          }\n        }\n      }\n    });\n\n    final Map<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, SNode, SNode>> changes = MapSequence.fromMap(new HashMap<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, SNode, SNode>>());\n    final Map<SNodeReference, SNodeReference> nodeRoots = MapSequence.fromMap(new HashMap<SNodeReference, SNodeReference>());\n    final Wrappers._T<List<SNodeReference>> allNodes = new Wrappers._T<List<SNodeReference>>();\n    final Wrappers._T<List<RefactoringParticipant.Option>> options = new Wrappers._T<List<RefactoringParticipant.Option>>();\n    project.getRepository().getModelAccess().runReadAction(new Runnable() {\n      public void run() {\n        for (SNodeReference nodeToMove : SetSequence.fromSet(MapSequence.fromMap(moveMap).keySet())) {\n          for (SNodeReference descendant : ListSequence.fromList(SNodeOperations.getNodeDescendants(resolveNode(nodeToMove, project), null, true, new SAbstractConcept[]{})).select(new ISelector<SNode, SNodeReference>() {\n            public SNodeReference select(SNode it) {\n              return it.getReference();\n            }\n          })) {\n            MapSequence.fromMap(nodeRoots).put(descendant, nodeToMove);\n          }\n        }\n        allNodes.value = SetSequence.fromSet(MapSequence.fromMap(nodeRoots).keySet()).toListSequence();\n        for (MoveNodeRefactoringParticipant<?, ?> participant : Sequence.fromIterable(new ExtensionPoint<MoveNodeRefactoringParticipant<?, ?>>(\"jetbrains.mps.ide.platform.MoveNodeParticipantEP\").getObjects()).toListSequence()) {\n          RefactoringParticipant.ParticipantState<?, ?, SNode, SNode> participantState;\n          MapSequence.fromMap(changes).put(participant, RefactoringParticipant.ParticipantState.create(participant, ListSequence.fromList(allNodes.value).select(new ISelector<SNodeReference, SNode>() {\n            public SNode select(SNodeReference it) {\n              return resolveNode(it, project);\n            }\n          }).toListSequence()));\n        }\n        options.value = MapSequence.fromMap(changes).translate(new ITranslator2<IMapping<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, SNode, SNode>>, RefactoringParticipant.Option>() {\n          public Iterable<RefactoringParticipant.Option> translate(IMapping<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, SNode, SNode>> it) {\n            return it.value().getAvaliableOptions(project.getRepository());\n          }\n        }).distinct().sort(new ISelector<RefactoringParticipant.Option, String>() {\n          public String select(RefactoringParticipant.Option it) {\n            return it.getDescription();\n          }\n        }, true).toListSequence();\n      }\n    });\n\n    List<Integer> selectedOptionIndices;\n    if (ListSequence.fromList(options.value).isNotEmpty()) {\n      selectedOptionIndices = SelectOptionsDialog.selectOptions(ProjectHelper.toIdeaProject(project), ListSequence.fromList(options.value).select(new ISelector<RefactoringParticipant.Option, String>() {\n        public String select(RefactoringParticipant.Option it) {\n          return it.getDescription();\n        }\n      }).toListSequence(), \"Refactoring Options\");\n    } else {\n      selectedOptionIndices = ListSequence.fromList(new ArrayList<Integer>());\n    }\n    if (selectedOptionIndices == null) {\n      return;\n    }\n    final List<RefactoringParticipant.Option> selectedOptions = ListSequence.fromList(selectedOptionIndices).select(new ISelector<Integer, RefactoringParticipant.Option>() {\n      public RefactoringParticipant.Option select(Integer i) {\n        return ListSequence.fromList(options.value).getElement(i);\n      }\n    }).toListSequence();\n\n    final Wrappers._boolean cancelled = new Wrappers._boolean(false);\n    ProgressManager.getInstance().run(new Task.Modal(project.getProject(), \"Refactoring\", true) {\n      public void run(@NotNull ProgressIndicator progressIndicator) {\n        final ProgressMonitorAdapter progressMonitor = new ProgressMonitorAdapter(progressIndicator);\n        project.getRepository().getModelAccess().runReadAction(new Runnable() {\n          public void run() {\n            int steps = MapSequence.fromMap(changes).count();\n            progressMonitor.start(\"Searching for usages\", steps);\n            for (IMapping<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, SNode, SNode>> participantState : MapSequence.fromMap(changes)) {\n              participantState.value().findChanges(project.getRepository(), selectedOptions, project.getScope(), progressMonitor.subTask(1, SubProgressKind.AS_COMMENT));\n              if (progressMonitor.isCanceled()) {\n                cancelled.value = true;\n                break;\n              }\n            }\n            progressMonitor.done();\n          }\n        });\n      }\n    });\n\n    if (cancelled.value) {\n      return;\n    }\n\n    SearchResults searchResults = new SearchResults();\n    final Map<SNodeReference, Boolean> shouldKeep = MapSequence.fromMap(new HashMap<SNodeReference, Boolean>());\n\n    for (SNodeReference node : SetSequence.fromSet(MapSequence.fromMap(moveMap).keySet())) {\n      MapSequence.fromMap(shouldKeep).put(node, false);\n    }\n    for (IMapping<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, SNode, SNode>> participantState : MapSequence.fromMap(changes)) {\n      List<? extends List<? extends RefactoringParticipant.Change<?, ?>>> nodesChanges = participantState.value().getChanges();\n      for (int i = 0; i < ListSequence.fromList(allNodes.value).count(); i++) {\n        for (RefactoringParticipant.Change<?, ?> change : ListSequence.fromList(ListSequence.fromList(nodesChanges).getElement(i))) {\n          MapSequence.fromMap(shouldKeep).putValue(MapSequence.fromMap(nodeRoots).get(ListSequence.fromList(allNodes.value).getElement(i)), MapSequence.fromMap(shouldKeep).get(MapSequence.fromMap(nodeRoots).get(ListSequence.fromList(allNodes.value).getElement(i))) || (change.needsToPreserveOldNode()));\n          searchResults.addAll(change.getSearchResults());\n        }\n      }\n    }\n\n    RefactoringAccessEx.getInstance().showRefactoringView(project.getProject(), new RefactoringViewAction() {\n      public void performAction(RefactoringViewItem refactoringViewItem) {\n        project.getRepository().getModelAccess().executeCommand(new Runnable() {\n          public void run() {\n            RefactoringSessionImpl refactoringSession = new RefactoringSessionImpl();\n            if (initRefactoringSession != null) {\n              initRefactoringSession.invoke(refactoringSession);\n            }\n\n\n            final Map<SNode, SNode> copyMap = MoveNodesDefault.CopyMapObject.getCopyMap(refactoringSession).getCopyMap();\n            final Map<SNodeReference, SNode> resolveMap = MapSequence.fromMap(new HashMap<SNodeReference, SNode>());\n            List<SNodeReference> nodesToMove = ListSequence.fromList(new ArrayList<SNodeReference>());\n            for (SNodeReference nodeRef : SetSequence.fromSet(MapSequence.fromMap(nodeRoots).keySet())) {\n              MapSequence.fromMap(resolveMap).put(nodeRef, resolveNode(nodeRef, project));\n            }\n            for (SNodeReference nodeRef : SetSequence.fromSet(MapSequence.fromMap(moveMap).keySet())) {\n              ListSequence.fromList(nodesToMove).addElement(nodeRef);\n            }\n\n            final Map<MoveNodesDefault.NodeProcessor, List<SNode>> nodeProcessors = MapSequence.fromMap(new HashMap<MoveNodesDefault.NodeProcessor, List<SNode>>());\n            ListSequence.fromList(nodesToMove).visitAll(new IVisitor<SNodeReference>() {\n              public void visit(SNodeReference it) {\n                MoveNodesDefault.NodeProcessor processor = MapSequence.fromMap(moveMap).get(it);\n                if (!(MapSequence.fromMap(nodeProcessors).containsKey(processor))) {\n                  MapSequence.fromMap(nodeProcessors).put(processor, ListSequence.fromList(new ArrayList<SNode>()));\n                }\n                ListSequence.fromList(MapSequence.fromMap(nodeProcessors).get(processor)).addElement(MapSequence.fromMap(resolveMap).get(it));\n              }\n            });\n            for (IMapping<MoveNodesDefault.NodeProcessor, List<SNode>> mapping : MapSequence.fromMap(nodeProcessors)) {\n              mapping.key().process(mapping.value(), ListSequence.fromList(mapping.value()).where(new IWhereFilter<SNode>() {\n                public boolean accept(SNode it) {\n                  return !(MapSequence.fromMap(shouldKeep).get(it.getReference()));\n                }\n              }).toListSequence(), refactoringSession);\n            }\n\n            for (IMapping<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, SNode, SNode>> participantState : MapSequence.fromMap(changes)) {\n              participantState.value().doRefactor(ListSequence.fromList(allNodes.value).select(new ISelector<SNodeReference, SNode>() {\n                public SNode select(SNodeReference it) {\n                  return MapSequence.fromMap(copyMap).get(MapSequence.fromMap(resolveMap).get(it));\n                }\n              }).toListSequence(), project.getRepository(), refactoringSession);\n            }\n            try {\n              refactoringSession.commit();\n            } catch (RuntimeException exception) {\n              if (LOG.isEnabledFor(Level.ERROR)) {\n                LOG.error(\"Exception during refactoring: \", exception);\n              }\n            }\n          }\n        });\n        refactoringViewItem.close();\n      }\n    }, searchResults, false, \"Move nodes\");\n  }","commit_id":"73e38dc0d6a171d29a92581f5670d802740087a9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<SNode> copy(List<SNode> oldNodes, List<Boolean> shouldKeep) {\n      if (ListSequence.fromList(oldNodes).count() != ListSequence.fromList(shouldKeep).count()) {\n        throw new IllegalArgumentException();\n      }\n      Map<SNode, SNode> localCopyMap = MapSequence.fromMap(new HashMap<SNode, SNode>());\n      List<SNode> result = CopyUtil.copyAndPreserveId(oldNodes, localCopyMap);\n      MapSequence.fromMap(copyMap).putAll(localCopyMap);\n      for (IMapping<SNode, SNode> mapping : MapSequence.fromMap(copyMap)) {\n        CopyUtil.addReferences(mapping.key(), copyMap, false);\n      }\n      {\n        Iterator<SNode> oldNode_it = ListSequence.fromList(oldNodes).iterator();\n        Iterator<Boolean> sk_it = ListSequence.fromList(shouldKeep).iterator();\n        SNode oldNode_var;\n        boolean sk_var;\n        while (oldNode_it.hasNext() && sk_it.hasNext()) {\n          oldNode_var = oldNode_it.next();\n          sk_var = sk_it.next();\n          for (SNode desc : ListSequence.fromList(SNodeOperations.getNodeDescendants(oldNode_var, null, true, new SAbstractConcept[]{}))) {\n            MapSequence.fromMap(keepOldNodes).put(desc, sk_var);\n          }\n          if (!(sk_var)) {\n            SNodeOperations.detachNode(oldNode_var);\n          }\n        }\n      }\n      return result;\n    }","id":33870,"modified_method":"public List<SNode> copy(List<SNode> oldNodes) {\n      Map<SNode, SNode> localCopyMap = MapSequence.fromMap(new HashMap<SNode, SNode>());\n      List<SNode> result = CopyUtil.copyAndPreserveId(oldNodes, localCopyMap);\n      MapSequence.fromMap(copyMap).putAll(localCopyMap);\n      for (IMapping<SNode, SNode> mapping : MapSequence.fromMap(copyMap)) {\n        CopyUtil.addReferences(mapping.key(), copyMap, false);\n      }\n      return result;\n    }","commit_id":"73e38dc0d6a171d29a92581f5670d802740087a9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<List<RefactoringParticipant.Change<NamedNodeReference, NamedNodeReference>>> getChanges(List<NamedNodeReference> initialStates, final SRepository repository, final List<RefactoringParticipant.Option> selectedOptions, SearchScope searchScope, ProgressMonitor progressMonitor) {\n    if (!(ListSequence.fromList(selectedOptions).contains(OPTION))) {\n      return ListSequence.fromList(initialStates).select(new ISelector<NamedNodeReference, List<RefactoringParticipant.Change<NamedNodeReference, NamedNodeReference>>>() {\n        public List<RefactoringParticipant.Change<NamedNodeReference, NamedNodeReference>> select(NamedNodeReference it) {\n          return (List<RefactoringParticipant.Change<NamedNodeReference, NamedNodeReference>>) Collections.<RefactoringParticipant.Change<NamedNodeReference, NamedNodeReference>>emptyList();\n        }\n      }).toListSequence();\n    }\n    Collection<SReference> usages;\n    List<SNode> movedNodes = ListSequence.fromList(initialStates).select(new ISelector<NamedNodeReference, SNode>() {\n      public SNode select(NamedNodeReference it) {\n        return it.reference().resolve(repository);\n      }\n    }).toListSequence();\n    {\n      final SearchScope scope = CommandUtil.createScope(searchScope);\n      QueryExecutionContext context = new QueryExecutionContext() {\n        public SearchScope getDefaultSearchScope() {\n          return scope;\n        }\n      };\n      if (ListSequence.fromList(movedNodes).all(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return it != null;\n        }\n      })) {\n        progressMonitor.start(\"References in current project\", 1);\n        usages = (Set<SReference>) FindUsagesFacade.getInstance().findUsages(searchScope, SetSequence.fromSetWithValues(new HashSet<SNode>(), movedNodes), progressMonitor.subTask(1));\n      } else {\n        progressMonitor.start(\"References in current project\", Sequence.fromIterable(CommandUtil.references(CommandUtil.createConsoleScope(null, false, context))).count());\n        usages = CollectionSequence.fromCollection(new ArrayList<SReference>());\n        for (SReference ref : Sequence.fromIterable(CommandUtil.references(CommandUtil.createConsoleScope(null, false, context)))) {\n          if (ListSequence.fromList(initialStates).select(new ISelector<NamedNodeReference, SNodeReference>() {\n            public SNodeReference select(NamedNodeReference it) {\n              return it.reference();\n            }\n          }).contains(ref.getTargetNodeReference())) {\n            CollectionSequence.fromCollection(usages).addElement(ref);\n          }\n          progressMonitor.advance(1);\n          if (progressMonitor.isCanceled()) {\n            return null;\n          }\n        }\n      }\n    }\n    final Map<SNodeReference, List<RefactoringParticipant.Change<NamedNodeReference, NamedNodeReference>>> result = MapSequence.fromMap(new HashMap<SNodeReference, List<RefactoringParticipant.Change<NamedNodeReference, NamedNodeReference>>>());\n    for (SReference ref : CollectionSequence.fromCollection(usages)) {\n      final SNodeReference containingNode = ref.getSourceNode().getReference();\n      final SReferenceLink role = ref.getLink();\n      final String resolveInfo = SLinkOperations.getResolveInfo(ref);\n      final SearchResults searchResults = new SearchResults(SetSequence.fromSetAndArray(new HashSet<SNode>(), ref.getTargetNode()), ListSequence.fromListAndArray(new ArrayList<SearchResult<SNode>>(), new SearchResult<SNode>(ref.getSourceNode(), \"reference\")));\n      RefactoringParticipant.Change<NamedNodeReference, NamedNodeReference> change = new RefactoringParticipant.Change<NamedNodeReference, NamedNodeReference>() {\n        public MoveNodeRefactoringParticipant<NamedNodeReference, NamedNodeReference> getParticipant() {\n          return UpdateReferencesParticipant.this;\n        }\n        public SearchResults getSearchResults() {\n          return searchResults;\n        }\n        public boolean needsToPreserveOldNode() {\n          return false;\n        }\n        public void confirm(final NamedNodeReference finalState, final SRepository repository, final RefactoringSession refactoringSession) {\n          refactoringSession.registerChange(new Runnable() {\n            public void run() {\n              SNode node = containingNode.resolve(repository);\n              MoveNodesDefault.CopyMapObject copyMap = MoveNodesDefault.CopyMapObject.getCopyMap(refactoringSession);\n              if (node == null || (MapSequence.fromMap(copyMap.getCopyMap()).containsKey(node) && copyMap.whetherKeepNode(node))) {\n                return;\n              }\n              node.setReference(role, jetbrains.mps.smodel.SReference.create(role, node, finalState.reference().getModelReference(), finalState.reference().getNodeId(), resolveInfo));\n              if (ListSequence.fromList(selectedOptions).contains(UpdateModelImports.OPTION)) {\n                UpdateModelImports.addModelImport(node.getModel(), finalState.reference().getModelReference().resolve(repository));\n              }\n            }\n          });\n        }\n      };\n      if (MapSequence.fromMap(result).get(ref.getTargetNodeReference()) == null) {\n        MapSequence.fromMap(result).put(ref.getTargetNodeReference(), ListSequence.fromList(new ArrayList<RefactoringParticipant.Change<NamedNodeReference, NamedNodeReference>>()));\n      }\n      ListSequence.fromList(MapSequence.fromMap(result).get(ref.getTargetNodeReference())).addElement(change);\n    }\n    return ListSequence.fromList(initialStates).select(new ISelector<NamedNodeReference, List<RefactoringParticipant.Change<NamedNodeReference, NamedNodeReference>>>() {\n      public List<RefactoringParticipant.Change<NamedNodeReference, NamedNodeReference>> select(NamedNodeReference initialState) {\n        return MapSequence.fromMap(result).get(initialState.reference());\n      }\n    }).toListSequence();\n  }","id":33871,"modified_method":"public List<RefactoringParticipant.Change<NamedNodeReference, NamedNodeReference>> getChanges(final NamedNodeReference initialState, SRepository repository, final List<RefactoringParticipant.Option> selectedOptions, SearchScope searchScope) {\n    if (!(ListSequence.fromList(selectedOptions).contains(OPTION))) {\n      return ListSequence.fromList(new ArrayList<RefactoringParticipant.Change<NamedNodeReference, NamedNodeReference>>());\n    }\n    {\n      final SearchScope scope = CommandUtil.createScope(searchScope);\n      QueryExecutionContext context = new QueryExecutionContext() {\n        public SearchScope getDefaultSearchScope() {\n          return scope;\n        }\n      };\n      final SNode movedNode = initialState.reference().resolve(repository);\n      Collection<SReference> usages;\n      if (movedNode != null) {\n        usages = CommandUtil.usages(CommandUtil.createConsoleScope(null, false, context), movedNode);\n      } else {\n        usages = Sequence.fromIterable(CommandUtil.references(CommandUtil.createConsoleScope(null, false, context))).where(new IWhereFilter<SReference>() {\n          public boolean accept(SReference it) {\n            return eq_k8iioh_a0a0a0a0a0a0a0a4a1a21(it.getTargetNodeReference(), initialState.reference());\n          }\n        }).toListSequence();\n      }\n      return CollectionSequence.fromCollection(usages).select(new ISelector<SReference, RefactoringParticipant.Change<NamedNodeReference, NamedNodeReference>>() {\n        public RefactoringParticipant.Change<NamedNodeReference, NamedNodeReference> select(SReference ref) {\n          final SNodeReference containingNode = ref.getSourceNode().getReference();\n          final SReferenceLink role = ref.getLink();\n          final String resolveInfo = SLinkOperations.getResolveInfo(ref);\n          final SearchResults searchResults = new SearchResults(SetSequence.fromSetAndArray(new HashSet<SNode>(), movedNode), ListSequence.fromListAndArray(new ArrayList<SearchResult<SNode>>(), new SearchResult<SNode>(ref.getSourceNode(), \"reference\")));\n          RefactoringParticipant.Change<NamedNodeReference, NamedNodeReference> change = new RefactoringParticipant.Change<NamedNodeReference, NamedNodeReference>() {\n            public MoveNodeRefactoringParticipant<NamedNodeReference, NamedNodeReference> getParticipant() {\n              return UpdateReferencesParticipant.this;\n            }\n            public SearchResults getSearchResults() {\n              return searchResults;\n            }\n            public boolean needsToPreserveOldNode() {\n              return false;\n            }\n            public void confirm(final NamedNodeReference finalState, final SRepository repository, RefactoringSession refactoringSession) {\n              refactoringSession.registerChange(new Runnable() {\n                public void run() {\n                  SNode node = containingNode.resolve(repository);\n                  if (node == null || (node.getModel() != null)) {\n                    return;\n                  }\n                  node.setReference(role, jetbrains.mps.smodel.SReference.create(role, node, finalState.reference().getModelReference(), finalState.reference().getNodeId(), resolveInfo));\n                  if (ListSequence.fromList(selectedOptions).contains(UpdateModelImports.OPTION)) {\n                    UpdateModelImports.addModelImport(node.getModel(), finalState.reference().getModelReference().resolve(repository));\n                  }\n                }\n              });\n            }\n          };\n          return change;\n        }\n      }).toListSequence();\n    }\n  }","commit_id":"73e38dc0d6a171d29a92581f5670d802740087a9","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void doMove(Project project,\n                     PsiElement[] elements,\n                     @Nullable PsiElement targetContainer,\n                     @Nullable MoveCallback callback) {\n    PsiNamedElement[] elementsToMove = new PsiNamedElement[elements.length];\n    for (int i = 0; i < elements.length; i++) {\n      final PsiNamedElement e = getElementToMove(elements[i]);\n      if (e == null) {\n        return;\n      }\n      elementsToMove[i] = e;\n    }\n    boolean previewUsages = false;\n    final String destination;\n    if (targetContainer instanceof PyFile) {\n      destination = targetContainer.getText();\n    }\n    else {\n      final PyMoveClassOrFunctionDialog dialog = new PyMoveClassOrFunctionDialog(project, elementsToMove);\n      dialog.show();\n      if (!dialog.isOK()) {\n        return;\n      }\n      destination = dialog.getTargetPath();\n      previewUsages = dialog.isPreviewUsages();\n    }\n    try {\n      final BaseRefactoringProcessor processor = new PyMoveClassOrFunctionProcessor(project, elementsToMove, destination, previewUsages);\n      processor.run();\n    }\n    catch (IncorrectOperationException e) {\n      CommonRefactoringUtil.showErrorMessage(RefactoringBundle.message(\"error.title\"), e.getMessage(),\n                                             null, project);\n    }\n  }","id":33872,"modified_method":"@Override\n  public void doMove(Project project,\n                     PsiElement[] elements,\n                     @Nullable PsiElement targetContainer,\n                     @Nullable MoveCallback callback) {\n    PsiNamedElement[] elementsToMove = new PsiNamedElement[elements.length];\n    for (int i = 0; i < elements.length; i++) {\n      final PsiNamedElement e = getElementToMove(elements[i]);\n      if (e == null) {\n        return;\n      }\n      elementsToMove[i] = e;\n    }\n    String initialDestination = null;\n    if (targetContainer instanceof PsiFile) {\n      final VirtualFile virtualFile = ((PsiFile)targetContainer).getVirtualFile();\n      if (virtualFile != null) {\n        initialDestination = FileUtil.toSystemDependentName(virtualFile.getPath());\n      }\n    }\n    final PyMoveClassOrFunctionDialog dialog = new PyMoveClassOrFunctionDialog(project, elementsToMove, initialDestination);\n    dialog.show();\n    if (!dialog.isOK()) {\n      return;\n    }\n    final String destination = dialog.getTargetPath();\n    final boolean previewUsages = dialog.isPreviewUsages();\n    try {\n      final BaseRefactoringProcessor processor = new PyMoveClassOrFunctionProcessor(project, elementsToMove, destination, previewUsages);\n      processor.run();\n    }\n    catch (IncorrectOperationException e) {\n      CommonRefactoringUtil.showErrorMessage(RefactoringBundle.message(\"error.title\"), e.getMessage(),\n                                             null, project);\n    }\n  }","commit_id":"920c84276d9650cb4f9c3e8e114e1183fbcea43d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean tryToMove(@NotNull PsiElement element,\n                           @NotNull Project project,\n                           @Nullable DataContext dataContext,\n                           @Nullable PsiReference reference,\n                           @Nullable Editor editor) {\n    final PsiNamedElement e = getElementToMove(element);\n    if (e instanceof PyClass || e instanceof PyFunction) {\n      if (PyPsiUtils.isTopLevel(e)) {\n        doMove(project, new PsiElement[] {e}, null, null);\n      }\n      else {\n        CommonRefactoringUtil.showErrorHint(project, editor, PyBundle.message(\"refactoring.move.class.or.function.error.selection\"),\n                                            RefactoringBundle.message(\"error.title\"), null);\n      }\n      return true;\n    }\n    return false;\n  }","id":33873,"modified_method":"@Override\n  public boolean tryToMove(@NotNull PsiElement element,\n                           @NotNull Project project,\n                           @Nullable DataContext dataContext,\n                           @Nullable PsiReference reference,\n                           @Nullable Editor editor) {\n    final PsiNamedElement e = getElementToMove(element);\n    if (e instanceof PyClass || e instanceof PyFunction) {\n      if (PyPsiUtils.isTopLevel(e)) {\n        PsiElement targetContainer = null;\n        if (editor != null) {\n          final Document document = editor.getDocument();\n          targetContainer = PsiDocumentManager.getInstance(project).getPsiFile(document);\n        }\n        doMove(project, new PsiElement[] {e}, targetContainer, null);\n      }\n      else {\n        CommonRefactoringUtil.showErrorHint(project, editor, PyBundle.message(\"refactoring.move.class.or.function.error.selection\"),\n                                            RefactoringBundle.message(\"error.title\"), null);\n      }\n      return true;\n    }\n    return false;\n  }","commit_id":"920c84276d9650cb4f9c3e8e114e1183fbcea43d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PyMoveClassOrFunctionDialog(@NotNull Project project, PsiNamedElement[] elements) {\n    super(project, true);\n    assert elements.length > 0;\n    final String moveText;\n    if (elements.length == 1) {\n      PsiNamedElement e = elements[0];\n      if (e instanceof PyClass) {\n        moveText = PyBundle.message(\"refactoring.move.class.$0\", ((PyClass)e).getQualifiedName());\n      }\n      else {\n        moveText = PyBundle.message(\"refactoring.move.function.$0\", e.getName());\n      }\n    }\n    else {\n      moveText = PyBundle.message(\"refactoring.move.selected.elements\");\n    }\n\n    myPanel = new PyMoveClassOrFunctionPanel(moveText, getContainingFileName(elements[0]));\n    setTitle(PyBundle.message(\"refactoring.move.class.or.function.dialog.title\"));\n\n    final FileChooserDescriptor descriptor = FileChooserDescriptorFactory.createSingleFileNoJarsDescriptor();\n    descriptor.setRoots(ProjectRootManager.getInstance(project).getContentRoots());\n    descriptor.setIsTreeRootVisible(true);\n\n    myPanel.getBrowseTargetFileButton().addBrowseFolderListener(PyBundle.message(\"refactoring.move.class.or.function.choose.destination.file.title\"),\n                                                                null, project, descriptor,\n                                                                TextComponentAccessor.TEXT_FIELD_WHOLE_TEXT);\n    init();\n  }","id":33874,"modified_method":"public PyMoveClassOrFunctionDialog(@NotNull Project project, @NotNull PsiNamedElement[] elements, @Nullable String destination) {\n    super(project, true);\n    assert elements.length > 0;\n    final String moveText;\n\n    if (elements.length == 1) {\n      PsiNamedElement e = elements[0];\n      if (e instanceof PyClass) {\n        moveText = PyBundle.message(\"refactoring.move.class.$0\", ((PyClass)e).getQualifiedName());\n      }\n      else {\n        moveText = PyBundle.message(\"refactoring.move.function.$0\", e.getName());\n      }\n    }\n    else {\n      moveText = PyBundle.message(\"refactoring.move.selected.elements\");\n    }\n\n    if (destination == null) {\n      destination = getContainingFileName(elements[0]);\n    }\n\n    myPanel = new PyMoveClassOrFunctionPanel(moveText, destination);\n    setTitle(PyBundle.message(\"refactoring.move.class.or.function.dialog.title\"));\n\n    final FileChooserDescriptor descriptor = FileChooserDescriptorFactory.createSingleFileNoJarsDescriptor();\n    descriptor.setRoots(ProjectRootManager.getInstance(project).getContentRoots());\n    descriptor.setIsTreeRootVisible(true);\n\n    myPanel.getBrowseTargetFileButton().addBrowseFolderListener(PyBundle.message(\"refactoring.move.class.or.function.choose.destination.file.title\"),\n                                                                null, project, descriptor,\n                                                                TextComponentAccessor.TEXT_FIELD_WHOLE_TEXT);\n    init();\n  }","commit_id":"920c84276d9650cb4f9c3e8e114e1183fbcea43d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void doMove(final Project project, final PsiElement[] elements, final PsiElement targetContainer, final MoveCallback callback) {\n    if (canMoveOrRearrangePackages(elements) ) {\n      final PsiDirectory[] directories = new PsiDirectory[elements.length];\n      System.arraycopy(elements, 0, directories, 0, directories.length);\n      SelectMoveOrRearrangePackageDialog dialog = new SelectMoveOrRearrangePackageDialog(project, directories, targetContainer == null);\n      dialog.show();\n      if (!dialog.isOK()) return;\n\n      if (dialog.isPackageRearrageSelected()) {\n        MoveClassesOrPackagesImpl.doRearrangePackage(project, directories);\n        return;\n      }\n\n      if (dialog.isMoveDirectory()) {\n        if (targetContainer instanceof PsiDirectory) {\n          final JavaRefactoringSettings refactoringSettings = JavaRefactoringSettings.getInstance();\n          final MoveDirectoryWithClassesProcessor processor =\n            new MoveDirectoryWithClassesProcessor(project, directories, (PsiDirectory)targetContainer,\n                                                  refactoringSettings.RENAME_SEARCH_IN_COMMENTS_FOR_PACKAGE,\n                                                  refactoringSettings.RENAME_SEARCH_IN_COMMENTS_FOR_PACKAGE, true, callback);\n          processor.setPrepareSuccessfulSwingThreadCallback(new Runnable() {\n            @Override\n            public void run() {\n            }\n          });\n          processor.run();\n        }\n        else {\n          final boolean containsJava = hasJavaFiles(directories[0]);\n          if (!containsJava) {\n            MoveFilesOrDirectoriesUtil.doMove(project, new PsiElement[] {directories[0]}, new PsiElement[]{targetContainer}, callback);\n            return;\n          }\n          final MoveClassesOrPackagesToNewDirectoryDialog dlg =\n            new MoveClassesOrPackagesToNewDirectoryDialog(directories[0], new PsiElement[0], false, callback) {\n              @Override\n              protected void performRefactoring(Project project,\n                                                final PsiDirectory targetDirectory,\n                                                PsiPackage aPackage,\n                                                boolean searchInComments,\n                                                boolean searchForTextOccurences) {\n                final MoveDirectoryWithClassesProcessor processor =\n                  new MoveDirectoryWithClassesProcessor(project, directories, targetDirectory, searchInComments, searchForTextOccurences,\n                                                        true, callback);\n                processor.setPrepareSuccessfulSwingThreadCallback(new Runnable() {\n                  @Override\n                  public void run() {\n                  }\n                });\n                processor.run();\n              }\n            };\n          dlg.show();\n        }\n        return;\n      }\n    }\n    if (tryDirectoryMove ( project, elements, targetContainer, callback)) {\n      return;\n    }\n    MoveClassesOrPackagesImpl.doMove(project, elements, targetContainer, callback);\n  }","id":33875,"modified_method":"public void doMove(final Project project, final PsiElement[] elements, final PsiElement targetContainer, final MoveCallback callback) {\n    final PsiDirectory[] directories = new PsiDirectory[elements.length];\n    System.arraycopy(elements, 0, directories, 0, directories.length);\n    final String prompt = getPromptToMoveDirectoryLibrariesSafe(elements);\n    if (prompt != null) {\n      moveDirectoriesLibrariesSafe(project, targetContainer, callback, directories, prompt);\n      return;\n    }\n    if (canMoveOrRearrangePackages(elements) ) {\n      SelectMoveOrRearrangePackageDialog dialog = new SelectMoveOrRearrangePackageDialog(project, directories, targetContainer == null);\n      dialog.show();\n      if (!dialog.isOK()) return;\n\n      if (dialog.isPackageRearrageSelected()) {\n        MoveClassesOrPackagesImpl.doRearrangePackage(project, directories);\n        return;\n      }\n\n      if (dialog.isMoveDirectory()) {\n        moveAsDirectory(project, targetContainer, callback, directories);\n        return;\n      }\n    }\n    if (tryDirectoryMove ( project, elements, targetContainer, callback)) {\n      return;\n    }\n    MoveClassesOrPackagesImpl.doMove(project, elements, targetContainer, callback);\n  }","commit_id":"41b3ea788d70f25286e235a754283a2db6532afc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean tryToMove(@NotNull PsiElement element,\n                           @NotNull Project project,\n                           @Nullable DataContext dataContext,\n                           @Nullable PsiReference reference,\n                           @Nullable Editor editor) {\n    final PsiNamedElement e = getElementToMove(element);\n    if (e != null && PyMoveModuleMembersHelper.isMovableElement(e)) {\n      if (PyUtil.isTopLevel(e)) {\n        PsiElement targetContainer = null;\n        if (editor != null) {\n          final Document document = editor.getDocument();\n          targetContainer = PsiDocumentManager.getInstance(project).getPsiFile(document);\n        }\n        doMove(project, new PsiElement[] {e}, targetContainer, null);\n      }\n      else {\n        CommonRefactoringUtil.showErrorHint(project, editor, PyBundle.message(\"refactoring.move.module.members.error.selection\"),\n                                            RefactoringBundle.message(\"error.title\"), null);\n      }\n      return true;\n    }\n    return false;\n  }","id":33876,"modified_method":"@Override\n  public boolean tryToMove(@NotNull PsiElement element,\n                           @NotNull Project project,\n                           @Nullable DataContext dataContext,\n                           @Nullable PsiReference reference,\n                           @Nullable Editor editor) {\n    final PsiNamedElement e = PyMoveModuleMembersHelper.extractNamedElement(element);\n    if (e != null && PyMoveModuleMembersHelper.isMovableElement(e)) {\n      if (PyUtil.isTopLevel(e)) {\n        final ArrayList<PsiNamedElement> elementsToMove = Lists.newArrayList(e);\n        PsiElement targetContainer = null;\n        if (editor != null) {\n          final Document document = editor.getDocument();\n          targetContainer = PsiDocumentManager.getInstance(project).getPsiFile(document);\n          final PyFile pyFile = as(targetContainer, PyFile.class);\n          if (pyFile != null) {\n            final SelectionModel selectionModel = editor.getSelectionModel();\n            final TextRange selectionRange = new TextRange(selectionModel.getSelectionStart(), selectionModel.getSelectionEnd());\n            final List<PyElement> members = PyMoveModuleMembersHelper.getTopLevelModuleMembers(pyFile);\n            for (PyElement member : members) {\n              if (member != e && member.getTextRange().intersects(selectionRange)) {\n                elementsToMove.add((PsiNamedElement)member);\n              }\n            }\n          }\n        }\n        doMove(project, ArrayUtil.toObjectArray(elementsToMove, PsiNamedElement.class), targetContainer, null);\n      }\n      else {\n        CommonRefactoringUtil.showErrorHint(project, editor, PyBundle.message(\"refactoring.move.module.members.error.selection\"),\n                                            RefactoringBundle.message(\"error.title\"), null);\n      }\n      return true;\n    }\n    return false;\n  }","commit_id":"12b4abb3ce34b3281b5b18ad48e2a86403b8138b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void doMove(Project project,\n                     PsiElement[] elements,\n                     @Nullable PsiElement targetContainer,\n                     @Nullable MoveCallback callback) {\n    final List<PsiNamedElement> initialElements = Lists.newArrayList();\n    for (PsiElement element : elements) {\n      final PsiNamedElement e = getElementToMove(element);\n      if (e == null) {\n        return;\n      }\n      initialElements.add(e);\n    }\n    String initialDestination = null;\n    if (targetContainer instanceof PsiFile) {\n      final VirtualFile virtualFile = ((PsiFile)targetContainer).getVirtualFile();\n      if (virtualFile != null) {\n        initialDestination = FileUtil.toSystemDependentName(virtualFile.getPath());\n      }\n    }\n    final PyMoveModuleMembersDialog dialog = PyMoveModuleMembersDialog.getInstance(project, initialElements, initialDestination);\n    if (!dialog.showAndGet()) {\n      return;\n    }\n    final String destination = dialog.getTargetPath();\n    final boolean previewUsages = dialog.isPreviewUsages();\n    try {\n      final PsiNamedElement[] selectedElements = ContainerUtil.findAllAsArray(dialog.getSelectedTopLevelSymbols(), PsiNamedElement.class);\n      final BaseRefactoringProcessor processor = new PyMoveModuleMembersProcessor(project, selectedElements, destination, previewUsages);\n      processor.run();\n    }\n    catch (IncorrectOperationException e) {\n      CommonRefactoringUtil.showErrorMessage(RefactoringBundle.message(\"error.title\"), e.getMessage(), null, project);\n    }\n  }","id":33877,"modified_method":"@Override\n  public void doMove(Project project,\n                     PsiElement[] elements,\n                     @Nullable PsiElement targetContainer,\n                     @Nullable MoveCallback callback) {\n    final List<PsiNamedElement> initialElements = Lists.newArrayList();\n    for (PsiElement element : elements) {\n      final PsiNamedElement e = PyMoveModuleMembersHelper.extractNamedElement(element);\n      if (e == null) {\n        return;\n      }\n      initialElements.add(e);\n    }\n    String initialDestination = null;\n    if (targetContainer instanceof PsiFile) {\n      final VirtualFile virtualFile = ((PsiFile)targetContainer).getVirtualFile();\n      if (virtualFile != null) {\n        initialDestination = FileUtil.toSystemDependentName(virtualFile.getPath());\n      }\n    }\n    final PyMoveModuleMembersDialog dialog = PyMoveModuleMembersDialog.getInstance(project, initialElements, initialDestination);\n    if (!dialog.showAndGet()) {\n      return;\n    }\n    final String destination = dialog.getTargetPath();\n    final boolean previewUsages = dialog.isPreviewUsages();\n    try {\n      final PsiNamedElement[] selectedElements = ContainerUtil.findAllAsArray(dialog.getSelectedTopLevelSymbols(), PsiNamedElement.class);\n      final BaseRefactoringProcessor processor = new PyMoveModuleMembersProcessor(project, selectedElements, destination, previewUsages);\n      processor.run();\n    }\n    catch (IncorrectOperationException e) {\n      CommonRefactoringUtil.showErrorMessage(RefactoringBundle.message(\"error.title\"), e.getMessage(), null, project);\n    }\n  }","commit_id":"12b4abb3ce34b3281b5b18ad48e2a86403b8138b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @param project dialog project\n   * @param elements elements to move\n   * @param destination destination where elements have to be moved\n   */\n  protected PyMoveModuleMembersDialog(@NotNull Project project, @NotNull List<PsiNamedElement> elements, @Nullable String destination) {\n    super(project, true);\n\n    assert !elements.isEmpty();\n    final PsiNamedElement firstElement = elements.get(0);\n    setTitle(PyBundle.message(\"refactoring.move.module.members.dialog.title\"));\n\n    final String sourceFilePath = getContainingFileName(firstElement);\n    mySourcePathField.setText(sourceFilePath);\n    if (destination == null) {\n      destination = sourceFilePath;\n    }\n    myBrowseFieldWithButton.setText(destination);\n    final FileChooserDescriptor descriptor = FileChooserDescriptorFactory.createSingleFileNoJarsDescriptor();\n    descriptor.setRoots(ProjectRootManager.getInstance(project).getContentRoots());\n    descriptor.withTreeRootVisible(true);\n    myBrowseFieldWithButton.addBrowseFolderListener(PyBundle.message(\"refactoring.move.module.members.dialog.choose.destination.file.title\"),\n                                                    null,\n                                                    project,\n                                                    descriptor,\n                                                    TextComponentAccessor.TEXT_FIELD_WHOLE_TEXT);\n\n    final PyFile pyFile = (PyFile)firstElement.getContainingFile();\n    myModuleMemberModel = new PyModuleMemberInfoModel(pyFile);\n\n    final List<PyModuleMemberInfo> symbolsInfos = myModuleMemberModel.collectTopLevelSymbolsInfo();\n    for (PyModuleMemberInfo info : symbolsInfos) {\n      info.setChecked(elements.contains(info.getMember()));\n    }\n    myModuleMemberModel.memberInfoChanged(new MemberInfoChange<PyElement, PyModuleMemberInfo>(symbolsInfos));\n    myMemberSelectionTable = new TopLevelSymbolsSelectionTable(symbolsInfos, myModuleMemberModel);\n    myMemberSelectionTable.addMemberInfoChangeListener(myModuleMemberModel);\n    myMemberSelectionTable.getModel().addTableModelListener(new TableModelListener() {\n      @Override\n      public void tableChanged(TableModelEvent e) {\n        validateButtons();\n      }\n    });\n    // MoveMemberDialog for Java uses SeparatorFactory.createSeparator instead of custom border\n    final boolean tableIsVisible = PropertiesComponent.getInstance().getBoolean(BULK_MOVE_TABLE_VISIBLE, false);\n    final String description;\n    if (!tableIsVisible && elements.size() == 1) {\n      if (firstElement instanceof PyFunction) {\n        description =  PyBundle.message(\"refactoring.move.module.members.dialog.description.function.$0\", firstElement.getName());\n      }\n      else if (firstElement instanceof PyClass) {\n        description = PyBundle.message(\"refactoring.move.module.members.dialog.description.class.$0\", firstElement.getName());\n      }\n      else {\n        description = PyBundle.message(\"refactoring.move.module.members.dialog.description.variable.$0\", firstElement.getName());\n      }\n    }\n    else {\n      description = PyBundle.message(\"refactoring.move.module.members.dialog.description.selection\");\n    }\n    myDescription.setText(description);\n    final HideableDecorator decorator = new HideableDecorator(myTablePanel, PyBundle.message(\"refactoring.move.module.members.dialog.table.title\"), true) {\n      @Override\n      protected void on() {\n        super.on();\n        myDescription.setText(PyBundle.message(\"refactoring.move.module.members.dialog.description.selection\"));\n        PropertiesComponent.getInstance().setValue(BULK_MOVE_TABLE_VISIBLE, \"true\");\n      }\n\n      @Override\n      protected void off() {\n        super.off();\n        PropertiesComponent.getInstance().setValue(BULK_MOVE_TABLE_VISIBLE, \"false\");\n      }\n    };\n    decorator.setOn(tableIsVisible);\n    decorator.setContentComponent(ScrollPaneFactory.createScrollPane(myMemberSelectionTable));\n    validateButtons();\n    init();\n  }","id":33878,"modified_method":"/**\n   * @param project dialog project\n   * @param elements elements to move\n   * @param destination destination where elements have to be moved\n   */\n  protected PyMoveModuleMembersDialog(@NotNull Project project, @NotNull List<PsiNamedElement> elements, @Nullable String destination) {\n    super(project, true);\n\n    assert !elements.isEmpty();\n    final PsiNamedElement firstElement = elements.get(0);\n    setTitle(PyBundle.message(\"refactoring.move.module.members.dialog.title\"));\n\n    final String sourceFilePath = getContainingFileName(firstElement);\n    mySourcePathField.setText(sourceFilePath);\n    if (destination == null) {\n      destination = sourceFilePath;\n    }\n    myBrowseFieldWithButton.setText(destination);\n    final FileChooserDescriptor descriptor = FileChooserDescriptorFactory.createSingleFileNoJarsDescriptor();\n    descriptor.setRoots(ProjectRootManager.getInstance(project).getContentRoots());\n    descriptor.withTreeRootVisible(true);\n    myBrowseFieldWithButton.addBrowseFolderListener(PyBundle.message(\"refactoring.move.module.members.dialog.choose.destination.file.title\"),\n                                                    null,\n                                                    project,\n                                                    descriptor,\n                                                    TextComponentAccessor.TEXT_FIELD_WHOLE_TEXT);\n\n    final PyFile pyFile = (PyFile)firstElement.getContainingFile();\n    myModuleMemberModel = new PyModuleMemberInfoModel(pyFile);\n\n    final List<PyModuleMemberInfo> symbolsInfos = collectModuleMemberInfos(myModuleMemberModel.myPyFile);\n    for (PyModuleMemberInfo info : symbolsInfos) {\n      info.setChecked(elements.contains(info.getMember()));\n    }\n    myModuleMemberModel.memberInfoChanged(new MemberInfoChange<PyElement, PyModuleMemberInfo>(symbolsInfos));\n    myMemberSelectionTable = new TopLevelSymbolsSelectionTable(symbolsInfos, myModuleMemberModel);\n    myMemberSelectionTable.addMemberInfoChangeListener(myModuleMemberModel);\n    myMemberSelectionTable.getModel().addTableModelListener(new TableModelListener() {\n      @Override\n      public void tableChanged(TableModelEvent e) {\n        validateButtons();\n      }\n    });\n    // MoveMemberDialog for Java uses SeparatorFactory.createSeparator instead of custom border\n    final boolean tableIsVisible = PropertiesComponent.getInstance().getBoolean(BULK_MOVE_TABLE_VISIBLE, false);\n    final String description;\n    if (!tableIsVisible && elements.size() == 1) {\n      if (firstElement instanceof PyFunction) {\n        description =  PyBundle.message(\"refactoring.move.module.members.dialog.description.function.$0\", firstElement.getName());\n      }\n      else if (firstElement instanceof PyClass) {\n        description = PyBundle.message(\"refactoring.move.module.members.dialog.description.class.$0\", firstElement.getName());\n      }\n      else {\n        description = PyBundle.message(\"refactoring.move.module.members.dialog.description.variable.$0\", firstElement.getName());\n      }\n    }\n    else {\n      description = PyBundle.message(\"refactoring.move.module.members.dialog.description.selection\");\n    }\n    myDescription.setText(description);\n    final HideableDecorator decorator = new HideableDecorator(myTablePanel, PyBundle.message(\"refactoring.move.module.members.dialog.table.title\"), true) {\n      @Override\n      protected void on() {\n        super.on();\n        myDescription.setText(PyBundle.message(\"refactoring.move.module.members.dialog.description.selection\"));\n        PropertiesComponent.getInstance().setValue(BULK_MOVE_TABLE_VISIBLE, \"true\");\n      }\n\n      @Override\n      protected void off() {\n        super.off();\n        PropertiesComponent.getInstance().setValue(BULK_MOVE_TABLE_VISIBLE, \"false\");\n      }\n    };\n    decorator.setOn(tableIsVisible);\n    decorator.setContentComponent(ScrollPaneFactory.createScrollPane(myMemberSelectionTable));\n    validateButtons();\n    init();\n  }","commit_id":"12b4abb3ce34b3281b5b18ad48e2a86403b8138b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Performs operation opposite to the {@link #expandNamedElementBody}, in particular it shrinks assignment statement back\n   * to the first target expression.\n   *\n   * @see #expandNamedElementBody(PsiNamedElement)\n   */\n  @Nullable\n  public static PsiNamedElement extractNamedElement(@NotNull PsiElement element) {\n    if (element instanceof PyClass || element instanceof PyFunction) {\n      return (PsiNamedElement)element;\n    }\n    final PyAssignmentStatement assignment = as(element, PyAssignmentStatement.class);\n    if (assignment != null) {\n      return as(assignment.getTargets()[0], PyTargetExpression.class);\n    }\n    return null;\n  }","id":33879,"modified_method":"/**\n   * Performs operation opposite to the {@link #expandNamedElementBody}, in particular it shrinks assignment statement back\n   * to the first target expression.\n   *\n   * @see #expandNamedElementBody(PsiNamedElement)\n   */\n  @Nullable\n  public static PsiNamedElement extractNamedElement(@NotNull PsiElement element) {\n    if (element instanceof PyClass || element instanceof PyFunction || element instanceof PyTargetExpression) {\n      return (PsiNamedElement)element;\n    }\n    final PyAssignmentStatement assignment = as(element, PyAssignmentStatement.class);\n    if (assignment != null) {\n      return as(assignment.getTargets()[0], PyTargetExpression.class);\n    }\n    return null;\n  }","commit_id":"12b4abb3ce34b3281b5b18ad48e2a86403b8138b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void doMove(final Project project, PsiElement[] elements, PsiElement targetContainer, MoveCallback callback) {\n\n    MoveFilesOrDirectoriesUtil\n      .doMove(project, elements, new PsiElement[]{targetContainer}, callback, new Function<PsiElement[], PsiElement[]>() {\n        @Override\n        public PsiElement[] fun(final PsiElement[] elements) {\n          return new WriteCommandAction<PsiElement[]>(project, \"Regrouping ...\") {\n            @Override\n            protected void run(Result<PsiElement[]> result) throws Throwable {\n              final List<PsiElement> adjustedElements = new ArrayList<PsiElement>();\n              for (int i = 0, length = elements.length; i < length; i++) {\n                PsiElement element = elements[i];\n                if (element instanceof PsiClass) {\n                  final PsiClass topLevelClass = PsiUtil.getTopLevelClass(element);\n                  if (topLevelClass != null) {\n                    elements[i] = topLevelClass;\n                    final PsiFile containingFile = obtainContainingFile(topLevelClass, elements);\n                    if (containingFile != null && !adjustedElements.contains(containingFile)) {\n                      adjustedElements.add(containingFile);\n                      continue;\n                    }\n                  } \n                }\n                adjustedElements.add(element);\n              }\n              result.setResult(PsiUtilCore.toPsiElementArray(adjustedElements));\n            }\n          }.execute().getResultObject();\n        }\n      });\n  }","id":33880,"modified_method":"@Override\n  public void doMove(final Project project, PsiElement[] elements, PsiElement targetContainer, MoveCallback callback) {\n\n    elements = adjustForMove(project, elements, targetContainer);\n    if (elements == null) {\n      return;\n    }\n    MoveFilesOrDirectoriesUtil\n      .doMove(project, elements, new PsiElement[]{targetContainer}, callback, new Function<PsiElement[], PsiElement[]>() {\n        @Override\n        public PsiElement[] fun(final PsiElement[] elements) {\n          return new WriteCommandAction<PsiElement[]>(project, \"Regrouping ...\") {\n            @Override\n            protected void run(Result<PsiElement[]> result) throws Throwable {\n              final List<PsiElement> adjustedElements = new ArrayList<PsiElement>();\n              for (int i = 0, length = elements.length; i < length; i++) {\n                PsiElement element = elements[i];\n                if (element instanceof PsiClass) {\n                  final PsiClass topLevelClass = PsiUtil.getTopLevelClass(element);\n                  if (topLevelClass != null) {\n                    elements[i] = topLevelClass;\n                    final PsiFile containingFile = obtainContainingFile(topLevelClass, elements);\n                    if (containingFile != null && !adjustedElements.contains(containingFile)) {\n                      adjustedElements.add(containingFile);\n                      continue;\n                    }\n                  }\n                }\n                adjustedElements.add(element);\n              }\n              result.setResult(PsiUtilCore.toPsiElementArray(adjustedElements));\n            }\n          }.execute().getResultObject();\n        }\n      });\n  }","commit_id":"aa9a7b18bcc3b098fd69ce49560b4f775887c2e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public PsiElement[] adjustForMove(Project project, PsiElement[] sourceElements, PsiElement targetElement) {\n    Set<PsiElement> result = new LinkedHashSet<PsiElement>();\n    for (PsiElement sourceElement : sourceElements) {\n      result.add(sourceElement instanceof PsiClass ? sourceElement.getContainingFile() : sourceElement);\n    }\n    return PsiUtilCore.toPsiElementArray(result);\n  }","id":33881,"modified_method":"@Override\n  public PsiElement[] adjustForMove(Project project, PsiElement[] sourceElements, PsiElement targetElement) {\n    sourceElements = super.adjustForMove(project, sourceElements, targetElement);\n    if (sourceElements == null) {\n      return null;\n    }\n\n    Set<PsiElement> result = new LinkedHashSet<PsiElement>();\n    for (PsiElement sourceElement : sourceElements) {\n      result.add(sourceElement instanceof PsiClass ? sourceElement.getContainingFile() : sourceElement);\n    }\n    return PsiUtilCore.toPsiElementArray(result);\n  }","commit_id":"aa9a7b18bcc3b098fd69ce49560b4f775887c2e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean canMove(final PsiElement[] elements, final PsiElement targetContainer) {\n    HashSet<String> names = new HashSet<String>();\n    for (PsiElement element : elements) {\n      if (element instanceof PsiFile) {\n        PsiFile file = (PsiFile)element;\n        String name = file.getName();\n        if (names.contains(name)) {\n          return false;\n        }\n        names.add(name);\n      }\n      else if (!(element instanceof PsiDirectory)) {\n        return false;\n      }\n    }\n\n    PsiElement[] filteredElements = PsiTreeUtil.filterAncestors(elements);\n    if (filteredElements.length != elements.length) {\n      // there are nested dirs\n      return false;\n    }\n    return super.canMove(elements, targetContainer);\n  }","id":33882,"modified_method":"@Override\n  public boolean canMove(final PsiElement[] elements, final PsiElement targetContainer) {\n    HashSet<String> names = new HashSet<String>();\n    for (PsiElement element : elements) {\n      if (element instanceof PsiFile) {\n        PsiFile file = (PsiFile)element;\n        String name = file.getName();\n        if (names.contains(name)) {\n          return false;\n        }\n        names.add(name);\n      }\n      else if (!(element instanceof PsiDirectory)) {\n        return false;\n      }\n    }\n\n    return super.canMove(elements, targetContainer);\n  }","commit_id":"aa9a7b18bcc3b098fd69ce49560b4f775887c2e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void doMove(final Project project, final PsiElement[] elements, final PsiElement targetContainer, @Nullable final MoveCallback callback) {\n    if (!LOG.assertTrue(targetContainer == null || targetContainer instanceof PsiDirectory || targetContainer instanceof PsiDirectoryContainer,\n                        \"container: \" + targetContainer + \"; elements: \" + Arrays.toString(elements) + \"; working handler: \" + toString())) {\n      return;\n    }\n    MoveFilesOrDirectoriesUtil.doMove(project, adjustForMove(project, elements, targetContainer), new PsiElement[] {targetContainer}, callback);\n  }","id":33883,"modified_method":"@Override\n  public void doMove(final Project project, final PsiElement[] elements, final PsiElement targetContainer, @Nullable final MoveCallback callback) {\n    if (!LOG.assertTrue(targetContainer == null || targetContainer instanceof PsiDirectory || targetContainer instanceof PsiDirectoryContainer,\n                        \"container: \" + targetContainer + \"; elements: \" + Arrays.toString(elements) + \"; working handler: \" + toString())) {\n      return;\n    }\n    final PsiElement[] adjustedElements = adjustForMove(project, elements, targetContainer);\n    if (adjustedElements != null) {\n      MoveFilesOrDirectoriesUtil.doMove(project, adjustedElements, new PsiElement[] {targetContainer}, callback);\n    }\n  }","commit_id":"aa9a7b18bcc3b098fd69ce49560b4f775887c2e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Component getTreeCellRendererComponent(\n                        JTree tree,\n                        Object value,\n                        boolean sel,\n                        boolean expanded,\n                        boolean leaf,\n                        int row,\n                        boolean hasFocus) \n        {\n            super.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus);\n\n            tufts.oki.hierarchy.HierarchyNode hierarchyNode = (tufts.oki.hierarchy.HierarchyNode)(((DefaultMutableTreeNode)value).getUserObject());\n            LWComponent component = hierarchyNode.getLWComponent();\n            \n            if (component instanceof LWNode)\n              setIcon(nodeIcon);\n            \n            else if (component instanceof LWLink)\n              setIcon(linkIcon);\n           \n            return this;\n        }","id":33884,"modified_method":"public Component getTreeCellRendererComponent(\n                        JTree tree,\n                        Object value,\n                        boolean sel,\n                        boolean expanded,\n                        boolean leaf,\n                        int row,\n                        boolean hasFocus) \n        {\n            super.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus);\n\n            if (((DefaultMutableTreeNode)value).getUserObject() instanceof tufts.oki.hierarchy.HierarchyNode)\n            {\n                tufts.oki.hierarchy.HierarchyNode hierarchyNode = (tufts.oki.hierarchy.HierarchyNode)(((DefaultMutableTreeNode)value).getUserObject());\n                LWComponent component = hierarchyNode.getLWComponent();\n            \n                if (component instanceof LWNode)\n                  setIcon(nodeIcon);\n            \n                else if (component instanceof LWLink)\n                  setIcon(linkIcon);\n            }\n            \n            return this;\n        }","commit_id":"91609cab31088f7c60a24b0b5b8403d5584bfa26","url":"https://github.com/VUE/VUE"},{"original_method":"public void emptyPanel(){\r\n    if (this.mbsc!=null){\r\n      try{\r\n        mbsc.removeNotificationListener(this.osgiON, this);\r\n        this.mbsc=null;\r\n        this.removeAll();\r\n      }catch(Exception e){\r\n        e.printStackTrace();\r\n      }\r\n    }\r\n  }","id":33885,"modified_method":"public void emptyPanel(){\r\n    if (this.mbsc!=null){\r\n      try{\r\n        mbsc.removeNotificationListener(this.osgiON, this);\r\n      }catch(Exception e){\r\n        e.printStackTrace();\r\n      }\r\n      this.mbsc=null;\r\n      this.removeAll();\r\n    }\r\n  }","commit_id":"1e7aea39c9fbbd441fa513cca310a0ef9da7b10e","url":"https://github.com/apache/felix"},{"original_method":"public Component getTreeCellRendererComponent(JTree tree, Object value, boolean sel, boolean expanded, boolean leaf, int row, boolean hasFocus) {\n    super.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus);\n    String val=value.toString();\n    if (!val.equals(NodesTree.TOP_NAME)){ \n      if (nodesTree.isNodeConnected(val)){\n        setIcon(iconConnected);\n      }else{\n        setIcon(iconStopped);\n      }\n    }\n    return this;\n  }","id":33886,"modified_method":"public Component getTreeCellRendererComponent(JTree tree, Object value, boolean sel, boolean expanded, boolean leaf, int row, boolean hasFocus) {\n    Object o = ((DefaultMutableTreeNode) value).getUserObject();\n    if ( !o.equals(NodesTree.TOP_NAME) ) {\n      Gateway g = (Gateway) o;\n      super.getTreeCellRendererComponent(tree, g.getName(), sel, expanded, leaf, row, hasFocus);\n      if ( g.isConnected() ) {\n        setIcon(iconConnected);\n      } else {\n        setIcon(iconStopped);\n      }\n      setToolTipText(g.getToolTipText());\n    } else {\n      super.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus);\n    }\n    return this;\n  }","commit_id":"1e7aea39c9fbbd441fa513cca310a0ef9da7b10e","url":"https://github.com/apache/felix"},{"original_method":"public MyButton(char c, String name, NodesTree listener, JPanel panel) {\n      super.setText(name);\n      super.setMnemonic(c);\n      super.setMinimumSize(new Dimension(W, H));\n      super.setPreferredSize(new Dimension(W, H));\n      super.setMaximumSize(new Dimension(W, H));\n      super.addActionListener(listener);\n      panel.add(this);\n    }","id":33887,"modified_method":"public MyButton(char c, String iconName, String ttt, NodesTree listener, JPanel panel) {\n      super(new ImageIcon(Toolkit.getDefaultToolkit().getImage(bc.getBundle().getResource(\"images/\"+iconName))));\n      super.setMnemonic(c);\n      super.setToolTipText(ttt);\n      super.setBorder(null);\n      super.setPreferredSize(new Dimension(W, H));\n      super.addActionListener(listener);\n      panel.add(this);\n    }","commit_id":"1e7aea39c9fbbd441fa513cca310a0ef9da7b10e","url":"https://github.com/apache/felix"},{"original_method":"public void runDiscovery(){\n    this.createDefaultNodes();\n    poolThread=new Thread(this.pt);\n    poolThread.start();\n  }","id":33888,"modified_method":"public void runDiscovery(){\n    Gateway[] g = Gateway.newGateways(bc);\n    for (int i = 0 ; i < g.length ; i++) {\n      this.createTreeNode(g[i]);\n    }\n    (new Thread(this.pt)).start();\n    tree.expandPath(new TreePath(((DefaultMutableTreeNode)(dtm.getRoot())).getPath())); // expand root node\n  }","commit_id":"1e7aea39c9fbbd441fa513cca310a0ef9da7b10e","url":"https://github.com/apache/felix"},{"original_method":"private JPanel createButtonPanel(){\n    JPanel buttonPanel=new JPanel(new FlowLayout(FlowLayout.CENTER,2,2));\n    //border...\n    addNodeButton=new MyButton('a', \" + \", this, buttonPanel);\n    removeNodeButton=new MyButton('d', \" - \", this, buttonPanel);\n    return buttonPanel;\n  }","id":33889,"modified_method":"private JPanel createButtonPanel(){\n    JPanel buttonPanel = new JPanel();\n    buttonPanel.setLayout(new BoxLayout(buttonPanel, BoxLayout.X_AXIS));\n    //border...\n    buttonPanel.add(Box.createHorizontalGlue());\n    jb_addNode = new MyButton('a', \"ADD.gif\", \"Add a gateway\", this, buttonPanel);\n    buttonPanel.add(Box.createRigidArea(new Dimension(2,0)));\n    jb_removeNode = new MyButton('d', \"REMOVE.gif\", \"Remove selected gateway\", this, buttonPanel);\n    buttonPanel.add(Box.createHorizontalGlue());\n    buttonPanel.add(Box.createRigidArea(new Dimension(2,0)));\n    buttonPanel.add(Box.createHorizontalGlue());\n    jtf_pool = new JTextField(\"\"+POOLING_TIME);\n    jtf_pool.addActionListener(this);\n    jtf_pool.setToolTipText(\"<html>Pooling time in millisecond<br>Value range is 500 to 9999<br>A value of 0 means no refresh.<\/html>\");\n    jtf_pool.setPreferredSize(new Dimension(40,21));\n    jtf_pool.setMaximumSize(new Dimension(40,21));\n    buttonPanel.add(jtf_pool);\n    buttonPanel.add(Box.createRigidArea(new Dimension(2,0)));\n    jb_refresh = new JButton(new ImageIcon(Toolkit.getDefaultToolkit().getImage(bc.getBundle().getResource(\"images/\"+\"REFRESH.gif\"))));\n    jb_refresh.setOpaque(true);\n    jb_refresh.setToolTipText(\"<html>Try to connect gateways now.<br>Enable only if there is no pooling time.<\/html>\");\n    jb_refresh.addActionListener(this);\n    jb_refresh.setPreferredSize(new Dimension(18, 18));\n    jb_refresh.setEnabled(false);\n    buttonPanel.add(jb_refresh);\n    buttonPanel.add(Box.createHorizontalGlue());\n    return buttonPanel;\n  }","commit_id":"1e7aea39c9fbbd441fa513cca310a0ef9da7b10e","url":"https://github.com/apache/felix"},{"original_method":"public void propertyChange(PropertyChangeEvent event) {\n    if (event.getPropertyName().equals(CommonPlugin.COMMON_PLUGIN_ADDED)) {\n      Enumeration enu=connectedNodes.keys();\n      while (enu.hasMoreElements()) {\n        // Common plugin added after a gateway connection so firePCE(Plugin.NEW_NODE_CONNECTION, connString , mbsc) again :\n        String key=(String) enu.nextElement();\n        System.out.println(\"   \"+key+\"=\"+connectedNodes.get(key));\n        a.firePropertyChangedEvent(Plugin.NEW_NODE_CONNECTION, key, connectedNodes.get(key));\n      }\n    }\n  }","id":33890,"modified_method":"public void propertyChange(PropertyChangeEvent event) {\n    if (event.getPropertyName().equals(CommonPlugin.COMMON_PLUGIN_ADDED)) {\n      Enumeration enu = top.breadthFirstEnumeration();\n      enu.nextElement(); // Skip top node\n      while ( enu.hasMoreElements() ) {\n        // Common plugin added after a gateway connection so firePCE(Plugin.NEW_NODE_CONNECTION, connString , mbsc) again :\n\tGateway g = (Gateway) ((DefaultMutableTreeNode) enu.nextElement()).getUserObject();\n\tif ( g.isConnected() ) {\n          activator.firePropertyChangedEvent(Plugin.NEW_NODE_CONNECTION, g.toString(), g.getMbsc());\n        }\n      }\n    }\n  }","commit_id":"1e7aea39c9fbbd441fa513cca310a0ef9da7b10e","url":"https://github.com/apache/felix"},{"original_method":"protected void tryToConnectAllNodes(){\n    //boolean oldTreeState=isAllNodesConnected;\n    isAllNodesConnected=true;\n    String connString=\"\";\n    Enumeration enu=top.breadthFirstEnumeration();\n    while (enu.hasMoreElements()) {\n      DefaultMutableTreeNode dmtn_tmp=(DefaultMutableTreeNode) enu.nextElement();\n      if (dmtn_tmp!=top) {\n        connString=(String) dmtn_tmp.getUserObject();\n        if (!this.connectToNode(connString)) {\n          isAllNodesConnected=false;\n        }\n      }\n    }\n    /*Enumeration dmtns_std=top.children();\n    while (dmtns_std.hasMoreElements()){\n      DefaultMutableTreeNode dmtn_std=(DefaultMutableTreeNode) dmtns_std.nextElement();\n      connString=(String) dmtn_std.getUserObject();\n      //System.out.println(\"   -connectToNode(\"+connString+\")\");\n      if (!this.connectToNode(connString)) {\n        isAllNodesConnected=false;\n      }\n      Enumeration dmtns_virtual=dmtn_std.children();\n      while (dmtns_virtual.hasMoreElements()){\n        DefaultMutableTreeNode dmtn_virtual=(DefaultMutableTreeNode) dmtns_virtual.nextElement();\n        connString=(String) dmtn_virtual.getUserObject();\n\t//System.out.println(\"      -connectToNode(\"+connString+\")\");\n        if (!this.connectToNode(connString)) {\n          isAllNodesConnected=false;\n        }\n      }\n    }*/\n    //if(oldTreeState!=isAllNodesConnected){\n    //  System.out.println(\"AllNodesConnected=\"+isAllNodesConnected);\n    //}\n  }","id":33891,"modified_method":"private void tryToConnectAllNodes(){\n    isAllNodesConnected = true;\n    Enumeration enu = top.breadthFirstEnumeration();\n    enu.nextElement(); // Skip top node\n    while ( enu.hasMoreElements() ) {\n      Gateway g = (Gateway) (((DefaultMutableTreeNode) enu.nextElement()).getUserObject());\n      if ( !g.isConnected() ) {\n        if ( !g.connect(this) ) {\n          isAllNodesConnected = false;\n        } else {\n          tree.treeDidChange();\n          activator.firePropertyChangedEvent(Plugin.NEW_NODE_CONNECTION, g.toString(), g.getMbsc());\n          // If new connected is the selected one then create a false valueChanged in order to load the NodePanel :\n          DefaultMutableTreeNode selected_node = (DefaultMutableTreeNode) tree.getLastSelectedPathComponent();\n          if ( selected_node != null &&  !selected_node.equals(top) ) {\n            Gateway g_selected = (Gateway) (selected_node.getUserObject());\n            if ( g_selected == g ) {\n\t      this.valueChanged(null);\n\t    } else {\n\t    }\n\t  }\n\t}\n      }\n    }\n  }","commit_id":"1e7aea39c9fbbd441fa513cca310a0ef9da7b10e","url":"https://github.com/apache/felix"},{"original_method":"public void run(){\n      while (cont){\n        if (!isAllNodesConnected) {\n\t  tryToConnectAllNodes();\n          tree.treeDidChange();\n        } \n\ttry{\n          Thread.sleep(POOLING_TIME);\n        }catch(InterruptedException e){\n          e.printStackTrace();\n        }\n      }\n    }","id":33892,"modified_method":"public void run() {\n      while ( cont ) {\n        if ( !isAllNodesConnected && POOLING_TIME > 0 ) {\n\t  tryToConnectAllNodes();\n        } \n\ttry {\n          Thread.sleep(POOLING_TIME);\n        } catch(InterruptedException e) {\n          //e.printStackTrace();\n        }\n      }\n    }","commit_id":"1e7aea39c9fbbd441fa513cca310a0ef9da7b10e","url":"https://github.com/apache/felix"},{"original_method":"public NodesTree(Activator a,BundleContext bc) {\n    super(new BorderLayout());\n    this.a=a;\n    this.bc=bc;\n    this.pt=new PoolingThread();\n    \n    System.setProperty(\"java.security.policy\", \"client.policy\");\n    top=new DefaultMutableTreeNode(NodesTree.TOP_NAME);\n    dtm=new DefaultTreeModel(top);\n    tree=new JTree(dtm);\n    tree.setCellRenderer(ncr=new NodeCellRenderer(bc,this));\n    tree.addTreeSelectionListener(this);\n    tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);\n\n    JScrollPane treeView=new JScrollPane(tree);\n    add(createButtonPanel(), BorderLayout.NORTH);\n    add(treeView, BorderLayout.CENTER);\n  }","id":33893,"modified_method":"public NodesTree(Activator activator, BundleContext bc) {\n    super(new BorderLayout());\n    this.activator = activator;\n    this.bc = bc;\n    this.pt = new PoolingThread();\n    \n    System.setProperty(\"java.security.policy\", \"client.policy\");\n    top = new DefaultMutableTreeNode(NodesTree.TOP_NAME);\n    dtm = new DefaultTreeModel(top);\n    tree = new JTree(dtm);\n    tree.setCellRenderer(new NodeCellRenderer(bc, this));\n    tree.addTreeSelectionListener(this);\n    tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);\n    javax.swing.ToolTipManager.sharedInstance().registerComponent(tree);\n\n    JScrollPane treeView = new JScrollPane(tree);\n    add(createButtonPanel(), BorderLayout.NORTH);\n    add(treeView, BorderLayout.CENTER);\n  }","commit_id":"1e7aea39c9fbbd441fa513cca310a0ef9da7b10e","url":"https://github.com/apache/felix"},{"original_method":"public void actionPerformed(ActionEvent e) {\n    // TODO : \n    Object object = e.getSource();\n    if (object==addNodeButton) { // Add a new node into tree\n      String connString = JOptionPane.showInputDialog(\"Please input a connection string : \", \"127.0.0.1:1099/vosgi\");\n      TreePath tp=tree.getSelectionPath();\n      if (connString!=null) {\n\tcreateTreeNode(connString,null,null);\n\tdtm.reload(top);\n\tisAllNodesConnected=false;\n\ttree.setSelectionPath(tp);\n      }\n    } else if (object==removeNodeButton) { // Remove a nod from tree\n      DefaultMutableTreeNode node = (DefaultMutableTreeNode)tree.getLastSelectedPathComponent();\n      String connString=(String) node.getUserObject();\n      if (connString!=null){\n        if (!node.equals(top)){\n\t  if(JOptionPane.showConfirmDialog(null,\"Sure we remove \\\"\"+connString+\"\\\" node ?\")==JOptionPane.YES_OPTION) {\n\t    if (top.getChildCount()>1){\n              disconnectFromNode(connString);\n\t      dtm.removeNodeFromParent(node);\n\t      System.out.println(\"Remove node : \"+(String) (node.getUserObject()));\n\t    }\n          }\n\t}\n      }\n    }\n  }","id":33894,"modified_method":"public void actionPerformed(ActionEvent ae) {\n    Object object = ae.getSource();\n    if ( object == jb_addNode ) { // Add a new node into tree\n      Gateway g = Gateway.newGateway();\n      if ( g != null ) {\n        TreePath tp = tree.getSelectionPath();\n        this.createTreeNode(g);\n        dtm.reload(top);\n        isAllNodesConnected = false;\n        tree.setSelectionPath(tp);\n      }\n    } else if ( object == jb_removeNode ) { // Remove a node from tree\n      DefaultMutableTreeNode node = (DefaultMutableTreeNode)tree.getLastSelectedPathComponent();\n      if ( node != top) {\n        Gateway g = (Gateway) node.getUserObject();\n        if ( !node.equals(top) ){\n\t  if( JOptionPane.showConfirmDialog(null, \"Sure we remove this gateway \\\"\"+g.getName()+\"\\\" ?\\n \"+g.toString()) == JOptionPane.YES_OPTION ) {\n            g.disconnect(this);\n\t    dtm.removeNodeFromParent(node);\n\t    System.out.println(\"Remove node : \"+g);\n          }\n\t}\n      }\n    } else if ( object == jtf_pool) {\n      try {\n        POOLING_TIME = Integer.parseInt(jtf_pool.getText());\n\tif ( POOLING_TIME > 0 & POOLING_TIME < 500 ) {\n          POOLING_TIME = 500;\n\t} else if ( POOLING_TIME < 0 ) {\n\t  POOLING_TIME = 0;\n\t} else if ( POOLING_TIME > 9999 ) {\n          POOLING_TIME = 9999;\n\t}\n      } catch (Exception exep) {\n        //\n      }\n      if ( POOLING_TIME >= 500 ) {\n        jb_refresh.setEnabled(false);\n      } else {\n        jb_refresh.setEnabled(true);\n      }\n      jtf_pool.setText(\"\"+POOLING_TIME);\n    } else if ( object == jb_refresh) {\n      tryToConnectAllNodes();\n    }\n  }","commit_id":"1e7aea39c9fbbd441fa513cca310a0ef9da7b10e","url":"https://github.com/apache/felix"},{"original_method":"private boolean connectToNode(String connString){\n    Object ls=this.connectedNodes.get(connString);\n    if (ls==null){\n      JMXConnector jmxc=null;\n      try {\n        JMXServiceURL surl=new JMXServiceURL(NodesTree.JMX_SERVICE_URL+connString);\n/*\nThread.currentThread().setContextClassLoader(this.getClass().getClassLoader());\nSystem.out.println(\"=====> \"+java.util.logging.Logger.getLogger(\"javax.management.remote.misc\"));\njava.util.logging.Logger.getLogger(\"javax.management.remote.misc\").setLevel(java.util.logging.Level.FINEST);\njava.util.logging.Logger.getLogger(\"javax.management.remote.rmi\").setLevel(java.util.logging.Level.FINEST);\n\njava.util.logging.ConsoleHandler ch=new java.util.logging.ConsoleHandler();\nch.setLevel(java.util.logging.Level.FINEST);\njava.util.logging.Logger.getLogger(\"javax.management.remote.misc\").addHandler(ch);\njava.util.logging.Logger.getLogger(\"javax.management.remote.rmi\").addHandler(ch);\n*/\t\t\t\t\n        jmxc = JMXConnectorFactory.connect(surl);\n        MBeanServerConnection mbsc = jmxc.getMBeanServerConnection();\n        if (mbsc.isRegistered(new ObjectName(\"OSGI:name=Remote Logger\"))){\n          jmxc.addConnectionNotificationListener(this, null, connString);\n          mbsc.addNotificationListener(new ObjectName(\"TabUI:name=OsgiProbes\"), this, null, null); //Needed ???\n          this.connectedNodes.put(connString, mbsc);\n          this.jmxConnectors.put(connString, jmxc);\n          a.firePropertyChangedEvent(Plugin.NEW_NODE_CONNECTION, connString, mbsc);\n\t  // If new connected is the selected one then create a false valueChanged in order to load the NodePanel :\n\t  DefaultMutableTreeNode node = (DefaultMutableTreeNode)tree.getLastSelectedPathComponent(); \n\t  if (node!=null) {\n  \t    if (connString.equals((String)node.getUserObject())){\n\t      this.valueChanged(null);\n            }\n\t  }\n\t  System.out.println(\"Node \"+connString+\" connected\");\n\t  return true;\n        }else {\n          System.out.println(\"The Remote Logger of \"+connString+\" is not started\");\n\t  return false;\n        }\n      }catch(java.io.IOException ex){\n        //System.out.println(\"Impossible to connect to \"+connString);\n      }catch(MalformedObjectNameException e){\n        e.printStackTrace();\n      }catch(Exception e){\n\t//use one thread per node to avoid being freeze by a timeOutConnection\n\tSystem.out.println(\"gui.NodesTree.connectToNode(\"+connString+\") : \"+e);\n\tSystem.out.println(\"  => Delete this node ? to implement... ?\");\n\n      }\n    }else{\n      return true;\n    }\n  return false;\n  }","id":33895,"modified_method":"private void createTreeNode(Gateway g) {\n    DefaultMutableTreeNode dmtn = new DefaultMutableTreeNode(g);\n    DefaultMutableTreeNode parentNode = null;\n    Gateway parent = g.getParent();\n    if ( parent != null ) {\n      Enumeration enu = top.breadthFirstEnumeration();\n      while ( enu.hasMoreElements() ) {\n        DefaultMutableTreeNode dmtn_tmp = (DefaultMutableTreeNode) enu.nextElement();\n        if ( dmtn_tmp.getUserObject().equals(parent) ) {\n          parentNode = dmtn_tmp;\n          break;\n        }\n      }\n    }\n    if ( parentNode == null ) { parentNode = top; }\n    parentNode.add(dmtn);\n  }","commit_id":"1e7aea39c9fbbd441fa513cca310a0ef9da7b10e","url":"https://github.com/apache/felix"},{"original_method":"public void valueChanged(TreeSelectionEvent e) {\n    //System.out.println(\"Value changed : e=\"+e);\n    DefaultMutableTreeNode node = (DefaultMutableTreeNode)tree.getLastSelectedPathComponent();\n    if (node!=null) {\n      String selectedNode=(String)node.getUserObject();\n      if (!selectedNode.equals(NodesTree.TOP_NAME)){\n        Object mbsc=connectedNodes.get(selectedNode);\n        if (mbsc!=null){\n\t  //tryToConnectAllNodes();\n\t  //createDefaultNodes(false);\n          a.firePropertyChangedEvent(Plugin.NEW_NODE_SELECTED, selectedNode, mbsc);\n        }else{\n          a.firePropertyChangedEvent(Plugin.EMPTY_NODE, null, \"null\");\n        }\n      }\n    }\n  }","id":33896,"modified_method":"public void valueChanged(TreeSelectionEvent e) {\n    DefaultMutableTreeNode node = (DefaultMutableTreeNode)tree.getLastSelectedPathComponent();\n    if (node!=null) {\n      Object selected = node.getUserObject();\n      if ( !selected.equals(NodesTree.TOP_NAME) ) {\n        Gateway g = (Gateway) selected;\n        Object mbsc = g.getMbsc();\n        if ( mbsc != null ){\n          activator.firePropertyChangedEvent(Plugin.NEW_NODE_SELECTED, g.toString(), mbsc);\n        } else {\n          activator.firePropertyChangedEvent(Plugin.EMPTY_NODE, null, \"null\");\n        }\n      }\n    }\n  }","commit_id":"1e7aea39c9fbbd441fa513cca310a0ef9da7b10e","url":"https://github.com/apache/felix"},{"original_method":"public void handleNotification(Notification notification, Object handback) {\n    //    System.out.println(\"Connection ==> \"+notification.getMessage()+\":\"+((JMXConnectionNotification)notification).getConnectionId()+\":\"+handback);\n    if ( !JMXConnectionNotification.OPENED.equals(notification.getType()) ){\n      this.disconnectFromNode((String)handback);\n      tree.treeDidChange();\n      isAllNodesConnected=false;\n    }\n  }","id":33897,"modified_method":"public void handleNotification(Notification notification, Object handback) {\n    //System.out.println(\"Connection ==> \"+notification.getMessage()+\":\"+((JMXConnectionNotification)notification).getConnectionId()+\":\"+handback);\n    if ( !JMXConnectionNotification.OPENED.equals(notification.getType()) ){\n      Enumeration enu = top.breadthFirstEnumeration();\n      enu.nextElement(); // Skip top node\n      while ( enu.hasMoreElements() ) {\n        Object o = ((DefaultMutableTreeNode) enu.nextElement()).getUserObject();\n\tGateway g = (Gateway) o;\n\tif ( g.toString().equals(handback.toString()) ) {\n\t  if ( g.isConnected() ) {\n\t    g.disconnect(this);\n\t    DefaultMutableTreeNode selectedNode = (DefaultMutableTreeNode) tree.getLastSelectedPathComponent(); \n\t    if ( selectedNode != null ) {\n\t      Gateway g_selected = (Gateway) selectedNode.getUserObject();\n\t      if ( g_selected.toString().equals(g.toString()) ) {\n\t        activator.firePropertyChangedEvent(Plugin.EMPTY_NODE, null, \"null\");\n\t      }\n\t    }\n            tree.treeDidChange();\n            isAllNodesConnected = false;\n\t  }\n\t}\n      }\n    }\n  }","commit_id":"1e7aea39c9fbbd441fa513cca310a0ef9da7b10e","url":"https://github.com/apache/felix"},{"original_method":"public void handleNotification(Notification notification, Object handback) {\n    StringTokenizer st = new StringTokenizer(notification.getMessage(),\"*\");\n    \n    long ts=notification.getTimeStamp();\n    String date=JtreeCellRenderer.UNKNOWN_DATE; //\"??/??/??\";\n    String time=JtreeCellRenderer.UNKNOWN_TIME; //\"??/??/??\";\n    if (ts!=0){ // means it's not an old log\n      Date d=new Date(ts);\n      //DateFormat dateFormat = new SimpleDateFormat(\"hh'h'mm dd-MM-yy\");\n      date=DateFormat.getDateInstance(DateFormat.SHORT).format(d);\n      time=DateFormat.getTimeInstance(DateFormat.MEDIUM).format(d);\n    }\n    String id=st.nextToken();\n    String name=st.nextToken();\n    String shortName=name.substring(name.lastIndexOf(\".\")+1,name.length());\n    String state=st.nextToken();\n    String lvl=st.nextToken();\n    String msg=st.nextToken();\n    Object [] event = new Object []{date,time,handback,id,shortName,state,lvl,msg};\n\t\t\t\t    \n    this.insertRow(0,event); \n    this.fireTableRowsInserted(0, 0);\n  }","id":33898,"modified_method":"public void handleNotification(Notification notification, Object handback) {\n    StringTokenizer st = new StringTokenizer(notification.getMessage(),\"*\");\n    \n    long ts=notification.getTimeStamp();\n    String date=JtreeCellRenderer.UNKNOWN_DATE; //\"??/??/??\";\n    String time=JtreeCellRenderer.UNKNOWN_TIME; //\"??/??/??\";\n    if (ts!=0){ // means it's not an old log\n      Date d=new Date(ts);\n      //DateFormat dateFormat = new SimpleDateFormat(\"hh'h'mm dd-MM-yy\");\n      date = dateF.format(d);\n      time = timeF.format(d);\n    }\n    String id=st.nextToken();\n    String name=st.nextToken();\n    String shortName=name.substring(name.lastIndexOf(\".\")+1,name.length());\n    String state=st.nextToken();\n    String lvl=st.nextToken();\n    String msg=st.nextToken();\n    Object [] event = new Object []{date,time,handback,id,shortName,state,lvl,msg};\n\t\t\t\t    \n    this.insertRow(0,event); \n    this.fireTableRowsInserted(0, 0);\n  }","commit_id":"1e7aea39c9fbbd441fa513cca310a0ef9da7b10e","url":"https://github.com/apache/felix"},{"original_method":"public void propertyChange(PropertyChangeEvent e){\n    if (e.getPropertyName().equals(Plugin.NEW_NODE_CONNECTION)){\n      try{\n        MBeanServerConnection mbs=(MBeanServerConnection)e.getNewValue();\n        if (nodes.get(mbs)==null){\n\t  //System.out.println(\"Ajout d'un listener \" +mbs);\n          ((MBeanServerConnection)e.getNewValue()).addNotificationListener(new ObjectName(\"OSGI:name=Remote Logger\"), this, null, e.getOldValue());\n          nodes.put(mbs, \"ok\");\n        }\n      }catch(Exception ex){\n        ex.printStackTrace();\n      }\n    }\n  }","id":33899,"modified_method":"public void propertyChange(PropertyChangeEvent e){\n    if (e.getPropertyName().equals(Plugin.NEW_NODE_CONNECTION)){\n      try{\n        MBeanServerConnection mbs=(MBeanServerConnection)e.getNewValue();\n        if (nodes.get(mbs)==null){\n\t  //System.out.println(\"Ajout d'un listener \" +mbs);\n          ((MBeanServerConnection)e.getNewValue()).addNotificationListener(Activator.REMOTE_LOGGER_ON, this, null, e.getOldValue());\n          nodes.put(mbs, \"ok\");\n        }\n      }catch(Exception ex){\n        ex.printStackTrace();\n      }\n    }\n  }","commit_id":"1e7aea39c9fbbd441fa513cca310a0ef9da7b10e","url":"https://github.com/apache/felix"},{"original_method":"private Integer getLogLvl(String connString) {\n    Integer val=new Integer(0);\n    try {\n      MBeanServerConnection mb=(MBeanServerConnection) ht_connectedGateway.get(connString);\n      val=(Integer) mb.getAttribute(new ObjectName(\"OSGI:name=Remote Logger\"), \"LogLvl\");\n    } catch (Exception exc) {\n      exc.printStackTrace();\n    }\n    return val;\n  }","id":33900,"modified_method":"private Integer getLogLvl(String connString) {\n    Integer val=new Integer(0);\n    try {\n      MBeanServerConnection mb=(MBeanServerConnection) ht_connectedGateway.get(connString);\n      val=(Integer) mb.getAttribute(Activator.REMOTE_LOGGER_ON, \"LogLvl\");\n    } catch (Exception exc) {\n      exc.printStackTrace();\n    }\n    return val;\n  }","commit_id":"1e7aea39c9fbbd441fa513cca310a0ef9da7b10e","url":"https://github.com/apache/felix"},{"original_method":"private void setLogLvl(TreePath tp) {\n    Object[] o=tp.getPath();\n    String connS=\"\"+o[1]+\":\"+o[2];\n    MBeanServerConnection mb=(MBeanServerConnection) ht_connectedGateway.get(connS);\n    try {\n      Integer curentVal=(Integer) mb.getAttribute(new ObjectName(\"OSGI:name=Remote Logger\"), \"LogLvl\");\n\n      JOptionPane jop = new JOptionPane(\"Select a log level for \\\"\"+connS+\"\\\" :\", JOptionPane.QUESTION_MESSAGE, JOptionPane.OK_CANCEL_OPTION, null, LOG_LVL, LOG_LVL[curentVal.intValue()-1]);\n      JDialog dialog = jop.createDialog(jp, \"Log level\");\n      dialog.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE);\n      dialog.show();\n      String choice = (String) jop.getValue();\n      Integer newVal=new Integer(4);\n      if (choice.equals(\"Error\")) {newVal=new Integer(1);}\n      else if (choice.equals(\"Warning\")) {newVal=new Integer(2);}\n      else if (choice.equals(\"Info\")) {newVal=new Integer(3);}\n      else if (choice.equals(\"Debug\")) {newVal=new Integer(4);}\n\n      mb.setAttribute(new ObjectName(\"OSGI:name=Remote Logger\"), new Attribute(\"LogLvl\", newVal));\n      DefaultMutableTreeNode ddmmttnn=(DefaultMutableTreeNode) tp.getLastPathComponent();\n      ht_logLvl.put(ddmmttnn, newVal);\n    } catch (Exception ex) {\n      JOptionPane.showMessageDialog(jp,\"Error with \\\"\"+connS+\"\\\" :\\n\"+ex, \"Error :\", JOptionPane.ERROR_MESSAGE);\n      ex.printStackTrace();\n    }\n  }","id":33901,"modified_method":"private void setLogLvl(TreePath tp) {\n    Object[] o=tp.getPath();\n    String connString = o[1]+\":\"+o[2];\n    try {\n      MBeanServerConnection mb=(MBeanServerConnection) ht_connectedGateway.get(connString);\n      Integer curentVal=(Integer) mb.getAttribute(Activator.REMOTE_LOGGER_ON, \"LogLvl\");\n\n      JOptionPane jop = new JOptionPane(\"Select a log level for \\\"\"+connString+\"\\\" :\", JOptionPane.QUESTION_MESSAGE, JOptionPane.OK_CANCEL_OPTION, null, LOG_LVL, LOG_LVL[curentVal.intValue()-1]);\n      JDialog dialog = jop.createDialog(jp, \"Log level\");\n      dialog.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE);\n      dialog.show();\n      String choice = (String) jop.getValue();\n      Integer newVal=new Integer(4);\n      if (choice.equals(\"Error\")) {newVal=new Integer(1);}\n      else if (choice.equals(\"Warning\")) {newVal=new Integer(2);}\n      else if (choice.equals(\"Info\")) {newVal=new Integer(3);}\n      else if (choice.equals(\"Debug\")) {newVal=new Integer(4);}\n\n      mb.setAttribute(Activator.REMOTE_LOGGER_ON, new Attribute(\"LogLvl\", newVal));\n      DefaultMutableTreeNode ddmmttnn=(DefaultMutableTreeNode) tp.getLastPathComponent();\n      ht_logLvl.put(ddmmttnn, newVal);\n    } catch (Exception ex) {\n      JOptionPane.showMessageDialog(jp,\"Error with \\\"\"+connString+\"\\\" :\\n\"+ex, \"Error :\", JOptionPane.ERROR_MESSAGE);\n      ex.printStackTrace();\n    }\n  }","commit_id":"1e7aea39c9fbbd441fa513cca310a0ef9da7b10e","url":"https://github.com/apache/felix"},{"original_method":"public void handleNotification(Notification notification, Object handback) {\n    StringTokenizer st=new StringTokenizer(handback.toString(), \":\");\n    String ip=st.nextToken();\n    String ref=st.nextToken();\n  \n    st = new StringTokenizer(notification.getMessage(), \"*\");\n    long ts=notification.getTimeStamp();\n    String time=JtreeCellRenderer.UNKNOWN_TIME;\n    String date=JtreeCellRenderer.UNKNOWN_DATE;\n    if (ts!=0) {\n      Date timeDate=new Date(ts);\n      DateFormat dateFormat = new SimpleDateFormat(\"dd-MM-yy\");\n      DateFormat timeFormat = new SimpleDateFormat(\"HH:mm:ss:SSS\");\n      // if I use local date format there are indentations problems\n      //DateFormat df = DateFormat.getTimeInstance(DateFormat.MEDIUM);\n      //DateFormat df2 = DateFormat.getDateInstance(DateFormat.SHORT);\n      time=timeFormat.format(timeDate);\n      date=dateFormat.format(timeDate);\n    }\n    String id=st.nextToken();\n    String name=st.nextToken();\n    String idname=new String(id+\" : \"+name);\n    // bundle state juste after remote loger received a the log entry (in old log case do state=\"\")\n    String state=(String) JtreeCellRenderer.ht_num2string.get(new Integer((int) Integer.parseInt(st.nextToken())));\n    String lvl=st.nextToken();\n    String msg=st.nextToken();\n    // Get and maybe create parents nodes : ip / ref / idname\n    DefaultMutableTreeNode dmtn_ip=createIfNeed(ip, rootNode);\n    DefaultMutableTreeNode dmtn_ref=createIfNeed(ref, dmtn_ip);\n    DefaultMutableTreeNode dmtn_idname=createIfNeed(idname, dmtn_ref);\n    // insert the leaf with message under id/ref/idname\n    DefaultMutableTreeNode dmtn=new DefaultMutableTreeNode(time+\" | \"+date+\" | \"+state+\" | \"+lvl+\" | \"+msg,false);\n    this.insertNodeInto(dmtn, dmtn_idname, 0);\n    // if usefull save nodes which contains new log\n    if ( !v_ul.contains(dmtn_ip) ) {\n\tv_ul.add(dmtn_ip);\n\tv_ul.add(dmtn_ref);\n\tv_ul.add(dmtn_idname);\n    } else if ( !v_ul.contains(dmtn_ref) ) {\n\tv_ul.add(dmtn_ref);\n\tv_ul.add(dmtn_idname);\n    } else if ( !v_ul.contains(dmtn_idname) ) {\n\tv_ul.add(dmtn_idname);\n    }\n    this.logTree.repaint();\n  }","id":33902,"modified_method":"public void handleNotification(Notification notification, Object handback) {\n    String jmxsurl = handback.toString();\n    String ref = jmxsurl.substring(jmxsurl.lastIndexOf(\":\")+1);\n    String ip_tmp = jmxsurl.substring(0, jmxsurl.lastIndexOf(\":\"));\n    String ip = ip_tmp.substring(ip_tmp.lastIndexOf(\"/\")+1);\n  \n    StringTokenizer st = new StringTokenizer(notification.getMessage(), \"*\");\n    long ts=notification.getTimeStamp();\n    String time=JtreeCellRenderer.UNKNOWN_TIME;\n    String date=JtreeCellRenderer.UNKNOWN_DATE;\n    if (ts!=0) {\n      Date timeDate=new Date(ts);\n      // if I use local date format there are indentations problems\n      //DateFormat df = DateFormat.getTimeInstance(DateFormat.MEDIUM);\n      //DateFormat df2 = DateFormat.getDateInstance(DateFormat.SHORT);\n      time=timeFormat.format(timeDate);\n      date=dateFormat.format(timeDate);\n    }\n    String id=st.nextToken();\n    String name=st.nextToken();\n    String idname=new String(id+\" : \"+name);\n    // bundle state juste after remote loger received a the log entry (in old log case do state=\"\")\n    String state=(String) JtreeCellRenderer.ht_num2string.get(new Integer((int) Integer.parseInt(st.nextToken())));\n    String lvl=st.nextToken();\n    String msg=st.nextToken();\n    // Get and maybe create parents nodes : ip / ref / idname\n    DefaultMutableTreeNode dmtn_ip=createIfNeed(ip, rootNode);\n    DefaultMutableTreeNode dmtn_ref=createIfNeed(ref, dmtn_ip);\n    DefaultMutableTreeNode dmtn_idname=createIfNeed(idname, dmtn_ref);\n    // insert the leaf with message under id/ref/idname\n    DefaultMutableTreeNode dmtn=new DefaultMutableTreeNode(time+\" | \"+date+\" | \"+state+\" | \"+lvl+\" | \"+msg,false);\n    this.insertNodeInto(dmtn, dmtn_idname, 0);\n    // if usefull save nodes which contains new log\n    if ( !v_ul.contains(dmtn_ip) ) {\n\tv_ul.add(dmtn_ip);\n\tv_ul.add(dmtn_ref);\n\tv_ul.add(dmtn_idname);\n    } else if ( !v_ul.contains(dmtn_ref) ) {\n\tv_ul.add(dmtn_ref);\n\tv_ul.add(dmtn_idname);\n    } else if ( !v_ul.contains(dmtn_idname) ) {\n\tv_ul.add(dmtn_idname);\n    }\n    this.logTree.repaint();\n  }","commit_id":"1e7aea39c9fbbd441fa513cca310a0ef9da7b10e","url":"https://github.com/apache/felix"},{"original_method":"public void propertyChange(PropertyChangeEvent e){\n    // TODO : DEBUG\n    // Sometimes ???\n    //   *1)  when stay with \"return\" key pressed => JoptionPane miss getValue()\n    //   *2)  when commonPanel started after a new_node_connection event.\n    //        Slow or slowed (by a key pressed for exemple) computer.\n    //        => gui.NodesTree fireNewNodeConnection after each PCE_common_plugin_added for each connected nodes\n    if (e.getPropertyName().equals(Plugin.NEW_NODE_CONNECTION)){\n      try {\n        MBeanServerConnection mbsc=(MBeanServerConnection)e.getNewValue();\n\tif ( !ht_connectedGateway.containsValue(mbsc) ) {\n\t  String connString=(String) e.getOldValue();\n\t  mbsc.addNotificationListener(new ObjectName(\"OSGI:name=Remote Logger\"), this, null, connString);\n\t  ht_connectedGateway.put(connString, mbsc);\n\t  // At gateway connection time : add into the tree an rmiport/profileName node under an ip node\n          String ip=connString.split(\":\")[0];\n          String ref=connString.split(\":\")[1];\n          DefaultMutableTreeNode dmtn_ip=createIfNeed(ip, rootNode);\n          DefaultMutableTreeNode dmtn_ref=createIfNeed(ref, dmtn_ip);\n          Integer lL=this.getLogLvl(connString);\n          ht_logLvl.put(dmtn_ref, lL);\n          // ask for old log management choice :\n          if (oldLogChoice==OLDLOG_THIS_TIME | oldLogChoice==OLDLOG_NOT_THIS_TIME) {\n            JOptionPane jop = new JOptionPane(\"Do you want old log from gateway :\\n\"+connString+\" ?\", JOptionPane.QUESTION_MESSAGE, JOptionPane.OK_CANCEL_OPTION, null, new String[] {OLDLOG_THIS_TIME, OLDLOG_NOT_THIS_TIME, OLDLOG_ALWAYS, OLDLOG_NEVER}, OLDLOG_THIS_TIME);\n            JDialog dialog = jop.createDialog(jp, \"Old log management\");\n\t    //dialog.setModal(true);\n\t    dialog.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE);\n\t    dialog.show();\n\t    oldLogChoice = (String) jop.getValue();\n\t    if (oldLogChoice==JOptionPane.UNINITIALIZED_VALUE) {\n              oldLogChoice=OLDLOG_THIS_TIME; // *1)\n\t    }\n\t  } \n          if (oldLogChoice==OLDLOG_THIS_TIME | oldLogChoice==OLDLOG_ALWAYS) {\n            mbsc.invoke(new ObjectName(\"OSGI:name=Remote Logger\"), \"sendOldLog\", new Object[]{}, new String[]{});\n\t  }\n        }\n      } catch(Exception ex){\n        System.out.println(\"[RemoteLogger_jtree] error : \"+ex);\n      }\n    }\n  }","id":33903,"modified_method":"public void propertyChange(PropertyChangeEvent e){\n    // TODO : DEBUG\n    // Sometimes ???\n    //   *1)  when stay with \"return\" key pressed => JoptionPane miss getValue()\n    //   *2)  when commonPanel started after a new_node_connection event.\n    //        Slow or slowed (by a key pressed for exemple) computer.\n    //        => gui.NodesTree fireNewNodeConnection after each PCE_common_plugin_added for each connected nodes\n    if (e.getPropertyName().equals(Plugin.NEW_NODE_CONNECTION)){\n      try {\n        MBeanServerConnection mbsc=(MBeanServerConnection)e.getNewValue();\n\tif ( !ht_connectedGateway.containsValue(mbsc) ) {\n\t  String jmxsurl = (String) e.getOldValue();\n\t  mbsc.addNotificationListener(Activator.REMOTE_LOGGER_ON, this, null, jmxsurl);\n\t  // At gateway connection time : add into the tree a \"port/profileName\" node under an \"ip\" node\n\t  String ref = jmxsurl.substring(jmxsurl.lastIndexOf(\":\")+1);\n\t  String ip_tmp = jmxsurl.substring(0, jmxsurl.lastIndexOf(\":\"));\n\t  String ip = ip_tmp.substring(ip_tmp.lastIndexOf(\"/\")+1);\n\t  String connString = jmxsurl.substring(ip_tmp.lastIndexOf(\"/\")+1);\n\t  ht_connectedGateway.put(connString, mbsc);\n          DefaultMutableTreeNode dmtn_ip=createIfNeed(ip, rootNode);\n          DefaultMutableTreeNode dmtn_ref=createIfNeed(ref, dmtn_ip);\n          Integer lL = this.getLogLvl(connString);\n          ht_logLvl.put(dmtn_ref, lL);\n          // ask for old log management choice :\n          if (oldLogChoice==OLDLOG_THIS_TIME | oldLogChoice==OLDLOG_NOT_THIS_TIME) {\n            JOptionPane jop = new JOptionPane(\"Do you want old log from gateway :\\n\"+jmxsurl+\" ?\", JOptionPane.QUESTION_MESSAGE, JOptionPane.OK_CANCEL_OPTION, null, new String[] {OLDLOG_THIS_TIME, OLDLOG_NOT_THIS_TIME, OLDLOG_ALWAYS, OLDLOG_NEVER}, OLDLOG_THIS_TIME);\n            JDialog dialog = jop.createDialog(jp, \"Old log management\");\n\t    //dialog.setModal(true);\n\t    dialog.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE);\n\t    dialog.show();\n\t    oldLogChoice = (String) jop.getValue();\n\t    if (oldLogChoice==JOptionPane.UNINITIALIZED_VALUE) {\n              oldLogChoice=OLDLOG_THIS_TIME; // *1)\n\t    }\n\t  } \n          if (oldLogChoice==OLDLOG_THIS_TIME | oldLogChoice==OLDLOG_ALWAYS) {\n            mbsc.invoke(Activator.REMOTE_LOGGER_ON, \"sendOldLog\", new Object[]{}, new String[]{});\n\t  }\n        }\n      } catch(Exception ex){\n        System.out.println(\"[RemoteLogger_jtree] error : \"+ex);\n      }\n    }\n  }","commit_id":"1e7aea39c9fbbd441fa513cca310a0ef9da7b10e","url":"https://github.com/apache/felix"},{"original_method":"public Component getTreeCellRendererComponent(JTree tree, Object value, boolean sel,\n                                                      boolean expanded,boolean leaf,int row, boolean hasFocus)\n        {\n            super.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus);\n\n            final ResourceNode node = (ResourceNode) value;\n            final int level = node.getLevel();\n\n            //if (sel) setBackground(getTextSelectionColor());\n            //else setBackground(Color.white);\n            \n            hasImageIcon = false;\n\n            final Resource r = node.getResource();\n            Icon icon = null;\n\n            if (leaf && level == 1 && r.isImage())\n                icon = r.getContentIcon(tree);\n\n            if (icon == null)\n                icon = r.getTinyIcon();\n            else\n                hasImageIcon = true;\n\n            if (icon != null) {\n\n                setIcon(icon);\n                \n            } else if ( !(node instanceof FileNode) && (node.getResource().getClientType() == FAVORITES)) {\n                if (node.getChildCount() > 0 ) {\n                    setIcon(activeIcon);\n                } else {\n                    setIcon(inactiveIcon);\n                }\n            }\n            \n            else {\n                setIcon(activeIcon);\n            }\n\n            if (level != 1 || row == 0) {\n                setBorder(null);\n            } else if (hasImageIcon) {\n                setBorder(lineBorder);\n                //setIconTextGap(4);\n            } else {\n                setBorder(leftInsetBorder);\n                //setIconTextGap(12);\n            }\n            \n            return this;\n        }","id":33904,"modified_method":"public Component getTreeCellRendererComponent(JTree tree, Object value, boolean sel,\n                                                      boolean expanded,boolean leaf,int row, boolean hasFocus)\n        {\n                    \n            final ResourceNode node = (ResourceNode) value;\n            final Resource r = node.getResource();\n            final int level = node.getLevel();\n\n            if (leaf && level == 1 && r != null && r.isImage() && !r.isLocalFile()) {\n                Icon icon = r.getContentIcon(tree);\n                if (icon != null) {\n                    hasImageIcon = true;\n                    superGetTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus);\n                    setIcon(icon);\n                    setBorder(lineBorder);\n                    return this;\n                }\n            }\n\n            super.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus);\n\n            hasImageIcon = false;\n\n            if (level != 1 || row == 0) {\n                setBorder(null);\n            } else {\n                setBorder(leftInsetBorder);\n            }\n            \n            return this;\n        }","commit_id":"a29ed14d924a750a3a2376b9bd01fbcc70f09d09","url":"https://github.com/VUE/VUE"},{"original_method":"public VueDandDTreeCellRenderer(VueDandDTree pTree) {\n            this.tree = pTree;\n            setAlignmentY(0.5f);            \n            tree.addMouseMotionListener(new MouseMotionAdapter() {\n                public void mouseClicked(MouseEvent me){\n                    if  (me.getClickCount() == 1) {\n                        TreePath treePath = tree.getPathForLocation(me.getX(), me.getY());\n                    }\n                }\n                public void mouseMoved(MouseEvent me) {\n                    TreePath treePath = tree.getPathForLocation(me.getX(), me.getY());\n                }\n            });\n        }","id":33905,"modified_method":"public VueDandDTreeCellRenderer(VueDandDTree pTree) {\n            super(pTree);\n            setAlignmentY(0.5f);            \n            tree.addMouseMotionListener(new MouseMotionAdapter() {\n                public void mouseClicked(MouseEvent me){\n                    if  (me.getClickCount() == 1) {\n                        TreePath treePath = tree.getPathForLocation(me.getX(), me.getY());\n                    }\n                }\n                public void mouseMoved(MouseEvent me) {\n                    TreePath treePath = tree.getPathForLocation(me.getX(), me.getY());\n                }\n            });\n        }","commit_id":"a29ed14d924a750a3a2376b9bd01fbcc70f09d09","url":"https://github.com/VUE/VUE"},{"original_method":"public ScopeEditorPanel(Project project, final NamedScopesHolder holder) {\n    myProject = project;\n    myButtonsPanel.add(createActionsPanel());\n\n    myPackageTree = new Tree();\n    myTreePanel.setLayout(new BorderLayout());\n    myTreePanel.add(ScrollPaneFactory.createScrollPane(myPackageTree), BorderLayout.CENTER);\n\n    myTreeToolbar.setLayout(new BorderLayout());\n    myTreeToolbar.add(createTreeToolbar(), BorderLayout.WEST);\n\n    myTreeExpansionMonitor = TreeExpansionMonitor.install(myPackageTree, myProject);\n\n    myTreeMarker = new TreeModelBuilder.Marker() {\n      public boolean isMarked(PsiFile file) {\n        return myCurrentScope != null && myCurrentScope.contains(file, holder);\n      }\n    };\n\n    myPatternField.getDocument().addDocumentListener(new DocumentAdapter() {\n      public void textChanged(DocumentEvent event) {\n        onTextChange();\n      }\n    });\n\n    myPatternField.addCaretListener(new CaretListener() {\n      public void caretUpdate(CaretEvent e) {\n        myCaretPosition = e.getDot();\n        updateCaretPositionText();\n      }\n    });\n\n    myPatternField.addFocusListener(new FocusListener() {\n      public void focusGained(FocusEvent e) {\n        myCaretPositionLabel.setVisible(true);\n      }\n\n      public void focusLost(FocusEvent e) {\n        myCaretPositionLabel.setVisible(false);\n      }\n    });\n\n    updateTreeModel();\n\n    initTree(myPackageTree);\n  }","id":33906,"modified_method":"public ScopeEditorPanel(Project project, final NamedScopesHolder holder) {\n    myProject = project;\n    myButtonsPanel.add(createActionsPanel());\n\n    myPackageTree = new Tree(new RootNode());\n    myTreePanel.setLayout(new BorderLayout());\n    myTreePanel.add(ScrollPaneFactory.createScrollPane(myPackageTree), BorderLayout.CENTER);\n\n    myTreeToolbar.setLayout(new BorderLayout());\n    myTreeToolbar.add(createTreeToolbar(), BorderLayout.WEST);\n\n    myTreeExpansionMonitor = TreeExpansionMonitor.install(myPackageTree, myProject);\n\n    myTreeMarker = new TreeModelBuilder.Marker() {\n      public boolean isMarked(PsiFile file) {\n        return myCurrentScope != null && myCurrentScope.contains(file, holder);\n      }\n    };\n\n    myPatternField.getDocument().addDocumentListener(new DocumentAdapter() {\n      public void textChanged(DocumentEvent event) {\n        onTextChange();\n      }\n    });\n\n    myPatternField.addCaretListener(new CaretListener() {\n      public void caretUpdate(CaretEvent e) {\n        myCaretPosition = e.getDot();\n        updateCaretPositionText();\n      }\n    });\n\n    myPatternField.addFocusListener(new FocusListener() {\n      public void focusGained(FocusEvent e) {\n        myCaretPositionLabel.setVisible(true);\n      }\n\n      public void focusLost(FocusEvent e) {\n        myCaretPositionLabel.setVisible(false);\n      }\n    });\n\n    initTree(myPackageTree);\n  }","commit_id":"3df49392dade2cfae51465052dfcf93384ac42c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Component getTreeCellRendererComponent(JTree tree,\n                                                  Object value,\n                                                  boolean sel,\n                                                  boolean expanded,\n                                                  boolean leaf,\n                                                  int row,\n                                                  boolean hasFocus) {\n      super.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus);\n      PackageDependenciesNode node = (PackageDependenciesNode)value;\n      if (expanded) {\n        setIcon(node.getOpenIcon());\n      }\n      else {\n        setIcon(node.getClosedIcon());\n      }\n\n      if (!sel && node.hasMarked() && !DependencyUISettings.getInstance().UI_FILTER_LEGALS) {\n        setForeground(node.hasUnmarked() ? PARTIAL_INCLUDED : WHOLE_INCLUDED);\n      }\n\n      return this;\n    }","id":33907,"modified_method":"public Component getTreeCellRendererComponent(JTree tree,\n                                                  Object value,\n                                                  boolean sel,\n                                                  boolean expanded,\n                                                  boolean leaf,\n                                                  int row,\n                                                  boolean hasFocus) {\n      super.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus);\n      if (value instanceof PackageDependenciesNode) {\n        PackageDependenciesNode node = (PackageDependenciesNode)value;\n        if (expanded) {\n          setIcon(node.getOpenIcon());\n        }\n        else {\n          setIcon(node.getClosedIcon());\n        }\n\n        if (!sel && node.hasMarked() && !DependencyUISettings.getInstance().UI_FILTER_LEGALS) {\n          setForeground(node.hasUnmarked() ? PARTIAL_INCLUDED : WHOLE_INCLUDED);\n        }\n      }\n\n      return this;\n    }","commit_id":"3df49392dade2cfae51465052dfcf93384ac42c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Component getTreeCellRendererComponent(JTree tree,Object obj,boolean selected,boolean expanded,boolean leaf,int row,boolean hasFocus){\n    Object userObject=((DefaultMutableTreeNode)obj).getUserObject();\n    if(userObject instanceof SummaryNode){\n      myNodeRenderer.getTreeCellRendererComponent(tree,userObject.toString(),selected,expanded,leaf,row,hasFocus);\n      myNodeRenderer.setFont(UIUtil.getTreeFont().deriveFont(Font.BOLD));\n      myNodeRenderer.setIcon(null);\n      return myNodeRenderer;\n    }else if(userObject instanceof HighlightedRegionProvider){\n      NodeDescriptor descriptor=(NodeDescriptor)userObject;\n      HighlightedRegionProvider regionProvider=(HighlightedRegionProvider)userObject;\n      myColorTreeCellRenderer.getTreeCellRendererComponent(tree,obj,selected,expanded,leaf,row,hasFocus);\n      for (HighlightedRegion highlightedRegion : regionProvider.getHighlightedRegions()) {\n        myColorTreeCellRenderer.addHighlighter(\n            highlightedRegion.startOffset,\n            highlightedRegion.endOffset,\n            highlightedRegion.textAttributes\n        );\n      }\n      myColorTreeCellRenderer.setIcon(descriptor.getIcon());\n      return myColorTreeCellRenderer;\n    }else{\n      return myNodeRenderer.getTreeCellRendererComponent(tree,null,selected,expanded,leaf,row,hasFocus);\n    }\n  }","id":33908,"modified_method":"public Component getTreeCellRendererComponent(JTree tree, Object obj, boolean selected, boolean expanded, boolean leaf, int row, boolean hasFocus) {\n    Component result;\n\n    Object userObject = ((DefaultMutableTreeNode)obj).getUserObject();\n    if (userObject instanceof SummaryNode) {\n      myNodeRenderer.getTreeCellRendererComponent(tree, userObject.toString(), selected, expanded, leaf, row, hasFocus);\n      myNodeRenderer.setFont(UIUtil.getTreeFont().deriveFont(Font.BOLD));\n      myNodeRenderer.setIcon(null);\n      result = myNodeRenderer;\n    }\n    else if (userObject instanceof NodeDescriptor && userObject instanceof HighlightedRegionProvider) {\n      NodeDescriptor descriptor = (NodeDescriptor)userObject;\n      HighlightedRegionProvider regionProvider = (HighlightedRegionProvider)userObject;\n      myColorTreeCellRenderer.getTreeCellRendererComponent(tree, obj, selected, expanded, leaf, row, hasFocus);\n      for (HighlightedRegion region : regionProvider.getHighlightedRegions()) {\n        myColorTreeCellRenderer.addHighlighter(region.startOffset, region.endOffset, region.textAttributes);\n      }\n      myColorTreeCellRenderer.setIcon(descriptor.getIcon());\n      result = myColorTreeCellRenderer;\n    }\n    else {\n      result = myNodeRenderer.getTreeCellRendererComponent(tree, null, selected, expanded, leaf, row, hasFocus);\n    }\n\n    if (result instanceof JComponent) {\n      ((JComponent)result).setOpaque(!selected);\n    }\n\n    return result;\n  }","commit_id":"20515dec761618beb54eb7dae64e2996ef965f27","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void addChild(VirtualFileImpl child) {\n    final String path = child.getPath();\n    if (ourFileSystem.myUnaccountedFiles.containsKey(path)) {\n      final VirtualFileImpl prev = ourFileSystem.myUnaccountedFiles.put(path, child);\n      LOG.assertTrue(prev == null || !prev.isValid());\n      return;\n    }\n\n    getChildren(); // to initialize myChildren\n\n    synchronized (ourFileSystem.LOCK) {\n      VirtualFileImpl[] newChildren = new VirtualFileImpl[myChildren.length + 1];\n      System.arraycopy(myChildren, 0, newChildren, 0, myChildren.length);\n      newChildren[myChildren.length] = child;\n      myChildren = newChildren;\n      child.setParent(this);\n    }\n  }","id":33909,"modified_method":"void addChild(VirtualFileImpl child) {\n    ourFileSystem.myUnaccountedFiles.remove(child.getPath());\n    getChildren(); // to initialize myChildren\n\n    synchronized (ourFileSystem.LOCK) {\n      VirtualFileImpl[] newChildren = new VirtualFileImpl[myChildren.length + 1];\n      System.arraycopy(myChildren, 0, newChildren, 0, myChildren.length);\n      newChildren[myChildren.length] = child;\n      myChildren = newChildren;\n      child.setParent(this);\n    }\n  }","commit_id":"b18df9ff429d116c7b7f7b38092baeb9495fc04d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ComputationResult getComputationResultForDashboardWidget(final DashboardWidget dashboardWidget) throws InvalidWidgetConfigurationException {\n        final String widgetId = dashboardWidget.getId();\n        if (!this.cache.containsKey(widgetId)) {\n            final WidgetStrategy widgetStrategy = this.widgetStrategyFactory.getWidgetForType(dashboardWidget.getType().toString(),\n                    dashboardWidget.getConfig(), dashboardWidget.getTimeRange(), widgetId);\n            this.cache.put(widgetId, Suppliers.memoizeWithExpiration(\n                    new ComputationResultSupplier(metricRegistry, dashboardWidget, widgetStrategy),\n                    dashboardWidget.getCacheTime(),\n                    TimeUnit.SECONDS\n            ));\n        }\n        return this.cache.get(widgetId).get();\n    }","id":33910,"modified_method":"public ComputationResult getComputationResultForDashboardWidget(final DashboardWidget dashboardWidget) throws InvalidWidgetConfigurationException {\n        final String widgetId = dashboardWidget.getId();\n        if (!this.cache.containsKey(widgetId)) {\n            final WidgetStrategy widgetStrategy = this.widgetStrategyFactory.getWidgetForType(dashboardWidget.getType().toString(),\n                    dashboardWidget.getConfig(), dashboardWidget.getTimeRange(), widgetId);\n            this.cache.putIfAbsent(widgetId, Suppliers.memoizeWithExpiration(\n                    new ComputationResultSupplier(metricRegistry, dashboardWidget, widgetStrategy),\n                    dashboardWidget.getCacheTime(),\n                    TimeUnit.SECONDS\n            ));\n        }\n        return this.cache.get(widgetId).get();\n    }","commit_id":"45d05a3b7689df0505ac56136294eacec0ff81f4","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Inject\n    public WidgetResultCache(MetricRegistry metricRegistry, WidgetStrategyFactory widgetStrategyFactory) {\n        this.metricRegistry = metricRegistry;\n        this.widgetStrategyFactory = widgetStrategyFactory;\n        this.cache = Maps.newHashMap();\n    }","id":33911,"modified_method":"@Inject\n    public WidgetResultCache(MetricRegistry metricRegistry, WidgetStrategyFactory widgetStrategyFactory) {\n        this.metricRegistry = metricRegistry;\n        this.widgetStrategyFactory = widgetStrategyFactory;\n        this.cache = Maps.newConcurrentMap();\n    }","commit_id":"45d05a3b7689df0505ac56136294eacec0ff81f4","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public void invalidate(final DashboardWidget dashboardWidget) {\n        final String widgetId = dashboardWidget.getId();\n        if (this.cache.containsKey(widgetId)) {\n            this.cache.remove(widgetId);\n        }\n    }","id":33912,"modified_method":"public void invalidate(final DashboardWidget dashboardWidget) {\n        this.cache.remove(dashboardWidget.getId());\n    }","commit_id":"45d05a3b7689df0505ac56136294eacec0ff81f4","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"/**\n   * Sets the timer class to use for the specified executor thread.\n   *\n   * @param name a name of a heartbeat executor thread\n   * @param timerClass the timer class to use for the executor thread\n   */\n  public static synchronized void setTimerClass(String name,\n      Class<? extends HeartbeatTimer> timerClass) {\n    if (!sTimerClasses.containsKey(name)) {\n      sTimerClasses.put(name, timerClass);\n    } else {\n      throw new RuntimeException(\"There is already a timer class for \" + name);\n    }\n  }","id":33913,"modified_method":"/**\n   * Sets the timer class to use for the specified executor thread.\n   *\n   * This method should only be used by tests.\n   *\n   * @param name a name of a heartbeat executor thread\n   * @param timerClass the timer class to use for the executor thread\n   */\n  @SuppressWarnings(\"unused\")\n  private static synchronized void setTimerClass(String name,\n      Class<? extends HeartbeatTimer> timerClass) {\n    if (timerClass == null) {\n      sTimerClasses.remove(name);\n    } else {\n      sTimerClasses.put(name, timerClass);\n    }\n  }","commit_id":"4de0709a13883410aefd9516baf39e853b2abaf8","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n    public Null call() throws Exception {\n      try {\n        HeartbeatContext.setTimerClass(mThreadName, HeartbeatContext.SCHEDULED_TIMER_CLASS);\n\n        DummyHeartbeatExecutor executor = new DummyHeartbeatExecutor();\n        HeartbeatThread ht = new HeartbeatThread(mThreadName, executor, 1);\n\n        // Run the HeartbeatThread.\n        mExecutorService.submit(ht);\n\n        // Wait for the DummyHeartbeatExecutor executor to be ready to execute its heartbeat.\n        Assert.assertTrue(\"Initial wait failed for \" + mThreadName,\n            HeartbeatScheduler.await(mThreadName, 5, TimeUnit.SECONDS));\n\n        final int numIterations = 200;\n        for (int i = 0; i < numIterations; i++) {\n          HeartbeatScheduler.schedule(mThreadName);\n          Assert.assertTrue(\"Iteration \" + i + \" failed.\",\n              HeartbeatScheduler.await(mThreadName, 5, TimeUnit.SECONDS));\n        }\n\n        Assert.assertEquals(\"The executor counter is wrong.\", numIterations, executor.getCounter());\n      } catch (Exception e) {\n        throw new RuntimeException(e.getMessage());\n      }\n      return null;\n    }","id":33914,"modified_method":"@Override\n    public Null call() throws Exception {\n      try (ManuallyScheduleHeartbeat.Resource r =\n          new ManuallyScheduleHeartbeat.Resource(Arrays.asList(mThreadName))) {\n        DummyHeartbeatExecutor executor = new DummyHeartbeatExecutor();\n        HeartbeatThread ht = new HeartbeatThread(mThreadName, executor, 1);\n\n        // Run the HeartbeatThread.\n        mExecutorService.submit(ht);\n\n        // Wait for the DummyHeartbeatExecutor executor to be ready to execute its heartbeat.\n        Assert.assertTrue(\"Initial wait failed for \" + mThreadName,\n            HeartbeatScheduler.await(mThreadName, 5, TimeUnit.SECONDS));\n\n        final int numIterations = 200;\n        for (int i = 0; i < numIterations; i++) {\n          HeartbeatScheduler.schedule(mThreadName);\n          Assert.assertTrue(\"Iteration \" + i + \" failed.\",\n              HeartbeatScheduler.await(mThreadName, 5, TimeUnit.SECONDS));\n        }\n\n        Assert.assertEquals(\"The executor counter is wrong.\", numIterations, executor.getCounter());\n      } catch (Exception e) {\n        throw new RuntimeException(e.getMessage());\n      }\n      return null;\n    }","commit_id":"4de0709a13883410aefd9516baf39e853b2abaf8","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public Statement apply(final Statement statement, Description description) {\n    for (String threadName : mThreads) {\n      try {\n        Whitebox.invokeMethod(HeartbeatContext.class, \"setTimerClass\", threadName,\n            HeartbeatContext.SCHEDULED_TIMER_CLASS);\n      } catch (Exception e) {\n        throw Throwables.propagate(e);\n      }\n    }\n    return new Statement() {\n      @Override\n      public void evaluate() throws Throwable {\n        try {\n          statement.evaluate();\n        } finally {\n          for (String threadName : mThreads) {\n            Whitebox.invokeMethod(HeartbeatContext.class, \"setTimerClass\", threadName,\n                HeartbeatContext.SLEEPING_TIMER_CLASS);\n          }\n        }\n      }\n    };\n  }","id":33915,"modified_method":"@Override\n  public Statement apply(final Statement statement, Description description) {\n    return new Statement() {\n      @Override\n      public void evaluate() throws Throwable {\n        try (Resource resource = new Resource(mThreads)) {\n          statement.evaluate();\n        }\n      }\n    };\n  }","commit_id":"4de0709a13883410aefd9516baf39e853b2abaf8","url":"https://github.com/amplab/tachyon"},{"original_method":"private List<Release> getReleases( List<Issue> issues )\n    {\n        if ( issues.isEmpty() )\n        {\n            return Collections.emptyList();\n        }\n        else\n        {\n            return IssueAdapter.getReleases( issues );\n        }\n    }","id":33916,"modified_method":"private List<Release> getReleases( List<Issue> issues )\n    {\n        if ( issues.isEmpty() )\n        {\n            return Collections.emptyList();\n        }\n        else\n        {\n        \tIssueAdapter adapter = new IssueAdapter(issueTypes);\n            return adapter.getReleases( issues );\n        }\n    }","commit_id":"b1241c0db70f7bd08eaec47f82a4024b3ef0e43b","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Adapt a <code>List<\/code> of <code>Issue<\/code>s to a\n     * <code>List<\/code> of <code>Release<\/code>s.\n     *\n     * @param issues The issues\n     * @return A list of releases\n     */\n    public static List<Release> getReleases( List<Issue> issues )\n    {\n        // A Map of releases keyed by fixVersion\n        Map<String,Release> releasesMap = new HashMap<String,Release>();\n\n        // Loop through all issues looking for fixVersions\n        for ( Issue issue : issues )\n        {\n            // Do NOT create a release for issues that lack a fixVersion\n            if ( issue.getFixVersions() != null )\n            {\n                for ( String fixVersion : issue.getFixVersions() )\n                {\n                    // Try to get a matching Release from the map\n                    Release release = releasesMap.get( fixVersion );\n                    if ( release == null )\n                    {\n                        // Add a new Release to the Map if it wasn't there\n                        release = new Release();\n                        release.setVersion( fixVersion );\n                        releasesMap.put( fixVersion, release );\n                    }\n\n                    // Add this issue as an Action to this release\n                    Action action = createAction( issue );\n                    release.addAction( action );\n                }\n            }\n        }\n\n        // Extract the releases from the Map to a List\n        List<Release> releasesList = new ArrayList<Release>();\n        for ( Release release : releasesMap.values() )\n        {\n            releasesList.add( release );\n        }\n        return releasesList;\n    }","id":33917,"modified_method":"/**\n     * Adapt a <code>List<\/code> of <code>Issue<\/code>s to a\n     * <code>List<\/code> of <code>Release<\/code>s.\n     *\n     * @param issues The issues\n     * @return A list of releases\n     */\n    public List<Release> getReleases( List<Issue> issues )\n    {\n        // A Map of releases keyed by fixVersion\n        Map<String,Release> releasesMap = new HashMap<String,Release>();\n\n        // Loop through all issues looking for fixVersions\n        for ( Issue issue : issues )\n        {\n            // Do NOT create a release for issues that lack a fixVersion\n            if ( issue.getFixVersions() != null )\n            {\n                for ( String fixVersion : issue.getFixVersions() )\n                {\n                    // Try to get a matching Release from the map\n                    Release release = releasesMap.get( fixVersion );\n                    if ( release == null )\n                    {\n                        // Add a new Release to the Map if it wasn't there\n                        release = new Release();\n                        release.setVersion( fixVersion );\n                        releasesMap.put( fixVersion, release );\n                    }\n\n                    // Add this issue as an Action to this release\n                    Action action = createAction( issue );\n                    release.addAction( action );\n                }\n            }\n        }\n\n        // Extract the releases from the Map to a List\n        List<Release> releasesList = new ArrayList<Release>();\n        for ( Release release : releasesMap.values() )\n        {\n            releasesList.add( release );\n        }\n        return releasesList;\n    }","commit_id":"b1241c0db70f7bd08eaec47f82a4024b3ef0e43b","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Create an <code>Action<\/code> from an issue.\n     *\n     * @param issue The issue to extract the information from\n     * @return An <code>Action<\/code>\n     */\n    public static Action createAction( Issue issue )\n    {\n        Action action = new Action();\n\n        // @todo We need to add something like issue.getPresentationIdentifier() to be able to support other IMSes beside JIRA\n        action.setIssue( issue.getKey() );\n\n        // @todo To support types for different IMSes we need some way to map these values to the ones used in a particular IMS\n        String type = \"\";\n        if ( issue.getType().equals( \"Bug\" ) )\n        {\n            type = \"fix\";\n        }\n        else if ( issue.getType().equals( \"New Feature\" ) )\n        {\n            type = \"add\";\n        }\n        else if ( issue.getType().equals( \"Improvement\" ) )\n        {\n            type = \"update\";\n        }\n        action.setType( type );\n\n        action.setDev( issue.getAssignee() );\n\n        // Set dueTo to the empty String instead of null to make Velocity happy\n        action.setDueTo( \"\" );\n        //action.setDueTo( issue.getReporter() );\n\n        action.setAction( issue.getSummary() );\n        return action;\n    }","id":33918,"modified_method":"/**\n     * Create an <code>Action<\/code> from an issue.\n     *\n     * @param issue The issue to extract the information from\n     * @return An <code>Action<\/code>\n     */\n    public Action createAction( Issue issue )\n    {\n        Action action = new Action();\n\n        // @todo We need to add something like issue.getPresentationIdentifier() to be able to support other IMSes beside JIRA\n        action.setIssue( issue.getKey() );\n\n        String type = \"\";\n        if ( issueMap.containsKey( issue.getType() ) )\n        {\n            type = issueMap.get( issue.getType() );\n        }\n        action.setType( type );\n\n        action.setDev( issue.getAssignee() );\n\n        // Set dueTo to the empty String instead of null to make Velocity happy\n        action.setDueTo( \"\" );\n        //action.setDueTo( issue.getReporter() );\n\n        action.setAction( issue.getSummary() );\n        return action;\n    }","commit_id":"b1241c0db70f7bd08eaec47f82a4024b3ef0e43b","url":"https://github.com/apache/maven-plugins"},{"original_method":"public static MetricDifferenceInfo calculateDifferenceSinceLastEvent(String namespace, String metricName, String dimensionName, String dimensionValue, Date newTimestamp, Double newMetricValue) {\n    MetricDifferenceInfo returnValue = null;\n    EntityTransaction db = Entities.get(AbsoluteMetricHistory.class);\n    try {\n      Criteria criteria = Entities.createCriteria(AbsoluteMetricHistory.class)\n          .add( Restrictions.eq( \"namespace\", namespace ) )\n          .add( Restrictions.eq( \"metricName\", metricName ) )\n          .add( Restrictions.eq( \"dimensionName\", dimensionName ) )\n          .add( Restrictions.eq( \"dimensionValue\", dimensionValue ) );\n      AbsoluteMetricHistory lastEntity = (AbsoluteMetricHistory) criteria.uniqueResult();\n      if (lastEntity == null) {\n        // first data point, add it and return null (nothing to diff against)\n        lastEntity = new AbsoluteMetricHistory();\n        lastEntity.setNamespace(namespace);\n        lastEntity.setMetricName(metricName);\n        lastEntity.setDimensionName(dimensionName);\n        lastEntity.setDimensionValue(dimensionValue);\n        lastEntity.setTimestamp(newTimestamp);\n        lastEntity.setLastMetricValue(newMetricValue);\n        Entities.persist(lastEntity);\n        returnValue =  null;\n      } else {\n        // TODO: should we assume all metrics are increasing?\n        long elapsedTimeInMillis = Math.abs(newTimestamp.getTime() - lastEntity.getTimestamp().getTime());\n        double valueDifference = Math.abs(newMetricValue - lastEntity.getLastMetricValue());\n        lastEntity.setTimestamp(newTimestamp);\n        lastEntity.setLastMetricValue(newMetricValue);\n        returnValue = new MetricDifferenceInfo(valueDifference, elapsedTimeInMillis);\n      }\n      db.commit();\n    } catch (RuntimeException ex) {\n      Logs.extreme().error(ex, ex);\n      throw ex;\n    } finally {\n      if (db.isActive())\n        db.rollback();\n    }\n    return returnValue;\n  }","id":33919,"modified_method":"public static MetricDifferenceInfo calculateDifferenceSinceLastEvent(String namespace, String metricName, String dimensionName, String dimensionValue, Date newTimestamp, Double newMetricValue) {\n    MetricDifferenceInfo returnValue = null;\n    EntityTransaction db = Entities.get(AbsoluteMetricHistory.class);\n    try {\n      Criteria criteria = Entities.createCriteria(AbsoluteMetricHistory.class)\n          .add( Restrictions.eq( \"namespace\", namespace ) )\n          .add( Restrictions.eq( \"metricName\", metricName ) )\n          .add( Restrictions.eq( \"dimensionName\", dimensionName ) )\n          .add( Restrictions.eq( \"dimensionValue\", dimensionValue ) );\n      AbsoluteMetricHistory lastEntity = (AbsoluteMetricHistory) criteria.uniqueResult();\n      if (lastEntity == null) {\n        // first data point, add it and return null (nothing to diff against)\n        lastEntity = new AbsoluteMetricHistory();\n        lastEntity.setNamespace(namespace);\n        lastEntity.setMetricName(metricName);\n        lastEntity.setDimensionName(dimensionName);\n        lastEntity.setDimensionValue(dimensionValue);\n        lastEntity.setTimestamp(newTimestamp);\n        lastEntity.setLastMetricValue(newMetricValue);\n        Entities.persist(lastEntity);\n        returnValue =  null;\n      } else {\n        double TOLERANCE = 0.0000001; // arbitrary to check double \"equality\"\n        long elapsedTimeInMillis = newTimestamp.getTime() - lastEntity.getTimestamp().getTime();\n        double valueDifference = newMetricValue - lastEntity.getLastMetricValue();\n        if (elapsedTimeInMillis < 0) {\n          // a negative value of elapsedTimeInMillis means this data point is not useful\n          return null;\n        } else if (elapsedTimeInMillis == 0) {\n          if (Math.abs(valueDifference) > TOLERANCE) {\n            LOG.warn(\"Getting different values \" + newMetricValue + \" and \" + lastEntity.getLastMetricValue() + \" for absolute metric \" + metricName + \" at the same timestamp \" + newTimestamp + \", keeping the second value.\");\n          }\n          return null; // not a useful data point either\n        } else if (elapsedTimeInMillis > 0) { // point in the future, update the reference\n          lastEntity.setTimestamp(newTimestamp);\n          lastEntity.setLastMetricValue(newMetricValue);\n          // if the value difference is negative (i.e. has gone down, the assumption is that the NC has restarted, and the new\n          // value started from some time in the past.  Best thing to do here is either assume it is a first point again, or\n          // assume the previous point had a 0 value.  Not sure which is the better choice, but for now, we will assume the\n          // previous point had a zero value\n          if (Math.abs(valueDifference) < TOLERANCE) {\n            valueDifference = 0.0;\n          } else {\n            if (valueDifference < -TOLERANCE) {\n              valueDifference = newMetricValue - 0;\n            }\n          }\n        }\n        returnValue = new MetricDifferenceInfo(valueDifference, elapsedTimeInMillis);\n      }\n      db.commit();\n    } catch (RuntimeException ex) {\n      Logs.extreme().error(ex, ex);\n      throw ex;\n    } finally {\n      if (db.isActive())\n        db.rollback();\n    }\n    return returnValue;\n  }","commit_id":"99a4bc21967c2392680e874ef0ac969e75b527eb","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public void run() {\n    LOG.info(\"Kicking off alarm state evaluation for \" + alarmName);\n    EntityTransaction db = Entities.get(AlarmEntity.class);\n    try {\n      Criteria criteria = Entities.createCriteria(AlarmEntity.class)\n          .add( Restrictions.eq( \"accountId\" , accountId ) )\n          .add( Restrictions.eq( \"alarmName\" , alarmName ) );\n      AlarmEntity alarmEntity = (AlarmEntity) criteria.uniqueResult();\n      if (alarmEntity == null) return; // TODO: didn't find it, not good.\n      AlarmState currentState = evaluateState(alarmEntity);\n      Date evaluationDate = new Date();\n      if (currentState.getStateValue() != alarmEntity.getStateValue()) {\n        AlarmManager.changeAlarmState(alarmEntity, currentState, evaluationDate);\n        AlarmManager.executeActions(alarmEntity, currentState, true, evaluationDate);\n      } else if (moreThanOnePeriodHasPassed(alarmEntity, evaluationDate)) {\n        AlarmManager.executeActions(alarmEntity, currentState, false, evaluationDate);\n      }\n      db.commit();\n    } catch (RuntimeException ex) { // TODO: exception in a Runnable gets lost...\n      Logs.extreme().error(ex, ex);\n      throw ex;\n    } finally {\n      if (db.isActive())\n        db.rollback();\n    }\n  }","id":33920,"modified_method":"@Override\n  public void run() {\n    LOG.debug(\"Kicking off alarm state evaluation for \" + alarmName);\n    EntityTransaction db = Entities.get(AlarmEntity.class);\n    try {\n      Criteria criteria = Entities.createCriteria(AlarmEntity.class)\n          .add( Restrictions.eq( \"accountId\" , accountId ) )\n          .add( Restrictions.eq( \"alarmName\" , alarmName ) );\n      AlarmEntity alarmEntity = (AlarmEntity) criteria.uniqueResult();\n      if (alarmEntity == null) return; // TODO: didn't find it, not good.\n      AlarmState currentState = evaluateState(alarmEntity);\n      Date evaluationDate = new Date();\n      if (currentState.getStateValue() != alarmEntity.getStateValue()) {\n        AlarmManager.changeAlarmState(alarmEntity, currentState, evaluationDate);\n        AlarmManager.executeActions(alarmEntity, currentState, true, evaluationDate);\n      } else if (moreThanOnePeriodHasPassed(alarmEntity, evaluationDate)) {\n        AlarmManager.executeActions(alarmEntity, currentState, false, evaluationDate);\n      }\n      db.commit();\n    } catch (RuntimeException ex) { // TODO: exception in a Runnable gets lost...\n      Logs.extreme().error(ex, ex);\n      throw ex;\n    } finally {\n      if (db.isActive())\n        db.rollback();\n    }\n  }","commit_id":"99a4bc21967c2392680e874ef0ac969e75b527eb","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void validateWithinTwoWeeks(Date timestamp, String name) throws CloudWatchException {\n    if (timestamp == null) return;\n    Date now = new Date();\n    Date twoWeeksAgo = new Date(now.getTime() - 2 * 7 * 3600 * 1000L);\n    long BUFFER = 2 * 3600 * 1000L; // two hours\n    if (timestamp.getTime() > now.getTime() + BUFFER || timestamp.getTime() < twoWeeksAgo.getTime() - BUFFER) {\n      throw new InvalidParameterValueException(\"The parameter \" + name + \".Timestamp must specify a time within the past two weeks.\");\n    }\n  }","id":33921,"modified_method":"private void validateWithinTwoWeeks(Date timestamp, String name) throws CloudWatchException {\n    if (timestamp == null) return;\n    Date now = new Date();\n    Date twoWeeksAgo = new Date(now.getTime() - 2 * 7 * 24 * 3600 * 1000L);\n    long BUFFER = 2 * 3600 * 1000L; // two hours\n    if (timestamp.getTime() > now.getTime() + BUFFER || timestamp.getTime() < twoWeeksAgo.getTime() - BUFFER) {\n      throw new InvalidParameterValueException(\"The parameter \" + name + \".Timestamp must specify a time within the past two weeks.\");\n    }\n  }","commit_id":"99a4bc21967c2392680e874ef0ac969e75b527eb","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void sendSystemMetric(Supplier<InstanceUsageEvent> cloudWatchSupplier) throws Exception {\n    InstanceUsageEvent event = null;\n    event = cloudWatchSupplier.get();\n\n    final VmInstance instance = VmInstances.lookup(event.getInstanceId());\n\n    if (!instance.getInstanceId().equals(event.getInstanceId())\n        || !instance.getMonitoring()) {\n      throw new NoSuchElementException(\"Instance : \" + event.getInstanceId() + \" monitoring is not enabled\");\n    }\n\n    if (instance.getInstanceId().equals(event.getInstanceId())\n        && instance.getMonitoring()) {\n\n      PutMetricDataType putMetricData = new PutMetricDataType();\n      MetricDatum metricDatum = new MetricDatum();\n      ArrayList<Dimension> dimArray = Lists.newArrayList();\n\n      if (event.getDimension() != null && event.getValue() != null) {\n\n        if (event.getDimension().startsWith(\"vol-\")) {\n          putMetricData.setNamespace(\"AWS/EBS\");\n          Dimension volDim = new Dimension();\n          volDim.setName(\"VolumeId\");\n          volDim.setValue(event.getDimension());\n          dimArray.add(volDim);\n          // Need to replace metric name\n          if (event.getMetric().startsWith(\"Disk\")) {\n            final String convertedEBSMetricName = event.getMetric()\n                .replace(\"Disk\", \"Volume\");\n            metricDatum.setMetricName(convertedEBSMetricName);\n          } else {\n            metricDatum.setMetricName(event.getMetric());\n          }\n        } else {\n          putMetricData.setNamespace(\"AWS/EC2\");\n\n          Dimension instanceIdDim = new Dimension();\n          instanceIdDim.setName(\"InstanceId\");\n          instanceIdDim.setValue(instance.getInstanceId());\n          dimArray.add(instanceIdDim);\n\n          Dimension imageIdDim = new Dimension();\n          imageIdDim.setName(\"ImageId\");\n          imageIdDim.setValue(instance.getImageId());\n          dimArray.add(imageIdDim);\n\n          Dimension instanceTypeDim = new Dimension();\n          instanceTypeDim.setName(\"InstanceType\");\n          instanceTypeDim.setValue(instance.getVmType()\n              .getDisplayName());\n          dimArray.add(instanceTypeDim);\n\n          // convert ephemeral disks metrics\n          if (event.getMetric().equals(\"VolumeTotalReadTime\")) {\n            metricDatum.setMetricName(\"DiskReadBytes\");\n          } else if (event.getMetric().endsWith(\"External\")) {\n            final String convertedEC2NetworkMetricName = event\n                .getMetric().replace(\"External\", \"\");\n            metricDatum\n                .setMetricName(convertedEC2NetworkMetricName);\n          } else if (event.getMetric().equals(\"VolumeTotalWriteTime\")) {\n            metricDatum.setMetricName(\"DiskWriteBytes\");\n          } else {\n            metricDatum.setMetricName(event.getMetric());\n          }\n        }\n      } else {\n        LOG.debug(\"Event does not contain a dimension\");\n        throw new Exception();\n      }\n\n      Dimensions dims = new Dimensions();\n      dims.setMember(dimArray);\n\n      MetricData metricData = new MetricData();\n\n      metricDatum.setTimestamp(new Date(event.getValueTimestamp()));\n      metricDatum.setDimensions(dims);\n      metricDatum.setValue(event.getValue());\n\n      final String unitType = containsUnitType(metricDatum.getMetricName());\n      metricDatum.setUnit(unitType);\n\n\n      if (metricDatum.getMetricName().equals(\"CPUUtilization\")) {\n        metricDatum.setMetricName(\"CPUUtilizationMS\"); // this is actually the data in milliseconds, not percentage\n      }\n      if (metricDatum.getMetricName().equals(\"VolumeReadOps\")) {\n        metricDatum.setMetricName(\"VolumeReadOpsTotal\"); // this is actually the total volume read Ops since volume creation, not for the period\n      }\n      if (metricDatum.getMetricName().equals(\"VolumeWriteOps\")) {\n        metricDatum.setMetricName(\"VolumeWriteOpsTotal\"); // this is actually the total volume write Ops since volume creation, not for the period\n      }\n      if (metricDatum.getMetricName().equals(\"VolumeReadBytes\")) {\n        metricDatum.setMetricName(\"VolumeReadBytesTotal\"); // this is actually the total volume read bytes since volume creation, not for the period\n      }\n      if (metricDatum.getMetricName().equals(\"VolumeWriteBytes\")) {\n        metricDatum.setMetricName(\"VolumeWriteBytesTotal\"); // this is actually the total volume write bytes since volume creation, not for the period\n      }\n      if (metricDatum.getMetricName().equals(\"VolumeTotalReadTime\")) {\n        metricDatum.setMetricName(\"VolumeTotalReadTimeTotal\"); // this is actually the total volume read time since volume creation, not for the period\n      }\n      if (metricDatum.getMetricName().equals(\"VolumeTotalWriteTime\")) {\n        metricDatum.setMetricName(\"VolumeTotalWriteTimeTotal\"); // this is actually the total volume write time since volume creation, not for the period\n      }\n      \n      metricData.setMember(Lists.newArrayList(metricDatum));\n      putMetricData.setMetricData(metricData);\n\n      Account account = Accounts.getAccountProvider().lookupAccountById(\n          instance.getOwnerAccountNumber());\n\n      User user = account.lookupUserByName(User.ACCOUNT_ADMIN);\n      putMetricData.setEffectiveUserId(user.getUserId());\n\n      ServiceConfiguration serviceConfiguration = ServiceConfigurations\n          .createEphemeral(ComponentIds.lookup(CloudWatch.class));\n      BaseMessage reply = (BaseMessage) AsyncRequests.dispatch(serviceConfiguration, putMetricData).get();\n      if (!(reply instanceof PutMetricDataResponseType)) {\n        throw new EucalyptusCloudException(\"Unable to send put metric data to cloud watch\");\n      }\n\n    }\n  }","id":33922,"modified_method":"private void sendSystemMetric(Supplier<InstanceUsageEvent> cloudWatchSupplier) throws Exception {\n    InstanceUsageEvent event = null;\n    event = cloudWatchSupplier.get();\n\n    final VmInstance instance = VmInstances.lookup(event.getInstanceId());\n\n    if (!instance.getInstanceId().equals(event.getInstanceId())\n        || !instance.getMonitoring()) {\n      throw new NoSuchElementException(\"Instance : \" + event.getInstanceId() + \" monitoring is not enabled\");\n    }\n\n    if (instance.getInstanceId().equals(event.getInstanceId())\n        && instance.getMonitoring()) {\n\n      PutMetricDataType putMetricData = new PutMetricDataType();\n      MetricDatum metricDatum = new MetricDatum();\n      ArrayList<Dimension> dimArray = Lists.newArrayList();\n\n      if (event.getDimension() != null && event.getValue() != null) {\n\n        if (event.getDimension().startsWith(\"vol-\")) {\n          putMetricData.setNamespace(\"AWS/EBS\");\n          Dimension volDim = new Dimension();\n          volDim.setName(\"VolumeId\");\n          volDim.setValue(event.getDimension());\n          dimArray.add(volDim);\n          // Need to replace metric name\n          if (event.getMetric().startsWith(\"Disk\")) {\n            final String convertedEBSMetricName = event.getMetric()\n                .replace(\"Disk\", \"Volume\");\n            metricDatum.setMetricName(convertedEBSMetricName);\n          } else {\n            metricDatum.setMetricName(event.getMetric());\n          }\n        } else {\n          putMetricData.setNamespace(\"AWS/EC2\");\n\n          Dimension instanceIdDim = new Dimension();\n          instanceIdDim.setName(\"InstanceId\");\n          instanceIdDim.setValue(instance.getInstanceId());\n          dimArray.add(instanceIdDim);\n\n          Dimension imageIdDim = new Dimension();\n          imageIdDim.setName(\"ImageId\");\n          imageIdDim.setValue(instance.getImageId());\n          dimArray.add(imageIdDim);\n\n          Dimension instanceTypeDim = new Dimension();\n          instanceTypeDim.setName(\"InstanceType\");\n          instanceTypeDim.setValue(instance.getVmType()\n              .getDisplayName());\n          dimArray.add(instanceTypeDim);\n\n          // convert ephemeral disks metrics\n          if (event.getMetric().equals(\"VolumeTotalReadTime\")) {\n            return; // AWS doesn't have a TotalReadTime metric for the root volume, or EC2\n//            metricDatum.setMetricName(\"DiskReadBytes\");\n\n// Commenting out the below because while metrics that end with external need to be sent, we will deal with them in cloudwatch           \n//          } else if (event.getMetric().endsWith(\"External\")) {\n//            final String convertedEC2NetworkMetricName = event\n//                .getMetric().replace(\"External\", \"\");\n//            metricDatum\n//                .setMetricName(convertedEC2NetworkMetricName);\n          } else if (event.getMetric().equals(\"VolumeTotalWriteTime\")) {\n            return; // AWS doesn't have a TotalWriteTime metric for the root volume, or EC2\n//            metricDatum.setMetricName(\"DiskWriteBytes\");\n          } else {\n            metricDatum.setMetricName(event.getMetric());\n          }\n        }\n      } else {\n        LOG.debug(\"Event does not contain a dimension\");\n        throw new Exception();\n      }\n\n      Dimensions dims = new Dimensions();\n      dims.setMember(dimArray);\n\n      MetricData metricData = new MetricData();\n\n      metricDatum.setTimestamp(new Date(event.getValueTimestamp()));\n      metricDatum.setDimensions(dims);\n      metricDatum.setValue(event.getValue());\n\n      final String unitType = containsUnitType(metricDatum.getMetricName());\n      metricDatum.setUnit(unitType);\n\n\n      if (metricDatum.getMetricName().equals(\"CPUUtilization\")) {\n        metricDatum.setMetricName(\"CPUUtilizationMSAbsolute\"); // this is actually the data in milliseconds, not percentage\n      }\n      if (metricDatum.getMetricName().equals(\"VolumeReadOps\")) {\n        metricDatum.setMetricName(\"VolumeReadOpsAbsolute\"); // this is actually the total volume read Ops since volume creation, not for the period\n      }\n      if (metricDatum.getMetricName().equals(\"VolumeWriteOps\")) {\n        metricDatum.setMetricName(\"VolumeWriteOpsAbsolute\"); // this is actually the total volume write Ops since volume creation, not for the period\n      }\n      if (metricDatum.getMetricName().equals(\"VolumeReadBytes\")) {\n        metricDatum.setMetricName(\"VolumeReadBytesAbsolute\"); // this is actually the total volume read bytes since volume creation, not for the period\n      }\n      if (metricDatum.getMetricName().equals(\"VolumeWriteBytes\")) {\n        metricDatum.setMetricName(\"VolumeWriteBytesAbsolute\"); // this is actually the total volume write bytes since volume creation, not for the period\n      }\n      if (metricDatum.getMetricName().equals(\"VolumeTotalReadTime\")) {\n        metricDatum.setMetricName(\"VolumeTotalReadTimeAbsolute\"); // this is actually the total volume read time since volume creation, not for the period\n      }\n      if (metricDatum.getMetricName().equals(\"VolumeTotalWriteTime\")) {\n        metricDatum.setMetricName(\"VolumeTotalWriteTimeAbsolute\"); // this is actually the total volume write time since volume creation, not for the period\n      }\n      if (metricDatum.getMetricName().equals(\"DiskReadOps\")) {\n        metricDatum.setMetricName(\"DiskReadOpsAbsolute\"); // this is actually the total disk read Ops since instance creation, not for the period\n      }\n      if (metricDatum.getMetricName().equals(\"DiskWriteOps\")) {\n        metricDatum.setMetricName(\"DiskWriteOpsAbsolute\"); // this is actually the total disk write Ops since instance creation, not for the period\n      }\n      if (metricDatum.getMetricName().equals(\"DiskReadBytes\")) {\n        metricDatum.setMetricName(\"DiskReadBytesAbsolute\"); // this is actually the total disk read bytes since instance creation, not for the period\n      }\n      if (metricDatum.getMetricName().equals(\"DiskWriteBytes\")) {\n        metricDatum.setMetricName(\"DiskWriteBytesAbsolute\"); // this is actually the total disk write bytes since instance creation, not for the period\n      }\n      if (metricDatum.getMetricName().equals(\"NetworkIn\")) {\n        metricDatum.setMetricName(\"NetworkInAbsolute\"); // this is actually the total network in bytes since instance creation, not for the period\n      }\n      if (metricDatum.getMetricName().equals(\"NetworkInExternal\")) {\n        metricDatum.setMetricName(\"NetworkInExternalAbsolute\"); // this is actually the total network in external bytes since instance creation, not for the period\n      }\n      if (metricDatum.getMetricName().equals(\"NetworkOut\")) {\n        metricDatum.setMetricName(\"NetworkOutAbsolute\"); // this is actually the total network out bytes since instance creation, not for the period\n      }\n      if (metricDatum.getMetricName().equals(\"NetworkOutExternal\")) {\n        metricDatum.setMetricName(\"NetworkOutExternalAbsolute\"); // this is actually the total network out external bytes since instance creation, not for the period\n      }\n      \n      metricData.setMember(Lists.newArrayList(metricDatum));\n      putMetricData.setMetricData(metricData);\n\n      Account account = Accounts.getAccountProvider().lookupAccountById(\n          instance.getOwnerAccountNumber());\n\n      User user = account.lookupUserByName(User.ACCOUNT_ADMIN);\n      putMetricData.setEffectiveUserId(user.getUserId());\n\n      ServiceConfiguration serviceConfiguration = ServiceConfigurations\n          .createEphemeral(ComponentIds.lookup(CloudWatch.class));\n      BaseMessage reply = (BaseMessage) AsyncRequests.dispatch(serviceConfiguration, putMetricData).get();\n      if (!(reply instanceof PutMetricDataResponseType)) {\n        throw new EucalyptusCloudException(\"Unable to send put metric data to cloud watch\");\n      }\n\n    }\n  }","commit_id":"99a4bc21967c2392680e874ef0ac969e75b527eb","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public void fire(final DescribeSensorsResponse msg) {\n    try {\n      final Iterable<String> uuidList =\n          Iterables.transform(VmInstances.list(VmState.RUNNING), VmInstances.toInstanceUuid());\n\n      for (final SensorsResourceType sensorData : msg.getSensorsResources()) {\n        if (!RESOURCE_TYPE_INSTANCE.equals(sensorData.getResourceType()) ||\n            !Iterables.contains(uuidList, sensorData.getResourceUuid()))\n          continue;\n\n        for (final MetricsResourceType metricType : sensorData.getMetrics()) {\n          for (final MetricCounterType counterType : metricType.getCounters()) {\n            for (final MetricDimensionsType dimensionType : counterType.getDimensions()) {\n\n              // find and fire most recent value for metric/dimension\n              final List<MetricDimensionsValuesType> values =\n                  Lists.newArrayList(dimensionType.getValues());\n\n              //CloudWatch use case of metric data\n\n              if(!values.isEmpty()) {\n\n                for (MetricDimensionsValuesType value : values) {\n                  final Double currentValue = value.getValue();\n                  final Long currentTimeStamp = value.getTimestamp().getTime();\n                  sendSystemMetric(new Supplier<InstanceUsageEvent>() {\n                    @Override\n                    public InstanceUsageEvent get() {\n                      return new InstanceUsageEvent(\n                          sensorData.getResourceUuid(),\n                          sensorData.getResourceName(),\n                          metricType.getMetricName(),\n                          dimensionType.getSequenceNum(),\n                          dimensionType.getDimensionName(),\n                          currentValue,\n                          currentTimeStamp);\n                    }\n                  });\n                }\n              }\n\n              //Reporting use case of metric data from the cc\n\n              Collections.sort(values, Ordering.natural().onResultOf(GetTimestamp.INSTANCE));\n\n              if (!values.isEmpty()) {\n                final MetricDimensionsValuesType latestValue = Iterables.getLast(values);\n                final Double usageValue = latestValue.getValue();\n                final Long usageTimestamp = latestValue.getTimestamp().getTime();\n                final long sequenceNumber = dimensionType.getSequenceNum() + (values.size() - 1);\n                fireUsageEvent( new Supplier<InstanceUsageEvent>(){\n                  @Override\n                  public InstanceUsageEvent get() {\n                    return new InstanceUsageEvent(\n                        sensorData.getResourceUuid(),\n                        sensorData.getResourceName(),\n                        metricType.getMetricName(),\n                        sequenceNumber,\n                        dimensionType.getDimensionName(),\n                        usageValue,\n                        usageTimestamp);\n                  }\n                });\n              }\n            }\n          }\n        }\n      }\n    } catch (Exception ex) {\n      LOG.debug(\"Unable to fire describe sensors call back\", ex);\n    }\n  }","id":33923,"modified_method":"@Override\n  public void fire(final DescribeSensorsResponse msg) {\n    try {\n      final Iterable<String> uuidList =\n          Iterables.transform(VmInstances.list(VmState.RUNNING), VmInstances.toInstanceUuid());\n      LOG.debug(\"DescribeSensorCallback (fire) called at \" + new Date());\n      for (final SensorsResourceType sensorData : msg.getSensorsResources()) {\n        if (!RESOURCE_TYPE_INSTANCE.equals(sensorData.getResourceType()) ||\n            !Iterables.contains(uuidList, sensorData.getResourceUuid()))\n          continue;\n        \n        for (final MetricsResourceType metricType : sensorData.getMetrics()) {\n          for (final MetricCounterType counterType : metricType.getCounters()) {\n            for (final MetricDimensionsType dimensionType : counterType.getDimensions()) {\n\n              // find and fire most recent value for metric/dimension\n              final List<MetricDimensionsValuesType> values =\n                  Lists.newArrayList(dimensionType.getValues());\n\n              //CloudWatch use case of metric data\n\n              if(!values.isEmpty()) {\n                // best to enter older data first...\n                Collections.sort(values, Ordering.natural().onResultOf(GetTimestamp.INSTANCE));\n\n                for (MetricDimensionsValuesType value : values) {\n                  LOG.debug(\"ResourceUUID: \" + sensorData.getResourceUuid());\n                  LOG.debug(\"ResourceName: \" + sensorData.getResourceName());\n                  LOG.debug(\"Metric: \" + metricType.getMetricName());\n                  LOG.debug(\"Dimension: \" + dimensionType.getDimensionName());\n                  LOG.debug(\"Timestamp: \" + value.getTimestamp());\n                  LOG.debug(\"Value: \" + value.getValue());\n                  final Long currentTimeStamp = value.getTimestamp().getTime();\n                  final Double currentValue = value.getValue();\n                  sendSystemMetric(new Supplier<InstanceUsageEvent>() {\n                    @Override\n                    public InstanceUsageEvent get() {\n                      return new InstanceUsageEvent(\n                          sensorData.getResourceUuid(),\n                          sensorData.getResourceName(),\n                          metricType.getMetricName(),\n                          dimensionType.getSequenceNum(),\n                          dimensionType.getDimensionName(),\n                          currentValue,\n                          currentTimeStamp);\n                    }\n                  });\n                }\n              }\n\n              //Reporting use case of metric data from the cc\n              Collections.sort(values, Ordering.natural().onResultOf(GetTimestamp.INSTANCE));\n\n              if (!values.isEmpty()) {\n                final MetricDimensionsValuesType latestValue = Iterables.getLast(values);\n                final Double usageValue = latestValue.getValue();\n                final Long usageTimestamp = latestValue.getTimestamp().getTime();\n                final long sequenceNumber = dimensionType.getSequenceNum() + (values.size() - 1);\n                fireUsageEvent( new Supplier<InstanceUsageEvent>(){\n                  @Override\n                  public InstanceUsageEvent get() {\n                    return new InstanceUsageEvent(\n                        sensorData.getResourceUuid(),\n                        sensorData.getResourceName(),\n                        metricType.getMetricName(),\n                        sequenceNumber,\n                        dimensionType.getDimensionName(),\n                        usageValue,\n                        usageTimestamp);\n                  }\n                });\n              }\n            }\n          }\n        }\n      }\n    } catch (Exception ex) {\n      LOG.debug(\"Unable to fire describe sensors call back\", ex);\n    }\n  }","commit_id":"99a4bc21967c2392680e874ef0ac969e75b527eb","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private boolean adjustAbsoluteVolumeValue(MetricDatum datum,\n      String absoluteMetricName, String relativeMetricName, String volumeId) {\n    MetricDifferenceInfo info = AbsoluteMetricHelper.calculateDifferenceSinceLastEvent(\"AWS/EBS\", absoluteMetricName, \"VolumeId\", volumeId, datum.getTimestamp(), datum.getValue());\n    if (info != null) {\n      datum.setMetricName(relativeMetricName);\n      datum.setValue(info.getValueDifference());\n      return true; //don't continue;\n    }\n    return false; // continue\n  }","id":33924,"modified_method":"private boolean adjustAbsoluteVolumeStatisticSet(MetricDatum datum,\n      String absoluteMetricName, String relativeMetricName, String volumeId) {\n    if (volumeId == null) return false;\n    MetricDifferenceInfo info = AbsoluteMetricHelper.calculateDifferenceSinceLastEvent(\"AWS/EBS\", absoluteMetricName, \"VolumeId\", volumeId, datum.getTimestamp(), datum.getValue());\n    if (info != null) {\n      datum.setMetricName(relativeMetricName);\n      // we need to weigh this data based on the time.  use a statistic set instead of the value\n      datum.setValue(null);\n      StatisticSet statisticSet = new StatisticSet();\n      double sampleCount = (double) info.getElapsedTimeInMillis() / 60000.0; // number of minutes (this weights the value)\n      statisticSet.setSum(info.getValueDifference());\n      statisticSet.setMaximum(info.getValueDifference() / sampleCount);\n      statisticSet.setMinimum(info.getValueDifference() / sampleCount);\n      statisticSet.setSampleCount(sampleCount);\n      datum.setStatisticValues(statisticSet);\n      return true; //don't continue;\n    }\n    return false; // continue\n  }","commit_id":"99a4bc21967c2392680e874ef0ac969e75b527eb","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void insertMetricData(final String ownerAccountId, final String nameSpace,\n      final List<MetricDatum> metricDatum, final MetricType metricType) {\n    List<MetricDatum> extraData = new ArrayList<MetricDatum>(); // some metrics are derived\n    Date now = new Date();\n    for (final MetricDatum datum : metricDatum) {\n      // Deal with some absolute metrics\n      // VolumeReadOps\n      // VolumeWriteOps\n      // VolumeReadBytes\n      // VolumeWriteBytes\n      // VolumeTotalReadTime\n      // VolumeTotalWriteTime\n      // CPUUtilization (special case)\n      if (\"AWS/EBS\".equals(nameSpace) && metricType == MetricType.System) {\n        String volumeId = null;\n        if ((datum.getDimensions() != null) && (datum.getDimensions().getMember() != null)) {\n          for (Dimension dimension: datum.getDimensions().getMember()) {\n            if (\"VolumeId\".equals(dimension.getName())) {\n              volumeId = dimension.getValue();\n            }\n          }\n          if (volumeId != null) {\n            if (\"VolumeReadOpsTotal\".equals(datum.getMetricName())) {\n              if (!adjustAbsoluteVolumeValue(datum, \"VolumeReadOpsTotal\", \"VolumeReadOps\", volumeId)) continue;\n              extraData.add(createVolumeThroughputMetric(datum));\n            } \n            if (\"VolumeWriteOpsTotal\".equals(datum.getMetricName())) {\n              if (!adjustAbsoluteVolumeValue(datum, \"VolumeWriteOpsTotal\", \"VolumeWriteOps\", volumeId)) continue;\n            } \n            if (\"VolumeReadBytesTotal\".equals(datum.getMetricName())) {\n              if (!adjustAbsoluteVolumeValue(datum, \"VolumeReadBytesTotal\", \"VolumeReadBytes\", volumeId)) continue;\n            } \n            if (\"VolumeWriteBytesTotal\".equals(datum.getMetricName())) {\n              if (!adjustAbsoluteVolumeValue(datum, \"VolumeWriteBytesTotal\", \"VolumeWriteBytes\", volumeId)) continue;\n            } \n            if (\"VolumeTotalReadTimeTotal\".equals(datum.getMetricName())) {\n              if (!adjustAbsoluteVolumeValue(datum, \"VolumeTotalReadTimeTotal\", \"VolumeTotalReadTime\", volumeId)) continue;\n            } \n            if (\"VolumeTotalWriteTimeTotal\".equals(datum.getMetricName())) {\n              if (!adjustAbsoluteVolumeValue(datum, \"VolumeTotalWriteTimeTotal\", \"VolumeTotalWriteTime\", volumeId)) continue;\n            } \n          }\n        }        \n      }            \n      if (\"AWS/EC2\".equals(nameSpace) && metricType == MetricType.System) {\n        String instanceId = null;\n        if ((datum.getDimensions() != null) && (datum.getDimensions().getMember() != null)) {\n          for (Dimension dimension: datum.getDimensions().getMember()) {\n            if (\"InstanceId\".equals(dimension.getName())) {\n              instanceId = dimension.getValue();\n            }\n          }\n          if (instanceId != null) {\n            if (\"CPUUtilizationMS\".equals(datum.getMetricName())) {\n              if (!adjustAbsoluteCPUValue(datum, \"CPUUtilizationMS\", \"CPUUtilization\", instanceId)) continue;\n            } \n          }\n        }        \n      }\n    }\n    metricDatum.addAll(extraData);\n    for (final MetricDatum datum : metricDatum) {\n      scrub(datum, now);\n      final ArrayList<Dimension> dimensions = datum.getDimensions().getMember(); \n      queue(new Supplier<MetricQueueItem>() {\n        @Override\n        public MetricQueueItem get() {\n          MetricQueueItem metricMetadata = new MetricQueueItem();\n          metricMetadata.setAccountId(ownerAccountId);\n          metricMetadata.setMetricName(datum.getMetricName());\n          metricMetadata.setNamespace(nameSpace);\n          metricMetadata.setDimensionMap(makeDimensionMap(dimensions));\n          metricMetadata.setMetricType(metricType);\n          metricMetadata.setUnits(Units.fromValue(datum.getUnit())); \n          metricMetadata.setTimestamp(datum.getTimestamp());\n          if (datum.getValue() != null) { // Either or case taken care of in service\n            metricMetadata.setSampleMax(datum.getValue());\n            metricMetadata.setSampleMin(datum.getValue());\n            metricMetadata.setSampleSum(datum.getValue());\n            metricMetadata.setSampleSize(1.0);\n          } else if ((datum.getStatisticValues() != null) &&\n                (datum.getStatisticValues().getMaximum() != null) &&\n                (datum.getStatisticValues().getMinimum() != null) &&\n                (datum.getStatisticValues().getSum() != null) &&\n                (datum.getStatisticValues().getSampleCount() != null)) {\n              metricMetadata.setSampleMax(datum.getStatisticValues().getMaximum());\n              metricMetadata.setSampleMin(datum.getStatisticValues().getMinimum());\n              metricMetadata.setSampleSum(datum.getStatisticValues().getSum());\n              metricMetadata.setSampleSize(datum.getStatisticValues().getSampleCount());\n          } else {\n            throw new RuntimeException(\"Statistics set (all values) or Value must be set\"); \n          }\n          return metricMetadata;\n        }\n\n      });\n    }\n  }","id":33925,"modified_method":"public void insertMetricData(final String ownerAccountId, final String nameSpace,\n      final List<MetricDatum> metricDatum, final MetricType metricType) {\n    List<MetricDatum> dataToInsert = new ArrayList<MetricDatum>(); \n    // Some points do not actually go in.  If a data point represents an absolute value, the first one does not go in.\n    // Also, some data points are added while we go through the list (derived metrics)\n    Date now = new Date();\n    for (final MetricDatum datum : metricDatum) {\n      LOG.debug(\"Received metric datum: \" + nameSpace + \" \" + datum.getMetricName() + \" \" + datum.getTimestamp());\n      // Deal with the absolute metrics\n      // CPUUtilization\n      // VolumeReadOps\n      // VolumeWriteOps\n      // VolumeReadBytes\n      // VolumeWriteBytes\n      // VolumeTotalReadTime\n      // VolumeTotalWriteTime\n      // DiskReadOps\n      // DiskWriteOps\n      // DiskReadBytes\n      // DiskWriteBytes\n      // NetworkIn \n      // NetworkInExternal (added as an additional NetworkIn metric)\n      // NetworkOut\n      // NetworkOutExternal (added as an additional NetworkOut metric)\n    \n      if (\"AWS/EBS\".equals(nameSpace) && metricType == MetricType.System) {\n        String volumeId = null;\n        if ((datum.getDimensions() != null) && (datum.getDimensions().getMember() != null)) {\n          for (Dimension dimension: datum.getDimensions().getMember()) {\n            if (\"VolumeId\".equals(dimension.getName())) {\n              volumeId = dimension.getValue();\n            }\n          }\n        }\n        if (EBS_ABSOLUTE_METRICS.containsKey(datum.getMetricName())) {\n          // we check if the point below is a 'first' point, or maybe a point in the past.  Either case reject it.\n          if (!adjustAbsoluteVolumeStatisticSet(datum, datum.getMetricName(), EBS_ABSOLUTE_METRICS.get(datum.getMetricName()), volumeId)) continue; \n        }\n        // one special case here (hack) -- we bind a derived metric to one of the voumne metrics, VolumeReadOpsAbsolute, just arbitrarily.\n        if (\"VolumeReadOpsAbsolute\".equals(datum.getMetricName())) { // special case\n          dataToInsert.add(createVolumeThroughputMetric(datum));\n        }\n      }\n      \n      if (\"AWS/EC2\".equals(nameSpace) && metricType == MetricType.System) {\n        String instanceId = null;\n        if ((datum.getDimensions() != null) && (datum.getDimensions().getMember() != null)) {\n          for (Dimension dimension: datum.getDimensions().getMember()) {\n            if (\"InstanceId\".equals(dimension.getName())) {\n              instanceId = dimension.getValue();\n            }\n          }\n        }\n        if (EC2_ABSOLUTE_METRICS.containsKey(datum.getMetricName())) {\n          if (!adjustAbsoluteInstanceStatisticSet(datum, datum.getMetricName(), EC2_ABSOLUTE_METRICS.get(datum.getMetricName()), instanceId)) continue; \n        } else if (\"CPUUtilizationMSAbsolute\".equals(datum.getMetricName())) { // special case\n          // we check if the point below is a 'first' point, or maybe a point in the past.  Either case reject it.\n          if (!adjustAbsoluteInstanceCPUStatisticSet(datum, \"CPUUtilizationMSAbsolute\", \"CPUUtilization\", instanceId)) continue;\n        } \n      }        \n      dataToInsert.add(datum); // this data point is ok\n    }\n    for (final MetricDatum datum : dataToInsert) {\n      scrub(datum, now);\n      final ArrayList<Dimension> dimensions = datum.getDimensions().getMember(); \n      queue(new Supplier<MetricQueueItem>() {\n        @Override\n        public MetricQueueItem get() {\n          MetricQueueItem metricMetadata = new MetricQueueItem();\n          metricMetadata.setAccountId(ownerAccountId);\n          metricMetadata.setMetricName(datum.getMetricName());\n          metricMetadata.setNamespace(nameSpace);\n          metricMetadata.setDimensionMap(makeDimensionMap(dimensions));\n          metricMetadata.setMetricType(metricType);\n          metricMetadata.setUnits(Units.fromValue(datum.getUnit())); \n          metricMetadata.setTimestamp(datum.getTimestamp());\n          if (datum.getValue() != null) { // Either or case taken care of in service\n            metricMetadata.setSampleMax(datum.getValue());\n            metricMetadata.setSampleMin(datum.getValue());\n            metricMetadata.setSampleSum(datum.getValue());\n            metricMetadata.setSampleSize(1.0);\n          } else if ((datum.getStatisticValues() != null) &&\n                (datum.getStatisticValues().getMaximum() != null) &&\n                (datum.getStatisticValues().getMinimum() != null) &&\n                (datum.getStatisticValues().getSum() != null) &&\n                (datum.getStatisticValues().getSampleCount() != null)) {\n              metricMetadata.setSampleMax(datum.getStatisticValues().getMaximum());\n              metricMetadata.setSampleMin(datum.getStatisticValues().getMinimum());\n              metricMetadata.setSampleSum(datum.getStatisticValues().getSum());\n              metricMetadata.setSampleSize(datum.getStatisticValues().getSampleCount());\n          } else {\n            throw new RuntimeException(\"Statistics set (all values) or Value must be set\"); \n          }\n          return metricMetadata;\n        }\n\n      });\n    }\n  }","commit_id":"99a4bc21967c2392680e874ef0ac969e75b527eb","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private boolean adjustAbsoluteCPUValue(MetricDatum datum, String absoluteMetricName,\n      String relativeMetricName, String instanceId) {\n    MetricDifferenceInfo info = AbsoluteMetricHelper.calculateDifferenceSinceLastEvent(\"AWS/EC2\", absoluteMetricName, \"InstanceId\", instanceId, datum.getTimestamp(), datum.getValue());\n    if (info != null) {\n      // calculate percentage\n      double percentage = 0.0;\n      if (info.getElapsedTimeInMillis() != 0) {\n        // don't want to divide by 0\n        percentage = 100.0 * (info.getValueDifference() / info.getElapsedTimeInMillis());\n      }\n      datum.setMetricName(relativeMetricName);\n      datum.setValue(percentage);\n      datum.setUnit(Units.Percent.toString());\n      return true; //don't continue;\n    }\n    return false; // continue\n  }","id":33926,"modified_method":"private boolean adjustAbsoluteInstanceCPUStatisticSet(MetricDatum datum, String absoluteMetricName,\n      String relativeMetricName, String instanceId) {\n    MetricDifferenceInfo info = AbsoluteMetricHelper.calculateDifferenceSinceLastEvent(\"AWS/EC2\", absoluteMetricName, \"InstanceId\", instanceId, datum.getTimestamp(), datum.getValue());\n    if (info != null) {\n      // calculate percentage\n      double percentage = 0.0;\n      if (info.getElapsedTimeInMillis() != 0) {\n        // don't want to divide by 0\n        percentage = 100.0 * (info.getValueDifference() / info.getElapsedTimeInMillis());\n      }\n      datum.setMetricName(relativeMetricName);\n      datum.setValue(null);\n      StatisticSet statisticSet = new StatisticSet();\n      statisticSet.setMaximum(percentage);\n      statisticSet.setMinimum(percentage);\n      double sampleCount = (double) info.getElapsedTimeInMillis() / 60000.0; // number of minutes (this weights the value)\n      statisticSet.setSum(sampleCount * percentage);\n      statisticSet.setSampleCount(sampleCount);\n      datum.setStatisticValues(statisticSet);\n      datum.setUnit(Units.Percent.toString());\n      return true; //don't continue;\n    }\n    return false; // continue\n  }","commit_id":"99a4bc21967c2392680e874ef0ac969e75b527eb","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private MetricDatum createVolumeThroughputMetric(MetricDatum datum) {\n    // add volume throughput percentage.  (The guess is that there will be a set of volume metrics.  \n    // Attach it to one so it will be sent as many times as the others.\n    // add one\n    MetricDatum vtpDatum = new MetricDatum();\n    vtpDatum.setMetricName(\"VolumeThroughputPercentage\");\n    vtpDatum.setTimestamp(datum.getTimestamp());\n    vtpDatum.setUnit(Units.Percent.toString());\n    vtpDatum.setValue(100.0); // Any time we have a volume data, this value is 100%\n    // use the same dimensions as current metric\n    Dimensions vtpDimensions = new Dimensions();\n    ArrayList<Dimension> vtpDimensionsMember = new ArrayList<Dimension>();\n    for (Dimension dimension: datum.getDimensions().getMember()) {\n      Dimension vtpDimension = new Dimension();\n      vtpDimension.setName(dimension.getName());\n      vtpDimension.setValue(dimension.getValue());\n      vtpDimensionsMember.add(vtpDimension);\n    }\n    vtpDimensions.setMember(vtpDimensionsMember);\n    vtpDatum.setDimensions(vtpDimensions);\n    return vtpDatum;\n  }","id":33927,"modified_method":"private MetricDatum createVolumeThroughputMetric(MetricDatum datum) {\n    // add volume throughput percentage.  (The guess is that there will be a set of volume metrics.  \n    // Attach it to one so it will be sent as many times as the others.\n    // add one\n    MetricDatum vtpDatum = new MetricDatum();\n    vtpDatum.setMetricName(\"VolumeThroughputPercentage\");\n    vtpDatum.setTimestamp(datum.getTimestamp());\n    vtpDatum.setUnit(Units.Percent.toString());\n    // should be 100% but weigh it the same\n    if (datum.getValue() != null) {\n      vtpDatum.setValue(100.0); // Any time we have a volume data, this value is 100%\n    } else if (datum.getStatisticValues() != null) {\n      StatisticSet statisticSet = new StatisticSet();\n      statisticSet.setMaximum(100.0);\n      statisticSet.setMinimum(100.0);\n      statisticSet.setSum(100.0 * datum.getStatisticValues().getSampleCount());\n      statisticSet.setSampleCount(datum.getStatisticValues().getSampleCount());\n      vtpDatum.setStatisticValues(statisticSet);\n    }\n    // use the same dimensions as current metric\n    Dimensions vtpDimensions = new Dimensions();\n    ArrayList<Dimension> vtpDimensionsMember = new ArrayList<Dimension>();\n    for (Dimension dimension: datum.getDimensions().getMember()) {\n      Dimension vtpDimension = new Dimension();\n      vtpDimension.setName(dimension.getName());\n      vtpDimension.setValue(dimension.getValue());\n      vtpDimensionsMember.add(vtpDimension);\n    }\n    vtpDimensions.setMember(vtpDimensionsMember);\n    vtpDatum.setDimensions(vtpDimensions);\n    return vtpDatum;\n  }","commit_id":"99a4bc21967c2392680e874ef0ac969e75b527eb","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            controller.drawCards(2, game);\r\n            CardsDrawnThisTurnWatcher watcher = (CardsDrawnThisTurnWatcher) game.getState().getWatchers().get(\"CardsDrawnThisTurnWatcher\", source.getControllerId());\r\n            if (watcher != null) {\r\n                Cards cards = new CardsImpl();\r\n                for (UUID cardId : controller.getHand()) {\r\n                    if (watcher.getCardsDrawnThisTurn().contains(cardId)) {\r\n                        Card card = game.getCard(cardId);\r\n                        if (card != null) {\r\n                            cards.add(card);\r\n                        }\r\n                    }\r\n                }\r\n                int numberOfTargets = Math.min(2, cards.size());\r\n                if (numberOfTargets > 0) {\r\n                    FilterCard filter = new FilterCard(numberOfTargets + \" cards of cards drawn this turn\");\r\n                    filter.add(new CardIdPredicate(cards));\r\n                    TargetCardInHand target = new TargetCardInHand(numberOfTargets, filter);\r\n                    controller.choose(outcome, target, source.getSourceId(), game);\r\n\r\n                    Cards cardsPutBack = new CardsImpl();\r\n                    for (UUID cardId : target.getTargets()) {\r\n                        Card card = cards.get(cardId, game);\r\n                        if (card != null) {\r\n                            if (controller.canPayLifeCost()\r\n                                    && controller.getLife() >= 4\r\n                                    && controller.chooseUse(outcome, \"Pay 4 life for \" + card.getLogName() + \"? (Otherwise it's put on top of your library)\", source, game)) {\r\n                                controller.loseLife(4, game);\r\n                                game.informPlayers(controller.getLogName() + \" pays 4 life to keep a card on hand\");\r\n                            } else {\r\n                                cardsPutBack.add(card);\r\n                            }\r\n                        }\r\n                    }\r\n                    int numberOfCardsToPutBack = cardsPutBack.size();\r\n                    if (numberOfCardsToPutBack > 1) {\r\n                        TargetCard target2 = new TargetCard(Zone.PICK, new FilterCard(\"card to put on the top of your library (last chosen will be on top)\"));\r\n                        while (controller.canRespond() && cardsPutBack.size() > 1) {\r\n                            controller.choose(Outcome.Benefit, cardsPutBack, target2, game);\r\n                            Card card = cardsPutBack.get(target2.getFirstTarget(), game);\r\n                            if (card != null) {\r\n                                cardsPutBack.remove(card);\r\n                                card.moveToZone(Zone.LIBRARY, source.getSourceId(), game, true);\r\n                            }\r\n                            target2.clearChosen();\r\n                        }\r\n                    }\r\n                    if (cardsPutBack.size() == 1) {\r\n                        Card card = cardsPutBack.get(cardsPutBack.iterator().next(), game);\r\n                        card.moveToZone(Zone.LIBRARY, source.getSourceId(), game, true);\r\n                    }\r\n                    if (numberOfCardsToPutBack > 0) {\r\n                        game.informPlayers(controller.getLogName() + \" puts \" + numberOfCardsToPutBack + \" card(s) back to library\");\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":33928,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            controller.drawCards(2, game);\r\n            CardsDrawnThisTurnWatcher watcher = (CardsDrawnThisTurnWatcher) game.getState().getWatchers().get(\"CardsDrawnThisTurnWatcher\");\r\n            if (watcher != null) {\r\n                Cards cards = new CardsImpl();\r\n                for (UUID cardId : controller.getHand()) {\r\n                    if (watcher.getCardsDrawnThisTurn(controller.getId()).contains(cardId)) {\r\n                        Card card = game.getCard(cardId);\r\n                        if (card != null) {\r\n                            cards.add(card);\r\n                        }\r\n                    }\r\n                }\r\n                int numberOfTargets = Math.min(2, cards.size());\r\n                if (numberOfTargets > 0) {\r\n                    FilterCard filter = new FilterCard(numberOfTargets + \" cards of cards drawn this turn\");\r\n                    filter.add(new CardIdPredicate(cards));\r\n                    TargetCardInHand target = new TargetCardInHand(numberOfTargets, filter);\r\n                    controller.choose(outcome, target, source.getSourceId(), game);\r\n\r\n                    Cards cardsPutBack = new CardsImpl();\r\n                    for (UUID cardId : target.getTargets()) {\r\n                        Card card = cards.get(cardId, game);\r\n                        if (card != null) {\r\n                            if (controller.canPayLifeCost()\r\n                                    && controller.getLife() >= 4\r\n                                    && controller.chooseUse(outcome, \"Pay 4 life for \" + card.getLogName() + \"? (Otherwise it's put on top of your library)\", source, game)) {\r\n                                controller.loseLife(4, game);\r\n                                game.informPlayers(controller.getLogName() + \" pays 4 life to keep a card on hand\");\r\n                            } else {\r\n                                cardsPutBack.add(card);\r\n                            }\r\n                        }\r\n                    }\r\n                    int numberOfCardsToPutBack = cardsPutBack.size();\r\n                    if (numberOfCardsToPutBack > 1) {\r\n                        TargetCard target2 = new TargetCard(Zone.PICK, new FilterCard(\"card to put on the top of your library (last chosen will be on top)\"));\r\n                        while (controller.canRespond() && cardsPutBack.size() > 1) {\r\n                            controller.choose(Outcome.Benefit, cardsPutBack, target2, game);\r\n                            Card card = cardsPutBack.get(target2.getFirstTarget(), game);\r\n                            if (card != null) {\r\n                                cardsPutBack.remove(card);\r\n                                card.moveToZone(Zone.LIBRARY, source.getSourceId(), game, true);\r\n                            }\r\n                            target2.clearChosen();\r\n                        }\r\n                    }\r\n                    if (cardsPutBack.size() == 1) {\r\n                        Card card = cardsPutBack.get(cardsPutBack.iterator().next(), game);\r\n                        card.moveToZone(Zone.LIBRARY, source.getSourceId(), game, true);\r\n                    }\r\n                    if (numberOfCardsToPutBack > 0) {\r\n                        game.informPlayers(controller.getLogName() + \" puts \" + numberOfCardsToPutBack + \" card(s) back to library\");\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"d145885d2d20ca8a617b0a65f5723073e76a8d9f","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public void watch(GameEvent event, Game game) {\r\n        if (event.getType() == GameEvent.EventType.DREW_CARD && event.getPlayerId().equals(this.getControllerId())) {\r\n            cardsDrawnThisTurn.add(event.getTargetId());\r\n        }\r\n    }","id":33929,"modified_method":"@Override\r\n    public void watch(GameEvent event, Game game) {\r\n        if (event.getType() == GameEvent.EventType.DREW_CARD) {\r\n            if (!cardsDrawnThisTurn.containsKey(event.getPlayerId())) {\r\n                Set<UUID> cardsDrawn = new LinkedHashSet<>();\r\n                cardsDrawnThisTurn.put(event.getPlayerId(), cardsDrawn);\r\n            }\r\n            Set<UUID> cardsDrawn = cardsDrawnThisTurn.get(event.getPlayerId());\r\n            cardsDrawn.add(event.getTargetId());\r\n        }\r\n    }","commit_id":"d145885d2d20ca8a617b0a65f5723073e76a8d9f","url":"https://github.com/magefree/mage"},{"original_method":"public CardsDrawnThisTurnWatcher() {\r\n        super(\"CardsDrawnThisTurnWatcher\", WatcherScope.PLAYER);\r\n    }","id":33930,"modified_method":"public CardsDrawnThisTurnWatcher() {\r\n        super(\"CardsDrawnThisTurnWatcher\", WatcherScope.GAME);\r\n    }","commit_id":"d145885d2d20ca8a617b0a65f5723073e76a8d9f","url":"https://github.com/magefree/mage"},{"original_method":"public CardsDrawnThisTurnWatcher(final CardsDrawnThisTurnWatcher watcher) {\r\n        super(watcher);\r\n        this.cardsDrawnThisTurn.addAll(watcher.cardsDrawnThisTurn);\r\n    }","id":33931,"modified_method":"public CardsDrawnThisTurnWatcher(final CardsDrawnThisTurnWatcher watcher) {\r\n        super(watcher);\r\n        this.cardsDrawnThisTurn.putAll(watcher.cardsDrawnThisTurn);\r\n    }","commit_id":"d145885d2d20ca8a617b0a65f5723073e76a8d9f","url":"https://github.com/magefree/mage"},{"original_method":"public Set<UUID> getCardsDrawnThisTurn() {\r\n        return cardsDrawnThisTurn;\r\n    }","id":33932,"modified_method":"public Set<UUID> getCardsDrawnThisTurn(UUID playerId) {\r\n        return cardsDrawnThisTurn.get(playerId);\r\n    }","commit_id":"d145885d2d20ca8a617b0a65f5723073e76a8d9f","url":"https://github.com/magefree/mage"},{"original_method":"protected void doTestIncrementalGeneration(final MPSProject p, final SModelDescriptor descr, final Runnable ...changeModel) throws IOException {\n    GeneratorManager gm = p.getProject().getComponent(GeneratorManager.class);\n\n    File generatorCaches = new File(PathManager.getSystemPath(), \"mps-generator-test\");\n    if(generatorCaches.exists()) {\n      Assert.assertTrue(FileUtil.delete(generatorCaches));\n    }\n    Assert.assertTrue(generatorCaches.mkdir());\n\n    final FileBasedGenerationCacheContainer generationCacheContainer = new FileBasedGenerationCacheContainer(generatorCaches);\n    IncrementalGenerationStrategy incrementalStrategy = new IncrementalGenerationStrategy() {\n      @Override\n      public Map<String, String> getModelHashes(SModelDescriptor sm, IOperationContext operationContext) {\n        return ModelDigestHelper.getInstance().getGenerationHashes(sm, operationContext);\n      }\n\n      @Override\n      public GenerationCacheContainer getContainer() {\n        return generationCacheContainer;\n      }\n\n      @Override\n      public GenerationDependencies getDependencies(SModelDescriptor sm) {\n        return GenerationDependenciesCache.getInstance().get(sm);\n      }\n    };\n\n    // Stage 0. Save model content.\n    byte[] content = readContent(((EditableSModelDescriptor)descr).getModelFile());\n\n    // Stage 1. Regenerate\n\n    GenerationOptions options = GenerationOptions.getDefaults()\n      .rebuildAll(true).strictMode(true).reporting(true, true, false, 2).incremental(incrementalStrategy).create();\n    IncrementalTestGenerationHandler generationHandler = new IncrementalTestGenerationHandler();\n    gm.generateModels(\n      Collections.singletonList(descr), ModuleContext.create(descr, p.getProject()),\n      generationHandler,\n      new EmptyProgressIndicator(), generationHandler.getMessageHandler(), options);\n\n    assertNoDiff(generationHandler.getExistingContent(), generationHandler.getGeneratedContent());\n\n    try {\n      // Stage 2. Modify model\n      Map<String, String> incrementalGenerationResults = null;\n      List<Long> time = new ArrayList<Long>();\n      Assert.assertTrue(changeModel.length > 0);\n      for(final Runnable r : changeModel) {\n\n        ThreadUtils.runInUIThreadAndWait(new Runnable(){\n          @Override\n          public void run() {\n            ModelAccess.instance().runWriteActionInCommand(r, p.getProject());\n            ModelAccess.instance().runWriteAction(new Runnable(){\n              @Override\n              public void run() {\n                ((EditableSModelDescriptor)descr).save();\n              }\n            });\n          }\n        });\n\n        // Stage 3. Generate incrementally\n\n        options = GenerationOptions.getDefaults()\n          .rebuildAll(false).strictMode(true).reporting(true, true, false, 2).incremental(incrementalStrategy).create();\n        generationHandler = new IncrementalTestGenerationHandler(incrementalGenerationResults);\n        generationHandler.checkIncremental();\n        long start = System.nanoTime();\n        gm.generateModels(\n          Collections.singletonList(descr), ModuleContext.create(descr, p.getProject()),\n          generationHandler,\n          new EmptyProgressIndicator(), generationHandler.getMessageHandler(), options);\n        time.add(System.nanoTime() - start);\n\n        incrementalGenerationResults = generationHandler.getGeneratedContent();\n        assertDiff(generationHandler.getExistingContent(), incrementalGenerationResults, 1);\n      }\n\n      // Stage 4. Regenerate. Check incremental results.\n\n      options = GenerationOptions.getDefaults()\n        .rebuildAll(true).strictMode(true).reporting(true, true, false, 2).incremental(incrementalStrategy).create();\n      generationHandler = new IncrementalTestGenerationHandler(incrementalGenerationResults);\n      long start = System.nanoTime();\n      gm.generateModels(\n        Collections.singletonList(descr), ModuleContext.create(descr, p.getProject()),\n        generationHandler,\n        new EmptyProgressIndicator(), generationHandler.getMessageHandler(), options);\n      time.add(System.nanoTime() - start);\n\n      assertNoDiff(generationHandler.getGeneratedContent(), incrementalGenerationResults);\n\n      if(DEBUG) {\n        long regen = time.remove(time.size() - 1);\n        System.out.print(\"Full cycle: \" + regen/1000000/1000.);\n        for(long l : time) {\n          System.out.print(\", incremental: \" + l/1000000/1000.);\n        }\n        System.out.println();\n      }\n    } finally {\n      writeContent(((EditableSModelDescriptor)descr).getModelFile(), content);\n\n      ThreadUtils.runInUIThreadAndWait(new Runnable(){\n        @Override\n        public void run() {\n          ModelAccess.instance().runWriteAction(new Runnable() {\n            @Override\n            public void run() {\n              ((EditableSModelDescriptor)descr).reloadFromDisk();\n            }\n          });\n        }\n      });\n    }\n  }","id":33933,"modified_method":"protected void doTestIncrementalGeneration(final MPSProject p, final SModelDescriptor descr, final Runnable ...changeModel) throws IOException {\n    GeneratorManager gm = p.getProject().getComponent(GeneratorManager.class);\n\n    File generatorCaches = new File(PathManager.getSystemPath(), \"mps-generator-test\");\n    if(generatorCaches.exists()) {\n      Assert.assertTrue(FileUtil.delete(generatorCaches));\n    }\n    Assert.assertTrue(generatorCaches.mkdir());\n\n    final MyIncrementalGenerationStrategy incrementalStrategy = new MyIncrementalGenerationStrategy(descr, new FileBasedGenerationCacheContainer(generatorCaches));\n    ModelAccess.instance().runReadAction(new Runnable() {\n      @Override\n      public void run() {\n        incrementalStrategy.buildHash();\n      }\n    });\n\n    // Stage 1. Regenerate\n\n    GenerationOptions options = GenerationOptions.getDefaults()\n      .rebuildAll(true).strictMode(true).reporting(true, true, false, 2).incremental(incrementalStrategy).create();\n    IncrementalTestGenerationHandler generationHandler = new IncrementalTestGenerationHandler();\n    gm.generateModels(\n      Collections.singletonList(descr), ModuleContext.create(descr, p.getProject()),\n      generationHandler,\n      new EmptyProgressIndicator(), generationHandler.getMessageHandler(), options);\n\n    assertNoDiff(generationHandler.getExistingContent(), generationHandler.getGeneratedContent());\n\n    // Stage 2. Modify model\n    Map<String, String> incrementalGenerationResults = null;\n    List<Long> time = new ArrayList<Long>();\n    Assert.assertTrue(changeModel.length > 0);\n    for(final Runnable r : changeModel) {\n\n      ThreadUtils.runInUIThreadAndWait(new Runnable(){\n        @Override\n        public void run() {\n          ModelAccess.instance().runWriteActionInCommand(r, p.getProject());\n        }\n      });\n\n      ModelAccess.instance().runReadAction(new Runnable() {\n        @Override\n        public void run() {\n          incrementalStrategy.buildHash();\n        }\n      });\n      Assert.assertNotNull(generationHandler.getLastDependencies());\n      incrementalStrategy.setDependencies(generationHandler.getLastDependencies());\n\n      // Stage 3. Generate incrementally\n\n      options = GenerationOptions.getDefaults()\n        .rebuildAll(false).strictMode(true).reporting(true, true, false, 2).incremental(incrementalStrategy).create();\n      generationHandler = new IncrementalTestGenerationHandler(incrementalGenerationResults);\n      generationHandler.checkIncremental();\n      long start = System.nanoTime();\n      gm.generateModels(\n        Collections.singletonList(descr), ModuleContext.create(descr, p.getProject()),\n        generationHandler,\n        new EmptyProgressIndicator(), generationHandler.getMessageHandler(), options);\n      time.add(System.nanoTime() - start);\n\n      incrementalGenerationResults = generationHandler.getGeneratedContent();\n      assertDiff(generationHandler.getExistingContent(), incrementalGenerationResults, 1);\n    }\n\n    // Stage 4. Regenerate. Check incremental results.\n\n    incrementalStrategy.setDependencies(null);\n    options = GenerationOptions.getDefaults()\n        .rebuildAll(true).strictMode(true).reporting(true, true, false, 2).incremental(incrementalStrategy).create();\n    generationHandler = new IncrementalTestGenerationHandler(incrementalGenerationResults);\n    long start = System.nanoTime();\n    gm.generateModels(\n      Collections.singletonList(descr), ModuleContext.create(descr, p.getProject()),\n      generationHandler,\n      new EmptyProgressIndicator(), generationHandler.getMessageHandler(), options);\n    time.add(System.nanoTime() - start);\n\n    assertNoDiff(generationHandler.getGeneratedContent(), incrementalGenerationResults);\n\n    PerformanceMessenger.getInstance().reportPercent(\"incrementalGeneration\", (time.get(time.size() - 2))/1000000, (time.get(time.size() - 1))/1000000);\n\n    if(DEBUG) {\n      long regen = time.remove(time.size() - 1);\n      System.out.print(\"Full cycle: \" + regen/1000000/1000.);\n      for(long l : time) {\n        System.out.print(\", incremental: \" + l/1000000/1000.);\n      }\n      System.out.println();\n    }\n  }","commit_id":"5536aafd199637599cb0fd66e4eec47a99a3e51f","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean handleOutput(IModule module, SModelDescriptor inputModel, GenerationStatus status, IOperationContext invocationContext, ITaskProgressHelper progressHelper) {\n    IFile targetDir = FileSystem.getInstance().getFileByPath(module.getOutputFor(inputModel));\n\n    Assert.assertTrue(status.isOk());\n    Assert.assertTrue(\"should be called once\", timesCalled++ == 0);\n\n    if(myCheckIncremental) {\n      GenerationDependencies dep = status.getDependencies();\n      Assert.assertTrue(\"was not optimized\", dep.getFromCacheCount() + dep.getSkippedCount() > 0);\n    }\n\n    if (status.isOk()) {\n      myFilesDir = FileGenerationUtil.getDefaultOutputDir(inputModel, targetDir);\n      IFile cachesDir = FileGenerationUtil.getDefaultOutputDir(inputModel, FileGenerationUtil.getCachesDir(targetDir));\n\n      StreamHandler streamHandler = new CollectingStreamHandler(cachesDir);\n      try {\n        boolean result = new TextGenerator(streamHandler,\n          //ModelGenerationStatusManager.getInstance().getCacheGenerator(),\n          BLDependenciesCache.getInstance().getGenerator(),\n          //TraceInfoCache.getInstance().getGenerator(),\n          GenerationDependenciesCache.getInstance().getGenerator()\n        ).handleOutput(invocationContext, status);\n        Assert.assertTrue(result);\n      } finally {\n        streamHandler.dispose();\n      }\n    }\n    return true;\n  }","id":33934,"modified_method":"@Override\n  public boolean handleOutput(IModule module, SModelDescriptor inputModel, GenerationStatus status, IOperationContext invocationContext, ITaskProgressHelper progressHelper) {\n    myLastDependencies = null;\n    IFile targetDir = FileSystem.getInstance().getFileByPath(module.getOutputFor(inputModel));\n\n    Assert.assertTrue(status.isOk());\n    Assert.assertTrue(\"should be called once\", timesCalled++ == 0);\n\n    if(myCheckIncremental) {\n      GenerationDependencies dep = status.getDependencies();\n      Assert.assertTrue(\"was not optimized\", dep.getFromCacheCount() + dep.getSkippedCount() > 0);\n    }\n\n    if (status.isOk()) {\n      myLastDependencies = status.getDependencies();\n      myFilesDir = FileGenerationUtil.getDefaultOutputDir(inputModel, targetDir);\n      IFile cachesDir = FileGenerationUtil.getDefaultOutputDir(inputModel, FileGenerationUtil.getCachesDir(targetDir));\n\n      StreamHandler streamHandler = new CollectingStreamHandler(cachesDir);\n      try {\n        boolean result = new TextGenerator(streamHandler,\n          //ModelGenerationStatusManager.getInstance().getCacheGenerator(),\n          BLDependenciesCache.getInstance().getGenerator(),\n          //TraceInfoCache.getInstance().getGenerator(),\n          GenerationDependenciesCache.getInstance().getGenerator()\n        ).handleOutput(invocationContext, status);\n        Assert.assertTrue(result);\n      } finally {\n        streamHandler.dispose();\n      }\n    }\n    return true;\n  }","commit_id":"5536aafd199637599cb0fd66e4eec47a99a3e51f","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public void saveStream(String name, Element content, boolean isCache) {\n      if (!isCache) {\n        try {\n          StringWriter writer = new StringWriter();\n          JDOMUtil.writeDocument(new Document(content), writer);\n          saveStream(name, writer.toString(), isCache);\n        } catch (IOException e) {\n          Assert.fail(e.toString());\n        }\n      } else if(name.equals(\".generated\")) {\n        try {\n          JDOMUtil.writeDocument(new Document(content), myCaches.child(name));\n        } catch (IOException e) {\n          Assert.fail(e.toString());\n        }\n      }\n    }","id":33935,"modified_method":"@Override\n    public void saveStream(String name, Element content, boolean isCache) {\n      if (!isCache) {\n        try {\n          StringWriter writer = new StringWriter();\n          JDOMUtil.writeDocument(new Document(content), writer);\n          saveStream(name, writer.toString(), isCache);\n        } catch (IOException e) {\n          Assert.fail(e.toString());\n        }\n      }\n    }","commit_id":"5536aafd199637599cb0fd66e4eec47a99a3e51f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    List<SNode> visibleDecl = new ArrayList<SNode>();\n    SNode taskCall = SNodeOperations.getAncestor(_context.getEnclosingNode(), \"jetbrains.mps.build.generictasks.structure.TaskCall\", true, false);\n    return TaskCall_Behavior.call_getUndefinedAttributes_353793545802643943(taskCall);\n  }","id":33936,"modified_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    final SNode taskCall = SNodeOperations.getAncestor(_context.getEnclosingNode(), \"jetbrains.mps.build.generictasks.structure.TaskCall\", true, false);\n    return new DefaultSearchScope(TaskCall_Behavior.call_getUndefinedAttributes_353793545802643943(taskCall)) {\n      @Override\n      public boolean isInScope(SNode node) {\n        if (SNodeOperations.isInstanceOf(node, \"jetbrains.mps.build.generictasks.structure.AttributeDeclaration\")) {\n          return false;\n        }\n        return ListSequence.fromList(ITaskDeclaration_Behavior.call_getAttributesDeclarations_1190349257898147625(SLinkOperations.getTarget(taskCall, \"declaration\", false))).contains(SNodeOperations.cast(node, \"jetbrains.mps.build.generictasks.structure.AttributeDeclaration\"));\n      }\n    };\n  }","commit_id":"ce40d7e4ac613b3d05adcec2bf3bdf3e435d210a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<SNode> virtual_getPossibleNesteds_1449762848926780436(SNode thisNode, List<SNode> declarations) {\n    return ListSequence.fromList(ITaskDeclaration_Behavior.callSuper_getPossibleNesteds_1449762848926780436(thisNode, \"jetbrains.mps.build.generictasks.structure.BuiltInTaskDeclaration\", declarations)).union(ListSequence.fromList(BuiltInTaskDeclaration_Behavior.call_getFakeDeclarations_353793545802644200(thisNode))).toListSequence();\n  }","id":33937,"modified_method":"public static Iterable<SNode> virtual_getPossibleNesteds_1449762848926780436(SNode thisNode, List<SNode> declarations) {\n    return Sequence.fromIterable(ITaskDeclaration_Behavior.callSuper_getPossibleNesteds_1449762848926780436(thisNode, \"jetbrains.mps.build.generictasks.structure.BuiltInTaskDeclaration\", declarations)).union(ListSequence.fromList(BuiltInTaskDeclaration_Behavior.call_getFakeDeclarations_353793545802644200(thisNode)));\n  }","commit_id":"ce40d7e4ac613b3d05adcec2bf3bdf3e435d210a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static File generate(final SNode configuration, SModelDescriptor descriptor, IOperationContext context, Project project, boolean showWindow) {\n    final String basedir = ModelAccess.instance().runReadAction(new Computable<String>() {\n      public String compute() {\n        return MPSLayout_Behavior.call_getFolderToGenerate_1229522949966(Configuration_Behavior.call_getLayout_1213877261819(configuration));\n      }\n    });\n    // generate files \n    final GeneratorManager generatorManager = project.getComponent(GeneratorManager.class);\n    final File[] fileToRun = new File[]{null};\n    TextGenerationHandler generationHandler = new TextGenerationHandler() {\n      @Override\n      protected void fileGenerated(String targetDir, String fileName, TextGenerationUtil.TextGenerationResult result) {\n        File target = new File(basedir + File.separator + fileName);\n        FileUtil.write(target, result.getText());\n        if (target.getName().equals(Configuration_Behavior.call_getBuildFileName_1230217425313(configuration) + \".xml\")) {\n          fileToRun[0] = target;\n        }\n      }\n    };\n    if (showWindow) {\n      generatorManager.generateModelsWithProgressWindow(ListSequence.fromListAndArray(new ArrayList<SModelDescriptor>(), descriptor), context, generationHandler, true);\n    } else {\n      generatorManager.generateModels(ListSequence.fromListAndArray(new ArrayList<SModelDescriptor>(), descriptor), context, generationHandler, new EmptyProgressIndicator(), new IMessageHandler() {\n        public void handle(Message message) {\n          switch (message.getKind()) {\n            case ERROR:\n              System.err.println(\"error: \" + message.getText());\n            case WARNING:\n              System.out.println(\"warning: \" + message.getText());\n            case INFORMATION:\n              System.out.println(\"info: \" + message.getText());\n            default:\n          }\n        }\n      });\n    }\n    return fileToRun[0];\n  }","id":33938,"modified_method":"public static File generate(final SNode configuration, SModelDescriptor descriptor, IOperationContext context, Project project, boolean showWindow) {\n    final String basedir = ModelAccess.instance().runReadAction(new Computable<String>() {\n      public String compute() {\n        return MPSLayout_Behavior.call_getFolderToGenerate_1229522949966(Configuration_Behavior.call_getLayout_1213877261819(configuration));\n      }\n    });\n    // generate files \n    final GeneratorManager generatorManager = project.getComponent(GeneratorManager.class);\n    final File[] fileToRun = new File[]{null};\n    TextGenerationHandler generationHandler = new TextGenerationHandler() {\n      @Override\n      protected void fileGenerated(String targetDir, String fileName, TextGenerationUtil.TextGenerationResult result) {\n        File target = new File(basedir + File.separator + fileName);\n        FileUtil.write(target, result.getText());\n        if (target.getName().equals(Configuration_Behavior.call_getBuildFileName_1230217425313(configuration) + \".xml\")) {\n          fileToRun[0] = target;\n        }\n      }\n    };\n    if (showWindow) {\n      generatorManager.generateModelsWithProgressWindow(ListSequence.fromListAndArray(new ArrayList<SModelDescriptor>(), descriptor), context, generationHandler, true);\n    } else {\n      generatorManager.generateModels(ListSequence.fromListAndArray(new ArrayList<SModelDescriptor>(), descriptor), context, generationHandler, new EmptyProgressIndicator(), new DefaultMessageHandler(project));\n    }\n    return fileToRun[0];\n  }","commit_id":"ce40d7e4ac613b3d05adcec2bf3bdf3e435d210a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<SNode> call_getPossibleNesteds_1449762848926780436(SNode thisNode, List<SNode> declarations) {\n    return (List<SNode>) BehaviorManager.getInstance().invoke(Object.class, SNodeOperations.cast(thisNode, \"jetbrains.mps.build.generictasks.structure.ITaskDeclaration\"), \"virtual_getPossibleNesteds_1449762848926780436\", PARAMETERS_1449762848926780436, declarations);\n  }","id":33939,"modified_method":"public static Iterable<SNode> call_getPossibleNesteds_1449762848926780436(SNode thisNode, List<SNode> declarations) {\n    return (Iterable<SNode>) BehaviorManager.getInstance().invoke(Object.class, SNodeOperations.cast(thisNode, \"jetbrains.mps.build.generictasks.structure.ITaskDeclaration\"), \"virtual_getPossibleNesteds_1449762848926780436\", PARAMETERS_1449762848926780436, declarations);\n  }","commit_id":"ce40d7e4ac613b3d05adcec2bf3bdf3e435d210a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<SNode> virtual_getPossibleNesteds_1449762848926780436(SNode thisNode, List<SNode> declarations) {\n    final List<SNode> nestedTasks = ITaskDeclaration_Behavior.call_getNestedTasks_4241383766070831847(thisNode);\n    return ListSequence.fromList(declarations).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return !(ITaskDeclaration_Behavior.call_filterMeOut_4710899751214010949(it)) && IDeclaration_Behavior.call_isHeirOf_5699548131010535105(it, nestedTasks) && !(IDeclaration_Behavior.call_isAbstract_5699548131010533031(it));\n      }\n    }).toListSequence();\n  }","id":33940,"modified_method":"public static Iterable<SNode> virtual_getPossibleNesteds_1449762848926780436(final SNode thisNode, List<SNode> declarations) {\n    final List<SNode> nestedTasks = ITaskDeclaration_Behavior.call_getNestedTasks_4241383766070831847(thisNode);\n    return ListSequence.fromList(declarations).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return ITaskDeclaration_Behavior.call_isPossibleNested_1648602681640249389(thisNode, it, nestedTasks);\n      }\n    });\n  }","commit_id":"ce40d7e4ac613b3d05adcec2bf3bdf3e435d210a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<SNode> callSuper_getPossibleNesteds_1449762848926780436(SNode thisNode, String callerConceptFqName, List<SNode> declarations) {\n    return (List<SNode>) BehaviorManager.getInstance().invokeSuper(Object.class, SNodeOperations.cast(thisNode, \"jetbrains.mps.build.generictasks.structure.ITaskDeclaration\"), callerConceptFqName, \"virtual_getPossibleNesteds_1449762848926780436\", PARAMETERS_1449762848926780436, declarations);\n  }","id":33941,"modified_method":"public static Iterable<SNode> callSuper_getPossibleNesteds_1449762848926780436(SNode thisNode, String callerConceptFqName, List<SNode> declarations) {\n    return (Iterable<SNode>) BehaviorManager.getInstance().invokeSuper(Object.class, SNodeOperations.cast(thisNode, \"jetbrains.mps.build.generictasks.structure.ITaskDeclaration\"), callerConceptFqName, \"virtual_getPossibleNesteds_1449762848926780436\", PARAMETERS_1449762848926780436, declarations);\n  }","commit_id":"ce40d7e4ac613b3d05adcec2bf3bdf3e435d210a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<SNode> call_getUndefinedAttributes_353793545802643943(SNode thisNode) {\n    List<SNode> result = new ArrayList<SNode>();\n    for (SNode attrDecl : ListSequence.fromList(BuiltInTaskDeclaration_Behavior.call_getAttributesDeaclarations_353793545802644071(SLinkOperations.getTarget(thisNode, \"declaration\", false)))) {\n      if (!(TaskCall_Behavior.call_isAttributeDefined_353793545802643915(thisNode, attrDecl))) {\n        ListSequence.fromList(result).addElement(attrDecl);\n      }\n    }\n    return result;\n  }","id":33942,"modified_method":"public static Iterable<SNode> call_getUndefinedAttributes_353793545802643943(final SNode thisNode) {\n    List<SNode> attributeDeclarations = ITaskDeclaration_Behavior.call_getAttributesDeclarations_1190349257898147625(SLinkOperations.getTarget(thisNode, \"declaration\", false));\n    return ListSequence.fromList(attributeDeclarations).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return !(TaskCall_Behavior.call_isAttributeDefined_353793545802643915(thisNode, it));\n      }\n    });\n  }","commit_id":"ce40d7e4ac613b3d05adcec2bf3bdf3e435d210a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void processReferentSetEvent(final SNode referenceNode, final SNode oldReferentNode, final SNode newReferentNode, IScope scope) {\n    for (SNode attrDecl : BuiltInTaskDeclaration_Behavior.call_getAttributesDeaclarations_353793545802644071(newReferentNode)) {\n      if (AttributeDeclaration_Behavior.call_isRequired_353793545802643811(attrDecl)) {\n        SNode attr = SConceptOperations.createNewNode(\"jetbrains.mps.build.generictasks.structure.Attribute\", null);\n        SLinkOperations.setTarget(attr, \"attributeDeclaration\", attrDecl, false);\n        ListSequence.fromList(SLinkOperations.getTargets(referenceNode, \"atributes\", true)).addElement(attr);\n      }\n    }\n  }","id":33943,"modified_method":"public void processReferentSetEvent(final SNode referenceNode, final SNode oldReferentNode, final SNode newReferentNode, IScope scope) {\n    for (SNode attrDecl : ITaskDeclaration_Behavior.call_getAttributesDeclarations_1190349257898147625(newReferentNode)) {\n      if (AttributeDeclaration_Behavior.call_isRequired_353793545802643811(attrDecl)) {\n        SNode attr = SConceptOperations.createNewNode(\"jetbrains.mps.build.generictasks.structure.Attribute\", null);\n        SLinkOperations.setTarget(attr, \"attributeDeclaration\", attrDecl, false);\n        ListSequence.fromList(SLinkOperations.getTargets(referenceNode, \"atributes\", true)).addElement(attr);\n      }\n    }\n  }","commit_id":"ce40d7e4ac613b3d05adcec2bf3bdf3e435d210a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    List<SNode> declarations = SModelOperations.getNodesIncludingImported(_context.getModel(), operationContext.getScope(), \"jetbrains.mps.build.generictasks.structure.ITaskDeclaration\");\n    if (!(SNodeOperations.isInstanceOf(_context.getEnclosingNode(), \"jetbrains.mps.build.generictasks.structure.TaskCall\"))) {\n      return new SimpleSearchScope(ListSequence.fromList(declarations).where(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return ITaskDeclaration_Behavior.call_canBeRootTask_1449762848926780427(it);\n        }\n      }).toListSequence());\n    }\n    return ITaskDeclaration_Behavior.call_getPossibleNesteds_1449762848926780436(SLinkOperations.getTarget(SNodeOperations.cast(_context.getEnclosingNode(), \"jetbrains.mps.build.generictasks.structure.TaskCall\"), \"declaration\", false), declarations);\n  }","id":33944,"modified_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    List<SNode> declarations = SModelOperations.getNodesIncludingImported(_context.getModel(), operationContext.getScope(), \"jetbrains.mps.build.generictasks.structure.ITaskDeclaration\");\n    if (!(SNodeOperations.isInstanceOf(_context.getEnclosingNode(), \"jetbrains.mps.build.generictasks.structure.TaskCall\"))) {\n      return new DefaultSearchScope(ListSequence.fromList(declarations).where(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return ITaskDeclaration_Behavior.call_canBeRootTask_1449762848926780427(it);\n        }\n      })) {\n        @Override\n        public boolean isInScope(SNode node) {\n          return SNodeOperations.isInstanceOf(node, \"jetbrains.mps.build.generictasks.structure.ITaskDeclaration\") && ITaskDeclaration_Behavior.call_canBeRootTask_1449762848926780427(SNodeOperations.cast(node, \"jetbrains.mps.build.generictasks.structure.ITaskDeclaration\"));\n        }\n      };\n    }\n    final List<SNode> nesteds = ITaskDeclaration_Behavior.call_getNestedTasks_4241383766070831847(SLinkOperations.getTarget(SNodeOperations.cast(_context.getEnclosingNode(), \"jetbrains.mps.build.generictasks.structure.TaskCall\"), \"declaration\", false));\n    return new DefaultSearchScope(ITaskDeclaration_Behavior.call_getPossibleNesteds_1449762848926780436(SLinkOperations.getTarget(SNodeOperations.cast(_context.getEnclosingNode(), \"jetbrains.mps.build.generictasks.structure.TaskCall\"), \"declaration\", false), declarations)) {\n      @Override\n      public boolean isInScope(SNode node) {\n        return SNodeOperations.isInstanceOf(node, \"jetbrains.mps.build.generictasks.structure.ITaskDeclaration\") && ITaskDeclaration_Behavior.call_isPossibleNested_1648602681640249389(SLinkOperations.getTarget(SNodeOperations.cast(_context.getEnclosingNode(), \"jetbrains.mps.build.generictasks.structure.TaskCall\"), \"declaration\", false), SNodeOperations.cast(node, \"jetbrains.mps.build.generictasks.structure.ITaskDeclaration\"), nesteds);\n      }\n    };\n  }","commit_id":"ce40d7e4ac613b3d05adcec2bf3bdf3e435d210a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode genericTaskCall, final TypeCheckingContext typeCheckingContext) {\n    for (SNode attrDecl : ListSequence.fromList(BuiltInTaskDeclaration_Behavior.call_getAttributesDeaclarations_353793545802644071(SLinkOperations.getTarget(genericTaskCall, \"declaration\", false)))) {\n      if (AttributeDeclaration_Behavior.call_isRequired_353793545802643811(attrDecl)) {\n        boolean found = false;\n        for (SNode attr : ListSequence.fromList(SLinkOperations.getTargets(genericTaskCall, \"atributes\", true))) {\n          if (SPropertyOperations.getString(SLinkOperations.getTarget(attr, \"attributeDeclaration\", false), \"name\").equals(SPropertyOperations.getString(attrDecl, \"name\"))) {\n            if ((SLinkOperations.getTarget(attr, \"value\", true) != null)) {\n              found = true;\n            }\n            break;\n          }\n        }\n        if (!(found)) {\n          {\n            BaseIntentionProvider intentionProvider = null;\n            IErrorTarget errorTarget = new NodeErrorTarget();\n            IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(genericTaskCall, \"Required attribute \\\"\" + SPropertyOperations.getString(attrDecl, \"name\") + \"\\\" undefined.\", \"r:eac20369-5993-49cc-a9ac-fbeb7a91d81f(jetbrains.mps.build.generictasks.typesystem)\", \"353793545802854846\", intentionProvider, errorTarget);\n          }\n          return;\n        }\n      }\n    }\n  }","id":33945,"modified_method":"public void applyRule(final SNode genericTaskCall, final TypeCheckingContext typeCheckingContext) {\n    for (SNode attrDecl : ListSequence.fromList(ITaskDeclaration_Behavior.call_getAttributesDeclarations_1190349257898147625(SLinkOperations.getTarget(genericTaskCall, \"declaration\", false)))) {\n      if (AttributeDeclaration_Behavior.call_isRequired_353793545802643811(attrDecl)) {\n        boolean found = false;\n        for (SNode attr : ListSequence.fromList(SLinkOperations.getTargets(genericTaskCall, \"atributes\", true))) {\n          if (SPropertyOperations.getString(SLinkOperations.getTarget(attr, \"attributeDeclaration\", false), \"name\").equals(SPropertyOperations.getString(attrDecl, \"name\"))) {\n            if ((SLinkOperations.getTarget(attr, \"value\", true) != null)) {\n              found = true;\n            }\n            break;\n          }\n        }\n        if (!(found)) {\n          {\n            BaseIntentionProvider intentionProvider = null;\n            IErrorTarget errorTarget = new NodeErrorTarget();\n            IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(genericTaskCall, \"Required attribute \" + SPropertyOperations.getString(attrDecl, \"name\") + \" is undefined.\", \"r:eac20369-5993-49cc-a9ac-fbeb7a91d81f(jetbrains.mps.build.generictasks.typesystem)\", \"353793545802854846\", intentionProvider, errorTarget);\n          }\n          return;\n        }\n      }\n    }\n  }","commit_id":"ce40d7e4ac613b3d05adcec2bf3bdf3e435d210a","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void doTestIncrementalGeneration(final MPSProject p, final SModelDescriptor descr, final Runnable ...changeModel) throws IOException {\n    GeneratorManager gm = p.getProject().getComponent(GeneratorManager.class);\n\n    File tmpFile = File.createTempFile(\"mps-generator-caches\", \"tmp\");\n    tmpFile.deleteOnExit();\n\n    // Stage 1. Regenerate\n\n    GenerationOptions options = GenerationOptions.getDefaults()\n      .rebuildAll(true).strictMode(true).reporting(true, true, false, 2).incremental(true, new FileBasedGenerationCacheContainer(tmpFile)).create();\n    IncrementalTestGenerationHandler generationHandler = new IncrementalTestGenerationHandler();\n    gm.generateModels(\n      Collections.singletonList(descr), ModuleContext.create(descr, p.getProject()),\n      generationHandler,\n      new EmptyProgressIndicator(), generationHandler.getMessageHandler(), options);\n\n    assertNoDiff(generationHandler.getExistingContent(), generationHandler.getGeneratedContent());\n\n    // Stage 2. Modify model\n    Map<String, String> incrementalGenerationResults = null;\n    List<Long> time = new ArrayList<Long>();\n    Assert.assertTrue(changeModel.length > 0);\n    for(final Runnable r : changeModel) {\n\n      ThreadUtils.runInUIThreadAndWait(new Runnable(){\n        @Override\n        public void run() {\n          ModelAccess.instance().runWriteActionInCommand(r, p.getProject());\n        }\n      });\n\n      // Stage 3. Generate incrementally\n\n      options = GenerationOptions.getDefaults()\n        .rebuildAll(false).strictMode(true).reporting(true, true, false, 2).incremental(true, new FileBasedGenerationCacheContainer(tmpFile)).create();\n      generationHandler = new IncrementalTestGenerationHandler(incrementalGenerationResults);\n      long start = System.nanoTime();\n      gm.generateModels(\n        Collections.singletonList(descr), ModuleContext.create(descr, p.getProject()),\n        generationHandler,\n        new EmptyProgressIndicator(), generationHandler.getMessageHandler(), options);\n      time.add(System.nanoTime() - start);\n\n      incrementalGenerationResults = generationHandler.getGeneratedContent();\n      assertDiff(generationHandler.getExistingContent(), incrementalGenerationResults, 1);\n    }\n\n    // Stage 4. Regenerate. Check incremental results.\n\n    options = GenerationOptions.getDefaults()\n      .rebuildAll(true).strictMode(true).reporting(true, true, false, 2).incremental(true, new FileBasedGenerationCacheContainer(tmpFile)).create();\n    generationHandler = new IncrementalTestGenerationHandler(incrementalGenerationResults);\n    long start = System.nanoTime();\n    gm.generateModels(\n      Collections.singletonList(descr), ModuleContext.create(descr, p.getProject()),\n      generationHandler,\n      new EmptyProgressIndicator(), generationHandler.getMessageHandler(), options);\n    time.add(System.nanoTime() - start);\n\n    assertNoDiff(generationHandler.getGeneratedContent(), incrementalGenerationResults);\n\n    ThreadUtils.runInUIThreadAndWait(new Runnable(){\n      @Override\n      public void run() {\n        ModelAccess.instance().runWriteAction(new Runnable() {\n          @Override\n          public void run() {\n            ((EditableSModelDescriptor)descr).reloadFromDisk();\n          }\n        });\n      }\n    });\n\n    if(DEBUG) {\n      long regen = time.remove(time.size() - 1);\n      System.out.print(\"Full cycle: \" + regen/1000000/1000.);\n      for(long l : time) {\n        System.out.print(\", incremental: \" + l/1000000/1000.);\n      }\n      System.out.println();\n    }\n  }","id":33946,"modified_method":"protected void doTestIncrementalGeneration(final MPSProject p, final SModelDescriptor descr, final Runnable ...changeModel) throws IOException {\n    GeneratorManager gm = p.getProject().getComponent(GeneratorManager.class);\n\n    File generatorCaches = new File(PathManager.getSystemPath(), \"mps-generator-test\");\n    if(generatorCaches.exists()) {\n      Assert.assertTrue(FileUtil.delete(generatorCaches));\n    }\n    Assert.assertTrue(generatorCaches.mkdir());\n\n    // Stage 0. Save model content.\n    byte[] content = readContent(((EditableSModelDescriptor)descr).getModelFile());\n\n    // Stage 1. Regenerate\n\n    GenerationOptions options = GenerationOptions.getDefaults()\n      .rebuildAll(true).strictMode(true).reporting(true, true, false, 2).incremental(true, new FileBasedGenerationCacheContainer(generatorCaches)).create();\n    IncrementalTestGenerationHandler generationHandler = new IncrementalTestGenerationHandler();\n    gm.generateModels(\n      Collections.singletonList(descr), ModuleContext.create(descr, p.getProject()),\n      generationHandler,\n      new EmptyProgressIndicator(), generationHandler.getMessageHandler(), options);\n\n    assertNoDiff(generationHandler.getExistingContent(), generationHandler.getGeneratedContent());\n\n    try {\n      // Stage 2. Modify model\n      Map<String, String> incrementalGenerationResults = null;\n      List<Long> time = new ArrayList<Long>();\n      Assert.assertTrue(changeModel.length > 0);\n      for(final Runnable r : changeModel) {\n\n        ThreadUtils.runInUIThreadAndWait(new Runnable(){\n          @Override\n          public void run() {\n            ModelAccess.instance().runWriteActionInCommand(r, p.getProject());\n            ModelAccess.instance().runWriteAction(new Runnable(){\n              @Override\n              public void run() {\n                ((EditableSModelDescriptor)descr).save();\n              }\n            });\n          }\n        });\n\n        // Stage 3. Generate incrementally\n\n        options = GenerationOptions.getDefaults()\n          .rebuildAll(false).strictMode(true).reporting(true, true, false, 2).incremental(true, new FileBasedGenerationCacheContainer(generatorCaches)).create();\n        generationHandler = new IncrementalTestGenerationHandler(incrementalGenerationResults);\n        long start = System.nanoTime();\n        gm.generateModels(\n          Collections.singletonList(descr), ModuleContext.create(descr, p.getProject()),\n          generationHandler,\n          new EmptyProgressIndicator(), generationHandler.getMessageHandler(), options);\n        time.add(System.nanoTime() - start);\n\n        incrementalGenerationResults = generationHandler.getGeneratedContent();\n        assertDiff(generationHandler.getExistingContent(), incrementalGenerationResults, 1);\n      }\n\n      // Stage 4. Regenerate. Check incremental results.\n\n      options = GenerationOptions.getDefaults()\n        .rebuildAll(true).strictMode(true).reporting(true, true, false, 2).incremental(true, new FileBasedGenerationCacheContainer(generatorCaches)).create();\n      generationHandler = new IncrementalTestGenerationHandler(incrementalGenerationResults);\n      long start = System.nanoTime();\n      gm.generateModels(\n        Collections.singletonList(descr), ModuleContext.create(descr, p.getProject()),\n        generationHandler,\n        new EmptyProgressIndicator(), generationHandler.getMessageHandler(), options);\n      time.add(System.nanoTime() - start);\n\n      assertNoDiff(generationHandler.getGeneratedContent(), incrementalGenerationResults);\n\n      if(DEBUG) {\n        long regen = time.remove(time.size() - 1);\n        System.out.print(\"Full cycle: \" + regen/1000000/1000.);\n        for(long l : time) {\n          System.out.print(\", incremental: \" + l/1000000/1000.);\n        }\n        System.out.println();\n      }\n    } finally {\n      writeContent(((EditableSModelDescriptor)descr).getModelFile(), content);\n\n      ThreadUtils.runInUIThreadAndWait(new Runnable(){\n        @Override\n        public void run() {\n          ModelAccess.instance().runWriteAction(new Runnable() {\n            @Override\n            public void run() {\n              ((EditableSModelDescriptor)descr).reloadFromDisk();\n            }\n          });\n        }\n      });\n    }\n  }","commit_id":"b7530c4ce850c1927db047c5e7234f8a043e35c4","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean handleOutput(IModule module, SModelDescriptor inputModel, GenerationStatus status, IOperationContext invocationContext, ITaskProgressHelper progressHelper) {\n    IFile targetDir = FileSystem.getInstance().getFileByPath(module.getOutputFor(inputModel));\n\n    Assert.assertTrue(status.isOk());\n    Assert.assertTrue(\"should be called once\", timesCalled++ == 0);\n\n    if (status.isOk()) {\n      myFilesDir = FileGenerationUtil.getDefaultOutputDir(inputModel, targetDir);\n\n      StreamHandler streamHandler = new CollectingStreamHandler();\n      try {\n        boolean result = new TextGenerator(streamHandler,\n          //ModelGenerationStatusManager.getInstance().getCacheGenerator(),\n          BLDependenciesCache.getInstance().getGenerator(),\n          //TraceInfoCache.getInstance().getGenerator(),\n          GenerationDependenciesCache.getInstance().getGenerator()\n        ).handleOutput(invocationContext, status);\n        Assert.assertTrue(result);\n      } finally {\n        streamHandler.dispose();\n      }\n    }\n    return true;\n  }","id":33947,"modified_method":"@Override\n  public boolean handleOutput(IModule module, SModelDescriptor inputModel, GenerationStatus status, IOperationContext invocationContext, ITaskProgressHelper progressHelper) {\n    IFile targetDir = FileSystem.getInstance().getFileByPath(module.getOutputFor(inputModel));\n\n    Assert.assertTrue(status.isOk());\n    Assert.assertTrue(\"should be called once\", timesCalled++ == 0);\n\n    if (status.isOk()) {\n      myFilesDir = FileGenerationUtil.getDefaultOutputDir(inputModel, targetDir);\n      IFile cachesDir = FileGenerationUtil.getDefaultOutputDir(inputModel, FileGenerationUtil.getCachesDir(targetDir));\n\n      StreamHandler streamHandler = new CollectingStreamHandler(cachesDir);\n      try {\n        boolean result = new TextGenerator(streamHandler,\n          //ModelGenerationStatusManager.getInstance().getCacheGenerator(),\n          BLDependenciesCache.getInstance().getGenerator(),\n          //TraceInfoCache.getInstance().getGenerator(),\n          GenerationDependenciesCache.getInstance().getGenerator()\n        ).handleOutput(invocationContext, status);\n        Assert.assertTrue(result);\n      } finally {\n        streamHandler.dispose();\n      }\n    }\n    return true;\n  }","commit_id":"b7530c4ce850c1927db047c5e7234f8a043e35c4","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public void saveStream(String name, String content, boolean isCache) {\n      if(!isCache) {\n        generatedContent.put(name, content);\n      }\n    }","id":33948,"modified_method":"public CollectingStreamHandler(IFile caches) {\n      myCaches = caches;\n    }","commit_id":"b7530c4ce850c1927db047c5e7234f8a043e35c4","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public void saveStream(String name, Element content, boolean isCache) {\n      if (!isCache) {\n        try {\n          StringWriter writer = new StringWriter();\n          JDOMUtil.writeDocument(new Document(content), writer);\n          saveStream(name, writer.toString(), isCache);\n        } catch (IOException e) {\n          Assert.fail(e.toString());\n        }\n      }\n    }","id":33949,"modified_method":"@Override\n    public void saveStream(String name, Element content, boolean isCache) {\n      if (!isCache) {\n        try {\n          StringWriter writer = new StringWriter();\n          JDOMUtil.writeDocument(new Document(content), writer);\n          saveStream(name, writer.toString(), isCache);\n        } catch (IOException e) {\n          Assert.fail(e.toString());\n        }\n      } else if(name.equals(\".generated\")) {\n        try {\n          JDOMUtil.writeDocument(new Document(content), myCaches.child(name));\n        } catch (IOException e) {\n          Assert.fail(e.toString());\n        }\n      }\n    }","commit_id":"b7530c4ce850c1927db047c5e7234f8a043e35c4","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void generateModels(MPSProject project, List<SModelDescriptor> models) {\n    StringBuffer s = new StringBuffer(\"Generating models:\");\n    for (SModelDescriptor m : models) {\n      s.append(\"\\n    \");\n      s.append(m);\n    }\n    info(s.toString());\n    GeneratorManager gm = project.getComponentSafe(GeneratorManager.class);\n    gm.generateModels(models,\n      new ProjectOperationContext(project),\n      myGenerationType,\n      new EmptyProgressIndicator(),\n      myMessageHandler);\n  }","id":33950,"modified_method":"private void generateModels(MPSProject project, List<SModelDescriptor> models) {\n    StringBuffer s = new StringBuffer(\"Generating models:\");\n    for (SModelDescriptor m : models) {\n      s.append(\"\\n    \");\n      s.append(m);\n    }\n    info(s.toString());\n    GeneratorManager gm = project.getComponentSafe(GeneratorManager.class);\n\n    ProjectOperationContext operationContext = new ProjectOperationContext(project);\n\n    Map<IModule, List<SModelDescriptor>> moduleToModels = new HashMap<IModule, List<SModelDescriptor>>();\n    for (final SModelDescriptor model : models) {\n      assert model != null;\n\n      Set<IModule> owningModules = ModelAccess.instance().runReadAction(new Computable<Set<IModule>>() {\n        public Set<IModule> compute() {\n          return SModelRepository.getInstance().getOwners(model, IModule.class);\n        }\n      });\n\n      IModule module = null;\n      if (owningModules.size() > 0) {\n        module = owningModules.iterator().next();\n      }\n\n      if (module == null) {\n        warning(\"Model \" + model.getLongName() + \" won't be generated\");\n      } else {\n        List<SModelDescriptor> modelsList = moduleToModels.get(module);\n        if (modelsList == null) {\n          modelsList = new ArrayList<SModelDescriptor>();\n          moduleToModels.put(module, modelsList);\n        }\n        modelsList.add(model);\n      }\n    }\n\n    EmptyProgressIndicator emptyProgressIndicator = new EmptyProgressIndicator();\n    for (IModule module : moduleToModels.keySet()) {\n      List<SModelDescriptor> modelsToGenerateNow = moduleToModels.get(module);\n      gm.generateModels(modelsToGenerateNow,\n        new ModuleContext(module, project),\n        myGenerationType,\n        emptyProgressIndicator,\n        myMessageHandler);\n\n    }\n  }","commit_id":"7b4ca30a88a42cbb8d2b554471c31e6905cdc9ea","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static GenerateFilesAndClassesGenerationType getGenerationType() {\n    return new GenerateFilesAndClassesGenerationType(true) {\n      public boolean requiresReloading() {\n        return false;\n      }\n\n      public boolean requiresCompilationBeforeGeneration() {\n        return false;\n      }\n\n      public boolean requiresCompilationAfterGeneration() {\n        return false;\n      }\n\n      protected boolean isPutClassesOnTheDisk() {\n        return false;\n      }\n    };\n  }","id":33951,"modified_method":"private static BaseGenerationType getGenerationType() {\n    return new GenerateFilesGenerationType();\n  }","commit_id":"7b4ca30a88a42cbb8d2b554471c31e6905cdc9ea","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void generate() {\n    BasicConfigurator.configure(new NullAppender());\n    Logger.getRootLogger().setLevel(getLog4jLevel());\n    jetbrains.mps.logging.Logger.addLoggingHandler(new MyMessageHandlerAppender());\n\n    IdeMain.setTestMode(TestMode.CORE_TEST);\n    TestMain.configureMPS();\n\n    setMacro();\n    loadLibraries();\n\n    File projectFile = FileUtil.createTmpFile();\n    MPSProject project = new MPSProject(projectFile, new ProjectDescriptor(), ProjectManager.getInstance().getDefaultProject());\n    generateModels(project, collectModelsToGenerate());\n\n    showStatistic();\n  }","id":33952,"modified_method":"public void generate() {\n    BasicConfigurator.configure(new NullAppender());\n    Logger.getRootLogger().setLevel(getLog4jLevel());\n    jetbrains.mps.logging.Logger.addLoggingHandler(new MyMessageHandlerAppender());\n\n    IdeMain.setTestMode(TestMode.CORE_TEST);\n    TestMain.configureMPS();\n\n    setMacro();\n    loadLibraries();\n\n    File projectFile = FileUtil.createTmpFile();\n    com.intellij.openapi.project.Project ideaProject = ProjectManager.getInstance().getDefaultProject();\n    MPSProject project = new MPSProject(projectFile, new ProjectDescriptor(), ideaProject);\n    ideaProject.getComponent(FileGeneratorManager.class).reloadFileGenerators();\n\n    generateModels(project, collectModelsToGenerate());\n\n    showStatistic();\n  }","commit_id":"7b4ca30a88a42cbb8d2b554471c31e6905cdc9ea","url":"https://github.com/JetBrains/MPS"},{"original_method":"private String getType(final RegisteredResource rsrc) {\n        final String type = rsrc.getType();\n        if ( type.equals(InstallableResource.TYPE_BUNDLE) ) {\n            return \"Bundle\";\n        } else if ( type.equals(InstallableResource.TYPE_CONFIG) ) {\n            return \"Configuration\";\n        } else if ( type.equals(InstallableResource.TYPE_FILE) ) {\n            return \"File\";\n        } else if ( type.equals(InstallableResource.TYPE_PROPERTIES) ) {\n            return \"Properties\";\n        }\n        return type;\n    }","id":33953,"modified_method":"private String getType(final RegisteredResource rsrc) {\n        final String type = rsrc.getType();\n        if ( type.equals(InstallableResource.TYPE_BUNDLE) ) {\n            return \"Bundles\";\n        } else if ( type.equals(InstallableResource.TYPE_CONFIG) ) {\n            return \"Configurations\";\n        } else if ( type.equals(InstallableResource.TYPE_FILE) ) {\n            return \"Files\";\n        } else if ( type.equals(InstallableResource.TYPE_PROPERTIES) ) {\n            return \"Properties\";\n        }\n        return type;\n    }","commit_id":"8385a96d63531fd8eff6aca34129cf28c2e28fc7","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Method for the configuration printer.\n     */\n    public void printConfiguration(final PrintWriter pw, final String mode) {\n        if ( !\"zip\".equals(mode) && !\"txt\".equals(mode) ) {\n            return;\n        }\n        pw.println(\"Apache Sling OSGi Installer\");\n        pw.println(\"===========================\");\n        synchronized ( this.installer.getResourcesLock() ) {\n            final State state = this.getCurrentState();\n            pw.println(\"Active Resources:\");\n            for(final EntityResourceList group : state.activeResources) {\n                final TaskResource toActivate = group.getActiveResource();\n                pw.printf(\"- %s %s: %s, %s, %s%n\",\n                        getType(toActivate),\n                        toActivate.getEntityId(),\n                        toActivate.getDigest(),\n                        toActivate.getURL(),\n                        toActivate.getState());\n            }\n            pw.println();\n\n            pw.println(\"Processed Resources:\");\n            for(final EntityResourceList group : state.installedResources) {\n                final Collection<TaskResource> resources = group.getResources();\n                if (resources.size() > 0) {\n                    final Iterator<TaskResource> iter = resources.iterator();\n                    final TaskResource first = iter.next();\n                    pw.printf(\"* %s %s: %s, %s, %s%n\",\n                            getType(first),\n                            first.getEntityId(),\n                            first.getDigest(),\n                            first.getURL(),\n                            first.getState());\n                    while ( iter.hasNext() ) {\n                        final TaskResource resource = iter.next();\n                        pw.printf(\"  - %s, %s, %s%n\",\n                            resource.getDigest(),\n                            resource.getURL(),\n                            resource.getState());\n                    }\n                }\n            }\n            pw.println();\n\n            pw.println(\"Untransformed Resources:\");\n            for(final RegisteredResource registeredResource : state.untransformedResources) {\n                pw.printf(\"- %s: %s, %s%n\",\n                        getType(registeredResource),\n                        registeredResource.getDigest(),\n                        registeredResource.getURL());\n            }\n        }\n    }","id":33954,"modified_method":"/**\n     * Method for the configuration printer.\n     */\n    public void printConfiguration(final PrintWriter pw, final String mode) {\n        if ( !\"zip\".equals(mode) && !\"txt\".equals(mode) ) {\n            return;\n        }\n        pw.println(\"Apache Sling OSGi Installer\");\n        pw.println(\"===========================\");\n        synchronized ( this.installer.getResourcesLock() ) {\n            final State state = this.getCurrentState();\n            pw.println(\"Active Resources\");\n            pw.println(\"----------------\");\n            String rt = null;\n            for(final EntityResourceList group : state.activeResources) {\n                final TaskResource toActivate = group.getActiveResource();\n                if ( !toActivate.getType().equals(rt) ) {\n                    pw.printf(\"%s:%n\", getType(toActivate));\n                    rt = toActivate.getType();\n                }\n                pw.printf(\"- %s: %s, %s, %s%n\",\n                        getEntityId(toActivate),\n                        toActivate.getDigest(),\n                        toActivate.getURL(),\n                        toActivate.getState());\n            }\n            pw.println();\n\n            pw.println(\"Processed Resources\");\n            pw.println(\"-------------------\");\n            rt = null;\n            for(final EntityResourceList group : state.installedResources) {\n                final Collection<TaskResource> resources = group.getResources();\n                if (resources.size() > 0) {\n                    final Iterator<TaskResource> iter = resources.iterator();\n                    final TaskResource first = iter.next();\n                    if ( !first.getType().equals(rt) ) {\n                        pw.printf(\"%s:%n\", getType(first));\n                        rt = first.getType();\n                    }\n                    pw.printf(\"* %s: %s, %s, %s%n\",\n                            getEntityId(first),\n                            first.getDigest(),\n                            first.getURL(),\n                            first.getState());\n                    while ( iter.hasNext() ) {\n                        final TaskResource resource = iter.next();\n                        pw.printf(\"  - %s, %s, %s%n\",\n                            resource.getDigest(),\n                            resource.getURL(),\n                            resource.getState());\n                    }\n                }\n            }\n            pw.println();\n\n            pw.println(\"Untransformed Resources\");\n            pw.println(\"-----------------------\");\n            rt = null;\n            for(final RegisteredResource registeredResource : state.untransformedResources) {\n                if ( !registeredResource.getType().equals(rt) ) {\n                    pw.printf(\"%s:%n\", getType(registeredResource));\n                    rt = registeredResource.getType();\n                }\n                pw.printf(\"- %s, %s%n\",\n                        registeredResource.getDigest(),\n                        registeredResource.getURL());\n            }\n        }\n    }","commit_id":"8385a96d63531fd8eff6aca34129cf28c2e28fc7","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public void service(ServletRequest req, ServletResponse res)\n    throws IOException {\n\n        final PrintWriter pw = res.getWriter();\n\n        synchronized ( this.installer.getResourcesLock() ) {\n            final State state = this.getCurrentState();\n\n            pw.println(\"<h1>Active Resources<\/h1>\");\n            pw.println(\"<ul>\");\n            for(final EntityResourceList group : state.activeResources) {\n                final TaskResource toActivate = group.getActiveResource();\n                pw.printf(\"<li>%s %s: %s, %s, %s<\/li>%n\",\n                        getType(toActivate),\n                        toActivate.getEntityId(),\n                        toActivate.getDigest(),\n                        toActivate.getURL(),\n                        toActivate.getState());\n            }\n            pw.println(\"<\/ul>\");\n\n            pw.println(\"<h1>Processed Resources<\/h1>\");\n            pw.println(\"<ul>\");\n            for(final EntityResourceList group : state.installedResources) {\n                final Collection<TaskResource> resources = group.getResources();\n                if (resources.size() > 0) {\n                    final Iterator<TaskResource> iter = resources.iterator();\n                    final TaskResource first = iter.next();\n                    pw.println(\"<ul>\");\n                    pw.printf(\"<li>%s %s: %s, %s, %s<\/li>%n\",\n                            getType(first),\n                            first.getEntityId(),\n                            first.getDigest(),\n                            first.getURL(),\n                            first.getState());\n                    while ( iter.hasNext() ) {\n                        final TaskResource resource = iter.next();\n                        pw.printf(\"<li>%s, %s, %s<\/li>%n\",\n                            resource.getDigest(),\n                            resource.getURL(),\n                            resource.getState());\n                    }\n                    pw.println(\"<\/ul>\");\n                }\n            }\n            pw.println(\"<\/ul>\");\n\n            pw.println(\"<h1>Untransformed Resources<\/h1>\");\n            pw.println(\"<ul>\");\n            for(final RegisteredResource registeredResource : state.untransformedResources) {\n                pw.printf(\"<li>%s: %s, %s<\/li>%n\",\n                    getType(registeredResource),\n                    registeredResource.getDigest(),\n                    registeredResource.getURL());\n            }\n            pw.println(\"<\/ul>\");\n        }\n    }","id":33955,"modified_method":"@Override\n    public void service(ServletRequest req, ServletResponse res)\n    throws IOException {\n\n        final PrintWriter pw = res.getWriter();\n\n        synchronized ( this.installer.getResourcesLock() ) {\n            final State state = this.getCurrentState();\n\n            pw.println(\"<h1>Active Resources<\/h1>\");\n            String rt = null;\n            for(final EntityResourceList group : state.activeResources) {\n                final TaskResource toActivate = group.getActiveResource();\n                if ( !toActivate.getType().equals(rt) ) {\n                    if ( rt != null ) {\n                        pw.println(\"<\/ul>\");\n                    }\n                    pw.printf(\"<h2>%s<\/h2>%n\", getType(toActivate));\n                    pw.println(\"<ul>\");\n                    rt = toActivate.getType();\n                }\n                pw.printf(\"<li>%s: %s, %s, %s<\/li>%n\",\n                        getEntityId(toActivate),\n                        toActivate.getDigest(),\n                        toActivate.getURL(),\n                        toActivate.getState());\n            }\n            pw.println(\"<\/ul>\");\n            rt = null;\n\n            pw.println(\"<h1>Processed Resources<\/h1>\");\n            for(final EntityResourceList group : state.installedResources) {\n                final Collection<TaskResource> resources = group.getResources();\n                if (resources.size() > 0) {\n                    final Iterator<TaskResource> iter = resources.iterator();\n                    final TaskResource first = iter.next();\n                    if ( !first.getType().equals(rt) ) {\n                        if ( rt != null ) {\n                            pw.println(\"<\/ul>\");\n                        }\n                        pw.printf(\"<h2>%s<\/h2>%n\", getType(first));\n                        rt = first.getType();\n                        pw.println(\"<ul>\");\n                    }\n                    pw.println(\"<ul>\");\n                    pw.printf(\"<li>%s: %s, %s, %s<\/li>%n\",\n                            getEntityId(first),\n                            first.getDigest(),\n                            first.getURL(),\n                            first.getState());\n                    while ( iter.hasNext() ) {\n                        final TaskResource resource = iter.next();\n                        pw.printf(\"<li>%s, %s, %s<\/li>%n\",\n                            resource.getDigest(),\n                            resource.getURL(),\n                            resource.getState());\n                    }\n                    pw.println(\"<\/ul>\");\n                }\n            }\n            if ( rt != null ) {\n                pw.println(\"<\/ul>\");\n            }\n\n            pw.println(\"<h1>Untransformed Resources<\/h1>\");\n            rt = null;\n            for(final RegisteredResource registeredResource : state.untransformedResources) {\n                if ( !registeredResource.getType().equals(rt) ) {\n                    if ( rt != null ) {\n                        pw.println(\"<\/ul>\");\n                    }\n                    pw.printf(\"<h2>%s<\/h2>%n\", getType(registeredResource));\n                    rt = registeredResource.getType();\n                    pw.println(\"<ul>\");\n                }\n                pw.printf(\"<li>%s, %s<\/li>%n\",\n                    registeredResource.getDigest(),\n                    registeredResource.getURL());\n            }\n            if ( rt != null ) {\n                pw.println(\"<\/ul>\");\n            }\n        }\n    }","commit_id":"8385a96d63531fd8eff6aca34129cf28c2e28fc7","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Get the current installer state.\n     * This method should be called from within a synchronized block for the resources!\n     */\n    private State getCurrentState() {\n        final State state = new State();\n\n        for(final String entityId : this.installer.getPersistentResourceList().getEntityIds()) {\n            final EntityResourceList group = this.installer.getPersistentResourceList().getEntityResourceList(entityId);\n            if ( group.getActiveResource() != null ) {\n                state.activeResources.add(group);\n            } else {\n                state.installedResources.add(group);\n            }\n        }\n        state.untransformedResources.addAll(this.installer.getPersistentResourceList().getUntransformedResources());\n\n        return state;\n    }","id":33956,"modified_method":"/**\n     * Get the current installer state.\n     * This method should be called from within a synchronized block for the resources!\n     */\n    private State getCurrentState() {\n        final State state = new State();\n\n        for(final String entityId : this.installer.getPersistentResourceList().getEntityIds()) {\n            final EntityResourceList group = this.installer.getPersistentResourceList().getEntityResourceList(entityId);\n            if ( group.getActiveResource() != null ) {\n                state.activeResources.add(group);\n            } else {\n                state.installedResources.add(group);\n            }\n        }\n        Collections.sort(state.activeResources, COMPARATOR);\n        Collections.sort(state.installedResources, COMPARATOR);\n        state.untransformedResources.addAll(this.installer.getPersistentResourceList().getUntransformedResources());\n\n        return state;\n    }","commit_id":"8385a96d63531fd8eff6aca34129cf28c2e28fc7","url":"https://github.com/apache/sling"},{"original_method":"public void onSuccess(FetchResult result, ClientGetter state, ObjectContainer container) {\n\t\tLogger.minor(this, \"Succeeded: \"+identifier);\n\t\tBucket data = result.asBucket();\n\t\tif(persistenceType == PERSIST_FOREVER) {\n\t\t\tif(data != null)\n\t\t\t\tcontainer.activate(data, 5);\n\t\t\tif(returnBucket != null)\n\t\t\t\tcontainer.activate(returnBucket, 5);\n\t\t\tcontainer.activate(client, 1);\n\t\t\tif(tempFile != null)\n\t\t\t\tcontainer.activate(tempFile, 5);\n\t\t\tif(targetFile != null)\n\t\t\t\tcontainer.activate(targetFile, 5);\n\t\t}\n\t\tif(returnBucket != data && !binaryBlob) {\n\t\t\tboolean failed = true;\n\t\t\tsynchronized(this) {\n\t\t\t\tif(finished) {\n\t\t\t\t\tLogger.error(this, \"Already finished but onSuccess() for \"+this+\" data = \"+data, new Exception(\"debug\"));\n\t\t\t\t\tdata.free();\n\t\t\t\t\tif(persistenceType == PERSIST_FOREVER) data.removeFrom(container);\n\t\t\t\t\treturn; // Already failed - bucket error maybe??\n\t\t\t\t}\n\t\t\t\tif(returnType == ClientGetMessage.RETURN_TYPE_DIRECT && returnBucket == null) {\n\t\t\t\t\t// Lost bucket for some reason e.g. bucket error (caused by IOException) on previous try??\n\t\t\t\t\t// Recover...\n\t\t\t\t\treturnBucket = data;\n\t\t\t\t\tfailed = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(failed && persistenceType == PERSIST_FOREVER) {\n\t\t\t\tif(container.ext().getID(returnBucket) == container.ext().getID(data)) {\n\t\t\t\t\tLogger.error(this, \"DB4O BUG DETECTED WITHOUT ARRAY HANDLING! EVIL HORRIBLE BUG! UID(returnBucket)=\"+container.ext().getID(returnBucket)+\" for \"+returnBucket+\" active=\"+container.ext().isActive(returnBucket)+\" stored = \"+container.ext().isStored(returnBucket)+\" but UID(data)=\"+container.ext().getID(data)+\" for \"+data+\" active = \"+container.ext().isActive(data)+\" stored = \"+container.ext().isStored(data));\n\t\t\t\t\t// Succeed anyway, hope that the returned bucket is consistent...\n\t\t\t\t\treturnBucket = data;\n\t\t\t\t\tfailed = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(data instanceof FileBucket) {\n\t\t\t\tLogger.error(this, \"Returned bucket \"+data+\" in onSuccess, expected \"+returnBucket, new Exception(\"error\"));\n\t\t\t\tonFailure(new FetchException(FetchException.INTERNAL_ERROR, \"Data != returnBucket\"), null, container);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Something wierd happened, recreate returnBucket ...\n\t\t\tif(tempFile != null && tempFile.exists()) tempFile.delete();\n\t\t\treturnBucket.free();\n\t\t\tif(persistenceType == PERSIST_FOREVER)\n\t\t\t\treturnBucket.removeFrom(container);\n\t\t\treturnBucket = getBucket(container);\n\t\t\tif(persistenceType == PERSIST_FOREVER && container.ext().isStored(this)) {\n\t\t\t\treturnBucket.storeTo(container);\n\t\t\t\tcontainer.store(this);\n\t\t\t}\n\n\t\t\tLogger.error(this, \"Data returned to wrong bucket \"+data+\" expected \"+returnBucket+\" in \"+this, new Exception(\"error\"));\n\t\t\ttry {\n\t\t\t\tBucketTools.copy(data, returnBucket);\n\t\t\t} catch (IOException e) {\n\t\t\t\tdata.free();\n\t\t\t\treturnBucket.free();\n\t\t\t\tif(persistenceType == PERSIST_FOREVER) {\n\t\t\t\t\tdata.removeFrom(container);\n\t\t\t\t}\n\t\t\t\tonFailure(new FetchException(FetchException.INTERNAL_ERROR, \"Data != returnBucket and then failed to copy\", e), null, container);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tboolean dontFree = false;\n\t\t// FIXME I don't think this is a problem in this case...? (Disk write while locked..)\n\t\tAllDataMessage adm = null;\n\t\tsynchronized(this) {\n\t\t\tif(succeeded) {\n\t\t\t\tLogger.error(this, \"onSuccess called twice for \"+this+\" (\"+identifier+ ')');\n\t\t\t\treturn; // We might be called twice; ignore it if so.\n\t\t\t}\n\t\t\tstarted = true;\n\t\t\tif(!binaryBlob)\n\t\t\t\tthis.foundDataMimeType = result.getMimeType();\n\t\t\telse\n\t\t\t\tthis.foundDataMimeType = BinaryBlob.MIME_TYPE;\n\n\t\t\tif(returnType == ClientGetMessage.RETURN_TYPE_DIRECT) {\n\t\t\t\t// Send all the data at once\n\t\t\t\t// FIXME there should be other options\n\t\t\t\t// FIXME: CompletionTime is set on finish() : we need to give it current time here\n\t\t\t\t// but it means we won't always return the same value to clients... Does it matter ?\n\t\t\t\tadm = new AllDataMessage(returnBucket, identifier, global, startupTime, System.currentTimeMillis(), this.foundDataMimeType);\n\t\t\t\tif(persistenceType == PERSIST_CONNECTION)\n\t\t\t\t\tadm.setFreeOnSent();\n\t\t\t\tdontFree = true;\n\t\t\t\t/*\n\t\t\t\t * } else if(returnType == ClientGetMessage.RETURN_TYPE_NONE) {\n\t\t\t\t// Do nothing\n\t\t\t\t */\n\t\t\t} else if(returnType == ClientGetMessage.RETURN_TYPE_DISK) {\n\t\t\t\t// Write to temp file, then rename over filename\n\t\t\t\tif(!FileUtil.renameTo(tempFile, targetFile)) {\n\t\t\t\t\tpostFetchProtocolErrorMessage = new ProtocolErrorMessage(ProtocolErrorMessage.COULD_NOT_RENAME_FILE, false, null, identifier, global);\n\t\t\t\t\t// Don't delete temp file, user might want it.\n\t\t\t\t}\n\t\t\t\treturnBucket = new FileBucket(targetFile, false, true, false, false, false);\n\t\t\t}\n\t\t\tif(persistenceType == PERSIST_FOREVER && progressPending != null) {\n\t\t\t\tcontainer.activate(progressPending, 1);\n\t\t\t\tprogressPending.removeFrom(container);\n\t\t\t}\n\t\t\tprogressPending = null;\n\t\t\tthis.foundDataLength = returnBucket.size();\n\t\t\tthis.succeeded = true;\n\t\t\tfinished = true;\n\t\t}\n\t\ttrySendDataFoundOrGetFailed(null, container);\n\n\t\tif(adm != null)\n\t\t\ttrySendAllDataMessage(adm, null, container);\n\t\tif(!dontFree) {\n\t\t\tdata.free();\n\t\t}\n\t\tif(persistenceType == PERSIST_FOREVER) {\n\t\t\treturnBucket.storeTo(container);\n\t\t\tcontainer.store(this);\n\t\t}\n\t\tfinish(container);\n\t\tif(client != null)\n\t\t\tclient.notifySuccess(this, container);\n\t}","id":33957,"modified_method":"public void onSuccess(FetchResult result, ClientGetter state, ObjectContainer container) {\n\t\tLogger.minor(this, \"Succeeded: \"+identifier);\n\t\tBucket data = result.asBucket();\n\t\tif(persistenceType == PERSIST_FOREVER) {\n\t\t\tif(data != null)\n\t\t\t\tcontainer.activate(data, 5);\n\t\t\tif(returnBucket != null)\n\t\t\t\tcontainer.activate(returnBucket, 5);\n\t\t\tcontainer.activate(client, 1);\n\t\t\tif(tempFile != null)\n\t\t\t\tcontainer.activate(tempFile, 5);\n\t\t\tif(targetFile != null)\n\t\t\t\tcontainer.activate(targetFile, 5);\n\t\t}\n\t\tif(returnBucket != data && !binaryBlob) {\n\t\t\tboolean failed = true;\n\t\t\tsynchronized(this) {\n\t\t\t\tif(finished) {\n\t\t\t\t\tLogger.error(this, \"Already finished but onSuccess() for \"+this+\" data = \"+data, new Exception(\"debug\"));\n\t\t\t\t\tdata.free();\n\t\t\t\t\tif(persistenceType == PERSIST_FOREVER) data.removeFrom(container);\n\t\t\t\t\treturn; // Already failed - bucket error maybe??\n\t\t\t\t}\n\t\t\t\tif(returnType == ClientGetMessage.RETURN_TYPE_DIRECT && returnBucket == null) {\n\t\t\t\t\t// Lost bucket for some reason e.g. bucket error (caused by IOException) on previous try??\n\t\t\t\t\t// Recover...\n\t\t\t\t\treturnBucket = data;\n\t\t\t\t\tfailed = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(failed && persistenceType == PERSIST_FOREVER) {\n\t\t\t\tif(container.ext().getID(returnBucket) == container.ext().getID(data)) {\n\t\t\t\t\tLogger.error(this, \"DB4O BUG DETECTED WITHOUT ARRAY HANDLING! EVIL HORRIBLE BUG! UID(returnBucket)=\"+container.ext().getID(returnBucket)+\" for \"+returnBucket+\" active=\"+container.ext().isActive(returnBucket)+\" stored = \"+container.ext().isStored(returnBucket)+\" but UID(data)=\"+container.ext().getID(data)+\" for \"+data+\" active = \"+container.ext().isActive(data)+\" stored = \"+container.ext().isStored(data));\n\t\t\t\t\t// Succeed anyway, hope that the returned bucket is consistent...\n\t\t\t\t\treturnBucket = data;\n\t\t\t\t\tfailed = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(data instanceof FileBucket && data != returnBucket) {\n\t\t\t\tLogger.error(this, \"Returned bucket \"+data+\" in onSuccess, expected \"+returnBucket, new Exception(\"error\"));\n\t\t\t\tonFailure(new FetchException(FetchException.INTERNAL_ERROR, \"Data != returnBucket\"), null, container);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Something wierd happened, recreate returnBucket ...\n\t\t\tif(tempFile != null && tempFile.exists()) tempFile.delete();\n\t\t\tif(data != returnBucket)\n\t\t\t\treturnBucket.free();\n\t\t\tif(data != returnBucket) {\n\t\t\t\tif(persistenceType == PERSIST_FOREVER)\n\t\t\t\t\treturnBucket.removeFrom(container);\n\t\t\t\treturnBucket = getBucket(container);\n\t\t\t}\n\t\t\tif(persistenceType == PERSIST_FOREVER && container.ext().isStored(this)) {\n\t\t\t\treturnBucket.storeTo(container);\n\t\t\t\tcontainer.store(this);\n\t\t\t\t\n\t\t\t\tLogger.error(this, \"Data returned to wrong bucket \"+data+\" expected \"+returnBucket+\" in \"+this, new Exception(\"error\"));\n\t\t\t\ttry {\n\t\t\t\t\tBucketTools.copy(data, returnBucket);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tdata.free();\n\t\t\t\t\treturnBucket.free();\n\t\t\t\t\tif(persistenceType == PERSIST_FOREVER) {\n\t\t\t\t\t\tdata.removeFrom(container);\n\t\t\t\t\t}\n\t\t\t\t\tonFailure(new FetchException(FetchException.INTERNAL_ERROR, \"Data != returnBucket and then failed to copy\", e), null, container);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tboolean dontFree = false;\n\t\t// FIXME I don't think this is a problem in this case...? (Disk write while locked..)\n\t\tAllDataMessage adm = null;\n\t\tsynchronized(this) {\n\t\t\tif(succeeded) {\n\t\t\t\tLogger.error(this, \"onSuccess called twice for \"+this+\" (\"+identifier+ ')');\n\t\t\t\treturn; // We might be called twice; ignore it if so.\n\t\t\t}\n\t\t\tstarted = true;\n\t\t\tif(!binaryBlob)\n\t\t\t\tthis.foundDataMimeType = result.getMimeType();\n\t\t\telse\n\t\t\t\tthis.foundDataMimeType = BinaryBlob.MIME_TYPE;\n\n\t\t\tif(returnType == ClientGetMessage.RETURN_TYPE_DIRECT) {\n\t\t\t\t// Send all the data at once\n\t\t\t\t// FIXME there should be other options\n\t\t\t\t// FIXME: CompletionTime is set on finish() : we need to give it current time here\n\t\t\t\t// but it means we won't always return the same value to clients... Does it matter ?\n\t\t\t\tadm = new AllDataMessage(returnBucket, identifier, global, startupTime, System.currentTimeMillis(), this.foundDataMimeType);\n\t\t\t\tif(persistenceType == PERSIST_CONNECTION)\n\t\t\t\t\tadm.setFreeOnSent();\n\t\t\t\tdontFree = true;\n\t\t\t\t/*\n\t\t\t\t * } else if(returnType == ClientGetMessage.RETURN_TYPE_NONE) {\n\t\t\t\t// Do nothing\n\t\t\t\t */\n\t\t\t} else if(returnType == ClientGetMessage.RETURN_TYPE_DISK) {\n\t\t\t\t// Write to temp file, then rename over filename\n\t\t\t\tif(!FileUtil.renameTo(tempFile, targetFile)) {\n\t\t\t\t\tpostFetchProtocolErrorMessage = new ProtocolErrorMessage(ProtocolErrorMessage.COULD_NOT_RENAME_FILE, false, null, identifier, global);\n\t\t\t\t\t// Don't delete temp file, user might want it.\n\t\t\t\t}\n\t\t\t\treturnBucket = new FileBucket(targetFile, false, true, false, false, false);\n\t\t\t}\n\t\t\tif(persistenceType == PERSIST_FOREVER && progressPending != null) {\n\t\t\t\tcontainer.activate(progressPending, 1);\n\t\t\t\tprogressPending.removeFrom(container);\n\t\t\t}\n\t\t\tprogressPending = null;\n\t\t\tthis.foundDataLength = returnBucket.size();\n\t\t\tthis.succeeded = true;\n\t\t\tfinished = true;\n\t\t}\n\t\ttrySendDataFoundOrGetFailed(null, container);\n\n\t\tif(adm != null)\n\t\t\ttrySendAllDataMessage(adm, null, container);\n\t\tif(!dontFree) {\n\t\t\tdata.free();\n\t\t}\n\t\tif(persistenceType == PERSIST_FOREVER) {\n\t\t\treturnBucket.storeTo(container);\n\t\t\tcontainer.store(this);\n\t\t}\n\t\tfinish(container);\n\t\tif(client != null)\n\t\t\tclient.notifySuccess(this, container);\n\t}","commit_id":"a3f0c9d71e456c6cbdbf294b020dab14a170890d","url":"https://github.com/freenet/fred"},{"original_method":"public void storeBlockStatuses(ObjectContainer container) {\n\t\tif(dataBlockStatus != null) {\n\t\t\tfor(SplitfileBlock block : dataBlockStatus)\n\t\t\t\tblock.storeTo(container);\n\t\t}\n\t\tif(checkBlockStatus != null) {\n\t\t\tfor(SplitfileBlock block : checkBlockStatus)\n\t\t\t\tblock.storeTo(container);\n\t\t}\n\t}","id":33958,"modified_method":"public void storeBlockStatuses(ObjectContainer container) {\n\t\tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tif(logMINOR) Logger.minor(this, \"Storing block statuses\");\n\t\tif(dataBlockStatus != null) {\n\t\t\tfor(int i=0;i<dataBlockStatus.length;i++) {\n\t\t\t\tSplitfileBlock block = dataBlockStatus[i];\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Storing data block \"+i+\": \"+block);\n\t\t\t\tblock.storeTo(container);\n\t\t\t}\n\t\t}\n\t\tif(checkBlockStatus != null) {\n\t\t\tfor(int i=0;i<checkBlockStatus.length;i++) {\n\t\t\t\tSplitfileBlock block = checkBlockStatus[i];\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Storing check block \"+i+\": \"+block);\n\t\t\t\tblock.storeTo(container);\n\t\t\t}\n\t\t}\n\t}","commit_id":"979f02310fa05744a4e085a46a2a566a4a5c5f61","url":"https://github.com/freenet/fred"},{"original_method":"public void activateForExecution(ObjectContainer container) {\n\t\tif(Logger.shouldLog(Logger.MINOR, this)) Logger.minor(this, \"Activating FECJob...\");\n\t\tcontainer.activate(this, 2);\n\t\tif(dataBlockStatus != null) {\n\t\t\tfor(int i=0;i<dataBlockStatus.length;i++)\n\t\t\t\tcontainer.activate(dataBlockStatus[i], 2);\n\t\t}\n\t\tif(checkBlockStatus != null) {\n\t\t\tfor(int i=0;i<checkBlockStatus.length;i++)\n\t\t\t\tcontainer.activate(checkBlockStatus[i], 2);\n\t\t}\n\t\tif(dataBlocks != null) {\n\t\t\tfor(int i=0;i<dataBlocks.length;i++)\n\t\t\t\tcontainer.activate(dataBlocks[i], 1);\n\t\t}\n\t\tif(checkBlocks != null) {\n\t\t\tfor(int i=0;i<checkBlocks.length;i++)\n\t\t\t\tcontainer.activate(checkBlocks[i], 1);\n\t\t}\n\t}","id":33959,"modified_method":"public void activateForExecution(ObjectContainer container) {\n\t\tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tif(logMINOR) Logger.minor(this, \"Activating FECJob...\");\n\t\tif(dataBlockStatus != null && logMINOR) {\n\t\t\tfor(int i=0;i<dataBlockStatus.length;i++)\n\t\t\t\tLogger.minor(this, \"Block \"+i+\": \"+dataBlockStatus[i]+\" (before activation)\");\n\t\t}\n\t\tcontainer.activate(this, 2);\n\t\tif(dataBlockStatus != null) {\n\t\t\tfor(int i=0;i<dataBlockStatus.length;i++)\n\t\t\t\tcontainer.activate(dataBlockStatus[i], 2);\n\t\t}\n\t\tif(dataBlockStatus != null && logMINOR) {\n\t\t\tfor(int i=0;i<dataBlockStatus.length;i++)\n\t\t\t\tLogger.minor(this, \"Block \"+i+\": \"+dataBlockStatus[i]+\" (after activation)\");\n\t\t}\n\t\tif(checkBlockStatus != null) {\n\t\t\tfor(int i=0;i<checkBlockStatus.length;i++)\n\t\t\t\tcontainer.activate(checkBlockStatus[i], 2);\n\t\t}\n\t\tif(dataBlocks != null) {\n\t\t\tfor(int i=0;i<dataBlocks.length;i++)\n\t\t\t\tcontainer.activate(dataBlocks[i], 1);\n\t\t}\n\t\tif(checkBlocks != null) {\n\t\t\tfor(int i=0;i<checkBlocks.length;i++)\n\t\t\t\tcontainer.activate(checkBlocks[i], 1);\n\t\t}\n\t}","commit_id":"979f02310fa05744a4e085a46a2a566a4a5c5f61","url":"https://github.com/freenet/fred"},{"original_method":"public FECJob(FECCodec codec, FECQueue queue, SplitfileBlock[] dataBlockStatus, SplitfileBlock[] checkBlockStatus,  int blockLength, BucketFactory bucketFactory, FECCallback callback, boolean isADecodingJob, short priority, boolean persistent) {\n\t\tthis.codec = codec;\n\t\tthis.queue = queue;\n\t\tthis.priority = priority;\n\t\tthis.addedTime = System.currentTimeMillis();\n\t\tthis.dataBlockStatus = dataBlockStatus;\n\t\tthis.checkBlockStatus = checkBlockStatus;\n\t\t\n\t\tthis.dataBlocks = new Bucket[dataBlockStatus.length];\n\t\tthis.checkBlocks = new Bucket[checkBlockStatus.length];\n\t\tfor(int i=0;i<dataBlocks.length;i++)\n\t\t\tthis.dataBlocks[i] = dataBlockStatus[i].getData();\n\t\tfor(int i=0;i<checkBlocks.length;i++)\n\t\t\tthis.checkBlocks[i] = checkBlockStatus[i].getData();\n\t\t\n\t\tthis.blockLength = blockLength;\n\t\tthis.bucketFactory = bucketFactory;\n\t\tthis.callback = callback;\n\t\tthis.isADecodingJob = isADecodingJob;\n\t\tthis.persistent = persistent;\n\t\tthis.hashCode = super.hashCode();\n\t}","id":33960,"modified_method":"public FECJob(FECCodec codec, FECQueue queue, SplitfileBlock[] dataBlockStatus, SplitfileBlock[] checkBlockStatus,  int blockLength, BucketFactory bucketFactory, FECCallback callback, boolean isADecodingJob, short priority, boolean persistent) {\n\t\tthis.codec = codec;\n\t\tthis.queue = queue;\n\t\tthis.priority = priority;\n\t\tthis.addedTime = System.currentTimeMillis();\n\t\t\n\t\tthis.dataBlockStatus = new SplitfileBlock[dataBlockStatus.length];\n\t\tthis.checkBlockStatus = new SplitfileBlock[checkBlockStatus.length];\n\t\tfor(int i=0;i<dataBlockStatus.length;i++)\n\t\t\tthis.dataBlockStatus[i] = dataBlockStatus[i];\n\t\tfor(int i=0;i<checkBlockStatus.length;i++)\n\t\t\tthis.checkBlockStatus[i] = checkBlockStatus[i];\n\t\t\n//\t\tthis.dataBlockStatus = dataBlockStatus;\n//\t\tthis.checkBlockStatus = checkBlockStatus;\n\t\t\n\t\tthis.dataBlocks = new Bucket[dataBlockStatus.length];\n\t\tthis.checkBlocks = new Bucket[checkBlockStatus.length];\n\t\tfor(int i=0;i<dataBlocks.length;i++)\n\t\t\tthis.dataBlocks[i] = dataBlockStatus[i].getData();\n\t\tfor(int i=0;i<checkBlocks.length;i++)\n\t\t\tthis.checkBlocks[i] = checkBlockStatus[i].getData();\n\t\t\n\t\tthis.blockLength = blockLength;\n\t\tthis.bucketFactory = bucketFactory;\n\t\tthis.callback = callback;\n\t\tthis.isADecodingJob = isADecodingJob;\n\t\tthis.persistent = persistent;\n\t\tthis.hashCode = super.hashCode();\n\t}","commit_id":"979f02310fa05744a4e085a46a2a566a4a5c5f61","url":"https://github.com/freenet/fred"},{"original_method":"public void deactivate(ObjectContainer container) {\n\t\tif(dataBlockStatus != null) {\n\t\t\tfor(int i=0;i<dataBlockStatus.length;i++)\n\t\t\t\tcontainer.deactivate(dataBlockStatus[i], 2);\n\t\t}\n\t\tif(checkBlockStatus != null) {\n\t\t\tfor(int i=0;i<checkBlockStatus.length;i++)\n\t\t\t\tcontainer.deactivate(checkBlockStatus[i], 2);\n\t\t}\n\t\tif(dataBlocks != null) {\n\t\t\tfor(int i=0;i<dataBlocks.length;i++)\n\t\t\t\tcontainer.deactivate(dataBlocks[i], 1);\n\t\t}\n\t\tif(checkBlocks != null) {\n\t\t\tfor(int i=0;i<checkBlocks.length;i++)\n\t\t\t\tcontainer.deactivate(checkBlocks[i], 1);\n\t\t}\n\t}","id":33961,"modified_method":"public void deactivate(ObjectContainer container) {\n\t\tif(Logger.shouldLog(Logger.MINOR, this)) Logger.minor(this, \"Deactivating FECJob...\");\n\t\tif(dataBlockStatus != null) {\n\t\t\tfor(int i=0;i<dataBlockStatus.length;i++)\n\t\t\t\tcontainer.deactivate(dataBlockStatus[i], 2);\n\t\t}\n\t\tif(checkBlockStatus != null) {\n\t\t\tfor(int i=0;i<checkBlockStatus.length;i++)\n\t\t\t\tcontainer.deactivate(checkBlockStatus[i], 2);\n\t\t}\n\t\tif(dataBlocks != null) {\n\t\t\tfor(int i=0;i<dataBlocks.length;i++)\n\t\t\t\tcontainer.deactivate(dataBlocks[i], 1);\n\t\t}\n\t\tif(checkBlocks != null) {\n\t\t\tfor(int i=0;i<checkBlocks.length;i++)\n\t\t\t\tcontainer.deactivate(checkBlocks[i], 1);\n\t\t}\n\t}","commit_id":"979f02310fa05744a4e085a46a2a566a4a5c5f61","url":"https://github.com/freenet/fred"},{"original_method":"public void onSuccess(FetchResult result, ClientGetter state, ObjectContainer container) {\n\t\tLogger.minor(this, \"Succeeded: \"+identifier);\n\t\tBucket data = result.asBucket();\n\t\tif(persistenceType == PERSIST_FOREVER) {\n\t\t\tif(data != null)\n\t\t\t\tcontainer.activate(data, 5);\n\t\t\tif(returnBucket != null)\n\t\t\t\tcontainer.activate(returnBucket, 5);\n\t\t\tcontainer.activate(client, 1);\n\t\t\tif(tempFile != null)\n\t\t\t\tcontainer.activate(tempFile, 5);\n\t\t\tif(targetFile != null)\n\t\t\t\tcontainer.activate(targetFile, 5);\n\t\t}\n\t\tif(returnBucket != data && !binaryBlob) {\n\t\t\tboolean failed = true;\n\t\t\tsynchronized(this) {\n\t\t\t\tif(finished) {\n\t\t\t\t\tLogger.error(this, \"Already finished but onSuccess() for \"+this+\" data = \"+data, new Exception(\"debug\"));\n\t\t\t\t\tdata.free();\n\t\t\t\t\tif(persistenceType == PERSIST_FOREVER) data.removeFrom(container);\n\t\t\t\t\treturn; // Already failed - bucket error maybe??\n\t\t\t\t}\n\t\t\t\tif(returnType == ClientGetMessage.RETURN_TYPE_DIRECT && returnBucket == null) {\n\t\t\t\t\t// Lost bucket for some reason e.g. bucket error (caused by IOException) on previous try??\n\t\t\t\t\t// Recover...\n\t\t\t\t\treturnBucket = data;\n\t\t\t\t\tfailed = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(failed && persistenceType == PERSIST_FOREVER) {\n\t\t\t\tif(container.ext().getID(returnBucket) == container.ext().getID(data)) {\n\t\t\t\t\tLogger.error(this, \"DB4O BUG DETECTED WITHOUT ARRAY HANDLING! EVIL HORRIBLE BUG! UID(returnBucket)=\"+container.ext().getID(returnBucket)+\" for \"+returnBucket+\" active=\"+container.ext().isActive(returnBucket)+\" stored = \"+container.ext().isStored(returnBucket)+\" but UID(data)=\"+container.ext().getID(data)+\" for \"+data+\" active = \"+container.ext().isActive(data)+\" stored = \"+container.ext().isStored(data));\n\t\t\t\t\t// Succeed anyway, hope that the returned bucket is consistent...\n\t\t\t\t\treturnBucket = data;\n\t\t\t\t\tfailed = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(data instanceof FileBucket) {\n\t\t\t\tLogger.error(this, \"Returned bucket \"+data+\" in onSuccess, expected \"+returnBucket, new Exception(\"error\"));\n\t\t\t\tonFailure(new FetchException(FetchException.INTERNAL_ERROR, \"Data != returnBucket\"), null, container);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Something wierd happened, recreate returnBucket ...\n\t\t\tif(tempFile != null && tempFile.exists()) tempFile.delete();\n\t\t\treturnBucket.free();\n\t\t\tif(persistenceType == PERSIST_FOREVER)\n\t\t\t\treturnBucket.removeFrom(container);\n\t\t\treturnBucket = getBucket(container);\n\t\t\tif(persistenceType == PERSIST_FOREVER && container.ext().isStored(this)) {\n\t\t\t\treturnBucket.storeTo(container);\n\t\t\t\tcontainer.store(this);\n\t\t\t}\n\n\t\t\tLogger.error(this, \"Data returned to wrong bucket \"+data+\" expected \"+returnBucket+\" in \"+this, new Exception(\"error\"));\n\t\t\ttry {\n\t\t\t\tBucketTools.copy(data, returnBucket);\n\t\t\t} catch (IOException e) {\n\t\t\t\tdata.free();\n\t\t\t\treturnBucket.free();\n\t\t\t\tif(persistenceType == PERSIST_FOREVER) {\n\t\t\t\t\tdata.removeFrom(container);\n\t\t\t\t}\n\t\t\t\tonFailure(new FetchException(FetchException.INTERNAL_ERROR, \"Data != returnBucket and then failed to copy\", e), null, container);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tboolean dontFree = false;\n\t\t// FIXME I don't think this is a problem in this case...? (Disk write while locked..)\n\t\tAllDataMessage adm = null;\n\t\tsynchronized(this) {\n\t\t\tif(succeeded) {\n\t\t\t\tLogger.error(this, \"onSuccess called twice for \"+this+\" (\"+identifier+ ')');\n\t\t\t\treturn; // We might be called twice; ignore it if so.\n\t\t\t}\n\t\t\tstarted = true;\n\t\t\tif(!binaryBlob)\n\t\t\t\tthis.foundDataMimeType = result.getMimeType();\n\t\t\telse\n\t\t\t\tthis.foundDataMimeType = BinaryBlob.MIME_TYPE;\n\n\t\t\tif(returnType == ClientGetMessage.RETURN_TYPE_DIRECT) {\n\t\t\t\t// Send all the data at once\n\t\t\t\t// FIXME there should be other options\n\t\t\t\t// FIXME: CompletionTime is set on finish() : we need to give it current time here\n\t\t\t\t// but it means we won't always return the same value to clients... Does it matter ?\n\t\t\t\tadm = new AllDataMessage(returnBucket, identifier, global, startupTime, System.currentTimeMillis(), this.foundDataMimeType);\n\t\t\t\tif(persistenceType == PERSIST_CONNECTION)\n\t\t\t\t\tadm.setFreeOnSent();\n\t\t\t\tdontFree = true;\n\t\t\t\t/*\n\t\t\t\t * } else if(returnType == ClientGetMessage.RETURN_TYPE_NONE) {\n\t\t\t\t// Do nothing\n\t\t\t\t */\n\t\t\t} else if(returnType == ClientGetMessage.RETURN_TYPE_DISK) {\n\t\t\t\t// Write to temp file, then rename over filename\n\t\t\t\tif(!FileUtil.renameTo(tempFile, targetFile)) {\n\t\t\t\t\tpostFetchProtocolErrorMessage = new ProtocolErrorMessage(ProtocolErrorMessage.COULD_NOT_RENAME_FILE, false, null, identifier, global);\n\t\t\t\t\t// Don't delete temp file, user might want it.\n\t\t\t\t}\n\t\t\t\treturnBucket = new FileBucket(targetFile, false, true, false, false, false);\n\t\t\t}\n\t\t\tif(persistenceType == PERSIST_FOREVER && progressPending != null) {\n\t\t\t\tcontainer.activate(progressPending, 1);\n\t\t\t\tprogressPending.removeFrom(container);\n\t\t\t}\n\t\t\tprogressPending = null;\n\t\t\tthis.foundDataLength = returnBucket.size();\n\t\t\tthis.succeeded = true;\n\t\t\tfinished = true;\n\t\t}\n\t\ttrySendDataFoundOrGetFailed(null, container);\n\n\t\tif(adm != null)\n\t\t\ttrySendAllDataMessage(adm, null, container);\n\t\tif(!dontFree) {\n\t\t\tdata.free();\n\t\t}\n\t\tif(persistenceType == PERSIST_FOREVER) {\n\t\t\treturnBucket.storeTo(container);\n\t\t\tcontainer.store(this);\n\t\t}\n\t\tfinish(container);\n\t\tif(client != null)\n\t\t\tclient.notifySuccess(this, container);\n\t}","id":33962,"modified_method":"public void onSuccess(FetchResult result, ClientGetter state, ObjectContainer container) {\n\t\tLogger.minor(this, \"Succeeded: \"+identifier);\n\t\tBucket data = result.asBucket();\n\t\tif(persistenceType == PERSIST_FOREVER) {\n\t\t\tif(data != null)\n\t\t\t\tcontainer.activate(data, 5);\n\t\t\tif(returnBucket != null)\n\t\t\t\tcontainer.activate(returnBucket, 5);\n\t\t\tcontainer.activate(client, 1);\n\t\t\tif(tempFile != null)\n\t\t\t\tcontainer.activate(tempFile, 5);\n\t\t\tif(targetFile != null)\n\t\t\t\tcontainer.activate(targetFile, 5);\n\t\t}\n\t\tif(returnBucket != data && !binaryBlob) {\n\t\t\tboolean failed = true;\n\t\t\tsynchronized(this) {\n\t\t\t\tif(finished) {\n\t\t\t\t\tLogger.error(this, \"Already finished but onSuccess() for \"+this+\" data = \"+data, new Exception(\"debug\"));\n\t\t\t\t\tdata.free();\n\t\t\t\t\tif(persistenceType == PERSIST_FOREVER) data.removeFrom(container);\n\t\t\t\t\treturn; // Already failed - bucket error maybe??\n\t\t\t\t}\n\t\t\t\tif(returnType == ClientGetMessage.RETURN_TYPE_DIRECT && returnBucket == null) {\n\t\t\t\t\t// Lost bucket for some reason e.g. bucket error (caused by IOException) on previous try??\n\t\t\t\t\t// Recover...\n\t\t\t\t\treturnBucket = data;\n\t\t\t\t\tfailed = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(failed && persistenceType == PERSIST_FOREVER) {\n\t\t\t\tif(container.ext().getID(returnBucket) == container.ext().getID(data)) {\n\t\t\t\t\tLogger.error(this, \"DB4O BUG DETECTED WITHOUT ARRAY HANDLING! EVIL HORRIBLE BUG! UID(returnBucket)=\"+container.ext().getID(returnBucket)+\" for \"+returnBucket+\" active=\"+container.ext().isActive(returnBucket)+\" stored = \"+container.ext().isStored(returnBucket)+\" but UID(data)=\"+container.ext().getID(data)+\" for \"+data+\" active = \"+container.ext().isActive(data)+\" stored = \"+container.ext().isStored(data));\n\t\t\t\t\t// Succeed anyway, hope that the returned bucket is consistent...\n\t\t\t\t\treturnBucket = data;\n\t\t\t\t\tfailed = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(data instanceof FileBucket && data != returnBucket) {\n\t\t\t\tLogger.error(this, \"Returned bucket \"+data+\" in onSuccess, expected \"+returnBucket, new Exception(\"error\"));\n\t\t\t\tonFailure(new FetchException(FetchException.INTERNAL_ERROR, \"Data != returnBucket\"), null, container);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Something wierd happened, recreate returnBucket ...\n\t\t\tif(tempFile != null && tempFile.exists()) tempFile.delete();\n\t\t\tif(data != returnBucket)\n\t\t\t\treturnBucket.free();\n\t\t\tif(data != returnBucket) {\n\t\t\t\tif(persistenceType == PERSIST_FOREVER)\n\t\t\t\t\treturnBucket.removeFrom(container);\n\t\t\t\treturnBucket = getBucket(container);\n\t\t\t}\n\t\t\tif(persistenceType == PERSIST_FOREVER && container.ext().isStored(this)) {\n\t\t\t\treturnBucket.storeTo(container);\n\t\t\t\tcontainer.store(this);\n\t\t\t\t\n\t\t\t\tLogger.error(this, \"Data returned to wrong bucket \"+data+\" expected \"+returnBucket+\" in \"+this, new Exception(\"error\"));\n\t\t\t\ttry {\n\t\t\t\t\tBucketTools.copy(data, returnBucket);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tdata.free();\n\t\t\t\t\treturnBucket.free();\n\t\t\t\t\tif(persistenceType == PERSIST_FOREVER) {\n\t\t\t\t\t\tdata.removeFrom(container);\n\t\t\t\t\t}\n\t\t\t\t\tonFailure(new FetchException(FetchException.INTERNAL_ERROR, \"Data != returnBucket and then failed to copy\", e), null, container);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tboolean dontFree = false;\n\t\t// FIXME I don't think this is a problem in this case...? (Disk write while locked..)\n\t\tAllDataMessage adm = null;\n\t\tsynchronized(this) {\n\t\t\tif(succeeded) {\n\t\t\t\tLogger.error(this, \"onSuccess called twice for \"+this+\" (\"+identifier+ ')');\n\t\t\t\treturn; // We might be called twice; ignore it if so.\n\t\t\t}\n\t\t\tstarted = true;\n\t\t\tif(!binaryBlob)\n\t\t\t\tthis.foundDataMimeType = result.getMimeType();\n\t\t\telse\n\t\t\t\tthis.foundDataMimeType = BinaryBlob.MIME_TYPE;\n\n\t\t\tif(returnType == ClientGetMessage.RETURN_TYPE_DIRECT) {\n\t\t\t\t// Send all the data at once\n\t\t\t\t// FIXME there should be other options\n\t\t\t\t// FIXME: CompletionTime is set on finish() : we need to give it current time here\n\t\t\t\t// but it means we won't always return the same value to clients... Does it matter ?\n\t\t\t\tadm = new AllDataMessage(returnBucket, identifier, global, startupTime, System.currentTimeMillis(), this.foundDataMimeType);\n\t\t\t\tif(persistenceType == PERSIST_CONNECTION)\n\t\t\t\t\tadm.setFreeOnSent();\n\t\t\t\tdontFree = true;\n\t\t\t\t/*\n\t\t\t\t * } else if(returnType == ClientGetMessage.RETURN_TYPE_NONE) {\n\t\t\t\t// Do nothing\n\t\t\t\t */\n\t\t\t} else if(returnType == ClientGetMessage.RETURN_TYPE_DISK) {\n\t\t\t\t// Write to temp file, then rename over filename\n\t\t\t\tif(!FileUtil.renameTo(tempFile, targetFile)) {\n\t\t\t\t\tpostFetchProtocolErrorMessage = new ProtocolErrorMessage(ProtocolErrorMessage.COULD_NOT_RENAME_FILE, false, null, identifier, global);\n\t\t\t\t\t// Don't delete temp file, user might want it.\n\t\t\t\t}\n\t\t\t\treturnBucket = new FileBucket(targetFile, false, true, false, false, false);\n\t\t\t}\n\t\t\tif(persistenceType == PERSIST_FOREVER && progressPending != null) {\n\t\t\t\tcontainer.activate(progressPending, 1);\n\t\t\t\tprogressPending.removeFrom(container);\n\t\t\t}\n\t\t\tprogressPending = null;\n\t\t\tthis.foundDataLength = returnBucket.size();\n\t\t\tthis.succeeded = true;\n\t\t\tfinished = true;\n\t\t}\n\t\ttrySendDataFoundOrGetFailed(null, container);\n\n\t\tif(adm != null)\n\t\t\ttrySendAllDataMessage(adm, null, container);\n\t\tif(!dontFree) {\n\t\t\tdata.free();\n\t\t}\n\t\tif(persistenceType == PERSIST_FOREVER) {\n\t\t\treturnBucket.storeTo(container);\n\t\t\tcontainer.store(this);\n\t\t}\n\t\tfinish(container);\n\t\tif(client != null)\n\t\t\tclient.notifySuccess(this, container);\n\t}","commit_id":"688edcbdc612af71e622c804d70f34e8c8c764e0","url":"https://github.com/freenet/fred"},{"original_method":"protected void doResults(\n        SoapMessage msg, \n        String actor,\n        Element soapHeader,\n        Element soapBody,\n        List<WSSecurityEngineResult> wsResult, \n        boolean utWithCallbacks\n    ) throws SOAPException, XMLStreamException, WSSecurityException {\n        /*\n         * All ok up to this point. Now construct and setup the security result\n         * structure. The service may fetch this and check it.\n         */\n        List<WSHandlerResult> results = CastUtils.cast((List<?>)msg.get(WSHandlerConstants.RECV_RESULTS));\n        if (results == null) {\n            results = new ArrayList<WSHandlerResult>();\n            msg.put(WSHandlerConstants.RECV_RESULTS, results);\n        }\n        WSHandlerResult rResult = new WSHandlerResult(actor, wsResult);\n        results.add(0, rResult);\n\n        for (WSSecurityEngineResult o : wsResult) {\n            final Principal p = (Principal)o.get(WSSecurityEngineResult.TAG_PRINCIPAL);\n            if (p != null) {\n                msg.put(PRINCIPAL_RESULT, p);\n                if (!utWithCallbacks) {\n                    WSS4JTokenConverter.convertToken(msg, p);\n                }\n                SecurityContext sc = msg.get(SecurityContext.class);\n                if (sc == null || sc.getUserPrincipal() == null) {\n                    msg.put(SecurityContext.class, createSecurityContext(p));\n                    break;\n                }\n            }            \n        }\n    }","id":33963,"modified_method":"protected void doResults(\n        SoapMessage msg, \n        String actor,\n        Element soapHeader,\n        Element soapBody,\n        List<WSSecurityEngineResult> wsResult, \n        boolean utWithCallbacks\n    ) throws SOAPException, XMLStreamException, WSSecurityException {\n        /*\n         * All ok up to this point. Now construct and setup the security result\n         * structure. The service may fetch this and check it.\n         */\n        List<WSHandlerResult> results = CastUtils.cast((List<?>)msg.get(WSHandlerConstants.RECV_RESULTS));\n        if (results == null) {\n            results = new ArrayList<WSHandlerResult>();\n            msg.put(WSHandlerConstants.RECV_RESULTS, results);\n        }\n        WSHandlerResult rResult = new WSHandlerResult(actor, wsResult);\n        results.add(0, rResult);\n\n        for (WSSecurityEngineResult o : wsResult) {\n            final Principal p = (Principal)o.get(WSSecurityEngineResult.TAG_PRINCIPAL);\n            if (p != null && isSecurityContextPrincipal(p, wsResult)) {\n                msg.put(PRINCIPAL_RESULT, p);\n                if (!utWithCallbacks) {\n                    WSS4JTokenConverter.convertToken(msg, p);\n                }\n                SecurityContext sc = msg.get(SecurityContext.class);\n                if (sc == null || sc.getUserPrincipal() == null) {\n                    msg.put(SecurityContext.class, createSecurityContext(p));\n                    break;\n                }\n            }            \n        }\n    }","commit_id":"c05591cc9a2cccfb12e9ea39d91aa976b03a5d94","url":"https://github.com/apache/cxf"},{"original_method":"private List<WSHandlerResult> makeInvocation(\n        Map<String, String> outProperties,\n        List<String> xpaths,\n        Map<String, String> inProperties\n    ) throws Exception {\n        Document doc = readDocument(\"wsse-request-clean.xml\");\n\n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor();\n        PhaseInterceptor<SoapMessage> handler = ohandler.createEndingInterceptor();\n\n        SoapMessage msg = new SoapMessage(new MessageImpl());\n        Exchange ex = new ExchangeImpl();\n        ex.setInMessage(msg);\n\n        SOAPMessage saajMsg = MessageFactory.newInstance().createMessage();\n        SOAPPart part = saajMsg.getSOAPPart();\n        part.setContent(new DOMSource(doc));\n        saajMsg.saveChanges();\n\n        msg.setContent(SOAPMessage.class, saajMsg);\n\n        for (String key : outProperties.keySet()) {\n            msg.put(key, outProperties.get(key));\n        }\n\n        handler.handleMessage(msg);\n\n        doc = part;\n\n        for (String xpath : xpaths) {\n            assertValid(xpath, doc);\n        }\n\n        byte[] docbytes = getMessageBytes(doc);\n        XMLStreamReader reader = StaxUtils.createXMLStreamReader(new ByteArrayInputStream(docbytes));\n\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n        dbf.setValidating(false);\n        dbf.setIgnoringComments(false);\n        dbf.setIgnoringElementContentWhitespace(true);\n        dbf.setNamespaceAware(true);\n\n        DocumentBuilder db = dbf.newDocumentBuilder();\n        db.setEntityResolver(new NullResolver());\n        doc = StaxUtils.read(db, reader, false);\n\n        WSS4JInInterceptor inHandler = new WSS4JInInterceptor();\n\n        SoapMessage inmsg = new SoapMessage(new MessageImpl());\n        ex.setInMessage(inmsg);\n        inmsg.setContent(SOAPMessage.class, saajMsg);\n\n        for (String key : inProperties.keySet()) {\n            inHandler.setProperty(key, inProperties.get(key));\n        }\n\n        inHandler.handleMessage(inmsg);\n\n        final List<WSHandlerResult> handlerResults = \n            CastUtils.cast((List<?>)inmsg.get(WSHandlerConstants.RECV_RESULTS));\n        return handlerResults;\n    }","id":33964,"modified_method":"private SoapMessage makeInvocation(\n        Map<String, String> outProperties,\n        List<String> xpaths,\n        Map<String, String> inProperties\n    ) throws Exception {\n        Document doc = readDocument(\"wsse-request-clean.xml\");\n\n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor();\n        PhaseInterceptor<SoapMessage> handler = ohandler.createEndingInterceptor();\n\n        SoapMessage msg = new SoapMessage(new MessageImpl());\n        Exchange ex = new ExchangeImpl();\n        ex.setInMessage(msg);\n\n        SOAPMessage saajMsg = MessageFactory.newInstance().createMessage();\n        SOAPPart part = saajMsg.getSOAPPart();\n        part.setContent(new DOMSource(doc));\n        saajMsg.saveChanges();\n\n        msg.setContent(SOAPMessage.class, saajMsg);\n\n        for (String key : outProperties.keySet()) {\n            msg.put(key, outProperties.get(key));\n        }\n\n        handler.handleMessage(msg);\n\n        doc = part;\n\n        for (String xpath : xpaths) {\n            assertValid(xpath, doc);\n        }\n\n        byte[] docbytes = getMessageBytes(doc);\n        XMLStreamReader reader = StaxUtils.createXMLStreamReader(new ByteArrayInputStream(docbytes));\n\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n        dbf.setValidating(false);\n        dbf.setIgnoringComments(false);\n        dbf.setIgnoringElementContentWhitespace(true);\n        dbf.setNamespaceAware(true);\n\n        DocumentBuilder db = dbf.newDocumentBuilder();\n        db.setEntityResolver(new NullResolver());\n        doc = StaxUtils.read(db, reader, false);\n\n        WSS4JInInterceptor inHandler = new WSS4JInInterceptor();\n\n        SoapMessage inmsg = new SoapMessage(new MessageImpl());\n        ex.setInMessage(inmsg);\n        inmsg.setContent(SOAPMessage.class, saajMsg);\n\n        for (String key : inProperties.keySet()) {\n            inHandler.setProperty(key, inProperties.get(key));\n        }\n\n        inHandler.handleMessage(inmsg);\n\n        return inmsg;\n    }","commit_id":"c05591cc9a2cccfb12e9ea39d91aa976b03a5d94","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testPKIPath() throws Exception {\n        Map<String, String> outProperties = new HashMap<String, String>();\n        outProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        outProperties.put(WSHandlerConstants.USER, \"alice\");\n        outProperties.put(WSHandlerConstants.SIG_PROP_FILE, \"alice.properties\");\n        outProperties.put(\n            WSHandlerConstants.PW_CALLBACK_CLASS, KeystorePasswordCallback.class.getName()\n        );\n        outProperties.put(WSHandlerConstants.SIG_KEY_ID, \"DirectReference\");\n        outProperties.put(WSHandlerConstants.USE_SINGLE_CERTIFICATE, \"false\");\n        \n        Map<String, String> inProperties = new HashMap<String, String>();\n        inProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        inProperties.put(WSHandlerConstants.SIG_PROP_FILE, \"cxfca.properties\");\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//wsse:Security/ds:Signature\");\n\n        List<WSHandlerResult> handlerResults = \n            makeInvocation(outProperties, xpaths, inProperties);\n        WSSecurityEngineResult actionResult =\n            WSSecurityUtil.fetchActionResult(handlerResults.get(0).getResults(), WSConstants.SIGN);\n         \n        X509Certificate[] certificates = \n            (X509Certificate[]) actionResult.get(WSSecurityEngineResult.TAG_X509_CERTIFICATES);\n        assertNotNull(certificates);\n        assertEquals(certificates.length, 2);\n    }","id":33965,"modified_method":"@Test\n    public void testPKIPath() throws Exception {\n        Map<String, String> outProperties = new HashMap<String, String>();\n        outProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        outProperties.put(WSHandlerConstants.USER, \"alice\");\n        outProperties.put(WSHandlerConstants.SIG_PROP_FILE, \"alice.properties\");\n        outProperties.put(\n            WSHandlerConstants.PW_CALLBACK_CLASS, KeystorePasswordCallback.class.getName()\n        );\n        outProperties.put(WSHandlerConstants.SIG_KEY_ID, \"DirectReference\");\n        outProperties.put(WSHandlerConstants.USE_SINGLE_CERTIFICATE, \"false\");\n        \n        Map<String, String> inProperties = new HashMap<String, String>();\n        inProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        inProperties.put(WSHandlerConstants.SIG_PROP_FILE, \"cxfca.properties\");\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//wsse:Security/ds:Signature\");\n\n        List<WSHandlerResult> handlerResults = \n            getResults(makeInvocation(outProperties, xpaths, inProperties));\n        WSSecurityEngineResult actionResult =\n            WSSecurityUtil.fetchActionResult(handlerResults.get(0).getResults(), WSConstants.SIGN);\n         \n        X509Certificate[] certificates = \n            (X509Certificate[]) actionResult.get(WSSecurityEngineResult.TAG_X509_CERTIFICATES);\n        assertNotNull(certificates);\n        assertEquals(certificates.length, 2);\n    }","commit_id":"c05591cc9a2cccfb12e9ea39d91aa976b03a5d94","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testEncryption() throws Exception {\n        Map<String, String> outProperties = new HashMap<String, String>();\n        outProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.ENCRYPT);\n        outProperties.put(WSHandlerConstants.ENC_PROP_FILE, \"outsecurity.properties\");\n        outProperties.put(WSHandlerConstants.USER, \"myalias\");\n        outProperties.put(\"password\", \"myAliasPassword\");\n        \n        Map<String, String> inProperties = new HashMap<String, String>();\n        inProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.ENCRYPT);\n        inProperties.put(WSHandlerConstants.DEC_PROP_FILE, \"insecurity.properties\");\n        inProperties.put(\n            WSHandlerConstants.PW_CALLBACK_CLASS, \n            \"org.apache.cxf.ws.security.wss4j.TestPwdCallback\"\n        );\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//s:Body/xenc:EncryptedData\");\n\n        List<WSHandlerResult> handlerResults = \n            makeInvocation(outProperties, xpaths, inProperties);\n\n        assertNotNull(handlerResults);\n        assertSame(handlerResults.size(), 1);\n        //\n        // This should contain exactly 1 protection result\n        //\n        final java.util.List<WSSecurityEngineResult> protectionResults =\n            (java.util.List<WSSecurityEngineResult>) handlerResults.get(0).getResults();\n        assertNotNull(protectionResults);\n        assertSame(protectionResults.size(), 1);\n        //\n        // This result should contain a reference to the decrypted element,\n        // which should contain the soap:Body Qname\n        //\n        final java.util.Map<String, Object> result =\n            (java.util.Map<String, Object>) protectionResults.get(0);\n        final java.util.List<WSDataRef> protectedElements =\n            CastUtils.cast((List<?>)result.get(WSSecurityEngineResult.TAG_DATA_REF_URIS));\n        assertNotNull(protectedElements);\n        assertSame(protectedElements.size(), 1);\n        assertEquals(\n            protectedElements.get(0).getName(),\n            new javax.xml.namespace.QName(\n                \"http://schemas.xmlsoap.org/soap/envelope/\",\n                \"Body\"\n            )\n        );\n    }","id":33966,"modified_method":"@Test\n    public void testEncryption() throws Exception {\n        Map<String, String> outProperties = new HashMap<String, String>();\n        outProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.ENCRYPT);\n        outProperties.put(WSHandlerConstants.ENC_PROP_FILE, \"outsecurity.properties\");\n        outProperties.put(WSHandlerConstants.USER, \"myalias\");\n        outProperties.put(\"password\", \"myAliasPassword\");\n        \n        Map<String, String> inProperties = new HashMap<String, String>();\n        inProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.ENCRYPT);\n        inProperties.put(WSHandlerConstants.DEC_PROP_FILE, \"insecurity.properties\");\n        inProperties.put(\n            WSHandlerConstants.PW_CALLBACK_CLASS, \n            \"org.apache.cxf.ws.security.wss4j.TestPwdCallback\"\n        );\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//s:Body/xenc:EncryptedData\");\n\n        List<WSHandlerResult> handlerResults = \n            getResults(makeInvocation(outProperties, xpaths, inProperties));\n\n        assertNotNull(handlerResults);\n        assertSame(handlerResults.size(), 1);\n        //\n        // This should contain exactly 1 protection result\n        //\n        final java.util.List<WSSecurityEngineResult> protectionResults =\n            (java.util.List<WSSecurityEngineResult>) handlerResults.get(0).getResults();\n        assertNotNull(protectionResults);\n        assertSame(protectionResults.size(), 1);\n        //\n        // This result should contain a reference to the decrypted element,\n        // which should contain the soap:Body Qname\n        //\n        final java.util.Map<String, Object> result =\n            (java.util.Map<String, Object>) protectionResults.get(0);\n        final java.util.List<WSDataRef> protectedElements =\n            CastUtils.cast((List<?>)result.get(WSSecurityEngineResult.TAG_DATA_REF_URIS));\n        assertNotNull(protectedElements);\n        assertSame(protectedElements.size(), 1);\n        assertEquals(\n            protectedElements.get(0).getName(),\n            new javax.xml.namespace.QName(\n                \"http://schemas.xmlsoap.org/soap/envelope/\",\n                \"Body\"\n            )\n        );\n    }","commit_id":"c05591cc9a2cccfb12e9ea39d91aa976b03a5d94","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testEncryptedUsernameToken() throws Exception {\n        Map<String, String> outProperties = new HashMap<String, String>();\n        outProperties.put(\n            WSHandlerConstants.ACTION,\n            WSHandlerConstants.USERNAME_TOKEN + \" \" + WSHandlerConstants.ENCRYPT\n        );\n        outProperties.put(WSHandlerConstants.ENC_PROP_FILE, \"outsecurity.properties\");\n        outProperties.put(WSHandlerConstants.USER, \"alice\");\n        outProperties.put(\"password\", \"alicePassword\");\n        outProperties.put(WSHandlerConstants.ENCRYPTION_USER, \"myalias\");\n        outProperties.put(\n            WSHandlerConstants.ENCRYPTION_PARTS, \n            \"{Content}{\" + WSConstants.WSSE_NS + \"}UsernameToken\"\n        );\n        \n        Map<String, String> inProperties = new HashMap<String, String>();\n        inProperties.put(\n            WSHandlerConstants.ACTION, \n            WSHandlerConstants.USERNAME_TOKEN + \" \" + WSHandlerConstants.ENCRYPT\n        );\n        inProperties.put(WSHandlerConstants.DEC_PROP_FILE, \"insecurity.properties\");\n        inProperties.put(\n            WSHandlerConstants.PW_CALLBACK_CLASS, \n            \"org.apache.cxf.ws.security.wss4j.TestPwdCallback\"\n        );\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n\n        List<WSHandlerResult> handlerResults = \n            makeInvocation(outProperties, xpaths, inProperties);\n\n        assertNotNull(handlerResults);\n        assertSame(handlerResults.size(), 1);\n        \n        //\n        // This should contain exactly 2 protection results\n        //\n        final java.util.List<WSSecurityEngineResult> protectionResults =\n            (java.util.List<WSSecurityEngineResult>) handlerResults.get(0).getResults();\n        assertNotNull(protectionResults);\n        assertSame(protectionResults.size(), 2);\n    }","id":33967,"modified_method":"@Test\n    public void testEncryptedUsernameToken() throws Exception {\n        Map<String, String> outProperties = new HashMap<String, String>();\n        outProperties.put(\n            WSHandlerConstants.ACTION,\n            WSHandlerConstants.USERNAME_TOKEN + \" \" + WSHandlerConstants.ENCRYPT\n        );\n        outProperties.put(WSHandlerConstants.ENC_PROP_FILE, \"outsecurity.properties\");\n        outProperties.put(WSHandlerConstants.USER, \"alice\");\n        outProperties.put(\"password\", \"alicePassword\");\n        outProperties.put(WSHandlerConstants.ENCRYPTION_USER, \"myalias\");\n        outProperties.put(\n            WSHandlerConstants.ENCRYPTION_PARTS, \n            \"{Content}{\" + WSConstants.WSSE_NS + \"}UsernameToken\"\n        );\n        \n        Map<String, String> inProperties = new HashMap<String, String>();\n        inProperties.put(\n            WSHandlerConstants.ACTION, \n            WSHandlerConstants.USERNAME_TOKEN + \" \" + WSHandlerConstants.ENCRYPT\n        );\n        inProperties.put(WSHandlerConstants.DEC_PROP_FILE, \"insecurity.properties\");\n        inProperties.put(\n            WSHandlerConstants.PW_CALLBACK_CLASS, \n            \"org.apache.cxf.ws.security.wss4j.TestPwdCallback\"\n        );\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n\n        SoapMessage inmsg = makeInvocation(outProperties, xpaths, inProperties);\n        List<WSHandlerResult> handlerResults = getResults(inmsg);\n\n        assertNotNull(handlerResults);\n        assertSame(handlerResults.size(), 1);\n        \n        //\n        // This should contain exactly 2 protection results\n        //\n        final java.util.List<WSSecurityEngineResult> protectionResults =\n            (java.util.List<WSSecurityEngineResult>) handlerResults.get(0).getResults();\n        assertNotNull(protectionResults);\n        assertSame(protectionResults.size(), 2);\n        \n        final Principal p1 = (Principal)protectionResults.get(0).get(WSSecurityEngineResult.TAG_PRINCIPAL);\n        final Principal p2 = (Principal)protectionResults.get(1).get(WSSecurityEngineResult.TAG_PRINCIPAL);\n        assertTrue(p1 instanceof WSUsernameTokenPrincipal || p2 instanceof WSUsernameTokenPrincipal);\n        \n        Principal utPrincipal = p1 instanceof WSUsernameTokenPrincipal ? p1 : p2;\n        \n        Principal secContextPrincipal = (Principal)inmsg.get(WSS4JInInterceptor.PRINCIPAL_RESULT);\n        assertSame(secContextPrincipal, utPrincipal);\n    }","commit_id":"c05591cc9a2cccfb12e9ea39d91aa976b03a5d94","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testDirectReferenceSignature() throws Exception {\n        Map<String, String> outProperties = new HashMap<String, String>();\n        outProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        outProperties.put(WSHandlerConstants.SIG_PROP_FILE, \"outsecurity.properties\");\n        outProperties.put(WSHandlerConstants.USER, \"myalias\");\n        outProperties.put(WSHandlerConstants.SIG_KEY_ID, \"DirectReference\");\n        outProperties.put(\"password\", \"myAliasPassword\");\n        \n        Map<String, String> inProperties = new HashMap<String, String>();\n        inProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        inProperties.put(WSHandlerConstants.SIG_PROP_FILE, \"insecurity.properties\");\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//wsse:Security/wsse:BinarySecurityToken\");\n        xpaths.add(\"//wsse:Security/ds:Signature\");\n\n        List<WSHandlerResult> handlerResults = \n            makeInvocation(outProperties, xpaths, inProperties);\n        WSSecurityEngineResult actionResult =\n            WSSecurityUtil.fetchActionResult(handlerResults.get(0).getResults(), WSConstants.SIGN);\n         \n        X509Certificate certificate = \n            (X509Certificate) actionResult.get(WSSecurityEngineResult.TAG_X509_CERTIFICATE);\n        assertNotNull(certificate);\n    }","id":33968,"modified_method":"@Test\n    public void testDirectReferenceSignature() throws Exception {\n        Map<String, String> outProperties = new HashMap<String, String>();\n        outProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        outProperties.put(WSHandlerConstants.SIG_PROP_FILE, \"outsecurity.properties\");\n        outProperties.put(WSHandlerConstants.USER, \"myalias\");\n        outProperties.put(WSHandlerConstants.SIG_KEY_ID, \"DirectReference\");\n        outProperties.put(\"password\", \"myAliasPassword\");\n        \n        Map<String, String> inProperties = new HashMap<String, String>();\n        inProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        inProperties.put(WSHandlerConstants.SIG_PROP_FILE, \"insecurity.properties\");\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//wsse:Security/wsse:BinarySecurityToken\");\n        xpaths.add(\"//wsse:Security/ds:Signature\");\n\n        List<WSHandlerResult> handlerResults = \n            getResults(makeInvocation(outProperties, xpaths, inProperties));\n        WSSecurityEngineResult actionResult =\n            WSSecurityUtil.fetchActionResult(handlerResults.get(0).getResults(), WSConstants.SIGN);\n         \n        X509Certificate certificate = \n            (X509Certificate) actionResult.get(WSSecurityEngineResult.TAG_X509_CERTIFICATE);\n        assertNotNull(certificate);\n    }","commit_id":"c05591cc9a2cccfb12e9ea39d91aa976b03a5d94","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testSignature() throws Exception {\n        Map<String, String> outProperties = new HashMap<String, String>();\n        outProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        outProperties.put(WSHandlerConstants.SIG_PROP_FILE, \"outsecurity.properties\");\n        outProperties.put(WSHandlerConstants.USER, \"myalias\");\n        outProperties.put(\"password\", \"myAliasPassword\");\n        \n        Map<String, String> inProperties = new HashMap<String, String>();\n        inProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        inProperties.put(WSHandlerConstants.SIG_PROP_FILE, \"insecurity.properties\");\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//wsse:Security/ds:Signature\");\n\n        List<WSHandlerResult> handlerResults = \n            makeInvocation(outProperties, xpaths, inProperties);\n        WSSecurityEngineResult actionResult =\n            WSSecurityUtil.fetchActionResult(handlerResults.get(0).getResults(), WSConstants.SIGN);\n         \n        X509Certificate certificate = \n            (X509Certificate) actionResult.get(WSSecurityEngineResult.TAG_X509_CERTIFICATE);\n        assertNotNull(certificate);\n    }","id":33969,"modified_method":"@Test\n    public void testSignature() throws Exception {\n        Map<String, String> outProperties = new HashMap<String, String>();\n        outProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        outProperties.put(WSHandlerConstants.SIG_PROP_FILE, \"outsecurity.properties\");\n        outProperties.put(WSHandlerConstants.USER, \"myalias\");\n        outProperties.put(\"password\", \"myAliasPassword\");\n        \n        Map<String, String> inProperties = new HashMap<String, String>();\n        inProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        inProperties.put(WSHandlerConstants.SIG_PROP_FILE, \"insecurity.properties\");\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//wsse:Security/ds:Signature\");\n\n        List<WSHandlerResult> handlerResults = \n            getResults(makeInvocation(outProperties, xpaths, inProperties));\n        WSSecurityEngineResult actionResult =\n            WSSecurityUtil.fetchActionResult(handlerResults.get(0).getResults(), WSConstants.SIGN);\n         \n        X509Certificate certificate = \n            (X509Certificate) actionResult.get(WSSecurityEngineResult.TAG_X509_CERTIFICATE);\n        assertNotNull(certificate);\n    }","commit_id":"c05591cc9a2cccfb12e9ea39d91aa976b03a5d94","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n  public void paint(Graphics g) {\n    Point point = ArrangementSettingsUtil.getLocationOnScreen(this);\n    if (point != null) {\n      Rectangle bounds = getBounds();\n      myScreenBounds = new Rectangle(point.x, point.y, bounds.width, bounds.height);\n    }\n    super.paint(g);\n    \n    Component[] components = getComponents();\n    if (components.length < 2) {\n      return;\n    }\n\n    // Draw node connectors.\n    int x = 0;\n    g.setColor(UIManager.getColor(\"Tree.hash\"));\n    for (int i = 0; i < components.length; i++) {\n      Component component = components[i];\n      Rectangle bounds = component.getBounds();\n      if (myScreenBounds != null && i < myComponents.size()) {\n        myComponents.get(i).setScreenBounds(new Rectangle(\n          myScreenBounds.x + bounds.x, myScreenBounds.y + bounds.y, bounds.width, bounds.height\n        ));\n      }\n      int y = bounds.y + bounds.height / 2;\n      // TODO den shift y for the component\n      x += bounds.width;\n      // TODO den use right 'y'\n      if (i < components.length - 1) {\n        g.drawLine(x, y, x + BUBBLE_CONNECTOR_LENGTH, y);\n      }\n      x += BUBBLE_CONNECTOR_LENGTH;\n    }\n  }","id":33970,"modified_method":"@Override\n  public void paint(Graphics g) {\n    Point point = ArrangementConfigUtil.getLocationOnScreen(this);\n    if (point != null) {\n      Rectangle bounds = getBounds();\n      myScreenBounds = new Rectangle(point.x, point.y, bounds.width, bounds.height);\n    }\n    super.paint(g);\n    \n    Component[] components = getComponents();\n    if (components.length < 2) {\n      return;\n    }\n\n    // Draw node connectors.\n    int x = 0;\n    g.setColor(UIManager.getColor(\"Tree.hash\"));\n    for (int i = 0; i < components.length; i++) {\n      Component component = components[i];\n      Rectangle bounds = component.getBounds();\n      if (myScreenBounds != null && i < myComponents.size()) {\n        myComponents.get(i).setScreenBounds(new Rectangle(\n          myScreenBounds.x + bounds.x, myScreenBounds.y + bounds.y, bounds.width, bounds.height\n        ));\n      }\n      int y = bounds.y + bounds.height / 2;\n      // TODO den shift y for the component\n      x += bounds.width;\n      // TODO den use right 'y'\n      if (i < components.length - 1) {\n        g.drawLine(x, y, x + BUBBLE_CONNECTOR_LENGTH, y);\n      }\n      x += BUBBLE_CONNECTOR_LENGTH;\n    }\n  }","commit_id":"339d8e021b166af59809efa59e36d3eef65b9908","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public ArrangementSettingsNode getSettingsNode() {\n    return mySettingsNode;\n  }","id":33971,"modified_method":"@NotNull\n  @Override\n  public ArrangementSettingsAtomNode getSettingsNode() {\n    return mySettingsNode;\n  }","commit_id":"339d8e021b166af59809efa59e36d3eef65b9908","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Asks current editor to refresh its state in accordance with the given arguments (e.g. when new rule is selected and\n   * we want to show only available conditions).\n   *\n   * @param settings  current rule settings if defined; null as an indication that no settings should be active\n   */\n  public void updateState(@Nullable ArrangementMatcherSettings settings) {\n    for (ArrangementEntryType type : ArrangementEntryType.values()) {\n      ArrangementAtomNodeComponent component = myComponents.get(type);\n      if (component == null) {\n        continue;\n      }\n      boolean enabled;\n      boolean selected;\n      if (settings == null) {\n        enabled = false;\n        selected = false;\n      }\n      else {\n        enabled = myFilter.isEnabled(type, settings);\n        selected = settings.hasCondition(type);\n      }\n      component.setEnabled(enabled);\n      component.setSelected(selected);\n    }\n    for (ArrangementModifier modifier : ArrangementModifier.values()) {\n      ArrangementAtomNodeComponent component = myComponents.get(modifier);\n      if (component == null) {\n        continue;\n      }\n      boolean enabled;\n      boolean selected;\n      if (settings == null) {\n        enabled = false;\n        selected = false;\n      }\n      else {\n        enabled = myFilter.isEnabled(modifier, settings);\n        selected = settings.hasCondition(modifier);\n      }\n      component.setEnabled(enabled);\n      component.setSelected(selected);\n    }\n    repaint();\n  }","id":33972,"modified_method":"/**\n   * Asks current editor to refresh its state in accordance with the given arguments (e.g. when new rule is selected and\n   * we want to show only available conditions).\n   *\n   * @param model  current rule settings model if defined; null as an indication that no settings should be active\n   */\n  public void updateState(@Nullable ArrangementRuleEditingModel model) {\n    myModel = model;\n    \n    // Reset state.\n    for (ArrangementAtomNodeComponent component : myComponents.values()) {\n      component.setEnabled(false);\n      component.setSelected(false);\n    }\n    \n    if (model == null) {\n      return;\n    }\n\n    Map<ArrangementSettingType, Collection<?>> available = ArrangementConfigUtil.buildAvailableOptions(myFilter, model.getSettingsNode());\n    for (Collection<?> ids : available.values()) {\n      for (Object id : ids) {\n        ArrangementAtomNodeComponent component = myComponents.get(id);\n        if (component != null) {\n          component.setEnabled(true);\n          component.setSelected(model.hasCondition(id));\n        }\n      }\n    }\n    repaint();\n  }","commit_id":"339d8e021b166af59809efa59e36d3eef65b9908","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ArrangementMatcherRuleEditor(@NotNull ArrangementStandardSettingsAware filter,\n                                      @NotNull ArrangementNodeDisplayManager displayManager)\n  {\n    myFilter = filter;\n    init(displayManager);\n  }","id":33973,"modified_method":"public ArrangementMatcherRuleEditor(@NotNull ArrangementStandardSettingsAware filter,\n                                      @NotNull ArrangementNodeDisplayManager displayManager)\n  {\n    myFilter = filter;\n    init(displayManager);\n    addMouseListener(new MouseAdapter() {\n      @Override\n      public void mouseClicked(MouseEvent e) {\n        onMouseClicked(e);\n      }\n    });\n  }","commit_id":"339d8e021b166af59809efa59e36d3eef65b9908","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void init(@NotNull ArrangementNodeDisplayManager displayManager) {\n    setLayout(new GridBagLayout());\n\n    Map<ArrangementSettingType, Collection<?>> supportedSettings = ArrangementSettingsUtil.buildAvailableOptions(myFilter, null);\n    addRowIfPossible(ArrangementSettingType.TYPE, supportedSettings, displayManager);\n    addRowIfPossible(ArrangementSettingType.MODIFIER, supportedSettings, displayManager);\n  }","id":33974,"modified_method":"private void init(@NotNull ArrangementNodeDisplayManager displayManager) {\n    setLayout(new GridBagLayout());\n\n    Map<ArrangementSettingType, Collection<?>> supportedSettings = ArrangementConfigUtil.buildAvailableOptions(myFilter, null);\n    addRowIfPossible(ArrangementSettingType.TYPE, supportedSettings, displayManager);\n    addRowIfPossible(ArrangementSettingType.MODIFIER, supportedSettings, displayManager);\n  }","commit_id":"339d8e021b166af59809efa59e36d3eef65b9908","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ArrangementNodeDisplayManager(@NotNull ArrangementStandardSettingsAware filter,\n                                       @NotNull ArrangementStandardSettingsRepresentationAware representationManager)\n  {\n    myRepresentationManager = representationManager;\n    Map<ArrangementSettingType, Collection<?>> map = ArrangementSettingsUtil.buildAvailableOptions(filter, null);\n    for (Map.Entry<ArrangementSettingType, Collection<?>> entry : map.entrySet()) {\n      myMaxWidths.put(entry.getKey(), maxWidth(entry.getValue()));\n    }\n  }","id":33975,"modified_method":"public ArrangementNodeDisplayManager(@NotNull ArrangementStandardSettingsAware filter,\n                                       @NotNull ArrangementStandardSettingsRepresentationAware representationManager)\n  {\n    myRepresentationManager = representationManager;\n    Map<ArrangementSettingType, Collection<?>> map = ArrangementConfigUtil.buildAvailableOptions(filter, null);\n    for (Map.Entry<ArrangementSettingType, Collection<?>> entry : map.entrySet()) {\n      myMaxWidths.put(entry.getKey(), maxWidth(entry.getValue()));\n    }\n  }","commit_id":"339d8e021b166af59809efa59e36d3eef65b9908","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void addEditingListener(@NotNull ArrangementMatcherEditingListener listener) {\n    myListeners.add(listener);\n  }","id":33976,"modified_method":"public void addEditingListener(@NotNull ArrangementRuleEditingListener listener) {\n    myListeners.add(listener);\n  }","commit_id":"339d8e021b166af59809efa59e36d3eef65b9908","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void setSelectionPath(TreePath path) {\n      if (!mySkipSelectionChange) {\n        super.setSelectionPath(path);\n        notifyEditingListeners(getActiveSettings());\n      }\n    }","id":33977,"modified_method":"@Override\n    public void setSelectionPath(TreePath path) {\n      if (!mySkipSelectionChange) {\n        super.setSelectionPath(path);\n        notifyEditingListeners(getActiveModel());\n      }\n    }","commit_id":"339d8e021b166af59809efa59e36d3eef65b9908","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private int map(@NotNull DefaultMutableTreeNode parentTreeNode,\n                  @NotNull HierarchicalArrangementSettingsNode settingsNode,\n                  @Nullable ArrangementSettingsCompositeNode template,\n                  int row)\n  {\n    DefaultMutableTreeNode childTreeNode = new DefaultMutableTreeNode(settingsNode.getCurrent());\n    parentTreeNode.add(childTreeNode);\n    List<HierarchicalArrangementSettingsNode> children = settingsNode.getChildren();\n    if (children.isEmpty()) {\n      ArrangementMatcherSettings settings = new ArrangementMatcherSettings();\n      ArrangementSettingsNode condition;\n      if (template == null) {\n        condition = settingsNode.getCurrent();\n      }\n      else {\n        condition = template.clone().addOperand(settingsNode.getCurrent());\n      }\n      settings.addCondition(condition);\n      mySettings.put(row, settings);\n      return row + 1;\n    }\n    else {\n      row++;\n      ArrangementSettingsCompositeNode newTemplate =\n        template == null ? new ArrangementSettingsCompositeNode(ArrangementSettingsCompositeNode.Operator.AND)\n                         : template.clone();\n      newTemplate.addOperand(settingsNode.getCurrent());\n      for (HierarchicalArrangementSettingsNode node : children) {\n        row = map(childTreeNode, node, newTemplate, row);\n      }\n      return row;\n    }\n  }","id":33978,"modified_method":"private void map(@NotNull DefaultMutableTreeNode root,\n                   @NotNull List<ArrangementSettingsNode> settings,\n                   @NotNull ArrangementSettingsGrouper grouper)\n  {\n    ArrangementRuleEditingModelBuilder builder = new ArrangementRuleEditingModelBuilder();\n    for (ArrangementSettingsNode setting : settings) {\n      builder.build(setting, root, grouper, myModels);\n    }\n  }","commit_id":"339d8e021b166af59809efa59e36d3eef65b9908","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ArrangementRuleTree(@NotNull ArrangementNodeDisplayManager displayManager) {\n    myFactory = new ArrangementNodeComponentFactory(displayManager);\n    DefaultMutableTreeNode root = new DefaultMutableTreeNode();\n    DefaultTreeModel treeModel = new DefaultTreeModel(root);\n    myTree = new Tree(treeModel) {\n      @Override\n      protected void setExpandedState(TreePath path, boolean state) {\n        // Don't allow node collapse\n        if (state) {\n          super.setExpandedState(path, state);\n        }\n      }\n\n      @Override\n      protected boolean isAlwaysPaintRowBackground() {\n        return false;\n      }\n\n      @Override\n      protected void processMouseEvent(MouseEvent e) {\n        // JTree selects a node on mouse click at the same row (even outside the node bounds). We don't want to support\n        // such selection because selected nodes are highlighted at the rule tree, so, it produces a 'blink' effect.\n        mySkipSelectionChange = e.getClickCount() > 0 && getNodeComponentAt(e.getLocationOnScreen()) == null;\n        try {\n          super.processMouseEvent(e);\n          if (mySkipSelectionChange) {\n            notifyEditingListeners(null);\n          }\n        }\n        finally {\n          mySkipSelectionChange = false;\n        }\n      }\n    };\n    myTree.setSelectionModel(mySelectionModel);\n    mySelectionModel.addTreeSelectionListener(new TreeSelectionListener() {\n      @Override\n      public void valueChanged(TreeSelectionEvent e) {\n        setSelection(e.getOldLeadSelectionPath(), false);\n        setSelection(e.getNewLeadSelectionPath(), true);\n      }\n    });\n    myTree.addMouseListener(new MouseAdapter() {\n      @Override\n      public void mouseClicked(MouseEvent e) {\n        onMouseClicked(e);\n      }\n    });\n\n    ArrangementSettingsCompositeNode constants = new ArrangementSettingsCompositeNode(ArrangementSettingsCompositeNode.Operator.AND);\n    constants.addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.MODIFIER, ArrangementModifier.PUBLIC));\n    constants.addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.MODIFIER, ArrangementModifier.STATIC));\n    constants.addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.MODIFIER, ArrangementModifier.FINAL));\n\n    ArrangementSettingsCompositeNode privateFields = new ArrangementSettingsCompositeNode(ArrangementSettingsCompositeNode.Operator.AND);\n    privateFields.addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.MODIFIER, ArrangementModifier.PRIVATE));\n\n    HierarchicalArrangementSettingsNode fields = new HierarchicalArrangementSettingsNode(new ArrangementSettingsAtomNode(\n      ArrangementSettingType.TYPE, ArrangementEntryType.FIELD\n    ));\n    fields.addChild(new HierarchicalArrangementSettingsNode(constants));\n    fields.addChild(new HierarchicalArrangementSettingsNode(privateFields));\n    int row = map(root, fields, null, 0);\n\n    HierarchicalArrangementSettingsNode methods = new HierarchicalArrangementSettingsNode(new ArrangementSettingsAtomNode(\n      ArrangementSettingType.TYPE, ArrangementEntryType.METHOD\n    ));\n    methods.addChild(new HierarchicalArrangementSettingsNode(new ArrangementSettingsAtomNode(\n      ArrangementSettingType.MODIFIER, ArrangementModifier.PUBLIC\n    )));\n    methods.addChild(new HierarchicalArrangementSettingsNode(new ArrangementSettingsAtomNode(\n      ArrangementSettingType.MODIFIER, ArrangementModifier.PRIVATE\n    )));\n    map(root, methods, null, row);\n\n    expandAll(myTree, new TreePath(root));\n    myTree.setRootVisible(false);\n    myTree.setShowsRootHandles(false);\n    myTree.setCellRenderer(new MyCellRenderer());\n  }","id":33979,"modified_method":"public ArrangementRuleTree(@NotNull ArrangementSettingsGrouper grouper, @NotNull ArrangementNodeDisplayManager displayManager) {\n    myFactory = new ArrangementNodeComponentFactory(displayManager);\n    DefaultMutableTreeNode root = new DefaultMutableTreeNode();\n    DefaultTreeModel treeModel = new DefaultTreeModel(root);\n    myTree = new Tree(treeModel) {\n      @Override\n      protected void setExpandedState(TreePath path, boolean state) {\n        // Don't allow node collapse\n        if (state) {\n          super.setExpandedState(path, state);\n        }\n      }\n\n      @Override\n      protected boolean isAlwaysPaintRowBackground() {\n        return false;\n      }\n\n      @Override\n      protected void processMouseEvent(MouseEvent e) {\n        // JTree selects a node on mouse click at the same row (even outside the node bounds). We don't want to support\n        // such selection because selected nodes are highlighted at the rule tree, so, it produces a 'blink' effect.\n        mySkipSelectionChange = e.getClickCount() > 0 && getNodeComponentAt(e.getLocationOnScreen()) == null;\n        try {\n          super.processMouseEvent(e);\n          if (mySkipSelectionChange) {\n            notifyEditingListeners(null);\n          }\n        }\n        finally {\n          mySkipSelectionChange = false;\n        }\n      }\n    };\n    myTree.setSelectionModel(mySelectionModel);\n    mySelectionModel.addTreeSelectionListener(new TreeSelectionListener() {\n      @Override\n      public void valueChanged(TreeSelectionEvent e) {\n        setSelection(e.getOldLeadSelectionPath(), false);\n        setSelection(e.getNewLeadSelectionPath(), true);\n      }\n    });\n    myTree.addMouseListener(new MouseAdapter() {\n      @Override\n      public void mouseClicked(MouseEvent e) {\n        onMouseClicked(e);\n      }\n    });\n    \n    List<ArrangementSettingsNode> rules = new ArrayList<ArrangementSettingsNode>();\n    rules.add(new ArrangementSettingsCompositeNode(ArrangementSettingsCompositeNode.Operator.AND)\n                .addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.TYPE, ArrangementEntryType.FIELD))\n                .addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.MODIFIER, ArrangementModifier.PUBLIC))\n                .addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.MODIFIER, ArrangementModifier.STATIC))\n                .addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.MODIFIER, ArrangementModifier.FINAL)));\n    rules.add(new ArrangementSettingsCompositeNode(ArrangementSettingsCompositeNode.Operator.AND)\n                .addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.TYPE, ArrangementEntryType.FIELD))\n                .addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.MODIFIER, ArrangementModifier.PRIVATE)));\n    rules.add(new ArrangementSettingsCompositeNode(ArrangementSettingsCompositeNode.Operator.AND)\n                .addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.TYPE, ArrangementEntryType.METHOD))\n                .addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.MODIFIER, ArrangementModifier.PUBLIC)));\n    rules.add(new ArrangementSettingsCompositeNode(ArrangementSettingsCompositeNode.Operator.AND)\n                .addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.TYPE, ArrangementEntryType.METHOD))\n                .addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.MODIFIER, ArrangementModifier.PRIVATE)));\n    map(root, rules, grouper);\n\n    expandAll(myTree, new TreePath(root));\n    myTree.setRootVisible(false);\n    myTree.setShowsRootHandles(false);\n    myTree.setCellRenderer(new MyCellRenderer());\n  }","commit_id":"339d8e021b166af59809efa59e36d3eef65b9908","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private ArrangementNodeComponent getNodeComponentAt(Point screenLocation) {\n    int low = 0;\n    int high = myTree.getRowCount() - 1;\n\n    while (low <= high) {\n      int mid = (low + high) >>> 1;\n      ArrangementNodeComponent midVal = myRenderers.get(mid);\n      if (midVal == null) {\n        return null;\n      }\n      Rectangle bounds = midVal.getScreenBounds();\n      if (bounds == null) {\n        return null;\n      }\n      if (bounds.contains(screenLocation)) {\n        return midVal.getNodeComponentAt(RelativePoint.fromScreen(screenLocation));\n      }\n      else if (bounds.y > screenLocation.y) {\n        high = mid - 1;\n      }\n      else if (bounds.y + bounds.height <= screenLocation.y) {\n        low = mid + 1;\n      }\n      else {\n        return null;\n      }\n    }\n    return null;\n  }","id":33980,"modified_method":"private void notifyEditingListeners(@Nullable ArrangementRuleEditingModel model) {\n    for (ArrangementRuleEditingListener listener : myListeners) {\n      if (model == null) {\n        listener.stopEditing();\n      }\n      else {\n        listener.startEditing(model);\n      }\n    }\n  }","commit_id":"339d8e021b166af59809efa59e36d3eef65b9908","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public List<ArrangementSettingsNode> getOperands() {\n    return myOperands;\n  }","id":33981,"modified_method":"@NotNull\n  public Set<ArrangementSettingsNode> getOperands() {\n    return myOperands;\n  }","commit_id":"339d8e021b166af59809efa59e36d3eef65b9908","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ArrangementSettingsPanel(@NotNull CodeStyleSettings settings, @NotNull ArrangementStandardSettingsAware filter) {\n    super(settings);\n    ArrangementStandardSettingsRepresentationAware representationManager = DefaultArrangementSettingsRepresentationManager.INSTANCE;\n    if (filter instanceof ArrangementStandardSettingsRepresentationAware) {\n      representationManager = (ArrangementStandardSettingsRepresentationAware)filter;\n    }\n    ArrangementNodeDisplayManager displayManager = new ArrangementNodeDisplayManager(filter, representationManager);\n    \n    final ArrangementRuleTree ruleTree = new ArrangementRuleTree(displayManager);\n    Tree component = ruleTree.getTreeComponent();\n    myContent.add(new JBScrollPane(component), new GridBag().weightx(1).weighty(1).fillCell().coverLine());\n    CustomizationUtil.installPopupHandler(\n      component, ArrangementConstants.ACTION_GROUP_RULE_EDITOR_CONTEXT_MENU, ArrangementConstants.RULE_EDITOR_PLACE\n    );\n\n    final JXTaskPane editorPane = new JXTaskPane(ApplicationBundle.message(\"arrangement.title.editor\"));\n    final ArrangementMatcherRuleEditor ruleEditor = new ArrangementMatcherRuleEditor(filter, displayManager);\n    ruleEditor.applyBackground(component.getBackground());\n    editorPane.getContentPane().setBackground(component.getBackground());\n    editorPane.add(ruleEditor);\n    editorPane.setCollapsed(true);\n    final Ref<Boolean> resetEditor = new Ref<Boolean>(Boolean.TRUE);\n    myContent.add(editorPane, new GridBag().weightx(1).fillCellHorizontally().coverLine());\n    editorPane.addPropertyChangeListener(\"collapsed\", new PropertyChangeListener() {\n      @Override\n      public void propertyChange(PropertyChangeEvent evt) {\n        if (evt.getNewValue() == Boolean.FALSE && resetEditor.get()) {\n          ruleEditor.updateState(null);\n        }\n      }\n    });\n    ruleTree.addEditingListener(new ArrangementMatcherEditingListener() {\n      @Override\n      public void startEditing(@NotNull ArrangementMatcherSettings settings) {\n        ruleEditor.updateState(settings);\n        resetEditor.set(Boolean.FALSE);\n        try {\n          editorPane.setCollapsed(false);\n        }\n        finally {\n          resetEditor.set(Boolean.TRUE);\n        }\n      }\n\n      @Override\n      public void stopEditing() {\n        editorPane.setCollapsed(true); \n      }\n    });\n  }","id":33982,"modified_method":"public ArrangementSettingsPanel(@NotNull CodeStyleSettings settings, @NotNull ArrangementStandardSettingsAware filter) {\n    super(settings);\n    ArrangementStandardSettingsRepresentationAware representationManager = DefaultArrangementSettingsRepresentationManager.INSTANCE;\n    if (filter instanceof ArrangementStandardSettingsRepresentationAware) {\n      representationManager = (ArrangementStandardSettingsRepresentationAware)filter;\n    }\n    ArrangementNodeDisplayManager displayManager = new ArrangementNodeDisplayManager(filter, representationManager);\n    ArrangementSettingsGrouper grouper = DefaultArrangementSettingsGrouper.INSTANCE;\n    if (filter instanceof ArrangementSettingsGrouper) {\n      grouper = (ArrangementSettingsGrouper)filter;\n    }\n    \n    final ArrangementRuleTree ruleTree = new ArrangementRuleTree(grouper, displayManager);\n    Tree component = ruleTree.getTreeComponent();\n    myContent.add(new JBScrollPane(component), new GridBag().weightx(1).weighty(1).fillCell().coverLine());\n    CustomizationUtil.installPopupHandler(\n      component, ArrangementConstants.ACTION_GROUP_RULE_EDITOR_CONTEXT_MENU, ArrangementConstants.RULE_EDITOR_PLACE\n    );\n\n    final JXTaskPane editorPane = new JXTaskPane(ApplicationBundle.message(\"arrangement.title.editor\"));\n    final ArrangementMatcherRuleEditor ruleEditor = new ArrangementMatcherRuleEditor(filter, displayManager);\n    ruleEditor.applyBackground(component.getBackground());\n    editorPane.getContentPane().setBackground(component.getBackground());\n    editorPane.add(ruleEditor);\n    editorPane.setCollapsed(true);\n    final Ref<Boolean> resetEditor = new Ref<Boolean>(Boolean.TRUE);\n    myContent.add(editorPane, new GridBag().weightx(1).fillCellHorizontally().coverLine());\n    editorPane.addPropertyChangeListener(\"collapsed\", new PropertyChangeListener() {\n      @Override\n      public void propertyChange(PropertyChangeEvent evt) {\n        if (evt.getNewValue() == Boolean.FALSE && resetEditor.get()) {\n          ruleEditor.updateState(null);\n        }\n      }\n    });\n    ruleTree.addEditingListener(new ArrangementRuleEditingListener() {\n      @Override\n      public void startEditing(@NotNull ArrangementRuleEditingModel model) {\n        ruleEditor.updateState(model);\n        resetEditor.set(Boolean.FALSE);\n        try {\n          editorPane.setCollapsed(false);\n        }\n        finally {\n          resetEditor.set(Boolean.TRUE);\n        }\n      }\n\n      @Override\n      public void stopEditing() {\n        editorPane.setCollapsed(true); \n      }\n    });\n  }","commit_id":"339d8e021b166af59809efa59e36d3eef65b9908","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean isEnabled(@NotNull ArrangementEntrySortType type, @Nullable ArrangementMatcherSettings settings) {\n    // TODO den implement \n    return true;\n  }","id":33983,"modified_method":"@Override\n  public boolean isEnabled(@NotNull ArrangementEntrySortType type, @Nullable ArrangementSettingsNode current) {\n    // TODO den implement \n    return true;\n  }","commit_id":"339d8e021b166af59809efa59e36d3eef65b9908","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean isNameFilterEnabled(@Nullable ArrangementMatcherSettings settings) {\n    // TODO den implement \n    return true;\n  }","id":33984,"modified_method":"@Override\n  public boolean isNameFilterEnabled(@Nullable ArrangementSettingsNode current) {\n    // TODO den implement \n    return true;\n  }","commit_id":"339d8e021b166af59809efa59e36d3eef65b9908","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean isEnabled(@NotNull ArrangementEntryType type, @Nullable ArrangementMatcherSettings settings) {\n    return SUPPORTED_TYPES.contains(type);\n  }","id":33985,"modified_method":"@Override\n  public boolean isEnabled(@NotNull ArrangementEntryType type, @Nullable ArrangementSettingsNode current) {\n    return SUPPORTED_TYPES.contains(type);\n  }","commit_id":"339d8e021b166af59809efa59e36d3eef65b9908","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean isEnabled(@NotNull ArrangementModifier modifier, @Nullable ArrangementMatcherSettings settings) {\n    if (settings == null) {\n      return SUPPORTED_MODIFIERS.contains(modifier);\n    }\n    Object key = NO_TYPE;\n    for (ArrangementEntryType type : ArrangementEntryType.values()) {\n      if (settings.hasCondition(type)) {\n        key = type;\n        break;\n      }\n    }\n    Set<ArrangementModifier> modifiers = MODIFIERS_BY_TYPE.get(key);\n    return modifiers != null && modifiers.contains(modifier);\n  }","id":33986,"modified_method":"@Override\n  public boolean isEnabled(@NotNull ArrangementModifier modifier, @Nullable ArrangementSettingsNode current) {\n    if (current == null) {\n      return SUPPORTED_MODIFIERS.contains(modifier);\n    }\n\n    final Ref<Object> typeRef = new Ref<Object>();\n    current.invite(new ArrangementSettingsNodeVisitor() {\n      @Override\n      public void visit(@NotNull ArrangementSettingsAtomNode node) {\n        if (node.getType() == ArrangementSettingType.TYPE) {\n          typeRef.set(node.getValue());\n        }\n      }\n\n      @Override\n      public void visit(@NotNull ArrangementSettingsCompositeNode node) {\n        for (ArrangementSettingsNode n : node.getOperands()) {\n          if (typeRef.get() != null) {\n            return;\n          }\n          n.invite(this);\n        } \n      }\n    });\n    Object key = typeRef.get() == null ? NO_TYPE : typeRef.get();\n    Set<ArrangementModifier> modifiers = MODIFIERS_BY_TYPE.get(key);\n    return modifiers != null && modifiers.contains(modifier);\n  }","commit_id":"339d8e021b166af59809efa59e36d3eef65b9908","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * create a Solr query string from this conjunction\n     * @return a string which is a Solr query string\n     */\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        for (Term term: this.terms) {\n            if (sb.length() == 0) sb.append('('); else sb.append(\") \").append(this.operandName).append(\" (\");\n            sb.append(term.toString());\n        }\n        sb.append(')');\n        return sb.toString();\n    }","id":33987,"modified_method":"/**\n     * create a Solr query string from this conjunction\n     * @return a string which is a Solr query string\n     */\n    @Override\n    public String toString() {\n        if (this.terms.size() == 0) return \"\";\n        StringBuilder sb = new StringBuilder();\n        if (this.terms.size() == 1) {\n            sb.append(terms.iterator().next().toString());\n        } else {\n            sb.append('(');\n            for (Term term: this.terms) {\n                if (sb.length() > 1) sb.append(' ').append(this.operandName).append(' ');\n                sb.append(term.toString());\n            }\n            sb.append(')');\n        }\n        return sb.toString();\n    }","commit_id":"fe537679dee3a77ee4ed137a2f408301327c660d","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void postprocessing_doublecontent(Segment segment, Set<String> uniqueURLs, SolrDocument doc, final SolrInputDocument sid, final DigestURL url) {\n        // FIND OUT IF THIS IS A DOUBLE DOCUMENT\n        String urlhash = ASCII.String(url.hash());\n        String hostid = url.hosthash();\n        Conjunction con = new Conjunction();\n        Disjunction dnf = new Disjunction();\n        CollectionSchema[][] doccheckschema = new CollectionSchema[][]{\n                {CollectionSchema.exact_signature_l, CollectionSchema.exact_signature_unique_b, CollectionSchema.exact_signature_copycount_i},\n                {CollectionSchema.fuzzy_signature_l, CollectionSchema.fuzzy_signature_unique_b, CollectionSchema.fuzzy_signature_copycount_i}};\n        uniquecheck: for (CollectionSchema[] checkfields: doccheckschema) {\n            CollectionSchema signaturefield = checkfields[0];\n            CollectionSchema uniquefield = checkfields[1];\n            CollectionSchema countfield = checkfields[2];\n\n            if (this.contains(signaturefield) && this.contains(uniquefield) && this.contains(countfield)) {\n                // lookup the document with the same signature\n                Long signature = (Long) doc.getFieldValue(signaturefield.getSolrFieldName());\n                if (signature == null) continue uniquecheck;\n                //con.addOperand(new Negation(new Literal(CollectionSchema.id, urlhash)));\n                //con.addOperand(new Literal(CollectionSchema.host_id_s, hostid));\n                dnf.addOperand(new Literal(signaturefield, signature.toString()));\n            }\n        }\n        con.addOperand(dnf);\n        con.addOperand(new Negation(new Literal(CollectionSchema.id, urlhash)));\n        con.addOperand(new Literal(CollectionSchema.host_id_s, hostid));\n        String query = con.toString();\n        SolrDocumentList docsAkk;\n        try {\n             docsAkk = segment.fulltext().getDefaultConnector().getDocumentListByQuery(query, null, 0, 200,\n                     CollectionSchema.id.getSolrFieldName(), CollectionSchema.exact_signature_l.getSolrFieldName(), CollectionSchema.fuzzy_signature_l.getSolrFieldName());\n        } catch (final IOException e) {\n            ConcurrentLog.logException(e);\n            docsAkk = new SolrDocumentList(); \n        }\n        if (docsAkk.getNumFound() > 0) uniquecheck: for (CollectionSchema[] checkfields: doccheckschema) {\n            CollectionSchema signaturefield = checkfields[0];\n            CollectionSchema uniquefield = checkfields[1];\n            CollectionSchema countfield = checkfields[2];\n\n            if (this.contains(signaturefield) && this.contains(uniquefield) && this.contains(countfield)) {\n                // lookup the document with the same signature\n                Long signature = (Long) doc.getFieldValue(signaturefield.getSolrFieldName());\n                if (signature == null) continue uniquecheck;\n                SolrDocumentList docs = new Literal(signaturefield, signature.toString()).apply(docsAkk);\n                if (docs.getNumFound() == 0) {\n                    sid.setField(uniquefield.getSolrFieldName(), true);\n                    sid.setField(countfield.getSolrFieldName(), 1);\n                } else {\n                    boolean firstappearance = true;\n                    for (SolrDocument d: docs) {if (uniqueURLs.contains(d.getFieldValue(CollectionSchema.id.getSolrFieldName()))) firstappearance = false; break;}\n                    sid.setField(uniquefield.getSolrFieldName(), firstappearance);\n                    sid.setField(countfield.getSolrFieldName(), docs.getNumFound() + 1); // the current url was excluded from search but is included in count\n                }\n            }\n        }\n        \n        // CHECK IF TITLE AND DESCRIPTION IS UNIQUE (this is by default not switched on)\n        // in case that the document has no status code 200, has a noindex attribute\n        // or a canonical tag which does not point to the document itself,\n        // then the unique-field is not written at all!\n        Integer robots_i = this.contains(CollectionSchema.robots_i) ? (Integer) doc.getFieldValue(CollectionSchema.robots_i.getSolrFieldName()) : null;\n        Integer httpstatus_i = this.contains(CollectionSchema.httpstatus_i) ? (Integer) doc.getFieldValue(CollectionSchema.httpstatus_i.getSolrFieldName()) : null;\n        String canonical_s = this.contains(CollectionSchema.canonical_s) ? (String) doc.getFieldValue(CollectionSchema.canonical_s.getSolrFieldName()) : null;\n        Boolean canonical_equal_sku_b = this.contains(CollectionSchema.canonical_equal_sku_b) ? (Boolean) doc.getFieldValue(CollectionSchema.canonical_equal_sku_b.getSolrFieldName()) : null;\n\n        CollectionSchema[][] metadatacheckschema = new CollectionSchema[][]{\n                {CollectionSchema.title, CollectionSchema.title_exact_signature_l, CollectionSchema.title_unique_b},\n                {CollectionSchema.description_txt, CollectionSchema.description_exact_signature_l, CollectionSchema.description_unique_b}};\n        if (segment.fulltext().getDefaultConfiguration().contains(CollectionSchema.host_id_s) &&\n            (robots_i == null || (robots_i.intValue() & (1 << 9)) == 0 /*noindex in http X-ROBOTS*/ && (robots_i.intValue() & (1 << 3)) == 0 /*noindex in html metas*/ ) &&\n            (canonical_s == null || canonical_s.length() == 0 || (canonical_equal_sku_b != null && canonical_equal_sku_b.booleanValue()) || url.toNormalform(true).equals(canonical_s)) &&\n            (httpstatus_i == null || httpstatus_i.intValue() == 200)) {\n            uniquecheck: for (CollectionSchema[] checkfields: metadatacheckschema) {\n                CollectionSchema checkfield = checkfields[0];\n                CollectionSchema signaturefield = checkfields[1];\n                CollectionSchema uniquefield = checkfields[2];\n                if (this.contains(checkfield) && this.contains(signaturefield) && this.contains(uniquefield)) {\n                    // lookup in the index within the same hosts for the same title or description\n                    //String checkstring = checkfield == CollectionSchema.title ? document.dc_title() : document.dc_description();\n                    Long signature = (Long) doc.getFieldValue(signaturefield.getSolrFieldName());\n                    if (signature == null) {\n                        continue uniquecheck;\n                    }\n                    try {\n                        String doccountquery = \n                                CollectionSchema.host_id_s.getSolrFieldName() + \":\\\"\" + hostid + \"\\\" AND \" +\n                                \"-\" + CollectionSchema.robots_i.getSolrFieldName() + \":8 AND \" + // bit 3 (noindex)\n                                \"-\" + CollectionSchema.robots_i.getSolrFieldName() + \":24 AND \" + // bit 3 + 4 (noindex + nofollow)\n                                \"-\" + CollectionSchema.robots_i.getSolrFieldName() + \":512 AND \" + // bit 9 (noindex)\n                                \"-\" + CollectionSchema.robots_i.getSolrFieldName() + \":1536 AND \" + // bit 9 + 10 (noindex + nofollow)\n                                \"((-\" + CollectionSchema.canonical_equal_sku_b.getSolrFieldName() + \":\" + AbstractSolrConnector.CATCHALL_TERM + \") OR (\" + CollectionSchema.canonical_equal_sku_b.getSolrFieldName() + \":true)) AND \" +\n                                CollectionSchema.httpstatus_i.getSolrFieldName() + \":200 AND \" +\n                                \"-\" + CollectionSchema.id.getSolrFieldName() + \":\\\"\" + urlhash + \"\\\" AND \" +\n                                signaturefield.getSolrFieldName() + \":\\\"\" + signature.toString() + \"\\\"\";\n                        long doccount = segment.fulltext().getDefaultConnector().getCountByQuery(doccountquery);\n                        sid.setField(uniquefield.getSolrFieldName(), doccount  == 0);\n                    } catch (final IOException e) {}\n                }\n            }\n        }\n        uniqueURLs.add(urlhash);\n    }","id":33988,"modified_method":"public void postprocessing_doublecontent(Segment segment, Set<String> uniqueURLs, SolrDocument doc, final SolrInputDocument sid, final DigestURL url) {\n        // FIND OUT IF THIS IS A DOUBLE DOCUMENT\n        // term to describe documents which are indexable:\n        // - no noindex in meta oder x-robots\n        // - no canonical-tag\n        Conjunction ValidDocTermTemplate = new Conjunction();\n        ValidDocTermTemplate.addOperand(new LongLiteral(CollectionSchema.httpstatus_i, 200));\n        ValidDocTermTemplate.addOperand(new Disjunction(new Negation(new CatchallLiteral(CollectionSchema.canonical_equal_sku_b)), new BooleanLiteral(CollectionSchema.canonical_equal_sku_b, true)));\n        ValidDocTermTemplate.addOperand(new Negation(new LongLiteral(CollectionSchema.robots_i, 8))); // bit 3 (noindex)\n        ValidDocTermTemplate.addOperand(new Negation(new LongLiteral(CollectionSchema.robots_i, 24))); // bit 3 + 4 (noindex + nofollow)\n        ValidDocTermTemplate.addOperand(new Negation(new LongLiteral(CollectionSchema.robots_i, 512))); // bit 9 (noindex)\n        ValidDocTermTemplate.addOperand(new Negation(new LongLiteral(CollectionSchema.robots_i, 1536))); // bit 9 + 10 (noindex + nofollow)\n        \n        String urlhash = ASCII.String(url.hash());\n        String hostid = url.hosthash();\n        Disjunction dnf = new Disjunction();\n        CollectionSchema[][] doccheckschema = new CollectionSchema[][]{\n                {CollectionSchema.exact_signature_l, CollectionSchema.exact_signature_unique_b, CollectionSchema.exact_signature_copycount_i},\n                {CollectionSchema.fuzzy_signature_l, CollectionSchema.fuzzy_signature_unique_b, CollectionSchema.fuzzy_signature_copycount_i}};\n        uniquecheck: for (CollectionSchema[] checkfields: doccheckschema) {\n            CollectionSchema signaturefield = checkfields[0];\n            CollectionSchema uniquefield = checkfields[1];\n            CollectionSchema countfield = checkfields[2];\n\n            if (this.contains(signaturefield) && this.contains(uniquefield) && this.contains(countfield)) {\n                // lookup the document with the same signature\n                Long signature = (Long) doc.getFieldValue(signaturefield.getSolrFieldName());\n                if (signature == null) continue uniquecheck;\n                //con.addOperand(new Negation(new Literal(CollectionSchema.id, urlhash)));\n                //con.addOperand(new Literal(CollectionSchema.host_id_s, hostid));\n                dnf.addOperand(new LongLiteral(signaturefield, signature));\n            }\n        }\n        Conjunction con = (Conjunction) ValidDocTermTemplate.clone();\n        con.addOperand(dnf);\n        con.addOperand(new Negation(new StringLiteral(CollectionSchema.id, urlhash)));\n        con.addOperand(new StringLiteral(CollectionSchema.host_id_s, hostid));\n        String query = con.toString();\n        SolrDocumentList docsAkk;\n        try {\n             docsAkk = segment.fulltext().getDefaultConnector().getDocumentListByQuery(query, null, 0, 200,\n                     CollectionSchema.id.getSolrFieldName(), CollectionSchema.exact_signature_l.getSolrFieldName(), CollectionSchema.fuzzy_signature_l.getSolrFieldName());\n        } catch (final IOException e) {\n            ConcurrentLog.logException(e);\n            docsAkk = new SolrDocumentList(); \n        }\n        if (docsAkk.getNumFound() > 0) uniquecheck: for (CollectionSchema[] checkfields: doccheckschema) {\n            CollectionSchema signaturefield = checkfields[0];\n            CollectionSchema uniquefield = checkfields[1];\n            CollectionSchema countfield = checkfields[2];\n\n            if (this.contains(signaturefield) && this.contains(uniquefield) && this.contains(countfield)) {\n                // lookup the document with the same signature\n                Long signature = (Long) doc.getFieldValue(signaturefield.getSolrFieldName());\n                if (signature == null) continue uniquecheck;\n                SolrDocumentList docs = new StringLiteral(signaturefield, signature.toString()).apply(docsAkk);\n                if (docs.getNumFound() == 0) {\n                    sid.setField(uniquefield.getSolrFieldName(), true);\n                    sid.setField(countfield.getSolrFieldName(), 1);\n                } else {\n                    boolean firstappearance = true;\n                    for (SolrDocument d: docs) {if (uniqueURLs.contains(d.getFieldValue(CollectionSchema.id.getSolrFieldName()))) firstappearance = false; break;}\n                    sid.setField(uniquefield.getSolrFieldName(), firstappearance);\n                    sid.setField(countfield.getSolrFieldName(), docs.getNumFound() + 1); // the current url was excluded from search but is included in count\n                }\n            }\n        }\n        \n        // CHECK IF TITLE AND DESCRIPTION IS UNIQUE (this is by default not switched on)\n        // in case that the document has no status code 200, has a noindex attribute\n        // or a canonical tag which does not point to the document itself,\n        // then the unique-field is not written at all!\n        Integer robots_i = this.contains(CollectionSchema.robots_i) ? (Integer) doc.getFieldValue(CollectionSchema.robots_i.getSolrFieldName()) : null;\n        Integer httpstatus_i = this.contains(CollectionSchema.httpstatus_i) ? (Integer) doc.getFieldValue(CollectionSchema.httpstatus_i.getSolrFieldName()) : null;\n        String canonical_s = this.contains(CollectionSchema.canonical_s) ? (String) doc.getFieldValue(CollectionSchema.canonical_s.getSolrFieldName()) : null;\n        Boolean canonical_equal_sku_b = this.contains(CollectionSchema.canonical_equal_sku_b) ? (Boolean) doc.getFieldValue(CollectionSchema.canonical_equal_sku_b.getSolrFieldName()) : null;\n\n        CollectionSchema[][] metadatacheckschema = new CollectionSchema[][]{\n                {CollectionSchema.title, CollectionSchema.title_exact_signature_l, CollectionSchema.title_unique_b},\n                {CollectionSchema.description_txt, CollectionSchema.description_exact_signature_l, CollectionSchema.description_unique_b}};\n        if (segment.fulltext().getDefaultConfiguration().contains(CollectionSchema.host_id_s) &&\n            (robots_i == null || (robots_i.intValue() & (1 << 9)) == 0 /*noindex in http X-ROBOTS*/ && (robots_i.intValue() & (1 << 3)) == 0 /*noindex in html metas*/ ) &&\n            (canonical_s == null || canonical_s.length() == 0 || (canonical_equal_sku_b != null && canonical_equal_sku_b.booleanValue()) || url.toNormalform(true).equals(canonical_s)) &&\n            (httpstatus_i == null || httpstatus_i.intValue() == 200)) {\n            uniquecheck: for (CollectionSchema[] checkfields: metadatacheckschema) {\n                CollectionSchema checkfield = checkfields[0];\n                CollectionSchema signaturefield = checkfields[1];\n                CollectionSchema uniquefield = checkfields[2];\n                if (this.contains(checkfield) && this.contains(signaturefield) && this.contains(uniquefield)) {\n                    // lookup in the index within the same hosts for the same title or description\n                    //String checkstring = checkfield == CollectionSchema.title ? document.dc_title() : document.dc_description();\n                    Long signature = (Long) doc.getFieldValue(signaturefield.getSolrFieldName());\n                    if (signature == null) {\n                        continue uniquecheck;\n                    }\n                    try {\n                        Conjunction doccountterm = (Conjunction) ValidDocTermTemplate.clone();\n                        doccountterm.addOperand(new Negation(new StringLiteral(CollectionSchema.id, urlhash)));\n                        doccountterm.addOperand(new StringLiteral(CollectionSchema.host_id_s, hostid));\n                        doccountterm.addOperand(new LongLiteral(signaturefield, signature));\n                        long doccount = segment.fulltext().getDefaultConnector().getCountByQuery(doccountterm.toString());\n                        sid.setField(uniquefield.getSolrFieldName(), doccount  == 0);\n                    } catch (final IOException e) {}\n                }\n            }\n        }\n        uniqueURLs.add(urlhash);\n    }","commit_id":"fe537679dee3a77ee4ed137a2f408301327c660d","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * Checks with this ConstraintedProperty instance supports applying the specified constraint.\n     *\n     * @param constraintName The name of the constraint\n     * @return True if the constraint is supported\n     */\n    public boolean supportsContraint(String constraintName) {\n\n        if (!constraints.containsKey(constraintName)) {\n            return bean.isWritableProperty(constraintName);\n        }\n\n        try {\n            Constraint c = instantiateConstraint(constraintName);\n            return c.supports(propertyType);\n        }\n        catch (Exception e) {\n            LOG.error(\"Exception thrown instantiating constraint [\" + constraintName +\n                    \"] to class [\" + owningClass + \"]\", e);\n            throw new ConstraintException(\"Exception thrown instantiating  constraint [\" + constraintName +\n                    \"] to class [\" + owningClass + \"]\");\n        }\n    }","id":33989,"modified_method":"/**\n     * Checks with this ConstraintedProperty instance supports applying the specified constraint.\n     *\n     * @param constraintName The name of the constraint\n     * @return True if the constraint is supported\n     */\n    public boolean supportsContraint(String constraintName) {\n\n        if (!constraints.containsKey(constraintName)) {\n            return bean.isWritableProperty(constraintName);\n        }\n\n        try {\n            Constraint c = instantiateConstraint(constraintName, false);\n            return c != null && c.supports(propertyType);\n        }\n        catch (Exception e) {\n            LOG.error(\"Exception thrown instantiating constraint [\" + constraintName +\n                    \"] to class [\" + owningClass + \"]\", e);\n            throw new ConstraintException(\"Exception thrown instantiating  constraint [\" + constraintName +\n                    \"] to class [\" + owningClass + \"]\");\n        }\n    }","commit_id":"5417f923b27d47d97f61c8b22b28c3081d2b7bbb","url":"https://github.com/grails/grails-core"},{"original_method":"public static void registerNewConstraint(String name, ConstraintFactory factory) {\n        Assert.hasLength(name, \"Argument [name] cannot be null or blank\");\n        Assert.notNull(factory, \"Argument [factory] cannot be null\");\n        constraints.put(name, factory);\n    }","id":33990,"modified_method":"public static void registerNewConstraint(String name, ConstraintFactory factory) {\n        Assert.hasLength(name, \"Argument [name] cannot be null or blank\");\n        Assert.notNull(factory, \"Argument [factory] cannot be null\");\n        List<Object> objects = getOrInitializeConstraint(name);\n        objects.add(factory);\n    }","commit_id":"5417f923b27d47d97f61c8b22b28c3081d2b7bbb","url":"https://github.com/grails/grails-core"},{"original_method":"public static void registerNewConstraint(String name, Class<?> constraintClass) {\n        Assert.hasLength(name, \"Argument [name] cannot be null\");\n        if (constraintClass == null || !Constraint.class.isAssignableFrom(constraintClass)) {\n            throw new IllegalArgumentException(\"Argument [constraintClass] with value [\" + constraintClass +\n                    \"] is not a valid constraint\");\n        }\n\n        constraints.put(name, constraintClass);\n    }","id":33991,"modified_method":"public static void registerNewConstraint(String name, Class<?> constraintClass) {\n        Assert.hasLength(name, \"Argument [name] cannot be null\");\n        if (constraintClass == null || !Constraint.class.isAssignableFrom(constraintClass)) {\n            throw new IllegalArgumentException(\"Argument [constraintClass] with value [\" + constraintClass +\n                    \"] is not a valid constraint\");\n        }\n\n        List<Object> objects = getOrInitializeConstraint(name);\n        objects.add(constraintClass);\n    }","commit_id":"5417f923b27d47d97f61c8b22b28c3081d2b7bbb","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Applies a constraint for the specified name and consraint value.\n     *\n     * @param constraintName The name of the constraint\n     * @param constrainingValue The constraining value\n     *\n     * @throws ConstraintException Thrown when the specified constraint is not supported by this ConstrainedProperty. Use <code>supportsContraint(String constraintName)<\/code> to check before calling\n     */\n    public void applyConstraint(String constraintName, Object constrainingValue) {\n\n        if (constraints.containsKey(constraintName)) {\n            if (constrainingValue == null) {\n                appliedConstraints.remove(constraintName);\n            }\n            else {\n                try {\n                    Constraint c = instantiateConstraint(constraintName);\n\n                    c.setOwningClass(owningClass);\n                    c.setPropertyName(propertyName);\n                    c.setParameter(constrainingValue);\n                    appliedConstraints.put(constraintName, c);\n                }\n                catch (Exception e) {\n                    LOG.error(\"Exception thrown applying constraint [\" + constraintName +\n                            \"] to class [\" + owningClass + \"] for value [\" + constrainingValue + \"]: \" + e.getMessage(), e);\n                    throw new ConstraintException(\"Exception thrown applying constraint [\" + constraintName +\n                            \"] to class [\" + owningClass + \"] for value [\" + constrainingValue + \"]: \" + e.getMessage(), e);\n                }\n            }\n        }\n        else if (bean.isWritableProperty(constraintName)) {\n            bean.setPropertyValue(constraintName, constrainingValue);\n        }\n        else {\n            throw new ConstraintException(\"Constraint [\" + constraintName + \"] is not supported for property [\" +\n                    propertyName + \"] of class [\" + owningClass + \"] with type [\" + propertyType + \"]\");\n        }\n    }","id":33992,"modified_method":"/**\n     * Applies a constraint for the specified name and consraint value.\n     *\n     * @param constraintName The name of the constraint\n     * @param constrainingValue The constraining value\n     *\n     * @throws ConstraintException Thrown when the specified constraint is not supported by this ConstrainedProperty. Use <code>supportsContraint(String constraintName)<\/code> to check before calling\n     */\n    public void applyConstraint(String constraintName, Object constrainingValue) {\n\n        if (constraints.containsKey(constraintName)) {\n            if (constrainingValue == null) {\n                appliedConstraints.remove(constraintName);\n            }\n            else {\n                try {\n                    Constraint c = instantiateConstraint(constraintName, true);\n                    if(c != null) {\n                        c.setParameter(constrainingValue);\n                        appliedConstraints.put(constraintName, c);\n                    }\n                }\n                catch (Exception e) {\n                    LOG.error(\"Exception thrown applying constraint [\" + constraintName +\n                            \"] to class [\" + owningClass + \"] for value [\" + constrainingValue + \"]: \" + e.getMessage(), e);\n                    throw new ConstraintException(\"Exception thrown applying constraint [\" + constraintName +\n                            \"] to class [\" + owningClass + \"] for value [\" + constrainingValue + \"]: \" + e.getMessage(), e);\n                }\n            }\n        }\n        else if (bean.isWritableProperty(constraintName)) {\n            bean.setPropertyValue(constraintName, constrainingValue);\n        }\n        else {\n            throw new ConstraintException(\"Constraint [\" + constraintName + \"] is not supported for property [\" +\n                    propertyName + \"] of class [\" + owningClass + \"] with type [\" + propertyType + \"]\");\n        }\n    }","commit_id":"5417f923b27d47d97f61c8b22b28c3081d2b7bbb","url":"https://github.com/grails/grails-core"},{"original_method":"private Constraint instantiateConstraint(String constraintName) throws InstantiationException, IllegalAccessException {\n        Object constraintFactory = constraints.get(constraintName);\n        if (constraintFactory instanceof ConstraintFactory) {\n            return ((ConstraintFactory)constraintFactory).newInstance();\n        }\n\n        return (Constraint)((Class<?>)constraintFactory).newInstance();\n    }","id":33993,"modified_method":"private Constraint instantiateConstraint(String constraintName, boolean validate) throws InstantiationException, IllegalAccessException {\n        List<Object> candidateConstraints = constraints.get(constraintName);\n\n        for (Object constraintFactory : candidateConstraints) {\n\n            Constraint c;\n            if (constraintFactory instanceof ConstraintFactory) {\n                c = ((ConstraintFactory)constraintFactory).newInstance();\n            }\n            else {\n                c = (Constraint)((Class<?>)constraintFactory).newInstance();\n            }\n\n            c.setOwningClass(owningClass);\n            c.setPropertyName(propertyName);\n\n            if(validate && c.isValid()) {\n\n                return c;\n            }\n            else if(!validate) {\n                return c;\n            }\n\n        }\n        return null;\n    }","commit_id":"5417f923b27d47d97f61c8b22b28c3081d2b7bbb","url":"https://github.com/grails/grails-core"},{"original_method":"@Override\n    protected void doGet(final HttpServletRequest request,\n            final HttpServletResponse response)\n    throws ServletException, IOException {\n        this.setNoCache( response );\n\n        // full request?\n        final StatusPrinterHandler handler;\n        if ( request.getPathInfo().lastIndexOf('/') > 0 ) {\n            handler = null; // all;\n        } else {\n            handler = this.getStatusPrinterHandler();\n            if ( handler == null ) {\n                response.sendError( HttpServletResponse.SC_NOT_FOUND );\n                return;\n            }\n        }\n\n        if ( request.getPathInfo().endsWith( \".txt\" ) ) { //$NON-NLS-2$\n            response.setContentType( \"text/plain; charset=utf-8\" ); //$NON-NLS-2$\n            final ConfigurationWriter pw = new PlainTextConfigurationWriter( response.getWriter() );\n            printConfigurationStatus( pw, PrinterMode.TEXT, handler );\n            pw.flush();\n        } else if ( request.getPathInfo().endsWith( \".zip\" ) ) { //$NON-NLS-2$\n            String type = getServletContext().getMimeType( request.getPathInfo() );\n            if ( type == null ) {\n                type = \"application/x-zip\"; //$NON-NLS-2$\n            }\n            response.setContentType( type );\n\n            final ZipOutputStream zip = new ZipOutputStream( response.getOutputStream() );\n            zip.setLevel( Deflater.BEST_SPEED );\n            zip.setMethod( ZipOutputStream.DEFLATED );\n\n            final Date now = new Date();\n            // create time stamp entry\n            final ZipEntry entry = new ZipEntry( \"timestamp.txt\" ); //$NON-NLS-2$\n            entry.setTime(now.getTime());\n            zip.putNextEntry( entry );\n            final StringBuilder sb = new StringBuilder();\n            sb.append(\"Date: \");\n            synchronized ( StatusPrinterAdapter.DISPLAY_DATE_FORMAT )                             {\n                sb.append(StatusPrinterAdapter.DISPLAY_DATE_FORMAT.format(now));\n            }\n            sb.append(\" (\");\n            sb.append(String.valueOf(now.getTime()));\n            sb.append(\")\\n\");\n\n            zip.write(sb.toString().getBytes(\"UTF-8\"));\n            zip.closeEntry();\n\n            final ZipConfigurationWriter pw = new ZipConfigurationWriter( zip );\n            printConfigurationStatus( pw, PrinterMode.ZIP_FILE, handler );\n\n            zip.finish();\n        } else if ( request.getPathInfo().endsWith( \".nfo\" ) ) {\n            if ( handler == null ) {\n                response.sendError( HttpServletResponse.SC_NOT_FOUND);\n                return;\n            }\n            response.setContentType( \"text/html; charset=utf-8\" );\n\n            final HtmlConfigurationWriter pw = new HtmlConfigurationWriter( response.getWriter() );\n            pw.println ( \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Strict//EN\\\"\" );\n            pw.println ( \"  \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\\\">\" );\n            pw.println ( \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\">\" );\n            pw.println ( \"<head><title>dummy<\/title><\/head><body><div>\" );\n\n            if ( handler.supports(PrinterMode.HTML_BODY) ) {\n                handler.print(PrinterMode.HTML_BODY, pw);\n            } else {\n                pw.enableFilter( true );\n                handler.print(PrinterMode.TEXT, pw);\n                pw.enableFilter( false );\n            }\n            pw.println( \"<\/div><\/body><\/html>\" );\n            return;\n        } else {\n            if ( handler == null ) {\n                response.sendError( HttpServletResponse.SC_NOT_FOUND);\n                return;\n            }\n            final HtmlConfigurationWriter pw = new HtmlConfigurationWriter(response.getWriter());\n            pw.println(\"<script type=\\\"text/javascript\\\">\");\n            pw.println(\"// <![CDATA[\");\n            pw.println(\"function pad(value) { if ( value < 10 ) { return '0' + value;} return '' + value;}\");\n            pw.println(\"function downloadDump(ext, full) {\");\n            pw.println(\"  if (full) {\");\n            pw.println(\"    var now = new Date();\");\n            pw.println(\"    var name = \\\"configuration-status-\\\" + now.getUTCFullYear() + pad(now.getUTCMonth() + 1) + pad(now.getUTCDate()) + \\\"-\\\" + pad(now.getUTCHours()) + pad(now.getUTCMinutes()) + pad(now.getUTCSeconds()) + \\\".\\\";\");\n            pw.println(\"    location.href = location.href + \\\"/\\\" + name + ext;\");\n            pw.println(\"  } else {\");\n            pw.println(\"    location.href = location.href + '.' + ext;\");\n            pw.println(\"  }\");\n            pw.println(\"}\");\n\n            pw.println(\"$(document).ready(function() {\");\n            pw.println(\"    $('.downloadTxt').click(function() { downloadDump('txt', false)});\");\n            pw.println(\"    $('.downloadZip').click(function() { downloadDump('zip', false)});\");\n            pw.println(\"    $('.downloadFullZip').click(function() { downloadDump('zip', true)});\");\n            pw.println(\"    $('.downloadFullTxt').click(function() { downloadDump('txt', true)});\");\n            pw.println(\"});\");\n            pw.println(\"// ]]>\");\n            pw.println(\"<\/script>\");\n            pw.println( \"<br/><p class=\\\"statline\\\">\");\n\n            final Date currentTime = new Date();\n            synchronized ( StatusPrinterAdapter.DISPLAY_DATE_FORMAT )                             {\n                pw.print(\"Date: \");\n                pw.println(StatusPrinterAdapter.DISPLAY_DATE_FORMAT.format(currentTime));\n            }\n\n            pw.print(\"<button type=\\\"button\\\" class=\\\"downloadFullZip\\\" style=\\\"float: right; margin-right: 30px; margin-top: 5px;\\\">Download Full Zip<\/button>\");\n            pw.print(\"<button type=\\\"button\\\" class=\\\"downloadFullTxt\\\" style=\\\"float: right; margin-right: 30px; margin-top: 5px;\\\">Download Full Text<\/button>\");\n\n            if ( handler.supports(PrinterMode.ZIP_FILE) ) {\n                pw.print(\"<button type=\\\"button\\\" class=\\\"downloadZip\\\" style=\\\"float: right; margin-right: 30px; margin-top: 5px;\\\">Download As Zip<\/button>\");\n            }\n            if ( handler.supports(PrinterMode.TEXT ) ) {\n                pw.print(\"<button type=\\\"button\\\" class=\\\"downloadTxt\\\" style=\\\"float: right; margin-right: 30px; margin-top: 5px;\\\">Download As Text<\/button>\");\n            }\n\n            pw.println(\"<br/>&nbsp;<\/p>\"); // status line\n            pw.print(\"<div>\");\n            if ( handler.supports(PrinterMode.HTML_BODY) ) {\n                handler.print(PrinterMode.HTML_BODY, pw);\n            } else {\n                pw.enableFilter( true );\n                handler.print(PrinterMode.TEXT, pw);\n                pw.enableFilter( false );\n            }\n            pw.print(\"<\/div>\");\n        }\n    }","id":33994,"modified_method":"@Override\n    protected void doGet(final HttpServletRequest request,\n            final HttpServletResponse response)\n    throws ServletException, IOException {\n        this.setNoCache( response );\n\n        // full request?\n        final StatusPrinterHandler handler;\n        if ( request.getPathInfo().lastIndexOf('/') > 0 ) {\n            handler = null; // all;\n        } else {\n            handler = this.getStatusPrinterHandler();\n            if ( handler == null ) {\n                response.sendError( HttpServletResponse.SC_NOT_FOUND );\n                return;\n            }\n        }\n\n        if ( request.getPathInfo().endsWith( \".txt\" ) ) { //$NON-NLS-2$\n            response.setContentType( \"text/plain; charset=utf-8\" ); //$NON-NLS-2$\n            final ConfigurationWriter pw = new PlainTextConfigurationWriter( response.getWriter() );\n            printConfigurationStatus( pw, PrinterMode.TEXT, handler );\n            pw.flush();\n        } else if ( request.getPathInfo().endsWith( \".zip\" ) ) { //$NON-NLS-2$\n            String type = getServletContext().getMimeType( request.getPathInfo() );\n            if ( type == null ) {\n                type = \"application/x-zip\"; //$NON-NLS-2$\n            }\n            response.setContentType( type );\n\n            final ZipOutputStream zip = new ZipOutputStream( response.getOutputStream() );\n            zip.setLevel( Deflater.BEST_SPEED );\n            zip.setMethod( ZipOutputStream.DEFLATED );\n\n            final Date now = new Date();\n            // create time stamp entry\n            final ZipEntry entry = new ZipEntry( \"timestamp.txt\" ); //$NON-NLS-2$\n            entry.setTime(now.getTime());\n            zip.putNextEntry( entry );\n            final StringBuilder sb = new StringBuilder();\n            sb.append(\"Date: \");\n            synchronized ( StatusPrinterAdapter.DISPLAY_DATE_FORMAT )                             {\n                sb.append(StatusPrinterAdapter.DISPLAY_DATE_FORMAT.format(now));\n            }\n            sb.append(\" (\");\n            sb.append(String.valueOf(now.getTime()));\n            sb.append(\")\\n\");\n\n            zip.write(sb.toString().getBytes(\"UTF-8\"));\n            zip.closeEntry();\n\n            final ZipConfigurationWriter pw = new ZipConfigurationWriter( zip );\n            printConfigurationStatus( pw, PrinterMode.ZIP_FILE_BIN, handler );\n            pw.counter = 0;\n            printConfigurationStatus( pw, PrinterMode.ZIP_FILE_JSON, handler );\n\n            zip.finish();\n        } else if ( request.getPathInfo().endsWith( \".nfo\" ) ) {\n            if ( handler == null ) {\n                response.sendError( HttpServletResponse.SC_NOT_FOUND);\n                return;\n            }\n            response.setContentType( \"text/html; charset=utf-8\" );\n\n            final HtmlConfigurationWriter pw = new HtmlConfigurationWriter( response.getWriter() );\n            pw.println ( \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Strict//EN\\\"\" );\n            pw.println ( \"  \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\\\">\" );\n            pw.println ( \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\">\" );\n            pw.println ( \"<head><title>dummy<\/title><\/head><body><div>\" );\n\n            if ( handler.supports(PrinterMode.HTML_BODY) ) {\n                handler.print(PrinterMode.HTML_BODY, pw);\n            } else {\n                pw.enableFilter( true );\n                handler.print(PrinterMode.TEXT, pw);\n                pw.enableFilter( false );\n            }\n            pw.println( \"<\/div><\/body><\/html>\" );\n            return;\n        } else {\n            if ( handler == null ) {\n                response.sendError( HttpServletResponse.SC_NOT_FOUND);\n                return;\n            }\n            final HtmlConfigurationWriter pw = new HtmlConfigurationWriter(response.getWriter());\n            pw.println(\"<script type=\\\"text/javascript\\\">\");\n            pw.println(\"// <![CDATA[\");\n            pw.println(\"function pad(value) { if ( value < 10 ) { return '0' + value;} return '' + value;}\");\n            pw.println(\"function downloadDump(ext, full) {\");\n            pw.println(\"  if (full) {\");\n            pw.println(\"    var now = new Date();\");\n            pw.println(\"    var name = \\\"configuration-status-\\\" + now.getUTCFullYear() + pad(now.getUTCMonth() + 1) + pad(now.getUTCDate()) + \\\"-\\\" + pad(now.getUTCHours()) + pad(now.getUTCMinutes()) + pad(now.getUTCSeconds()) + \\\".\\\";\");\n            pw.println(\"    location.href = location.href + \\\"/\\\" + name + ext;\");\n            pw.println(\"  } else {\");\n            pw.println(\"    location.href = location.href + '.' + ext;\");\n            pw.println(\"  }\");\n            pw.println(\"}\");\n\n            pw.println(\"$(document).ready(function() {\");\n            pw.println(\"    $('.downloadTxt').click(function() { downloadDump('txt', false)});\");\n            pw.println(\"    $('.downloadZip').click(function() { downloadDump('zip', false)});\");\n            pw.println(\"    $('.downloadFullZip').click(function() { downloadDump('zip', true)});\");\n            pw.println(\"    $('.downloadFullTxt').click(function() { downloadDump('txt', true)});\");\n            pw.println(\"});\");\n            pw.println(\"// ]]>\");\n            pw.println(\"<\/script>\");\n            pw.println( \"<br/><p class=\\\"statline\\\">\");\n\n            final Date currentTime = new Date();\n            synchronized ( StatusPrinterAdapter.DISPLAY_DATE_FORMAT )                             {\n                pw.print(\"Date: \");\n                pw.println(StatusPrinterAdapter.DISPLAY_DATE_FORMAT.format(currentTime));\n            }\n\n            pw.print(\"<button type=\\\"button\\\" class=\\\"downloadFullZip\\\" style=\\\"float: right; margin-right: 30px; margin-top: 5px;\\\">Download Full Zip<\/button>\");\n            pw.print(\"<button type=\\\"button\\\" class=\\\"downloadFullTxt\\\" style=\\\"float: right; margin-right: 30px; margin-top: 5px;\\\">Download Full Text<\/button>\");\n\n            if ( handler.supports(PrinterMode.ZIP_FILE_BIN) || handler.supports(PrinterMode.ZIP_FILE_JSON) ) {\n                pw.print(\"<button type=\\\"button\\\" class=\\\"downloadZip\\\" style=\\\"float: right; margin-right: 30px; margin-top: 5px;\\\">Download As Zip<\/button>\");\n            }\n            if ( handler.supports(PrinterMode.TEXT ) ) {\n                pw.print(\"<button type=\\\"button\\\" class=\\\"downloadTxt\\\" style=\\\"float: right; margin-right: 30px; margin-top: 5px;\\\">Download As Text<\/button>\");\n            }\n\n            pw.println(\"<br/>&nbsp;<\/p>\"); // status line\n            pw.print(\"<div>\");\n            if ( handler.supports(PrinterMode.HTML_BODY) ) {\n                handler.print(PrinterMode.HTML_BODY, pw);\n            } else {\n                pw.enableFilter( true );\n                handler.print(PrinterMode.TEXT, pw);\n                pw.enableFilter( false );\n            }\n            pw.print(\"<\/div>\");\n        }\n    }","commit_id":"e21a0475c9bff763c07abc708ac076bc5c62c8b3","url":"https://github.com/apache/felix"},{"original_method":"@Override\n        public void printStatus(\n                final PrinterMode mode,\n                final StatusPrinterHandler handler)\n        throws IOException {\n            super.printStatus(mode, handler);\n            final String title = getFormattedTitle(handler.getTitle());\n            handler.addAttachments(title.concat(\"/\"), this.zip);\n            if ( handler.supports(PrinterMode.JSON) ) {\n                final String name = \"json/\".concat(title).concat(\".json\");\n\n                final ZipEntry entry = new ZipEntry( name );\n                zip.putNextEntry( entry );\n                handler.print(PrinterMode.JSON, this);\n                flush();\n\n                zip.closeEntry();\n            }\n        }","id":33995,"modified_method":"@Override\n        public void printStatus(\n                final PrinterMode mode,\n                final StatusPrinterHandler handler)\n        throws IOException {\n            final String title = getFormattedTitle(handler.getTitle());\n            if ( mode == PrinterMode.ZIP_FILE_BIN ) {\n                super.printStatus(mode, handler);\n                handler.addAttachments(title.concat(\"/\"), this.zip);\n            } else {\n                counter++;\n                final String name = \"json/\".concat(title).concat(\".json\");\n\n                final ZipEntry entry = new ZipEntry( name );\n                zip.putNextEntry( entry );\n                handler.print(PrinterMode.ZIP_FILE_JSON, this);\n                flush();\n\n                zip.closeEntry();\n                if ( !handler.supports(PrinterMode.ZIP_FILE_BIN) ) {\n                    handler.addAttachments(title.concat(\"/\"), this.zip);\n                }\n            }\n        }","commit_id":"e21a0475c9bff763c07abc708ac076bc5c62c8b3","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Map the modes to status printer modes\n     */\n    public String[] getPrinterModes() {\n        final Set<String> list = new HashSet<String>();\n        if ( this.match(ConsoleConstants.MODE_TXT) || this.match(ConsoleConstants.MODE_ZIP) ) {\n            list.add(PrinterMode.ZIP_FILE.name());\n        }\n        if ( this.match(ConsoleConstants.MODE_WEB) ) {\n            if ( !escapeHtml ) {\n                list.add(PrinterMode.HTML_BODY.name());\n            } else {\n                list.add(PrinterMode.TEXT.name());\n            }\n        }\n        return list.toArray(new String[list.size()]);\n    }","id":33996,"modified_method":"/**\n     * Map the modes to status printer modes\n     */\n    public String[] getPrinterModes() {\n        final Set<String> list = new HashSet<String>();\n        if ( this.match(ConsoleConstants.MODE_TXT) || this.match(ConsoleConstants.MODE_ZIP) ) {\n            list.add(PrinterMode.ZIP_FILE_BIN.name());\n        }\n        if ( this.match(ConsoleConstants.MODE_WEB) ) {\n            if ( !escapeHtml ) {\n                list.add(PrinterMode.HTML_BODY.name());\n            } else {\n                list.add(PrinterMode.TEXT.name());\n            }\n        }\n        return list.toArray(new String[list.size()]);\n    }","commit_id":"e21a0475c9bff763c07abc708ac076bc5c62c8b3","url":"https://github.com/apache/felix"},{"original_method":"public void add(final ServiceReference reference, final Object service) {\n        final ConfigurationPrinterAdapter cpa = ConfigurationPrinterAdapter.createAdapter(service, reference);\n        if ( cpa != null && cpa.title != null ) {\n            if ( cpa.title.startsWith(\"%\") ) {\n                final String key = cpa.title.substring(1);\n                final ResourceBundle rb = this.rbManager.getResourceBundle(reference.getBundle());\n                if ( rb == null || !rb.containsKey(key) ) {\n                    cpa.title = key;\n                } else {\n                    cpa.title = rb.getString(key);\n                }\n            }\n            if ( cpa.label == null ) {\n                cpa.label = cpa.title;\n            }\n            final Dictionary<String, Object> props = new Hashtable<String, Object>();\n            props.put(StatusPrinter.CONFIG_NAME, cpa.label);\n            props.put(StatusPrinter.CONFIG_TITLE, cpa.title);\n            props.put(StatusPrinter.CONFIG_PRINTER_MODES, cpa.getPrinterModes());\n\n            if ( reference.getProperty(ConsoleConstants.PLUGIN_CATEGORY) != null ) {\n                props.put(StatusPrinter.CONFIG_CATEGORY, reference.getProperty(ConsoleConstants.PLUGIN_CATEGORY));\n            }\n            final ServiceRegistration reg = this.bundleContext.registerService(StatusPrinter.class.getName(), new ZipAttachmentProvider() {\n\n                /**\n                 * @see org.apache.felix.status.StatusPrinter#print(org.apache.felix.status.PrinterMode, java.io.PrintWriter)\n                 */\n                public void print(final PrinterMode mode, final PrintWriter printWriter) {\n                    final String m;\n                    if ( mode == PrinterMode.HTML_BODY ) {\n                        m = ConsoleConstants.MODE_WEB;\n                    } else if ( mode == PrinterMode.TEXT ) {\n                        m = ConsoleConstants.MODE_TXT;\n                    } else if ( mode == PrinterMode.ZIP_FILE ) {\n                        m = ConsoleConstants.MODE_ZIP;\n                    } else {\n                        m = null;\n                    }\n                    if ( m != null ) {\n                        cpa.printConfiguration(printWriter, m);\n                    }\n                }\n\n                /**\n                 * @see org.apache.felix.status.ZipAttachmentProvider#addAttachments(java.lang.String, java.util.zip.ZipOutputStream)\n                 */\n                public void addAttachments(final String namePrefix, final ZipOutputStream zos)\n                throws IOException {\n                    final URL[] attachments = cpa.getAttachments();\n                    if ( attachments != null ) {\n                        for(final URL current : attachments) {\n                            final String path = current.getPath();\n                            final String name;\n                            if ( path == null || path.length() == 0 ) {\n                                // sanity code, we should have a path, but if not let's\n                                // just create some random name\n                                name = \"file\" + Double.doubleToLongBits( Math.random() );\n                            } else {\n                                final int pos = path.lastIndexOf('/');\n                                name = (pos == -1 ? path : path.substring(pos + 1));\n                            }\n                            final ZipEntry entry = new ZipEntry(namePrefix + name);\n                            zos.putNextEntry(entry);\n                            final InputStream is = current.openStream();\n                            try {\n                                byte[] buffer = new byte[4096];\n                                int n = 0;\n                                while (-1 != (n = is.read(buffer))) {\n                                    zos.write(buffer, 0, n);\n                                }\n                            } finally {\n                                if ( is != null ) {\n                                    try { is.close(); } catch (final IOException ignore) {}\n                                }\n                            }\n                            zos.closeEntry();\n                        }\n                    }\n                }\n\n            }, props);\n            synchronized ( this.registrations ) {\n                this.registrations.put(reference, reg);\n            }\n        }\n    }","id":33997,"modified_method":"public void add(final ServiceReference reference, final Object service) {\n        final ConfigurationPrinterAdapter cpa = ConfigurationPrinterAdapter.createAdapter(service, reference);\n        if ( cpa != null && cpa.title != null ) {\n            if ( cpa.title.startsWith(\"%\") ) {\n                final String key = cpa.title.substring(1);\n                final ResourceBundle rb = this.rbManager.getResourceBundle(reference.getBundle());\n                if ( rb == null || !rb.containsKey(key) ) {\n                    cpa.title = key;\n                } else {\n                    cpa.title = rb.getString(key);\n                }\n            }\n            if ( cpa.label == null ) {\n                cpa.label = cpa.title;\n            }\n            final Dictionary<String, Object> props = new Hashtable<String, Object>();\n            props.put(StatusPrinter.CONFIG_NAME, cpa.label);\n            props.put(StatusPrinter.CONFIG_TITLE, cpa.title);\n            props.put(StatusPrinter.CONFIG_PRINTER_MODES, cpa.getPrinterModes());\n\n            if ( reference.getProperty(ConsoleConstants.PLUGIN_CATEGORY) != null ) {\n                props.put(StatusPrinter.CONFIG_CATEGORY, reference.getProperty(ConsoleConstants.PLUGIN_CATEGORY));\n            }\n            final ServiceRegistration reg = this.bundleContext.registerService(StatusPrinter.class.getName(), new ZipAttachmentProvider() {\n\n                /**\n                 * @see org.apache.felix.status.StatusPrinter#print(org.apache.felix.status.PrinterMode, java.io.PrintWriter)\n                 */\n                public void print(final PrinterMode mode, final PrintWriter printWriter) {\n                    final String m;\n                    if ( mode == PrinterMode.HTML_BODY ) {\n                        m = ConsoleConstants.MODE_WEB;\n                    } else if ( mode == PrinterMode.TEXT ) {\n                        m = ConsoleConstants.MODE_TXT;\n                    } else if ( mode == PrinterMode.ZIP_FILE_BIN ) {\n                        m = ConsoleConstants.MODE_ZIP;\n                    } else {\n                        m = null;\n                    }\n                    if ( m != null ) {\n                        cpa.printConfiguration(printWriter, m);\n                    }\n                }\n\n                /**\n                 * @see org.apache.felix.status.ZipAttachmentProvider#addAttachments(java.lang.String, java.util.zip.ZipOutputStream)\n                 */\n                public void addAttachments(final String namePrefix, final ZipOutputStream zos)\n                throws IOException {\n                    final URL[] attachments = cpa.getAttachments();\n                    if ( attachments != null ) {\n                        for(final URL current : attachments) {\n                            final String path = current.getPath();\n                            final String name;\n                            if ( path == null || path.length() == 0 ) {\n                                // sanity code, we should have a path, but if not let's\n                                // just create some random name\n                                name = \"file\" + Double.doubleToLongBits( Math.random() );\n                            } else {\n                                final int pos = path.lastIndexOf('/');\n                                name = (pos == -1 ? path : path.substring(pos + 1));\n                            }\n                            final ZipEntry entry = new ZipEntry(namePrefix + name);\n                            zos.putNextEntry(entry);\n                            final InputStream is = current.openStream();\n                            try {\n                                byte[] buffer = new byte[4096];\n                                int n = 0;\n                                while (-1 != (n = is.read(buffer))) {\n                                    zos.write(buffer, 0, n);\n                                }\n                            } finally {\n                                if ( is != null ) {\n                                    try { is.close(); } catch (final IOException ignore) {}\n                                }\n                            }\n                            zos.closeEntry();\n                        }\n                    }\n                }\n\n            }, props);\n            synchronized ( this.registrations ) {\n                this.registrations.put(reference, reg);\n            }\n        }\n    }","commit_id":"e21a0475c9bff763c07abc708ac076bc5c62c8b3","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Checks with this ConstraintedProperty instance supports applying the specified constraint.\n     *\n     * @param constraintName The name of the constraint\n     * @return True if the constraint is supported\n     */\n    public boolean supportsContraint(String constraintName) {\n\n        if (!constraints.containsKey(constraintName)) {\n            return bean.isWritableProperty(constraintName);\n        }\n\n        try {\n            Constraint c = instantiateConstraint(constraintName);\n            return c.supports(propertyType);\n        }\n        catch (Exception e) {\n            LOG.error(\"Exception thrown instantiating constraint [\" + constraintName +\n                    \"] to class [\" + owningClass + \"]\", e);\n            throw new ConstraintException(\"Exception thrown instantiating  constraint [\" + constraintName +\n                    \"] to class [\" + owningClass + \"]\");\n        }\n    }","id":33998,"modified_method":"/**\n     * Checks with this ConstraintedProperty instance supports applying the specified constraint.\n     *\n     * @param constraintName The name of the constraint\n     * @return True if the constraint is supported\n     */\n    public boolean supportsContraint(String constraintName) {\n\n        if (!constraints.containsKey(constraintName)) {\n            return bean.isWritableProperty(constraintName);\n        }\n\n        try {\n            Constraint c = instantiateConstraint(constraintName, false);\n            return c != null && c.supports(propertyType);\n        }\n        catch (Exception e) {\n            LOG.error(\"Exception thrown instantiating constraint [\" + constraintName +\n                    \"] to class [\" + owningClass + \"]\", e);\n            throw new ConstraintException(\"Exception thrown instantiating  constraint [\" + constraintName +\n                    \"] to class [\" + owningClass + \"]\");\n        }\n    }","commit_id":"4bfe85d7977ec12f088f73515b3910c0359306f3","url":"https://github.com/grails/grails-core"},{"original_method":"public static void registerNewConstraint(String name, Class<?> constraintClass) {\n        Assert.hasLength(name, \"Argument [name] cannot be null\");\n        if (constraintClass == null || !Constraint.class.isAssignableFrom(constraintClass)) {\n            throw new IllegalArgumentException(\"Argument [constraintClass] with value [\" + constraintClass +\n                    \"] is not a valid constraint\");\n        }\n\n        constraints.put(name, constraintClass);\n    }","id":33999,"modified_method":"public static void registerNewConstraint(String name, Class<?> constraintClass) {\n        Assert.hasLength(name, \"Argument [name] cannot be null\");\n        if (constraintClass == null || !Constraint.class.isAssignableFrom(constraintClass)) {\n            throw new IllegalArgumentException(\"Argument [constraintClass] with value [\" + constraintClass +\n                    \"] is not a valid constraint\");\n        }\n\n        List<Object> objects = getOrInitializeConstraint(name);\n        objects.add(constraintClass);\n    }","commit_id":"4bfe85d7977ec12f088f73515b3910c0359306f3","url":"https://github.com/grails/grails-core"}]