[{"original_method":"private void loadClasses(final ComponentConfig config) {\n      ClassLoader loader = config.getClassLoader();\n\n      try {\n        final Class<?> interfaceClass = Class.forName(config.interfaceClass, true, loader);\n        final Class<?> implementationClass = Class.forName(config.implementationClass, true, loader);\n\n        if (myInterfaceToClassMap.get(interfaceClass) != null) {\n          throw new Error(\"ComponentSetup for component \" + interfaceClass.getName() + \" already registered\");\n        }\n\n        getPicoContainer().registerComponent(new ComponentConfigComponentAdapter(config));\n        myInterfaceToClassMap.put(interfaceClass, implementationClass);\n        myComponentClassToConfig.put(implementationClass, config);\n        myComponentInterfaces.add(interfaceClass);\n      }\n      catch (Exception e) {\n        @NonNls final String message = \"Error while registering component: \" + config;\n\n        if (config.pluginDescriptor != null) {\n          LOG.error(message, new PluginException(e, config.pluginDescriptor.getPluginId()));\n        }\n        else {\n          LOG.error(message, e);\n        }\n      }\n      catch (Error e) {\n        if (config.pluginDescriptor != null) {\n          LOG.error(new PluginException(e, config.pluginDescriptor.getPluginId()));\n        }\n        else {\n          throw e;\n        }\n      }\n    }","id":60000,"modified_method":"private void loadClasses(final ComponentConfig config) {\n      ClassLoader loader = config.getClassLoader();\n\n      try {\n        final Class<?> interfaceClass = Class.forName(config.getInterfaceClass(), true, loader);\n        final Class<?> implementationClass = Class.forName(config.getImplementationClass(), true, loader);\n\n        if (myInterfaceToClassMap.get(interfaceClass) != null) {\n          throw new Error(\"ComponentSetup for component \" + interfaceClass.getName() + \" already registered\");\n        }\n\n        getPicoContainer().registerComponent(new ComponentConfigComponentAdapter(config));\n        myInterfaceToClassMap.put(interfaceClass, implementationClass);\n        myComponentClassToConfig.put(implementationClass, config);\n        myComponentInterfaces.add(interfaceClass);\n      }\n      catch (Exception e) {\n        @NonNls final String message = \"Error while registering component: \" + config;\n\n        if (config.pluginDescriptor != null) {\n          LOG.error(message, new PluginException(e, config.pluginDescriptor.getPluginId()));\n        }\n        else {\n          LOG.error(message, e);\n        }\n      }\n      catch (Error e) {\n        if (config.pluginDescriptor != null) {\n          LOG.error(new PluginException(e, config.pluginDescriptor.getPluginId()));\n        }\n        else {\n          throw e;\n        }\n      }\n    }","commit_id":"974d8097c9ef04eb65bbb46b6f41b6f517470239","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private ComponentAdapter getDelegate() {\n      if (myDelegate == null) {\n        final Object componentKey = getComponentKey();\n\n        ClassLoader loader = myConfig.getClassLoader();\n\n        Class<?> implementationClass = null;\n\n        try {\n          implementationClass = Class.forName(myConfig.implementationClass, true, loader);\n        }\n        catch (Exception e) {\n          @NonNls final String message = \"Error while registering component: \" + myConfig;\n\n          if (myConfig.pluginDescriptor != null) {\n            LOG.error(message, new PluginException(e, myConfig.pluginDescriptor.getPluginId()));\n          }\n          else {\n            LOG.error(message, e);\n          }\n        }\n        catch (Error e) {\n          if (myConfig.pluginDescriptor != null) {\n            LOG.error(new PluginException(e, myConfig.pluginDescriptor.getPluginId()));\n          }\n          else {\n            throw e;\n          }\n        }\n\n        assert implementationClass != null;\n\n        myDelegate = new CachingComponentAdapter(new ConstructorInjectionComponentAdapter(componentKey, implementationClass, null, true)) {\n            public Object getComponentInstance(PicoContainer picoContainer) throws PicoInitializationException, PicoIntrospectionException {\n              Object componentInstance = null;\n              try {\n                long startTime = myInitialized ? 0 : System.nanoTime();\n                componentInstance = super.getComponentInstance(picoContainer);\n\n                if (!myInitialized) {\n                  if (myInitializing) {\n                    if (myConfig.pluginDescriptor != null) {\n                      LOG.error(new PluginException(\"Cyclic component initialization: \" + componentKey, myConfig.pluginDescriptor.getPluginId()));\n                    }\n                    else {\n                      LOG.error(new Throwable(\"Cyclic component initialization: \" + componentKey));\n                    }\n                  }\n                  myInitializing = true;\n                  myComponentsRegistry.registerComponentInstance(componentInstance);\n                  initComponent(componentInstance);\n                  long endTime = System.nanoTime();\n                  long ms = (endTime - startTime) / 1000000;\n                  if (ms > 10) {\n                    if (logSlowComponents()) {\n                      LOG.info(componentInstance.getClass().getName() + \" initialized in \" + ms + \" ms\");\n                    }\n                  }\n                  myInitializing = false;\n                  myInitialized = true;\n                }\n              }\n              catch (ProcessCanceledException e) {\n                throw e;\n              }\n              catch (StateStorageException e) {\n                throw e;\n              }\n              catch (Throwable t) {\n                handleInitComponentError(t, componentInstance == null, componentKey.toString());\n              }\n              return componentInstance;\n            }\n          };\n      }\n\n      return myDelegate;\n    }","id":60001,"modified_method":"private ComponentAdapter getDelegate() {\n      if (myDelegate == null) {\n        final Object componentKey = getComponentKey();\n\n        ClassLoader loader = myConfig.getClassLoader();\n\n        Class<?> implementationClass = null;\n\n        try {\n          implementationClass = Class.forName(myConfig.getImplementationClass(), true, loader);\n        }\n        catch (Exception e) {\n          @NonNls final String message = \"Error while registering component: \" + myConfig;\n\n          if (myConfig.pluginDescriptor != null) {\n            LOG.error(message, new PluginException(e, myConfig.pluginDescriptor.getPluginId()));\n          }\n          else {\n            LOG.error(message, e);\n          }\n        }\n        catch (Error e) {\n          if (myConfig.pluginDescriptor != null) {\n            LOG.error(new PluginException(e, myConfig.pluginDescriptor.getPluginId()));\n          }\n          else {\n            throw e;\n          }\n        }\n\n        assert implementationClass != null;\n\n        myDelegate = new CachingComponentAdapter(new ConstructorInjectionComponentAdapter(componentKey, implementationClass, null, true)) {\n            public Object getComponentInstance(PicoContainer picoContainer) throws PicoInitializationException, PicoIntrospectionException {\n              Object componentInstance = null;\n              try {\n                long startTime = myInitialized ? 0 : System.nanoTime();\n                componentInstance = super.getComponentInstance(picoContainer);\n\n                if (!myInitialized) {\n                  if (myInitializing) {\n                    if (myConfig.pluginDescriptor != null) {\n                      LOG.error(new PluginException(\"Cyclic component initialization: \" + componentKey, myConfig.pluginDescriptor.getPluginId()));\n                    }\n                    else {\n                      LOG.error(new Throwable(\"Cyclic component initialization: \" + componentKey));\n                    }\n                  }\n                  myInitializing = true;\n                  myComponentsRegistry.registerComponentInstance(componentInstance);\n                  initComponent(componentInstance);\n                  long endTime = System.nanoTime();\n                  long ms = (endTime - startTime) / 1000000;\n                  if (ms > 10) {\n                    if (logSlowComponents()) {\n                      LOG.info(componentInstance.getClass().getName() + \" initialized in \" + ms + \" ms\");\n                    }\n                  }\n                  myInitializing = false;\n                  myInitialized = true;\n                }\n              }\n              catch (ProcessCanceledException e) {\n                throw e;\n              }\n              catch (StateStorageException e) {\n                throw e;\n              }\n              catch (Throwable t) {\n                handleInitComponentError(t, componentInstance == null, componentKey.toString());\n              }\n              return componentInstance;\n            }\n          };\n      }\n\n      return myDelegate;\n    }","commit_id":"974d8097c9ef04eb65bbb46b6f41b6f517470239","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public Object getComponent(final ComponentConfig componentConfig) {\n    return getPicoContainer().getComponentInstance(componentConfig.interfaceClass);\n  }","id":60002,"modified_method":"@Nullable\n  public Object getComponent(final ComponentConfig componentConfig) {\n    return getPicoContainer().getComponentInstance(componentConfig.getInterfaceClass());\n  }","commit_id":"974d8097c9ef04eb65bbb46b6f41b6f517470239","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object getComponentKey() {\n      return myConfig.interfaceClass;\n    }","id":60003,"modified_method":"public Object getComponentKey() {\n      return myConfig.getInterfaceClass();\n    }","commit_id":"974d8097c9ef04eb65bbb46b6f41b6f517470239","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings({\"NonPrivateFieldAccessedInSynchronizedContext\"})\n  public synchronized void registerComponent(final ComponentConfig config, final PluginDescriptor pluginDescriptor) {\n    if (isHeadless()) {\n      String headlessImplClass = config.headlessImplementationClass;\n      if (headlessImplClass != null) {\n        if (headlessImplClass.trim().length() == 0) {\n          return;\n        }\n        config.implementationClass = headlessImplClass;\n      }\n    }\n\n    config.implementationClass = config.implementationClass.trim();\n\n    if (config.interfaceClass == null) config.interfaceClass = config.implementationClass;\n    config.interfaceClass = config.interfaceClass.trim();\n\n    config.pluginDescriptor =  pluginDescriptor;\n    myComponentsRegistry.registerComponent(config);\n  }","id":60004,"modified_method":"@SuppressWarnings({\"NonPrivateFieldAccessedInSynchronizedContext\"})\n  public synchronized void registerComponent(final ComponentConfig config, final PluginDescriptor pluginDescriptor) {\n    if (!config.prepareClasses(isHeadless())) return;\n\n    config.pluginDescriptor =  pluginDescriptor;\n    myComponentsRegistry.registerComponent(config);\n  }","commit_id":"974d8097c9ef04eb65bbb46b6f41b6f517470239","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * <strike>Also makes sure '\\\\' in the file name for Unix is handled correctly<\/strike>.\n     *\n     * To prevent directory traversal attack, we now treat '\\\\' just like '/'.\n     */\n    @Email(\"http://www.nabble.com/Status-Code-400-viewing-or-downloading-artifact-whose-filename-contains-two-consecutive-periods-tt21407604.html\")\n    @Test\n    public void doubleDots2() throws Exception {\n        if(Functions.isWindows())  return; // can't test this on Windows\n\n        // create a problematic file name in the workspace\n        FreeStyleProject p = j.createFreeStyleProject();\n        p.getBuildersList().add(new Shell(\"mkdir abc; touch abc/def.bin\"));\n        p.scheduleBuild2(0).get();\n\n        // can we see it?\n        j.createWebClient().goTo(\"job/\"+p.getName()+\"/ws/abc%5Cdef.bin\",\"application/octet-stream\");\n    }","id":60005,"modified_method":"/**\n     * <strike>Also makes sure '\\\\' in the file name for Unix is handled correctly<\/strike>.\n     *\n     * To prevent directory traversal attack, we now treat '\\\\' just like '/'.\n     */\n    @Email(\"http://www.nabble.com/Status-Code-400-viewing-or-downloading-artifact-whose-filename-contains-two-consecutive-periods-tt21407604.html\")\n    @Test\n    public void doubleDots2() throws Exception {\n        Assume.assumeFalse(\"can't test this on Windows\", Functions.isWindows());\n\n        // create a problematic file name in the workspace\n        FreeStyleProject p = j.createFreeStyleProject();\n        p.getBuildersList().add(new Shell(\"mkdir abc; touch abc/def.bin\"));\n        p.scheduleBuild2(0).get();\n\n        // can we see it?\n        j.createWebClient().goTo(\"job/\"+p.getName()+\"/ws/abc%5Cdef.bin\",\"application/octet-stream\");\n    }","commit_id":"39903842575d3eadbec8c8153f79caa76c3f2c6e","url":"https://github.com/kohsuke/hudson"},{"original_method":"public void testFreeStyleAntOnSlave() throws Exception {\n        if (jenkins.getDescriptorByType(Ant.DescriptorImpl.class).getInstallations().length == 0) {\n            System.out.println(\"Cannot do testFreeStyleAntOnSlave without ANT_HOME\");\n            return;\n        }\n\t\tFreeStyleProject project = createFreeStyleProject();\n\t\tproject.setJDK(jenkins.getJDK(\"varJDK\"));\n\t\tproject.setScm(new ExtractResourceSCM(getClass().getResource(\n\t\t\t\t\"/simple-projects.zip\")));\n\n\t\tString buildFile = \"build.xml${\" + DUMMY_LOCATION_VARNAME + \"}\";\n\t\t// we need additional escapes because bash itself expanding\n\t\tproject.getBuildersList().add(\n\t\t\t\tnew Ant(\"-Dtest.property=cor${\" + DUMMY_LOCATION_VARNAME\n\t\t\t\t\t\t+ \"}rect\", \"varAnt\", \"\", buildFile, \"\"));\n\n\t\t// test the regular slave - variable not expanded\n\t\tproject.setAssignedLabel(slaveRegular.getSelfLabel());\n\t\tFreeStyleBuild build = project.scheduleBuild2(0).get();\n\t\tSystem.out.println(build.getDisplayName() + \" completed\");\n\n\t\tassertBuildStatus(Result.FAILURE, build);\n\n\t\tString buildLogRegular = getBuildLog(build);\n\t\tassertTrue(buildLogRegular.contains(Ant_ExecutableNotFound(\"varAnt\")));\n\n\t\t// test the slave with prepared environment\n\t\tproject.setAssignedLabel(slaveEnv.getSelfLabel());\n\t\tbuild = project.scheduleBuild2(0).get();\n\t\tSystem.out.println(build.getDisplayName() + \" completed\");\n\n\t\tassertBuildStatusSuccess(build);\n\n\t\t// Check variable was expanded\n\t\tString buildLogEnv = getBuildLog(build);\n\t\tSystem.out.println(buildLogEnv);\n\t\tassertTrue(buildLogEnv.contains(\"Ant home: \"));\n\t\tassertTrue(buildLogEnv.contains(\"Test property: correct\"));\n\t\tassertFalse(buildLogEnv.matches(\"(?s)^.*Ant home: [^\\\\n\\\\r]*\"\n\t\t\t\t+ DUMMY_LOCATION_VARNAME + \".*$\"));\n\t\tassertFalse(buildLogEnv.matches(\"(?s)^.*Test property: [^\\\\n\\\\r]*\"\n\t\t\t\t+ DUMMY_LOCATION_VARNAME + \".*$\"));\n\t}","id":60006,"modified_method":"public void testFreeStyleAntOnSlave() throws Exception {\n\t\tAssume.assumeFalse(\n\t\t\t\t\"Cannot do testFreeStyleAntOnSlave without ANT_HOME\",\n\t\t\t\tjenkins.getDescriptorByType(Ant.DescriptorImpl.class).getInstallations().length == 0\n\t\t);\n\n\t\tFreeStyleProject project = createFreeStyleProject();\n\t\tproject.setJDK(jenkins.getJDK(\"varJDK\"));\n\t\tproject.setScm(new ExtractResourceSCM(getClass().getResource(\n\t\t\t\t\"/simple-projects.zip\")));\n\n\t\tString buildFile = \"build.xml${\" + DUMMY_LOCATION_VARNAME + \"}\";\n\t\t// we need additional escapes because bash itself expanding\n\t\tproject.getBuildersList().add(\n\t\t\t\tnew Ant(\"-Dtest.property=cor${\" + DUMMY_LOCATION_VARNAME\n\t\t\t\t\t\t+ \"}rect\", \"varAnt\", \"\", buildFile, \"\"));\n\n\t\t// test the regular slave - variable not expanded\n\t\tproject.setAssignedLabel(slaveRegular.getSelfLabel());\n\t\tFreeStyleBuild build = project.scheduleBuild2(0).get();\n\t\tSystem.out.println(build.getDisplayName() + \" completed\");\n\n\t\tassertBuildStatus(Result.FAILURE, build);\n\n\t\tString buildLogRegular = getBuildLog(build);\n\t\tassertTrue(buildLogRegular.contains(Ant_ExecutableNotFound(\"varAnt\")));\n\n\t\t// test the slave with prepared environment\n\t\tproject.setAssignedLabel(slaveEnv.getSelfLabel());\n\t\tbuild = project.scheduleBuild2(0).get();\n\t\tSystem.out.println(build.getDisplayName() + \" completed\");\n\n\t\tassertBuildStatusSuccess(build);\n\n\t\t// Check variable was expanded\n\t\tString buildLogEnv = getBuildLog(build);\n\t\tSystem.out.println(buildLogEnv);\n\t\tassertTrue(buildLogEnv.contains(\"Ant home: \"));\n\t\tassertTrue(buildLogEnv.contains(\"Test property: correct\"));\n\t\tassertFalse(buildLogEnv.matches(\"(?s)^.*Ant home: [^\\\\n\\\\r]*\"\n\t\t\t\t+ DUMMY_LOCATION_VARNAME + \".*$\"));\n\t\tassertFalse(buildLogEnv.matches(\"(?s)^.*Test property: [^\\\\n\\\\r]*\"\n\t\t\t\t+ DUMMY_LOCATION_VARNAME + \".*$\"));\n\t}","commit_id":"39903842575d3eadbec8c8153f79caa76c3f2c6e","url":"https://github.com/kohsuke/hudson"},{"original_method":"@Test public void symlinkInTar() throws Exception {\n        if (Functions.isWindows())  return; // can't test on Windows\n\n        FilePath tmp = new FilePath(temp.getRoot());\n            FilePath in = tmp.child(\"in\");\n            in.mkdirs();\n            in.child(\"c\").touch(0);\n            in.child(\"b\").symlinkTo(\"c\", TaskListener.NULL);\n                        \n            FilePath tar = tmp.child(\"test.tar\");\n            in.tar(tar.write(), \"**/*\");\n\n            FilePath dst = in.child(\"dst\");\n            tar.untar(dst, TarCompression.NONE);\n\n            assertEquals(\"c\",dst.child(\"b\").readLink());\n    }","id":60007,"modified_method":"@Test public void symlinkInTar() throws Exception {\n        assumeFalse(\"can't test on Windows\", Functions.isWindows());\n\n        FilePath tmp = new FilePath(temp.getRoot());\n            FilePath in = tmp.child(\"in\");\n            in.mkdirs();\n            in.child(\"c\").touch(0);\n            in.child(\"b\").symlinkTo(\"c\", TaskListener.NULL);\n                        \n            FilePath tar = tmp.child(\"test.tar\");\n            in.tar(tar.write(), \"**/*\");\n\n            FilePath dst = in.child(\"dst\");\n            tar.untar(dst, TarCompression.NONE);\n\n            assertEquals(\"c\",dst.child(\"b\").readLink());\n    }","commit_id":"39903842575d3eadbec8c8153f79caa76c3f2c6e","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Can we locate the bundles?\n     */\n    @Test\n    public void locate() throws Exception {\n        // this is a really time consuming test, so only run it when we really want.\n        if(!Boolean.getBoolean(\"jenkins.testJDKInstaller\"))\n            return;\n\n        retrieveUpdateCenterData();\n\n        JDKInstaller i = new JDKInstaller(\"jdk-7u3-oth-JPR\", true);\n        StreamTaskListener listener = StreamTaskListener.fromStdout();\n        i.locate(listener, Platform.LINUX, CPU.i386);\n        i.locate(listener, Platform.WINDOWS, CPU.amd64);\n        i.locate(listener, Platform.SOLARIS, CPU.Sparc);\n    }","id":60008,"modified_method":"/**\n     * Can we locate the bundles?\n     */\n    @Test\n    public void locate() throws Exception {\n        Assume.assumeTrue(\"this is a really time consuming test, so only run it when we really want\", Boolean.getBoolean(\"jenkins.testJDKInstaller\"));\n\n        retrieveUpdateCenterData();\n\n        JDKInstaller i = new JDKInstaller(\"jdk-7u3-oth-JPR\", true);\n        StreamTaskListener listener = StreamTaskListener.fromStdout();\n        i.locate(listener, Platform.LINUX, CPU.i386);\n        i.locate(listener, Platform.WINDOWS, CPU.amd64);\n        i.locate(listener, Platform.SOLARIS, CPU.Sparc);\n    }","commit_id":"39903842575d3eadbec8c8153f79caa76c3f2c6e","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * End-to-end installation test.\n     */\n    private void doTestAutoInstallation(String id, String fullversion) throws Exception {\n        // this is a really time consuming test, so only run it when we really want\n        if(!Boolean.getBoolean(\"jenkins.testJDKInstaller\"))\n            return;\n\n        retrieveUpdateCenterData();\n\n        JDKInstaller installer = new JDKInstaller(id, true);\n\n        JDK jdk = new JDK(\"test\", tmp.getRoot().getAbsolutePath(), Arrays.asList(\n                new InstallSourceProperty(Arrays.<ToolInstaller>asList(installer))));\n\n        j.jenkins.getJDKs().add(jdk);\n\n        FreeStyleProject p = j.createFreeStyleProject();\n        p.setJDK(jdk);\n        p.getBuildersList().add(new Shell(\"java -fullversion\\necho $JAVA_HOME\"));\n        FreeStyleBuild b = j.buildAndAssertSuccess(p);\n        @SuppressWarnings(\"deprecation\") String log = b.getLog();\n        System.out.println(log);\n        // make sure it runs with the JDK that just got installed\n        assertTrue(log.contains(fullversion));\n        assertTrue(log.contains(tmp.getRoot().getAbsolutePath()));\n    }","id":60009,"modified_method":"/**\n     * End-to-end installation test.\n     */\n    private void doTestAutoInstallation(String id, String fullversion) throws Exception {\n        Assume.assumeTrue(\"this is a really time consuming test, so only run it when we really want\", Boolean.getBoolean(\"jenkins.testJDKInstaller\"));\n\n        retrieveUpdateCenterData();\n\n        JDKInstaller installer = new JDKInstaller(id, true);\n\n        JDK jdk = new JDK(\"test\", tmp.getRoot().getAbsolutePath(), Arrays.asList(\n                new InstallSourceProperty(Arrays.<ToolInstaller>asList(installer))));\n\n        j.jenkins.getJDKs().add(jdk);\n\n        FreeStyleProject p = j.createFreeStyleProject();\n        p.setJDK(jdk);\n        p.getBuildersList().add(new Shell(\"java -fullversion\\necho $JAVA_HOME\"));\n        FreeStyleBuild b = j.buildAndAssertSuccess(p);\n        @SuppressWarnings(\"deprecation\") String log = b.getLog();\n        System.out.println(log);\n        // make sure it runs with the JDK that just got installed\n        assertTrue(log.contains(fullversion));\n        assertTrue(log.contains(tmp.getRoot().getAbsolutePath()));\n    }","commit_id":"39903842575d3eadbec8c8153f79caa76c3f2c6e","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Fake installation on Unix.\n     */\n    @Test\n    public void fakeUnixInstall() throws Exception {\n        // If we're on Windows, don't bother doing this.\n        if (Functions.isWindows())\n            return;\n\n        File bundle = File.createTempFile(\"fake-jdk-by-hudson\",\"sh\");\n        try {\n            new FilePath(bundle).write(\n                    \"#!/bin/bash -ex\\n\" +\n                    \"mkdir -p jdk1.6.0_dummy/bin\\n\" +\n                    \"touch jdk1.6.0_dummy/bin/java\",\"ASCII\");\n            TaskListener l = StreamTaskListener.fromStdout();\n\n            new JDKInstaller(\"\",true).install(new LocalLauncher(l),Platform.LINUX,\n                    new JDKInstaller.FilePathFileSystem(j.jenkins),l,tmp.getRoot().getPath(),bundle.getPath());\n\n            assertTrue(new File(tmp.getRoot(),\"bin/java\").exists());\n        } finally {\n            bundle.delete();\n        }\n    }","id":60010,"modified_method":"/**\n     * Fake installation on Unix.\n     */\n    @Test\n    public void fakeUnixInstall() throws Exception {\n        Assume.assumeFalse(\"If we're on Windows, don't bother doing this\", Functions.isWindows());\n\n        File bundle = File.createTempFile(\"fake-jdk-by-hudson\",\"sh\");\n        try {\n            new FilePath(bundle).write(\n                    \"#!/bin/bash -ex\\n\" +\n                    \"mkdir -p jdk1.6.0_dummy/bin\\n\" +\n                    \"touch jdk1.6.0_dummy/bin/java\",\"ASCII\");\n            TaskListener l = StreamTaskListener.fromStdout();\n\n            new JDKInstaller(\"\",true).install(new LocalLauncher(l),Platform.LINUX,\n                    new JDKInstaller.FilePathFileSystem(j.jenkins),l,tmp.getRoot().getPath(),bundle.getPath());\n\n            assertTrue(new File(tmp.getRoot(),\"bin/java\").exists());\n        } finally {\n            bundle.delete();\n        }\n    }","commit_id":"39903842575d3eadbec8c8153f79caa76c3f2c6e","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Starts a JNLP slave agent and makes sure it successfully connects to Hudson. \n     */\n    public void testLaunch() throws Exception {\n        if(GraphicsEnvironment.isHeadless()) {\n            System.err.println(\"Skipping JNLPLauncherTest.testLaunch because we are running headless\");\n            return;\n        }\n\n        System.err.println(\"Not in headless mode, continuing with JNLPLauncherTest.testLaunch...\");\n        Computer c = addTestSlave();\n        launchJnlpAndVerify(c, buildJnlpArgs(c));\n    }","id":60011,"modified_method":"/**\n     * Starts a JNLP slave agent and makes sure it successfully connects to Hudson. \n     */\n    public void testLaunch() throws Exception {\n        Assume.assumeFalse(\"Skipping JNLPLauncherTest.testLaunch because we are running headless\", GraphicsEnvironment.isHeadless());\n\n        Computer c = addTestSlave();\n        launchJnlpAndVerify(c, buildJnlpArgs(c));\n    }","commit_id":"39903842575d3eadbec8c8153f79caa76c3f2c6e","url":"https://github.com/kohsuke/hudson"},{"original_method":"@Issue(\"JENKINS-4611\")\n    @Test public void remoteKill() throws Exception {\n        if (File.pathSeparatorChar != ':') {\n            System.err.println(\"Skipping, currently Unix-specific test\");\n            return;\n        }\n\n        File tmp = temp.newFile();\n\n            FilePath f = new FilePath(channels.french, tmp.getPath());\n            Launcher l = f.createLauncher(StreamTaskListener.fromStderr());\n            Proc p = l.launch().cmds(\"sh\", \"-c\", \"echo $$$$ > \"+tmp+\"; sleep 30\").stdout(System.out).stderr(System.err).start();\n            while (!tmp.exists())\n                Thread.sleep(100);\n            long start = System.currentTimeMillis();\n            p.kill();\n            assertTrue(p.join()!=0);\n            long end = System.currentTimeMillis();\n            assertTrue(\"join finished promptly\", (end - start < 15000));\n            channels.french.call(NOOP); // this only returns after the other side of the channel has finished executing cancellation\n            Thread.sleep(2000); // more delay to make sure it's gone\n            assertNull(\"process should be gone\",ProcessTree.get().get(Integer.parseInt(FileUtils.readFileToString(tmp).trim())));\n\n            // Manual version of test: set up instance w/ one slave. Now in script console\n            // new hudson.FilePath(new java.io.File(\"/tmp\")).createLauncher(new hudson.util.StreamTaskListener(System.err)).\n            //   launch().cmds(\"sleep\", \"1d\").stdout(System.out).stderr(System.err).start().kill()\n            // returns immediately and pgrep sleep => nothing. But without fix\n            // hudson.model.Hudson.instance.nodes[0].rootPath.createLauncher(new hudson.util.StreamTaskListener(System.err)).\n            //   launch().cmds(\"sleep\", \"1d\").stdout(System.out).stderr(System.err).start().kill()\n            // hangs and on slave machine pgrep sleep => one process; after manual kill, script returns.\n    }","id":60012,"modified_method":"@Issue(\"JENKINS-4611\")\n    @Test public void remoteKill() throws Exception {\n        Assume.assumeFalse(\"Skipping, currently Unix-specific test\", Functions.isWindows());\n\n        File tmp = temp.newFile();\n\n            FilePath f = new FilePath(channels.french, tmp.getPath());\n            Launcher l = f.createLauncher(StreamTaskListener.fromStderr());\n            Proc p = l.launch().cmds(\"sh\", \"-c\", \"echo $$$$ > \"+tmp+\"; sleep 30\").stdout(System.out).stderr(System.err).start();\n            while (!tmp.exists())\n                Thread.sleep(100);\n            long start = System.currentTimeMillis();\n            p.kill();\n            assertTrue(p.join()!=0);\n            long end = System.currentTimeMillis();\n            assertTrue(\"join finished promptly\", (end - start < 15000));\n            channels.french.call(NOOP); // this only returns after the other side of the channel has finished executing cancellation\n            Thread.sleep(2000); // more delay to make sure it's gone\n            assertNull(\"process should be gone\",ProcessTree.get().get(Integer.parseInt(FileUtils.readFileToString(tmp).trim())));\n\n            // Manual version of test: set up instance w/ one slave. Now in script console\n            // new hudson.FilePath(new java.io.File(\"/tmp\")).createLauncher(new hudson.util.StreamTaskListener(System.err)).\n            //   launch().cmds(\"sleep\", \"1d\").stdout(System.out).stderr(System.err).start().kill()\n            // returns immediately and pgrep sleep => nothing. But without fix\n            // hudson.model.Hudson.instance.nodes[0].rootPath.createLauncher(new hudson.util.StreamTaskListener(System.err)).\n            //   launch().cmds(\"sleep\", \"1d\").stdout(System.out).stderr(System.err).start().kill()\n            // hangs and on slave machine pgrep sleep => one process; after manual kill, script returns.\n    }","commit_id":"39903842575d3eadbec8c8153f79caa76c3f2c6e","url":"https://github.com/kohsuke/hudson"},{"original_method":"@Test\n    @Issue(\"JENKINS-22641\")\n    public void processProperlyKilledUnix() throws Exception {\n        ProcessTree.enabled = true;\n        if (Functions.isWindows()) return; // This test does not involve windows.\n\n        FreeStyleProject sleepProject = j.createFreeStyleProject();\n        FreeStyleProject processJob = j.createFreeStyleProject();\n\n        sleepProject.getBuildersList().add(new Shell(\"nohup sleep 100000 &\"));\n\n        j.assertBuildStatusSuccess(sleepProject.scheduleBuild2(0).get());\n\n        processJob.getBuildersList().add(new Shell(\"ps -ef | grep sleep\"));\n\n        j.assertLogNotContains(\"sleep 100000\", processJob.scheduleBuild2(0).get());\n    }","id":60013,"modified_method":"@Test\n    @Issue(\"JENKINS-22641\")\n    public void processProperlyKilledUnix() throws Exception {\n        ProcessTree.enabled = true;\n        Assume.assumeFalse(\"This test does not involve windows\", Functions.isWindows());\n\n        FreeStyleProject sleepProject = j.createFreeStyleProject();\n        FreeStyleProject processJob = j.createFreeStyleProject();\n\n        sleepProject.getBuildersList().add(new Shell(\"nohup sleep 100000 &\"));\n\n        j.assertBuildStatusSuccess(sleepProject.scheduleBuild2(0).get());\n\n        processJob.getBuildersList().add(new Shell(\"ps -ef | grep sleep\"));\n\n        j.assertLogNotContains(\"sleep 100000\", processJob.scheduleBuild2(0).get());\n    }","commit_id":"39903842575d3eadbec8c8153f79caa76c3f2c6e","url":"https://github.com/kohsuke/hudson"},{"original_method":"@Test public void remoting() throws Exception {\n        // on some platforms where we fail to list any processes, this test will just not work\n        if (ProcessTree.get()==ProcessTree.DEFAULT)\n            return;\n\n        Tag t = channels.french.call(new MyCallable());\n\n        // make sure the serialization preserved the reference graph\n        assertSame(t.p.getTree(), t.tree);\n\n        // verify that some remote call works\n        t.p.getEnvironmentVariables();\n\n        // it should point to the same object\n        assertEquals(t.id,t.p.getPid());\n\n        t.p.act(new ProcessCallableImpl());\n    }","id":60014,"modified_method":"@Test public void remoting() throws Exception {\n        Assume.assumeFalse(\"on some platforms where we fail to list any processes\", ProcessTree.get()==ProcessTree.DEFAULT);\n\n        Tag t = channels.french.call(new MyCallable());\n\n        // make sure the serialization preserved the reference graph\n        assertSame(t.p.getTree(), t.tree);\n\n        // verify that some remote call works\n        t.p.getEnvironmentVariables();\n\n        // it should point to the same object\n        assertEquals(t.id,t.p.getPid());\n\n        t.p.act(new ProcessCallableImpl());\n    }","commit_id":"39903842575d3eadbec8c8153f79caa76c3f2c6e","url":"https://github.com/kohsuke/hudson"},{"original_method":"@Test\n    public void testBasic() throws Exception {\n        // If we're on Windows, don't bother doing this.\n        if (Functions.isWindows())\n            return;\n\n        // TODO: define a FakeLauncher implementation with easymock so that this kind of assertions can be simplified.\n        PretendSlave s = rule.createPretendSlave(new FakeLauncher() {\n            public Proc onLaunch(ProcStarter p) throws IOException {\n                // test the command line argument.\n                List<String> cmds = p.cmds();\n                rule.assertStringContains(\"/bin/sh\",cmds.get(0));\n                rule.assertStringContains(\"-xe\",cmds.get(1));\n                assertTrue(new File(cmds.get(2)).exists());\n\n                // fake the execution\n                PrintStream ps = new PrintStream(p.stdout());\n                ps.println(\"Hudson was here\");\n                ps.close();\n\n                return new FinishedProc(0);\n            }\n        });\n        FreeStyleProject p = rule.createFreeStyleProject();\n        p.getBuildersList().add(new Shell(\"echo abc\"));\n        p.setAssignedNode(s);\n        \n        FreeStyleBuild b = rule.assertBuildStatusSuccess(p.scheduleBuild2(0).get());\n\n        assertEquals(1,s.numLaunch);\n        assertTrue(FileUtils.readFileToString(b.getLogFile()).contains(\"Hudson was here\"));\n    }","id":60015,"modified_method":"@Test\n    public void testBasic() throws Exception {\n        Assume.assumeFalse(\"If we're on Windows, don't bother doing this\", Functions.isWindows());\n\n        // TODO: define a FakeLauncher implementation with easymock so that this kind of assertions can be simplified.\n        PretendSlave s = rule.createPretendSlave(new FakeLauncher() {\n            public Proc onLaunch(ProcStarter p) throws IOException {\n                // test the command line argument.\n                List<String> cmds = p.cmds();\n                rule.assertStringContains(\"/bin/sh\",cmds.get(0));\n                rule.assertStringContains(\"-xe\",cmds.get(1));\n                assertTrue(new File(cmds.get(2)).exists());\n\n                // fake the execution\n                PrintStream ps = new PrintStream(p.stdout());\n                ps.println(\"Hudson was here\");\n                ps.close();\n\n                return new FinishedProc(0);\n            }\n        });\n        FreeStyleProject p = rule.createFreeStyleProject();\n        p.getBuildersList().add(new Shell(\"echo abc\"));\n        p.setAssignedNode(s);\n        \n        FreeStyleBuild b = rule.assertBuildStatusSuccess(p.scheduleBuild2(0).get());\n\n        assertEquals(1,s.numLaunch);\n        assertTrue(FileUtils.readFileToString(b.getLogFile()).contains(\"Hudson was here\"));\n    }","commit_id":"39903842575d3eadbec8c8153f79caa76c3f2c6e","url":"https://github.com/kohsuke/hudson"},{"original_method":"private boolean isAuditResource(TargetResource target) {\n            // TODO implement isAuditResource\n            return false;\n        }","id":60016,"modified_method":"private boolean isAuditResource(TargetResource target) {\n            return AuditLogAddressUtil.isAuditLogAddress(target.getResourceAddress());\n        }","commit_id":"e940d31df2d7d697fed5a315c60db80067bf8840","url":"https://github.com/wildfly/wildfly"},{"original_method":"private boolean isAuditOperation(Action action) {\n            // TODO implement isAuditOperation\n            return false;\n        }","id":60017,"modified_method":"private boolean isAuditOperation(Action action) {\n            return AuditLogAddressUtil.isAuditLogAddress(PathAddress.pathAddress(action.getOperation().get(OP_ADDR)));\n        }","commit_id":"e940d31df2d7d697fed5a315c60db80067bf8840","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public Constraint getStandardUserConstraint(StandardRole role, Action.ActionEffect actionEffect) {\n            return role == StandardRole.AUDITOR || role == StandardRole.SUPERUSER ? ALLOWS : DISALLOWS;\n        }","id":60018,"modified_method":"@Override\n        public Constraint getStandardUserConstraint(StandardRole role, Action.ActionEffect actionEffect) {\n            if (actionEffect == ActionEffect.ADDRESS) {\n                return ALLOWS;\n            }\n            return role == StandardRole.AUDITOR || role == StandardRole.SUPERUSER ? ALLOWS : DISALLOWS;\n        }","commit_id":"e940d31df2d7d697fed5a315c60db80067bf8840","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Before\n    public void setup() {\n        ModelNode operation = Util.createOperation(ADD, pathAddress(UNCONSTRAINED_RESOURCE, FOO));\n        executeWithRole(operation, StandardRole.SUPERUSER);\n\n        operation = Util.createOperation(ADD, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO));\n        executeWithRole(operation, StandardRole.SUPERUSER);\n\n        operation = Util.createOperation(ADD, pathAddress(SENSITIVE_NON_ADDRESSABLE_RESOURCE, FOO));\n        executeWithRole(operation, StandardRole.SUPERUSER);\n\n        operation = Util.createOperation(ADD, pathAddress(SENSITIVE_ADDRESSABLE_RESOURCE, FOO));\n        executeWithRole(operation, StandardRole.SUPERUSER);\n\n        operation = Util.createOperation(ADD, pathAddress(SENSITIVE_READ_ONLY_RESOURCE, FOO));\n        executeWithRole(operation, StandardRole.SUPERUSER);\n    }","id":60019,"modified_method":"@Before\n    public void setup() {\n        ModelNode operation = Util.createOperation(ADD, pathAddress(UNCONSTRAINED_RESOURCE, FOO));\n        executeWithRole(operation, StandardRole.SUPERUSER);\n\n        operation = Util.createOperation(ADD, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO));\n        executeWithRole(operation, StandardRole.SUPERUSER);\n\n        operation = Util.createOperation(ADD, pathAddress(SENSITIVE_NON_ADDRESSABLE_RESOURCE, FOO));\n        executeWithRole(operation, StandardRole.SUPERUSER);\n\n        operation = Util.createOperation(ADD, pathAddress(SENSITIVE_ADDRESSABLE_RESOURCE, FOO));\n        executeWithRole(operation, StandardRole.SUPERUSER);\n\n        operation = Util.createOperation(ADD, pathAddress(SENSITIVE_READ_ONLY_RESOURCE, FOO));\n        executeWithRole(operation, StandardRole.SUPERUSER);\n\n        operation = Util.createOperation(ADD, PathAddress.pathAddress(CORE_MANAGEMENT));\n        executeWithRole(operation, StandardRole.SUPERUSER);\n\n        operation = Util.createOperation(ADD, PathAddress.pathAddress(ACCESS_AUDIT_ADDR));\n        executeWithRole(operation, StandardRole.SUPERUSER);\n    }","commit_id":"e940d31df2d7d697fed5a315c60db80067bf8840","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testAuditorReadConfigPermitted() throws Exception {\n        permitted(READ_RESOURCE_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), StandardRole.AUDITOR);\n        permitted(READ_RESOURCE_OPERATION, pathAddress(SENSITIVE_NON_ADDRESSABLE_RESOURCE, FOO), StandardRole.AUDITOR);\n        permitted(READ_RESOURCE_OPERATION, pathAddress(SENSITIVE_ADDRESSABLE_RESOURCE, FOO), StandardRole.AUDITOR);\n        permitted(READ_RESOURCE_OPERATION, pathAddress(SENSITIVE_READ_ONLY_RESOURCE, FOO), StandardRole.AUDITOR);\n        permitted(READ_RESOURCE_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), StandardRole.AUDITOR);\n    }","id":60020,"modified_method":"@Test\n    public void testAuditorReadConfigPermitted() throws Exception {\n        permitted(READ_RESOURCE_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), StandardRole.AUDITOR);\n        permitted(READ_RESOURCE_OPERATION, pathAddress(SENSITIVE_NON_ADDRESSABLE_RESOURCE, FOO), StandardRole.AUDITOR);\n        permitted(READ_RESOURCE_OPERATION, pathAddress(SENSITIVE_ADDRESSABLE_RESOURCE, FOO), StandardRole.AUDITOR);\n        permitted(READ_RESOURCE_OPERATION, pathAddress(SENSITIVE_READ_ONLY_RESOURCE, FOO), StandardRole.AUDITOR);\n        permitted(READ_RESOURCE_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), StandardRole.AUDITOR);\n        permitted(READ_RESOURCE_OPERATION, ACCESS_AUDIT_ADDR, StandardRole.AUDITOR);\n    }","commit_id":"e940d31df2d7d697fed5a315c60db80067bf8840","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testDeployerNoAccess() throws Exception {\n        noAccess(READ_RESOURCE_OPERATION, pathAddress(SENSITIVE_NON_ADDRESSABLE_RESOURCE, FOO), StandardRole.DEPLOYER);\n    }","id":60021,"modified_method":"@Test\n    public void testDeployerNoAccess() throws Exception {\n        noAccess(READ_RESOURCE_OPERATION, pathAddress(SENSITIVE_NON_ADDRESSABLE_RESOURCE, FOO), StandardRole.DEPLOYER);\n        noAccess(READ_RESOURCE_OPERATION, ACCESS_AUDIT_ADDR, StandardRole.DEPLOYER);\n    }","commit_id":"e940d31df2d7d697fed5a315c60db80067bf8840","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testSuperUserReadRuntimePermitted() throws Exception {\n        permitted(READONLY_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), StandardRole.SUPERUSER);\n        permitted(READONLY_OPERATION, pathAddress(SENSITIVE_NON_ADDRESSABLE_RESOURCE, FOO), StandardRole.SUPERUSER);\n        permitted(READONLY_OPERATION, pathAddress(SENSITIVE_ADDRESSABLE_RESOURCE, FOO), StandardRole.SUPERUSER);\n        permitted(READONLY_OPERATION, pathAddress(SENSITIVE_READ_ONLY_RESOURCE, FOO), StandardRole.SUPERUSER);\n        permitted(READONLY_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), StandardRole.SUPERUSER);\n    }","id":60022,"modified_method":"@Test\n    public void testSuperUserReadRuntimePermitted() throws Exception {\n        permitted(READONLY_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), StandardRole.SUPERUSER);\n        permitted(READONLY_OPERATION, pathAddress(SENSITIVE_NON_ADDRESSABLE_RESOURCE, FOO), StandardRole.SUPERUSER);\n        permitted(READONLY_OPERATION, pathAddress(SENSITIVE_ADDRESSABLE_RESOURCE, FOO), StandardRole.SUPERUSER);\n        permitted(READONLY_OPERATION, pathAddress(SENSITIVE_READ_ONLY_RESOURCE, FOO), StandardRole.SUPERUSER);\n        permitted(READONLY_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), StandardRole.SUPERUSER);\n        permitted(READONLY_OPERATION, ACCESS_AUDIT_ADDR, StandardRole.AUDITOR);\n    }","commit_id":"e940d31df2d7d697fed5a315c60db80067bf8840","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testSuperUserWriteRuntimePermitted() throws Exception {\n        permitted(READWRITE_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, BAR), StandardRole.SUPERUSER);\n        permitted(READWRITE_OPERATION, pathAddress(SENSITIVE_NON_ADDRESSABLE_RESOURCE, BAR), StandardRole.SUPERUSER);\n        permitted(READWRITE_OPERATION, pathAddress(SENSITIVE_ADDRESSABLE_RESOURCE, BAR), StandardRole.SUPERUSER);\n        permitted(READWRITE_OPERATION, pathAddress(SENSITIVE_READ_ONLY_RESOURCE, BAR), StandardRole.SUPERUSER);\n        permitted(READWRITE_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, BAR), StandardRole.SUPERUSER);\n    }","id":60023,"modified_method":"@Test\n    public void testSuperUserWriteRuntimePermitted() throws Exception {\n        permitted(READWRITE_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, BAR), StandardRole.SUPERUSER);\n        permitted(READWRITE_OPERATION, pathAddress(SENSITIVE_NON_ADDRESSABLE_RESOURCE, BAR), StandardRole.SUPERUSER);\n        permitted(READWRITE_OPERATION, pathAddress(SENSITIVE_ADDRESSABLE_RESOURCE, BAR), StandardRole.SUPERUSER);\n        permitted(READWRITE_OPERATION, pathAddress(SENSITIVE_READ_ONLY_RESOURCE, BAR), StandardRole.SUPERUSER);\n        permitted(READWRITE_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, BAR), StandardRole.SUPERUSER);\n        permitted(READWRITE_OPERATION, ACCESS_AUDIT_ADDR, StandardRole.AUDITOR);\n    }","commit_id":"e940d31df2d7d697fed5a315c60db80067bf8840","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testMaintainerNonAddressable() throws Exception {\n        noAccess(READ_RESOURCE_OPERATION, pathAddress(SENSITIVE_NON_ADDRESSABLE_RESOURCE, FOO), StandardRole.MAINTAINER);\n    }","id":60024,"modified_method":"@Test\n    public void testMaintainerNonAddressable() throws Exception {\n        noAccess(READ_RESOURCE_OPERATION, pathAddress(SENSITIVE_NON_ADDRESSABLE_RESOURCE, FOO), StandardRole.MAINTAINER);\n        noAccess(READ_RESOURCE_OPERATION, ACCESS_AUDIT_ADDR, StandardRole.MAINTAINER);\n    }","commit_id":"e940d31df2d7d697fed5a315c60db80067bf8840","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testSuperUserReadConfigPermitted() throws Exception {\n        permitted(READ_RESOURCE_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), StandardRole.SUPERUSER);\n        permitted(READ_RESOURCE_OPERATION, pathAddress(SENSITIVE_NON_ADDRESSABLE_RESOURCE, FOO), StandardRole.SUPERUSER);\n        permitted(READ_RESOURCE_OPERATION, pathAddress(SENSITIVE_ADDRESSABLE_RESOURCE, FOO), StandardRole.SUPERUSER);\n        permitted(READ_RESOURCE_OPERATION, pathAddress(SENSITIVE_READ_ONLY_RESOURCE, FOO), StandardRole.SUPERUSER);\n        permitted(READ_RESOURCE_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), StandardRole.SUPERUSER);\n    }","id":60025,"modified_method":"@Test\n    public void testSuperUserReadConfigPermitted() throws Exception {\n        permitted(READ_RESOURCE_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), StandardRole.SUPERUSER);\n        permitted(READ_RESOURCE_OPERATION, pathAddress(SENSITIVE_NON_ADDRESSABLE_RESOURCE, FOO), StandardRole.SUPERUSER);\n        permitted(READ_RESOURCE_OPERATION, pathAddress(SENSITIVE_ADDRESSABLE_RESOURCE, FOO), StandardRole.SUPERUSER);\n        permitted(READ_RESOURCE_OPERATION, pathAddress(SENSITIVE_READ_ONLY_RESOURCE, FOO), StandardRole.SUPERUSER);\n        permitted(READ_RESOURCE_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), StandardRole.SUPERUSER);\n        permitted(READ_RESOURCE_OPERATION, ACCESS_AUDIT_ADDR, StandardRole.AUDITOR);\n    }","commit_id":"e940d31df2d7d697fed5a315c60db80067bf8840","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testAuditorReadRuntimePermitted() throws Exception {\n        permitted(READONLY_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), StandardRole.AUDITOR);\n        permitted(READONLY_OPERATION, pathAddress(SENSITIVE_NON_ADDRESSABLE_RESOURCE, FOO), StandardRole.AUDITOR);\n        permitted(READONLY_OPERATION, pathAddress(SENSITIVE_ADDRESSABLE_RESOURCE, FOO), StandardRole.AUDITOR);\n        permitted(READONLY_OPERATION, pathAddress(SENSITIVE_READ_ONLY_RESOURCE, FOO), StandardRole.AUDITOR);\n        permitted(READONLY_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), StandardRole.AUDITOR);\n    }","id":60026,"modified_method":"@Test\n    public void testAuditorReadRuntimePermitted() throws Exception {\n        permitted(READONLY_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), StandardRole.AUDITOR);\n        permitted(READONLY_OPERATION, pathAddress(SENSITIVE_NON_ADDRESSABLE_RESOURCE, FOO), StandardRole.AUDITOR);\n        permitted(READONLY_OPERATION, pathAddress(SENSITIVE_ADDRESSABLE_RESOURCE, FOO), StandardRole.AUDITOR);\n        permitted(READONLY_OPERATION, pathAddress(SENSITIVE_READ_ONLY_RESOURCE, FOO), StandardRole.AUDITOR);\n        permitted(READONLY_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), StandardRole.AUDITOR);\n        permitted(READONLY_OPERATION, ACCESS_AUDIT_ADDR, StandardRole.AUDITOR);\n    }","commit_id":"e940d31df2d7d697fed5a315c60db80067bf8840","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testAuditorWriteRuntimeDenied() throws Exception {\n        denied(READWRITE_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), StandardRole.AUDITOR);\n        denied(READWRITE_OPERATION, pathAddress(SENSITIVE_READ_ONLY_RESOURCE, FOO), StandardRole.AUDITOR);\n        denied(READWRITE_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), StandardRole.AUDITOR);\n    }","id":60027,"modified_method":"@Test\n    public void testAuditorWriteRuntimeDenied() throws Exception {\n        denied(READWRITE_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), StandardRole.AUDITOR);\n        denied(READWRITE_OPERATION, pathAddress(SENSITIVE_READ_ONLY_RESOURCE, FOO), StandardRole.AUDITOR);\n        denied(READWRITE_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), StandardRole.AUDITOR);\n        permitted(READWRITE_OPERATION, ACCESS_AUDIT_ADDR, StandardRole.AUDITOR);\n    }","commit_id":"e940d31df2d7d697fed5a315c60db80067bf8840","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testOperatorNonAddressable() throws Exception {\n        noAccess(READ_RESOURCE_OPERATION, pathAddress(SENSITIVE_NON_ADDRESSABLE_RESOURCE, FOO), StandardRole.OPERATOR);\n    }","id":60028,"modified_method":"@Test\n    public void testOperatorNonAddressable() throws Exception {\n        noAccess(READ_RESOURCE_OPERATION, pathAddress(SENSITIVE_NON_ADDRESSABLE_RESOURCE, FOO), StandardRole.OPERATOR);\n        noAccess(READ_RESOURCE_OPERATION, ACCESS_AUDIT_ADDR, StandardRole.OPERATOR);\n    }","commit_id":"e940d31df2d7d697fed5a315c60db80067bf8840","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testMonitorNonAddressable() throws Exception {\n        noAccess(READ_RESOURCE_OPERATION, pathAddress(SENSITIVE_NON_ADDRESSABLE_RESOURCE, FOO), StandardRole.MONITOR);\n    }","id":60029,"modified_method":"@Test\n    public void testMonitorNonAddressable() throws Exception {\n        noAccess(READ_RESOURCE_OPERATION, pathAddress(SENSITIVE_NON_ADDRESSABLE_RESOURCE, FOO), StandardRole.MONITOR);\n        noAccess(READ_RESOURCE_OPERATION, ACCESS_AUDIT_ADDR, StandardRole.MONITOR);\n    }","commit_id":"e940d31df2d7d697fed5a315c60db80067bf8840","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void initModel(Resource rootResource, ManagementResourceRegistration registration) {\n        GlobalOperationHandlers.registerGlobalOperations(registration, ProcessType.EMBEDDED_SERVER);\n\n        registration.registerSubModel(new TestResourceDefinition(UNCONSTRAINED_RESOURCE));\n        registration.registerSubModel(new TestResourceDefinition(SENSITIVE_NON_ADDRESSABLE_RESOURCE,\n                ADDRESSABLE_SENSITIVITY_CONSTRAINT));\n        registration.registerSubModel(new TestResourceDefinition(SENSITIVE_ADDRESSABLE_RESOURCE,\n                READ_SENSITIVITY_CONSTRAINT));\n        registration.registerSubModel(new TestResourceDefinition(SENSITIVE_READ_ONLY_RESOURCE,\n                WRITE_SENSITIVITY_CONSTRAINT));\n        registration.registerSubModel(new TestResourceDefinition(APPLICATION_CONSTRAINED_RESOURCE,\n                MY_APPLICATION_CONSTRAINT));\n    }","id":60030,"modified_method":"@Override\n    protected void initModel(Resource rootResource, ManagementResourceRegistration registration) {\n        GlobalOperationHandlers.registerGlobalOperations(registration, ProcessType.EMBEDDED_SERVER);\n\n        registration.registerSubModel(new TestResourceDefinition(UNCONSTRAINED_RESOURCE));\n        registration.registerSubModel(new TestResourceDefinition(SENSITIVE_NON_ADDRESSABLE_RESOURCE,\n                ADDRESSABLE_SENSITIVITY_CONSTRAINT));\n        registration.registerSubModel(new TestResourceDefinition(SENSITIVE_ADDRESSABLE_RESOURCE,\n                READ_SENSITIVITY_CONSTRAINT));\n        registration.registerSubModel(new TestResourceDefinition(SENSITIVE_READ_ONLY_RESOURCE,\n                WRITE_SENSITIVITY_CONSTRAINT));\n        registration.registerSubModel(new TestResourceDefinition(APPLICATION_CONSTRAINED_RESOURCE,\n                MY_APPLICATION_CONSTRAINT));\n\n        ManagementResourceRegistration mgmt = registration.registerSubModel(new TestResourceDefinition(CORE_MANAGEMENT));\n        mgmt.registerSubModel(new TestResourceDefinition(ACCESS_AUDIT));\n    }","commit_id":"e940d31df2d7d697fed5a315c60db80067bf8840","url":"https://github.com/wildfly/wildfly"},{"original_method":"TestResourceDefinition(String path, AccessConstraintDefinition... constraintDefinitions) {\n            super(pathElement(path),\n                    new NonResolvingResourceDescriptionResolver(),\n                    new AbstractAddStepHandler() {},\n                    new AbstractRemoveStepHandler() {}\n            );\n\n            this.constraintDefinitions = Collections.unmodifiableList(Arrays.asList(constraintDefinitions));\n        }","id":60031,"modified_method":"TestResourceDefinition(String path, AccessConstraintDefinition... constraintDefinitions) {\n            this(pathElement(path), constraintDefinitions);\n        }","commit_id":"e940d31df2d7d697fed5a315c60db80067bf8840","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testSuperUserWriteConfigPermitted() throws Exception {\n        permitted(ADD, pathAddress(UNCONSTRAINED_RESOURCE, BAR), StandardRole.SUPERUSER);\n        permitted(ADD, pathAddress(SENSITIVE_NON_ADDRESSABLE_RESOURCE, BAR), StandardRole.SUPERUSER);\n        permitted(ADD, pathAddress(SENSITIVE_ADDRESSABLE_RESOURCE, BAR), StandardRole.SUPERUSER);\n        permitted(ADD, pathAddress(SENSITIVE_READ_ONLY_RESOURCE, BAR), StandardRole.SUPERUSER);\n        permitted(ADD, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, BAR), StandardRole.SUPERUSER);\n    }","id":60032,"modified_method":"@Test\n    public void testSuperUserWriteConfigPermitted() throws Exception {\n        permitted(ADD, pathAddress(UNCONSTRAINED_RESOURCE, BAR), StandardRole.SUPERUSER);\n        permitted(ADD, pathAddress(SENSITIVE_NON_ADDRESSABLE_RESOURCE, BAR), StandardRole.SUPERUSER);\n        permitted(ADD, pathAddress(SENSITIVE_ADDRESSABLE_RESOURCE, BAR), StandardRole.SUPERUSER);\n        permitted(ADD, pathAddress(SENSITIVE_READ_ONLY_RESOURCE, BAR), StandardRole.SUPERUSER);\n        permitted(ADD, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, BAR), StandardRole.SUPERUSER);\n        permitted(REMOVE, ACCESS_AUDIT_ADDR, StandardRole.SUPERUSER);\n        permitted(ADD, ACCESS_AUDIT_ADDR, StandardRole.SUPERUSER);\n    }","commit_id":"e940d31df2d7d697fed5a315c60db80067bf8840","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testDeployer() {\n        StandardRole role = StandardRole.DEPLOYER;\n\n        permitted(READ_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(READ_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(READ_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        denied(WRITE_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        denied(WRITE_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(READ_CONFIG_READ_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_READ_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_READ_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        denied(READ_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        denied(WRITE_CONFIG_READ_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_CONFIG_READ_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_CONFIG_READ_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        denied(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(READ_RUNTIME_READ_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(READ_RUNTIME_READ_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_RUNTIME_READ_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        denied(WRITE_RUNTIME_READ_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_RUNTIME_READ_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_RUNTIME_READ_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        denied(READ_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(READ_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        denied(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n    }","id":60033,"modified_method":"@Test\n    public void testDeployer() {\n        StandardRole role = StandardRole.DEPLOYER;\n\n        permitted(READ_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(READ_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(READ_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_RUNTIME_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        denied(WRITE_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_CONFIG_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        denied(WRITE_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_RUNTIME_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(READ_CONFIG_READ_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_READ_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_READ_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_READ_RUNTIME_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        denied(READ_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_WRITE_RUNTIME_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        denied(WRITE_CONFIG_READ_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_CONFIG_READ_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_CONFIG_READ_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_CONFIG_READ_RUNTIME_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        denied(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(READ_RUNTIME_READ_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(READ_RUNTIME_READ_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_RUNTIME_READ_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_RUNTIME_READ_CONFIG_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        denied(WRITE_RUNTIME_READ_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_RUNTIME_READ_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_RUNTIME_READ_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_RUNTIME_READ_CONFIG_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        denied(READ_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(READ_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_RUNTIME_WRITE_CONFIG_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        denied(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, ACCESS_AUDIT_ADDR, role);\n    }","commit_id":"e940d31df2d7d697fed5a315c60db80067bf8840","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testOperator() {\n        StandardRole role = StandardRole.OPERATOR;\n\n        permitted(READ_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(READ_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(READ_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        denied(WRITE_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(WRITE_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(READ_CONFIG_READ_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_READ_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_READ_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(READ_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        denied(WRITE_CONFIG_READ_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_CONFIG_READ_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_CONFIG_READ_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        denied(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(READ_RUNTIME_READ_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(READ_RUNTIME_READ_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_RUNTIME_READ_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(WRITE_RUNTIME_READ_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_RUNTIME_READ_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_RUNTIME_READ_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        denied(READ_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(READ_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        denied(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n    }","id":60034,"modified_method":"@Test\n    public void testOperator() {\n        StandardRole role = StandardRole.OPERATOR;\n\n        permitted(READ_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(READ_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(READ_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_RUNTIME_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        denied(WRITE_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_CONFIG_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(WRITE_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_RUNTIME_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(READ_CONFIG_READ_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_READ_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_READ_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_READ_RUNTIME_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(READ_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_WRITE_RUNTIME_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        denied(WRITE_CONFIG_READ_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_CONFIG_READ_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_CONFIG_READ_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_CONFIG_READ_RUNTIME_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        denied(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(READ_RUNTIME_READ_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(READ_RUNTIME_READ_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_RUNTIME_READ_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_RUNTIME_READ_CONFIG_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(WRITE_RUNTIME_READ_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_RUNTIME_READ_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_RUNTIME_READ_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_RUNTIME_READ_CONFIG_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        denied(READ_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(READ_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_RUNTIME_WRITE_CONFIG_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        denied(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, ACCESS_AUDIT_ADDR, role);\n    }","commit_id":"e940d31df2d7d697fed5a315c60db80067bf8840","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void initModel(Resource rootResource, ManagementResourceRegistration registration) {\n        GlobalOperationHandlers.registerGlobalOperations(registration, ProcessType.EMBEDDED_SERVER);\n\n        registration.registerSubModel(new TestResourceDefinition(UNCONSTRAINED_RESOURCE));\n        registration.registerSubModel(new TestResourceDefinition(SENSITIVE_CONSTRAINED_RESOURCE,\n                MY_SENSITIVE_CONSTRAINT));\n        registration.registerSubModel(new TestResourceDefinition(APPLICATION_CONSTRAINED_RESOURCE,\n                MY_APPLICATION_CONSTRAINT));\n    }","id":60035,"modified_method":"@Override\n    protected void initModel(Resource rootResource, ManagementResourceRegistration registration) {\n        GlobalOperationHandlers.registerGlobalOperations(registration, ProcessType.EMBEDDED_SERVER);\n\n        registration.registerSubModel(new TestResourceDefinition(UNCONSTRAINED_RESOURCE));\n        registration.registerSubModel(new TestResourceDefinition(SENSITIVE_CONSTRAINED_RESOURCE,\n                MY_SENSITIVE_CONSTRAINT));\n        registration.registerSubModel(new TestResourceDefinition(APPLICATION_CONSTRAINED_RESOURCE,\n                MY_APPLICATION_CONSTRAINT));\n\n        ManagementResourceRegistration mgmt = registration.registerSubModel(new TestResourceDefinition(CORE_MANAGEMENT));\n        mgmt.registerSubModel(new TestResourceDefinition(ACCESS_AUDIT));\n\n    }","commit_id":"e940d31df2d7d697fed5a315c60db80067bf8840","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testMaintainer() {\n        StandardRole role = StandardRole.MAINTAINER;\n\n        permitted(READ_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(READ_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(READ_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(WRITE_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(WRITE_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(READ_CONFIG_READ_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_READ_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_READ_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(READ_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(WRITE_CONFIG_READ_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_CONFIG_READ_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_CONFIG_READ_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(READ_RUNTIME_READ_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(READ_RUNTIME_READ_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_RUNTIME_READ_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(WRITE_RUNTIME_READ_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_RUNTIME_READ_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_RUNTIME_READ_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(READ_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(READ_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n    }","id":60036,"modified_method":"@Test\n    public void testMaintainer() {\n        StandardRole role = StandardRole.MAINTAINER;\n\n        permitted(READ_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(READ_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(READ_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_RUNTIME_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(WRITE_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_CONFIG_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(WRITE_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_RUNTIME_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(READ_CONFIG_READ_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_READ_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_READ_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_READ_RUNTIME_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(READ_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_WRITE_RUNTIME_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(WRITE_CONFIG_READ_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_CONFIG_READ_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_CONFIG_READ_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_CONFIG_READ_RUNTIME_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(READ_RUNTIME_READ_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(READ_RUNTIME_READ_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_RUNTIME_READ_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_RUNTIME_READ_CONFIG_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(WRITE_RUNTIME_READ_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_RUNTIME_READ_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_RUNTIME_READ_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_RUNTIME_READ_CONFIG_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(READ_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(READ_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_RUNTIME_WRITE_CONFIG_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, ACCESS_AUDIT_ADDR, role);\n    }","commit_id":"e940d31df2d7d697fed5a315c60db80067bf8840","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Before\n    public void setUp() {\n        ModelNode operation = Util.createOperation(ADD, pathAddress(UNCONSTRAINED_RESOURCE, FOO));\n        executeWithRoles(operation, StandardRole.SUPERUSER);\n\n        operation = Util.createOperation(ADD, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO));\n        executeWithRoles(operation, StandardRole.SUPERUSER);\n\n        operation = Util.createOperation(ADD, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO));\n        executeWithRoles(operation, StandardRole.SUPERUSER);\n    }","id":60037,"modified_method":"@Before\n    public void setUp() {\n        ModelNode operation = Util.createOperation(ADD, pathAddress(UNCONSTRAINED_RESOURCE, FOO));\n        executeWithRoles(operation, StandardRole.SUPERUSER);\n\n        operation = Util.createOperation(ADD, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO));\n        executeWithRoles(operation, StandardRole.SUPERUSER);\n\n        operation = Util.createOperation(ADD, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO));\n        executeWithRoles(operation, StandardRole.SUPERUSER);\n\n        operation = Util.createOperation(ADD, PathAddress.pathAddress(CORE_MANAGEMENT));\n        executeWithRoles(operation, StandardRole.SUPERUSER);\n\n        operation = Util.createOperation(ADD, ACCESS_AUDIT_ADDR);\n        executeWithRoles(operation, StandardRole.SUPERUSER);\n    }","commit_id":"e940d31df2d7d697fed5a315c60db80067bf8840","url":"https://github.com/wildfly/wildfly"},{"original_method":"TestResourceDefinition(String path, AccessConstraintDefinition... constraintDefinitions) {\n            super(pathElement(path),\n                    new NonResolvingResourceDescriptionResolver(),\n                    new AbstractAddStepHandler() {},\n                    new AbstractRemoveStepHandler() {}\n            );\n\n            this.constraintDefinitions = Collections.unmodifiableList(Arrays.asList(constraintDefinitions));\n        }","id":60038,"modified_method":"TestResourceDefinition(String path, AccessConstraintDefinition... constraintDefinitions) {\n            this(pathElement(path), constraintDefinitions);\n        }","commit_id":"e940d31df2d7d697fed5a315c60db80067bf8840","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testAdministrator() {\n        StandardRole role = StandardRole.ADMINISTRATOR;\n\n        permitted(READ_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(READ_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(WRITE_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(WRITE_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(READ_CONFIG_READ_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_READ_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_READ_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(READ_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(WRITE_CONFIG_READ_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_CONFIG_READ_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_CONFIG_READ_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(READ_RUNTIME_READ_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_RUNTIME_READ_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_RUNTIME_READ_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(WRITE_RUNTIME_READ_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_RUNTIME_READ_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_RUNTIME_READ_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(READ_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n    }","id":60039,"modified_method":"@Test\n    public void testAdministrator() {\n        StandardRole role = StandardRole.ADMINISTRATOR;\n\n        permitted(READ_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(READ_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_RUNTIME_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(WRITE_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_CONFIG_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(WRITE_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_RUNTIME_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(READ_CONFIG_READ_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_READ_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_READ_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_READ_RUNTIME_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(READ_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_WRITE_RUNTIME_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(WRITE_CONFIG_READ_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_CONFIG_READ_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_CONFIG_READ_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_CONFIG_READ_RUNTIME_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(READ_RUNTIME_READ_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_RUNTIME_READ_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_RUNTIME_READ_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_RUNTIME_READ_CONFIG_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(WRITE_RUNTIME_READ_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_RUNTIME_READ_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_RUNTIME_READ_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_RUNTIME_READ_CONFIG_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(READ_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_RUNTIME_WRITE_CONFIG_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, ACCESS_AUDIT_ADDR, role);\n    }","commit_id":"e940d31df2d7d697fed5a315c60db80067bf8840","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testMonitor() {\n        StandardRole role = StandardRole.MONITOR;\n\n        permitted(READ_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(READ_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(READ_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        denied(WRITE_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        denied(WRITE_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(READ_CONFIG_READ_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_READ_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_READ_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        denied(READ_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        denied(WRITE_CONFIG_READ_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_CONFIG_READ_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_CONFIG_READ_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        denied(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        permitted(READ_RUNTIME_READ_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(READ_RUNTIME_READ_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_RUNTIME_READ_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        denied(WRITE_RUNTIME_READ_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_RUNTIME_READ_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_RUNTIME_READ_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        denied(READ_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(READ_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n\n        denied(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n    }","id":60040,"modified_method":"@Test\n    public void testMonitor() {\n        StandardRole role = StandardRole.MONITOR;\n\n        permitted(READ_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(READ_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(READ_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_RUNTIME_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        denied(WRITE_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_CONFIG_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        denied(WRITE_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_RUNTIME_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(READ_CONFIG_READ_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_READ_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_CONFIG_READ_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_READ_RUNTIME_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        denied(READ_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_CONFIG_WRITE_RUNTIME_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        denied(WRITE_CONFIG_READ_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_CONFIG_READ_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_CONFIG_READ_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_CONFIG_READ_RUNTIME_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        denied(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_CONFIG_WRITE_RUNTIME_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        permitted(READ_RUNTIME_READ_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(READ_RUNTIME_READ_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        permitted(READ_RUNTIME_READ_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_RUNTIME_READ_CONFIG_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        denied(WRITE_RUNTIME_READ_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_RUNTIME_READ_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_RUNTIME_READ_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_RUNTIME_READ_CONFIG_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        denied(READ_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(READ_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(READ_RUNTIME_WRITE_CONFIG_OPERATION, ACCESS_AUDIT_ADDR, role);\n\n        denied(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(UNCONSTRAINED_RESOURCE, FOO), role);\n        noAccess(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(SENSITIVE_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, pathAddress(APPLICATION_CONSTRAINED_RESOURCE, FOO), role);\n        denied(WRITE_RUNTIME_WRITE_CONFIG_OPERATION, ACCESS_AUDIT_ADDR, role);\n    }","commit_id":"e940d31df2d7d697fed5a315c60db80067bf8840","url":"https://github.com/wildfly/wildfly"},{"original_method":"private boolean isAuditResource(TargetResource target) {\n            // TODO implement isAuditResource\n            return false;\n        }","id":60041,"modified_method":"private boolean isAuditResource(TargetResource target) {\n            return AuditLogAddressUtil.isAuditLogAddress(target.getResourceAddress());\n        }","commit_id":"e940d31df2d7d697fed5a315c60db80067bf8840","url":"https://github.com/wildfly/wildfly"},{"original_method":"private boolean isAuditOperation(Action action) {\n            // TODO implement isAuditOperation\n            return false;\n        }","id":60042,"modified_method":"private boolean isAuditOperation(Action action) {\n            return AuditLogAddressUtil.isAuditLogAddress(PathAddress.pathAddress(action.getOperation().get(OP_ADDR)));\n        }","commit_id":"e940d31df2d7d697fed5a315c60db80067bf8840","url":"https://github.com/wildfly/wildfly"},{"original_method":"private BatchJobResourceDefinition() {\n        super(PathElement.pathElement(JOB), BatchResourceDescriptionResolver.getResourceDescriptionResolver(\"deployment\", \"job\"));\n    }","id":60043,"modified_method":"private BatchJobResourceDefinition() {\n        super(new Parameters(PathElement.pathElement(JOB), BatchResourceDescriptionResolver.getResourceDescriptionResolver(\"deployment\", \"job\")).setRuntime());\n    }","commit_id":"1099e613f78887950c3d23ebc74653d364c75f92","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void initialize(ExtensionContext context) {\n        final SubsystemRegistration subsystem = context.registerSubsystem(BatchSubsystemDefinition.NAME, CURRENT_MODEL_VERSION);\n        subsystem.registerSubsystemModel(BatchSubsystemDefinition.INSTANCE);\n        subsystem.registerXMLElementWriter(BatchSubsystemParser.INSTANCE);\n        // Register the deployment resources\n        if (context.isRuntimeOnlyRegistrationValid()) {\n            final SimpleResourceDefinition deploymentResource = new SimpleResourceDefinition(\n                    BatchSubsystemDefinition.SUBSYSTEM_PATH,\n                    BatchResourceDescriptionResolver.getResourceDescriptionResolver(\"deployment\"));\n            final ManagementResourceRegistration deployments = subsystem.registerDeploymentModel(deploymentResource);\n            final ManagementResourceRegistration jobRegistration = deployments.registerSubModel(BatchJobResourceDefinition.INSTANCE);\n            jobRegistration.registerSubModel(new BatchJobExecutionResourceDefinition()).setRuntimeOnly(true);\n        }\n    }","id":60044,"modified_method":"@Override\n    public void initialize(ExtensionContext context) {\n        final SubsystemRegistration subsystem = context.registerSubsystem(BatchSubsystemDefinition.NAME, CURRENT_MODEL_VERSION);\n        subsystem.registerSubsystemModel(BatchSubsystemDefinition.INSTANCE);\n        subsystem.registerXMLElementWriter(BatchSubsystemParser.INSTANCE);\n        // Register the deployment resources\n        if (context.isRuntimeOnlyRegistrationValid()) {\n            final SimpleResourceDefinition deploymentResource = new SimpleResourceDefinition(new SimpleResourceDefinition.Parameters(\n                    BatchSubsystemDefinition.SUBSYSTEM_PATH,\n                    BatchResourceDescriptionResolver.getResourceDescriptionResolver(\"deployment\")).setRuntime());\n            final ManagementResourceRegistration deployments = subsystem.registerDeploymentModel(deploymentResource);\n            final ManagementResourceRegistration jobRegistration = deployments.registerSubModel(BatchJobResourceDefinition.INSTANCE);\n            // TODO WFLY-5285 get rid of redundant .setRuntimeOnly once WFCORE-959 is integrated\n            jobRegistration.registerSubModel(new BatchJobExecutionResourceDefinition()).setRuntimeOnly(true);\n        }\n    }","commit_id":"1099e613f78887950c3d23ebc74653d364c75f92","url":"https://github.com/wildfly/wildfly"},{"original_method":"public CoreAddressDefinition() {\n        super(PATH,\n                MessagingExtension.getResourceDescriptionResolver(CommonAttributes.CORE_ADDRESS));\n    }","id":60045,"modified_method":"public CoreAddressDefinition() {\n        super(new Parameters(PATH,\n                MessagingExtension.getResourceDescriptionResolver(CommonAttributes.CORE_ADDRESS)).setRuntime());\n    }","commit_id":"1099e613f78887950c3d23ebc74653d364c75f92","url":"https://github.com/wildfly/wildfly"},{"original_method":"private ResourceDefinition createProtocolResourceDefinition(String protocolName, Class<? extends Protocol> protocolClass) {\n\n        SimpleResourceDescriptionResolver resolver = new SimpleResourceDescriptionResolver(protocolName, protocolClass.getSimpleName());\n        ResourceBuilder builder = ResourceBuilder.Factory.create(ProtocolResourceDefinition.pathElement(protocolName), resolver);\n        ProtocolMetricsHandler handler = new ProtocolMetricsHandler(this);\n\n        for (Map.Entry<String, Attribute> entry: ProtocolMetricsHandler.findProtocolAttributes(protocolClass).entrySet()) {\n            String name = entry.getKey();\n            Attribute attribute = entry.getValue();\n            FieldType type = FieldType.valueOf(attribute.getType());\n            resolver.addDescription(name, attribute.getDescription());\n            builder.addMetric(new SimpleAttributeDefinitionBuilder(name, type.getModelType(), true).setStorageRuntime().build(), handler);\n        }\n\n        return builder.build();\n    }","id":60046,"modified_method":"private ResourceDefinition createProtocolResourceDefinition(String protocolName, Class<? extends Protocol> protocolClass) {\n\n        SimpleResourceDescriptionResolver resolver = new SimpleResourceDescriptionResolver(protocolName, protocolClass.getSimpleName());\n        ResourceBuilder builder = ResourceBuilder.Factory.create(ProtocolResourceDefinition.pathElement(protocolName), resolver).setRuntime();\n        ProtocolMetricsHandler handler = new ProtocolMetricsHandler(this);\n\n        for (Map.Entry<String, Attribute> entry: ProtocolMetricsHandler.findProtocolAttributes(protocolClass).entrySet()) {\n            String name = entry.getKey();\n            Attribute attribute = entry.getValue();\n            FieldType type = FieldType.valueOf(attribute.getType());\n            resolver.addDescription(name, attribute.getDescription());\n            builder.addMetric(new SimpleAttributeDefinitionBuilder(name, type.getModelType(), true).setStorageRuntime().build(), handler);\n        }\n\n        return builder.build();\n    }","commit_id":"1099e613f78887950c3d23ebc74653d364c75f92","url":"https://github.com/wildfly/wildfly"},{"original_method":"private QueueDefinition(final boolean runtimeOnly,\n                            final PathElement path) {\n        super(path,\n                MessagingExtension.getResourceDescriptionResolver(CommonAttributes.QUEUE),\n                runtimeOnly ? null : QueueAdd.INSTANCE,\n                runtimeOnly ? null : QueueRemove.INSTANCE);\n        this.runtimeOnly = runtimeOnly;\n    }","id":60047,"modified_method":"private QueueDefinition(final boolean runtimeOnly,\n                            final PathElement path) {\n        super(path,\n                MessagingExtension.getResourceDescriptionResolver(CommonAttributes.QUEUE),\n                runtimeOnly ? null : QueueAdd.INSTANCE,\n                runtimeOnly ? null : QueueRemove.INSTANCE,\n                runtimeOnly);\n        this.runtimeOnly = runtimeOnly;\n    }","commit_id":"1099e613f78887950c3d23ebc74653d364c75f92","url":"https://github.com/wildfly/wildfly"},{"original_method":"private SecurityRoleDefinition(final boolean runtimeOnly) {\n        super(MessagingExtension.ROLE_PATH,\n                MessagingExtension.getResourceDescriptionResolver(CommonAttributes.SECURITY_ROLE),\n                runtimeOnly ? null : SecurityRoleAdd.INSTANCE,\n                runtimeOnly ? null : SecurityRoleRemove.INSTANCE);\n        this.runtimeOnly = runtimeOnly;\n    }","id":60048,"modified_method":"private SecurityRoleDefinition(final boolean runtimeOnly) {\n        super(MessagingExtension.ROLE_PATH,\n                MessagingExtension.getResourceDescriptionResolver(CommonAttributes.SECURITY_ROLE),\n                runtimeOnly ? null : SecurityRoleAdd.INSTANCE,\n                runtimeOnly ? null : SecurityRoleRemove.INSTANCE,\n                runtimeOnly);\n        this.runtimeOnly = runtimeOnly;\n    }","commit_id":"1099e613f78887950c3d23ebc74653d364c75f92","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Constructor for the {@link org.jboss.as.controller.descriptions.OverrideDescriptionProvider} case. Internationalization support is not provided.\n     *\n     * @param bundleName name to pass to {@link java.util.ResourceBundle#getBundle(String)}\n     * @param plugin     the statistics plugins\n     */\n    public StatisticsResourceDefinition(final PathElement path, final String bundleName, final StatisticsPlugin plugin) {\n        super(path, getResolver(\"statistics\", bundleName, plugin));\n        this.plugin = plugin;\n    }","id":60049,"modified_method":"/**\n     * Constructor for the {@link org.jboss.as.controller.descriptions.OverrideDescriptionProvider} case. Internationalization support is not provided.\n     *\n     * @param bundleName name to pass to {@link java.util.ResourceBundle#getBundle(String)}\n     * @param plugin     the statistics plugins\n     */\n    public StatisticsResourceDefinition(final PathElement path, final String bundleName, final StatisticsPlugin plugin) {\n        super(new Parameters(path, getResolver(\"statistics\", bundleName, plugin)).setRuntime());\n        this.plugin = plugin;\n    }","commit_id":"1099e613f78887950c3d23ebc74653d364c75f92","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void registerAttributes(final ManagementResourceRegistration resourceRegistration) {\n        resourceRegistration.registerReadOnlyAttribute(INSTANCE_ID, new JobOperationStepHandler() {\n            @Override\n            protected void updateModel(final OperationContext context, final ModelNode model, final JobOperator jobOperator, final String jobName) throws OperationFailedException {\n                final JobInstance jobInstance = jobOperator.getJobInstance(Long.parseLong(context.getCurrentAddressValue()));\n                model.set(jobInstance.getInstanceId());\n            }\n        });\n        resourceRegistration.registerReadOnlyAttribute(BATCH_STATUS, new JobExecutionOperationStepHandler() {\n            @Override\n            protected void updateModel(final ModelNode model, final JobExecution jobExecution) throws OperationFailedException {\n                final BatchStatus status = jobExecution.getBatchStatus();\n                if (status != null) {\n                    model.set(status.toString());\n                }\n            }\n        });\n        resourceRegistration.registerReadOnlyAttribute(EXIT_STATUS, new JobExecutionOperationStepHandler() {\n            @Override\n            protected void updateModel(final ModelNode model, final JobExecution jobExecution) throws OperationFailedException {\n                final String exitStatus = jobExecution.getExitStatus();\n                if (exitStatus != null) {\n                    model.set(exitStatus);\n                }\n            }\n        });\n        resourceRegistration.registerReadOnlyAttribute(CREATE_TIME, new DateTimeFormatterOperationStepHandler() {\n            @Override\n            protected Date getDateTime(final JobExecution jobExecution) {\n                return jobExecution.getCreateTime();\n            }\n        });\n        resourceRegistration.registerReadOnlyAttribute(START_TIME, new DateTimeFormatterOperationStepHandler() {\n            @Override\n            protected Date getDateTime(final JobExecution jobExecution) {\n                return jobExecution.getStartTime();\n            }\n        });\n        resourceRegistration.registerReadOnlyAttribute(LAST_UPDATED_TIME, new DateTimeFormatterOperationStepHandler() {\n            @Override\n            protected Date getDateTime(final JobExecution jobExecution) {\n                return jobExecution.getLastUpdatedTime();\n            }\n        });\n        resourceRegistration.registerReadOnlyAttribute(END_TIME, new DateTimeFormatterOperationStepHandler() {\n            @Override\n            protected Date getDateTime(final JobExecution jobExecution) {\n                return jobExecution.getEndTime();\n            }\n        });\n    }","id":60050,"modified_method":"@Override\n    public void registerAttributes(final ManagementResourceRegistration resourceRegistration) {\n        resourceRegistration.registerReadOnlyAttribute(INSTANCE_ID, new JobOperationUpdateStepHandler() {\n            @Override\n            protected void updateModel(final OperationContext context, final ModelNode model, final JobOperator jobOperator, final String jobName) throws OperationFailedException {\n                final JobInstance jobInstance = jobOperator.getJobInstance(Long.parseLong(context.getCurrentAddressValue()));\n                model.set(jobInstance.getInstanceId());\n            }\n        });\n        resourceRegistration.registerReadOnlyAttribute(BATCH_STATUS, new JobExecutionOperationStepHandler() {\n            @Override\n            protected void updateModel(final ModelNode model, final JobExecution jobExecution) throws OperationFailedException {\n                final BatchStatus status = jobExecution.getBatchStatus();\n                if (status != null) {\n                    model.set(status.toString());\n                }\n            }\n        });\n        resourceRegistration.registerReadOnlyAttribute(EXIT_STATUS, new JobExecutionOperationStepHandler() {\n            @Override\n            protected void updateModel(final ModelNode model, final JobExecution jobExecution) throws OperationFailedException {\n                final String exitStatus = jobExecution.getExitStatus();\n                if (exitStatus != null) {\n                    model.set(exitStatus);\n                }\n            }\n        });\n        resourceRegistration.registerReadOnlyAttribute(CREATE_TIME, new DateTimeFormatterOperationStepHandler() {\n            @Override\n            protected Date getDateTime(final JobExecution jobExecution) {\n                return jobExecution.getCreateTime();\n            }\n        });\n        resourceRegistration.registerReadOnlyAttribute(START_TIME, new DateTimeFormatterOperationStepHandler() {\n            @Override\n            protected Date getDateTime(final JobExecution jobExecution) {\n                return jobExecution.getStartTime();\n            }\n        });\n        resourceRegistration.registerReadOnlyAttribute(LAST_UPDATED_TIME, new DateTimeFormatterOperationStepHandler() {\n            @Override\n            protected Date getDateTime(final JobExecution jobExecution) {\n                return jobExecution.getLastUpdatedTime();\n            }\n        });\n        resourceRegistration.registerReadOnlyAttribute(END_TIME, new DateTimeFormatterOperationStepHandler() {\n            @Override\n            protected Date getDateTime(final JobExecution jobExecution) {\n                return jobExecution.getEndTime();\n            }\n        });\n    }","commit_id":"89ab55be9060eb25a107d44c84e8aa16ab9e57a4","url":"https://github.com/wildfly/wildfly"},{"original_method":"public BatchJobExecutionResourceDefinition() {\n        super(PathElement.pathElement(EXECUTION), BatchResourceDescriptionResolver.getResourceDescriptionResolver(\"deployment\", \"job\", \"execution\"));\n    }","id":60051,"modified_method":"public BatchJobExecutionResourceDefinition() {\n        super(new Parameters(PathElement.pathElement(EXECUTION), DEFAULT_RESOLVER).setRuntime());\n    }","commit_id":"89ab55be9060eb25a107d44c84e8aa16ab9e57a4","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void registerAttributes(final ManagementResourceRegistration resourceRegistration) {\n        resourceRegistration.registerReadOnlyAttribute(RUNNING_EXECUTIONS, new JobOperationStepHandler() {\n            @Override\n            protected void updateModel(final OperationContext context, final ModelNode model, final JobOperator jobOperator, final String jobName) throws OperationFailedException {\n                model.set(jobOperator.getRunningExecutions(jobName).size());\n            }\n        });\n        resourceRegistration.registerReadOnlyAttribute(INSTANCE_COUNT, new JobOperationStepHandler() {\n            @Override\n            protected void updateModel(final OperationContext context, final ModelNode model, final JobOperator jobOperator, final String jobName) throws OperationFailedException {\n                model.set(jobOperator.getJobInstanceCount(jobName));\n            }\n        });\n    }","id":60052,"modified_method":"@Override\n    public void registerAttributes(final ManagementResourceRegistration resourceRegistration) {\n        resourceRegistration.registerReadOnlyAttribute(RUNNING_EXECUTIONS, new JobOperationUpdateStepHandler() {\n            @Override\n            protected void updateModel(final OperationContext context, final ModelNode model, final JobOperator jobOperator, final String jobName) throws OperationFailedException {\n                model.set(jobOperator.getRunningExecutions(jobName).size());\n            }\n        });\n        resourceRegistration.registerReadOnlyAttribute(INSTANCE_COUNT, new JobOperationUpdateStepHandler() {\n            @Override\n            protected void updateModel(final OperationContext context, final ModelNode model, final JobOperator jobOperator, final String jobName) throws OperationFailedException {\n                model.set(jobOperator.getJobInstanceCount(jobName));\n            }\n        });\n    }","commit_id":"89ab55be9060eb25a107d44c84e8aa16ab9e57a4","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void initialize(final ExtensionContext context) {\n        final SubsystemRegistration subsystem = context.registerSubsystem(BatchSubsystemDefinition.NAME, CURRENT_MODEL_VERSION);\n        subsystem.registerSubsystemModel(new BatchSubsystemDefinition(context.isRuntimeOnlyRegistrationValid()));\n        subsystem.registerXMLElementWriter(new BatchSubsystemWriter());\n        // Register the deployment resources\n        if (context.isRuntimeOnlyRegistrationValid()) {\n            final SimpleResourceDefinition deploymentResource = new SimpleResourceDefinition(\n                    BatchSubsystemDefinition.SUBSYSTEM_PATH,\n                    BatchResourceDescriptionResolver.getResourceDescriptionResolver(\"deployment\"));\n            final ManagementResourceRegistration deployments = subsystem.registerDeploymentModel(deploymentResource);\n            final ManagementResourceRegistration jobRegistration = deployments.registerSubModel(BatchJobResourceDefinition.INSTANCE);\n            jobRegistration.registerSubModel(new BatchJobExecutionResourceDefinition()).setRuntimeOnly(true);\n        }\n\n    }","id":60053,"modified_method":"@Override\n    public void initialize(final ExtensionContext context) {\n        final SubsystemRegistration subsystem = context.registerSubsystem(BatchSubsystemDefinition.NAME, CURRENT_MODEL_VERSION);\n        subsystem.registerSubsystemModel(new BatchSubsystemDefinition(context.isRuntimeOnlyRegistrationValid()));\n        subsystem.registerXMLElementWriter(new BatchSubsystemWriter());\n        // Register the deployment resources\n        if (context.isRuntimeOnlyRegistrationValid()) {\n            final ManagementResourceRegistration deployments = subsystem.registerDeploymentModel(new BatchDeploymentResourceDefinition());\n            final ManagementResourceRegistration jobRegistration = deployments.registerSubModel(BatchJobResourceDefinition.INSTANCE);\n            jobRegistration.registerSubModel(new BatchJobExecutionResourceDefinition()).setRuntimeOnly(true);\n        }\n\n    }","commit_id":"89ab55be9060eb25a107d44c84e8aa16ab9e57a4","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void writeItems(final List<Object> items) throws Exception {\n        writtenItems.addAll(items);\n        if (sleep > 0) {\n            TimeUnit.MILLISECONDS.sleep(sleep);\n        }\n    }","id":60054,"modified_method":"@Override\n    public void writeItems(final List<Object> items) throws Exception {\n        counter.increment(items.size());\n        if (sleep > 0) {\n            TimeUnit.MILLISECONDS.sleep(sleep);\n        }\n    }","commit_id":"89ab55be9060eb25a107d44c84e8aa16ab9e57a4","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public Serializable checkpointInfo() throws Exception {\n        synchronized (writtenItems) {\n            return new ArrayList<>(writtenItems);\n        }\n    }","id":60055,"modified_method":"@Override\n    public Serializable checkpointInfo() throws Exception {\n        return counter;\n    }","commit_id":"89ab55be9060eb25a107d44c84e8aa16ab9e57a4","url":"https://github.com/wildfly/wildfly"},{"original_method":"public int getWrittenItemSize() {\n        return writtenItems.size();\n    }","id":60056,"modified_method":"public int getWrittenItemSize() {\n        return counter.get();\n    }","commit_id":"89ab55be9060eb25a107d44c84e8aa16ab9e57a4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Updates the model with information from the {@link javax.batch.operations.JobOperator JobOperator}.\n     *\n     * @param context     the operation context used\n     * @param model       the model to update\n     * @param jobOperator the job operator\n     * @param jobName     the name of the job\n     *\n     * @throws OperationFailedException if an update failure occurs\n     */\n    protected abstract void updateModel(OperationContext context, ModelNode model, JobOperator jobOperator, String jobName) throws OperationFailedException;","id":60057,"modified_method":"/**\n     * Executes the step. Includes the {@linkplain JobOperator} for convenience.\n     *\n     * @param context     the operation context used\n     * @param operation   the operation for the step\n     * @param jobOperator the job operator\n     *\n     * @throws OperationFailedException if there is a step failure\n     */\n    protected abstract void execute(OperationContext context, ModelNode operation, JobOperator jobOperator) throws OperationFailedException;","commit_id":"89ab55be9060eb25a107d44c84e8aa16ab9e57a4","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public final void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n        final PathAddress address = context.getCurrentAddress();\n        final ServiceController<?> controller = context.getServiceRegistry(false).getService(BatchServiceNames.jobOperatorServiceName(address));\n        final JobOperator jobOperator = (JobOperator) controller.getService();\n        final String jobName = getJobName(address);\n        updateModel(context, context.getResult(), jobOperator, jobName);\n    }","id":60058,"modified_method":"@Override\n    public final void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n        final PathAddress address = context.getCurrentAddress();\n        final ServiceController<?> controller = context.getServiceRegistry(false).getService(BatchServiceNames.jobOperatorServiceName(address));\n        final JobOperator jobOperator = (JobOperator) controller.getService();\n        execute(context, operation, jobOperator);\n    }","commit_id":"89ab55be9060eb25a107d44c84e8aa16ab9e57a4","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void actionPerformed(ActionEvent e)\n    {\n        JMenuItem menuItem = (JMenuItem) e.getSource();\n\n        String statusMessage = \"\";\n\n        if (menuItem.equals(newMessageItem))\n        {\n            NewStatusMessageDialog dialog\n                = new NewStatusMessageDialog(protocolProvider);\n\n            dialog.setLocation(\n                Toolkit.getDefaultToolkit().getScreenSize().width/2\n                    - dialog.getWidth()/2,\n                Toolkit.getDefaultToolkit().getScreenSize().height/2\n                    - dialog.getHeight()/2\n                );\n\n            dialog.setVisible(true);\n\n            dialog.requestFocusInFiled();\n        }\n        else if (menuItem.equals(busyMessageItem))\n        {\n            statusMessage = BUSY_MESSAGE;\n        }\n        else if (menuItem.equals(brbMessageItem))\n        {\n            statusMessage = BRB_MESSAGE;\n        }\n\n        new PublishStatusMessageThread(statusMessage).start();\n    }","id":60059,"modified_method":"public void actionPerformed(ActionEvent e)\n    {\n        Object menuItem = e.getSource();\n\n        String statusMessage = \"\";\n\n        if (menuItem.equals(newMessageItem))\n        {\n            NewStatusMessageDialog dialog =\n                new NewStatusMessageDialog(protocolProvider);\n            Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n\n            dialog.setLocation(screenSize.width / 2 - dialog.getWidth() / 2,\n                screenSize.height / 2 - dialog.getHeight() / 2);\n\n            dialog.setVisible(true);\n\n            dialog.requestFocusInFiled();\n        }\n        else if (menuItem.equals(busyMessageItem))\n        {\n            statusMessage = BUSY_MESSAGE;\n        }\n        else if (menuItem.equals(brbMessageItem))\n        {\n            statusMessage = BRB_MESSAGE;\n        }\n\n        new PublishStatusMessageThread(statusMessage).start();\n    }","commit_id":"af2587049ca5cfa8b143559adb9d1d71398f837a","url":"https://github.com/jitsi/jitsi"},{"original_method":"public StatusMessageMenu(  ProtocolProviderService protocolProvider)\n    {\n        super(Resources.getString(\"service.gui.SET_STATUS_MESSAGE\"));\n\n        this.protocolProvider = protocolProvider;\n\n        this.noMessageItem.addActionListener(this);\n        this.newMessageItem.addActionListener(this);\n        this.busyMessageItem.addActionListener(this);\n        this.brbMessageItem.addActionListener(this);\n\n        this.add(noMessageItem);\n        this.add(newMessageItem);\n\n        this.addSeparator();\n\n        this.add(busyMessageItem);\n        this.add(brbMessageItem);\n    }","id":60060,"modified_method":"public StatusMessageMenu(ProtocolProviderService protocolProvider,\n        boolean swing)\n    {\n        this.protocolProvider = protocolProvider;\n\n        String text = Resources.getString(\"service.gui.SET_STATUS_MESSAGE\");\n        if (swing)\n            menu = new JMenu(text);\n        else\n            menu = new Menu(text);\n\n        createMenuItem(Resources.getString(\"service.gui.NO_MESSAGE\"));\n        newMessageItem =\n            createMenuItem(Resources.getString(\"service.gui.NEW_MESSAGE\"));\n\n        addSeparator();\n\n        busyMessageItem = createMenuItem(BUSY_MESSAGE);\n        brbMessageItem = createMenuItem(BRB_MESSAGE);\n    }","commit_id":"af2587049ca5cfa8b143559adb9d1d71398f837a","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Stops the timer that manages the connecting animated icon.\n     */\n    public void updateStatus(PresenceStatus presenceStatus)\n    {\n        logger.trace(\"Systray update status for provider: \"\n            + provider.getAccountID().getAccountAddress()\n            + \". The new status will be: \" + presenceStatus.getStatusName());\n\n        this.setIcon(new ImageIcon(presenceStatus.getStatusIcon()));\n    }","id":60061,"modified_method":"/**\n     * Stops the timer that manages the connecting animated icon.\n     */\n    public void updateStatus(PresenceStatus presenceStatus)\n    {\n        logger.trace(\"Systray update status for provider: \"\n            + provider.getAccountID().getAccountAddress()\n            + \". The new status will be: \" + presenceStatus.getStatusName());\n\n        if (menu instanceof AbstractButton)\n            ((AbstractButton) menu).setIcon(new ImageIcon(presenceStatus\n                .getStatusIcon()));\n    }","commit_id":"af2587049ca5cfa8b143559adb9d1d71398f837a","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Change the status of the protocol according to\n     * the menu item selected\n     * @param evt the event containing the menu item name\n     */\n    public void actionPerformed(ActionEvent evt)\n    {\n        JMenuItem menuItem = (JMenuItem) evt.getSource();\n\n        Iterator statusSet = presence.getSupportedStatusSet();\n\n        while (statusSet.hasNext()) \n        {\n            PresenceStatus status = ((PresenceStatus) statusSet.next());\n\n            if (status.getStatusName().equals(menuItem.getText())) \n            {\n                \n                if (this.provider.getRegistrationState()\n                        == RegistrationState.REGISTERED\n                    && !presence.getPresenceStatus().equals(status))\n                {\n                    if (status.isOnline()) \n                    {\n                        new PublishPresenceStatusThread(status).start();\n                    }\n                    else\n                    {\n                        new ProviderUnRegistration(this.provider).start();\n                    }\n                }\n                else if (this.provider.getRegistrationState()\n                            != RegistrationState.REGISTERED\n                        && this.provider.getRegistrationState()\n                            != RegistrationState.REGISTERING\n                        && this.provider.getRegistrationState()\n                            != RegistrationState.AUTHENTICATING\n                        && status.isOnline())\n                {\n                    new ProviderRegistration(provider).start();\n                }\n                else\n                {\n                    if(!status.isOnline()\n                        && !(this.provider.getRegistrationState()\n                        == RegistrationState.UNREGISTERING))\n                    {\n                        new ProviderUnRegistration(this.provider).start();\n                    }\n                }    \n                \n                parentSystray.saveStatusInformation(\n                    provider, status.getStatusName());\n                \n                break;\n            }\n        }\n    }","id":60062,"modified_method":"/**\n     * Change the status of the protocol according to the menu item selected\n     * \n     * @param evt the event containing the menu item name\n     */\n    public void actionPerformed(ActionEvent evt)\n    {\n        Object source = evt.getSource();\n        String menuItemText;\n        if (source instanceof AbstractButton)\n            menuItemText = ((AbstractButton) source).getText();\n        else\n            menuItemText = ((MenuItem) source).getLabel();\n\n        Iterator statusSet = presence.getSupportedStatusSet();\n\n        while (statusSet.hasNext())\n        {\n            PresenceStatus status = (PresenceStatus) statusSet.next();\n\n            if (status.getStatusName().equals(menuItemText))\n            {\n                RegistrationState registrationState =\n                    provider.getRegistrationState();\n\n                if (registrationState == RegistrationState.REGISTERED\n                    && !presence.getPresenceStatus().equals(status))\n                {\n                    if (status.isOnline())\n                        new PublishPresenceStatusThread(status).start();\n                    else\n                        new ProviderUnRegistration(this.provider).start();\n                }\n                else if (registrationState != RegistrationState.REGISTERED\n                    && registrationState != RegistrationState.REGISTERING\n                    && registrationState != RegistrationState.AUTHENTICATING\n                    && status.isOnline())\n                {\n                    new ProviderRegistration(provider).start();\n                }\n                else if (!status.isOnline()\n                    && !(registrationState == RegistrationState.UNREGISTERING))\n                {\n                    new ProviderUnRegistration(this.provider).start();\n                }\n\n                parentSystray.saveStatusInformation(provider, status\n                    .getStatusName());\n\n                break;\n            }\n        }\n    }","commit_id":"af2587049ca5cfa8b143559adb9d1d71398f837a","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates an instance of StatusSelector\n     * \n     * @param jdicSystray a reference of the parent <tt>Systray<\/tt>\n     * @param provider the protocol provider\n     * @param presence the presence status\n     */\n    public StatusSelector(  SystrayServiceJdicImpl jdicSystray,\n                            ProtocolProviderService provider,\n                            OperationSetPresence presence)\n    {\n        this.parentSystray = jdicSystray;\n        this.provider = provider;\n        this.presence = presence;\n\n        this.statusMessageMenu = new StatusMessageMenu(provider);\n        /* the parent item */\n\n        this.setText(provider.getAccountID().getUserID());\n        this.setIcon(new ImageIcon(\n                presence.getPresenceStatus().getStatusIcon()));\n\n        /* the submenu itself */\n\n        Iterator statusIterator = this.presence.getSupportedStatusSet();\n\n        while(statusIterator.hasNext()) \n        {\n            PresenceStatus status = (PresenceStatus) statusIterator.next();\n\n            ImageIcon icon = new ImageIcon(status.getStatusIcon());\n            JMenuItem item = new JMenuItem(status.getStatusName(),icon);\n\n            item.addActionListener(this);\n\n            this.add(item);\n        }\n\n        this.addSeparator();\n\n        this.add(statusMessageMenu);\n    }","id":60063,"modified_method":"/**\n     * Creates an instance of StatusSelector\n     * \n     * @param jdicSystray a reference of the parent <tt>Systray<\/tt>\n     * @param provider the protocol provider\n     * @param presence the presence status\n     */\n    public StatusSelector(SystrayServiceJdicImpl jdicSystray,\n        ProtocolProviderService provider, OperationSetPresence presence,\n        boolean swing)\n    {\n        this.parentSystray = jdicSystray;\n        this.provider = provider;\n        this.presence = presence;\n\n        /* the parent item */\n        {\n            String text = provider.getAccountID().getUserID();\n            if (swing)\n            {\n                JMenu menu = new JMenu(text);\n                menu.setIcon(new ImageIcon(presence.getPresenceStatus()\n                    .getStatusIcon()));\n\n                this.menu = menu;\n            }\n            else\n            {\n                this.menu = new Menu(text);\n            }\n        }\n\n        /* the submenu itself */\n\n        Iterator statusIterator = this.presence.getSupportedStatusSet();\n\n        while (statusIterator.hasNext())\n        {\n            PresenceStatus status = (PresenceStatus) statusIterator.next();\n            String text = status.getStatusName();\n\n            if (menu instanceof Container)\n            {\n                ImageIcon icon = new ImageIcon(status.getStatusIcon());\n                JMenuItem item = new JMenuItem(text, icon);\n\n                item.addActionListener(this);\n\n                ((Container) menu).add(item);\n            }\n            else\n            {\n                MenuItem item = new MenuItem(text);\n                item.addActionListener(this);\n                ((Menu) menu).add(item);\n            }\n        }\n\n        addSeparator();\n\n        StatusSubMenu.addMenuItem(menu, new StatusMessageMenu(provider, swing)\n            .getMenu());\n    }","commit_id":"af2587049ca5cfa8b143559adb9d1d71398f837a","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Change the status of the protocol according to\n     * the menu item selected\n     * @param evt the event containing the menu item name\n     */\n    public void actionPerformed(ActionEvent evt)\n    {\n\n        JMenuItem menuItem = (JMenuItem) evt.getSource();\n        String itemName = menuItem.getName();\n\n        if(itemName.equals(\"online\")) \n        {\n            if(!this.provider.isRegistered()) \n            {\n                new ProviderRegistration(provider).start();\n            }\n        }\n        else \n        {\n            if(    !this.provider.getRegistrationState()\n                            .equals(RegistrationState.UNREGISTERED)\n                && !this.provider.getRegistrationState()\n                            .equals(RegistrationState.UNREGISTERING))\n            {\n                new ProviderUnRegistration(this.provider).start();\n            }\n        }\n    }","id":60064,"modified_method":"/**\n     * Change the status of the protocol according to\n     * the menu item selected\n     * @param evt the event containing the menu item name\n     */\n    public void actionPerformed(ActionEvent evt)\n    {\n        Object source = evt.getSource();\n        String itemName;\n        if (source instanceof Component)\n            itemName = ((Component) source).getName();\n        else\n            itemName = ((MenuComponent) source).getName();\n\n        if(itemName.equals(\"online\")) \n        {\n            if(!this.provider.isRegistered()) \n            {\n                new ProviderRegistration(provider).start();\n            }\n        }\n        else \n        {\n            if(    !this.provider.getRegistrationState()\n                            .equals(RegistrationState.UNREGISTERED)\n                && !this.provider.getRegistrationState()\n                            .equals(RegistrationState.UNREGISTERING))\n            {\n                new ProviderUnRegistration(this.provider).start();\n            }\n        }\n    }","commit_id":"af2587049ca5cfa8b143559adb9d1d71398f837a","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Stops the timer that manages the connecting animated icon.\n     */\n    public void updateStatus(PresenceStatus presenceStatus)\n    {\n        logger.trace(\"Systray update status for provider: \"\n            + provider.getAccountID().getAccountAddress()\n            + \". The new status will be: \" + presenceStatus.getStatusName());\n\n        this.setIcon(new ImageIcon(presenceStatus.getStatusIcon()));\n    }","id":60065,"modified_method":"/**\n     * Stops the timer that manages the connecting animated icon.\n     */\n    public void updateStatus(PresenceStatus presenceStatus)\n    {\n        logger.trace(\"Systray update status for provider: \"\n            + provider.getAccountID().getAccountAddress()\n            + \". The new status will be: \" + presenceStatus.getStatusName());\n\n        if (menu instanceof AbstractButton)\n            ((AbstractButton) menu).setIcon(new ImageIcon(presenceStatus\n                .getStatusIcon()));\n    }","commit_id":"af2587049ca5cfa8b143559adb9d1d71398f837a","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates an instance of <tt>StatusSimpleSelector<\/tt>\n     * \n     * @param jdicSystray a reference of the parent <tt>Systray<\/tt>\n     * @param protocolProvider the protocol provider\n     */\n    public StatusSimpleSelector(SystrayServiceJdicImpl jdicSystray,\n                                ProtocolProviderService protocolProvider)\n    {\n\n        this.provider = protocolProvider;\n        this.parentSystray = jdicSystray;\n\n        /* the parent item */\n\n        ImageIcon icon;\n\n        if(provider.isRegistered())\n        {\n            icon = new ImageIcon(protocolProvider.getProtocolIcon()\n                .getIcon(ProtocolIcon.ICON_SIZE_16x16));\n        }\n        else\n        {\n            icon = new ImageIcon(LightGrayFilter.createDisabledImage(\n                new ImageIcon(protocolProvider.getProtocolIcon()\n                    .getIcon(ProtocolIcon.ICON_SIZE_16x16)).getImage()));\n        }\n\n        this.setText(provider.getAccountID().getUserID());\n        this.setIcon(icon);\n\n        /* the menu itself */\n\n        this.onlineItem.addActionListener(this);\n        this.offlineItem.addActionListener(this);\n\n        this.onlineItem.setName(\"online\");\n        this.offlineItem.setName(\"offline\");\n\n        this.add(onlineItem);\n        this.add(offlineItem);\n    }","id":60066,"modified_method":"/**\n     * Creates an instance of <tt>StatusSimpleSelector<\/tt>\n     * \n     * @param protocolProvider the protocol provider\n     */\n    public StatusSimpleSelector(ProtocolProviderService protocolProvider,\n        boolean swing)\n    {\n        this.provider = protocolProvider;\n\n        /* the parent item */\n        String text = provider.getAccountID().getUserID();\n        if (swing)\n        {\n            JMenu menu = new JMenu(text);\n\n            ImageIcon icon =\n                new ImageIcon(protocolProvider.getProtocolIcon().getIcon(\n                    ProtocolIcon.ICON_SIZE_16x16));\n            if (!provider.isRegistered())\n            {\n                icon =\n                    new ImageIcon(LightGrayFilter.createDisabledImage(icon\n                        .getImage()));\n            }\n            menu.setIcon(icon);\n\n            this.menu = menu;\n        }\n        else\n        {\n            this.menu = new Menu(text);\n        }\n\n        /* the menu itself */\n        createMenuItem(\"impl.systray.ONLINE_STATUS\", \"online\");\n        createMenuItem(\"impl.systray.OFFLINE_STATUS\", \"offline\");\n    }","commit_id":"af2587049ca5cfa8b143559adb9d1d71398f837a","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n         * When a service is registered or unregistered, we update\n         * the provider tables and add/remove listeners (if it supports\n         * BasicInstantMessenging implementation)\n         *\n         * @param event ServiceEvent\n         */\n        public void serviceChanged(ServiceEvent event)\n        {\n            //if the event is caused by a bundle being stopped, we don't want to\n            //know\n            if(event.getServiceReference().getBundle().getState()\n                == Bundle.STOPPING)\n            {\n                return;\n            }\n\n            Object service = SystrayActivator.bundleContext\n                .getService( event.getServiceReference());\n\n            if (! (service instanceof ProtocolProviderService))\n                return;\n\n            ProtocolProviderService provider = (ProtocolProviderService)service;\n\n            if (event.getType() == ServiceEvent.REGISTERED)\n                addAccount(provider);\n\n            if (event.getType() == ServiceEvent.UNREGISTERING)\n               removeAccount(provider);\n        }","id":60067,"modified_method":"/**\n         * When a service is registered or unregistered, we update\n         * the provider tables and add/remove listeners (if it supports\n         * BasicInstantMessenging implementation)\n         *\n         * @param event ServiceEvent\n         */\n        public void serviceChanged(ServiceEvent event)\n        {\n            //if the event is caused by a bundle being stopped, we don't want to\n            //know\n            if(event.getServiceReference().getBundle().getState()\n                == Bundle.STOPPING)\n            {\n                return;\n            }\n\n            Object service = SystrayActivator.bundleContext\n                .getService( event.getServiceReference());\n\n            if (! (service instanceof ProtocolProviderService))\n                return;\n\n            ProtocolProviderService provider = (ProtocolProviderService)service;\n\n            switch (event.getType())\n            {\n            case ServiceEvent.REGISTERED:\n                addAccount(provider);\n                break;\n\n            case ServiceEvent.UNREGISTERING:\n                removeAccount(provider);\n                break;\n            }\n        }","commit_id":"af2587049ca5cfa8b143559adb9d1d71398f837a","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Removes the account corresponding to the given protocol provider from\n     * this menu.\n     * \n     * @param protocolProvider the protocol provider corresponding to the\n     * account to remove.\n     */\n    private void removeAccount(ProtocolProviderService protocolProvider)\n    {\n        Component c = (Component) this.accountSelectors\n            .get(protocolProvider.getAccountID());\n\n        this.remove(c);\n    }","id":60068,"modified_method":"/**\n     * Removes the account corresponding to the given protocol provider from\n     * this menu.\n     * \n     * @param protocolProvider the protocol provider corresponding to the\n     * account to remove.\n     */\n    private void removeAccount(ProtocolProviderService protocolProvider)\n    {\n        Object selector =\n            this.accountSelectors.get(protocolProvider.getAccountID());\n\n        if (menu instanceof Container)\n            ((Container) menu).remove((Component) selector);\n        else\n            ((MenuContainer) menu).remove((MenuComponent) selector);\n    }","commit_id":"af2587049ca5cfa8b143559adb9d1d71398f837a","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Adds the account corresponding to the given protocol provider to this\n     * menu.\n     * \n     * @param protocolProvider the protocol provider corresponding to the\n     * account to add\n     */\n    private void addAccount(ProtocolProviderService protocolProvider)\n    {\n        OperationSetPresence presence = (OperationSetPresence)\n            protocolProvider.getOperationSet(OperationSetPresence.class);\n\n        if (presence == null)\n        {\n            StatusSimpleSelector simpleSelector = \n                new StatusSimpleSelector(parentSystray, protocolProvider);\n\n            this.accountSelectors.put(  protocolProvider.getAccountID(),\n                                        simpleSelector);\n            this.add(simpleSelector);\n        }\n        else\n        {\n            StatusSelector statusSelector = \n                new StatusSelector( parentSystray,\n                                    protocolProvider,\n                                    presence);\n\n            this.accountSelectors.put(  protocolProvider.getAccountID(),\n                                        statusSelector);\n            this.add(statusSelector);\n\n            presence.addProviderPresenceStatusListener(\n                new SystrayProviderPresenceStatusListener());\n        }\n    }","id":60069,"modified_method":"/**\n     * Adds the account corresponding to the given protocol provider to this\n     * menu.\n     * \n     * @param protocolProvider the protocol provider corresponding to the\n     *            account to add\n     */\n    private void addAccount(ProtocolProviderService protocolProvider)\n    {\n        OperationSetPresence presence =\n            (OperationSetPresence) protocolProvider\n                .getOperationSet(OperationSetPresence.class);\n        boolean swing = (menu instanceof JComponent);\n\n        if (presence == null)\n        {\n            StatusSimpleSelector simpleSelector =\n                new StatusSimpleSelector(protocolProvider, swing);\n\n            this.accountSelectors.put(protocolProvider.getAccountID(),\n                simpleSelector);\n            addMenuItem(menu, simpleSelector.getMenu());\n        }\n        else\n        {\n            StatusSelector statusSelector =\n                new StatusSelector(parentSystray, protocolProvider, presence,\n                    swing);\n\n            this.accountSelectors.put(protocolProvider.getAccountID(),\n                statusSelector);\n            addMenuItem(menu, statusSelector.getMenu());\n\n            presence\n                .addProviderPresenceStatusListener(new SystrayProviderPresenceStatusListener());\n        }\n    }","commit_id":"af2587049ca5cfa8b143559adb9d1d71398f837a","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates an instance of <tt>StatusSubMenu<\/tt>.\n     * @param tray a reference of the parent <tt>Systray<\/tt>\n     */\n    public StatusSubMenu(SystrayServiceJdicImpl tray)\n    {\n        \n        parentSystray = tray;\n\n        this.setText(Resources.getString(\"impl.systray.SET_STATUS\"));\n        this.setIcon(Resources.getImage(\"service.systray.STATUS_MENU_ICON\"));\n\n        /* makes the menu look better */\n        this.setPreferredSize(new java.awt.Dimension(28, 24));\n\n        this.init();\n    }","id":60070,"modified_method":"/**\n     * Creates an instance of <tt>StatusSubMenu<\/tt>.\n     * \n     * @param tray a reference of the parent <tt>Systray<\/tt>\n     * @param swing <tt>true<\/tt> to represent this instance with a Swing\n     *            <code>JMenu<\/code>; <tt>false<\/tt> to use an AWT\n     *            <code>Menu<\/code>\n     */\n    public StatusSubMenu(SystrayServiceJdicImpl tray, boolean swing)\n    {\n        parentSystray = tray;\n\n        String text = Resources.getString(\"impl.systray.SET_STATUS\");\n        if (swing)\n        {\n            JMenu menu = new JMenu(text);\n            menu\n                .setIcon(Resources.getImage(\"service.systray.STATUS_MENU_ICON\"));\n\n            /* makes the menu look better */\n            menu.setPreferredSize(new java.awt.Dimension(28, 24));\n\n            this.menu = menu;\n        }\n        else\n        {\n            this.menu = new Menu(text);\n        }\n\n        this.init();\n    }","commit_id":"af2587049ca5cfa8b143559adb9d1d71398f837a","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Sets a new Systray icon.\n     *\n     * @param imageType the type of the image to set.\n     */\n    public void setSystrayIcon(int imageType)\n    {\n        if(!checkInitialized())\n            return;\n\n        String osName = System.getProperty(\"os.name\");\n\n        ImageIcon toChangeSystrayIcon = null;\n\n        if (imageType == SystrayService.SC_IMG_TYPE)\n        {\n            if (osName.startsWith(\"Mac OS X\") && this.menu.isVisible())\n            {\n                toChangeSystrayIcon = logoIconWhite;\n            }\n            else\n            {\n                toChangeSystrayIcon = logoIcon;\n            }\n        }\n        else if (imageType == SystrayService.SC_IMG_OFFLINE_TYPE)\n        {\n            if (!osName.startsWith(\"Mac OS X\"))\n            {\n                toChangeSystrayIcon = logoIconOffline;\n            }\n        }\n        else if (imageType == SystrayService.SC_IMG_AWAY_TYPE)\n        {\n            if (!osName.startsWith(\"Mac OS X\"))\n            {\n                toChangeSystrayIcon = logoIconAway;\n            }\n        }\n        else if (imageType == SystrayService.SC_IMG_FFC_TYPE)\n        {\n            if (!osName.startsWith(\"Mac OS X\"))\n            {\n                toChangeSystrayIcon = logoIconFFC;\n            }\n        }\n        else if (imageType == SystrayService.ENVELOPE_IMG_TYPE)\n        {\n            if (osName.startsWith(\"Mac OS X\") && this.menu.isVisible())\n            {\n                toChangeSystrayIcon = envelopeIconWhite;\n            }\n            else\n            {\n                toChangeSystrayIcon = envelopeIcon;\n            }\n        }\n\n        if(toChangeSystrayIcon != null)\n        {\n            this.trayIcon.setIcon(toChangeSystrayIcon);\n            this.currentIcon = toChangeSystrayIcon;\n        }\n\n        if (osName.startsWith(\"Mac OS X\"))\n        {\n            URL toChangeDockIcon = null;\n            switch(imageType)\n            {\n                case SystrayService.SC_IMG_TYPE:\n                    // online will restore the original image\n                    break;\n                case SystrayService.SC_IMG_OFFLINE_TYPE :\n                    toChangeDockIcon = dockIconOffline; break;\n                case SystrayService.SC_IMG_AWAY_TYPE :\n                    toChangeDockIcon = dockIconAway; break;\n                case SystrayService.SC_IMG_FFC_TYPE :\n                    toChangeDockIcon = dockIconFFC; break;\n            }\n\n            try\n            {\n                if(toChangeDockIcon != null)\n                {\n                    Dock.setDockTileImage(toChangeDockIcon);\n                }\n                else\n                    Dock.restoreDockTileImage();\n            }\n            catch (Exception e)\n            {\n                logger.error(\"failed to change dock icon\", e);\n            }\n        }\n    }","id":60071,"modified_method":"/**\n     * Sets a new Systray icon.\n     *\n     * @param imageType the type of the image to set.\n     */\n    public void setSystrayIcon(int imageType)\n    {\n        if(!checkInitialized())\n            return;\n\n        String osName = System.getProperty(\"os.name\");\n\n        ImageIcon toChangeSystrayIcon = null;\n\n        if (imageType == SystrayService.SC_IMG_TYPE)\n        {\n            if (osName.startsWith(\"Mac OS X\")\n                && TrayMenuFactory.isVisible(menu))\n            {\n                toChangeSystrayIcon = logoIconWhite;\n            }\n            else\n            {\n                toChangeSystrayIcon = logoIcon;\n            }\n        }\n        else if (imageType == SystrayService.SC_IMG_OFFLINE_TYPE)\n        {\n            if (!osName.startsWith(\"Mac OS X\"))\n            {\n                toChangeSystrayIcon = logoIconOffline;\n            }\n        }\n        else if (imageType == SystrayService.SC_IMG_AWAY_TYPE)\n        {\n            if (!osName.startsWith(\"Mac OS X\"))\n            {\n                toChangeSystrayIcon = logoIconAway;\n            }\n        }\n        else if (imageType == SystrayService.SC_IMG_FFC_TYPE)\n        {\n            if (!osName.startsWith(\"Mac OS X\"))\n            {\n                toChangeSystrayIcon = logoIconFFC;\n            }\n        }\n        else if (imageType == SystrayService.ENVELOPE_IMG_TYPE)\n        {\n            if (osName.startsWith(\"Mac OS X\")\n                && TrayMenuFactory.isVisible(menu))\n            {\n                toChangeSystrayIcon = envelopeIconWhite;\n            }\n            else\n            {\n                toChangeSystrayIcon = envelopeIcon;\n            }\n        }\n\n        if(toChangeSystrayIcon != null)\n        {\n            this.trayIcon.setIcon(toChangeSystrayIcon);\n            this.currentIcon = toChangeSystrayIcon;\n        }\n\n        if (osName.startsWith(\"Mac OS X\"))\n        {\n            URL toChangeDockIcon = null;\n            switch(imageType)\n            {\n                case SystrayService.SC_IMG_TYPE:\n                    // online will restore the original image\n                    break;\n                case SystrayService.SC_IMG_OFFLINE_TYPE :\n                    toChangeDockIcon = dockIconOffline; break;\n                case SystrayService.SC_IMG_AWAY_TYPE :\n                    toChangeDockIcon = dockIconAway; break;\n                case SystrayService.SC_IMG_FFC_TYPE :\n                    toChangeDockIcon = dockIconFFC; break;\n            }\n\n            try\n            {\n                if(toChangeDockIcon != null)\n                {\n                    Dock.setDockTileImage(toChangeDockIcon);\n                }\n                else\n                    Dock.restoreDockTileImage();\n            }\n            catch (Exception e)\n            {\n                logger.error(\"failed to change dock icon\", e);\n            }\n        }\n    }","commit_id":"af2587049ca5cfa8b143559adb9d1d71398f837a","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Initializes the systray icon and related listeners.\n     */\n    private void initSystray()\n    {\n        popupTimer.scheduleAtFixedRate(new ShowPopupTask(), 0, messageDelay);\n\n        // Get the system's double click speed\n        Object o = Toolkit.getDefaultToolkit().getDesktopProperty(\n                \"awt.multiClickInterval\");\n        final int doubleClickSpeed = (o instanceof Integer ? ((Integer) o)\n                .intValue() : 500);\n\n        menu = new TrayMenu(this);\n\n        String osName = System.getProperty(\"os.name\");\n        // If we're running under Windows, we use a special icon without\n        // background.\n        if (osName.startsWith(\"Windows\"))\n        {\n            logoIcon\n                = Resources.getImage(\"service.systray.TRAY_ICON_WINDOWS\");\n            logoIconOffline\n                = Resources.getImage(\"service.systray.TRAY_ICON_WINDOWS_OFFLINE\");\n            logoIconAway\n                = Resources.getImage(\"service.systray.TRAY_ICON_WINDOWS_AWAY\");\n            logoIconFFC\n                = Resources.getImage(\"service.systray.TRAY_ICON_WINDOWS_FFC\");\n            envelopeIcon\n                = Resources.getImage(\"service.systray.MESSAGE_ICON_WINDOWS\");\n        }\n\n        // If we're running under MacOSX, we use a special black and\n        // white icons without background.\n        else if (osName.startsWith(\"Mac OS X\"))\n        {\n            logoIcon\n                = Resources.getImage(\"service.systray.TRAY_ICON_MACOSX\");\n            logoIconWhite\n                = Resources.getImage(\"service.systray.TRAY_ICON_MACOSX_WHITE\");\n            envelopeIcon\n                = Resources.getImage(\"service.systray.MESSAGE_ICON_MACOSX\");\n            envelopeIconWhite\n                = Resources.getImage(\"service.systray.MESSAGE_ICON_MACOSX_WHITE\");\n        }\n        else\n        {\n            logoIcon = Resources.getImage(\"service.systray.TRAY_ICON\");\n            logoIconOffline = Resources.getImage(\"service.systray.TRAY_ICON_OFFLINE\");\n            logoIconAway = Resources.getImage(\"service.systray.TRAY_ICON_AWAY\");\n            logoIconFFC = Resources.getImage(\"service.systray.TRAY_ICON_FFC\");\n            envelopeIcon = Resources.getImage(\"service.systray.MESSAGE_ICON\");\n        }\n\n        if (!osName.startsWith(\"Mac OS X\"))\n        {\n            // default to set offline , if any protocols become\n            // online will set it to online\n            currentIcon = logoIconOffline;\n        }\n        else\n            currentIcon = logoIcon;\n\n        trayIcon = new TrayIcon(\n            currentIcon,\n            Resources.getApplicationString(\"service.gui.APPLICATION_NAME\"),\n            menu);\n\n        trayIcon.setIconAutoSize(true);\n\n        if (osName.startsWith(\"Mac OS X\"))\n        {\n            // init dock Icons\n            dockIconOffline\n                = Resources.getImageURL(\"service.systray.DOCK_ICON_OFFLINE\");\n            dockIconAway\n                = Resources.getImageURL(\"service.systray.DOCK_ICON_AWAY\");\n            dockIconFFC\n                = Resources.getImageURL(\"service.systray.DOCK_ICON_FFC\");\n        }\n\n        //Show/hide the contact list when user clicks on the systray.\n        trayIcon.addActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                long currentTime = System.currentTimeMillis();\n                UIService uiService = SystrayActivator.getUIService();\n\n                boolean isVisible;\n\n                isVisible = ! uiService.isVisible();\n                if (isVisible) {\n                    setVisibleTime = currentTime;\n                }\n                else if (currentTime < (setVisibleTime + doubleClickSpeed))\n                {\n                    // Do nothing. the last restore is less than 2 seconds, so it is very\n                    // likely, that the user made a double click. prevent the main window\n                    // from opening and immediately closing again.\n                    return;\n                }\n\n                uiService.setVisible(isVisible);\n\n                ConfigurationService configService\n                    = SystrayActivator.getConfigurationService();\n\n                configService.setProperty(\n                        \"net.java.sip.communicator.impl.systray.showApplication\",\n                        Boolean.toString(isVisible));\n            }\n        });\n\n        // Change the MacOSX icon with the white one when the popup\n        // menu appears\n        if (osName.startsWith(\"Mac OS X\"))\n        {\n            menu.addPopupMenuListener(new PopupMenuListener()\n            {\n                public void popupMenuWillBecomeVisible(PopupMenuEvent e)\n                {\n                    if (currentIcon == envelopeIcon)\n                    {\n                        trayIcon.setIcon(envelopeIconWhite);\n                        currentIcon = envelopeIconWhite;\n                    }\n                    else\n                    {\n                        trayIcon.setIcon(logoIconWhite);\n                        currentIcon = logoIconWhite;\n                    }\n                }\n\n                public void popupMenuWillBecomeInvisible(PopupMenuEvent e)\n                {\n                    if (currentIcon == envelopeIconWhite)\n                    {\n                        trayIcon.setIcon(envelopeIcon);\n                        currentIcon = envelopeIcon;\n                    }\n                    else\n                    {\n                        trayIcon.setIcon(logoIcon);\n                        currentIcon = logoIcon;\n                    }\n                }\n\n                public void popupMenuCanceled(PopupMenuEvent e)\n                {\n                    popupMenuWillBecomeInvisible(e);\n                }\n            });\n        }\n\n        //Notify all interested listener that user has clicked on the systray\n        //popup message.\n        trayIcon.addBalloonActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                UIService uiService = SystrayActivator.getUIService();\n\n                firePopupMessageEvent(e.getSource());\n\n                ExportedWindow chatWindow\n                    = uiService.getExportedWindow(ExportedWindow.CHAT_WINDOW);\n\n                if(chatWindow != null && chatWindow.isVisible())\n                {\n                    chatWindow.bringToFront();\n                }\n            }\n        });\n\n        systray.addTrayIcon(trayIcon);\n\n        initialized = true;\n    }","id":60072,"modified_method":"/**\n     * Initializes the systray icon and related listeners.\n     */\n    private void initSystray()\n    {\n        popupTimer.scheduleAtFixedRate(new ShowPopupTask(), 0, messageDelay);\n\n        // Get the system's double click speed\n        Object o = Toolkit.getDefaultToolkit().getDesktopProperty(\n                \"awt.multiClickInterval\");\n        final int doubleClickSpeed = (o instanceof Integer ? ((Integer) o)\n                .intValue() : 500);\n\n        menu = TrayMenuFactory.createTrayMenu(this, systray.isSwing());\n\n        String osName = System.getProperty(\"os.name\");\n        // If we're running under Windows, we use a special icon without\n        // background.\n        if (osName.startsWith(\"Windows\"))\n        {\n            logoIcon\n                = Resources.getImage(\"service.systray.TRAY_ICON_WINDOWS\");\n            logoIconOffline\n                = Resources.getImage(\"service.systray.TRAY_ICON_WINDOWS_OFFLINE\");\n            logoIconAway\n                = Resources.getImage(\"service.systray.TRAY_ICON_WINDOWS_AWAY\");\n            logoIconFFC\n                = Resources.getImage(\"service.systray.TRAY_ICON_WINDOWS_FFC\");\n            envelopeIcon\n                = Resources.getImage(\"service.systray.MESSAGE_ICON_WINDOWS\");\n        }\n\n        // If we're running under MacOSX, we use a special black and\n        // white icons without background.\n        else if (osName.startsWith(\"Mac OS X\"))\n        {\n            logoIcon\n                = Resources.getImage(\"service.systray.TRAY_ICON_MACOSX\");\n            logoIconWhite\n                = Resources.getImage(\"service.systray.TRAY_ICON_MACOSX_WHITE\");\n            envelopeIcon\n                = Resources.getImage(\"service.systray.MESSAGE_ICON_MACOSX\");\n            envelopeIconWhite\n                = Resources.getImage(\"service.systray.MESSAGE_ICON_MACOSX_WHITE\");\n        }\n        else\n        {\n            logoIcon = Resources.getImage(\"service.systray.TRAY_ICON\");\n            logoIconOffline = Resources.getImage(\"service.systray.TRAY_ICON_OFFLINE\");\n            logoIconAway = Resources.getImage(\"service.systray.TRAY_ICON_AWAY\");\n            logoIconFFC = Resources.getImage(\"service.systray.TRAY_ICON_FFC\");\n            envelopeIcon = Resources.getImage(\"service.systray.MESSAGE_ICON\");\n        }\n\n        if (!osName.startsWith(\"Mac OS X\"))\n        {\n            // default to set offline , if any protocols become\n            // online will set it to online\n            currentIcon = logoIconOffline;\n        }\n        else\n            currentIcon = logoIcon;\n\n        trayIcon = new TrayIcon(\n            currentIcon,\n            Resources.getApplicationString(\"service.gui.APPLICATION_NAME\"),\n            menu);\n\n        trayIcon.setIconAutoSize(true);\n\n        if (osName.startsWith(\"Mac OS X\"))\n        {\n            // init dock Icons\n            dockIconOffline\n                = Resources.getImageURL(\"service.systray.DOCK_ICON_OFFLINE\");\n            dockIconAway\n                = Resources.getImageURL(\"service.systray.DOCK_ICON_AWAY\");\n            dockIconFFC\n                = Resources.getImageURL(\"service.systray.DOCK_ICON_FFC\");\n        }\n\n        //Show/hide the contact list when user clicks on the systray.\n        trayIcon.addActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                long currentTime = System.currentTimeMillis();\n                UIService uiService = SystrayActivator.getUIService();\n\n                boolean isVisible;\n\n                isVisible = ! uiService.isVisible();\n                if (isVisible) {\n                    setVisibleTime = currentTime;\n                }\n                else if (currentTime < (setVisibleTime + doubleClickSpeed))\n                {\n                    // Do nothing. the last restore is less than 2 seconds, so it is very\n                    // likely, that the user made a double click. prevent the main window\n                    // from opening and immediately closing again.\n                    return;\n                }\n\n                uiService.setVisible(isVisible);\n\n                ConfigurationService configService\n                    = SystrayActivator.getConfigurationService();\n\n                configService.setProperty(\n                        \"net.java.sip.communicator.impl.systray.showApplication\",\n                        Boolean.toString(isVisible));\n            }\n        });\n\n        // Change the MacOSX icon with the white one when the popup\n        // menu appears\n        if (osName.startsWith(\"Mac OS X\"))\n        {\n            TrayMenuFactory.addPopupMenuListener(menu, new PopupMenuListener()\n            {\n                public void popupMenuWillBecomeVisible(PopupMenuEvent e)\n                {\n                    if (currentIcon == envelopeIcon)\n                    {\n                        trayIcon.setIcon(envelopeIconWhite);\n                        currentIcon = envelopeIconWhite;\n                    }\n                    else\n                    {\n                        trayIcon.setIcon(logoIconWhite);\n                        currentIcon = logoIconWhite;\n                    }\n                }\n\n                public void popupMenuWillBecomeInvisible(PopupMenuEvent e)\n                {\n                    if (currentIcon == envelopeIconWhite)\n                    {\n                        trayIcon.setIcon(envelopeIcon);\n                        currentIcon = envelopeIcon;\n                    }\n                    else\n                    {\n                        trayIcon.setIcon(logoIcon);\n                        currentIcon = logoIcon;\n                    }\n                }\n\n                public void popupMenuCanceled(PopupMenuEvent e)\n                {\n                    popupMenuWillBecomeInvisible(e);\n                }\n            });\n        }\n\n        //Notify all interested listener that user has clicked on the systray\n        //popup message.\n        trayIcon.addBalloonActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                UIService uiService = SystrayActivator.getUIService();\n\n                firePopupMessageEvent(e.getSource());\n\n                ExportedWindow chatWindow\n                    = uiService.getExportedWindow(ExportedWindow.CHAT_WINDOW);\n\n                if(chatWindow != null && chatWindow.isVisible())\n                {\n                    chatWindow.bringToFront();\n                }\n            }\n        });\n\n        systray.addTrayIcon(trayIcon);\n\n        initialized = true;\n    }","commit_id":"af2587049ca5cfa8b143559adb9d1d71398f837a","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Starts this bundle\n     *\n     * @param bundleContext BundleContext\n     * @throws Exception\n     */\n    public void start(BundleContext bundleContext) throws Exception\n    {\n        try\n        {\n            logger.logEntry();\n            UpdateCheckActivator.bundleContext = bundleContext;\n        }\n        finally\n        {\n            logger.logExit();\n        }\n\n        String osName = System.getProperty(\"os.name\");\n\n        if (osName.startsWith(\"Windows\"))\n        {\n            // register update button\n            Hashtable<String, String> toolsMenuFilter\n                = new Hashtable<String, String>();\n            toolsMenuFilter.put( Container.CONTAINER_ID,\n                                 Container.CONTAINER_TOOLS_MENU.getID());\n\n            bundleContext.registerService(\n                PluginComponent.class.getName(),\n                new UpdateMenuButtonComponent(\n                    Container.CONTAINER_TOOLS_MENU),\n                toolsMenuFilter);\n        }\n\n        if(isNewestVersion())\n            return;\n\n        if (osName.startsWith(\"Windows\"))\n        {\n            windowsUpdaterShow();\n            return;\n        }\n\n        final JDialog dialog = new SIPCommDialog()\n        {\n            protected void close(boolean isEscaped)\n            {\n            }\n        };\n        dialog.setTitle(\n            getResources().getI18NString(\"plugin.updatechecker.DIALOG_TITLE\"));\n\n        JEditorPane contentMessage = new JEditorPane();\n        contentMessage.setContentType(\"text/html\");\n        contentMessage.setOpaque(false);\n        contentMessage.setEditable(false);\n\n        String dialogMsg =\n            getResources().getI18NString(\"plugin.updatechecker.DIALOG_MESSAGE\",\n            new String[]{getResources()\n                .getSettingsString(\"service.gui.APPLICATION_NAME\")});\n\n        if(lastVersion != null)\n            dialogMsg +=\n                getResources().getI18NString(\n                \"plugin.updatechecker.DIALOG_MESSAGE_2\",\n                new String[]{\n                    getResources().getSettingsString(\n                        \"service.gui.APPLICATION_NAME\"),\n                    lastVersion});\n\n        contentMessage.setText(dialogMsg);\n\n        JPanel contentPane = new TransparentPanel(new BorderLayout(5,5));\n        contentPane.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n        contentPane.add(contentMessage, BorderLayout.CENTER);\n\n        JPanel buttonPanel\n            = new TransparentPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));\n        JButton closeButton = new JButton(\n            getResources().getI18NString(\"plugin.updatechecker.BUTTON_CLOSE\"));\n\n        closeButton.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e)\n            {\n                dialog.setVisible(false);\n            }\n        });\n\n        if(downloadLink != null)\n        {\n            JButton downloadButton = new JButton(getResources().getI18NString(\n                \"plugin.updatechecker.BUTTON_DOWNLOAD\"));\n\n            downloadButton.addActionListener(new ActionListener() {\n\n                public void actionPerformed(ActionEvent e)\n                {\n                    getBrowserLauncher().openURL(downloadLink);\n                    dialog.dispose();\n                }\n            });\n\n            buttonPanel.add(downloadButton);\n        }\n\n        buttonPanel.add(closeButton);\n\n        contentPane.add(buttonPanel, BorderLayout.SOUTH);\n\n        dialog.setContentPane(contentPane);\n\n        dialog.pack();\n\n        dialog.setLocation(\n            Toolkit.getDefaultToolkit().getScreenSize().width/2\n                - dialog.getWidth()/2,\n            Toolkit.getDefaultToolkit().getScreenSize().height/2\n                - dialog.getHeight()/2\n        );\n\n        dialog.setVisible(true);\n    }","id":60073,"modified_method":"/**\n     * Starts this bundle\n     *\n     * @param bundleContext BundleContext\n     * @throws Exception\n     */\n    public void start(BundleContext bundleContext) throws Exception\n    {\n        try\n        {\n            logger.logEntry();\n            UpdateCheckActivator.bundleContext = bundleContext;\n        }\n        finally\n        {\n            logger.logExit();\n        }\n\n        String osName = System.getProperty(\"os.name\");\n\n        if (osName.startsWith(\"Windows\"))\n        {\n            // register update button\n            Hashtable<String, String> toolsMenuFilter\n                = new Hashtable<String, String>();\n            toolsMenuFilter.put( Container.CONTAINER_ID,\n                                 Container.CONTAINER_HELP_MENU.getID());\n\n            bundleContext.registerService(\n                PluginComponent.class.getName(),\n                new UpdateMenuButtonComponent(\n                    Container.CONTAINER_HELP_MENU),\n                toolsMenuFilter);\n        }\n\n        if(isNewestVersion())\n            return;\n\n        if (osName.startsWith(\"Windows\"))\n        {\n            windowsUpdaterShow();\n            return;\n        }\n\n        final JDialog dialog = new SIPCommDialog()\n        {\n            protected void close(boolean isEscaped)\n            {\n            }\n        };\n        dialog.setTitle(\n            getResources().getI18NString(\"plugin.updatechecker.DIALOG_TITLE\"));\n\n        JEditorPane contentMessage = new JEditorPane();\n        contentMessage.setContentType(\"text/html\");\n        contentMessage.setOpaque(false);\n        contentMessage.setEditable(false);\n\n        String dialogMsg =\n            getResources().getI18NString(\"plugin.updatechecker.DIALOG_MESSAGE\",\n            new String[]{getResources()\n                .getSettingsString(\"service.gui.APPLICATION_NAME\")});\n\n        if(lastVersion != null)\n            dialogMsg +=\n                getResources().getI18NString(\n                \"plugin.updatechecker.DIALOG_MESSAGE_2\",\n                new String[]{\n                    getResources().getSettingsString(\n                        \"service.gui.APPLICATION_NAME\"),\n                    lastVersion});\n\n        contentMessage.setText(dialogMsg);\n\n        JPanel contentPane = new TransparentPanel(new BorderLayout(5,5));\n        contentPane.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n        contentPane.add(contentMessage, BorderLayout.CENTER);\n\n        JPanel buttonPanel\n            = new TransparentPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));\n        JButton closeButton = new JButton(\n            getResources().getI18NString(\"plugin.updatechecker.BUTTON_CLOSE\"));\n\n        closeButton.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e)\n            {\n                dialog.setVisible(false);\n            }\n        });\n\n        if(downloadLink != null)\n        {\n            JButton downloadButton = new JButton(getResources().getI18NString(\n                \"plugin.updatechecker.BUTTON_DOWNLOAD\"));\n\n            downloadButton.addActionListener(new ActionListener() {\n\n                public void actionPerformed(ActionEvent e)\n                {\n                    getBrowserLauncher().openURL(downloadLink);\n                    dialog.dispose();\n                }\n            });\n\n            buttonPanel.add(downloadButton);\n        }\n\n        buttonPanel.add(closeButton);\n\n        contentPane.add(buttonPanel, BorderLayout.SOUTH);\n\n        dialog.setContentPane(contentPane);\n\n        dialog.pack();\n\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n        dialog.setLocation(\n            screenSize.width/2 - dialog.getWidth()/2,\n            screenSize.height/2 - dialog.getHeight()/2\n        );\n\n        dialog.setVisible(true);\n    }","commit_id":"5fdbc090d64604033b770c62f26ae0526a483239","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * The update process itself.\n     * - Downloads the installer in a temp directory.\n     * - Warns that update will shutdown.\n     * - Trigers update (installer) in separate process with the help\n     * of update.exe and shutdowns.\n     */\n    private void windowsUpdate()\n    {\n        File tempF = null;\n        try\n        {\n            final File temp = File.createTempFile(\"sc-install\", \".exe\");\n            tempF = temp;\n\n            URL u = new URL(downloadLink);\n            HttpURLConnection uc = (HttpURLConnection)u.openConnection();\n\n            if(uc.getResponseCode() == HttpURLConnection.HTTP_UNAUTHORIZED)\n            {\n                new Thread(new Runnable()\n                {\n                    public void run()\n                    {\n                        ExportedWindow authWindow =\n                            getUIService().getExportedWindow(\n                                ExportedWindow.AUTHENTICATION_WINDOW);\n\n                        UserCredentials cred = new UserCredentials();\n                        authWindow.setParams(new Object[]{cred});\n                        authWindow.setVisible(true);\n\n                        userCredentials = cred;\n\n                        if(cred.getUserName() == null)\n                        {\n                            userCredentials = null;\n                        }\n                        else\n                            windowsUpdate();\n                    }\n                }).start();\n            }\n            else if(uc.getResponseCode() == HttpURLConnection.HTTP_OK\n                    && userCredentials != null\n                    && userCredentials.getUserName() != null\n                    && userCredentials.isPasswordPersistent())\n            {\n                // if save password is checked save the pass\n                getConfigurationService().setProperty(\n                        UPDATE_USERNAME_CONFIG, userCredentials.getUserName());\n                getConfigurationService().setProperty(\n                        UPDATE_PASSWORD_CONFIG, new String(Base64.encode(\n                            userCredentials.getPasswordAsString().getBytes())));\n            }\n            InputStream in = uc.getInputStream();\n\n            // Chain a ProgressMonitorInputStream to the\n            // URLConnection's InputStream\n            final ProgressMonitorInputStream pin\n             = new ProgressMonitorInputStream(null, u.toString(), in);\n\n            // Set the maximum value of the ProgressMonitor\n            ProgressMonitor pm = pin.getProgressMonitor();\n            pm.setMaximum(uc.getContentLength());\n\n            final BufferedOutputStream out =\n                    new BufferedOutputStream(new FileOutputStream(temp));\n            new Thread(new Runnable()\n            {\n                public void run()\n                {\n                    try\n                    {\n                        int read = -1;\n                        byte[] buff = new byte[1024];\n                        while((read = pin.read(buff)) != -1)\n                        {\n                            out.write(buff, 0, read);\n                        }\n                        pin.close();\n                        out.flush();\n                        out.close();\n\n                        if(getUIService().getPopupDialog().showConfirmPopupDialog(\n                            getResources().getI18NString(\n                                \"plugin.updatechecker.DIALOG_WARN\"),\n                            getResources().getI18NString(\n                                \"plugin.updatechecker.DIALOG_TITLE\"),\n                            PopupDialog.YES_NO_OPTION,\n                            PopupDialog.QUESTION_MESSAGE\n                            ) != PopupDialog.YES_OPTION)\n                        {\n                            return;\n                        }\n\n                        // file saved. Now start updater and shutdown.\n                        String workingDir = System.getProperty(\"user.dir\");\n                        new ProcessBuilder(\n                            new String[]{\n                                workingDir + File.separator + \"updater.exe\",\n                                temp.getCanonicalPath()}).start();\n                        getUIService().beginShutdown();\n\n                    } catch (Exception e)\n                    {\n                        logger.error(\"Error saving\", e);\n                        try\n                        {\n                            pin.close();\n                            out.close();\n                        } catch (Exception e1)\n                        {}\n                    }\n                }\n            }).start();\n\n        }\n        catch(FileNotFoundException e)\n        {\n            getUIService().getPopupDialog().showMessagePopupDialog(\n                getResources().getI18NString(\"plugin.updatechecker.DIALOG_MISSING_UPDATE\"),\n                getResources().getI18NString(\"plugin.updatechecker.DIALOG_NOUPDATE_TITLE\"),\n                PopupDialog.INFORMATION_MESSAGE);\n            tempF.delete();\n        }\n        catch (Exception e)\n        {\n            logger.info(\"Error starting update process!\", e);\n            tempF.delete();\n        }\n    }","id":60074,"modified_method":"/**\n     * The update process itself.\n     * - Downloads the installer in a temp directory.\n     * - Warns that update will shutdown.\n     * - Triggers update (installer) in separate process with the help\n     * of update.exe and shutdowns.\n     */\n    private void windowsUpdate()\n    {\n        File tempF = null;\n        try\n        {\n            final File temp = File.createTempFile(\"sc-install\", \".exe\");\n            tempF = temp;\n\n            URL u = new URL(downloadLink);\n            URLConnection uc = u.openConnection();\n\n            if (uc instanceof HttpURLConnection)\n            {\n                int responseCode = ((HttpURLConnection) uc).getResponseCode();\n\n                if(responseCode == HttpURLConnection.HTTP_UNAUTHORIZED)\n                {\n                    new Thread(new Runnable()\n                    {\n                        public void run()\n                        {\n                            ExportedWindow authWindow =\n                                getUIService().getExportedWindow(\n                                    ExportedWindow.AUTHENTICATION_WINDOW);\n\n                            UserCredentials cred = new UserCredentials();\n                            authWindow.setParams(new Object[]{cred});\n                            authWindow.setVisible(true);\n\n                            userCredentials = cred;\n\n                            if(cred.getUserName() == null)\n                            {\n                                userCredentials = null;\n                            }\n                            else\n                                windowsUpdate();\n                        }\n                    }).start();\n                }\n                else if(responseCode == HttpURLConnection.HTTP_OK\n                        && userCredentials != null\n                        && userCredentials.getUserName() != null\n                        && userCredentials.isPasswordPersistent())\n                {\n                    // if save password is checked save the pass\n                    getConfigurationService().setProperty(\n                        UPDATE_USERNAME_CONFIG, userCredentials.getUserName());\n                    getConfigurationService().setProperty(\n                        UPDATE_PASSWORD_CONFIG, new String(Base64.encode(\n                            userCredentials.getPasswordAsString().getBytes())));\n                }\n            }\n\n            InputStream in = uc.getInputStream();\n\n            // Chain a ProgressMonitorInputStream to the\n            // URLConnection's InputStream\n            final ProgressMonitorInputStream pin\n             = new ProgressMonitorInputStream(null, u.toString(), in);\n\n            // Set the maximum value of the ProgressMonitor\n            ProgressMonitor pm = pin.getProgressMonitor();\n            pm.setMaximum(uc.getContentLength());\n\n            final BufferedOutputStream out =\n                    new BufferedOutputStream(new FileOutputStream(temp));\n            new Thread(new Runnable()\n            {\n                public void run()\n                {\n                    try\n                    {\n                        int read = -1;\n                        byte[] buff = new byte[1024];\n                        while((read = pin.read(buff)) != -1)\n                        {\n                            out.write(buff, 0, read);\n                        }\n                        pin.close();\n                        out.flush();\n                        out.close();\n\n                        if(getUIService().getPopupDialog().showConfirmPopupDialog(\n                            getResources().getI18NString(\n                                \"plugin.updatechecker.DIALOG_WARN\"),\n                            getResources().getI18NString(\n                                \"plugin.updatechecker.DIALOG_TITLE\"),\n                            PopupDialog.YES_NO_OPTION,\n                            PopupDialog.QUESTION_MESSAGE\n                            ) != PopupDialog.YES_OPTION)\n                        {\n                            return;\n                        }\n\n                        // file saved. Now start updater and shutdown.\n                        String workingDir = System.getProperty(\"user.dir\");\n                        ProcessBuilder processBuilder\n                            = new ProcessBuilder(\n                                new String[]\n                                {\n                                    workingDir + File.separator + \"updater.exe\",\n                                    temp.getCanonicalPath()\n                                });\n                        processBuilder.environment().put(\n                            \"SIP_COMMUNICATOR_AUTOUPDATE_INSTALLDIR\",\n                            workingDir);\n                        processBuilder.start();\n\n                        getUIService().beginShutdown();\n\n                    } catch (Exception e)\n                    {\n                        logger.error(\"Error saving\", e);\n                        try\n                        {\n                            pin.close();\n                            out.close();\n                        } catch (Exception e1)\n                        {}\n                    }\n                }\n            }).start();\n\n        }\n        catch(FileNotFoundException e)\n        {\n            getUIService().getPopupDialog().showMessagePopupDialog(\n                getResources().getI18NString(\"plugin.updatechecker.DIALOG_MISSING_UPDATE\"),\n                getResources().getI18NString(\"plugin.updatechecker.DIALOG_NOUPDATE_TITLE\"),\n                PopupDialog.INFORMATION_MESSAGE);\n            tempF.delete();\n        }\n        catch (Exception e)\n        {\n            logger.info(\"Error starting update process!\", e);\n            tempF.delete();\n        }\n    }","commit_id":"5fdbc090d64604033b770c62f26ae0526a483239","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void paintComponent(Graphics g)\n    {\n        super.paintComponent(g);\n\n        Graphics2D g2 = (Graphics2D) g;\n\n        AntialiasingManager.activateAntialiasing(g2);\n\n        GradientPaint p = new GradientPaint(this.getWidth()/2, 0,\n                                            startBgColor,\n                                            this.getWidth()/2, this.getHeight(),\n                                            endBgColor);\n\n        FadeTracker fadeTracker = FadeTracker.getInstance();\n\n        g2.setPaint(p);\n        g2.fillRoundRect(0, 0,\n            this.getWidth() - 1,\n            this.getHeight() - 1, 15, 15);\n\n        g2.setColor(baseStartColor);\n        g2.drawRoundRect(0, 0,\n            this.getWidth() - 1,\n            this.getHeight() - 1, 15, 15);\n    }","id":60075,"modified_method":"public void paintComponent(Graphics g)\n    {\n        super.paintComponent(g);\n\n        Graphics2D g2 = (Graphics2D) g;\n\n        AntialiasingManager.activateAntialiasing(g2);\n\n        int width = getWidth();\n        int height = getHeight();\n        GradientPaint p =\n            new GradientPaint(width / 2, 0, startBgColor, width / 2, height,\n                endBgColor);\n\n        FadeTracker fadeTracker = FadeTracker.getInstance();\n\n        g2.setPaint(p);\n        g2.fillRoundRect(0, 0, width - 1, height - 1, 15, 15);\n\n        g2.setColor(baseStartColor);\n        g2.drawRoundRect(0, 0, width - 1, height - 1, 15, 15);\n    }","commit_id":"475b401890ff81f3bf51ff22a18ad926f1deff22","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Implements the <tt>ListCellRenderer<\/tt> method.\n     * \n     * Returns this panel that has been configured to display the meta contact\n     * and meta contact group cells.\n     */\n    public Component getListCellRendererComponent(JList list, Object value,\n            int index, boolean isSelected, boolean cellHasFocus)\n    {\n        this.index = index;\n\n        this.photoLabel.setIcon(null);\n\n        ContactList contactList = (ContactList) list;\n\n        if (value instanceof MetaContact)\n        {\n            this.setPreferredSize(new Dimension(20, 30));\n\n            MetaContact metaContact = (MetaContact) value;\n\n            String displayName = metaContact.getDisplayName();\n\n            if (displayName == null || displayName.length() < 1)\n            {\n                displayName = Messages.getI18NString(\"unknown\").getText();\n            }\n\n            this.nameLabel.setText(displayName);\n\n            if(contactList.isMetaContactActive(metaContact))\n            {\n                statusIcon.setImage(msgReceivedImage);\n            }\n            else\n            {\n                statusIcon.setImage(Constants.getStatusIcon(\n                    contactList.getMetaContactStatus(metaContact)));\n            }\n\n            this.nameLabel.setIcon(statusIcon);\n\n            this.nameLabel.setFont(this.getFont().deriveFont(Font.PLAIN));\n\n            if (contactForegroundColor != null)\n                this.nameLabel.setForeground(contactForegroundColor);\n\n            this.setBorder(BorderFactory.createEmptyBorder(1, 5, 1, 3));\n\n            byte[] avatar = metaContact.getAvatar(true);\n            if (avatar != null && avatar.length > 0)\n            {\n                ImageIcon roundedAvatar\n                    = ImageUtils.getScaledRoundedImage( avatar,\n                                                        AVATAR_WIDTH,\n                                                        AVATAR_HEIGHT);\n\n                if (roundedAvatar != null)\n                    this.photoLabel.setIcon(roundedAvatar);\n            }\n\n            // We should set the bounds of the cell explicitely in order to\n            // make getComponentAt work properly.\n            this.setBounds(0, 0, list.getWidth() - 2, 30);\n\n            this.nameLabel.setBounds(\n                    0, 0, list.getWidth() - 28, 17);\n            this.photoLabel.setBounds(\n                list.getWidth() - 28, 0, 25, 30);\n\n            this.isLeaf = true;\n        }\n        else if (value instanceof MetaContactGroup)\n        {\n            this.setPreferredSize(new Dimension(20, 20));\n\n            MetaContactGroup groupItem = (MetaContactGroup) value;\n\n            this.nameLabel.setText(groupItem.getGroupName() \n                    + \"  ( \" + groupItem.countChildContacts() + \" )\");\n\n            this.nameLabel.setFont(this.getFont().deriveFont(Font.BOLD));\n\n            if (groupForegroundColor != null)\n                this.nameLabel.setForeground(groupForegroundColor);\n\n            this.setBorder(BorderFactory.createEmptyBorder(2, 5, 2, 2));\n\n            // We should set the bounds of the cell explicitely in order to\n            // make getComponentAt work properly.\n            this.setBounds(0, 0, list.getWidth() - 2, 20);\n\n            if(((ContactListModel)list.getModel()).isGroupClosed(groupItem))\n                this.nameLabel.setIcon(closedGroupIcon);\n            else\n                this.nameLabel.setIcon(openedGroupIcon);\n\n            // We have no photo icon for groups.\n            this.photoLabel.setIcon(null);\n\n            this.isLeaf = false;\n        }\n\n        this.isSelected = isSelected;\n\n        return this;\n    }","id":60076,"modified_method":"/**\n     * Implements the <tt>ListCellRenderer<\/tt> method.\n     * \n     * Returns this panel that has been configured to display the meta contact\n     * and meta contact group cells.\n     */\n    public Component getListCellRendererComponent(JList list, Object value,\n            int index, boolean isSelected, boolean cellHasFocus)\n    {\n        this.index = index;\n\n        this.photoLabel.setIcon(null);\n\n        ContactList contactList = (ContactList) list;\n\n        if (value instanceof MetaContact)\n        {\n            this.setPreferredSize(new Dimension(20, 30));\n\n            MetaContact metaContact = (MetaContact) value;\n\n            String displayName = metaContact.getDisplayName();\n\n            if (displayName == null || displayName.length() < 1)\n            {\n                displayName = Messages.getI18NString(\"unknown\").getText();\n            }\n\n            this.nameLabel.setText(displayName);\n\n            if(contactList.isMetaContactActive(metaContact))\n            {\n                statusIcon.setImage(msgReceivedImage);\n            }\n            else\n            {\n                statusIcon.setImage(Constants.getStatusIcon(\n                    contactList.getMetaContactStatus(metaContact)));\n            }\n\n            this.nameLabel.setIcon(statusIcon);\n\n            this.nameLabel.setFont(this.getFont().deriveFont(Font.PLAIN));\n\n            if (contactForegroundColor != null)\n                this.nameLabel.setForeground(contactForegroundColor);\n\n            this.setBorder(BorderFactory.createEmptyBorder(1, 5, 1, 3));\n\n            byte[] avatar = metaContact.getAvatar(true);\n            if (avatar != null && avatar.length > 0)\n            {\n                ImageIcon roundedAvatar\n                    = ImageUtils.getScaledRoundedImage( avatar,\n                                                        AVATAR_WIDTH,\n                                                        AVATAR_HEIGHT);\n\n                if (roundedAvatar != null)\n                    this.photoLabel.setIcon(roundedAvatar);\n            }\n\n            // We should set the bounds of the cell explicitly in order to\n            // make getComponentAt work properly.\n            final int listWidth = list.getWidth();\n            this.setBounds(0, 0, listWidth - 2, 30);\n\n            this.nameLabel.setBounds(0, 0, listWidth - 28, 17);\n            this.photoLabel.setBounds(listWidth - 28, 0, 25, 30);\n\n            this.isLeaf = true;\n        }\n        else if (value instanceof MetaContactGroup)\n        {\n            this.setPreferredSize(new Dimension(20, 20));\n\n            MetaContactGroup groupItem = (MetaContactGroup) value;\n\n            this.nameLabel.setText(groupItem.getGroupName() \n                    + \"  ( \" + groupItem.countChildContacts() + \" )\");\n\n            this.nameLabel.setFont(this.getFont().deriveFont(Font.BOLD));\n\n            if (groupForegroundColor != null)\n                this.nameLabel.setForeground(groupForegroundColor);\n\n            this.setBorder(BorderFactory.createEmptyBorder(2, 5, 2, 2));\n\n            // We should set the bounds of the cell explicitly in order to\n            // make getComponentAt work properly.\n            this.setBounds(0, 0, list.getWidth() - 2, 20);\n\n            if(((ContactListModel)list.getModel()).isGroupClosed(groupItem))\n                this.nameLabel.setIcon(closedGroupIcon);\n            else\n                this.nameLabel.setIcon(openedGroupIcon);\n\n            // We have no photo icon for groups.\n            this.photoLabel.setIcon(null);\n\n            this.isLeaf = false;\n        }\n\n        this.isSelected = isSelected;\n\n        return this;\n    }","commit_id":"475b401890ff81f3bf51ff22a18ad926f1deff22","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Paint a background for all groups and a round blue border and background\n     * when a cell is selected. \n     */\n    public void paintComponent(Graphics g)\n    {\n        super.paintComponent(g);\n\n        Graphics2D g2 = (Graphics2D) g;\n\n        AntialiasingManager.activateAntialiasing(g2);\n\n        if (!this.isLeaf)\n        {\n            GradientPaint p = new GradientPaint(0,\n                0,\n                Constants.CONTACT_LIST_GROUP_BG_COLOR,\n                this.getWidth() - 5,\n                0,\n                Constants.CONTACT_LIST_GROUP_BG_GRADIENT_COLOR);\n\n            g2.setPaint(p);\n\n            g2.fillRoundRect(   1, 1,\n                                this.getWidth() - 2, this.getHeight() - 1,\n                                10, 10);\n        }\n        else if (index%2 > 0)\n        {\n            Color bgColor = new Color(GuiActivator.getResources()\n                    .getColor(\"contactListRowColor\"), true);\n\n            g2.setColor(new Color(  bgColor.getRed(),\n                                    bgColor.getGreen(),\n                                    bgColor.getBlue(),\n                                    rowTransparency));\n        }\n\n        if (this.isSelected)\n        {\n            g2.setColor(Constants.SELECTED_COLOR);\n            g2.fillRoundRect(   1, 1,\n                                this.getWidth() - 2, this.getHeight() - 1,\n                                10, 10);\n        }\n    }","id":60077,"modified_method":"/**\n     * Paint a background for all groups and a round blue border and background\n     * when a cell is selected. \n     */\n    public void paintComponent(Graphics g)\n    {\n        super.paintComponent(g);\n\n        Graphics2D g2 = (Graphics2D) g;\n\n        AntialiasingManager.activateAntialiasing(g2);\n\n        if (!this.isLeaf)\n        {\n            final int width = getWidth();\n            GradientPaint p =\n                new GradientPaint(0, 0, Constants.CONTACT_LIST_GROUP_BG_COLOR,\n                    width - 5, 0,\n                    Constants.CONTACT_LIST_GROUP_BG_GRADIENT_COLOR);\n\n            g2.setPaint(p);\n\n            g2.fillRoundRect(1, 1, width - 2, this.getHeight() - 1, 10, 10);\n        }\n        else if (index%2 > 0)\n        {\n            Color bgColor = new Color(GuiActivator.getResources()\n                    .getColor(\"contactListRowColor\"), true);\n\n            g2.setColor(new Color(  bgColor.getRed(),\n                                    bgColor.getGreen(),\n                                    bgColor.getBlue(),\n                                    rowTransparency));\n        }\n\n        if (this.isSelected)\n        {\n            g2.setColor(Constants.SELECTED_COLOR);\n            g2.fillRoundRect(   1, 1,\n                                this.getWidth() - 2, this.getHeight() - 1,\n                                10, 10);\n        }\n    }","commit_id":"475b401890ff81f3bf51ff22a18ad926f1deff22","url":"https://github.com/jitsi/jitsi"},{"original_method":"private void initPluginComponents()\n    {\n     // Search for plugin components registered through the OSGI bundle\n        // context.\n        ServiceReference[] serRefs = null;\n\n        String osgiFilter = \"(\"\n            + Container.CONTAINER_ID\n            + \"=\"+Container.CONTAINER_CONTACT_LIST.getID()+\")\";\n\n        try\n        {\n            serRefs = GuiActivator.bundleContext.getServiceReferences(\n                PluginComponent.class.getName(),\n                osgiFilter);\n        }\n        catch (InvalidSyntaxException exc)\n        {\n            logger.error(\"Could not obtain plugin reference.\", exc);\n        }\n\n        if (serRefs != null)\n        {\n            for (int i = 0; i < serRefs.length; i ++)\n            {\n                PluginComponent component = (PluginComponent) GuiActivator\n                    .bundleContext.getService(serRefs[i]);;\n\n                    Object selectedValue = mainFrame.getContactListPanel()\n                    .getContactList().getSelectedValue();\n\n                if(selectedValue instanceof MetaContact)\n                {\n                    component.setCurrentContact((MetaContact)selectedValue);\n                }\n                else if(selectedValue instanceof MetaContactGroup)\n                {\n                    component\n                        .setCurrentContactGroup((MetaContactGroup)selectedValue);\n                }\n\n                Object constraints = null;\n\n                if (component.getConstraints() != null)\n                    constraints = UIServiceImpl\n                        .getBorderLayoutConstraintsFromContainer(\n                            component.getConstraints());\n                else\n                    constraints = BorderLayout.SOUTH;\n\n                this.add((Component)component.getComponent(), constraints);\n\n                this.repaint();\n            }\n        }\n\n        GuiActivator.getUIService().addPluginComponentListener(this);\n    }","id":60078,"modified_method":"private void initPluginComponents()\n    {\n        // Search for plugin components registered through the OSGI bundle\n        // context.\n        ServiceReference[] serRefs = null;\n\n        String osgiFilter = \"(\"\n            + Container.CONTAINER_ID\n            + \"=\"+Container.CONTAINER_CONTACT_LIST.getID()+\")\";\n\n        try\n        {\n            serRefs = GuiActivator.bundleContext.getServiceReferences(\n                PluginComponent.class.getName(),\n                osgiFilter);\n        }\n        catch (InvalidSyntaxException exc)\n        {\n            logger.error(\"Could not obtain plugin reference.\", exc);\n        }\n\n        if (serRefs != null)\n        {\n            for (int i = 0; i < serRefs.length; i ++)\n            {\n                PluginComponent component = (PluginComponent) GuiActivator\n                    .bundleContext\n                        .getService(serRefs[i]);\n\n                Object selectedValue =\n                    mainFrame.getContactListPanel().getContactList()\n                        .getSelectedValue();\n\n                if(selectedValue instanceof MetaContact)\n                {\n                    component.setCurrentContact((MetaContact)selectedValue);\n                }\n                else if(selectedValue instanceof MetaContactGroup)\n                {\n                    component\n                        .setCurrentContactGroup((MetaContactGroup)selectedValue);\n                }\n\n                String pluginConstraints = component.getConstraints();\n                Object constraints = null;\n\n                if (pluginConstraints != null)\n                    constraints =\n                        UIServiceImpl\n                            .getBorderLayoutConstraintsFromContainer(pluginConstraints);\n                else\n                    constraints = BorderLayout.SOUTH;\n\n                this.add((Component)component.getComponent(), constraints);\n\n                this.repaint();\n            }\n        }\n\n        GuiActivator.getUIService().addPluginComponentListener(this);\n    }","commit_id":"475b401890ff81f3bf51ff22a18ad926f1deff22","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Initiates the content of this frame.\n     */\n    private void init()\n    {\n        if (GuiActivator.getUIService().getExitOnMainWindowClose())\n            this.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n        else\n            this.setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);\n\n        this.setKeybindingInput(KeybindingSet.Category.MAIN);\n        this.addKeybindingAction(\"main-rename\", new RenameAction());\n\n        TransparentPanel northPanel = new TransparentPanel(new BorderLayout());\n\n        TransparentPanel centerPanel\n            = new TransparentPanel(new BorderLayout(0, 0));\n\n        String isToolbarExtendedString\n            = GuiActivator.getResources().\n                getSettingsString(\"isToolBarExteneded\");\n\n        boolean isToolBarExtended\n            = new Boolean(isToolbarExtendedString).booleanValue();\n\n        JPanel menusPanel = new JPanel(new BorderLayout());\n\n        if (isToolBarExtended)\n        {\n            quickMenu = new ExtendedQuickMenu(this);\n\n            menusPanel.add(quickMenu, BorderLayout.SOUTH);\n        }\n\n        this.setJMenuBar(menu);\n\n        menusPanel.setUI(new SIPCommOpaquePanelUI());\n\n        northPanel.add(new LogoBar(), BorderLayout.NORTH);\n        northPanel.add(menusPanel, BorderLayout.CENTER);\n        northPanel.add(accountStatusPanel, BorderLayout.SOUTH);\n\n        TransparentPanel moreActionsPanel\n            = new TransparentPanel(new FlowLayout(FlowLayout.CENTER, 0, 0));\n\n        moreActionsPanel.add(moreActionsLabel);\n        moreActionsLabel.setToolTipText(GuiActivator.getResources()\n            .getI18NString(\"openTools\"));\n\n        moreActionsLabel.addMouseListener(new ActionMenuMouseListener());\n\n        centerPanel.add(moreActionsPanel, BorderLayout.NORTH);\n        centerPanel.add(contactListPanel, BorderLayout.CENTER);\n        centerPanel.add(mainCallPanel, BorderLayout.SOUTH);\n\n        this.mainPanel.add(northPanel, BorderLayout.NORTH);\n        this.mainPanel.add(centerPanel, BorderLayout.CENTER);\n\n        this.getContentPane().add(mainPanel, BorderLayout.CENTER);\n        this.getContentPane().add(statusBarPanel, BorderLayout.SOUTH);\n    }","id":60079,"modified_method":"/**\n     * Initiates the content of this frame.\n     */\n    private void init()\n    {\n        if (GuiActivator.getUIService().getExitOnMainWindowClose())\n            this.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n        else\n            this.setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);\n\n        this.setKeybindingInput(KeybindingSet.Category.MAIN);\n        this.addKeybindingAction(\"main-rename\", new RenameAction());\n\n        TransparentPanel northPanel = new TransparentPanel(new BorderLayout());\n\n        TransparentPanel centerPanel\n            = new TransparentPanel(new BorderLayout(0, 0));\n\n        String isToolbarExtendedString\n            = GuiActivator.getResources().\n                getSettingsString(\"isToolBarExteneded\");\n\n        boolean isToolBarExtended\n            = new Boolean(isToolbarExtendedString).booleanValue();\n\n        JPanel menusPanel = new JPanel(new BorderLayout());\n\n        if (isToolBarExtended)\n        {\n            quickMenu = new ExtendedQuickMenu(this);\n\n            menusPanel.add(quickMenu, BorderLayout.SOUTH);\n        }\n\n        this.setJMenuBar(menu);\n\n        menusPanel.setUI(new SIPCommOpaquePanelUI());\n\n        northPanel.add(new LogoBar(), BorderLayout.NORTH);\n        northPanel.add(menusPanel, BorderLayout.CENTER);\n        northPanel.add(accountStatusPanel, BorderLayout.SOUTH);\n\n        TransparentPanel moreActionsPanel\n            = new TransparentPanel(new FlowLayout(FlowLayout.CENTER, 0, 0));\n\n        moreActionsPanel.add(moreActionsLabel);\n        moreActionsLabel.setToolTipText(GuiActivator.getResources()\n            .getI18NString(\"openTools\"));\n\n        moreActionsLabel.addMouseListener(new ActionMenuMouseListener());\n\n        centerPanel.add(moreActionsPanel, BorderLayout.NORTH);\n        centerPanel.add(contactListPanel, BorderLayout.CENTER);\n        centerPanel.add(mainCallPanel, BorderLayout.SOUTH);\n\n        this.mainPanel.add(northPanel, BorderLayout.NORTH);\n        this.mainPanel.add(centerPanel, BorderLayout.CENTER);\n\n        java.awt.Container contentPane = getContentPane();\n        contentPane.add(mainPanel, BorderLayout.CENTER);\n        contentPane.add(statusBarPanel, BorderLayout.SOUTH);\n    }","commit_id":"475b401890ff81f3bf51ff22a18ad926f1deff22","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Adds the given component with to the container corresponding to the\n     * given constraints.\n     *\n     * @param c the component to add\n     * @param constraints the constraints determining the container\n     */\n    private void addPluginComponent(Component c,\n                                    Container container,\n                                    Object constraints)\n    {\n        if (container.equals(Container.CONTAINER_MAIN_WINDOW))\n        {\n            if (constraints.equals(BorderLayout.NORTH))\n            {\n                pluginPanelNorth.add(c);\n                pluginPanelNorth.repaint();\n            }\n            else if (constraints.equals(BorderLayout.SOUTH))\n            {\n                pluginPanelSouth.add(c);\n                pluginPanelSouth.repaint();\n            }\n            else if (constraints.equals(BorderLayout.WEST))\n            {\n                pluginPanelWest.add(c);\n                pluginPanelSouth.repaint();\n            }\n            else if (constraints.equals(BorderLayout.EAST))\n            {\n                pluginPanelEast.add(c);\n                pluginPanelSouth.repaint();\n            }\n        }\n        else if (container.equals(Container.CONTAINER_STATUS_BAR))\n        {\n            statusBarPanel.add(c);\n        }\n\n        this.getContentPane().repaint();\n    }","id":60080,"modified_method":"/**\n     * Adds the given component with to the container corresponding to the\n     * given constraints.\n     *\n     * @param c the component to add\n     * @param constraints the constraints determining the container\n     */\n    private void addPluginComponent(Component c,\n                                    Container container,\n                                    Object constraints)\n    {\n        if (container.equals(Container.CONTAINER_MAIN_WINDOW))\n        {\n            if (constraints.equals(BorderLayout.NORTH))\n            {\n                pluginPanelNorth.add(c);\n                pluginPanelNorth.repaint();\n            }\n            else if (constraints.equals(BorderLayout.SOUTH))\n            {\n                pluginPanelSouth.add(c);\n                pluginPanelSouth.repaint();\n            }\n            else if (constraints.equals(BorderLayout.WEST))\n            {\n                pluginPanelWest.add(c);\n                pluginPanelWest.repaint();\n            }\n            else if (constraints.equals(BorderLayout.EAST))\n            {\n                pluginPanelEast.add(c);\n                pluginPanelEast.repaint();\n            }\n        }\n        else if (container.equals(Container.CONTAINER_STATUS_BAR))\n        {\n            statusBarPanel.add(c);\n        }\n\n        this.getContentPane().repaint();\n    }","commit_id":"475b401890ff81f3bf51ff22a18ad926f1deff22","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void actionPerformed(ActionEvent e)\n        {\n            Object selectedObject\n                = getContactListPanel().getContactList().getSelectedValue();\n\n            if(selectedObject instanceof MetaContact) {\n                RenameContactDialog dialog = new RenameContactDialog(\n                        MainFrame.this, (MetaContact)selectedObject);\n\n                dialog.setLocation(\n                        Toolkit.getDefaultToolkit().getScreenSize().width/2\n                            - 200,\n                        Toolkit.getDefaultToolkit().getScreenSize().height/2\n                            - 50\n                        );\n\n                dialog.setVisible(true);\n\n                dialog.requestFocusInFiled();\n            }\n            else if(selectedObject instanceof MetaContactGroup) {\n\n                RenameGroupDialog dialog = new RenameGroupDialog(\n                        MainFrame.this, (MetaContactGroup)selectedObject);\n\n                dialog.setLocation(\n                        Toolkit.getDefaultToolkit().getScreenSize().width/2\n                            - 200,\n                        Toolkit.getDefaultToolkit().getScreenSize().height/2\n                            - 50\n                        );\n\n                dialog.setVisible(true);\n\n                dialog.requestFocusInFiled();\n            }\n        }","id":60081,"modified_method":"public void actionPerformed(ActionEvent e)\n        {\n            Object selectedObject\n                = getContactListPanel().getContactList().getSelectedValue();\n\n            if(selectedObject instanceof MetaContact) {\n                RenameContactDialog dialog = new RenameContactDialog(\n                        MainFrame.this, (MetaContact)selectedObject);\n\n                dialog.setLocation(\n                        Toolkit.getDefaultToolkit().getScreenSize().width/2\n                            - 200,\n                        Toolkit.getDefaultToolkit().getScreenSize().height/2\n                            - 50\n                        );\n\n                dialog.setVisible(true);\n\n                dialog.requestFocusInFiled();\n            }\n            else if(selectedObject instanceof MetaContactGroup) {\n\n                RenameGroupDialog dialog = new RenameGroupDialog(\n                        MainFrame.this, (MetaContactGroup)selectedObject);\n\n                Dimension screenSize =\n                    Toolkit.getDefaultToolkit().getScreenSize();\n                dialog.setLocation(screenSize.width / 2 - 200,\n                    screenSize.height / 2 - 50);\n\n                dialog.setVisible(true);\n\n                dialog.requestFocusInFiled();\n            }\n        }","commit_id":"475b401890ff81f3bf51ff22a18ad926f1deff22","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Adds the associated with this <tt>PluginComponentEvent<\/tt> component\n     * to the appropriate container.\n     */\n    public void pluginComponentAdded(PluginComponentEvent event)\n    {\n        PluginComponent pluginComponent = event.getPluginComponent();\n\n        if (pluginComponent.getContainer()\n                .equals(Container.CONTAINER_MAIN_WINDOW)\n            || pluginComponent.getContainer()\n                .equals(Container.CONTAINER_STATUS_BAR))\n        {\n            Object constraints = null;\n\n            if (pluginComponent.getConstraints() != null)\n                constraints = UIServiceImpl\n                    .getBorderLayoutConstraintsFromContainer(\n                        pluginComponent.getConstraints());\n            else\n                constraints = BorderLayout.SOUTH;\n\n            if (pluginComponent.isNativeComponent())\n            {\n                this.nativePluginsTable.put(pluginComponent, new JPanel());\n\n                if (isVisible())\n                {\n                    SwingUtilities.invokeLater(new Runnable()\n                    {\n                        public void run()\n                        {\n                            addNativePlugins();\n                        }\n                    });\n                }\n            }\n            else\n            {\n                this.addPluginComponent(\n                    (Component) pluginComponent.getComponent(),\n                    pluginComponent.getContainer(),\n                    constraints);\n            }\n        }\n    }","id":60082,"modified_method":"/**\n     * Adds the associated with this <tt>PluginComponentEvent<\/tt> component to\n     * the appropriate container.\n     */\n    public void pluginComponentAdded(PluginComponentEvent event)\n    {\n        PluginComponent pluginComponent = event.getPluginComponent();\n        Container pluginContainer = pluginComponent.getContainer();\n\n        if (pluginContainer.equals(Container.CONTAINER_MAIN_WINDOW)\n            || pluginContainer.equals(Container.CONTAINER_STATUS_BAR))\n        {\n            String pluginConstraints = pluginComponent.getConstraints();\n            Object constraints = null;\n\n            if (pluginConstraints != null)\n                constraints =\n                    UIServiceImpl\n                        .getBorderLayoutConstraintsFromContainer(pluginConstraints);\n            else\n                constraints = BorderLayout.SOUTH;\n\n            if (pluginComponent.isNativeComponent())\n            {\n                this.nativePluginsTable.put(pluginComponent, new JPanel());\n\n                if (isVisible())\n                {\n                    SwingUtilities.invokeLater(new Runnable()\n                    {\n                        public void run()\n                        {\n                            addNativePlugins();\n                        }\n                    });\n                }\n            }\n            else\n            {\n                this.addPluginComponent((Component) pluginComponent\n                    .getComponent(), pluginContainer, constraints);\n            }\n        }\n    }","commit_id":"475b401890ff81f3bf51ff22a18ad926f1deff22","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Initialize plugin components already registered for this container.\n     */\n    private void initPluginComponents()\n    {\n        pluginPanelSouth.setLayout(\n            new BoxLayout(pluginPanelSouth, BoxLayout.Y_AXIS));\n        pluginPanelNorth.setLayout(\n            new BoxLayout(pluginPanelNorth, BoxLayout.Y_AXIS));\n        pluginPanelEast.setLayout(\n            new BoxLayout(pluginPanelEast, BoxLayout.Y_AXIS));\n        pluginPanelWest.setLayout(\n            new BoxLayout(pluginPanelWest, BoxLayout.Y_AXIS));\n\n        this.getContentPane().add(pluginPanelNorth, BorderLayout.NORTH);\n        this.getContentPane().add(pluginPanelEast, BorderLayout.EAST);\n        this.getContentPane().add(pluginPanelWest, BorderLayout.WEST);\n        this.mainPanel.add(pluginPanelSouth, BorderLayout.SOUTH);\n\n        // Search for plugin components registered through the OSGI bundle\n        // context.\n        ServiceReference[] serRefs = null;\n\n        String osgiFilter = \"(|(\"\n            + Container.CONTAINER_ID\n            + \"=\"+Container.CONTAINER_MAIN_WINDOW.getID()+\")\"\n            + \"(\" + Container.CONTAINER_ID\n            + \"=\"+Container.CONTAINER_STATUS_BAR.getID()+\"))\";\n\n        try\n        {\n            serRefs = GuiActivator.bundleContext.getServiceReferences(\n                PluginComponent.class.getName(),\n                osgiFilter);\n        }\n        catch (InvalidSyntaxException exc)\n        {\n            logger.error(\"Could not obtain plugin reference.\", exc);\n        }\n\n        if (serRefs != null)\n        {\n            for (int i = 0; i < serRefs.length; i ++)\n            {\n                PluginComponent c = (PluginComponent) GuiActivator\n                    .bundleContext.getService(serRefs[i]);\n\n                if (c.isNativeComponent())\n                    nativePluginsTable.put(c, new JPanel());\n                else\n                {\n                    Object constraints = null;\n\n                    if (c.getConstraints() != null)\n                        constraints = UIServiceImpl\n                            .getBorderLayoutConstraintsFromContainer(\n                                c.getConstraints());\n                    else\n                        constraints = BorderLayout.SOUTH;\n\n                    this.addPluginComponent((Component) c.getComponent(),\n                                            c.getContainer(),\n                                            constraints);\n                }\n            }\n        }\n\n        GuiActivator.getUIService().addPluginComponentListener(this);\n    }","id":60083,"modified_method":"/**\n     * Initialize plugin components already registered for this container.\n     */\n    private void initPluginComponents()\n    {\n        pluginPanelSouth.setLayout(\n            new BoxLayout(pluginPanelSouth, BoxLayout.Y_AXIS));\n        pluginPanelNorth.setLayout(\n            new BoxLayout(pluginPanelNorth, BoxLayout.Y_AXIS));\n        pluginPanelEast.setLayout(\n            new BoxLayout(pluginPanelEast, BoxLayout.Y_AXIS));\n        pluginPanelWest.setLayout(\n            new BoxLayout(pluginPanelWest, BoxLayout.Y_AXIS));\n\n        java.awt.Container contentPane = getContentPane();\n        contentPane.add(pluginPanelNorth, BorderLayout.NORTH);\n        contentPane.add(pluginPanelEast, BorderLayout.EAST);\n        contentPane.add(pluginPanelWest, BorderLayout.WEST);\n        this.mainPanel.add(pluginPanelSouth, BorderLayout.SOUTH);\n\n        // Search for plugin components registered through the OSGI bundle\n        // context.\n        ServiceReference[] serRefs = null;\n\n        String osgiFilter = \"(|(\"\n            + Container.CONTAINER_ID\n            + \"=\"+Container.CONTAINER_MAIN_WINDOW.getID()+\")\"\n            + \"(\" + Container.CONTAINER_ID\n            + \"=\"+Container.CONTAINER_STATUS_BAR.getID()+\"))\";\n\n        try\n        {\n            serRefs = GuiActivator.bundleContext.getServiceReferences(\n                PluginComponent.class.getName(),\n                osgiFilter);\n        }\n        catch (InvalidSyntaxException exc)\n        {\n            logger.error(\"Could not obtain plugin reference.\", exc);\n        }\n\n        if (serRefs != null)\n        {\n            for (int i = 0; i < serRefs.length; i++)\n            {\n                PluginComponent c =\n                    (PluginComponent) GuiActivator.bundleContext\n                        .getService(serRefs[i]);\n\n                if (c.isNativeComponent())\n                    nativePluginsTable.put(c, new JPanel());\n                else\n                {\n                    String pluginConstraints = c.getConstraints();\n                    Object constraints = null;\n\n                    if (pluginConstraints != null)\n                        constraints =\n                            UIServiceImpl\n                                .getBorderLayoutConstraintsFromContainer(pluginConstraints);\n                    else\n                        constraints = BorderLayout.SOUTH;\n\n                    this.addPluginComponent((Component) c.getComponent(), c\n                        .getContainer(), constraints);\n                }\n            }\n        }\n\n        GuiActivator.getUIService().addPluginComponentListener(this);\n    }","commit_id":"475b401890ff81f3bf51ff22a18ad926f1deff22","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Implements <code>isVisible<\/code> in the UIService interface. Checks if\n     * the main application window is visible.\n     *\n     * @return <code>true<\/code> if main application window is visible,\n     *         <code>false<\/code> otherwise\n     * @see UIService#isVisible()\n     */\n    public boolean isVisible()\n    {\n        if (super.isVisible())\n        {\n            if (super.getExtendedState() == JFrame.ICONIFIED)\n                return false;\n            else\n                return true;\n        }\n        else\n            return false;\n    }","id":60084,"modified_method":"/**\n     * Implements <code>isVisible<\/code> in the UIService interface. Checks if\n     * the main application window is visible.\n     *\n     * @return <code>true<\/code> if main application window is visible,\n     *         <code>false<\/code> otherwise\n     * @see UIService#isVisible()\n     */\n    public boolean isVisible()\n    {\n        return super.isVisible()\n            && (super.getExtendedState() != JFrame.ICONIFIED);\n    }","commit_id":"475b401890ff81f3bf51ff22a18ad926f1deff22","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Removes the associated with this <tt>PluginComponentEvent<\/tt> component\n     * from this container.\n     */\n    public void pluginComponentRemoved(PluginComponentEvent event)\n    {\n        final PluginComponent pluginComponent = event.getPluginComponent();\n\n        Container containerID = pluginComponent.getContainer();\n\n        if (containerID.equals(Container.CONTAINER_MAIN_WINDOW))\n        {\n            Object constraints = UIServiceImpl\n                    .getBorderLayoutConstraintsFromContainer(\n                        pluginComponent.getConstraints());\n\n            if (constraints == null)\n                constraints = BorderLayout.SOUTH;\n\n            if (pluginComponent.isNativeComponent())\n            {\n                if (nativePluginsTable.containsKey(pluginComponent))\n                {\n                    final Component c = nativePluginsTable.get(pluginComponent);\n\n                    final Object finalConstraints = constraints;\n\n                    SwingUtilities.invokeLater(new Runnable()\n                    {\n                        public void run()\n                        {\n                            removePluginComponent(\n                                c,\n                                pluginComponent.getContainer(),\n                                finalConstraints);\n\n                            getContentPane().repaint();\n                        }\n                    });\n                }\n            }\n            else\n            {\n                this.removePluginComponent(\n                    (Component) pluginComponent.getComponent(),\n                    pluginComponent.getContainer(),\n                    constraints);\n            }\n\n            nativePluginsTable.remove(pluginComponent);\n        }\n    }","id":60085,"modified_method":"/**\n     * Removes the associated with this <tt>PluginComponentEvent<\/tt> component\n     * from this container.\n     */\n    public void pluginComponentRemoved(PluginComponentEvent event)\n    {\n        final PluginComponent pluginComponent = event.getPluginComponent();\n\n        final Container containerID = pluginComponent.getContainer();\n\n        if (containerID.equals(Container.CONTAINER_MAIN_WINDOW))\n        {\n            Object constraints = UIServiceImpl\n                    .getBorderLayoutConstraintsFromContainer(\n                        pluginComponent.getConstraints());\n\n            if (constraints == null)\n                constraints = BorderLayout.SOUTH;\n\n            if (pluginComponent.isNativeComponent())\n            {\n                if (nativePluginsTable.containsKey(pluginComponent))\n                {\n                    final Component c = nativePluginsTable.get(pluginComponent);\n\n                    final Object finalConstraints = constraints;\n\n                    SwingUtilities.invokeLater(new Runnable()\n                    {\n                        public void run()\n                        {\n                            removePluginComponent(c, containerID,\n                                finalConstraints);\n\n                            getContentPane().repaint();\n                        }\n                    });\n                }\n            }\n            else\n            {\n                this.removePluginComponent((Component) pluginComponent\n                    .getComponent(), containerID, constraints);\n            }\n\n            nativePluginsTable.remove(pluginComponent);\n        }\n    }","commit_id":"475b401890ff81f3bf51ff22a18ad926f1deff22","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n         * Creates the logo bar and specify the size.\n         */\n        public LogoBar()\n        {\n            int width = GuiActivator.getResources()\n                .getSettingsInt(\"logoBarWidth\");\n            int height = GuiActivator.getResources()\n                .getSettingsInt(\"logoBarHeight\");\n\n            this.setMinimumSize(new Dimension(width, height));\n            this.setPreferredSize(new Dimension(width, height));\n\n            BufferedImage bgImage\n                = ImageLoader.getImage(ImageLoader.WINDOW_TITLE_BAR_BG);\n\n            Rectangle rect\n                = new Rectangle(0, 0,\n                            bgImage.getWidth(null),\n                            bgImage.getHeight(null));\n\n            texture = new TexturePaint(bgImage, rect);\n        }","id":60086,"modified_method":"/**\n         * Creates the logo bar and specify the size.\n         */\n        public LogoBar()\n        {\n            ResourceManagementService resources = GuiActivator.getResources();\n            int width = resources.getSettingsInt(\"logoBarWidth\");\n            int height = resources.getSettingsInt(\"logoBarHeight\");\n            Dimension size = new Dimension(width, height);\n\n            this.setMinimumSize(size);\n            this.setPreferredSize(size);\n\n            BufferedImage bgImage =\n                ImageLoader.getImage(ImageLoader.WINDOW_TITLE_BAR_BG);\n\n            Rectangle rect =\n                new Rectangle(0, 0, bgImage.getWidth(null), bgImage\n                    .getHeight(null));\n\n            texture = new TexturePaint(bgImage, rect);\n        }","commit_id":"475b401890ff81f3bf51ff22a18ad926f1deff22","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Checks in the configuration xml if there is already stored index for\n     * this provider and if yes, returns it, otherwise creates a new account\n     * index and stores it.\n     *\n     * @param protocolProvider the protocol provider\n     * @return the protocol provider index\n     */\n    private int initiateProviderIndex(\n            ProtocolProviderService protocolProvider)\n    {\n        ConfigurationService configService\n            = GuiActivator.getConfigurationService();\n\n        String prefix = \"net.java.sip.communicator.impl.gui.accounts\";\n\n        List accounts = configService\n                .getPropertyNamesByPrefix(prefix, true);\n\n        Iterator accountsIter = accounts.iterator();\n\n        boolean savedAccount = false;\n\n        while(accountsIter.hasNext()) {\n            String accountRootPropName\n                = (String) accountsIter.next();\n\n            String accountUID\n                = configService.getString(accountRootPropName);\n\n            if(accountUID.equals(protocolProvider\n                    .getAccountID().getAccountUniqueID())) {\n\n                savedAccount = true;\n                String  index = configService.getString(\n                        accountRootPropName + \".accountIndex\");\n\n                if(index != null) {\n                    //if we have found the accountIndex for this protocol provider\n                    //return this index\n                    return new Integer(index).intValue();\n                }\n                else {\n                    //if there's no stored accountIndex for this protocol\n                    //provider, calculate the index, set it in the configuration\n                    //service and return it.\n\n                    int accountIndex = createAccountIndex(protocolProvider,\n                            accountRootPropName);\n                    return accountIndex;\n                }\n            }\n        }\n\n        if(!savedAccount) {\n            String accNodeName\n                = \"acc\" + Long.toString(System.currentTimeMillis());\n\n            String accountPackage\n                = \"net.java.sip.communicator.impl.gui.accounts.\"\n                        + accNodeName;\n\n            configService.setProperty(accountPackage,\n                    protocolProvider.getAccountID().getAccountUniqueID());\n\n            int accountIndex = createAccountIndex(protocolProvider,\n                    accountPackage);\n\n            return accountIndex;\n        }\n        return -1;\n    }","id":60087,"modified_method":"/**\n     * Checks in the configuration xml if there is already stored index for\n     * this provider and if yes, returns it, otherwise creates a new account\n     * index and stores it.\n     *\n     * @param protocolProvider the protocol provider\n     * @return the protocol provider index\n     */\n    private int initiateProviderIndex(\n            ProtocolProviderService protocolProvider)\n    {\n        ConfigurationService configService\n            = GuiActivator.getConfigurationService();\n\n        String prefix = \"net.java.sip.communicator.impl.gui.accounts\";\n\n        List<String> accounts = configService\n                .getPropertyNamesByPrefix(prefix, true);\n\n        boolean savedAccount = false;\n\n        for (String accountRootPropName : accounts) {\n            String accountUID\n                = configService.getString(accountRootPropName);\n\n            if(accountUID.equals(protocolProvider\n                    .getAccountID().getAccountUniqueID())) {\n\n                savedAccount = true;\n                String  index = configService.getString(\n                        accountRootPropName + \".accountIndex\");\n\n                if(index != null) {\n                    //if we have found the accountIndex for this protocol provider\n                    //return this index\n                    return Integer.parseInt(index);\n                }\n                else {\n                    //if there's no stored accountIndex for this protocol\n                    //provider, calculate the index, set it in the configuration\n                    //service and return it.\n\n                    int accountIndex = createAccountIndex(protocolProvider,\n                            accountRootPropName);\n                    return accountIndex;\n                }\n            }\n        }\n\n        if(!savedAccount) {\n            String accNodeName\n                = \"acc\" + Long.toString(System.currentTimeMillis());\n\n            String accountPackage\n                = \"net.java.sip.communicator.impl.gui.accounts.\"\n                        + accNodeName;\n\n            configService.setProperty(accountPackage,\n                    protocolProvider.getAccountID().getAccountUniqueID());\n\n            int accountIndex = createAccountIndex(protocolProvider,\n                    accountPackage);\n\n            return accountIndex;\n        }\n        return -1;\n    }","commit_id":"475b401890ff81f3bf51ff22a18ad926f1deff22","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the multi user chat operation set for the given protocol provider.\n     *\n     * @param protocolProvider The protocol provider for which the multi user\n     * chat operation set is about.\n     * @return OperationSetMultiUserChat The telephony operation\n     * set for the given protocol provider.\n     */\n    public OperationSetMultiUserChat getMultiUserChatOpSet(\n            ProtocolProviderService protocolProvider)\n    {\n        OperationSet opSet\n            = protocolProvider.getOperationSet(OperationSetMultiUserChat.class);\n\n        if(opSet != null && opSet instanceof OperationSetMultiUserChat)\n            return (OperationSetMultiUserChat) opSet;\n\n        return null;\n    }","id":60088,"modified_method":"/**\n     * Returns the multi user chat operation set for the given protocol provider.\n     *\n     * @param protocolProvider The protocol provider for which the multi user\n     * chat operation set is about.\n     * @return OperationSetMultiUserChat The telephony operation\n     * set for the given protocol provider.\n     */\n    public OperationSetMultiUserChat getMultiUserChatOpSet(\n            ProtocolProviderService protocolProvider)\n    {\n        OperationSet opSet\n            = protocolProvider.getOperationSet(OperationSetMultiUserChat.class);\n\n        return (opSet instanceof OperationSetMultiUserChat) ? (OperationSetMultiUserChat) opSet\n            : null;\n    }","commit_id":"475b401890ff81f3bf51ff22a18ad926f1deff22","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates an instance of <tt>MainFrame<\/tt>.\n     */\n    public MainFrame()\n    {\n        if (!ConfigurationManager.isWindowDecorated())\n        {\n            this.setUndecorated(true);\n        }\n\n        this.mainCallPanel = new MainCallPanel(this);\n\n        this.contactListPanel = new ContactListPane(this);\n\n        this.accountStatusPanel = new AccountStatusPanel(this);\n\n        menu = new MainMenu(this);\n\n        /*\n         * Before closing the application window saves the current size and\n         * position through the ConfigurationService.\n         */\n        this.addWindowListener(new WindowAdapter()\n        {\n            public void windowClosed(WindowEvent event)\n            {\n                MainFrame.this.windowClosed(event);\n            }\n\n            public void windowClosing(WindowEvent event)\n            {\n                MainFrame.this.windowClosing(event);\n            }\n        });\n\n        this.initTitleFont();\n\n        String applicationName\n            = GuiActivator.getResources().getSettingsString(\n                \"applicationName\");\n\n        this.setTitle(applicationName);\n\n        this.mainPanel.setBackground(new Color(\n                GuiActivator.getResources()\n                    .getColor(\"mainWindowBackground\")));\n\n        this.init();\n\n        this.initPluginComponents();\n    }","id":60089,"modified_method":"/**\n     * Creates an instance of <tt>MainFrame<\/tt>.\n     */\n    public MainFrame()\n    {\n        if (!ConfigurationManager.isWindowDecorated())\n        {\n            this.setUndecorated(true);\n        }\n\n        this.mainCallPanel = new MainCallPanel(this);\n\n        this.contactListPanel = new ContactListPane(this);\n\n        this.accountStatusPanel = new AccountStatusPanel(this);\n\n        menu = new MainMenu(this);\n\n        /*\n         * Before closing the application window saves the current size and\n         * position through the ConfigurationService.\n         */\n        this.addWindowListener(new WindowAdapter()\n        {\n            public void windowClosed(WindowEvent event)\n            {\n                MainFrame.this.windowClosed(event);\n            }\n\n            public void windowClosing(WindowEvent event)\n            {\n                MainFrame.this.windowClosing(event);\n            }\n        });\n\n        this.initTitleFont();\n\n        ResourceManagementService resources = GuiActivator.getResources();\n        String applicationName = resources.getSettingsString(\"applicationName\");\n\n        this.setTitle(applicationName);\n\n        this.mainPanel.setBackground(new Color(resources\n            .getColor(\"mainWindowBackground\")));\n\n        this.init();\n\n        this.initPluginComponents();\n    }","commit_id":"475b401890ff81f3bf51ff22a18ad926f1deff22","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Adds all native plugins to this container.\n     */\n    public void addNativePlugins()\n    {\n        this.removeNativePlugins();\n\n        Iterator pluginIterator = nativePluginsTable.entrySet().iterator();\n\n        while (pluginIterator.hasNext())\n        {\n            Map.Entry pluginEntry = (Map.Entry) pluginIterator.next();\n\n            PluginComponent plugin = (PluginComponent) pluginEntry.getKey();\n\n            Object constraints = UIServiceImpl\n                    .getBorderLayoutConstraintsFromContainer(\n                        plugin.getConstraints());\n\n            Component c = (Component) plugin.getComponent();\n\n            this.addPluginComponent(c, plugin.getContainer(), constraints);\n\n            this.nativePluginsTable.put(plugin, c);\n        }\n    }","id":60090,"modified_method":"/**\n     * Adds all native plugins to this container.\n     */\n    public void addNativePlugins()\n    {\n        this.removeNativePlugins();\n\n        for (Map.Entry<PluginComponent, Component> pluginEntry : nativePluginsTable\n            .entrySet())\n        {\n            PluginComponent plugin = pluginEntry.getKey();\n\n            Object constraints =\n                UIServiceImpl.getBorderLayoutConstraintsFromContainer(plugin\n                    .getConstraints());\n\n            Component c = (Component) plugin.getComponent();\n\n            this.addPluginComponent(c, plugin.getContainer(), constraints);\n\n            this.nativePluginsTable.put(plugin, c);\n        }\n    }","commit_id":"475b401890ff81f3bf51ff22a18ad926f1deff22","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the presence operation set for the given protocol provider.\n     *\n     * @param protocolProvider The protocol provider for which the\n     * presence operation set is searched.\n     * @return the presence operation set for the given protocol provider.\n     */\n    public OperationSetPresence getProtocolPresenceOpSet(\n            ProtocolProviderService protocolProvider)\n    {\n        OperationSet opSet\n            = protocolProvider.getOperationSet(OperationSetPresence.class);\n\n        if(opSet != null && opSet instanceof OperationSetPresence)\n            return (OperationSetPresence) opSet;\n\n        return null;\n    }","id":60091,"modified_method":"/**\n     * Returns the presence operation set for the given protocol provider.\n     *\n     * @param protocolProvider The protocol provider for which the\n     * presence operation set is searched.\n     * @return the presence operation set for the given protocol provider.\n     */\n    public OperationSetPresence getProtocolPresenceOpSet(\n            ProtocolProviderService protocolProvider)\n    {\n        OperationSet opSet\n            = protocolProvider.getOperationSet(OperationSetPresence.class);\n\n        return (opSet instanceof OperationSetPresence) ? (OperationSetPresence) opSet\n            : null;\n    }","commit_id":"475b401890ff81f3bf51ff22a18ad926f1deff22","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void mousePressed(MouseEvent e)\n        {\n            ActionMenuGlassPane glassPane = new ActionMenuGlassPane();\n\n            ActionMenuPanel actionMenuPanel = new ActionMenuPanel();\n\n            glassPane.add(actionMenuPanel);\n\n            if (isVisible() && rootPane != null)\n                rootPane.setGlassPane(glassPane);\n\n            glassPane.revalidate();\n            glassPane.setVisible(!glassPane.isVisible());\n            glassPane.repaint();\n        }","id":60092,"modified_method":"public void mousePressed(MouseEvent e)\n        {\n            ActionMenuGlassPane glassPane = new ActionMenuGlassPane();\n\n            glassPane.add(new ActionMenuPanel());\n\n            if ((rootPane != null) && isVisible())\n                rootPane.setGlassPane(glassPane);\n\n            glassPane.revalidate();\n            glassPane.setVisible(!glassPane.isVisible());\n            glassPane.repaint();\n        }","commit_id":"475b401890ff81f3bf51ff22a18ad926f1deff22","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Initialize main window font.\n     */\n    private void initTitleFont()\n    {\n        JComponent layeredPane = this.getLayeredPane();\n\n        String fontName\n            = GuiActivator.getResources().getSettingsString(\n                \"fontName\");\n\n        String titleFontSize\n            = GuiActivator.getResources().getSettingsString(\n                \"titleFontSize\");\n\n        Font font = new Font(   fontName,\n                                Font.BOLD,\n                                new Integer(titleFontSize).intValue());\n\n        for (int i = 0; i < layeredPane.getComponentCount(); i++)\n        {\n            layeredPane.getComponent(i).setFont(font);\n        }\n    }","id":60093,"modified_method":"/**\n     * Initialize main window font.\n     */\n    private void initTitleFont()\n    {\n        JComponent layeredPane = this.getLayeredPane();\n\n        ResourceManagementService resources = GuiActivator.getResources();\n        String fontName = resources.getSettingsString(\"fontName\");\n        String titleFontSize = resources.getSettingsString(\"titleFontSize\");\n\n        Font font = new Font(   fontName,\n                                Font.BOLD,\n                                new Integer(titleFontSize).intValue());\n\n        final int componentCount = layeredPane.getComponentCount();\n        for (int i = 0; i < componentCount; i++)\n        {\n            layeredPane.getComponent(i).setFont(font);\n        }\n    }","commit_id":"475b401890ff81f3bf51ff22a18ad926f1deff22","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Sets frame size and position.\n     */\n    public void initBounds()\n    {\n        int width\n            = GuiActivator.getResources().getSettingsInt(\"mainWindowWidth\");\n        int height\n            = GuiActivator.getResources().getSettingsInt(\"mainWindowHeight\");\n\n        int minWidth\n            = GuiActivator.getResources().getSettingsInt(\"minMainWindowWidth\");\n        int minHeight\n            = GuiActivator.getResources().getSettingsInt(\"minMainWindowHeight\");\n\n        this.setMinimumSize(new Dimension(minWidth, minHeight));\n\n        this.setSize(width, height);\n\n        this.setLocation(Toolkit.getDefaultToolkit().getScreenSize().width\n                - this.getWidth(), 50);\n    }","id":60094,"modified_method":"/**\n     * Sets frame size and position.\n     */\n    public void initBounds()\n    {\n        ResourceManagementService resources = GuiActivator.getResources();\n        int width\n            = resources.getSettingsInt(\"mainWindowWidth\");\n        int height\n            = resources.getSettingsInt(\"mainWindowHeight\");\n\n        int minWidth\n            = resources.getSettingsInt(\"minMainWindowWidth\");\n        int minHeight\n            = resources.getSettingsInt(\"minMainWindowHeight\");\n\n        this.setMinimumSize(new Dimension(minWidth, minHeight));\n\n        this.setSize(width, height);\n\n        this.setLocation(Toolkit.getDefaultToolkit().getScreenSize().width\n                - this.getWidth(), 50);\n    }","commit_id":"475b401890ff81f3bf51ff22a18ad926f1deff22","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the Web Contact Info operation set for the given\n     * protocol provider.\n     *\n     * @param protocolProvider The protocol provider for which the TN\n     * is searched.\n     * @return OperationSetWebContactInfo The Web Contact Info operation\n     * set for the given protocol provider.\n     */\n    public OperationSetWebContactInfo getWebContactInfoOpSet(\n            ProtocolProviderService protocolProvider)\n    {\n        OperationSet opSet\n            = protocolProvider.getOperationSet(OperationSetWebContactInfo.class);\n\n        if(opSet != null && opSet instanceof OperationSetWebContactInfo)\n            return (OperationSetWebContactInfo) opSet;\n\n        return null;\n    }","id":60095,"modified_method":"/**\n     * Returns the Web Contact Info operation set for the given\n     * protocol provider.\n     *\n     * @param protocolProvider The protocol provider for which the TN\n     * is searched.\n     * @return OperationSetWebContactInfo The Web Contact Info operation\n     * set for the given protocol provider.\n     */\n    public OperationSetWebContactInfo getWebContactInfoOpSet(\n            ProtocolProviderService protocolProvider)\n    {\n        OperationSet opSet\n            = protocolProvider.getOperationSet(OperationSetWebContactInfo.class);\n\n        return (opSet instanceof OperationSetWebContactInfo) ? (OperationSetWebContactInfo) opSet\n            : null;\n    }","commit_id":"475b401890ff81f3bf51ff22a18ad926f1deff22","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the telephony operation set for the given protocol provider.\n     *\n     * @param protocolProvider The protocol provider for which the telephony\n     * operation set is about.\n     * @return OperationSetBasicTelephony The telephony operation\n     * set for the given protocol provider.\n     */\n    public OperationSetBasicTelephony getTelephonyOpSet(\n            ProtocolProviderService protocolProvider)\n    {\n        OperationSet opSet\n            = protocolProvider.getOperationSet(OperationSetBasicTelephony.class);\n\n        if(opSet != null && opSet instanceof OperationSetBasicTelephony)\n            return (OperationSetBasicTelephony) opSet;\n\n        return null;\n    }","id":60096,"modified_method":"/**\n     * Returns the telephony operation set for the given protocol provider.\n     *\n     * @param protocolProvider The protocol provider for which the telephony\n     * operation set is about.\n     * @return OperationSetBasicTelephony The telephony operation\n     * set for the given protocol provider.\n     */\n    public OperationSetBasicTelephony getTelephonyOpSet(\n            ProtocolProviderService protocolProvider)\n    {\n        OperationSet opSet\n            = protocolProvider.getOperationSet(OperationSetBasicTelephony.class);\n\n        return (opSet instanceof OperationSetBasicTelephony) ? (OperationSetBasicTelephony) opSet\n            : null;\n    }","commit_id":"475b401890ff81f3bf51ff22a18ad926f1deff22","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n         * Returns the size of the given component.\n         * @return the size of the given component.\n         */\n        public Dimension getPreferredSize(JComponent c)\n        {\n            int width = 0;\n            if (imageLabel.getIcon() != null)\n                width += imageLabel.getIcon().getIconWidth();\n\n            width += textWidth;\n\n            int imageHeight = 0;\n            if (imageLabel.getIcon() != null)\n                imageHeight = imageLabel.getIcon().getIconHeight();\n\n            int height = imageHeight > textHeight ?\n                imageHeight : textHeight;\n\n            return new Dimension(width + 15, height);\n        }","id":60097,"modified_method":"/**\n         * Returns the size of the given component.\n         * @return the size of the given component.\n         */\n        public Dimension getPreferredSize(JComponent c)\n        {\n            Icon icon = imageLabel.getIcon();\n            int width = 0;\n            if (icon != null)\n                width += icon.getIconWidth();\n\n            width += textWidth;\n\n            int imageHeight = 0;\n            if (icon != null)\n                imageHeight = icon.getIconHeight();\n\n            int height = imageHeight > textHeight ?\n                imageHeight : textHeight;\n\n            return new Dimension(width + 15, height);\n        }","commit_id":"475b401890ff81f3bf51ff22a18ad926f1deff22","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Created a <tt>MetaContactTooltip<\/tt>.\n     */\n    public MetaContactTooltip()\n    {\n        this.setUI(new ImageToolTipUI());\n\n        this.setLayout(new BorderLayout());\n\n        mainPanel.setOpaque(false);\n        centerPanel.setOpaque(false);\n        protocolContactsPanel.setOpaque(false);\n\n        mainPanel.add(imageLabel, BorderLayout.WEST);\n        mainPanel.add(centerPanel, BorderLayout.CENTER);\n\n        titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD));\n\n        centerPanel.add(titleLabel, BorderLayout.NORTH);\n        centerPanel.add(protocolContactsPanel, BorderLayout.CENTER);\n\n        protocolContactsPanel.setLayout(\n            new BoxLayout(protocolContactsPanel, BoxLayout.Y_AXIS));\n\n        this.add(mainPanel); \n    }","id":60098,"modified_method":"/**\n     * Created a <tt>MetaContactTooltip<\/tt>.\n     */\n    public MetaContactTooltip()\n    {\n        this.setUI(new ImageToolTipUI());\n\n        this.setLayout(new BorderLayout());\n\n        JPanel mainPanel = new JPanel(new BorderLayout(5, 5));\n        JPanel centerPanel = new JPanel(new BorderLayout());\n\n        mainPanel.setOpaque(false);\n        centerPanel.setOpaque(false);\n        protocolContactsPanel.setOpaque(false);\n\n        mainPanel.add(imageLabel, BorderLayout.WEST);\n        mainPanel.add(centerPanel, BorderLayout.CENTER);\n\n        titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD));\n\n        centerPanel.add(titleLabel, BorderLayout.NORTH);\n        centerPanel.add(protocolContactsPanel, BorderLayout.CENTER);\n\n        protocolContactsPanel.setLayout(\n            new BoxLayout(protocolContactsPanel, BoxLayout.Y_AXIS));\n\n        this.add(mainPanel); \n    }","commit_id":"475b401890ff81f3bf51ff22a18ad926f1deff22","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Saves the (protocol provider, wizard) pair in through the\n     * <tt>ConfigurationService<\/tt>.\n     * \n     * @param protocolProvider the protocol provider to save\n     * @param wizard the wizard to save\n     */\n    private void saveAccountWizard(ProtocolProviderService protocolProvider,\n        AccountRegistrationWizard wizard)\n    {\n        String prefix = \"net.java.sip.communicator.impl.gui.accounts\";\n\n        ConfigurationService configService = getConfigurationService();\n\n        List accounts = configService.getPropertyNamesByPrefix(prefix, true);\n\n        boolean savedAccount = false;\n        Iterator accountsIter = accounts.iterator();\n\n        while (accountsIter.hasNext())\n        {\n            String accountRootPropName = (String) accountsIter.next();\n\n            String accountUID = configService.getString(accountRootPropName);\n\n            if (accountUID.equals(protocolProvider.getAccountID()\n                .getAccountUniqueID()))\n            {\n\n                configService.setProperty(accountRootPropName + \".wizard\",\n                    wizard.getClass().getName().replace('.', '_'));\n\n                savedAccount = true;\n            }\n        }\n\n        if (!savedAccount)\n        {\n            String accNodeName =\n                \"acc\" + Long.toString(System.currentTimeMillis());\n\n            String accountPackage =\n                \"net.java.sip.communicator.impl.gui.accounts.\" + accNodeName;\n\n            configService.setProperty(accountPackage, protocolProvider\n                .getAccountID().getAccountUniqueID());\n\n            configService.setProperty(accountPackage + \".wizard\", wizard);\n        }\n    }","id":60099,"modified_method":"/**\n     * Saves the (protocol provider, wizard) pair in through the\n     * <tt>ConfigurationService<\/tt>.\n     * \n     * @param protocolProvider the protocol provider to save\n     * @param wizard the wizard to save\n     */\n    private void saveAccountWizard(ProtocolProviderService protocolProvider,\n        AccountRegistrationWizard wizard)\n    {\n        String prefix = \"net.java.sip.communicator.impl.gui.accounts\";\n\n        ConfigurationService configService = getConfigurationService();\n\n        List<String> accounts = configService.getPropertyNamesByPrefix(prefix, true);\n        boolean savedAccount = false;\n\n        for (String accountRootPropName : accounts)\n        {\n            String accountUID = configService.getString(accountRootPropName);\n\n            if (accountUID.equals(protocolProvider.getAccountID()\n                .getAccountUniqueID()))\n            {\n\n                configService.setProperty(accountRootPropName + \".wizard\",\n                    wizard.getClass().getName().replace('.', '_'));\n\n                savedAccount = true;\n            }\n        }\n\n        if (!savedAccount)\n        {\n            String accNodeName =\n                \"acc\" + Long.toString(System.currentTimeMillis());\n\n            String accountPackage =\n                \"net.java.sip.communicator.impl.gui.accounts.\" + accNodeName;\n\n            configService.setProperty(accountPackage, protocolProvider\n                .getAccountID().getAccountUniqueID());\n\n            configService.setProperty(accountPackage + \".wizard\", wizard);\n        }\n    }","commit_id":"97fdda1a3e8be1335d927dd19805d54d45a6b65f","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void actionPerformed(ActionEvent evt)\n        {\n            JButton button = (JButton) evt.getSource();\n\n            if (button.equals(signinButton))\n            {\n                Iterator regIterator = registrationForms.iterator();\n\n                if (regIterator.hasNext())\n                    setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n\n                while(regIterator.hasNext())\n                {\n                    AccountRegistrationPanel regForm\n                        = (AccountRegistrationPanel) regIterator.next();\n\n                    if (regForm.isFilled())\n                    {\n                        regForm.signin();\n                    }\n                }\n            }\n\n            InitialAccountRegistrationFrame initialAccountRegistrationFrame =\n                InitialAccountRegistrationFrame.this;\n            initialAccountRegistrationFrame.setVisible(false);\n            initialAccountRegistrationFrame.dispose();\n        }","id":60100,"modified_method":"public void actionPerformed(ActionEvent evt)\n        {\n            JButton button = (JButton) evt.getSource();\n\n            if (button.equals(signinButton))\n            {\n                Iterator<AccountRegistrationPanel> regIterator =\n                    registrationForms.iterator();\n\n                if (regIterator.hasNext())\n                    setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n\n                while(regIterator.hasNext())\n                {\n                    AccountRegistrationPanel regForm = regIterator.next();\n\n                    if (regForm.isFilled())\n                    {\n                        regForm.signin();\n                    }\n                }\n            }\n\n            InitialAccountRegistrationFrame initialAccountRegistrationFrame =\n                InitialAccountRegistrationFrame.this;\n            initialAccountRegistrationFrame.setVisible(false);\n            initialAccountRegistrationFrame.dispose();\n        }","commit_id":"97fdda1a3e8be1335d927dd19805d54d45a6b65f","url":"https://github.com/jitsi/jitsi"},{"original_method":"public boolean isFilled()\n        {\n            if(usernameField.getText() != null\n                && usernameField.getText().length() > 0)\n                return true;\n\n            return false;\n        }","id":60101,"modified_method":"public boolean isFilled()\n        {\n            String username = usernameField.getText();\n            return (username != null) && (username.length() > 0);\n        }","commit_id":"97fdda1a3e8be1335d927dd19805d54d45a6b65f","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void paintComponent(Graphics g)\n        {\n            Graphics2D g2d = (Graphics2D) g;\n\n            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                    RenderingHints.VALUE_ANTIALIAS_ON);\n\n            // do the superclass behavior first\n            super.paintComponent(g2d);\n\n            g2d.setColor(new Color(\n                Resources.getColor(\"service.gui.DESKTOP_BACKGROUND\")));\n\n            // paint the background with the chosen color\n            g2d.fillRoundRect(0, 0, getWidth(), getHeight(), 15, 15);\n        }","id":60102,"modified_method":"public void paintComponent(Graphics g)\n        {\n            // do the superclass behavior first\n            super.paintComponent(g);\n\n            g = g.create();\n            try\n            {\n                Graphics2D g2d = (Graphics2D) g;\n\n                g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                    RenderingHints.VALUE_ANTIALIAS_ON);\n\n                // paint the background with the chosen color\n                g2d.setColor(accountRegistrationPanelBackground);\n                g2d.fillRoundRect(0, 0, getWidth(), getHeight(), 15, 15);\n            }\n            finally\n            {\n                g.dispose();\n            }\n        }","commit_id":"97fdda1a3e8be1335d927dd19805d54d45a6b65f","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void paintComponent(Graphics g)\n        {\n            Graphics2D g2d = (Graphics2D) g;\n\n            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                    RenderingHints.VALUE_ANTIALIAS_ON);\n\n            // do the superclass behavior first\n            super.paintComponent(g2d);\n\n            g2d.setColor(new Color(\n                Resources.getColor(\"plugin.simpleaccreg.ACCOUNT_REGISTRATION_BACKGROUND\")));\n\n            // paint the background with the chosen color\n            g2d.fillRoundRect(10, 10, getWidth() - 20, getHeight() - 20, 15, 15);\n        }","id":60103,"modified_method":"public void paintComponent(Graphics g)\n        {\n            // do the superclass behavior first\n            super.paintComponent(g);\n\n            g = g.create();\n            try\n            {\n                Graphics2D g2d = (Graphics2D) g;\n\n                g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                    RenderingHints.VALUE_ANTIALIAS_ON);\n\n                // paint the background with the chosen color\n                g2d.setColor(background);\n                g2d.fillRoundRect(10, 10, getWidth() - 20, getHeight() - 20,\n                    15, 15);\n            }\n            finally\n            {\n                g.dispose();\n            }\n        }","commit_id":"97fdda1a3e8be1335d927dd19805d54d45a6b65f","url":"https://github.com/jitsi/jitsi"},{"original_method":"public WelcomeWindow()\n    {\n        this.setTitle(APPLICATION_NAME);\n\n        this.setModal(false);\n        this.setUndecorated(true);\n\n        this.mainPanel.setLayout(new BorderLayout());\n\n        this.textPanel.setPreferredSize(new Dimension(470, 280));\n        this.textPanel.setLayout(new BoxLayout(textPanel, BoxLayout.Y_AXIS));\n        this.textPanel\n                .setBorder(BorderFactory.createEmptyBorder(15, 15, 0, 15));\n        this.textPanel.setOpaque(false);\n\n        this.titleLabel.setFont(\n            titleLabel.getFont().deriveFont(Font.BOLD, 28));\n        this.titleLabel.setForeground(Constants.TITLE_COLOR);\n        this.titleLabel.setAlignmentX(Component.RIGHT_ALIGNMENT);\n\n        this.versionLabel.setFont(\n            versionLabel.getFont().deriveFont(Font.BOLD, 18));\n        this.versionLabel.setForeground(Constants.TITLE_COLOR);\n        this.versionLabel.setAlignmentX(Component.RIGHT_ALIGNMENT);\n\n        int logoAreaFontSize = BrandingActivator.getResources().\n            getSettingsInt(\"plugin.branding.ABOUT_LOGO_FONT_SIZE\");\n\n        this.logoArea.setFont(\n            logoArea.getFont().deriveFont(Font.BOLD, logoAreaFontSize));\n        this.logoArea.setForeground(Constants.TITLE_COLOR);\n        this.logoArea.setOpaque(false);\n        this.logoArea.setLineWrap(true);\n        this.logoArea.setWrapStyleWord(true);\n        this.logoArea.setEditable(false);\n        this.logoArea.setPreferredSize(new Dimension(100, 20));\n        this.logoArea.setAlignmentX(Component.RIGHT_ALIGNMENT);\n        this.logoArea.setBorder(BorderFactory\n            .createEmptyBorder(20, DEFAULT_TEXT_INDENT, 0, 0));\n\n        this.rightsArea.setContentType(\"text/html\");\n        this.rightsArea.appendToEnd(BrandingActivator.getResources().getI18NString(\n            \"plugin.branding.WELCOME_MESSAGE\",\n            new String[]{\n                Constants.TEXT_COLOR,\n                APPLICATION_NAME,\n                BrandingActivator.getResources()\n                    .getSettingsString(\"service.gui.APPLICATION_WEB_SITE\")\n                }));\n\n        this.rightsArea.setPreferredSize(new Dimension(50, 50));\n        this.rightsArea\n                .setBorder(BorderFactory\n                    .createEmptyBorder(0, DEFAULT_TEXT_INDENT, 0, 0));\n        this.rightsArea.setOpaque(false);\n        this.rightsArea.setEditable(false);\n        this.rightsArea.setAlignmentX(Component.RIGHT_ALIGNMENT);\n\n        this.licenseArea.setContentType(\"text/html\");\n        this.licenseArea.appendToEnd(BrandingActivator.getResources().getI18NString(\n            \"plugin.branding.LICENSE\",\n            new String[]\n                       {\n                            Constants.TEXT_COLOR\n                       }));\n\n        this.licenseArea.setPreferredSize(new Dimension(50, 20));\n        this.licenseArea.setBorder(BorderFactory\n                .createEmptyBorder(0, DEFAULT_TEXT_INDENT, 0, 0));\n        this.licenseArea.setOpaque(false);\n        this.licenseArea.setEditable(false);\n        this.licenseArea.setAlignmentX(Component.RIGHT_ALIGNMENT);\n\n        this.bundleLabel.setFont(loadingLabel.getFont().deriveFont(Font.PLAIN));\n        this.loadingPanel.setOpaque(false);\n        this.loadingPanel.add(loadingLabel, BorderLayout.WEST);\n        this.loadingPanel.add(bundleLabel, BorderLayout.CENTER);\n        this.loadingPanel.setAlignmentX(Component.RIGHT_ALIGNMENT);\n        this.loadingPanel.setBorder(\n            BorderFactory.createEmptyBorder(10, 10, 10, 10));\n\n        this.textPanel.add(titleLabel);\n        this.textPanel.add(versionLabel);\n        this.textPanel.add(logoArea);\n        this.textPanel.add(rightsArea);\n        this.textPanel.add(licenseArea);\n\n        this.mainPanel.add(textPanel, BorderLayout.CENTER);\n        this.mainPanel.add(loadingPanel, BorderLayout.SOUTH);\n\n        this.getContentPane().add(mainPanel);\n\n        this.setResizable(false);\n\n        this.mainPanel.setPreferredSize(new Dimension(570, 330));\n\n        this.setLocation(\n            Toolkit.getDefaultToolkit().getScreenSize().width / 2 - 527 / 2,\n            Toolkit.getDefaultToolkit().getScreenSize().height / 2 - 305 / 2);\n\n        // Close the splash screen on simple click or Esc.\n        this.getGlassPane().addMouseListener(new MouseAdapter()\n        {\n            public void mouseClicked(MouseEvent e)\n            {\n                WelcomeWindow.this.close();\n            }\n        });\n\n        this.getGlassPane().setVisible(true);\n\n        ActionMap amap = this.getRootPane().getActionMap();\n\n        amap.put(\"close\", new CloseAction());\n\n        InputMap imap = this.getRootPane().getInputMap(\n                JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);\n\n        imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), \"close\");\n    }","id":60104,"modified_method":"public WelcomeWindow()\n    {\n        Container mainPanel = new WindowBackground();\n\n        this.setTitle(APPLICATION_NAME);\n\n        this.setModal(false);\n        this.setUndecorated(true);\n\n        mainPanel.setLayout(new BorderLayout());\n\n        this.textPanel.setPreferredSize(new Dimension(470, 280));\n        this.textPanel.setLayout(new BoxLayout(textPanel, BoxLayout.Y_AXIS));\n        this.textPanel\n                .setBorder(BorderFactory.createEmptyBorder(15, 15, 0, 15));\n        this.textPanel.setOpaque(false);\n\n        this.titleLabel.setFont(\n            titleLabel.getFont().deriveFont(Font.BOLD, 28));\n        this.titleLabel.setForeground(Constants.TITLE_COLOR);\n        this.titleLabel.setAlignmentX(Component.RIGHT_ALIGNMENT);\n\n        this.versionLabel.setFont(\n            versionLabel.getFont().deriveFont(Font.BOLD, 18));\n        this.versionLabel.setForeground(Constants.TITLE_COLOR);\n        this.versionLabel.setAlignmentX(Component.RIGHT_ALIGNMENT);\n\n        int logoAreaFontSize = BrandingActivator.getResources().\n            getSettingsInt(\"plugin.branding.ABOUT_LOGO_FONT_SIZE\");\n\n        this.logoArea.setFont(\n            logoArea.getFont().deriveFont(Font.BOLD, logoAreaFontSize));\n        this.logoArea.setForeground(Constants.TITLE_COLOR);\n        this.logoArea.setOpaque(false);\n        this.logoArea.setLineWrap(true);\n        this.logoArea.setWrapStyleWord(true);\n        this.logoArea.setEditable(false);\n        this.logoArea.setPreferredSize(new Dimension(100, 20));\n        this.logoArea.setAlignmentX(Component.RIGHT_ALIGNMENT);\n        this.logoArea.setBorder(BorderFactory\n            .createEmptyBorder(20, DEFAULT_TEXT_INDENT, 0, 0));\n\n        this.rightsArea.setContentType(\"text/html\");\n        this.rightsArea.appendToEnd(BrandingActivator.getResources().getI18NString(\n            \"plugin.branding.WELCOME_MESSAGE\",\n            new String[]{\n                Constants.TEXT_COLOR,\n                APPLICATION_NAME,\n                BrandingActivator.getResources()\n                    .getSettingsString(\"service.gui.APPLICATION_WEB_SITE\")\n                }));\n\n        this.rightsArea.setPreferredSize(new Dimension(50, 50));\n        this.rightsArea\n                .setBorder(BorderFactory\n                    .createEmptyBorder(0, DEFAULT_TEXT_INDENT, 0, 0));\n        this.rightsArea.setOpaque(false);\n        this.rightsArea.setEditable(false);\n        this.rightsArea.setAlignmentX(Component.RIGHT_ALIGNMENT);\n\n        this.licenseArea.setContentType(\"text/html\");\n        this.licenseArea.appendToEnd(BrandingActivator.getResources().getI18NString(\n            \"plugin.branding.LICENSE\",\n            new String[]\n                       {\n                            Constants.TEXT_COLOR\n                       }));\n\n        this.licenseArea.setPreferredSize(new Dimension(50, 20));\n        this.licenseArea.setBorder(BorderFactory\n                .createEmptyBorder(0, DEFAULT_TEXT_INDENT, 0, 0));\n        this.licenseArea.setOpaque(false);\n        this.licenseArea.setEditable(false);\n        this.licenseArea.setAlignmentX(Component.RIGHT_ALIGNMENT);\n\n        this.bundleLabel.setFont(loadingLabel.getFont().deriveFont(Font.PLAIN));\n        this.loadingPanel.setOpaque(false);\n        this.loadingPanel.add(loadingLabel, BorderLayout.WEST);\n        this.loadingPanel.add(bundleLabel, BorderLayout.CENTER);\n        this.loadingPanel.setAlignmentX(Component.RIGHT_ALIGNMENT);\n        this.loadingPanel.setBorder(\n            BorderFactory.createEmptyBorder(10, 10, 10, 10));\n\n        this.textPanel.add(titleLabel);\n        this.textPanel.add(versionLabel);\n        this.textPanel.add(logoArea);\n        this.textPanel.add(rightsArea);\n        this.textPanel.add(licenseArea);\n\n        mainPanel.add(textPanel, BorderLayout.CENTER);\n        mainPanel.add(loadingPanel, BorderLayout.SOUTH);\n\n        this.getContentPane().add(mainPanel);\n\n        this.setResizable(false);\n\n        mainPanel.setPreferredSize(new Dimension(570, 330));\n\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n        this.setLocation(screenSize.width / 2 - 527 / 2,\n            screenSize.height / 2 - 305 / 2);\n\n        // Close the splash screen on simple click or Esc.\n        this.getGlassPane().addMouseListener(new MouseAdapter()\n        {\n            public void mouseClicked(MouseEvent e)\n            {\n                WelcomeWindow.this.close();\n            }\n        });\n\n        this.getGlassPane().setVisible(true);\n\n        ActionMap amap = this.getRootPane().getActionMap();\n\n        amap.put(\"close\", new CloseAction());\n\n        InputMap imap = this.getRootPane().getInputMap(\n                JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);\n\n        imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), \"close\");\n    }","commit_id":"97fdda1a3e8be1335d927dd19805d54d45a6b65f","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Implements the <tt>ListCellRenderer<\/tt> method.\n     * Returns this panel that has been configured to display bundle name,\n     * version and description.\n     * @param table the parent table\n     * @param value the value of the rendered cell\n     * @param isSelected indicates if the rendered cell is selected\n     * @param hasFocus indicates if the rendered cell has the focus\n     * @param rowIndex the row index of the rendered cell\n     * @param vColIndex the column index of the rendered cell\n     * @return the rendering component\n     */\n    @SuppressWarnings(\"unchecked\")\n    public Component getTableCellRendererComponent(JTable table, Object value,\n            boolean isSelected, boolean hasFocus, int rowIndex, int vColIndex)\n    {\n        Bundle bundle = (Bundle) value;\n\n        Dictionary<Object, Object> headers = bundle.getHeaders();\n        Object bundleName = headers.get(Constants.BUNDLE_NAME);\n        Object bundleVersion = headers.get(Constants.BUNDLE_VERSION);\n        Object bundleDescription = headers.get(Constants.BUNDLE_DESCRIPTION);\n\n        Icon stateIcon = getStateIcon(bundle.getState());\n\n        if(bundleName != null)\n            this.nameLabel.setText(bundleName.toString());\n        else\n            this.nameLabel.setText(\"unknown\");\n\n        if(bundleVersion != null)\n            this.versionLabel.setText(bundleVersion.toString());\n        else\n            this.versionLabel.setText(\"\");\n\n        if(bundleDescription != null)\n            this.descriptionLabel.setText(bundleDescription.toString());\n        else\n            this.descriptionLabel.setText(\"\");\n\n        if(stateIcon != null)\n            this.stateLabel.setIcon(stateIcon);\n\n        this.nameVersionPanel.remove(systemLabel);\n\n        if(PluginManagerActivator.isSystemBundle(bundle))\n            this.nameVersionPanel.add(systemLabel);\n\n        this.isSelected = isSelected;\n\n        return this;\n    }","id":60105,"modified_method":"/**\n     * Implements the <tt>ListCellRenderer<\/tt> method.\n     * Returns this panel that has been configured to display bundle name,\n     * version and description.\n     * @param table the parent table\n     * @param value the value of the rendered cell\n     * @param isSelected indicates if the rendered cell is selected\n     * @param hasFocus indicates if the rendered cell has the focus\n     * @param rowIndex the row index of the rendered cell\n     * @param vColIndex the column index of the rendered cell\n     * @return the rendering component\n     */\n    @SuppressWarnings(\"unchecked\")\n    public Component getTableCellRendererComponent(JTable table, Object value,\n            boolean isSelected, boolean hasFocus, int rowIndex, int vColIndex)\n    {\n        Bundle bundle = (Bundle) value;\n\n        Dictionary<?, ?> headers = bundle.getHeaders();\n        Object bundleName = headers.get(Constants.BUNDLE_NAME);\n        Object bundleVersion = headers.get(Constants.BUNDLE_VERSION);\n        Object bundleDescription = headers.get(Constants.BUNDLE_DESCRIPTION);\n\n        Icon stateIcon = getStateIcon(bundle.getState());\n\n        if(bundleName != null)\n            this.nameLabel.setText(bundleName.toString());\n        else\n            this.nameLabel.setText(\"unknown\");\n\n        if(bundleVersion != null)\n            this.versionLabel.setText(bundleVersion.toString());\n        else\n            this.versionLabel.setText(\"\");\n\n        if(bundleDescription != null)\n            this.descriptionLabel.setText(bundleDescription.toString());\n        else\n            this.descriptionLabel.setText(\"\");\n\n        if(stateIcon != null)\n            this.stateLabel.setIcon(stateIcon);\n\n        this.nameVersionPanel.remove(systemLabel);\n\n        if(PluginManagerActivator.isSystemBundle(bundle))\n            this.nameVersionPanel.add(systemLabel);\n\n        this.isSelected = isSelected;\n\n        return this;\n    }","commit_id":"2ce621309bcd2e0c1e55357be173fe47ac9e2fe9","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Starts the SIP Communicator.\n     *\n     * @param args command line args if any\n     *\n     * @throws Exception whenever it makes sense.\n     */\n    public static void main(String[] args)\n        throws Exception\n    {\n        String version = System.getProperty(\"java.version\");\n        String vmVendor = System.getProperty(\"java.vendor\");\n        String osName = System.getProperty(\"os.name\");\n\n        // disable Direct 3D pipeline (used for fullscreen) before\n        // displaying anything (frame, ...)\n        if(osName.startsWith(\"Windows\"))\n            System.setProperty(\"sun.java2d.d3d\", \"false\");\n\n        /*\n         * SC_HOME_DIR_* are specific to the OS so make sure they're configured\n         * accordingly before any other application-specific logic depending on\n         * them starts (e.g. Felix).\n         */\n        setScHomeDir(osName);\n\n        if (version.startsWith(\"1.4\") || vmVendor.startsWith(\"Gnu\") ||\n                vmVendor.startsWith(\"Free\"))\n        {\n            String os = \"\";\n\n            if (osName.startsWith(\"Mac\"))\n                os = ChangeJVMFrame.MAC_OSX;\n            else if (osName.startsWith(\"Linux\"))\n                os = ChangeJVMFrame.LINUX;\n            else if (osName.startsWith(\"Windows\"))\n                os = ChangeJVMFrame.WINDOWS;\n\n            ChangeJVMFrame changeJVMFrame = new ChangeJVMFrame(os);\n\n            changeJVMFrame.setLocation(\n                Toolkit.getDefaultToolkit().getScreenSize().width/2\n                    - changeJVMFrame.getWidth()/2,\n                Toolkit.getDefaultToolkit().getScreenSize().height/2\n                    - changeJVMFrame.getHeight()/2\n                );\n            changeJVMFrame.setVisible(true);\n\n            return;\n        }\n\n        //first - pass the arguments to our arg handler\n        LaunchArgHandler argHandler = LaunchArgHandler.getInstance();\n        int argHandlerRes = argHandler.handleArgs(args);\n\n        if ( argHandlerRes == LaunchArgHandler.ACTION_EXIT\n             || argHandlerRes == LaunchArgHandler.ACTION_ERROR)\n        {\n            System.exit(argHandler.getErrorCode());\n        }\n\n        //lock our config dir so that we would only have a single instance of\n        //sip communicator, no matter how many times we start it (use mainly\n        //for handling sip: uris after starting the application)\n        if ( argHandlerRes != LaunchArgHandler.ACTION_CONTINUE_LOCK_DISABLED )\n        {\n            SipCommunicatorLock lock = new SipCommunicatorLock();\n\n            int lockResult = lock.tryLock(args);\n\n            if( lockResult == SipCommunicatorLock.LOCK_ERROR )\n            {\n                System.err.println(\"Failed to lock SIP Communicator's \"\n                                +\"configuration directory.\\n\"\n                                +\"Try launching with the --multiple param.\");\n                System.exit(SipCommunicatorLock.LOCK_ERROR);\n\n            }\n            else if(lockResult == SipCommunicatorLock.ALREADY_STARTED)\n            {\n                System.out.println(\n                    \"SIP Communicator is already running and will \"\n                    +\"handle your parameters (if any).\\n\"\n                    +\"Launch with the --multiple param to override this \"\n                    +\"behaviour.\");\n\n                //we exit with success because for the user that's what it is.\n                System.exit(SipCommunicatorLock.SUCCESS);\n            }\n            else if(lockResult == SipCommunicatorLock.SUCCESS)\n            {\n                //Successfully locked, continue as normal.\n            }\n        }\n\n        //there was no error, continue;\n        System.setOut(new ScStdOut(System.out));\n        Main.main(new String[0]);\n    }","id":60106,"modified_method":"/**\n     * Starts the SIP Communicator.\n     *\n     * @param args command line args if any\n     *\n     * @throws Exception whenever it makes sense.\n     */\n    public static void main(String[] args)\n        throws Exception\n    {\n        String version = System.getProperty(\"java.version\");\n        String vmVendor = System.getProperty(\"java.vendor\");\n        String osName = System.getProperty(\"os.name\");\n\n        // disable Direct 3D pipeline (used for fullscreen) before\n        // displaying anything (frame, ...)\n        if(osName.startsWith(\"Windows\"))\n            System.setProperty(\"sun.java2d.d3d\", \"false\");\n\n        /*\n         * SC_HOME_DIR_* are specific to the OS so make sure they're configured\n         * accordingly before any other application-specific logic depending on\n         * them starts (e.g. Felix).\n         */\n        setScHomeDir(osName);\n\n        if (version.startsWith(\"1.4\") || vmVendor.startsWith(\"Gnu\") ||\n                vmVendor.startsWith(\"Free\"))\n        {\n            String os = \"\";\n\n            if (osName.startsWith(\"Mac\"))\n                os = ChangeJVMFrame.MAC_OSX;\n            else if (osName.startsWith(\"Linux\"))\n                os = ChangeJVMFrame.LINUX;\n            else if (osName.startsWith(\"Windows\"))\n                os = ChangeJVMFrame.WINDOWS;\n\n            ChangeJVMFrame changeJVMFrame = new ChangeJVMFrame(os);\n            Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n\n            changeJVMFrame.setLocation(\n                screenSize.width/2 - changeJVMFrame.getWidth()/2,\n                screenSize.height/2 - changeJVMFrame.getHeight()/2);\n            changeJVMFrame.setVisible(true);\n\n            return;\n        }\n\n        //first - pass the arguments to our arg handler\n        LaunchArgHandler argHandler = LaunchArgHandler.getInstance();\n        int argHandlerRes = argHandler.handleArgs(args);\n\n        if ( argHandlerRes == LaunchArgHandler.ACTION_EXIT\n             || argHandlerRes == LaunchArgHandler.ACTION_ERROR)\n        {\n            System.exit(argHandler.getErrorCode());\n        }\n\n        //lock our config dir so that we would only have a single instance of\n        //sip communicator, no matter how many times we start it (use mainly\n        //for handling sip: uris after starting the application)\n        if ( argHandlerRes != LaunchArgHandler.ACTION_CONTINUE_LOCK_DISABLED )\n        {\n            switch (new SipCommunicatorLock().tryLock(args))\n            {\n            case SipCommunicatorLock.LOCK_ERROR:\n                System.err.println(\"Failed to lock SIP Communicator's \"\n                                +\"configuration directory.\\n\"\n                                +\"Try launching with the --multiple param.\");\n                System.exit(SipCommunicatorLock.LOCK_ERROR);\n                break;\n            case SipCommunicatorLock.ALREADY_STARTED:\n                System.out.println(\n                    \"SIP Communicator is already running and will \"\n                    +\"handle your parameters (if any).\\n\"\n                    +\"Launch with the --multiple param to override this \"\n                    +\"behaviour.\");\n\n                //we exit with success because for the user that's what it is.\n                System.exit(SipCommunicatorLock.SUCCESS);\n                break;\n            case SipCommunicatorLock.SUCCESS:\n                //Successfully locked, continue as normal.\n                break;\n            }\n        }\n\n        //there was no error, continue;\n        System.setOut(new ScStdOut(System.out));\n        Main.main(new String[0]);\n    }","commit_id":"2ce621309bcd2e0c1e55357be173fe47ac9e2fe9","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Looks through the osgi framework for a service with a \"service.pid\"\n     * property set to <tt>id<\/tt>.\n     * @param bc the BundleContext where the service is to be looked for.\n     * @param id the value of the \"service.pid\" property for the specified\n     * service.\n     * @return a TestSuite service corresponding the specified <tt>id<\/tt>\n     * or a junit TestCase impl wrapping an exception in case we failed to\n     * retrieve the service for some reason.\n     */\n    public TestSuite getTestSuite(BundleContext bc,\n                                  final String id)\n    {\n        Object obj = null;\n\n        try\n        {\n            ServiceReference[] srl =\n                bc.getServiceReferences(null, \"(service.pid=\" + id + \")\");\n\n            if (srl == null || srl.length == 0)\n            {\n                obj = new TestCase(\"No id=\" + id)\n                {\n                    public void runTest()\n                    {\n                        throw new IllegalArgumentException(\"No test with id=\" +\n                            id);\n                    }\n                };\n            }\n            if (srl != null && srl.length != 1)\n            {\n                obj = new TestCase(\"Multiple id=\" + id)\n                {\n                    public void runTest()\n                    {\n                        throw new IllegalArgumentException(\n                            \"More than one test with id=\" + id);\n                    }\n                };\n            }\n            if (obj == null)\n            {\n                obj = bc.getService(srl[0]);\n            }\n        }\n        catch (Exception e)\n        {\n            obj = new TestCase(\"Bad filter syntax id=\" + id)\n            {\n                public void runTest()\n                {\n                    throw new IllegalArgumentException(\"Bad syntax id=\" + id);\n                }\n            };\n        }\n\n        if (! (obj instanceof Test))\n        {\n            final Object oldObj = obj;\n            obj = new TestCase(\"ClassCastException\")\n            {\n                public void runTest()\n                {\n                    throw new ClassCastException(\"Service implements \" +\n                                                 oldObj.getClass().getName() +\n                                                 \" instead of \" +\n                                                 Test.class.getName());\n                }\n            };\n        }\n\n        Test test = (Test) obj;\n\n        TestSuite suite;\n\n        if (test instanceof TestSuite)\n        {\n            suite = (TestSuite) test;\n        }\n        else\n        {\n            suite = new TestSuite(id);\n            suite.addTest(test);\n        }\n\n        return suite;\n    }","id":60107,"modified_method":"/**\n     * Looks through the osgi framework for a service with a \"service.pid\"\n     * property set to <tt>id<\/tt>.\n     * @param bc the BundleContext where the service is to be looked for.\n     * @param id the value of the \"service.pid\" property for the specified\n     * service.\n     * @return a TestSuite service corresponding the specified <tt>id<\/tt>\n     * or a junit TestCase impl wrapping an exception in case we failed to\n     * retrieve the service for some reason.\n     */\n    public TestSuite getTestSuite(BundleContext bc,\n                                  final String id)\n    {\n        Object obj = null;\n\n        try\n        {\n            ServiceReference[] srl\n                = bc.getServiceReferences(\n                        (String) null,\n                        \"(service.pid=\" + id + \")\");\n\n            if (srl == null || srl.length == 0)\n            {\n                obj = new TestCase(\"No id=\" + id)\n                {\n                    public void runTest()\n                    {\n                        throw new IllegalArgumentException(\"No test with id=\" +\n                            id);\n                    }\n                };\n            }\n            if (srl != null && srl.length != 1)\n            {\n                obj = new TestCase(\"Multiple id=\" + id)\n                {\n                    public void runTest()\n                    {\n                        throw new IllegalArgumentException(\n                            \"More than one test with id=\" + id);\n                    }\n                };\n            }\n            if (obj == null)\n            {\n                obj = bc.getService(srl[0]);\n            }\n        }\n        catch (Exception e)\n        {\n            obj = new TestCase(\"Bad filter syntax id=\" + id)\n            {\n                public void runTest()\n                {\n                    throw new IllegalArgumentException(\"Bad syntax id=\" + id);\n                }\n            };\n        }\n\n        if (! (obj instanceof Test))\n        {\n            final Object oldObj = obj;\n            obj = new TestCase(\"ClassCastException\")\n            {\n                public void runTest()\n                {\n                    throw new ClassCastException(\"Service implements \" +\n                                                 oldObj.getClass().getName() +\n                                                 \" instead of \" +\n                                                 Test.class.getName());\n                }\n            };\n        }\n\n        Test test = (Test) obj;\n\n        TestSuite suite;\n\n        if (test instanceof TestSuite)\n        {\n            suite = (TestSuite) test;\n        }\n        else\n        {\n            suite = new TestSuite(id);\n            suite.addTest(test);\n        }\n\n        return suite;\n    }","commit_id":"2ce621309bcd2e0c1e55357be173fe47ac9e2fe9","url":"https://github.com/jitsi/jitsi"},{"original_method":"public IEncodingProvider getEncodingProvider() {\n\t\treturn get(IEncodingProvider.class);\n\t}","id":60108,"modified_method":"public IEncodingProvider getEncodingProvider() {\n\t\treturn encodingProvider;\n\t}","commit_id":"d553370c0709a1296dd668ef0d67e8cf85510379","url":"https://github.com/eclipse/xtext"},{"original_method":"public IResourceValidator getResourceValidator() {\n\t\treturn get(IResourceValidator.class);\n\t}","id":60109,"modified_method":"public IResourceValidator getResourceValidator() {\n\t\treturn resourceValidator;\n\t}","commit_id":"d553370c0709a1296dd668ef0d67e8cf85510379","url":"https://github.com/eclipse/xtext"},{"original_method":"public org.eclipse.xtext.resource.IContainer.Manager getContainerManager() {\n\t\treturn get(org.eclipse.xtext.resource.IContainer.Manager.class);\n\t}","id":60110,"modified_method":"public org.eclipse.xtext.resource.IContainer.Manager getContainerManager() {\n\t\treturn containerManager;\n\t}","commit_id":"d553370c0709a1296dd668ef0d67e8cf85510379","url":"https://github.com/eclipse/xtext"},{"original_method":"public IResourceDescription.Manager getResourceDescriptionManager() {\n\t\treturn get(IResourceDescription.Manager.class);\n\t}","id":60111,"modified_method":"public IResourceDescription.Manager getResourceDescriptionManager() {\n\t\treturn resourceDescriptionManager;\n\t}","commit_id":"d553370c0709a1296dd668ef0d67e8cf85510379","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic IResourceDescription getResourceDescription(URI uri) {\n\t\tIResourceDescription liveResourceDescription = super.getResourceDescription(uri);\n\t\treturn liveResourceDescription == null ? delegate.getResourceDescription(uri) : liveResourceDescription;\n\t}","id":60112,"modified_method":"@Override\n\tpublic IResourceDescription getResourceDescription(URI uri) {\n\t\tIResourceDescription result = super.getResourceDescription(uri);\n\t\tif (result == null && !isExistingOrRenamedResourceURI(uri))\n\t\t\tresult = delegate.getResourceDescription(uri);\n\t\treturn result;\n\t}","commit_id":"d553370c0709a1296dd668ef0d67e8cf85510379","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic Iterable<IResourceDescription> getAllResourceDescriptions() {\n\t\tIterable<IResourceDescription> liveDescriptions = super.getAllResourceDescriptions();\n\t\tfinal Iterable<URI> liveDescriptionURIs = transform(liveDescriptions, new Function<IResourceDescription, URI>() {\n\t\t\tpublic URI apply(IResourceDescription from) {\n\t\t\t\treturn from.getURI();\n\t\t\t}\n\t\t}); \n\t\treturn concat(liveDescriptions, filter(delegate.getAllResourceDescriptions(),(new Predicate<IResourceDescription>() {\n\t\t\tpublic boolean apply(IResourceDescription input) {\n\t\t\t\treturn !contains(liveDescriptionURIs, input.getURI());\n\t\t\t}\n\t\t})));\n\t}","id":60113,"modified_method":"@Override\n\tpublic Iterable<IResourceDescription> getAllResourceDescriptions() {\n\t\tIterable<IResourceDescription> notInLiveResourceSet = Iterables.transform(delegate.getAllResourceDescriptions(), new Function<IResourceDescription, IResourceDescription>() {\n\t\t\tpublic IResourceDescription apply(IResourceDescription from) {\n\t\t\t\tif (isExistingOrRenamedResourceURI(from.getURI())) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn from;\n\t\t\t}\n\t\t});\n\t\tIterable<IResourceDescription> withNullEntries = Iterables.concat(super.getAllResourceDescriptions(), notInLiveResourceSet);\n\t\tIterable<IResourceDescription> result = Iterables.filter(withNullEntries, Predicates.notNull());\n\t\treturn result;\n\t}","commit_id":"d553370c0709a1296dd668ef0d67e8cf85510379","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void configure(ResourceSet resourceSet) {\n\t\tresourceSet.getLoadOptions().put(org.eclipse.xtext.resource.impl.ResourceDescriptionsProvider.LIVE_SCOPE,\n\t\t\t\tBoolean.TRUE);\n\t\texternalContentSupport.configureResourceSet(resourceSet, dirtyStateManager.getActualContentProvider());\n\t}","id":60114,"modified_method":"protected void configure(ResourceSet resourceSet) {\n\t\tresourceSet.getLoadOptions().put(org.eclipse.xtext.resource.impl.ResourceDescriptionsProvider.LIVE_SCOPE,\n\t\t\t\tBoolean.TRUE);\n\t\tif (resourceSet instanceof ResourceSetImpl) {\n\t\t\t((ResourceSetImpl) resourceSet).setURIResourceMap(Maps.<URI, Resource>newHashMap());\n\t\t}\n\t\texternalContentSupport.configureResourceSet(resourceSet, dirtyStateManager.getActualContentProvider());\n\t}","commit_id":"d553370c0709a1296dd668ef0d67e8cf85510379","url":"https://github.com/eclipse/xtext"},{"original_method":"protected String getPortableURIFragment(final EObject obj) {\n    Resource _eResource = obj.eResource();\n    final Resource res = _eResource;\n    boolean _matched = false;\n    if (!_matched) {\n      if (res instanceof XtextResource) {\n        _matched=true;\n        IResourceServiceProvider _resourceServiceProvider = ((XtextResource)res).getResourceServiceProvider();\n        IResourceDescription.Manager _resourceDescriptionManager = _resourceServiceProvider.getResourceDescriptionManager();\n        Resource _eResource_1 = obj.eResource();\n        final IResourceDescription desc = _resourceDescriptionManager.getResourceDescription(_eResource_1);\n        Iterable<IEObjectDescription> _exportedObjects = desc.getExportedObjects();\n        final Function1<IEObjectDescription, Boolean> _function = new Function1<IEObjectDescription, Boolean>() {\n          public Boolean apply(final IEObjectDescription it) {\n            boolean _xblockexpression = false;\n            {\n              EObject _eObjectOrProxy = it.getEObjectOrProxy();\n              final EObject possibleContainer = EcoreUtil.resolve(_eObjectOrProxy, res);\n              boolean _or = false;\n              boolean _equals = Objects.equal(obj, possibleContainer);\n              if (_equals) {\n                _or = true;\n              } else {\n                boolean _isAncestor = EcoreUtil.isAncestor(obj, possibleContainer);\n                _or = _isAncestor;\n              }\n              _xblockexpression = _or;\n            }\n            return Boolean.valueOf(_xblockexpression);\n          }\n        };\n        final IEObjectDescription containerDesc = IterableExtensions.<IEObjectDescription>findFirst(_exportedObjects, _function);\n        boolean _notEquals = (!Objects.equal(containerDesc, null));\n        if (_notEquals) {\n          final String fragment = this.createPortableURIFragment(containerDesc, obj);\n          return fragment;\n        }\n      }\n    }\n    return null;\n  }","id":60115,"modified_method":"/**\n   * @return a portable URI fragment, or <code>null<\/code> if the give EObject isn't itself or is not contained in an exported EObjectDescription\n   */\n  protected String getPortableURIFragment(final EObject obj) {\n    URI _uRI = EcoreUtil.getURI(obj);\n    final IResourceServiceProvider serviceProvider = this.resourceServiceProviderRegistry.getResourceServiceProvider(_uRI);\n    IResourceDescription.Manager _resourceDescriptionManager = null;\n    if (serviceProvider!=null) {\n      _resourceDescriptionManager=serviceProvider.getResourceDescriptionManager();\n    }\n    IResourceDescription _resourceDescription = null;\n    if (_resourceDescriptionManager!=null) {\n      Resource _eResource = obj.eResource();\n      _resourceDescription=_resourceDescriptionManager.getResourceDescription(_eResource);\n    }\n    final IResourceDescription desc = _resourceDescription;\n    boolean _equals = Objects.equal(desc, null);\n    if (_equals) {\n      return null;\n    }\n    Iterable<IEObjectDescription> _exportedObjects = desc.getExportedObjects();\n    final Function1<IEObjectDescription, Boolean> _function = new Function1<IEObjectDescription, Boolean>() {\n      public Boolean apply(final IEObjectDescription it) {\n        boolean _xblockexpression = false;\n        {\n          EObject _eObjectOrProxy = it.getEObjectOrProxy();\n          Resource _eResource = obj.eResource();\n          final EObject possibleContainer = EcoreUtil.resolve(_eObjectOrProxy, _eResource);\n          boolean _or = false;\n          boolean _equals = Objects.equal(obj, possibleContainer);\n          if (_equals) {\n            _or = true;\n          } else {\n            boolean _isAncestor = EcoreUtil.isAncestor(obj, possibleContainer);\n            _or = _isAncestor;\n          }\n          _xblockexpression = _or;\n        }\n        return Boolean.valueOf(_xblockexpression);\n      }\n    };\n    final IEObjectDescription containerDesc = IterableExtensions.<IEObjectDescription>findFirst(_exportedObjects, _function);\n    boolean _notEquals = (!Objects.equal(containerDesc, null));\n    if (_notEquals) {\n      final PortableURIs.PortableFragmentDescription fragmentDescription = this.createPortableFragmentDescription(containerDesc, obj);\n      return this.toFragmentString(fragmentDescription);\n    }\n    return null;\n  }","commit_id":"f1ea7d84ec8bbd8c771ee0d326483ce568bfc2a9","url":"https://github.com/eclipse/xtext"},{"original_method":"protected String createPortableURIFragment(final IEObjectDescription desc, final EObject target) {\n    EObject _eObjectOrProxy = desc.getEObjectOrProxy();\n    final EObject possibleContainer = EcoreUtil.resolve(_eObjectOrProxy, target);\n    final String fragmentToTarget = this.getFragment(target, possibleContainer);\n    EClass _eClass = desc.getEClass();\n    String _name = _eClass.getName();\n    QualifiedName _qualifiedName = desc.getQualifiedName();\n    final PortableURIs.PortableFragmentDescription portableDescription = new PortableURIs.PortableFragmentDescription(_name, _qualifiedName, fragmentToTarget);\n    return this.toFragmentString(portableDescription);\n  }","id":60116,"modified_method":"protected PortableURIs.PortableFragmentDescription createPortableFragmentDescription(final IEObjectDescription desc, final EObject target) {\n    EObject _eObjectOrProxy = desc.getEObjectOrProxy();\n    final EObject possibleContainer = EcoreUtil.resolve(_eObjectOrProxy, target);\n    final String fragmentToTarget = this.getFragment(target, possibleContainer);\n    EClass _eClass = desc.getEClass();\n    QualifiedName _qualifiedName = desc.getQualifiedName();\n    return new PortableURIs.PortableFragmentDescription(_eClass, _qualifiedName, fragmentToTarget);\n  }","commit_id":"f1ea7d84ec8bbd8c771ee0d326483ce568bfc2a9","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n    @Pure\n    public String toString() {\n      ToStringBuilder b = new ToStringBuilder(this);\n      b.add(\"descriptionEClassName\", this.descriptionEClassName);\n      b.add(\"descriptionQualifiedName\", this.descriptionQualifiedName);\n      b.add(\"descriptionRelativeFragment\", this.descriptionRelativeFragment);\n      return b.toString();\n    }","id":60117,"modified_method":"@Override\n    @Pure\n    public String toString() {\n      ToStringBuilder b = new ToStringBuilder(this);\n      b.add(\"descriptionEClass\", this.descriptionEClass);\n      b.add(\"descriptionQualifiedName\", this.descriptionQualifiedName);\n      b.add(\"descriptionRelativeFragment\", this.descriptionRelativeFragment);\n      return b.toString();\n    }","commit_id":"f1ea7d84ec8bbd8c771ee0d326483ce568bfc2a9","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n    @Pure\n    public int hashCode() {\n      final int prime = 31;\n      int result = 1;\n      result = prime * result + ((this.descriptionEClassName== null) ? 0 : this.descriptionEClassName.hashCode());\n      result = prime * result + ((this.descriptionQualifiedName== null) ? 0 : this.descriptionQualifiedName.hashCode());\n      result = prime * result + ((this.descriptionRelativeFragment== null) ? 0 : this.descriptionRelativeFragment.hashCode());\n      return result;\n    }","id":60118,"modified_method":"@Override\n    @Pure\n    public int hashCode() {\n      final int prime = 31;\n      int result = 1;\n      result = prime * result + ((this.descriptionEClass== null) ? 0 : this.descriptionEClass.hashCode());\n      result = prime * result + ((this.descriptionQualifiedName== null) ? 0 : this.descriptionQualifiedName.hashCode());\n      result = prime * result + ((this.descriptionRelativeFragment== null) ? 0 : this.descriptionRelativeFragment.hashCode());\n      return result;\n    }","commit_id":"f1ea7d84ec8bbd8c771ee0d326483ce568bfc2a9","url":"https://github.com/eclipse/xtext"},{"original_method":"public EObject resolve(final StorageAwareResource resource, final String portableFragment) {\n    final PortableURIs.PortableFragmentDescription desc = this.fromFragmentString(portableFragment);\n    final EReference mock = EcoreFactory.eINSTANCE.createEReference();\n    mock.setEType(EcorePackage.Literals.EOBJECT);\n    Predicate<IEObjectDescription> _alwaysTrue = Predicates.<IEObjectDescription>alwaysTrue();\n    final IScope scope = this.globalScopeProvider.getScope(resource, mock, _alwaysTrue);\n    Iterable<IEObjectDescription> _elements = scope.getElements(desc.descriptionQualifiedName);\n    final Function1<IEObjectDescription, Boolean> _function = new Function1<IEObjectDescription, Boolean>() {\n      public Boolean apply(final IEObjectDescription it) {\n        EClass _eClass = it.getEClass();\n        String _name = _eClass.getName();\n        return Boolean.valueOf(Objects.equal(_name, desc.descriptionEClassName));\n      }\n    };\n    final IEObjectDescription description = IterableExtensions.<IEObjectDescription>findFirst(_elements, _function);\n    boolean _equals = Objects.equal(description, null);\n    if (_equals) {\n      return null;\n    }\n    EObject _eObjectOrProxy = description.getEObjectOrProxy();\n    final EObject container = EcoreUtil.resolve(_eObjectOrProxy, resource);\n    return this.getEObject(container, desc.descriptionRelativeFragment);\n  }","id":60119,"modified_method":"/**\n   * Resolves a given portable URI fragment against the given resource.\n   * \n   * @param resource the resource from which global scope to look up the EObject\n   * @param portableFragment the portable fragment pointing to the to be resolved EObject\n   * \n   * @return the EObject for the given portableURIFragment\n   */\n  public EObject resolve(final StorageAwareResource resource, final String portableFragment) {\n    final PortableURIs.PortableFragmentDescription desc = this.fromFragmentString(portableFragment);\n    final EReference mock = EcoreFactory.eINSTANCE.createEReference();\n    mock.setEType(desc.descriptionEClass);\n    Predicate<IEObjectDescription> _alwaysTrue = Predicates.<IEObjectDescription>alwaysTrue();\n    final IScope scope = this.globalScopeProvider.getScope(resource, mock, _alwaysTrue);\n    Iterable<IEObjectDescription> _elements = scope.getElements(desc.descriptionQualifiedName);\n    final IEObjectDescription description = IterableExtensions.<IEObjectDescription>head(_elements);\n    boolean _equals = Objects.equal(description, null);\n    if (_equals) {\n      return null;\n    }\n    EObject _eObjectOrProxy = description.getEObjectOrProxy();\n    final EObject container = EcoreUtil.resolve(_eObjectOrProxy, resource);\n    return this.getEObject(container, desc.descriptionRelativeFragment);\n  }","commit_id":"f1ea7d84ec8bbd8c771ee0d326483ce568bfc2a9","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n    @Pure\n    public boolean equals(final Object obj) {\n      if (this == obj)\n        return true;\n      if (obj == null)\n        return false;\n      if (getClass() != obj.getClass())\n        return false;\n      PortableURIs.PortableFragmentDescription other = (PortableURIs.PortableFragmentDescription) obj;\n      if (this.descriptionEClassName == null) {\n        if (other.descriptionEClassName != null)\n          return false;\n      } else if (!this.descriptionEClassName.equals(other.descriptionEClassName))\n        return false;\n      if (this.descriptionQualifiedName == null) {\n        if (other.descriptionQualifiedName != null)\n          return false;\n      } else if (!this.descriptionQualifiedName.equals(other.descriptionQualifiedName))\n        return false;\n      if (this.descriptionRelativeFragment == null) {\n        if (other.descriptionRelativeFragment != null)\n          return false;\n      } else if (!this.descriptionRelativeFragment.equals(other.descriptionRelativeFragment))\n        return false;\n      return true;\n    }","id":60120,"modified_method":"@Override\n    @Pure\n    public boolean equals(final Object obj) {\n      if (this == obj)\n        return true;\n      if (obj == null)\n        return false;\n      if (getClass() != obj.getClass())\n        return false;\n      PortableURIs.PortableFragmentDescription other = (PortableURIs.PortableFragmentDescription) obj;\n      if (this.descriptionEClass == null) {\n        if (other.descriptionEClass != null)\n          return false;\n      } else if (!this.descriptionEClass.equals(other.descriptionEClass))\n        return false;\n      if (this.descriptionQualifiedName == null) {\n        if (other.descriptionQualifiedName != null)\n          return false;\n      } else if (!this.descriptionQualifiedName.equals(other.descriptionQualifiedName))\n        return false;\n      if (this.descriptionRelativeFragment == null) {\n        if (other.descriptionRelativeFragment != null)\n          return false;\n      } else if (!this.descriptionRelativeFragment.equals(other.descriptionRelativeFragment))\n        return false;\n      return true;\n    }","commit_id":"f1ea7d84ec8bbd8c771ee0d326483ce568bfc2a9","url":"https://github.com/eclipse/xtext"},{"original_method":"public PortableFragmentDescription(final String descriptionEClassName, final QualifiedName descriptionQualifiedName, final String descriptionRelativeFragment) {\n      super();\n      this.descriptionEClassName = descriptionEClassName;\n      this.descriptionQualifiedName = descriptionQualifiedName;\n      this.descriptionRelativeFragment = descriptionRelativeFragment;\n    }","id":60121,"modified_method":"public PortableFragmentDescription(final EClass descriptionEClass, final QualifiedName descriptionQualifiedName, final String descriptionRelativeFragment) {\n      super();\n      this.descriptionEClass = descriptionEClass;\n      this.descriptionQualifiedName = descriptionQualifiedName;\n      this.descriptionRelativeFragment = descriptionRelativeFragment;\n    }","commit_id":"f1ea7d84ec8bbd8c771ee0d326483ce568bfc2a9","url":"https://github.com/eclipse/xtext"},{"original_method":"protected PortableURIs.PortableFragmentDescription fromFragmentString(final String fragmentString) {\n    Splitter _on = Splitter.on(\"#\");\n    Iterable<String> _split = _on.split(fragmentString);\n    final Iterator<String> segments = _split.iterator();\n    segments.next();\n    final String eClassName = segments.next();\n    Splitter _on_1 = Splitter.on(\":\");\n    String _next = segments.next();\n    Iterable<String> _split_1 = _on_1.split(_next);\n    List<String> _list = IterableExtensions.<String>toList(_split_1);\n    final QualifiedName qname = QualifiedName.create(_list);\n    String _xifexpression = null;\n    boolean _hasNext = segments.hasNext();\n    if (_hasNext) {\n      _xifexpression = segments.next();\n    }\n    final String fragment = _xifexpression;\n    return new PortableURIs.PortableFragmentDescription(eClassName, qname, fragment);\n  }","id":60122,"modified_method":"protected PortableURIs.PortableFragmentDescription fromFragmentString(final String fragmentString) {\n    Splitter _on = Splitter.on(\"#\");\n    Iterable<String> _split = _on.split(fragmentString);\n    final Iterator<String> segments = _split.iterator();\n    segments.next();\n    String _next = segments.next();\n    String _decode = URI.decode(_next);\n    final URI eClassURI = URI.createURI(_decode);\n    URI _trimFragment = eClassURI.trimFragment();\n    String _string = _trimFragment.toString();\n    final EPackage ePackage = this.packageRegistry.getEPackage(_string);\n    Resource _eResource = null;\n    if (ePackage!=null) {\n      _eResource=ePackage.eResource();\n    }\n    EObject _eObject = null;\n    if (_eResource!=null) {\n      String _fragment = eClassURI.fragment();\n      _eObject=_eResource.getEObject(_fragment);\n    }\n    final EClass eClass = ((EClass) _eObject);\n    Splitter _on_1 = Splitter.on(\":\");\n    String _next_1 = segments.next();\n    String _decode_1 = URI.decode(_next_1);\n    Iterable<String> _split_1 = _on_1.split(_decode_1);\n    List<String> _list = IterableExtensions.<String>toList(_split_1);\n    final QualifiedName qname = QualifiedName.create(_list);\n    String _xifexpression = null;\n    boolean _hasNext = segments.hasNext();\n    if (_hasNext) {\n      String _next_2 = segments.next();\n      _xifexpression = URI.decode(_next_2);\n    }\n    final String fragment = _xifexpression;\n    EClass _elvis = null;\n    if (eClass != null) {\n      _elvis = eClass;\n    } else {\n      _elvis = EcorePackage.Literals.EOBJECT;\n    }\n    return new PortableURIs.PortableFragmentDescription(_elvis, qname, fragment);\n  }","commit_id":"f1ea7d84ec8bbd8c771ee0d326483ce568bfc2a9","url":"https://github.com/eclipse/xtext"},{"original_method":"protected String toFragmentString(final PortableURIs.PortableFragmentDescription desc) {\n    final String typeName = desc.descriptionEClassName;\n    final List<String> segments = desc.descriptionQualifiedName.getSegments();\n    String _join = IterableExtensions.join(segments, \":\");\n    String uriFragment = ((((PortableURIs.PORTABLE_SCHEME + \"#\") + typeName) + \"#\") + _join);\n    boolean _notEquals = (!Objects.equal(desc.descriptionRelativeFragment, null));\n    if (_notEquals) {\n      String _uriFragment = uriFragment;\n      uriFragment = (_uriFragment + (\"#\" + desc.descriptionRelativeFragment));\n    }\n    return uriFragment;\n  }","id":60123,"modified_method":"protected String toFragmentString(final PortableURIs.PortableFragmentDescription desc) {\n    URI _uRI = EcoreUtil.getURI(desc.descriptionEClass);\n    String _string = _uRI.toString();\n    final String eclassUriAsString = URI.encodeFragment(_string, false);\n    final List<String> segments = desc.descriptionQualifiedName.getSegments();\n    String _join = IterableExtensions.join(segments, \":\");\n    String _encodeFragment = URI.encodeFragment(_join, false);\n    String uriFragment = ((((PortableURIs.PORTABLE_SCHEME + \"#\") + eclassUriAsString) + \"#\") + _encodeFragment);\n    boolean _notEquals = (!Objects.equal(desc.descriptionRelativeFragment, null));\n    if (_notEquals) {\n      String _uriFragment = uriFragment;\n      String _encodeFragment_1 = URI.encodeFragment(desc.descriptionRelativeFragment, false);\n      String _plus = (\"#\" + _encodeFragment_1);\n      uriFragment = (_uriFragment + _plus);\n    }\n    return uriFragment;\n  }","commit_id":"f1ea7d84ec8bbd8c771ee0d326483ce568bfc2a9","url":"https://github.com/eclipse/xtext"},{"original_method":"public boolean isPortableURIFragment(final String uriFragment) {\n    return uriFragment.startsWith(PortableURIs.PORTABLE_SCHEME);\n  }","id":60124,"modified_method":"/**\n   * @return whether the given string is a portable URI fragment\n   */\n  public boolean isPortableURIFragment(final String uriFragment) {\n    return uriFragment.startsWith(PortableURIs.PORTABLE_SCHEME);\n  }","commit_id":"f1ea7d84ec8bbd8c771ee0d326483ce568bfc2a9","url":"https://github.com/eclipse/xtext"},{"original_method":"public URI toPortableURI(final StorageAwareResource res, final URI uri, final String fragment) {\n    boolean _and = false;\n    URI _uRI = res.getURI();\n    boolean _equals = Objects.equal(_uRI, uri);\n    if (!_equals) {\n      _and = false;\n    } else {\n      boolean _isCrossLinkFragment = this.lazyURIencoder.isCrossLinkFragment(res, fragment);\n      _and = _isCrossLinkFragment;\n    }\n    if (_and) {\n      final EObject result = res.getEObject(fragment);\n      boolean _or = false;\n      boolean _equals_1 = Objects.equal(result, null);\n      if (_equals_1) {\n        _or = true;\n      } else {\n        boolean _eIsProxy = result.eIsProxy();\n        _or = _eIsProxy;\n      }\n      if (_or) {\n        return uri.appendFragment(StorageAwareResource.UNRESOLVABLE_FRAGMENT);\n      } else {\n        final String portableFragment = this.getPortableURIFragment(result);\n        boolean _notEquals = (!Objects.equal(portableFragment, null));\n        if (_notEquals) {\n          URI _uRI_1 = res.getURI();\n          return _uRI_1.appendFragment(portableFragment);\n        }\n      }\n    }\n    ResourceSet _resourceSet = res.getResourceSet();\n    final Resource resource = _resourceSet.getResource(uri, false);\n    boolean _notEquals_1 = (!Objects.equal(resource, null));\n    if (_notEquals_1) {\n      final EObject obj = resource.getEObject(fragment);\n      boolean _notEquals_2 = (!Objects.equal(obj, null));\n      if (_notEquals_2) {\n        final String portableFragment_1 = this.getPortableURIFragment(obj);\n        boolean _notEquals_3 = (!Objects.equal(portableFragment_1, null));\n        if (_notEquals_3) {\n          URI _uRI_2 = res.getURI();\n          return _uRI_2.appendFragment(portableFragment_1);\n        }\n      }\n    }\n    return uri.appendFragment(fragment);\n  }","id":60125,"modified_method":"/**\n   * Creates and returns a portable URI from the given resource to the targetURI.\n   * Returns <code>null<\/code> is no portable URI can be constructed, which is the case if the\n   * targetObject is not itself exported or is a child of an exported EObject.\n   * \n   * @param sourceResource the resource from which the EObject should later be resolved\n   * @param targetURI the target URI that should be resolvable by the created portable URI\n   * \n   * @return a portable URI or <code>null<\/code>\n   */\n  public URI toPortableURI(final StorageAwareResource sourceResource, final URI targetURI) {\n    ResourceSet _resourceSet = sourceResource.getResourceSet();\n    URI _trimFragment = targetURI.trimFragment();\n    Resource _resource = _resourceSet.getResource(_trimFragment, false);\n    EObject _eObject = null;\n    if (_resource!=null) {\n      String _fragment = targetURI.fragment();\n      _eObject=_resource.getEObject(_fragment);\n    }\n    final EObject to = _eObject;\n    final URI result = this.toPortableURI(sourceResource, to);\n    boolean _notEquals = (!Objects.equal(result, null));\n    if (_notEquals) {\n      return result;\n    }\n    return null;\n  }","commit_id":"f1ea7d84ec8bbd8c771ee0d326483ce568bfc2a9","url":"https://github.com/eclipse/xtext"},{"original_method":"@Pure\n    public String getDescriptionEClassName() {\n      return this.descriptionEClassName;\n    }","id":60126,"modified_method":"@Pure\n    public EClass getDescriptionEClass() {\n      return this.descriptionEClass;\n    }","commit_id":"f1ea7d84ec8bbd8c771ee0d326483ce568bfc2a9","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n  public void testPortableUris() {\n    try {\n      final XtextResourceSet resourceSet = this.<XtextResourceSet>get(XtextResourceSet.class);\n      URI _createURI = URI.createURI(\"hubba:/bubba.langatestlanguage\");\n      Resource _createResource = resourceSet.createResource(_createURI);\n      final StorageAwareResource resourceA = ((StorageAwareResource) _createResource);\n      URI _createURI_1 = URI.createURI(\"hubba:/bubba2.langatestlanguage\");\n      Resource _createResource_1 = resourceSet.createResource(_createURI_1);\n      final StorageAwareResource resourceB = ((StorageAwareResource) _createResource_1);\n      StringConcatenation _builder = new StringConcatenation();\n      _builder.append(\"type B\");\n      _builder.newLine();\n      InputStream _asStream = this.getAsStream(_builder.toString());\n      resourceB.load(_asStream, null);\n      StringConcatenation _builder_1 = new StringConcatenation();\n      _builder_1.append(\"import \\'hubba:/bubba2.langatestlanguage\\'\");\n      _builder_1.newLine();\n      _builder_1.newLine();\n      _builder_1.append(\"type A extends B\");\n      _builder_1.newLine();\n      InputStream _asStream_1 = this.getAsStream(_builder_1.toString());\n      resourceA.load(_asStream_1, null);\n      EList<EObject> _contents = resourceA.getContents();\n      Iterable<Main> _filter = Iterables.<Main>filter(_contents, Main.class);\n      Main _head = IterableExtensions.<Main>head(_filter);\n      EList<Type> _types = _head.getTypes();\n      Type _head_1 = IterableExtensions.<Type>head(_types);\n      final Type extended = _head_1.getExtends();\n      final URI uri = EcoreUtil.getURI(extended);\n      PortableURIs _portableURIs = resourceA.getPortableURIs();\n      URI _trimFragment = uri.trimFragment();\n      String _fragment = uri.fragment();\n      final URI portableURI = _portableURIs.toPortableURI(resourceA, _trimFragment, _fragment);\n      URI _uRI = resourceA.getURI();\n      URI _trimFragment_1 = portableURI.trimFragment();\n      Assert.assertEquals(_uRI, _trimFragment_1);\n      PortableURIs _portableURIs_1 = resourceA.getPortableURIs();\n      String _fragment_1 = portableURI.fragment();\n      boolean _isPortableURIFragment = _portableURIs_1.isPortableURIFragment(_fragment_1);\n      Assert.assertTrue(_isPortableURIFragment);\n      String _fragment_2 = portableURI.fragment();\n      EObject _eObject = resourceA.getEObject(_fragment_2);\n      Assert.assertSame(extended, _eObject);\n    } catch (Throwable _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","id":60127,"modified_method":"@Test\n  public void testPortableUris() {\n    try {\n      final XtextResourceSet resourceSet = this.<XtextResourceSet>get(XtextResourceSet.class);\n      URI _createURI = URI.createURI(\"hubba:/bubba.langatestlanguage\");\n      Resource _createResource = resourceSet.createResource(_createURI);\n      final StorageAwareResource resourceA = ((StorageAwareResource) _createResource);\n      URI _createURI_1 = URI.createURI(\"hubba:/bubba2.langatestlanguage\");\n      Resource _createResource_1 = resourceSet.createResource(_createURI_1);\n      final StorageAwareResource resourceB = ((StorageAwareResource) _createResource_1);\n      StringConcatenation _builder = new StringConcatenation();\n      _builder.append(\"type B\");\n      _builder.newLine();\n      InputStream _asStream = this.getAsStream(_builder.toString());\n      resourceB.load(_asStream, null);\n      StringConcatenation _builder_1 = new StringConcatenation();\n      _builder_1.append(\"import \\'hubba:/bubba2.langatestlanguage\\'\");\n      _builder_1.newLine();\n      _builder_1.newLine();\n      _builder_1.append(\"type A extends B\");\n      _builder_1.newLine();\n      InputStream _asStream_1 = this.getAsStream(_builder_1.toString());\n      resourceA.load(_asStream_1, null);\n      EList<EObject> _contents = resourceA.getContents();\n      Iterable<Main> _filter = Iterables.<Main>filter(_contents, Main.class);\n      Main _head = IterableExtensions.<Main>head(_filter);\n      EList<Type> _types = _head.getTypes();\n      Type _head_1 = IterableExtensions.<Type>head(_types);\n      final Type extended = _head_1.getExtends();\n      final URI uri = EcoreUtil.getURI(extended);\n      PortableURIs _portableURIs = resourceA.getPortableURIs();\n      final URI portableURI = _portableURIs.toPortableURI(resourceA, uri);\n      URI _uRI = resourceA.getURI();\n      URI _trimFragment = portableURI.trimFragment();\n      Assert.assertEquals(_uRI, _trimFragment);\n      PortableURIs _portableURIs_1 = resourceA.getPortableURIs();\n      String _fragment = portableURI.fragment();\n      boolean _isPortableURIFragment = _portableURIs_1.isPortableURIFragment(_fragment);\n      Assert.assertTrue(_isPortableURIFragment);\n      String _fragment_1 = portableURI.fragment();\n      EObject _eObject = resourceA.getEObject(_fragment_1);\n      Assert.assertSame(extended, _eObject);\n    } catch (Throwable _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","commit_id":"f1ea7d84ec8bbd8c771ee0d326483ce568bfc2a9","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void writeContents(final StorageAwareResource storageAwareResource, final ZipOutputStream zipOut) {\n    try {\n      ZipEntry _zipEntry = new ZipEntry(\"emf-contents\");\n      zipOut.putNextEntry(_zipEntry);\n      Map<Object, Object> _emptyMap = CollectionLiterals.<Object, Object>emptyMap();\n      final BinaryResourceImpl.EObjectOutputStream out = new BinaryResourceImpl.EObjectOutputStream(zipOut, _emptyMap) {\n        public void writeURI(final URI uri, final String fragment) throws IOException {\n          PortableURIs _portableURIs = storageAwareResource.getPortableURIs();\n          final URI portableURI = _portableURIs.toPortableURI(storageAwareResource, uri, fragment);\n          URI _trimFragment = portableURI.trimFragment();\n          String _fragment = portableURI.fragment();\n          super.writeURI(_trimFragment, _fragment);\n        }\n      };\n      try {\n        out.saveResource(storageAwareResource);\n      } finally {\n        out.flush();\n      }\n      zipOut.closeEntry();\n    } catch (Throwable _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","id":60128,"modified_method":"protected void writeContents(final StorageAwareResource storageAwareResource, final ZipOutputStream zipOut) {\n    try {\n      ZipEntry _zipEntry = new ZipEntry(\"emf-contents\");\n      zipOut.putNextEntry(_zipEntry);\n      Map<Object, Object> _emptyMap = CollectionLiterals.<Object, Object>emptyMap();\n      final BinaryResourceImpl.EObjectOutputStream out = new BinaryResourceImpl.EObjectOutputStream(zipOut, _emptyMap) {\n        public void writeURI(final URI uri, final String fragment) throws IOException {\n          final URI fullURI = uri.appendFragment(fragment);\n          URI _elvis = null;\n          PortableURIs _portableURIs = storageAwareResource.getPortableURIs();\n          URI _portableURI = _portableURIs.toPortableURI(storageAwareResource, fullURI);\n          if (_portableURI != null) {\n            _elvis = _portableURI;\n          } else {\n            _elvis = fullURI;\n          }\n          final URI uriToWrite = _elvis;\n          URI _trimFragment = uriToWrite.trimFragment();\n          String _fragment = uriToWrite.fragment();\n          super.writeURI(_trimFragment, _fragment);\n        }\n      };\n      try {\n        out.saveResource(storageAwareResource);\n      } finally {\n        out.flush();\n      }\n      zipOut.closeEntry();\n    } catch (Throwable _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","commit_id":"f1ea7d84ec8bbd8c771ee0d326483ce568bfc2a9","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Actually generate a JSON snapshot of the beans in the given ApplicationContexts\n\t * @param contexts the set of ApplicationContexts\n\t * @return the JSON document\n\t */\n\tprotected String generateJson(Set<ConfigurableApplicationContext> contexts) {\n\t\tStringBuilder result = new StringBuilder();\n\t\tfor (ConfigurableApplicationContext context : contexts) {\n\t\t\tresult.append(\"{\\n\\\"context\\\": \\\"\").append(context.getId()).append(\"\\\"\\n\");\n\t\t\tif (context.getParent() != null) {\n\t\t\t\tresult.append(\"\\\"parent\\\": \\\"\").append(context.getParent().getId()).append(\"\\\"\\n\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.append(\"\\\"parent\\\": null\\n\");\n\t\t\t}\n\t\t\tConfigurableListableBeanFactory bf = context.getBeanFactory();\n\t\t\tString[] beanNames = bf.getBeanDefinitionNames();\n\t\t\tfor (String beanName : beanNames) {\n\t\t\t\tBeanDefinition bd = bf.getBeanDefinition(beanName);\n\t\t\t\tif (bd.getRole() != BeanDefinition.ROLE_INFRASTRUCTURE &&\n\t\t\t\t\t\t(!bd.isLazyInit() || bf.containsSingleton(beanName))) {\n\t\t\t\t\tresult.append(\"{\\n\\\"bean\\\": \\\"\").append(beanName).append(\"\\\"\\n\");\n\t\t\t\t\tString scope = bd.getScope();\n\t\t\t\t\tif (!StringUtils.hasText(scope)) {\n\t\t\t\t\t\tscope = BeanDefinition.SCOPE_SINGLETON;\n\t\t\t\t\t}\n\t\t\t\t\tresult.append(\"\\\"scope\\\": \\\"\").append(scope).append(\"\\\"\\n\");\n\t\t\t\t\tClass beanType = bf.getType(beanName);\n\t\t\t\t\tif (beanType != null) {\n\t\t\t\t\t\tresult.append(\"\\\"type\\\": \\\"\").append(beanType.getName()).append(\"\\\"\\n\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresult.append(\"\\\"type\\\": null\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tresult.append(\"\\\"resource\\\": \\\"\").append(bd.getResourceDescription()).append(\"\\\"\\n\");\n\t\t\t\t\tresult.append(\"\\\"dependencies\\\": [\");\n\t\t\t\t\tString[] dependencies = bf.getDependenciesForBean(beanName);\n\t\t\t\t\tif (dependencies.length > 0) {\n\t\t\t\t\t\tresult.append(\"\\\"\");\n\t\t\t\t\t}\n\t\t\t\t\tresult.append(StringUtils.arrayToDelimitedString(dependencies, \"\\\", \\\"\"));\n\t\t\t\t\tif (dependencies.length > 0) {\n\t\t\t\t\t\tresult.append(\"\\\"\");\n\t\t\t\t\t}\n\t\t\t\t\tresult.append(\"]\\n}\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult.append(\"}\");\n\t\t}\n\t\treturn result.toString();\n\t}","id":60129,"modified_method":"/**\n\t * Actually generate a JSON snapshot of the beans in the given ApplicationContexts.\n\t * <p>This implementation doesn't use any JSON parsing libraries in order to avoid\n\t * third-party library dependencies. It produces an array of context description\n\t * objects, each containing a context and parent attribute as well as a beans\n\t * attribute with nested bean description objects. Each bean object contains a\n\t * bean, scope, type and resource attribute, as well as a dependencies attribute\n\t * with a nested array of bean names that the present bean depends on.\n\t * @param contexts the set of ApplicationContexts\n\t * @return the JSON document\n\t */\n\tprotected String generateJson(Set<ConfigurableApplicationContext> contexts) {\n\t\tStringBuilder result = new StringBuilder(\"[\\n\");\n\t\tfor (Iterator<ConfigurableApplicationContext> it = contexts.iterator(); it.hasNext();) {\n\t\t\tConfigurableApplicationContext context = it.next();\n\t\t\tresult.append(\"{\\n\\\"context\\\": \\\"\").append(context.getId()).append(\"\\\",\\n\");\n\t\t\tif (context.getParent() != null) {\n\t\t\t\tresult.append(\"\\\"parent\\\": \\\"\").append(context.getParent().getId()).append(\"\\\",\\n\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.append(\"\\\"parent\\\": null,\\n\");\n\t\t\t}\n\t\t\tresult.append(\"\\\"beans\\\": [\\n\");\n\t\t\tConfigurableListableBeanFactory bf = context.getBeanFactory();\n\t\t\tString[] beanNames = bf.getBeanDefinitionNames();\n\t\t\tfor (int i = 0; i < beanNames.length; i++) {\n\t\t\t\tString beanName = beanNames[i];\n\t\t\t\tBeanDefinition bd = bf.getBeanDefinition(beanName);\n\t\t\t\tif (bd.getRole() != BeanDefinition.ROLE_INFRASTRUCTURE &&\n\t\t\t\t\t\t(!bd.isLazyInit() || bf.containsSingleton(beanName))) {\n\t\t\t\t\tresult.append(\"{\\n\\\"bean\\\": \\\"\").append(beanName).append(\"\\\",\\n\");\n\t\t\t\t\tString scope = bd.getScope();\n\t\t\t\t\tif (!StringUtils.hasText(scope)) {\n\t\t\t\t\t\tscope = BeanDefinition.SCOPE_SINGLETON;\n\t\t\t\t\t}\n\t\t\t\t\tresult.append(\"\\\"scope\\\": \\\"\").append(scope).append(\"\\\",\\n\");\n\t\t\t\t\tClass beanType = bf.getType(beanName);\n\t\t\t\t\tif (beanType != null) {\n\t\t\t\t\t\tresult.append(\"\\\"type\\\": \\\"\").append(beanType.getName()).append(\"\\\",\\n\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresult.append(\"\\\"type\\\": null,\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tString resource = StringUtils.replace(bd.getResourceDescription(), \"\\\\\", \"/\");\n\t\t\t\t\tresult.append(\"\\\"resource\\\": \\\"\").append(resource).append(\"\\\",\\n\");\n\t\t\t\t\tresult.append(\"\\\"dependencies\\\": [\");\n\t\t\t\t\tString[] dependencies = bf.getDependenciesForBean(beanName);\n\t\t\t\t\tif (dependencies.length > 0) {\n\t\t\t\t\t\tresult.append(\"\\\"\");\n\t\t\t\t\t}\n\t\t\t\t\tresult.append(StringUtils.arrayToDelimitedString(dependencies, \"\\\", \\\"\"));\n\t\t\t\t\tif (dependencies.length > 0) {\n\t\t\t\t\t\tresult.append(\"\\\"\");\n\t\t\t\t\t}\n\t\t\t\t\tresult.append(\"]\\n}\");\n\t\t\t\t\tif (i < beanNames.length - 1) {\n\t\t\t\t\t\tresult.append(\",\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult.append(\"]\\n\");\n\t\t\tresult.append(\"}\");\n\t\t\tif (it.hasNext()) {\n\t\t\t\tresult.append(\",\\n\");\n\t\t\t}\n\t\t}\n\t\tresult.append(\"]\");\n\t\treturn result.toString();\n\t}","commit_id":"3c557bfbc36564af11805970c07a6d35b6d229f6","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private void openFileAsGpx(File file) throws SAXException, IOException, FileNotFoundException {\n\t\tString fn = file.getName();\n\t\tif (ExtensionFileFilter.filters[ExtensionFileFilter.GPX].acceptName(fn)) {\n\t\t\tGpxReader r = null;\n\t\t\tif (file.getName().endsWith(\".gpx.gz\")) {\n\t\t\t\tr = new GpxReader(new GZIPInputStream(new FileInputStream(file)), file.getAbsoluteFile().getParentFile());\n\t\t\t} else{\n\t\t\t\tr = new GpxReader(new FileInputStream(file), file.getAbsoluteFile().getParentFile());\n\t\t\t}\n\t\t\tr.data.storageFile = file;\n\t\t\tMain.main.addLayer(new GpxLayer(r.data, fn));\n            Main.main.addLayer(new MarkerLayer(r.data, tr(\"Markers from {0}\", fn), file));\n\n\t\t} else {\n\t\t\tthrow new IllegalStateException();\n\t\t}\n    }","id":60130,"modified_method":"private void openFileAsGpx(File file) throws SAXException, IOException, FileNotFoundException {\n\t\tString fn = file.getName();\n\t\tif (ExtensionFileFilter.filters[ExtensionFileFilter.GPX].acceptName(fn)) {\n\t\t\tGpxReader r = null;\n\t\t\tif (file.getName().endsWith(\".gpx.gz\")) {\n\t\t\t\tr = new GpxReader(new GZIPInputStream(new FileInputStream(file)), file.getAbsoluteFile().getParentFile());\n\t\t\t} else{\n\t\t\t\tr = new GpxReader(new FileInputStream(file), file.getAbsoluteFile().getParentFile());\n\t\t\t}\n\t\t\tr.data.storageFile = file;\n\t\t\tMain.main.addLayer(new GpxLayer(r.data, fn));\n            MarkerLayer ml = new MarkerLayer(r.data, tr(\"Markers from {0}\", fn), file);\n            if (ml.data.size() > 0) {\n            \tMain.main.addLayer(ml);\n            }\n\n\t\t} else {\n\t\t\tthrow new IllegalStateException();\n\t\t}\n    }","commit_id":"60178ac0e381f6d87cb3c56bf73b6540e29e2fce","url":"https://github.com/openstreetmap/josm"},{"original_method":"private <L extends Layer> L addOrMergeLayer(L layer, L mergeLayer) {\n            if (layer == null) return null;\n            if (newLayer || mergeLayer == null) {\n                Main.main.addLayer(layer);\n                return layer;\n            } else {\n                mergeLayer.mergeFrom(layer);\n                Main.map.repaint();\n                return mergeLayer;\n            }\n        }","id":60131,"modified_method":"private <L extends Layer> L addOrMergeLayer(L layer, L mergeLayer) {\n            if (layer == null) return null;\n            if (newLayer || mergeLayer == null) {\n                if (Main.main != null) {\n                    Main.main.addLayer(layer);\n                }\n                return layer;\n            } else {\n                mergeLayer.mergeFrom(layer);\n                if (Main.map != null) {\n                    Main.map.repaint();\n                }\n                return mergeLayer;\n            }\n        }","commit_id":"3390cbb3c7d2ffe77a96488c91052ff6593e5069","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override protected void finish() {\n            if (rawData == null)\n                return;\n            rawData.recalculateBounds();\n            String name = tr(\"Downloaded GPX Data\");\n            GpxLayer layer = new GpxLayer(rawData, name);\n            Layer x = findMergeLayer();\n            if (newLayer || x == null)\n                Main.main.addLayer(layer);\n            else\n                x.mergeFrom(layer);\n        }","id":60132,"modified_method":"@Override protected void finish() {\n            if (lastException != null) {\n                ExceptionDialogUtil.explainException(lastException);\n                return;\n            }\n            if (rawData == null)\n                return;\n            rawData.recalculateBounds();\n            String name = tr(\"Downloaded GPX Data\");\n            GpxLayer layer = new GpxLayer(rawData, name);\n            Layer x = findMergeLayer();\n            if (newLayer || x == null) {\n                Main.main.addLayer(layer);\n            } else {\n                x.mergeFrom(layer);\n            }\n        }","commit_id":"1d582574e6edffc081b8622d1a4de1420478e266","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override public void realRun() throws IOException, SAXException, OsmTransferException {\n            rawData = reader.parseRawGps(progressMonitor.createSubTaskMonitor(ProgressMonitor.ALL_TICKS, false));\n        }","id":60133,"modified_method":"@Override public void realRun() throws IOException, SAXException, OsmTransferException {\n            try {\n                rawData = reader.parseRawGps(progressMonitor.createSubTaskMonitor(ProgressMonitor.ALL_TICKS, false));\n            } catch(OsmTransferException e) {\n                lastException = e;\n            } catch(Exception e) {\n                lastException = new OsmTransferException(e);\n            }\n        }","commit_id":"1d582574e6edffc081b8622d1a4de1420478e266","url":"https://github.com/openstreetmap/josm"},{"original_method":"public TempDirectories() throws IOException {\n    this.rootDir = TempFileUtils.createTempDirectory(\"sonar-batch\");\n    LoggerFactory.getLogger(getClass()).debug(\"Temporary directory: \" + rootDir.getAbsolutePath());\n  }","id":60134,"modified_method":"public TempDirectories() throws IOException {\n    this.rootDir = TempFileUtils.createTempDirectory(DIR_PREFIX);\n    LoggerFactory.getLogger(getClass()).debug(\"Temporary directory: \" + rootDir.getAbsolutePath());\n  }","commit_id":"eb28861955f2823b4b2e92c4a59683d16d0b8dbb","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * This method is executed by picocontainer during shutdown.\n   */\n  public void stop() {\n    directoriesByKey.clear();\n    LoggerFactory.getLogger(getClass()).debug(\"Delete temporary directory: \" + rootDir.getAbsolutePath());\n\n    // it probably does not work on MS Windows and Sun JVM. URLClassLoader locks JARs and resources.\n    FileUtils.deleteQuietly(rootDir);\n  }","id":60135,"modified_method":"/**\n   * This method is executed by picocontainer during shutdown.\n   */\n  public void stop() {\n    directoriesByKey.clear();\n\n    LoggerFactory.getLogger(getClass()).debug(\"Delete temporary directories\");\n\n    // Deleting temp directory does not work on MS Windows and Sun JVM because URLClassLoader locks JARs and resources.\n    // The workaround is that sonar deletes orphans itself.\n    rootDir.setLastModified(System.currentTimeMillis() - AGE_BEFORE_DELETION - 60 * 60 * 1000); // older than AGE_BEFORE_DELETION to be sure that the current dir is deleted on mac and linux.\n\n    File[] directoriesToDelete = rootDir.getParentFile().listFiles((FileFilter) new AndFileFilter(Arrays.asList(\n        DirectoryFileFilter.DIRECTORY, new PrefixFileFilter(DIR_PREFIX), new AgeFileFilter(System.currentTimeMillis() - AGE_BEFORE_DELETION))));\n    for (File dir : directoriesToDelete) {\n      LoggerFactory.getLogger(getClass()).debug(\"Delete temporary directory: \" + dir);\n      FileUtils.deleteQuietly(dir);\n    }\n  }","commit_id":"eb28861955f2823b4b2e92c4a59683d16d0b8dbb","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public PluginDownloader(TempDirectories tempDirs, ServerClient server) {\n    this.tempDirs = tempDirs;\n    this.server = server;\n  }","id":60136,"modified_method":"public PluginDownloader(TempDirectories workingDirectories, ServerClient server) {\n    this.workingDirectories = workingDirectories;\n    this.server = server;\n  }","commit_id":"0ce9f7a5206ae0ad678e57189de4d6c68bf35495","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public List<File> downloadPlugin(RemotePlugin remote) {\n    try {\n      File targetDir = tempDirs.getDir(\"plugins/\" + remote.getKey());\n      FileUtils.forceMkdir(targetDir);\n      LOG.debug(\"Downloading plugin \" + remote.getKey() + \" into \" + targetDir);\n\n      List<File> files = Lists.newArrayList();\n      for (String filename : remote.getFilenames()) {\n        String url = \"/deploy/plugins/\" + remote.getKey() + \"/\" + filename;\n        File toFile = new File(targetDir, filename);\n        server.download(url, toFile);\n        files.add(toFile);\n      }\n      return files;\n\n    } catch (Exception e) {\n      throw new SonarException(\"Fail to download plugin: \" + remote.getKey(), e);\n    }\n  }","id":60137,"modified_method":"public List<File> downloadPlugin(RemotePlugin remote) {\n    try {\n      File targetDir = workingDirectories.getDir(\"plugins/\" + remote.getKey());\n      FileUtils.forceMkdir(targetDir);\n      LOG.debug(\"Downloading plugin \" + remote.getKey() + \" into \" + targetDir);\n\n      List<File> files = Lists.newArrayList();\n      for (String filename : remote.getFilenames()) {\n        String url = \"/deploy/plugins/\" + remote.getKey() + \"/\" + filename;\n        File toFile = new File(targetDir, filename);\n        server.download(url, toFile);\n        files.add(toFile);\n      }\n      return files;\n\n    } catch (Exception e) {\n      throw new SonarException(\"Fail to download plugin: \" + remote.getKey(), e);\n    }\n  }","commit_id":"0ce9f7a5206ae0ad678e57189de4d6c68bf35495","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public File getFile(String dirname, String filename) {\n    File dir = getDir(dirname);\n    return new File(dir, filename);\n  }","id":60138,"modified_method":"public File getFile(String directoryKey, String filename) {\n    File dir = getDir(directoryKey);\n    return new File(dir, filename);\n  }","commit_id":"0ce9f7a5206ae0ad678e57189de4d6c68bf35495","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * Get or create a working directory\n   */\n  public File getDir(String dirname) {\n    if (StringUtils.isBlank(dirname)) {\n      return rootDir;\n    }\n\n    File dir = new File(rootDir, dirname);\n    try {\n      FileUtils.forceMkdir(dir);\n      return dir;\n    } catch (IOException e) {\n      throw new IllegalStateException(\"Fail to create temp directory: \" + dir, e);\n    }\n  }","id":60139,"modified_method":"/**\n   * Get or create a working directory\n   */\n  public File getDir(String key) {\n    if (StringUtils.isBlank(key)) {\n      return rootDir;\n    }\n\n    File dir = directoriesByKey.get(key);\n    if (dir == null) {\n      dir = new File(rootDir, key);\n      try {\n        FileUtils.forceMkdir(dir);\n        directoriesByKey.put(key, dir);\n\n      } catch (IOException e) {\n        throw new SonarException(\"Can not create the temp directory: \" + dir, e);\n      }\n    }\n    return dir;\n  }","commit_id":"0ce9f7a5206ae0ad678e57189de4d6c68bf35495","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void stop() {\n    FileUtils.deleteQuietly(rootDir);\n  }","id":60140,"modified_method":"/**\n   * This method is executed by picocontainer during shutdown.\n   */\n  public void stop() {\n    directoriesByKey.clear();\n\n    // Deleting temp directory does not work on MS Windows and Sun JVM because URLClassLoader locks JARs and resources.\n    // The workaround is that sonar deletes orphans itself.\n\n    // older than AGE_BEFORE_DELETION to be sure that the current dir is deleted on mac and linux.\n    rootDir.setLastModified(System.currentTimeMillis() - AGE_BEFORE_DELETION - 60 * 60 * 1000);\n\n    File[] directoriesToDelete = rootDir.getParentFile().listFiles((FileFilter) new AndFileFilter(Arrays.asList(\n        DirectoryFileFilter.DIRECTORY, new PrefixFileFilter(DIR_PREFIX), new AgeFileFilter(System.currentTimeMillis() - AGE_BEFORE_DELETION))));\n    for (File dir : directoriesToDelete) {\n      LoggerFactory.getLogger(getClass()).debug(\"Delete temporary directory: \" + dir);\n      FileUtils.deleteQuietly(dir);\n    }\n  }","commit_id":"0ce9f7a5206ae0ad678e57189de4d6c68bf35495","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public TempDirectories(ProjectReactor reactor) throws IOException {\n    this.rootDir = new File(reactor.getRoot().getWorkDir(), \"_tmp\");\n    if (rootDir.exists()) {\n      FileUtils.deleteDirectory(rootDir);\n    }\n    FileUtils.forceMkdir(rootDir);\n  }","id":60141,"modified_method":"public TempDirectories() throws IOException {\n    this.rootDir = TempFileUtils.createTempDirectory(DIR_PREFIX);\n    LoggerFactory.getLogger(getClass()).debug(\"Temporary directory: \" + rootDir.getAbsolutePath());\n  }","commit_id":"0ce9f7a5206ae0ad678e57189de4d6c68bf35495","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Before\n  public void before() throws IOException {\n    workDir = folder.newFolder();\n    ProjectDefinition project = ProjectDefinition.create().setKey(\"foo\").setWorkDir(workDir);\n    reactor = new ProjectReactor(project);\n  }","id":60142,"modified_method":"@Before\n  public void before() throws IOException {\n    tempDirectories = new TempDirectories();\n  }","commit_id":"0ce9f7a5206ae0ad678e57189de4d6c68bf35495","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_create_sub_directory() throws IOException {\n    tempDirectories = new TempDirectories(reactor);\n    File findbugsDir = tempDirectories.getDir(\"findbugs\");\n    assertThat(findbugsDir).isNotNull();\n    assertThat(findbugsDir).exists();\n    assertThat(findbugsDir.getParentFile()).isEqualTo(tempDirectories.getRoot());\n    assertThat(findbugsDir.getName()).isEqualTo(\"findbugs\");\n  }","id":60143,"modified_method":"@Test\n  public void shouldCreateDirectory() {\n    File findbugsDir = tempDirectories.getDir(\"findbugs\");\n    assertThat(findbugsDir).isNotNull();\n    assertThat(findbugsDir).exists();\n    assertThat(findbugsDir.getParentFile()).isEqualTo(tempDirectories.getRoot());\n    assertThat(findbugsDir.getName()).isEqualTo(\"findbugs\");\n  }","commit_id":"0ce9f7a5206ae0ad678e57189de4d6c68bf35495","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private ProjectOutcomes buildProjectOutcomes(GradleBuildInvocationSpec spec) {\n        GradleVersion gradleVersion = GradleVersion.version(spec.getGradleVersion());\n\n        GradleConnector connector = GradleConnector.newConnector().forProjectDirectory(spec.getProjectDir());\n        connector.useGradleUserHomeDir(getProject().getGradle().getStartParameter().getGradleUserHomeDir());\n        if (gradleVersion.equals(GradleVersion.current())) {\n            connector.useInstallation(getProject().getGradle().getGradleHomeDir());\n        } else {\n            connector.useGradleVersion(gradleVersion.getVersion());\n        }\n\n        ProjectConnection connection = connector.connect();\n        try {\n            List<String> tasksList = spec.getTasks();\n            String[] tasks = tasksList.toArray(new String[tasksList.size()]);\n            List<String> argumentsList = getImpliedArguments(spec);\n            String[] arguments = argumentsList.toArray(new String[argumentsList.size()]);\n\n            // Run the build and get the build outcomes model\n            ModelBuilder<ProjectOutcomes> modelBuilder = connection.model(ProjectOutcomes.class);\n            return modelBuilder.\n                    withArguments(arguments).\n                    forTasks(tasks).\n                    get();\n        } finally {\n            connection.close();\n        }\n    }","id":60144,"modified_method":"private ProjectOutcomes buildProjectOutcomesOrJustExec(GradleBuildInvocationSpec spec, boolean justExec) {\n        GradleVersion gradleVersion = GradleVersion.version(spec.getGradleVersion());\n\n        GradleConnector connector = GradleConnector.newConnector().forProjectDirectory(spec.getProjectDir());\n        File gradleUserHomeDir = getProject().getGradle().getStartParameter().getGradleUserHomeDir();\n        if (gradleUserHomeDir != null) {\n            connector.useGradleUserHomeDir(gradleUserHomeDir);\n        }\n        if (gradleVersion.equals(GradleVersion.current())) {\n            connector.useInstallation(getProject().getGradle().getGradleHomeDir());\n        } else {\n            connector.useGradleVersion(gradleVersion.getVersion());\n        }\n\n        ProjectConnection connection = connector.connect();\n        try {\n            List<String> tasksList = spec.getTasks();\n            String[] tasks = tasksList.toArray(new String[tasksList.size()]);\n            List<String> argumentsList = getImpliedArguments(spec);\n            String[] arguments = argumentsList.toArray(new String[argumentsList.size()]);\n\n            if (justExec) {\n                BuildLauncher buildLauncher = connection.newBuild();\n                buildLauncher.\n                        withArguments(arguments).\n                        forTasks(tasks).\n                        run();\n\n                return null;\n            } else {\n                // Run the build and get the build outcomes model\n                ModelBuilder<ProjectOutcomes> modelBuilder = connection.model(ProjectOutcomes.class);\n                return modelBuilder.\n                        withArguments(arguments).\n                        forTasks(tasks).\n                        get();\n            }\n        } finally {\n            connection.close();\n        }\n    }","commit_id":"09ecee27488fcb34a5136f48fdde785d311af022","url":"https://github.com/gradle/gradle"},{"original_method":"@TaskAction\n    void compare() {\n        if (sourceBuild.equals(targetBuild)) {\n            getLogger().warn(\"The source build and target build are identical. Set '{}.targetBuild.gradleVersion' if you want to compare with a different Gradle version.\", getName());\n        }\n\n        boolean sourceBuildHasOutcomesModel = canObtainProjectOutcomesModel(sourceBuild);\n        boolean targetBuildHasOutcomesModel = canObtainProjectOutcomesModel(targetBuild);\n\n        if (!sourceBuildHasOutcomesModel && !targetBuildHasOutcomesModel) {\n            throw new GradleException(String.format(\n                    \"Cannot run comparison because both the source and target build are to be executed with a Gradle version older than %s (source: %s, target: %s).\",\n                    PROJECT_OUTCOMES_MINIMUM_VERSION, sourceBuild.getGradleVersion(), targetBuild.getGradleVersion()\n            ));\n        }\n\n        ProgressLogger progressLogger = progressLoggerFactory.newOperation(getClass());\n\n        progressLogger.setDescription(\"Gradle Build Comparison\");\n        progressLogger.setShortDescription(getName());\n\n        // Build the outcome model and outcomes\n        progressLogger.started(\"executing source build\");\n        GradleBuildOutcomeSetTransformer fromOutcomeTransformer = createOutcomeSetTransformer(\"source\");\n        ProjectOutcomes fromOutput = buildProjectOutcomes(getSourceBuild());\n        progressLogger.progress(\"inspecting source build outcomes\");\n        Set<BuildOutcome> fromOutcomes = fromOutcomeTransformer.transform(fromOutput);\n\n        progressLogger.progress(\"executing target build\");\n        GradleBuildOutcomeSetTransformer toOutcomeTransformer = createOutcomeSetTransformer(\"target\");\n        ProjectOutcomes toOutput = buildProjectOutcomes(getTargetBuild());\n        progressLogger.progress(\"inspecting target build outcomes\");\n        Set<BuildOutcome> toOutcomes = toOutcomeTransformer.transform(toOutput);\n\n        progressLogger.progress(\"preparing for comparison\");\n\n        // Infrastructure that we have to register handlers with\n        DefaultBuildOutcomeComparatorFactory comparatorFactory = new DefaultBuildOutcomeComparatorFactory();\n        BuildOutcomeAssociator[] associators = new BuildOutcomeAssociator[2];\n        DefaultBuildOutcomeComparisonResultRendererFactory<HtmlRenderContext> renderers = new DefaultBuildOutcomeComparisonResultRendererFactory<HtmlRenderContext>(HtmlRenderContext.class);\n\n        // Register archives\n        associators[0] = new ByTypeAndNameBuildOutcomeAssociator<BuildOutcome>(GeneratedArchiveBuildOutcome.class);\n        comparatorFactory.registerComparator(new GeneratedArchiveBuildOutcomeComparator());\n        renderers.registerRenderer(new GeneratedArchiveBuildOutcomeComparisonResultHtmlRenderer(\"Source Build\", \"Target Build\"));\n\n        // Register unknown handling\n        associators[1] = new ByTypeAndNameBuildOutcomeAssociator<BuildOutcome>(UnknownBuildOutcome.class);\n        comparatorFactory.registerComparator(new UnknownBuildOutcomeComparator());\n        renderers.registerRenderer(new UnknownBuildOutcomeComparisonResultHtmlRenderer(\"Source Build\", \"Target Build\"));\n\n        // Associate from each side (create spec)\n        BuildOutcomeAssociator compositeAssociator = new CompositeBuildOutcomeAssociator(associators);\n        BuildComparisonSpecFactory specFactory = new BuildComparisonSpecFactory(compositeAssociator);\n        BuildComparisonSpec comparisonSpec = specFactory.createSpec(fromOutcomes, toOutcomes);\n\n        progressLogger.progress(\"comparing build outcomes\");\n\n        // Compare\n        BuildComparator buildComparator = new DefaultBuildComparator(comparatorFactory);\n        BuildComparisonResult result = buildComparator.compareBuilds(comparisonSpec);\n\n        writeReport(result, renderers);\n\n        progressLogger.completed();\n\n        communicateResult(result);\n    }","id":60145,"modified_method":"@TaskAction\n    void compare() {\n        if (sourceBuild.equals(targetBuild)) {\n            getLogger().warn(\"The source build and target build are identical. Set '{}.targetBuild.gradleVersion' if you want to compare with a different Gradle version.\", getName());\n        }\n\n        boolean sourceBuildHasOutcomesModel = canObtainProjectOutcomesModel(sourceBuild);\n        boolean targetBuildHasOutcomesModel = canObtainProjectOutcomesModel(targetBuild);\n\n        if (!sourceBuildHasOutcomesModel && !targetBuildHasOutcomesModel) {\n            throw new GradleException(String.format(\n                    \"Cannot run comparison because both the source and target build are to be executed with a Gradle version older than %s (source: %s, target: %s).\",\n                    PROJECT_OUTCOMES_MINIMUM_VERSION, sourceBuild.getGradleVersion(), targetBuild.getGradleVersion()\n            ));\n        }\n\n        ProgressLogger progressLogger = progressLoggerFactory.newOperation(getClass());\n\n        progressLogger.setDescription(\"Gradle Build Comparison\");\n        progressLogger.setShortDescription(getName());\n\n        // Build the outcome model and outcomes\n\n        Set<BuildOutcome> fromOutcomes = null;\n        if (sourceBuildHasOutcomesModel) {\n            progressLogger.started(\"executing source build\");\n            ProjectOutcomes fromOutput = buildProjectOutcomesOrJustExec(getSourceBuild(), false);\n            progressLogger.progress(\"inspecting source build outcomes\");\n            GradleBuildOutcomeSetTransformer fromOutcomeTransformer = createOutcomeSetTransformer(SOURCE_FILESTORE_PREFIX);\n            fromOutcomes = fromOutcomeTransformer.transform(fromOutput);\n        }\n\n        if (sourceBuildHasOutcomesModel) {\n            progressLogger.progress(\"executing target build\");\n        } else {\n            progressLogger.started(\"executing target build\");\n        }\n\n        ProjectOutcomes toOutput = buildProjectOutcomesOrJustExec(getTargetBuild(), !targetBuildHasOutcomesModel);\n\n        Set<BuildOutcome> toOutcomes = null;\n        if (targetBuildHasOutcomesModel) {\n            progressLogger.progress(\"inspecting target build outcomes\");\n            GradleBuildOutcomeSetTransformer toOutcomeTransformer = createOutcomeSetTransformer(TARGET_FILESTORE_PREFIX);\n            toOutcomes = toOutcomeTransformer.transform(toOutput);\n        } else {\n            toOutcomes = createOutcomeSetInferrer(TARGET_FILESTORE_PREFIX, getTargetBuild().getProjectDir()).transform(fromOutcomes);\n        }\n\n        if (!sourceBuildHasOutcomesModel) {\n            progressLogger.progress(\"executing source build\");\n            buildProjectOutcomesOrJustExec(getSourceBuild(), true);\n            progressLogger.progress(\"inspecting source build outcomes\");\n            fromOutcomes = createOutcomeSetInferrer(SOURCE_FILESTORE_PREFIX, getSourceBuild().getProjectDir()).transform(toOutcomes);\n        }\n\n        progressLogger.progress(\"preparing for comparison\");\n\n        // Infrastructure that we have to register handlers with\n        DefaultBuildOutcomeComparatorFactory comparatorFactory = new DefaultBuildOutcomeComparatorFactory();\n        BuildOutcomeAssociator[] associators = new BuildOutcomeAssociator[2];\n        DefaultBuildOutcomeComparisonResultRendererFactory<HtmlRenderContext> renderers = new DefaultBuildOutcomeComparisonResultRendererFactory<HtmlRenderContext>(HtmlRenderContext.class);\n\n        // Register archives\n        associators[0] = new ByTypeAndNameBuildOutcomeAssociator<BuildOutcome>(GeneratedArchiveBuildOutcome.class);\n        comparatorFactory.registerComparator(new GeneratedArchiveBuildOutcomeComparator());\n        renderers.registerRenderer(new GeneratedArchiveBuildOutcomeComparisonResultHtmlRenderer(\"Source Build\", \"Target Build\"));\n\n        // Register unknown handling\n        associators[1] = new ByTypeAndNameBuildOutcomeAssociator<BuildOutcome>(UnknownBuildOutcome.class);\n        comparatorFactory.registerComparator(new UnknownBuildOutcomeComparator());\n        renderers.registerRenderer(new UnknownBuildOutcomeComparisonResultHtmlRenderer(\"Source Build\", \"Target Build\"));\n\n        // Associate from each side (create spec)\n        BuildOutcomeAssociator compositeAssociator = new CompositeBuildOutcomeAssociator(associators);\n        BuildComparisonSpecFactory specFactory = new BuildComparisonSpecFactory(compositeAssociator);\n        BuildComparisonSpec comparisonSpec = specFactory.createSpec(fromOutcomes, toOutcomes);\n\n        progressLogger.progress(\"comparing build outcomes\");\n\n        // Compare\n        BuildComparator buildComparator = new DefaultBuildComparator(comparatorFactory);\n        BuildComparisonResult result = buildComparator.compareBuilds(comparisonSpec);\n\n        writeReport(result, renderers);\n\n        progressLogger.completed();\n\n        communicateResult(result);\n    }","commit_id":"09ecee27488fcb34a5136f48fdde785d311af022","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * The generated archive, may be null.\n     *\n     * If null, the archives was expected to have been generated but was not.\n     *\n     * @return The generated archive, or null if no archive was generated.\n     */\n    public File getArchiveFile() {\n        return fileStoreEntry.getFile();\n    }","id":60146,"modified_method":"/**\n     * The generated archive, may be null.\n     *\n     * If null, the archives was expected to have been generated but was not.\n     *\n     * @return The generated archive, or null if no archive was generated.\n     */\n    public File getArchiveFile() {\n        return fileStoreEntry == null ? null : fileStoreEntry.getFile();\n    }","commit_id":"09ecee27488fcb34a5136f48fdde785d311af022","url":"https://github.com/gradle/gradle"},{"original_method":"private void readClasspathEntry(ModifiableRootModel rootModel,\n                                  final Collection<String> unknownLibraries,\n                                  Collection<String> unknownJdks,\n                                  final Set<String> usedVariables,\n                                  Set<String> refsToModules,\n                                  final String testPattern,\n                                  Element element, int idx) throws ConversionException {\n    String kind = element.getAttributeValue(EclipseXml.KIND_ATTR);\n    if (kind == null) {\n      throw new ConversionException(\"Missing classpathentry/@kind\");\n    }\n\n\n    String path = element.getAttributeValue(EclipseXml.PATH_ATTR);\n    if (path == null) {\n      throw new ConversionException(\"Missing classpathentry/@path\");\n    }\n\n    final boolean exported = EclipseXml.TRUE_VALUE.equals(element.getAttributeValue(EclipseXml.EXPORTED_ATTR));\n\n    final EclipseModuleManager eclipseModuleManager = EclipseModuleManager.getInstance(rootModel.getModule());\n    if (kind.equals(EclipseXml.SRC_KIND)) {\n      if (path.startsWith(\"/\")) {\n        final String moduleName = path.substring(1);\n        refsToModules.add(moduleName);\n        rootModel.addInvalidModuleEntry(moduleName).setExported(exported);\n      }\n      else {\n        String srcUrl = VfsUtil.pathToUrl(myRootPath + \"/\" + path);\n        final boolean isTestFolder = testPattern != null && testPattern.length() > 0 && path.matches(testPattern);\n        if (EclipseProjectFinder.isExternalResource(myRootPath, path)) {\n          final String varName = EclipseProjectFinder.extractPathVariableName(path);\n          usedVariables.add(varName);\n\n          final String toPathVariableFormat =\n            getVariableRelatedPath(varName, path.length() > varName.length() ? path.substring(varName.length()) : null);\n          srcUrl = VfsUtil.pathToUrl(PathMacroManager.getInstance(rootModel.getModule()).expandPath(toPathVariableFormat));\n          eclipseModuleManager.registerEclipseLinkedSrcVarPath(srcUrl, path);\n\n          rootModel.addContentEntry(srcUrl).addSourceFolder(srcUrl, isTestFolder);\n        } else {\n          getContentEntry().addSourceFolder(srcUrl, isTestFolder);\n        }\n        eclipseModuleManager.setExpectedModuleSourcePlace(rearrangeOrderEntryOfType(rootModel, ModuleSourceOrderEntry.class));\n        eclipseModuleManager.registerSrcPlace(srcUrl, idx);\n      }\n    }\n\n    else if (kind.equals(EclipseXml.OUTPUT_KIND)) {\n      setupOutput(rootModel, myRootPath + \"/\" + path);\n    }\n\n    else if (kind.equals(EclipseXml.LIB_KIND)) {\n      final String libName = getPresentableName(path);\n      final Library library = rootModel.getModuleLibraryTable().getModifiableModel().createLibrary(libName);\n      final Library.ModifiableModel modifiableModel = library.getModifiableModel();\n\n      final String url = expandEclipsePath2Url(path, rootModel, myCurrentRoots);\n      modifiableModel.addRoot(url, OrderRootType.CLASSES);\n      eclipseModuleManager.registerEclipseLibUrl(url);\n\n      final String sourcePath = element.getAttributeValue(EclipseXml.SOURCEPATH_ATTR);\n      if (sourcePath != null) {\n        final String srcUrl = expandEclipsePath2Url(sourcePath, rootModel, myCurrentRoots);\n        modifiableModel.addRoot(srcUrl, OrderRootType.SOURCES);\n      }\n\n      EJavadocUtil.appendJavadocRoots(element, rootModel, myCurrentRoots, modifiableModel);\n      modifiableModel.commit();\n\n      setLibraryEntryExported(rootModel, exported, library);\n    }\n    else if (kind.equals(EclipseXml.VAR_KIND)) {\n      int slash = path.indexOf(\"/\");\n      if (slash == 0) {\n        throw new ConversionException(\"Incorrect 'classpathentry/var@path' format\");\n      }\n\n      final String libName = getPresentableName(path);\n      final Library library = rootModel.getModuleLibraryTable().getModifiableModel().createLibrary(libName);\n      final Library.ModifiableModel modifiableModel = library.getModifiableModel();\n\n      final String url = eclipseVariabledPath2Url(rootModel, usedVariables, path, 0);\n      modifiableModel.addRoot(url, OrderRootType.CLASSES);\n      eclipseModuleManager.registerEclipseVariablePath(url, path);\n\n      final String srcPathAttr = element.getAttributeValue(EclipseXml.SOURCEPATH_ATTR);\n      if (srcPathAttr != null) {\n        final String srcUrl = eclipseVariabledPath2Url(rootModel, usedVariables, srcPathAttr, srcVarStart(srcPathAttr));\n        modifiableModel.addRoot(srcUrl, OrderRootType.SOURCES);\n        eclipseModuleManager.registerEclipseSrcVariablePath(srcUrl, srcPathAttr);\n      }\n\n      EJavadocUtil.appendJavadocRoots(element, rootModel, myCurrentRoots, modifiableModel);\n\n      modifiableModel.commit();\n\n      setLibraryEntryExported(rootModel, exported, library);\n    }\n    else if (kind.equals(EclipseXml.CON_KIND)) {\n      if (path.equals(EclipseXml.ECLIPSE_PLATFORM)) {\n        addNamedLibrary(rootModel, unknownLibraries, exported, IdeaXml.ECLIPSE_LIBRARY, LibraryTablesRegistrar.APPLICATION_LEVEL);\n      }\n      else if (path.startsWith(EclipseXml.JRE_CONTAINER)) {\n\n        final String jdkName = getLastPathComponent(path);\n        if (jdkName == null) {\n          rootModel.inheritSdk();\n        }\n        else {\n          final Sdk moduleJdk = ProjectJdkTable.getInstance().findJdk(jdkName);\n          if (moduleJdk != null) {\n            rootModel.setSdk(moduleJdk);\n          }\n          else {\n            rootModel.setInvalidSdk(jdkName, IdeaXml.JAVA_SDK_TYPE);\n            unknownJdks.add(jdkName);\n          }\n        }\n        rearrangeOrderEntryOfType(rootModel, JdkOrderEntry.class);\n      }\n      else if (path.startsWith(EclipseXml.USER_LIBRARY)) {\n        addNamedLibrary(rootModel, unknownLibraries, exported, getPresentableName(path), LibraryTablesRegistrar.PROJECT_LEVEL);\n      }\n      else if (path.startsWith(EclipseXml.JUNIT_CONTAINER)) {\n        final String junitName = IdeaXml.JUNIT + getPresentableName(path);\n        final Library library = rootModel.getModuleLibraryTable().getModifiableModel().createLibrary(junitName);\n        final Library.ModifiableModel modifiableModel = library.getModifiableModel();\n        modifiableModel.addRoot(getJunitClsUrl(junitName.contains(\"4\")), OrderRootType.CLASSES);\n        modifiableModel.commit();\n      } else {\n        eclipseModuleManager.registerUnknownCons(path);\n        addNamedLibrary(rootModel, new ArrayList<String>(), exported, path, LibraryTablesRegistrar.APPLICATION_LEVEL);\n      }\n    }\n    else {\n      throw new ConversionException(\"Unknown classpathentry/@kind: \" + kind);\n    }\n  }","id":60147,"modified_method":"private void readClasspathEntry(ModifiableRootModel rootModel,\n                                  final Collection<String> unknownLibraries,\n                                  Collection<String> unknownJdks,\n                                  final Set<String> usedVariables,\n                                  Set<String> refsToModules,\n                                  final String testPattern,\n                                  Element element, int idx) throws ConversionException {\n    String kind = element.getAttributeValue(EclipseXml.KIND_ATTR);\n    if (kind == null) {\n      throw new ConversionException(\"Missing classpathentry/@kind\");\n    }\n\n\n    String path = element.getAttributeValue(EclipseXml.PATH_ATTR);\n    if (path == null) {\n      throw new ConversionException(\"Missing classpathentry/@path\");\n    }\n\n    final boolean exported = EclipseXml.TRUE_VALUE.equals(element.getAttributeValue(EclipseXml.EXPORTED_ATTR));\n\n    final EclipseModuleManager eclipseModuleManager = EclipseModuleManager.getInstance(rootModel.getModule());\n    if (kind.equals(EclipseXml.SRC_KIND)) {\n      if (path.startsWith(\"/\")) {\n        final String moduleName = path.substring(1);\n        refsToModules.add(moduleName);\n        rootModel.addInvalidModuleEntry(moduleName).setExported(exported);\n      }\n      else {\n        String srcUrl = VfsUtil.pathToUrl(myRootPath + \"/\" + path);\n        final boolean isTestFolder = testPattern != null && testPattern.length() > 0 && path.matches(testPattern);\n        if (EclipseProjectFinder.isExternalResource(myRootPath, path)) {\n          srcUrl = VfsUtil.pathToUrl(getExpandedLinkedResourcePath(rootModel, usedVariables, path));\n          eclipseModuleManager.registerEclipseLinkedSrcVarPath(srcUrl, path);\n          rootModel.addContentEntry(srcUrl).addSourceFolder(srcUrl, isTestFolder);\n        } else {\n          getContentEntry().addSourceFolder(srcUrl, isTestFolder);\n        }\n        eclipseModuleManager.setExpectedModuleSourcePlace(rearrangeOrderEntryOfType(rootModel, ModuleSourceOrderEntry.class));\n        eclipseModuleManager.registerSrcPlace(srcUrl, idx);\n      }\n    }\n\n    else if (kind.equals(EclipseXml.OUTPUT_KIND)) {\n      String output = myRootPath + \"/\" + path;\n      if (EclipseProjectFinder.isExternalResource(myRootPath, path)) {\n        output = getExpandedLinkedResourcePath(rootModel, usedVariables, path);\n        eclipseModuleManager.registerEclipseLinkedVarPath(VfsUtil.pathToUrl(output), path);\n      }\n      setupOutput(rootModel, output);\n    }\n\n    else if (kind.equals(EclipseXml.LIB_KIND)) {\n      final String libName = getPresentableName(path);\n      final Library library = rootModel.getModuleLibraryTable().getModifiableModel().createLibrary(libName);\n      final Library.ModifiableModel modifiableModel = library.getModifiableModel();\n\n      final String url = expandEclipsePath2Url(path, rootModel, myCurrentRoots);\n      modifiableModel.addRoot(url, OrderRootType.CLASSES);\n      eclipseModuleManager.registerEclipseLibUrl(url);\n\n      final String sourcePath = element.getAttributeValue(EclipseXml.SOURCEPATH_ATTR);\n      if (sourcePath != null) {\n        final String srcUrl = expandEclipsePath2Url(sourcePath, rootModel, myCurrentRoots);\n        modifiableModel.addRoot(srcUrl, OrderRootType.SOURCES);\n      }\n\n      EJavadocUtil.appendJavadocRoots(element, rootModel, myCurrentRoots, modifiableModel);\n      modifiableModel.commit();\n\n      setLibraryEntryExported(rootModel, exported, library);\n    }\n    else if (kind.equals(EclipseXml.VAR_KIND)) {\n      int slash = path.indexOf(\"/\");\n      if (slash == 0) {\n        throw new ConversionException(\"Incorrect 'classpathentry/var@path' format\");\n      }\n\n      final String libName = getPresentableName(path);\n      final Library library = rootModel.getModuleLibraryTable().getModifiableModel().createLibrary(libName);\n      final Library.ModifiableModel modifiableModel = library.getModifiableModel();\n\n      final String url = eclipseVariabledPath2Url(rootModel, usedVariables, path, 0);\n      modifiableModel.addRoot(url, OrderRootType.CLASSES);\n      eclipseModuleManager.registerEclipseVariablePath(url, path);\n\n      final String srcPathAttr = element.getAttributeValue(EclipseXml.SOURCEPATH_ATTR);\n      if (srcPathAttr != null) {\n        final String srcUrl = eclipseVariabledPath2Url(rootModel, usedVariables, srcPathAttr, srcVarStart(srcPathAttr));\n        modifiableModel.addRoot(srcUrl, OrderRootType.SOURCES);\n        eclipseModuleManager.registerEclipseSrcVariablePath(srcUrl, srcPathAttr);\n      }\n\n      EJavadocUtil.appendJavadocRoots(element, rootModel, myCurrentRoots, modifiableModel);\n\n      modifiableModel.commit();\n\n      setLibraryEntryExported(rootModel, exported, library);\n    }\n    else if (kind.equals(EclipseXml.CON_KIND)) {\n      if (path.equals(EclipseXml.ECLIPSE_PLATFORM)) {\n        addNamedLibrary(rootModel, unknownLibraries, exported, IdeaXml.ECLIPSE_LIBRARY, LibraryTablesRegistrar.APPLICATION_LEVEL);\n      }\n      else if (path.startsWith(EclipseXml.JRE_CONTAINER)) {\n\n        final String jdkName = getLastPathComponent(path);\n        if (jdkName == null) {\n          rootModel.inheritSdk();\n        }\n        else {\n          final Sdk moduleJdk = ProjectJdkTable.getInstance().findJdk(jdkName);\n          if (moduleJdk != null) {\n            rootModel.setSdk(moduleJdk);\n          }\n          else {\n            rootModel.setInvalidSdk(jdkName, IdeaXml.JAVA_SDK_TYPE);\n            unknownJdks.add(jdkName);\n          }\n        }\n        rearrangeOrderEntryOfType(rootModel, JdkOrderEntry.class);\n      }\n      else if (path.startsWith(EclipseXml.USER_LIBRARY)) {\n        addNamedLibrary(rootModel, unknownLibraries, exported, getPresentableName(path), LibraryTablesRegistrar.PROJECT_LEVEL);\n      }\n      else if (path.startsWith(EclipseXml.JUNIT_CONTAINER)) {\n        final String junitName = IdeaXml.JUNIT + getPresentableName(path);\n        final Library library = rootModel.getModuleLibraryTable().getModifiableModel().createLibrary(junitName);\n        final Library.ModifiableModel modifiableModel = library.getModifiableModel();\n        modifiableModel.addRoot(getJunitClsUrl(junitName.contains(\"4\")), OrderRootType.CLASSES);\n        modifiableModel.commit();\n      } else {\n        eclipseModuleManager.registerUnknownCons(path);\n        addNamedLibrary(rootModel, new ArrayList<String>(), exported, path, LibraryTablesRegistrar.APPLICATION_LEVEL);\n      }\n    }\n    else {\n      throw new ConversionException(\"Unknown classpathentry/@kind: \" + kind);\n    }\n  }","commit_id":"d60ccf99e0a3be62a5bff674db9c78c77c4df3a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void collectVariables(Set<String> usedVariables, Element classpathElement, final String rootPath) {\n    for (Object o : classpathElement.getChildren(EclipseXml.CLASSPATHENTRY_TAG)) {\n      final Element element = (Element)o;\n      String path = element.getAttributeValue(EclipseXml.PATH_ATTR);\n      if (path == null) continue;\n      final String kind = element.getAttributeValue(EclipseXml.KIND_ATTR);\n      if (Comparing.strEqual(kind, EclipseXml.VAR_KIND)) {\n        createEPathVariable(usedVariables, path, 0);\n        final String srcPath = element.getAttributeValue(EclipseXml.SOURCEPATH_ATTR);\n        if (srcPath != null) {\n          createEPathVariable(usedVariables, srcPath, srcVarStart(srcPath));\n        }\n      } else if (Comparing.strEqual(kind, EclipseXml.SRC_KIND)) {\n        if (EclipseProjectFinder.isExternalResource(rootPath, path)) {\n          usedVariables.add(EclipseProjectFinder.extractPathVariableName(path));\n        }\n      }\n    }\n  }","id":60148,"modified_method":"public static void collectVariables(Set<String> usedVariables, Element classpathElement, final String rootPath) {\n    for (Object o : classpathElement.getChildren(EclipseXml.CLASSPATHENTRY_TAG)) {\n      final Element element = (Element)o;\n      String path = element.getAttributeValue(EclipseXml.PATH_ATTR);\n      if (path == null) continue;\n      final String kind = element.getAttributeValue(EclipseXml.KIND_ATTR);\n      if (Comparing.strEqual(kind, EclipseXml.VAR_KIND)) {\n        createEPathVariable(usedVariables, path, 0);\n        final String srcPath = element.getAttributeValue(EclipseXml.SOURCEPATH_ATTR);\n        if (srcPath != null) {\n          createEPathVariable(usedVariables, srcPath, srcVarStart(srcPath));\n        }\n      } else if (Comparing.strEqual(kind, EclipseXml.SRC_KIND) || Comparing.strEqual(kind, EclipseXml.OUTPUT_KIND)) {\n        if (EclipseProjectFinder.isExternalResource(rootPath, path)) {\n          final String linkedLocation = EclipseProjectFinder.replaceLinkedPathLocationVariable(rootPath, path);\n          usedVariables.add(EclipseProjectFinder.extractPathVariableName(linkedLocation));\n        }\n      }\n    }\n  }","commit_id":"d60ccf99e0a3be62a5bff674db9c78c77c4df3a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void writeClasspath(Element classpathElement, @Nullable Element oldRoot) throws ConversionException {\n    if (oldRoot != null) {\n      for (Object o : oldRoot.getChildren(EclipseXml.CLASSPATHENTRY_TAG)) {\n        final Element oldChild = (Element)o;\n        final String oldKind = oldChild.getAttributeValue(EclipseXml.KIND_ATTR);\n        final String oldPath = oldChild.getAttributeValue(EclipseXml.PATH_ATTR);\n        myOldEntries.put(oldKind + getJREKey(oldPath), oldChild);\n      }\n    }\n\n    for (OrderEntry orderEntry : myModel.getOrderEntries()) {\n      createClasspathEntry(orderEntry, classpathElement);\n    }\n\n    @NonNls String outputPath = \"bin\";\n    final VirtualFile contentRoot = EPathUtil.getContentRoot(myModel);\n    final VirtualFile output = myModel.getModuleExtension(CompilerModuleExtension.class).getCompilerOutputPath();\n    if (contentRoot != null && output != null && VfsUtil.isAncestor(contentRoot, output, false)) {\n      outputPath = EPathUtil.collapse2EclipsePath(output.getUrl(), myModel);\n    }\n    else if (output == null) {\n      final String url = myModel.getModuleExtension(CompilerModuleExtension.class).getCompilerOutputUrl();\n      if (url != null) {\n        outputPath = EPathUtil.collapse2EclipsePath(url, myModel);\n      }\n    }\n    final Element orderEntry = addOrderEntry(EclipseXml.OUTPUT_KIND, outputPath, classpathElement);\n    setAttributeIfAbsent(orderEntry, EclipseXml.PATH_ATTR, EclipseXml.BIN_DIR);\n  }","id":60149,"modified_method":"public void writeClasspath(Element classpathElement, @Nullable Element oldRoot) throws ConversionException {\n    if (oldRoot != null) {\n      for (Object o : oldRoot.getChildren(EclipseXml.CLASSPATHENTRY_TAG)) {\n        final Element oldChild = (Element)o;\n        final String oldKind = oldChild.getAttributeValue(EclipseXml.KIND_ATTR);\n        final String oldPath = oldChild.getAttributeValue(EclipseXml.PATH_ATTR);\n        myOldEntries.put(oldKind + getJREKey(oldPath), oldChild);\n      }\n    }\n\n    for (OrderEntry orderEntry : myModel.getOrderEntries()) {\n      createClasspathEntry(orderEntry, classpathElement);\n    }\n\n    @NonNls String outputPath = \"bin\";\n    final String compilerOutputUrl = myModel.getModuleExtension(CompilerModuleExtension.class).getCompilerOutputUrl();\n    final String linkedPath = EclipseModuleManager.getInstance(myModel.getModule()).getEclipseLinkedVarPath(compilerOutputUrl);\n    if (linkedPath != null) {\n      outputPath = linkedPath;\n    } else {\n      final VirtualFile contentRoot = EPathUtil.getContentRoot(myModel);\n      final VirtualFile output = myModel.getModuleExtension(CompilerModuleExtension.class).getCompilerOutputPath();\n      if (contentRoot != null && output != null && VfsUtil.isAncestor(contentRoot, output, false)) {\n        outputPath = EPathUtil.collapse2EclipsePath(output.getUrl(), myModel);\n      }\n      else if (output == null && compilerOutputUrl != null) {\n        outputPath = EPathUtil.collapse2EclipsePath(compilerOutputUrl, myModel);\n      }\n    }\n    final Element orderEntry = addOrderEntry(EclipseXml.OUTPUT_KIND, outputPath, classpathElement);\n    setAttributeIfAbsent(orderEntry, EclipseXml.PATH_ATTR, EclipseXml.BIN_DIR);\n  }","commit_id":"d60ccf99e0a3be62a5bff674db9c78c77c4df3a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void loadState(Element state) {\n    for (Object o : state.getChildren(LIBELEMENT)) {\n      myEclipseUrls.add(((Element)o).getAttributeValue(VALUE_ATTR));\n    }\n\n    for (Object o : state.getChildren(VARELEMENT)) {\n      final String prefix = ((Element)o).getAttributeValue(PREFIX_ATTR);\n      myEclipseVariablePaths.put(((Element)o).getAttributeValue(VAR_ATTRIBUTE), (prefix != null ? prefix : \"\") + ((Element)o).getAttributeValue(VALUE_ATTR));\n    }\n\n    for (Object o : state.getChildren(CONELEMENT)) {\n      myUnknownCons.add(((Element)o).getAttributeValue(VALUE_ATTR));\n    }\n\n    final String forcedJdk = state.getAttributeValue(FORCED_JDK);\n    myForceConfigureJDK = forcedJdk != null && Boolean.parseBoolean(forcedJdk);\n  }","id":60150,"modified_method":"public void loadState(Element state) {\n    for (Object o : state.getChildren(LIBELEMENT)) {\n      myEclipseUrls.add(((Element)o).getAttributeValue(VALUE_ATTR));\n    }\n\n    for (Object o : state.getChildren(VARELEMENT)) {\n      final String prefix = ((Element)o).getAttributeValue(PREFIX_ATTR);\n      myEclipseVariablePaths.put(((Element)o).getAttributeValue(VAR_ATTRIBUTE), (prefix != null ? prefix : \"\") + ((Element)o).getAttributeValue(VALUE_ATTR));\n    }\n\n    for (Object o : state.getChildren(CONELEMENT)) {\n      myUnknownCons.add(((Element)o).getAttributeValue(VALUE_ATTR));\n    }\n\n    final String forcedJdk = state.getAttributeValue(FORCED_JDK);\n    myForceConfigureJDK = forcedJdk != null && Boolean.parseBoolean(forcedJdk);\n\n    final Element srcDescriptionElement = state.getChild(SRC_DESCRIPTION);\n    if (srcDescriptionElement != null) {\n       myExpectedModuleSourcePlace = Integer.parseInt(srcDescriptionElement.getAttributeValue(EXPECTED_POSITION));\n      for (Object o : srcDescriptionElement.getChildren(SRC_FOLDER)) {\n        mySrcPlace.put(((Element)o).getAttributeValue(VALUE_ATTR), Integer.parseInt(((Element)o).getAttributeValue(EXPECTED_POSITION)));\n      }\n    }\n  }","commit_id":"d60ccf99e0a3be62a5bff674db9c78c77c4df3a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Element getState() {\n    if (!ClasspathStorage.getStorageType(myModule).equals(EclipseClasspathStorageProvider.ID)) {\n      if (!myEclipseUrls.isEmpty() || !myEclipseVariablePaths.isEmpty() || myForceConfigureJDK || !myUnknownCons.isEmpty()) {\n        Element root = new Element(\"EclipseModuleSettings\");\n        for (String eclipseUrl : myEclipseUrls) {\n          final Element libElement = new Element(LIBELEMENT);\n          libElement.setAttribute(VALUE_ATTR, eclipseUrl);\n          root.addContent(libElement);\n        }\n        for (String var : myEclipseVariablePaths.keySet()) {\n          Element varElement = new Element(VARELEMENT);\n          if (var.startsWith(SRC_PREFIX)) {\n            varElement.setAttribute(VAR_ATTRIBUTE, StringUtil.trimStart(var, SRC_PREFIX));\n            varElement.setAttribute(PREFIX_ATTR, SRC_PREFIX);\n          } else if (var.startsWith(SRC_LINK_PREFIX)) {\n            varElement.setAttribute(VAR_ATTRIBUTE, StringUtil.trimStart(var, SRC_LINK_PREFIX));\n            varElement.setAttribute(PREFIX_ATTR, SRC_LINK_PREFIX);\n          } else {\n            varElement.setAttribute(VAR_ATTRIBUTE, var);\n          }\n          varElement.setAttribute(VALUE_ATTR, myEclipseVariablePaths.get(var));\n          root.addContent(varElement);\n        }\n        for (String unknownCon : myUnknownCons) {\n          Element conElement = new Element(CONELEMENT);\n          conElement.setAttribute(VALUE_ATTR, unknownCon);\n          root.addContent(conElement);\n        }\n\n        if (myForceConfigureJDK) {\n          root.setAttribute(FORCED_JDK, String.valueOf(true));\n        }\n        return root;\n      }\n    }\n    return null;\n  }","id":60151,"modified_method":"public Element getState() {\n    if (!ClasspathStorage.getStorageType(myModule).equals(EclipseClasspathStorageProvider.ID)) {\n      if (!myEclipseUrls.isEmpty() || !myEclipseVariablePaths.isEmpty() || myForceConfigureJDK || !myUnknownCons.isEmpty()) {\n        Element root = new Element(\"EclipseModuleSettings\");\n        for (String eclipseUrl : myEclipseUrls) {\n          final Element libElement = new Element(LIBELEMENT);\n          libElement.setAttribute(VALUE_ATTR, eclipseUrl);\n          root.addContent(libElement);\n        }\n        for (String var : myEclipseVariablePaths.keySet()) {\n          Element varElement = new Element(VARELEMENT);\n          if (var.startsWith(SRC_PREFIX)) {\n            varElement.setAttribute(VAR_ATTRIBUTE, StringUtil.trimStart(var, SRC_PREFIX));\n            varElement.setAttribute(PREFIX_ATTR, SRC_PREFIX);\n          } else if (var.startsWith(SRC_LINK_PREFIX)) {\n            varElement.setAttribute(VAR_ATTRIBUTE, StringUtil.trimStart(var, SRC_LINK_PREFIX));\n            varElement.setAttribute(PREFIX_ATTR, SRC_LINK_PREFIX);\n          } else if (var.startsWith(LINK_PREFIX)) {\n            varElement.setAttribute(VAR_ATTRIBUTE, StringUtil.trimStart(var, LINK_PREFIX));\n            varElement.setAttribute(PREFIX_ATTR, LINK_PREFIX);\n          }\n          else {\n            varElement.setAttribute(VAR_ATTRIBUTE, var);\n          }\n          varElement.setAttribute(VALUE_ATTR, myEclipseVariablePaths.get(var));\n          root.addContent(varElement);\n        }\n        for (String unknownCon : myUnknownCons) {\n          Element conElement = new Element(CONELEMENT);\n          conElement.setAttribute(VALUE_ATTR, unknownCon);\n          root.addContent(conElement);\n        }\n\n        if (myForceConfigureJDK) {\n          root.setAttribute(FORCED_JDK, String.valueOf(true));\n        }\n\n        final Element srcDescriptionElement = new Element(SRC_DESCRIPTION);\n        srcDescriptionElement.setAttribute(EXPECTED_POSITION, String.valueOf(myExpectedModuleSourcePlace));\n        for (String srcUrl : mySrcPlace.keySet()) {\n          final Element srcFolder = new Element(SRC_FOLDER);\n          srcFolder.setAttribute(VALUE_ATTR, srcUrl);\n          srcFolder.setAttribute(EXPECTED_POSITION, mySrcPlace.get(srcUrl).toString());\n          srcDescriptionElement.addContent(srcFolder);\n        }\n        root.addContent(srcDescriptionElement);\n\n        return root;\n      }\n    }\n    return null;\n  }","commit_id":"d60ccf99e0a3be62a5bff674db9c78c77c4df3a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testSimpleProject() throws IOException {\n    importProject(\"<groupId>test<\/groupId>\" + \"<artifactId>project<\/artifactId>\" + \"<version>1<\/version>\");\n\n    assertModules(\"project\");\n  }","id":60152,"modified_method":"public void testSimpleProjectStructure() throws IOException {\n    importProject(\"<groupId>test<\/groupId>\" +\n                  \"<artifactId>project<\/artifactId>\" +\n                  \"<version>1<\/version>\");\n\n    assertModules(\"project\");\n    assertContentRoots(\"project\", root.getPath());\n\n    assertSources(\"project\", \"src/main/java\", \"src/main/resources\");\n    assertTestSources(\"project\", \"src/test/java\", \"src/test/resources\");\n  }","commit_id":"556d5e98cfafe54649bf644a583cefdd40be98de","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void createOutput(final RootModelAdapter rootModel, final MavenProject mavenProject) {\n    Build build = mavenProject.getBuild();\n    if (preferences.isUseMavenOutput()) {\n      rootModel.useModuleOutput(build.getOutputDirectory(), build.getTestOutputDirectory());\n    }\n    else {\n      rootModel.useProjectOutput();\n      rootModel.excludeRoot(build.getOutputDirectory());\n      rootModel.excludeRoot(build.getTestOutputDirectory());\n    }\n  }","id":60153,"modified_method":"private void createOutput(RootModelAdapter rootModel, MavenProject mavenProject) {\n    Build build = mavenProject.getBuild();\n    if (preferences.isUseMavenOutput()) {\n      rootModel.useModuleOutput(build.getOutputDirectory(), build.getTestOutputDirectory());\n    }\n    else {\n      rootModel.useProjectOutput();\n      rootModel.excludeRoot(build.getOutputDirectory());\n      rootModel.excludeRoot(build.getTestOutputDirectory());\n    }\n    rootModel.excludeRoot(build.getDirectory());\n  }","commit_id":"556d5e98cfafe54649bf644a583cefdd40be98de","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void assertModuleLibraries(String moduleName, String... expectedLibraries) {\n    Module m = getModule(moduleName);\n    List<String> actual = new ArrayList<String>();\n\n    for (OrderEntry e : ModuleRootManager.getInstance(m).getOrderEntries()) {\n      if (e instanceof LibraryOrderEntry) {\n        actual.add(e.getPresentableName());\n      }\n    }\n\n    assertElementsAreEqual(expectedLibraries, actual);\n  }","id":60154,"modified_method":"protected void assertModuleLibraries(String moduleName, String... expectedLibraries) {\n    List<String> actual = new ArrayList<String>();\n\n    for (OrderEntry e : getRootManager(moduleName).getOrderEntries()) {\n      if (e instanceof LibraryOrderEntry) {\n        actual.add(e.getPresentableName());\n      }\n    }\n\n    assertElementsAreEqual(expectedLibraries, actual);\n  }","commit_id":"556d5e98cfafe54649bf644a583cefdd40be98de","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void excludeRoot(final String path) {\n    final VirtualFile dir = LocalFileSystem.getInstance().refreshAndFindFileByPath(path);\n    if (dir != null) {\n      findOrCreateContentRoot(dir).addExcludeFolder(dir);\n    }\n  }","id":60155,"modified_method":"public void excludeRoot(String path) {\n    String url = toUrl(path);\n    findOrCreateContentRoot(url).addExcludeFolder(url);\n  }","commit_id":"556d5e98cfafe54649bf644a583cefdd40be98de","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void useModuleOutput(final String production, final String test) {\n    modifiableRootModel.inheritCompilerOutputPath(false);\n    modifiableRootModel.setCompilerOutputPath(VfsUtil.pathToUrl(FileUtil.toSystemIndependentName(production)));\n    modifiableRootModel.setCompilerOutputPathForTests(VfsUtil.pathToUrl(FileUtil.toSystemIndependentName(test)));\n  }","id":60156,"modified_method":"public void useModuleOutput(String production, String test) {\n    modifiableRootModel.inheritCompilerOutputPath(false);\n    modifiableRootModel.setCompilerOutputPath(toUrl(production));\n    modifiableRootModel.setCompilerOutputPathForTests(toUrl(test));\n  }","commit_id":"556d5e98cfafe54649bf644a583cefdd40be98de","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"ContentEntry findOrCreateContentRoot(VirtualFile srcDir) {\n    for (ContentEntry contentEntry : modifiableRootModel.getContentEntries()) {\n      VirtualFile virtualFile = contentEntry.getFile();\n      if (virtualFile != null && VfsUtil.isAncestor(virtualFile, srcDir, false)) {\n        return contentEntry;\n      }\n    }\n    return modifiableRootModel.addContentEntry(srcDir);\n  }","id":60157,"modified_method":"ContentEntry findOrCreateContentRoot(String url) {\n    try {\n      for (ContentEntry e : modifiableRootModel.getContentEntries()) {\n        if (FileUtil.isAncestor(new File(e.getUrl()), new File(url), false)) return e;\n      }\n      return modifiableRootModel.addContentEntry(url);\n    }\n    catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }","commit_id":"556d5e98cfafe54649bf644a583cefdd40be98de","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void createSrcDir(String path, boolean testSource) {\n    final VirtualFile srcDir = LocalFileSystem.getInstance().refreshAndFindFileByPath(path);\n    if (srcDir != null) {\n      findOrCreateContentRoot(srcDir).addSourceFolder(srcDir, testSource);\n    }\n  }","id":60158,"modified_method":"void createSrcDir(String path, boolean testSource) {\n    String url = toUrl(path);\n    findOrCreateContentRoot(url).addSourceFolder(url, testSource);\n  }","commit_id":"556d5e98cfafe54649bf644a583cefdd40be98de","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public SourceRelativeURI getGeneratedUriForTrace(final IProjectConfig projectConfig, final AbsoluteURI absoluteSourceResource, final AbsoluteURI generatedFileURI, final ITraceURIConverter traceURIConverter) {\n    final Module module = ((IdeaModuleConfig) projectConfig).getModule();\n    IResourceServiceProvider _serviceProvider = this.getServiceProvider(absoluteSourceResource);\n    final IdeaOutputConfigurationProvider outputConfigurationProvider = _serviceProvider.<IdeaOutputConfigurationProvider>get(IdeaOutputConfigurationProvider.class);\n    final Set<OutputConfiguration> outputConfigurations = outputConfigurationProvider.getOutputConfigurations(module);\n    URI _uRI = absoluteSourceResource.getURI();\n    final ISourceFolder sourceFolder = projectConfig.findSourceFolderContaining(_uRI);\n    OutputConfiguration _head = IterableExtensions.<OutputConfiguration>head(outputConfigurations);\n    String _name = sourceFolder.getName();\n    final String outputFolder = _head.getOutputDirectory(_name);\n    Application _application = ApplicationManager.getApplication();\n    final Computable<VirtualFile> _function = new Computable<VirtualFile>() {\n      @Override\n      public VirtualFile compute() {\n        boolean _isAbsolutePath = TraceForVirtualFileProvider.this.isAbsolutePath(outputFolder);\n        if (_isAbsolutePath) {\n          VirtualFileManager _instance = VirtualFileManager.getInstance();\n          String _pathToUrl = VfsUtilCore.pathToUrl(outputFolder);\n          return _instance.findFileByUrl(_pathToUrl);\n        } else {\n          ModuleRootManager _instance_1 = ModuleRootManager.getInstance(module);\n          VirtualFile[] _contentRoots = _instance_1.getContentRoots();\n          for (final VirtualFile contentRoot : _contentRoots) {\n            {\n              final VirtualFile result = contentRoot.findFileByRelativePath(outputFolder);\n              boolean _notEquals = (!Objects.equal(result, null));\n              if (_notEquals) {\n                return result;\n              }\n            }\n          }\n          return null;\n        }\n      }\n    };\n    final VirtualFile outputSourceFolder = _application.<VirtualFile>runReadAction(_function);\n    boolean _or = false;\n    if ((outputSourceFolder == null)) {\n      _or = true;\n    } else {\n      boolean _exists = outputSourceFolder.exists();\n      boolean _not = (!_exists);\n      _or = _not;\n    }\n    if (_or) {\n      final SourceRelativeURI result = super.getGeneratedUriForTrace(projectConfig, absoluteSourceResource, generatedFileURI, traceURIConverter);\n      return result;\n    }\n    final URI sourceFolderURI = VirtualFileURIUtil.getURI(outputSourceFolder);\n    final SourceRelativeURI result_1 = generatedFileURI.deresolve(sourceFolderURI);\n    return result_1;\n  }","id":60159,"modified_method":"@Override\n  public SourceRelativeURI getGeneratedUriForTrace(final IProjectConfig projectConfig, final AbsoluteURI absoluteSourceResource, final AbsoluteURI generatedFileURI, final ITraceURIConverter traceURIConverter) {\n    final Module module = ((IdeaModuleConfig) projectConfig).getModule();\n    IResourceServiceProvider _serviceProvider = this.getServiceProvider(absoluteSourceResource);\n    final IdeaOutputConfigurationProvider outputConfigurationProvider = _serviceProvider.<IdeaOutputConfigurationProvider>get(IdeaOutputConfigurationProvider.class);\n    final Set<OutputConfiguration> outputConfigurations = outputConfigurationProvider.getOutputConfigurations(module);\n    URI _uRI = absoluteSourceResource.getURI();\n    final ISourceFolder sourceFolder = projectConfig.findSourceFolderContaining(_uRI);\n    if ((sourceFolder == null)) {\n      return null;\n    }\n    OutputConfiguration _head = IterableExtensions.<OutputConfiguration>head(outputConfigurations);\n    String _name = sourceFolder.getName();\n    final String outputFolder = _head.getOutputDirectory(_name);\n    Application _application = ApplicationManager.getApplication();\n    final Computable<VirtualFile> _function = new Computable<VirtualFile>() {\n      @Override\n      public VirtualFile compute() {\n        boolean _isAbsolutePath = TraceForVirtualFileProvider.this.isAbsolutePath(outputFolder);\n        if (_isAbsolutePath) {\n          VirtualFileManager _instance = VirtualFileManager.getInstance();\n          String _pathToUrl = VfsUtilCore.pathToUrl(outputFolder);\n          return _instance.findFileByUrl(_pathToUrl);\n        } else {\n          ModuleRootManager _instance_1 = ModuleRootManager.getInstance(module);\n          VirtualFile[] _contentRoots = _instance_1.getContentRoots();\n          for (final VirtualFile contentRoot : _contentRoots) {\n            {\n              final VirtualFile result = contentRoot.findFileByRelativePath(outputFolder);\n              boolean _notEquals = (!Objects.equal(result, null));\n              if (_notEquals) {\n                return result;\n              }\n            }\n          }\n          return null;\n        }\n      }\n    };\n    final VirtualFile outputSourceFolder = _application.<VirtualFile>runReadAction(_function);\n    boolean _or = false;\n    if ((outputSourceFolder == null)) {\n      _or = true;\n    } else {\n      boolean _exists = outputSourceFolder.exists();\n      boolean _not = (!_exists);\n      _or = _not;\n    }\n    if (_or) {\n      final SourceRelativeURI result = super.getGeneratedUriForTrace(projectConfig, absoluteSourceResource, generatedFileURI, traceURIConverter);\n      return result;\n    }\n    final URI sourceFolderURI = VirtualFileURIUtil.getURI(outputSourceFolder);\n    final SourceRelativeURI result_1 = generatedFileURI.deresolve(sourceFolderURI);\n    return result_1;\n  }","commit_id":"f198e31d3e53a70afe0bbeec43341cd8d49fcdd3","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public void addSupport(final Module module, final ModifiableRootModel rootModel, final ModifiableModelsProvider modifiableModelsProvider) {\n    ContentEntry[] _contentEntries = rootModel.getContentEntries();\n    final ContentEntry entry = IterableExtensions.<ContentEntry>head(((Iterable<ContentEntry>)Conversions.doWrapArray(_contentEntries)));\n    SourceFolder[] _sourceFolders = entry.getSourceFolders();\n    final Function1<SourceFolder, Boolean> _function = new Function1<SourceFolder, Boolean>() {\n      @Override\n      public Boolean apply(final SourceFolder it) {\n        boolean _and = false;\n        boolean _isTestSource = it.isTestSource();\n        boolean _not = (!_isTestSource);\n        if (!_not) {\n          _and = false;\n        } else {\n          VirtualFile _file = it.getFile();\n          boolean _exists = false;\n          if (_file!=null) {\n            _exists=_file.exists();\n          }\n          _and = _exists;\n        }\n        return Boolean.valueOf(_and);\n      }\n    };\n    Iterable<SourceFolder> _filter = IterableExtensions.<SourceFolder>filter(((Iterable<SourceFolder>)Conversions.doWrapArray(_sourceFolders)), _function);\n    final SourceFolder mainSrc = IterableExtensions.<SourceFolder>head(_filter);\n    VirtualFile xtendGenMain = null;\n    boolean _notEquals = (!Objects.equal(mainSrc, null));\n    if (_notEquals) {\n      VirtualFile _file = mainSrc.getFile();\n      VirtualFile _parent = _file.getParent();\n      VirtualFile _orCreateDir = this.getOrCreateDir(_parent, \"xtend-gen\");\n      xtendGenMain = _orCreateDir;\n      JpsJavaExtensionService _instance = JpsJavaExtensionService.getInstance();\n      final JavaSourceRootProperties properties = _instance.createSourceRootProperties(\"\", true);\n      entry.<JavaSourceRootProperties>addSourceFolder(xtendGenMain, JavaSourceRootType.SOURCE, properties);\n    }\n    SourceFolder[] _sourceFolders_1 = entry.getSourceFolders();\n    final Function1<SourceFolder, Boolean> _function_1 = new Function1<SourceFolder, Boolean>() {\n      @Override\n      public Boolean apply(final SourceFolder it) {\n        boolean _and = false;\n        boolean _isTestSource = it.isTestSource();\n        if (!_isTestSource) {\n          _and = false;\n        } else {\n          VirtualFile _file = it.getFile();\n          boolean _exists = false;\n          if (_file!=null) {\n            _exists=_file.exists();\n          }\n          _and = _exists;\n        }\n        return Boolean.valueOf(_and);\n      }\n    };\n    Iterable<SourceFolder> _filter_1 = IterableExtensions.<SourceFolder>filter(((Iterable<SourceFolder>)Conversions.doWrapArray(_sourceFolders_1)), _function_1);\n    final SourceFolder testSrc = IterableExtensions.<SourceFolder>head(_filter_1);\n    VirtualFile xtendGenTest = null;\n    boolean _notEquals_1 = (!Objects.equal(testSrc, null));\n    if (_notEquals_1) {\n      VirtualFile _file_1 = testSrc.getFile();\n      VirtualFile _parent_1 = _file_1.getParent();\n      VirtualFile _orCreateDir_1 = this.getOrCreateDir(_parent_1, \"xtend-gen\");\n      xtendGenTest = _orCreateDir_1;\n      JpsJavaExtensionService _instance_1 = JpsJavaExtensionService.getInstance();\n      final JavaSourceRootProperties properties_1 = _instance_1.createSourceRootProperties(\"\", true);\n      entry.<JavaSourceRootProperties>addSourceFolder(xtendGenTest, JavaSourceRootType.TEST_SOURCE, properties_1);\n    }\n    FacetTypeRegistry _instance_2 = FacetTypeRegistry.getInstance();\n    String _iD = XtendLanguage.INSTANCE.getID();\n    final FacetType facetType = _instance_2.findFacetType(_iD);\n    final FacetManager mnr = FacetManager.getInstance(module);\n    Facet _elvis = null;\n    FacetTypeId _id = facetType.getId();\n    String _defaultFacetName = facetType.getDefaultFacetName();\n    Facet _findFacet = mnr.<Facet>findFacet(_id, _defaultFacetName);\n    if (_findFacet != null) {\n      _elvis = _findFacet;\n    } else {\n      FacetManager _instance_3 = FacetManager.getInstance(module);\n      String _defaultFacetName_1 = facetType.getDefaultFacetName();\n      Facet _addFacet = _instance_3.<Facet, FacetConfiguration>addFacet(facetType, _defaultFacetName_1, null);\n      _elvis = _addFacet;\n    }\n    Facet facet = _elvis;\n    FacetConfiguration _configuration = facet.getConfiguration();\n    final XtendFacetConfiguration conf = ((XtendFacetConfiguration) _configuration);\n    final XbaseGeneratorConfigurationState state = conf.getState();\n    boolean _notEquals_2 = (!Objects.equal(xtendGenMain, null));\n    if (_notEquals_2) {\n      String _canonicalPath = xtendGenMain.getCanonicalPath();\n      state.setOutputDirectory(_canonicalPath);\n    }\n    boolean _notEquals_3 = (!Objects.equal(xtendGenTest, null));\n    if (_notEquals_3) {\n      String _canonicalPath_1 = xtendGenTest.getCanonicalPath();\n      state.setTestOutputDirectory(_canonicalPath_1);\n    }\n    this.xtendLibManager.ensureXtendLibAvailable(rootModel, module);\n  }","id":60160,"modified_method":"@Override\n  public void addSupport(final Module module, final ModifiableRootModel rootModel, final ModifiableModelsProvider modifiableModelsProvider) {\n    ContentEntry[] _contentEntries = rootModel.getContentEntries();\n    final ContentEntry entry = IterableExtensions.<ContentEntry>head(((Iterable<ContentEntry>)Conversions.doWrapArray(_contentEntries)));\n    SourceFolder[] _sourceFolders = entry.getSourceFolders();\n    final Function1<SourceFolder, Boolean> _function = new Function1<SourceFolder, Boolean>() {\n      @Override\n      public Boolean apply(final SourceFolder it) {\n        boolean _and = false;\n        boolean _isTestSource = it.isTestSource();\n        boolean _not = (!_isTestSource);\n        if (!_not) {\n          _and = false;\n        } else {\n          VirtualFile _file = it.getFile();\n          boolean _exists = false;\n          if (_file!=null) {\n            _exists=_file.exists();\n          }\n          _and = _exists;\n        }\n        return Boolean.valueOf(_and);\n      }\n    };\n    Iterable<SourceFolder> _filter = IterableExtensions.<SourceFolder>filter(((Iterable<SourceFolder>)Conversions.doWrapArray(_sourceFolders)), _function);\n    final SourceFolder mainSrc = IterableExtensions.<SourceFolder>head(_filter);\n    VirtualFile xtendGenMain = this.createOrGetInParentDir(mainSrc, \"xtend-gen\");\n    boolean _notEquals = (!Objects.equal(xtendGenMain, null));\n    if (_notEquals) {\n      JpsJavaExtensionService _instance = JpsJavaExtensionService.getInstance();\n      final JavaSourceRootProperties properties = _instance.createSourceRootProperties(\"\", true);\n      entry.<JavaSourceRootProperties>addSourceFolder(xtendGenMain, JavaSourceRootType.SOURCE, properties);\n    }\n    SourceFolder[] _sourceFolders_1 = entry.getSourceFolders();\n    final Function1<SourceFolder, Boolean> _function_1 = new Function1<SourceFolder, Boolean>() {\n      @Override\n      public Boolean apply(final SourceFolder it) {\n        boolean _and = false;\n        boolean _isTestSource = it.isTestSource();\n        if (!_isTestSource) {\n          _and = false;\n        } else {\n          VirtualFile _file = it.getFile();\n          boolean _exists = false;\n          if (_file!=null) {\n            _exists=_file.exists();\n          }\n          _and = _exists;\n        }\n        return Boolean.valueOf(_and);\n      }\n    };\n    Iterable<SourceFolder> _filter_1 = IterableExtensions.<SourceFolder>filter(((Iterable<SourceFolder>)Conversions.doWrapArray(_sourceFolders_1)), _function_1);\n    final SourceFolder testSrc = IterableExtensions.<SourceFolder>head(_filter_1);\n    VirtualFile xtendGenTest = this.createOrGetInParentDir(testSrc, \"xtend-gen\");\n    boolean _notEquals_1 = (!Objects.equal(xtendGenTest, null));\n    if (_notEquals_1) {\n      JpsJavaExtensionService _instance_1 = JpsJavaExtensionService.getInstance();\n      final JavaSourceRootProperties properties_1 = _instance_1.createSourceRootProperties(\"\", true);\n      entry.<JavaSourceRootProperties>addSourceFolder(xtendGenTest, JavaSourceRootType.TEST_SOURCE, properties_1);\n    }\n    FacetTypeRegistry _instance_2 = FacetTypeRegistry.getInstance();\n    String _iD = XtendLanguage.INSTANCE.getID();\n    final FacetType facetType = _instance_2.findFacetType(_iD);\n    if ((facetType == null)) {\n      return;\n    }\n    final FacetManager mnr = FacetManager.getInstance(module);\n    Facet _elvis = null;\n    FacetTypeId _id = facetType.getId();\n    String _defaultFacetName = facetType.getDefaultFacetName();\n    Facet _findFacet = mnr.<Facet>findFacet(_id, _defaultFacetName);\n    if (_findFacet != null) {\n      _elvis = _findFacet;\n    } else {\n      FacetManager _instance_3 = FacetManager.getInstance(module);\n      String _defaultFacetName_1 = facetType.getDefaultFacetName();\n      Facet _addFacet = _instance_3.<Facet, FacetConfiguration>addFacet(facetType, _defaultFacetName_1, null);\n      _elvis = _addFacet;\n    }\n    Facet facet = _elvis;\n    FacetConfiguration _configuration = facet.getConfiguration();\n    final XtendFacetConfiguration conf = ((XtendFacetConfiguration) _configuration);\n    final XbaseGeneratorConfigurationState state = conf.getState();\n    boolean _notEquals_2 = (!Objects.equal(xtendGenMain, null));\n    if (_notEquals_2) {\n      String _canonicalPath = xtendGenMain.getCanonicalPath();\n      state.setOutputDirectory(_canonicalPath);\n    }\n    boolean _notEquals_3 = (!Objects.equal(xtendGenTest, null));\n    if (_notEquals_3) {\n      String _canonicalPath_1 = xtendGenTest.getCanonicalPath();\n      state.setTestOutputDirectory(_canonicalPath_1);\n    }\n    this.xtendLibManager.ensureXtendLibAvailable(rootModel, module);\n  }","commit_id":"f198e31d3e53a70afe0bbeec43341cd8d49fcdd3","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n\tpublic void create20SampleProjects() throws URISyntaxException {\n\t\tFliesClient client = new FliesClient(\"http://localhost:8080/flies/seam/resource/restv1\", \"admin\", \"34567890123456789012345678901234\");\n\t\t\n\t\tProjectsResource projectsResource = client.getProjectsResource();\n\t\t\n\t\tClientResponse<Project> projectResponse = projectsResource.getProjectResource(\"sample-project\").get();\n\t\t\n\t\tif (projectResponse.getResponseStatus().getStatusCode() < 399) {\n\t\t\tProject p = projectResponse.getEntity();\n\t\t\tSystem.out.println( p.getName() );\n\t\t\tp.getIterations().clear();\n\t\t\tp.setName( \"replaced \"+ p.getName());\n\t\t\tResponse r = projectsResource.getProjectResource(\"myproject\").put(p);\n\t\t\tSystem.out.println(\"Completed with status: \" + r.getStatus());\n\t\t\t\n\t\t\tfor (int i = 1; i < 21; i++) {\n\t\t\t\tp = new Project(\"myxproject-\"+i, \"Project #\"+i, \"Sample Description #\"+i);\n\t\t\t\tr = projectsResource.getProjectResource(p.getId()).put(p);\n\t\t\t\tStatus s = Status.fromStatusCode(r.getStatus());\n\t\t\t\tif(Status.CREATED == s ) {\n\t\t\t\t\tSystem.out.println(\"Created project \" + i);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.err.println(i + \"Failed with status: \" + s);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tProjectResource projectResource = \n\t\t\t\t    client.getProjectsResource().\n\t\t\t\t    getProjectResource(p.getId());\n\t\t\t\tfor (int j = 1; j < 3; j++) {\n\t\t\t\t\tProjectIteration pIt = new ProjectIteration();\n\t\t\t\t\tpIt.setId(\"iteration-\"+j);\n\t\t\t\t\tpIt.setName(\"Project Iteration #\"+j);\n\t\t\t\t\tpIt.setSummary(\"A sample Iteration #\"+j);\n\t\t\t\t\tr = projectResource.getIterationResource(pIt.getId()).put(pIt);\n\t\t\t\t\ts = Status.fromStatusCode(r.getStatus());\n\t\t\t\t\tif(Status.CREATED == s ) {\n\t\t\t\t\t\tSystem.out.println(\"  Iteration Created: \" + j);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tSystem.err.println(\"  \" + j + \" Iteration Creation Failed with status: \" + s);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tString [] documentIds = {\n\t\t\t\t\t\t\t\"my/document/doc1.txt\", \n\t\t\t\t\t\t\t\"my/document/other.txt\"};\n\t\t\t\t\t\n\t\t\t\t\tDocumentsResource documentResource = \n\t\t\t\t\t    client.getProjectsResource().\n\t\t\t\t\t    getProjectResource(p.getId()).\n\t\t\t\t\t    getIterationResource(pIt.getId()).\n\t\t\t\t\t    getDocumentsResource();\n\t\t\t\t\t\n\t\t\t\t\tfor (int k = 0; k < documentIds.length; k++) {\n\t\t\t\t\t\tDocument doc = new Document(documentIds[k], ContentType.TextPlain);\n\t\t\t\t\t\t\n\t\t\t\t\t\tTextFlow tf = new TextFlow(\"tf1\");\n\t\t\t\t\t\ttf.setContent(\"Hello World\");\n\t\t\t\t\t\tdoc.getResources(true).add(tf);\n\t\t\t\t\t\t\n\t\t\t\t\t\tr = documentResource.getDocumentResource(doc.getId()).put(doc);\n\t\t\t\t\t\ts = Status.fromStatusCode(r.getStatus());\n\t\t\t\t\t\tif(Status.CREATED == s ) {\n\t\t\t\t\t\t\tSystem.out.println(\"    Document Created: \" + documentIds[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tSystem.err.println(\"    \" + documentIds[k] + \" Creation Failed with status: \" + s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}","id":60161,"modified_method":"@Test\n\tpublic void create20SampleProjects() throws URISyntaxException {\n\t\tFliesClient client = new FliesClient(\"http://localhost:8080/flies/seam/resource/restv1\", \"admin\", \"34567890123456789012345678901234\");\n\t\t\n\t\tProjectsResource projectsResource = client.getProjectsResource();\n\t\t\n\t\tClientResponse<ProjectRes> projectResponse = projectsResource.getProjectResource(\"sample-project\").get();\n\t\t\n\t\tif (projectResponse.getResponseStatus().getStatusCode() < 399) {\n\t\t\tProjectRes p = new ProjectRes(projectResponse.getEntity());\n\t\t\tSystem.out.println( p.getName() );\n\t\t\tp.setName( \"replaced \"+ p.getName());\n\t\t\tResponse r = projectsResource.getProjectResource(\"myproject\").put(p);\n\t\t\tSystem.out.println(\"Completed with status: \" + r.getStatus());\n\t\t\t\n\t\t\tfor (int i = 1; i < 21; i++) {\n\t\t\t\tp = new ProjectRes(\"myxproject-\"+i, \"Project #\"+i, \"Sample Description #\"+i, ProjectType.IterationProject);\n\t\t\t\tr = projectsResource.getProjectResource(p.getId()).put(p);\n\t\t\t\tStatus s = Status.fromStatusCode(r.getStatus());\n\t\t\t\tif(Status.CREATED == s ) {\n\t\t\t\t\tSystem.out.println(\"Created project \" + i);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.err.println(i + \"Failed with status: \" + s);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tProjectResource projectResource = \n\t\t\t\t    client.getProjectsResource().\n\t\t\t\t    getProjectResource(p.getId());\n\t\t\t\tfor (int j = 1; j < 3; j++) {\n\t\t\t\t\tProjectIteration pIt = new ProjectIteration();\n\t\t\t\t\tpIt.setId(\"iteration-\"+j);\n\t\t\t\t\tpIt.setName(\"Project Iteration #\"+j);\n\t\t\t\t\tpIt.setSummary(\"A sample Iteration #\"+j);\n\t\t\t\t\tr = projectResource.getIterationResource(pIt.getId()).put(pIt);\n\t\t\t\t\ts = Status.fromStatusCode(r.getStatus());\n\t\t\t\t\tif(Status.CREATED == s ) {\n\t\t\t\t\t\tSystem.out.println(\"  Iteration Created: \" + j);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tSystem.err.println(\"  \" + j + \" Iteration Creation Failed with status: \" + s);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tString [] documentIds = {\n\t\t\t\t\t\t\t\"my/document/doc1.txt\", \n\t\t\t\t\t\t\t\"my/document/other.txt\"};\n\t\t\t\t\t\n\t\t\t\t\tDocumentsResource documentResource = \n\t\t\t\t\t    client.getProjectsResource().\n\t\t\t\t\t    getProjectResource(p.getId()).\n\t\t\t\t\t    getIterationResource(pIt.getId()).\n\t\t\t\t\t    getDocumentsResource();\n\t\t\t\t\t\n\t\t\t\t\tfor (int k = 0; k < documentIds.length; k++) {\n\t\t\t\t\t\tDocument doc = new Document(documentIds[k], ContentType.TextPlain);\n\t\t\t\t\t\t\n\t\t\t\t\t\tTextFlow tf = new TextFlow(\"tf1\");\n\t\t\t\t\t\ttf.setContent(\"Hello World\");\n\t\t\t\t\t\tdoc.getResources(true).add(tf);\n\t\t\t\t\t\t\n\t\t\t\t\t\tr = documentResource.getDocumentResource(doc.getId()).put(doc);\n\t\t\t\t\t\ts = Status.fromStatusCode(r.getStatus());\n\t\t\t\t\t\tif(Status.CREATED == s ) {\n\t\t\t\t\t\t\tSystem.out.println(\"    Document Created: \" + documentIds[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tSystem.err.println(\"    \" + documentIds[k] + \" Creation Failed with status: \" + s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}","commit_id":"e4ee3e22dcfa1db79f2c47c0603413ac29ef0a8c","url":"https://github.com/zanata/zanata-server"},{"original_method":"public ProjectRef(String id, String name, String description, ProjectType type) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t\tthis.description = description;\n\t\tthis.type = type;\n\t}","id":60162,"modified_method":"public ProjectRef(String id, String name, String description, ProjectType type) {\n\t\tsuper(id, name, description, type);\n\t}","commit_id":"e4ee3e22dcfa1db79f2c47c0603413ac29ef0a8c","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n\tpublic ClientResponse<Project> get() {\n\t\treturn projectResource.get();\n\t}","id":60163,"modified_method":"@Override\n\tpublic ClientResponse<ProjectRes> get() {\n\t\treturn projectResource.get();\n\t}","commit_id":"e4ee3e22dcfa1db79f2c47c0603413ac29ef0a8c","url":"https://github.com/zanata/zanata-server"},{"original_method":"private static Project toMini(HProject hProject) {\n\t\tProject project = new Project();\n\t\tproject.setId(hProject.getSlug());\n\t\tproject.setName(hProject.getName());\n\t\tproject.setDescription(hProject.getDescription());\n\t\tif (hProject instanceof HIterationProject) {\n\t\t\tHIterationProject itProject = (HIterationProject) hProject;\n\t\t\tfor (HProjectIteration pIt : itProject.getProjectIterations()) {\n\t\t\t\tproject.getIterations().add(\n\t\t\t\t\t\tnew ProjectIteration(pIt.getSlug(), pIt.getName(), pIt\n\t\t\t\t\t\t\t\t.getDescription()));\n\t\t\t}\n\t\t}\n\n\t\treturn project;\n\t}","id":60164,"modified_method":"private static ProjectRes toMini(HProject hProject) {\n\t\tProjectRes project = new ProjectRes();\n\t\tproject.setId(hProject.getSlug());\n\t\tproject.setName(hProject.getName());\n\t\tproject.setDescription(hProject.getDescription());\n\t\tif (hProject instanceof HIterationProject) {\n\t\t\tHIterationProject itProject = (HIterationProject) hProject;\n\t\t\tfor (HProjectIteration pIt : itProject.getProjectIterations()) {\n\t\t\t\tproject.getLinks().add(\n\t\t\t\t\t\tnew Link( URI.create(\"iterations/i\"+pIt.getSlug()), \"iteration\", MediaTypes.APPLICATION_FLIES_PROJECT_ITERATION)\n\t\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn project;\n\t}","commit_id":"e4ee3e22dcfa1db79f2c47c0603413ac29ef0a8c","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void createProject(){\n\t\tfinal String PROJECT_SLUG = \"my-new-project\";\n\t\tfinal String PROJECT_NAME = \"My New Project\";\n\t\tfinal String PROJECT_DESC = \"Another test project\";\n\t\tProject project = new Project(PROJECT_SLUG, PROJECT_NAME, PROJECT_DESC);\n\n\t\tprojectService = clientRequestFactory.createProxy(IProjectResource.class, baseUri.resolve(PROJECT_SLUG));\n\t\t\n\t\tResponse response = projectService.put(project);\n\t\t\n\t\tassertThat( response.getStatus(), is( Status.CREATED.getStatusCode()));\n\t\t\n\t\tString location = (String) response.getMetadata().getFirst(\"Location\");\n\t\t\n\t\tassertThat( location, endsWith(\"/projects/p/\"+PROJECT_SLUG));\n\t\t\n\t\tClientResponse<Project> response1 = projectService.get();\n\t\tassertThat(response1.getStatus(), is(Status.OK.getStatusCode()));\n\t\tassertThat(response1.getEntity(), notNullValue());\n\t\tassertThat(response1.getEntity().getName(), is(PROJECT_NAME)); \n\t\tassertThat(response1.getEntity().getId(), is(PROJECT_SLUG)); \n\t\tassertThat(response1.getEntity().getDescription(), is(PROJECT_DESC)); \n\t}","id":60165,"modified_method":"public void createProject(){\n\t\tfinal String PROJECT_SLUG = \"my-new-project\";\n\t\tfinal String PROJECT_NAME = \"My New Project\";\n\t\tfinal String PROJECT_DESC = \"Another test project\";\n\t\tProjectRes project = new ProjectRes(PROJECT_SLUG, PROJECT_NAME, PROJECT_DESC, ProjectType.IterationProject);\n\n\t\tprojectService = clientRequestFactory.createProxy(IProjectResource.class, baseUri.resolve(PROJECT_SLUG));\n\t\t\n\t\tResponse response = projectService.put(project);\n\t\t\n\t\tassertThat( response.getStatus(), is( Status.CREATED.getStatusCode()));\n\t\t\n\t\tString location = (String) response.getMetadata().getFirst(\"Location\");\n\t\t\n\t\tassertThat( location, endsWith(\"/projects/p/\"+PROJECT_SLUG));\n\t\t\n\t\tClientResponse<ProjectRes> response1 = projectService.get();\n\t\tassertThat(response1.getStatus(), is(Status.OK.getStatusCode()));\n\t\tassertThat(response1.getEntity(), notNullValue());\n\t\tassertThat(response1.getEntity().getName(), is(PROJECT_NAME)); \n\t\tassertThat(response1.getEntity().getId(), is(PROJECT_SLUG)); \n\t\tassertThat(response1.getEntity().getDescription(), is(PROJECT_DESC)); \n\t}","commit_id":"e4ee3e22dcfa1db79f2c47c0603413ac29ef0a8c","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void retrieveNonExistingProject(){\n\t\tprojectService = clientRequestFactory.createProxy(IProjectResource.class, baseUri.resolve(\"invalid-project\"));\n\n\t\tClientResponse<Project> response = projectService.get();\n\t\tassertThat( response.getStatus(), is(404) );\n\t}","id":60166,"modified_method":"public void retrieveNonExistingProject(){\n\t\tprojectService = clientRequestFactory.createProxy(IProjectResource.class, baseUri.resolve(\"invalid-project\"));\n\n\t\tClientResponse<ProjectRes> response = projectService.get();\n\t\tassertThat( response.getStatus(), is(404) );\n\t}","commit_id":"e4ee3e22dcfa1db79f2c47c0603413ac29ef0a8c","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void retrieveExistingProject(){\n\t\tprojectService = clientRequestFactory.createProxy(IProjectResource.class, baseUri.resolve(\"sample-project\"));\n\t\tClientResponse<Project> response = projectService.get();\n\t\tassertThat( response.getStatus(), lessThan(400) );\n\t}","id":60167,"modified_method":"public void retrieveExistingProject(){\n\t\tprojectService = clientRequestFactory.createProxy(IProjectResource.class, baseUri.resolve(\"sample-project\"));\n\t\tClientResponse<ProjectRes> response = projectService.get();\n\t\tassertThat( response.getStatus(), lessThan(400) );\n\t}","commit_id":"e4ee3e22dcfa1db79f2c47c0603413ac29ef0a8c","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void updateProjectWithInvalidData() {\n\t\tProject project = new Project(\"sample-project\", \"ProjectUpdateProjectUpdateProjectUpdateProjectUpdateProjectUpdateProjectUpdateProjectUpdate\", \"Project Name exceeds 80\");\n\n\t\tprojectService = clientRequestFactory.createProxy(IProjectResource.class, baseUri.resolve(\"sample-project\"));\n\t\t\n\t\tResponse response = projectService.put(project);\n\t\t\t\t\n\t\tassertThat( response.getStatus(), is(Status.BAD_REQUEST.getStatusCode()));\n\n\t}","id":60168,"modified_method":"public void updateProjectWithInvalidData() {\n\t\tProjectRes project = new ProjectRes(\"sample-project\", \"ProjectUpdateProjectUpdateProjectUpdateProjectUpdateProjectUpdateProjectUpdateProjectUpdate\", \"Project Name exceeds 80\", ProjectType.IterationProject);\n\n\t\tprojectService = clientRequestFactory.createProxy(IProjectResource.class, baseUri.resolve(\"sample-project\"));\n\t\t\n\t\tResponse response = projectService.put(project);\n\t\t\t\t\n\t\tassertThat( response.getStatus(), is(Status.BAD_REQUEST.getStatusCode()));\n\n\t}","commit_id":"e4ee3e22dcfa1db79f2c47c0603413ac29ef0a8c","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void createProjectWithInvalidData(){\n\t\tfinal String PROJECT_SLUG = \"my-new-project\";\n\t\tfinal String PROJECT_SLUG_INVALID = \"my,new,project\";\n\t\tfinal String PROJECT_NAME = \"My New Project\";\n\t\tfinal String PROJECT_NAME_INVALID = \"My test ProjectMy test ProjectMy test ProjectMy test ProjectMy test ProjectMy test Project\";\n\t\tfinal String PROJECT_DESC = \"Another test project\";\n\t\tprojectService = clientRequestFactory.createProxy(IProjectResource.class, baseUri.resolve(PROJECT_SLUG_INVALID));\n\n\t\tProject project = new Project(PROJECT_SLUG_INVALID, PROJECT_NAME, PROJECT_DESC);\n\t\tResponse response = projectService.put(project);\n\t\t\n        assertThat( response.getStatus(), is( Status.BAD_REQUEST.getStatusCode()));\n\n\t\tprojectService = clientRequestFactory.createProxy(IProjectResource.class, baseUri.resolve(PROJECT_SLUG));\n        Project project1 = new Project(PROJECT_SLUG,PROJECT_NAME_INVALID, PROJECT_DESC);\n        Response response1 = projectService.put(project1);\n        \n        assertThat(response1.getStatus(), is(Status.BAD_REQUEST.getStatusCode()));\n        \n\t}","id":60169,"modified_method":"public void createProjectWithInvalidData(){\n\t\tfinal String PROJECT_SLUG = \"my-new-project\";\n\t\tfinal String PROJECT_SLUG_INVALID = \"my,new,project\";\n\t\tfinal String PROJECT_NAME = \"My New Project\";\n\t\tfinal String PROJECT_NAME_INVALID = \"My test ProjectMy test ProjectMy test ProjectMy test ProjectMy test ProjectMy test Project\";\n\t\tfinal String PROJECT_DESC = \"Another test project\";\n\t\tprojectService = clientRequestFactory.createProxy(IProjectResource.class, baseUri.resolve(PROJECT_SLUG_INVALID));\n\n\t\tProjectRes project = new ProjectRes(PROJECT_SLUG_INVALID, PROJECT_NAME, PROJECT_DESC, ProjectType.IterationProject);\n\t\tResponse response = projectService.put(project);\n\t\t\n        assertThat( response.getStatus(), is( Status.BAD_REQUEST.getStatusCode()));\n\n\t\tprojectService = clientRequestFactory.createProxy(IProjectResource.class, baseUri.resolve(PROJECT_SLUG));\n        ProjectRes project1 = new ProjectRes(PROJECT_SLUG,PROJECT_NAME_INVALID, PROJECT_DESC,ProjectType.IterationProject);\n        Response response1 = projectService.put(project1);\n        \n        assertThat(response1.getStatus(), is(Status.BAD_REQUEST.getStatusCode()));\n        \n\t}","commit_id":"e4ee3e22dcfa1db79f2c47c0603413ac29ef0a8c","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void updateProject() {\n\t\tProject project = new Project(\"sample-project\", \"My Project Update\", \"Update project\");\n\n\t\tprojectService = clientRequestFactory.createProxy(IProjectResource.class, baseUri.resolve(\"sample-project\"));\n\t\t\n\t\tResponse response = projectService.put(project);\n\t\t\t\t\n\t\tassertThat( response.getStatus(), is( Status.OK.getStatusCode()));\n\t\t\n\t\tClientResponse<Project> projectResponse = projectService.get();\n\t\t\n\t\tassertThat( projectResponse.getStatus(), is( Status.OK.getStatusCode()));\n\t\t\n\t\tproject = projectResponse.getEntity();\n\t\t\n\t\tassertThat( project.getName(), is(\"My Project Update\"));\n\t\tassertThat( project.getDescription(), is(\"Update project\"));\n\t}","id":60170,"modified_method":"public void updateProject() {\n\t\tProjectRes project = new ProjectRes(\"sample-project\", \"My Project Update\", \"Update project\",ProjectType.IterationProject);\n\n\t\tprojectService = clientRequestFactory.createProxy(IProjectResource.class, baseUri.resolve(\"sample-project\"));\n\t\t\n\t\tResponse response = projectService.put(project);\n\t\t\t\t\n\t\tassertThat( response.getStatus(), is( Status.OK.getStatusCode()));\n\t\t\n\t\tClientResponse<ProjectRes> projectResponse = projectService.get();\n\t\t\n\t\tassertThat( projectResponse.getStatus(), is( Status.OK.getStatusCode()));\n\t\t\n\t\tproject = new ProjectRes(projectResponse.getEntity());\n\t\t\n\t\tassertThat( project.getName(), is(\"My Project Update\"));\n\t\tassertThat( project.getDescription(), is(\"Update project\"));\n\t}","commit_id":"e4ee3e22dcfa1db79f2c47c0603413ac29ef0a8c","url":"https://github.com/zanata/zanata-server"},{"original_method":"@GET\n\t@Produces( { MediaTypes.APPLICATION_FLIES_PROJECTS_XML,\n\t\t\tMediaTypes.APPLICATION_FLIES_PROJECTS_JSON,\n\t\t\tMediaType.APPLICATION_JSON })\n\t@Wrapped(element = \"projects\", namespace = Namespaces.FLIES)\n\tpublic List<ProjectRef> get() {\n\t\tList<HProject> projects = session.createQuery(\"from HProject p\").list();\n\n\t\tList<ProjectRef> projectRefs = new ArrayList<ProjectRef>(projects\n\t\t\t\t.size());\n\n\t\tfor (HProject hProject : projects) {\n\t\t\tProjectRef project = new ProjectRef(hProject.getSlug(), hProject\n\t\t\t\t\t.getName(), hProject.getDescription(),\n\t\t\t\t\tProjectType.IterationProject);\n\t\t\tprojectRefs.add(project);\n\t\t}\n\n\t\tlog.info(\"All still good hot deploying again...\");\n\n\t\treturn projectRefs;\n\t}","id":60171,"modified_method":"@GET\n\t@Produces( { MediaTypes.APPLICATION_FLIES_PROJECTS_XML,\n\t\t\tMediaTypes.APPLICATION_FLIES_PROJECTS_JSON,\n\t\t\tMediaType.APPLICATION_JSON })\n\t@Wrapped(element = \"projects\", namespace = Namespaces.FLIES)\n\tpublic List<ProjectRef> get() {\n\t\tList<HProject> projects = session.createQuery(\"from HProject p\").list();\n\n\t\tList<ProjectRef> projectRefs = new ArrayList<ProjectRef>(projects\n\t\t\t\t.size());\n\n\t\tfor (HProject hProject : projects) {\n\t\t\tProjectRef project = new ProjectRef(hProject.getSlug(), hProject\n\t\t\t\t\t.getName(), hProject.getDescription(),\n\t\t\t\t\tProjectType.IterationProject);\n\t\t\tproject.getLinks().add( \n\t\t\t\t\tnew Link(URI.create(\"p/\"+hProject.getSlug()), \"self\", MediaTypes.APPLICATION_FLIES_PROJECT));\n\t\t\tprojectRefs.add(project);\n\t\t}\n\n\t\tlog.info(\"All still good hot deploying again...\");\n\n\t\treturn projectRefs;\n\t}","commit_id":"e4ee3e22dcfa1db79f2c47c0603413ac29ef0a8c","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public void set(String name, Object value, Document document, LuceneOptions luceneOptions)\n   {\n      HIterationProject project = (HIterationProject) value;\n\n      addStringField(name + PROJECT_FIELD, project.getSlug(), document, luceneOptions);\n   }","id":60172,"modified_method":"@Override\n   public void set(String name, Object value, Document document, LuceneOptions luceneOptions)\n   {\n      HIterationProject project = (HIterationProject) value;\n\n      Field field = new Field(PROJECT_FIELD, project.getSlug(), luceneOptions.getStore(), luceneOptions.getIndex(), luceneOptions.getTermVector());\n      field.setBoost(luceneOptions.getBoost());\n      document.add(field);\n   }","commit_id":"693af05af1ea5c675f930ca8bb9419682dbbf216","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public TranslationWorkspace getOrRegisterWorkspace(WorkspaceId workspaceId) throws NoSuchWorkspaceException\n   {\n      TranslationWorkspace workspace = workspaceMap.get(workspaceId);\n      if (workspace == null)\n      {\n         workspace = createWorkspace(workspaceId);\n         TranslationWorkspace prev = workspaceMap.putIfAbsent(workspaceId, workspace);\n\n         if (prev == null)\n         {\n            projectIterationLocaleMap.put(workspaceId.getProjectIterationId(), workspaceId.getLocaleId());\n            localeWorkspaceMap.put(workspaceId.getLocaleId(), workspace);\n            if (Events.exists())\n               Events.instance().raiseEvent(EVENT_WORKSPACE_CREATED, workspaceId);\n         }\n\n         return prev == null ? workspace : prev;\n      }\n\n      validateAndGetWorkspaceContext(workspaceId);\n\n      return workspace;\n   }","id":60173,"modified_method":"@Override\n   public TranslationWorkspace getOrRegisterWorkspace(WorkspaceId workspaceId) throws NoSuchWorkspaceException\n   {\n      TranslationWorkspace workspace = workspaceMap.get(workspaceId);\n      if (workspace == null)\n      {\n         workspace = createWorkspace(workspaceId);\n         TranslationWorkspace prev = workspaceMap.putIfAbsent(workspaceId, workspace);\n\n         if (prev == null)\n         {\n            projIterWorkspaceMap.put(workspaceId.getProjectIterationId(), workspace);\n            projWorkspaceMap.put(workspaceId.getProjectIterationId().getProjectSlug(), workspace);\n            if (Events.exists())\n               Events.instance().raiseEvent(EVENT_WORKSPACE_CREATED, workspaceId);\n         }\n\n         return prev == null ? workspace : prev;\n      }\n\n      validateAndGetWorkspaceContext(workspaceId);\n\n      return workspace;\n   }","commit_id":"b91743d3273b4189292aa00175079deb0d14c130","url":"https://github.com/zanata/zanata-server"},{"original_method":"public TranslationWorkspaceManagerImpl()\n   {\n      this.workspaceMap = new ConcurrentHashMap<WorkspaceId, TranslationWorkspace>();\n\n      Multimap<ProjectIterationId, LocaleId> projectIterationLocaleMap = HashMultimap.create();\n      this.projectIterationLocaleMap = Multimaps.synchronizedMultimap(projectIterationLocaleMap);\n\n      Multimap<LocaleId, TranslationWorkspace> localeWorkspaceMap = HashMultimap.create();\n      this.localeWorkspaceMap = Multimaps.synchronizedMultimap(localeWorkspaceMap);\n\n   }","id":60174,"modified_method":"public TranslationWorkspaceManagerImpl()\n   {\n      this.workspaceMap = new ConcurrentHashMap<WorkspaceId, TranslationWorkspace>();\n\n      Multimap<String, TranslationWorkspace> pwm = HashMultimap.create();\n      this.projWorkspaceMap = Multimaps.synchronizedMultimap(pwm);\n\n      Multimap<ProjectIterationId, TranslationWorkspace> piwm = HashMultimap.create();\n      this.projIterWorkspaceMap = Multimaps.synchronizedMultimap(piwm);\n   }","commit_id":"b91743d3273b4189292aa00175079deb0d14c130","url":"https://github.com/zanata/zanata-server"},{"original_method":"private WorkspaceContext validateAndGetWorkspaceContext(WorkspaceId workspaceId) throws NoSuchWorkspaceException\n   {\n      Session session = (Session) Component.getInstance(\"session\");\n\n      EntityStatus projectStatus = (EntityStatus) session.createQuery(\"select p.status from HProject as p where p.slug = :slug\").setParameter(\"slug\", workspaceId.getProjectIterationId().getProjectSlug()).uniqueResult();\n      if (projectStatus.equals(EntityStatus.Obsolete))\n      {\n         throw new NoSuchWorkspaceException(\"Project is obsolete\");\n      }\n\n      EntityStatus projectIterationStatus = (EntityStatus) session.createQuery(\"select it.status from HProjectIteration it where it.slug = :slug and it.project.slug = :pslug\").setParameter(\"slug\", workspaceId.getProjectIterationId().getIterationSlug()).setParameter(\"pslug\", workspaceId.getProjectIterationId().getProjectSlug()).uniqueResult();\n      if (projectIterationStatus.equals(EntityStatus.Obsolete))\n      {\n         throw new NoSuchWorkspaceException(\"Project Iteration is obsolete\");\n      }\n\n      String workspaceName = (String) session.createQuery(\"select it.project.name || ' (' || it.slug || ')' \" + \"from HProjectIteration it \" + \"where it.slug = :slug \" + \"and it.project.slug = :pslug \" + \"and it.status <> :status\").setParameter(\"slug\", workspaceId.getProjectIterationId().getIterationSlug()).setParameter(\"pslug\", workspaceId.getProjectIterationId().getProjectSlug()).setParameter(\"status\", EntityStatus.Obsolete).uniqueResult();\n      if (workspaceName == null)\n      {\n         throw new NoSuchWorkspaceException(\"Invalid workspace Id\");\n      }\n\n      if (projectStatus.equals(EntityStatus.Retired) || projectIterationStatus.equals(EntityStatus.Retired))\n      {\n         return new WorkspaceContext(workspaceId, workspaceName, ULocale.getDisplayName(workspaceId.getLocaleId().toJavaName(), ULocale.ENGLISH), true);\n      }\n\n      return new WorkspaceContext(workspaceId, workspaceName, ULocale.getDisplayName(workspaceId.getLocaleId().toJavaName(), ULocale.ENGLISH), false);\n   }","id":60175,"modified_method":"private WorkspaceContext validateAndGetWorkspaceContext(WorkspaceId workspaceId) throws NoSuchWorkspaceException\n   {\n      Session session = (Session) Component.getInstance(\"session\");\n\n      EntityStatus projectStatus = (EntityStatus) session.createQuery(\"select p.status from HProject as p where p.slug = :slug\").setParameter(\"slug\", workspaceId.getProjectIterationId().getProjectSlug()).uniqueResult();\n      if (projectStatus.equals(EntityStatus.Obsolete))\n      {\n         throw new NoSuchWorkspaceException(\"Project is obsolete\");\n      }\n\n      EntityStatus projectIterationStatus = (EntityStatus) session.createQuery(\"select it.status from HProjectIteration it where it.slug = :slug and it.project.slug = :pslug\").setParameter(\"slug\", workspaceId.getProjectIterationId().getIterationSlug()).setParameter(\"pslug\", workspaceId.getProjectIterationId().getProjectSlug()).uniqueResult();\n      if (projectIterationStatus.equals(EntityStatus.Obsolete))\n      {\n         throw new NoSuchWorkspaceException(\"Project Iteration is obsolete\");\n      }\n\n      String workspaceName = (String) session.createQuery(\"select it.project.name || ' (' || it.slug || ')' \" + \"from HProjectIteration it \" + \"where it.slug = :slug \" + \"and it.project.slug = :pslug \" + \"and it.status <> :status\").setParameter(\"slug\", workspaceId.getProjectIterationId().getIterationSlug()).setParameter(\"pslug\", workspaceId.getProjectIterationId().getProjectSlug()).setParameter(\"status\", EntityStatus.Obsolete).uniqueResult();\n      if (workspaceName == null)\n      {\n         throw new NoSuchWorkspaceException(\"Invalid workspace Id\");\n      }\n\n      boolean current = projectStatus.equals(EntityStatus.Current) && projectIterationStatus.equals(EntityStatus.Current);\n      boolean readOnly = !current;\n      String localeDisplayName = ULocale.getDisplayName(workspaceId.getLocaleId().toJavaName(), ULocale.ENGLISH);\n      return new WorkspaceContext(workspaceId, workspaceName, localeDisplayName, readOnly);\n   }","commit_id":"b91743d3273b4189292aa00175079deb0d14c130","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Observer(ProjectIterationHome.PROJECT_ITERATION_UPDATE)\n   public void projectIterationUpdate(HProjectIteration projectIteration)\n   {\n      log.info(\"Project iteration {0} updated\", projectIteration.getSlug());\n      ImmutableSet<TranslationWorkspace> workspaceSet = ImmutableSet.copyOf(workspaceMap.values());\n      for (TranslationWorkspace workspace : workspaceSet)\n      {\n         if (workspace.getWorkspaceContext().getWorkspaceId().getProjectIterationId().getProjectSlug().equals(projectIteration.getProject().getSlug()) &&\n               workspace.getWorkspaceContext().getWorkspaceId().getProjectIterationId().getIterationSlug().equals(projectIteration.getSlug()))\n         {\n            ProjectIterationUpdate event = new ProjectIterationUpdate(projectIteration.getProject().getSlug(), projectIteration.getProject().getStatus(), projectIteration.getSlug(), projectIteration.getStatus());\n            workspace.publish(event);\n         }\n      }\n   }","id":60176,"modified_method":"@Observer(ProjectIterationHome.PROJECT_ITERATION_UPDATE)\n   public void projectIterationUpdate(HProjectIteration projectIteration)\n   {\n      String projectSlug = projectIteration.getProject().getSlug();\n      String iterSlug = projectIteration.getSlug();\n      log.info(\"Project {0} iteration {1} updated\", projectSlug, iterSlug);\n      ProjectIterationId iterId = new ProjectIterationId(projectSlug, iterSlug);\n\n      for (TranslationWorkspace workspace : projIterWorkspaceMap.get(iterId))\n      {\n         ProjectIterationUpdate event = new ProjectIterationUpdate(projectSlug, projectIteration.getProject().getStatus(), iterSlug, projectIteration.getStatus());\n         workspace.publish(event);\n      }\n   }","commit_id":"b91743d3273b4189292aa00175079deb0d14c130","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Observer(ProjectHome.PROJECT_UPDATE)\n   public void projectUpdate(HIterationProject project)\n   {\n      log.info(\"Project {0} updated\", project.getSlug());\n      ImmutableSet<TranslationWorkspace> workspaceSet = ImmutableSet.copyOf(workspaceMap.values());\n      for (TranslationWorkspace workspace : workspaceSet)\n      {\n         if (workspace.getWorkspaceContext().getWorkspaceId().getProjectIterationId().getProjectSlug().equals(project.getSlug()))\n         {\n            ProjectUpdate event = new ProjectUpdate(project.getSlug(), project.getStatus());\n            workspace.publish(event);\n         }\n      }\n   }","id":60177,"modified_method":"@Observer(ProjectHome.PROJECT_UPDATE)\n   public void projectUpdate(HIterationProject project)\n   {\n      String projectSlug = project.getSlug();\n      log.info(\"Project {0} updated\", projectSlug);\n      for (TranslationWorkspace workspace : projWorkspaceMap.get(projectSlug))\n      {\n         ProjectUpdate event = new ProjectUpdate(projectSlug, project.getStatus());\n         workspace.publish(event);\n      }\n   }","commit_id":"b91743d3273b4189292aa00175079deb0d14c130","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Note: we don't need @PermissionRequired(user = IS_DBA | IS_OWNER) here\n     * because all of these methods delegate to the subclass implementation.\n     *\n     * @param modeStr The String representing a mode to set\n     *\n     * @throws org.exist.util.SyntaxException If the string syntax for the mode\n     * is not recognised. The following syntaxes are supported. Simple symbolic,\n     * Unix symbolic, eXist symbolic.\n     * \n     * @throws org.exist.security.PermissionDeniedException If you do not have\n     * permission to set the mode\n     */\n    @Override\n    public final void setMode(final String modeStr) \n            throws SyntaxException, PermissionDeniedException {\n        simpleSymbolicModeMatcher.reset(modeStr);\n\n        if(simpleSymbolicModeMatcher.matches()) {\n            setSimpleSymbolicMode(modeStr);\n        } else {\n            unixSymbolicModeMatcher.reset(modeStr);\n            if(unixSymbolicModeMatcher.matches()){\n                setUnixSymbolicMode(modeStr);\n            } else {\n                existSymbolicModeMatcher.reset(modeStr);\n                if(existSymbolicModeMatcher.matches()) {\n                    setExistSymbolicMode(modeStr);\n                } else {\n                    throw new SyntaxException(\"Unknown mode String: \" + modeStr);\n                }\n            }\n        }\n    }","id":60178,"modified_method":"/**\n     * Note: we don't need @PermissionRequired(user = IS_DBA | IS_OWNER) here\n     * because all of these methods delegate to the subclass implementation.\n     *\n     * @param modeStr The String representing a mode to set\n     *\n     * @throws org.exist.util.SyntaxException If the string syntax for the mode\n     * is not recognised. The following syntaxes are supported. Simple symbolic,\n     * Unix symbolic, eXist symbolic.\n     * \n     * @throws org.exist.security.PermissionDeniedException If you do not have\n     * permission to set the mode\n     */\n    @Override\n    public final void setMode(final String modeStr) \n            throws SyntaxException, PermissionDeniedException {\n        final Matcher simpleSymbolicModeMatcher = simpleSymbolicModePattern.matcher(modeStr);\n\n        if(simpleSymbolicModeMatcher.matches()) {\n            setSimpleSymbolicMode(modeStr);\n        } else {\n            final Matcher unixSymbolicModeMatcher = unixSymbolicModePattern.matcher(modeStr);\n            if(unixSymbolicModeMatcher.matches()){\n                setUnixSymbolicMode(modeStr);\n            } else {\n                final Matcher existSymbolicModeMatcher = existSymbolicModePattern.matcher(modeStr);\n                if(existSymbolicModeMatcher.matches()) {\n                    setExistSymbolicMode(modeStr);\n                } else {\n                    throw new SyntaxException(\"Unknown mode String: \" + modeStr);\n                }\n            }\n        }\n    }","commit_id":"b580670fa19b56f33414c85f127290e46a08060f","url":"https://github.com/eXist-db/exist"},{"original_method":"private Matcher getMatcher(String toMatch) {\n        if(matcher == null) {\n            matcher = base64Pattern.matcher(toMatch);\n        } else {\n            matcher = matcher.reset(toMatch);\n        }\n        return matcher;\n    }","id":60179,"modified_method":"private Matcher getMatcher(final String toMatch) {\n        return base64Pattern.matcher(toMatch);\n    }","commit_id":"b580670fa19b56f33414c85f127290e46a08060f","url":"https://github.com/eXist-db/exist"},{"original_method":"private Matcher getMatcher(String toMatch) {\n        if(matcher == null) {\n            matcher = hexPattern.matcher(toMatch);\n        } else {\n            matcher = matcher.reset(toMatch);\n        }\n        return matcher;\n    }","id":60180,"modified_method":"private Matcher getMatcher(final String toMatch) {\n        return hexPattern.matcher(toMatch);\n    }","commit_id":"b580670fa19b56f33414c85f127290e46a08060f","url":"https://github.com/eXist-db/exist"},{"original_method":"public static synchronized String[] parseKeyValuePair(String s) {\n        matcher.reset(s);\n\t\tif(matcher.matches()) {\n\t\t\tString value = matcher.group(2);\n\t\t\tif(value.charAt(0) == '\\'' || value.charAt(0) == '\"')\n\t\t\t\t{value = value.substring(1, value.length() - 1);}\n\t\t\treturn new String[] { matcher.group(1), value };\n\t\t}\n\t\treturn null;\n\t}","id":60181,"modified_method":"public static synchronized String[] parseKeyValuePair(String s) {\n        final Matcher matcher = pattern.matcher(s);\n\t\tif(matcher.matches()) {\n\t\t\tString value = matcher.group(2);\n\t\t\tif(value.charAt(0) == '\\'' || value.charAt(0) == '\"') {\n\t\t\t\tvalue = value.substring(1, value.length() - 1);\n\t\t\t}\n\t\t\treturn new String[] { matcher.group(1), value };\n\t\t}\n\t\treturn null;\n\t}","commit_id":"b580670fa19b56f33414c85f127290e46a08060f","url":"https://github.com/eXist-db/exist"},{"original_method":"public Password(Account account, String password) {\n        \n        if (password == null) {\n            this.algorithm = DEFAULT_ALGORITHM;\n            this.pw = null;\n            this.digestPw = null;\n        } else{\n            mtcHash.reset(password);\n            \n            if (mtcHash.matches()) {\n                this.algorithm = Hash.valueOf(mtcHash.group(1));\n                this.pw = mtcHash.group(2);\n            } else {\n                this.algorithm = DEFAULT_ALGORITHM;\n                this.pw = hashAndEncode(password);\n            }\n            \n            this.digestPw = digest(account.getName(), account.getRealmId(), pw);\n        }\n    }","id":60182,"modified_method":"public Password(Account account, String password) {\n        \n        if (password == null) {\n            this.algorithm = DEFAULT_ALGORITHM;\n            this.pw = null;\n            this.digestPw = null;\n        } else{\n            final Matcher mtcHash = ptnHash.matcher(password);\n            \n            if (mtcHash.matches()) {\n                this.algorithm = Hash.valueOf(mtcHash.group(1));\n                this.pw = mtcHash.group(2);\n            } else {\n                this.algorithm = DEFAULT_ALGORITHM;\n                this.pw = hashAndEncode(password);\n            }\n            \n            this.digestPw = digest(account.getName(), account.getRealmId(), pw);\n        }\n    }","commit_id":"b580670fa19b56f33414c85f127290e46a08060f","url":"https://github.com/eXist-db/exist"},{"original_method":"private String removeNamePrefix(String name) throws ResourceException {\n        URI uri = new File(servletContext.getRealPath(\"/\")).toURI();\n        try {\n            String basePath = uri.toURL().toExternalForm();\n            if (name.startsWith(basePath)) return name.substring(basePath.length());\n        } catch (MalformedURLException e) {\n            throw new ResourceException(\"Malformed URL for base path '\"+ uri + \"'\", e);\n        }\n        \n        try {\n            URL res = servletContext.getResource(\"/\"); \n            if (res!=null) uri = res.toURI();\n        } catch (MalformedURLException e) {\n            // ignore\n        } catch (URISyntaxException e) {\n            // ignore\n        }\n\n        if (uri!=null) {\n            try {\n                String basePath = uri.toURL().toExternalForm();\n                if (name.startsWith(basePath)) return name.substring(basePath.length());\n            } catch (MalformedURLException e) {\n                throw new ResourceException(\"Malformed URL for base path '\"+ uri + \"'\", e);\n            }\n        }\n        return name;\n    }","id":60183,"modified_method":"private String removeNamePrefix(String name) throws ResourceException {\n        URI uri = null;\n        try {\n            String realPath = servletContext.getRealPath(\"/\");\n            if (realPath != null) {\n              uri = new File(realPath).toURI();\n              String basePath = uri.toURL().toExternalForm();\n              if (name.startsWith(basePath)) { return name.substring(basePath.length());}\n            }\n        } catch (MalformedURLException e) {\n            throw new ResourceException(\"Malformed URL for base path '\"+ uri + \"'\", e);\n        }\n        \n        try {\n            URL res = servletContext.getResource(\"/\"); \n            if (res!=null) uri = res.toURI();\n        } catch (MalformedURLException e) {\n            // ignore\n        } catch (URISyntaxException e) {\n            // ignore\n        }\n\n        if (uri!=null) {\n            try {\n                String basePath = uri.toURL().toExternalForm();\n                if (name.startsWith(basePath)) return name.substring(basePath.length());\n            } catch (MalformedURLException e) {\n                throw new ResourceException(\"Malformed URL for base path '\"+ uri + \"'\", e);\n            }\n        }\n        return name;\n    }","commit_id":"4015e6b6fc7eb0e9679ec07770f08921546a5750","url":"https://github.com/apache/groovy"},{"original_method":"private String applyResourceNameMatcher(final String aUri) {\n        /*\n         * mangle resource name with the compiled pattern.\n         */\n        String uri = aUri;\n        Matcher matcher = resourceNameMatcher;\n        if (matcher != null) {\n            matcher.reset(uri);\n            String replaced;\n            if (resourceNameReplaceAll) {\n                replaced = matcher.replaceAll(resourceNameReplacement);\n            } else {\n                replaced = matcher.replaceFirst(resourceNameReplacement);\n            }\n            if (!uri.equals(replaced)) {\n                if (verbose) {\n                    log(\"Replaced resource name \\\"\" + uri + \"\\\" with \\\"\" + replaced + \"\\\".\");\n                }\n                uri = replaced;\n            }\n        }\n        return uri;\n    }","id":60184,"modified_method":"protected String applyResourceNameMatcher (String uri) {\n        if (resourceNamePattern != null) {// mangle resource name with the compiled pattern.\n            Matcher matcher = resourceNamePattern.matcher(uri);\n\n            String replaced;\n            if (resourceNameReplaceAll) {\n                replaced = matcher.replaceAll(resourceNameReplacement);\n            } else {\n                replaced = matcher.replaceFirst(resourceNameReplacement);\n            }\n            if (!uri.equals(replaced)) {\n                if (verbose) {\n                    log(\"Replaced resource name \\\"\" + uri + \"\\\" with \\\"\" + replaced + \"\\\".\");\n                }\n                return replaced;\n            }\n        }\n        return uri;\n    }","commit_id":"4015e6b6fc7eb0e9679ec07770f08921546a5750","url":"https://github.com/apache/groovy"},{"original_method":"/**\n     * Interface method for ResourceContainer. This is used by the GroovyScriptEngine.\n     */\n    public URLConnection getResourceConnection(String name) throws ResourceException {\n        name = removeNamePrefix(name);\n        name = name.replaceAll(\"\\\\\\\\\", \"/\");\n\n        //remove the leading / as we are trying with a leading / now\n        if (name.startsWith(\"/\")) name = name.substring(1);\n\n        /*\n        * Try to locate the resource and return an opened connection to it.\n        */\n        try {\n            String tryScriptName = \"/\" + name;\n            URL url = servletContext.getResource(tryScriptName);\n            if (url == null) {\n                tryScriptName = \"/WEB-INF/groovy/\" + name;\n                url = servletContext.getResource(\"/WEB-INF/groovy/\" + name);\n            }\n            if (url == null) {\n                throw new ResourceException(\"Resource \\\"\" + name + \"\\\" not found!\");\n            }\n            return url.openConnection();\n        } catch (IOException e) {\n            throw new ResourceException(\"Problems getting resource named \\\"\" + name + \"\\\"!\", e);\n        }\n    }","id":60185,"modified_method":"/**\n     * Interface method for ResourceContainer. This is used by the GroovyScriptEngine.\n     */\n    public URLConnection getResourceConnection (String name) throws ResourceException {\n        name = removeNamePrefix(name).replace('\\\\', '/');\n\n        //remove the leading / as we are trying with a leading / now\n        if (name.startsWith(\"/\")) name = name.substring(1);\n\n        /*\n        * Try to locate the resource and return an opened connection to it.\n        */\n        try {\n            URL url = servletContext.getResource('/' + name);\n            if (url == null) {\n                url = servletContext.getResource(\"/WEB-INF/groovy/\" + name);\n            }\n            if (url == null) {\n                throw new ResourceException(\"Resource \\\"\" + name + \"\\\" not found!\");\n            }\n            return url.openConnection();\n        } catch (IOException e) {\n            throw new ResourceException(\"Problems getting resource named \\\"\" + name + \"\\\"!\", e);\n        }\n    }","commit_id":"4015e6b6fc7eb0e9679ec07770f08921546a5750","url":"https://github.com/apache/groovy"},{"original_method":"/**\n     * Overrides the generic init method to set some debug flags.\n     *\n     * @param config the servlet configuration provided by the container\n     * @throws ServletException if init() method defined in super class\n     *                          javax.servlet.GenericServlet throws it\n     */\n    public void init(ServletConfig config) throws ServletException {\n        /*\n         * Never forget super.init()!\n         */\n        super.init(config);\n\n        /*\n         * Grab the servlet context.\n         */\n        this.servletContext = config.getServletContext();\n\n        // Get verbosity hint.\n        String value = config.getInitParameter(\"verbose\");\n        if (value != null) {\n            this.verbose = Boolean.valueOf(value);\n        }\n\n        // get encoding\n        value = config.getInitParameter(\"encoding\");\n        if (value != null) {\n            this.encoding = value;\n        }\n\n        // And now the real init work...\n        if (verbose) {\n            log(\"Parsing init parameters...\");\n        }\n\n        String regex = config.getInitParameter(\"resource.name.regex\");\n        if (regex != null) {\n            String replacement = config.getInitParameter(\"resource.name.replacement\");\n            if (replacement == null) {\n                Exception npex = new NullPointerException(\"resource.name.replacement\");\n                String message = \"Init-param 'resource.name.replacement' not specified!\";\n                log(message, npex);\n                throw new ServletException(message, npex);\n            }\n            int flags = 0; // TODO : Parse pattern compile flags.\n            this.resourceNameMatcher = Pattern.compile(regex, flags).matcher(\"\");\n            this.resourceNameReplacement = replacement;\n            String all = config.getInitParameter(\"resource.name.replace.all\");\n            if (all != null) {\n                this.resourceNameReplaceAll = Boolean.valueOf(all);\n            }\n        }\n\n        value = config.getInitParameter(\"logGROOVY861\");\n        if (value != null) {\n            this.logGROOVY861 = Boolean.valueOf(value);\n            // nothing else to do here\n        }\n\n        /*\n         * If verbose, log the parameter values.\n         */\n        if (verbose) {\n            log(\"(Abstract) init done. Listing some parameter name/value pairs:\");\n            log(\"verbose = \" + verbose); // this *is* verbose! ;)\n            log(\"reflection = \" + reflection);\n            log(\"logGROOVY861 = \" + logGROOVY861);\n            if (resourceNameMatcher != null) {\n                log(\"resource.name.regex = \" + resourceNameMatcher.pattern().pattern());\n            } else {\n                log(\"resource.name.regex = null\");\n            }\n            log(\"resource.name.replacement = \" + resourceNameReplacement);\n        }\n    }","id":60186,"modified_method":"/**\n     * Overrides the generic init method to set some debug flags.\n     *\n     * @param config the servlet configuration provided by the container\n     * @throws ServletException if init() method defined in super class\n     *                          javax.servlet.GenericServlet throws it\n     */\n    public void init(ServletConfig config) throws ServletException {\n        /*\n         * Never forget super.init()!\n         */\n        super.init(config);\n\n        /*\n         * Grab the servlet context.\n         */\n        this.servletContext = config.getServletContext();\n\n        // Get verbosity hint.\n        String value = config.getInitParameter(\"verbose\");\n        if (value != null) {\n            this.verbose = Boolean.valueOf(value);\n        }\n\n        // get encoding\n        value = config.getInitParameter(\"encoding\");\n        if (value != null) {\n            this.encoding = value;\n        }\n\n        // And now the real init work...\n        if (verbose) {\n            log(\"Parsing init parameters...\");\n        }\n\n        String regex = config.getInitParameter(INIT_PARAM_RESOURCE_NAME_REGEX);\n        if (regex != null) {\n            String replacement = config.getInitParameter(\"resource.name.replacement\");\n            if (replacement == null) {\n                Exception npex = new NullPointerException(\"resource.name.replacement\");\n                String message = \"Init-param 'resource.name.replacement' not specified!\";\n                log(message, npex);\n                throw new ServletException(message, npex);\n            } else if (\"EMPTY_STRING\".equals(replacement)) {//<param-value><\/param-value> is prohibited\n                replacement = \"\";\n            }\n            int flags = 0; // TODO : Parse pattern compile flags (literal names).\n            String flagsStr = config.getInitParameter(INIT_PARAM_RESOURCE_NAME_REGEX_FLAGS);\n            if (flagsStr != null && flagsStr.length() > 0) {\n              flags = Integer.decode(flagsStr.trim());//throws NumberFormatException\n            }\n            resourceNamePattern = Pattern.compile(regex, flags);\n            this.resourceNameReplacement = replacement;\n            String all = config.getInitParameter(\"resource.name.replace.all\");\n            if (all != null) {\n                this.resourceNameReplaceAll = Boolean.valueOf(all.trim());\n            }\n        }\n\n        value = config.getInitParameter(\"logGROOVY861\");\n        if (value != null) {\n            this.logGROOVY861 = Boolean.valueOf(value);\n            // nothing else to do here\n        }\n\n        /*\n         * If verbose, log the parameter values.\n         */\n        if (verbose) {\n            log(\"(Abstract) init done. Listing some parameter name/value pairs:\");\n            log(\"verbose = \" + verbose); // this *is* verbose! ;)\n            log(\"reflection = \" + reflection);\n            log(\"logGROOVY861 = \" + logGROOVY861);\n            if (resourceNamePattern != null) {\n                log(INIT_PARAM_RESOURCE_NAME_REGEX + \" = \" + resourceNamePattern.pattern());\n            } else {\n                log(INIT_PARAM_RESOURCE_NAME_REGEX + \" = null\");\n            }\n            log(\"resource.name.replacement = \" + resourceNameReplacement);\n        }\n    }","commit_id":"4015e6b6fc7eb0e9679ec07770f08921546a5750","url":"https://github.com/apache/groovy"},{"original_method":"/**\n     * Initializes all fields with default values.\n     */\n    public AbstractHttpServlet() {\n        this.servletContext = null;\n        this.resourceNameMatcher = null;\n        this.resourceNameReplacement = null;\n        this.resourceNameReplaceAll = true;\n        this.verbose = false;\n        this.reflection = false;\n        this.logGROOVY861 = false;\n    }","id":60187,"modified_method":"/**\n     * Initializes all fields with default values.\n     */\n    public AbstractHttpServlet() {\n        this.servletContext = null;\n        this.resourceNameReplacement = null;\n        this.resourceNameReplaceAll = true;\n        this.verbose = false;\n        this.reflection = false;\n        this.logGROOVY861 = false;\n    }","commit_id":"4015e6b6fc7eb0e9679ec07770f08921546a5750","url":"https://github.com/apache/groovy"},{"original_method":"public boolean isSatisfiedBy(RelativePath pathToTest) {\r\n        ListIterator<PatternStep> patternIt = steps.listIterator();\r\n        ListIterator<String> testIt = pathToTest.segmentIterator();\r\n        boolean seenGreedy = false;\r\n\r\n        PatternStep patternStep;\r\n\r\n        while (testIt.hasNext()) {\r\n            String nextToTest = testIt.next();\r\n\r\n            if (!patternIt.hasNext()) {\r\n                return false;\r\n            }\r\n            patternStep = patternIt.next();\r\n\r\n            if (patternStep.isGreedy()) {\r\n                seenGreedy = true;\r\n                advancePatternStepToNextNonGreedy(patternIt);\r\n                if (!patternIt.hasNext())\r\n                    return true;    // pattern ends in greedy\r\n                patternStep = patternIt.next();\r\n\r\n                // advance test until match\r\n                while ( ! (patternStep.matches(nextToTest, !testIt.hasNext()&& pathToTest.isFile()) &&\r\n                ((patternIt.hasNext() == testIt.hasNext()) || nextPatternIsGreedy(patternIt) )) ) {\r\n                    if (!testIt.hasNext()) {\r\n                        return false; //isTerminatingMatch(pathToTest, patternIt);  // didn't match, but no more segments to test\r\n                    }\r\n                    nextToTest = testIt.next();\r\n                }\r\n\r\n                // should have match at this point, can continue on around the loop\r\n            } else {\r\n                // not a greedy patternStep\r\n                if (!patternStep.matches(nextToTest, !testIt.hasNext() && pathToTest.isFile())) {\r\n                    // didn't match, check if we are after another greedy\r\n                    if (seenGreedy) {\r\n                        rewindPatternStepToPreviousGreedy(patternIt);  // rewind pattern to greedy\r\n                        testIt.previous(); // back up test by one\r\n                    } else {\r\n                        return false;  // haven't seen greedy, no match\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // ran out of stuff to test\r\n\r\n        if (!patternIt.hasNext()) {\r\n            return true;    // if out of pattern too, then it's a match\r\n        }\r\n\r\n        return isTerminatingMatch(pathToTest, patternIt);\r\n    }","id":60188,"modified_method":"public boolean isSatisfiedBy(RelativePath pathToTest) {\r\n        ListIterator<PatternStep> patternIt = steps.listIterator();\r\n        ListIterator<String> testIt = pathToTest.segmentIterator();\r\n        boolean seenGreedy = false;\r\n\r\n        PatternStep patternStep;\r\n\r\n        while (testIt.hasNext()) {\r\n            String nextToTest = testIt.next();\r\n\r\n            if (!patternIt.hasNext()) {\r\n                return false;\r\n            }\r\n            patternStep = patternIt.next();\r\n\r\n            if (patternStep.isGreedy()) {\r\n                seenGreedy = true;\r\n                advancePatternStepToNextNonGreedy(patternIt);\r\n                if (!patternIt.hasNext())\r\n                    return true;    // pattern ends in greedy\r\n                patternStep = patternIt.next();\r\n\r\n                // advance test until match\r\n                while ( ! (patternStep.matches(nextToTest, !testIt.hasNext()&& pathToTest.isFile()) &&\r\n                ((patternIt.hasNext() == testIt.hasNext()) || nextPatternIsGreedy(patternIt) )) ) {\r\n                    if (!testIt.hasNext()) {\r\n                        return partialMatchDirs && !pathToTest.isFile(); //isTerminatingMatch(pathToTest, patternIt);  // didn't match, but no more segments to test\r\n                    }\r\n                    nextToTest = testIt.next();\r\n                }\r\n\r\n                // should have match at this point, can continue on around the loop\r\n            } else {\r\n                // not a greedy patternStep\r\n                if (!patternStep.matches(nextToTest, !testIt.hasNext() && pathToTest.isFile())) {\r\n                    // didn't match, check if we are after another greedy\r\n                    if (seenGreedy) {\r\n                        rewindPatternStepToPreviousGreedy(patternIt);  // rewind pattern to greedy\r\n                        testIt.previous(); // back up test by one\r\n                    } else {\r\n                        return false;  // haven't seen greedy, no match\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // ran out of stuff to test\r\n\r\n        if (!patternIt.hasNext()) {\r\n            return true;    // if out of pattern too, then it's a match\r\n        }\r\n\r\n        return isTerminatingMatch(pathToTest, patternIt);\r\n    }","commit_id":"5208d47af4191c869db193e2af7de52a79045fe2","url":"https://github.com/gradle/gradle"},{"original_method":"@Test public void testGreedy() {\r\n        matcher = new DefaultPatternMatcher(true, true, \"a\",\"**\");\r\n        path = new RelativePath(true, \"a\", \"b\", \"c\");\r\n        assertTrue(matcher.isSatisfiedBy(path));\r\n\r\n        //leading greedy\r\n        matcher = new DefaultPatternMatcher(true, true, \"**\", \"c\");\r\n        path = new RelativePath(true, \"a\", \"b\", \"c\");\r\n        assertTrue(matcher.isSatisfiedBy(path));\r\n        \r\n        path = new RelativePath(true, \"a\", \"b\", \"d\");\r\n        assertFalse(matcher.isSatisfiedBy(path));\r\n\r\n        // inner greedy\r\n        matcher = new DefaultPatternMatcher(true, true, \"a\", \"**\", \"c\");\r\n        path = new RelativePath(true, \"a\", \"b\", \"c\");\r\n        assertTrue(matcher.isSatisfiedBy(path));\r\n\r\n        path = new RelativePath(true, \"a\", \"aa\", \"bb\", \"c\");\r\n        assertTrue(matcher.isSatisfiedBy(path));\r\n\r\n        path = new RelativePath(false, \"a\", \"aa\", \"bb\", \"d\");\r\n        assertFalse(matcher.isSatisfiedBy(path));\r\n\r\n        path = new RelativePath(true, \"a\", \"aa\", \"bb\", \"d\");\r\n        assertFalse(matcher.isSatisfiedBy(path));\r\n\r\n        // fake trail\r\n        matcher = new DefaultPatternMatcher(true, true, \"a\", \"**\", \"c\", \"d\");\r\n        path = new RelativePath(true, \"a\", \"b\", \"c\", \"e\", \"c\", \"d\");\r\n        assertTrue(matcher.isSatisfiedBy(path));\r\n        \r\n        // multiple greedies\r\n        matcher = new DefaultPatternMatcher(true, true, \"a\", \"**\", \"c\", \"**\", \"e\");\r\n        path = new RelativePath(true, \"a\", \"b\", \"c\", \"d\", \"e\");\r\n        assertTrue(matcher.isSatisfiedBy(path));\r\n\r\n        path = new RelativePath(true, \"a\", \"b\", \"bb\", \"c\", \"d\", \"e\");\r\n        assertTrue(matcher.isSatisfiedBy(path));\r\n\r\n        path = new RelativePath(true, \"a\", \"q\", \"bb\", \"c\", \"d\", \"c\", \"d\", \"e\");\r\n        assertTrue(matcher.isSatisfiedBy(path));\r\n\r\n        // Missing greedy\r\n        matcher = new DefaultPatternMatcher(true, true, \"a\", \"**\", \"c\");\r\n        path = new RelativePath(true, \"a\", \"c\");\r\n        assertTrue(matcher.isSatisfiedBy(path));\r\n\r\n        path = new RelativePath(true, \"a\", \"d\");\r\n        assertFalse(matcher.isSatisfiedBy(path));\r\n    }","id":60189,"modified_method":"@Test public void testGreedy() {\r\n        matcher = new DefaultPatternMatcher(true, true, \"a\",\"**\");\r\n        path = new RelativePath(true, \"a\", \"b\", \"c\");\r\n        assertTrue(matcher.isSatisfiedBy(path));\r\n\r\n        //leading greedy\r\n        matcher = new DefaultPatternMatcher(true, true, \"**\", \"c\");\r\n        path = new RelativePath(true, \"a\", \"b\", \"c\");\r\n        assertTrue(matcher.isSatisfiedBy(path));\r\n        \r\n        path = new RelativePath(true, \"a\", \"b\", \"d\");\r\n        assertFalse(matcher.isSatisfiedBy(path));\r\n\r\n        // inner greedy\r\n        matcher = new DefaultPatternMatcher(true, true, \"a\", \"**\", \"c\");\r\n        path = new RelativePath(true, \"a\", \"b\", \"c\");\r\n        assertTrue(matcher.isSatisfiedBy(path));\r\n\r\n        path = new RelativePath(true, \"a\", \"aa\", \"bb\", \"c\");\r\n        assertTrue(matcher.isSatisfiedBy(path));\r\n\r\n        path = new RelativePath(false, \"a\", \"aa\", \"bb\", \"d\");\r\n        assertTrue(matcher.isSatisfiedBy(path));\r\n\r\n        path = new RelativePath(true, \"a\", \"aa\", \"bb\", \"d\");\r\n        assertFalse(matcher.isSatisfiedBy(path));\r\n\r\n        // fake trail\r\n        matcher = new DefaultPatternMatcher(true, true, \"a\", \"**\", \"c\", \"d\");\r\n        path = new RelativePath(true, \"a\", \"b\", \"c\", \"e\", \"c\", \"d\");\r\n        assertTrue(matcher.isSatisfiedBy(path));\r\n        \r\n        // multiple greedies\r\n        matcher = new DefaultPatternMatcher(true, true, \"a\", \"**\", \"c\", \"**\", \"e\");\r\n        path = new RelativePath(true, \"a\", \"b\", \"c\", \"d\", \"e\");\r\n        assertTrue(matcher.isSatisfiedBy(path));\r\n\r\n        path = new RelativePath(true, \"a\", \"b\", \"bb\", \"c\", \"d\", \"e\");\r\n        assertTrue(matcher.isSatisfiedBy(path));\r\n\r\n        path = new RelativePath(true, \"a\", \"q\", \"bb\", \"c\", \"d\", \"c\", \"d\", \"e\");\r\n        assertTrue(matcher.isSatisfiedBy(path));\r\n\r\n        // Missing greedy\r\n        matcher = new DefaultPatternMatcher(true, true, \"a\", \"**\", \"c\");\r\n        path = new RelativePath(true, \"a\", \"c\");\r\n        assertTrue(matcher.isSatisfiedBy(path));\r\n\r\n        path = new RelativePath(true, \"a\", \"d\");\r\n        assertFalse(matcher.isSatisfiedBy(path));\r\n    }","commit_id":"5208d47af4191c869db193e2af7de52a79045fe2","url":"https://github.com/gradle/gradle"},{"original_method":"public boolean isSatisfiedBy(RelativePath path) {\r\n        if (!path.isFile()) {\r\n            return partialMatchDirs;\r\n        }\r\n        return nameStep.matches(path.getLastName(), true);\r\n    }","id":60190,"modified_method":"public boolean isSatisfiedBy(RelativePath path) {\r\n        if (!path.isFile()) {\r\n            return partialMatchDirs;\r\n        }\r\n        String lastName = path.getLastName();\r\n        if (lastName == null) {\r\n            return false;\r\n        }\r\n        return nameStep.matches(lastName, true);\r\n    }","commit_id":"5208d47af4191c869db193e2af7de52a79045fe2","url":"https://github.com/gradle/gradle"},{"original_method":"public static PatternStep getStep(String source, boolean isLast, boolean caseSensitive) {\r\n        if (source.equals(\"**\")) {\r\n            return new GreedyPatternStep();\r\n        } else {\r\n            return new RegExpPatternStep(source, isLast, caseSensitive);\r\n        }\r\n    }","id":60191,"modified_method":"public static PatternStep getStep(String source, boolean isLast, boolean caseSensitive) {\r\n        if (source.equals(\"**\")) {\r\n            return new GreedyPatternStep();\r\n        } else {\r\n            return new RegExpPatternStep(source, caseSensitive);\r\n        }\r\n    }","commit_id":"5208d47af4191c869db193e2af7de52a79045fe2","url":"https://github.com/gradle/gradle"},{"original_method":"public RegExpPatternStep(String pattern, boolean isLast, boolean caseSensitive) {\r\n        matcher = Pattern.compile(getRegExPattern(pattern), caseSensitive?0:Pattern.CASE_INSENSITIVE).matcher(\"\");\r\n        this.isLast = isLast;\r\n    }","id":60192,"modified_method":"public RegExpPatternStep(String pattern, boolean caseSensitive) {\r\n        this.pattern = Pattern.compile(getRegExPattern(pattern), caseSensitive?0:Pattern.CASE_INSENSITIVE);\r\n    }","commit_id":"5208d47af4191c869db193e2af7de52a79045fe2","url":"https://github.com/gradle/gradle"},{"original_method":"public boolean matches(String testString, boolean isFile) {\r\n        matcher.reset(testString);\r\n        // (isLast == isFile) &&\r\n        return matcher.matches();\r\n    }","id":60193,"modified_method":"public boolean matches(String testString, boolean isFile) {\r\n        Matcher matcher = pattern.matcher(testString);\r\n        return matcher.matches();\r\n    }","commit_id":"5208d47af4191c869db193e2af7de52a79045fe2","url":"https://github.com/gradle/gradle"},{"original_method":"@Test public void testEscapeSet() {\r\n        String testChars = \"`~!@#$%^&*()-_=+[]{}\\\\|;:'\\\"<>,/\";\r\n        RegExpPatternStep step = new RegExpPatternStep(testChars, true, true);\r\n        assertTrue(step.matches(testChars, true));\r\n    }","id":60194,"modified_method":"@Test public void testEscapeSet() {\r\n        String testChars = \"`~!@#$%^&*()-_=+[]{}\\\\|;:'\\\"<>,/\";\r\n        RegExpPatternStep step = new RegExpPatternStep(testChars, true);\r\n        assertTrue(step.matches(testChars, true));\r\n    }","commit_id":"5208d47af4191c869db193e2af7de52a79045fe2","url":"https://github.com/gradle/gradle"},{"original_method":"@Test public void testCase() {\r\n        RegExpPatternStep step = new RegExpPatternStep(\"MiXeD\", true, true);\r\n        assertTrue(step.matches(\"MiXeD\", true));\r\n        assertFalse(step.matches(\"mixed\", true));\r\n\r\n        step = new RegExpPatternStep(\"MiXeD\", true, false);\r\n        assertTrue(step.matches(\"MiXeD\", true));\r\n        assertTrue(step.matches(\"mixed\", true));\r\n    }","id":60195,"modified_method":"@Test public void testCase() {\r\n        RegExpPatternStep step = new RegExpPatternStep(\"MiXeD\", true);\r\n        assertTrue(step.matches(\"MiXeD\", true));\r\n        assertFalse(step.matches(\"mixed\", true));\r\n\r\n        step = new RegExpPatternStep(\"MiXeD\", false);\r\n        assertTrue(step.matches(\"MiXeD\", true));\r\n        assertTrue(step.matches(\"mixed\", true));\r\n    }","commit_id":"5208d47af4191c869db193e2af7de52a79045fe2","url":"https://github.com/gradle/gradle"},{"original_method":"@Test public void testMatches() {\r\n        RegExpPatternStep step = new RegExpPatternStep(\"literal\", true, true);\r\n        assertTrue(step.matches(\"literal\", true));\r\n        assertFalse(step.matches(\"Literal\", true));\r\n        assertFalse(step.matches(\"literally\", true));\r\n        assertFalse(step.matches(\"aliteral\", true));\r\n\r\n        step = new RegExpPatternStep(\"a?c\", true, true);\r\n        assertTrue(step.matches(\"abc\", true));\r\n        assertFalse(step.matches(\"abcd\", true));\r\n        assertTrue(step.matches(\"a$c\", true));\r\n\r\n        step = new RegExpPatternStep(\"a*c\", true, true);\r\n        assertTrue(step.matches(\"abc\", true));\r\n        assertTrue(step.matches(\"abrac\", true));\r\n        assertFalse(step.matches(\"abcd\", true));\r\n\r\n        step = new RegExpPatternStep(\"*\", true, true);\r\n        assertTrue(step.matches(\"asd;flkj\", true));\r\n    }","id":60196,"modified_method":"@Test public void testMatches() {\r\n        RegExpPatternStep step = new RegExpPatternStep(\"literal\", true);\r\n        assertTrue(step.matches(\"literal\", true));\r\n        assertFalse(step.matches(\"Literal\", true));\r\n        assertFalse(step.matches(\"literally\", true));\r\n        assertFalse(step.matches(\"aliteral\", true));\r\n\r\n        step = new RegExpPatternStep(\"a?c\", true);\r\n        assertTrue(step.matches(\"abc\", true));\r\n        assertFalse(step.matches(\"abcd\", true));\r\n        assertTrue(step.matches(\"a$c\", true));\r\n\r\n        step = new RegExpPatternStep(\"a*c\", true);\r\n        assertTrue(step.matches(\"abc\", true));\r\n        assertTrue(step.matches(\"abrac\", true));\r\n        assertFalse(step.matches(\"abcd\", true));\r\n\r\n        step = new RegExpPatternStep(\"*\", true);\r\n        assertTrue(step.matches(\"asd;flkj\", true));\r\n    }","commit_id":"5208d47af4191c869db193e2af7de52a79045fe2","url":"https://github.com/gradle/gradle"},{"original_method":"private void processWsdl(WsdlOption wsdlOption,\n                             long cgtimestamp) throws MojoExecutionException {\n        \n        File outputDirFile = wsdlOption.getOutputDir();\n        outputDirFile.mkdirs();\n        \n        File file = new File(wsdlOption.getWsdl());\n        // If URL to WSDL, replace ? and & since they're invalid chars for file names\n        File doneFile =\n            new File(markerDirectory, \".\" + file.getName().replace('?', '_').replace('&', '_') + \".DONE\");\n        boolean doWork = cgtimestamp > doneFile.lastModified();\n        if (!doneFile.exists()) {\n            doWork = true;\n        } else if (file.lastModified() > doneFile.lastModified()) {\n            doWork = true;\n        } else if (isDefServiceName(wsdlOption)) {\n            doWork = true;\n        } else {\n            File files[] = wsdlOption.getDependencies();\n            if (files != null) {\n                for (int z = 0; z < files.length; ++z) {\n                    if (files[z].lastModified() > doneFile.lastModified()) {\n                        doWork = true;\n                    }\n                }\n            }\n        }\n\n        if (doWork) {\n            doneFile.delete();\n\n            List<String> list = new ArrayList<String>();\n            if (wsdlOption.getPackagenames() != null) {\n                Iterator it = wsdlOption.getPackagenames().iterator();\n                while (it.hasNext()) {\n                    list.add(\"-p\");\n                    list.add(it.next().toString());\n                }\n            }\n            // -d specify the dir for generated source code\n            //list.add(\"-verbose\");\n            list.add(\"-d\");\n            list.add(outputDirFile.toString());\n\n            if (wsdlOption.getExtraargs() != null) {\n                Iterator it = wsdlOption.getExtraargs().iterator();\n                while (it.hasNext()) {\n                    list.add(it.next().toString());\n                }\n            }\n            list.add(wsdlOption.getWsdl());\n\n            getLog().debug(\"Calling wsdl2java with args: \" + list);\n            try {\n                new WSDLToJava((String[])list.toArray(new String[list.size()])).run(new ToolContext());\n                doneFile.createNewFile();\n            } catch (Throwable e) {\n                getLog().debug(e);\n                throw new MojoExecutionException(e.getMessage(), e);\n            }\n        }\n    }","id":60197,"modified_method":"private void processWsdl(WsdlOption wsdlOption,\n                             long cgtimestamp) throws MojoExecutionException {\n        \n        File outputDirFile = wsdlOption.getOutputDir();\n        outputDirFile.mkdirs();\n        \n        \n        String wsdlLocation = wsdlOption.getWsdl();\n        URI basedir = project.getBasedir().toURI();\n        URI wsdlURI = basedir.resolve(wsdlLocation);\n        \n        String doneFileName = wsdlURI.toString();\n        if (doneFileName.startsWith(basedir.toString())) {\n            doneFileName = doneFileName.substring(basedir.toString().length());\n        }\n        \n        doneFileName = doneFileName.replace('?', '_')\n            .replace('&', '_').replace('/', '_').replace('\\\\', '_');\n        \n        // If URL to WSDL, replace ? and & since they're invalid chars for file names\n        File doneFile =\n            new File(markerDirectory, \".\" + doneFileName + \".DONE\");\n        \n        long timestamp = 0;\n        if (\"file\".equals(wsdlURI.getScheme())) {\n            timestamp = new File(wsdlURI).lastModified();\n        } else {\n            try {\n                timestamp = wsdlURI.toURL().openConnection().getDate();\n            } catch (Exception e) {\n                //ignore\n            }\n        }\n        \n        \n        boolean doWork = cgtimestamp > doneFile.lastModified();\n        if (!doneFile.exists()) {\n            doWork = true;\n        } else if (timestamp > doneFile.lastModified()) {\n            doWork = true;\n        } else if (isDefServiceName(wsdlOption)) {\n            doWork = true;\n        } else {\n            File files[] = wsdlOption.getDependencies();\n            if (files != null) {\n                for (int z = 0; z < files.length; ++z) {\n                    if (files[z].lastModified() > doneFile.lastModified()) {\n                        doWork = true;\n                    }\n                }\n            }\n        }\n\n        if (doWork) {\n            doneFile.delete();\n\n            List<String> list = new ArrayList<String>();\n            if (wsdlOption.getPackagenames() != null) {\n                Iterator it = wsdlOption.getPackagenames().iterator();\n                while (it.hasNext()) {\n                    list.add(\"-p\");\n                    list.add(it.next().toString());\n                }\n            }\n            // -d specify the dir for generated source code\n            //list.add(\"-verbose\");\n            list.add(\"-d\");\n            list.add(outputDirFile.toString());\n\n            if (wsdlOption.getExtraargs() != null) {\n                Iterator it = wsdlOption.getExtraargs().iterator();\n                while (it.hasNext()) {\n                    list.add(it.next().toString());\n                }\n            }\n            list.add(wsdlURI.toString());\n\n            getLog().debug(\"Calling wsdl2java with args: \" + list);\n            try {\n                new WSDLToJava((String[])list.toArray(new String[list.size()])).run(new ToolContext());\n                doneFile.createNewFile();\n            } catch (Throwable e) {\n                getLog().debug(e);\n                throw new MojoExecutionException(e.getMessage(), e);\n            }\n        }\n    }","commit_id":"32781d8032b85211eb3d148f8c03eac982719c4b","url":"https://github.com/apache/cxf"},{"original_method":"public void execute() throws MojoExecutionException {\n        String outputDir = testSourceRoot == null ? sourceRoot : testSourceRoot;\n        File outputDirFile = new File(outputDir);\n        outputDirFile.mkdirs();\n        \n        long timestamp = CodegenUtils.getCodegenTimestamp();\n        boolean result = true;\n        \n        if (xsdOptions == null) {\n            throw new MojoExecutionException(\"Must specify xsdOptions\");           \n        }\n     \n        for (int x = 0; x < xsdOptions.length; x++) {\n            String[] args = getArguments(xsdOptions[x], outputDir);\n            \n            File file = new File(xsdOptions[x].getXsd());\n            File doneFile = new File(outputDirFile, \".\" + file.getName() + \".DONE\");\n            boolean doWork = timestamp > doneFile.lastModified();\n            if (!doneFile.exists()) {\n                doWork = true;\n            } else if (file.lastModified() > doneFile.lastModified()) {\n                doWork = true;\n            } else {\n                File files[] = xsdOptions[x].getDependencies();\n                if (files != null) {\n                    for (int z = 0; z < files.length; ++z) {\n                        if (files[z].lastModified() > doneFile.lastModified()) {\n                            doWork = true;\n                        }\n                    }\n                }\n            }\n            \n            if (doWork) {\n                SecurityManager oldSm = System.getSecurityManager();\n                try {\n                    try {\n                        System.setSecurityManager(new NoExitSecurityManager());\n                        \n                        com.sun.tools.xjc.Driver.main(args);\n                       \n                    } catch (ExitException e) {\n                        if (e.getStatus() == 0) {\n                            doneFile.delete();\n                            doneFile.createNewFile();\n                        } else {\n                            throw e;\n                        }\n                    } finally {\n                        System.setSecurityManager(oldSm);\n                        File dirs[] = xsdOptions[x].getDeleteDirs();\n                        if (dirs != null) {\n                            for (int idx = 0; idx < dirs.length; ++idx) {\n                                result = result && deleteDir(dirs[idx]);\n                            }\n                        }\n                    }\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    throw new MojoExecutionException(e.getMessage(), e);\n                }\n            }\n        \n            if (!result) {\n                throw new MojoExecutionException(\"Could not delete redundant dirs\");\n            }                \n        }\n        \n        if (project != null && sourceRoot != null) {\n            project.addCompileSourceRoot(sourceRoot);\n        }\n        if (project != null && testSourceRoot != null) {\n            project.addTestCompileSourceRoot(testSourceRoot);\n        }\n    }","id":60198,"modified_method":"public void execute() throws MojoExecutionException {\n        String outputDir = testSourceRoot == null ? sourceRoot : testSourceRoot;\n        File outputDirFile = new File(outputDir);\n        outputDirFile.mkdirs();\n        markerDirectory.mkdirs();\n\n        long timestamp = CodegenUtils.getCodegenTimestamp();\n        boolean result = true;\n        \n        if (xsdOptions == null) {\n            throw new MojoExecutionException(\"Must specify xsdOptions\");           \n        }\n     \n        for (int x = 0; x < xsdOptions.length; x++) {\n            String[] args = getArguments(xsdOptions[x], outputDir);\n            \n            String xsdLocation = xsdOptions[x].getXsd();\n            URI basedir = project.getBasedir().toURI();\n            URI xsdURI = basedir.resolve(xsdLocation);\n            \n            String doneFileName = xsdURI.toString();\n            if (doneFileName.startsWith(basedir.toString())) {\n                doneFileName = doneFileName.substring(basedir.toString().length());\n            }\n            \n            doneFileName = doneFileName.replace('?', '_')\n                .replace('&', '_').replace('/', '_').replace('\\\\', '_');\n            \n            // If URL to WSDL, replace ? and & since they're invalid chars for file names\n            File doneFile =\n                new File(markerDirectory, \".\" + doneFileName + \".DONE\");\n            \n            long srctimestamp = 0;\n            if (\"file\".equals(xsdURI.getScheme())) {\n                srctimestamp = new File(xsdURI).lastModified();\n            } else {\n                try {\n                    srctimestamp = xsdURI.toURL().openConnection().getDate();\n                } catch (Exception e) {\n                    //ignore\n                }\n            }\n            \n            boolean doWork = timestamp > doneFile.lastModified();\n            if (!doneFile.exists()) {\n                doWork = true;\n            } else if (srctimestamp > doneFile.lastModified()) {\n                doWork = true;\n            } else {\n                File files[] = xsdOptions[x].getDependencies();\n                if (files != null) {\n                    for (int z = 0; z < files.length; ++z) {\n                        if (files[z].lastModified() > doneFile.lastModified()) {\n                            doWork = true;\n                        }\n                    }\n                }\n            }\n            \n            if (doWork) {\n                SecurityManager oldSm = System.getSecurityManager();\n                try {\n                    try {\n                        System.setSecurityManager(new NoExitSecurityManager());\n                        \n                        com.sun.tools.xjc.Driver.main(args);\n                       \n                    } catch (ExitException e) {\n                        if (e.getStatus() == 0) {\n                            doneFile.delete();\n                            doneFile.createNewFile();\n                        } else {\n                            throw e;\n                        }\n                    } finally {\n                        System.setSecurityManager(oldSm);\n                        File dirs[] = xsdOptions[x].getDeleteDirs();\n                        if (dirs != null) {\n                            for (int idx = 0; idx < dirs.length; ++idx) {\n                                result = result && deleteDir(dirs[idx]);\n                            }\n                        }\n                    }\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    throw new MojoExecutionException(e.getMessage(), e);\n                }\n            }\n        \n            if (!result) {\n                throw new MojoExecutionException(\"Could not delete redundant dirs\");\n            }                \n        }\n        \n        if (project != null && sourceRoot != null) {\n            project.addCompileSourceRoot(sourceRoot);\n        }\n        if (project != null && testSourceRoot != null) {\n            project.addTestCompileSourceRoot(testSourceRoot);\n        }\n    }","commit_id":"32781d8032b85211eb3d148f8c03eac982719c4b","url":"https://github.com/apache/cxf"},{"original_method":"public void execute() throws MojoExecutionException {\n        if (includes == null) {\n            includes = new String[] {\"*.wsdl\"};\n        } \n       \n        File classesDir = new File(classesDirectory);\n        classesDir.mkdirs();\n        markerDirectory.mkdirs();\n        \n        List<WsdlOption> options = new ArrayList<WsdlOption>();\n        if (wsdlRoot != null && wsdlRoot.exists()) {\n            options.addAll(getWsdlOptionsFromDir(wsdlRoot, sourceRoot));\n        }\n        if (testWsdlRoot != null && testWsdlRoot.exists()) {\n            options.addAll(getWsdlOptionsFromDir(testWsdlRoot, testSourceRoot));\n        }\n\n        if (wsdlOptions != null) {\n            mergeOptions(options);\n        }\n        wsdlOptions = options.toArray(new WsdlOption[options.size()]);\n\n        if (wsdlOptions.length == 0) {\n            getLog().info(\"Nothing to generate\");\n            return;\n        }\n\n        List<URL> urlList = new ArrayList<URL>();\n        StringBuffer buf = new StringBuffer();\n\n        try {\n            urlList.add(classesDir.toURI().toURL());\n            if (!useCompileClasspath) {\n                urlList.add(new File(project.getBuild().getOutputDirectory()).toURI().toURL());\n            }\n        } catch (MalformedURLException e) {\n            //ignore\n        }\n\n        buf.append(classesDir.getAbsolutePath());\n        buf.append(File.pathSeparatorChar);\n        if (!useCompileClasspath) {\n            buf.append(project.getBuild().getOutputDirectory());\n            buf.append(File.pathSeparatorChar);\n        }\n        List artifacts = useCompileClasspath ? project.getCompileArtifacts() : project.getTestArtifacts();\n        for (Artifact a : CastUtils.cast(artifacts, Artifact.class)) {\n            try {\n                if (a.getFile() != null\n                    && a.getFile().exists()) {\n                    urlList.add(a.getFile().toURI().toURL());\n                    buf.append(a.getFile().getAbsolutePath());\n                    buf.append(File.pathSeparatorChar);\n                    //System.out.println(\"     \" + a.getFile().getAbsolutePath());\n                }\n            } catch (MalformedURLException e) {\n                //ignore\n            }\n        }\n        \n        ClassLoader origContext = Thread.currentThread().getContextClassLoader();\n        URLClassLoader loader = new URLClassLoader(urlList.toArray(new URL[urlList.size()]),\n                                                   origContext);\n        String newCp = buf.toString();\n        \n        getLog().debug(\"Classpath: \" + urlList.toString());\n\n        //with some VM's, creating an XML parser (which we will do to parse wsdls)\n        //will set some system properties that then interferes with mavens \n        //dependency resolution.  (OSX is the major culprit here)\n        //We'll save the props and then set them back later.\n        Map<Object, Object> origProps = new HashMap<Object, Object>(System.getProperties());\n        \n        String cp = System.getProperty(\"java.class.path\");\n        boolean result = true;\n        \n        try {\n            Thread.currentThread().setContextClassLoader(loader);\n            System.setProperty(\"java.class.path\", newCp);\n            for (WsdlOption o : wsdlOptions) {\n                processWsdl(o);\n\n                File dirs[] = o.getDeleteDirs();\n                if (dirs != null) {\n                    for (int idx = 0; idx < dirs.length; ++idx) {\n                        result = result && deleteDir(dirs[idx]);\n                    }\n                }                \n            }\n        } finally {\n            //cleanup as much as we can.\n            Bus bus = BusFactory.getDefaultBus(false);\n            if (bus != null) {\n                bus.shutdown(true);\n            }\n            Thread.currentThread().setContextClassLoader(origContext);\n            System.setProperty(\"java.class.path\", cp);\n            \n            Map<Object, Object> newProps = new HashMap<Object, Object>(System.getProperties());\n            for (Object o : newProps.keySet()) {\n                if (!origProps.containsKey(o)) {\n                    System.clearProperty(o.toString());\n                }\n            }\n            System.getProperties().putAll(origProps);\n            org.apache.cxf.tools.wsdlto.core.PluginLoader.unload();\n        }\n        if (project != null && sourceRoot != null && sourceRoot.exists()) {\n            project.addCompileSourceRoot(sourceRoot.getAbsolutePath());\n        }\n        if (project != null && testSourceRoot != null && testSourceRoot.exists()) {\n            project.addTestCompileSourceRoot(testSourceRoot.getAbsolutePath());\n        }\n\n        System.gc();\n    }","id":60199,"modified_method":"public void execute() throws MojoExecutionException {\n        if (includes == null) {\n            includes = new String[] {\n                \"*.wsdl\"\n            };\n        }\n\n        File classesDir = new File(classesDirectory);\n        classesDir.mkdirs();\n        markerDirectory.mkdirs();\n\n        WsdlOption[] effectiveWsdlOptions = createWsdlOptionsFromWsdlFilesAndExplicitWsdlOptions();\n\n        if (effectiveWsdlOptions.length == 0) {\n            getLog().info(\"Nothing to generate\");\n            return;\n        }\n\n        ClassLoaderSwitcher classLoaderSwitcher = new ClassLoaderSwitcher(getLog());\n        boolean result = true;\n\n        try {\n            classLoaderSwitcher.switchClassLoader(project, useCompileClasspath, classesDir);\n\n            for (WsdlOption o : effectiveWsdlOptions) {\n                processWsdl(o);\n\n                File dirs[] = o.getDeleteDirs();\n                if (dirs != null) {\n                    for (int idx = 0; idx < dirs.length; ++idx) {\n                        result = result && deleteDir(dirs[idx]);\n                    }\n                }\n            }\n        } finally {\n            // cleanup as much as we can.\n            Bus bus = BusFactory.getDefaultBus(false);\n            if (bus != null) {\n                bus.shutdown(true);\n            }\n            classLoaderSwitcher.restoreClassLoader();\n            org.apache.cxf.tools.wsdlto.core.PluginLoader.unload();\n        }\n        if (project != null && sourceRoot != null && sourceRoot.exists()) {\n            project.addCompileSourceRoot(sourceRoot.getAbsolutePath());\n        }\n        if (project != null && testSourceRoot != null && testSourceRoot.exists()) {\n            project.addTestCompileSourceRoot(testSourceRoot.getAbsolutePath());\n        }\n\n        System.gc();\n    }","commit_id":"e293245c432c7e80edb4dae6267fd1a6e72dbc0b","url":"https://github.com/apache/cxf"},{"original_method":"private void mergeOptions(List<WsdlOption> options) {\n        File outputDirFile = testSourceRoot == null ? sourceRoot : testSourceRoot;\n        for (WsdlOption o : wsdlOptions) {\n            if (o.getOutputDir() == null) {\n                o.setOutputDir(outputDirFile);\n            }\n            \n            File file = new File(o.getWsdl());\n            if (!file.exists()) {\n                file = new File(project.getBasedir(), o.getWsdl());\n            }\n            if (file.exists()) {\n                file = file.getAbsoluteFile();\n                for (WsdlOption o2 : options) {\n                    File file2 = null;\n                    try {\n                        URI uri = new URI(o2.getWsdl());\n                        if (uri.isAbsolute()) {\n                            file2 = new File(uri);\n                        }\n                    } catch (Exception e) {\n                        //ignore\n                    }\n                    if (file2 == null || !file2.exists()) {\n                        file2 = new File(o2.getWsdl());\n                    }\n                    if (file2 == null || !file2.exists()) {\n                        file2 = new File(project.getBasedir(), o2.getWsdl());\n                    }\n                    if (file2.exists() \n                        && file2.getAbsoluteFile().equals(file)) {\n                        o.getExtraargs().addAll(0, o2.getExtraargs());\n                        options.remove(o2);\n                        break;\n                    }\n                }\n            }\n            options.add(0, o);\n        }        \n    }","id":60200,"modified_method":"/**\n     * Merge WsdlOptions that point to the same file by adding the extraargs to the first option and deleting\n     * the second from the options list\n     * \n     * @param options\n     */\n    private void mergeOptions(List<WsdlOption> effectiveWsdlOptions, WsdlOption[] explicitWsdlOptions) {\n        File outputDirFile = testSourceRoot == null ? sourceRoot : testSourceRoot;\n        for (WsdlOption o : explicitWsdlOptions) {\n            if (o.getOutputDir() == null) {\n                o.setOutputDir(outputDirFile);\n            }\n\n            File file = getFileFromWsdlPath(o.getWsdl());\n            if (file.exists()) {\n                file = file.getAbsoluteFile();\n                for (WsdlOption o2 : effectiveWsdlOptions) {\n                    File file2 = getFileFromWsdlPath(o2.getWsdl());\n                    if (file2.exists() && file2.getAbsoluteFile().equals(file)) {\n                        o.getExtraargs().addAll(0, o2.getExtraargs());\n                        effectiveWsdlOptions.remove(o2);\n                        break;\n                    }\n                }\n            }\n            effectiveWsdlOptions.add(0, o);\n        }\n    }","commit_id":"e293245c432c7e80edb4dae6267fd1a6e72dbc0b","url":"https://github.com/apache/cxf"},{"original_method":"private List<WsdlOption> getWsdlOptionsFromDir(final File root,\n                                                   final File output)\n        throws MojoExecutionException {\n        List<WsdlOption> options = new ArrayList<WsdlOption>();\n        for (WsdlOption o : new WsdlOptionLoader().load(root, includes, excludes, defaultOptions)) {\n            if (o.getOutputDir() == null) {\n                o.setOutputDir(output);\n            }\n            if (!options.contains(o)) {\n                options.add(o);\n            }\n        }\n        return options;\n    }","id":60201,"modified_method":"/**\n     * Create WsdlOption objects for each wsdl file found in the root dir. includes, excludes filter which\n     * files are considered. The defaultOptions will be applied.\n     * \n     * @param root Base directory to search\n     * @param output\n     * @return\n     * @throws MojoExecutionException\n     */\n    private List<WsdlOption> getWsdlOptionsFromDir(final File root, final File output)\n        throws MojoExecutionException {\n        List<WsdlOption> options = new ArrayList<WsdlOption>();\n        for (WsdlOption o : new WsdlOptionLoader().load(root, includes, excludes, defaultOptions)) {\n            if (o.getOutputDir() == null) {\n                o.setOutputDir(output);\n            }\n            if (!options.contains(o)) {\n                options.add(o);\n            }\n        }\n        return options;\n    }","commit_id":"e293245c432c7e80edb4dae6267fd1a6e72dbc0b","url":"https://github.com/apache/cxf"},{"original_method":"public BaseRepositoryEditor(final Project project, final T repository, Consumer<T> changeListener) {\n    myRepository = repository;\n    myChangeListener = changeListener;\n\n    myTestButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        TaskManager.getManager(project).testConnection(repository);\n      }\n    });\n\n    myProxySettingsButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        HttpConfigurable.editConfigurable(myPanel);\n        enableButtons();\n      }\n    });\n\n    myURLText.setText(repository.getUrl());\n    myUserNameText.setText(repository.getUsername());\n    myPasswordText.setText(repository.getPassword());\n    myShareURL.setSelected(repository.isShared());\n    myUseProxy.setSelected(repository.isUseProxy());\n\n    myUseHTTPAuthentication.setSelected(repository.isUseHttpAuthentication());\n    myUseHTTPAuthentication.setVisible(repository.getRepositoryType().isSupported(TaskRepositoryType.BASIC_HTTP_AUTHORIZATION));\n\n    myAddCommitMessage.setSelected(repository.isShouldFormatCommitMessage());\n    myDocument = EditorFactory.getInstance().createDocument(repository.getCommitMessageFormat());\n    myEditor = EditorFactory.getInstance().createEditor(myDocument);\n    myEditorPanel.add(ScrollPaneFactory.createScrollPane(myEditor.getComponent(), SideBorder.NONE), BorderLayout.CENTER);\n    myComment.setText(\"Available placeholders: \" + repository.getComment());\n\n    installListener(myAddCommitMessage);\n    myDocument.addDocumentListener(new com.intellij.openapi.editor.event.DocumentAdapter() {\n      @Override\n      public void documentChanged(com.intellij.openapi.editor.event.DocumentEvent e) {\n        doApply();\n      }\n    });\n\n    installListener(myURLText);\n    installListener(myUserNameText);\n    installListener(myPasswordText);\n\n    installListener(myShareURL);\n    installListener(myUseProxy);\n    installListener(myUseHTTPAuthentication);\n\n    enableButtons();\n  }","id":60202,"modified_method":"public BaseRepositoryEditor(final Project project, final T repository, Consumer<T> changeListener) {\n    myRepository = repository;\n    myChangeListener = changeListener;\n\n    myTestButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        afterTestConnection(TaskManager.getManager(project).testConnection(repository));\n      }\n    });\n\n    myProxySettingsButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        HttpConfigurable.editConfigurable(myPanel);\n        enableButtons();\n      }\n    });\n\n    myURLText.setText(repository.getUrl());\n    myUserNameText.setText(repository.getUsername());\n    myPasswordText.setText(repository.getPassword());\n    myShareURL.setSelected(repository.isShared());\n    myUseProxy.setSelected(repository.isUseProxy());\n\n    myUseHTTPAuthentication.setSelected(repository.isUseHttpAuthentication());\n    myUseHTTPAuthentication.setVisible(repository.getRepositoryType().isSupported(TaskRepositoryType.BASIC_HTTP_AUTHORIZATION));\n\n    myAddCommitMessage.setSelected(repository.isShouldFormatCommitMessage());\n    myDocument = EditorFactory.getInstance().createDocument(repository.getCommitMessageFormat());\n    myEditor = EditorFactory.getInstance().createEditor(myDocument);\n    myEditorPanel.add(ScrollPaneFactory.createScrollPane(myEditor.getComponent(), SideBorder.NONE), BorderLayout.CENTER);\n    myComment.setText(\"Available placeholders: \" + repository.getComment());\n\n    installListener(myAddCommitMessage);\n    myDocument.addDocumentListener(new com.intellij.openapi.editor.event.DocumentAdapter() {\n      @Override\n      public void documentChanged(com.intellij.openapi.editor.event.DocumentEvent e) {\n        doApply();\n      }\n    });\n\n    installListener(myURLText);\n    installListener(myUserNameText);\n    installListener(myPasswordText);\n\n    installListener(myShareURL);\n    installListener(myUseProxy);\n    installListener(myUseHTTPAuthentication);\n\n    enableButtons();\n\n    JComponent customPanel = createCustomPanel();\n    if (customPanel != null) {\n      myCustomPanel.add(customPanel, BorderLayout.CENTER);\n    }\n\n    setAnchor(myUseProxy);\n  }","commit_id":"1872ff92871c4955812eb2d4fa0f39b5335b32db","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doApply() {\n    if (!myApplying) {\n      try {\n        myApplying = true;\n        apply();\n      }\n      finally {\n        myApplying = false;\n      }\n    }\n  }","id":60203,"modified_method":"protected void doApply() {\n    if (!myApplying) {\n      try {\n        myApplying = true;\n        apply();\n      }\n      finally {\n        myApplying = false;\n      }\n    }\n  }","commit_id":"1872ff92871c4955812eb2d4fa0f39b5335b32db","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GitHubRepositoryEditor(final Project project,\n                                final GitHubRepository repository,\n                                Consumer<GitHubRepository> changeListener) {\n    super(project, repository, changeListener);\n\n    myUrlLabel.setVisible(false);\n    myURLText.setVisible(false);\n\n    // project author, by default same as username\n    myRepoAuthor = new JTextField();\n    myRepoAuthor.setText(repository.getRepoAuthor());\n    installListener(myRepoAuthor);\n    myCustomPanel.add(myRepoAuthor, BorderLayout.NORTH);\n    myCustomLabel.add(new JLabel(\"Repository author:\", SwingConstants.RIGHT) {\n      @Override\n      public Dimension getPreferredSize() {\n        final Dimension oldSize = super.getPreferredSize();\n        final Dimension size = myRepoAuthor.getPreferredSize();\n        return new Dimension(oldSize.width, size.height);\n      }\n    }, BorderLayout.NORTH);\n\n    // project id\n    myRepoName = new JTextField();\n    myRepoName.setText(repository.getRepoName());\n    installListener(myRepoName);\n    myCustomPanel.add(myRepoName, BorderLayout.CENTER);\n    myCustomLabel.add(new JLabel(\"Repository:\", SwingConstants.RIGHT) {\n      @Override\n      public Dimension getPreferredSize() {\n        final Dimension oldSize = super.getPreferredSize();\n        final Dimension size = myRepoName.getPreferredSize();\n        return new Dimension(oldSize.width, size.height);\n      }\n    }, BorderLayout.CENTER);\n  }","id":60204,"modified_method":"public GitHubRepositoryEditor(final Project project,\n                                final GitHubRepository repository,\n                                Consumer<GitHubRepository> changeListener) {\n    super(project, repository, changeListener);\n\n    // project author, by default same as username\n    myRepoAuthor.setText(repository.getRepoAuthor());\n\n    // project id\n    myRepoName.setText(repository.getRepoName());\n\n    myUrlLabel.setVisible(false);\n    myURLText.setVisible(false);\n\n    setAnchor(myRepositoryAuthorLabel);\n  }","commit_id":"1872ff92871c4955812eb2d4fa0f39b5335b32db","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Dimension getPreferredSize() {\n    return myAnchor == null ? super.getPreferredSize() : myAnchor.getPreferredSize();\n  }","id":60205,"modified_method":"@Override\n  public Dimension getPreferredSize() {\n    return myAnchor == null || myAnchor == this ? super.getPreferredSize() : myAnchor.getPreferredSize();\n  }","commit_id":"1872ff92871c4955812eb2d4fa0f39b5335b32db","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Dimension getMinimumSize() {\n    return myAnchor == null ? super.getMinimumSize() : myAnchor.getMinimumSize();\n  }","id":60206,"modified_method":"@Override\n  public Dimension getMinimumSize() {\n    return myAnchor == null || myAnchor == this ? super.getMinimumSize() : myAnchor.getMinimumSize();\n  }","commit_id":"1872ff92871c4955812eb2d4fa0f39b5335b32db","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void setAnchor(@Nullable JComponent anchor) {\n    if (this != anchor) {\n      myAnchor = anchor;\n    }\n  }","id":60207,"modified_method":"@Override\n  public void setAnchor(@Nullable JComponent anchor) {\n    myAnchor = anchor;\n  }","commit_id":"1872ff92871c4955812eb2d4fa0f39b5335b32db","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public LighthouseRepositoryEditor(final Project project,\n                                    final LighthouseRepository repository,\n                                    Consumer<LighthouseRepository> changeListener) {\n    super(project, repository, changeListener);\n    myUserNameText.setVisible(false);\n    myUsernameLabel.setVisible(false);\n    myPasswordText.setVisible(false);\n    myPasswordLabel.setVisible(false);\n\n    myCustomLabel.add(new JLabel(\"Project ID:\", SwingConstants.RIGHT), BorderLayout.NORTH);\n\n    myProjectId = new JTextField();\n    myProjectId.setText(repository.getProjectId());\n    installListener(myProjectId);\n\n    myCustomPanel.add(myProjectId, BorderLayout.NORTH);\n\n    myCustomLabel.add(new JLabel(\"API Token:\", SwingConstants.RIGHT), BorderLayout.SOUTH);\n\n    myAPIKey = new JTextField();\n    myAPIKey.setText(repository.getAPIKey());\n    installListener(myAPIKey);\n\n    myCustomPanel.add(myAPIKey, BorderLayout.SOUTH);    \n  }","id":60208,"modified_method":"public LighthouseRepositoryEditor(final Project project,\n                                    final LighthouseRepository repository,\n                                    Consumer<LighthouseRepository> changeListener) {\n    super(project, repository, changeListener);\n    myUserNameText.setVisible(false);\n    myUsernameLabel.setVisible(false);\n    myPasswordText.setVisible(false);\n    myPasswordLabel.setVisible(false);\n\n    myProjectId.setText(repository.getProjectId());\n    myAPIKey.setText(repository.getAPIKey());\n  }","commit_id":"1872ff92871c4955812eb2d4fa0f39b5335b32db","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private MantisRepository(BaseRepository other) {\n    super(other);\n  }","id":60209,"modified_method":"private MantisRepository(MantisRepository other) {\n    super(other);\n    myProject = other.getProject();\n    myFilter = other.getFilter();\n  }","commit_id":"1872ff92871c4955812eb2d4fa0f39b5335b32db","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Task createIssue(IssueData data) {\n    return new LocalTaskImpl(data.getId().toString(), data.getSummary()) {\n      @Override\n      public TaskRepository getRepository() {\n        return MantisRepository.this;\n      }\n    };\n  }","id":60210,"modified_method":"@Nullable\n  private Task createIssue(final IssueData data) throws Exception {\n    String id = String.valueOf(data.getId());\n    if (id == null) return null;\n    String summary = data.getSummary();\n    if (summary == null) return null;\n    LocalTaskImpl task = new MantisTask(id, summary, ContainerUtil.find(getProjects(), new Condition<MantisProject>() {\n      @Override\n      public boolean value(final MantisProject project) {\n        return project.getId() == data.getId().intValue();\n      }\n    }), this) {\n      @Override\n      public String getDescription() {\n        return data.getDescription();\n      }\n    };\n\n    task.setUpdated(data.getLast_updated().getTime());\n    task.setCreated(data.getDate_submitted().getTime());\n    return task;\n  }","commit_id":"1872ff92871c4955812eb2d4fa0f39b5335b32db","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Task[] getIssues(String request, int max, long since) throws Exception {\n    MantisConnectPortType soap = createSoap();\n    IssueData[] datas =\n      soap.mc_filter_get_issues(getUsername(), getPassword(), BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO, BigInteger.valueOf(50));\n    return ContainerUtil.map2Array(datas, Task.class, new Function<IssueData, Task>() {\n      public Task fun(IssueData issueData) {\n        return createIssue(issueData);\n      }\n    });\n  }","id":60211,"modified_method":"@Override\n  public Task[] getIssues(String request, int max, long since) throws Exception {\n    MantisConnectPortType soap = createSoap();\n    try {\n      IssueData[] issues;\n      if (myFilter == MantisFilter.LAST_TASKS) {\n        issues = soap.mc_project_get_issues(getUsername(), getPassword(), BigInteger.valueOf(myProject.getId()), BigInteger.ZERO,\n                                            BigInteger.valueOf(max));\n      }\n      else {\n        issues = soap.mc_filter_get_issues(getUsername(), getPassword(), BigInteger.valueOf(myProject.getId()),\n                                           BigInteger.valueOf(myFilter.getId()), BigInteger.ZERO, BigInteger.valueOf(max));\n      }\n      final List<Task> filteredTasks =\n        TaskSearchSupport.filterTasks(request == null ? \"\" : request, ContainerUtil.mapNotNull(issues, new NullableFunction<IssueData, Task>() {\n          public Task fun(IssueData issueData) {\n            try {\n              return createIssue(issueData);\n            }\n            catch (Exception e) {\n              return null;\n            }\n          }\n        }));\n      return filteredTasks.toArray(new Task[filteredTasks.size()]);\n    }\n    catch (Exception e) {\n      IssueHeaderData[] issues;\n      if (myFilter == MantisFilter.LAST_TASKS) {\n        issues = soap.mc_project_get_issue_headers(getUsername(), getPassword(), BigInteger.valueOf(myProject.getId()), BigInteger.ZERO,\n                                                   BigInteger.valueOf(max));\n      }\n      else {\n        issues = soap.mc_filter_get_issue_headers(getUsername(), getPassword(), BigInteger.valueOf(myProject.getId()),\n                                                  BigInteger.valueOf(myFilter.getId()), BigInteger.ZERO, BigInteger.valueOf(max));\n      }\n      final List<Task> filteredTasks =\n        TaskSearchSupport.filterTasks(request == null ? \"\" : request, ContainerUtil.mapNotNull(issues, new NullableFunction<IssueHeaderData, Task>() {\n          public Task fun(IssueHeaderData issueHeaderData) {\n            try {\n              return createIssue(issueHeaderData);\n            }\n            catch (Exception e) {\n              return null;\n            }\n          }\n        }));\n      return filteredTasks.toArray(new Task[filteredTasks.size()]);\n    }\n  }","commit_id":"1872ff92871c4955812eb2d4fa0f39b5335b32db","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private synchronized MantisConnectPortType createSoap() throws ServiceException, MalformedURLException {\n//    FileProvider provider = new FileProvider(getClass().getResourceAsStream(\"/com/intellij/tasks/mantis/client-config.wsdd\"));\n    MantisConnectLocator locator = new MantisConnectLocator();\n    return locator.getMantisConnectPort(new URL(getUrl()));\n  }","id":60212,"modified_method":"private synchronized MantisConnectPortType createSoap() throws ServiceException, MalformedURLException {\n    return new MantisConnectLocator().getMantisConnectPort(new URL(getUrl() + SOAP_API_LOCATION));\n  }","commit_id":"1872ff92871c4955812eb2d4fa0f39b5335b32db","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Task findTask(String id) throws Exception {\n    IssueData data = createSoap().mc_issue_get(getUsername(), getPassword(), BigInteger.valueOf(0));\n    return data == null ? null : createIssue(data);\n  }","id":60213,"modified_method":"@Override\n  public Task findTask(String id) throws Exception {\n    IssueData data = createSoap().mc_issue_get(getUsername(), getPassword(), BigInteger.valueOf(Integer.valueOf(id)));\n    return data == null ? null : createIssue(data);\n  }","commit_id":"1872ff92871c4955812eb2d4fa0f39b5335b32db","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PivotalTrackerRepositoryEditor(final Project project,\n                                    final PivotalTrackerRepository repository,\n                                    Consumer<PivotalTrackerRepository> changeListener) {\n    super(project, repository, changeListener);\n\n    // project id\n    myProjectId = new JTextField();\n    myProjectId.setText(repository.getProjectId());\n    installListener(myProjectId);\n    myCustomPanel.add(myProjectId, BorderLayout.NORTH);\n    myCustomLabel.add(new JLabel(\"Project ID:\", SwingConstants.RIGHT) {\n      @Override\n      public Dimension getPreferredSize() {\n        final Dimension oldSize = super.getPreferredSize();\n        final Dimension size = myProjectId.getPreferredSize();\n        return new Dimension(oldSize.width, size.height);\n      }\n    }, BorderLayout.NORTH);\n\n    // api key\n    myAPIKey = new JTextField();\n    myAPIKey.setText(repository.getAPIKey());\n    installListener(myAPIKey);\n    myCustomPanel.add(myAPIKey, BorderLayout.CENTER);\n    myCustomLabel.add(new JLabel(\"API Token:\", SwingConstants.RIGHT) {\n      @Override\n      public Dimension getPreferredSize() {\n        final Dimension oldSize = super.getPreferredSize();\n        final Dimension size = myAPIKey.getPreferredSize();\n        return new Dimension(oldSize.width, size.height);\n      }\n    }, BorderLayout.CENTER);\n\n    myUsernameLabel.setVisible(false);\n    myUserNameText.setVisible(false);\n    myPasswordLabel.setVisible(false);\n    myPasswordText.setVisible(false);\n    myUseHTTPAuthentication.setVisible(false);\n  }","id":60214,"modified_method":"public PivotalTrackerRepositoryEditor(final Project project,\n                                    final PivotalTrackerRepository repository,\n                                    Consumer<PivotalTrackerRepository> changeListener) {\n    super(project, repository, changeListener);\n    myUserNameText.setVisible(false);\n    myUsernameLabel.setVisible(false);\n    myPasswordText.setVisible(false);\n    myPasswordLabel.setVisible(false);\n\n    myProjectId.setText(repository.getProjectId());\n    myAPIKey.setText(repository.getAPIKey());\n    myUseHTTPAuthentication.setVisible(false);\n  }","commit_id":"1872ff92871c4955812eb2d4fa0f39b5335b32db","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public RedmineRepositoryEditor(final Project project, final RedmineRepository repository, Consumer<RedmineRepository> changeListener) {\n    super(project, repository, changeListener);\n\n    // project id\n    myProjectId = new JTextField();\n    myProjectId.setText(repository.getProjectId());\n    installListener(myProjectId);\n    myCustomPanel.add(myProjectId, BorderLayout.NORTH);\n    myCustomLabel.add(new JLabel(\"Project ID:\", SwingConstants.RIGHT) {\n      @Override\n      public Dimension getPreferredSize() {\n        final Dimension oldSize = super.getPreferredSize();\n        final Dimension size = myProjectId.getPreferredSize();\n        return new Dimension(oldSize.width, size.height);\n      }\n    }, BorderLayout.NORTH);\n\n    // api key\n    myAPIKey = new JTextField();\n    myAPIKey.setText(repository.getAPIKey());\n    installListener(myAPIKey);\n    myCustomPanel.add(myAPIKey, BorderLayout.CENTER);\n    myCustomLabel.add(new JLabel(\"API Token:\", SwingConstants.RIGHT) {\n      @Override\n      public Dimension getPreferredSize() {\n        final Dimension oldSize = super.getPreferredSize();\n        final Dimension size = myAPIKey.getPreferredSize();\n        return new Dimension(oldSize.width, size.height);\n      }\n    }, BorderLayout.CENTER);\n  }","id":60215,"modified_method":"public RedmineRepositoryEditor(final Project project, final RedmineRepository repository, Consumer<RedmineRepository> changeListener) {\n    super(project, repository, changeListener);\n    myProjectId.setText(repository.getProjectId());\n    myAPIKey.setText(repository.getAPIKey());\n  }","commit_id":"1872ff92871c4955812eb2d4fa0f39b5335b32db","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public List<Task> getLocalAndCachedTasks(String pattern) {\n    List<Task> tasks = new ArrayList<Task>();\n      ContainerUtil.addAll(tasks, myManager.getLocalTasks());\n      ContainerUtil.addAll(tasks, ContainerUtil.filter(myManager.getCachedIssues(), new Condition<Task>() {\n        @Override\n        public boolean value(final Task task) {\n          return myManager.findTask(task.getId()) == null;\n        }\n      }));\n    final Matcher matcher = getMatcher(pattern);\n    List<Task> filteredTasks = ContainerUtil.mapNotNull(tasks, new NullableFunction<Task, Task>() {\n      public Task fun(Task task) {\n        return matcher.matches(task.getId()) || matcher.matches(task.getSummary()) ? task : null;\n      }\n    });\n    ContainerUtil.sort(filteredTasks, TaskManagerImpl.TASK_UPDATE_COMPARATOR);\n    return filteredTasks;\n  }","id":60216,"modified_method":"public List<Task> getLocalAndCachedTasks(String pattern) {\n    List<Task> tasks = new ArrayList<Task>();\n    ContainerUtil.addAll(tasks, myManager.getLocalTasks());\n    ContainerUtil.addAll(tasks, ContainerUtil.filter(myManager.getCachedIssues(), new Condition<Task>() {\n      @Override\n      public boolean value(final Task task) {\n        return myManager.findTask(task.getId()) == null;\n      }\n    }));\n    List<Task> filteredTasks = filterTasks(pattern, tasks);\n    ContainerUtil.sort(filteredTasks, TaskManagerImpl.TASK_UPDATE_COMPARATOR);\n    return filteredTasks;\n  }","commit_id":"1872ff92871c4955812eb2d4fa0f39b5335b32db","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Matcher getMatcher(String pattern) {\n    if (myMatcher == null) {\n      StringTokenizer tokenizer = new StringTokenizer(pattern, \" \");\n      StringBuilder builder = new StringBuilder();\n      while (tokenizer.hasMoreTokens()) {\n        String word = tokenizer.nextToken();\n        builder.append('*');\n        builder.append(word);\n        builder.append(\"* \");\n      }\n\n      myMatcher = NameUtil.buildMatcher(builder.toString(), 0, true, true, pattern.toLowerCase().equals(pattern));\n    }\n    return myMatcher;\n  }","id":60217,"modified_method":"private static Matcher getMatcher(String pattern) {\n    StringTokenizer tokenizer = new StringTokenizer(pattern, \" \");\n    StringBuilder builder = new StringBuilder();\n    while (tokenizer.hasMoreTokens()) {\n      String word = tokenizer.nextToken();\n      builder.append('*');\n      builder.append(word);\n      builder.append(\"* \");\n    }\n\n    return NameUtil.buildMatcher(builder.toString(), 0, true, true, pattern.toLowerCase().equals(pattern));\n  }","commit_id":"1872ff92871c4955812eb2d4fa0f39b5335b32db","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TracRepositoryEditor(final Project project, final TracRepository repository, Consumer<TracRepository> changeListener) {\n    super(project, repository, changeListener);\n\n    myCustomLabel.add(new JLabel(\"Search:\", SwingConstants.RIGHT));\n\n    myDefaultSearch = new JTextField();\n    myDefaultSearch.setText(repository.getDefaultSearch());\n    installListener(myDefaultSearch);\n\n    myCustomPanel.add(myDefaultSearch);\n  }","id":60218,"modified_method":"public TracRepositoryEditor(final Project project, final TracRepository repository, Consumer<TracRepository> changeListener) {\n    super(project, repository, changeListener);\n    myDefaultSearch.setText(repository.getDefaultSearch());\n  }","commit_id":"1872ff92871c4955812eb2d4fa0f39b5335b32db","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public YouTrackRepositoryEditor(final Project project, final YouTrackRepository repository, Consumer<YouTrackRepository> changeListener) {\n    super(project, repository, changeListener);\n\n    myCustomLabel.add(new JLabel(\"Search:\", SwingConstants.RIGHT));\n\n    myDefaultSearch = new JTextField();\n    myDefaultSearch.setText(repository.getDefaultSearch());\n    installListener(myDefaultSearch);\n\n    myCustomPanel.add(myDefaultSearch);\n  }","id":60219,"modified_method":"public YouTrackRepositoryEditor(final Project project, final YouTrackRepository repository, Consumer<YouTrackRepository> changeListener) {\n    super(project, repository, changeListener);\n    myDefaultSearch.setText(repository.getDefaultSearch());\n  }","commit_id":"1872ff92871c4955812eb2d4fa0f39b5335b32db","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * the f-measure if we just guess as negativ the first numleft and guess as poitive the last numright\n   *\n   */\n  public double fmeasure(int numleft, int numright) {\n    int tp = 0, fp = 0, fn = 0;\n    tp = numpositive[numright];\n    fp = numright - tp;\n    fn = numleft - numnegative[numleft];\n    return f1(tp, fp, fn);\n  }","id":60220,"modified_method":"/**\n   * the f-measure if we just guess as negative the first numleft and guess as positive the last numright\n   *\n   */\n  public double fmeasure(int numleft, int numright) {\n    int tp = numpositive[numright];\n    int fp = numright - tp;\n    int fn = numleft - numnegative[numleft];\n    return f1(tp, fp, fn);\n  }","commit_id":"4d08ad4598d60425470b8006ff267096c957e06f","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * reads scores with classes from a file, sorts by score and creates the arrays\n   *\n   */\n  public PRCurve(String filename) {\n    try {\n      ArrayList<Pair<Double, Integer>> dataScores = new ArrayList<Pair<Double, Integer>>();\n      for(String line : ObjectBank.getLineIterator(new File(filename))) {\n        List<String> elems = StringUtils.split(line);\n        Pair<Double, Integer> p = new Pair<Double, Integer>(new Double(elems.get(0).toString()), Integer.valueOf(elems.get(1).toString()));\n        dataScores.add(p);\n      }\n      init(dataScores);\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n\n  }","id":60221,"modified_method":"/**\n   * reads scores with classes from a file, sorts by score and creates the arrays\n   *\n   */\n  public PRCurve(String filename) {\n    try {\n      ArrayList<Pair<Double, Integer>> dataScores = new ArrayList<Pair<Double, Integer>>();\n      for(String line : ObjectBank.getLineIterator(new File(filename))) {\n        List<String> elems = StringUtils.split(line);\n        Pair<Double, Integer> p = new Pair<Double, Integer>(Double.valueOf(elems.get(0)), Integer.valueOf(elems.get(1)));\n        dataScores.add(p);\n      }\n      init(dataScores);\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n\n  }","commit_id":"4d08ad4598d60425470b8006ff267096c957e06f","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * reads scores with classes from a file, sorts by score and creates the arrays\n   *\n   */\n  public PRCurve(String filename, boolean svm) {\n    try {\n\n      ArrayList<Pair<Double, Integer>> dataScores = new ArrayList<Pair<Double, Integer>>();\n      for(String line : ObjectBank.getLineIterator(new File(filename))) {\n        List<String> elems = StringUtils.split(line);\n        int cls = (new Double(elems.get(0).toString())).intValue();\n        if (cls == -1) {\n          cls = 0;\n        }\n        double score = Double.parseDouble(elems.get(1).toString()) + 0.5;\n        Pair<Double, Integer> p = new Pair<Double, Integer>(new Double(score), Integer.valueOf(cls));\n        dataScores.add(p);\n      }\n      init(dataScores);\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n\n  }","id":60222,"modified_method":"/**\n   * reads scores with classes from a file, sorts by score and creates the arrays\n   *\n   */\n  public PRCurve(String filename, boolean svm) {\n    try {\n\n      ArrayList<Pair<Double, Integer>> dataScores = new ArrayList<Pair<Double, Integer>>();\n      for(String line : ObjectBank.getLineIterator(new File(filename))) {\n        List<String> elems = StringUtils.split(line);\n        int cls = Double.valueOf(elems.get(0)).intValue();\n        if (cls == -1) {\n          cls = 0;\n        }\n        double score = Double.valueOf(elems.get(1)) + 0.5;\n        Pair<Double, Integer> p = new Pair<Double, Integer>(new Double(score), Integer.valueOf(cls));\n        dataScores.add(p);\n      }\n      init(dataScores);\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n\n  }","commit_id":"4d08ad4598d60425470b8006ff267096c957e06f","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public Document nextDoc() throws Exception {\n    List<List<CoreLabel>> allWords = new ArrayList<List<CoreLabel>>();\n    List<Tree> allTrees = new ArrayList<Tree>();\n\n    CoNLL2011DocumentReader.Document conllDoc = reader.getNextDocument();\n    if (conllDoc == null) {\n      return null;\n    }\n\n    Annotation anno = conllDoc.getAnnotation();\n    List<CoreMap> sentences = anno.get(CoreAnnotations.SentencesAnnotation.class);\n    for (CoreMap sentence:sentences) {\n      if (!Constants.USE_GOLD_PARSES && !replicateCoNLL) {\n        // Remove tree from annotation and replace with parse using stanford parser\n        sentence.remove(TreeCoreAnnotations.TreeAnnotation.class);\n      } else {\n        Tree tree = sentence.get(TreeCoreAnnotations.TreeAnnotation.class);\n        // generate the dependency graph\n        try {\n          SemanticGraph deps = SemanticGraphFactory.makeFromTree(tree,\n              collapse, ccProcess, includeExtras, lemmatize, threadSafe);\n          SemanticGraph basicDeps = SemanticGraphFactory.makeFromTree(tree,\n              !collapse, ccProcess, includeExtras, lemmatize, threadSafe);\n          sentence.set(SemanticGraphCoreAnnotations.BasicDependenciesAnnotation.class, basicDeps);\n          sentence.set(SemanticGraphCoreAnnotations.CollapsedDependenciesAnnotation.class, deps);\n        } catch(Exception e) {\n          logger.log(Level.WARNING, \"Exception caught during extraction of Stanford dependencies. Will ignore and continue...\", e);\n        }\n      }\n    }\n\n    String preSpeaker = null;\n    String curSpeaker = null;\n    int utterance = -1;\n    for (CoreLabel token:anno.get(CoreAnnotations.TokensAnnotation.class)) {\n      if (!token.containsKey(CoreAnnotations.SpeakerAnnotation.class))  {\n        token.set(CoreAnnotations.SpeakerAnnotation.class, \"\");\n      }\n      curSpeaker = token.get(CoreAnnotations.SpeakerAnnotation.class);\n      if(!curSpeaker.equals(preSpeaker)) {\n        utterance++;\n        preSpeaker = curSpeaker;\n      }\n      token.set(CoreAnnotations.UtteranceAnnotation.class, utterance);\n    }\n\n    // Run pipeline\n    stanfordProcessor.annotate(anno);\n\n    for (CoreMap sentence:anno.get(CoreAnnotations.SentencesAnnotation.class)) {\n      allWords.add(sentence.get(CoreAnnotations.TokensAnnotation.class));\n      allTrees.add(sentence.get(TreeCoreAnnotations.TreeAnnotation.class));\n    }\n\n    // Initialize gold mentions\n    List<List<Mention>> allGoldMentions = extractGoldMentions(conllDoc);\n\n    List<List<Mention>> allPredictedMentions;\n    if (Constants.USE_GOLD_MENTIONS) {\n      //allPredictedMentions = allGoldMentions;\n      // Make copy of gold mentions since mentions may be later merged, mentionID's changed and stuff\n      allPredictedMentions = makeCopy(allGoldMentions);\n    } else if (Constants.USE_GOLD_MENTION_BOUNDARIES) {\n      allPredictedMentions = ((RuleBasedCorefMentionFinder) mentionFinder).filterPredictedMentions(allGoldMentions, anno, dictionaries);\n    } else {\n      allPredictedMentions = mentionFinder.extractPredictedMentions(anno, maxID, dictionaries);\n    }\n\n    try {\n      recallErrors(allGoldMentions,allPredictedMentions,anno);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    Document doc = arrange(anno, allWords, allTrees, allPredictedMentions, allGoldMentions, true);\n    doc.conllDoc = conllDoc;\n    return doc;\n  }","id":60223,"modified_method":"@Override\n  public Document nextDoc() throws Exception {\n    List<List<CoreLabel>> allWords = new ArrayList<List<CoreLabel>>();\n    List<Tree> allTrees = new ArrayList<Tree>();\n\n    CoNLL2011DocumentReader.Document conllDoc = reader.getNextDocument();\n    if (conllDoc == null) {\n      return null;\n    }\n\n    Annotation anno = conllDoc.getAnnotation();\n    List<CoreMap> sentences = anno.get(CoreAnnotations.SentencesAnnotation.class);\n    for (CoreMap sentence:sentences) {\n      if (!Constants.USE_GOLD_PARSES && !replicateCoNLL) {\n        // Remove tree from annotation and replace with parse using stanford parser\n        sentence.remove(TreeCoreAnnotations.TreeAnnotation.class);\n      } else {\n        Tree tree = sentence.get(TreeCoreAnnotations.TreeAnnotation.class);\n        // generate the dependency graph\n        try {\n          SemanticGraph deps = SemanticGraphFactory.makeFromTree(tree,\n              collapse, ccProcess, includeExtras, lemmatize, threadSafe);\n          SemanticGraph basicDeps = SemanticGraphFactory.makeFromTree(tree,\n              !collapse, ccProcess, includeExtras, lemmatize, threadSafe);\n          sentence.set(SemanticGraphCoreAnnotations.BasicDependenciesAnnotation.class, basicDeps);\n          sentence.set(SemanticGraphCoreAnnotations.CollapsedDependenciesAnnotation.class, deps);\n        } catch(Exception e) {\n          logger.log(Level.WARNING, \"Exception caught during extraction of Stanford dependencies. Will ignore and continue...\", e);\n        }\n      }\n    }\n\n    String preSpeaker = null;\n    int utterance = -1;\n    for (CoreLabel token:anno.get(CoreAnnotations.TokensAnnotation.class)) {\n      if (!token.containsKey(CoreAnnotations.SpeakerAnnotation.class))  {\n        token.set(CoreAnnotations.SpeakerAnnotation.class, \"\");\n      }\n      String curSpeaker = token.get(CoreAnnotations.SpeakerAnnotation.class);\n      if (!curSpeaker.equals(preSpeaker)) {\n        utterance++;\n        preSpeaker = curSpeaker;\n      }\n      token.set(CoreAnnotations.UtteranceAnnotation.class, utterance);\n    }\n\n    // Run pipeline\n    stanfordProcessor.annotate(anno);\n\n    for (CoreMap sentence:anno.get(CoreAnnotations.SentencesAnnotation.class)) {\n      allWords.add(sentence.get(CoreAnnotations.TokensAnnotation.class));\n      allTrees.add(sentence.get(TreeCoreAnnotations.TreeAnnotation.class));\n    }\n\n    // Initialize gold mentions\n    List<List<Mention>> allGoldMentions = extractGoldMentions(conllDoc);\n\n    List<List<Mention>> allPredictedMentions;\n    if (Constants.USE_GOLD_MENTIONS) {\n      //allPredictedMentions = allGoldMentions;\n      // Make copy of gold mentions since mentions may be later merged, mentionID's changed and stuff\n      allPredictedMentions = makeCopy(allGoldMentions);\n    } else if (Constants.USE_GOLD_MENTION_BOUNDARIES) {\n      allPredictedMentions = ((RuleBasedCorefMentionFinder) mentionFinder).filterPredictedMentions(allGoldMentions, anno, dictionaries);\n    } else {\n      allPredictedMentions = mentionFinder.extractPredictedMentions(anno, maxID, dictionaries);\n    }\n\n    try {\n      recallErrors(allGoldMentions,allPredictedMentions,anno);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    Document doc = arrange(anno, allWords, allTrees, allPredictedMentions, allGoldMentions, true);\n    doc.conllDoc = conllDoc;\n    return doc;\n  }","commit_id":"a8d28ec8db46dc2486c32e4e37252df5317750d2","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * the f-measure if we just guess as negativ the first numleft and guess as poitive the last numright\n   *\n   */\n  public double fmeasure(int numleft, int numright) {\n    int tp = 0, fp = 0, fn = 0;\n    tp = numpositive[numright];\n    fp = numright - tp;\n    fn = numleft - numnegative[numleft];\n    return f1(tp, fp, fn);\n  }","id":60224,"modified_method":"/**\n   * the f-measure if we just guess as negative the first numleft and guess as positive the last numright\n   *\n   */\n  public double fmeasure(int numleft, int numright) {\n    int tp = numpositive[numright];\n    int fp = numright - tp;\n    int fn = numleft - numnegative[numleft];\n    return f1(tp, fp, fn);\n  }","commit_id":"a8d28ec8db46dc2486c32e4e37252df5317750d2","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * reads scores with classes from a file, sorts by score and creates the arrays\n   *\n   */\n  public PRCurve(String filename) {\n    try {\n      ArrayList<Pair<Double, Integer>> dataScores = new ArrayList<Pair<Double, Integer>>();\n      for(String line : ObjectBank.getLineIterator(new File(filename))) {\n        List<String> elems = StringUtils.split(line);\n        Pair<Double, Integer> p = new Pair<Double, Integer>(new Double(elems.get(0).toString()), Integer.valueOf(elems.get(1).toString()));\n        dataScores.add(p);\n      }\n      init(dataScores);\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n\n  }","id":60225,"modified_method":"/**\n   * reads scores with classes from a file, sorts by score and creates the arrays\n   *\n   */\n  public PRCurve(String filename) {\n    try {\n      ArrayList<Pair<Double, Integer>> dataScores = new ArrayList<Pair<Double, Integer>>();\n      for(String line : ObjectBank.getLineIterator(new File(filename))) {\n        List<String> elems = StringUtils.split(line);\n        Pair<Double, Integer> p = new Pair<Double, Integer>(Double.valueOf(elems.get(0)), Integer.valueOf(elems.get(1)));\n        dataScores.add(p);\n      }\n      init(dataScores);\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n\n  }","commit_id":"a8d28ec8db46dc2486c32e4e37252df5317750d2","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * reads scores with classes from a file, sorts by score and creates the arrays\n   *\n   */\n  public PRCurve(String filename, boolean svm) {\n    try {\n\n      ArrayList<Pair<Double, Integer>> dataScores = new ArrayList<Pair<Double, Integer>>();\n      for(String line : ObjectBank.getLineIterator(new File(filename))) {\n        List<String> elems = StringUtils.split(line);\n        int cls = (new Double(elems.get(0).toString())).intValue();\n        if (cls == -1) {\n          cls = 0;\n        }\n        double score = Double.parseDouble(elems.get(1).toString()) + 0.5;\n        Pair<Double, Integer> p = new Pair<Double, Integer>(new Double(score), Integer.valueOf(cls));\n        dataScores.add(p);\n      }\n      init(dataScores);\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n\n  }","id":60226,"modified_method":"/**\n   * reads scores with classes from a file, sorts by score and creates the arrays\n   *\n   */\n  public PRCurve(String filename, boolean svm) {\n    try {\n\n      ArrayList<Pair<Double, Integer>> dataScores = new ArrayList<Pair<Double, Integer>>();\n      for(String line : ObjectBank.getLineIterator(new File(filename))) {\n        List<String> elems = StringUtils.split(line);\n        int cls = Double.valueOf(elems.get(0)).intValue();\n        if (cls == -1) {\n          cls = 0;\n        }\n        double score = Double.valueOf(elems.get(1)) + 0.5;\n        Pair<Double, Integer> p = new Pair<Double, Integer>(new Double(score), Integer.valueOf(cls));\n        dataScores.add(p);\n      }\n      init(dataScores);\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n\n  }","commit_id":"a8d28ec8db46dc2486c32e4e37252df5317750d2","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public boolean getCheckGuest() {\n\t\treturn this.checkGuest;\n\t}","id":60227,"modified_method":"public boolean isCheckGuest() {\n\t\treturn checkGuest;\n\t}","commit_id":"52b19cec3cca0b3806bff393cc6960288183347b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getRedirect(\n\t\t\tThemeDisplay themeDisplay, List<Layout> layouts, long groupId,\n\t\t\tString privateLayoutParam)\n\t\tthrows Exception {\n\n\t\tString redirect = null;\n\n\t\tif (layouts.size() > 0) {\n\t\t\tPermissionChecker permissionChecker =\n\t\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\t\tboolean currentLayoutCheckGuest = permissionChecker.getCheckGuest();\n\n\t\t\tfor (Layout layout : layouts) {\n\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\tpermissionChecker.setCheckGuest(false);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpermissionChecker.setCheckGuest(true);\n\t\t\t\t}\n\n\t\t\t\tif (!layout.isHidden() &&\n\t\t\t\t\tLayoutPermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, layout, ActionKeys.VIEW)) {\n\n\t\t\t\t\tredirect = PortalUtil.getLayoutURL(layout, themeDisplay);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpermissionChecker.setCheckGuest(currentLayoutCheckGuest);\n\t\t}\n\n\t\tif (Validator.isNull(redirect)) {\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\t\tredirect = PortalUtil.getGroupFriendlyURL(\n\t\t\t\tgroup, GetterUtil.getBoolean(privateLayoutParam), themeDisplay);\n\t\t}\n\n\t\treturn redirect;\n\t}","id":60228,"modified_method":"protected String getRedirect(\n\t\t\tThemeDisplay themeDisplay, List<Layout> layouts, long groupId,\n\t\t\tString privateLayoutParam)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tboolean checkGuest = permissionChecker.isCheckGuest();\n\n\t\ttry {\n\t\t\tfor (Layout layout : layouts) {\n\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\tpermissionChecker.setCheckGuest(false);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpermissionChecker.setCheckGuest(true);\n\t\t\t\t}\n\n\t\t\t\tif (!layout.isHidden() &&\n\t\t\t\t\tLayoutPermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, layout, ActionKeys.VIEW)) {\n\n\t\t\t\t\treturn PortalUtil.getLayoutURL(layout, themeDisplay);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tpermissionChecker.setCheckGuest(checkGuest);\n\t\t}\n\n\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\treturn PortalUtil.getGroupFriendlyURL(\n\t\t\tgroup, GetterUtil.getBoolean(privateLayoutParam), themeDisplay);\n\t}","commit_id":"52b19cec3cca0b3806bff393cc6960288183347b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getRedirect(\n\t\t\tThemeDisplay themeDisplay, List<Layout> layouts, long groupId,\n\t\t\tString privateLayoutParam)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tfor (Layout layout : layouts) {\n\t\t\tif (!layout.isHidden() &&\n\t\t\t\tLayoutPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, layout, ActionKeys.VIEW)) {\n\n\t\t\t\treturn PortalUtil.getCanonicalURL(\n\t\t\t\t\tnull, themeDisplay, layout, true);\n\t\t\t}\n\t\t}\n\n\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\treturn PortalUtil.getGroupFriendlyURL(\n\t\t\tgroup, GetterUtil.getBoolean(privateLayoutParam), themeDisplay);\n\t}","id":60229,"modified_method":"protected String getRedirect(\n\t\t\tThemeDisplay themeDisplay, List<Layout> layouts, long groupId,\n\t\t\tString privateLayoutParam)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tfor (Layout layout : layouts) {\n\t\t\tif (!layout.isHidden() &&\n\t\t\t\tLayoutPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, layout, ActionKeys.VIEW)) {\n\n\t\t\t\tString canonicalURL = PortalUtil.getCanonicalURL(\n\t\t\t\t\tnull, themeDisplay, layout, true);\n\n\t\t\t\tif (Validator.isNotNull(themeDisplay.getDoAsUserId())) {\n\t\t\t\t\tcanonicalURL = HttpUtil.setParameter(\n\t\t\t\t\t\tcanonicalURL, \"doAsUserId\",\n\t\t\t\t\t\tthemeDisplay.getDoAsUserId());\n\t\t\t\t}\n\n\t\t\t\treturn canonicalURL;\n\t\t\t}\n\t\t}\n\n\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\tString groupFriendlyURL = PortalUtil.getGroupFriendlyURL(\n\t\t\tgroup, GetterUtil.getBoolean(privateLayoutParam), themeDisplay);\n\n\t\tif (Validator.isNotNull(themeDisplay.getDoAsUserId())) {\n\t\t\tgroupFriendlyURL = HttpUtil.setParameter(\n\t\t\t\tgroupFriendlyURL, \"doAsUserId\", themeDisplay.getDoAsUserId());\n\t\t}\n\n\t\treturn groupFriendlyURL;\n\t}","commit_id":"8d0b8b3c0cf5f778d4a8a1b6ea27ccedcb8fdb1b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getRedirect(\n\t\t\tThemeDisplay themeDisplay, List<Layout> layouts, long groupId,\n\t\t\tString privateLayoutParam)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tfor (Layout layout : layouts) {\n\t\t\tif (!layout.isHidden() &&\n\t\t\t\tLayoutPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, layout, ActionKeys.VIEW)) {\n\n\t\t\t\tString canonicalURL = PortalUtil.getCanonicalURL(\n\t\t\t\t\tnull, themeDisplay, layout, true);\n\n\t\t\t\tif (Validator.isNotNull(themeDisplay.getDoAsUserId())) {\n\t\t\t\t\tcanonicalURL = HttpUtil.setParameter(\n\t\t\t\t\t\tcanonicalURL, \"doAsUserId\",\n\t\t\t\t\t\tthemeDisplay.getDoAsUserId());\n\t\t\t\t}\n\n\t\t\t\treturn canonicalURL;\n\t\t\t}\n\t\t}\n\n\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\tString groupFriendlyURL = PortalUtil.getGroupFriendlyURL(\n\t\t\tgroup, GetterUtil.getBoolean(privateLayoutParam), themeDisplay);\n\n\t\tif (Validator.isNotNull(themeDisplay.getDoAsUserId())) {\n\t\t\tgroupFriendlyURL = HttpUtil.setParameter(\n\t\t\t\tgroupFriendlyURL, \"doAsUserId\", themeDisplay.getDoAsUserId());\n\t\t}\n\n\t\treturn groupFriendlyURL;\n\t}","id":60230,"modified_method":"protected String getRedirect(\n\t\t\tThemeDisplay themeDisplay, List<Layout> layouts, long groupId,\n\t\t\tString privateLayoutParam)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tfor (Layout layout : layouts) {\n\t\t\tif (!layout.isHidden() &&\n\t\t\t\tLayoutPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, layout, ActionKeys.VIEW)) {\n\n\t\t\t\treturn PortalUtil.getCanonicalURL(\n\t\t\t\t\tnull, themeDisplay, layout, true);\n\t\t\t}\n\t\t}\n\n\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\treturn PortalUtil.getGroupFriendlyURL(\n\t\t\tgroup, GetterUtil.getBoolean(privateLayoutParam), themeDisplay);\n\t}","commit_id":"74ea66bfd91a1b2257024edc493a7b1cb74da0af","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getRedirect(\n\t\t\tThemeDisplay themeDisplay, List<Layout> layouts, long groupId,\n\t\t\tString privateLayoutParam)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tfor (Layout layout : layouts) {\n\t\t\tif (!layout.isHidden() &&\n\t\t\t\tLayoutPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, layout, ActionKeys.VIEW)) {\n\n\t\t\t\treturn PortalUtil.getCanonicalURL(\n\t\t\t\t\tnull, themeDisplay, layout, true);\n\t\t\t}\n\t\t}\n\n\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\treturn PortalUtil.getGroupFriendlyURL(\n\t\t\tgroup, GetterUtil.getBoolean(privateLayoutParam), themeDisplay);\n\t}","id":60231,"modified_method":"protected String getRedirect(\n\t\t\tThemeDisplay themeDisplay, List<Layout> layouts, long groupId,\n\t\t\tString privateLayoutParam)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tfor (Layout layout : layouts) {\n\t\t\tif (!layout.isHidden() &&\n\t\t\t\tLayoutPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, layout, ActionKeys.VIEW)) {\n\n\t\t\t\tString canonicalURL = PortalUtil.getCanonicalURL(\n\t\t\t\t\tnull, themeDisplay, layout, true);\n\n\t\t\t\treturn PortalUtil.addPreservedParameters(\n\t\t\t\t\tthemeDisplay, layout, canonicalURL, true);\n\t\t\t}\n\t\t}\n\n\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\tString groupFriendlyURL = PortalUtil.getGroupFriendlyURL(\n\t\t\tgroup, GetterUtil.getBoolean(privateLayoutParam), themeDisplay);\n\n\t\treturn PortalUtil.addPreservedParameters(\n\t\t\tthemeDisplay, groupFriendlyURL);\n\t}","commit_id":"683fc994fa1fa5dd42d8677bb4e8678600a48815","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected DaemonContext createDaemonContext() {\n        DaemonContextBuilder builder = new DaemonContextBuilder(get(ProcessEnvironment.class));\n        builder.setDaemonRegistryDir(daemonBaseDir);\n        builder.setIdleTimeout(idleTimeoutMs);\n\n        JvmOptions jvmOptions = new JvmOptions(new IdentityFileResolver());\n        jvmOptions.setAllJvmArgs(ManagementFactory.getRuntimeMXBean().getInputArguments());\n        builder.setDaemonOpts(jvmOptions.getAllJvmArgsWithoutSystemProperties());\n\n        return builder.create();\n    }","id":60232,"modified_method":"protected DaemonContext createDaemonContext() {\n        DaemonContextBuilder builder = new DaemonContextBuilder(get(ProcessEnvironment.class));\n        builder.setDaemonRegistryDir(daemonBaseDir);\n        builder.setIdleTimeout(idleTimeoutMs);\n\n        JvmOptions jvmOptions = new JvmOptions(new IdentityFileResolver());\n        List<String> inputArguments = new ArrayList<String>(ManagementFactory.getRuntimeMXBean().getInputArguments());\n        if (Jvm.current().isIbmJvm()) {\n            // Filter out the implicit jvm args that the ibm jvm adds\n            Iterator<String> iter = inputArguments.iterator();\n            while (iter.hasNext()) {\n                String arg = iter.next();\n                if (!arg.startsWith(\"-\") || arg.startsWith(\"-Xjcl\") || arg.equals(\"-Xdump\")) {\n                    iter.remove();\n                }\n            }\n        }\n        jvmOptions.setAllJvmArgs(inputArguments);\n        builder.setDaemonOpts(jvmOptions.getAllJvmArgsWithoutSystemProperties());\n\n        return builder.create();\n    }","commit_id":"6e834a5af508134a085a0603183cbbd697ceee7e","url":"https://github.com/gradle/gradle"},{"original_method":"static Jvm create(File javaBase) {\n        String vendor = System.getProperty(\"java.vm.vendor\");\n        if (vendor.toLowerCase().startsWith(\"apple inc.\")) {\n            return new AppleJvm(OperatingSystem.current(), javaBase);\n        }\n        return new Jvm(OperatingSystem.current(), javaBase);\n    }","id":60233,"modified_method":"private static Jvm create(File javaBase) {\n        String vendor = System.getProperty(\"java.vm.vendor\");\n        if (vendor.toLowerCase().startsWith(\"apple inc.\")) {\n            return new AppleJvm(OperatingSystem.current(), javaBase);\n        }\n        if (vendor.toLowerCase().startsWith(\"ibm corporation\")) {\n            return new IbmJvm(OperatingSystem.current(), javaBase);\n        }\n        return new Jvm(OperatingSystem.current(), javaBase);\n    }","commit_id":"6e834a5af508134a085a0603183cbbd697ceee7e","url":"https://github.com/gradle/gradle"},{"original_method":"public Jvm(OperatingSystem os) {\n        this(os, null);\n    }","id":60234,"modified_method":"Jvm(OperatingSystem os) {\n        this(os, null);\n    }","commit_id":"6e834a5af508134a085a0603183cbbd697ceee7e","url":"https://github.com/gradle/gradle"},{"original_method":"public AppleJvm(OperatingSystem os) {\n            super(os);\n        }","id":60235,"modified_method":"AppleJvm(OperatingSystem os) {\n            super(os);\n        }","commit_id":"6e834a5af508134a085a0603183cbbd697ceee7e","url":"https://github.com/gradle/gradle"},{"original_method":"public static String getReportHeader()\n    {\n        StringBuilder text = new StringBuilder();\n        text.append(Version.getInstance().getReleaseAttributes());\n        text.append(\"\\n\");\n        text.append(\"Identification: \" + Version.getInstance().getAgentString());\n        text.append(\"\\n\");\n        text.append(\"Memory Usage: \");\n        text.append(Runtime.getRuntime().totalMemory()/1024/1024);\n        text.append(\" MB / \");\n        text.append(Runtime.getRuntime().maxMemory()/1024/1024);\n        text.append(\" MB (\");\n        text.append(Runtime.getRuntime().freeMemory()/1024/1024);\n        text.append(\" MB allocated, but free)\");\n        text.append(\"\\n\");\n        text.append(\"Java version: \" + System.getProperty(\"java.version\") + \", \" + System.getProperty(\"java.vendor\") + \", \" + System.getProperty(\"java.vm.name\"));\n        text.append(\"\\n\");\n        text.append(\"Operating system: \"+ System.getProperty(\"os.name\"));\n        text.append(\"\\n\");\n        try {\n            List<String> vmArguments = ManagementFactory.getRuntimeMXBean().getInputArguments();\n            if (!vmArguments.isEmpty()) {\n                text.append(\"VM arguments: \"+ vmArguments.toString().replace(\"\\\\\\\\\", \"\\\\\"));\n                text.append(\"\\n\");\n            }\n        } catch (SecurityException e) {\n            // Ignore exception\n        }\n        if (Main.commandLineArgs.length > 0) {\n            text.append(\"Program arguments: \"+ Arrays.toString(Main.commandLineArgs));\n            text.append(\"\\n\");\n        }\n        DataSet dataset = Main.main.getCurrentDataSet();\n        if (dataset != null) {\n            String result = DatasetConsistencyTest.runTests(dataset);\n            if (result.length() == 0) {\n                text.append(\"Dataset consistency test: No problems found\\n\");\n            } else {\n                text.append(\"\\nDataset consistency test:\\n\"+result+\"\\n\");\n            }\n        }\n        text.append(\"\\n\");\n        text.append(PluginHandler.getBugReportText());\n        text.append(\"\\n\");\n\n        return text.toString();\n    }","id":60236,"modified_method":"public static String getReportHeader()\n    {\n        StringBuilder text = new StringBuilder();\n        text.append(Version.getInstance().getReleaseAttributes());\n        text.append(\"\\n\");\n        text.append(\"Identification: \" + Version.getInstance().getAgentString());\n        text.append(\"\\n\");\n        text.append(\"Memory Usage: \");\n        text.append(Runtime.getRuntime().totalMemory()/1024/1024);\n        text.append(\" MB / \");\n        text.append(Runtime.getRuntime().maxMemory()/1024/1024);\n        text.append(\" MB (\");\n        text.append(Runtime.getRuntime().freeMemory()/1024/1024);\n        text.append(\" MB allocated, but free)\");\n        text.append(\"\\n\");\n        text.append(\"Java version: \" + System.getProperty(\"java.version\") + \", \" + System.getProperty(\"java.vendor\") + \", \" + System.getProperty(\"java.vm.name\"));\n        text.append(\"\\n\");\n        text.append(\"Operating system: \"+ System.getProperty(\"os.name\"));\n        text.append(\"\\n\");\n        try {\n            // Build a new list of VM parameters to modify it below if needed (default implementation returns an UnmodifiableList instance)\n            List<String> vmArguments = new ArrayList<String>(ManagementFactory.getRuntimeMXBean().getInputArguments());\n            // Hide some parameters for privacy concerns\n            for (ListIterator<String> it = vmArguments.listIterator(); it.hasNext(); ) {\n                String value = it.next();\n                if (value.contains(\"=\") && value.toLowerCase().startsWith(\"-dproxy\")) {\n                    it.set(value.split(\"=\")[0]+\"=xxx\");\n                }\n            }\n            if (!vmArguments.isEmpty()) {\n                text.append(\"VM arguments: \"+ vmArguments.toString().replace(\"\\\\\\\\\", \"\\\\\"));\n                text.append(\"\\n\");\n            }\n        } catch (SecurityException e) {\n            // Ignore exception\n        }\n        if (Main.commandLineArgs.length > 0) {\n            text.append(\"Program arguments: \"+ Arrays.toString(Main.commandLineArgs));\n            text.append(\"\\n\");\n        }\n        DataSet dataset = Main.main.getCurrentDataSet();\n        if (dataset != null) {\n            String result = DatasetConsistencyTest.runTests(dataset);\n            if (result.length() == 0) {\n                text.append(\"Dataset consistency test: No problems found\\n\");\n            } else {\n                text.append(\"\\nDataset consistency test:\\n\"+result+\"\\n\");\n            }\n        }\n        text.append(\"\\n\");\n        text.append(PluginHandler.getBugReportText());\n        text.append(\"\\n\");\n\n        return text.toString();\n    }","commit_id":"26169f8a8506fdd7193d65e1d5db16613d5429d0","url":"https://github.com/openstreetmap/josm"},{"original_method":"public ShowStatusReportAction() {\n        super(\n                tr(\"Show Status Report\"),\n                \"clock\",\n                tr(\"Show status report with useful information that can be attached to bugs\"),\n                Shortcut.registerShortcut(\"help:showstatusreport\", tr(\"Help: {0}\",\n                        tr(\"Show Status Report\")), KeyEvent.CHAR_UNDEFINED, Shortcut.NONE), false);\n\n        putValue(\"help\", ht(\"/Action/ShowStatusReport\"));\n        putValue(\"toolbar\", \"help/showstatusreport\");\n        Main.toolbar.register(this);\n    }","id":60237,"modified_method":"/**\n     * Constructs a new {@code ShowStatusReportAction}\n     */\n    public ShowStatusReportAction() {\n        super(\n                tr(\"Show Status Report\"),\n                \"clock\",\n                tr(\"Show status report with useful information that can be attached to bugs\"),\n                Shortcut.registerShortcut(\"help:showstatusreport\", tr(\"Help: {0}\",\n                        tr(\"Show Status Report\")), KeyEvent.CHAR_UNDEFINED, Shortcut.NONE), false);\n\n        putValue(\"help\", ht(\"/Action/ShowStatusReport\"));\n        putValue(\"toolbar\", \"help/showstatusreport\");\n        Main.toolbar.register(this);\n    }","commit_id":"26169f8a8506fdd7193d65e1d5db16613d5429d0","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Stops all daemons, if any is running.\n     */\n    public void stop() {\n        DaemonConnection connection = connector.maybeConnect();\n        if (connection == null) {\n            LOGGER.lifecycle(\"No Gradle daemons are running.\");\n            return;\n        }\n\n        LOGGER.lifecycle(\"At least one daemon is running. Sending stop command...\");\n        //iterate and stop all daemons\n        while (connection != null) {\n            new StopDispatcher().dispatch(clientMetaData, connection.getConnection());\n            LOGGER.lifecycle(\"Gradle daemon stopped.\");\n            connection = connector.maybeConnect();\n        }\n    }","id":60238,"modified_method":"/**\n     * Stops all daemons, if any is running.\n     */\n    public void stop() {\n        Spec<DaemonContext> stoppableDaemonSpec = Specs.satisfyAll();\n        DaemonConnection connection = connector.maybeConnect(stoppableDaemonSpec);\n        if (connection == null) {\n            LOGGER.lifecycle(\"No Gradle daemons are running.\");\n            return;\n        }\n\n        LOGGER.lifecycle(\"Stopping daemon.\");\n        //iterate and stop all daemons\n        while (connection != null) {\n            new StopDispatcher().dispatch(clientMetaData, connection.getConnection());\n            LOGGER.lifecycle(\"Gradle daemon stopped.\");\n            connection = connector.maybeConnect(stoppableDaemonSpec);\n        }\n    }","commit_id":"cc51c617d52368f7707f5def48aada31253b64a5","url":"https://github.com/gradle/gradle"},{"original_method":"public DaemonClient(DaemonConnector connector, BuildClientMetaData clientMetaData, OutputEventListener outputEventListener) {\n        this.connector = connector;\n        this.clientMetaData = clientMetaData;\n        this.outputEventListener = outputEventListener;\n    }","id":60239,"modified_method":"public DaemonClient(DaemonConnector connector, BuildClientMetaData clientMetaData, OutputEventListener outputEventListener, Spec<DaemonContext> compatibilitySpec) {\n        this.connector = connector;\n        this.clientMetaData = clientMetaData;\n        this.outputEventListener = outputEventListener;\n        this.compatibilitySpec = compatibilitySpec;\n    }","commit_id":"cc51c617d52368f7707f5def48aada31253b64a5","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * Executes the given action in the daemon. The action and parameters must be serializable.\n     *\n     * @param action The action\n     * @throws org.gradle.launcher.exec.ReportedException On failure, when the failure has already been logged/reported.\n     */\n    public <T> T execute(GradleLauncherAction<T> action, BuildActionParameters parameters) {\n        LOGGER.warn(\"Note: the Gradle build daemon is an experimental feature.\");\n        LOGGER.warn(\"As such, you may experience unexpected build failures. You may need to occasionally stop the daemon.\");\n        while(true) {\n            DaemonConnection daemonConnection = connector.connect();\n\n            Result<T> result = runBuild(new Build(action, parameters), daemonConnection.getConnection());\n            if (result instanceof DaemonBusy) {\n                continue; // try a different daemon\n            } else if (result instanceof Failure) {\n                // Could potentially distinguish between CommandFailure and DaemonFailure here.\n                throw ((Failure)result).getValue();\n            } else if (result instanceof Success) {\n                return result.getValue();\n            } else {\n                throw new IllegalStateException(String.format(\"Daemon returned %s for which there is no strategy to handle (i.e. is an unknown Result type)\", result));\n            }\n        }\n    }","id":60240,"modified_method":"/**\n     * Executes the given action in the daemon. The action and parameters must be serializable.\n     *\n     * @param action The action\n     * @throws org.gradle.launcher.exec.ReportedException On failure, when the failure has already been logged/reported.\n     */\n    public <T> T execute(GradleLauncherAction<T> action, BuildActionParameters parameters) {\n        LOGGER.warn(\"Note: the Gradle build daemon is an experimental feature.\");\n        LOGGER.warn(\"As such, you may experience unexpected build failures. You may need to occasionally stop the daemon.\");\n        while(true) {\n            DaemonConnection daemonConnection = connector.connect(compatibilitySpec);\n\n            Result<T> result = runBuild(new Build(action, parameters), daemonConnection.getConnection());\n            if (result instanceof DaemonBusy) {\n                continue; // try a different daemon\n            } else if (result instanceof Failure) {\n                // Could potentially distinguish between CommandFailure and DaemonFailure here.\n                throw ((Failure)result).getValue();\n            } else if (result instanceof Success) {\n                return result.getValue();\n            } else {\n                throw new IllegalStateException(String.format(\"Daemon returned %s for which there is no strategy to handle (i.e. is an unknown Result type)\", result));\n            }\n        }\n    }","commit_id":"cc51c617d52368f7707f5def48aada31253b64a5","url":"https://github.com/gradle/gradle"},{"original_method":"protected DaemonClient createDaemonClient() {\n        return new DaemonClient(get(DaemonConnector.class), get(BuildClientMetaData.class), get(OutputEventListener.class));\n    }","id":60241,"modified_method":"protected DaemonClient createDaemonClient() {\n        return new DaemonClient(get(DaemonConnector.class), get(BuildClientMetaData.class), get(OutputEventListener.class), makeDaemonCompatibilitySpec());\n    }","commit_id":"cc51c617d52368f7707f5def48aada31253b64a5","url":"https://github.com/gradle/gradle"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    protected DaemonConnector createDaemonConnector() {\n        return new DefaultDaemonConnector(get(DaemonRegistry.class), makeDaemonCompatibilitySpec(), get(OutgoingConnector.class), makeDaemonStarter());\n    }","id":60242,"modified_method":"protected DaemonConnector createDaemonConnector() {\n        return new DefaultDaemonConnector(get(DaemonRegistry.class), get(OutgoingConnector.class), makeDaemonStarter());\n    }","commit_id":"cc51c617d52368f7707f5def48aada31253b64a5","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public Map<String, String> getAllEnvironmentVars() {\n        Map<String, String> vars = new HashMap<String, String>();\n        vars.put(\"GRADLE_DAEMON_OPTS\", \"-XX:MaxPermSize=256m\");\n        vars.putAll(super.getAllEnvironmentVars());\n        return vars;\n    }","id":60243,"modified_method":"@Override\n    public Map<String, String> getAllEnvironmentVars() {\n        Map<String, String> vars = new HashMap<String, String>();\n        vars.put(\"GRADLE_DAEMON_OPTS\", \"-ea -XX:MaxPermSize=256m\");\n        vars.putAll(super.getAllEnvironmentVars());\n        return vars;\n    }","commit_id":"cc51c617d52368f7707f5def48aada31253b64a5","url":"https://github.com/gradle/gradle"},{"original_method":"protected DaemonContext createDaemonContext() {\n        DaemonContextBuilder builder = new DaemonContextBuilder();\n        builder.setDaemonRegistryDir(daemonBaseDir);\n        builder.setIdleTimeout(idleTimeoutMs);\n        builder.setDaemonOpts(ManagementFactory.getRuntimeMXBean().getInputArguments());\n        return builder.create();\n    }","id":60244,"modified_method":"protected DaemonContext createDaemonContext() {\n        DaemonContextBuilder builder = new DaemonContextBuilder();\n        builder.setDaemonRegistryDir(daemonBaseDir);\n        builder.setIdleTimeout(idleTimeoutMs);\n\n        List<String> jvmArgs = new ArrayList<String>();\n        for (String arg : ManagementFactory.getRuntimeMXBean().getInputArguments()) {\n            if (!arg.startsWith(\"-D\")) {\n                jvmArgs.add(arg);\n            }\n        }\n        builder.setDaemonOpts(jvmArgs);\n\n        System.out.println(\"=> ADVERTISING OPTS \" + builder.getDaemonOpts());\n\n        return builder.create();\n    }","commit_id":"cc51c617d52368f7707f5def48aada31253b64a5","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultDaemonConnector(DaemonRegistry daemonRegistry, Spec<DaemonContext> contextCompatibilitySpec, OutgoingConnector<Object> connector, Runnable daemonStarter) {\n        this.daemonRegistry = daemonRegistry;\n        this.contextCompatibilitySpec = contextCompatibilitySpec;\n        this.connector = connector;\n        this.daemonStarter = daemonStarter;\n    }","id":60245,"modified_method":"public DefaultDaemonConnector(DaemonRegistry daemonRegistry, OutgoingConnector<Object> connector, Runnable daemonStarter) {\n        this.daemonRegistry = daemonRegistry;\n        this.connector = connector;\n        this.daemonStarter = daemonStarter;\n    }","commit_id":"cc51c617d52368f7707f5def48aada31253b64a5","url":"https://github.com/gradle/gradle"},{"original_method":"private DaemonConnection findConnection(List<DaemonInfo> daemonInfos) {\n        for (DaemonInfo daemonInfo : daemonInfos) {\n            if (!contextCompatibilitySpec.isSatisfiedBy(daemonInfo.getContext())) {\n                continue;\n            }\n\n            try {\n                return new DaemonConnection(connector.connect(daemonInfo.getAddress()), daemonInfo.getPassword());\n            } catch (ConnectException e) {\n                //this means the daemon died without removing its address from the registry\n                //we can safely remove this address now\n                LOGGER.debug(\"We cannot connect to the daemon at \" + daemonInfo.getAddress() + \" due to \" + e + \". \"\n                        + \"We will not remove this daemon from the registry because the connection issue may have been temporary.\");\n                //TODO it might be good to store in the registry the number of failed attempts to connect to the deamon\n                //if the number is high we may decide to remove the daemon from the registry\n                //daemonRegistry.remove(address);\n            }\n        }\n        return null;\n    }","id":60246,"modified_method":"private DaemonConnection findConnection(List<DaemonInfo> daemonInfos, Spec<? super DaemonContext> constraint) {\n        for (DaemonInfo daemonInfo : daemonInfos) {\n            if (!constraint.isSatisfiedBy(daemonInfo.getContext())) {\n                continue;\n            }\n\n            try {\n                return new DaemonConnection(connector.connect(daemonInfo.getAddress()), daemonInfo.getPassword());\n            } catch (ConnectException e) {\n                //this means the daemon died without removing its address from the registry\n                //we can safely remove this address now\n                LOGGER.debug(\"We cannot connect to the daemon at \" + daemonInfo.getAddress() + \" due to \" + e + \". \"\n                        + \"We will not remove this daemon from the registry because the connection issue may have been temporary.\");\n                //TODO it might be good to store in the registry the number of failed attempts to connect to the deamon\n                //if the number is high we may decide to remove the daemon from the registry\n                //daemonRegistry.remove(address);\n            }\n        }\n        return null;\n    }","commit_id":"cc51c617d52368f7707f5def48aada31253b64a5","url":"https://github.com/gradle/gradle"},{"original_method":"public static <T> Spec<T> satisfyAll() {\n        return new Spec<T>() {\n            public boolean isSatisfiedBy(T element) {\n                return true;\n            }\n        };\n    }","id":60247,"modified_method":"public static <T> Spec<T> satisfyAll() {\n        return (Spec<T>)SATISFIES_ALL;\n    }","commit_id":"cc51c617d52368f7707f5def48aada31253b64a5","url":"https://github.com/gradle/gradle"},{"original_method":"public static <T> Spec<T> satisfyNone() {\n        return new Spec<T>() {\n            public boolean isSatisfiedBy(T element) {\n                return false;\n            }\n        };\n    }","id":60248,"modified_method":"public static <T> Spec<T> satisfyNone() {\n        return (Spec<T>)SATISFIES_NONE;\n    }","commit_id":"cc51c617d52368f7707f5def48aada31253b64a5","url":"https://github.com/gradle/gradle"},{"original_method":"public void onSuccess(FetchResult result, ClientGetter state, ObjectContainer container) {\n\t\tLogger.minor(this, \"Succeeded: \"+identifier);\n\t\tBucket data = result.asBucket();\n\t\tif(persistenceType == PERSIST_FOREVER) {\n\t\t\tif(data != null)\n\t\t\t\tcontainer.activate(data, 5);\n\t\t\tif(returnBucket != null)\n\t\t\t\tcontainer.activate(returnBucket, 5);\n\t\t\tcontainer.activate(client, 1);\n\t\t\tif(tempFile != null)\n\t\t\t\tcontainer.activate(tempFile, 5);\n\t\t\tif(targetFile != null)\n\t\t\t\tcontainer.activate(targetFile, 5);\n\t\t}\n\t\tif(returnBucket != data && !binaryBlob) {\n\t\t\tboolean failed = true;\n\t\t\tsynchronized(this) {\n\t\t\t\tif(finished) {\n\t\t\t\t\tLogger.error(this, \"Already finished but onSuccess() for \"+this+\" data = \"+data, new Exception(\"debug\"));\n\t\t\t\t\tdata.free();\n\t\t\t\t\treturn; // Already failed - bucket error maybe??\n\t\t\t\t}\n\t\t\t\tif(returnType == ClientGetMessage.RETURN_TYPE_DIRECT && returnBucket == null) {\n\t\t\t\t\t// Lost bucket for some reason e.g. bucket error (caused by IOException) on previous try??\n\t\t\t\t\t// Recover...\n\t\t\t\t\treturnBucket = data;\n\t\t\t\t\tfailed = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(failed) {\n\t\t\t\tLogger.error(this, \"returnBucket = \"+returnBucket+\" but onSuccess() data = \"+data, new Exception(\"debug\"));\n\t\t\t\t// Caller guarantees that data == returnBucket\n\t\t\t\tonFailure(new FetchException(FetchException.INTERNAL_ERROR, \"Data != returnBucket\"), null, container);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tboolean dontFree = false;\n\t\t// FIXME I don't think this is a problem in this case...? (Disk write while locked..)\n\t\tAllDataMessage adm = null;\n\t\tsynchronized(this) {\n\t\t\tif(succeeded) {\n\t\t\t\tLogger.error(this, \"onSuccess called twice for \"+this+\" (\"+identifier+ ')');\n\t\t\t\treturn; // We might be called twice; ignore it if so.\n\t\t\t}\n\t\t\tstarted = true;\n\t\t\tif(returnType == ClientGetMessage.RETURN_TYPE_DIRECT) {\n\t\t\t\t// Send all the data at once\n\t\t\t\t// FIXME there should be other options\n\t\t\t\t// FIXME: CompletionTime is set on finish() : we need to give it current time here\n\t\t\t\t// but it means we won't always return the same value to clients... Does it matter ?\n\t\t\t\tadm = new AllDataMessage(returnBucket, identifier, global, startupTime, System.currentTimeMillis());\n\t\t\t\tif(persistenceType == PERSIST_CONNECTION)\n\t\t\t\t\tadm.setFreeOnSent();\n\t\t\t\tdontFree = true;\n\t\t\t\t/* \n\t\t\t\t * } else if(returnType == ClientGetMessage.RETURN_TYPE_NONE) {\n\t\t\t\t// Do nothing\n\t\t\t\t */\n\t\t\t} else if(returnType == ClientGetMessage.RETURN_TYPE_DISK) {\n\t\t\t\t// Write to temp file, then rename over filename\n\t\t\t\tif(!FileUtil.renameTo(tempFile, targetFile)) {\n\t\t\t\t\tpostFetchProtocolErrorMessage = new ProtocolErrorMessage(ProtocolErrorMessage.COULD_NOT_RENAME_FILE, false, null, identifier, global);\n\t\t\t\t\t// Don't delete temp file, user might want it.\n\t\t\t\t}\n\t\t\t\treturnBucket = new FileBucket(targetFile, false, true, false, false, false);\n\t\t\t}\n\t\t\tprogressPending = null;\n\t\t\tthis.foundDataLength = returnBucket.size();\n\t\t\tif(!binaryBlob)\n\t\t\t\tthis.foundDataMimeType = result.getMimeType(persistenceType == PERSIST_FOREVER ? container : null);\n\t\t\telse\n\t\t\t\tthis.foundDataMimeType = BinaryBlob.MIME_TYPE;\n\t\t\tthis.succeeded = true;\n\t\t\tfinished = true;\n\t\t}\n\t\ttrySendDataFoundOrGetFailed(null, container);\n\n\t\tif(adm != null)\n\t\t\ttrySendAllDataMessage(adm, null, container);\n\t\tif(!dontFree)\n\t\t\tdata.free();\n\t\tif(persistenceType == PERSIST_FOREVER) {\n\t\t\treturnBucket.storeTo(container);\n\t\t\tcontainer.set(this);\n\t\t}\n\t\tfinish(container);\n\t\tclient.notifySuccess(this, container);\n\t}","id":60249,"modified_method":"public void onSuccess(FetchResult result, ClientGetter state, ObjectContainer container) {\n\t\tLogger.minor(this, \"Succeeded: \"+identifier);\n\t\tBucket data = result.asBucket();\n\t\tif(persistenceType == PERSIST_FOREVER) {\n\t\t\tif(data != null)\n\t\t\t\tcontainer.activate(data, 5);\n\t\t\tif(returnBucket != null)\n\t\t\t\tcontainer.activate(returnBucket, 5);\n\t\t\tcontainer.activate(client, 1);\n\t\t\tif(tempFile != null)\n\t\t\t\tcontainer.activate(tempFile, 5);\n\t\t\tif(targetFile != null)\n\t\t\t\tcontainer.activate(targetFile, 5);\n\t\t}\n\t\tif(returnBucket != data && !binaryBlob) {\n\t\t\tboolean failed = true;\n\t\t\tsynchronized(this) {\n\t\t\t\tif(finished) {\n\t\t\t\t\tLogger.error(this, \"Already finished but onSuccess() for \"+this+\" data = \"+data, new Exception(\"debug\"));\n\t\t\t\t\tdata.free();\n\t\t\t\t\treturn; // Already failed - bucket error maybe??\n\t\t\t\t}\n\t\t\t\tif(returnType == ClientGetMessage.RETURN_TYPE_DIRECT && returnBucket == null) {\n\t\t\t\t\t// Lost bucket for some reason e.g. bucket error (caused by IOException) on previous try??\n\t\t\t\t\t// Recover...\n\t\t\t\t\treturnBucket = data;\n\t\t\t\t\tfailed = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(failed) {\n\t\t\t\tLogger.error(this, \"returnBucket = \"+returnBucket+\" but onSuccess() data = \"+data, new Exception(\"debug\"));\n\t\t\t\t// Caller guarantees that data == returnBucket\n\t\t\t\tonFailure(new FetchException(FetchException.INTERNAL_ERROR, \"Data != returnBucket\"), null, container);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tboolean dontFree = false;\n\t\t// FIXME I don't think this is a problem in this case...? (Disk write while locked..)\n\t\tAllDataMessage adm = null;\n\t\tsynchronized(this) {\n\t\t\tif(succeeded) {\n\t\t\t\tLogger.error(this, \"onSuccess called twice for \"+this+\" (\"+identifier+ ')');\n\t\t\t\treturn; // We might be called twice; ignore it if so.\n\t\t\t}\n\t\t\tstarted = true;\n\t\t\tif(returnType == ClientGetMessage.RETURN_TYPE_DIRECT) {\n\t\t\t\t// Send all the data at once\n\t\t\t\t// FIXME there should be other options\n\t\t\t\t// FIXME: CompletionTime is set on finish() : we need to give it current time here\n\t\t\t\t// but it means we won't always return the same value to clients... Does it matter ?\n\t\t\t\tadm = new AllDataMessage(returnBucket, identifier, global, startupTime, System.currentTimeMillis());\n\t\t\t\tif(persistenceType == PERSIST_CONNECTION)\n\t\t\t\t\tadm.setFreeOnSent();\n\t\t\t\tdontFree = true;\n\t\t\t\t/* \n\t\t\t\t * } else if(returnType == ClientGetMessage.RETURN_TYPE_NONE) {\n\t\t\t\t// Do nothing\n\t\t\t\t */\n\t\t\t} else if(returnType == ClientGetMessage.RETURN_TYPE_DISK) {\n\t\t\t\t// Write to temp file, then rename over filename\n\t\t\t\tif(!FileUtil.renameTo(tempFile, targetFile)) {\n\t\t\t\t\tpostFetchProtocolErrorMessage = new ProtocolErrorMessage(ProtocolErrorMessage.COULD_NOT_RENAME_FILE, false, null, identifier, global);\n\t\t\t\t\t// Don't delete temp file, user might want it.\n\t\t\t\t}\n\t\t\t\treturnBucket = new FileBucket(targetFile, false, true, false, false, false);\n\t\t\t}\n\t\t\tprogressPending = null;\n\t\t\tthis.foundDataLength = returnBucket.size();\n\t\t\tif(!binaryBlob)\n\t\t\t\tthis.foundDataMimeType = result.getMimeType();\n\t\t\telse\n\t\t\t\tthis.foundDataMimeType = BinaryBlob.MIME_TYPE;\n\t\t\tthis.succeeded = true;\n\t\t\tfinished = true;\n\t\t}\n\t\ttrySendDataFoundOrGetFailed(null, container);\n\n\t\tif(adm != null)\n\t\t\ttrySendAllDataMessage(adm, null, container);\n\t\tif(!dontFree)\n\t\t\tdata.free();\n\t\tif(persistenceType == PERSIST_FOREVER) {\n\t\t\treturnBucket.storeTo(container);\n\t\t\tcontainer.set(this);\n\t\t}\n\t\tfinish(container);\n\t\tclient.notifySuccess(this, container);\n\t}","commit_id":"9390feb973080c5e67744ef0f688425bfaf24fd2","url":"https://github.com/freenet/fred"},{"original_method":"public void onSuccess(FetchResult result, ClientGetter state, ObjectContainer container) {\n\t\tLogger.minor(this, \"Succeeded: \"+identifier);\n\t\tBucket data = result.asBucket();\n\t\tif(persistenceType == PERSIST_FOREVER) {\n\t\t\tif(data != null)\n\t\t\t\tcontainer.activate(data, 5);\n\t\t\tif(returnBucket != null)\n\t\t\t\tcontainer.activate(returnBucket, 5);\n\t\t\tcontainer.activate(client, 1);\n\t\t\tif(tempFile != null)\n\t\t\t\tcontainer.activate(tempFile, 5);\n\t\t\tif(targetFile != null)\n\t\t\t\tcontainer.activate(targetFile, 5);\n\t\t}\n\t\tif(returnBucket != data && !binaryBlob) {\n\t\t\tboolean failed = true;\n\t\t\tsynchronized(this) {\n\t\t\t\tif(finished) {\n\t\t\t\t\tLogger.error(this, \"Already finished but onSuccess() for \"+this+\" data = \"+data, new Exception(\"debug\"));\n\t\t\t\t\tdata.free();\n\t\t\t\t\treturn; // Already failed - bucket error maybe??\n\t\t\t\t}\n\t\t\t\tif(returnType == ClientGetMessage.RETURN_TYPE_DIRECT && returnBucket == null) {\n\t\t\t\t\t// Lost bucket for some reason e.g. bucket error (caused by IOException) on previous try??\n\t\t\t\t\t// Recover...\n\t\t\t\t\treturnBucket = data;\n\t\t\t\t\tfailed = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(failed) {\n\t\t\t\tLogger.error(this, \"returnBucket = \"+returnBucket+\" but onSuccess() data = \"+data, new Exception(\"debug\"));\n\t\t\t\t// Caller guarantees that data == returnBucket\n\t\t\t\tonFailure(new FetchException(FetchException.INTERNAL_ERROR, \"Data != returnBucket\"), null, container);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tboolean dontFree = false;\n\t\t// FIXME I don't think this is a problem in this case...? (Disk write while locked..)\n\t\tAllDataMessage adm = null;\n\t\tsynchronized(this) {\n\t\t\tif(succeeded) {\n\t\t\t\tLogger.error(this, \"onSuccess called twice for \"+this+\" (\"+identifier+ ')');\n\t\t\t\treturn; // We might be called twice; ignore it if so.\n\t\t\t}\n\t\t\tstarted = true;\n\t\t\tif(returnType == ClientGetMessage.RETURN_TYPE_DIRECT) {\n\t\t\t\t// Send all the data at once\n\t\t\t\t// FIXME there should be other options\n\t\t\t\t// FIXME: CompletionTime is set on finish() : we need to give it current time here\n\t\t\t\t// but it means we won't always return the same value to clients... Does it matter ?\n\t\t\t\tadm = new AllDataMessage(returnBucket, identifier, global, startupTime, System.currentTimeMillis());\n\t\t\t\tif(persistenceType == PERSIST_CONNECTION)\n\t\t\t\t\tadm.setFreeOnSent();\n\t\t\t\tdontFree = true;\n\t\t\t\t/* \n\t\t\t\t * } else if(returnType == ClientGetMessage.RETURN_TYPE_NONE) {\n\t\t\t\t// Do nothing\n\t\t\t\t */\n\t\t\t} else if(returnType == ClientGetMessage.RETURN_TYPE_DISK) {\n\t\t\t\t// Write to temp file, then rename over filename\n\t\t\t\tif(!FileUtil.renameTo(tempFile, targetFile)) {\n\t\t\t\t\tpostFetchProtocolErrorMessage = new ProtocolErrorMessage(ProtocolErrorMessage.COULD_NOT_RENAME_FILE, false, null, identifier, global);\n\t\t\t\t\t// Don't delete temp file, user might want it.\n\t\t\t\t}\n\t\t\t\treturnBucket = new FileBucket(targetFile, false, true, false, false, false);\n\t\t\t}\n\t\t\tprogressPending = null;\n\t\t\tthis.foundDataLength = returnBucket.size();\n\t\t\tif(!binaryBlob)\n\t\t\t\tthis.foundDataMimeType = result.getMimeType();\n\t\t\telse\n\t\t\t\tthis.foundDataMimeType = BinaryBlob.MIME_TYPE;\n\t\t\tthis.succeeded = true;\n\t\t\tfinished = true;\n\t\t}\n\t\ttrySendDataFoundOrGetFailed(null, container);\n\n\t\tif(adm != null)\n\t\t\ttrySendAllDataMessage(adm, null, container);\n\t\tif(!dontFree)\n\t\t\tdata.free();\n\t\tif(persistenceType == PERSIST_FOREVER) {\n\t\t\treturnBucket.storeTo(container);\n\t\t\tcontainer.set(this);\n\t\t}\n\t\tfinish(container);\n\t\tclient.notifySuccess(this, container);\n\t}","id":60250,"modified_method":"public void onSuccess(FetchResult result, ClientGetter state, ObjectContainer container) {\n\t\tLogger.minor(this, \"Succeeded: \"+identifier);\n\t\tBucket data = result.asBucket();\n\t\tif(persistenceType == PERSIST_FOREVER) {\n\t\t\tif(data != null)\n\t\t\t\tcontainer.activate(data, 5);\n\t\t\tif(returnBucket != null)\n\t\t\t\tcontainer.activate(returnBucket, 5);\n\t\t\tcontainer.activate(client, 1);\n\t\t\tif(tempFile != null)\n\t\t\t\tcontainer.activate(tempFile, 5);\n\t\t\tif(targetFile != null)\n\t\t\t\tcontainer.activate(targetFile, 5);\n\t\t}\n\t\tif(returnBucket != data && !binaryBlob) {\n\t\t\tboolean failed = true;\n\t\t\tsynchronized(this) {\n\t\t\t\tif(finished) {\n\t\t\t\t\tLogger.error(this, \"Already finished but onSuccess() for \"+this+\" data = \"+data, new Exception(\"debug\"));\n\t\t\t\t\tdata.free();\n\t\t\t\t\treturn; // Already failed - bucket error maybe??\n\t\t\t\t}\n\t\t\t\tif(returnType == ClientGetMessage.RETURN_TYPE_DIRECT && returnBucket == null) {\n\t\t\t\t\t// Lost bucket for some reason e.g. bucket error (caused by IOException) on previous try??\n\t\t\t\t\t// Recover...\n\t\t\t\t\treturnBucket = data;\n\t\t\t\t\tfailed = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(failed) {\n\t\t\t\tLogger.error(this, \"returnBucket = \"+returnBucket+\" but onSuccess() data = \"+data, new Exception(\"debug\"));\n\t\t\t\t// Caller guarantees that data == returnBucket\n\t\t\t\tonFailure(new FetchException(FetchException.INTERNAL_ERROR, \"Data != returnBucket\"), null, container);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tboolean dontFree = false;\n\t\t// FIXME I don't think this is a problem in this case...? (Disk write while locked..)\n\t\tAllDataMessage adm = null;\n\t\tsynchronized(this) {\n\t\t\tif(succeeded) {\n\t\t\t\tLogger.error(this, \"onSuccess called twice for \"+this+\" (\"+identifier+ ')');\n\t\t\t\treturn; // We might be called twice; ignore it if so.\n\t\t\t}\n\t\t\tstarted = true;\n\t\t\tif(returnType == ClientGetMessage.RETURN_TYPE_DIRECT) {\n\t\t\t\t// Send all the data at once\n\t\t\t\t// FIXME there should be other options\n\t\t\t\t// FIXME: CompletionTime is set on finish() : we need to give it current time here\n\t\t\t\t// but it means we won't always return the same value to clients... Does it matter ?\n\t\t\t\tadm = new AllDataMessage(returnBucket, identifier, global, startupTime, System.currentTimeMillis());\n\t\t\t\tif(persistenceType == PERSIST_CONNECTION)\n\t\t\t\t\tadm.setFreeOnSent();\n\t\t\t\tdontFree = true;\n\t\t\t\t/* \n\t\t\t\t * } else if(returnType == ClientGetMessage.RETURN_TYPE_NONE) {\n\t\t\t\t// Do nothing\n\t\t\t\t */\n\t\t\t} else if(returnType == ClientGetMessage.RETURN_TYPE_DISK) {\n\t\t\t\t// Write to temp file, then rename over filename\n\t\t\t\tif(!FileUtil.renameTo(tempFile, targetFile)) {\n\t\t\t\t\tpostFetchProtocolErrorMessage = new ProtocolErrorMessage(ProtocolErrorMessage.COULD_NOT_RENAME_FILE, false, null, identifier, global);\n\t\t\t\t\t// Don't delete temp file, user might want it.\n\t\t\t\t}\n\t\t\t\treturnBucket = new FileBucket(targetFile, false, true, false, false, false);\n\t\t\t}\n\t\t\tprogressPending = null;\n\t\t\tthis.foundDataLength = returnBucket.size();\n\t\t\tif(!binaryBlob)\n\t\t\t\tthis.foundDataMimeType = result.getMimeType(persistenceType == PERSIST_FOREVER ? container : null);\n\t\t\telse\n\t\t\t\tthis.foundDataMimeType = BinaryBlob.MIME_TYPE;\n\t\t\tthis.succeeded = true;\n\t\t\tfinished = true;\n\t\t}\n\t\ttrySendDataFoundOrGetFailed(null, container);\n\n\t\tif(adm != null)\n\t\t\ttrySendAllDataMessage(adm, null, container);\n\t\tif(!dontFree)\n\t\t\tdata.free();\n\t\tif(persistenceType == PERSIST_FOREVER) {\n\t\t\treturnBucket.storeTo(container);\n\t\t\tcontainer.set(this);\n\t\t}\n\t\tfinish(container);\n\t\tclient.notifySuccess(this, container);\n\t}","commit_id":"72a607e3a3db53a4726260386fedd1e146eda1fa","url":"https://github.com/freenet/fred"},{"original_method":"private int splitNode(int parentAddress) {\n      if (doSanityCheck) {\n        myAssert(isFull());\n        dump(\"before split:\"+isIndexLeaf());\n      }\n\n      short maxIndex = (short)(getMaxChildrenCount() / 2);\n\n      BtreeIndexNodeView newIndexNode = new BtreeIndexNodeView(btree);\n      newIndexNode.setAddress(btree.nextPage());\n      newIndexNode.setParentAddress(parentAddress);\n\n      boolean indexLeaf = isIndexLeaf();\n      newIndexNode.setIndexLeaf(indexLeaf);\n\n      short recordCount = getChildrenCount();\n\n      short recordCountInNewNode = (short)(recordCount - maxIndex);\n      newIndexNode.setChildrenCount(recordCountInNewNode);\n      int medianKey;\n\n      if (indexLeaf) {\n        if (btree.isLarge) {\n          final int bytesToMove = recordCountInNewNode * INTERIOR_SIZE;\n          getBytes(indexToOffset(maxIndex), btree.buffer, 0, bytesToMove);\n          newIndexNode.putBytes(newIndexNode.indexToOffset(0), btree.buffer, 0, bytesToMove);\n        } else {\n          for(int i = 0; i < recordCountInNewNode; ++i) {\n            newIndexNode.setAddressAt(i, addressAt(i + maxIndex));\n            newIndexNode.setKeyAt(i, keyAt(i + maxIndex));\n          }\n        }\n        medianKey = newIndexNode.keyAt(0);\n      } else {\n        BtreeIndexNodeView c = new BtreeIndexNodeView(btree);\n        for(int i = 0; i < recordCountInNewNode; ++i) {\n          int address = addressAt(i + maxIndex);\n          c.setAddress(-address);\n          c.setParentAddress(newIndexNode.address);\n          c.sync();\n          newIndexNode.setAddressAt(i, address);\n          newIndexNode.setKeyAt(i, keyAt(i + maxIndex));\n        }\n\n        int address = addressAt(recordCount);\n        c.setAddress(-address);\n        c.setParentAddress(newIndexNode.address);\n        c.sync();\n        newIndexNode.setAddressAt(recordCountInNewNode, address);\n        --maxIndex;\n        medianKey = keyAt(maxIndex);\n      }\n\n      setChildrenCount(maxIndex);\n\n      if (parentAddress != 0) {\n        BtreeIndexNodeView parent = new BtreeIndexNodeView(btree);\n        parent.setAddress(parentAddress);\n\n        if (doSanityCheck) {\n          int medianKeyInParent = parent.search(medianKey);\n          int ourKey = keyAt(0);\n          int ourKeyInParent = parent.search(ourKey);\n          parent.dump(\"About to insert \"+medianKey + \",\" + newIndexNode.address+\",\" + medianKeyInParent + \" our key \" + ourKey + \", \" + ourKeyInParent);\n\n          myAssert(medianKeyInParent < 0);\n          myAssert(!parent.isFull());\n        }\n\n        parent.insert(medianKey, -newIndexNode.address);\n        parent.setAddress(newIndexNode.parentAddress());\n\n        if (doSanityCheck) {\n          parent.dump(\"After modifying parent\");\n          int search = parent.search(medianKey);\n          myAssert(search >= 0);\n          myAssert(parent.addressAt(search + 1) == -newIndexNode.address);\n\n          dump(\"old node after split:\");\n          newIndexNode.dump(\"new node after split:\");\n        }\n      } else {\n        if (doSanityCheck) {\n          btree.root.dump(\"Splitting root:\"+medianKey);\n        }\n        int newRootAddress = btree.nextPage();\n        if (doSanityCheck) {\n          System.out.println(\"Pages:\"+btree.pagesCount+\", elements:\"+btree.size + \", average:\" + (btree.maxStepsSearched + 1));\n        }\n        btree.setRootAddress(newRootAddress);\n        parentAddress = newRootAddress;\n        btree.root.setChildrenCount((short)1);\n        btree.root.setKeyAt(0, medianKey);\n        btree.root.setAddressAt(0, -address);\n        btree.root.setAddressAt(1, -newIndexNode.address);\n        btree.root.sync();\n        newIndexNode.setParentAddress(newRootAddress);\n        setParentAddress(newRootAddress);\n\n        if (doSanityCheck) {\n          btree.root.dump(\"New root\");\n          dump(\"First child\");\n          newIndexNode.dump(\"Second child\");\n        }\n      }\n\n      sync();\n      newIndexNode.sync();\n\n      return parentAddress;\n    }","id":60251,"modified_method":"private int splitNode(int parentAddress) {\n      if (doSanityCheck) {\n        myAssert(isFull());\n        dump(\"before split:\"+isIndexLeaf());\n      }\n\n      short maxIndex = (short)(getMaxChildrenCount() / 2);\n\n      BtreeIndexNodeView newIndexNode = new BtreeIndexNodeView(btree);\n      newIndexNode.setAddress(btree.nextPage());\n\n      boolean indexLeaf = isIndexLeaf();\n      newIndexNode.setIndexLeaf(indexLeaf);\n\n      short recordCount = getChildrenCount();\n\n      short recordCountInNewNode = (short)(recordCount - maxIndex);\n      newIndexNode.setChildrenCount(recordCountInNewNode);\n      int medianKey;\n\n      if (btree.isLarge) {\n        final int bytesToMove = recordCountInNewNode * INTERIOR_SIZE;\n        getBytes(indexToOffset(maxIndex), btree.buffer, 0, bytesToMove);\n        newIndexNode.putBytes(newIndexNode.indexToOffset(0), btree.buffer, 0, bytesToMove);\n      } else {\n        for(int i = 0; i < recordCountInNewNode; ++i) {\n          newIndexNode.setAddressAt(i, addressAt(i + maxIndex));\n          newIndexNode.setKeyAt(i, keyAt(i + maxIndex));\n        }\n      }\n\n      if (indexLeaf) {\n        medianKey = newIndexNode.keyAt(0);\n      } else {\n        newIndexNode.setAddressAt(recordCountInNewNode, addressAt(recordCount));\n        --maxIndex;\n        medianKey = keyAt(maxIndex);     // key count is odd (since children count is even) and middle key goes to parent\n      }\n\n      setChildrenCount(maxIndex);\n\n      if (parentAddress != 0) {\n        BtreeIndexNodeView parent = new BtreeIndexNodeView(btree);\n        parent.setAddress(parentAddress);\n\n        if (doSanityCheck) {\n          int medianKeyInParent = parent.search(medianKey);\n          int ourKey = keyAt(0);\n          int ourKeyInParent = parent.search(ourKey);\n          parent.dump(\"About to insert \"+medianKey + \",\" + newIndexNode.address+\",\" + medianKeyInParent + \" our key \" + ourKey + \", \" + ourKeyInParent);\n\n          myAssert(medianKeyInParent < 0);\n          myAssert(!parent.isFull());\n        }\n\n        parent.insert(medianKey, -newIndexNode.address);\n\n        if (doSanityCheck) {\n          parent.dump(\"After modifying parent\");\n          int search = parent.search(medianKey);\n          myAssert(search >= 0);\n          myAssert(parent.addressAt(search + 1) == -newIndexNode.address);\n\n          dump(\"old node after split:\");\n          newIndexNode.dump(\"new node after split:\");\n        }\n      } else {\n        if (doSanityCheck) {\n          btree.root.dump(\"Splitting root:\"+medianKey);\n        }\n        int newRootAddress = btree.nextPage();\n        if (doSanityCheck) {\n          System.out.println(\"Pages:\"+btree.pagesCount+\", elements:\"+btree.size + \", average:\" + (btree.maxStepsSearched + 1));\n        }\n        btree.setRootAddress(newRootAddress);\n        parentAddress = newRootAddress;\n        btree.root.setChildrenCount((short)1);\n        btree.root.setKeyAt(0, medianKey);\n        btree.root.setAddressAt(0, -address);\n        btree.root.setAddressAt(1, -newIndexNode.address);\n        btree.root.sync();\n\n        if (doSanityCheck) {\n          btree.root.dump(\"New root\");\n          dump(\"First child\");\n          newIndexNode.dump(\"Second child\");\n        }\n      }\n\n      sync();\n      newIndexNode.sync();\n\n      return parentAddress;\n    }","commit_id":"532436a4e4f9478c1388800949ff1a9d13b9f59f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void insertToNotFull(int valueHC, int newValueId, int index) {\n      short recordCount = getChildrenCount();\n      if (doSanityCheck) myAssert(recordCount < getMaxChildrenCount());\n      setChildrenCount((short)(recordCount + 1));\n\n      if (isIndexLeaf()) {\n        if (btree.isLarge) {\n          final int bytesToMove = (recordCount - index) * INTERIOR_SIZE;\n          getBytes(indexToOffset(index), btree.buffer, 0, bytesToMove);\n          putBytes(indexToOffset(index + 1), btree.buffer, 0, bytesToMove);\n        } else {\n          for(int i = recordCount - 1; i >= index; --i) {\n            setKeyAt(i + 1, keyAt(i));\n            setAddressAt(i + 1, addressAt(i));\n          }\n        }\n        setKeyAt(index, valueHC);\n        setAddressAt(index, newValueId);\n      } else {\n        BtreeIndexNodeView view = new BtreeIndexNodeView(btree);\n        view.setAddress(-newValueId);\n        view.setParentAddress(address);\n        view.sync();\n\n        // <address> (<key><address>) {record_count - 1}\n        //\n        setAddressAt(recordCount + 1, addressAt(recordCount));\n        if (btree.isLarge) {\n          int elementsAfterIndex = recordCount - index - 1;\n          if (elementsAfterIndex > 0) {\n            int bytesToMove = elementsAfterIndex * INTERIOR_SIZE;\n            getBytes(indexToOffset(index + 1), btree.buffer, 0, bytesToMove);\n            putBytes(indexToOffset(index + 2), btree.buffer, 0, bytesToMove);\n          }\n        } else {\n          for(int i = recordCount - 1; i > index; --i) {\n            setKeyAt(i + 1, keyAt(i));\n            setAddressAt(i + 1, addressAt(i));\n          }\n        }\n\n        if (index < recordCount) setKeyAt(index + 1, keyAt(index));\n\n        setKeyAt(index, valueHC);\n        setAddressAt(index + 1, newValueId);\n      }\n\n      if (doSanityCheck) {\n        if (index > 0) myAssert(keyAt(index - 1) < keyAt(index));\n        if (index < recordCount) myAssert(keyAt(index) < keyAt(index + 1));\n      }\n\n      sync();\n    }","id":60252,"modified_method":"private void insertToNotFull(int valueHC, int newValueId, int index) {\n      short recordCount = getChildrenCount();\n      if (doSanityCheck) myAssert(recordCount < getMaxChildrenCount());\n      setChildrenCount((short)(recordCount + 1));\n\n      // TODO Clever books tell us to use Btree for cheaper elements shifting within page\n      if (isIndexLeaf()) {\n        if (btree.isLarge) {\n          final int bytesToMove = (recordCount - index) * INTERIOR_SIZE;\n          getBytes(indexToOffset(index), btree.buffer, 0, bytesToMove);\n          putBytes(indexToOffset(index + 1), btree.buffer, 0, bytesToMove);\n        } else {\n          for(int i = recordCount - 1; i >= index; --i) {\n            setKeyAt(i + 1, keyAt(i));\n            setAddressAt(i + 1, addressAt(i));\n          }\n        }\n        setKeyAt(index, valueHC);\n        setAddressAt(index, newValueId);\n      } else {\n        // <address> (<key><address>) {record_count - 1}\n        //\n        setAddressAt(recordCount + 1, addressAt(recordCount));\n        if (btree.isLarge) {\n          int elementsAfterIndex = recordCount - index - 1;\n          if (elementsAfterIndex > 0) {\n            int bytesToMove = elementsAfterIndex * INTERIOR_SIZE;\n            getBytes(indexToOffset(index + 1), btree.buffer, 0, bytesToMove);\n            putBytes(indexToOffset(index + 2), btree.buffer, 0, bytesToMove);\n          }\n        } else {\n          for(int i = recordCount - 1; i > index; --i) {\n            setKeyAt(i + 1, keyAt(i));\n            setAddressAt(i + 1, addressAt(i));\n          }\n        }\n\n        if (index < recordCount) setKeyAt(index + 1, keyAt(index));\n\n        setKeyAt(index, valueHC);\n        setAddressAt(index + 1, newValueId);\n      }\n\n      if (doSanityCheck) {\n        if (index > 0) myAssert(keyAt(index - 1) < keyAt(index));\n        if (index < recordCount) myAssert(keyAt(index) < keyAt(index + 1));\n      }\n\n      sync();\n    }","commit_id":"532436a4e4f9478c1388800949ff1a9d13b9f59f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void insert(int valueHC, int newValueId, int index) {\n      if (doSanityCheck) myAssert(!isFull());\n      insertToNotFull(valueHC, newValueId, index);\n\n      if (doSanityCheck) {\n        if (index == 0) {\n          int parentAddress = parentAddress();\n\n          if (parentAddress > 0) {\n            BtreeIndexNodeView parent = new BtreeIndexNodeView(btree);\n            parent.setAddress(parentAddress);\n            int indexInParent = -1;\n\n            for (int i = 0; i <= parent.getChildrenCount(); ++i) {\n              if (parent.addressAt(i) == -address) {\n                indexInParent = i;\n                break;\n              }\n            }\n\n            myAssert(indexInParent >= 0);\n            if (indexInParent == 0) {\n              myAssert(keyAt(getChildrenCount() - 1) < parent.keyAt(0));\n            }\n          }\n        }\n      }\n    }","id":60253,"modified_method":"private void insert(int valueHC, int newValueId, int index) {\n      if (doSanityCheck) myAssert(!isFull());\n      insertToNotFull(valueHC, newValueId, index);\n    }","commit_id":"532436a4e4f9478c1388800949ff1a9d13b9f59f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private int locate(int valueHC, boolean split) {\n      int searched = 0;\n      int parentAddress = 0;\n\n      while(true) {\n        if (split && isFull()) {\n          if (doSanityCheck) myAssert(parentAddress == parentAddress());\n          parentAddress = splitNode(parentAddress);\n          if (doSanityCheck) myAssert(parentAddress == parentAddress());\n          setAddress(parentAddress);\n          --searched;\n        }\n\n        int i = search(valueHC);\n\n        ++searched;\n\n        if (isIndexLeaf()) {\n          btree.maxStepsSearched = Math.max(btree.maxStepsSearched, searched);\n          return i;\n        }\n\n        int address = i < 0 ? addressAt(-i - 1):addressAt(i + 1);\n        if (doSanityCheck) myAssert(address != 0);\n        parentAddress = this.address;\n        setAddress(-address);\n      }\n    }","id":60254,"modified_method":"private int locate(int valueHC, boolean split) {\n      int searched = 0;\n      int parentAddress = 0;\n\n      while(true) {\n        if (split && isFull()) {\n          parentAddress = splitNode(parentAddress);\n          setAddress(parentAddress);\n          --searched;\n        }\n\n        int i = search(valueHC);\n\n        ++searched;\n\n        if (isIndexLeaf()) {\n          btree.maxStepsSearched = Math.max(btree.maxStepsSearched, searched);\n          return i;\n        }\n\n        int address = i < 0 ? addressAt(-i - 1):addressAt(i + 1);\n        if (doSanityCheck) myAssert(address != 0);\n        parentAddress = this.address;\n        setAddress(-address);\n      }\n    }","commit_id":"532436a4e4f9478c1388800949ff1a9d13b9f59f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void processCell(EditorCell cell, final EditorContext editorContext, String smallPattern, final String tail) {\n    boolean sourceCellRemains = false;\n    INodeSubstituteInfo substituteInfo = cell.getSubstituteInfo();\n    if (substituteInfo == null) {\n      substituteInfo = new NullSubstituteInfo();\n    }\n\n    EditorCell cellForNewNode;\n    final SNode newNode;\n    if (cell instanceof EditorCell_Label &&\n        ((EditorCell_Label) cell).isValidText(smallPattern) && !\"\".equals(smallPattern)\n            && substituteInfo.hasExactlyNActions(smallPattern + tail, false, 0)) {\n      newNode = cell.getSNode();\n      cellForNewNode = cell;\n      sourceCellRemains = true;\n    } else if (canCompleteSmallPatternImmediately(substituteInfo, smallPattern, tail) ||\n      canCompleteSmallPatternImmediately(substituteInfo, smallPattern.trim(), tail)) {\n\n      if (canCompleteSmallPatternImmediately(substituteInfo, smallPattern.trim(), tail)) {\n        smallPattern = smallPattern.trim();\n      }\n\n      List<INodeSubstituteAction> matchingActions = substituteInfo.getMatchingActions(smallPattern, true);\n      INodeSubstituteAction item = matchingActions.get(0);\n      newNode = item.doSubstitute(smallPattern);\n      assert newNode != null;\n      cellForNewNode = editorContext.createNodeCellInAir(newNode, ourServiceEditorManager);\n      EditorCell errorCell = EditorUtil.findErrorCell(cellForNewNode);\n\n      if (errorCell != null && errorCell instanceof EditorCell_Label) {\n        editorContext.flushEvents();\n        new Runnable() {\n          public void run() {\n            EditorCell cellForNewNode = editorContext.getNodeEditorComponent().findNodeCell(newNode);\n            EditorCell_Label errorCell = (EditorCell_Label) EditorUtil.findErrorCell(cellForNewNode);\n            ((EditorCell_Label) errorCell).changeText(tail);\n            errorCell.setCaretPosition(tail.length());\n          }\n        }.run();\n        return;\n      }\n    } else if (canCompleteTheWholeStringImmediately(substituteInfo, smallPattern, tail) ||\n      canCompleteTheWholeStringImmediately(substituteInfo, smallPattern.trim(), tail)) {\n\n      if (canCompleteTheWholeStringImmediately(substituteInfo, smallPattern.trim(), tail)) {\n        smallPattern = smallPattern.trim();\n      }\n\n      List<INodeSubstituteAction> matchingActions = substituteInfo.getMatchingActions(smallPattern + tail, true);\n      INodeSubstituteAction item = matchingActions.get(0);\n      editorContext.selectWRTFocusPolicy(item.doSubstitute(smallPattern + tail));\n      return;\n    } else {\n      return;\n    }\n\n    EditorCellAction rtAction = EditorUtil.getCellAction(EditorUtil.findLastSelectableCell(cellForNewNode), EditorCellAction.RIGHT_TRANSFORM, editorContext);\n    if (rtAction == null) {\n      final CellInfo cellInfo = cellForNewNode.getCellInfo();\n\n      editorContext.flushEvents();\n\n      AbstractEditorComponent component = editorContext.getNodeEditorComponent();\n      EditorCell cellToSelect = cellInfo.findCell(component);\n      if (cellToSelect != null) {\n        EditorCell errorCell = EditorUtil.findErrorCell(cellToSelect);\n        if (errorCell instanceof EditorCell_Label) {\n          EditorCell_Label label = (EditorCell_Label) errorCell;\n          if (label.isEditable() && !(label instanceof EditorCell_Constant)) {\n            label.changeText(smallPattern + tail);\n          }\n          label.getRenderedTextLine().setCaretPositionToLast();\n        }\n      }\n      return;\n    }\n\n    rtAction.execute(editorContext);\n    final CellFinder cellFounder = new CellFinder(editorContext, newNode, tail);\n    EditorCell newCellForNewNode = editorContext.createNodeCellInAir(newNode, ourServiceEditorManager);\n\n    cellFounder.run(newCellForNewNode);\n    EditorCell foundCell = cellFounder.getFoundCell(); // found cell should be a rt hint cell\n\n    if (foundCell != null) {\n      INodeSubstituteInfo rtSubstituteInfo = foundCell.getSubstituteInfo();\n      if (rtSubstituteInfo == null) {\n        rtSubstituteInfo = new NullSubstituteInfo();\n      }\n      TypeChecker.getInstance().setTypeCheckingMode(TypeCheckingMode.COMPLETION);\n      List<INodeSubstituteAction> rtMatchingActions = rtSubstituteInfo.getMatchingActions(tail, true);\n      TypeChecker.getInstance().resetTypeCheckingMode();\n\n      if (sourceCellRemains) {\n        ((EditorCell_Label) cell).changeText(smallPattern);\n      }\n\n      cellFounder.setCallSelect(true);\n\n      if (!canCompleteSmallPatternImmediately(rtSubstituteInfo, tail, \"\")) { //don't execute non-unique action on RT hint cell\n        editorContext.flushEvents();\n        cellFounder.run();\n        return;\n      }\n\n      INodeSubstituteAction rtItem = rtMatchingActions.get(0);\n      final SNode yetNewNode = rtItem.doSubstitute(smallPattern);\n\n      editorContext.flushEvents();\n\n      AbstractEditorComponent editor = editorContext.getNodeEditorComponent();\n      EditorCell yetNewNodeCell = editor.findNodeCell(yetNewNode);\n      EditorCell errorOrEditableCell = EditorUtil.findErrorOrEditableCell(yetNewNodeCell);\n      editor.changeSelectionWRTFocusPolicy(errorOrEditableCell);\n    } else {\n      editorContext.flushEvents();\n      cellFounder.run();\n    }\n  }","id":60255,"modified_method":"private static void processCell(EditorCell cell, final EditorContext editorContext, String smallPattern, final String tail) {\n    boolean sourceCellRemains = false;\n    INodeSubstituteInfo substituteInfo = cell.getSubstituteInfo();\n    if (substituteInfo == null) {\n      substituteInfo = new NullSubstituteInfo();\n    }\n\n    EditorCell cellForNewNode;\n    final SNode newNode;\n    if (cell instanceof EditorCell_Label &&\n        ((EditorCell_Label) cell).isValidText(smallPattern) && !\"\".equals(smallPattern)\n            && substituteInfo.hasExactlyNActions(smallPattern + tail, false, 0)) {\n      newNode = cell.getSNode();\n      cellForNewNode = cell;\n      sourceCellRemains = true;\n    } else if (canCompleteSmallPatternImmediately(substituteInfo, smallPattern, tail) ||\n      canCompleteSmallPatternImmediately(substituteInfo, smallPattern.trim(), tail)) {\n\n      if (!canCompleteSmallPatternImmediately(substituteInfo, smallPattern, tail) &&\n        canCompleteSmallPatternImmediately(substituteInfo, smallPattern.trim(), tail)) {\n        smallPattern = smallPattern.trim();\n      }\n\n      List<INodeSubstituteAction> matchingActions = substituteInfo.getMatchingActions(smallPattern, true);\n      INodeSubstituteAction item = matchingActions.get(0);\n      newNode = item.doSubstitute(smallPattern);\n      assert newNode != null;\n      cellForNewNode = editorContext.createNodeCellInAir(newNode, ourServiceEditorManager);\n      EditorCell errorCell = EditorUtil.findErrorCell(cellForNewNode);\n\n      if (errorCell != null && errorCell instanceof EditorCell_Label) {\n        editorContext.flushEvents();\n        new Runnable() {\n          public void run() {\n            EditorCell cellForNewNode = editorContext.getNodeEditorComponent().findNodeCell(newNode);\n            EditorCell_Label errorCell = (EditorCell_Label) EditorUtil.findErrorCell(cellForNewNode);\n            ((EditorCell_Label) errorCell).changeText(tail);\n            errorCell.setCaretPosition(tail.length());\n          }\n        }.run();\n        return;\n      }\n    } else if (canCompleteTheWholeStringImmediately(substituteInfo, smallPattern, tail) ||\n      canCompleteTheWholeStringImmediately(substituteInfo, smallPattern.trim(), tail)) {\n\n      if (!canCompleteTheWholeStringImmediately(substituteInfo, smallPattern, tail) &&\n        canCompleteTheWholeStringImmediately(substituteInfo, smallPattern.trim(), tail)) {\n        smallPattern = smallPattern.trim();\n      }\n\n      List<INodeSubstituteAction> matchingActions = substituteInfo.getMatchingActions(smallPattern + tail, true);\n      INodeSubstituteAction item = matchingActions.get(0);\n      editorContext.selectWRTFocusPolicy(item.doSubstitute(smallPattern + tail));\n      return;\n    } else {\n      return;\n    }\n\n    EditorCellAction rtAction = EditorUtil.getCellAction(EditorUtil.findLastSelectableCell(cellForNewNode), EditorCellAction.RIGHT_TRANSFORM, editorContext);\n    if (rtAction == null) {\n      final CellInfo cellInfo = cellForNewNode.getCellInfo();\n\n      editorContext.flushEvents();\n\n      AbstractEditorComponent component = editorContext.getNodeEditorComponent();\n      EditorCell cellToSelect = cellInfo.findCell(component);\n      if (cellToSelect != null) {\n        EditorCell errorCell = EditorUtil.findErrorCell(cellToSelect);\n        if (errorCell instanceof EditorCell_Label) {\n          EditorCell_Label label = (EditorCell_Label) errorCell;\n          if (label.isEditable() && !(label instanceof EditorCell_Constant)) {\n            label.changeText(smallPattern + tail);\n          }\n          label.getRenderedTextLine().setCaretPositionToLast();\n        }\n      }\n      return;\n    }\n\n    rtAction.execute(editorContext);\n    final CellFinder cellFounder = new CellFinder(editorContext, newNode, tail);\n    EditorCell newCellForNewNode = editorContext.createNodeCellInAir(newNode, ourServiceEditorManager);\n\n    cellFounder.run(newCellForNewNode);\n    EditorCell foundCell = cellFounder.getFoundCell(); // found cell should be a rt hint cell\n\n    if (foundCell != null) {\n      INodeSubstituteInfo rtSubstituteInfo = foundCell.getSubstituteInfo();\n      if (rtSubstituteInfo == null) {\n        rtSubstituteInfo = new NullSubstituteInfo();\n      }\n      TypeChecker.getInstance().setTypeCheckingMode(TypeCheckingMode.COMPLETION);\n      List<INodeSubstituteAction> rtMatchingActions = rtSubstituteInfo.getMatchingActions(tail, true);\n      TypeChecker.getInstance().resetTypeCheckingMode();\n\n      if (sourceCellRemains) {\n        ((EditorCell_Label) cell).changeText(smallPattern);\n      }\n\n      cellFounder.setCallSelect(true);\n\n      if (!canCompleteSmallPatternImmediately(rtSubstituteInfo, tail, \"\")) { //don't execute non-unique action on RT hint cell\n        editorContext.flushEvents();\n        cellFounder.run();\n        return;\n      }\n\n      INodeSubstituteAction rtItem = rtMatchingActions.get(0);\n      final SNode yetNewNode = rtItem.doSubstitute(smallPattern);\n\n      editorContext.flushEvents();\n\n      AbstractEditorComponent editor = editorContext.getNodeEditorComponent();\n      EditorCell yetNewNodeCell = editor.findNodeCell(yetNewNode);\n      EditorCell errorOrEditableCell = EditorUtil.findErrorOrEditableCell(yetNewNodeCell);\n      editor.changeSelectionWRTFocusPolicy(errorOrEditableCell);\n    } else {\n      editorContext.flushEvents();\n      cellFounder.run();\n    }\n  }","commit_id":"70c3ac3c4d89f1c8fe89efca1ba8a738a9ba9a2e","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static void processCellAtStart(EditorCell_Label cell, final EditorContext editorContext, String head, String smallPattern) {\n    NodeSubstituteInfo info = cell.getSubstituteInfo();\n    if (info == null) {\n      info = new NullSubstituteInfo();\n    }\n    EditorCell cellForNewNode;\n    SNode newNode;\n    boolean sourceCellRemains = false;\n\n\n    if (cell.isValidText(smallPattern) && !\"\".equals(smallPattern)\n        && info.hasExactlyNActions(head + smallPattern, false, 0)) {\n      newNode = cell.getSNode();\n      cellForNewNode = cell;\n      sourceCellRemains = true;\n    } else if (canCompleteSmallPatternImmediately(info, smallPattern, \"\")) {\n      newNode = info.getMatchingActions(smallPattern, true).get(0).substitute(editorContext, smallPattern);\n      cellForNewNode = editorContext.createNodeCellInAir(newNode, ourServiceEditorManager);\n    } else if (canCompleteTheWholeStringImmediately(info, head + smallPattern) ||\n      canCompleteTheWholeStringImmediately(info, head + smallPattern.trim())) {\n\n      if (!canCompleteTheWholeStringImmediately(info, head + smallPattern) &&\n        canCompleteTheWholeStringImmediately(info, head + smallPattern.trim())) {\n        smallPattern = smallPattern.trim();\n      }\n\n      List<INodeSubstituteAction> matchingActions = info.getMatchingActions(head + smallPattern, true);\n      INodeSubstituteAction item = matchingActions.get(0);\n      item.substitute(editorContext, head + smallPattern);\n      return;\n    } else {\n      return;\n    }\n\n\n    EditorCellAction ltAction = cellForNewNode.findChild(CellFinders.LAST_SELECTABLE_LEAF, true).getApplicableCellAction(CellActionType.LEFT_TRANSFORM);\n    TypeChecker.getInstance().setTypeCheckingMode(TypeCheckingMode.COMPLETION);\n    boolean hasSideActions = hasSideActions(cellForNewNode, CellSide.LEFT, head);\n    TypeChecker.getInstance().resetTypeCheckingMode();\n    if (ltAction == null || !hasSideActions) {\n      CellInfo cellInfo = cellForNewNode.getCellInfo();\n      if (!sourceCellRemains) {\n        putTextInErrorChild(cellInfo, head + smallPattern, editorContext);\n      }\n      return;\n    }\n\n    if (sourceCellRemains) {\n      cell.changeText(smallPattern);\n      editorContext.getNodeEditorComponent().relayout();\n    }\n\n    ltAction.execute(editorContext);\n\n    EditorCell newCellForNewNode = editorContext.createNodeCellInAir(newNode, ourServiceEditorManager);\n    prepareSTCell(editorContext, newCellForNewNode, head);\n  }","id":60256,"modified_method":"private static void processCellAtStart(EditorCell_Label cell, final EditorContext editorContext, String head, String smallPattern) {\n    NodeSubstituteInfo info = cell.getSubstituteInfo();\n    if (info == null) {\n      info = new NullSubstituteInfo();\n    }\n    EditorCell cellForNewNode;\n    SNode newNode;\n    boolean sourceCellRemains = false;\n\n\n    if (cell.isValidText(smallPattern) && !\"\".equals(smallPattern)\n        && info.hasExactlyNActions(head + smallPattern, false, 0)) {\n      newNode = cell.getSNode();\n      cellForNewNode = cell;\n      sourceCellRemains = true;\n    } else if (canCompleteSmallPatternImmediately(info, smallPattern, \"\") &&\n      info.getMatchingActions(head, false).isEmpty()) {\n      \n      newNode = info.getMatchingActions(smallPattern, true).get(0).substitute(editorContext, smallPattern);\n      cellForNewNode = editorContext.createNodeCellInAir(newNode, ourServiceEditorManager);\n    } else if (canCompleteTheWholeStringImmediately(info, head + smallPattern) ||\n      canCompleteTheWholeStringImmediately(info, head + smallPattern.trim())) {\n\n      if (!canCompleteTheWholeStringImmediately(info, head + smallPattern) &&\n        canCompleteTheWholeStringImmediately(info, head + smallPattern.trim())) {\n        smallPattern = smallPattern.trim();\n      }\n\n      List<INodeSubstituteAction> matchingActions = info.getMatchingActions(head + smallPattern, true);\n      INodeSubstituteAction item = matchingActions.get(0);\n      item.substitute(editorContext, head + smallPattern);\n      return;\n    } else {\n      return;\n    }\n\n\n    EditorCellAction ltAction = cellForNewNode.findChild(CellFinders.LAST_SELECTABLE_LEAF, true).getApplicableCellAction(CellActionType.LEFT_TRANSFORM);\n    TypeChecker.getInstance().setTypeCheckingMode(TypeCheckingMode.COMPLETION);\n    boolean hasSideActions = hasSideActions(cellForNewNode, CellSide.LEFT, head);\n    TypeChecker.getInstance().resetTypeCheckingMode();\n    if (ltAction == null || !hasSideActions) {\n      CellInfo cellInfo = cellForNewNode.getCellInfo();\n      if (!sourceCellRemains) {\n        putTextInErrorChild(cellInfo, head + smallPattern, editorContext);\n      }\n      return;\n    }\n\n    if (sourceCellRemains) {\n      cell.changeText(smallPattern);\n      editorContext.getNodeEditorComponent().relayout();\n    }\n\n    ltAction.execute(editorContext);\n\n    EditorCell newCellForNewNode = editorContext.createNodeCellInAir(newNode, ourServiceEditorManager);\n    prepareSTCell(editorContext, newCellForNewNode, head);\n  }","commit_id":"7f66cb08034382f2a1da506384bfbb711c35fb25","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static void processSTHintCell(EditorCell_STHint cell, EditorContext editorContext, String pattern) {\n    NodeSubstituteInfo substituteInfo = cell.getSubstituteInfo();\n    String smallPattern = pattern.substring(0, pattern.length() - 1);\n    String tail = \"\" + pattern.charAt(pattern.length() - 1);\n    EditorCell nextCell = cell.getNextLeaf();\n    while (nextCell != null && !nextCell.isSelectable()) {\n      nextCell = nextCell.getNextLeaf();      \n    }\n\n    if (canCompleteSmallPatternImmediately(substituteInfo, pattern, \"\") ||\n      canCompleteSmallPatternImmediately(substituteInfo, trimLeft(pattern), \"\")) {\n\n      if (!canCompleteSmallPatternImmediately(substituteInfo, pattern, \"\")) {\n        pattern = trimLeft(pattern);\n      }\n\n      substituteInfo.getMatchingActions(pattern, true).get(0).substitute(editorContext, pattern);\n    } else if (pattern.length() > 0 && canCompleteSmallPatternImmediately(substituteInfo, smallPattern, tail)) {\n      List<INodeSubstituteAction> matchingActions = substituteInfo.getMatchingActions(smallPattern, true);\n      INodeSubstituteAction item = matchingActions.get(0);\n      SNode newNode = item.substitute(editorContext, smallPattern);\n      editorContext.flushEvents();\n      EditorCell cellForNewNode = editorContext.getNodeEditorComponent().findNodeCell(newNode);\n\n      EditorCell_Label target = null;\n      EditorCell errorOrEditable =  cellForNewNode.findChild(CellFinders.or(CellFinders.FIRST_ERROR, CellFinders.LAST_EDITABLE), true);\n      if (errorOrEditable instanceof EditorCell_Label) {\n        target = (EditorCell_Label) errorOrEditable;\n      }\n\n      if (target != null) {\n        target.changeText(tail);\n        target.end();\n\n        editorContext.getNodeEditorComponent().relayout();\n\n        if (target.isErrorState()) {\n          target.validate(true, false);\n        }\n\n        editorContext.flushEvents();\n\n        if (editorContext.getSelectedCell() instanceof EditorCell_Label) {\n          EditorCell_Label label = (EditorCell_Label) editorContext.getSelectedCell();\n          label.end();\n        }\n      }\n    } else if (substituteInfo.getMatchingActions(pattern, false).isEmpty() &&\n                substituteInfo.getMatchingActions(trimLeft(pattern), false).isEmpty() &&\n                nextCell != null && nextCell.isErrorState() && nextCell instanceof EditorCell_Label && ((EditorCell_Label) nextCell).isEditable()) {\n\n      cell.getSNode().removeRightTransformHint();\n\n      EditorCell_Label label = (EditorCell_Label) nextCell;\n      label.changeText(pattern);\n      label.end();\n      editorContext.getNodeEditorComponent().changeSelection(label);\n      editorContext.getNodeEditorComponent().relayout();\n    }\n  }","id":60257,"modified_method":"private static void processSTHintCell(EditorCell_STHint cell, EditorContext editorContext, String pattern) {\n    NodeSubstituteInfo substituteInfo = cell.getSubstituteInfo();\n    String smallPattern = pattern.substring(0, pattern.length() - 1);\n    String tail = \"\" + pattern.charAt(pattern.length() - 1);\n    EditorCell nextCell = cell.getNextLeaf();\n    while (nextCell != null && !nextCell.isSelectable()) {\n      nextCell = nextCell.getNextLeaf();      \n    }\n\n    if (canCompleteSmallPatternImmediately(substituteInfo, pattern, \"\") ||\n      canCompleteSmallPatternImmediately(substituteInfo, trimLeft(pattern), \"\")) {\n\n      if (!canCompleteSmallPatternImmediately(substituteInfo, pattern, \"\")) {\n        pattern = trimLeft(pattern);\n      }\n\n      substituteInfo.getMatchingActions(pattern, true).get(0).substitute(editorContext, pattern);\n    } else if (pattern.length() > 0 && (canCompleteSmallPatternImmediately(substituteInfo, smallPattern, tail) ||\n                canCompleteSmallPatternImmediately(substituteInfo, trimLeft(smallPattern), tail))) {\n\n      if (!canCompleteSmallPatternImmediately(substituteInfo, smallPattern, tail)) {\n        smallPattern = trimLeft(smallPattern);\n      }\n\n      List<INodeSubstituteAction> matchingActions = substituteInfo.getMatchingActions(smallPattern, true);\n      INodeSubstituteAction item = matchingActions.get(0);\n      SNode newNode = item.substitute(editorContext, smallPattern);\n      editorContext.flushEvents();\n      EditorCell cellForNewNode = editorContext.getNodeEditorComponent().findNodeCell(newNode);\n\n      EditorCell_Label target = null;\n      EditorCell errorOrEditable =  cellForNewNode.findChild(CellFinders.or(CellFinders.FIRST_ERROR, CellFinders.LAST_EDITABLE), true);\n      if (errorOrEditable instanceof EditorCell_Label) {\n        target = (EditorCell_Label) errorOrEditable;\n      }\n\n      if (target != null) {\n        target.changeText(tail);\n        target.end();\n\n        editorContext.getNodeEditorComponent().relayout();\n\n        if (target.isErrorState()) {\n          target.validate(true, false);\n        }\n\n        editorContext.flushEvents();\n\n        if (editorContext.getSelectedCell() instanceof EditorCell_Label) {\n          EditorCell_Label label = (EditorCell_Label) editorContext.getSelectedCell();\n          label.end();\n        }\n      }\n    } else if (substituteInfo.getMatchingActions(pattern, false).isEmpty() &&\n                substituteInfo.getMatchingActions(trimLeft(pattern), false).isEmpty() &&\n                nextCell != null && nextCell.isErrorState() && nextCell instanceof EditorCell_Label && ((EditorCell_Label) nextCell).isEditable()) {\n\n      cell.getSNode().removeRightTransformHint();\n\n      EditorCell_Label label = (EditorCell_Label) nextCell;\n      label.changeText(pattern);\n      label.end();\n      editorContext.getNodeEditorComponent().changeSelection(label);\n      editorContext.getNodeEditorComponent().relayout();\n    }\n  }","commit_id":"9360d697a1c1aac869c3a08d5e1d38daff2cef97","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * Initializes all components in this panel.\n     */\n    private void initComponents()\n    {\n        JPanel mainPanel = new JPanel(new BorderLayout());\n        JLabel callLabel = new JLabel();\n\n        JPanel buttonsPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));\n\n        SIPCommButton callButton = new SIPCommButton(\n            ImageLoader.getImage(ImageLoader.CALL_BUTTON_BG));\n\n        SIPCommButton hangupButton = new SIPCommButton(\n            ImageLoader.getImage(ImageLoader.HANGUP_BUTTON_BG));\n\n        mainPanel.setPreferredSize(new Dimension(400, 90));\n        mainPanel.setOpaque(false);\n        mainPanel.setBorder(BorderFactory.createCompoundBorder(\n            SIPCommBorders.getRoundBorder(),\n            BorderFactory.createEmptyBorder(20, 20, 20, 20)));\n\n        callButton.setName(CALL_BUTTON);\n        hangupButton.setName(HANGUP_BUTTON);\n\n        callButton.addActionListener(this);\n        hangupButton.addActionListener(this);\n\n        this.initCallLabel(callLabel);\n\n        this.getContentPane().add(mainPanel);\n\n        mainPanel.add(callLabel, BorderLayout.CENTER);\n        mainPanel.add(buttonsPanel, BorderLayout.EAST);\n\n        buttonsPanel.add(callButton);\n        buttonsPanel.add(hangupButton);\n    }","id":60258,"modified_method":"/**\n     * Initializes all components in this panel.\n     */\n    private void initComponents()\n    {\n        JPanel mainPanel = new JPanel(new GridBagLayout());\n        JLabel callLabel = new JLabel();\n\n        JPanel buttonsPanel = new TransparentPanel(new GridBagLayout());\n\n        SIPCommButton callButton = new SIPCommButton(\n            ImageLoader.getImage(ImageLoader.CALL_BUTTON_BG));\n\n        SIPCommButton hangupButton = new SIPCommButton(\n            ImageLoader.getImage(ImageLoader.HANGUP_BUTTON_BG));\n\n        mainPanel.setPreferredSize(new Dimension(400, 90));\n        mainPanel.setOpaque(false);\n        mainPanel.setBorder(BorderFactory.createEmptyBorder(20, 20, 20, 20));\n\n        callButton.setName(CALL_BUTTON);\n        hangupButton.setName(HANGUP_BUTTON);\n\n        callButton.addActionListener(this);\n        hangupButton.addActionListener(this);\n\n        this.initCallLabel(callLabel);\n\n        this.getContentPane().add(mainPanel);\n\n        GridBagConstraints mainConstraints = new GridBagConstraints();\n        mainConstraints.anchor = GridBagConstraints.WEST;\n        mainConstraints.gridx = 0;\n        mainConstraints.gridy = 0;\n        mainConstraints.weightx = 1;\n        mainPanel.add(callLabel, mainConstraints);\n        mainConstraints.anchor = GridBagConstraints.CENTER;\n        mainConstraints.gridx = 1;\n        mainConstraints.weightx = 0;\n        mainPanel.add(Box.createHorizontalStrut(HGAP), mainConstraints);\n        mainConstraints.anchor = GridBagConstraints.CENTER;\n        mainConstraints.gridx = 2;\n        mainConstraints.weightx = 0;\n        mainPanel.add(buttonsPanel, mainConstraints);\n\n        GridBagConstraints buttonConstraints = new GridBagConstraints();\n        buttonConstraints.gridx = 0;\n        buttonConstraints.gridy = 0;\n        buttonsPanel.add(callButton, buttonConstraints);\n        buttonConstraints.gridx = 1;\n        buttonsPanel.add(Box.createHorizontalStrut(HGAP));\n        buttonConstraints.gridx = 2;\n        buttonsPanel.add(hangupButton, buttonConstraints);\n    }","commit_id":"e3cd45fd6c0f0ebc2cb8aa2bcd7b1bec728ad7a3","url":"https://github.com/jitsi/jitsi"},{"original_method":"private void initGui() {\n    JComponent filler = new JComponent() {\n      @Override\n      public Dimension getPreferredSize() {\n        return myTextLabel.getPreferredSize();\n      }\n    };\n    setLayout(new BorderLayout());\n    setBorder(BorderFactory.createCompoundBorder(IdeBorderFactory.createBorder(),\n                                                 BorderFactory.createEmptyBorder(3, 20, 3, 20)));\n\n    add(myTextLabel, BorderLayout.WEST);\n    Box box = Box.createHorizontalBox();\n    box.add(Box.createHorizontalGlue());\n    JPanel panel = new JPanel(new GridLayout(1, myLabels.size(), 0, 0));\n    for (final JComponent myLabel : myLabels) {\n      panel.add(myLabel);\n    }\n    panel.setMaximumSize(panel.getPreferredSize());\n    box.add(panel);\n    box.add(Box.createHorizontalGlue());\n    add(box, BorderLayout.CENTER);\n\n    add(filler, BorderLayout.EAST);\n  }","id":60259,"modified_method":"private void initGui() {\n    JComponent filler = new JComponent() {\n      @Override\n      public Dimension getPreferredSize() {\n        return myTextLabel.getPreferredSize();\n      }\n    };\n    setLayout(new BorderLayout());\n    setBorder(BorderFactory.createEmptyBorder(3, 20, 3, 20));\n\n    add(myTextLabel, BorderLayout.WEST);\n    Box box = Box.createHorizontalBox();\n    box.add(Box.createHorizontalGlue());\n    JPanel panel = new JPanel(new GridLayout(1, myLabels.size(), 0, 0));\n    for (final JComponent myLabel : myLabels) {\n      panel.add(myLabel);\n    }\n    panel.setMaximumSize(panel.getPreferredSize());\n    box.add(panel);\n    box.add(Box.createHorizontalGlue());\n    add(box, BorderLayout.CENTER);\n\n    add(filler, BorderLayout.EAST);\n  }","commit_id":"c124c37fc1480ef8309bc674ba5a48c0a91bcfb9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Creates an instance of <tt>ChatSendPanel<\/tt>.\n     *\n     * @param chatPanel The parent <tt>ChatPanel<\/tt>.\n     */\n    public ChatSendPanel(ChatPanel chatPanel)\n    {\n        super(new BorderLayout(5, 0));\n\n        this.setBorder(BorderFactory.createEmptyBorder(3, 3, 3, 3));\n\n        sendButton = new JButton(\n            GuiActivator.getResources().getI18NString(\"service.gui.SEND\"));\n\n        this.chatPanel = chatPanel;\n\n        this.sendPanel.add(sendButton);\n\n        this.add(statusPanel, BorderLayout.CENTER);\n        this.add(sendPanel, BorderLayout.EAST);\n\n        this.sendButton.addActionListener(this);\n        this.sendButton.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\"service.gui.SEND\"));\n    }","id":60260,"modified_method":"/**\n     * Creates an instance of <tt>ChatSendPanel<\/tt>.\n     *\n     * @param chatPanel The parent <tt>ChatPanel<\/tt>.\n     */\n    public ChatSendPanel(ChatPanel chatPanel)\n    {\n        super(new BorderLayout(5, 0));\n\n        // MacOS would add a default border, so we just add a border for\n        // other operating systems.\n        if (!OSUtils.IS_MAC)\n            this.setBorder(BorderFactory.createEmptyBorder(3, 3, 3, 3));\n\n        sendButton = new JButton(\n            GuiActivator.getResources().getI18NString(\"service.gui.SEND\"));\n\n        this.chatPanel = chatPanel;\n\n        this.sendPanel.add(sendButton);\n\n        this.add(statusPanel, BorderLayout.CENTER);\n        this.add(sendPanel, BorderLayout.EAST);\n\n        this.sendButton.addActionListener(this);\n        this.sendButton.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\"service.gui.SEND\"));\n    }","commit_id":"eb143572d3f1e2c8d6fc3a09634678f3e8e4b13e","url":"https://github.com/jitsi/jitsi"},{"original_method":"public StatusPanel()\n    {\n        super(new BorderLayout());\n\n        this.setPreferredSize(new Dimension(100, getFontHeight() + 10));\n\n        this.setBorder(BorderFactory.createCompoundBorder(\n            SIPCommBorders.getRoundBorder(),\n            BorderFactory.createEmptyBorder(3, 3, 3, 3)));\n\n        this.add(statusLabel, BorderLayout.WEST);\n    }","id":60261,"modified_method":"public StatusPanel()\n    {\n        super(new BorderLayout());\n\n        this.setPreferredSize(new Dimension(100, getFontHeight() + 5));\n\n        this.setBorder(BorderFactory.createEmptyBorder(3, 3, 3, 3));\n\n        this.add(statusLabel, BorderLayout.WEST);\n    }","commit_id":"eb143572d3f1e2c8d6fc3a09634678f3e8e4b13e","url":"https://github.com/jitsi/jitsi"},{"original_method":"public LocalComponentMetaData getProject(String projectPath) {\n        ProjectInternal project = projectRegistry.getProject(projectPath);\n        return localComponentFactory.convert(new ComponentConverterSource(project.getConfigurations(), project.getModule()));\n    }","id":60262,"modified_method":"public LocalComponentMetaData getProject(String projectPath) {\n        ProjectInternal project = projectRegistry.getProject(projectPath);\n        if (project == null) {\n            return null;\n        }\n        return localComponentFactory.convert(new ComponentConverterSource(project.getConfigurations(), project.getModule()));\n    }","commit_id":"0e322e2bc231c2f12fab777118da7c11f20c4de1","url":"https://github.com/gradle/gradle"},{"original_method":"public void resolve(ComponentIdentifier identifier, ComponentOverrideMetadata componentOverrideMetadata, BuildableComponentResolveResult result) {\n        if (identifier instanceof ProjectComponentIdentifier) {\n            LocalComponentMetaData componentMetaData = projectComponentRegistry.getProject(((ProjectComponentIdentifier) identifier).getProjectPath());\n            result.resolved(componentMetaData.toResolveMetaData());\n        } else {\n            delegateComponentResolver.resolve(identifier, componentOverrideMetadata, result);\n        }\n    }","id":60263,"modified_method":"public void resolve(ComponentIdentifier identifier, ComponentOverrideMetadata componentOverrideMetadata, BuildableComponentResolveResult result) {\n        if (identifier instanceof ProjectComponentIdentifier) {\n            String projectPath = ((ProjectComponentIdentifier) identifier).getProjectPath();\n            LocalComponentMetaData componentMetaData = projectComponentRegistry.getProject(projectPath);\n            if (componentMetaData == null) {\n                result.failed(new ModuleVersionResolveException(new DefaultProjectComponentSelector(projectPath), \"project '\" + projectPath + \"' not found.\"));\n            } else {\n                result.resolved(componentMetaData.toResolveMetaData());\n            }\n        } else {\n            delegateComponentResolver.resolve(identifier, componentOverrideMetadata, result);\n        }\n    }","commit_id":"0e322e2bc231c2f12fab777118da7c11f20c4de1","url":"https://github.com/gradle/gradle"},{"original_method":"public void resolve(DependencyMetaData dependency, BuildableComponentIdResolveResult result) {\n        if (dependency.getSelector() instanceof ProjectComponentSelector) {\n            ProjectComponentSelector selector = (ProjectComponentSelector) dependency.getSelector();\n            LocalComponentMetaData componentMetaData = projectComponentRegistry.getProject(selector.getProjectPath());\n            result.resolved(componentMetaData.toResolveMetaData());\n        } else {\n            delegateIdResolver.resolve(dependency, result);\n        }\n    }","id":60264,"modified_method":"public void resolve(DependencyMetaData dependency, BuildableComponentIdResolveResult result) {\n        if (dependency.getSelector() instanceof ProjectComponentSelector) {\n            ProjectComponentSelector selector = (ProjectComponentSelector) dependency.getSelector();\n            String projectPath = selector.getProjectPath();\n            LocalComponentMetaData componentMetaData = projectComponentRegistry.getProject(projectPath);\n            if (componentMetaData == null) {\n                result.failed(new ModuleVersionResolveException(selector, \"project '\" + projectPath + \"' not found.\"));\n            } else {\n                result.resolved(componentMetaData.toResolveMetaData());\n            }\n        } else {\n            delegateIdResolver.resolve(dependency, result);\n        }\n    }","commit_id":"0e322e2bc231c2f12fab777118da7c11f20c4de1","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * Gets IDE project dependencies.\n     *\n     * @param configuration Configuration\n     * @param project Project\n     * @return IDE project dependencies\n     */\n    public List<IdeProjectDependency> getIdeProjectDependencies(Configuration configuration, Project project) {\n        ResolutionResult result = getIncomingResolutionResult(configuration);\n        final Set<ResolvedComponentResult> projectComponents = CollectionUtils.filter(result.getAllComponents(), new Spec<ResolvedComponentResult>() {\n            @Override\n            public boolean isSatisfiedBy(ResolvedComponentResult element) {\n                return element.getId() instanceof ProjectComponentIdentifier;\n            }\n        });\n        List<IdeProjectDependency> ideProjectDependencies = new ArrayList<IdeProjectDependency>();\n\n        for (ResolvedComponentResult projectComponent : projectComponents) {\n            Project resolvedProject = project.findProject(((ProjectComponentIdentifier) projectComponent.getId()).getProjectPath());\n            // TODO:DAZ Composite build means that we can't rely on finding a project in this way\n            if(resolvedProject != null && !resolvedProject.equals(project)) {\n                ideProjectDependencies.add(new IdeProjectDependency(configuration.getName(), resolvedProject));\n            }\n        }\n\n        return ideProjectDependencies;\n    }","id":60265,"modified_method":"/**\n     * Gets IDE project dependencies.\n     *\n     * @param configuration Configuration\n     * @param project Project\n     * @return IDE project dependencies\n     */\n    public List<IdeProjectDependency> getIdeProjectDependencies(Configuration configuration, Project project) {\n        ResolutionResult result = getIncomingResolutionResult(configuration);\n        final Set<ResolvedComponentResult> projectComponents = CollectionUtils.filter(result.getAllComponents(), new Spec<ResolvedComponentResult>() {\n            @Override\n            public boolean isSatisfiedBy(ResolvedComponentResult element) {\n                return element.getId() instanceof ProjectComponentIdentifier;\n            }\n        });\n        List<IdeProjectDependency> ideProjectDependencies = new ArrayList<IdeProjectDependency>();\n\n        for (ResolvedComponentResult projectComponent : projectComponents) {\n            String resolvedProjectPath = ((ProjectComponentIdentifier) projectComponent.getId()).getProjectPath();\n            if (project.getPath().equals(resolvedProjectPath)) {\n                continue;\n            }\n            Project resolvedProject = project.findProject(resolvedProjectPath);\n            if (resolvedProject == null) {\n                ideProjectDependencies.add(new IdeProjectDependency(configuration.getName(), resolvedProjectPath));\n            } else {\n                ideProjectDependencies.add(new IdeProjectDependency(configuration.getName(), resolvedProject));\n            }\n        }\n        return ideProjectDependencies;\n    }","commit_id":"5f98b0d7ac5c9c1007e134847d0a5fdb46850a0a","url":"https://github.com/gradle/gradle"},{"original_method":"public Collection<IdeProjectDependency> extractProjectDependencies(Project project, Collection<Configuration> plusConfigurations, Collection<Configuration> minusConfigurations) {\n        LinkedHashMap<Project, IdeProjectDependency> deps = new LinkedHashMap<Project, IdeProjectDependency>();\n\n        for (Configuration plusConfiguration : plusConfigurations) {\n            for (IdeProjectDependency dep : ideDependencyResolver.getIdeProjectDependencies(plusConfiguration, project)) {\n                deps.put(dep.getProject(), dep);\n            }\n        }\n\n        for (Configuration minusConfiguration : minusConfigurations) {\n            for (IdeProjectDependency dep : ideDependencyResolver.getIdeProjectDependencies(minusConfiguration, project)) {\n                deps.remove(dep.getProject());\n            }\n        }\n\n        return deps.values();\n    }","id":60266,"modified_method":"public Collection<IdeProjectDependency> extractProjectDependencies(Project project, Collection<Configuration> plusConfigurations, Collection<Configuration> minusConfigurations) {\n        LinkedHashMap<String, IdeProjectDependency> deps = new LinkedHashMap<String, IdeProjectDependency>();\n\n        for (Configuration plusConfiguration : plusConfigurations) {\n            for (IdeProjectDependency dep : ideDependencyResolver.getIdeProjectDependencies(plusConfiguration, project)) {\n                deps.put(dep.getProjectPath(), dep);\n            }\n        }\n\n        for (Configuration minusConfiguration : minusConfigurations) {\n            for (IdeProjectDependency dep : ideDependencyResolver.getIdeProjectDependencies(minusConfiguration, project)) {\n                deps.remove(dep.getProjectPath());\n            }\n        }\n\n        return deps.values();\n    }","commit_id":"5f98b0d7ac5c9c1007e134847d0a5fdb46850a0a","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        protected boolean isSameDependency(IdeDependency otherDependency) {\n            return otherDependency instanceof IdeProjectDependency && Objects.equal(ideDependency.getProject(), ((IdeProjectDependency) otherDependency).getProject());\n        }","id":60267,"modified_method":"@Override\n        protected boolean isSameDependency(IdeDependency otherDependency) {\n            return otherDependency instanceof IdeProjectDependency && Objects.equal(ideDependency.getProjectPath(), ((IdeProjectDependency) otherDependency).getProjectPath());\n        }","commit_id":"5f98b0d7ac5c9c1007e134847d0a5fdb46850a0a","url":"https://github.com/gradle/gradle"},{"original_method":"public String toString() {\n            return \"ProjectDependencyKey{\" + ideDependency.getProject() + \"}\";\n        }","id":60268,"modified_method":"public String toString() {\n            return \"ProjectDependencyKey{\" + ideDependency.getProjectPath() + \"}\";\n        }","commit_id":"5f98b0d7ac5c9c1007e134847d0a5fdb46850a0a","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        protected int dependencyHashCode() {\n            return ideDependency.getProject().hashCode();\n        }","id":60269,"modified_method":"@Override\n        protected int dependencyHashCode() {\n            return ideDependency.getProjectPath().hashCode();\n        }","commit_id":"5f98b0d7ac5c9c1007e134847d0a5fdb46850a0a","url":"https://github.com/gradle/gradle"},{"original_method":"public IdeProjectDependency(String declaredConfiguration, Project project) {\n        super(declaredConfiguration);\n        this.project = project;\n    }","id":60270,"modified_method":"public IdeProjectDependency(String declaredConfiguration, Project project) {\n        super(declaredConfiguration);\n        this.project = project;\n        this.projectPath = project.getPath();\n    }","commit_id":"5f98b0d7ac5c9c1007e134847d0a5fdb46850a0a","url":"https://github.com/gradle/gradle"},{"original_method":"public ModuleDependency create(IdeProjectDependency dependency, String scope) {\n        Project project = dependency.getProject();\n        if (project.getPlugins().hasPlugin(IdeaPlugin.class)) {\n            return new ModuleDependency(((IdeaModel) project.getExtensions().getByName(\"idea\")).getModule().getName(), scope);\n        } else {\n            return new ModuleDependency(project.getName(), scope);\n        }\n    }","id":60271,"modified_method":"public ModuleDependency create(IdeProjectDependency dependency, String scope) {\n        return new ModuleDependency(determineProjectName(dependency), scope);\n    }","commit_id":"5f98b0d7ac5c9c1007e134847d0a5fdb46850a0a","url":"https://github.com/gradle/gradle"},{"original_method":"public ProjectDependency build(IdeProjectDependency dependency) {\n        Project project = dependency.getProject();\n        return buildProjectDependency(determineProjectName(project), project.getPath(), dependency.getDeclaredConfiguration());\n    }","id":60272,"modified_method":"public ProjectDependency build(IdeProjectDependency dependency) {\n        return buildProjectDependency(determineProjectName(dependency), dependency.getProjectPath(), dependency.getDeclaredConfiguration());\n    }","commit_id":"5f98b0d7ac5c9c1007e134847d0a5fdb46850a0a","url":"https://github.com/gradle/gradle"},{"original_method":"private String determineProjectName(Project project) {\n        String name;\n        if (project.getPlugins().hasPlugin(EclipsePlugin.class)) {\n            name = project.getExtensions().getByType(EclipseModel.class).getProject().getName();\n        } else {\n            name = project.getName();\n        }\n        return name;\n    }","id":60273,"modified_method":"private String determineProjectName(IdeProjectDependency dependency) {\n        Project project = dependency.getProject();\n        if (project == null) {\n            return '/' + dependency.getProjectPath();\n        } else if (project.getPlugins().hasPlugin(EclipsePlugin.class)) {\n            return project.getExtensions().getByType(EclipseModel.class).getProject().getName();\n        } else {\n            return project.getName();\n        }\n    }","commit_id":"5f98b0d7ac5c9c1007e134847d0a5fdb46850a0a","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public int send(List<Argument> arguments) {\n        m_arguments = arguments;\n        String fileName = getFileName();\n        String lang = getLangClass();\n        String engine = getBsfEngine();\n        String[] extensions = getFileExtensions();\n\n        LOG.info(\"Loading notification script from file '{}'\", fileName);\n        File scriptFile = new File(fileName);\n        BSFManager bsfManager = new BSFManager();\n        int returnCode = -1;\n\n        try {\n\n            if(lang==null) lang = BSFManager.getLangFromFilename(fileName);\n\n            // Declare some beans that can be used inside the script                    \n            HashMap<String,String> results = new HashMap<String,String>();\n            bsfManager.declareBean(\"results\", results, Map.class);\n            declareBeans(bsfManager);\n\n            if(engine != null && lang != null && extensions != null && extensions.length > 0 ){\n                BSFManager.registerScriptingEngine(lang, engine, extensions);\n            }\n\n            if(scriptFile.exists() && scriptFile.canRead()){   \n                String code = IOUtils.getStringFromReader(new InputStreamReader(new FileInputStream(scriptFile), \"UTF-8\"));\n\n                // Check foot before firing\n                checkAberrantScriptBehaviors(code);\n\n                // Execute the script\n                bsfManager.exec(lang, \"BSFNotificationStrategy\", 0, 0, code);\n\n                // Check whether the script finished successfully\n                if (\"OK\".equals(results.get(\"status\"))) {\n                    LOG.info(\"Execution succeeded and successful status passed back for script '{}'\", scriptFile);\n                    returnCode = 0;\n                } else {\n                    LOG.warn(\"Execution succeeded for script '{}', but script did not indicate successful notification by putting an entry into the 'results' bean with key 'status' and value 'OK'\", scriptFile);\n                    returnCode = -1;\n                }\n            } else {\n                LOG.warn(\"Cannot locate or read BSF script file '{}'. Returning failure indication.\", fileName);\n                returnCode = -1;\n            }\n        } catch (BSFException e) {\n            LOG.warn(\"Execution of script '{}' failed with BSFException: {}\", scriptFile, e.getMessage(), e);\n            returnCode = -1;\n        } catch (FileNotFoundException e){\n            LOG.warn(\"Could not find BSF script file '{}'.\", fileName);\n            returnCode = -1;\n        } catch (IOException e) {\n            LOG.warn(\"Execution of script '{}' failed with IOException: {}\", scriptFile, e.getMessage(), e);\n            returnCode = -1;\n        } catch (Throwable e) {\n            // Catch any RuntimeException throws\n            LOG.warn(\"Execution of script '{}' failed with unexpected throwable: {}\", scriptFile, e.getMessage(), e);\n            returnCode = -1;\n        } finally { \n            bsfManager.terminate();\n        }\n\n        return returnCode;\n    }","id":60274,"modified_method":"@Override\n    public int send(List<Argument> arguments) {\n        m_arguments = arguments;\n        String fileName = getFileName();\n        String lang = getLangClass();\n        String engine = getBsfEngine();\n        String runType = getBsfRunType();\n        String[] extensions = getFileExtensions();\n\n        LOG.info(\"Loading notification script from file '{}'\", fileName);\n        File scriptFile = new File(fileName);\n        BSFManager bsfManager = new BSFManager();\n        int returnCode = -1;\n\n        try {\n\n            if(lang==null) lang = BSFManager.getLangFromFilename(fileName);\n\n            // Declare some beans that can be used inside the script                    \n            HashMap<String,String> results = new HashMap<String,String>();\n            bsfManager.declareBean(\"results\", results, Map.class);\n            declareBeans(bsfManager);\n\n            if(engine != null && lang != null && extensions != null && extensions.length > 0 ){\n                BSFManager.registerScriptingEngine(lang, engine, extensions);\n            }\n\n            if(scriptFile.exists() && scriptFile.canRead()){   \n                String code = IOUtils.getStringFromReader(new InputStreamReader(new FileInputStream(scriptFile), \"UTF-8\"));\n\n                // Check foot before firing\n                checkAberrantScriptBehaviors(code);\n\n                // Execute the script\n                if(\"eval\".equals(runType)){\n                    results.put(\"status\", bsfManager.eval(lang, \"BSFNotificationStrategy\", 0, 0, code).toString());  \n                }else if(\"exec\".equals(runType)){\n                    bsfManager.exec(lang, \"BSFNotificationStrategy\", 0, 0, code);\n                }else{\n                    LOG.warn(\"Invalid run-type parameter value '{}' for BSF notification script '{}'. Only 'eval' and 'exec' are supported.\", runType, scriptFile);\n                }\n\n                // Check whether the script finished successfully\n                if (\"OK\".equals(results.get(\"status\"))) {\n                    LOG.info(\"Execution succeeded and successful status passed back for script '{}'\", scriptFile);\n                    returnCode = 0;\n                } else {\n                    LOG.warn(\"Execution succeeded for script '{}', but script did not indicate successful notification by putting an entry into the 'results' bean with key 'status' and value 'OK'\", scriptFile);\n                    returnCode = -1;\n                }\n            } else {\n                LOG.warn(\"Cannot locate or read BSF script file '{}'. Returning failure indication.\", fileName);\n                returnCode = -1;\n            }\n        } catch (BSFException e) {\n            LOG.warn(\"Execution of script '{}' failed with BSFException: {}\", scriptFile, e.getMessage(), e);\n            returnCode = -1;\n        } catch (FileNotFoundException e){\n            LOG.warn(\"Could not find BSF script file '{}'.\", fileName);\n            returnCode = -1;\n        } catch (IOException e) {\n            LOG.warn(\"Execution of script '{}' failed with IOException: {}\", scriptFile, e.getMessage(), e);\n            returnCode = -1;\n        } catch (Throwable e) {\n            // Catch any RuntimeException throws\n            LOG.warn(\"Execution of script '{}' failed with unexpected throwable: {}\", scriptFile, e.getMessage(), e);\n            returnCode = -1;\n        } finally { \n            bsfManager.terminate();\n        }\n\n        return returnCode;\n    }","commit_id":"9b8d68c84cdeeb8c8c751350a681d9c5cfda0ba6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private static void doOpen(@NotNull File _dir, @Nullable File _toSelect) throws IOException, ExecutionException {\n    String dir = FileUtil.toCanonicalPath(_dir.getPath());\n    String toSelect = _toSelect == null ? null : FileUtil.toCanonicalPath(_toSelect.getPath());\n\n    if (SystemInfo.isWindows) {\n      String cmd = toSelect != null ? \"explorer /select,\" + toSelect : \"explorer /root,\" + dir;\n      Runtime.getRuntime().exec(cmd);  // no quoting/escaping is needed\n      return;\n    }\n\n    if (SystemInfo.isMac) {\n      GeneralCommandLine cmd = toSelect != null ? new GeneralCommandLine(\"open\", \"-R\", toSelect) : new GeneralCommandLine(\"open\", dir);\n      cmd.createProcess();\n      return;\n    }\n\n    if (canUseNautilus.getValue()) {\n      new GeneralCommandLine(\"nautilus\", toSelect != null ? toSelect : dir).createProcess();\n      return;\n    }\n\n    if (SystemInfo.hasXdgOpen()) {\n      new GeneralCommandLine(\"/usr/bin/xdg-open\", dir).createProcess();\n    }\n    else if (Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.OPEN)) {\n      Desktop.getDesktop().open(new File(dir));\n    }\n    else {\n      Messages.showErrorDialog(\"This action isn't supported on the current platform\", \"Cannot Open File\");\n    }\n  }","id":60275,"modified_method":"private static void doOpen(@NotNull File _dir, @Nullable File _toSelect) throws IOException, ExecutionException {\n    String dir = FileUtil.toCanonicalPath(_dir.getPath());\n    String toSelect = _toSelect != null ? FileUtil.toCanonicalPath(_toSelect.getPath()) : null;\n\n    if (SystemInfo.isWindows) {\n      String cmd = toSelect != null ? \"explorer /select,\" + toSelect : \"explorer /root,\" + dir;\n      Process process = Runtime.getRuntime().exec(cmd);  // no quoting/escaping is needed\n      new CapturingProcessHandler(process, null, cmd).runProcess().checkSuccess(LOG);\n    }\n    else if (SystemInfo.isMac) {\n      GeneralCommandLine cmd = toSelect != null ? new GeneralCommandLine(\"open\", \"-R\", toSelect) : new GeneralCommandLine(\"open\", dir);\n      ExecUtil.execAndGetOutput(cmd).checkSuccess(LOG);\n    }\n    else if (canUseNautilus.getValue()) {\n      GeneralCommandLine cmd = new GeneralCommandLine(\"nautilus\", toSelect != null ? toSelect : dir);\n      ExecUtil.execAndGetOutput(cmd).checkSuccess(LOG);\n    }\n    else if (SystemInfo.hasXdgOpen()) {\n      GeneralCommandLine cmd = new GeneralCommandLine(\"/usr/bin/xdg-open\", dir);\n      ExecUtil.execAndGetOutput(cmd).checkSuccess(LOG);\n    }\n    else if (Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.OPEN)) {\n      Desktop.getDesktop().open(new File(dir));\n    }\n    else {\n      Messages.showErrorDialog(\"This action isn't supported on the current platform\", \"Cannot Open File\");\n    }\n  }","commit_id":"9b08ed27ad66be6ad4a8125604c1a37a9ca459ac","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String encodeSpecialChars_Mac(String url)\n        throws java.io.IOException\n    {\n        // In case there are any special characters (e.g., Unicode chars) in the\n        // file name, we must first encode them for MacOSX (local files only?)\n        // FYI, MacOSX openURL uses UTF-8, NOT the native MacRoman encoding.\n        // URLEncoder encodes EVERYTHING other than alphas tho, so we need\n        // to put it back.\n\n        // But first we DECODE it, in case there are already any encodings,\n        // we don't want to double-encode.\n        url = java.net.URLDecoder.decode(url, \"UTF-8\");\n        if (DEBUG) System.err.println(\"  DECODE UTF [\" + url + \"]\");\n\n        url = java.net.URLEncoder.encode(url, \"UTF-8\"); // URLEncoder is way overzealous...\n        if (DEBUG) System.err.println(\"  ENCODE UTF [\" + url + \"]\");\n\n        // now decode the over-coded stuff so it looks sane (has colon & slashes, etc)\n        url = url.replaceAll(\"%3A\", \":\"); // be sure to do ALL of these...\n        url = url.replaceAll(\"%2F\", \"/\");\n        url = url.replaceAll(\"%3F\", \"?\");\n        url = url.replaceAll(\"%3D\", \"=\");\n        url = url.replaceAll(\"%26\", \"&\");\n        url = url.replaceAll(\"\\\\+\", \"%20\");\n        \n        if (DEBUG) System.err.println(\"     CLEANUP [\" + url + \"]\");\n\n        return url;\n    }","id":60276,"modified_method":"private static String encodeSpecialChars_Mac(String url, boolean isMailTo)\n        throws java.io.IOException\n    {\n        // In case there are any special characters (e.g., Unicode chars) in the\n        // file name, we must first encode them for MacOSX (local files only?)\n        // FYI, MacOSX openURL uses UTF-8, NOT the native MacRoman encoding.\n        // URLEncoder encodes EVERYTHING other than alphas tho, so we need\n        // to put it back.\n\n        // But first we DECODE it, in case there are already any encodings,\n        // we don't want to double-encode.\n        url = java.net.URLDecoder.decode(url, \"UTF-8\");\n        if (DEBUG) System.err.println(\"  DECODE UTF [\" + url + \"]\");\n\n        url = java.net.URLEncoder.encode(url, \"UTF-8\"); // URLEncoder is way overzealous...\n        if (DEBUG) System.err.println(\"  ENCODE UTF [\" + url + \"]\");\n\n            // now decode the over-coded stuff so it looks sane (has colon & slashes, etc)\n        url = url.replaceAll(\"%3A\", \":\"); // be sure to do ALL of these...\n        url = url.replaceAll(\"%2F\", \"/\");\n        url = url.replaceAll(\"%3F\", \"?\");\n        url = url.replaceAll(\"%3D\", \"=\");\n        url = url.replaceAll(\"%26\", \"&\");\n        url = url.replaceAll(\"\\\\+\", \"%20\"); // Mac doesn't undestand '+' I think\n\n        if (DEBUG) System.err.println(\"     CLEANUP [\" + url + \"]\");\n\n        return url;\n    }","commit_id":"744bd982187e85ddd02e01094294a673bc07d2be","url":"https://github.com/VUE/VUE"},{"original_method":"private static void openURL_Mac(String url)\n    {\n        boolean isLocalFile = \"file:\".equalsIgnoreCase(url.substring(0,5));\n        \n        if (DEBUG) System.err.println(\"openURL_Mac0 [\" + url + \"] isLocalFile=\" + isLocalFile);\n\n        if (isLocalFile) {\n            if (url.startsWith(\"file:////\")) {\n                // don't think we have to do this, but just in case\n                // (was getting a complaint and couldn't tell if this was why or not,\n                // so now we won't see it)\n                url = \"file:///\" + url.substring(9);\n            }\n        }\n\n        try {\n            url = encodeSpecialChars_Mac(url);\n        } catch (Throwable t) {\n            printStackTrace(t);\n        }\n\n        // In Mac OS X, local files MUST have %20 and NO spaces in the URL's -- reverse of Windows.\n        // But enforcing this for regular HTTP URL's breaks them: turns existing %20's into %2520's\n\n        // If no protocol in the URL string, assume it's a pathname.  Normally, there\n        // would be nothing to do as openURL handles that fine on MacOSX, unless it's\n        // not absolute, it which case we make it absolute by assuming the users home\n        // directory.\n        \n        if (url.indexOf(':') < 0 && !url.startsWith(\"/\")) {\n            // Hack to make relative references relative to user home directory.  OSX\n            // won't default to use current directory for a relative references, so \n            // we're prepending the home directory manually as a bail out try-for-it.\n            url = \"file://\" + System.getProperty(\"user.home\") + \"/\" + url;\n            if (DEBUG) System.err.println(\"    OUM HOME [\" + url + \"]\");\n        }\n\n        execMacOpenURL(url);\n    }","id":60277,"modified_method":"private static void openURL_Mac(String url, boolean isLocalFile, boolean isMailTo)\n    {\n        if (DEBUG) System.err.println(\"openURL_Mac0 [\" + url + \"]\");\n\n        if (isLocalFile) {\n            if (url.startsWith(\"file:////\")) {\n                // don't think we have to do this, but just in case\n                // (was getting a complaint and couldn't tell if this was why or not,\n                // so now we won't see it)\n                url = \"file:///\" + url.substring(9);\n            }\n        }\n\n        if (isMailTo) {\n//             final String flatURL = url.toLowerCase();\n//             final int queryIndex = flatURL.indexOf('?') + 1;\n//             if (queryIndex > 1) {\n//                 final String query = flatURL.substring(queryIndex);\n//                 if (DEBUG) System.out.println(\"QUERY: [\" + query + \"]\");\n//                 final int subjectIndex = query.indexOf(\"subject=\");\n//             }\n            \n            //url = url.replaceAll(\" \", \"%20\");\n//             try {\n//                 url = URLEncoder.encode(url, \"UTF-8\");\n//             } catch (Throwable t) {\n//                 printStackTrace(t);\n//             }\n        } else {\n            try {\n                url = encodeSpecialChars_Mac(url, isMailTo);\n            } catch (Throwable t) {\n                printStackTrace(t);\n            }\n        }\n\n        // In Mac OS X, local files MUST have %20 and NO spaces in the URL's -- reverse of Windows.\n        // But enforcing this for regular HTTP URL's breaks them: turns existing %20's into %2520's\n\n        // If no protocol in the URL string, assume it's a pathname.  Normally, there\n        // would be nothing to do as openURL handles that fine on MacOSX, unless it's\n        // not absolute, it which case we make it absolute by assuming the users home\n        // directory.\n        \n        if (!isMailTo && url.indexOf(':') < 0 && !url.startsWith(\"/\")) {\n            // Hack to make relative references relative to user home directory.  OSX\n            // won't default to use current directory for a relative references, so \n            // we're prepending the home directory manually as a bail out try-for-it.\n            url = \"file://\" + System.getProperty(\"user.home\") + \"/\" + url;\n            if (DEBUG) System.err.println(\"    OUM HOME [\" + url + \"]\");\n        }\n\n        execMacOpenURL(url);\n    }","commit_id":"744bd982187e85ddd02e01094294a673bc07d2be","url":"https://github.com/VUE/VUE"},{"original_method":"public static void openURL(String platformURL)\n        throws java.io.IOException\n    {\n        if (isMacPlatform())\n            openURL_Mac(platformURL);\n        else if (isUnixPlatform())\n            openURL_Unix(platformURL);\n        else // default is a windows platform\n            openURL_Windows(platformURL);\n    }","id":60278,"modified_method":"/** @param url -- a url assumed to be in the platform default format (e.g., it may be\n     * formatted in a way only understood on the current platform).\n     */\n    public static void openURL(String url)\n        throws java.io.IOException\n    {\n        boolean isLocalFile = url.length() >= 5 && \"file:\".equalsIgnoreCase(url.substring(0,5));\n        boolean isMailTo = url.length() >= 7 && \"mailto:\".equalsIgnoreCase(url.substring(0,7));\n\n        if (DEBUG) System.err.println(\"openURL_PLAT [\" + url + \"] isLocalFile=\" + isLocalFile + \" isMailTo=\" + isMailTo);\n        \n        if (isMacPlatform())\n            openURL_Mac(url, isLocalFile, isMailTo);\n        else if (isUnixPlatform())\n            openURL_Unix(url, isLocalFile, isMailTo);\n        else // default is a windows platform\n            openURL_Windows(url, isLocalFile, isMailTo);\n    }","commit_id":"744bd982187e85ddd02e01094294a673bc07d2be","url":"https://github.com/VUE/VUE"},{"original_method":"public static void main(String args[])\n        throws Exception\n    {\n        int tries = 1;\n        for (int i = 0; i < tries; i++) {\n            if (i > 0)\n                Thread.sleep(2000);\n            System.err.print(\"Internet is reachable (DNS available): \");\n            System.err.println(\"\" + isInternetReachable());\n        }\n        \n        Enumeration nie = NetworkInterface.getNetworkInterfaces();\n        while (nie.hasMoreElements()) {\n            NetworkInterface ni = (NetworkInterface) nie.nextElement();\n            System.err.println(\"\\nNetwork Interface[\" + ni + \"]\");\n            //Enumeration ie = ni.get\n            \n        }\n\n        //System.err.println(\"ServerSocket: \" + new ServerSocket(0)); // not sensitive to network availability\n      \n       if (false && args.length > 0 && args[0].startsWith(\"-\")) {\n            String host = args[0].substring(1);\n            InetAddress[] ips = InetAddress.getAllByName(host);\n            System.out.println(host + \" IP's: \" + Arrays.asList(ips));\n            System.exit(0);\n        }\n        \n        \n        //System.out.println(\"cursor16 \" + java.awt.Toolkit.getDefaultToolkit().getBestCursorSize(16,16));\n        //System.out.println(\"cursor24 \" + java.awt.Toolkit.getDefaultToolkit().getBestCursorSize(24,24));\n        //System.out.println(\"cursor32 \" + java.awt.Toolkit.getDefaultToolkit().getBestCursorSize(32,32));\n                                       //.list(System.out);\n\n        DEBUG = true;\n        // TESTING CODE\n        System.out.println(\"Default JVM character encoding for this platform: \" +\n                           (new java.io.OutputStreamWriter(new java.io.ByteArrayOutputStream())).getEncoding());\n            \n        if (args.length > 0 && args[0].equals(\"-charsets\")) {\n            Map cs = java.nio.charset.Charset.availableCharsets();\n            //System.out.println(\"Charsets: \" + cs.values());\n            Iterator i = cs.values().iterator();\n            while (i.hasNext()) {\n                java.nio.charset.Charset o = (java.nio.charset.Charset) i.next();\n                System.out.println(o\n                                   + \"\\t\" + o.aliases()\n                                   //+ \" \" + o.getClass()\n                                   );\n            }\n            System.exit(0);\n        }\n\n        String test = \"file:///Users/sfraize/Desktop/CupChevron.png\";\n        \n        if (args.length == 1) {\n            if (\"test\".equals(args[0])) {\n                execMacOpenURL(test);\n                openURL(test);\n            } else\n                openURL(args[0]);\n            //else\n            //test_OpenURL();\n        } else if (args.length == 2) {\n            try {\n                // Even tho we tried putting blackships.jar in two different places in java.library.path, it claimed it couldn't find it.\n                System.loadLibrary(\"blackships.jar\");\n                java.net.URL url = new java.net.URL(\"blackships/large/02_010b_DutchFamily_l.jpg\");\n                System.out.println(\"URL: \" + url);\n                System.out.println(\"CONTENT: \" + url.getContent());\n                // cannot build a file object from a URL\n                //java.net.URL url = new java.net.URL(\"jar:file:/VUE/src/VUE-core.jar!/tufts/vue/images/pathway_hide_on.gif\");\n                //java.net.URI uri = new java.net.URI(url.toString());\n                //java.io.File f = new java.io.File(uri);\n                //System.out.println(\"File \" + f + \" has length \" + f.length() + \" exists=\" + f.exists());\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        } else if (args.length == 3) {\n            JarFile jar = new JarFile(args[0]);\n            System.out.println(\"Got jar \" + jar);\n            Enumeration e = jar.entries();\n            while (e.hasMoreElements()) {\n                JarEntry entry = (JarEntry) e.nextElement();\n                long size = entry.getSize();\n                System.out.println(\"Got entry \" + entry + \"  size=\" + size);\n                if (entry.getComment() != null)\n                    System.out.println(\"\\tcomment[\" + entry.getComment() + \"]\");\n                    byte[] extra = entry.getExtra();\n                    if (extra != null) {\n                        System.out.println(\"\\textra len=\" + extra.length + \" [\" + extra + \"]\");\n                    }\n                if (entry.getName().endsWith(\"MANIFEST.MF\")) {\n                    java.io.InputStream in = jar.getInputStream(entry);\n                    byte[] data = new byte[(int)size];\n                    in.read(data);\n                    System.out.println(\"Contents[\" + new String(data) + \"]\");\n                }\n            }\n                \n        } else {\n            Hashtable props = System.getProperties();\n            Enumeration e = props.keys();\n            while (e.hasMoreElements()) {\n                Object key = e.nextElement();\n                //System.out.println(\"\u001b[1;36m\" + key + \"\u001b[m=\" + props.get(key));\n                System.out.println(key + \"=\" + props.get(key));\n            }\n        }\n        \n        System.exit(0);\n    }","id":60279,"modified_method":"public static void main(String args[])\n        throws Exception\n    {\n\n        if (true) {\n            openURL(makeQueryURL(\"MAILTO:foo@foobar.com\",\n                                 \n                                 \"subject\", \"VUE Log Report\",\n                                 \n                                 //\"attachment\", \"c:\\\\\\\\foo.txt\"\n                                 //,\n                                 \n                                 \"body\",\n                                 \"I am the body.  Spic & Span?\"\n                                 + \"\\nfoo@bar.com\"\n                                 + \"\\nfile://local/file/\"\n                                 + \"\\n\\\\\\\\.psf\\\\foobie\\\\\"\n                                 + \"\\ncolons:are:no:problem\"\n\n\n+ \"\\nVUE 2007-06-25 18:32:43,187 [main] INFO   Startup; build: June 25 2007 at 1523 by sfraize on Mac OS X 10.4.10 i386 JVM 1.5.0_07-164\"\n+ \"\\nVUE 2007-06-25 18:32:43,197 [main] INFO   Running in Java VM: 1.5.0_11-b03; MaxMemory(-Xmx)=381.1M, CurMemory(-Xms)=1.9M\"\n+ \"\\nVUE 2007-06-25 18:32:43,197 [main] INFO   VUE version: 2.0 alpha-x\"\n+ \"\\nVUE 2007-06-25 18:32:43,197 [main] INFO   Current Working Directory: \\\\\\\\.psf\\\\vue\"\n+ \"\\nVUE 2007-06-25 18:32:43,197 [main] INFO   User/host: Scott Fraize@null\"\n+ \"\\nVUE 2007-06-25 18:32:43,197 [main] DEBUG GUI init\"\n+ \"\\nVUE 2007-06-25 18:32:43,257 [main] DEBUG GUI LAF  name: Windows\"\n+ \"\\nVUE 2007-06-25 18:32:43,257 [main] DEBUG GUI LAF descr: The Microsoft Windows Look and Feel\"\n+ \"\\nVUE 2007-06-25 18:32:43,257 [main] DEBUG GUI LAF class: class com.sun.java.swing.plaf.windows.WindowsLookAndFeel\"\n+ \"\\nVUE 2007-06-25 18:32:47,523 [main] DEBUG  loading disk cache...\"\n+ \"\\nVUE 2007-06-25 18:32:47,784 [main] DEBUG  Got cache directory: C:\\\\Documents and Settings\\\\Scott Fraize\\\\vue_2\\\\cache\"\n+ \"\\nVUE 2007-06-25 18:32:47,784 [main] DEBUG  listing disk cache...\"\n+ \"\\nVUE 2007-06-25 18:32:47,784 [main] DEBUG  listing disk cache: done; entries=21\"\n+ \"\\nVUE 2007-06-25 18:32:47,934 [main] DEBUG  loading disk cache: done\"\n+ \"\\nVUE 2007-06-25 18:32:48,064 [main] DEBUG  loading fonts.\"\n+ \"XXXXXXX\"\n+ \"XXXXXXX\"\n+ \"XXXXXXX\"\n+ \"0\"\n+ \"1\" // 2064\n+ \"2\" // 2065\n\n                                 + \"\\n\\nEnd.\\n\"\n                                 ));\n            System.exit(0);\n        }\n                         \n\n    \n        if (args.length > 0 && \"network\".equals(args[0])) {\n            int tries = 1;\n            for (int i = 0; i < tries; i++) {\n                if (i > 0)\n                    Thread.sleep(2000);\n                System.err.print(\"Internet is reachable (DNS available): \");\n                System.err.println(\"\" + isInternetReachable());\n            }\n        \n            Enumeration nie = NetworkInterface.getNetworkInterfaces();\n            while (nie.hasMoreElements()) {\n                NetworkInterface ni = (NetworkInterface) nie.nextElement();\n                System.err.println(\"\\nNetwork Interface[\" + ni + \"]\");\n                //Enumeration ie = ni.get\n            \n            }\n            System.exit(0);\n        }\n\n        //System.err.println(\"ServerSocket: \" + new ServerSocket(0)); // not sensitive to network availability\n      \n       if (false && args.length > 0 && args[0].startsWith(\"-\")) {\n            String host = args[0].substring(1);\n            InetAddress[] ips = InetAddress.getAllByName(host);\n            System.out.println(host + \" IP's: \" + Arrays.asList(ips));\n            System.exit(0);\n        }\n        \n        \n        //System.out.println(\"cursor16 \" + java.awt.Toolkit.getDefaultToolkit().getBestCursorSize(16,16));\n        //System.out.println(\"cursor24 \" + java.awt.Toolkit.getDefaultToolkit().getBestCursorSize(24,24));\n        //System.out.println(\"cursor32 \" + java.awt.Toolkit.getDefaultToolkit().getBestCursorSize(32,32));\n                                       //.list(System.out);\n\n        DEBUG = true;\n        // TESTING CODE\n        System.out.println(\"Default JVM character encoding for this platform: \" +\n                           (new java.io.OutputStreamWriter(new java.io.ByteArrayOutputStream())).getEncoding());\n            \n        if (args.length > 0 && args[0].equals(\"-charsets\")) {\n            Map cs = java.nio.charset.Charset.availableCharsets();\n            //System.out.println(\"Charsets: \" + cs.values());\n            Iterator i = cs.values().iterator();\n            while (i.hasNext()) {\n                java.nio.charset.Charset o = (java.nio.charset.Charset) i.next();\n                System.out.println(o\n                                   + \"\\t\" + o.aliases()\n                                   //+ \" \" + o.getClass()\n                                   );\n            }\n            System.exit(0);\n        }\n\n        String test = \"file:///Users/sfraize/Desktop/CupChevron.png\";\n        \n        if (args.length == 1) {\n            if (\"test\".equals(args[0])) {\n                execMacOpenURL(test);\n                openURL(test);\n            } else\n                openURL(args[0]);\n            //else\n            //test_OpenURL();\n        } else if (args.length == 2) {\n            try {\n                // Even tho we tried putting blackships.jar in two different places in java.library.path, it claimed it couldn't find it.\n                System.loadLibrary(\"blackships.jar\");\n                java.net.URL url = new java.net.URL(\"blackships/large/02_010b_DutchFamily_l.jpg\");\n                System.out.println(\"URL: \" + url);\n                System.out.println(\"CONTENT: \" + url.getContent());\n                // cannot build a file object from a URL\n                //java.net.URL url = new java.net.URL(\"jar:file:/VUE/src/VUE-core.jar!/tufts/vue/images/pathway_hide_on.gif\");\n                //java.net.URI uri = new java.net.URI(url.toString());\n                //java.io.File f = new java.io.File(uri);\n                //System.out.println(\"File \" + f + \" has length \" + f.length() + \" exists=\" + f.exists());\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        } else if (args.length == 3) {\n            JarFile jar = new JarFile(args[0]);\n            System.out.println(\"Got jar \" + jar);\n            Enumeration e = jar.entries();\n            while (e.hasMoreElements()) {\n                JarEntry entry = (JarEntry) e.nextElement();\n                long size = entry.getSize();\n                System.out.println(\"Got entry \" + entry + \"  size=\" + size);\n                if (entry.getComment() != null)\n                    System.out.println(\"\\tcomment[\" + entry.getComment() + \"]\");\n                    byte[] extra = entry.getExtra();\n                    if (extra != null) {\n                        System.out.println(\"\\textra len=\" + extra.length + \" [\" + extra + \"]\");\n                    }\n                if (entry.getName().endsWith(\"MANIFEST.MF\")) {\n                    java.io.InputStream in = jar.getInputStream(entry);\n                    byte[] data = new byte[(int)size];\n                    in.read(data);\n                    System.out.println(\"Contents[\" + new String(data) + \"]\");\n                }\n            }\n                \n        } else {\n            Hashtable props = System.getProperties();\n            Enumeration e = props.keys();\n            while (e.hasMoreElements()) {\n                Object key = e.nextElement();\n                //System.out.println(\"\u001b[1;36m\" + key + \"\u001b[m=\" + props.get(key));\n                System.out.println(key + \"=\" + props.get(key));\n            }\n        }\n        \n        System.exit(0);\n    }","commit_id":"744bd982187e85ddd02e01094294a673bc07d2be","url":"https://github.com/VUE/VUE"},{"original_method":"public GroupIterator() {}","id":60280,"modified_method":"private static void openURL_Unix(String url, boolean isLocalFile, boolean isMailTo)\n        throws java.io.IOException\n    {\n        // For now we just assume Netscape is installed.\n\n        // todo: run down list of netscape, mozilla, konqueror (KDE\n        // browser), gnome version?  KDE/Gnome may have their own\n        // services for getting a default browser.\n        \n    \t/*    \t \n    \tThe problem I had with my 2 linux installations was that even though netscape wasn't \n    \tinstalled the distribution provided a symlink named netscape which pointed to firefox\n    \thowever firefox couldn't interpet the netscape parameters.  So below I've modified it\n    \tto try to load firefox first and then if that fails load netscape, i suppose konqueror\n    \tshould be in the mix too maybe but this is better than it was and catches alot of cases.\n    \t*/\n    \tProcess process = null;\n    \ttry\n    \t{\n    \t\tprocess = Runtime.getRuntime().exec(new String[] { \"firefox\", url});\n    \t}\n    \tcatch (java.io.IOException ioe)\n    \t{\n    \t\t//firefox not available try netscape instead.\n    \t\tprocess = Runtime.getRuntime().exec(new String[] { \"netscape\",\n                    \"-remove\",\n                    \"'openURL('\" + url + \"')\" });\n    \t}\n        out(\"process: \" + process);\n        \n// Can't wait for process to complete!  Browser is left running...\n//         try {\n//             int exitCode = process.waitFor();\n//             if (exitCode != 0)\t// if Netscape was not open\n//                 Runtime.getRuntime().exec(new String[] { \"netscape\", url });\n//         } catch (InterruptedException e) {\n//             java.io.IOException ioe =  new java.io.IOException();\n//             ioe.initCause(e);\n//             throw ioe;\n//         }\n    }","commit_id":"744bd982187e85ddd02e01094294a673bc07d2be","url":"https://github.com/VUE/VUE"},{"original_method":"private static void execMacOpenURL(String url)\n    {\n        if (getJavaVersion() >= 1.4f) {\n            // Can't call this directly because wont compile on the PC\n            //com.apple.eio.FileManager.openURL(url);\n            \n            if (macOpenURL_Method == null) {\n                try {\n                    Class macFileManager = Class.forName(\"com.apple.eio.FileManager\");\n                    //Class macFileManager = ClassLoader.getSystemClassLoader().loadClass(\"com.apple.eio.FileManager\");\n                    macOpenURL_Method = macFileManager.getMethod(\"openURL\", new Class[] { String.class });\n                } catch (Exception e) {\n                    System.err.println(\"Failed to find Mac FileManager or openURL method: will not be able to display URL content.\");\n                    e.printStackTrace();\n                    throw new UnsupportedOperationException(\"com.apple.eio.FileManager:openURL \" + e);\n                }\n            }\n            \n            if (macOpenURL_Method != null) {\n                try {\n                    macOpenURL_Method.invoke(null, new Object[] { url });\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    throw new UnsupportedOperationException(\"com.apple.eio.FileManager.openURL \" + e);\n                }\n            } else\n                throw new UnsupportedOperationException(\"openURL_Mac\");\n\n\n        } else {\n            throw new UnsupportedOperationException(\"mac java <= 1.3 openURL unimplemented\");\n            // put this back if want to suppor mac java 1.3\n            // this has been deprecated in mac java 1.4, so\n            // just ignore the warning if using a 1.4 or beyond\n            // compiler\n            //    com.apple.mrj.MRJFileUtils.openURL(url);\n        }\n\n        if (DEBUG) System.err.println(\"execMacOpenURL returns (\" + url + \")\");\n        \n    }","id":60281,"modified_method":"private static void execMacOpenURL(String url)\n    {\n        if (getJavaVersion() >= 1.4f) {\n            // Can't call this directly because wont compile on the PC\n            //com.apple.eio.FileManager.openURL(url);\n            \n            if (macOpenURL_Method == null) {\n                try {\n                    Class macFileManager = Class.forName(\"com.apple.eio.FileManager\");\n                    //Class macFileManager = ClassLoader.getSystemClassLoader().loadClass(\"com.apple.eio.FileManager\");\n                    macOpenURL_Method = macFileManager.getMethod(\"openURL\", new Class[] { String.class });\n                } catch (Exception e) {\n                    System.err.println(\"Failed to find Mac FileManager or openURL method: will not be able to display URL content.\");\n                    e.printStackTrace();\n                    throw new UnsupportedOperationException(\"com.apple.eio.FileManager:openURL \" + e);\n                }\n            }\n            \n            if (macOpenURL_Method != null) {\n                try {\n                    macOpenURL_Method.invoke(null, new Object[] { url });\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    throw new UnsupportedOperationException(\"com.apple.eio.FileManager.openURL \" + e);\n                }\n            } else\n                throw new UnsupportedOperationException(\"openURL_Mac\");\n\n\n        } else {\n            throw new UnsupportedOperationException(\"mac java <= 1.3 openURL unimplemented\");\n            // put this back if want to suppor mac java 1.3\n            // this has been deprecated in mac java 1.4, so\n            // just ignore the warning if using a 1.4 or beyond\n            // compiler\n            //    com.apple.mrj.MRJFileUtils.openURL(url);\n        }\n\n        if (DEBUG) System.err.println(\"execMacOpenURL returns for (\" + url + \")\");\n        \n    }","commit_id":"744bd982187e85ddd02e01094294a673bc07d2be","url":"https://github.com/VUE/VUE"},{"original_method":"private static void openURL_Windows(String url)\n        throws java.io.IOException\n    {\n        System.err.println(\"openURL_Win  [\" + url + \"]\");\n\n        // On at least Windows 2000, %20's don't work when given to url.dll FileProtocolHandler\n        // (Should be using some kind of URLProtocolHanlder ?)\n        \n        // Also at least Win2K: file:///C:/foo/bar.html works, but start that with file:/ or file://\n        // and it DOES NOT work -- you MUST have the three slashes, OR, you can have NO SLASHES,\n        // and it will work... (file:C:/foo/bar.html)\n        // ALSO, file:// or // file:/// works BY ITSELF (file:/ by itself still doesn't work).\n        \n        //url = url.replaceAll(\"%20\", \" \");\n        url = decodeURL(url);\n        url = decodeURL(url); // run twice in case any %2520 double encoded spaces\n        if (url.toLowerCase().startsWith(\"file:\")) {\n            // below works, but we're doing a full conversion to windows path names now\n            //url = url.replaceFirst(\"^file:/+\", \"file:\");\n            url = url.replaceFirst(\"^file:/+\", \"\");\n            url = url.replace('/', '\\\\');\n            char c1 = 0;\n            try { c1 = url.charAt(1); } catch (StringIndexOutOfBoundsException e) {}\n            if (c1 == ':' || c1 == '|') {\n                // Windows drive letter specification, e.g., \"C:\".\n                // Also, I've seen D|/dir/file.txt in a shortcut file, so we allow that too.\n                // In any case, we do noting: this string should be workable to url.dll\n            } else {\n                // if this does NOT start with a drive specification, assume\n                // the first component is a host for a windows network\n                // drive, and thus we have to pre-pend \\\\ to it, to get \\\\host\\file\n                url = \"\\\\\\\\\" + url; \n            }\n            // at this point, \"url\" is really just a local windows file\n            // in full windows syntax (backslashes, drive specs, etc)\n        }\n\n        String cmd = PC_OPENURL_CMD + \" \" + url;\n        System.err.println(\"exec[\" + cmd + \"]\");\n        Process p = Runtime.getRuntime().exec(cmd);\n        if (false) {\n            try {\n                System.err.println(\"waiting...\");\n                p.waitFor();\n            } catch (Exception ex) {\n                System.err.println(ex);\n            }\n            System.err.println(\"exit value=\" + p.exitValue());\n        }\n    }","id":60282,"modified_method":"private static void openURL_Windows(String url, boolean isLocalFile, boolean isMailTo)\n        throws java.io.IOException\n    {\n        System.err.println(\"openURL_Win  [\" + url + \"]\");\n\n        // On at least Windows 2000, %20's don't work when given to url.dll FileProtocolHandler\n        // (Should be using some kind of URLProtocolHanlder ?)\n        \n        // Also at least Win2K: file:///C:/foo/bar.html works, but start that with file:/ or file://\n        // and it DOES NOT work -- you MUST have the three slashes, OR, you can have NO SLASHES,\n        // and it will work... (file:C:/foo/bar.html)\n        // ALSO, file:// or // file:/// works BY ITSELF (file:/ by itself still doesn't work).\n        \n        //url = url.replaceAll(\"%20\", \" \");\n\n        if (!isMailTo) {\n            url = decodeURL(url);\n            url = decodeURL(url); // run twice in case any %2520 double encoded spaces\n        }\n\n        if (isLocalFile) {\n            // below works, but we're doing a full conversion to windows path names now\n            //url = url.replaceFirst(\"^file:/+\", \"file:\");\n            url = url.replaceFirst(\"^file:/+\", \"\");\n            url = url.replace('/', '\\\\');\n            char c1 = 0;\n            try { c1 = url.charAt(1); } catch (StringIndexOutOfBoundsException e) {}\n            if (c1 == ':' || c1 == '|') {\n                // Windows drive letter specification, e.g., \"C:\".\n                // Also, I've seen D|/dir/file.txt in a shortcut file, so we allow that too.\n                // In any case, we do noting: this string should be workable to url.dll\n            } else {\n                // if this does NOT start with a drive specification, assume\n                // the first component is a host for a windows network\n                // drive, and thus we have to pre-pend \\\\ to it, to get \\\\host\\file\n                url = \"\\\\\\\\\" + url; \n            }\n            // at this point, \"url\" is really just a local windows file\n            // in full windows syntax (backslashes, drive specs, etc)\n            System.err.println(\"openURL_WinLF[\" + url + \"]\");\n        }\n\n        String cmd = PC_OPENURL_CMD + \" \" + url;\n        final int sizeURL = url.length();\n        final int sizeCommand = cmd.length();\n        final int sizeWinArgs = sizeCommand - 17; // subtract \"rundll32 url.dll,\"\n        boolean debug = DEBUG;\n        if (sizeURL > 2027 || sizeCommand > 2064 || sizeWinArgs >= 2048) {\n            System.err.println(\"\\nWarning: WinXP buffer lengths likely exceeded: command not likely to run (arglen=\" + sizeWinArgs + \")\");\n            debug = true;\n        } else {\n            System.err.println();\n        }\n        if (debug) {\n            System.err.println(\"exec       url length: \" + sizeURL);\n            System.err.println(\"exec   command length: \" + sizeCommand);\n            System.err.println(\"exec url.dll args len: \" + sizeWinArgs);\n        }\n\n        if (sizeCommand > 2064) {\n            System.err.println(\"exec: truncating command and hoping for the best...\");\n            cmd = cmd.substring(0,2063);\n        }\n\n        System.err.println(\"exec[\" + cmd + \"]\");\n\n        Runtime.getRuntime().exec(cmd);\n\n//         final String mailto = \"mailto:\"\n//             + \"foo@bar.com?\"\n//             + \"subject=TestSubject\"\n//             + \"&attachment=\"\n//             //+ \"&Attach=\"\n//             + \"\\\"\"\n//             + \"c:\\\\\\\\foo.txt\"\n//             + \"\\\"\"\n//             ;\n//         System.err.println(\"MAILTO: [\"+mailto+\"]\");\n//         Runtime.getRuntime().exec(new String[] {\"rundll32\", \"url.dll,FileProtocolHandler\", mailto\n//                                                 \"mailto:\"\n//                                                 + \"&subject=TestSubject\"\n//                                                 + \"&attachment=\" + \"\\\"\" + \"c:\\\\\\\\foo.txt\" + \"\\\"\"\n//             },\n//             null);\n\n        \n//         if (false) {\n//             Process p = Runtime.getRuntime().exec(cmd);\n//             try {\n//                 System.err.println(\"waiting...\");\n//                 p.waitFor();\n//             } catch (Exception ex) {\n//                 System.err.println(ex);\n//             }\n//             System.err.println(\"exit value=\" + p.exitValue());\n//         }\n    }","commit_id":"744bd982187e85ddd02e01094294a673bc07d2be","url":"https://github.com/VUE/VUE"},{"original_method":"/** print stack trace items only from fully qualified class names that match the given prefix */\n    public static void printClassTrace(Throwable t, String prefix, String message, java.io.PrintStream s) {\n\n        java.awt.Toolkit.getDefaultToolkit().beep();\n        \n        synchronized (System.out) {\n        synchronized (System.err) {\n        synchronized (s) {\n\n            s.print(TERM_RED);\n\n            if (message != null)\n                s.println(message);\n            \n            final String head;\n            if (t.getClass().getName().equals(\"java.lang.Throwable\"))\n                head = t.getMessage();\n            else\n                head = t.toString();\n            if (prefix == null || prefix == NO_CLASS_FILTER)\n                s.print(head + \";\");\n            else\n                s.print(head + \" (stack element prefix \\\"\" + prefix + \"\\\") \");\n\n            long now = System.currentTimeMillis();\n\n            s.print(\" in \" + Thread.currentThread() + \" at \" + now + \" \" + new java.util.Date(now));\n\n            s.print(TERM_CLEAR);\n            \n            if (prefix == null || prefix == NO_CLASS_FILTER)\n                prefix = \"!tufts.Util.print\";\n\n            StackTraceElement[] trace = t.getStackTrace();\n            int skipped = 0;\n            for (int i = 0; i < trace.length; i++) {\n                if (includeInTrace(trace[i], prefix)) {\n                    s.print(\"\\n\\tat \" + trace[i] + \" \");\n                } else {\n                    s.print(\".\");\n                }\n            }\n            s.println(\"\");\n\n            Throwable cause = t.getCause();\n            if (cause != null) {\n                //ourCause.printStackTraceAsCause(s, trace);\n                s.print(TERM_RED + \"    CAUSE: \" + TERM_CLEAR);\n                cause.printStackTrace();\n            }\n            s.println(\"END \" + t + \"\\n\");\n            \n        }\n        }}\n    }","id":60283,"modified_method":"/** print stack trace items only from fully qualified class names that match the given prefix */\n    public static void printClassTrace(Throwable t, String prefix, String message, java.io.PrintStream pst) {\n\n        java.awt.Toolkit.getDefaultToolkit().beep();\n        \n        synchronized (System.out) {\n        synchronized (System.err) {\n        synchronized (pst) {\n\n            pst.print(TERM_RED);\n            Log.println();\n\n            if (message != null) {\n                pst.println(message);\n                Log.println(message);\n            }\n            \n            final String head;\n            if (t.getClass().getName().equals(\"java.lang.Throwable\"))\n                head = t.getMessage();\n            else\n                head = t.toString();\n            if (prefix == null || prefix == NO_CLASS_FILTER) {\n                pst.println(head + \";\");\n                Log.println(head + \";\");\n            } else {\n                pst.println(head + \" (stack element prefix \\\"\" + prefix + \"\\\") \");\n                Log.println(head + \" (stack element prefix \\\"\" + prefix + \"\\\") \");\n            }\n\n            final long now = System.currentTimeMillis();\n            final String stamp = \"\\tin \" + Thread.currentThread() + \" at \" + now + \" \" + new java.util.Date(now);\n\n            pst.print(stamp);\n            Log.print(stamp);\n\n            pst.print(TERM_CLEAR);\n            \n            if (prefix == null || prefix == NO_CLASS_FILTER)\n                prefix = \"!tufts.Util.print\";\n\n            StackTraceElement[] trace = t.getStackTrace();\n            int skipped = 0;\n            for (int i = 0; i < trace.length; i++) {\n                if (includeInTrace(trace[i], prefix)) {\n                    pst.print(\"\\n\\tat \" + trace[i] + \" \");\n                    Log.print(\"\\n\\tat \" + trace[i] + \" \");\n                } else {\n                    pst.print(\".\");\n                    Log.print(\".\");\n                }\n            }\n            pst.println();\n            Log.println();\n\n            Throwable cause = t.getCause();\n            if (cause != null) {\n                //ourCause.printStackTraceAsCause(s, trace);\n                pst.print(TERM_RED);\n                pst.print(\"    CAUSE: \");\n                Log.print(\"    CAUSE: \");\n                pst.print(TERM_CLEAR);\n                cause.printStackTrace(pst);\n                cause.printStackTrace(Log);\n            }\n            pst.println(\"END \" + t + \"\\n\");\n            Log.println(\"END \" + t + \"\\n\");\n            \n        }\n        }}\n    }","commit_id":"744bd982187e85ddd02e01094294a673bc07d2be","url":"https://github.com/VUE/VUE"},{"original_method":"@Override\n    public void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException\n    {\n        if (!_ok)\n        {\n            res.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE);\n            return;\n        }\n\n        String pathInContext = (_relative?\"\":StringUtil.nonNull(req.getServletPath())) + StringUtil.nonNull(req.getPathInfo());\n        if (LOG.isDebugEnabled())\n        {\n            LOG.debug(\"CGI: ContextPath : \" + req.getContextPath());\n            LOG.debug(\"CGI: ServletPath : \" + req.getServletPath());\n            LOG.debug(\"CGI: PathInfo    : \" + req.getPathInfo());\n            LOG.debug(\"CGI: _docRoot    : \" + _docRoot);\n            LOG.debug(\"CGI: _path       : \" + _path);\n            LOG.debug(\"CGI: _ignoreExitState: \" + _ignoreExitState);\n        }\n\n        // pathInContext may actually comprises scriptName/pathInfo...We will\n        // walk backwards up it until we find the script - the rest must\n        // be the pathInfo;\n\n        String both = pathInContext;\n        String first = both;\n        String last = \"\";\n\n        File exe = new File(_docRoot,first);\n\n        while ((first.endsWith(\"/\") || !exe.exists()) && first.length() >= 0)\n        {\n            int index = first.lastIndexOf('/');\n\n            first = first.substring(0,index);\n            last = both.substring(index,both.length());\n            exe = new File(_docRoot,first);\n        }\n\n        if (first.length() == 0 || !exe.exists() || exe.isDirectory() || !exe.getCanonicalPath().equals(exe.getAbsolutePath()))\n        {\n            res.sendError(404);\n        }\n        else\n        {\n            if (LOG.isDebugEnabled())\n            {\n                LOG.debug(\"CGI: script is \" + exe);\n                LOG.debug(\"CGI: pathInfo is \" + last);\n            }\n            exec(exe,last,req,res);\n        }\n    }","id":60284,"modified_method":"@Override\n    public void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException\n    {\n        if (!_ok)\n        {\n            res.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE);\n            return;\n        }\n\n        if (LOG.isDebugEnabled())\n        {\n            LOG.debug(\"CGI: ContextPath : \" + req.getContextPath());\n            LOG.debug(\"CGI: ServletPath : \" + req.getServletPath());\n            LOG.debug(\"CGI: PathInfo    : \" + req.getPathInfo());\n            LOG.debug(\"CGI: _docRoot    : \" + _docRoot);\n            LOG.debug(\"CGI: _path       : \" + _path);\n            LOG.debug(\"CGI: _ignoreExitState: \" + _ignoreExitState);\n        }\n\n        // pathInContext may actually comprises scriptName/pathInfo...We will\n        // walk backwards up it until we find the script - the rest must\n        // be the pathInfo;\n        String pathInContext = (_relative ? \"\" : StringUtil.nonNull(req.getServletPath())) + StringUtil.nonNull(req.getPathInfo());\n        File execCmd = new File(_docRoot, pathInContext);\n        String pathInfo = pathInContext;\n\n        if(!_useFullPath)\n        {\n            String path = pathInContext;\n            String info = \"\";\n\n            // Search docroot for a matching execCmd\n            while (path.endsWith(\"/\") && path.length() >= 0)\n            {\n                if(!execCmd.exists())\n                    break;\n    \n                int index = path.lastIndexOf('/');\n    \n                path = path.substring(0,index);\n                info = pathInContext.substring(index,pathInContext.length());\n                execCmd = new File(_docRoot,path);\n            }\n    \n            if (path.length() == 0 || !execCmd.exists() || execCmd.isDirectory() || !execCmd.getCanonicalPath().equals(execCmd.getAbsolutePath()))\n            {\n                res.sendError(404);\n            }\n            \n            pathInfo = info;\n        }\n        exec(execCmd,pathInfo,req,res);\n    }","commit_id":"5a0811b328031c4da35c060bbcf33c5bdf3f04c5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void init() throws ServletException\n    {\n        _env = new EnvList();\n        _cmdPrefix = getInitParameter(\"commandPrefix\");\n        _relative = Boolean.parseBoolean(getInitParameter(\"cgibinResourceBaseIsRelative\"));\n\n        String tmp = getInitParameter(\"cgibinResourceBase\");\n        if (tmp == null)\n        {\n            tmp = getInitParameter(\"resourceBase\");\n            if (tmp == null)\n                tmp = getServletContext().getRealPath(\"/\");\n        }\n        else if (_relative)\n        {\n            tmp = getServletContext().getRealPath(tmp);\n        }\n\n        if (tmp == null)\n        {\n            LOG.warn(\"CGI: no CGI bin !\");\n            return;\n        }\n\n        File dir = new File(tmp);\n        if (!dir.exists())\n        {\n            LOG.warn(\"CGI: CGI bin does not exist - \" + dir);\n            return;\n        }\n\n        if (!dir.canRead())\n        {\n            LOG.warn(\"CGI: CGI bin is not readable - \" + dir);\n            return;\n        }\n\n        if (!dir.isDirectory())\n        {\n            LOG.warn(\"CGI: CGI bin is not a directory - \" + dir);\n            return;\n        }\n\n        try\n        {\n            _docRoot = dir.getCanonicalFile();\n        }\n        catch (IOException e)\n        {\n            LOG.warn(\"CGI: CGI bin failed - \" + dir,e);\n            return;\n        }\n\n        _path = getInitParameter(\"Path\");\n        if (_path != null)\n            _env.set(\"PATH\",_path);\n\n        _ignoreExitState = \"true\".equalsIgnoreCase(getInitParameter(\"ignoreExitState\"));\n        Enumeration e = getInitParameterNames();\n        while (e.hasMoreElements())\n        {\n            String n = (String)e.nextElement();\n            if (n != null && n.startsWith(\"ENV_\"))\n                _env.set(n.substring(4),getInitParameter(n));\n        }\n        if (!_env.envMap.containsKey(\"SystemRoot\"))\n        {\n            String os = System.getProperty(\"os.name\");\n            if (os != null && os.toLowerCase(Locale.ENGLISH).indexOf(\"windows\") != -1)\n            {\n                _env.set(\"SystemRoot\",\"C:\\\\WINDOWS\");\n            }\n        }\n\n        _ok = true;\n    }","id":60285,"modified_method":"@Override\n    public void init() throws ServletException\n    {\n        _env = new EnvList();\n        _cmdPrefix = getInitParameter(\"commandPrefix\");\n        _useFullPath = Boolean.parseBoolean(getInitParameter(\"useFullPath\"));\n        _relative = Boolean.parseBoolean(getInitParameter(\"cgibinResourceBaseIsRelative\"));\n\n        String tmp = getInitParameter(\"cgibinResourceBase\");\n        if (tmp != null)\n            _cgiBinProvided = true;\n        else\n        {\n            tmp = getInitParameter(\"resourceBase\");\n            if (tmp != null)\n                _cgiBinProvided = true;\n            else\n                tmp = getServletContext().getRealPath(\"/\");\n        }\n\n        if (_relative && _cgiBinProvided)\n        {\n            tmp = getServletContext().getRealPath(tmp);\n        }\n\n        if (tmp == null)\n        {\n            LOG.warn(\"CGI: no CGI bin !\");\n            return;\n        }\n\n        File dir = new File(tmp);\n        if (!dir.exists())\n        {\n            LOG.warn(\"CGI: CGI bin does not exist - \" + dir);\n            return;\n        }\n\n        if (!dir.canRead())\n        {\n            LOG.warn(\"CGI: CGI bin is not readable - \" + dir);\n            return;\n        }\n\n        if (!dir.isDirectory())\n        {\n            LOG.warn(\"CGI: CGI bin is not a directory - \" + dir);\n            return;\n        }\n\n        try\n        {\n            _docRoot = dir.getCanonicalFile();\n        }\n        catch (IOException e)\n        {\n            LOG.warn(\"CGI: CGI bin failed - \" + dir,e);\n            return;\n        }\n\n        _path = getInitParameter(\"Path\");\n        if (_path != null)\n            _env.set(\"PATH\",_path);\n\n        _ignoreExitState = \"true\".equalsIgnoreCase(getInitParameter(\"ignoreExitState\"));\n        Enumeration<String> e = getInitParameterNames();\n        while (e.hasMoreElements())\n        {\n            String n = e.nextElement();\n            if (n != null && n.startsWith(\"ENV_\"))\n                _env.set(n.substring(4),getInitParameter(n));\n        }\n        if (!_env.envMap.containsKey(\"SystemRoot\"))\n        {\n            String os = System.getProperty(\"os.name\");\n            if (os != null && os.toLowerCase(Locale.ENGLISH).indexOf(\"windows\") != -1)\n            {\n                _env.set(\"SystemRoot\",\"C:\\\\WINDOWS\");\n            }\n        }\n\n        _ok = true;\n    }","commit_id":"5a0811b328031c4da35c060bbcf33c5bdf3f04c5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private static void writeProcessInput(final Process p, final String input)\n    {\n        new Thread(new Runnable()\n        {\n            public void run()\n            {\n                try\n                {\n                    try (Writer outToCgi = new OutputStreamWriter(p.getOutputStream()))\n                    {\n                        outToCgi.write(input);\n                    }\n                }\n                catch (IOException e)\n                {\n                    LOG.debug(e);\n                }\n            }\n        }).start();\n    }","id":60286,"modified_method":"private static void writeProcessInput(final Process p, final String input)\n    {\n        new Thread(new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                try\n                {\n                    try (Writer outToCgi = new OutputStreamWriter(p.getOutputStream()))\n                    {\n                        outToCgi.write(input);\n                    }\n                }\n                catch (IOException e)\n                {\n                    LOG.debug(e);\n                }\n            }\n        }).start();\n    }","commit_id":"5a0811b328031c4da35c060bbcf33c5bdf3f04c5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void exec(File command, String pathInfo, HttpServletRequest req, HttpServletResponse res) throws IOException\n    {\n        String path = command.getAbsolutePath();\n        File dir = command.getParentFile();\n        String scriptName = req.getRequestURI().substring(0,req.getRequestURI().length() - pathInfo.length());\n        String scriptPath = getServletContext().getRealPath(scriptName);\n        String pathTranslated = req.getPathTranslated();\n\n        int len = req.getContentLength();\n        if (len < 0)\n            len = 0;\n        if ((pathTranslated == null) || (pathTranslated.length() == 0))\n            pathTranslated = path;\n\n        String bodyFormEncoded = null;\n        if ((HttpMethod.POST.equals(req.getMethod()) || HttpMethod.PUT.equals(req.getMethod())) && \"application/x-www-form-urlencoded\".equals(req.getContentType()))\n        {\n            MultiMap<String> parameterMap = new MultiMap<String>();\n            Enumeration names = req.getParameterNames();\n            while (names.hasMoreElements())\n            {\n                String parameterName = (String)names.nextElement();\n                parameterMap.addValues(parameterName, req.getParameterValues(parameterName));\n            }\n            bodyFormEncoded = UrlEncoded.encode(parameterMap, Charset.forName(req.getCharacterEncoding()), true);\n        }\n\n        EnvList env = new EnvList(_env);\n        // these ones are from \"The WWW Common Gateway Interface Version 1.1\"\n        // look at :\n        // http://Web.Golux.Com/coar/cgi/draft-coar-cgi-v11-03-clean.html#6.1.1\n        env.set(\"AUTH_TYPE\", req.getAuthType());\n        if (bodyFormEncoded != null)\n        {\n            env.set(\"CONTENT_LENGTH\", Integer.toString(bodyFormEncoded.length()));\n        }\n        else\n        {\n            env.set(\"CONTENT_LENGTH\", Integer.toString(len));\n        }\n        env.set(\"CONTENT_TYPE\", req.getContentType());\n        env.set(\"GATEWAY_INTERFACE\", \"CGI/1.1\");\n        if ((pathInfo != null) && (pathInfo.length() > 0))\n        {\n            env.set(\"PATH_INFO\", pathInfo);\n        }\n        env.set(\"PATH_TRANSLATED\", pathTranslated);\n        env.set(\"QUERY_STRING\", req.getQueryString());\n        env.set(\"REMOTE_ADDR\", req.getRemoteAddr());\n        env.set(\"REMOTE_HOST\", req.getRemoteHost());\n        // The identity information reported about the connection by a\n        // RFC 1413 [11] request to the remote agent, if\n        // available. Servers MAY choose not to support this feature, or\n        // not to request the data for efficiency reasons.\n        // \"REMOTE_IDENT\" => \"NYI\"\n        env.set(\"REMOTE_USER\", req.getRemoteUser());\n        env.set(\"REQUEST_METHOD\", req.getMethod());\n        env.set(\"SCRIPT_NAME\", scriptName);\n        env.set(\"SCRIPT_FILENAME\", scriptPath);\n        env.set(\"SERVER_NAME\", req.getServerName());\n        env.set(\"SERVER_PORT\", Integer.toString(req.getServerPort()));\n        env.set(\"SERVER_PROTOCOL\", req.getProtocol());\n        env.set(\"SERVER_SOFTWARE\", getServletContext().getServerInfo());\n\n        Enumeration enm = req.getHeaderNames();\n        while (enm.hasMoreElements())\n        {\n            String name = (String)enm.nextElement();\n            String value = req.getHeader(name);\n            env.set(\"HTTP_\" + name.toUpperCase(Locale.ENGLISH).replace('-','_'),value);\n        }\n\n        // these extra ones were from printenv on www.dev.nomura.co.uk\n        env.set(\"HTTPS\", (req.isSecure()?\"ON\":\"OFF\"));\n        // \"DOCUMENT_ROOT\" => root + \"/docs\",\n        // \"SERVER_URL\" => \"NYI - http://us0245\",\n        // \"TZ\" => System.getProperty(\"user.timezone\"),\n\n        // are we meant to decode args here ? or does the script get them\n        // via PATH_INFO ? if we are, they should be decoded and passed\n        // into exec here...\n        String execCmd = path;\n        if ((execCmd.charAt(0) != '\"') && (execCmd.indexOf(\" \") >= 0))\n            execCmd = \"\\\"\" + execCmd + \"\\\"\";\n        if (_cmdPrefix != null)\n            execCmd = _cmdPrefix + \" \" + execCmd;\n\n        LOG.debug(\"Environment: \" + env.getExportString());\n        LOG.debug(\"Command: \" + execCmd);\n\n        final Process p;\n        if (dir == null)\n            p = Runtime.getRuntime().exec(execCmd, env.getEnvArray());\n        else\n            p = Runtime.getRuntime().exec(execCmd, env.getEnvArray(), dir);\n\n        // hook processes input to browser's output (async)\n        if (bodyFormEncoded != null)\n            writeProcessInput(p, bodyFormEncoded);\n        else if (len > 0)\n            writeProcessInput(p, req.getInputStream(), len);\n\n        // hook processes output to browser's input (sync)\n        // if browser closes stream, we should detect it and kill process...\n        OutputStream os = null;\n        AsyncContext async=req.startAsync();\n        try\n        {\n            async.start(new Runnable()\n            {\n                @Override\n                public void run()\n                {\n                    try\n                    {\n                        IO.copy(p.getErrorStream(), System.err);\n                    }\n                    catch (IOException e)\n                    {\n                        LOG.warn(e);\n                    }\n                }     \n            });\n            \n            // read any headers off the top of our input stream\n            // NOTE: Multiline header items not supported!\n            String line = null;\n            InputStream inFromCgi = p.getInputStream();\n\n            // br=new BufferedReader(new InputStreamReader(inFromCgi));\n            // while ((line=br.readLine())!=null)\n            while ((line = getTextLineFromStream(inFromCgi)).length() > 0)\n            {\n                if (!line.startsWith(\"HTTP\"))\n                {\n                    int k = line.indexOf(':');\n                    if (k > 0)\n                    {\n                        String key = line.substring(0,k).trim();\n                        String value = line.substring(k + 1).trim();\n                        if (\"Location\".equals(key))\n                        {\n                            res.sendRedirect(res.encodeRedirectURL(value));\n                        }\n                        else if (\"Status\".equals(key))\n                        {\n                            String[] token = value.split(\" \");\n                            int status = Integer.parseInt(token[0]);\n                            res.setStatus(status);\n                        }\n                        else\n                        {\n                            // add remaining header items to our response header\n                            res.addHeader(key,value);\n                        }\n                    }\n                }\n            }\n            // copy cgi content to response stream...\n            os = res.getOutputStream();\n            IO.copy(inFromCgi,os);\n            p.waitFor();\n\n            if (!_ignoreExitState)\n            {\n                int exitValue = p.exitValue();\n                if (0 != exitValue)\n                {\n                    LOG.warn(\"Non-zero exit status (\" + exitValue + \") from CGI program: \" + path);\n                    if (!res.isCommitted())\n                        res.sendError(500,\"Failed to exec CGI\");\n                }\n            }\n        }\n        catch (IOException e)\n        {\n            // browser has probably closed its input stream - we\n            // terminate and clean up...\n            LOG.debug(\"CGI: Client closed connection!\");\n        }\n        catch (InterruptedException ie)\n        {\n            LOG.debug(\"CGI: interrupted!\");\n        }\n        finally\n        {\n            if (os != null)\n            {\n                try\n                {\n                    os.close();\n                }\n                catch (Exception e)\n                {\n                    LOG.debug(e);\n                }\n            }\n            p.destroy();\n            // LOG.debug(\"CGI: terminated!\");\n            async.complete();\n        }\n    }","id":60287,"modified_method":"/** executes the CGI process\n    /*\n     * @param command the command to execute, this command is prefixed by\n     *  the context parameter \"commandPrefix\".\n     * @param pathInfo The PATH_INFO to process,\n     *  see http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getPathInfo%28%29. Cannot be null\n     * @param req\n     * @param res\n     * @exception IOException\n     */\n    private void exec(File command, String pathInfo, HttpServletRequest req, HttpServletResponse res) throws IOException\n    {\n        assert req != null;\n        assert res != null;\n        assert pathInfo != null;\n        assert command != null;\n\n        if (LOG.isDebugEnabled())\n        {\n            LOG.debug(\"CGI: script is \" + command);\n            LOG.debug(\"CGI: pathInfo is \" + pathInfo);\n        }\n\n        String bodyFormEncoded = null;\n        if ((HttpMethod.POST.equals(req.getMethod()) || HttpMethod.PUT.equals(req.getMethod())) && \"application/x-www-form-urlencoded\".equals(req.getContentType()))\n        {\n            MultiMap<String> parameterMap = new MultiMap<String>();\n            Enumeration<String> names = req.getParameterNames();\n            while (names.hasMoreElements())\n            {\n                String parameterName = names.nextElement();\n                parameterMap.addValues(parameterName, req.getParameterValues(parameterName));\n            }\n            bodyFormEncoded = UrlEncoded.encode(parameterMap, Charset.forName(req.getCharacterEncoding()), true);\n        }\n\n        EnvList env = new EnvList(_env);\n        // these ones are from \"The WWW Common Gateway Interface Version 1.1\"\n        // look at :\n        // http://Web.Golux.Com/coar/cgi/draft-coar-cgi-v11-03-clean.html#6.1.1\n        env.set(\"AUTH_TYPE\", req.getAuthType());\n\n        int contentLen = req.getContentLength();\n        if (contentLen < 0)\n            contentLen = 0;\n        if (bodyFormEncoded != null)\n        {\n            env.set(\"CONTENT_LENGTH\", Integer.toString(bodyFormEncoded.length()));\n        }\n        else\n        {\n            env.set(\"CONTENT_LENGTH\", Integer.toString(contentLen));\n        }\n        env.set(\"CONTENT_TYPE\", req.getContentType());\n        env.set(\"GATEWAY_INTERFACE\", \"CGI/1.1\");\n        if (pathInfo.length() > 0)\n        {\n            env.set(\"PATH_INFO\", pathInfo);\n        }\n\n        String pathTranslated = req.getPathTranslated();\n        if ((pathTranslated == null) || (pathTranslated.length() == 0))\n            pathTranslated = pathInfo;\n        env.set(\"PATH_TRANSLATED\", pathTranslated);\n        env.set(\"QUERY_STRING\", req.getQueryString());\n        env.set(\"REMOTE_ADDR\", req.getRemoteAddr());\n        env.set(\"REMOTE_HOST\", req.getRemoteHost());\n\n        // The identity information reported about the connection by a\n        // RFC 1413 [11] request to the remote agent, if\n        // available. Servers MAY choose not to support this feature, or\n        // not to request the data for efficiency reasons.\n        // \"REMOTE_IDENT\" => \"NYI\"\n        env.set(\"REMOTE_USER\", req.getRemoteUser());\n        env.set(\"REQUEST_METHOD\", req.getMethod());\n\n        String scriptPath;\n        String scriptName;\n        // use docRoot for scriptPath, too\n        if(_cgiBinProvided) \n        {\n            scriptPath = command.getAbsolutePath();\n            scriptName = scriptPath.substring(_docRoot.getAbsolutePath().length());\n        } \n        else \n        {\n            String requestURI = req.getRequestURI();\n            scriptName = requestURI.substring(0,requestURI.length() - pathInfo.length());\n            scriptPath = getServletContext().getRealPath(scriptName);\n        }\n        env.set(\"SCRIPT_FILENAME\", scriptPath);\n        env.set(\"SCRIPT_NAME\", scriptName);\n\n        env.set(\"SERVER_NAME\", req.getServerName());\n        env.set(\"SERVER_PORT\", Integer.toString(req.getServerPort()));\n        env.set(\"SERVER_PROTOCOL\", req.getProtocol());\n        env.set(\"SERVER_SOFTWARE\", getServletContext().getServerInfo());\n\n        Enumeration<String> enm = req.getHeaderNames();\n        while (enm.hasMoreElements())\n        {\n            String name = enm.nextElement();\n            String value = req.getHeader(name);\n            env.set(\"HTTP_\" + name.toUpperCase(Locale.ENGLISH).replace('-','_'),value);\n        }\n\n        // these extra ones were from printenv on www.dev.nomura.co.uk\n        env.set(\"HTTPS\", (req.isSecure()?\"ON\":\"OFF\"));\n        // \"DOCUMENT_ROOT\" => root + \"/docs\",\n        // \"SERVER_URL\" => \"NYI - http://us0245\",\n        // \"TZ\" => System.getProperty(\"user.timezone\"),\n\n        // are we meant to decode args here? or does the script get them\n        // via PATH_INFO? if we are, they should be decoded and passed\n        // into exec here...\n        String absolutePath = command.getAbsolutePath();\n        String execCmd = absolutePath;\n\n        // escape the execCommand\n        if (execCmd.length() > 0 && execCmd.charAt(0) != '\"' && execCmd.indexOf(\" \") >= 0)\n            execCmd = \"\\\"\" + execCmd + \"\\\"\";\n\n        if (_cmdPrefix != null)\n            execCmd = _cmdPrefix + \" \" + execCmd;\n\n        assert execCmd != null;\n        LOG.debug(\"Environment: \" + env.getExportString());\n        LOG.debug(\"Command: \" + execCmd);\n\n        final Process p = Runtime.getRuntime().exec(execCmd, env.getEnvArray(), _docRoot);\n\n        // hook processes input to browser's output (async)\n        if (bodyFormEncoded != null)\n            writeProcessInput(p, bodyFormEncoded);\n        else if (contentLen > 0)\n            writeProcessInput(p, req.getInputStream(), contentLen);\n\n        // hook processes output to browser's input (sync)\n        // if browser closes stream, we should detect it and kill process...\n        OutputStream os = null;\n        AsyncContext async=req.startAsync();\n        try\n        {\n            async.start(new Runnable()\n            {\n                @Override\n                public void run()\n                {\n                    try\n                    {\n                        IO.copy(p.getErrorStream(), System.err);\n                    }\n                    catch (IOException e)\n                    {\n                        LOG.warn(e);\n                    }\n                }\n            });\n\n            // read any headers off the top of our input stream\n            // NOTE: Multiline header items not supported!\n            String line = null;\n            InputStream inFromCgi = p.getInputStream();\n\n            // br=new BufferedReader(new InputStreamReader(inFromCgi));\n            // while ((line=br.readLine())!=null)\n            while ((line = getTextLineFromStream(inFromCgi)).length() > 0)\n            {\n                if (!line.startsWith(\"HTTP\"))\n                {\n                    int k = line.indexOf(':');\n                    if (k > 0)\n                    {\n                        String key = line.substring(0,k).trim();\n                        String value = line.substring(k + 1).trim();\n                        if (\"Location\".equals(key))\n                        {\n                            res.sendRedirect(res.encodeRedirectURL(value));\n                        }\n                        else if (\"Status\".equals(key))\n                        {\n                            String[] token = value.split(\" \");\n                            int status = Integer.parseInt(token[0]);\n                            res.setStatus(status);\n                        }\n                        else\n                        {\n                            // add remaining header items to our response header\n                            res.addHeader(key,value);\n                        }\n                    }\n                }\n            }\n            // copy cgi content to response stream...\n            os = res.getOutputStream();\n            IO.copy(inFromCgi,os);\n            p.waitFor();\n\n            if (!_ignoreExitState)\n            {\n                int exitValue = p.exitValue();\n                if (0 != exitValue)\n                {\n                    LOG.warn(\"Non-zero exit status (\" + exitValue + \") from CGI program: \" + absolutePath);\n                    if (!res.isCommitted())\n                        res.sendError(500,\"Failed to exec CGI\");\n                }\n            }\n        }\n        catch (IOException e)\n        {\n            // browser has probably closed its input stream - we\n            // terminate and clean up...\n            LOG.debug(\"CGI: Client closed connection!\", e);\n        }\n        catch (InterruptedException ie)\n        {\n            LOG.debug(\"CGI: interrupted!\");\n        }\n        finally\n        {\n            if (os != null)\n            {\n                try\n                {\n                    os.close();\n                }\n                catch (Exception e)\n                {\n                    LOG.debug(e);\n                }\n            }\n            p.destroy();\n            // LOG.debug(\"CGI: terminated!\");\n            async.complete();\n        }\n    }","commit_id":"5a0811b328031c4da35c060bbcf33c5bdf3f04c5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private static void writeProcessInput(final Process p, final InputStream input, final int len)\n    {\n        if (len <= 0) return;\n\n        new Thread(new Runnable()\n        {\n            public void run()\n            {\n                try\n                {\n                    OutputStream outToCgi = p.getOutputStream();\n                    IO.copy(input, outToCgi, len);\n                    outToCgi.close();\n                }\n                catch (IOException e)\n                {\n                    LOG.debug(e);\n                }\n            }\n        }).start();\n    }","id":60288,"modified_method":"private static void writeProcessInput(final Process p, final InputStream input, final int len)\n    {\n        if (len <= 0) return;\n\n        new Thread(new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                try\n                {\n                    OutputStream outToCgi = p.getOutputStream();\n                    IO.copy(input, outToCgi, len);\n                    outToCgi.close();\n                }\n                catch (IOException e)\n                {\n                    LOG.debug(e);\n                }\n            }\n        }).start();\n    }","commit_id":"5a0811b328031c4da35c060bbcf33c5bdf3f04c5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void setImplementation(ModelType<?> implementationType, ModelRuleDescriptor source) {\n            if (implementationRegistration != null) {\n                throw new IllegalStateException(String.format(\"Cannot register implementation for type '%s' because an implementation for this type was already registered by %s\",\n                    publicType, implementationRegistration.getSource()));\n            }\n            if (managedPublicType) {\n                throw new IllegalArgumentException(String.format(\"Cannot specify default implementation for managed type '%s'\", publicType));\n            }\n            if (!baseInterface.isAssignableFrom(implementationType)) {\n                throw new IllegalArgumentException(String.format(\"Implementation type '%s' registered for '%s' must extend '%s'\", implementationType, publicType, baseImplementationType));\n            }\n            if (Modifier.isAbstract(implementationType.getConcreteClass().getModifiers())) {\n                throw new IllegalArgumentException(String.format(\"Implementation type '%s' registered for '%s' must not be abstract\", implementationType, publicType));\n            }\n            try {\n                implementationType.getConcreteClass().getConstructor();\n            } catch (NoSuchMethodException e) {\n                throw new IllegalArgumentException(String.format(\"Implementation type '%s' registered for '%s' must have a public default constructor\", implementationType, publicType));\n            }\n            Class<? extends BASEIMPL> implementationClass = implementationType.getConcreteClass().asSubclass(baseImplementation);\n            ImplementationFactory<S, BASEIMPL> factory = findFactory(implementationClass);\n            if (factory == null) {\n                throw new IllegalArgumentException(String.format(\"No factory registered to create an instance of implementation class '%s'.\", implementationClass.getName()));\n            }\n            this.implementationRegistration = new ImplementationRegistration<S, BASEIMPL>(source, implementationType.asSubtype(baseImplementationType), factory);\n        }","id":60289,"modified_method":"public void setImplementation(ModelType<?> implementationType, ModelRuleDescriptor source) {\n            if (implementationRegistration != null) {\n                throw new IllegalStateException(String.format(\"Cannot register implementation for type '%s' because an implementation for this type was already registered by %s\",\n                    publicType, implementationRegistration.getSource()));\n            }\n            if (managedPublicType) {\n                throw new IllegalArgumentException(String.format(\"Cannot specify default implementation for managed type '%s'\", publicType));\n            }\n            if (Modifier.isAbstract(implementationType.getConcreteClass().getModifiers())) {\n                throw new IllegalArgumentException(String.format(\"Implementation type '%s' registered for '%s' must not be abstract\", implementationType, publicType));\n            }\n            try {\n                implementationType.getConcreteClass().getConstructor();\n            } catch (NoSuchMethodException e) {\n                throw new IllegalArgumentException(String.format(\"Implementation type '%s' registered for '%s' must have a public default constructor\", implementationType, publicType));\n            }\n            Class<?> implementationClass = implementationType.getConcreteClass();\n            ImplementationFactory<S, ?> factory = findFactory(implementationClass);\n            if (factory == null) {\n                throw new IllegalArgumentException(String.format(\"No factory registered to create an instance of implementation class '%s'.\", implementationClass.getName()));\n            }\n            this.implementationRegistration = new ImplementationRegistration<S>(source, implementationType, factory);\n        }","commit_id":"aa11ae1b6e31abcb2a4a63ad9908cbedbf7fc827","url":"https://github.com/gradle/gradle"},{"original_method":"private ImplementationRegistration(ModelRuleDescriptor source, ModelType<? extends BASEIMPL> implementationType, ImplementationFactory<? super PUBLIC, ? super BASEIMPL> factory) {\n            this.source = source;\n            this.implementationType = implementationType;\n            this.factory = factory;\n        }","id":60290,"modified_method":"private ImplementationRegistration(ModelRuleDescriptor source, ModelType<?> implementationType, ImplementationFactory<? super PUBLIC, ?> factory) {\n            this.source = source;\n            this.implementationType = implementationType;\n            this.factory = factory;\n        }","commit_id":"aa11ae1b6e31abcb2a4a63ad9908cbedbf7fc827","url":"https://github.com/gradle/gradle"},{"original_method":"@Override @Nullable\n    public <S extends PUBLIC> ImplementationInfo getImplementationInfo(ModelType<S> publicType) {\n        ImplementationRegistration<S, ? extends BASEIMPL> implementationRegistration = getImplementationRegistration(publicType);\n        if (implementationRegistration == null) {\n            return null;\n        }\n        return new ImplementationInfoImpl<S, BASEIMPL>(publicType, implementationRegistration, getInternalViews(publicType));\n    }","id":60291,"modified_method":"@Override @Nullable\n    public <S extends PUBLIC> ImplementationInfo getImplementationInfo(ModelType<S> publicType) {\n        ImplementationRegistration<S> implementationRegistration = getImplementationRegistration(publicType);\n        if (implementationRegistration == null) {\n            return null;\n        }\n        return new ImplementationInfoImpl<S>(publicType, implementationRegistration, getInternalViews(publicType));\n    }","commit_id":"aa11ae1b6e31abcb2a4a63ad9908cbedbf7fc827","url":"https://github.com/gradle/gradle"},{"original_method":"private <S extends PUBLIC> ImplementationRegistration<S, ? extends BASEIMPL> getImplementationRegistration(ModelType<S> type) {\n        TypeRegistration<S> registration = getRegistration(type);\n        if (registration == null) {\n            return null;\n        }\n        if (registration.implementationRegistration == null) {\n            throw new IllegalArgumentException(\n                String.format(\"Cannot create a '%s' because this type does not have an implementation registered.\", type));\n        }\n        return registration.implementationRegistration;\n    }","id":60292,"modified_method":"private <S extends PUBLIC> ImplementationRegistration<S> getImplementationRegistration(ModelType<S> type) {\n        TypeRegistration<S> registration = getRegistration(type);\n        if (registration == null) {\n            return null;\n        }\n        if (registration.implementationRegistration == null) {\n            throw new IllegalArgumentException(\n                String.format(\"Cannot create a '%s' because this type does not have an implementation registered.\", type));\n        }\n        return registration.implementationRegistration;\n    }","commit_id":"aa11ae1b6e31abcb2a4a63ad9908cbedbf7fc827","url":"https://github.com/gradle/gradle"},{"original_method":"@Nullable\n    private <S extends PUBLIC> ImplementationFactory<S, BASEIMPL> findFactory(Class<? extends BASEIMPL> implementationClass) {\n        ImplementationFactory<? extends PUBLIC, ? extends BASEIMPL> implementationFactory = factories.get(implementationClass);\n        if (implementationFactory != null) {\n            return Cast.uncheckedCast(implementationFactory);\n        }\n\n        Class<?> superclass = implementationClass.getSuperclass();\n        if (superclass != null && baseImplementation.isAssignableFrom(superclass)) {\n            implementationFactory = findFactory(superclass.asSubclass(baseImplementation));\n            factories.put(implementationClass, implementationFactory);\n            return Cast.uncheckedCast(implementationFactory);\n        }\n\n        return null;\n    }","id":60293,"modified_method":"@Nullable\n    private <S extends PUBLIC> ImplementationFactory<S, ?> findFactory(Class<?> implementationClass) {\n        ImplementationFactory<? extends PUBLIC, ?> implementationFactory = factories.get(implementationClass);\n        if (implementationFactory != null) {\n            return Cast.uncheckedCast(implementationFactory);\n        }\n\n        Class<?> superclass = implementationClass.getSuperclass();\n        if (superclass != null && superclass != Object.class) {\n            implementationFactory = findFactory(superclass);\n            factories.put(implementationClass, implementationFactory);\n            return Cast.uncheckedCast(implementationFactory);\n        }\n\n        return null;\n    }","commit_id":"aa11ae1b6e31abcb2a4a63ad9908cbedbf7fc827","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public Object create(MutableModelNode modelNode) {\n            return implementationRegistration.factory.create(publicType, implementationRegistration.implementationType, modelNode.getPath().getName(), modelNode);\n        }","id":60294,"modified_method":"@Override\n        public Object create(MutableModelNode modelNode) {\n            ImplementationFactory<PUBLIC, Object> implementationFactory = Cast.uncheckedCast(implementationRegistration.factory);\n            return implementationFactory.create(publicType, implementationRegistration.implementationType, modelNode.getPath().getName(), modelNode);\n        }","commit_id":"aa11ae1b6e31abcb2a4a63ad9908cbedbf7fc827","url":"https://github.com/gradle/gradle"},{"original_method":"public BaseInstanceFactory(Class<PUBLIC> baseInterface, Class<BASEIMPL> baseImplementation) {\n        this.baseInterface = ModelType.of(baseInterface);\n        this.baseImplementation = baseImplementation;\n        this.baseImplementationType = ModelType.of(baseImplementation);\n    }","id":60295,"modified_method":"public BaseInstanceFactory(Class<PUBLIC> baseInterface) {\n        this.baseInterface = ModelType.of(baseInterface);\n    }","commit_id":"aa11ae1b6e31abcb2a4a63ad9908cbedbf7fc827","url":"https://github.com/gradle/gradle"},{"original_method":"public ImplementationFactory<? super PUBLIC, ? super BASEIMPL> getFactory() {\n            return factory;\n        }","id":60296,"modified_method":"public ImplementationFactory<? super PUBLIC, ?> getFactory() {\n            return factory;\n        }","commit_id":"aa11ae1b6e31abcb2a4a63ad9908cbedbf7fc827","url":"https://github.com/gradle/gradle"},{"original_method":"public <S extends PUBLIC> void register(ModelType<S> publicType, Set<Class<?>> internalViews, @Nullable ModelType<? extends BASEIMPL> implementationType, ModelRuleDescriptor definedBy) {\n        TypeRegistrationBuilder<S> registration = register(publicType, definedBy);\n        if (implementationType != null) {\n            registration.withImplementation(implementationType);\n        }\n        for (Class<?> internalView : internalViews) {\n            registration.withInternalView(ModelType.of(internalView));\n        }\n    }","id":60297,"modified_method":"public <S extends PUBLIC> void register(ModelType<S> publicType, Set<Class<?>> internalViews, @Nullable ModelType<?> implementationType, ModelRuleDescriptor definedBy) {\n        TypeRegistrationBuilder<S> registration = register(publicType, definedBy);\n        if (implementationType != null) {\n            registration.withImplementation(implementationType);\n        }\n        for (Class<?> internalView : internalViews) {\n            registration.withInternalView(ModelType.of(internalView));\n        }\n    }","commit_id":"aa11ae1b6e31abcb2a4a63ad9908cbedbf7fc827","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public <S extends PUBLIC> ImplementationInfo getManagedSubtypeImplementationInfo(final ModelType<S> publicType) {\n        if (!isManaged(publicType)) {\n            throw new IllegalArgumentException(String.format(\"Type '%s' is not managed\", publicType));\n        }\n        final List<ImplementationInfo> implementationInfos = Lists.newArrayListWithCapacity(1);\n        ModelSchemaUtils.walkTypeHierarchy(publicType.getConcreteClass(), new RegistrationHierarchyVisitor<S>() {\n            @Override\n            protected void visitRegistration(TypeRegistration<? extends PUBLIC> registration) {\n                if (registration != null && registration.implementationRegistration != null) {\n                    implementationInfos.add(new ImplementationInfoImpl<S, BASEIMPL>(publicType, registration.implementationRegistration, getInternalViews(publicType)));\n                }\n            }\n        });\n\n        if (implementationInfos.isEmpty()) {\n            throw new IllegalStateException(String.format(\"Factory registration for '%s' is invalid because it doesn't extend an interface with a default implementation\", publicType));\n        }\n\n        return implementationInfos.get(0);\n    }","id":60298,"modified_method":"@Override\n    public <S extends PUBLIC> ImplementationInfo getManagedSubtypeImplementationInfo(final ModelType<S> publicType) {\n        if (!isManaged(publicType)) {\n            throw new IllegalArgumentException(String.format(\"Type '%s' is not managed\", publicType));\n        }\n        final List<ImplementationInfo> implementationInfos = Lists.newArrayListWithCapacity(1);\n        ModelSchemaUtils.walkTypeHierarchy(publicType.getConcreteClass(), new RegistrationHierarchyVisitor<S>() {\n            @Override\n            protected void visitRegistration(TypeRegistration<? extends PUBLIC> registration) {\n                if (registration != null && registration.implementationRegistration != null) {\n                    implementationInfos.add(new ImplementationInfoImpl<S>(publicType, registration.implementationRegistration, getInternalViews(publicType)));\n                }\n            }\n        });\n\n        if (implementationInfos.isEmpty()) {\n            throw new IllegalStateException(String.format(\"Factory registration for '%s' is invalid because it doesn't extend an interface with a default implementation\", publicType));\n        }\n\n        return implementationInfos.get(0);\n    }","commit_id":"aa11ae1b6e31abcb2a4a63ad9908cbedbf7fc827","url":"https://github.com/gradle/gradle"},{"original_method":"public ImplementationInfoImpl(ModelType<PUBLIC> publicType, ImplementationRegistration<?, ?> implementationRegistration, Set<ModelType<?>> internalViews) {\n            this.publicType = publicType;\n            this.internalViews = internalViews;\n            this.implementationRegistration = Cast.uncheckedCast(implementationRegistration);\n        }","id":60299,"modified_method":"public ImplementationInfoImpl(ModelType<PUBLIC> publicType, ImplementationRegistration<?> implementationRegistration, Set<ModelType<?>> internalViews) {\n            this.publicType = publicType;\n            this.internalViews = internalViews;\n            this.implementationRegistration = Cast.uncheckedCast(implementationRegistration);\n        }","commit_id":"aa11ae1b6e31abcb2a4a63ad9908cbedbf7fc827","url":"https://github.com/gradle/gradle"},{"original_method":"public BinarySpecFactory(final Instantiator instantiator, final ITaskFactory taskFactory) {\n        super(BinarySpec.class, BaseBinarySpec.class);\n        registerFactory(BaseBinarySpec.class, new ImplementationFactory<BinarySpec, BaseBinarySpec>() {\n            @Override\n            public <T extends BaseBinarySpec> T create(ModelType<? extends BinarySpec> publicType, ModelType<T> implementationType, String name, MutableModelNode binaryNode) {\n                MutableModelNode componentBinariesNode = binaryNode.getParent();\n                MutableModelNode componentNode = componentBinariesNode.getParent();\n                return BaseBinarySpec.create(\n                        publicType.getConcreteClass(),\n                        implementationType.getConcreteClass(),\n                        name,\n                        binaryNode,\n                        componentNode,\n                        instantiator,\n                        taskFactory);\n            }\n        });\n    }","id":60300,"modified_method":"public BinarySpecFactory(final Instantiator instantiator, final ITaskFactory taskFactory) {\n        super(BinarySpec.class);\n        registerFactory(BaseBinarySpec.class, new ImplementationFactory<BinarySpec, BaseBinarySpec>() {\n            @Override\n            public <T extends BaseBinarySpec> T create(ModelType<? extends BinarySpec> publicType, ModelType<T> implementationType, String name, MutableModelNode binaryNode) {\n                MutableModelNode componentBinariesNode = binaryNode.getParent();\n                MutableModelNode componentNode = componentBinariesNode.getParent();\n                return BaseBinarySpec.create(\n                        publicType.getConcreteClass(),\n                        implementationType.getConcreteClass(),\n                        name,\n                        binaryNode,\n                        componentNode,\n                        instantiator,\n                        taskFactory);\n            }\n        });\n    }","commit_id":"aa11ae1b6e31abcb2a4a63ad9908cbedbf7fc827","url":"https://github.com/gradle/gradle"},{"original_method":"public BinaryTypeModelRuleExtractor(ModelSchemaStore schemaStore) {\n        super(\"binary\", BinarySpec.class, BaseBinarySpec.class, ModelReference.of(BinarySpecFactory.class), ImmutableList.of(BinaryBasePlugin.class), schemaStore);\n    }","id":60301,"modified_method":"public BinaryTypeModelRuleExtractor(ModelSchemaStore schemaStore) {\n        super(\"binary\", BinarySpec.class, ModelReference.of(BinarySpecFactory.class), ImmutableList.of(BinaryBasePlugin.class), schemaStore);\n    }","commit_id":"aa11ae1b6e31abcb2a4a63ad9908cbedbf7fc827","url":"https://github.com/gradle/gradle"},{"original_method":"public ComponentSpecFactory(final ProjectIdentifier projectIdentifier) {\n        super(ComponentSpec.class, BaseComponentSpec.class);\n        registerFactory(BaseComponentSpec.class, new ImplementationFactory<ComponentSpec, BaseComponentSpec>() {\n            @Override\n            public <T extends BaseComponentSpec> T create(ModelType<? extends ComponentSpec> publicType, ModelType<T> implementationType, String name, MutableModelNode componentNode) {\n                ComponentSpecIdentifier id = new DefaultComponentSpecIdentifier(projectIdentifier.getPath(), name);\n                return BaseComponentSpec.create(publicType.getConcreteClass(), implementationType.getConcreteClass(), id, componentNode);\n            }\n        });\n    }","id":60302,"modified_method":"public ComponentSpecFactory(final ProjectIdentifier projectIdentifier) {\n        super(ComponentSpec.class);\n        registerFactory(DefaultComponentSpec.class, new ImplementationFactory<ComponentSpec, DefaultComponentSpec>() {\n            @Override\n            public <T extends DefaultComponentSpec> T create(ModelType<? extends ComponentSpec> publicType, ModelType<T> implementationType, String name, MutableModelNode componentNode) {\n                ComponentSpecIdentifier id = new DefaultComponentSpecIdentifier(projectIdentifier.getPath(), name);\n                return DefaultComponentSpec.create(publicType.getConcreteClass(), implementationType.getConcreteClass(), id, componentNode);\n            }\n        });\n    }","commit_id":"aa11ae1b6e31abcb2a4a63ad9908cbedbf7fc827","url":"https://github.com/gradle/gradle"},{"original_method":"public ComponentTypeModelRuleExtractor(ModelSchemaStore schemaStore) {\n        super(\"component\", ComponentSpec.class, BaseComponentSpec.class, ModelReference.of(ComponentSpecFactory.class), ImmutableList.of(ComponentModelBasePlugin.class), schemaStore);\n    }","id":60303,"modified_method":"public ComponentTypeModelRuleExtractor(ModelSchemaStore schemaStore) {\n        super(\"component\", ComponentSpec.class, ModelReference.of(ComponentSpecFactory.class), ImmutableList.of(ComponentModelBasePlugin.class), schemaStore);\n    }","commit_id":"aa11ae1b6e31abcb2a4a63ad9908cbedbf7fc827","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public Class<? extends T> getDefaultImplementation() {\n        return this.implementation;\n    }","id":60304,"modified_method":"@Override\n    public Class<?> getDefaultImplementation() {\n        return this.implementation;\n    }","commit_id":"aa11ae1b6e31abcb2a4a63ad9908cbedbf7fc827","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public TypeBuilderInternal<T> defaultImplementation(Class<? extends T> implementation) {\n        if (this.schema instanceof ManagedImplSchema) {\n            throw new InvalidModelException(String.format(\"Method annotated with @%s cannot set default implementation for managed type %s.\", markerAnnotation.getSimpleName(), schema.getType().getName()));\n        }\n        if (this.implementation != null) {\n            throw new InvalidModelException(String.format(\"Method annotated with @%s cannot set default implementation multiple times.\", markerAnnotation.getSimpleName()));\n        }\n        this.implementation = implementation;\n        return this;\n    }","id":60305,"modified_method":"@Override\n    public TypeBuilderInternal<T> defaultImplementation(Class<?> implementation) {\n        if (this.schema instanceof ManagedImplSchema) {\n            throw new InvalidModelException(String.format(\"Method annotated with @%s cannot set default implementation for managed type %s.\", markerAnnotation.getSimpleName(), schema.getType().getName()));\n        }\n        if (this.implementation != null) {\n            throw new InvalidModelException(String.format(\"Method annotated with @%s cannot set default implementation multiple times.\", markerAnnotation.getSimpleName()));\n        }\n        this.implementation = implementation;\n        return this;\n    }","commit_id":"aa11ae1b6e31abcb2a4a63ad9908cbedbf7fc827","url":"https://github.com/gradle/gradle"},{"original_method":"public LanguageSourceSetFactory(final SourceDirectorySetFactory sourceDirectorySetFactory) {\n        super(LanguageSourceSet.class, BaseLanguageSourceSet.class);\n        registerFactory(BaseLanguageSourceSet.class, new ImplementationFactory<LanguageSourceSet, BaseLanguageSourceSet>() {\n            @Override\n            public <T extends BaseLanguageSourceSet> T create(ModelType<? extends LanguageSourceSet> publicType, ModelType<T> implementationType, String sourceSetName, MutableModelNode node) {\n                return Cast.uncheckedCast(BaseLanguageSourceSet.create(publicType.getConcreteClass(), implementationType.getConcreteClass(), sourceSetName, determineParentName(node), sourceDirectorySetFactory));\n            }\n        });\n    }","id":60306,"modified_method":"public LanguageSourceSetFactory(final SourceDirectorySetFactory sourceDirectorySetFactory) {\n        super(LanguageSourceSet.class);\n        registerFactory(BaseLanguageSourceSet.class, new ImplementationFactory<LanguageSourceSet, BaseLanguageSourceSet>() {\n            @Override\n            public <T extends BaseLanguageSourceSet> T create(ModelType<? extends LanguageSourceSet> publicType, ModelType<T> implementationType, String sourceSetName, MutableModelNode node) {\n                return Cast.uncheckedCast(BaseLanguageSourceSet.create(publicType.getConcreteClass(), implementationType.getConcreteClass(), sourceSetName, determineParentName(node), sourceDirectorySetFactory));\n            }\n        });\n    }","commit_id":"aa11ae1b6e31abcb2a4a63ad9908cbedbf7fc827","url":"https://github.com/gradle/gradle"},{"original_method":"public LanguageTypeModelRuleExtractor(ModelSchemaStore schemaStore) {\n        super(\"language\", LanguageSourceSet.class, BaseLanguageSourceSet.class, ModelReference.of(LanguageSourceSetFactory.class), ImmutableList.of(LanguageBasePlugin.class), schemaStore);\n    }","id":60307,"modified_method":"public LanguageTypeModelRuleExtractor(ModelSchemaStore schemaStore) {\n        super(\"language\", LanguageSourceSet.class, ModelReference.of(LanguageSourceSetFactory.class), ImmutableList.of(LanguageBasePlugin.class), schemaStore);\n    }","commit_id":"aa11ae1b6e31abcb2a4a63ad9908cbedbf7fc827","url":"https://github.com/gradle/gradle"},{"original_method":"private ModelType<? extends BASEIMPL> determineImplementationType(ModelType<?> type, TypeBuilderInternal<?> builder) {\n        for (Class<?> internalView : builder.getInternalViews()) {\n            if (!internalView.isInterface()) {\n                throw new InvalidModelException(String.format(\"Internal view %s must be an interface.\", internalView.getName()));\n            }\n        }\n\n        Class<?> implementation = builder.getDefaultImplementation();\n        if (implementation == null) {\n            return null;\n        }\n\n        ModelType<?> implementationType = ModelType.of(implementation);\n\n        if (!baseImplementation.isAssignableFrom(implementationType)) {\n            throw new InvalidModelException(String.format(\"%s implementation %s must extend %s.\", StringUtils.capitalize(modelName), implementationType, baseImplementation));\n        }\n\n        ModelType<? extends BASEIMPL> asSubclass = implementationType.asSubtype(baseImplementation);\n        if (!type.isAssignableFrom(asSubclass)) {\n            throw new InvalidModelException(String.format(\"%s implementation %s must implement %s.\", StringUtils.capitalize(modelName), asSubclass, type));\n        }\n\n        for (Class<?> internalView : builder.getInternalViews()) {\n            if (!internalView.isAssignableFrom(implementation)) {\n                throw new InvalidModelException(String.format(\"%s implementation %s must implement internal view %s.\", StringUtils.capitalize(modelName), asSubclass, internalView.getName()));\n            }\n        }\n\n        try {\n            asSubclass.getRawClass().getConstructor();\n        } catch (NoSuchMethodException nsmException) {\n            throw new InvalidModelException(String.format(\"%s implementation %s must have public default constructor.\", StringUtils.capitalize(modelName), asSubclass));\n        }\n\n        return asSubclass;\n    }","id":60308,"modified_method":"private ModelType<?> determineImplementationType(TypeBuilderInternal<?> builder) {\n        for (Class<?> internalView : builder.getInternalViews()) {\n            if (!internalView.isInterface()) {\n                throw new InvalidModelException(String.format(\"Internal view %s must be an interface.\", internalView.getName()));\n            }\n        }\n\n        Class<?> implementation = builder.getDefaultImplementation();\n        if (implementation == null) {\n            return null;\n        }\n\n        return ModelType.of(implementation);\n    }","commit_id":"aa11ae1b6e31abcb2a4a63ad9908cbedbf7fc827","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n            protected void execute(ModelRuleInvoker<?> invoker, REGISTRY registry, List<ModelView<?>> inputs) {\n                try {\n                    ModelSchema<PUBLICTYPE> schema = schemaStore.getSchema(publicType);\n                    TypeBuilderInternal<PUBLICTYPE> builder = new DefaultTypeBuilder<PUBLICTYPE>(getAnnotationType(), schema);\n                    invoker.invoke(builder);\n                    ModelType<? extends BASEIMPL> implModelType = determineImplementationType(publicType, builder);\n                    registry.register(publicType, builder.getInternalViews(), implModelType, ruleDefinition.getDescriptor());\n                } catch (InvalidModelException e) {\n                    throw invalidModelRule(ruleDefinition, e);\n                }\n            }","id":60309,"modified_method":"@Override\n            protected void execute(ModelRuleInvoker<?> invoker, REGISTRY registry, List<ModelView<?>> inputs) {\n                try {\n                    ModelSchema<PUBLICTYPE> schema = schemaStore.getSchema(publicType);\n                    TypeBuilderInternal<PUBLICTYPE> builder = new DefaultTypeBuilder<PUBLICTYPE>(getAnnotationType(), schema);\n                    invoker.invoke(builder);\n                    ModelType<?> implModelType = determineImplementationType(builder);\n                    registry.register(publicType, builder.getInternalViews(), implModelType, ruleDefinition.getDescriptor());\n                } catch (InvalidModelException e) {\n                    throw invalidModelRule(ruleDefinition, e);\n                }\n            }","commit_id":"aa11ae1b6e31abcb2a4a63ad9908cbedbf7fc827","url":"https://github.com/gradle/gradle"},{"original_method":"public TypeModelRuleExtractor(String modelName, Class<TYPE> baseInterface, Class<BASEIMPL> baseImplementation, ModelReference<REGISTRY> registryRef, List<? extends Class<?>> requiredPlugins, ModelSchemaStore schemaStore) {\n        this.modelName = modelName;\n        this.registryRef = registryRef;\n        this.requiredPlugins = requiredPlugins;\n        this.schemaStore = schemaStore;\n        this.baseInterface = ModelType.of(baseInterface);\n        this.baseImplementation = ModelType.of(baseImplementation);\n    }","id":60310,"modified_method":"public TypeModelRuleExtractor(String modelName, Class<TYPE> baseInterface, ModelReference<REGISTRY> registryRef, List<? extends Class<?>> requiredPlugins, ModelSchemaStore schemaStore) {\n        this.modelName = modelName;\n        this.registryRef = registryRef;\n        this.requiredPlugins = requiredPlugins;\n        this.schemaStore = schemaStore;\n        this.baseInterface = ModelType.of(baseInterface);\n    }","commit_id":"aa11ae1b6e31abcb2a4a63ad9908cbedbf7fc827","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected <R> ModelSchema<R> createSchema(ModelSchemaExtractionContext<R> extractionContext, ModelSchemaStore store, ModelType<R> type, List<ModelProperty<?>> properties, List<ModelSchemaAspect> aspects) {\n        return AbstractModelSchema.struct(type, properties, aspects, type.getConcreteClass(), BinarySpecInternal.class, new Function<ModelManagedImplStructSchema<R>, NodeInitializer>() {\n            @Override\n            public NodeInitializer apply(ModelManagedImplStructSchema<R> schema) {\n                return null;\n            }\n        });\n    }","id":60311,"modified_method":"@Override\n    protected <R> ModelSchema<R> createSchema(ModelSchemaExtractionContext<R> extractionContext, ModelSchemaStore store, ModelType<R> type, List<ModelProperty<?>> properties, List<ModelSchemaAspect> aspects) {\n        return new ModelManagedImplStructSchema<R>(type, properties, aspects, type.getConcreteClass(), BinarySpecInternal.class, new Function<ModelManagedImplStructSchema<R>, NodeInitializer>() {\n            @Override\n            public NodeInitializer apply(ModelManagedImplStructSchema<R> schema) {\n                return null;\n            }\n        });\n    }","commit_id":"2f6374f75c379e6a82c2877ccea798367715243c","url":"https://github.com/gradle/gradle"},{"original_method":"public <T> ModelSchemaExtractionResult<T> extract(ModelSchemaExtractionContext<T> extractionContext, ModelSchemaStore store, ModelSchemaCache cache) {\n        ModelType<T> type = extractionContext.getType();\n        if (type.getRawClass().isEnum()) {\n            return new ModelSchemaExtractionResult<T>(AbstractModelSchema.value(type));\n        } else {\n            return null;\n        }\n    }","id":60312,"modified_method":"public <T> ModelSchemaExtractionResult<T> extract(ModelSchemaExtractionContext<T> extractionContext, ModelSchemaStore store, ModelSchemaCache cache) {\n        ModelType<T> type = extractionContext.getType();\n        if (type.getRawClass().isEnum()) {\n            return new ModelSchemaExtractionResult<T>(new ModelValueSchema<T>(type));\n        } else {\n            return null;\n        }\n    }","commit_id":"2f6374f75c379e6a82c2877ccea798367715243c","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected <R> ModelSchema<R> createSchema(final ModelSchemaExtractionContext<R> extractionContext, final ModelSchemaStore store, ModelType<R> type, List<ModelProperty<?>> properties, List<ModelSchemaAspect> aspects) {\n        Class<? extends R> implClass = classGenerator.generate(type.getConcreteClass(), JarBinarySpecInternal.class, properties);\n        return AbstractModelSchema.struct(type, properties, aspects, implClass, JarBinarySpecInternal.class, new Function<ModelManagedImplStructSchema<R>, NodeInitializer>() {\n            @Override\n            public NodeInitializer apply(ModelManagedImplStructSchema<R> schema) {\n                return new JarBinarySpecSpecializationModelInitializer<R>(schema, store);\n            }\n        });\n    }","id":60313,"modified_method":"@Override\n    protected <R> ModelSchema<R> createSchema(final ModelSchemaExtractionContext<R> extractionContext, final ModelSchemaStore store, ModelType<R> type, List<ModelProperty<?>> properties, List<ModelSchemaAspect> aspects) {\n        Class<? extends R> implClass = classGenerator.generate(type.getConcreteClass(), JarBinarySpecInternal.class, properties);\n        return new ModelManagedImplStructSchema<R>(type, properties, aspects, implClass, JarBinarySpecInternal.class, new Function<ModelManagedImplStructSchema<R>, NodeInitializer>() {\n            @Override\n            public NodeInitializer apply(ModelManagedImplStructSchema<R> schema) {\n                return new JarBinarySpecSpecializationModelInitializer<R>(schema, store);\n            }\n        });\n    }","commit_id":"2f6374f75c379e6a82c2877ccea798367715243c","url":"https://github.com/gradle/gradle"},{"original_method":"public <R> ModelSchemaExtractionResult<R> extract(ModelSchemaExtractionContext<R> extractionContext, ModelSchemaStore store, ModelSchemaCache cache) {\n        ModelType<R> type = extractionContext.getType();\n        if (TYPES.contains(type)) {\n            return new ModelSchemaExtractionResult<R>(AbstractModelSchema.value(type));\n        } else {\n            for (ModelType<?> nonFinalType : NON_FINAL_TYPES) {\n                if (nonFinalType.isAssignableFrom(type)) {\n                    throw new InvalidManagedModelElementTypeException(extractionContext, \"subclasses of \" + nonFinalType + \" are not supported\");\n                }\n            }\n\n            return null;\n        }\n    }","id":60314,"modified_method":"public <R> ModelSchemaExtractionResult<R> extract(ModelSchemaExtractionContext<R> extractionContext, ModelSchemaStore store, ModelSchemaCache cache) {\n        ModelType<R> type = extractionContext.getType();\n        if (TYPES.contains(type)) {\n            return new ModelSchemaExtractionResult<R>(new ModelValueSchema<R>(type));\n        } else {\n            for (ModelType<?> nonFinalType : NON_FINAL_TYPES) {\n                if (nonFinalType.isAssignableFrom(type)) {\n                    throw new InvalidManagedModelElementTypeException(extractionContext, \"subclasses of \" + nonFinalType + \" are not supported\");\n                }\n            }\n\n            return null;\n        }\n    }","commit_id":"2f6374f75c379e6a82c2877ccea798367715243c","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected <R> ModelSchema<R> createSchema(final ModelSchemaExtractionContext<R> extractionContext, final ModelSchemaStore store, ModelType<R> type, List<ModelProperty<?>> properties, List<ModelSchemaAspect> aspects) {\n        Class<? extends R> implClass = classGenerator.generate(type.getConcreteClass(), properties);\n        final ModelManagedImplStructSchema<R> schema = AbstractModelSchema.struct(type, properties, aspects, implClass, null, new Function<ModelManagedImplStructSchema<R>, NodeInitializer>() {\n            @Override\n            public NodeInitializer apply(ModelManagedImplStructSchema<R> schema) {\n                return new ManagedModelInitializer<R>(schema, store);\n            }\n        });\n        extractionContext.addValidator(new Action<ModelSchemaExtractionContext<R>>() {\n            @Override\n            public void execute(ModelSchemaExtractionContext<R> validatorModelSchemaExtractionContext) {\n                ensureCanBeInstantiated(extractionContext, schema);\n            }\n        });\n        return schema;\n    }","id":60315,"modified_method":"@Override\n    protected <R> ModelSchema<R> createSchema(final ModelSchemaExtractionContext<R> extractionContext, final ModelSchemaStore store, ModelType<R> type, List<ModelProperty<?>> properties, List<ModelSchemaAspect> aspects) {\n        Class<? extends R> implClass = classGenerator.generate(type.getConcreteClass(), properties);\n        final ModelManagedImplStructSchema<R> schema = new ModelManagedImplStructSchema<R>(type, properties, aspects, implClass, null, new Function<ModelManagedImplStructSchema<R>, NodeInitializer>() {\n            @Override\n            public NodeInitializer apply(ModelManagedImplStructSchema<R> schema) {\n                return new ManagedModelInitializer<R>(schema, store);\n            }\n        });\n        extractionContext.addValidator(new Action<ModelSchemaExtractionContext<R>>() {\n            @Override\n            public void execute(ModelSchemaExtractionContext<R> validatorModelSchemaExtractionContext) {\n                ensureCanBeInstantiated(extractionContext, schema);\n            }\n        });\n        return schema;\n    }","commit_id":"2f6374f75c379e6a82c2877ccea798367715243c","url":"https://github.com/gradle/gradle"},{"original_method":"private <T, E> ModelSchemaExtractionResult<T> gettModelSchemaExtractionResult(ModelSchemaExtractionContext<T> extractionContext, final ModelSchemaCache cache, ModelType<E> elementType, final ModelSchemaStore store) {\n        ModelCollectionSchema<T, E> schema = AbstractModelSchema.collection(extractionContext.getType(), elementType, new Function<ModelCollectionSchema<T, E>, NodeInitializer>() {\n            @Override\n            public NodeInitializer apply(ModelCollectionSchema<T, E> input) {\n                final ManagedChildNodeCreatorStrategy<E> childCreator = new ManagedChildNodeCreatorStrategy<E>(store);\n                return new ProjectionOnlyNodeInitializer(ModelMapModelProjection.managed(input.getElementType(), childCreator));\n            }\n        });\n        ModelSchemaExtractionContext<?> typeParamExtractionContext = extractionContext.child(elementType, \"element type\", Actions.doNothing());\n        return new ModelSchemaExtractionResult<T>(schema, ImmutableList.of(typeParamExtractionContext));\n    }","id":60316,"modified_method":"private <T, E> ModelSchemaExtractionResult<T> gettModelSchemaExtractionResult(ModelSchemaExtractionContext<T> extractionContext, final ModelSchemaCache cache, ModelType<E> elementType, final ModelSchemaStore store) {\n        ModelCollectionSchema<T, E> schema = new ModelCollectionSchema<T, E>(extractionContext.getType(), elementType, new Function<ModelCollectionSchema<T, E>, NodeInitializer>() {\n            @Override\n            public NodeInitializer apply(ModelCollectionSchema<T, E> input) {\n                final ManagedChildNodeCreatorStrategy<E> childCreator = new ManagedChildNodeCreatorStrategy<E>(store);\n                return new ProjectionOnlyNodeInitializer(ModelMapModelProjection.managed(input.getElementType(), childCreator));\n            }\n        });\n        ModelSchemaExtractionContext<?> typeParamExtractionContext = extractionContext.child(elementType, \"element type\", Actions.doNothing());\n        return new ModelSchemaExtractionResult<T>(schema, ImmutableList.of(typeParamExtractionContext));\n    }","commit_id":"2f6374f75c379e6a82c2877ccea798367715243c","url":"https://github.com/gradle/gradle"},{"original_method":"public <T> ModelSchemaExtractionResult<T> extract(ModelSchemaExtractionContext<T> extractionContext, ModelSchemaStore store, ModelSchemaCache cache) {\n        ModelType<T> type = extractionContext.getType();\n        if (type.getRawClass().isPrimitive()) {\n            return new ModelSchemaExtractionResult<T>(AbstractModelSchema.value(type));\n        }\n\n        return null;\n    }","id":60317,"modified_method":"public <T> ModelSchemaExtractionResult<T> extract(ModelSchemaExtractionContext<T> extractionContext, ModelSchemaStore store, ModelSchemaCache cache) {\n        ModelType<T> type = extractionContext.getType();\n        if (type.getRawClass().isPrimitive()) {\n            return new ModelSchemaExtractionResult<T>(new ModelValueSchema<T>(type));\n        }\n\n        return null;\n    }","commit_id":"2f6374f75c379e6a82c2877ccea798367715243c","url":"https://github.com/gradle/gradle"},{"original_method":"private <T, E> ModelSchemaExtractionResult<T> gettModelSchemaExtractionResult(ModelSchemaExtractionContext<T> extractionContext, final ModelSchemaCache cache, ModelType<E> elementType, ModelSchemaStore store) {\n        if (modelType.isAssignableFrom(elementType)) {\n            throw new InvalidManagedModelElementTypeException(extractionContext, String.format(\"%1$s cannot be used as type parameter of %1$s\", modelType.getConcreteClass().getName()));\n        }\n\n        ModelCollectionSchema<T, E> schema = AbstractModelSchema.collection(extractionContext.getType(), elementType, this.<T, E>getNodeInitializer(store));\n        ModelSchemaExtractionContext<?> typeParamExtractionContext = extractionContext.child(elementType, \"element type\", new Action<ModelSchemaExtractionContext<?>>() {\n            public void execute(ModelSchemaExtractionContext<?> context) {\n                ModelSchema<?> typeParamSchema = cache.get(context.getType());\n\n                if (!typeParamSchema.getKind().isManaged()) {\n                    throw new InvalidManagedModelElementTypeException(context.getParent(), String.format(\n                        \"cannot create a managed set of type %s as it is an unmanaged type. Only @Managed types are allowed.\",\n                        context.getType()\n                    ));\n                }\n            }\n        });\n        return new ModelSchemaExtractionResult<T>(schema, ImmutableList.of(typeParamExtractionContext));\n    }","id":60318,"modified_method":"private <T, E> ModelSchemaExtractionResult<T> gettModelSchemaExtractionResult(ModelSchemaExtractionContext<T> extractionContext, final ModelSchemaCache cache, ModelType<E> elementType, ModelSchemaStore store) {\n        if (modelType.isAssignableFrom(elementType)) {\n            throw new InvalidManagedModelElementTypeException(extractionContext, String.format(\"%1$s cannot be used as type parameter of %1$s\", modelType.getConcreteClass().getName()));\n        }\n\n        ModelCollectionSchema<T, E> schema = new ModelCollectionSchema<T, E>(extractionContext.getType(), elementType, this.<T, E>getNodeInitializer(store));\n        ModelSchemaExtractionContext<?> typeParamExtractionContext = extractionContext.child(elementType, \"element type\", new Action<ModelSchemaExtractionContext<?>>() {\n            public void execute(ModelSchemaExtractionContext<?> context) {\n                ModelSchema<?> typeParamSchema = cache.get(context.getType());\n\n                if (!typeParamSchema.getKind().isManaged()) {\n                    throw new InvalidManagedModelElementTypeException(context.getParent(), String.format(\n                        \"cannot create a managed set of type %s as it is an unmanaged type. Only @Managed types are allowed.\",\n                        context.getType()\n                    ));\n                }\n            }\n        });\n        return new ModelSchemaExtractionResult<T>(schema, ImmutableList.of(typeParamExtractionContext));\n    }","commit_id":"2f6374f75c379e6a82c2877ccea798367715243c","url":"https://github.com/gradle/gradle"},{"original_method":"@Nullable\n    @Override\n    public <T> ModelSchemaExtractionResult<T> extract(ModelSchemaExtractionContext<T> extractionContext, ModelSchemaStore store, ModelSchemaCache cache) {\n        Type type = extractionContext.getType().getType();\n        if (!(type instanceof Class)) {\n            return null;\n        }\n        Class<?> contractType = (Class<?>) type;\n        if (!contractType.isInterface()) {\n            return null;\n        }\n        if (contractType.getGenericInterfaces().length != 1) {\n            return null;\n        }\n        Type superType = contractType.getGenericInterfaces()[0];\n        if (!(superType instanceof ParameterizedType)) {\n            return null;\n        }\n        ParameterizedType parameterizedSuperType = (ParameterizedType) superType;\n        if (!parameterizedSuperType.getRawType().equals(ModelMap.class)) {\n            return null;\n        }\n        ModelType<?> elementType = ModelType.of(parameterizedSuperType.getActualTypeArguments()[0]);\n        Class<?> proxyImpl = generator.generate(ModelMapGroovyDecorator.class, contractType);\n        return new ModelSchemaExtractionResult<T>(AbstractModelSchema.specializedMap(extractionContext.getType(), elementType, proxyImpl));\n    }","id":60319,"modified_method":"@Nullable\n    @Override\n    public <T> ModelSchemaExtractionResult<T> extract(ModelSchemaExtractionContext<T> extractionContext, ModelSchemaStore store, ModelSchemaCache cache) {\n        Type type = extractionContext.getType().getType();\n        if (!(type instanceof Class)) {\n            return null;\n        }\n        Class<?> contractType = (Class<?>) type;\n        if (!contractType.isInterface()) {\n            return null;\n        }\n        if (contractType.getGenericInterfaces().length != 1) {\n            return null;\n        }\n        Type superType = contractType.getGenericInterfaces()[0];\n        if (!(superType instanceof ParameterizedType)) {\n            return null;\n        }\n        ParameterizedType parameterizedSuperType = (ParameterizedType) superType;\n        if (!parameterizedSuperType.getRawType().equals(ModelMap.class)) {\n            return null;\n        }\n        ModelType<?> elementType = ModelType.of(parameterizedSuperType.getActualTypeArguments()[0]);\n        Class<?> proxyImpl = generator.generate(ModelMapGroovyDecorator.class, contractType);\n        return new ModelSchemaExtractionResult<T>(new ModelMapSchema<T>(extractionContext.getType(), elementType, proxyImpl));\n    }","commit_id":"2f6374f75c379e6a82c2877ccea798367715243c","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected <R> ModelSchema<R> createSchema(ModelSchemaExtractionContext<R> extractionContext, ModelSchemaStore store, ModelType<R> type, List<ModelProperty<?>> properties, List<ModelSchemaAspect> aspects) {\n        return AbstractModelSchema.struct(type, properties, aspects, type.getConcreteClass(), delegateType, Functions.<NodeInitializer>constant(null));\n    }","id":60320,"modified_method":"@Override\n    protected <R> ModelSchema<R> createSchema(ModelSchemaExtractionContext<R> extractionContext, ModelSchemaStore store, ModelType<R> type, List<ModelProperty<?>> properties, List<ModelSchemaAspect> aspects) {\n        return new ModelManagedImplStructSchema<R>(type, properties, aspects, type.getConcreteClass(), delegateType, Functions.<NodeInitializer>constant(null));\n    }","commit_id":"2f6374f75c379e6a82c2877ccea798367715243c","url":"https://github.com/gradle/gradle"},{"original_method":"protected <R> ModelSchema<R> createSchema(final ModelSchemaExtractionContext<R> extractionContext, final ModelSchemaStore store, ModelType<R> type, List<ModelProperty<?>> properties, List<ModelSchemaAspect> aspects) {\n        return AbstractModelSchema.unmanaged(type, properties, aspects);\n    }","id":60321,"modified_method":"protected <R> ModelSchema<R> createSchema(final ModelSchemaExtractionContext<R> extractionContext, final ModelSchemaStore store, ModelType<R> type, List<ModelProperty<?>> properties, List<ModelSchemaAspect> aspects) {\n        return new ModelUnmanagedImplStructSchema<R>(type, properties, aspects);\n    }","commit_id":"2f6374f75c379e6a82c2877ccea798367715243c","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\r\n\tpublic void draw (SpriteBatch batch, float parentAlpha) {\r\n\t\tfinal BitmapFont font = style.font;\r\n\t\tfinal Color fontColor = style.fontColor;\r\n\t\tfinal Drawable selection = style.selection;\r\n\t\tfinal Drawable cursorPatch = style.cursor;\r\n\r\n\t\tColor color = getColor();\r\n\t\tfloat x = getX();\r\n\t\tfloat y = getY();\r\n\t\tfloat width = getWidth();\r\n\t\tfloat height = getHeight();\r\n\r\n\t\tbatch.setColor(color.r, color.g, color.b, color.a * parentAlpha);\r\n\t\tfloat bgLeftWidth = 0;\r\n\t\tif (style.background != null) {\r\n\t\t\tstyle.background.draw(batch, x, y, width, height);\r\n\t\t\tbgLeftWidth = style.background.getLeftWidth();\r\n\t\t}\r\n\r\n\t\tfloat textY = (int)(height / 2 + textBounds.height / 2 + font.getDescent());\r\n\t\tcalculateOffsets();\r\n\r\n\t\tStage stage = getStage();\r\n\t\tboolean focused = stage != null && stage.getKeyboardFocus() == this;\r\n\t\tif (focused && hasSelection && selection != null) {\r\n\t\t\tselection.draw(batch, x + selectionX + bgLeftWidth + renderOffset,\r\n\t\t\t\ty + textY - textBounds.height - font.getDescent() / 2, selectionWidth, textBounds.height);\r\n\t\t}\r\n\r\n\t\tif (displayText.length() == 0) {\r\n\t\t\tif (!focused && messageText != null) {\r\n\t\t\t\tif (style.messageFontColor != null) {\r\n\t\t\t\t\tfont.setColor(style.messageFontColor.r, style.messageFontColor.g, style.messageFontColor.b,\r\n\t\t\t\t\t\tstyle.messageFontColor.a * parentAlpha);\r\n\t\t\t\t} else\r\n\t\t\t\t\tfont.setColor(0.7f, 0.7f, 0.7f, parentAlpha);\r\n\t\t\t\tBitmapFont messageFont = style.messageFont != null ? style.messageFont : font;\r\n\t\t\t\tfont.draw(batch, messageText, x + bgLeftWidth, y + textY);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfont.setColor(fontColor.r, fontColor.g, fontColor.b, fontColor.a * parentAlpha);\r\n\t\t\tfont.draw(batch, displayText, x + bgLeftWidth + textOffset, y + textY, visibleTextStart, visibleTextEnd);\r\n\t\t}\r\n\t\tif (focused) {\r\n\t\t\tblink();\r\n\t\t\tif (cursorOn && cursorPatch != null) {\r\n\t\t\t\tcursorPatch.draw(batch, x + bgLeftWidth + glyphPositions.get(cursor) + renderOffset - 1, y + textY\r\n\t\t\t\t\t- textBounds.height - font.getDescent(), cursorPatch.getMinWidth(), textBounds.height + font.getDescent() / 2);\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":60322,"modified_method":"@Override\r\n\tpublic void draw (SpriteBatch batch, float parentAlpha) {\r\n\t\tfinal BitmapFont font = style.font;\r\n\t\tfinal Color fontColor = style.fontColor;\r\n\t\tfinal Drawable selection = style.selection;\r\n\t\tfinal Drawable cursorPatch = style.cursor;\r\n\r\n\t\tColor color = getColor();\r\n\t\tfloat x = getX();\r\n\t\tfloat y = getY();\r\n\t\tfloat width = getWidth();\r\n\t\tfloat height = getHeight();\r\n\r\n\t\tbatch.setColor(color.r, color.g, color.b, color.a * parentAlpha);\r\n\t\tfloat bgLeftWidth = 0;\r\n\t\tif (style.background != null) {\r\n\t\t\tstyle.background.draw(batch, x, y, width, height);\r\n\t\t\tbgLeftWidth = style.background.getLeftWidth();\r\n\t\t}\r\n\r\n\t\tfloat textY = (int)(height / 2 + textBounds.height / 2 + font.getDescent());\r\n\t\tcalculateOffsets();\r\n\r\n\t\tStage stage = getStage();\r\n\t\tboolean focused = stage != null && stage.getKeyboardFocus() == this;\r\n\t\tif (focused && hasSelection && selection != null) {\r\n\t\t\tselection.draw(batch, x + selectionX + bgLeftWidth + renderOffset, y + textY - textBounds.height - font.getDescent(),\r\n\t\t\t\tselectionWidth, textBounds.height + font.getDescent() / 2);\r\n\t\t}\r\n\r\n\t\tif (displayText.length() == 0) {\r\n\t\t\tif (!focused && messageText != null) {\r\n\t\t\t\tif (style.messageFontColor != null) {\r\n\t\t\t\t\tfont.setColor(style.messageFontColor.r, style.messageFontColor.g, style.messageFontColor.b,\r\n\t\t\t\t\t\tstyle.messageFontColor.a * parentAlpha);\r\n\t\t\t\t} else\r\n\t\t\t\t\tfont.setColor(0.7f, 0.7f, 0.7f, parentAlpha);\r\n\t\t\t\tBitmapFont messageFont = style.messageFont != null ? style.messageFont : font;\r\n\t\t\t\tfont.draw(batch, messageText, x + bgLeftWidth, y + textY);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfont.setColor(fontColor.r, fontColor.g, fontColor.b, fontColor.a * parentAlpha);\r\n\t\t\tfont.draw(batch, displayText, x + bgLeftWidth + textOffset, y + textY, visibleTextStart, visibleTextEnd);\r\n\t\t}\r\n\t\tif (focused) {\r\n\t\t\tblink();\r\n\t\t\tif (cursorOn && cursorPatch != null) {\r\n\t\t\t\tcursorPatch.draw(batch, x + bgLeftWidth + glyphPositions.get(cursor) + renderOffset - 1, y + textY\r\n\t\t\t\t\t- textBounds.height - font.getDescent(), cursorPatch.getMinWidth(), textBounds.height + font.getDescent() / 2);\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"155b37b84bbbd5cbbdbc7317e4be846cf7f8ffc4","url":"https://github.com/libgdx/libgdx"},{"original_method":"public Skin (FileHandle skinFile, FileHandle textureFile) {\r\n\t\tthis(skinFile);\r\n\t\tdata.texture = new Texture(textureFile);\r\n\t}","id":60323,"modified_method":"public Skin (FileHandle skinFile, FileHandle textureFile) {\r\n\t\tdata = new SkinData();\r\n\t\tdata.texture = new Texture(textureFile);\r\n\t\ttry {\r\n\t\t\tgetJsonLoader(skinFile).fromJson(Skin.class, skinFile);\r\n\t\t} catch (SerializationException ex) {\r\n\t\t\tthrow new SerializationException(\"Error reading file: \" + skinFile, ex);\r\n\t\t}\r\n\t}","commit_id":"51e632aa18ecd248fdad371f82f7cb315477a042","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void draw (SpriteBatch batch, float parentAlpha) {\r\n\t\tfinal BitmapFont font = style.font;\r\n\t\tfinal Color fontColor = style.fontColor;\r\n\t\tfinal NinePatch background = style.background;\r\n\t\tfinal TextureRegion selection = style.selection;\r\n\t\tfinal NinePatch cursorPatch = style.cursor;\r\n\r\n\t\tif (invalidated) layout();\r\n\r\n\t\tbatch.setColor(color.r, color.g, color.b, color.a * parentAlpha);\r\n\t\tbackground.draw(batch, x, y, width, height);\r\n\t\tfloat textY = (int)(height / 2) + (int)(textBounds.height / 2) + font.getDescent() / 2;\r\n\t\tfont.setColor(fontColor.r, fontColor.g, fontColor.b, fontColor.a * parentAlpha);\r\n\t\tcalculateOffsets();\r\n\r\n\t\tif (hasSelection) {\r\n\t\t\tbatch.draw(selection, x + selectionX + background.getLeftWidth() + renderOffset,\r\n\t\t\t\ty + textY - textBounds.height - font.getDescent() / 2, selectionWidth, textBounds.height);\r\n\t\t}\r\n\r\n\t\tfont.draw(batch, text, x + background.getLeftWidth() + textOffset, y + textY, visibleTextStart, visibleTextEnd);\r\n\t\tif (parent.keyboardFocusedActor == this) {\r\n\t\t\tblink();\r\n\t\t\tif (cursorOn) {\r\n\t\t\t\tcursorPatch.draw(batch, x + background.getLeftWidth() + glyphPositions.get(cursor) + renderOffset - 1, y + textY\r\n\t\t\t\t\t- textBounds.height - font.getDescent() / 2, cursorPatch.getTotalWidth(), textBounds.height);\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":60324,"modified_method":"@Override\r\n\tpublic void draw (SpriteBatch batch, float parentAlpha) {\r\n\t\tfinal BitmapFont font = style.font;\r\n\t\tfinal Color fontColor = style.fontColor;\r\n\t\tfinal NinePatch background = style.background;\r\n\t\tfinal TextureRegion selection = style.selection;\r\n\t\tfinal NinePatch cursorPatch = style.cursor;\r\n\r\n\t\tif (invalidated) layout();\r\n\r\n\t\tbatch.setColor(color.r, color.g, color.b, color.a * parentAlpha);\r\n\t\tbackground.draw(batch, x, y, width, height);\r\n\t\tfloat textY = (int)(height / 2) + (int)(textBounds.height / 2) + font.getDescent() / 2;\r\n\t\tfont.setColor(fontColor.r, fontColor.g, fontColor.b, fontColor.a * parentAlpha);\r\n\t\tcalculateOffsets();\r\n\r\n\t\tif (hasSelection) {\r\n\t\t\tbatch.draw(selection, x + selectionX + background.getLeftWidth() + renderOffset,\r\n\t\t\t\ty + textY - textBounds.height - font.getDescent() / 2, selectionWidth, textBounds.height);\r\n\t\t}\r\n\r\n\t\tfont.draw(batch, text, x + background.getLeftWidth() + textOffset, y + textY, visibleTextStart, visibleTextEnd);\r\n\t\tif (parent.keyboardFocusedActor == this) {\r\n\t\t\tblink();\r\n\t\t\tif (cursorOn) {\r\n\t\t\t\tcursorPatch.draw(batch, x + background.getLeftWidth() + glyphPositions.get(cursor) + renderOffset - 1, y + textY\r\n\t\t\t\t\t- textBounds.height - font.getDescent(), cursorPatch.getTotalWidth(), textBounds.height + font.getDescent() / 2);\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"51e632aa18ecd248fdad371f82f7cb315477a042","url":"https://github.com/libgdx/libgdx"},{"original_method":"private int setHeight(int itemCount){\n    if(scrollPane.getHorizontalScrollBar().isVisible()) itemCount++;\n    FontMetrics fm = textarea.getFontMetrics(textarea.getFont()); \n    float h = (fm.getHeight() +  fm.getDescent()*0.5f) * (itemCount + 1);\n    log(\"popup height \" + Math.min(250,h));\n    return Math.min(250,(int)h); // popup menu height\n  }","id":60325,"modified_method":"private int setHeight(int itemCount){\n    FontMetrics fm = textarea.getFontMetrics(textarea.getFont());\n    float h = (fm.getHeight() + (fm.getDescent()) * 0.5f) * (itemCount);\n    if (scrollPane.getHorizontalScrollBar().isVisible())\n      h += scrollPane.getHorizontalScrollBar().getHeight() + fm.getHeight()\n          + (fm.getDescent() + fm.getAscent()) * 0.8f;\n    // 0.5f and 0.8f scaling give respectable results.\n    //log(\"popup height \" + Math.min(250,h) \n    //+ scrollPane.getHorizontalScrollBar().isVisible());\n    return Math.min(250, (int) h); // popup menu height\n  }","commit_id":"a6de454da33a0befba12a2628e40c93d96b49547","url":"https://github.com/processing/processing"},{"original_method":"/**\n     * Deletes the index store trying to acquire all shards locks for this index.\n     * This method will delete the metadata for the index even if the actual shards can't be locked.\n     */\n    public void deleteIndexStore(String reason, IndexMetaData metaData) throws IOException {\n        if (nodeEnv.hasNodeFile()) {\n            synchronized (this) {\n                String indexName = metaData.index();\n                if (indices.containsKey(metaData.index())) {\n                    String localUUid = indices.get(metaData.index()).v1().indexUUID();\n                    throw new ElasticsearchIllegalStateException(\"Can't delete index store for [\" + metaData.getIndex() + \"] - it's still part of the indices service [\" + localUUid+ \"] [\" + metaData.getUUID() + \"]\");\n                }\n                ClusterState clusterState = clusterService.state();\n                if (clusterState.metaData().hasIndex(indexName)) {\n                    final IndexMetaData index = clusterState.metaData().index(indexName);\n                    throw new ElasticsearchIllegalStateException(\"Can't delete closed index store for [\" + indexName + \"] - it's still part of the cluster state [\" + index.getUUID() + \"] [\" + metaData.getUUID() + \"]\");\n                }\n            }\n            Index index = new Index(metaData.index());\n            final Settings indexSettings = buildIndexSettings(metaData);\n            deleteIndexStore(reason, index, indexSettings);\n        }\n    }","id":60326,"modified_method":"/**\n     * Deletes the index store trying to acquire all shards locks for this index.\n     * This method will delete the metadata for the index even if the actual shards can't be locked.\n     */\n    public void deleteIndexStore(String reason, IndexMetaData metaData) throws IOException {\n        if (nodeEnv.hasNodeFile()) {\n            synchronized (this) {\n                String indexName = metaData.index();\n                if (indices.containsKey(indexName)) {\n                    String localUUid = indices.get(indexName).v1().indexUUID();\n                    throw new ElasticsearchIllegalStateException(\"Can't delete index store for [\" + indexName + \"] - it's still part of the indices service [\" + localUUid+ \"] [\" + metaData.getUUID() + \"]\");\n                }\n                ClusterState clusterState = clusterService.state();\n                if (clusterState.metaData().hasIndex(indexName) && (clusterState.nodes().localNode().masterNode() == true)) {\n                    // we do not delete the store if it is a master eligible node and the index is still in the cluster state\n                    // because we want to keep the meta data for indices around even if no shards are left here\n                    final IndexMetaData index = clusterState.metaData().index(indexName);\n                    throw new ElasticsearchIllegalStateException(\"Can't delete closed index store for [\" + indexName + \"] - it's still part of the cluster state [\" + index.getUUID() + \"] [\" + metaData.getUUID() + \"]\");\n                }\n            }\n            Index index = new Index(metaData.index());\n            final Settings indexSettings = buildIndexSettings(metaData);\n            deleteIndexStore(reason, index, indexSettings);\n        }\n    }","commit_id":"cea8999406cba545acda9e1c2a51391b2912a59e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void allNodesResponded() {\n            if (activeCopies.get() != expectedActiveCopies) {\n                logger.trace(\"not deleting shard {}, expected {} active copies, but only {} found active copies\", shardId, expectedActiveCopies, activeCopies.get());\n                return;\n            }\n\n            ClusterState latestClusterState = clusterService.state();\n            if (clusterState.getVersion() != latestClusterState.getVersion()) {\n                logger.trace(\"not deleting shard {}, the latest cluster state version[{}] is not equal to cluster state before shard active api call [{}]\", shardId, latestClusterState.getVersion(), clusterState.getVersion());\n                return;\n            }\n\n            clusterService.submitStateUpdateTask(\"indices_store\", new ClusterStateNonMasterUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) throws Exception {\n                    if (clusterState.getVersion() != currentState.getVersion()) {\n                        logger.trace(\"not deleting shard {}, the update task state version[{}] is not equal to cluster state before shard active api call [{}]\", shardId, currentState.getVersion(), clusterState.getVersion());\n                        return currentState;\n                    }\n                    IndexMetaData indexMeta = clusterState.getMetaData().indices().get(shardId.getIndex());\n                    try {\n                        indicesService.deleteShardStore(\"no longer used\", shardId, indexMeta);\n                    } catch (Exception ex) {\n                        logger.debug(\"{} failed to delete unallocated shard, ignoring\", ex, shardId);\n                    }\n                    return currentState;\n                }\n\n                @Override\n                public void onFailure(String source, Throwable t) {\n                    logger.error(\"{} unexpected error during deletion of unallocated shard\", t, shardId);\n                }\n            });\n        }","id":60327,"modified_method":"private void allNodesResponded() {\n            if (activeCopies.get() != expectedActiveCopies) {\n                logger.trace(\"not deleting shard {}, expected {} active copies, but only {} found active copies\", shardId, expectedActiveCopies, activeCopies.get());\n                return;\n            }\n\n            ClusterState latestClusterState = clusterService.state();\n            if (clusterState.getVersion() != latestClusterState.getVersion()) {\n                logger.trace(\"not deleting shard {}, the latest cluster state version[{}] is not equal to cluster state before shard active api call [{}]\", shardId, latestClusterState.getVersion(), clusterState.getVersion());\n                return;\n            }\n\n            clusterService.submitStateUpdateTask(\"indices_store\", new ClusterStateNonMasterUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) throws Exception {\n                    if (clusterState.getVersion() != currentState.getVersion()) {\n                        logger.trace(\"not deleting shard {}, the update task state version[{}] is not equal to cluster state before shard active api call [{}]\", shardId, currentState.getVersion(), clusterState.getVersion());\n                        return currentState;\n                    }\n                    IndexMetaData indexMeta = clusterState.getMetaData().indices().get(shardId.getIndex());\n                    try {\n                        indicesService.deleteShardStore(\"no longer used\", shardId, indexMeta);\n                    } catch (Throwable ex) {\n                        logger.debug(\"{} failed to delete unallocated shard, ignoring\", ex, shardId);\n                    }\n                    // if the index doesn't exists anymore, delete its store as well, but only if its a non master node, since master\n                    // nodes keep the index metadata around \n                    if (indicesService.hasIndex(shardId.getIndex()) == false && currentState.nodes().localNode().masterNode() == false) {\n                        try {\n                            indicesService.deleteIndexStore(\"no longer used\", indexMeta);\n                        } catch (Throwable ex) {\n                            logger.debug(\"{} failed to delete unallocated index, ignoring\", ex, shardId.getIndex());\n                        }\n                    }\n                    return currentState;\n                }\n\n                @Override\n                public void onFailure(String source, Throwable t) {\n                    logger.error(\"{} unexpected error during deletion of unallocated shard\", t, shardId);\n                }\n            });\n        }","commit_id":"cea8999406cba545acda9e1c2a51391b2912a59e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testShardActiveElseWhere() throws Exception {\n        String node_1 = internalCluster().startNode();\n        String node_2 = internalCluster().startNode();\n        final String node_1_id = internalCluster().getInstance(DiscoveryService.class, node_1).localNode().getId();\n        final String node_2_id = internalCluster().getInstance(DiscoveryService.class, node_2).localNode().getId();\n\n        final int numShards = scaledRandomIntBetween(2, 20);\n        assertAcked(prepareCreate(\"test\")\n                        .setSettings(ImmutableSettings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0).put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, numShards))\n        );\n        ensureGreen(\"test\");\n\n        ClusterStateResponse stateResponse = client().admin().cluster().prepareState().get();\n        RoutingNode routingNode = stateResponse.getState().routingNodes().node(node_2_id);\n        int[] node2Shards = new int[routingNode.numberOfOwningShards()];\n        int i = 0;\n        for (MutableShardRouting mutableShardRouting : routingNode) {\n            node2Shards[i++] = mutableShardRouting.shardId().id();\n        }\n        logger.info(\"Node 2 has shards: {}\", Arrays.toString(node2Shards));\n        waitNoPendingTasksOnAll();\n        internalCluster().getInstance(ClusterService.class, node_2).submitStateUpdateTask(\"test\", Priority.IMMEDIATE, new ClusterStateUpdateTask() {\n            @Override\n            public ClusterState execute(ClusterState currentState) throws Exception {\n                IndexRoutingTable.Builder indexRoutingTableBuilder = IndexRoutingTable.builder(\"test\");\n                for (int i = 0; i < numShards; i++) {\n                   indexRoutingTableBuilder.addIndexShard(\n                           new IndexShardRoutingTable.Builder(new ShardId(\"test\", i), false)\n                                   .addShard(new ImmutableShardRouting(\"test\", i, node_1_id, true, ShardRoutingState.STARTED, 1))\n                                   .build()\n                   );\n                }\n                return ClusterState.builder(currentState)\n                        .routingTable(RoutingTable.builder().add(indexRoutingTableBuilder).build())\n                        .build();\n            }\n\n            public boolean runOnlyOnMaster() {\n                return false;\n            }\n\n            @Override\n            public void onFailure(String source, Throwable t) {\n            }\n        });\n        waitNoPendingTasksOnAll();\n        logger.info(\"Checking if shards aren't removed\");\n        for (int shard : node2Shards) {\n            assertTrue(waitForShardDeletion(node_2, \"test\", shard));\n        }\n    }","id":60328,"modified_method":"@Test\n    public void testShardActiveElseWhere() throws Exception {\n        boolean node1IsMasterEligible = randomBoolean();\n        boolean node2IsMasterEligible = !node1IsMasterEligible || randomBoolean();\n        Future<String> node_1_future = internalCluster().startNodeAsync(ImmutableSettings.builder().put(\"node.master\", node1IsMasterEligible).build());\n        Future<String> node_2_future = internalCluster().startNodeAsync(ImmutableSettings.builder().put(\"node.master\", node2IsMasterEligible).build());\n        final String node_1 = node_1_future.get();\n        final String node_2 = node_2_future.get();\n        final String node_1_id = internalCluster().getInstance(DiscoveryService.class, node_1).localNode().getId();\n        final String node_2_id = internalCluster().getInstance(DiscoveryService.class, node_2).localNode().getId();\n\n        logger.debug(\"node {} (node_1) is {}master eligible\", node_1, node1IsMasterEligible ? \"\" : \"not \");\n        logger.debug(\"node {} (node_2) is {}master eligible\", node_2, node2IsMasterEligible ? \"\" : \"not \");\n        logger.debug(\"node {} became master\", internalCluster().getMasterName());\n        final int numShards = scaledRandomIntBetween(2, 20);\n        assertAcked(prepareCreate(\"test\")\n                        .setSettings(ImmutableSettings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0).put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, numShards))\n        );\n        ensureGreen(\"test\");\n\n        waitNoPendingTasksOnAll();\n        ClusterStateResponse stateResponse = client().admin().cluster().prepareState().get();\n\n        RoutingNode routingNode = stateResponse.getState().routingNodes().node(node_2_id);\n        final int[] node2Shards = new int[routingNode.numberOfOwningShards()];\n        int i = 0;\n        for (MutableShardRouting mutableShardRouting : routingNode) {\n            node2Shards[i] = mutableShardRouting.shardId().id();\n            i++;\n        }\n        logger.info(\"Node 2 has shards: {}\", Arrays.toString(node2Shards));\n        final long shardVersions[] = new long[numShards];\n        final int shardIds[] = new int[numShards];\n        i=0;\n        for (ShardRouting shardRouting : stateResponse.getState().getRoutingTable().allShards(\"test\")) {\n            shardVersions[i] = shardRouting.version();\n            shardIds[i] = shardRouting.getId();\n            i++;\n        }\n        internalCluster().getInstance(ClusterService.class, node_2).submitStateUpdateTask(\"test\", Priority.IMMEDIATE, new ClusterStateUpdateTask() {\n            @Override\n            public ClusterState execute(ClusterState currentState) throws Exception {\n                IndexRoutingTable.Builder indexRoutingTableBuilder = IndexRoutingTable.builder(\"test\");\n                for (int i = 0; i < numShards; i++) {\n                   indexRoutingTableBuilder.addIndexShard(\n                           new IndexShardRoutingTable.Builder(new ShardId(\"test\", i), false)\n                                   .addShard(new ImmutableShardRouting(\"test\", i, node_1_id, true, ShardRoutingState.STARTED, shardVersions[shardIds[i]]))\n                                   .build()\n                   );\n                }\n                return ClusterState.builder(currentState)\n                        .routingTable(RoutingTable.builder().add(indexRoutingTableBuilder).build())\n                        .build();\n            }\n\n            public boolean runOnlyOnMaster() {\n                return false;\n            }\n\n            @Override\n            public void onFailure(String source, Throwable t) {\n            }\n        });\n        waitNoPendingTasksOnAll();\n        logger.info(\"Checking if shards aren't removed\");\n        for (int shard : node2Shards) {\n            assertTrue(waitForShardDeletion(node_2, \"test\", shard));\n        }\n    }","commit_id":"cea8999406cba545acda9e1c2a51391b2912a59e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test @Slow\n    public void testShardActiveElseWhere() throws Exception {\n        boolean node1IsMasterEligible = randomBoolean();\n        boolean node2IsMasterEligible = !node1IsMasterEligible || randomBoolean();\n        Future<String> node_1_future = internalCluster().startNodeAsync(Settings.builder().put(\"node.master\", node1IsMasterEligible).build());\n        Future<String> node_2_future = internalCluster().startNodeAsync(Settings.builder().put(\"node.master\", node2IsMasterEligible).build());\n        final String node_1 = node_1_future.get();\n        final String node_2 = node_2_future.get();\n        final String node_1_id = internalCluster().getInstance(DiscoveryService.class, node_1).localNode().getId();\n        final String node_2_id = internalCluster().getInstance(DiscoveryService.class, node_2).localNode().getId();\n\n        logger.debug(\"node {} (node_1) is {}master eligible\", node_1, node1IsMasterEligible ? \"\" : \"not \");\n        logger.debug(\"node {} (node_2) is {}master eligible\", node_2, node2IsMasterEligible ? \"\" : \"not \");\n        logger.debug(\"node {} became master\", internalCluster().getMasterName());\n        final int numShards = scaledRandomIntBetween(2, 20);\n        assertAcked(prepareCreate(\"test\")\n                        .setSettings(Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0).put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, numShards))\n        );\n        ensureGreen(\"test\");\n\n        waitNoPendingTasksOnAll();\n        ClusterStateResponse stateResponse = client().admin().cluster().prepareState().get();\n\n        RoutingNode routingNode = stateResponse.getState().routingNodes().node(node_2_id);\n        final int[] node2Shards = new int[routingNode.numberOfOwningShards()];\n        int i = 0;\n        for (ShardRouting shardRouting : routingNode) {\n            node2Shards[i] = shardRouting.shardId().id();\n            i++;\n        }\n        logger.info(\"Node 2 has shards: {}\", Arrays.toString(node2Shards));\n        final long shardVersions[] = new long[numShards];\n        final int shardIds[] = new int[numShards];\n        i = 0;\n        for (ShardRouting shardRouting : stateResponse.getState().getRoutingTable().allShards(\"test\")) {\n            shardVersions[i] = shardRouting.version();\n            shardIds[i] = shardRouting.getId();\n            i++;\n        }\n        // disable relocations when we do this, to make sure the shards are not relocated from node2\n        // due to rebalancing, and delete its content\n        client().admin().cluster().prepareUpdateSettings().setTransientSettings(settingsBuilder().put(EnableAllocationDecider.CLUSTER_ROUTING_REBALANCE_ENABLE, EnableAllocationDecider.Rebalance.NONE)).get();\n        internalCluster().getInstance(ClusterService.class, node_2).submitStateUpdateTask(\"test\", Priority.IMMEDIATE, new ClusterStateUpdateTask() {\n            @Override\n            public ClusterState execute(ClusterState currentState) throws Exception {\n                IndexRoutingTable.Builder indexRoutingTableBuilder = IndexRoutingTable.builder(\"test\");\n                for (int i = 0; i < numShards; i++) {\n                    indexRoutingTableBuilder.addIndexShard(\n                            new IndexShardRoutingTable.Builder(new ShardId(\"test\", i), false)\n                                    .addShard(TestShardRouting.newShardRouting(\"test\", i, node_1_id, true, ShardRoutingState.STARTED, shardVersions[shardIds[i]]))\n                                    .build()\n                    );\n                }\n                return ClusterState.builder(currentState)\n                        .routingTable(RoutingTable.builder().add(indexRoutingTableBuilder).build())\n                        .build();\n            }\n\n            public boolean runOnlyOnMaster() {\n                return false;\n            }\n\n            @Override\n            public void onFailure(String source, Throwable t) {\n            }\n        });\n        waitNoPendingTasksOnAll();\n        logger.info(\"Checking if shards aren't removed\");\n        for (int shard : node2Shards) {\n            assertTrue(waitForShardDeletion(node_2, \"test\", shard));\n        }\n    }","id":60329,"modified_method":"@Test @Slow\n    public void testShardActiveElseWhere() throws Exception {\n        List<String> nodes = internalCluster().startNodesAsync(2).get();\n\n        final String masterNode = internalCluster().getMasterName();\n        final String nonMasterNode = nodes.get(0).equals(masterNode) ? nodes.get(1) : nodes.get(0);\n\n        final String masterId = internalCluster().clusterService(masterNode).localNode().id();\n        final String nonMasterId = internalCluster().clusterService(nonMasterNode).localNode().id();\n\n        final int numShards = scaledRandomIntBetween(2, 10);\n        assertAcked(prepareCreate(\"test\")\n                        .setSettings(Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0).put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, numShards))\n        );\n        ensureGreen(\"test\");\n\n        waitNoPendingTasksOnAll();\n        ClusterStateResponse stateResponse = client().admin().cluster().prepareState().get();\n\n        RoutingNode routingNode = stateResponse.getState().routingNodes().node(nonMasterId);\n        final int[] node2Shards = new int[routingNode.numberOfOwningShards()];\n        int i = 0;\n        for (ShardRouting shardRouting : routingNode) {\n            node2Shards[i] = shardRouting.shardId().id();\n            i++;\n        }\n        logger.info(\"Node [{}] has shards: {}\", nonMasterNode, Arrays.toString(node2Shards));\n        final long shardVersions[] = new long[numShards];\n        final int shardIds[] = new int[numShards];\n        i = 0;\n        for (ShardRouting shardRouting : stateResponse.getState().getRoutingTable().allShards(\"test\")) {\n            shardVersions[i] = shardRouting.version();\n            shardIds[i] = shardRouting.getId();\n            i++;\n        }\n\n        // disable relocations when we do this, to make sure the shards are not relocated from node2\n        // due to rebalancing, and delete its content\n        client().admin().cluster().prepareUpdateSettings().setTransientSettings(settingsBuilder().put(EnableAllocationDecider.CLUSTER_ROUTING_REBALANCE_ENABLE, EnableAllocationDecider.Rebalance.NONE)).get();\n        internalCluster().getInstance(ClusterService.class, nonMasterNode).submitStateUpdateTask(\"test\", Priority.IMMEDIATE, new ClusterStateUpdateTask() {\n            @Override\n            public ClusterState execute(ClusterState currentState) throws Exception {\n                IndexRoutingTable.Builder indexRoutingTableBuilder = IndexRoutingTable.builder(\"test\");\n                for (int i = 0; i < numShards; i++) {\n                    indexRoutingTableBuilder.addIndexShard(\n                            new IndexShardRoutingTable.Builder(new ShardId(\"test\", i), false)\n                                    .addShard(TestShardRouting.newShardRouting(\"test\", i, masterId, true, ShardRoutingState.STARTED, shardVersions[shardIds[i]]))\n                                    .build()\n                    );\n                }\n                return ClusterState.builder(currentState)\n                        .routingTable(RoutingTable.builder().add(indexRoutingTableBuilder).build())\n                        .build();\n            }\n\n            public boolean runOnlyOnMaster() {\n                return false;\n            }\n\n            @Override\n            public void onFailure(String source, Throwable t) {\n            }\n        });\n        waitNoPendingTasksOnAll();\n        logger.info(\"Checking if shards aren't removed\");\n        for (int shard : node2Shards) {\n            assertTrue(waitForShardDeletion(nonMasterNode, \"test\", shard));\n        }\n    }","commit_id":"068fae218f3c59fe6bc51adcd8d5f9b5a1dbccaf","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/** {@inheritDoc} */\n    public List getResult(RequestContext context) {\n\n        HttpServletRequest request = context.getRequest();\n        User user = context.getLoggedInUser();\n\n        // Stuff packages into an RhnSet to be used in the query\n        String packagesDecl = (String) request.getAttribute(\"packagesDecl\");\n        if (packagesDecl != null) {\n            Set<String> data = SessionSetHelper.lookupAndBind(request, packagesDecl);\n\n            // bz465892 - As the selected packages are parsed, remove duplicates\n            // keeping the highest EVR\n            Map<Long, PackageListItem> packageNameIdsToItems =\n                new HashMap<Long, PackageListItem>(data.size());\n            \n            for (String idCombo : data) {\n                PackageListItem item = PackageListItem.parse(idCombo);\n                \n                PackageListItem existing = packageNameIdsToItems.get(item.getIdOne()); \n                if (existing != null) {\n                    String[] existingParts = splitEvr(existing.getNvre());\n                    String[] itemParts = splitEvr(item.getNvre());\n                    \n                    PackageEvr existingEvr = new PackageEvr();\n                    existingEvr.setEpoch(existingParts[0]);\n                    existingEvr.setVersion(existingParts[1]);\n                    existingEvr.setRelease(existingParts[2]);\n                    \n                    PackageEvr itemEvr = new PackageEvr();\n                    itemEvr.setEpoch(itemParts[0]);\n                    itemEvr.setVersion(itemParts[1]);\n                    itemEvr.setRelease(itemParts[2]);\n\n                    if (existingEvr.compareTo(itemEvr) < 0) {\n                        packageNameIdsToItems.put(item.getIdOne(), item);\n                    }\n                }\n                else {\n                    packageNameIdsToItems.put(item.getIdOne(), item);\n                }\n            }\n\n            RhnSet packageSet = RhnSetManager.createSet(user.getId(),\n                RhnSetDecl.SSM_UPGRADE_PACKAGES_LIST.getLabel(), SetCleanup.NOOP);\n            \n            for (PackageListItem item : packageNameIdsToItems.values()) {\n                packageSet.addElement(item.getIdOne(), item.getIdTwo(), item.getIdThree());\n            }\n            \n            RhnSetManager.store(packageSet);\n        }        \n        \n        DataResult results = SystemManager.ssmSystemPackagesToUpgrade(user,\n            RhnSetDecl.SSM_UPGRADE_PACKAGES_LIST.getLabel());\n        \n        TagHelper.bindElaboratorTo(\"groupList\", results.getElaborator(), request);\n        \n        return results;\n    }","id":60330,"modified_method":"/** {@inheritDoc} */\n    public List getResult(RequestContext context) {\n\n        HttpServletRequest request = context.getRequest();\n        User user = context.getLoggedInUser();\n\n        // Stuff packages into an RhnSet to be used in the query\n        String packagesDecl = (String) request.getAttribute(\"packagesDecl\");\n        if (packagesDecl != null) {\n            Set<String> data = SessionSetHelper.lookupAndBind(request, packagesDecl);\n\n            // bz465892 - As the selected packages are parsed, remove duplicates\n            // keeping the highest EVR\n            Map<String, PackageListItem> packageNameIdsToItems =\n                new HashMap<String, PackageListItem>(data.size());\n            \n            for (String idCombo : data) {\n                PackageListItem item = PackageListItem.parse(idCombo);\n                \n                PackageListItem existing = packageNameIdsToItems.get(item.getIdOne() + \"|\"+ item.getIdThree()); \n                if (existing != null) {\n                    String[] existingParts = splitEvr(existing.getNvre());\n                    String[] itemParts = splitEvr(item.getNvre());\n                    \n                    PackageEvr existingEvr = new PackageEvr();\n                    existingEvr.setEpoch(existingParts[0]);\n                    existingEvr.setVersion(existingParts[1]);\n                    existingEvr.setRelease(existingParts[2]);\n                    \n                    PackageEvr itemEvr = new PackageEvr();\n                    itemEvr.setEpoch(itemParts[0]);\n                    itemEvr.setVersion(itemParts[1]);\n                    itemEvr.setRelease(itemParts[2]);\n\n                    if (existingEvr.compareTo(itemEvr) < 0) {\n                        packageNameIdsToItems.put(item.getIdOne() + \"|\"+ item.getIdThree(), item);\n                    }\n                }\n                else {\n                    packageNameIdsToItems.put(item.getIdOne() + \"|\"+ item.getIdThree(), item);\n                }\n            }\n\n            RhnSet packageSet = RhnSetManager.createSet(user.getId(),\n                RhnSetDecl.SSM_UPGRADE_PACKAGES_LIST.getLabel(), SetCleanup.NOOP);\n            \n            for (PackageListItem item : packageNameIdsToItems.values()) {\n                packageSet.addElement(item.getIdOne(), item.getIdTwo(), item.getIdThree());\n            }\n            \n            RhnSetManager.store(packageSet);\n        }        \n        \n        DataResult results = SystemManager.ssmSystemPackagesToUpgrade(user,\n            RhnSetDecl.SSM_UPGRADE_PACKAGES_LIST.getLabel());\n        \n        TagHelper.bindElaboratorTo(\"groupList\", results.getElaborator(), request);\n        \n        return results;\n    }","commit_id":"5e63202fa9be8adc5e54e1573384ff7a2050ef79","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"public void processAction(ActionEvent ae) throws AbortProcessingException\n  {\n\tFacesContext context = FacesContext.getCurrentInstance();\n\n    PublishedAssessmentSettingsBean assessmentSettings = (PublishedAssessmentSettingsBean) ContextUtil.lookupBean(\n                         \"publishedSettings\");\n    // create an assessment based on the title entered and the assessment\n    // template selected\n    // #1 - set Assessment\n    Long assessmentId = assessmentSettings.getAssessmentId();\n    //log.info(\"**** save assessment assessmentId =\"+assessmentId.toString());\n    PublishedAssessmentService assessmentService = new PublishedAssessmentService();\n    PublishedAssessmentFacade assessment = assessmentService.getPublishedAssessment(\n        assessmentId.toString());\n    //log.info(\"** assessment = \"+assessment);\n\n    // #2 - update delivery dates in AssessmentAccessControl\n    PublishedAccessControl control = (PublishedAccessControl)assessment.getAssessmentAccessControl();\n    if (control == null){\n      control = new PublishedAccessControl();\n      // need to fix accessControl so it can take AssessmentFacade later\n      control.setAssessmentBase(assessment.getData());\n    }\n    // a. LATER set dueDate, retractDate, startDate, releaseTo\n    control.setStartDate(assessmentSettings.getStartDate());\n    control.setDueDate(assessmentSettings.getDueDate());\n    control.setRetractDate(assessmentSettings.getRetractDate());\n    control.setFeedbackDate(assessmentSettings.getFeedbackDate());\n\n    // check if the score is > 0, Gradebook doesn't allow assessments with total\n\t// point = 0.\n\t\tboolean error = false;\n\n\t\tif (assessmentSettings.getToDefaultGradebook().equals(\"1\")) {\n\t\t\tif (assessment.getTotalScore().floatValue() <= 0) {\n\n\t\t\t\tString gb_err = (String) ContextUtil.getLocalizedString(\n\t\t\t\t\t\t\t\t\"org.sakaiproject.tool.assessment.bundle.AuthorMessages\",\"gradebook_exception_min_points\");\n\t\t\t\tcontext.addMessage(null, new FacesMessage(gb_err));\n\t\t\t\terror = true;\n\t\t\t}\n\t\t}\n\n\t\t   if (error){\n\t\t\t      assessmentSettings.setOutcome(\"editPublishedAssessmentSettings\");\n\t\t\t      return;\n\t\t\t    }\n\n\n    //#3 - add or remove external assessment to gradebook\n    // a. if Gradebook does not exists, do nothing, 'cos setting should have been hidden\n    // b. if Gradebook exists, just call addExternal and removeExternal and swallow any exception. The\n    //    exception are indication that the assessment is already in the Gradebook or there is nothing\n    //    to remove.\n    GradebookService g = null;\n    if (integrated)\n    {\n      g = (GradebookService) SpringBeanLocator.getInstance().\n        getBean(\"org.sakaiproject.service.gradebook.GradebookService\");\n    }\n\n    if (gbsHelper.gradebookExists(GradebookFacade.getGradebookUId(), g)){ // => something to do\n      PublishedEvaluationModel evaluation = (PublishedEvaluationModel)assessment.getEvaluationModel();\n      //Integer scoringType = EvaluationModelIfc.HIGHEST_SCORE;\n      if (evaluation == null){\n        evaluation = new PublishedEvaluationModel();\n        evaluation.setAssessmentBase(assessment.getData());\n      }\n      evaluation.setToGradeBook(assessmentSettings.getToDefaultGradebook());\n      Integer scoringType = evaluation.getScoringType();\n      if (evaluation.getToGradeBook()!=null && \n        evaluation.getToGradeBook().equals(EvaluationModelIfc.TO_DEFAULT_GRADEBOOK.toString())){\n        //add and copy scores over if any\n\n        try{\n         log.debug(\"before gbsHelper.addToGradebook()\");\n         gbsHelper.addToGradebook((PublishedAssessmentData)assessment.getData(), g);\n         log.debug(\"before gbsHelper.updateGradebook()\");\n         gbsHelper.updateGradebook((PublishedAssessmentData)assessment.getData(), g);\n          // any score to copy over? get all the assessmentGradingData and copy over\n          GradingService gradingService = new GradingService();\n          \n           // need to decide what to tell gradebook\n          ArrayList list = null;\n          \n          if ((scoringType).equals(EvaluationModelIfc.HIGHEST_SCORE)){\n        \t  list = gradingService.getHighestAssessmentGradingList(assessment.getPublishedAssessmentId());\n          }\n          else {\n           list = gradingService.getLastAssessmentGradingList(assessment.getPublishedAssessmentId());\n          }\n          \n          //ArrayList list = gradingService.getAllSubmissions(assessment.getPublishedAssessmentId().toString());\n          log.debug(\"list size =\" + list.size()\t);\n          for (int i=0; i<list.size();i++){\n         \t   \n            AssessmentGradingData ag = (AssessmentGradingData)list.get(i);\n            log.debug(\"ag.scores \" + ag.getTotalAutoScore());\n            gbsHelper.updateExternalAssessmentScore(ag, g);\n          }\n        }\n        catch(Exception e){\n          log.warn(\"oh well, must have been added already:\"+e.getMessage());\n        }\n      }\n      else{ //remove\n        try{\n          gbsHelper.removeExternalAssessment(\n            GradebookFacade.getGradebookUId(),\n            assessment.getPublishedAssessmentId().toString(), g);\n        }\n        catch(Exception e){\n          log.warn(\"*** oh well, looks like there is nothing to remove:\"+e.getMessage());\n        }\n      }\n    }\n\n    assessmentService.saveAssessment(assessment);\n\n    //#4 - regenerate the publsihed assessment list in autor bean again\n    // sortString can be of these value:title,releaseTo,dueDate,startDate\n    // get the managed bean, author and reset the list.\n    // Yes, we need to do that just in case the user change those delivery\n    // dates and turning an inactive pub to active pub\n    GradingService gradingService = new GradingService();\n    HashMap map = gradingService.getSubmissionSizeOfAllPublishedAssessments();\n    AuthorBean author = (AuthorBean) ContextUtil.lookupBean(\n                       \"author\");\n    ArrayList publishedList = assessmentService.\n        getBasicInfoOfAllActivePublishedAssessments(author.getPublishedAssessmentOrderBy(),author.isPublishedAscending());\n    // get the managed bean, author and set the list\n    author.setPublishedAssessments(publishedList);\n    setSubmissionSize(publishedList, map);\n\n    ArrayList inactivePublishedList = assessmentService.\n        getBasicInfoOfAllInActivePublishedAssessments(author.getInactivePublishedAssessmentOrderBy(),author.isInactivePublishedAscending());\n    // get the managed bean, author and set the list\n    author.setInactivePublishedAssessments(inactivePublishedList);\n    setSubmissionSize(inactivePublishedList, map);\n    \n    assessmentSettings.setOutcome(\"saveSettings\");\n  }","id":60331,"modified_method":"public void processAction(ActionEvent ae) throws AbortProcessingException\n  {\n\tFacesContext context = FacesContext.getCurrentInstance();\n\n    PublishedAssessmentSettingsBean assessmentSettings = (PublishedAssessmentSettingsBean) ContextUtil.lookupBean(\n                         \"publishedSettings\");\n    \n    // create an assessment based on the title entered and the assessment\n    // template selected\n    // #1 - set Assessment\n    Long assessmentId = assessmentSettings.getAssessmentId();\n    //log.info(\"**** save assessment assessmentId =\"+assessmentId.toString());\n    PublishedAssessmentService assessmentService = new PublishedAssessmentService();\n    PublishedAssessmentFacade assessment = assessmentService.getPublishedAssessment(\n        assessmentId.toString());\n    //log.info(\"** assessment = \"+assessment);\n\n    // #2 - update delivery dates in AssessmentAccessControl\n    PublishedAccessControl control = (PublishedAccessControl)assessment.getAssessmentAccessControl();\n    if (control == null){\n      control = new PublishedAccessControl();\n      // need to fix accessControl so it can take AssessmentFacade later\n      control.setAssessmentBase(assessment.getData());\n    }\n    \n    String id = ae.getComponent().getId();\n    // Check if the action is clicking the the Retract button on Assessment Retract Confirmation button\n    if (id.equals(\"retract\")) {\n    \tcontrol.setRetractDate(new Date());\n    }\n    else {\n    \tcontrol.setRetractDate(assessmentSettings.getRetractDate());\n    }\n   \t// a. LATER set dueDate, startDate, releaseTo\n   \tcontrol.setStartDate(assessmentSettings.getStartDate());\n   \tcontrol.setDueDate(assessmentSettings.getDueDate());\n   \tcontrol.setFeedbackDate(assessmentSettings.getFeedbackDate());\n\n    \n    // check if the score is > 0, Gradebook doesn't allow assessments with total\n\t// point = 0.\n\t\tboolean error = false;\n\n\t\tif (assessmentSettings.getToDefaultGradebook().equals(\"1\")) {\n\t\t\tif (assessment.getTotalScore().floatValue() <= 0) {\n\n\t\t\t\tString gb_err = (String) ContextUtil.getLocalizedString(\n\t\t\t\t\t\t\t\t\"org.sakaiproject.tool.assessment.bundle.AuthorMessages\",\"gradebook_exception_min_points\");\n\t\t\t\tcontext.addMessage(null, new FacesMessage(gb_err));\n\t\t\t\terror = true;\n\t\t\t}\n\t\t}\n\n\t\t   if (error){\n\t\t\t      assessmentSettings.setOutcome(\"editPublishedAssessmentSettings\");\n\t\t\t      return;\n\t\t\t    }\n\n\n    //#3 - add or remove external assessment to gradebook\n    // a. if Gradebook does not exists, do nothing, 'cos setting should have been hidden\n    // b. if Gradebook exists, just call addExternal and removeExternal and swallow any exception. The\n    //    exception are indication that the assessment is already in the Gradebook or there is nothing\n    //    to remove.\n    GradebookService g = null;\n    if (integrated)\n    {\n      g = (GradebookService) SpringBeanLocator.getInstance().\n        getBean(\"org.sakaiproject.service.gradebook.GradebookService\");\n    }\n\n    if (gbsHelper.gradebookExists(GradebookFacade.getGradebookUId(), g)){ // => something to do\n      PublishedEvaluationModel evaluation = (PublishedEvaluationModel)assessment.getEvaluationModel();\n      //Integer scoringType = EvaluationModelIfc.HIGHEST_SCORE;\n      if (evaluation == null){\n        evaluation = new PublishedEvaluationModel();\n        evaluation.setAssessmentBase(assessment.getData());\n      }\n      evaluation.setToGradeBook(assessmentSettings.getToDefaultGradebook());\n      Integer scoringType = evaluation.getScoringType();\n      if (evaluation.getToGradeBook()!=null && \n        evaluation.getToGradeBook().equals(EvaluationModelIfc.TO_DEFAULT_GRADEBOOK.toString())){\n        //add and copy scores over if any\n\n        try{\n         log.debug(\"before gbsHelper.addToGradebook()\");\n         gbsHelper.addToGradebook((PublishedAssessmentData)assessment.getData(), g);\n         log.debug(\"before gbsHelper.updateGradebook()\");\n         gbsHelper.updateGradebook((PublishedAssessmentData)assessment.getData(), g);\n          // any score to copy over? get all the assessmentGradingData and copy over\n          GradingService gradingService = new GradingService();\n          \n           // need to decide what to tell gradebook\n          ArrayList list = null;\n          \n          if ((scoringType).equals(EvaluationModelIfc.HIGHEST_SCORE)){\n        \t  list = gradingService.getHighestAssessmentGradingList(assessment.getPublishedAssessmentId());\n          }\n          else {\n           list = gradingService.getLastAssessmentGradingList(assessment.getPublishedAssessmentId());\n          }\n          \n          //ArrayList list = gradingService.getAllSubmissions(assessment.getPublishedAssessmentId().toString());\n          log.debug(\"list size =\" + list.size()\t);\n          for (int i=0; i<list.size();i++){\n         \t   \n            AssessmentGradingData ag = (AssessmentGradingData)list.get(i);\n            log.debug(\"ag.scores \" + ag.getTotalAutoScore());\n            gbsHelper.updateExternalAssessmentScore(ag, g);\n          }\n        }\n        catch(Exception e){\n          log.warn(\"oh well, must have been added already:\"+e.getMessage());\n        }\n      }\n      else{ //remove\n        try{\n          gbsHelper.removeExternalAssessment(\n            GradebookFacade.getGradebookUId(),\n            assessment.getPublishedAssessmentId().toString(), g);\n        }\n        catch(Exception e){\n          log.warn(\"*** oh well, looks like there is nothing to remove:\"+e.getMessage());\n        }\n      }\n    }\n\n    assessmentService.saveAssessment(assessment);\n\n    //#4 - regenerate the publsihed assessment list in autor bean again\n    // sortString can be of these value:title,releaseTo,dueDate,startDate\n    // get the managed bean, author and reset the list.\n    // Yes, we need to do that just in case the user change those delivery\n    // dates and turning an inactive pub to active pub\n    GradingService gradingService = new GradingService();\n    HashMap map = gradingService.getSubmissionSizeOfAllPublishedAssessments();\n    AuthorBean author = (AuthorBean) ContextUtil.lookupBean(\n                       \"author\");\n    ArrayList publishedList = assessmentService.\n        getBasicInfoOfAllActivePublishedAssessments(author.getPublishedAssessmentOrderBy(),author.isPublishedAscending());\n    // get the managed bean, author and set the list\n    author.setPublishedAssessments(publishedList);\n    setSubmissionSize(publishedList, map);\n\n    ArrayList inactivePublishedList = assessmentService.\n        getBasicInfoOfAllInActivePublishedAssessments(author.getInactivePublishedAssessmentOrderBy(),author.isInactivePublishedAscending());\n    // get the managed bean, author and set the list\n    author.setInactivePublishedAssessments(inactivePublishedList);\n    setSubmissionSize(inactivePublishedList, map);\n    \n    assessmentSettings.setOutcome(\"saveSettings\");\n  }","commit_id":"70dc83b3cf19d34590584b04c7bd34b4c4b8f5f4","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public boolean isActive(PublishedAssessmentFacade f, HashMap submissionCountHash, HashMap inProgressCountHash, HashMap numberRetakeHash, \n\t\t  HashMap actualNumberRetakeHash, List needResubmitList) {\n\t  boolean returnValue = false;\n\t  //1. prepare our significant parameters\n\t  Integer status = f.getStatus();\n\t  Date currentDate = new Date();\n\t  Date startDate = f.getStartDate();\n\t  Date retractDate = f.getRetractDate();\n\t  Date dueDate = f.getDueDate();\n\t  \n\t  boolean acceptLateSubmission = AssessmentAccessControlIfc.ACCEPT_LATE_SUBMISSION.equals(f.getLateHandling());\n\t  int maxSubmissionsAllowed = 9999;\n\t  if ((Boolean.FALSE).equals(f.getUnlimitedSubmissions())){\n\t\t  maxSubmissionsAllowed = f.getSubmissionsAllowed();\n\t  }\n\t  \n\t  ArrayList<String> userIdList = new ArrayList<String>();\n\t  if (f.getReleaseTo() != null && !(\"\").equals(f.getReleaseTo())) {\n\t\t  if (f.getReleaseTo().contains( \"Anonymous Users\" )) {\n\t\t\t  if (submissionCountHash != null) {\n\t\t\t\t  f.setSubmittedCount(submissionCountHash.size());\n\t\t\t  }\n\t\t\t  else {\n\t\t\t\t  f.setSubmittedCount(0);\n\t\t\t  }\n\t\t\t  if (inProgressCountHash != null) {\n\t\t\t\t  f.setInProgressCount(inProgressCountHash.size());\n\t\t\t  }\n\t\t\t  else {\n\t\t\t\t  f.setInProgressCount(0);\n\t\t\t  }\n\t\t\t  if (dueDate != null && dueDate.before(currentDate)) {\n\t\t\t\t  return false;\n\t\t\t  }\n\t\t\t  else {\n\t\t\t\t  return true;\n\t\t\t  }\n\t\t  }\n\t\t  else {\n\t\t\t  if (AssessmentAccessControl.RELEASE_TO_SELECTED_GROUPS.equals(f.getReleaseTo())) {\n\t\t\t\t  PublishedAssessmentSettingsBean publishedAssessmentSettingsBean = (PublishedAssessmentSettingsBean) ContextUtil.lookupBean(\"publishedSettings\");\n\t\t\t\t  publishedAssessmentSettingsBean.setAssessmentId(f.getPublishedAssessmentId());\n\t\t\t\t  String [] groupsAuthorized = publishedAssessmentSettingsBean.getGroupsAuthorized();\n\t\t\t\t  //Use a set to avoid duplicated entries in the userList\n\t\t\t\t  HashSet<String> uuser = new HashSet<String>();                \n\t\t\t\t  if(groupsAuthorized != null && groupsAuthorized.length > 0) {\n\t\t\t\t\t  for( String groupsAuthorized1 : groupsAuthorized ) {\n\t\t\t\t\t\t  if( groupUsersIdMap.get( groupsAuthorized1 ) != null )\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t  for( String userId : groupUsersIdMap.get( groupsAuthorized1 ) )\n\t\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t\t  uuser.add(userId);\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t  }\n\t\t\t\t\t  }\n\t\t\t\t  userIdList = new ArrayList<String>(uuser);\n\t\t\t  }\n\t\t\t  }\n\t\t\t  else {\n\t\t\t\t  userIdList = siteUsersIdList;\n\t\t\t  }\n\t\t\t  \n\t\t\t  int submittedCounts = 0;\n\t\t\t  int inProgressCounts = 0;\n\t\t\t  if (userIdList != null) {\n\t\t\t\t  Iterator iter = userIdList.iterator();\n\t\t\t\t  String userId;\n\t\t\t\t  boolean isStillAvailable;\n\t\t\t\t  while(iter.hasNext()) {\n\t\t\t\t\t  userId = (String) iter.next();\n\t\t\t\t\t  int totalSubmitted = 0;\n\t\t\t\t\t  int totalInProgress;\n\t\t\t\t\t  if (submissionCountHash != null && submissionCountHash.get(userId) != null){\n\t\t\t\t\t\t  totalSubmitted = ( (Integer) submissionCountHash.get(userId));\n\t\t\t\t\t\t  if (totalSubmitted > 0) {\n\t\t\t\t\t\t\t  submittedCounts++;\n\t\t\t\t\t\t  }\n\t\t\t\t\t  }\n\t\t\t\t\t  if (inProgressCountHash != null && inProgressCountHash.get(userId) != null){\n\t\t\t\t\t\t  totalInProgress = ( (Integer) inProgressCountHash.get(userId));\n\t\t\t\t\t\t  if (totalInProgress > 0) {\n\t\t\t\t\t\t\t  inProgressCounts++;\n\t\t\t\t\t\t  }\n\t\t\t\t\t  }\n\n\t\t\t\t\t  if (!returnValue) {\n\t\t\t\t\t\t  isStillAvailable = isStillAvailable(totalSubmitted, numberRetakeHash, actualNumberRetakeHash, \n\t\t\t\t\t\t\t\t  userId, currentDate, dueDate, acceptLateSubmission, maxSubmissionsAllowed);\n\t\t\t\t\t\t  if (isStillAvailable) {\n\t\t\t\t\t\t\t  returnValue = true;\n\t\t\t\t\t\t  }\n\t\t\t\t\t  }\n\t\t\t\t  }\n\t\t\t  }\n\t\t\t  else {\n\t\t\t\t  returnValue = true;\n\t\t\t  }\n\t\t\t  f.setSubmittedCount(submittedCounts);\n\t\t\t  f.setInProgressCount(inProgressCounts);\n\t\t\t  if ((submittedCounts + inProgressCounts) > 0) {\n\t\t\t\t  f.setHasAssessmentGradingData(true);\n\t\t\t  }\n\t\t\t  else {\n\t\t\t\t  f.setHasAssessmentGradingData(false);\n\t\t\t  }\n\t\t  }\n\n\t\t  if (!Integer.valueOf(1).equals(status)) {\n\t\t\t  returnValue = false;\n\t\t  }\n\n\t\t  if (startDate != null && startDate.after(currentDate)) {\n\t\t\t  returnValue = false;\n\t\t  }\n\n\t\t  if (acceptLateSubmission && retractDate != null && retractDate.before(currentDate)) {\n\t\t\t  returnValue = false;\n\t\t  }\n\n\t\t  if (needResubmitList.contains(f.getPublishedAssessmentId())) {\n\t\t\t  returnValue = true;\n\t\t  }\n\t  }\n\t  else {\n\t\t  // should not come to here. but if this happens\n\t\t  returnValue = false;\n\t  }\n\t  return returnValue;\n  }","id":60332,"modified_method":"public boolean isActive(PublishedAssessmentFacade f, HashMap submissionCountHash, HashMap inProgressCountHash, HashMap numberRetakeHash, \n\t\t  HashMap actualNumberRetakeHash, List needResubmitList) {\n\t  boolean returnValue = false;\n\t  //1. prepare our significant parameters\n\t  Integer status = f.getStatus();\n\t  Date currentDate = new Date();\n\t  Date startDate = f.getStartDate();\n\t  Date retractDate = f.getRetractDate();\n\t  Date dueDate = f.getDueDate();\n\t  \n\t  boolean acceptLateSubmission = AssessmentAccessControlIfc.ACCEPT_LATE_SUBMISSION.equals(f.getLateHandling());\n\t  int maxSubmissionsAllowed = 9999;\n\t  if ((Boolean.FALSE).equals(f.getUnlimitedSubmissions())){\n\t\t  maxSubmissionsAllowed = f.getSubmissionsAllowed();\n\t  }\n\t  \n\t  ArrayList<String> userIdList = new ArrayList<String>();\n\t  if (f.getReleaseTo() != null && !(\"\").equals(f.getReleaseTo())) {\n\t\t  if (f.getReleaseTo().contains( \"Anonymous Users\" )) {\n\t\t\t  if (submissionCountHash != null) {\n\t\t\t\t  f.setSubmittedCount(submissionCountHash.size());\n\t\t\t  }\n\t\t\t  else {\n\t\t\t\t  f.setSubmittedCount(0);\n\t\t\t  }\n\t\t\t  if (inProgressCountHash != null) {\n\t\t\t\t  f.setInProgressCount(inProgressCountHash.size());\n\t\t\t  }\n\t\t\t  else {\n\t\t\t\t  f.setInProgressCount(0);\n\t\t\t  }\n\t\t\t  if (dueDate != null && dueDate.before(currentDate)) {\n\t\t\t\t  return false;\n\t\t\t  }\n\t\t\t  else {\n\t\t\t\t  return true;\n\t\t\t  }\n\t\t  }\n\t\t  else {\n\t\t\t  if (AssessmentAccessControl.RELEASE_TO_SELECTED_GROUPS.equals(f.getReleaseTo())) {\n\t\t\t\t  PublishedAssessmentSettingsBean publishedAssessmentSettingsBean = (PublishedAssessmentSettingsBean) ContextUtil.lookupBean(\"publishedSettings\");\n\t\t\t\t  publishedAssessmentSettingsBean.setAssessmentId(f.getPublishedAssessmentId());\n\t\t\t\t  String [] groupsAuthorized = publishedAssessmentSettingsBean.getGroupsAuthorized();\n\t\t\t\t  //Use a set to avoid duplicated entries in the userList\n\t\t\t\t  HashSet<String> uuser = new HashSet<String>();                \n\t\t\t\t  if(groupsAuthorized != null && groupsAuthorized.length > 0) {\n\t\t\t\t\t  for( String groupsAuthorized1 : groupsAuthorized ) {\n\t\t\t\t\t\t  if( groupUsersIdMap.get( groupsAuthorized1 ) != null )\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t  for( String userId : groupUsersIdMap.get( groupsAuthorized1 ) )\n\t\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t\t  uuser.add(userId);\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t  }\n\t\t\t\t\t  }\n\t\t\t\t  userIdList = new ArrayList<String>(uuser);\n\t\t\t  }\n\t\t\t  }\n\t\t\t  else {\n\t\t\t\t  userIdList = siteUsersIdList;\n\t\t\t  }\n\t\t\t  \n\t\t\t  int submittedCounts = 0;\n\t\t\t  int inProgressCounts = 0;\n\t\t\t  if (userIdList != null) {\n\t\t\t\t  Iterator iter = userIdList.iterator();\n\t\t\t\t  String userId;\n\t\t\t\t  boolean isStillAvailable;\n\t\t\t\t  while(iter.hasNext()) {\n\t\t\t\t\t  userId = (String) iter.next();\n\t\t\t\t\t  int totalSubmitted = 0;\n\t\t\t\t\t  int totalInProgress;\n\t\t\t\t\t  if (submissionCountHash != null && submissionCountHash.get(userId) != null){\n\t\t\t\t\t\t  totalSubmitted = ( (Integer) submissionCountHash.get(userId));\n\t\t\t\t\t\t  if (totalSubmitted > 0) {\n\t\t\t\t\t\t\t  submittedCounts++;\n\t\t\t\t\t\t  }\n\t\t\t\t\t  }\n\t\t\t\t\t  if (inProgressCountHash != null && inProgressCountHash.get(userId) != null){\n\t\t\t\t\t\t  totalInProgress = ( (Integer) inProgressCountHash.get(userId));\n\t\t\t\t\t\t  if (totalInProgress > 0) {\n\t\t\t\t\t\t\t  inProgressCounts++;\n\t\t\t\t\t\t  }\n\t\t\t\t\t  }\n\n\t\t\t\t\t  if (!returnValue) {\n\t\t\t\t\t\t  isStillAvailable = isStillAvailable(totalSubmitted, numberRetakeHash, actualNumberRetakeHash, \n\t\t\t\t\t\t\t\t  userId, currentDate, dueDate, acceptLateSubmission, maxSubmissionsAllowed);\n\t\t\t\t\t\t  if (isStillAvailable) {\n\t\t\t\t\t\t\t  returnValue = true;\n\t\t\t\t\t\t  }\n\t\t\t\t\t  }\n\t\t\t\t  }\n\t\t\t  }\n\t\t\t  else {\n\t\t\t\t  returnValue = true;\n\t\t\t  }\n\t\t\t  f.setSubmittedCount(submittedCounts);\n\t\t\t  f.setInProgressCount(inProgressCounts);\n\t\t\t  if ((submittedCounts + inProgressCounts) > 0) {\n\t\t\t\t  f.setHasAssessmentGradingData(true);\n\t\t\t  }\n\t\t\t  else {\n\t\t\t\t  f.setHasAssessmentGradingData(false);\n\t\t\t  }\n\t\t  }\n\n\t\t  if (!Integer.valueOf(1).equals(status)) {\n\t\t\t  returnValue = false;\n\t\t  }\n\n\t\t  if (startDate != null && startDate.after(currentDate)) {\n\t\t\t  returnValue = false;\n\t\t  }\n\n\t\t  if (acceptLateSubmission\n\t\t\t\t  && (dueDate != null && dueDate.before(currentDate))\n\t\t\t\t  && (retractDate == null || retractDate.before(currentDate))) {\n\t\t\t  returnValue = false;\n\t\t  }\n\n\t\t  if (needResubmitList.contains(f.getPublishedAssessmentId())) {\n\t\t\t  returnValue = true;\n\t\t  }\n\t  }\n\t  else {\n\t\t  // should not come to here. but if this happens\n\t\t  returnValue = false;\n\t  }\n\t  return returnValue;\n  }","commit_id":"b0838d8a0b03aec051031732de0df836bb25759d","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public AssessmentFacade save(AssessmentSettingsBean assessmentSettings, boolean isFromConfirmPublishAssessmentListener)\n  {\n    // create an assessment based on the title entered and the assessment\n    // template selected\n    // #1 - set Assessment\n    Long assessmentId = assessmentSettings.getAssessmentId();\n    //log.info(\"**** save assessment assessmentId =\"+assessmentId.toString());\n    ItemAuthorBean iAuthor=new ItemAuthorBean();\n    //System.out.println(\"assessmentSettings.getFeedbackAuthoring: \"+assessmentSettings.getFeedbackAuthoring());\n    iAuthor.setShowFeedbackAuthoring(assessmentSettings.getFeedbackAuthoring());\n    //System.out.println(\"iAuthor.getShowFeedbackAuthoring :\"+iAuthor.getShowFeedbackAuthoring());\n    AssessmentService assessmentService = new AssessmentService();\n    AssessmentFacade assessment = assessmentService.getAssessment(\n        assessmentId.toString());\n    //log.info(\"** assessment = \"+assessment);\n    assessment.setTitle(TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, assessmentSettings.getTitle()));\n    //assessment.setTitle(assessmentSettings.getTitle());\n    assessment.setDescription(assessmentSettings.getDescription());\n    assessment.updateAssessmentMetaData(AssessmentMetaDataIfc.AUTHORS, TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, assessmentSettings.getAuthors()));\n\n    // #2 - set AssessmentAccessControl\n    AssessmentAccessControl control = (AssessmentAccessControl)assessment.getAssessmentAccessControl();\n    if (control == null){\n      control = new AssessmentAccessControl();\n      // need to fix accessControl so it can take AssessmentFacade later\n      control.setAssessmentBase(assessment.getData());\n    }\n    // a. LATER set dueDate, retractDate, startDate, releaseTo\n    if (isFromConfirmPublishAssessmentListener) {\n    \tif (assessmentSettings.getStartDate() != null) {\n    \t\tcontrol.setStartDate(assessmentSettings.getStartDate());\n    \t}\n    \telse {\n    \t\tcontrol.setStartDate(new Date());\n    \t}\n    }\n    else {\n    \tcontrol.setStartDate(assessmentSettings.getStartDate());\n    }\n    control.setDueDate(assessmentSettings.getDueDate());\n    control.setRetractDate(assessmentSettings.getRetractDate());\n    control.setFeedbackDate(assessmentSettings.getFeedbackDate());\n    control.setReleaseTo(assessmentSettings.getReleaseTo());\n    //log.info(\"control RELEASETO =\"+control.getReleaseTo());\n    //log.info(\"settings RELEASETO =\"+assessmentSettings.getReleaseTo());\n\n    // b. set Timed Assessment\n    //log.info(\"** Time limit update to = \"+assessmentSettings.getTimeLimit().intValue());\n    control.setTimeLimit(assessmentSettings.getTimeLimit());\n    if (assessmentSettings.getTimedAssessment())\n      control.setTimedAssessment(AssessmentAccessControl.TIMED_ASSESSMENT);\n    else\n      control.setTimedAssessment(AssessmentAccessControl.DO_NOT_TIMED_ASSESSMENT);\n\n    // c. set Assessment Orgainzation\n    if (assessmentSettings.getItemNavigation()!=null ) {\n    \tString nav = assessmentSettings.getItemNavigation();\n    \tif (\"1\".equals(nav)) {\n    \t\tassessmentSettings.setAssessmentFormat(\"1\");\n    \t}\n    \tcontrol.setItemNavigation(Integer.valueOf(nav));\n    }\n    if (assessmentSettings.getItemNumbering()!=null)\n      control.setItemNumbering(new Integer(assessmentSettings.getItemNumbering()));\n    if(assessmentSettings.getDisplayScoreDuringAssessments() != null)\n    \tcontrol.setDisplayScoreDuringAssessments(new Integer(assessmentSettings.getDisplayScoreDuringAssessments()));\n    if (assessmentSettings.getAssessmentFormat()!=null )\n     control.setAssessmentFormat(new Integer(assessmentSettings.getAssessmentFormat()));\n\n    if (assessmentSettings.getIsMarkForReview())\n        control.setMarkForReview(AssessmentAccessControl.MARK_FOR_REVIEW);\n    else {\n    \tcontrol.setMarkForReview(AssessmentAccessControl.NOT_MARK_FOR_REVIEW);\n    }\n\n\n    // d. set Submissions\n    if (assessmentSettings.getUnlimitedSubmissions()!=null){\n    \tif (!assessmentSettings.getUnlimitedSubmissions().\n    \t\t\tequals(AssessmentAccessControlIfc.UNLIMITED_SUBMISSIONS.toString())) {\n    \t\tcontrol.setUnlimitedSubmissions(Boolean.FALSE);\n    \t\tif (assessmentSettings.getSubmissionsAllowed() != null)\n    \t\t\tcontrol.setSubmissionsAllowed(new Integer(assessmentSettings.\n    \t\t\t\t\tgetSubmissionsAllowed()));\n    \t\telse\n    \t\t\tcontrol.setSubmissionsAllowed(Integer.valueOf(\"1\"));\n    \t}\n    \telse {\n    \t\tcontrol.setUnlimitedSubmissions(Boolean.TRUE);\n    \t\tcontrol.setSubmissionsAllowed(null);\n    \t}\n    }\n\n    //log.info(\"**unlimited submission=\"+assessmentSettings.getUnlimitedSubmissions());\n    //log.info(\"**allowed=\"+control.getSubmissionsAllowed());\n\n    if (assessmentSettings.getLateHandling()!=null){\n      control.setLateHandling(new Integer(assessmentSettings.\n                                                getLateHandling()));\n    }\n    if (assessmentSettings.getSubmissionsSaved()!=null){\n      control.setSubmissionsSaved(new Integer(assessmentSettings.getSubmissionsSaved()));\n    }\n    \n    if (assessmentSettings.getAutoSubmit())\n        control.setAutoSubmit(AssessmentAccessControl.AUTO_SUBMIT);\n    else {\n    \tcontrol.setAutoSubmit(AssessmentAccessControl.DO_NOT_AUTO_SUBMIT);\n    }\n    assessment.setAssessmentAccessControl(control);\n\n    // e. set Submission Messages\n    control.setSubmissionMessage(assessmentSettings.getSubmissionMessage());\n    // f. set username\n    control.setUsername(TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, StringUtils.trim(assessmentSettings.getUsername())));\n    // g. set password\n    control.setPassword(TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, StringUtils.trim(assessmentSettings.getPassword())));\n    // h. set finalPageUrl\n\n    String finalPageUrl = \"\";\n    if (assessmentSettings.getFinalPageUrl() != null) {\n    \tfinalPageUrl = TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, assessmentSettings.getFinalPageUrl().trim());\n    \tif (finalPageUrl.length() != 0 && !finalPageUrl.toLowerCase().startsWith(\"http\")) {\n    \t\tfinalPageUrl = \"http://\" + finalPageUrl;\n    \t}\n    }\n    control.setFinalPageUrl(finalPageUrl);\n\n    //#3 Feedback\n    AssessmentFeedback feedback = (AssessmentFeedback)assessment.getAssessmentFeedback();\n    if (feedback == null){\n      feedback = new AssessmentFeedback();\n      // need to fix feeback so it can take AssessmentFacade later\n      feedback.setAssessmentBase(assessment.getData());\n    }\n    if (assessmentSettings.getFeedbackDelivery()!=null)\n     feedback.setFeedbackDelivery(new Integer(assessmentSettings.getFeedbackDelivery()));\n    if (StringUtils.isNotBlank(assessmentSettings.getFeedbackComponentOption()))\n        feedback.setFeedbackComponentOption(new Integer(assessmentSettings.getFeedbackComponentOption()));\n    if (assessmentSettings.getFeedbackAuthoring()!=null)\n     feedback.setFeedbackAuthoring(new Integer(assessmentSettings.getFeedbackAuthoring()));\n    // if 'No feedback' (it corresponds to value 3) is selected, \n\t// all components are unchecked\n    if (feedback.getFeedbackDelivery().equals(new Integer(\"3\")))\n    {\n    \tfeedback.setShowQuestionText(false);\n\t\tfeedback.setShowStudentResponse(false);\n\t\tfeedback.setShowCorrectResponse(false);\n\t\tfeedback.setShowStudentScore(false);\n\t\tfeedback.setShowStudentQuestionScore(false);\n\t\tfeedback.setShowQuestionLevelFeedback(false);\n\t\tfeedback.setShowSelectionLevelFeedback(false);\n\t\tfeedback.setShowGraderComments(false);\n\t\tfeedback.setShowStatistics(false);\n    }\n    else {\n    \t\tfeedback.setShowQuestionText(Boolean.valueOf(assessmentSettings.getShowQuestionText()));\n    \t\tfeedback.setShowStudentResponse(Boolean.valueOf(assessmentSettings.getShowStudentResponse()));\n    \t\tfeedback.setShowCorrectResponse(Boolean.valueOf(assessmentSettings.getShowCorrectResponse()));\n    \t\tfeedback.setShowStudentScore(Boolean.valueOf(assessmentSettings.getShowStudentScore()));\n    \t\tfeedback.setShowStudentQuestionScore(Boolean.valueOf(assessmentSettings.getShowStudentQuestionScore()));\n    \t\tfeedback.setShowQuestionLevelFeedback(Boolean.valueOf(assessmentSettings.getShowQuestionLevelFeedback()));\n    \t\tfeedback.setShowSelectionLevelFeedback(Boolean.valueOf(assessmentSettings.getShowSelectionLevelFeedback()));\n    \t\tfeedback.setShowGraderComments(Boolean.valueOf(assessmentSettings.getShowGraderComments()));\n    \t\tfeedback.setShowStatistics(Boolean.valueOf(assessmentSettings.getShowStatistics()));\n    }\n    assessment.setAssessmentFeedback(feedback);\n\n    // g. set Grading\n    EvaluationModel evaluation = (EvaluationModel) assessment.getEvaluationModel();\n    if (evaluation == null){\n      evaluation = new EvaluationModel();\n      // need to fix evaluation so it can take AssessmentFacade later\n      evaluation.setAssessmentBase(assessment.getData());\n    }\n    \n    String firstTargetSelected = assessmentSettings.getFirstTargetSelected();\n\tif (\"Anonymous Users\".equals(firstTargetSelected)) {\n\t\tevaluation.setAnonymousGrading(Integer.valueOf(\"1\"));\n\t\tevaluation.setToGradeBook(\"2\");\n\t}\n\telse {\n\t\tif (assessmentSettings.getAnonymousGrading()) {\n\t\t      evaluation.setAnonymousGrading(Integer.valueOf(1));\n\t\t}\n\t\telse {\n\t\t\tevaluation.setAnonymousGrading(Integer.valueOf(2));\n\t\t}\n\t\tif (assessmentSettings.getToDefaultGradebook()) {\n\t\t\tevaluation.setToGradeBook(\"1\");\n\t\t}\n\t\telse {\n\t\t\tevaluation.setToGradeBook(\"2\");\n\t\t}\n\t}\n    \n    if (assessmentSettings.getScoringType()!=null)\n      evaluation.setScoringType(new Integer(assessmentSettings.getScoringType()));\n    assessment.setEvaluationModel(evaluation);\n\n\n    // h. update ValueMap: it contains value for teh checkboxes in\n    // authorSettings.jsp for: hasAvailableDate, hasDueDate,\n    // hasRetractDate, hasAnonymous, hasAuthenticatedUser, hasIpAddress,\n    // hasUsernamePassword,\n    // hasTimeAssessment,hasAutoSubmit, hasPartMetaData, hasQuestionMetaData\n    HashMap h = assessmentSettings.getValueMap();\n    h = addExtendedTimeValuesToMetaData(assessment, assessmentSettings);\n    updateMetaWithValueMap(assessment, h);\n\n    // i. set Graphics\n    assessment.updateAssessmentMetaData(AssessmentMetaDataIfc.BGCOLOR, TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, assessmentSettings.getBgColor()));\n    assessment.updateAssessmentMetaData(AssessmentMetaDataIfc.BGIMAGE, TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, assessmentSettings.getBgImage()));\n\n    // j. set objectives,rubrics,keywords\n    assessment.updateAssessmentMetaData(AssessmentMetaDataIfc.KEYWORDS, TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, assessmentSettings.getKeywords()));\n    assessment.updateAssessmentMetaData(AssessmentMetaDataIfc.OBJECTIVES, TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, assessmentSettings.getObjectives()));\n    assessment.updateAssessmentMetaData(AssessmentMetaDataIfc.RUBRICS, TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, assessmentSettings.getRubrics()));\n\n    // jj. save assessment first, then deal with ip\n    assessmentService.saveAssessment(assessment);\n    assessmentService.deleteAllSecuredIP(assessment);\n\n    // k. set ipAddresses\n   \n    HashSet ipSet = new HashSet();\n    String ipAddresses = assessmentSettings.getIpAddresses();\n    if (ipAddresses == null)\n      ipAddresses = \"\";\n    \n    String[] ip = ipAddresses.split(\"\\\\n\");\n    for (int j=0; j<ip.length;j++){\n      if (ip[j]!=null && !ip[j].equals(\"\\r\")) {\n    \t  \n        ipSet.add(new SecuredIPAddress(assessment.getData(),null,ip[j]));\n      }\n    }\n    assessment.setSecuredIPAddressSet(ipSet);\n    \n    // kk. secure delivery settings\n    SecureDeliveryServiceAPI secureDeliveryService = SamigoApiFactory.getInstance().getSecureDeliveryServiceAPI();\n    assessment.updateAssessmentMetaData(SecureDeliveryServiceAPI.MODULE_KEY, assessmentSettings.getSecureDeliveryModule() );\n    String encryptedPassword = secureDeliveryService.encryptPassword( assessmentSettings.getSecureDeliveryModule(), assessmentSettings.getSecureDeliveryModuleExitPassword() );\n    assessment.updateAssessmentMetaData(SecureDeliveryServiceAPI.EXITPWD_KEY, TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, encryptedPassword ));\n    \n    // kkk. remove the existing title decoration (if any) and then add the new one (if any)    \n    String titleDecoration = assessment.getAssessmentMetaDataByLabel( SecureDeliveryServiceAPI.TITLE_DECORATION );\n    String newTitle;\n    if ( titleDecoration != null )\n    \tnewTitle = assessment.getTitle().replace( titleDecoration, \"\");\n    else\n    \tnewTitle = assessment.getTitle();\n    \n    // getTitleDecoration() returns \"\" if null or NONE module is passed\n    titleDecoration = secureDeliveryService.getTitleDecoration( assessmentSettings.getSecureDeliveryModule(), new ResourceLoader().getLocale() );\n    if (titleDecoration != null && !titleDecoration.trim().equals(\"\")) {\n    \tnewTitle = newTitle + \" \" + titleDecoration;\n    }\n    \n    assessment.setTitle( newTitle );\n    assessment.updateAssessmentMetaData(SecureDeliveryServiceAPI.TITLE_DECORATION, titleDecoration );\n\n    assessment.setInstructorNotification(Integer.valueOf(assessmentSettings.getInstructorNotification()));\n\n    // l. FINALLY: save the assessment\n    assessmentService.saveAssessment(assessment);\n\n    // added by daisyf, 10/10/06\n    updateAttachment(assessment.getAssessmentAttachmentList(), assessmentSettings.getAttachmentList(),(AssessmentIfc)assessment.getData(), true);\n    EventTrackingService.post(EventTrackingService.newEvent(\"sam.setting.edit\", \"siteId=\" + AgentFacade.getCurrentSiteId() + \", assessmentId=\" + assessmentSettings.getAssessmentId(), true));\n    \n    AuthzQueriesFacadeAPI authz = PersistenceService.getInstance().getAuthzQueriesFacade();\n    if (assessmentSettings.getReleaseTo().equals(AssessmentAccessControl.RELEASE_TO_SELECTED_GROUPS)) {\n        authz.removeAuthorizationByQualifierAndFunction(assessmentId.toString(), \"TAKE_ASSESSMENT\");\n    \tString[] groupsAuthorized = assessmentSettings.getGroupsAuthorizedToSave();//getGroupsAuthorized();\n    \tif (groupsAuthorized != null && groupsAuthorized.length > 0) {\n    \t\tfor (int i=0; i<groupsAuthorized.length; i++){\n    \t\t\tauthz.createAuthorization(groupsAuthorized[i], \"TAKE_ASSESSMENT\", assessmentId.toString());\n    \t\t}\n    \t\t\n    \t\tPublishedAssessmentService publishedAssessmentService = new PublishedAssessmentService();\n    \t\tTreeMap groupsForSite = publishedAssessmentService.getGroupsForSite();\n    \t\tif (groupsForSite != null && groupsForSite.size() > 0) {\n    \t\t\tString releaseToGroups = getReleaseToGroupsAsString(groupsForSite, groupsAuthorized);\n    \t\t\tassessmentSettings.setReleaseToGroupsAsString(releaseToGroups);\n    \t\t}\n    \t}\n    }\n    else { // releaseTo is not \"Selected Groups\" - clean up old/orphaned group permissions if necessary\n    \tCollection groups = null;\n    \ttry {\n    \t\tSite site = SiteService.getSite(ToolManager.getCurrentPlacement().getContext());\n    \t\tgroups = site.getGroups();\n    \t}\n\t\tcatch (IdUnusedException ex) {\n\t\t\t// No site available\n\t\t}\n\t\tif (groups != null && groups.size() > 0) {\n\t\t\tIterator groupIter = groups.iterator();\n\t\t\twhile (groupIter.hasNext()) {\n\t\t\t\tGroup group = (Group) groupIter.next();\n\t\t\t\t//try {\n\t\t\t\t\tauthz.removeAuthorizationByAgentQualifierAndFunction(group.getId(), assessmentId.toString(), \"TAKE_ASSESSMENT\");\n\t\t\t\t//}\n\t\t\t\t//catch (Exception ex) {\n\t\t\t\t\t// No authz permission data for the group\n\t\t\t\t//}\n    \t\t}\n    \t}\n    }\n    \n    assessment = assessmentService.getAssessment(assessmentId.toString());\n    \n    return assessment;\n  }","id":60333,"modified_method":"public AssessmentFacade save(AssessmentSettingsBean assessmentSettings, boolean isFromConfirmPublishAssessmentListener)\n  {\n    // create an assessment based on the title entered and the assessment\n    // template selected\n    // #1 - set Assessment\n    Long assessmentId = assessmentSettings.getAssessmentId();\n    //log.info(\"**** save assessment assessmentId =\"+assessmentId.toString());\n    ItemAuthorBean iAuthor=new ItemAuthorBean();\n    //System.out.println(\"assessmentSettings.getFeedbackAuthoring: \"+assessmentSettings.getFeedbackAuthoring());\n    iAuthor.setShowFeedbackAuthoring(assessmentSettings.getFeedbackAuthoring());\n    //System.out.println(\"iAuthor.getShowFeedbackAuthoring :\"+iAuthor.getShowFeedbackAuthoring());\n    AssessmentService assessmentService = new AssessmentService();\n    AssessmentFacade assessment = assessmentService.getAssessment(\n        assessmentId.toString());\n    //log.info(\"** assessment = \"+assessment);\n    assessment.setTitle(TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, assessmentSettings.getTitle()));\n    //assessment.setTitle(assessmentSettings.getTitle());\n    assessment.setDescription(assessmentSettings.getDescription());\n    assessment.updateAssessmentMetaData(AssessmentMetaDataIfc.AUTHORS, TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, assessmentSettings.getAuthors()));\n\n    // #2 - set AssessmentAccessControl\n    AssessmentAccessControl control = (AssessmentAccessControl)assessment.getAssessmentAccessControl();\n    if (control == null){\n      control = new AssessmentAccessControl();\n      // need to fix accessControl so it can take AssessmentFacade later\n      control.setAssessmentBase(assessment.getData());\n    }\n    // a. LATER set dueDate, retractDate, startDate, releaseTo\n    if (isFromConfirmPublishAssessmentListener) {\n    \tif (assessmentSettings.getStartDate() != null) {\n    \t\tcontrol.setStartDate(assessmentSettings.getStartDate());\n    \t}\n    \telse {\n    \t\tcontrol.setStartDate(new Date());\n    \t}\n    }\n    else {\n    \tcontrol.setStartDate(assessmentSettings.getStartDate());\n    }\n    control.setDueDate(assessmentSettings.getDueDate());\n\n    if (assessmentSettings.getLateHandling() != null) {\n        control.setLateHandling(new Integer(assessmentSettings.getLateHandling()));\n    }\n\n    if (assessmentSettings.getRetractDate() == null\n            || \"\".equals(assessmentSettings.getRetractDateString())) {\n        control.setRetractDate(null);\n        control.setLateHandling(AssessmentAccessControl.NOT_ACCEPT_LATE_SUBMISSION);\n    } else {\n        control.setRetractDate(assessmentSettings.getRetractDate());\n    }\n    control.setFeedbackDate(assessmentSettings.getFeedbackDate());\n    control.setReleaseTo(assessmentSettings.getReleaseTo());\n    //log.info(\"control RELEASETO =\"+control.getReleaseTo());\n    //log.info(\"settings RELEASETO =\"+assessmentSettings.getReleaseTo());\n\n    // b. set Timed Assessment\n    //log.info(\"** Time limit update to = \"+assessmentSettings.getTimeLimit().intValue());\n    control.setTimeLimit(assessmentSettings.getTimeLimit());\n    if (assessmentSettings.getTimedAssessment())\n      control.setTimedAssessment(AssessmentAccessControl.TIMED_ASSESSMENT);\n    else\n      control.setTimedAssessment(AssessmentAccessControl.DO_NOT_TIMED_ASSESSMENT);\n\n    // c. set Assessment Orgainzation\n    if (assessmentSettings.getItemNavigation()!=null ) {\n    \tString nav = assessmentSettings.getItemNavigation();\n    \tif (\"1\".equals(nav)) {\n    \t\tassessmentSettings.setAssessmentFormat(\"1\");\n    \t}\n    \tcontrol.setItemNavigation(Integer.valueOf(nav));\n    }\n    if (assessmentSettings.getItemNumbering()!=null)\n      control.setItemNumbering(new Integer(assessmentSettings.getItemNumbering()));\n    if(assessmentSettings.getDisplayScoreDuringAssessments() != null)\n    \tcontrol.setDisplayScoreDuringAssessments(new Integer(assessmentSettings.getDisplayScoreDuringAssessments()));\n    if (assessmentSettings.getAssessmentFormat()!=null )\n     control.setAssessmentFormat(new Integer(assessmentSettings.getAssessmentFormat()));\n\n    if (assessmentSettings.getIsMarkForReview())\n        control.setMarkForReview(AssessmentAccessControl.MARK_FOR_REVIEW);\n    else {\n    \tcontrol.setMarkForReview(AssessmentAccessControl.NOT_MARK_FOR_REVIEW);\n    }\n\n\n    // d. set Submissions\n    if (assessmentSettings.getUnlimitedSubmissions()!=null){\n    \tif (!assessmentSettings.getUnlimitedSubmissions().\n    \t\t\tequals(AssessmentAccessControlIfc.UNLIMITED_SUBMISSIONS.toString())) {\n    \t\tcontrol.setUnlimitedSubmissions(Boolean.FALSE);\n    \t\tif (assessmentSettings.getSubmissionsAllowed() != null)\n    \t\t\tcontrol.setSubmissionsAllowed(new Integer(assessmentSettings.\n    \t\t\t\t\tgetSubmissionsAllowed()));\n    \t\telse\n    \t\t\tcontrol.setSubmissionsAllowed(Integer.valueOf(\"1\"));\n    \t}\n    \telse {\n    \t\tcontrol.setUnlimitedSubmissions(Boolean.TRUE);\n    \t\tcontrol.setSubmissionsAllowed(null);\n    \t}\n    }\n\n    //log.info(\"**unlimited submission=\"+assessmentSettings.getUnlimitedSubmissions());\n    //log.info(\"**allowed=\"+control.getSubmissionsAllowed());\n\n    if (assessmentSettings.getSubmissionsSaved()!=null){\n      control.setSubmissionsSaved(new Integer(assessmentSettings.getSubmissionsSaved()));\n    }\n    \n    if (assessmentSettings.getAutoSubmit())\n        control.setAutoSubmit(AssessmentAccessControl.AUTO_SUBMIT);\n    else {\n    \tcontrol.setAutoSubmit(AssessmentAccessControl.DO_NOT_AUTO_SUBMIT);\n    }\n    assessment.setAssessmentAccessControl(control);\n\n    // e. set Submission Messages\n    control.setSubmissionMessage(assessmentSettings.getSubmissionMessage());\n    // f. set username\n    control.setUsername(TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, StringUtils.trim(assessmentSettings.getUsername())));\n    // g. set password\n    control.setPassword(TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, StringUtils.trim(assessmentSettings.getPassword())));\n    // h. set finalPageUrl\n\n    String finalPageUrl = \"\";\n    if (assessmentSettings.getFinalPageUrl() != null) {\n    \tfinalPageUrl = TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, assessmentSettings.getFinalPageUrl().trim());\n    \tif (finalPageUrl.length() != 0 && !finalPageUrl.toLowerCase().startsWith(\"http\")) {\n    \t\tfinalPageUrl = \"http://\" + finalPageUrl;\n    \t}\n    }\n    control.setFinalPageUrl(finalPageUrl);\n\n    //#3 Feedback\n    AssessmentFeedback feedback = (AssessmentFeedback)assessment.getAssessmentFeedback();\n    if (feedback == null){\n      feedback = new AssessmentFeedback();\n      // need to fix feeback so it can take AssessmentFacade later\n      feedback.setAssessmentBase(assessment.getData());\n    }\n    if (assessmentSettings.getFeedbackDelivery()!=null)\n     feedback.setFeedbackDelivery(new Integer(assessmentSettings.getFeedbackDelivery()));\n    if (StringUtils.isNotBlank(assessmentSettings.getFeedbackComponentOption()))\n        feedback.setFeedbackComponentOption(new Integer(assessmentSettings.getFeedbackComponentOption()));\n    if (assessmentSettings.getFeedbackAuthoring()!=null)\n     feedback.setFeedbackAuthoring(new Integer(assessmentSettings.getFeedbackAuthoring()));\n    // if 'No feedback' (it corresponds to value 3) is selected, \n\t// all components are unchecked\n    if (feedback.getFeedbackDelivery().equals(new Integer(\"3\")))\n    {\n    \tfeedback.setShowQuestionText(false);\n\t\tfeedback.setShowStudentResponse(false);\n\t\tfeedback.setShowCorrectResponse(false);\n\t\tfeedback.setShowStudentScore(false);\n\t\tfeedback.setShowStudentQuestionScore(false);\n\t\tfeedback.setShowQuestionLevelFeedback(false);\n\t\tfeedback.setShowSelectionLevelFeedback(false);\n\t\tfeedback.setShowGraderComments(false);\n\t\tfeedback.setShowStatistics(false);\n    }\n    else {\n    \t\tfeedback.setShowQuestionText(Boolean.valueOf(assessmentSettings.getShowQuestionText()));\n    \t\tfeedback.setShowStudentResponse(Boolean.valueOf(assessmentSettings.getShowStudentResponse()));\n    \t\tfeedback.setShowCorrectResponse(Boolean.valueOf(assessmentSettings.getShowCorrectResponse()));\n    \t\tfeedback.setShowStudentScore(Boolean.valueOf(assessmentSettings.getShowStudentScore()));\n    \t\tfeedback.setShowStudentQuestionScore(Boolean.valueOf(assessmentSettings.getShowStudentQuestionScore()));\n    \t\tfeedback.setShowQuestionLevelFeedback(Boolean.valueOf(assessmentSettings.getShowQuestionLevelFeedback()));\n    \t\tfeedback.setShowSelectionLevelFeedback(Boolean.valueOf(assessmentSettings.getShowSelectionLevelFeedback()));\n    \t\tfeedback.setShowGraderComments(Boolean.valueOf(assessmentSettings.getShowGraderComments()));\n    \t\tfeedback.setShowStatistics(Boolean.valueOf(assessmentSettings.getShowStatistics()));\n    }\n    assessment.setAssessmentFeedback(feedback);\n\n    // g. set Grading\n    EvaluationModel evaluation = (EvaluationModel) assessment.getEvaluationModel();\n    if (evaluation == null){\n      evaluation = new EvaluationModel();\n      // need to fix evaluation so it can take AssessmentFacade later\n      evaluation.setAssessmentBase(assessment.getData());\n    }\n    \n    String firstTargetSelected = assessmentSettings.getFirstTargetSelected();\n\tif (\"Anonymous Users\".equals(firstTargetSelected)) {\n\t\tevaluation.setAnonymousGrading(Integer.valueOf(\"1\"));\n\t\tevaluation.setToGradeBook(\"2\");\n\t}\n\telse {\n\t\tif (assessmentSettings.getAnonymousGrading()) {\n\t\t      evaluation.setAnonymousGrading(Integer.valueOf(1));\n\t\t}\n\t\telse {\n\t\t\tevaluation.setAnonymousGrading(Integer.valueOf(2));\n\t\t}\n\t\tif (assessmentSettings.getToDefaultGradebook()) {\n\t\t\tevaluation.setToGradeBook(\"1\");\n\t\t}\n\t\telse {\n\t\t\tevaluation.setToGradeBook(\"2\");\n\t\t}\n\t}\n    \n    if (assessmentSettings.getScoringType()!=null)\n      evaluation.setScoringType(new Integer(assessmentSettings.getScoringType()));\n    assessment.setEvaluationModel(evaluation);\n\n\n    // h. update ValueMap: it contains value for teh checkboxes in\n    // authorSettings.jsp for: hasAvailableDate, hasDueDate,\n    // hasRetractDate, hasAnonymous, hasAuthenticatedUser, hasIpAddress,\n    // hasUsernamePassword,\n    // hasTimeAssessment,hasAutoSubmit, hasPartMetaData, hasQuestionMetaData\n    HashMap h = assessmentSettings.getValueMap();\n    h = addExtendedTimeValuesToMetaData(assessment, assessmentSettings);\n    updateMetaWithValueMap(assessment, h);\n\n    // i. set Graphics\n    assessment.updateAssessmentMetaData(AssessmentMetaDataIfc.BGCOLOR, TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, assessmentSettings.getBgColor()));\n    assessment.updateAssessmentMetaData(AssessmentMetaDataIfc.BGIMAGE, TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, assessmentSettings.getBgImage()));\n\n    // j. set objectives,rubrics,keywords\n    assessment.updateAssessmentMetaData(AssessmentMetaDataIfc.KEYWORDS, TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, assessmentSettings.getKeywords()));\n    assessment.updateAssessmentMetaData(AssessmentMetaDataIfc.OBJECTIVES, TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, assessmentSettings.getObjectives()));\n    assessment.updateAssessmentMetaData(AssessmentMetaDataIfc.RUBRICS, TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, assessmentSettings.getRubrics()));\n\n    // jj. save assessment first, then deal with ip\n    assessmentService.saveAssessment(assessment);\n    assessmentService.deleteAllSecuredIP(assessment);\n\n    // k. set ipAddresses\n   \n    HashSet ipSet = new HashSet();\n    String ipAddresses = assessmentSettings.getIpAddresses();\n    if (ipAddresses == null)\n      ipAddresses = \"\";\n    \n    String[] ip = ipAddresses.split(\"\\\\n\");\n    for (int j=0; j<ip.length;j++){\n      if (ip[j]!=null && !ip[j].equals(\"\\r\")) {\n    \t  \n        ipSet.add(new SecuredIPAddress(assessment.getData(),null,ip[j]));\n      }\n    }\n    assessment.setSecuredIPAddressSet(ipSet);\n    \n    // kk. secure delivery settings\n    SecureDeliveryServiceAPI secureDeliveryService = SamigoApiFactory.getInstance().getSecureDeliveryServiceAPI();\n    assessment.updateAssessmentMetaData(SecureDeliveryServiceAPI.MODULE_KEY, assessmentSettings.getSecureDeliveryModule() );\n    String encryptedPassword = secureDeliveryService.encryptPassword( assessmentSettings.getSecureDeliveryModule(), assessmentSettings.getSecureDeliveryModuleExitPassword() );\n    assessment.updateAssessmentMetaData(SecureDeliveryServiceAPI.EXITPWD_KEY, TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, encryptedPassword ));\n    \n    // kkk. remove the existing title decoration (if any) and then add the new one (if any)    \n    String titleDecoration = assessment.getAssessmentMetaDataByLabel( SecureDeliveryServiceAPI.TITLE_DECORATION );\n    String newTitle;\n    if ( titleDecoration != null )\n    \tnewTitle = assessment.getTitle().replace( titleDecoration, \"\");\n    else\n    \tnewTitle = assessment.getTitle();\n    \n    // getTitleDecoration() returns \"\" if null or NONE module is passed\n    titleDecoration = secureDeliveryService.getTitleDecoration( assessmentSettings.getSecureDeliveryModule(), new ResourceLoader().getLocale() );\n    if (titleDecoration != null && !titleDecoration.trim().equals(\"\")) {\n    \tnewTitle = newTitle + \" \" + titleDecoration;\n    }\n    \n    assessment.setTitle( newTitle );\n    assessment.updateAssessmentMetaData(SecureDeliveryServiceAPI.TITLE_DECORATION, titleDecoration );\n\n    assessment.setInstructorNotification(Integer.valueOf(assessmentSettings.getInstructorNotification()));\n\n    // l. FINALLY: save the assessment\n    assessmentService.saveAssessment(assessment);\n\n    // added by daisyf, 10/10/06\n    updateAttachment(assessment.getAssessmentAttachmentList(), assessmentSettings.getAttachmentList(),(AssessmentIfc)assessment.getData(), true);\n    EventTrackingService.post(EventTrackingService.newEvent(\"sam.setting.edit\", \"siteId=\" + AgentFacade.getCurrentSiteId() + \", assessmentId=\" + assessmentSettings.getAssessmentId(), true));\n    \n    AuthzQueriesFacadeAPI authz = PersistenceService.getInstance().getAuthzQueriesFacade();\n    if (assessmentSettings.getReleaseTo().equals(AssessmentAccessControl.RELEASE_TO_SELECTED_GROUPS)) {\n        authz.removeAuthorizationByQualifierAndFunction(assessmentId.toString(), \"TAKE_ASSESSMENT\");\n    \tString[] groupsAuthorized = assessmentSettings.getGroupsAuthorizedToSave();//getGroupsAuthorized();\n    \tif (groupsAuthorized != null && groupsAuthorized.length > 0) {\n    \t\tfor (int i=0; i<groupsAuthorized.length; i++){\n    \t\t\tauthz.createAuthorization(groupsAuthorized[i], \"TAKE_ASSESSMENT\", assessmentId.toString());\n    \t\t}\n    \t\t\n    \t\tPublishedAssessmentService publishedAssessmentService = new PublishedAssessmentService();\n    \t\tTreeMap groupsForSite = publishedAssessmentService.getGroupsForSite();\n    \t\tif (groupsForSite != null && groupsForSite.size() > 0) {\n    \t\t\tString releaseToGroups = getReleaseToGroupsAsString(groupsForSite, groupsAuthorized);\n    \t\t\tassessmentSettings.setReleaseToGroupsAsString(releaseToGroups);\n    \t\t}\n    \t}\n    }\n    else { // releaseTo is not \"Selected Groups\" - clean up old/orphaned group permissions if necessary\n    \tCollection groups = null;\n    \ttry {\n    \t\tSite site = SiteService.getSite(ToolManager.getCurrentPlacement().getContext());\n    \t\tgroups = site.getGroups();\n    \t}\n\t\tcatch (IdUnusedException ex) {\n\t\t\t// No site available\n\t\t}\n\t\tif (groups != null && groups.size() > 0) {\n\t\t\tIterator groupIter = groups.iterator();\n\t\t\twhile (groupIter.hasNext()) {\n\t\t\t\tGroup group = (Group) groupIter.next();\n\t\t\t\t//try {\n\t\t\t\t\tauthz.removeAuthorizationByAgentQualifierAndFunction(group.getId(), assessmentId.toString(), \"TAKE_ASSESSMENT\");\n\t\t\t\t//}\n\t\t\t\t//catch (Exception ex) {\n\t\t\t\t\t// No authz permission data for the group\n\t\t\t\t//}\n    \t\t}\n    \t}\n    }\n    \n    assessment = assessmentService.getAssessment(assessmentId.toString());\n    \n    return assessment;\n  }","commit_id":"b0838d8a0b03aec051031732de0df836bb25759d","url":"https://github.com/sakaiproject/sakai"},{"original_method":"private void setPublishedSettings(PublishedAssessmentSettingsBean assessmentSettings, PublishedAssessmentFacade assessment, boolean retractNow, SaveAssessmentSettings saveAssessmentSettings) {\n\t\t// Title is set in isTitleChanged()\n\t\tassessment.setDescription(assessmentSettings.getDescription());\n\t    assessment.updateAssessmentMetaData(AssessmentMetaDataIfc.AUTHORS, assessmentSettings.getAuthors());\n\t    \n\t\tPublishedAccessControl control = (PublishedAccessControl)assessment.getAssessmentAccessControl();\n\t\tif (control == null){\n\t\t\tcontrol = new PublishedAccessControl();\n\t\t\t// need to fix accessControl so it can take AssessmentFacade later\n\t\t\tcontrol.setAssessmentBase(assessment.getData());\n\t\t}\n\t\t// set startDate, dueDate, retractDate \n\t\tcontrol.setStartDate(assessmentSettings.getStartDate());\n\t\tcontrol.setDueDate(assessmentSettings.getDueDate());\n\t\tif (retractNow)\n\t\t{\n\t\t\tcontrol.setRetractDate(new Date());\n\t\t}\n\t\telse {\n\t\t\tcontrol.setRetractDate(assessmentSettings.getRetractDate());\n\t\t}\n\n\t\t\n\t\t// set Assessment Orgainzation\n\t\tif (assessmentSettings.getItemNavigation()!=null ) {\n\t\t\tString nav = assessmentSettings.getItemNavigation();\n\t\t\tif (\"1\".equals(nav)) {\n\t\t\t\tassessmentSettings.setAssessmentFormat(\"1\");\n\t\t\t}\n\t\t\tcontrol.setItemNavigation(Integer.valueOf(nav));\n\t\t}\n\t\tif (assessmentSettings.getAssessmentFormat() != null ) {\n\t\t\tcontrol.setAssessmentFormat(new Integer(assessmentSettings.getAssessmentFormat()));\n\t\t}\t    \n\t\tif (assessmentSettings.getItemNumbering() != null) {\n\t\t\tcontrol.setItemNumbering(new Integer(assessmentSettings.getItemNumbering()));\n\t\t}\n\t\tif (assessmentSettings.getDisplayScoreDuringAssessments() != null) {\n\t\t\tcontrol.setDisplayScoreDuringAssessments(new Integer(assessmentSettings.getDisplayScoreDuringAssessments()));\n\t\t}\n\t\t\n\t\t// set Timed Assessment\n\t\tcontrol.setTimeLimit(assessmentSettings.getTimeLimit());\n\t\tif (assessmentSettings.getTimedAssessment()) {\n\t\t\tcontrol.setTimedAssessment(AssessmentAccessControl.TIMED_ASSESSMENT);\n\t\t}\n\t\telse {\n\t\t\tcontrol.setTimedAssessment(AssessmentAccessControl.DO_NOT_TIMED_ASSESSMENT);\n\t\t}\n\t\t\n\t\tif (assessmentSettings.getIsMarkForReview())\n\t        control.setMarkForReview(AssessmentAccessControl.MARK_FOR_REVIEW);\n\t    else {\n\t    \tcontrol.setMarkForReview(AssessmentAccessControl.NOT_MARK_FOR_REVIEW);\n\t    }\n\n\t\t// set Submissions\n\t\tif (assessmentSettings.getUnlimitedSubmissions()!=null){\n\t\t\tif (!assessmentSettings.getUnlimitedSubmissions().\n\t\t\t\t\tequals(AssessmentAccessControlIfc.UNLIMITED_SUBMISSIONS.toString())) {\n\t\t\t\tcontrol.setUnlimitedSubmissions(Boolean.FALSE);\n\t\t\t\tif (assessmentSettings.getSubmissionsAllowed() != null)\n\t\t\t\t\tcontrol.setSubmissionsAllowed(new Integer(assessmentSettings.\n\t\t\t\t\t\t\tgetSubmissionsAllowed()));\n\t\t\t\telse\n\t\t\t\t\tcontrol.setSubmissionsAllowed(Integer.valueOf(\"1\"));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcontrol.setUnlimitedSubmissions(Boolean.TRUE);\n\t\t\t\tcontrol.setSubmissionsAllowed(null);\n\t\t\t}\n\t\t}\n\n\t\tif (assessmentSettings.getLateHandling()!=null){\n\t\t\tcontrol.setLateHandling(new Integer(assessmentSettings.\n\t\t\t\t\tgetLateHandling()));\n\t\t}\n\t\tif (assessmentSettings.getSubmissionsSaved()!=null){\n\t\t\tcontrol.setSubmissionsSaved(new Integer(assessmentSettings.getSubmissionsSaved()));\n\t\t}\n\t\t\n\t\tif (assessmentSettings.getAutoSubmit())\n\t        control.setAutoSubmit(AssessmentAccessControl.AUTO_SUBMIT);\n\t    else {\n\t    \tcontrol.setAutoSubmit(AssessmentAccessControl.DO_NOT_AUTO_SUBMIT);\n\t    }\n\t\tassessment.setAssessmentAccessControl(control);\n\n\t\t// e. set Submission Messages\n\t    control.setSubmissionMessage(assessmentSettings.getSubmissionMessage());\n\t    // f. set username\n\t    control.setUsername(TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, StringUtils.trim(assessmentSettings.getUsername())));\n\t    // g. set password\n\t    control.setPassword(TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, StringUtils.trim(assessmentSettings.getPassword())));\n\t    // h. set finalPageUrl\n\t    String finalPageUrl = \"\";\n\t    if (assessmentSettings.getFinalPageUrl() != null) {\n\t    \tfinalPageUrl = TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, assessmentSettings.getFinalPageUrl().trim());\n\t    \tif (finalPageUrl.length() != 0 && !finalPageUrl.toLowerCase().startsWith(\"http\")) {\n\t    \t\tfinalPageUrl = \"http://\" + finalPageUrl;\n\t    \t}\n\t    }\n\t    control.setFinalPageUrl(finalPageUrl);\n\n\t\t// set Feedback\n\t\tAssessmentFeedbackIfc feedback = (AssessmentFeedbackIfc) assessment.getAssessmentFeedback();\n\t\tif (feedback == null){\n\t\t\tfeedback = new AssessmentFeedback();\n\t\t\t// need to fix feeback so it can take AssessmentFacade later\n\t\t\tfeedback.setAssessmentBase(assessment.getData());\n\t\t}\n\t\t// Feedback authoring\n\t\tif (StringUtils.isNotBlank(assessmentSettings.getFeedbackAuthoring()))\n\t\t\tfeedback.setFeedbackAuthoring(new Integer(assessmentSettings.getFeedbackAuthoring()));\n\t\t// Feedback delivery\n\t\tif (StringUtils.isNotBlank(assessmentSettings.getFeedbackDelivery()))\n\t\t\tfeedback.setFeedbackDelivery(new Integer(assessmentSettings.getFeedbackDelivery()));\n\t\tif (StringUtils.isNotBlank(assessmentSettings.getFeedbackComponentOption()))\n\t\t    feedback.setFeedbackComponentOption(new Integer(assessmentSettings.getFeedbackComponentOption()));\n\n\t\tcontrol.setFeedbackDate(assessmentSettings.getFeedbackDate());\n\t\t// Feedback Components Students Can See\n\t\t// if 'No feedback' (it corresponds to value 3) is selected, \n\t\t// all components are unchecked\n\t\t if (feedback.getFeedbackDelivery().equals(new Integer(\"3\")))\n\t\t    {\n\t\t    \tfeedback.setShowQuestionText(false);\n\t\t\t\tfeedback.setShowStudentResponse(false);\n\t\t\t\tfeedback.setShowCorrectResponse(false);\n\t\t\t\tfeedback.setShowStudentScore(false);\n\t\t\t\tfeedback.setShowStudentQuestionScore(false);\n\t\t\t\tfeedback.setShowQuestionLevelFeedback(false);\n\t\t\t\tfeedback.setShowSelectionLevelFeedback(false);\n\t\t\t\tfeedback.setShowGraderComments(false);\n\t\t\t\tfeedback.setShowStatistics(false);\n\t\t    }\n\t\t    else {\n\t\t    \t\tfeedback.setShowQuestionText(Boolean.valueOf(assessmentSettings.getShowQuestionText()));\n\t\t    \t\tfeedback.setShowStudentResponse(Boolean.valueOf(assessmentSettings.getShowStudentResponse()));\n\t\t    \t\tfeedback.setShowCorrectResponse(Boolean.valueOf(assessmentSettings.getShowCorrectResponse()));\n\t\t    \t\tfeedback.setShowStudentScore(Boolean.valueOf(assessmentSettings.getShowStudentScore()));\n\t\t    \t\tfeedback.setShowStudentQuestionScore(Boolean.valueOf(assessmentSettings.getShowStudentQuestionScore()));\n\t\t    \t\tfeedback.setShowQuestionLevelFeedback(Boolean.valueOf(assessmentSettings.getShowQuestionLevelFeedback()));\n\t\t    \t\tfeedback.setShowSelectionLevelFeedback(Boolean.valueOf(assessmentSettings.getShowSelectionLevelFeedback()));\n\t\t    \t\tfeedback.setShowGraderComments(Boolean.valueOf(assessmentSettings.getShowGraderComments()));\n\t\t    \t\tfeedback.setShowStatistics(Boolean.valueOf(assessmentSettings.getShowStatistics()));\n\t\t    }\n\t\tassessment.setAssessmentFeedback(feedback);\n\n\t\t// set Grading\n\t\tEvaluationModelIfc evaluation = (EvaluationModelIfc) assessment.getEvaluationModel();\n\t\tif (evaluation == null){\n\t\t\tevaluation = new EvaluationModel();\n\t\t\tevaluation.setAssessmentBase(assessment.getData());\n\t\t}\n\t\tif (assessmentSettings.getAnonymousGrading()) {\n\t\t\tevaluation.setAnonymousGrading(Integer.valueOf(1));\n\t\t}\n\t\telse {\n\t\t\tevaluation.setAnonymousGrading(Integer.valueOf(2));\n\t\t}\n\t    \n\t\t// If there is value set for toDefaultGradebook, we reset it\n\t\t// Otherwise, do nothing\n\t\tif (assessmentSettings.getToDefaultGradebook()) {\n\t\t\tevaluation.setToGradeBook(\"1\");\n\t\t}\n\t\telse {\n\t\t\tevaluation.setToGradeBook(\"2\");\n\t\t}\n\n\t\tif (assessmentSettings.getScoringType() != null) {\n\t\t\tevaluation.setScoringType(new Integer(assessmentSettings.getScoringType()));\n\t\t}\n\t\tassessment.setEvaluationModel(evaluation);\n\n\t\t// update ValueMap: it contains value for thh checkboxes in\n\t\t// publishedSettings.jsp for: hasAvailableDate, hasDueDate,\n\t\t// hasRetractDate, hasAnonymous, hasAuthenticatedUser, hasIpAddress,\n\t\t// hasUsernamePassword, hasTimeAssessment,hasAutoSubmit, hasPartMetaData, \n\t\t// hasQuestionMetaData\n\t\tHashMap h = assessmentSettings.getValueMap();\n\t\th = addExtendedTimeValuesToMetaData(assessment, assessmentSettings);\n\t\tsaveAssessmentSettings.updateMetaWithValueMap(assessment, h);\n\t\t\n\t\t// i. set Graphics\n\t\tassessment.updateAssessmentMetaData(AssessmentMetaDataIfc.BGCOLOR, TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, assessmentSettings.getBgColor()));\n\t\tassessment.updateAssessmentMetaData(AssessmentMetaDataIfc.BGIMAGE, TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, assessmentSettings.getBgImage()));\n\n\t    // j. set objectives,rubrics,keywords\n\t\tassessment.updateAssessmentMetaData(AssessmentMetaDataIfc.KEYWORDS, TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, assessmentSettings.getKeywords()));\n\t    assessment.updateAssessmentMetaData(AssessmentMetaDataIfc.OBJECTIVES, TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, assessmentSettings.getObjectives()));\n\t    assessment.updateAssessmentMetaData(AssessmentMetaDataIfc.RUBRICS, TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, assessmentSettings.getRubrics()));\n\t}","id":60334,"modified_method":"private void setPublishedSettings(PublishedAssessmentSettingsBean assessmentSettings, PublishedAssessmentFacade assessment, boolean retractNow, SaveAssessmentSettings saveAssessmentSettings) {\n\t\t// Title is set in isTitleChanged()\n\t\tassessment.setDescription(assessmentSettings.getDescription());\n\t    assessment.updateAssessmentMetaData(AssessmentMetaDataIfc.AUTHORS, assessmentSettings.getAuthors());\n\t    \n\t\tPublishedAccessControl control = (PublishedAccessControl)assessment.getAssessmentAccessControl();\n\t\tif (control == null){\n\t\t\tcontrol = new PublishedAccessControl();\n\t\t\t// need to fix accessControl so it can take AssessmentFacade later\n\t\t\tcontrol.setAssessmentBase(assessment.getData());\n\t\t}\n\t\t// set startDate, dueDate, retractDate \n\t\tcontrol.setStartDate(assessmentSettings.getStartDate());\n\t\tcontrol.setDueDate(assessmentSettings.getDueDate());\n\n\t\tif (assessmentSettings.getLateHandling() != null) {\n\t\t\tcontrol.setLateHandling(new Integer(assessmentSettings.getLateHandling()));\n\t\t}\n\n\t\tif (retractNow)\n\t\t{\n\t\t\tcontrol.setRetractDate(new Date());\n\t\t}\n\t\telse if (assessmentSettings.getRetractDate() == null\n\t\t\t\t || \"\".equals(assessmentSettings.getRetractDateString()))\n\t\t{\n\t\t\tcontrol.setLateHandling(AssessmentAccessControl.NOT_ACCEPT_LATE_SUBMISSION);\n\t\t\tcontrol.setRetractDate(null);\n\t\t}\n\t\telse {\n\t\t\tcontrol.setRetractDate(assessmentSettings.getRetractDate());\n\t\t}\n\n\t\t\n\t\t// set Assessment Orgainzation\n\t\tif (assessmentSettings.getItemNavigation()!=null ) {\n\t\t\tString nav = assessmentSettings.getItemNavigation();\n\t\t\tif (\"1\".equals(nav)) {\n\t\t\t\tassessmentSettings.setAssessmentFormat(\"1\");\n\t\t\t}\n\t\t\tcontrol.setItemNavigation(Integer.valueOf(nav));\n\t\t}\n\t\tif (assessmentSettings.getAssessmentFormat() != null ) {\n\t\t\tcontrol.setAssessmentFormat(new Integer(assessmentSettings.getAssessmentFormat()));\n\t\t}\t    \n\t\tif (assessmentSettings.getItemNumbering() != null) {\n\t\t\tcontrol.setItemNumbering(new Integer(assessmentSettings.getItemNumbering()));\n\t\t}\n\t\tif (assessmentSettings.getDisplayScoreDuringAssessments() != null) {\n\t\t\tcontrol.setDisplayScoreDuringAssessments(new Integer(assessmentSettings.getDisplayScoreDuringAssessments()));\n\t\t}\n\t\t\n\t\t// set Timed Assessment\n\t\tcontrol.setTimeLimit(assessmentSettings.getTimeLimit());\n\t\tif (assessmentSettings.getTimedAssessment()) {\n\t\t\tcontrol.setTimedAssessment(AssessmentAccessControl.TIMED_ASSESSMENT);\n\t\t}\n\t\telse {\n\t\t\tcontrol.setTimedAssessment(AssessmentAccessControl.DO_NOT_TIMED_ASSESSMENT);\n\t\t}\n\t\t\n\t\tif (assessmentSettings.getIsMarkForReview())\n\t        control.setMarkForReview(AssessmentAccessControl.MARK_FOR_REVIEW);\n\t    else {\n\t    \tcontrol.setMarkForReview(AssessmentAccessControl.NOT_MARK_FOR_REVIEW);\n\t    }\n\n\t\t// set Submissions\n\t\tif (assessmentSettings.getUnlimitedSubmissions()!=null){\n\t\t\tif (!assessmentSettings.getUnlimitedSubmissions().\n\t\t\t\t\tequals(AssessmentAccessControlIfc.UNLIMITED_SUBMISSIONS.toString())) {\n\t\t\t\tcontrol.setUnlimitedSubmissions(Boolean.FALSE);\n\t\t\t\tif (assessmentSettings.getSubmissionsAllowed() != null)\n\t\t\t\t\tcontrol.setSubmissionsAllowed(new Integer(assessmentSettings.\n\t\t\t\t\t\t\tgetSubmissionsAllowed()));\n\t\t\t\telse\n\t\t\t\t\tcontrol.setSubmissionsAllowed(Integer.valueOf(\"1\"));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcontrol.setUnlimitedSubmissions(Boolean.TRUE);\n\t\t\t\tcontrol.setSubmissionsAllowed(null);\n\t\t\t}\n\t\t}\n\n\n\t\tif (assessmentSettings.getSubmissionsSaved()!=null){\n\t\t\tcontrol.setSubmissionsSaved(new Integer(assessmentSettings.getSubmissionsSaved()));\n\t\t}\n\t\t\n\t\tif (assessmentSettings.getAutoSubmit())\n\t        control.setAutoSubmit(AssessmentAccessControl.AUTO_SUBMIT);\n\t    else {\n\t    \tcontrol.setAutoSubmit(AssessmentAccessControl.DO_NOT_AUTO_SUBMIT);\n\t    }\n\t\tassessment.setAssessmentAccessControl(control);\n\n\t\t// e. set Submission Messages\n\t    control.setSubmissionMessage(assessmentSettings.getSubmissionMessage());\n\t    // f. set username\n\t    control.setUsername(TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, StringUtils.trim(assessmentSettings.getUsername())));\n\t    // g. set password\n\t    control.setPassword(TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, StringUtils.trim(assessmentSettings.getPassword())));\n\t    // h. set finalPageUrl\n\t    String finalPageUrl = \"\";\n\t    if (assessmentSettings.getFinalPageUrl() != null) {\n\t    \tfinalPageUrl = TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, assessmentSettings.getFinalPageUrl().trim());\n\t    \tif (finalPageUrl.length() != 0 && !finalPageUrl.toLowerCase().startsWith(\"http\")) {\n\t    \t\tfinalPageUrl = \"http://\" + finalPageUrl;\n\t    \t}\n\t    }\n\t    control.setFinalPageUrl(finalPageUrl);\n\n\t\t// set Feedback\n\t\tAssessmentFeedbackIfc feedback = (AssessmentFeedbackIfc) assessment.getAssessmentFeedback();\n\t\tif (feedback == null){\n\t\t\tfeedback = new AssessmentFeedback();\n\t\t\t// need to fix feeback so it can take AssessmentFacade later\n\t\t\tfeedback.setAssessmentBase(assessment.getData());\n\t\t}\n\t\t// Feedback authoring\n\t\tif (StringUtils.isNotBlank(assessmentSettings.getFeedbackAuthoring()))\n\t\t\tfeedback.setFeedbackAuthoring(new Integer(assessmentSettings.getFeedbackAuthoring()));\n\t\t// Feedback delivery\n\t\tif (StringUtils.isNotBlank(assessmentSettings.getFeedbackDelivery()))\n\t\t\tfeedback.setFeedbackDelivery(new Integer(assessmentSettings.getFeedbackDelivery()));\n\t\tif (StringUtils.isNotBlank(assessmentSettings.getFeedbackComponentOption()))\n\t\t    feedback.setFeedbackComponentOption(new Integer(assessmentSettings.getFeedbackComponentOption()));\n\n\t\tcontrol.setFeedbackDate(assessmentSettings.getFeedbackDate());\n\t\t// Feedback Components Students Can See\n\t\t// if 'No feedback' (it corresponds to value 3) is selected, \n\t\t// all components are unchecked\n\t\t if (feedback.getFeedbackDelivery().equals(new Integer(\"3\")))\n\t\t    {\n\t\t    \tfeedback.setShowQuestionText(false);\n\t\t\t\tfeedback.setShowStudentResponse(false);\n\t\t\t\tfeedback.setShowCorrectResponse(false);\n\t\t\t\tfeedback.setShowStudentScore(false);\n\t\t\t\tfeedback.setShowStudentQuestionScore(false);\n\t\t\t\tfeedback.setShowQuestionLevelFeedback(false);\n\t\t\t\tfeedback.setShowSelectionLevelFeedback(false);\n\t\t\t\tfeedback.setShowGraderComments(false);\n\t\t\t\tfeedback.setShowStatistics(false);\n\t\t    }\n\t\t    else {\n\t\t    \t\tfeedback.setShowQuestionText(Boolean.valueOf(assessmentSettings.getShowQuestionText()));\n\t\t    \t\tfeedback.setShowStudentResponse(Boolean.valueOf(assessmentSettings.getShowStudentResponse()));\n\t\t    \t\tfeedback.setShowCorrectResponse(Boolean.valueOf(assessmentSettings.getShowCorrectResponse()));\n\t\t    \t\tfeedback.setShowStudentScore(Boolean.valueOf(assessmentSettings.getShowStudentScore()));\n\t\t    \t\tfeedback.setShowStudentQuestionScore(Boolean.valueOf(assessmentSettings.getShowStudentQuestionScore()));\n\t\t    \t\tfeedback.setShowQuestionLevelFeedback(Boolean.valueOf(assessmentSettings.getShowQuestionLevelFeedback()));\n\t\t    \t\tfeedback.setShowSelectionLevelFeedback(Boolean.valueOf(assessmentSettings.getShowSelectionLevelFeedback()));\n\t\t    \t\tfeedback.setShowGraderComments(Boolean.valueOf(assessmentSettings.getShowGraderComments()));\n\t\t    \t\tfeedback.setShowStatistics(Boolean.valueOf(assessmentSettings.getShowStatistics()));\n\t\t    }\n\t\tassessment.setAssessmentFeedback(feedback);\n\n\t\t// set Grading\n\t\tEvaluationModelIfc evaluation = (EvaluationModelIfc) assessment.getEvaluationModel();\n\t\tif (evaluation == null){\n\t\t\tevaluation = new EvaluationModel();\n\t\t\tevaluation.setAssessmentBase(assessment.getData());\n\t\t}\n\t\tif (assessmentSettings.getAnonymousGrading()) {\n\t\t\tevaluation.setAnonymousGrading(Integer.valueOf(1));\n\t\t}\n\t\telse {\n\t\t\tevaluation.setAnonymousGrading(Integer.valueOf(2));\n\t\t}\n\t    \n\t\t// If there is value set for toDefaultGradebook, we reset it\n\t\t// Otherwise, do nothing\n\t\tif (assessmentSettings.getToDefaultGradebook()) {\n\t\t\tevaluation.setToGradeBook(\"1\");\n\t\t}\n\t\telse {\n\t\t\tevaluation.setToGradeBook(\"2\");\n\t\t}\n\n\t\tif (assessmentSettings.getScoringType() != null) {\n\t\t\tevaluation.setScoringType(new Integer(assessmentSettings.getScoringType()));\n\t\t}\n\t\tassessment.setEvaluationModel(evaluation);\n\n\t\t// update ValueMap: it contains value for thh checkboxes in\n\t\t// publishedSettings.jsp for: hasAvailableDate, hasDueDate,\n\t\t// hasRetractDate, hasAnonymous, hasAuthenticatedUser, hasIpAddress,\n\t\t// hasUsernamePassword, hasTimeAssessment,hasAutoSubmit, hasPartMetaData, \n\t\t// hasQuestionMetaData\n\t\tHashMap h = assessmentSettings.getValueMap();\n\t\th = addExtendedTimeValuesToMetaData(assessment, assessmentSettings);\n\t\tsaveAssessmentSettings.updateMetaWithValueMap(assessment, h);\n\t\t\n\t\t// i. set Graphics\n\t\tassessment.updateAssessmentMetaData(AssessmentMetaDataIfc.BGCOLOR, TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, assessmentSettings.getBgColor()));\n\t\tassessment.updateAssessmentMetaData(AssessmentMetaDataIfc.BGIMAGE, TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, assessmentSettings.getBgImage()));\n\n\t    // j. set objectives,rubrics,keywords\n\t\tassessment.updateAssessmentMetaData(AssessmentMetaDataIfc.KEYWORDS, TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, assessmentSettings.getKeywords()));\n\t    assessment.updateAssessmentMetaData(AssessmentMetaDataIfc.OBJECTIVES, TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, assessmentSettings.getObjectives()));\n\t    assessment.updateAssessmentMetaData(AssessmentMetaDataIfc.RUBRICS, TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, assessmentSettings.getRubrics()));\n\t}","commit_id":"b0838d8a0b03aec051031732de0df836bb25759d","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public boolean isAvailable(PublishedAssessmentFacade f, HashMap h, HashMap numberRetakeHash, HashMap actualNumberRetakeHash, List updatedAssessmentNeedResubmitList, List updatedAssessmentList) {\n    boolean returnValue = false;\n    //1. prepare our significant parameters\n    Integer status = f.getStatus();\n    Date currentDate = new Date();\n    Date startDate = f.getStartDate();\n    Date dueDate = f.getDueDate();\n    Date retractDate = f.getRetractDate();\n    boolean acceptLateSubmission = AssessmentAccessControlIfc.ACCEPT_LATE_SUBMISSION.equals(f.getLateHandling());\n    \n    if (!Integer.valueOf(1).equals(status)) {\n    \treturn false;\n    }\n    \n    if (startDate != null && startDate.after(currentDate)) {\n    \treturn false;\n    }\n    \n    if (retractDate != null && retractDate.before(currentDate) && acceptLateSubmission) {\n    \treturn false;\n    }\n    \n    if (updatedAssessmentNeedResubmitList.contains(f.getPublishedAssessmentId()) || updatedAssessmentList.contains(f.getPublishedAssessmentId())) {\n    \treturn true;\n    }\n    \n    int maxSubmissionsAllowed = 9999;\n    if ( (Boolean.FALSE).equals(f.getUnlimitedSubmissions())){\n      maxSubmissionsAllowed = f.getSubmissionsAllowed().intValue();\n    }\n\n    int numberRetake = 0;\n    if (numberRetakeHash.get(f.getPublishedAssessmentId()) != null) {\n    \tnumberRetake = (((StudentGradingSummaryData) numberRetakeHash.get(f.getPublishedAssessmentId())).getNumberRetake()).intValue();\n    }\n    int totalSubmitted = 0;\n    \n    //boolean notSubmitted = false;\n    if (h.get(f.getPublishedAssessmentId()) != null){\n      totalSubmitted = ( (Integer) h.get(f.getPublishedAssessmentId())).\n          intValue();\n    }\n    \n      //2. time to go through all the criteria\n    // Tests if dueDate has passed\n    if (dueDate != null && dueDate.before(currentDate)) {\n    \t// DUE DATE HAS PASSED\n    \tif (acceptLateSubmission) {\n    \t\t// LATE SUBMISSION ARE HANDLED: The assessment is available in these situations:\n    \t\t//    * Is the first submission\n    \t\t//    * A retake has been granted \n    \t\t// (if late submission are handled, a previous test implies that retract date has not yet passed)\n\t\t\tif (totalSubmitted == 0) {\n\t\t\t\treturnValue = true;\n\t\t\t} else {\n\t\t\t\tint actualNumberRetake = 0;\n\t\t\t\tif (actualNumberRetakeHash.get(f.getPublishedAssessmentId()) != null) {\n\t\t\t\t\tactualNumberRetake = ((Integer) actualNumberRetakeHash.get(f.getPublishedAssessmentId())).intValue();\n\t\t\t\t}\n\t\t\t\tif (actualNumberRetake < numberRetake) {\n\t\t\t\t\treturnValue = true;\n\t\t\t\t} else {\n\t\t\t\t\treturnValue = false;\n\t\t\t\t}\n\t\t\t}\n    \t} else {\n    \t\t// LATE SUBMISSION ARE NOT HANDLED: Test retract date and retakes\n    \t\tif (retractDate == null || retractDate.after(currentDate)) {\n\t\t\t\tint actualNumberRetake = 0;\n\t\t\t\tif (actualNumberRetakeHash.get(f.getPublishedAssessmentId()) != null) {\n\t\t\t\t\tactualNumberRetake = ((Integer) actualNumberRetakeHash.get(f.getPublishedAssessmentId())).intValue();\n\t\t\t\t}\n\t\t\t\tif (actualNumberRetake < numberRetake) {\n\t\t\t\t\treturnValue = true;\n\t\t\t\t} else {\n\t\t\t\t\treturnValue = false;\n\t\t\t\t}\n    \t\t}\n    \t\telse{\n\t    \t\t// Retract date has passed: Assessment is not available    \t\t\n\t    \t\treturnValue = false;\n    \t\t}\n    \t}\n\t}\n\telse {\n\t\tif (totalSubmitted < maxSubmissionsAllowed + numberRetake) {\n\t\t\treturnValue = true;\n\t\t}\n\t}\n    \n    return returnValue;\n  }","id":60335,"modified_method":"public boolean isAvailable(PublishedAssessmentFacade f, HashMap h, HashMap numberRetakeHash, HashMap actualNumberRetakeHash, List updatedAssessmentNeedResubmitList, List updatedAssessmentList) {\n    boolean returnValue = false;\n    //1. prepare our significant parameters\n    Integer status = f.getStatus();\n    Date currentDate = new Date();\n    Date startDate = f.getStartDate();\n    Date dueDate = f.getDueDate();\n    Date retractDate = f.getRetractDate();\n    boolean acceptLateSubmission = AssessmentAccessControlIfc.ACCEPT_LATE_SUBMISSION.equals(f.getLateHandling());\n    \n    if (!Integer.valueOf(1).equals(status)) {\n    \treturn false;\n    }\n    \n    if (startDate != null && startDate.after(currentDate)) {\n    \treturn false;\n    }\n    \n    if (acceptLateSubmission\n            && (dueDate != null && dueDate.before(currentDate))\n            && (retractDate == null || retractDate.before(currentDate))) {\n    \treturn false;\n    }\n    \n    if (updatedAssessmentNeedResubmitList.contains(f.getPublishedAssessmentId()) || updatedAssessmentList.contains(f.getPublishedAssessmentId())) {\n    \treturn true;\n    }\n    \n    int maxSubmissionsAllowed = 9999;\n    if ( (Boolean.FALSE).equals(f.getUnlimitedSubmissions())){\n      maxSubmissionsAllowed = f.getSubmissionsAllowed().intValue();\n    }\n\n    int numberRetake = 0;\n    if (numberRetakeHash.get(f.getPublishedAssessmentId()) != null) {\n    \tnumberRetake = (((StudentGradingSummaryData) numberRetakeHash.get(f.getPublishedAssessmentId())).getNumberRetake()).intValue();\n    }\n    int totalSubmitted = 0;\n    \n    //boolean notSubmitted = false;\n    if (h.get(f.getPublishedAssessmentId()) != null){\n      totalSubmitted = ( (Integer) h.get(f.getPublishedAssessmentId())).\n          intValue();\n    }\n    \n      //2. time to go through all the criteria\n    // Tests if dueDate has passed\n    if (dueDate != null && dueDate.before(currentDate)) {\n    \t// DUE DATE HAS PASSED\n    \tif (acceptLateSubmission) {\n    \t\t// LATE SUBMISSION ARE HANDLED: The assessment is available in these situations:\n    \t\t//    * Is the first submission\n    \t\t//    * A retake has been granted \n    \t\t// (if late submission are handled, a previous test implies that retract date has not yet passed)\n\t\t\tif (totalSubmitted == 0) {\n\t\t\t\treturnValue = true;\n\t\t\t} else {\n\t\t\t\tint actualNumberRetake = 0;\n\t\t\t\tif (actualNumberRetakeHash.get(f.getPublishedAssessmentId()) != null) {\n\t\t\t\t\tactualNumberRetake = ((Integer) actualNumberRetakeHash.get(f.getPublishedAssessmentId())).intValue();\n\t\t\t\t}\n\t\t\t\tif (actualNumberRetake < numberRetake) {\n\t\t\t\t\treturnValue = true;\n\t\t\t\t} else {\n\t\t\t\t\treturnValue = false;\n\t\t\t\t}\n\t\t\t}\n    \t} else {\n    \t\t// LATE SUBMISSION ARE NOT HANDLED: Test retract date and retakes\n    \t\tif (retractDate == null || retractDate.after(currentDate)) {\n\t\t\t\tint actualNumberRetake = 0;\n\t\t\t\tif (actualNumberRetakeHash.get(f.getPublishedAssessmentId()) != null) {\n\t\t\t\t\tactualNumberRetake = ((Integer) actualNumberRetakeHash.get(f.getPublishedAssessmentId())).intValue();\n\t\t\t\t}\n\t\t\t\tif (actualNumberRetake < numberRetake) {\n\t\t\t\t\treturnValue = true;\n\t\t\t\t} else {\n\t\t\t\t\treturnValue = false;\n\t\t\t\t}\n    \t\t}\n    \t\telse{\n\t    \t\t// Retract date has passed: Assessment is not available    \t\t\n\t    \t\treturnValue = false;\n    \t\t}\n    \t}\n\t}\n\telse {\n\t\tif (totalSubmitted < maxSubmissionsAllowed + numberRetake) {\n\t\t\treturnValue = true;\n\t\t}\n\t}\n    \n    return returnValue;\n  }","commit_id":"b0838d8a0b03aec051031732de0df836bb25759d","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void processAction(ActionEvent ae) throws AbortProcessingException {\r\n\t\tAuthorBean author = (AuthorBean) ContextUtil.lookupBean(\"author\");\r\n\t\tauthor.setIsEditPendingAssessmentFlow(false);\r\n\t\tString publishedAssessmentId = ContextUtil.lookupParam(\"publishedAssessmentId\");\r\n\t\tAssessmentBean assessmentBean = (AssessmentBean) ContextUtil.lookupBean(\r\n        \t\"assessmentBean\");\r\n\t\tassessmentBean.setAssessmentId(publishedAssessmentId);\r\n\t}","id":60336,"modified_method":"public void processAction(ActionEvent ae) throws AbortProcessingException {\r\n\t\tAuthorBean author = (AuthorBean) ContextUtil.lookupBean(\"author\");\r\n\t\tauthor.setIsEditPendingAssessmentFlow(false);\r\n\t\tString publishedAssessmentId = ContextUtil.lookupParam(\"publishedAssessmentId\");\r\n\t\tAssessmentBean assessmentBean = (AssessmentBean) ContextUtil.lookupBean(\r\n        \t\"assessmentBean\");\r\n\t\tassessmentBean.setAssessmentId(publishedAssessmentId);\r\n\t\tEventTrackingService.post(EventTrackingService.newEvent(\"sam.pubassessment.confirm_edit\", \"publishedAssessmentId=\" + publishedAssessmentId, true));\r\n\t}","commit_id":"c48ad2981aa9c2fb864ac30622aa2abab3efb799","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void processAction(ActionEvent ae) throws AbortProcessingException {\r\n\t\tAuthorBean author = (AuthorBean) ContextUtil.lookupBean(\"author\");\r\n\t\tPublishedAssessmentService assessmentService = new PublishedAssessmentService();\r\n\t\tSavePublishedSettingsListener savePublishedSettingsListener = new SavePublishedSettingsListener();\r\n\t\tPublishedAssessmentSettingsBean assessmentSettings = (PublishedAssessmentSettingsBean) ContextUtil.lookupBean(\"publishedSettings\");\r\n\t\tLong assessmentId = assessmentSettings.getAssessmentId();\r\n\t\tPublishedAssessmentFacade assessment = assessmentService.getPublishedAssessment(assessmentId.toString());\r\n\t\tPublishedAccessControl control = (PublishedAccessControl)assessment.getAssessmentAccessControl();\r\n\t\tif (control == null){\r\n\t\t\tcontrol = new PublishedAccessControl();\r\n\t\t    // need to fix accessControl so it can take AssessmentFacade\r\n\t\t\t// later\r\n\t\t    control.setAssessmentBase(assessment.getData());\r\n\t\t}\r\n\t    \r\n\t\tFacesContext context = FacesContext.getCurrentInstance();\r\n\t\tboolean error = savePublishedSettingsListener.setPublishedSettings(assessmentSettings, context, control, assessment);\r\n\t\tif (error){\r\n\t\t   \tassessmentSettings.setOutcome(\"editPublishedAssessmentSettings\");\r\n\t\t   \treturn;\r\n\t\t}\r\n\r\n\t\tboolean gbError = savePublishedSettingsListener.checkScore(assessmentSettings, assessment, context);\r\n\t\tif (gbError){\r\n\t\t   \tassessmentSettings.setOutcome(\"editPublishedAssessmentSettings\");\r\n\t\t   \treturn;\r\n\t\t}\r\n\r\n\t\tsavePublishedSettingsListener.updateGB(assessmentSettings, assessment);\r\n\r\n\t\tassessmentService.saveAssessment(assessment);\r\n\t\t\r\n\t\t//These outcome are set for Cancel button in publishAssessment.jsp\r\n\t\tString actionCommand = ae.getComponent().getId();\r\n\t\tif (\"republishRegrade\".equals(actionCommand)) {\r\n\t\t\tlog.debug(\"republishRegrade\");\r\n\t\t\tauthor.setOutcome(\"editAssessment\");\r\n\t\t}\r\n\t\telse if (\"republish\".equals(actionCommand)) {\r\n\t\t\tlog.debug(\"republish\");\r\n\t\t\tauthor.setOutcome(\"editAssessment\");\r\n\t\t}\r\n\t\telse if (\"publish\".equals(actionCommand)) {\r\n\t\t\tlog.debug(\"publish\");\r\n\t\t\tauthor.setOutcome(\"editPublishedAssessmentSettings\");\r\n\t\t}\r\n\t\t\r\n\t\tPublishedAssessmentSettingsBean publishedAssessmentSettings = (PublishedAssessmentSettingsBean) ContextUtil\r\n\t\t\t.lookupBean(\"publishedSettings\");\r\n\t\tLong publishedAssessmentId = publishedAssessmentSettings.getAssessmentId();\r\n\t\tGradingService gradingService = new GradingService();\r\n\r\n\t\tArrayList al = gradingService.getHasGradingDataAndHasSubmission(publishedAssessmentId);\r\n\t\tAssessmentBean assessmentBean = (AssessmentBean) ContextUtil.lookupBean(\"assessmentBean\");\r\n\r\n\t\tif (al.size() == 2) {\r\n\t\t\tassessmentBean.setHasGradingData(((Boolean)al.get(0)).booleanValue());\r\n\t\t\tassessmentBean.setHasSubmission(((Boolean)al.get(1)).booleanValue());\t\t\t\t\r\n\t\t}\r\n\t\telse {\r\n\t\t\tassessmentBean.setHasGradingData(false);\r\n\t\t\tassessmentBean.setHasSubmission(false);\r\n\t\t}\r\n\t\tpublishedAssessmentSettings.setUpdateMostCurrentSubmission(false);\r\n\t}","id":60337,"modified_method":"public void processAction(ActionEvent ae) throws AbortProcessingException {\r\n\t\tAuthorBean author = (AuthorBean) ContextUtil.lookupBean(\"author\");\r\n\t\tPublishedAssessmentService assessmentService = new PublishedAssessmentService();\r\n\t\tSavePublishedSettingsListener savePublishedSettingsListener = new SavePublishedSettingsListener();\r\n\t\tPublishedAssessmentSettingsBean assessmentSettings = (PublishedAssessmentSettingsBean) ContextUtil.lookupBean(\"publishedSettings\");\r\n\t\tLong assessmentId = assessmentSettings.getAssessmentId();\r\n\t\tPublishedAssessmentFacade assessment = assessmentService.getPublishedAssessment(assessmentId.toString());\r\n\t\tPublishedAccessControl control = (PublishedAccessControl)assessment.getAssessmentAccessControl();\r\n\t\tif (control == null){\r\n\t\t\tcontrol = new PublishedAccessControl();\r\n\t\t    // need to fix accessControl so it can take AssessmentFacade\r\n\t\t\t// later\r\n\t\t    control.setAssessmentBase(assessment.getData());\r\n\t\t}\r\n\t    \r\n\t\tEventTrackingService.post(EventTrackingService.newEvent(\"sam.pubsetting.edit\", \"publishedAssessmentId=\" + assessmentId, true));\r\n\t\tFacesContext context = FacesContext.getCurrentInstance();\r\n\t\tboolean error = savePublishedSettingsListener.setPublishedSettings(assessmentSettings, context, control, assessment, false);\r\n\t\tif (error){\r\n\t\t   \tassessmentSettings.setOutcome(\"editPublishedAssessmentSettings\");\r\n\t\t   \treturn;\r\n\t\t}\r\n\r\n\t\tboolean gbError = savePublishedSettingsListener.checkScore(assessmentSettings, assessment, context);\r\n\t\tif (gbError){\r\n\t\t   \tassessmentSettings.setOutcome(\"editPublishedAssessmentSettings\");\r\n\t\t   \treturn;\r\n\t\t}\r\n\r\n\t\tsavePublishedSettingsListener.updateGB(assessmentSettings, assessment);\r\n\r\n\t\tassessmentService.saveAssessment(assessment);\r\n\t\t\r\n\t\t//These outcome are set for Cancel button in publishAssessment.jsp\r\n\t\tString actionCommand = ae.getComponent().getId();\r\n\t\tif (\"republishRegrade\".equals(actionCommand)) {\r\n\t\t\tlog.debug(\"republishRegrade\");\r\n\t\t\tauthor.setOutcome(\"editAssessment\");\r\n\t\t}\r\n\t\telse if (\"republish\".equals(actionCommand)) {\r\n\t\t\tlog.debug(\"republish\");\r\n\t\t\tauthor.setOutcome(\"editAssessment\");\r\n\t\t}\r\n\t\telse if (\"publish\".equals(actionCommand)) {\r\n\t\t\tlog.debug(\"publish\");\r\n\t\t\tauthor.setOutcome(\"editPublishedAssessmentSettings\");\r\n\t\t}\r\n\t\t\r\n\t\tPublishedAssessmentSettingsBean publishedAssessmentSettings = (PublishedAssessmentSettingsBean) ContextUtil\r\n\t\t\t.lookupBean(\"publishedSettings\");\r\n\t\tLong publishedAssessmentId = publishedAssessmentSettings.getAssessmentId();\r\n\t\tGradingService gradingService = new GradingService();\r\n\r\n\t\tArrayList al = gradingService.getHasGradingDataAndHasSubmission(publishedAssessmentId);\r\n\t\tAssessmentBean assessmentBean = (AssessmentBean) ContextUtil.lookupBean(\"assessmentBean\");\r\n\r\n\t\tif (al.size() == 2) {\r\n\t\t\tassessmentBean.setHasGradingData(((Boolean)al.get(0)).booleanValue());\r\n\t\t\tassessmentBean.setHasSubmission(((Boolean)al.get(1)).booleanValue());\t\t\t\t\r\n\t\t}\r\n\t\telse {\r\n\t\t\tassessmentBean.setHasGradingData(false);\r\n\t\t\tassessmentBean.setHasSubmission(false);\r\n\t\t}\r\n\t\tpublishedAssessmentSettings.setUpdateMostCurrentSubmission(false);\r\n\t}","commit_id":"c48ad2981aa9c2fb864ac30622aa2abab3efb799","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n   * Standard process action method.\n   * @param ae ActionEvent\n   * @throws AbortProcessingException\n   */\n  public void processAction(ActionEvent ae) throws AbortProcessingException {\n\n    //boolean correct=false;\n\n    log.debug(\"ItemAdd LISTENER.\");\n\n    ItemAuthorBean itemauthorbean = (ItemAuthorBean) ContextUtil.lookupBean(\"itemauthor\");\n    ItemBean item = itemauthorbean.getCurrentItem();\n    String iText = ContextUtil.stringWYSIWYG(item.getItemText());\n    String iInstruction = ContextUtil.stringWYSIWYG(item.getInstruction());\n    String iType = item.getItemType();\n    String err=\"\";\n    FacesContext context=FacesContext.getCurrentInstance();\n   \n    // SAK-6050\n    // if((!iType.equals(TypeFacade.MATCHING.toString())&&((iText==null)||(iText.replaceAll(\"<.*?>\", \"\").trim().equals(\"\"))))|| (iType.equals(TypeFacade.MATCHING.toString()) && ((iInstruction==null)||(iInstruction.replaceAll(\"<.*?>\", \"\").trim().equals(\"\"))))){\n    if((!iType.equals(TypeFacade.MATCHING.toString())&&((iText==null)||(iText.toLowerCase().replaceAll(\"<^[^(img)]*?>\", \"\").trim().equals(\"\"))))|| (iType.equals(TypeFacade.MATCHING.toString()) && ((iInstruction==null)||(iInstruction.toLowerCase().replaceAll(\"<^[^(img)]*?>\", \"\").trim().equals(\"\"))))){ \n\t\n \n\tString emptyText_err = ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AuthorMessages\",\"emptyText_error\");     \n\tcontext.addMessage(null,new FacesMessage(emptyText_err));\n\treturn;\n\n    }   \n   \n    if(iType.equals(TypeFacade.MULTIPLE_CHOICE.toString()))\n\tcheckMC(true);\n\n    if(iType.equals(TypeFacade.MULTIPLE_CORRECT.toString()))\n\tcheckMC(false);\n    if(iType.equals(TypeFacade.MATCHING.toString()))\n        {   \n            ArrayList l=item.getMatchItemBeanList();\n\t    if (l==null || l.size()==0){\n\t\tString noPairMatching_err=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AuthorMessages\",\"noMatchingPair_error\");\n\t\tcontext.addMessage(null,new FacesMessage(noPairMatching_err));\n\t\terror=true;\n\t    }\n\t}\n    if(error)\n\treturn;\n    \n    if(iType.equals(TypeFacade.MULTIPLE_CHOICE_SURVEY.toString()))\n    {   \n      String scaleName = item.getScaleName();\n      if (scaleName == null){\n\t    err = ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AuthorMessages\",\"corrAnswer\");\n\t    context.addMessage(null,new FacesMessage(err));\n\t    item.setOutcome(\"surveyItem\");\n\t\titem.setPoolOutcome(\"surveyItem\");\n\t    return;\n      }\n    }\n    \n    if(iType.equals(TypeFacade.TRUE_FALSE.toString()))\n    {   \n      String corrAnswer = item.getCorrAnswer();\n      if (corrAnswer == null){\n\t    err = ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AuthorMessages\",\"corrAnswer\");\n\t    context.addMessage(null,new FacesMessage(err));\n\t    item.setOutcome(\"trueFalseItem\");\n\t\titem.setPoolOutcome(\"trueFalseItem\");\n\t    return;\n      }\n    }\n    \n    if(iType.equals(TypeFacade.FILL_IN_BLANK.toString())){\n\t\n    \tif(isErrorFIB()){\n    \t\terr=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AuthorMessages\",\"pool_missingBracket_error\");\n    \t\tcontext.addMessage(null,new FacesMessage(err));\n    \t\titem.setOutcome(\"fillInBlackItem\");\n    \t\titem.setPoolOutcome(\"fillInBlackItem\");\n    \t\treturn;\n    \t}\n    }\n    \n    if(iType.equals(TypeFacade.FILL_IN_NUMERIC.toString())){\n    \t\n    \tif(isErrorFIN()){\n    \t    err=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AuthorMessages\",\"pool_missingBracket_error\");\n    \t    context.addMessage(null,new FacesMessage(err));\n    \t    item.setOutcome(\"fillInNumericItem\");\n    \t    item.setPoolOutcome(\"fillInNumericItem\");\n    \t    return;\n\n    \t}\n    }\n    \n    if(iType.equals(TypeFacade.AUDIO_RECORDING.toString())){\n    \ttry {\n\t   \t\tString timeAllowed = item.getTimeAllowed().trim();\n\t   \t\tint intTimeAllowed = Integer.parseInt(timeAllowed);\n\t   \t\tif (intTimeAllowed < 1) {\n\t   \t\t\tthrow new RuntimeException();\n\t   \t\t}\n    \t}\n\t\tcatch (RuntimeException e){\n\t\t\terr=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AuthorMessages\",\"submissions_allowed_error\");\n    \t    context.addMessage(null,new FacesMessage(err));\n    \t    item.setOutcome(\"audioRecItem\");\n    \t    item.setPoolOutcome(\"audioRecItem\");\n    \t    return;\n\t\t}    \t\n    }\n\t\n    if (!saveItem(itemauthorbean)){\n\tthrow new RuntimeException(\"failed to saveItem.\");\n    }\n    EventTrackingService.post(EventTrackingService.newEvent(\"sam.assessment.revise\", \"itemId=\" + itemauthorbean.getItemId(), true));\n    item.setOutcome(\"editAssessment\");\n    item.setPoolOutcome(\"editPool\");\n    itemauthorbean.setItemTypeString(\"\");\n  }","id":60338,"modified_method":"/**\n   * Standard process action method.\n   * @param ae ActionEvent\n   * @throws AbortProcessingException\n   */\n  public void processAction(ActionEvent ae) throws AbortProcessingException {\n\n    //boolean correct=false;\n\n    log.debug(\"ItemAdd LISTENER.\");\n\n    ItemAuthorBean itemauthorbean = (ItemAuthorBean) ContextUtil.lookupBean(\"itemauthor\");\n    ItemBean item = itemauthorbean.getCurrentItem();\n    String iText = ContextUtil.stringWYSIWYG(item.getItemText());\n    String iInstruction = ContextUtil.stringWYSIWYG(item.getInstruction());\n    String iType = item.getItemType();\n    String err=\"\";\n    FacesContext context=FacesContext.getCurrentInstance();\n   \n    // SAK-6050\n    // if((!iType.equals(TypeFacade.MATCHING.toString())&&((iText==null)||(iText.replaceAll(\"<.*?>\", \"\").trim().equals(\"\"))))|| (iType.equals(TypeFacade.MATCHING.toString()) && ((iInstruction==null)||(iInstruction.replaceAll(\"<.*?>\", \"\").trim().equals(\"\"))))){\n    if((!iType.equals(TypeFacade.MATCHING.toString())&&((iText==null)||(iText.toLowerCase().replaceAll(\"<^[^(img)]*?>\", \"\").trim().equals(\"\"))))|| (iType.equals(TypeFacade.MATCHING.toString()) && ((iInstruction==null)||(iInstruction.toLowerCase().replaceAll(\"<^[^(img)]*?>\", \"\").trim().equals(\"\"))))){ \n\t\n \n\tString emptyText_err = ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AuthorMessages\",\"emptyText_error\");     \n\tcontext.addMessage(null,new FacesMessage(emptyText_err));\n\treturn;\n\n    }   \n   \n    if(iType.equals(TypeFacade.MULTIPLE_CHOICE.toString()))\n\tcheckMC(true);\n\n    if(iType.equals(TypeFacade.MULTIPLE_CORRECT.toString()))\n\tcheckMC(false);\n    if(iType.equals(TypeFacade.MATCHING.toString()))\n        {   \n            ArrayList l=item.getMatchItemBeanList();\n\t    if (l==null || l.size()==0){\n\t\tString noPairMatching_err=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AuthorMessages\",\"noMatchingPair_error\");\n\t\tcontext.addMessage(null,new FacesMessage(noPairMatching_err));\n\t\terror=true;\n\t    }\n\t}\n    if(error)\n\treturn;\n    \n    if(iType.equals(TypeFacade.MULTIPLE_CHOICE_SURVEY.toString()))\n    {   \n      String scaleName = item.getScaleName();\n      if (scaleName == null){\n\t    err = ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AuthorMessages\",\"corrAnswer\");\n\t    context.addMessage(null,new FacesMessage(err));\n\t    item.setOutcome(\"surveyItem\");\n\t\titem.setPoolOutcome(\"surveyItem\");\n\t    return;\n      }\n    }\n    \n    if(iType.equals(TypeFacade.TRUE_FALSE.toString()))\n    {   \n      String corrAnswer = item.getCorrAnswer();\n      if (corrAnswer == null){\n\t    err = ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AuthorMessages\",\"corrAnswer\");\n\t    context.addMessage(null,new FacesMessage(err));\n\t    item.setOutcome(\"trueFalseItem\");\n\t\titem.setPoolOutcome(\"trueFalseItem\");\n\t    return;\n      }\n    }\n    \n    if(iType.equals(TypeFacade.FILL_IN_BLANK.toString())){\n\t\n    \tif(isErrorFIB()){\n    \t\terr=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AuthorMessages\",\"pool_missingBracket_error\");\n    \t\tcontext.addMessage(null,new FacesMessage(err));\n    \t\titem.setOutcome(\"fillInBlackItem\");\n    \t\titem.setPoolOutcome(\"fillInBlackItem\");\n    \t\treturn;\n    \t}\n    }\n    \n    if(iType.equals(TypeFacade.FILL_IN_NUMERIC.toString())){\n    \t\n    \tif(isErrorFIN()){\n    \t    err=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AuthorMessages\",\"pool_missingBracket_error\");\n    \t    context.addMessage(null,new FacesMessage(err));\n    \t    item.setOutcome(\"fillInNumericItem\");\n    \t    item.setPoolOutcome(\"fillInNumericItem\");\n    \t    return;\n\n    \t}\n    }\n    \n    if(iType.equals(TypeFacade.AUDIO_RECORDING.toString())){\n    \ttry {\n\t   \t\tString timeAllowed = item.getTimeAllowed().trim();\n\t   \t\tint intTimeAllowed = Integer.parseInt(timeAllowed);\n\t   \t\tif (intTimeAllowed < 1) {\n\t   \t\t\tthrow new RuntimeException();\n\t   \t\t}\n    \t}\n\t\tcatch (RuntimeException e){\n\t\t\terr=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AuthorMessages\",\"submissions_allowed_error\");\n    \t    context.addMessage(null,new FacesMessage(err));\n    \t    item.setOutcome(\"audioRecItem\");\n    \t    item.setPoolOutcome(\"audioRecItem\");\n    \t    return;\n\t\t}    \t\n    }\n\t\n    if (!saveItem(itemauthorbean)){\n\tthrow new RuntimeException(\"failed to saveItem.\");\n    }\n    item.setOutcome(\"editAssessment\");\n    item.setPoolOutcome(\"editPool\");\n    itemauthorbean.setItemTypeString(\"\");\n  }","commit_id":"c48ad2981aa9c2fb864ac30622aa2abab3efb799","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public boolean saveItem(ItemAuthorBean itemauthor) {\n    boolean update = false;\n    try {\n      ItemBean bean = itemauthor.getCurrentItem();\n      ItemFacade item;\n      AuthorBean author = (AuthorBean) ContextUtil.lookupBean(\"author\");\n      isEditPendingAssessmentFlow = author.getIsEditPendingAssessmentFlow();\n      log.debug(\"**** isEditPendingAssessmentFlow : \" + isEditPendingAssessmentFlow);\n      String target = itemauthor.getTarget();\n      boolean isFromQuestionPool = false;\n      if (target != null && target.equals(ItemAuthorBean.FROM_QUESTIONPOOL)) {\n    \t  isFromQuestionPool = true;\n      }\n      log.debug(\"**** isFromQuestionPool : \" + isFromQuestionPool);\n      isPendingOrPool = isEditPendingAssessmentFlow || isFromQuestionPool;\n      ItemService delegate;\n      if (isPendingOrPool) {\n      \t  delegate = new ItemService();\n      }\n      else {\n      \t  delegate = new PublishedItemService();\n      }\n      // update not working yet, delete, then add\n      if ( (bean.getItemId() != null) && (!bean.getItemId().equals(\"0\"))) {\n        update = true;\n        // if modify ,itemid shouldn't be null , or 0.\n        Long oldId = new Long(bean.getItemId());\n        if (isPendingOrPool) {\n        \tdelegate.deleteItemContent(oldId, AgentFacade.getAgentString());\n        }\n    \titem = delegate.getItem(oldId,AgentFacade.getAgentString());\n      }\n      else{\n     \tif (isPendingOrPool) {\n     \t\titem = new ItemFacade();\n     \t}\n     \telse {\n     \t\titem = new PublishedItemFacade();\n     \t}\n      }\n      item.setScore(new Float(bean.getItemScore()));\n      item.setHint(\"\");\n\n      item.setStatus(ItemDataIfc.ACTIVE_STATUS);\n\n      item.setTypeId(new Long(bean.getItemType()));\n\n      item.setCreatedBy(AgentFacade.getAgentString());\n      item.setCreatedDate(new Date());\n      item.setLastModifiedBy(AgentFacade.getAgentString());\n      item.setLastModifiedDate(new Date());\n\n      if (bean.getInstruction() != null) {\n        // for matching\n        item.setInstruction(bean.getInstruction());\n      }\n      // update hasRationale\n      if (bean.getRationale() != null) {\n        item.setHasRationale(Boolean.valueOf(bean.getRationale()));\n      }\n      else {\n        item.setHasRationale(Boolean.FALSE);\n      }\n\n      // update maxNumAttempts for audio\n      if (bean.getNumAttempts() != null) {\n        item.setTriesAllowed(new Integer(bean.getNumAttempts()));\n      }\n\n      // save timeallowed for audio recording\n      if (bean.getTimeAllowed() != null) {\n        item.setDuration(new Integer(bean.getTimeAllowed()));\n      }\n\n      if (update && !isPendingOrPool) {\n    \t  //prepare itemText, including answers\n            item.setItemTextSet(preparePublishedText(item, bean, delegate));\n         \n          // prepare MetaData\n          item.setItemMetaDataSet(preparePublishedMetaData(item, bean));\n\n          // prepare feedback, because this is UPDATE\n          // if it's an empty string, we need to update feedback to an empty string\n          // not like below (below we don't ADD if the feedback is null or empty string)\n          if ((bean.getCorrFeedback() != null)) {\n            \t\tupdateItemFeedback(item, ItemFeedbackIfc.CORRECT_FEEDBACK, stripPtags(bean.getCorrFeedback()));\n              }\n              if ((bean.getIncorrFeedback() != null)) {\n                \tupdateItemFeedback(item, ItemFeedbackIfc.INCORRECT_FEEDBACK, stripPtags(bean.getIncorrFeedback()));\n              }\n              if ((bean.getGeneralFeedback() != null)) {\n                \tupdateItemFeedback(item, ItemFeedbackIfc.GENERAL_FEEDBACK, stripPtags(bean.getGeneralFeedback()));\n              }\n      }\n      else {\n        \t//prepare itemText, including answers\n            if (!item.getTypeId().equals(TypeFacade.MATCHING)) {\n              item.setItemTextSet(prepareText(item, bean, itemauthor));\n            }\n            else {\n              item.setItemTextSet(prepareTextForMatching(item, bean, itemauthor));\n            }\n            // prepare MetaData\n            item.setItemMetaDataSet(prepareMetaData(item, bean));\n\n            // prepare feedback, only store if feedbacks are not empty\n            if ( (bean.getCorrFeedback() != null) &&\n      \t\t\t  (!bean.getCorrFeedback().equals(\"\"))) {\n            \titem.setCorrectItemFeedback(stripPtags(bean.getCorrFeedback()));\n      \t  \t}\n      \t  \tif ( (bean.getIncorrFeedback() != null) &&\n      \t\t\t  (!bean.getIncorrFeedback().equals(\"\"))) {\n      \t  \t\titem.setInCorrectItemFeedback(stripPtags(bean.getIncorrFeedback()));\n      \t  \t}\n      \t  \tif ( (bean.getGeneralFeedback() != null) &&\n      \t\t\t  (!bean.getGeneralFeedback().equals(\"\"))) {\n      \t  \t\titem.setGeneralItemFeedback(stripPtags(bean.getGeneralFeedback()));\n      \t  \t}\n      }\n\n      if (isFromQuestionPool) {\n        // Came from Pool manager\n\n        delegate.saveItem(item);\n\n       // added by daisyf, 10/10/06\n       updateAttachment(item.getItemAttachmentList(), itemauthor.getAttachmentList(),\n                        (ItemDataIfc)item.getData(), true);\n       item = delegate.getItem(item.getItemId().toString());\n\n\n        QuestionPoolService qpdelegate = new QuestionPoolService();\n\n        if (!qpdelegate.hasItem(item.getItemIdString(),\n                                new Long(itemauthor.getQpoolId()))) {\n          qpdelegate.addItemToPool(item.getItemIdString(),\n                                   new Long(itemauthor.getQpoolId()));\n\n        }\n\n        QuestionPoolBean qpoolbean = (QuestionPoolBean) ContextUtil.lookupBean(\"questionpool\");\n        QuestionPoolDataBean contextCurrentPool = qpoolbean.getCurrentPool();\n       \n        qpoolbean.buildTree();\n\n        /*\n            // Reset question pool bean\n            QuestionPoolFacade thepool= qpdelegate.getPool(new Long(itemauthor.getQpoolId()), AgentFacade.getAgentString());\n            qpoolbean.getCurrentPool().setNumberOfQuestions(thepool.getQuestionSize().toString());\n         */\n        qpoolbean.startEditPoolAgain(itemauthor.getQpoolId());\n        QuestionPoolDataBean currentPool = qpoolbean.getCurrentPool();\n        currentPool.setDisplayName(contextCurrentPool.getDisplayName());\n        currentPool.setOrganizationName(contextCurrentPool.getOrganizationName());\n        currentPool.setDescription(contextCurrentPool.getDescription());\n        currentPool.setObjectives(contextCurrentPool.getObjectives());\n        currentPool.setKeywords(contextCurrentPool.getKeywords());\n        \n        ArrayList addedQuestions = qpoolbean.getAddedQuestions();\n        if (addedQuestions == null) {\n        \taddedQuestions = new ArrayList();\n        }\n        addedQuestions.add(item.getItemId());\n        qpoolbean.setAddedPools(addedQuestions);\n        // return to edit pool\n        itemauthor.setOutcome(\"editPool\");\n      }\n      // Came from Questionbank Authoring\n      else if (itemauthor.getTarget() != null && (itemauthor.getTarget().equals(\"sambank\"))) {\n\t\tdelegate.saveItem(item);\n\t\titemauthor.setItemNo(item.getItemId().toString());\n      }\n      else {\n        // Came from Assessment Authoring\n\n        AssessmentService assessdelegate;\n        if (isEditPendingAssessmentFlow) {\n        \tassessdelegate = new AssessmentService();\n        }\n        else {\n        \tassessdelegate = new PublishedAssessmentService();\n        }\n        // add the item to the specified part, otherwise add to default\n        if (bean.getSelectedSection() != null) {\n// need to do  add a temp part first if assigned to a temp part SAK-2109\n \n          SectionFacade section;\n\n\t  if (\"-1\".equals(bean.getSelectedSection())) {\n\t    AssessmentBean assessmentBean = (AssessmentBean) ContextUtil.lookupBean(\"assessmentBean\");\n// add a new section\n      \t    section = assessdelegate.addSection(assessmentBean.getAssessmentId());\n          }\n\n\t  else {\n            section = assessdelegate.getSection(bean.getSelectedSection());\n          }\n          item.setSection(section);\n\n          if (update) {\n\t  // if Modify, need to reorder if assgned to different section '\n            if ( (bean.getOrigSection() != null) &&\n\t\t(!bean.getOrigSection().equals(bean.getSelectedSection()))) {\n                // if reassigned to different section\n              Integer oldSeq = item.getSequence();\n              item.setSequence(new Integer(section.getItemSet().size() + 1));\n\n              // reorder the sequences of items in the OrigSection\n    \t      SectionFacade origsect= assessdelegate.getSection(bean.getOrigSection());\n\t      shiftItemsInOrigSection(delegate, origsect, oldSeq);\n\n\n            }\n            else {\n              // no action needed\n            }\n          }\n\n          if (!update) {\n            if ( (itemauthor.getInsertPosition() == null) ||\n                (\"\".equals(itemauthor.getInsertPosition()))\n                || !section.getSequence().equals(itemauthor.getInsertToSection())) {\n              // if adding to the end\n              if (section.getItemSet() != null) {\n            \t  item.setSequence(new Integer(section.getItemSet().size() + 1));\n              }\n              else {\n\t \t// this is a new part, not saved yet \n\t\titem.setSequence(new Integer(1));\n              }\n            }\n            else {\n              // if inserting or a question\n              String insertPos = itemauthor.getInsertPosition();\n              shiftSequences(delegate, section, new Integer(insertPos));\n              int insertPosInt = (new Integer(insertPos)).intValue() + 1;\n              item.setSequence(new Integer(insertPosInt));\n              // reset InsertPosition\n              itemauthor.setInsertPosition(\"\");\n            }\n          }\n          if (itemauthor.getInsertToSection() != null) {\n    \t\t  // reset insertToSection to null;\n    \t\t  itemauthor.setInsertToSection(null);\n    \t  }\n          \n          delegate.saveItem(item);\n\n          // added by daisyf, 10/10/06\n          updateAttachment(item.getItemAttachmentList(), itemauthor.getAttachmentList(),\n                           (ItemDataIfc)item.getData(), isEditPendingAssessmentFlow);\n          item = delegate.getItem(item.getItemId().toString());\n\n        }\n\n        QuestionPoolService qpdelegate = new QuestionPoolService();\n\t// removed the old pool-item mappings\n          if ( (bean.getOrigPool() != null) && (!bean.getOrigPool().equals(\"\"))) {\n            qpdelegate.removeQuestionFromPool(item.getItemIdString(),\n                                              new Long(bean.getOrigPool()));\n          }\n\n        // if assign to pool, add the item to the pool\n        if ( (bean.getSelectedPool() != null) && !bean.getSelectedPool().equals(\"\")) {\n        \t// if the item is already in the pool then do not add.\n          // This is a scenario where the item might already be in the pool:\n          // create an item in an assessemnt and assign it to p1\n          // copy item from p1 to p2. \n          // now the item is already in p2. and if you want to edit the original item in the assessment, and reassign it to p2, you will get a duplicate error. \n\n          if (!qpdelegate.hasItem(item.getItemIdString(),\n                                new Long(bean.getSelectedPool()))) {\n            qpdelegate.addItemToPool(item.getItemIdString(),\n                                   new Long(bean.getSelectedPool()));\n          }\n        }\n\n        // #1a - goto editAssessment.jsp, so reset assessmentBean\n        AssessmentBean assessmentBean = (AssessmentBean) ContextUtil.lookupBean(\n            \"assessmentBean\");\n        AssessmentIfc assessment = assessdelegate.getAssessment(\n            Long.valueOf(assessmentBean.getAssessmentId()));\n        assessmentBean.setAssessment(assessment);\n\n        itemauthor.setOutcome(\"editAssessment\");\n\n      }\n      // sorry, i need this for item attachment, used by SaveItemAttachmentListener. \n      itemauthor.setItemId(item.getItemId().toString());\n      return true;\n    }\n    catch (RuntimeException e) {\n      e.printStackTrace();\n      return false;\n    }\n  }","id":60339,"modified_method":"public boolean saveItem(ItemAuthorBean itemauthor) {\n    boolean update = false;\n    try {\n      ItemBean bean = itemauthor.getCurrentItem();\n      ItemFacade item;\n      AuthorBean author = (AuthorBean) ContextUtil.lookupBean(\"author\");\n      isEditPendingAssessmentFlow = author.getIsEditPendingAssessmentFlow();\n      log.debug(\"**** isEditPendingAssessmentFlow : \" + isEditPendingAssessmentFlow);\n      String target = itemauthor.getTarget();\n      boolean isFromQuestionPool = false;\n      if (target != null && target.equals(ItemAuthorBean.FROM_QUESTIONPOOL)) {\n    \t  isFromQuestionPool = true;\n      }\n      log.debug(\"**** isFromQuestionPool : \" + isFromQuestionPool);\n      isPendingOrPool = isEditPendingAssessmentFlow || isFromQuestionPool;\n      ItemService delegate;\n      if (isPendingOrPool) {\n    \t  EventTrackingService.post(EventTrackingService.newEvent(\"sam.assessment.revise\", \"itemId=\" + itemauthor.getItemId(), true));\n      \t  delegate = new ItemService();\n      }\n      else {\n    \t  EventTrackingService.post(EventTrackingService.newEvent(\"sam.pubassessment.revise\", \"itemId=\" + itemauthor.getItemId(), true));\n      \t  delegate = new PublishedItemService();\n      }\n      // update not working yet, delete, then add\n      if ( (bean.getItemId() != null) && (!bean.getItemId().equals(\"0\"))) {\n        update = true;\n        // if modify ,itemid shouldn't be null , or 0.\n        Long oldId = new Long(bean.getItemId());\n        if (isPendingOrPool) {\n        \tdelegate.deleteItemContent(oldId, AgentFacade.getAgentString());\n        }\n    \titem = delegate.getItem(oldId,AgentFacade.getAgentString());\n      }\n      else{\n     \tif (isPendingOrPool) {\n     \t\titem = new ItemFacade();\n     \t}\n     \telse {\n     \t\titem = new PublishedItemFacade();\n     \t}\n      }\n      item.setScore(new Float(bean.getItemScore()));\n      item.setHint(\"\");\n\n      item.setStatus(ItemDataIfc.ACTIVE_STATUS);\n\n      item.setTypeId(new Long(bean.getItemType()));\n\n      item.setCreatedBy(AgentFacade.getAgentString());\n      item.setCreatedDate(new Date());\n      item.setLastModifiedBy(AgentFacade.getAgentString());\n      item.setLastModifiedDate(new Date());\n\n      if (bean.getInstruction() != null) {\n        // for matching\n        item.setInstruction(bean.getInstruction());\n      }\n      // update hasRationale\n      if (bean.getRationale() != null) {\n        item.setHasRationale(Boolean.valueOf(bean.getRationale()));\n      }\n      else {\n        item.setHasRationale(Boolean.FALSE);\n      }\n\n      // update maxNumAttempts for audio\n      if (bean.getNumAttempts() != null) {\n        item.setTriesAllowed(new Integer(bean.getNumAttempts()));\n      }\n\n      // save timeallowed for audio recording\n      if (bean.getTimeAllowed() != null) {\n        item.setDuration(new Integer(bean.getTimeAllowed()));\n      }\n\n      if (update && !isPendingOrPool) {\n    \t  //prepare itemText, including answers\n            item.setItemTextSet(preparePublishedText(item, bean, delegate));\n         \n          // prepare MetaData\n          item.setItemMetaDataSet(preparePublishedMetaData(item, bean));\n\n          // prepare feedback, because this is UPDATE\n          // if it's an empty string, we need to update feedback to an empty string\n          // not like below (below we don't ADD if the feedback is null or empty string)\n          if ((bean.getCorrFeedback() != null)) {\n            \t\tupdateItemFeedback(item, ItemFeedbackIfc.CORRECT_FEEDBACK, stripPtags(bean.getCorrFeedback()));\n              }\n              if ((bean.getIncorrFeedback() != null)) {\n                \tupdateItemFeedback(item, ItemFeedbackIfc.INCORRECT_FEEDBACK, stripPtags(bean.getIncorrFeedback()));\n              }\n              if ((bean.getGeneralFeedback() != null)) {\n                \tupdateItemFeedback(item, ItemFeedbackIfc.GENERAL_FEEDBACK, stripPtags(bean.getGeneralFeedback()));\n              }\n      }\n      else {\n        \t//prepare itemText, including answers\n            if (!item.getTypeId().equals(TypeFacade.MATCHING)) {\n              item.setItemTextSet(prepareText(item, bean, itemauthor));\n            }\n            else {\n              item.setItemTextSet(prepareTextForMatching(item, bean, itemauthor));\n            }\n            // prepare MetaData\n            item.setItemMetaDataSet(prepareMetaData(item, bean));\n\n            // prepare feedback, only store if feedbacks are not empty\n            if ( (bean.getCorrFeedback() != null) &&\n      \t\t\t  (!bean.getCorrFeedback().equals(\"\"))) {\n            \titem.setCorrectItemFeedback(stripPtags(bean.getCorrFeedback()));\n      \t  \t}\n      \t  \tif ( (bean.getIncorrFeedback() != null) &&\n      \t\t\t  (!bean.getIncorrFeedback().equals(\"\"))) {\n      \t  \t\titem.setInCorrectItemFeedback(stripPtags(bean.getIncorrFeedback()));\n      \t  \t}\n      \t  \tif ( (bean.getGeneralFeedback() != null) &&\n      \t\t\t  (!bean.getGeneralFeedback().equals(\"\"))) {\n      \t  \t\titem.setGeneralItemFeedback(stripPtags(bean.getGeneralFeedback()));\n      \t  \t}\n      }\n\n      if (isFromQuestionPool) {\n        // Came from Pool manager\n\n        delegate.saveItem(item);\n\n       // added by daisyf, 10/10/06\n       updateAttachment(item.getItemAttachmentList(), itemauthor.getAttachmentList(),\n                        (ItemDataIfc)item.getData(), true);\n       item = delegate.getItem(item.getItemId().toString());\n\n\n        QuestionPoolService qpdelegate = new QuestionPoolService();\n\n        if (!qpdelegate.hasItem(item.getItemIdString(),\n                                new Long(itemauthor.getQpoolId()))) {\n          qpdelegate.addItemToPool(item.getItemIdString(),\n                                   new Long(itemauthor.getQpoolId()));\n\n        }\n\n        QuestionPoolBean qpoolbean = (QuestionPoolBean) ContextUtil.lookupBean(\"questionpool\");\n        QuestionPoolDataBean contextCurrentPool = qpoolbean.getCurrentPool();\n       \n        qpoolbean.buildTree();\n\n        /*\n            // Reset question pool bean\n            QuestionPoolFacade thepool= qpdelegate.getPool(new Long(itemauthor.getQpoolId()), AgentFacade.getAgentString());\n            qpoolbean.getCurrentPool().setNumberOfQuestions(thepool.getQuestionSize().toString());\n         */\n        qpoolbean.startEditPoolAgain(itemauthor.getQpoolId());\n        QuestionPoolDataBean currentPool = qpoolbean.getCurrentPool();\n        currentPool.setDisplayName(contextCurrentPool.getDisplayName());\n        currentPool.setOrganizationName(contextCurrentPool.getOrganizationName());\n        currentPool.setDescription(contextCurrentPool.getDescription());\n        currentPool.setObjectives(contextCurrentPool.getObjectives());\n        currentPool.setKeywords(contextCurrentPool.getKeywords());\n        \n        ArrayList addedQuestions = qpoolbean.getAddedQuestions();\n        if (addedQuestions == null) {\n        \taddedQuestions = new ArrayList();\n        }\n        addedQuestions.add(item.getItemId());\n        qpoolbean.setAddedPools(addedQuestions);\n        // return to edit pool\n        itemauthor.setOutcome(\"editPool\");\n      }\n      // Came from Questionbank Authoring\n      else if (itemauthor.getTarget() != null && (itemauthor.getTarget().equals(\"sambank\"))) {\n\t\tdelegate.saveItem(item);\n\t\titemauthor.setItemNo(item.getItemId().toString());\n      }\n      else {\n        // Came from Assessment Authoring\n\n        AssessmentService assessdelegate;\n        if (isEditPendingAssessmentFlow) {\n        \tassessdelegate = new AssessmentService();\n        }\n        else {\n        \tassessdelegate = new PublishedAssessmentService();\n        }\n        // add the item to the specified part, otherwise add to default\n        if (bean.getSelectedSection() != null) {\n// need to do  add a temp part first if assigned to a temp part SAK-2109\n \n          SectionFacade section;\n\n\t  if (\"-1\".equals(bean.getSelectedSection())) {\n\t    AssessmentBean assessmentBean = (AssessmentBean) ContextUtil.lookupBean(\"assessmentBean\");\n// add a new section\n      \t    section = assessdelegate.addSection(assessmentBean.getAssessmentId());\n          }\n\n\t  else {\n            section = assessdelegate.getSection(bean.getSelectedSection());\n          }\n          item.setSection(section);\n\n          if (update) {\n\t  // if Modify, need to reorder if assgned to different section '\n            if ( (bean.getOrigSection() != null) &&\n\t\t(!bean.getOrigSection().equals(bean.getSelectedSection()))) {\n                // if reassigned to different section\n              Integer oldSeq = item.getSequence();\n              item.setSequence(new Integer(section.getItemSet().size() + 1));\n\n              // reorder the sequences of items in the OrigSection\n    \t      SectionFacade origsect= assessdelegate.getSection(bean.getOrigSection());\n\t      shiftItemsInOrigSection(delegate, origsect, oldSeq);\n\n\n            }\n            else {\n              // no action needed\n            }\n          }\n\n          if (!update) {\n            if ( (itemauthor.getInsertPosition() == null) ||\n                (\"\".equals(itemauthor.getInsertPosition()))\n                || !section.getSequence().equals(itemauthor.getInsertToSection())) {\n              // if adding to the end\n              if (section.getItemSet() != null) {\n            \t  item.setSequence(new Integer(section.getItemSet().size() + 1));\n              }\n              else {\n\t \t// this is a new part, not saved yet \n\t\titem.setSequence(new Integer(1));\n              }\n            }\n            else {\n              // if inserting or a question\n              String insertPos = itemauthor.getInsertPosition();\n              shiftSequences(delegate, section, new Integer(insertPos));\n              int insertPosInt = (new Integer(insertPos)).intValue() + 1;\n              item.setSequence(new Integer(insertPosInt));\n              // reset InsertPosition\n              itemauthor.setInsertPosition(\"\");\n            }\n          }\n          if (itemauthor.getInsertToSection() != null) {\n    \t\t  // reset insertToSection to null;\n    \t\t  itemauthor.setInsertToSection(null);\n    \t  }\n          \n          delegate.saveItem(item);\n\n          // added by daisyf, 10/10/06\n          updateAttachment(item.getItemAttachmentList(), itemauthor.getAttachmentList(),\n                           (ItemDataIfc)item.getData(), isEditPendingAssessmentFlow);\n          item = delegate.getItem(item.getItemId().toString());\n\n        }\n\n        QuestionPoolService qpdelegate = new QuestionPoolService();\n\t// removed the old pool-item mappings\n          if ( (bean.getOrigPool() != null) && (!bean.getOrigPool().equals(\"\"))) {\n            qpdelegate.removeQuestionFromPool(item.getItemIdString(),\n                                              new Long(bean.getOrigPool()));\n          }\n\n        // if assign to pool, add the item to the pool\n        if ( (bean.getSelectedPool() != null) && !bean.getSelectedPool().equals(\"\")) {\n        \t// if the item is already in the pool then do not add.\n          // This is a scenario where the item might already be in the pool:\n          // create an item in an assessemnt and assign it to p1\n          // copy item from p1 to p2. \n          // now the item is already in p2. and if you want to edit the original item in the assessment, and reassign it to p2, you will get a duplicate error. \n\n          if (!qpdelegate.hasItem(item.getItemIdString(),\n                                new Long(bean.getSelectedPool()))) {\n            qpdelegate.addItemToPool(item.getItemIdString(),\n                                   new Long(bean.getSelectedPool()));\n          }\n        }\n\n        // #1a - goto editAssessment.jsp, so reset assessmentBean\n        AssessmentBean assessmentBean = (AssessmentBean) ContextUtil.lookupBean(\n            \"assessmentBean\");\n        AssessmentIfc assessment = assessdelegate.getAssessment(\n            Long.valueOf(assessmentBean.getAssessmentId()));\n        assessmentBean.setAssessment(assessment);\n\n        itemauthor.setOutcome(\"editAssessment\");\n\n      }\n      // sorry, i need this for item attachment, used by SaveItemAttachmentListener. \n      itemauthor.setItemId(item.getItemId().toString());\n      return true;\n    }\n    catch (RuntimeException e) {\n      e.printStackTrace();\n      return false;\n    }\n  }","commit_id":"c48ad2981aa9c2fb864ac30622aa2abab3efb799","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void processAction(ActionEvent ae) throws AbortProcessingException {\r\n\t\tAssessmentBean assessmentBean = (AssessmentBean) ContextUtil\r\n\t\t\t\t.lookupBean(\"assessmentBean\");\r\n\t\tboolean hasGradingData = assessmentBean.getHasGradingData();\r\n\r\n\t\tString publishedAssessmentId = assessmentBean.getAssessmentId();\r\n\t\tlog.debug(\"publishedAssessmentId = \" + publishedAssessmentId);\r\n\t\tPublishedAssessmentService publishedAssessmentService = new PublishedAssessmentService();\r\n\t\t// Go to database to get the newly updated data. The data inside beans might not be up to date.\r\n\t\tPublishedAssessmentFacade assessment = publishedAssessmentService.getPublishedAssessment(publishedAssessmentId);\r\n\t\t\r\n\t\tboolean withSection = true; \r\n\t\tif (assessment == null) {\r\n\t\t\tPublishedAssessmentSettingsBean assessmentSettings = (PublishedAssessmentSettingsBean) ContextUtil.lookupBean(\"publishedSettings\");\r\n\t\t\tassessment = assessmentSettings.getAssessment();\r\n\t\t\twithSection = false; // the assessment getting from assessmentSettings doesn't have sections\r\n\t\t}\r\n\t\tassessment.setStatus(AssessmentBaseIfc.ACTIVE_STATUS);\r\n\t\tpublishedAssessmentService.saveAssessment(assessment);\r\n\t\t\r\n\t\t// If there are submissions, need to regrade them\r\n\t\tif (hasGradingData) {\r\n\t\t\tif (!withSection) {\r\n\t\t\t\tassessment.setSectionSet(publishedAssessmentService.getSectionSetForAssessment((PublishedAssessmentIfc) assessment));\r\n\t\t\t}\r\n\t\t\tregradeRepublishedAssessment(publishedAssessmentService, (PublishedAssessmentIfc) assessment);\r\n\t\t}\r\n\r\n\t\tAuthorBean author = (AuthorBean) ContextUtil.lookupBean(\"author\");\r\n\t\t//\t\t get the managed bean, author and set all the list\r\n\t\tGradingService gradingService = new GradingService();\r\n\t\tHashMap map = gradingService\r\n\t\t\t\t.getSubmissionSizeOfAllPublishedAssessments();\r\n\r\n\t\t// 1. need to update active published list in author bean\r\n\t\tArrayList activePublishedList = publishedAssessmentService\r\n\t\t\t\t.getBasicInfoOfAllActivePublishedAssessments(author\r\n\t\t\t\t\t\t.getPublishedAssessmentOrderBy(), author\r\n\t\t\t\t\t\t.isPublishedAscending());\r\n\t\tauthor.setPublishedAssessments(activePublishedList);\r\n\t\tsetSubmissionSize(activePublishedList, map);\r\n\r\n\t\t// 2. need to update inactive published list in author bean\r\n\t\tArrayList inactivePublishedList = publishedAssessmentService\r\n\t\t\t\t.getBasicInfoOfAllInActivePublishedAssessments(author\r\n\t\t\t\t\t\t.getInactivePublishedAssessmentOrderBy(), author\r\n\t\t\t\t\t\t.isInactivePublishedAscending());\r\n\t\tauthor.setInactivePublishedAssessments(inactivePublishedList);\r\n\t\tsetSubmissionSize(inactivePublishedList, map);\r\n\r\n\t\t// 3. reset the core listing\r\n\t\t// 'cos user may change core assessment title and publish - sigh\r\n\t\tAssessmentService assessmentService = new AssessmentService();\r\n\t\tArrayList assessmentList = assessmentService\r\n\t\t\t\t.getBasicInfoOfAllActiveAssessments(author\r\n\t\t\t\t\t\t.getCoreAssessmentOrderBy(), author.isCoreAscending());\r\n\t\t// get the managed bean, author and set the list\r\n\t\tauthor.setAssessments(assessmentList);\r\n\t\tauthor.setOutcome(\"author\");\r\n\t}","id":60340,"modified_method":"public void processAction(ActionEvent ae) throws AbortProcessingException {\r\n\t\tAssessmentBean assessmentBean = (AssessmentBean) ContextUtil\r\n\t\t\t\t.lookupBean(\"assessmentBean\");\r\n\t\tboolean hasGradingData = assessmentBean.getHasGradingData();\r\n\r\n\t\tString publishedAssessmentId = assessmentBean.getAssessmentId();\r\n\t\tlog.debug(\"publishedAssessmentId = \" + publishedAssessmentId);\r\n\t\tPublishedAssessmentService publishedAssessmentService = new PublishedAssessmentService();\r\n\t\t// Go to database to get the newly updated data. The data inside beans might not be up to date.\r\n\t\tPublishedAssessmentFacade assessment = publishedAssessmentService.getPublishedAssessment(publishedAssessmentId);\r\n\t\tEventTrackingService.post(EventTrackingService.newEvent(\"sam.pubassessment.republish\", \"publishedAssessmentId=\" + publishedAssessmentId, true));\r\n\t\tassessment.setStatus(AssessmentBaseIfc.ACTIVE_STATUS);\r\n\t\tpublishedAssessmentService.saveAssessment(assessment);\r\n\r\n\t\t// If there are submissions, need to regrade them\r\n\t\tif (hasGradingData) {\r\n\t\t\tregradeRepublishedAssessment(publishedAssessmentService, (PublishedAssessmentIfc) assessment);\r\n\t\t}\r\n\r\n\t\tAuthorBean author = (AuthorBean) ContextUtil.lookupBean(\"author\");\r\n\t\t//\t\t get the managed bean, author and set all the list\r\n\t\tGradingService gradingService = new GradingService();\r\n\t\tHashMap map = gradingService\r\n\t\t\t\t.getSubmissionSizeOfAllPublishedAssessments();\r\n\r\n\t\t// 1. need to update active published list in author bean\r\n\t\tArrayList activePublishedList = publishedAssessmentService\r\n\t\t\t\t.getBasicInfoOfAllActivePublishedAssessments(author\r\n\t\t\t\t\t\t.getPublishedAssessmentOrderBy(), author\r\n\t\t\t\t\t\t.isPublishedAscending());\r\n\t\tauthor.setPublishedAssessments(activePublishedList);\r\n\t\tsetSubmissionSize(activePublishedList, map);\r\n\r\n\t\t// 2. need to update inactive published list in author bean\r\n\t\tArrayList inactivePublishedList = publishedAssessmentService\r\n\t\t\t\t.getBasicInfoOfAllInActivePublishedAssessments(author\r\n\t\t\t\t\t\t.getInactivePublishedAssessmentOrderBy(), author\r\n\t\t\t\t\t\t.isInactivePublishedAscending());\r\n\t\tauthor.setInactivePublishedAssessments(inactivePublishedList);\r\n\t\tsetSubmissionSize(inactivePublishedList, map);\r\n\r\n\t\t// 3. reset the core listing\r\n\t\t// 'cos user may change core assessment title and publish - sigh\r\n\t\tAssessmentService assessmentService = new AssessmentService();\r\n\t\tArrayList assessmentList = assessmentService\r\n\t\t\t\t.getBasicInfoOfAllActiveAssessments(author\r\n\t\t\t\t\t\t.getCoreAssessmentOrderBy(), author.isCoreAscending());\r\n\t\t// get the managed bean, author and set the list\r\n\t\tauthor.setAssessments(assessmentList);\r\n\t\tauthor.setOutcome(\"author\");\r\n\t}","commit_id":"c48ad2981aa9c2fb864ac30622aa2abab3efb799","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public boolean setPublishedSettings(PublishedAssessmentSettingsBean assessmentSettings, FacesContext context, PublishedAccessControl control, PublishedAssessmentFacade assessment) {\n\t    boolean error = false;\n\t    // check if start date is valid\n\t    if(!assessmentSettings.getIsValidStartDate()){\n\t    \tString startDateErr = ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.GeneralMessages\",\"invalid_start_date\");\n\t    \tcontext.addMessage(null,new FacesMessage(startDateErr));\n\t    \terror=true;\n\t    }\n\t    // check if due date is valid\n\t    if(!assessmentSettings.getIsValidDueDate()){\n\t    \tString dueDateErr = ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.GeneralMessages\",\"invalid_due_date\");\n\t    \tcontext.addMessage(null,new FacesMessage(dueDateErr));\n\t    \terror=true;\n\t    }\n\t    // check if retract date is valid\n\t    if(!assessmentSettings.getIsValidRetractDate()){\n\t    \tString retractDateErr = ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.GeneralMessages\",\"invalid_retrack_date\");\n\t    \tcontext.addMessage(null,new FacesMessage(retractDateErr));\n\t    \terror=true;\n\t    }\n\t    \n\t   \t// a. LATER set dueDate, startDate, releaseTo\n\t   \tcontrol.setStartDate(assessmentSettings.getStartDate());\n\t   \tcontrol.setDueDate(assessmentSettings.getDueDate());\n\t   \tcontrol.setRetractDate(assessmentSettings.getRetractDate());\n\t   \t\n\t    //check feedback - if at specific time then time should be defined.\n\t    if((assessmentSettings.getFeedbackDelivery()).equals(\"2\")) {\n\t    \tif (assessmentSettings.getFeedbackDateString()==null || assessmentSettings.getFeedbackDateString().equals(\"\")) {\n\t    \t\terror=true;\n\t    \t\tString  date_err=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AssessmentSettingsMessages\",\"date_error\");\n\t    \t\tcontext.addMessage(null,new FacesMessage(date_err));\n\t    \t}\n\t    \telse if(!assessmentSettings.getIsValidFeedbackDate()){\n\t        \tString feedbackDateErr = ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.GeneralMessages\",\"invalid_feedback_date\");\n\t        \tcontext.addMessage(null,new FacesMessage(feedbackDateErr));\n\t        \terror=true;\n\t        }\n\t    }\n\t   \tcontrol.setFeedbackDate(assessmentSettings.getFeedbackDate());\n\n\t   \t\n\t    //#3 Feedback\n\t   \tAssessmentFeedbackIfc feedback = (AssessmentFeedbackIfc) assessment.getAssessmentFeedback();\n\t    if (feedback == null){\n\t      feedback = new AssessmentFeedback();\n\t      // need to fix feeback so it can take AssessmentFacade later\n\t      feedback.setAssessmentBase(assessment.getData());\n\t    }\n\t    if (assessmentSettings.getFeedbackDelivery()!=null)\n\t     feedback.setFeedbackDelivery(new Integer(assessmentSettings.getFeedbackDelivery()));\n\t    \n\t    feedback.setShowStudentResponse(Boolean.valueOf(assessmentSettings.getShowStudentResponse()));\n\t    feedback.setShowCorrectResponse(Boolean.valueOf(assessmentSettings.getShowCorrectResponse()));\n\t    feedback.setShowStudentScore(Boolean.valueOf(assessmentSettings.getShowStudentScore()));\n\t    feedback.setShowStudentQuestionScore(Boolean.valueOf(assessmentSettings.getShowStudentQuestionScore()));\n\t    feedback.setShowQuestionLevelFeedback(Boolean.valueOf(assessmentSettings.getShowQuestionLevelFeedback()));\n\t    feedback.setShowSelectionLevelFeedback(Boolean.valueOf(assessmentSettings.getShowSelectionLevelFeedback()));\n\t    feedback.setShowGraderComments(Boolean.valueOf(assessmentSettings.getShowGraderComments()));\n\t    feedback.setShowStatistics(Boolean.valueOf(assessmentSettings.getShowStatistics()));\n\t    assessment.setAssessmentFeedback(feedback);\n\n\t    return error;\n  }","id":60341,"modified_method":"public boolean setPublishedSettings(PublishedAssessmentSettingsBean assessmentSettings, FacesContext context, PublishedAccessControl control, PublishedAssessmentFacade assessment, boolean retractNow) {\n\t    boolean error = false;\n\t    // check if start date is valid\n\t    if(!assessmentSettings.getIsValidStartDate()){\n\t    \tString startDateErr = ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.GeneralMessages\",\"invalid_start_date\");\n\t    \tcontext.addMessage(null,new FacesMessage(startDateErr));\n\t    \terror=true;\n\t    }\n\t    // check if due date is valid\n\t    if(!assessmentSettings.getIsValidDueDate()){\n\t    \tString dueDateErr = ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.GeneralMessages\",\"invalid_due_date\");\n\t    \tcontext.addMessage(null,new FacesMessage(dueDateErr));\n\t    \terror=true;\n\t    }\n\t    // check if retract date is valid\n\t    if(!assessmentSettings.getIsValidRetractDate()){\n\t    \tString retractDateErr = ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.GeneralMessages\",\"invalid_retrack_date\");\n\t    \tcontext.addMessage(null,new FacesMessage(retractDateErr));\n\t    \terror=true;\n\t    }\n\t    \n\t   \t// LATER set dueDate, startDate, retractDate \n\t   \tcontrol.setStartDate(assessmentSettings.getStartDate());\n\t   \tcontrol.setDueDate(assessmentSettings.getDueDate());\n\t   \tif (retractNow)\n\t   \t{\n\t   \t\tcontrol.setRetractDate(new Date());\n\t   \t}\n\t   \telse {\n\t   \t\tcontrol.setRetractDate(assessmentSettings.getRetractDate());\n\t   \t}\n\t   \t\n\t    //check feedback - if at specific time then time should be defined.\n\t    if((assessmentSettings.getFeedbackDelivery()).equals(\"2\")) {\n\t    \tif (assessmentSettings.getFeedbackDateString()==null || assessmentSettings.getFeedbackDateString().equals(\"\")) {\n\t    \t\terror=true;\n\t    \t\tString  date_err=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AssessmentSettingsMessages\",\"date_error\");\n\t    \t\tcontext.addMessage(null,new FacesMessage(date_err));\n\t    \t}\n\t    \telse if(!assessmentSettings.getIsValidFeedbackDate()){\n\t        \tString feedbackDateErr = ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.GeneralMessages\",\"invalid_feedback_date\");\n\t        \tcontext.addMessage(null,new FacesMessage(feedbackDateErr));\n\t        \terror=true;\n\t        }\n\t    }\n\t   \tcontrol.setFeedbackDate(assessmentSettings.getFeedbackDate());\n\n\t   \t\n\t    //#3 Feedback\n\t   \tAssessmentFeedbackIfc feedback = (AssessmentFeedbackIfc) assessment.getAssessmentFeedback();\n\t    if (feedback == null){\n\t      feedback = new AssessmentFeedback();\n\t      // need to fix feeback so it can take AssessmentFacade later\n\t      feedback.setAssessmentBase(assessment.getData());\n\t    }\n\t    if (assessmentSettings.getFeedbackDelivery()!=null)\n\t     feedback.setFeedbackDelivery(new Integer(assessmentSettings.getFeedbackDelivery()));\n\t    \n\t    feedback.setShowStudentResponse(Boolean.valueOf(assessmentSettings.getShowStudentResponse()));\n\t    feedback.setShowCorrectResponse(Boolean.valueOf(assessmentSettings.getShowCorrectResponse()));\n\t    feedback.setShowStudentScore(Boolean.valueOf(assessmentSettings.getShowStudentScore()));\n\t    feedback.setShowStudentQuestionScore(Boolean.valueOf(assessmentSettings.getShowStudentQuestionScore()));\n\t    feedback.setShowQuestionLevelFeedback(Boolean.valueOf(assessmentSettings.getShowQuestionLevelFeedback()));\n\t    feedback.setShowSelectionLevelFeedback(Boolean.valueOf(assessmentSettings.getShowSelectionLevelFeedback()));\n\t    feedback.setShowGraderComments(Boolean.valueOf(assessmentSettings.getShowGraderComments()));\n\t    feedback.setShowStatistics(Boolean.valueOf(assessmentSettings.getShowStatistics()));\n\t    assessment.setAssessmentFeedback(feedback);\n\n\t    return error;\n  }","commit_id":"c48ad2981aa9c2fb864ac30622aa2abab3efb799","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void processAction(ActionEvent ae) throws AbortProcessingException\n  {\n\t  \tFacesContext context = FacesContext.getCurrentInstance();\n\t    PublishedAssessmentSettingsBean assessmentSettings = (PublishedAssessmentSettingsBean) ContextUtil.lookupBean(\n\t                         \"publishedSettings\");\n\t    \n\t    // create an assessment based on the title entered and the assessment\n\t    // template selected\n\t    // #1 - set Assessment\n\t    Long assessmentId = assessmentSettings.getAssessmentId();\n\t    log.debug(\"**** save assessment assessmentId =\"+assessmentId.toString());\n\t    PublishedAssessmentService assessmentService = new PublishedAssessmentService();\n\t    PublishedAssessmentFacade assessment = assessmentService.getPublishedAssessment(\n\t        assessmentId.toString());\n\t    //log.info(\"** assessment = \"+assessment);\n\n\t    // #2 - update delivery dates in AssessmentAccessControl\n\t    PublishedAccessControl control = (PublishedAccessControl)assessment.getAssessmentAccessControl();\n\t    if (control == null){\n\t        control = new PublishedAccessControl();\n\t        // need to fix accessControl so it can take AssessmentFacade later\n\t        control.setAssessmentBase(assessment.getData());\n\t    }\n\t    String id = ae.getComponent().getId();\n\t    // Check if the action is clicking the the Retract button on Assessment Retract Confirmation button\n\t    if (id.equals(\"retract\")) {\n\t    \tcontrol.setRetractDate(new Date());\n\t    }\n\t    else {\n\t    \tcontrol.setRetractDate(assessmentSettings.getRetractDate());\n\t    }\n\t    \n    boolean error = setPublishedSettings(assessmentSettings, context, control, assessment);\n    if (error){\n        assessmentSettings.setOutcome(\"editPublishedAssessmentSettings\");\n        return;\n    }\n\n    boolean gbError = checkScore(assessmentSettings, assessment, context);\n    if (gbError){\n    \tassessmentSettings.setOutcome(\"editPublishedAssessmentSettings\");\n\t\treturn;\n    }\n\n    updateGB(assessmentSettings, assessment);\n\n    assessmentService.saveAssessment(assessment);\n\n    AuthorBean author = (AuthorBean) ContextUtil.lookupBean(\"author\");\n    resetPublishedAssessmentsList(author, assessmentService);\n        \n    assessmentSettings.setOutcome(author.getFromPage());\n  }","id":60342,"modified_method":"public void processAction(ActionEvent ae) throws AbortProcessingException\n  {\n\t  \tFacesContext context = FacesContext.getCurrentInstance();\n\t    PublishedAssessmentSettingsBean assessmentSettings = (PublishedAssessmentSettingsBean) ContextUtil.lookupBean(\n\t                         \"publishedSettings\");\n\t    \n\t    // create an assessment based on the title entered and the assessment\n\t    // template selected\n\t    // #1 - set Assessment\n\t    Long assessmentId = assessmentSettings.getAssessmentId();\n\t    log.debug(\"**** save assessment assessmentId =\"+assessmentId.toString());\n\t    PublishedAssessmentService assessmentService = new PublishedAssessmentService();\n\t    PublishedAssessmentFacade assessment = assessmentService.getPublishedAssessment(\n\t        assessmentId.toString());\n\t    //log.info(\"** assessment = \"+assessment);\n\n\t    // #2 - update delivery dates in AssessmentAccessControl\n\t    PublishedAccessControl control = (PublishedAccessControl)assessment.getAssessmentAccessControl();\n\t    if (control == null){\n\t        control = new PublishedAccessControl();\n\t        // need to fix accessControl so it can take AssessmentFacade later\n\t        control.setAssessmentBase(assessment.getData());\n\t    }\n\t    boolean retractNow = false;\n\t    String id = ae.getComponent().getId();\n\t    // Check if the action is clicking the the \"Retract\" button on Assessment Retract Confirmation button\n\t    if (id.equals(\"retract\")) {\n\t    \tretractNow = true;\n\t    }\n\n\tEventTrackingService.post(EventTrackingService.newEvent(\"sam.pubsetting.edit\", \"publishedAssessmentId=\" + assessmentId, true));\n    boolean error = setPublishedSettings(assessmentSettings, context, control, assessment, retractNow);\n    if (error){\n        assessmentSettings.setOutcome(\"editPublishedAssessmentSettings\");\n        return;\n    }\n\n    boolean gbError = checkScore(assessmentSettings, assessment, context);\n    if (gbError){\n    \tassessmentSettings.setOutcome(\"editPublishedAssessmentSettings\");\n\t\treturn;\n    }\n    \n    updateGB(assessmentSettings, assessment);\n\n    assessmentService.saveAssessment(assessment);\n\n    AuthorBean author = (AuthorBean) ContextUtil.lookupBean(\"author\");\n    resetPublishedAssessmentsList(author, assessmentService);\n        \n    assessmentSettings.setOutcome(author.getFromPage());\n  }","commit_id":"c48ad2981aa9c2fb864ac30622aa2abab3efb799","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public ModuleOutputPaths(Iterable<SModule> modules) {\n    // todo: use union of output paths for models? \n    this.sortedOutDirs = DirUtil.sortDirs(Sequence.fromIterable(modules).where(new IWhereFilter<SModule>() {\n      public boolean accept(SModule it) {\n        return it instanceof AbstractModule && ((AbstractModule) it).getOutputPath() != null;\n      }\n    }).select(new ISelector<SModule, String>() {\n      public String select(SModule it) {\n        return ((AbstractModule) it).getOutputPath().getPath();\n      }\n    }));\n    this.sortedOutCacheDirs = DirUtil.sortDirs(Sequence.fromIterable(Sequence.fromArray(this.sortedOutDirs)).select(new ISelector<String, String>() {\n      public String select(String outDir) {\n        return FileGenerationUtil.getCachesPath(outDir);\n      }\n    }));\n\n    this.sortedTestOutDirs = DirUtil.sortDirs(Sequence.fromIterable(modules).where(new IWhereFilter<SModule>() {\n      public boolean accept(SModule it) {\n        return it.getFacet(TestsFacet.class) != null;\n      }\n    }).select(new ISelector<SModule, String>() {\n      public String select(SModule it) {\n        IFile dir = it.getFacet(TestsFacet.class).getTestsOutputPath();\n        return (dir != null ?\n          dir.getPath() :\n          null\n        );\n      }\n    }));\n    this.sortedTestOutCacheDirs = DirUtil.sortDirs(Sequence.fromIterable(Sequence.fromArray(this.sortedTestOutDirs)).select(new ISelector<String, String>() {\n      public String select(String outDir) {\n        return FileGenerationUtil.getCachesPath(outDir);\n      }\n    }));\n\n    Iterable<String> modelRootPaths = Sequence.fromIterable(modules).translate(new ITranslator2<SModule, ModelRoot>() {\n      public Iterable<ModelRoot> translate(SModule mod) {\n        return mod.getModelRoots();\n      }\n    }).where(new IWhereFilter<ModelRoot>() {\n      public boolean accept(ModelRoot it) {\n        return it instanceof FolderModelRootBase;\n      }\n    }).select(new ISelector<ModelRoot, String>() {\n      public String select(ModelRoot smr) {\n        return ((FolderModelRootBase) smr).getPath();\n      }\n    });\n    modelRootPaths = Sequence.fromIterable(modelRootPaths).concat(Sequence.fromIterable(modules).translate(new ITranslator2<SModule, ModelRoot>() {\n      public Iterable<ModelRoot> translate(SModule mod) {\n        return mod.getModelRoots();\n      }\n    }).where(new IWhereFilter<ModelRoot>() {\n      public boolean accept(ModelRoot it) {\n        return it instanceof FileBasedModelRoot;\n      }\n    }).select(new ISelector<ModelRoot, String>() {\n      public String select(ModelRoot smr) {\n        return ((FileBasedModelRoot) smr).getContentRoot();\n      }\n    }));\n\n    this.sortedModelDirs = DirUtil.sortDirs(Sequence.fromIterable(modelRootPaths).select(new ISelector<String, IFile>() {\n      public IFile select(String path) {\n        return FileSystem.getInstance().getFileByPath(path);\n      }\n    }).where(new IWhereFilter<IFile>() {\n      public boolean accept(IFile f) {\n        return f.isDirectory() && !(f instanceof JarEntryFile);\n      }\n    }).select(new ISelector<IFile, String>() {\n      public String select(IFile dir) {\n        return dir.getPath();\n      }\n    }));\n  }","id":60343,"modified_method":"public ModuleOutputPaths(Iterable<SModule> _modules) {\n    Iterable<AbstractModule> modules = Sequence.fromIterable(_modules).where(new IWhereFilter<SModule>() {\n      public boolean accept(SModule it) {\n        return it instanceof AbstractModule;\n      }\n    }).select(new ISelector<SModule, AbstractModule>() {\n      public AbstractModule select(SModule it) {\n        return ((AbstractModule) it);\n      }\n    });\n    this.sortedOutDirs = DirUtil.sortDirs(Sequence.fromIterable(modules).select(new ISelector<AbstractModule, String>() {\n      public String select(AbstractModule mod) {\n        return ((AbstractModule) mod).getGeneratorOutputPath();\n      }\n    }));\n    this.sortedOutCacheDirs = DirUtil.sortDirs(Sequence.fromIterable(modules).select(new ISelector<AbstractModule, String>() {\n      public String select(AbstractModule mod) {\n        return FileGenerationUtil.getCachesPath(mod.getGeneratorOutputPath());\n      }\n    }));\n    // todo: use union of output paths for models? \n    this.sortedTestOutDirs = DirUtil.sortDirs(Sequence.fromIterable(modules).select(new ISelector<AbstractModule, String>() {\n      public String select(AbstractModule mod) {\n        // todo: tmp hack \n        String path = mod.getTestsGeneratorOutputPath();\n        return (path != null ?\n          path :\n          mod.getGeneratorOutputPath()\n        );\n      }\n    }));\n    this.sortedTestOutCacheDirs = DirUtil.sortDirs(Sequence.fromIterable(modules).select(new ISelector<AbstractModule, String>() {\n      public String select(AbstractModule mod) {\n        // todo: tmp hack \n        String path = mod.getTestsGeneratorOutputPath();\n        if (path == null) {\n          path = mod.getGeneratorOutputPath();\n        }\n        return FileGenerationUtil.getCachesPath(path);\n      }\n    }));\n\n    Iterable<String> modelRootPaths = Sequence.fromIterable(_modules).translate(new ITranslator2<SModule, ModelRoot>() {\n      public Iterable<ModelRoot> translate(SModule mod) {\n        return mod.getModelRoots();\n      }\n    }).where(new IWhereFilter<ModelRoot>() {\n      public boolean accept(ModelRoot it) {\n        return it instanceof FolderModelRootBase;\n      }\n    }).select(new ISelector<ModelRoot, String>() {\n      public String select(ModelRoot smr) {\n        return ((FolderModelRootBase) smr).getPath();\n      }\n    });\n    modelRootPaths = Sequence.fromIterable(modelRootPaths).concat(Sequence.fromIterable(_modules).translate(new ITranslator2<SModule, ModelRoot>() {\n      public Iterable<ModelRoot> translate(SModule mod) {\n        return mod.getModelRoots();\n      }\n    }).where(new IWhereFilter<ModelRoot>() {\n      public boolean accept(ModelRoot it) {\n        return it instanceof FileBasedModelRoot;\n      }\n    }).select(new ISelector<ModelRoot, String>() {\n      public String select(ModelRoot smr) {\n        return ((FileBasedModelRoot) smr).getContentRoot();\n      }\n    }));\n\n    this.sortedModelDirs = DirUtil.sortDirs(Sequence.fromIterable(modelRootPaths).select(new ISelector<String, IFile>() {\n      public IFile select(String path) {\n        return FileSystem.getInstance().getFileByPath(path);\n      }\n    }).where(new IWhereFilter<IFile>() {\n      public boolean accept(IFile f) {\n        return f.isDirectory() && !(f instanceof JarEntryFile);\n      }\n    }).select(new ISelector<IFile, String>() {\n      public String select(IFile dir) {\n        return dir.getPath();\n      }\n    }));\n  }","commit_id":"ae1bec119e7a79d4ad20b9ee3d135723d0097b73","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void findBugsButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_findBugsButtonActionPerformed\n        Project project = getCurrentProject();\n        AnalysisRun analysisRun = new AnalysisRun(project);\n        \n        // Run the analysis!\n        RunAnalysisDialog dialog = new RunAnalysisDialog(this, analysisRun);\n        dialog.setSize(400, 300);\n        dialog.show();\n\n        if (dialog.isCompleted()) {\n            // Create a navigator tree node for the analysis run\n            DefaultTreeModel treeModel = (DefaultTreeModel) navigatorTree.getModel();\n            TreePath treePath = navigatorTree.getSelectionPath();\n            DefaultMutableTreeNode projectNode = (DefaultMutableTreeNode) treePath.getPath()[1];\n            treeModel.insertNodeInto(\n                new DefaultMutableTreeNode(analysisRun), projectNode, projectNode.getChildCount());\n        }\n    }","id":60344,"modified_method":"private void findBugsButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_findBugsButtonActionPerformed\n        Project project = getCurrentProject();\n        AnalysisRun analysisRun = new AnalysisRun(project);\n        \n        // Run the analysis!\n        RunAnalysisDialog dialog = new RunAnalysisDialog(this, analysisRun);\n        dialog.setSize(400, 300);\n        dialog.show();\n\n        if (dialog.isCompleted()) {\n            // Create a navigator tree node for the analysis run\n            DefaultTreeModel treeModel = (DefaultTreeModel) navigatorTree.getModel();\n            TreePath treePath = navigatorTree.getSelectionPath();\n            DefaultMutableTreeNode projectNode = (DefaultMutableTreeNode) treePath.getPath()[1];\n            DefaultMutableTreeNode analysisRunNode = new DefaultMutableTreeNode(analysisRun);\n            treeModel.insertNodeInto(analysisRunNode, projectNode, projectNode.getChildCount());\n            \n            // Make the new node the currently selected node\n            TreePath path = new TreePath(new Object[]{rootNode, projectNode, analysisRunNode});\n            navigatorTree.makeVisible(path);\n            navigatorTree.setSelectionPath(path);\n        }\n    }","commit_id":"86c7e4730ccbea146a9ad47e5d2221f6c40e5ecb","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void insertChangeNode(final Object change, final HashMap<FilePath, ChangesBrowserNode> foldersCache,\n                                final ChangesGroupingPolicy policy,\n                                final ChangesBrowserNode listNode) {\n    final FilePath nodePath = getPathForObject(change);\n    ChangesBrowserNode oldNode = foldersCache.get(nodePath);\n    if (oldNode != null) {\n      ChangesBrowserNode node = ChangesBrowserNode.create(myProject, change);\n      for(int i=oldNode.getChildCount()-1; i >= 0; i--) {\n        MutableTreeNode child = (MutableTreeNode) model.getChild(oldNode, i);\n        model.removeNodeFromParent(child);\n        model.insertNodeInto(child, node, model.getChildCount(child));\n      }\n      final MutableTreeNode parent = (MutableTreeNode)oldNode.getParent();\n      int index = model.getIndexOfChild(parent, oldNode);\n      model.removeNodeFromParent(oldNode);\n      model.insertNodeInto(node, parent, index);\n      foldersCache.put(nodePath, node);\n    }\n    else {\n      final ChangesBrowserNode node = ChangesBrowserNode.create(myProject, change);\n      model.insertNodeInto(node, getParentNodeFor(node, foldersCache, policy, listNode), model.getChildCount(node));\n      foldersCache.put(nodePath, node);\n    }\n  }","id":60345,"modified_method":"private void insertChangeNode(final Object change, final HashMap<FilePath, ChangesBrowserNode> foldersCache,\n                                final ChangesGroupingPolicy policy,\n                                final ChangesBrowserNode listNode) {\n    final FilePath nodePath = getPathForObject(change);\n    ChangesBrowserNode oldNode = foldersCache.get(nodePath);\n    if (oldNode != null) {\n      ChangesBrowserNode node = ChangesBrowserNode.create(myProject, change);\n      for(int i=oldNode.getChildCount()-1; i >= 0; i--) {\n        MutableTreeNode child = (MutableTreeNode) model.getChild(oldNode, i);\n        model.removeNodeFromParent(child);\n        model.insertNodeInto(child, node, model.getChildCount(node));\n      }\n      final MutableTreeNode parent = (MutableTreeNode)oldNode.getParent();\n      int index = model.getIndexOfChild(parent, oldNode);\n      model.removeNodeFromParent(oldNode);\n      model.insertNodeInto(node, parent, index);\n      foldersCache.put(nodePath, node);\n    }\n    else {\n      final ChangesBrowserNode node = ChangesBrowserNode.create(myProject, change);\n      ChangesBrowserNode parentNode = getParentNodeFor(node, foldersCache, policy, listNode);\n      model.insertNodeInto(node, parentNode, model.getChildCount(parentNode));\n      foldersCache.put(nodePath, node);\n    }\n  }","commit_id":"d882b90a020570fb86470af1f4d9c2dc68442599","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MainFrame(final UI_Controller ui_controller) {\n        this.ui_controller = ui_controller;\n        this.graphTable = new UI_GraphTable(ui_controller);\n        this.refTable = new UI_NewRefTable(ui_controller.getRefsTreeTableModel());\n        packElements();\n    }","id":60346,"modified_method":"public MainFrame(final UI_Controller ui_controller) {\n        this.ui_controller = ui_controller;\n        this.graphTable = new UI_GraphTable(ui_controller);\n        this.refTable = new UI_RefTable(ui_controller.getRefsTreeTableModel());\n        packElements();\n    }","commit_id":"2ae545f02fcc59d649383777c315d589659aa17f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void prepare() {\n        setDefaultRenderer(CommitCell.class, new CommitCellRender());\n\n        setRowHeight(HEIGHT_CELL);\n        setShowHorizontalLines(false);\n        setIntercellSpacing(new Dimension(0, 0));\n\n\n        getColumnModel().getColumn(0).setMinWidth(24);\n        getColumnModel().getColumn(0).setMaxWidth(24);\n        getColumnModel().getColumn(1).setPreferredWidth(800);\n        getColumnModel().getColumn(2).setMinWidth(80);\n        getColumnModel().getColumn(3).setMinWidth(80);\n\n    }","id":60347,"modified_method":"private void prepare() {\n        setRootVisible(false);\n        expandAll();\n\n        getColumnModel().getColumn(0).setMaxWidth(20);\n\n        setTreeCellRenderer(new RefTreeCellRender());\n\n        setRowHeight(Print_Parameters.HEIGHT_CELL);\n\n        setLeafIcon(null);\n        setClosedIcon(null);\n        setOpenIcon(null);\n    }","commit_id":"2ae545f02fcc59d649383777c315d589659aa17f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public UI_RefTable(@NotNull TableModel refsTableModel) {\n        super(refsTableModel);\n        prepare();\n    }","id":60348,"modified_method":"public UI_RefTable(TreeTableModel treeModel) {\n        super(treeModel);\n        prepare();\n    }","commit_id":"2ae545f02fcc59d649383777c315d589659aa17f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private MapsSelectionPanel() \n    {\n        setOpaque(false);\n        GridBagLayout gridBag = new GridBagLayout();\n        GridBagConstraints gridBagConstraints = new GridBagConstraints();\n        setLayout(gridBag);\n        \n        //fileNameField = new JTextField(20);\n        browseButton = new JButton(\"Add Maps\");\n        browseButton.addActionListener(new ActionListener()\n        {\n           public void actionPerformed(ActionEvent e)\n           {\n               JFileChooser choose = new JFileChooser();\n               if(lastDirectory!=null)\n                   choose.setCurrentDirectory(lastDirectory);\n               VueFileFilter vff = new VueFileFilter(VueFileFilter.VUE_DESCRIPTION);\n               choose.setFileFilter(vff);\n               choose.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);\n               int cancel = choose.showOpenDialog(MapsSelectionPanel.this);\n               if(cancel == JFileChooser.CANCEL_OPTION)\n                   return;\n               File choice = choose.getSelectedFile();\n               if(choose.getSelectedFile().getParentFile().isDirectory())\n                 lastDirectory = choose.getSelectedFile().getParentFile();\n               if(choice.isDirectory())\n               {\n                  java.io.FileFilter iff = new java.io.FileFilter()\n                  {\n                      public boolean accept(File file)\n                      {\n                          if(file.getName().substring(file.getName().lastIndexOf(\".\")+1,file.getName().length()).equals(\"vue\"))\n                            return true;\n                          else \n                            return false;\n                      }\n                      \n                      public String getDescription()\n                      {\n                          return \"VUE FILE\";\n                      }\n                  };\n                  File[] files =  choice.listFiles(iff);\n                  for(int i=0;i<files.length;i++)\n                  {\n                      File file = files[files.length-1-i];\n                      String name = file.getAbsolutePath();\n                      ((MapTableModel)maps.getModel()).addRow(name);\n                      //String shortName = getShortNameForFile(name); \n                      //fileNameField.setText(shortName);\n                      revalidate();\n                      scroll.getViewport().revalidate();\n                  }\n               }\n               else\n               {    \n                  String name = choice.getAbsolutePath();\n                  ((MapTableModel)maps.getModel()).addRow(name);\n                  //fileNameField.setText(getShortNameForFile(name));\n                  revalidate();\n                  scroll.getViewport().revalidate();\n               }\n           }\n        });\n        VUE.getTabbedPane().addContainerListener(new java.awt.event.ContainerListener()\n        {\n            public void componentAdded(java.awt.event.ContainerEvent e)\n            {\n                //System.out.println(\"MSP: VUE tabbed pane component added \" + e);\n                revalidate();\n            }\n            \n            public void componentRemoved(java.awt.event.ContainerEvent e)\n            {\n                //System.out.println(\"MSP: VUE tabbed pane component removed \" + e);\n                revalidate();\n            }\n        });\n        VUE.getTabbedPane().addChangeListener(new ChangeListener()\n        {\n            public void stateChanged(javax.swing.event.ChangeEvent e)\n            {\n                //System.out.println(\"MSP: VUE tabbed pane change event \" + e);\n            }\n        });\n        \n        VUE.getTabbedPane().addPropertyChangeListener(new PropertyChangeListener()\n        {\n            public void propertyChange(PropertyChangeEvent e)\n            {\n                revalidate();\n                repaint();\n                scroll.getViewport().revalidate();\n                //System.out.println(\"MSP: VUE tabbed pane property change event \" + e.getPropertyName());\n            }\n        });\n\n        JLabel stepOneLabel = new JLabel(stepOneMessage);\n        stepOneLabel.setFont(tufts.vue.gui.GUI.LabelFace);\n        //gridBagConstraints.gridwidth = GridBagConstraints.REMAINDER;\n        gridBagConstraints.anchor = GridBagConstraints.NORTHWEST;\n        gridBag.setConstraints(stepOneLabel,gridBagConstraints);\n        //stepOneLabel.setBorder(BorderFactory.createEmptyBorder(15,0,0,0));\n        stepOneLabel.setBorder(BorderFactory.createEmptyBorder(5+2,15,5+2,7));\n        add(stepOneLabel);\n        \n        gridBagConstraints.gridwidth = GridBagConstraints.REMAINDER;\n        gridBagConstraints.weightx = 0.0;\n        gridBagConstraints.anchor = GridBagConstraints.WEST;\n        \n        //gridBagConstraints.insets = new Insets(3,0,0,0);\n        \n        //gridBagConstraints.gridwidth = 1;\n        // //gridBagConstraints.gridwidth = GridBagConstraints.REMAINDER;\n        gridBag.setConstraints(browseButton,gridBagConstraints);\n        browseButton.setOpaque(false);\n        browseButton.setFont(tufts.vue.gui.GUI.LabelFace);\n        add(browseButton);\n        \n        gridBagConstraints.insets = new Insets(0,0,0,0);\n        \n        JLabel stepTwoLabel = new JLabel(stepTwoMessage);\n        stepTwoLabel.setFont(tufts.vue.gui.GUI.LabelFace);\n        //gridBagConstraints.gridwidth = GridBagConstraints.REMAINDER;\n        gridBag.setConstraints(stepTwoLabel,gridBagConstraints);\n        stepTwoLabel.setBorder(BorderFactory.createEmptyBorder(5+2,15,5+2,5));\n        add(stepTwoLabel);  \n\n        JLabel stepThreeLabel = new JLabel(stepThreeMessage);\n        stepThreeLabel.setFont(tufts.vue.gui.GUI.LabelFace);\n        //gridBagConstraints.gridwidth = GridBagConstraints.REMAINDER;\n        gridBagConstraints.gridwidth = 1;\n        gridBag.setConstraints(stepThreeLabel,gridBagConstraints);\n        stepThreeLabel.setBorder(BorderFactory.createEmptyBorder(5+2,15,5+2,7));\n        add(stepThreeLabel);  \n        \n        mapFilterChoice = new JComboBox(mapFilterChoices);\n        mapFilterChoice.setFont(tufts.vue.gui.GUI.LabelFace);\n        \n        gridBagConstraints.gridwidth = GridBagConstraints.REMAINDER;\n        gridBagConstraints.weightx = 0.0;\n        gridBagConstraints.anchor = GridBagConstraints.WEST;\n        \n        //gridBagConstraints.insets = new Insets(15,5,15,5);\n        \n        //gridBagConstraints.gridwidth = 1;\n        // //gridBagConstraints.gridwidth = GridBagConstraints.REMAINDER;\n        gridBag.setConstraints(mapFilterChoice,gridBagConstraints);\n        add(mapFilterChoice);\n        \n        gridBagConstraints.insets = new Insets(0,0,0,0);\n        \n        //bottomPanel = new JPanel();\n        filterOnBaseMap = new JCheckBox();\n        JLabel filterOnBaseMapMessage = new JLabel(filterOnBaseMapMessageString);\n        ////filterOnBaseMapMessage.setOpaque(false);\n        //bottomPanel.setOpaque(false);\n        //bottomPanel.add(filterOnBaseMap);\n        //bottomPanel.add(filterOnBaseMapMessage);\n        //gridBagConstraints.weighty = 0.0;\n        //gridBagConstraints.anchor = GridBagConstraints.WEST;\n        //gridBagConstraints.gridwidth = GridBagConstraints.REMAINDER;\n        //gridBag.setConstraints(bottomPanel,gridBagConstraints);\n        //add(bottomPanel);\n        \n        \n        //JLabel selectMapsLabel = new JLabel(\"Select maps:\");\n        //selectMapsLabel.setBorder(BorderFactory.createEmptyBorder(0,0,0,8));\n        //gridBagConstraints.gridwidth = 1;\n        //gridBag.setConstraints(selectMapsLabel,gridBagConstraints);\n        //add(selectMapsLabel);\n        \n        //gridBagConstraints.weightx = 1.0;\n        //gridBagConstraints.weighty = 0.0;\n        //gridBagConstraints.fill = GridBagConstraints.HORIZONTAL;\n        //gridBag.setConstraints(fileNameField,gridBagConstraints);\n        //add(fileNameField);\n        \n        \n        //gridBagConstraints.weightx = 0.0;\n        //gridBagConstraints.anchor = GridBagConstraints.WEST;\n        //gridBagConstraints.gridwidth = 1;\n        // //gridBagConstraints.gridwidth = GridBagConstraints.REMAINDER;\n        //gridBag.setConstraints(browseButton,gridBagConstraints);\n        //browseButton.setOpaque(false);\n        //add(browseButton);\n        \n        \n        gridBagConstraints.weightx = 1.0;\n        \n        gridBagConstraints.gridwidth = 1;\n        \n        gridBagConstraints.anchor = GridBagConstraints.EAST;\n        gridBag.setConstraints(filterOnBaseMap,gridBagConstraints);\n        filterOnBaseMap.setOpaque(false);\n        //add(filterOnBaseMap);\n        gridBagConstraints.weightx = 0.0;\n        gridBagConstraints.insets = new Insets(0,0,0,5);\n        gridBagConstraints.gridwidth = GridBagConstraints.REMAINDER;\n        filterOnBaseMapMessage.setForeground(new Color(77,109,109));\n        gridBag.setConstraints(filterOnBaseMapMessage,gridBagConstraints);\n        //add(filterOnBaseMapMessage);\n        gridBagConstraints.insets = new Insets(0,0,0,0);\n        maps = new JTable(new MapTableModel());\n        maps.setRowHeight(maps.getRowHeight()+6);\n        maps.getTableHeader().setReorderingAllowed(false);\n        \n        ((DefaultTableCellRenderer)(maps.getTableHeader().getDefaultRenderer())).setHorizontalAlignment(SwingConstants.LEFT);\n                \n        maps.addMouseListener(new java.awt.event.MouseAdapter() {\n          public void mousePressed(java.awt.event.MouseEvent e)\n          {\n            MapTableModel model = (MapTableModel)maps.getModel();\n            //System.out.println(\"MSP mouse pressed, row column: \" + maps.getSelectedRow() + \",\" + maps.getSelectedColumn());\n            if(maps.getSelectedColumn() == 0)\n            {\n                if(model.isSelected(maps.getSelectedRow()))\n                    model.setSelected(false,maps.getSelectedRow());\n                else\n                    model.setSelected(true,maps.getSelectedRow());\n            }\n            if(maps.getSelectedColumn() == 2)\n            {\n                model.setBaseMapIndex(maps.getSelectedRow());\n            }\n            if(maps.getSelectedColumn() == 3)\n            {\n                deleteDown = true;\n            }\n            else\n            {\n                deleteDown = false;\n            }\n            repaint();\n            \n          }\n          \n          public void mouseReleased(java.awt.event.MouseEvent e)\n          {\n            if(maps.getSelectedColumn() == 3 && ((MapTableModel)maps.getModel()).getMapType(maps.getSelectedRow()) == LOCAL_FILE)\n            {\n                ((MapTableModel)maps.getModel()).localFiles.remove(maps.getSelectedRow());\n                deleteDown = false;\n            }     \n            repaint();\n          }\n          \n        });\n        maps.setDefaultRenderer(Object.class,new MapTableCellRenderer());\n        maps.getColumnModel().getColumn(0).setMinWidth(40);\n        maps.getColumnModel().getColumn(1).setMinWidth(270);\n        maps.getColumnModel().getColumn(2).setMinWidth(40);\n        maps.getColumnModel().getColumn(2).setMaxWidth(45);\n        maps.getColumnModel().getColumn(3).setMinWidth(80);\n        gridBagConstraints.weightx = 1.0;\n        gridBagConstraints.weighty = 1.0;\n        gridBagConstraints.anchor = GridBagConstraints.NORTH;\n        gridBagConstraints.fill = gridBagConstraints.BOTH;\n        scroll = new JScrollPane(maps);\n        //scroll.setViewportBorder(BorderFactory.createEmptyBorder(0,5,0,5));\n        //gridBag.setConstraints(scroll,gridBagConstraints);\n        JPanel scrollPanel = new JPanel(new java.awt.BorderLayout());\n        scrollPanel.setOpaque(false);\n        scrollPanel.setBorder(BorderFactory.createEmptyBorder(15,15,15,15));\n        scrollPanel.add(scroll);\n        gridBag.setConstraints(scrollPanel,gridBagConstraints);\n        //add(scroll);\n        add(scrollPanel);\n        \n    }","id":60349,"modified_method":"private MapsSelectionPanel() \n    {\n        setOpaque(false);\n        \n        if(tufts.Util.isWindowsPlatform())\n        {\n            setOpaque(true);\n            setBackground(java.awt.Color.WHITE);\n        }\n        \n        GridBagLayout gridBag = new GridBagLayout();\n        GridBagConstraints gridBagConstraints = new GridBagConstraints();\n        setLayout(gridBag);\n        \n        //fileNameField = new JTextField(20);\n        browseButton = new JButton(\"Add Maps\");\n        browseButton.addActionListener(new ActionListener()\n        {\n           public void actionPerformed(ActionEvent e)\n           {\n               JFileChooser choose = new JFileChooser();\n               if(lastDirectory!=null)\n                   choose.setCurrentDirectory(lastDirectory);\n               VueFileFilter vff = new VueFileFilter(VueFileFilter.VUE_DESCRIPTION);\n               choose.setFileFilter(vff);\n               choose.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);\n               int cancel = choose.showOpenDialog(MapsSelectionPanel.this);\n               if(cancel == JFileChooser.CANCEL_OPTION)\n                   return;\n               File choice = choose.getSelectedFile();\n               if(choose.getSelectedFile().getParentFile().isDirectory())\n                 lastDirectory = choose.getSelectedFile().getParentFile();\n               if(choice.isDirectory())\n               {\n                  java.io.FileFilter iff = new java.io.FileFilter()\n                  {\n                      public boolean accept(File file)\n                      {\n                          if(file.getName().substring(file.getName().lastIndexOf(\".\")+1,file.getName().length()).equals(\"vue\"))\n                            return true;\n                          else \n                            return false;\n                      }\n                      \n                      public String getDescription()\n                      {\n                          return \"VUE FILE\";\n                      }\n                  };\n                  File[] files =  choice.listFiles(iff);\n                  for(int i=0;i<files.length;i++)\n                  {\n                      File file = files[files.length-1-i];\n                      String name = file.getAbsolutePath();\n                      ((MapTableModel)maps.getModel()).addRow(name);\n                      //String shortName = getShortNameForFile(name); \n                      //fileNameField.setText(shortName);\n                      revalidate();\n                      scroll.getViewport().revalidate();\n                  }\n               }\n               else\n               {    \n                  String name = choice.getAbsolutePath();\n                  ((MapTableModel)maps.getModel()).addRow(name);\n                  //fileNameField.setText(getShortNameForFile(name));\n                  revalidate();\n                  scroll.getViewport().revalidate();\n               }\n           }\n        });\n        VUE.getTabbedPane().addContainerListener(new java.awt.event.ContainerListener()\n        {\n            public void componentAdded(java.awt.event.ContainerEvent e)\n            {\n                //System.out.println(\"MSP: VUE tabbed pane component added \" + e);\n                revalidate();\n            }\n            \n            public void componentRemoved(java.awt.event.ContainerEvent e)\n            {\n                //System.out.println(\"MSP: VUE tabbed pane component removed \" + e);\n                revalidate();\n            }\n        });\n        VUE.getTabbedPane().addChangeListener(new ChangeListener()\n        {\n            public void stateChanged(javax.swing.event.ChangeEvent e)\n            {\n                //System.out.println(\"MSP: VUE tabbed pane change event \" + e);\n            }\n        });\n        \n        VUE.getTabbedPane().addPropertyChangeListener(new PropertyChangeListener()\n        {\n            public void propertyChange(PropertyChangeEvent e)\n            {\n                revalidate();\n                repaint();\n                scroll.getViewport().revalidate();\n                //System.out.println(\"MSP: VUE tabbed pane property change event \" + e.getPropertyName());\n            }\n        });\n\n        JLabel stepOneLabel = new JLabel(stepOneMessage);\n        stepOneLabel.setFont(tufts.vue.gui.GUI.LabelFace);\n        //gridBagConstraints.gridwidth = GridBagConstraints.REMAINDER;\n        gridBagConstraints.anchor = GridBagConstraints.NORTHWEST;\n        gridBag.setConstraints(stepOneLabel,gridBagConstraints);\n        //stepOneLabel.setBorder(BorderFactory.createEmptyBorder(15,0,0,0));\n        stepOneLabel.setBorder(BorderFactory.createEmptyBorder(5+2,15,5+2,7));\n        add(stepOneLabel);\n        \n        gridBagConstraints.gridwidth = GridBagConstraints.REMAINDER;\n        gridBagConstraints.weightx = 0.0;\n        gridBagConstraints.anchor = GridBagConstraints.WEST;\n        \n        //gridBagConstraints.insets = new Insets(3,0,0,0);\n        \n        //gridBagConstraints.gridwidth = 1;\n        // //gridBagConstraints.gridwidth = GridBagConstraints.REMAINDER;\n        gridBag.setConstraints(browseButton,gridBagConstraints);\n        browseButton.setOpaque(false);\n        browseButton.setFont(tufts.vue.gui.GUI.LabelFace);\n        add(browseButton);\n        \n        gridBagConstraints.insets = new Insets(0,0,0,0);\n        \n        JLabel stepTwoLabel = new JLabel(stepTwoMessage);\n        stepTwoLabel.setFont(tufts.vue.gui.GUI.LabelFace);\n        //gridBagConstraints.gridwidth = GridBagConstraints.REMAINDER;\n        gridBag.setConstraints(stepTwoLabel,gridBagConstraints);\n        stepTwoLabel.setBorder(BorderFactory.createEmptyBorder(5+2,15,5+2,5));\n        add(stepTwoLabel);  \n\n        JLabel stepThreeLabel = new JLabel(stepThreeMessage);\n        stepThreeLabel.setFont(tufts.vue.gui.GUI.LabelFace);\n        //gridBagConstraints.gridwidth = GridBagConstraints.REMAINDER;\n        gridBagConstraints.gridwidth = 1;\n        gridBag.setConstraints(stepThreeLabel,gridBagConstraints);\n        stepThreeLabel.setBorder(BorderFactory.createEmptyBorder(5+2,15,5+2,7));\n        add(stepThreeLabel);  \n        \n        mapFilterChoice = new JComboBox(mapFilterChoices);\n        mapFilterChoice.setFont(tufts.vue.gui.GUI.LabelFace);\n        \n        gridBagConstraints.gridwidth = GridBagConstraints.REMAINDER;\n        gridBagConstraints.weightx = 0.0;\n        gridBagConstraints.anchor = GridBagConstraints.WEST;\n        \n        //gridBagConstraints.insets = new Insets(15,5,15,5);\n        \n        //gridBagConstraints.gridwidth = 1;\n        // //gridBagConstraints.gridwidth = GridBagConstraints.REMAINDER;\n        gridBag.setConstraints(mapFilterChoice,gridBagConstraints);\n        add(mapFilterChoice);\n        \n        gridBagConstraints.insets = new Insets(0,0,0,0);\n        \n        //bottomPanel = new JPanel();\n        filterOnBaseMap = new JCheckBox();\n        JLabel filterOnBaseMapMessage = new JLabel(filterOnBaseMapMessageString);\n        ////filterOnBaseMapMessage.setOpaque(false);\n        //bottomPanel.setOpaque(false);\n        //bottomPanel.add(filterOnBaseMap);\n        //bottomPanel.add(filterOnBaseMapMessage);\n        //gridBagConstraints.weighty = 0.0;\n        //gridBagConstraints.anchor = GridBagConstraints.WEST;\n        //gridBagConstraints.gridwidth = GridBagConstraints.REMAINDER;\n        //gridBag.setConstraints(bottomPanel,gridBagConstraints);\n        //add(bottomPanel);\n        \n        \n        //JLabel selectMapsLabel = new JLabel(\"Select maps:\");\n        //selectMapsLabel.setBorder(BorderFactory.createEmptyBorder(0,0,0,8));\n        //gridBagConstraints.gridwidth = 1;\n        //gridBag.setConstraints(selectMapsLabel,gridBagConstraints);\n        //add(selectMapsLabel);\n        \n        //gridBagConstraints.weightx = 1.0;\n        //gridBagConstraints.weighty = 0.0;\n        //gridBagConstraints.fill = GridBagConstraints.HORIZONTAL;\n        //gridBag.setConstraints(fileNameField,gridBagConstraints);\n        //add(fileNameField);\n        \n        \n        //gridBagConstraints.weightx = 0.0;\n        //gridBagConstraints.anchor = GridBagConstraints.WEST;\n        //gridBagConstraints.gridwidth = 1;\n        // //gridBagConstraints.gridwidth = GridBagConstraints.REMAINDER;\n        //gridBag.setConstraints(browseButton,gridBagConstraints);\n        //browseButton.setOpaque(false);\n        //add(browseButton);\n        \n        \n        gridBagConstraints.weightx = 1.0;\n        \n        gridBagConstraints.gridwidth = 1;\n        \n        gridBagConstraints.anchor = GridBagConstraints.EAST;\n        gridBag.setConstraints(filterOnBaseMap,gridBagConstraints);\n        filterOnBaseMap.setOpaque(false);\n        //add(filterOnBaseMap);\n        gridBagConstraints.weightx = 0.0;\n        gridBagConstraints.insets = new Insets(0,0,0,5);\n        gridBagConstraints.gridwidth = GridBagConstraints.REMAINDER;\n        filterOnBaseMapMessage.setForeground(new Color(77,109,109));\n        gridBag.setConstraints(filterOnBaseMapMessage,gridBagConstraints);\n        //add(filterOnBaseMapMessage);\n        gridBagConstraints.insets = new Insets(0,0,0,0);\n        maps = new JTable(new MapTableModel());\n        maps.setRowHeight(maps.getRowHeight()+6);\n        maps.getTableHeader().setReorderingAllowed(false);\n        \n        ((DefaultTableCellRenderer)(maps.getTableHeader().getDefaultRenderer())).setHorizontalAlignment(SwingConstants.LEFT);\n                \n        maps.addMouseListener(new java.awt.event.MouseAdapter() {\n          public void mousePressed(java.awt.event.MouseEvent e)\n          {\n            MapTableModel model = (MapTableModel)maps.getModel();\n            //System.out.println(\"MSP mouse pressed, row column: \" + maps.getSelectedRow() + \",\" + maps.getSelectedColumn());\n            if(maps.getSelectedColumn() == 0)\n            {\n                if(model.isSelected(maps.getSelectedRow()))\n                    model.setSelected(false,maps.getSelectedRow());\n                else\n                    model.setSelected(true,maps.getSelectedRow());\n            }\n            if(maps.getSelectedColumn() == 2)\n            {\n                model.setBaseMapIndex(maps.getSelectedRow());\n            }\n            if(maps.getSelectedColumn() == 3)\n            {\n                deleteDown = true;\n            }\n            else\n            {\n                deleteDown = false;\n            }\n            repaint();\n            \n          }\n          \n          public void mouseReleased(java.awt.event.MouseEvent e)\n          {\n            if(maps.getSelectedColumn() == 3 && ((MapTableModel)maps.getModel()).getMapType(maps.getSelectedRow()) == LOCAL_FILE)\n            {\n                ((MapTableModel)maps.getModel()).localFiles.remove(maps.getSelectedRow());\n                deleteDown = false;\n            }     \n            repaint();\n          }\n          \n        });\n        maps.setDefaultRenderer(Object.class,new MapTableCellRenderer());\n        maps.getColumnModel().getColumn(0).setMinWidth(35);\n        maps.getColumnModel().getColumn(0).setMaxWidth(35);\n        maps.getColumnModel().getColumn(1).setMinWidth(250);\n        maps.getColumnModel().getColumn(2).setMinWidth(35);\n        //maps.getColumnModel().getColumn(2).setMaxWidth(45);\n        maps.getColumnModel().getColumn(3).setMinWidth(80);\n        gridBagConstraints.weightx = 1.0;\n        gridBagConstraints.weighty = 1.0;\n        gridBagConstraints.anchor = GridBagConstraints.NORTH;\n        gridBagConstraints.fill = gridBagConstraints.BOTH;\n        scroll = new JScrollPane(maps);\n        //scroll.setViewportBorder(BorderFactory.createEmptyBorder(0,5,0,5));\n        //gridBag.setConstraints(scroll,gridBagConstraints);\n        JPanel scrollPanel = new JPanel(new java.awt.BorderLayout());\n        scrollPanel.setOpaque(false);\n        scrollPanel.setBorder(BorderFactory.createEmptyBorder(15,15,15,15));\n        scrollPanel.add(scroll);\n        gridBag.setConstraints(scrollPanel,gridBagConstraints);\n        //add(scroll);\n        add(scrollPanel);\n        \n    }","commit_id":"976c5c0368fa3d3838704cae8b58f5095133ebc7","url":"https://github.com/VUE/VUE"},{"original_method":"public VisualizationSettingsPanel() \n    {\n        \n        weightPanel = new WeightVisualizationSettingsPanel(weightParameterChoiceDisplayedHere);\n        weightParameterChoice = weightPanel.getParameterCombo();\n        \n        setOpaque(false);\n        gridBag = new GridBagLayout();\n        gridBagConstraints = new GridBagConstraints();\n        \n        gridBagConstraints.weighty =0.0;\n        \n        setLayout(gridBag);\n        \n        \n        String[] choices = {\"Weight\",\"Vote\"};\n        visualizationChoice = new JComboBox(choices);\n        visualizationChoice.addActionListener(this);\n        \n        JLabel visualizationSettingsChoiceLabel = new JLabel(visualizationSettingsChoiceMessage);\n        \n        gridBagConstraints.weightx = 0.5;\n        \n        //gridBagConstraints.anchor = GridBagConstraints.NORTHWEST;\n        gridBagConstraints.anchor = GridBagConstraints.EAST;\n        gridBagConstraints.insets = new java.awt.Insets(15,10,15,8);\n        gridBag.setConstraints(visualizationSettingsChoiceLabel,gridBagConstraints);\n        add(visualizationSettingsChoiceLabel);\n        gridBagConstraints.insets = new java.awt.Insets(0,0,0,0);\n        \n        //gridBagConstraints.weightx = 0.0;\n        gridBagConstraints.weightx = 0.5;\n        gridBagConstraints.anchor = GridBagConstraints.WEST;\n        //gridBagConstraints.anchor = GridBagConstraints.CENTER;\n        gridBagConstraints.gridwidth = GridBagConstraints.REMAINDER;\n        gridBag.setConstraints(visualizationChoice,gridBagConstraints);\n        add(visualizationChoice);\n           \n        setUpParameterChoiceGUI();        \n     \n        gridBagConstraints.anchor = GridBagConstraints.NORTHWEST;\n        gridBagConstraints.weighty = 1.0;\n        //gridBagConstraints.insets = new java.awt.Insets(0,0,60,0);\n        gridBag.setConstraints(votePanel,gridBagConstraints);\n        gridBag.setConstraints(weightPanel,gridBagConstraints);\n        add(weightPanel);\n        \n    }","id":60350,"modified_method":"public VisualizationSettingsPanel() \n    {\n        \n        setBorder(BorderFactory.createEmptyBorder(10,10,10,10));\n        \n        weightPanel = new WeightVisualizationSettingsPanel(weightParameterChoiceDisplayedHere);\n        //weightPanel.setBorder(BorderFactory.createEmptyBorder(15,0,0,0));\n        weightParameterChoice = weightPanel.getParameterCombo();\n        \n        setOpaque(false);\n        \n        if(tufts.Util.isWindowsPlatform())\n        {\n            setOpaque(true);\n            setBackground(java.awt.Color.WHITE);\n        }\n        \n        gridBag = new GridBagLayout();\n        gridBagConstraints = new GridBagConstraints();\n        \n        gridBagConstraints.weighty =0.0;\n        \n        setLayout(gridBag);\n        \n        \n        final String[] choices = {\"Weight\",\"Vote\"};\n        visualizationChoice = new JComboBox(choices)\n        {\n            public java.awt.Dimension getMinimumSize()\n            {\n               return new java.awt.Dimension(/*getGraphics().getFontMetrics().charsWidth(choices[0].toCharArray(),0,choices[0].length())+*/70,\n                                             super.getPreferredSize().height);      \n            }\n        };\n        visualizationChoice.setFont(tufts.vue.gui.GUI.LabelFace);\n        visualizationChoice.addActionListener(this);\n        \n        JLabel visualizationSettingsChoiceLabel = new JLabel(visualizationSettingsChoiceMessage);\n        visualizationSettingsChoiceLabel.setFont(tufts.vue.gui.GUI.LabelFace);\n        \n        gridBagConstraints.weightx = 0.5;\n        \n        //gridBagConstraints.anchor = GridBagConstraints.NORTHWEST;\n        gridBagConstraints.anchor = GridBagConstraints.EAST;\n        gridBagConstraints.insets = new java.awt.Insets(15,10,15,8);\n        gridBag.setConstraints(visualizationSettingsChoiceLabel,gridBagConstraints);\n        add(visualizationSettingsChoiceLabel);\n        gridBagConstraints.insets = new java.awt.Insets(0,0,0,0);\n        \n        //gridBagConstraints.weightx = 0.0;\n        gridBagConstraints.weightx = 0.5;\n        gridBagConstraints.anchor = GridBagConstraints.WEST;\n        //gridBagConstraints.anchor = GridBagConstraints.CENTER;\n        //gridBagConstraints.fill = GridBagConstraints.HORIZONTAL;\n        gridBagConstraints.gridwidth = GridBagConstraints.REMAINDER;\n        gridBag.setConstraints(visualizationChoice,gridBagConstraints);\n        add(visualizationChoice);\n           \n        setUpParameterChoiceGUI();        \n     \n        gridBagConstraints.anchor = GridBagConstraints.NORTHWEST;\n        gridBagConstraints.weighty = 1.0;\n        //gridBagConstraints.insets = new java.awt.Insets(0,0,60,0);\n        gridBag.setConstraints(votePanel,gridBagConstraints);\n        gridBag.setConstraints(weightPanel,gridBagConstraints);\n        add(weightPanel);\n        \n    }","commit_id":"976c5c0368fa3d3838704cae8b58f5095133ebc7","url":"https://github.com/VUE/VUE"},{"original_method":"public void setUpParameterChoiceGUI()\n    {\n        gridBagConstraints.weighty = 0.0;\n        gridBagConstraints.gridwidth = GridBagConstraints.RELATIVE;;\n        weightParameterChoiceLabel = new JLabel(\"Set parameters for:\");\n        //gridBagConstraints.anchor = GridBagConstraints.NORTHWEST;\n        gridBagConstraints.anchor = GridBagConstraints.EAST;\n        gridBagConstraints.insets = new java.awt.Insets(15,10,15,8);\n        gridBag.setConstraints(weightParameterChoiceLabel,gridBagConstraints);\n        add(weightParameterChoiceLabel);\n        gridBagConstraints.insets = new java.awt.Insets(0,0,0,0);\n        \n        //gridBagConstraints.weightx = 0.0;\n        gridBagConstraints.weightx = 0.5;\n        gridBagConstraints.anchor = GridBagConstraints.WEST;\n        //gridBagConstraints.anchor = GridBagConstraints.CENTER;\n        gridBagConstraints.gridwidth = GridBagConstraints.REMAINDER;\n        gridBag.setConstraints(weightParameterChoice,gridBagConstraints);\n        add(weightParameterChoice); \n    }","id":60351,"modified_method":"public void setUpParameterChoiceGUI()\n    {\n        gridBagConstraints.weighty = 0.0;\n        gridBagConstraints.gridwidth = GridBagConstraints.RELATIVE;;\n        weightParameterChoiceLabel = new JLabel(\"Set parameters for:\");\n        weightParameterChoiceLabel.setFont(tufts.vue.gui.GUI.LabelFace);\n        //gridBagConstraints.anchor = GridBagConstraints.NORTHWEST;\n        gridBagConstraints.anchor = GridBagConstraints.EAST;\n        gridBagConstraints.insets = new java.awt.Insets(15,10,15,8);\n        gridBag.setConstraints(weightParameterChoiceLabel,gridBagConstraints);\n        add(weightParameterChoiceLabel);\n        gridBagConstraints.insets = new java.awt.Insets(0,0,0,0);\n        \n        //gridBagConstraints.weightx = 0.0;\n        gridBagConstraints.weightx = 0.5;\n        gridBagConstraints.anchor = GridBagConstraints.WEST;\n        //gridBagConstraints.anchor = GridBagConstraints.CENTER;\n        gridBagConstraints.gridwidth = GridBagConstraints.REMAINDER;\n        gridBag.setConstraints(weightParameterChoice,gridBagConstraints);\n        weightParameterChoice.setFont(tufts.vue.gui.GUI.LabelFace);\n        add(weightParameterChoice); \n    }","commit_id":"976c5c0368fa3d3838704cae8b58f5095133ebc7","url":"https://github.com/VUE/VUE"},{"original_method":"public void setUpGui()\n     {\n     \n         setOpaque(false); \n         //setOpaque(true);\n         //setBackground(java.awt.Color.BLUE);\n         \n        String[] parameterChoices = {\"Nodes\",\"Links\"};\n        \n       tufts.vue.PolygonIcon lineIcon = new tufts.vue.PolygonIcon(new Color(153,153,153));\n       /*{\n           public java.awt.Dimension getPreferredSize()\n           {\n               return new java.awt.Dimension(getParent().getWidth(),1);\n           }\n       };*/\n        // tufts.vue.PolygonIcon lineIcon = new tufts.vue.PolygonIcon(Color.BLACK);\n        lineIcon.setIconWidth(500);\n        lineIcon.setIconHeight(1);\n        \n        parameterChoice = new JComboBox(parameterChoices);\n        JLabel intervalNumberChoiceMessage = new JLabel(intervalChoiceMessageString,JLabel.RIGHT);\n        Integer[] intervalNumberChoices = {3,4,5,6,7,8,9,10};\n        intervalNumberChoice = new JComboBox(intervalNumberChoices)\n        {\n            public java.awt.Dimension getPreferredSize()\n            {\n                return new java.awt.Dimension(30,30);\n            }\n        };\n        intervalNumberChoice.setSelectedItem(5);\n        JLabel paletteChoiceMessage = new JLabel(paletteChoiceMessageString,JLabel.RIGHT);\n        Colors[] colors = {Colors.one,Colors.two,Colors.three,Colors.four,Colors.five,Colors.six};\n        paletteChoice = new JComboBox(colors);\n        paletteChoice.setRenderer(new ColorsComboBoxRenderer());\n        //paletteChoice.setModel(... need way to express both style loaded and color brewer choices?\n        nodeModel = new IntervalListModel();\n        linkModel = new IntervalListModel();\n        intervalList = new JTable()\n        {\n            public java.awt.Dimension getMinimumSize()\n            {\n                return new java.awt.Dimension(100,300);\n            }\n        };\n        //intervalList.setPreferredSize(new java.awt.Dimension(535,200));\n        intervalList.setDefaultRenderer(PercentageInterval.class,new PercentageIntervalRenderer());\n        intervalList.setDefaultEditor(PercentageInterval.class,new PercentageIntervalEditor());\n        intervalList.setDefaultRenderer(IntervalStylePreview.class,new IntervalStylePreviewRenderer());\n        intervalList.setDefaultEditor(IntervalStylePreview.class,new IntervalStylePreviewEditor());\n\n        //$\n           intervalList.setRowHeight(30);\n        //$\n\n        loadSettings();\n        \n        setModel();\n        \n        GridBagLayout gridBag = new GridBagLayout();\n        GridBagConstraints c = new GridBagConstraints();\n        setLayout(gridBag);\n        \n        //first row\n        c.fill = GridBagConstraints.BOTH;\n        c.anchor = GridBagConstraints.EAST;\n        c.insets = new Insets(0,0,0,5);\n        gridBag.setConstraints(parameterChoiceMessage,c);\n        \n        if(! parameterChoiceDisplayedInOtherPanel)\n          add(parameterChoiceMessage);\n        \n        \n        c.insets = new Insets(0,0,0,0);\n        c.anchor = GridBagConstraints.WEST;\n        //c.weightx = 1.0;\n        c.gridwidth = GridBagConstraints.REMAINDER;\n        gridBag.setConstraints(parameterChoice,c);\n        \n        if(! parameterChoiceDisplayedInOtherPanel)\n          add(parameterChoice);\n        \n\n        //c.weightx = 1.0;\n        //c.gridwidth = GridBagConstraints.REMAINDER;\n        //gridBag.setConstraints(helpLabel,c);\n        //add(helpLabel);\n        \n        \n        \n        JLabel lineLabel = new JLabel(lineIcon);\n        c.insets = new Insets(15,0,15,0);\n        gridBag.setConstraints(lineLabel,c);\n        add(lineLabel);\n        \n        //second row\n        //c.weightx = 0.0;\n        //c.gridwidth = 1;\n        //c.anchor = GridBagConstraints.EAST;\n        //gridBag.setConstraints(intervalNumberChoiceMessage,c);\n        //add(intervalNumberChoiceMessage);\n        //c.gridwidth = GridBagConstraints.REMAINDER;\n        //c.anchor = GridBagConstraints.WEST;\n        //gridBag.setConstraints(intervalNumberChoice,c);\n        //add(intervalNumberChoice);\n        \n        //third row\n        c.weightx = 0.0;\n        c.weighty = 0.0;\n        c.gridwidth = 1;\n        c.anchor = GridBagConstraints.EAST;\n        c.insets = new Insets(0,0,0,5);\n        gridBag.setConstraints(paletteChoiceMessage,c);\n        add(paletteChoiceMessage);\n        c.insets = new Insets(0,0,0,170);\n        c.gridwidth = GridBagConstraints.REMAINDER;\n        c.anchor = GridBagConstraints.WEST;\n        gridBag.setConstraints(paletteChoice,c);\n        add(paletteChoice);\n        c.insets = new Insets(0,0,0,0);\n        \n        //table\n        //c.fill = GridBagConstraints.NONE;\n        intervalList.setPreferredScrollableViewportSize(new java.awt.Dimension(200,300));\n        JScrollPane scroll = new JScrollPane(intervalList)\n        {\n           public java.awt.Dimension getMinimumSize()\n           {\n               return new java.awt.Dimension(100,350);\n           }\n        };\n       // scroll.setPreferredSize(new java.awt.Dimension(100,300));\n        //c.gridx = 0;\n        //c.gridy = 2;\n        //c.gridwidth = 3;\n        //$\n          c.insets = new Insets(25,0,25,0);\n          c.weightx = 1.0;\n          c.weighty = 1.0;\n        //$\n        gridBag.setConstraints(scroll,c);\n        add(scroll);\n        \n        //set up event handling within this panel\n        parameterChoice.addActionListener(this);\n        paletteChoice.addActionListener(this);\n        \n    }","id":60352,"modified_method":"public void setUpGui()\n     {\n     \n         setOpaque(false); \n         //setOpaque(true);\n         //setBackground(java.awt.Color.BLUE);\n         \n        String[] parameterChoices = {\"Nodes\",\"Links\"};\n        \n       tufts.vue.PolygonIcon lineIcon = new tufts.vue.PolygonIcon(new Color(153,153,153));\n       /*{\n           public java.awt.Dimension getPreferredSize()\n           {\n               return new java.awt.Dimension(getParent().getWidth(),1);\n           }\n       };*/\n        // tufts.vue.PolygonIcon lineIcon = new tufts.vue.PolygonIcon(Color.BLACK);\n        lineIcon.setIconWidth(500);\n        lineIcon.setIconHeight(1);\n        \n        parameterChoice = new JComboBox(parameterChoices)\n        {\n            public java.awt.Dimension getMinimumSize()\n            {\n               return new java.awt.Dimension(/*getGraphics().getFontMetrics().charsWidth(choices[0].toCharArray(),0,choices[0].length())+*/70,\n                                             super.getPreferredSize().height);      \n            }\n        };\n        JLabel intervalNumberChoiceMessage = new JLabel(intervalChoiceMessageString,JLabel.RIGHT);\n        Integer[] intervalNumberChoices = {3,4,5,6,7,8,9,10};\n        intervalNumberChoice = new JComboBox(intervalNumberChoices)\n        {\n            public java.awt.Dimension getPreferredSize()\n            {\n                return new java.awt.Dimension(30,30);\n            }\n        };\n        intervalNumberChoice.setSelectedItem(5);\n        JLabel paletteChoiceMessage = new JLabel(paletteChoiceMessageString,JLabel.RIGHT);\n        paletteChoiceMessage.setFont(tufts.vue.gui.GUI.LabelFace);\n        Colors[] colors = {Colors.one,Colors.two,Colors.three,Colors.four,Colors.five,Colors.six};\n        paletteChoice = new JComboBox(colors);\n        paletteChoice.setRenderer(new ColorsComboBoxRenderer());\n        //paletteChoice.setModel(... need way to express both style loaded and color brewer choices?\n        nodeModel = new IntervalListModel();\n        linkModel = new IntervalListModel();\n        intervalList = new JTable()\n        {\n            public java.awt.Dimension getMinimumSize()\n            {\n                return new java.awt.Dimension(100,300);\n            }\n        };\n        //intervalList.setPreferredSize(new java.awt.Dimension(535,200));\n        intervalList.setDefaultRenderer(PercentageInterval.class,new PercentageIntervalRenderer());\n        intervalList.setDefaultEditor(PercentageInterval.class,new PercentageIntervalEditor());\n        intervalList.setDefaultRenderer(IntervalStylePreview.class,new IntervalStylePreviewRenderer());\n        intervalList.setDefaultEditor(IntervalStylePreview.class,new IntervalStylePreviewEditor());\n\n        //$\n           intervalList.setRowHeight(30);\n        //$\n\n        loadSettings();\n        \n        setModel();\n        \n        GridBagLayout gridBag = new GridBagLayout();\n        GridBagConstraints c = new GridBagConstraints();\n        setLayout(gridBag);\n        \n        //first row\n        c.fill = GridBagConstraints.BOTH;\n        c.anchor = GridBagConstraints.EAST;\n        c.insets = new Insets(0,0,0,5);\n        gridBag.setConstraints(parameterChoiceMessage,c);\n        \n        if(! parameterChoiceDisplayedInOtherPanel)\n          add(parameterChoiceMessage);\n        \n        \n        c.insets = new Insets(0,0,0,0);\n        c.anchor = GridBagConstraints.WEST;\n        //c.weightx = 1.0;\n        c.gridwidth = GridBagConstraints.REMAINDER;\n        gridBag.setConstraints(parameterChoice,c);\n        \n        if(! parameterChoiceDisplayedInOtherPanel)\n          add(parameterChoice);\n        \n\n        //c.weightx = 1.0;\n        //c.gridwidth = GridBagConstraints.REMAINDER;\n        //gridBag.setConstraints(helpLabel,c);\n        //add(helpLabel);\n        \n        \n        \n        JLabel lineLabel = new JLabel(lineIcon);\n        c.insets = new Insets(15,0,15,0);\n        gridBag.setConstraints(lineLabel,c);\n        add(lineLabel);\n        \n        //second row\n        //c.weightx = 0.0;\n        //c.gridwidth = 1;\n        //c.anchor = GridBagConstraints.EAST;\n        //gridBag.setConstraints(intervalNumberChoiceMessage,c);\n        //add(intervalNumberChoiceMessage);\n        //c.gridwidth = GridBagConstraints.REMAINDER;\n        //c.anchor = GridBagConstraints.WEST;\n        //gridBag.setConstraints(intervalNumberChoice,c);\n        //add(intervalNumberChoice);\n        \n        //third row\n        c.weightx = 0.0;\n        c.weighty = 0.0;\n        c.gridwidth = 1;\n        c.anchor = GridBagConstraints.EAST;\n        c.insets = new Insets(0,0,0,5);\n        gridBag.setConstraints(paletteChoiceMessage,c);\n        add(paletteChoiceMessage);\n        c.insets = new Insets(0,0,0,170);\n        c.gridwidth = GridBagConstraints.REMAINDER;\n        c.anchor = GridBagConstraints.WEST;\n        gridBag.setConstraints(paletteChoice,c);\n        add(paletteChoice);\n        c.insets = new Insets(0,0,0,0);\n        \n        //table\n        //c.fill = GridBagConstraints.NONE;\n        intervalList.setPreferredScrollableViewportSize(new java.awt.Dimension(200,300));\n        JScrollPane scroll = new JScrollPane(intervalList)\n        {\n           public java.awt.Dimension getMinimumSize()\n           {\n               return new java.awt.Dimension(100,350);\n           }\n        };\n       // scroll.setPreferredSize(new java.awt.Dimension(100,300));\n        //c.gridx = 0;\n        //c.gridy = 2;\n        //c.gridwidth = 3;\n        //$\n          c.insets = new Insets(25,0,25,0);\n          c.weightx = 1.0;\n          c.weighty = 1.0;\n        //$\n        gridBag.setConstraints(scroll,c);\n        add(scroll);\n        \n        //set up event handling within this panel\n        parameterChoice.addActionListener(this);\n        paletteChoice.addActionListener(this);\n        \n    }","commit_id":"976c5c0368fa3d3838704cae8b58f5095133ebc7","url":"https://github.com/VUE/VUE"},{"original_method":"public void adjustHeaderTableColumnModel() {\n        if (searchHeaderTbl == null)\n            return;\n        int editorWidth = searchHeaderTbl.getWidth();\n        if (searchHeaderTbl.getModel().getColumnCount() == 3) {    \n            searchHeaderTbl.getColumnModel().getColumn(0).setCellRenderer(\n                    new SearchTermsTableHeaderRenderer());\n            searchHeaderTbl.getColumnModel().getColumn(1).setCellRenderer(\n                    new ComboBoxAndOrRenderer(andOrCmbBox));            \n            \n            searchHeaderTbl.getColumnModel().getColumn(2).setCellRenderer(\n                    new SearchTermsTableHeaderRenderer());\n            \n            searchHeaderTbl.getColumnModel().getColumn(1).setCellEditor(\n                    new ComboBoxAndOrEditor(andOrCmbBox));\n            searchHeaderTbl.getColumnModel().getColumn(2).setCellEditor(\n                    new AddButtonTableCellEditor());\n            \n            \n            searchHeaderTbl.getColumnModel().getColumn(1).setMaxWidth(80);\n            searchHeaderTbl.getColumnModel().getColumn(1).setMinWidth(80);\n            searchHeaderTbl.getColumnModel().getColumn(2).setMaxWidth(40);\n            searchHeaderTbl.getColumnModel().getColumn(2).setMinWidth(40);\n\n        } else if (searchHeaderTbl.getModel().getColumnCount() == 4) {\n        \n            searchHeaderTbl.getColumnModel().getColumn(0).setCellRenderer(\n                    new SearchTermsTableHeaderRenderer());\n            searchHeaderTbl.getColumnModel().getColumn(1).setCellRenderer(\n                    new SearchTermsTableHeaderRenderer());\n            searchHeaderTbl.getColumnModel().getColumn(2).setCellRenderer(\n                    new ComboBoxAndOrRenderer(andOrCmbBox));            \n            searchHeaderTbl.getColumnModel().getColumn(3).setCellRenderer(\n                    new SearchTermsTableHeaderRenderer());            \n            searchHeaderTbl.getColumnModel().getColumn(2).setCellEditor(\n                    new ComboBoxAndOrEditor(andOrCmbBox));\n            searchHeaderTbl.getColumnModel().getColumn(3).setCellEditor(\n                    new AddButtonTableCellEditor());\n            searchHeaderTbl.getColumnModel().getColumn(0).setPreferredWidth(145);\n            searchHeaderTbl.getColumnModel().getColumn(2).setMaxWidth(60);\n            searchHeaderTbl.getColumnModel().getColumn(2).setMinWidth(60);            \n            searchHeaderTbl.getColumnModel().getColumn(3).setMaxWidth(40);\n            searchHeaderTbl.getColumnModel().getColumn(3).setMinWidth(40);\n        }\n    }","id":60353,"modified_method":"public void adjustHeaderTableColumnModel() {\n        if (searchHeaderTbl == null)\n            return;\n        int editorWidth = searchHeaderTbl.getWidth();\n        if (searchHeaderTbl.getModel().getColumnCount() == 3) {    \n            searchHeaderTbl.getColumnModel().getColumn(0).setCellRenderer(\n                    new SearchTermsTableHeaderRenderer());\n            searchHeaderTbl.getColumnModel().getColumn(1).setCellRenderer(\n                    new ComboBoxAndOrRenderer(andOrCmbBox));            \n            \n            searchHeaderTbl.getColumnModel().getColumn(2).setCellRenderer(\n                    new SearchTermsTableHeaderRenderer());\n            \n            searchHeaderTbl.getColumnModel().getColumn(1).setCellEditor(\n                    new ComboBoxAndOrEditor(andOrCmbBox));\n            searchHeaderTbl.getColumnModel().getColumn(2).setCellEditor(\n                    new AddButtonTableCellEditor());\n            \n           if(Util.isMacLeopard()) {\n        \t   searchHeaderTbl.getColumnModel().getColumn(1).setMaxWidth(75);\n        \t   searchHeaderTbl.getColumnModel().getColumn(1).setMinWidth(75);\n           }else{\n        \t   searchHeaderTbl.getColumnModel().getColumn(1).setMaxWidth(60);\n        \t   searchHeaderTbl.getColumnModel().getColumn(1).setMinWidth(60);\n           }\n            searchHeaderTbl.getColumnModel().getColumn(2).setMaxWidth(40);\n            searchHeaderTbl.getColumnModel().getColumn(2).setMinWidth(40);\n\n        } else if (searchHeaderTbl.getModel().getColumnCount() == 4) {\n        \n            searchHeaderTbl.getColumnModel().getColumn(0).setCellRenderer(\n                    new SearchTermsTableHeaderRenderer());\n            searchHeaderTbl.getColumnModel().getColumn(1).setCellRenderer(\n                    new SearchTermsTableHeaderRenderer());\n            searchHeaderTbl.getColumnModel().getColumn(2).setCellRenderer(\n                    new ComboBoxAndOrRenderer(andOrCmbBox));            \n            searchHeaderTbl.getColumnModel().getColumn(3).setCellRenderer(\n                    new SearchTermsTableHeaderRenderer());            \n            searchHeaderTbl.getColumnModel().getColumn(2).setCellEditor(\n                    new ComboBoxAndOrEditor(andOrCmbBox));\n            searchHeaderTbl.getColumnModel().getColumn(3).setCellEditor(\n                    new AddButtonTableCellEditor());\n            searchHeaderTbl.getColumnModel().getColumn(0).setPreferredWidth(145);\n            searchHeaderTbl.getColumnModel().getColumn(2).setMaxWidth(60);\n            searchHeaderTbl.getColumnModel().getColumn(2).setMinWidth(60);            \n            searchHeaderTbl.getColumnModel().getColumn(3).setMaxWidth(40);\n            searchHeaderTbl.getColumnModel().getColumn(3).setMinWidth(40);\n        }\n    }","commit_id":"c37f832cc9b862bb86cb1e7051d4ae3ec8def2f7","url":"https://github.com/VUE/VUE"},{"original_method":"/**\n     * Build out the Base directory (if needed)\n     * \n     * @return true if base directory was changed, false if left unchanged.\n     * @throws IOException\n     */\n    public boolean build() throws IOException\n    {\n        Modules modules = startArgs.getAllModules();\n        boolean dirty = false;\n\n        String dirSource = \"<add-to-startd>\";\n        String iniSource = \"<add-to-start-ini>\";\n\n        int count = 0;\n        count += modules.enableAll(startArgs.getAddToStartdIni(),dirSource);\n        count += modules.enableAll(startArgs.getAddToStartIni(),iniSource);\n\n        Matcher startDMatcher = new AndMatcher(new EnabledMatcher(),new UniqueSourceMatcher(dirSource));\n        Matcher startIniMatcher = new AndMatcher(new EnabledMatcher(),new UniqueSourceMatcher(iniSource));\n\n        // look for ambiguous declaration in 2 places\n        Matcher ambiguousMatcher = new AndMatcher(new EnabledMatcher(),new SourceSetMatcher(dirSource,iniSource));\n        List<Module> ambiguous = modules.getMatching(ambiguousMatcher);\n\n        if (ambiguous.size() > 0)\n        {\n            StringBuilder err = new StringBuilder();\n            err.append(\"Unable to add \");\n            err.append(ambiguous.size());\n            err.append(\" module\");\n            if (ambiguous.size() > 1)\n            {\n                err.append('s');\n            }\n            err.append(\" (found declared via both --add-to-start and --add-to-startd): [\");\n            for (int i = 0; i < ambiguous.size(); i++)\n            {\n                if (i > 0)\n                {\n                    err.append(\", \");\n                }\n                err.append(ambiguous.get(i).getName());\n            }\n            err.append(']');\n            throw new RuntimeException(err.toString());\n        }\n\n        StartLog.debug(\"Adding %s new module(s)\",count);\n\n        // Acknowledge Licenses\n        ackLicenses();\n\n        // Collect specific modules to enable\n        List<Module> startDModules = modules.getMatching(startDMatcher);\n        List<Module> startIniModules = modules.getMatching(startIniMatcher);\n\n        List<FileArg> files = new ArrayList<FileArg>();\n\n        if (!startDModules.isEmpty())\n        {\n            StartDirBuilder builder = new StartDirBuilder(this);\n            for (Module mod : startDModules)\n            {\n                dirty |= builder.addModule(mod);\n                for (String file : mod.getFiles())\n                {\n                    files.add(new FileArg(mod,file));\n                }\n            }\n        }\n\n        if (!startIniModules.isEmpty())\n        {\n            StartIniBuilder builder = new StartIniBuilder(this);\n            for (Module mod : startIniModules)\n            {\n                dirty |= builder.addModule(mod);\n                for (String file : mod.getFiles())\n                {\n                    files.add(new FileArg(mod,file));\n                }\n            }\n        }\n\n        // Process files\n        files.addAll(startArgs.getFiles());\n        dirty |= processFileResources(files);\n\n        return dirty;\n    }","id":60354,"modified_method":"/**\n     * Build out the Base directory (if needed)\n     * \n     * @return true if base directory was changed, false if left unchanged.\n     * @throws IOException\n     */\n    public boolean build() throws IOException\n    {\n        Modules modules = startArgs.getAllModules();\n        boolean dirty = false;\n\n        String dirSource = \"<add-to-startd>\";\n        String iniSource = \"<add-to-start-ini>\";\n        Selection startDirSelection = new Selection(dirSource);\n        Selection startIniSelection = new Selection(iniSource);\n\n        int count = 0;\n        count += modules.selectNodes(startArgs.getAddToStartdIni(),startDirSelection);\n        count += modules.selectNodes(startArgs.getAddToStartIni(),startIniSelection);\n\n        Predicate startDMatcher = new HowSetMatcher(dirSource);\n        Predicate startIniMatcher = new HowSetMatcher(iniSource);\n\n        // look for ambiguous declaration found in both places\n        Predicate ambiguousMatcher = new HowSetMatcher(dirSource,iniSource);\n        List<Module> ambiguous = modules.getMatching(ambiguousMatcher);\n\n        if (ambiguous.size() > 0)\n        {\n            StringBuilder err = new StringBuilder();\n            err.append(\"Unable to add \");\n            err.append(ambiguous.size());\n            err.append(\" module\");\n            if (ambiguous.size() > 1)\n            {\n                err.append('s');\n            }\n            err.append(\" (found declared via both --add-to-start and --add-to-startd): [\");\n            for (int i = 0; i < ambiguous.size(); i++)\n            {\n                if (i > 0)\n                {\n                    err.append(\", \");\n                }\n                err.append(ambiguous.get(i).getName());\n            }\n            err.append(']');\n            throw new RuntimeException(err.toString());\n        }\n\n        StartLog.debug(\"Adding %s new module(s)\",count);\n\n        // Acknowledge Licenses\n        ackLicenses();\n\n        // Collect specific modules to enable\n        List<Module> startDModules = modules.getMatching(startDMatcher);\n        List<Module> startIniModules = modules.getMatching(startIniMatcher);\n\n        List<FileArg> files = new ArrayList<FileArg>();\n\n        if (!startDModules.isEmpty())\n        {\n            StartDirBuilder builder = new StartDirBuilder(this);\n            for (Module mod : startDModules)\n            {\n                dirty |= builder.addModule(mod);\n                for (String file : mod.getFiles())\n                {\n                    files.add(new FileArg(mod,file));\n                }\n            }\n        }\n\n        if (!startIniModules.isEmpty())\n        {\n            StartIniBuilder builder = new StartIniBuilder(this);\n            for (Module mod : startIniModules)\n            {\n                dirty |= builder.addModule(mod);\n                for (String file : mod.getFiles())\n                {\n                    files.add(new FileArg(mod,file));\n                }\n            }\n        }\n\n        // Process files\n        files.addAll(startArgs.getFiles());\n        dirty |= processFileResources(files);\n\n        return dirty;\n    }","commit_id":"005b5136535cf4154d8bf585f603fad486a75bc8","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public StartArgs processCommandLine(String[] cmdLine) throws Exception\n    {\n        // Processing Order is important!\n        // ------------------------------------------------------------\n        // 1) Configuration Locations\n        CommandLineConfigSource cmdLineSource = new CommandLineConfigSource(cmdLine);\n        baseHome = new BaseHome(cmdLineSource);\n\n        StartLog.debug(\"jetty.home=%s\",baseHome.getHome());\n        StartLog.debug(\"jetty.base=%s\",baseHome.getBase());\n\n        // ------------------------------------------------------------\n        // 2) Parse everything provided.\n        // This would be the directory information +\n        // the various start inis\n        // and then the raw command line arguments\n        StartLog.debug(\"Parsing collected arguments\");\n        StartArgs args = new StartArgs();\n        args.parse(baseHome.getConfigSources());\n\n        // ------------------------------------------------------------\n        // 3) Module Registration\n        Modules modules = new Modules(baseHome,args);\n        StartLog.debug(\"Registering all modules\");\n        modules.registerAll();\n\n        // ------------------------------------------------------------\n        // 4) Active Module Resolution\n        for (String enabledModule : args.getEnabledModules())\n        {\n            List<String> msources = args.getSources(enabledModule);\n            modules.enable(enabledModule,msources);\n        }\n        \n        StartLog.debug(\"Building Module Graph\");\n        modules.buildGraph();\n\n        args.setAllModules(modules);\n        List<Module> activeModules = modules.getEnabled();\n        modules.assertModulesValid(activeModules);\n        \n        // ------------------------------------------------------------\n        // 5) Lib & XML Expansion / Resolution\n        args.expandLibs(baseHome);\n        args.expandModules(baseHome,activeModules);\n\n        // ------------------------------------------------------------\n        // 6) Resolve Extra XMLs\n        args.resolveExtraXmls(baseHome);\n        \n        // ------------------------------------------------------------\n        // 9) Resolve Property Files\n        args.resolvePropertyFiles(baseHome);\n\n        return args;\n    }","id":60355,"modified_method":"public StartArgs processCommandLine(String[] cmdLine) throws Exception\n    {\n        // Processing Order is important!\n        // ------------------------------------------------------------\n        // 1) Configuration Locations\n        CommandLineConfigSource cmdLineSource = new CommandLineConfigSource(cmdLine);\n        baseHome = new BaseHome(cmdLineSource);\n\n        StartLog.debug(\"jetty.home=%s\",baseHome.getHome());\n        StartLog.debug(\"jetty.base=%s\",baseHome.getBase());\n\n        // ------------------------------------------------------------\n        // 2) Parse everything provided.\n        // This would be the directory information +\n        // the various start inis\n        // and then the raw command line arguments\n        StartLog.debug(\"Parsing collected arguments\");\n        StartArgs args = new StartArgs();\n        args.parse(baseHome.getConfigSources());\n\n        try\n        {\n            // ------------------------------------------------------------\n            // 3) Module Registration\n            Modules modules = new Modules(baseHome,args);\n            StartLog.debug(\"Registering all modules\");\n            modules.registerAll();\n\n            // ------------------------------------------------------------\n            // 4) Active Module Resolution\n            for (String enabledModule : args.getEnabledModules())\n            {\n                for (String source : args.getSources(enabledModule))\n                {\n                    String shortForm = baseHome.toShortForm(source);\n                    modules.selectNode(enabledModule,new Selection(shortForm));\n                }\n            }\n\n            StartLog.debug(\"Building Module Graph\");\n            modules.buildGraph();\n\n            args.setAllModules(modules);\n            List<Module> activeModules = modules.getEnabled();\n            modules.assertModulesValid(activeModules);\n\n            // ------------------------------------------------------------\n            // 5) Lib & XML Expansion / Resolution\n            args.expandLibs(baseHome);\n            args.expandModules(baseHome,activeModules);\n            \n        } catch(GraphException e) {\n            throw new UsageException(ERR_BAD_GRAPH,e);\n        }\n\n        // ------------------------------------------------------------\n        // 6) Resolve Extra XMLs\n        args.resolveExtraXmls(baseHome);\n        \n        // ------------------------------------------------------------\n        // 9) Resolve Property Files\n        args.resolvePropertyFiles(baseHome);\n\n        return args;\n    }","commit_id":"005b5136535cf4154d8bf585f603fad486a75bc8","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public Module(BaseHome basehome, Path file) throws FileNotFoundException, IOException\n    {\n        this.file = file;\n\n        // Strip .mod\n        this.fileRef = Pattern.compile(\".mod$\",Pattern.CASE_INSENSITIVE).matcher(file.getFileName().toString()).replaceFirst(\"\");\n        this.logicalName = fileRef;\n\n        init(basehome);\n        process(basehome);\n    }","id":60356,"modified_method":"public Module(BaseHome basehome, Path file) throws FileNotFoundException, IOException\n    {\n        super();\n        this.file = file;\n\n        // Strip .mod\n        this.fileRef = Pattern.compile(\".mod$\",Pattern.CASE_INSENSITIVE).matcher(file.getFileName().toString()).replaceFirst(\"\");\n        this.setName(fileRef);\n\n        init(basehome);\n        process(basehome);\n    }","commit_id":"005b5136535cf4154d8bf585f603fad486a75bc8","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void setEnabled(boolean enabled)\n    {\n        this.enabled = enabled;\n    }","id":60357,"modified_method":"public void setEnabled(boolean enabled)\n    {\n        throw new RuntimeException(\"Don't enable directly\");\n    }","commit_id":"005b5136535cf4154d8bf585f603fad486a75bc8","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public boolean isEnabled()\n    {\n        return enabled;\n    }","id":60358,"modified_method":"@Deprecated\n    public boolean isEnabled()\n    {\n        return isSelected();\n    }","commit_id":"005b5136535cf4154d8bf585f603fad486a75bc8","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void init(BaseHome basehome)\n    {\n        parentNames = new HashSet<>();\n        optionalParentNames = new HashSet<>();\n        parentEdges = new HashSet<>();\n        childEdges = new HashSet<>();\n        xmls = new ArrayList<>();\n        defaultConfig = new ArrayList<>();\n        libs = new ArrayList<>();\n        files = new ArrayList<>();\n        jvmArgs = new ArrayList<>();\n        license = new ArrayList<>();\n\n        String name = basehome.toShortForm(file);\n\n        // Find module system name (usually in the form of a filesystem reference)\n        Pattern pat = Pattern.compile(\"^.*[/\\\\\\\\]{1}modules[/\\\\\\\\]{1}(.*).mod$\",Pattern.CASE_INSENSITIVE);\n        Matcher mat = pat.matcher(name);\n        if (!mat.find())\n        {\n            throw new RuntimeException(\"Invalid Module location (must be located under /modules/ directory): \" + name);\n        }\n        this.fileRef = mat.group(1).replace('\\\\','/');\n        this.logicalName = this.fileRef;\n    }","id":60359,"modified_method":"private void init(BaseHome basehome)\n    {\n        xmls = new ArrayList<>();\n        defaultConfig = new ArrayList<>();\n        libs = new ArrayList<>();\n        files = new ArrayList<>();\n        jvmArgs = new ArrayList<>();\n        license = new ArrayList<>();\n\n        String name = basehome.toShortForm(file);\n\n        // Find module system name (usually in the form of a filesystem reference)\n        Pattern pat = Pattern.compile(\"^.*[/\\\\\\\\]{1}modules[/\\\\\\\\]{1}(.*).mod$\",Pattern.CASE_INSENSITIVE);\n        Matcher mat = pat.matcher(name);\n        if (!mat.find())\n        {\n            throw new RuntimeException(\"Invalid Module location (must be located under /modules/ directory): \" + name);\n        }\n        this.fileRef = mat.group(1).replace('\\\\','/');\n        setName(this.fileRef);\n    }","commit_id":"005b5136535cf4154d8bf585f603fad486a75bc8","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void process(BaseHome basehome) throws FileNotFoundException, IOException\n    {\n        Pattern section = Pattern.compile(\"\\\\s*\\\\[([^]]*)\\\\]\\\\s*\");\n\n        if (!FS.canReadFile(file))\n        {\n            StartLog.debug(\"Skipping read of missing file: %s\",basehome.toShortForm(file));\n            return;\n        }\n\n        try (BufferedReader buf = Files.newBufferedReader(file,StandardCharsets.UTF_8))\n        {\n            String sectionType = \"\";\n            String line;\n            while ((line = buf.readLine()) != null)\n            {\n                line = line.trim();\n\n                Matcher sectionMatcher = section.matcher(line);\n\n                if (sectionMatcher.matches())\n                {\n                    sectionType = sectionMatcher.group(1).trim().toUpperCase(Locale.ENGLISH);\n                }\n                else\n                {\n                    // blank lines and comments are valid for ini-template section\n                    if ((line.length() == 0) || line.startsWith(\"#\"))\n                    {\n                        if (\"INI-TEMPLATE\".equals(sectionType))\n                        {\n                            defaultConfig.add(line);\n                        }\n                    }\n                    else\n                    {\n                        switch (sectionType)\n                        {\n                            case \"\":\n                                // ignore (this would be entries before first section)\n                                break;\n                            case \"DEPEND\":\n                                parentNames.add(line);\n                                break;\n                            case \"FILES\":\n                                files.add(line);\n                                break;\n                            case \"DEFAULTS\":\n                            case \"INI-TEMPLATE\":\n                                defaultConfig.add(line);\n                                hasDefaultConfig = true;\n                                break;\n                            case \"LIB\":\n                                libs.add(line);\n                                break;\n                            case \"LICENSE\":\n                            case \"LICENCE\":\n                                license.add(line);\n                                break;\n                            case \"NAME\":\n                                logicalName = line;\n                                break;\n                            case \"OPTIONAL\":\n                                optionalParentNames.add(line);\n                                break;\n                            case \"EXEC\":\n                                jvmArgs.add(line);\n                                break;\n                            case \"XML\":\n                                xmls.add(line);\n                                break;\n                            default:\n                                throw new IOException(\"Unrecognized Module section: [\" + sectionType + \"]\");\n                        }\n                    }\n                }\n            }\n        }\n    }","id":60360,"modified_method":"public void process(BaseHome basehome) throws FileNotFoundException, IOException\n    {\n        Pattern section = Pattern.compile(\"\\\\s*\\\\[([^]]*)\\\\]\\\\s*\");\n\n        if (!FS.canReadFile(file))\n        {\n            StartLog.debug(\"Skipping read of missing file: %s\",basehome.toShortForm(file));\n            return;\n        }\n\n        try (BufferedReader buf = Files.newBufferedReader(file,StandardCharsets.UTF_8))\n        {\n            String sectionType = \"\";\n            String line;\n            while ((line = buf.readLine()) != null)\n            {\n                line = line.trim();\n\n                Matcher sectionMatcher = section.matcher(line);\n\n                if (sectionMatcher.matches())\n                {\n                    sectionType = sectionMatcher.group(1).trim().toUpperCase(Locale.ENGLISH);\n                }\n                else\n                {\n                    // blank lines and comments are valid for ini-template section\n                    if ((line.length() == 0) || line.startsWith(\"#\"))\n                    {\n                        if (\"INI-TEMPLATE\".equals(sectionType))\n                        {\n                            defaultConfig.add(line);\n                        }\n                    }\n                    else\n                    {\n                        switch (sectionType)\n                        {\n                            case \"\":\n                                // ignore (this would be entries before first section)\n                                break;\n                            case \"DEPEND\":\n                                addParentName(line);\n                                break;\n                            case \"FILES\":\n                                files.add(line);\n                                break;\n                            case \"DEFAULTS\":\n                            case \"INI-TEMPLATE\":\n                                defaultConfig.add(line);\n                                hasDefaultConfig = true;\n                                break;\n                            case \"LIB\":\n                                libs.add(line);\n                                break;\n                            case \"LICENSE\":\n                            case \"LICENCE\":\n                                license.add(line);\n                                break;\n                            case \"NAME\":\n                                setName(line);\n                                break;\n                            case \"OPTIONAL\":\n                                addOptionalParentName(line);\n                                break;\n                            case \"EXEC\":\n                                jvmArgs.add(line);\n                                break;\n                            case \"XML\":\n                                xmls.add(line);\n                                break;\n                            default:\n                                throw new IOException(\"Unrecognized Module section: [\" + sectionType + \"]\");\n                        }\n                    }\n                }\n            }\n        }\n    }","commit_id":"005b5136535cf4154d8bf585f603fad486a75bc8","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public boolean isVirtual()\n    {\n        return !logicalName.equals(fileRef);\n    }","id":60361,"modified_method":"public boolean isVirtual()\n    {\n        return !getName().equals(fileRef);\n    }","commit_id":"005b5136535cf4154d8bf585f603fad486a75bc8","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void expandProperties(Props props)\n    {\n        // Expand Parents\n        Set<String> parents = new HashSet<>();\n        for (String parent : parentNames)\n        {\n            parents.add(props.expand(parent));\n        }\n        parentNames.clear();\n        parentNames.addAll(parents);\n    }","id":60362,"modified_method":"public void expandProperties(Props props)\n    {\n        // Expand Parents\n        Set<String> parents = new HashSet<>();\n        for (String parent : getParentNames())\n        {\n            parents.add(props.expand(parent));\n        }\n        setParentNames(parents);\n    }","commit_id":"005b5136535cf4154d8bf585f603fad486a75bc8","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public String toString()\n    {\n        StringBuilder str = new StringBuilder();\n        str.append(\"Module[\").append(logicalName);\n        if (!logicalName.equals(fileRef))\n        {\n            str.append(\",file=\").append(fileRef);\n        }\n        if (enabled)\n        {\n            str.append(\",enabled\");\n        }\n        str.append(']');\n        return str.toString();\n    }","id":60363,"modified_method":"@Override\n    public String toString()\n    {\n        StringBuilder str = new StringBuilder();\n        str.append(\"Module[\").append(getName());\n        if (isVirtual())\n        {\n            str.append(\",file=\").append(fileRef);\n        }\n        if (isSelected())\n        {\n            str.append(\",selected\");\n        }\n        str.append(']');\n        return str.toString();\n    }","commit_id":"005b5136535cf4154d8bf585f603fad486a75bc8","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void writeRelationships(PrintWriter out, Modules modules, List<Module> enabled)\n    {\n        for (Module module : modules)\n        {\n            for (Module parent : module.getParentEdges())\n            {\n                out.printf(\"    \\\"%s\\\" -> \\\"%s\\\";%n\",module.getName(),parent.getName());\n            }\n        }\n    }","id":60364,"modified_method":"private void writeRelationships(PrintWriter out, Graph<Module> modules, List<Module> enabled)\n    {\n        for (Module module : modules)\n        {\n            for (Node<?> parent : module.getParentEdges())\n            {\n                out.printf(\"    \\\"%s\\\" -> \\\"%s\\\";%n\",module.getName(),parent.getName());\n            }\n        }\n    }","commit_id":"005b5136535cf4154d8bf585f603fad486a75bc8","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void writeModuleNode(PrintWriter out, Module module, boolean resolved)\n    {\n        String color = colorModuleBg;\n        if (module.isEnabled())\n        {\n            // specifically enabled by config\n            color = colorEnabledBg;\n        }\n        else if (resolved)\n        {\n            // enabled by transitive reasons\n            color = colorTransitiveBg;\n        }\n\n        out.printf(\"  \\\"%s\\\" [ color=\\\"%s\\\" label=<\",module.getName(),color);\n        out.printf(\"<TABLE BORDER=\\\"0\\\" CELLBORDER=\\\"0\\\" CELLSPACING=\\\"0\\\" CELLPADDING=\\\"2\\\">%n\");\n        out.printf(\"  <TR><TD ALIGN=\\\"LEFT\\\"><B>%s<\/B><\/TD><\/TR>%n\",module.getName());\n\n        if (module.isEnabled())\n        {\n            writeModuleDetailHeader(out,\"ENABLED\");\n            for (String source : module.getSources())\n            {\n                writeModuleDetailLine(out,\"via: \" + source);\n            }\n        }\n        else if (resolved)\n        {\n            writeModuleDetailHeader(out,\"TRANSITIVE\");\n        }\n\n        if (!module.getXmls().isEmpty())\n        {\n            List<String> xmls = module.getXmls();\n            writeModuleDetailHeader(out,\"XML\",xmls.size());\n            for (String xml : xmls)\n            {\n                writeModuleDetailLine(out,xml);\n            }\n        }\n\n        if (!module.getLibs().isEmpty())\n        {\n            List<String> libs = module.getLibs();\n            writeModuleDetailHeader(out,\"LIB\",libs.size());\n            for (String lib : libs)\n            {\n                writeModuleDetailLine(out,lib);\n            }\n        }\n\n        if (!module.getDefaultConfig().isEmpty())\n        {\n            List<String> inis = module.getDefaultConfig();\n            writeModuleDetailHeader(out,\"INI Template\",inis.size());\n        }\n\n        out.printf(\"<\/TABLE>>];%n\");\n    }","id":60365,"modified_method":"private void writeModuleNode(PrintWriter out, Module module, boolean resolved)\n    {\n        String color = colorModuleBg;\n        if (module.isEnabled())\n        {\n            // specifically enabled by config\n            color = colorEnabledBg;\n        }\n        else if (resolved)\n        {\n            // enabled by transitive reasons\n            color = colorTransitiveBg;\n        }\n\n        out.printf(\"  \\\"%s\\\" [ color=\\\"%s\\\" label=<\",module.getName(),color);\n        out.printf(\"<TABLE BORDER=\\\"0\\\" CELLBORDER=\\\"0\\\" CELLSPACING=\\\"0\\\" CELLPADDING=\\\"2\\\">%n\");\n        out.printf(\"  <TR><TD ALIGN=\\\"LEFT\\\"><B>%s<\/B><\/TD><\/TR>%n\",module.getName());\n\n        if (module.isEnabled())\n        {\n            writeModuleDetailHeader(out,\"ENABLED\");\n            for (Selection selection : module.getSelections())\n            {\n                writeModuleDetailLine(out,\"via: \" + selection);\n            }\n        }\n        else if (resolved)\n        {\n            writeModuleDetailHeader(out,\"TRANSITIVE\");\n        }\n\n        if (!module.getXmls().isEmpty())\n        {\n            List<String> xmls = module.getXmls();\n            writeModuleDetailHeader(out,\"XML\",xmls.size());\n            for (String xml : xmls)\n            {\n                writeModuleDetailLine(out,xml);\n            }\n        }\n\n        if (!module.getLibs().isEmpty())\n        {\n            List<String> libs = module.getLibs();\n            writeModuleDetailHeader(out,\"LIB\",libs.size());\n            for (String lib : libs)\n            {\n                writeModuleDetailLine(out,lib);\n            }\n        }\n\n        if (!module.getDefaultConfig().isEmpty())\n        {\n            List<String> inis = module.getDefaultConfig();\n            writeModuleDetailHeader(out,\"INI Template\",inis.size());\n        }\n\n        out.printf(\"<\/TABLE>>];%n\");\n    }","commit_id":"005b5136535cf4154d8bf585f603fad486a75bc8","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void assertModulesValid(Collection<Module> active)\n    {\n        /*\n         * check against the missing modules\n         * \n         * Ex: npn should match anything under npn/\n         */\n        for (String missing : missingModules)\n        {\n            for (Module module : active)\n            {\n                if (missing.startsWith(module.getName()))\n                {\n                    StartLog.warn(\"** Unable to continue, required dependency missing. [%s]\",missing);\n                    StartLog.warn(\"** As configured, Jetty is unable to start due to a missing enabled module dependency.\");\n                    StartLog.warn(\"** This may be due to a transitive dependency akin to spdy on npn, which resolves based on the JDK in use.\");\n                    throw new UsageException(UsageException.ERR_BAD_ARG, \"Missing referenced dependency: \" + missing);\n                }\n            }\n        }\n    }","id":60366,"modified_method":"public void assertModulesValid(Collection<Module> active)\n    {\n        //        /*\n        //         * check against the missing modules\n        //         * \n        //         * Ex: npn should match anything under npn/\n        //         */\n        //        for (String missing : missingModules)\n        //        {\n        //            for (Module module : active)\n        //            {\n        //                if (missing.startsWith(module.getName()))\n        //                {\n        //                    StartLog.warn(\"** Unable to continue, required dependency missing. [%s]\",missing);\n        //                    StartLog.warn(\"** As configured, Jetty is unable to start due to a missing enabled module dependency.\");\n        //                    StartLog.warn(\"** This may be due to a transitive dependency akin to spdy on npn, which resolves based on the JDK in use.\");\n        //                    throw new UsageException(UsageException.ERR_BAD_ARG,\"Missing referenced dependency: \" + missing);\n        //                }\n        //            }\n        //        }\n    }","commit_id":"005b5136535cf4154d8bf585f603fad486a75bc8","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private Module registerModule(Path file) throws FileNotFoundException, IOException\n    {\n        if (!FS.canReadFile(file))\n        {\n            throw new IOException(\"Cannot read file: \" + file);\n        }\n        StartLog.debug(\"Registering Module: %s\",baseHome.toShortForm(file));\n        Module module = new Module(baseHome,file);\n        return register(module);\n    }","id":60367,"modified_method":"private Module registerModule(Path file)\n    {\n        if (!FS.canReadFile(file))\n        {\n            throw new GraphException(\"Cannot read file: \" + file);\n        }\n        String shortName = baseHome.toShortForm(file);\n        try\n        {\n            StartLog.debug(\"Registering Module: %s\",shortName);\n            Module module = new Module(baseHome,file);\n            return register(module);\n        }\n        catch (Throwable t)\n        {\n            throw new GraphException(\"Unable to register module: \" + shortName,t);\n        }\n    }","commit_id":"005b5136535cf4154d8bf585f603fad486a75bc8","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public Set<String> resolveParentModulesOf(String moduleName)\n    {\n        Map<String, Module> ret = new HashMap<>();\n        Module module = get(moduleName);\n        findParents(module,ret);\n        return ret.keySet();\n    }","id":60368,"modified_method":"@Override\n    public Module resolveNode(String name)\n    {\n        String expandedName = args.getProperties().expand(name);\n\n        if (Props.hasPropertyKey(expandedName))\n        {\n            throw new GraphException(\"Unable to expand property in name: \" + name);\n        }\n\n        Path file = baseHome.getPath(\"modules/\" + expandedName + \".mod\");\n        if (FS.canReadFile(file))\n        {\n            Module parent = registerModule(file);\n            parent.expandProperties(args.getProperties());\n            updateParentReferencesTo(parent);\n            return parent;\n        }\n        else\n        {\n            if (!Props.hasPropertyKey(name))\n            {\n                StartLog.debug(\"Missing module definition: [ Mod: %s | File: %s ]\",name,file);\n            }\n            return null;\n        }\n    }","commit_id":"005b5136535cf4154d8bf585f603fad486a75bc8","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void normalizeDependencies() throws FileNotFoundException, IOException\n    {\n        Set<String> expandedModules = new HashSet<>();\n        boolean done = false;\n        while (!done)\n        {\n            done = true;\n            Set<String> missingParents = new HashSet<>();\n\n            for (Module m : modules.values())\n            {\n                for (String parent : m.getParentNames())\n                {\n                    String expanded = args.getProperties().expand(parent);\n                    if (modules.containsKey(expanded) || missingModules.contains(parent) || expandedModules.contains(parent))\n                    {\n                        continue; // found. skip it.\n                    }\n                    done = false;\n                    StartLog.debug(\"Missing parent module %s == %s for %s\",parent,expanded,m);\n                    missingParents.add(parent);\n                }\n            }\n\n            for (String missingParent : missingParents)\n            {\n                String expanded = args.getProperties().expand(missingParent);\n                Path file = baseHome.getPath(\"modules/\" + expanded + \".mod\");\n                if (FS.canReadFile(file))\n                {\n                    Module module = registerModule(file);\n                    updateParentReferencesTo(module);\n                    if (!expanded.equals(missingParent))\n                    {\n                        expandedModules.add(missingParent);\n                    }\n                }\n                else\n                {\n                    if (Props.hasPropertyKey(expanded))\n                    {\n                        StartLog.debug(\"Module property not expandable (yet) [%s]\",expanded);\n                        expandedModules.add(missingParent);\n                    }\n                    else\n                    {\n                        StartLog.debug(\"Missing module definition: %s expanded to %s\",missingParent,expanded);\n                        missingModules.add(missingParent);\n                    }\n                }\n            }\n        }\n    }","id":60369,"modified_method":"public void normalizeDependencies() throws IOException\n    {\n        Set<String> expandedModules = new HashSet<>();\n        boolean done = false;\n        while (!done)\n        {\n            done = true;\n            Set<String> missingParents = new HashSet<>();\n\n            for (Module m : getNodes())\n            {\n                for (String parent : m.getParentNames())\n                {\n                    String expanded = args.getProperties().expand(parent);\n                    if (containsNode(expanded) || expandedModules.contains(parent))\n                    {\n                        continue; // found. skip it.\n                    }\n                    done = false;\n                    StartLog.debug(\"Missing parent module %s == %s for %s\",parent,expanded,m);\n                    missingParents.add(parent);\n                }\n            }\n\n            for (String missingParent : missingParents)\n            {\n                String expanded = args.getProperties().expand(missingParent);\n                Path file = baseHome.getPath(\"modules/\" + expanded + \".mod\");\n                if (FS.canReadFile(file))\n                {\n                    Module module = registerModule(file);\n                    updateParentReferencesTo(module);\n                    if (!expanded.equals(missingParent))\n                    {\n                        expandedModules.add(missingParent);\n                    }\n                }\n                else\n                {\n                    if (Props.hasPropertyKey(expanded))\n                    {\n                        StartLog.debug(\"Module property not expandable (yet) [%s]\",expanded);\n                        expandedModules.add(missingParent);\n                    }\n                    else\n                    {\n                        StartLog.debug(\"Missing module definition: %s expanded to %s\",missingParent,expanded);\n                        //                        missingModules.add(missingParent);\n                    }\n                }\n            }\n        }\n    }","commit_id":"005b5136535cf4154d8bf585f603fad486a75bc8","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public Modules(BaseHome basehome, StartArgs args)\n    {\n        this.baseHome = basehome;\n        this.args = args;\n    }","id":60370,"modified_method":"public Modules(BaseHome basehome, StartArgs args)\n    {\n        this.baseHome = basehome;\n        this.args = args;\n        this.setSelectionTerm(\"enable\");\n        this.setNodeTerm(\"module\");\n    }","commit_id":"005b5136535cf4154d8bf585f603fad486a75bc8","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public String toString()\n    {\n        StringBuilder str = new StringBuilder();\n        str.append(\"Modules[\");\n        str.append(\"count=\").append(modules.size());\n        str.append(\",<\");\n        boolean delim = false;\n        for (String name : modules.keySet())\n        {\n            if (delim)\n            {\n                str.append(',');\n            }\n            str.append(name);\n            delim = true;\n        }\n        str.append(\">\");\n        str.append(\"]\");\n        return str.toString();\n    }","id":60371,"modified_method":"@Override\n    public String toString()\n    {\n        StringBuilder str = new StringBuilder();\n        str.append(\"Modules[\");\n        str.append(\"count=\").append(count());\n        str.append(\",<\");\n        boolean delim = false;\n        for (String name : getNodeNames())\n        {\n            if (delim)\n            {\n                str.append(',');\n            }\n            str.append(name);\n            delim = true;\n        }\n        str.append(\">\");\n        str.append(\"]\");\n        return str.toString();\n    }","commit_id":"005b5136535cf4154d8bf585f603fad486a75bc8","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Modules can have a different logical name than to their filesystem reference. This updates existing references to the filesystem form to use the logical\n     * name form.\n     * \n     * @param module\n     *            the module that might have other modules referring to it.\n     */\n    private void updateParentReferencesTo(Module module)\n    {\n        if (module.getName().equals(module.getFilesystemRef()))\n        {\n            // nothing to do, its sane already\n            return;\n        }\n\n        for (Module m : modules.values())\n        {\n            Set<String> resolvedParents = new HashSet<>();\n            for (String parent : m.getParentNames())\n            {\n                if (parent.equals(module.getFilesystemRef()))\n                {\n                    // use logical name instead\n                    resolvedParents.add(module.getName());\n                }\n                else\n                {\n                    // use name as-is\n                    resolvedParents.add(parent);\n                }\n            }\n            m.setParentNames(resolvedParents);\n        }\n    }","id":60372,"modified_method":"/**\n     * Modules can have a different logical name than to their filesystem reference. This updates existing references to\n     * the filesystem form to use the logical\n     * name form.\n     * \n     * @param module\n     *            the module that might have other modules referring to it.\n     */\n    private void updateParentReferencesTo(Module module)\n    {\n        if (module.getName().equals(module.getFilesystemRef()))\n        {\n            // nothing to do, its sane already\n            return;\n        }\n\n        for (Module m : getNodes())\n        {\n            Set<String> resolvedParents = new HashSet<>();\n            for (String parent : m.getParentNames())\n            {\n                if (parent.equals(module.getFilesystemRef()))\n                {\n                    // use logical name instead\n                    resolvedParents.add(module.getName());\n                }\n                else\n                {\n                    // use name as-is\n                    resolvedParents.add(parent);\n                }\n            }\n            m.setParentNames(resolvedParents);\n        }\n    }","commit_id":"005b5136535cf4154d8bf585f603fad486a75bc8","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void registerParentsIfMissing(Module module) throws IOException\n    {\n        Set<String> parents = new HashSet<>(module.getParentNames());\n        for (String name : parents)\n        {\n            if (!modules.containsKey(name))\n            {\n                Path file = baseHome.getPath(\"modules/\" + name + \".mod\");\n                if (FS.canReadFile(file))\n                {\n                    Module parent = registerModule(file);\n                    updateParentReferencesTo(parent);\n                    registerParentsIfMissing(parent);\n                }\n            }\n        }\n    }","id":60373,"modified_method":"public void registerParentsIfMissing(Module module) throws IOException\n    {\n        Set<String> parents = new HashSet<>(module.getParentNames());\n        for (String name : parents)\n        {\n            if (!containsNode(name))\n            {\n                Path file = baseHome.getPath(\"modules/\" + name + \".mod\");\n                if (FS.canReadFile(file))\n                {\n                    Module parent = registerModule(file);\n                    updateParentReferencesTo(parent);\n                    registerParentsIfMissing(parent);\n                }\n            }\n        }\n    }","commit_id":"005b5136535cf4154d8bf585f603fad486a75bc8","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void dump()\n    {\n        List<Module> ordered = new ArrayList<>();\n        ordered.addAll(modules.values());\n        Collections.sort(ordered,new Module.NameComparator());\n\n        List<Module> active = getEnabled();\n\n        for (Module module : ordered)\n        {\n            boolean activated = active.contains(module);\n            boolean enabled = module.isEnabled();\n            boolean transitive = activated && !enabled;\n\n            char status = '-';\n            if (enabled)\n            {\n                status = '*';\n            }\n            else if (transitive)\n            {\n                status = '+';\n            }\n\n            System.out.printf(\"%n %s Module: %s%n\",status,module.getName());\n            if (!module.getName().equals(module.getFilesystemRef()))\n            {\n                System.out.printf(\"      Ref: %s%n\",module.getFilesystemRef());\n            }\n            for (String parent : module.getParentNames())\n            {\n                System.out.printf(\"   Depend: %s%n\",parent);\n            }\n            for (String lib : module.getLibs())\n            {\n                System.out.printf(\"      LIB: %s%n\",lib);\n            }\n            for (String xml : module.getXmls())\n            {\n                System.out.printf(\"      XML: %s%n\",xml);\n            }\n            if (StartLog.isDebugEnabled())\n            {\n                System.out.printf(\"    depth: %d%n\",module.getDepth());\n            }\n            if (activated)\n            {\n                for (String source : module.getSources())\n                {\n                    System.out.printf(\"  Enabled: <via> %s%n\",source);\n                }\n                if (transitive)\n                {\n                    System.out.printf(\"  Enabled: <via transitive reference>%n\");\n                }\n            }\n            else\n            {\n                System.out.printf(\"  Enabled: <not enabled in this configuration>%n\");\n            }\n        }\n    }","id":60374,"modified_method":"public void dump()\n    {\n        List<Module> ordered = new ArrayList<>();\n        ordered.addAll(getNodes());\n        Collections.sort(ordered,new Module.NameComparator());\n\n        List<Module> active = getEnabled();\n\n        for (Module module : ordered)\n        {\n            boolean activated = active.contains(module);\n            boolean selected = module.isSelected();\n            boolean transitive = selected && module.matches(OnlyTransitivePredicate.INSTANCE);\n\n            String status = \"[ ]\";\n            if (transitive)\n            {\n                status = \"[t]\";\n            }\n            else if (selected)\n            {\n                status = \"[x]\";\n            }\n\n            System.out.printf(\"%n %s Module: %s%n\",status,module.getName());\n            if (!module.getName().equals(module.getFilesystemRef()))\n            {\n                System.out.printf(\"        Ref: %s%n\",module.getFilesystemRef());\n            }\n            for (String parent : module.getParentNames())\n            {\n                System.out.printf(\"     Depend: %s%n\",parent);\n            }\n            for (String lib : module.getLibs())\n            {\n                System.out.printf(\"        LIB: %s%n\",lib);\n            }\n            for (String xml : module.getXmls())\n            {\n                System.out.printf(\"        XML: %s%n\",xml);\n            }\n            if (StartLog.isDebugEnabled())\n            {\n                System.out.printf(\"      depth: %d%n\",module.getDepth());\n            }\n            if (activated)\n            {\n                for (Selection selection : module.getSelections())\n                {\n                    System.out.printf(\"    Enabled: <via> %s%n\",selection);\n                }\n            }\n            else\n            {\n                System.out.printf(\"    Enabled: <not enabled in this configuration>%n\");\n            }\n        }\n    }","commit_id":"005b5136535cf4154d8bf585f603fad486a75bc8","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Resolve the execution order of the enabled modules, and all dependent modules, based on depth first transitive reduction.\n     * \n     * @return the list of active modules (plus dependent modules), in execution order.\n     * @deprecated use {@link #getEnabled()} and {@link #assertModulesValid(Collection)} instead.\n     */\n    @Deprecated\n    public List<Module> resolveEnabled()\n    {\n        Map<String, Module> active = new HashMap<String, Module>();\n\n        for (Module module : modules.values())\n        {\n            if (module.isEnabled())\n            {\n                findParents(module,active);\n            }\n        }\n\n        assertModulesValid(active.values());\n\n        List<Module> ordered = new ArrayList<>();\n        ordered.addAll(active.values());\n        Collections.sort(ordered,new Module.DepthComparator());\n        return ordered;\n    }","id":60375,"modified_method":"/**\n     * Resolve the execution order of the enabled modules, and all dependent modules, based on depth first transitive\n     * reduction.\n     * \n     * @return the list of active modules (plus dependent modules), in execution order.\n     * @deprecated use {@link #getEnabled()} and {@link #assertModulesValid(Collection)} instead.\n     */\n    @Deprecated\n    public List<Module> resolveEnabled()\n    {\n        Map<String, Module> active = new HashMap<String, Module>();\n\n        for (Module module : getNodes())\n        {\n            if (module.isEnabled())\n            {\n                findParents(module,active);\n            }\n        }\n\n        assertModulesValid(active.values());\n\n        List<Module> ordered = new ArrayList<>();\n        ordered.addAll(active.values());\n        Collections.sort(ordered,new NodeDepthComparator());\n        return ordered;\n    }","commit_id":"005b5136535cf4154d8bf585f603fad486a75bc8","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testResolve_ServerHttp() throws IOException\n    {\n        // Test Env\n        File homeDir = MavenTestingUtils.getTestResourceDir(\"usecases/home\");\n        File baseDir = testdir.getEmptyDir();\n        String cmdLine[] = new String[] { \"jetty.version=TEST\" };\n\n        // Configuration\n        CommandLineConfigSource cmdLineSource = new CommandLineConfigSource(cmdLine);\n        ConfigSources config = new ConfigSources();\n        config.add(cmdLineSource);\n        config.add(new JettyHomeConfigSource(homeDir.toPath()));\n        config.add(new JettyBaseConfigSource(baseDir.toPath()));\n\n        // Initialize\n        BaseHome basehome = new BaseHome(config);\n\n        StartArgs args = new StartArgs();\n        args.parse(config);\n\n        // Test Modules\n        Modules modules = new Modules(basehome,args);\n        modules.registerAll();\n\n        // Enable 2 modules\n        modules.enable(\"server\",TEST_SOURCE);\n        modules.enable(\"http\",TEST_SOURCE);\n\n        modules.buildGraph();\n\n        // Collect active module list\n        List<Module> active = modules.getEnabled();\n\n        // Assert names are correct, and in the right order\n        List<String> expectedNames = new ArrayList<>();\n        expectedNames.add(\"base\");\n        expectedNames.add(\"xml\");\n        expectedNames.add(\"server\");\n        expectedNames.add(\"http\");\n\n        List<String> actualNames = new ArrayList<>();\n        for (Module actual : active)\n        {\n            actualNames.add(actual.getName());\n        }\n\n        assertThat(\"Resolved Names: \" + actualNames,actualNames,contains(expectedNames.toArray()));\n\n        // Assert Library List\n        List<String> expectedLibs = new ArrayList<>();\n        expectedLibs.add(\"lib/jetty-util-${jetty.version}.jar\");\n        expectedLibs.add(\"lib/jetty-io-${jetty.version}.jar\");\n        expectedLibs.add(\"lib/jetty-xml-${jetty.version}.jar\");\n        expectedLibs.add(\"lib/servlet-api-3.1.jar\");\n        expectedLibs.add(\"lib/jetty-schemas-3.1.jar\");\n        expectedLibs.add(\"lib/jetty-http-${jetty.version}.jar\");\n        expectedLibs.add(\"lib/jetty-continuation-${jetty.version}.jar\");\n        expectedLibs.add(\"lib/jetty-server-${jetty.version}.jar\");\n\n        List<String> actualLibs = modules.normalizeLibs(active);\n        assertThat(\"Resolved Libs: \" + actualLibs,actualLibs,contains(expectedLibs.toArray()));\n\n        // Assert XML List\n        List<String> expectedXmls = new ArrayList<>();\n        expectedXmls.add(\"etc/jetty.xml\");\n        expectedXmls.add(\"etc/jetty-http.xml\");\n\n        List<String> actualXmls = modules.normalizeXmls(active);\n        assertThat(\"Resolved XMLs: \" + actualXmls,actualXmls,contains(expectedXmls.toArray()));\n    }","id":60376,"modified_method":"@Test\n    public void testResolve_ServerHttp() throws IOException\n    {\n        // Test Env\n        File homeDir = MavenTestingUtils.getTestResourceDir(\"usecases/home\");\n        File baseDir = testdir.getEmptyDir();\n        String cmdLine[] = new String[] { \"jetty.version=TEST\" };\n\n        // Configuration\n        CommandLineConfigSource cmdLineSource = new CommandLineConfigSource(cmdLine);\n        ConfigSources config = new ConfigSources();\n        config.add(cmdLineSource);\n        config.add(new JettyHomeConfigSource(homeDir.toPath()));\n        config.add(new JettyBaseConfigSource(baseDir.toPath()));\n\n        // Initialize\n        BaseHome basehome = new BaseHome(config);\n\n        StartArgs args = new StartArgs();\n        args.parse(config);\n\n        // Test Modules\n        Modules modules = new Modules(basehome,args);\n        modules.registerAll();\n\n        // Enable 2 modules\n        modules.selectNode(\"server\",new Selection(TEST_SOURCE));\n        modules.selectNode(\"http\",new Selection(TEST_SOURCE));\n\n        modules.buildGraph();\n\n        // Collect active module list\n        List<Module> active = modules.getEnabled();\n\n        // Assert names are correct, and in the right order\n        List<String> expectedNames = new ArrayList<>();\n        expectedNames.add(\"base\");\n        expectedNames.add(\"xml\");\n        expectedNames.add(\"server\");\n        expectedNames.add(\"http\");\n\n        List<String> actualNames = new ArrayList<>();\n        for (Module actual : active)\n        {\n            actualNames.add(actual.getName());\n        }\n\n        assertThat(\"Resolved Names: \" + actualNames,actualNames,contains(expectedNames.toArray()));\n\n        // Assert Library List\n        List<String> expectedLibs = new ArrayList<>();\n        expectedLibs.add(\"lib/jetty-util-${jetty.version}.jar\");\n        expectedLibs.add(\"lib/jetty-io-${jetty.version}.jar\");\n        expectedLibs.add(\"lib/jetty-xml-${jetty.version}.jar\");\n        expectedLibs.add(\"lib/servlet-api-3.1.jar\");\n        expectedLibs.add(\"lib/jetty-schemas-3.1.jar\");\n        expectedLibs.add(\"lib/jetty-http-${jetty.version}.jar\");\n        expectedLibs.add(\"lib/jetty-continuation-${jetty.version}.jar\");\n        expectedLibs.add(\"lib/jetty-server-${jetty.version}.jar\");\n\n        List<String> actualLibs = modules.normalizeLibs(active);\n        assertThat(\"Resolved Libs: \" + actualLibs,actualLibs,contains(expectedLibs.toArray()));\n\n        // Assert XML List\n        List<String> expectedXmls = new ArrayList<>();\n        expectedXmls.add(\"etc/jetty.xml\");\n        expectedXmls.add(\"etc/jetty-http.xml\");\n\n        List<String> actualXmls = modules.normalizeXmls(active);\n        assertThat(\"Resolved XMLs: \" + actualXmls,actualXmls,contains(expectedXmls.toArray()));\n    }","commit_id":"005b5136535cf4154d8bf585f603fad486a75bc8","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testResolve_WebSocket() throws IOException\n    {\n        // Test Env\n        File homeDir = MavenTestingUtils.getTestResourceDir(\"usecases/home\");\n        File baseDir = testdir.getEmptyDir();\n        String cmdLine[] = new String[] { \"jetty.version=TEST\" };\n\n        // Configuration\n        CommandLineConfigSource cmdLineSource = new CommandLineConfigSource(cmdLine);\n        ConfigSources config = new ConfigSources();\n        config.add(cmdLineSource);\n        config.add(new JettyHomeConfigSource(homeDir.toPath()));\n        config.add(new JettyBaseConfigSource(baseDir.toPath()));\n\n        // Initialize\n        BaseHome basehome = new BaseHome(config);\n\n        StartArgs args = new StartArgs();\n        args.parse(config);\n\n        // Test Modules\n        Modules modules = new Modules(basehome,args);\n        modules.registerAll();\n\n        // Enable 2 modules\n        modules.enable(\"websocket\",TEST_SOURCE);\n        modules.enable(\"http\",TEST_SOURCE);\n\n        modules.buildGraph();\n        // modules.dump();\n\n        // Collect active module list\n        List<Module> active = modules.getEnabled();\n\n        // Assert names are correct, and in the right order\n        List<String> expectedNames = new ArrayList<>();\n        expectedNames.add(\"base\");\n        expectedNames.add(\"xml\");\n        expectedNames.add(\"server\");\n        expectedNames.add(\"http\");\n        expectedNames.add(\"jndi\");\n        expectedNames.add(\"security\");\n        expectedNames.add(\"plus\");\n        expectedNames.add(\"annotations\");\n        expectedNames.add(\"websocket\");\n\n        List<String> actualNames = new ArrayList<>();\n        for (Module actual : active)\n        {\n            actualNames.add(actual.getName());\n        }\n\n        assertThat(\"Resolved Names: \" + actualNames,actualNames,contains(expectedNames.toArray()));\n\n        // Assert Library List\n        List<String> expectedLibs = new ArrayList<>();\n        expectedLibs.add(\"lib/jetty-util-${jetty.version}.jar\");\n        expectedLibs.add(\"lib/jetty-io-${jetty.version}.jar\");\n        expectedLibs.add(\"lib/jetty-xml-${jetty.version}.jar\");\n        expectedLibs.add(\"lib/servlet-api-3.1.jar\");\n        expectedLibs.add(\"lib/jetty-schemas-3.1.jar\");\n        expectedLibs.add(\"lib/jetty-http-${jetty.version}.jar\");\n        expectedLibs.add(\"lib/jetty-continuation-${jetty.version}.jar\");\n        expectedLibs.add(\"lib/jetty-server-${jetty.version}.jar\");\n        expectedLibs.add(\"lib/jetty-jndi-${jetty.version}.jar\");\n        expectedLibs.add(\"lib/jndi/*.jar\");\n        expectedLibs.add(\"lib/jetty-security-${jetty.version}.jar\");\n        expectedLibs.add(\"lib/jetty-plus-${jetty.version}.jar\");\n        expectedLibs.add(\"lib/jetty-annotations-${jetty.version}.jar\");\n        expectedLibs.add(\"lib/annotations/*.jar\");\n        expectedLibs.add(\"lib/websocket/*.jar\");\n\n        List<String> actualLibs = modules.normalizeLibs(active);\n        assertThat(\"Resolved Libs: \" + actualLibs,actualLibs,contains(expectedLibs.toArray()));\n\n        // Assert XML List\n        List<String> expectedXmls = new ArrayList<>();\n        expectedXmls.add(\"etc/jetty.xml\");\n        expectedXmls.add(\"etc/jetty-http.xml\");\n        expectedXmls.add(\"etc/jetty-plus.xml\");\n        expectedXmls.add(\"etc/jetty-annotations.xml\");\n        expectedXmls.add(\"etc/jetty-websockets.xml\");\n\n        List<String> actualXmls = modules.normalizeXmls(active);\n        assertThat(\"Resolved XMLs: \" + actualXmls,actualXmls,contains(expectedXmls.toArray()));\n    }","id":60377,"modified_method":"@Test\n    public void testResolve_WebSocket() throws IOException\n    {\n        // Test Env\n        File homeDir = MavenTestingUtils.getTestResourceDir(\"usecases/home\");\n        File baseDir = testdir.getEmptyDir();\n        String cmdLine[] = new String[] { \"jetty.version=TEST\" };\n\n        // Configuration\n        CommandLineConfigSource cmdLineSource = new CommandLineConfigSource(cmdLine);\n        ConfigSources config = new ConfigSources();\n        config.add(cmdLineSource);\n        config.add(new JettyHomeConfigSource(homeDir.toPath()));\n        config.add(new JettyBaseConfigSource(baseDir.toPath()));\n\n        // Initialize\n        BaseHome basehome = new BaseHome(config);\n\n        StartArgs args = new StartArgs();\n        args.parse(config);\n\n        // Test Modules\n        Modules modules = new Modules(basehome,args);\n        modules.registerAll();\n\n        // Enable 2 modules\n        modules.selectNode(\"websocket\",new Selection(TEST_SOURCE));\n        modules.selectNode(\"http\",new Selection(TEST_SOURCE));\n\n        modules.buildGraph();\n        // modules.dump();\n\n        // Collect active module list\n        List<Module> active = modules.getEnabled();\n\n        // Assert names are correct, and in the right order\n        List<String> expectedNames = new ArrayList<>();\n        expectedNames.add(\"base\");\n        expectedNames.add(\"xml\");\n        expectedNames.add(\"server\");\n        expectedNames.add(\"http\");\n        expectedNames.add(\"jndi\");\n        expectedNames.add(\"security\");\n        expectedNames.add(\"plus\");\n        expectedNames.add(\"annotations\");\n        expectedNames.add(\"websocket\");\n\n        List<String> actualNames = new ArrayList<>();\n        for (Module actual : active)\n        {\n            actualNames.add(actual.getName());\n        }\n\n        assertThat(\"Resolved Names: \" + actualNames,actualNames,contains(expectedNames.toArray()));\n\n        // Assert Library List\n        List<String> expectedLibs = new ArrayList<>();\n        expectedLibs.add(\"lib/jetty-util-${jetty.version}.jar\");\n        expectedLibs.add(\"lib/jetty-io-${jetty.version}.jar\");\n        expectedLibs.add(\"lib/jetty-xml-${jetty.version}.jar\");\n        expectedLibs.add(\"lib/servlet-api-3.1.jar\");\n        expectedLibs.add(\"lib/jetty-schemas-3.1.jar\");\n        expectedLibs.add(\"lib/jetty-http-${jetty.version}.jar\");\n        expectedLibs.add(\"lib/jetty-continuation-${jetty.version}.jar\");\n        expectedLibs.add(\"lib/jetty-server-${jetty.version}.jar\");\n        expectedLibs.add(\"lib/jetty-jndi-${jetty.version}.jar\");\n        expectedLibs.add(\"lib/jndi/*.jar\");\n        expectedLibs.add(\"lib/jetty-security-${jetty.version}.jar\");\n        expectedLibs.add(\"lib/jetty-plus-${jetty.version}.jar\");\n        expectedLibs.add(\"lib/jetty-annotations-${jetty.version}.jar\");\n        expectedLibs.add(\"lib/annotations/*.jar\");\n        expectedLibs.add(\"lib/websocket/*.jar\");\n\n        List<String> actualLibs = modules.normalizeLibs(active);\n        assertThat(\"Resolved Libs: \" + actualLibs,actualLibs,contains(expectedLibs.toArray()));\n\n        // Assert XML List\n        List<String> expectedXmls = new ArrayList<>();\n        expectedXmls.add(\"etc/jetty.xml\");\n        expectedXmls.add(\"etc/jetty-http.xml\");\n        expectedXmls.add(\"etc/jetty-plus.xml\");\n        expectedXmls.add(\"etc/jetty-annotations.xml\");\n        expectedXmls.add(\"etc/jetty-websockets.xml\");\n\n        List<String> actualXmls = modules.normalizeXmls(active);\n        assertThat(\"Resolved XMLs: \" + actualXmls,actualXmls,contains(expectedXmls.toArray()));\n    }","commit_id":"005b5136535cf4154d8bf585f603fad486a75bc8","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testEnableRegexSimple() throws IOException\n    {\n        // Test Env\n        File homeDir = MavenTestingUtils.getTestResourceDir(\"usecases/home\");\n        File baseDir = testdir.getEmptyDir();\n        String cmdLine[] = new String[] { \"jetty.version=TEST\", \"java.version=1.7.0_60\" };\n\n        // Configuration\n        CommandLineConfigSource cmdLineSource = new CommandLineConfigSource(cmdLine);\n        ConfigSources config = new ConfigSources();\n        config.add(cmdLineSource);\n        config.add(new JettyHomeConfigSource(homeDir.toPath()));\n        config.add(new JettyBaseConfigSource(baseDir.toPath()));\n\n        // Initialize\n        BaseHome basehome = new BaseHome(config);\n\n        StartArgs args = new StartArgs();\n        args.parse(config);\n\n        // Test Modules\n        Modules modules = new Modules(basehome,args);\n        modules.registerAll();\n        modules.enable(\"[sj]{1}.*\",TEST_SOURCE);\n        modules.buildGraph();\n\n        List<String> expected = new ArrayList<>();\n        expected.add(\"jmx\");\n        expected.add(\"stats\");\n        expected.add(\"spdy\");\n        expected.add(\"security\");\n        expected.add(\"jndi\");\n        expected.add(\"jsp\");\n        expected.add(\"servlet\");\n        expected.add(\"jaas\");\n        expected.add(\"server\");\n        // transitive\n        expected.add(\"base\");\n        expected.add(\"ssl\");\n        expected.add(\"protonego\");\n        expected.add(\"protonego-boot\");\n        expected.add(\"protonego-impl\");\n        expected.add(\"xml\");\n        expected.add(\"jsp-impl\");\n\n        List<String> resolved = new ArrayList<>();\n        for (Module module : modules.getEnabled())\n        {\n            resolved.add(module.getName());\n        }\n\n        ConfigurationAssert.assertContainsUnordered(\"Enabled Modules\",expected,resolved);\n    }","id":60378,"modified_method":"@Test\n    public void testEnableRegexSimple() throws IOException\n    {\n        // Test Env\n        File homeDir = MavenTestingUtils.getTestResourceDir(\"usecases/home\");\n        File baseDir = testdir.getEmptyDir();\n        String cmdLine[] = new String[] { \"jetty.version=TEST\", \"java.version=1.7.0_60\" };\n\n        // Configuration\n        CommandLineConfigSource cmdLineSource = new CommandLineConfigSource(cmdLine);\n        ConfigSources config = new ConfigSources();\n        config.add(cmdLineSource);\n        config.add(new JettyHomeConfigSource(homeDir.toPath()));\n        config.add(new JettyBaseConfigSource(baseDir.toPath()));\n\n        // Initialize\n        BaseHome basehome = new BaseHome(config);\n\n        StartArgs args = new StartArgs();\n        args.parse(config);\n\n        // Test Modules\n        Modules modules = new Modules(basehome,args);\n        modules.registerAll();\n        Predicate sjPredicate = new RegexNamePredicate(\"[sj]{1}.*\");\n        modules.selectNode(sjPredicate,new Selection(TEST_SOURCE));\n        modules.buildGraph();\n\n        List<String> expected = new ArrayList<>();\n        expected.add(\"jmx\");\n        expected.add(\"stats\");\n        expected.add(\"spdy\");\n        expected.add(\"security\");\n        expected.add(\"jndi\");\n        expected.add(\"jsp\");\n        expected.add(\"servlet\");\n        expected.add(\"jaas\");\n        expected.add(\"server\");\n        // transitive\n        expected.add(\"base\");\n        expected.add(\"ssl\");\n        expected.add(\"protonego\");\n        expected.add(\"protonego-boot\");\n        expected.add(\"protonego-impl\");\n        expected.add(\"xml\");\n        expected.add(\"jsp-impl\");\n\n        List<String> resolved = new ArrayList<>();\n        for (Module module : modules.getEnabled())\n        {\n            resolved.add(module.getName());\n        }\n\n        ConfigurationAssert.assertContainsUnordered(\"Enabled Modules\",expected,resolved);\n    }","commit_id":"005b5136535cf4154d8bf585f603fad486a75bc8","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testResolve_Alt() throws IOException\n    {\n        // Test Env\n        File homeDir = MavenTestingUtils.getTestResourceDir(\"usecases/home\");\n        File baseDir = testdir.getEmptyDir();\n        String cmdLine[] = new String[] { \"jetty.version=TEST\" };\n\n        // Configuration\n        CommandLineConfigSource cmdLineSource = new CommandLineConfigSource(cmdLine);\n        ConfigSources config = new ConfigSources();\n        config.add(cmdLineSource);\n        config.add(new JettyHomeConfigSource(homeDir.toPath()));\n        config.add(new JettyBaseConfigSource(baseDir.toPath()));\n\n        // Initialize\n        BaseHome basehome = new BaseHome(config);\n\n        StartArgs args = new StartArgs();\n        args.parse(config);\n\n        // Test Modules\n        Modules modules = new Modules(basehome,args);\n        modules.registerAll();\n\n        // Enable test modules\n        modules.enable(\"http\",TEST_SOURCE);\n        modules.enable(\"annotations\",TEST_SOURCE);\n        modules.enable(\"deploy\",TEST_SOURCE);\n        // Enable alternate modules\n        String alt = \"<alt>\";\n        modules.enable(\"websocket\",Collections.singletonList(alt));\n        modules.enable(\"jsp\",Collections.singletonList(alt));\n\n        modules.buildGraph();\n        // modules.dump();\n\n        // Collect active module list\n        List<Module> active = modules.getEnabled();\n\n        // Assert names are correct, and in the right order\n        List<String> expectedNames = new ArrayList<>();\n        expectedNames.add(\"base\");\n        expectedNames.add(\"jsp-impl\");\n        expectedNames.add(\"xml\");\n        expectedNames.add(\"server\");\n        expectedNames.add(\"http\");\n        expectedNames.add(\"jndi\");\n        expectedNames.add(\"security\");\n        expectedNames.add(\"servlet\");\n        expectedNames.add(\"jsp\");\n        expectedNames.add(\"plus\");\n        expectedNames.add(\"webapp\");\n        expectedNames.add(\"annotations\");\n        expectedNames.add(\"deploy\");\n        expectedNames.add(\"websocket\");\n\n        List<String> actualNames = new ArrayList<>();\n        for (Module actual : active)\n        {\n            actualNames.add(actual.getName());\n        }\n\n        assertThat(\"Resolved Names: \" + actualNames,actualNames,contains(expectedNames.toArray()));\n\n        // Now work with the 'alt' selected\n        List<String> expectedAlts = new ArrayList<>();\n        expectedAlts.add(\"jsp-impl\");\n        expectedAlts.add(\"jsp\");\n        expectedAlts.add(\"websocket\");\n\n        for (String expectedAlt : expectedAlts)\n        {\n            Module altMod = modules.get(expectedAlt);\n            assertThat(\"Alt.mod[\" + expectedAlt + \"].enabled\",altMod.isEnabled(),is(true));\n            Set<String> sources = altMod.getSources();\n            assertThat(\"Alt.mod[\" + expectedAlt + \"].sources: [\" + Utils.join(sources,\", \") + \"]\",sources,contains(alt));\n        }\n\n        // Now collect the unique source list\n        List<Module> alts = modules.getMatching(new AndMatcher(new EnabledMatcher(),new UniqueSourceMatcher(alt)));\n\n        // Assert names are correct, and in the right order\n        actualNames = new ArrayList<>();\n        for (Module actual : alts)\n        {\n            actualNames.add(actual.getName());\n        }\n\n        assertThat(\"Resolved Alt (Sources) Names: \" + actualNames,actualNames,contains(expectedAlts.toArray()));\n    }","id":60379,"modified_method":"@Test\n    public void testResolve_Alt() throws IOException\n    {\n        // Test Env\n        File homeDir = MavenTestingUtils.getTestResourceDir(\"usecases/home\");\n        File baseDir = testdir.getEmptyDir();\n        String cmdLine[] = new String[] { \"jetty.version=TEST\" };\n\n        // Configuration\n        CommandLineConfigSource cmdLineSource = new CommandLineConfigSource(cmdLine);\n        ConfigSources config = new ConfigSources();\n        config.add(cmdLineSource);\n        config.add(new JettyHomeConfigSource(homeDir.toPath()));\n        config.add(new JettyBaseConfigSource(baseDir.toPath()));\n\n        // Initialize\n        BaseHome basehome = new BaseHome(config);\n\n        StartArgs args = new StartArgs();\n        args.parse(config);\n\n        // Test Modules\n        Modules modules = new Modules(basehome,args);\n        modules.registerAll();\n\n        // Enable test modules\n        modules.selectNode(\"http\",new Selection(TEST_SOURCE));\n        modules.selectNode(\"annotations\",new Selection(TEST_SOURCE));\n        modules.selectNode(\"deploy\",new Selection(TEST_SOURCE));\n        // Enable alternate modules\n        String alt = \"<alt>\";\n        modules.selectNode(\"websocket\",new Selection(alt));\n        modules.selectNode(\"jsp\",new Selection(alt));\n\n        modules.buildGraph();\n        // modules.dump();\n\n        // Collect active module list\n        List<Module> active = modules.getEnabled();\n\n        // Assert names are correct, and in the right order\n        List<String> expectedNames = new ArrayList<>();\n        expectedNames.add(\"base\");\n        expectedNames.add(\"jsp-impl\");\n        expectedNames.add(\"xml\");\n        expectedNames.add(\"server\");\n        expectedNames.add(\"http\");\n        expectedNames.add(\"jndi\");\n        expectedNames.add(\"security\");\n        expectedNames.add(\"servlet\");\n        expectedNames.add(\"jsp\");\n        expectedNames.add(\"plus\");\n        expectedNames.add(\"webapp\");\n        expectedNames.add(\"annotations\");\n        expectedNames.add(\"deploy\");\n        expectedNames.add(\"websocket\");\n\n        List<String> actualNames = new ArrayList<>();\n        for (Module actual : active)\n        {\n            actualNames.add(actual.getName());\n        }\n\n        assertThat(\"Resolved Names: \" + actualNames,actualNames,contains(expectedNames.toArray()));\n\n        // Now work with the 'alt' selected\n        List<String> expectedAlts = new ArrayList<>();\n        expectedAlts.add(\"jsp-impl\");\n        expectedAlts.add(\"jsp\");\n        expectedAlts.add(\"websocket\");\n\n        for (String expectedAlt : expectedAlts)\n        {\n            Module altMod = modules.get(expectedAlt);\n            assertThat(\"Alt.mod[\" + expectedAlt + \"].selected\",altMod.isSelected(),is(true));\n            Set<String> sources = altMod.getSelectedHowSet();\n            assertThat(\"Alt.mod[\" + expectedAlt + \"].sources: [\" + Utils.join(sources,\", \") + \"]\",sources,contains(alt));\n        }\n\n        // Now collect the unique source list\n        List<Module> alts = modules.getMatching(new HowSetMatcher(alt));\n\n        // Assert names are correct, and in the right order\n        actualNames = new ArrayList<>();\n        for (Module actual : alts)\n        {\n            actualNames.add(actual.getName());\n        }\n\n        assertThat(\"Resolved Alt (Sources) Names: \" + actualNames,actualNames,contains(expectedAlts.toArray()));\n    }","commit_id":"005b5136535cf4154d8bf585f603fad486a75bc8","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected MavenArchiver createArchiver()\n        throws MojoExecutionException\n    {\n        MavenArchiver archiver = new MavenArchiver();\n        archiver.setArchiver( jarArchiver );\n\n        if ( project.getBuild() != null )\n        {\n            List resources = project.getBuild().getResources();\n\n            for ( Iterator i = resources.iterator(); i.hasNext(); )\n            {\n                Resource r = (Resource) i.next();\n\n                if ( r.getDirectory().endsWith( \"maven-shared-archive-resources\" ) )\n                {\n                    addDirectory( archiver.getArchiver(), new File( r.getDirectory() ), getCombinedIncludes( null ),\n                                  getCombinedExcludes( null ) );\n                }\n            }\n        }\n\n        return archiver;\n    }","id":60380,"modified_method":"protected MavenArchiver createArchiver()\n        throws MojoExecutionException\n    {\n        MavenArchiver archiver = new MavenArchiver();\n        archiver.setArchiver( jarArchiver );\n\n        if ( project.getBuild() != null )\n        {\n            List<Resource> resources = project.getBuild().getResources();\n\n            for ( Resource r : resources )\n            {\n\n                if ( r.getDirectory().endsWith( \"maven-shared-archive-resources\" ) )\n                {\n                    addDirectory( archiver.getArchiver(), new File( r.getDirectory() ), getCombinedIncludes( null ),\n                                  getCombinedExcludes( null ) );\n                }\n            }\n        }\n\n        return archiver;\n    }","commit_id":"221fdafb6c540cbb250479c1c97d3686dbbbce42","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Combines the user parameter {@link #excludes}, the default excludes from plexus FileUtils,\n     * and the contents of the parameter addionalExcludes.\n     * \n     * @param additionalExcludes Additional excludes to add to the array\n     * @return The combined list of excludes.\n     */\n\n    private String[] getCombinedExcludes( List additionalExcludes )\n    {\n        ArrayList combinedExcludes = new ArrayList();\n\n        if ( useDefaultExcludes )\n        {\n            combinedExcludes.addAll( FileUtils.getDefaultExcludesAsList() );\n        }\n\n        if ( excludes != null && excludes.length > 0 )\n        {\n            combinedExcludes.addAll( Arrays.asList( excludes ) );\n        }\n\n        if ( additionalExcludes != null && additionalExcludes.size() > 0 )\n        {\n            combinedExcludes.addAll( additionalExcludes );\n        }\n\n        if ( combinedExcludes.size() == 0 )\n        {\n            combinedExcludes.addAll( Arrays.asList( DEFAULT_EXCLUDES ) );\n        }\n\n        return (String[]) combinedExcludes.toArray( new String[combinedExcludes.size()] );\n    }","id":60381,"modified_method":"/**\n     * Combines the user parameter {@link #excludes}, the default excludes from plexus FileUtils,\n     * and the contents of the parameter addionalExcludes.\n     *\n     * @param additionalExcludes Additional excludes to add to the array\n     * @return The combined list of excludes.\n     */\n\n    private String[] getCombinedExcludes( List additionalExcludes )\n    {\n        List<String> combinedExcludes = new ArrayList<String>();\n\n        if ( useDefaultExcludes )\n        {\n            combinedExcludes.addAll( FileUtils.getDefaultExcludesAsList() );\n        }\n\n        if ( excludes != null && excludes.length > 0 )\n        {\n            combinedExcludes.addAll( Arrays.asList( excludes ) );\n        }\n\n        if ( additionalExcludes != null && additionalExcludes.size() > 0 )\n        {\n            combinedExcludes.addAll( additionalExcludes );\n        }\n\n        if ( combinedExcludes.size() == 0 )\n        {\n            combinedExcludes.addAll( Arrays.asList( DEFAULT_EXCLUDES ) );\n        }\n\n        return combinedExcludes.toArray( new String[combinedExcludes.size()] );\n    }","commit_id":"221fdafb6c540cbb250479c1c97d3686dbbbce42","url":"https://github.com/apache/maven-plugins"},{"original_method":"protected void packageSources( MavenProject p )\n        throws MojoExecutionException\n    {\n        if ( !\"pom\".equals( p.getPackaging() ) )\n        {\n            packageSources( Arrays.asList( new Object[] { p } ) );\n        }\n    }","id":60382,"modified_method":"protected void packageSources( MavenProject p )\n        throws MojoExecutionException\n    {\n        if ( !\"pom\".equals( p.getPackaging() ) )\n        {\n            packageSources( Arrays.asList( p ) );\n        }\n    }","commit_id":"221fdafb6c540cbb250479c1c97d3686dbbbce42","url":"https://github.com/apache/maven-plugins"},{"original_method":"protected void packageSources( List projects )\n        throws MojoExecutionException\n    {\n        if ( project.getArtifact().getClassifier() != null )\n        {\n            getLog().warn( \"NOT adding sources to artifacts with classifier as Maven only supports one classifier \"\n                + \"per artifact. Current artifact [\" + project.getArtifact().getId() + \"] has a [\"\n                + project.getArtifact().getClassifier() + \"] classifier.\" );\n\n            return;\n        }\n\n        MavenArchiver archiver = createArchiver();\n\n        for ( Iterator i = projects.iterator(); i.hasNext(); )\n        {\n            MavenProject subProject = getProject( (MavenProject) i.next() );\n\n            if ( \"pom\".equals( subProject.getPackaging() ) )\n            {\n                continue;\n            }\n\n            archiveProjectContent( subProject, archiver.getArchiver() );\n        }\n\n        if(!archiver.getArchiver().getFiles().isEmpty()){\n        \n            if ( useDefaultManifestFile && defaultManifestFile.exists() && archive.getManifestFile() == null )\n            {\n                getLog().info( \"Adding existing MANIFEST to archive. Found under: \" + defaultManifestFile.getPath() );\n                archive.setManifestFile( defaultManifestFile );\n            }\n    \n            File outputFile = new File( outputDirectory, finalName + \"-\" + getClassifier() + getExtension() );\n            \n            try\n            {\n                archiver.setOutputFile( outputFile );\n    \n                archive.setAddMavenDescriptor( false );\n                archive.setForced( forceCreation );\n    \n                archiver.createArchive( project, archive );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Error creating source archive: \" + e.getMessage(), e );\n            }\n            catch ( ArchiverException e )\n            {\n                throw new MojoExecutionException( \"Error creating source archive: \" + e.getMessage(), e );\n            }\n            catch ( DependencyResolutionRequiredException e )\n            {\n                throw new MojoExecutionException( \"Error creating source archive: \" + e.getMessage(), e );\n            }\n            catch ( ManifestException e )\n            {\n                throw new MojoExecutionException( \"Error creating source archive: \" + e.getMessage(), e );\n            }\n    \n            if ( attach )\n            {\n                projectHelper.attachArtifact( project, getType(), getClassifier(), outputFile );\n            }\n            else\n            {\n                getLog().info( \"NOT adding java-sources to attached artifacts list.\" );\n            }\n        }\n        else\n        {\n            getLog().info( \"No sources in project. Archive not created.\" );\n        }\n    }","id":60383,"modified_method":"protected void packageSources( List<MavenProject> projects )\n        throws MojoExecutionException\n    {\n        if ( project.getArtifact().getClassifier() != null )\n        {\n            getLog().warn( \"NOT adding sources to artifacts with classifier as Maven only supports one classifier \"\n                               + \"per artifact. Current artifact [\" + project.getArtifact().getId() + \"] has a [\"\n                               + project.getArtifact().getClassifier() + \"] classifier.\" );\n\n            return;\n        }\n\n        MavenArchiver archiver = createArchiver();\n\n        for ( MavenProject project : projects )\n        {\n            MavenProject subProject = getProject( project );\n\n            if ( \"pom\".equals( subProject.getPackaging() ) )\n            {\n                continue;\n            }\n\n            archiveProjectContent( subProject, archiver.getArchiver() );\n        }\n\n        if ( !archiver.getArchiver().getFiles().isEmpty() )\n        {\n\n            if ( useDefaultManifestFile && defaultManifestFile.exists() && archive.getManifestFile() == null )\n            {\n                getLog().info( \"Adding existing MANIFEST to archive. Found under: \" + defaultManifestFile.getPath() );\n                archive.setManifestFile( defaultManifestFile );\n            }\n\n            File outputFile = new File( outputDirectory, finalName + \"-\" + getClassifier() + getExtension() );\n\n            try\n            {\n                archiver.setOutputFile( outputFile );\n\n                archive.setAddMavenDescriptor( false );\n                archive.setForced( forceCreation );\n\n                archiver.createArchive( project, archive );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Error creating source archive: \" + e.getMessage(), e );\n            }\n            catch ( ArchiverException e )\n            {\n                throw new MojoExecutionException( \"Error creating source archive: \" + e.getMessage(), e );\n            }\n            catch ( DependencyResolutionRequiredException e )\n            {\n                throw new MojoExecutionException( \"Error creating source archive: \" + e.getMessage(), e );\n            }\n            catch ( ManifestException e )\n            {\n                throw new MojoExecutionException( \"Error creating source archive: \" + e.getMessage(), e );\n            }\n\n            if ( attach )\n            {\n                projectHelper.attachArtifact( project, getType(), getClassifier(), outputFile );\n            }\n            else\n            {\n                getLog().info( \"NOT adding java-sources to attached artifacts list.\" );\n            }\n        }\n        else\n        {\n            getLog().info( \"No sources in project. Archive not created.\" );\n        }\n    }","commit_id":"221fdafb6c540cbb250479c1c97d3686dbbbce42","url":"https://github.com/apache/maven-plugins"},{"original_method":"protected void archiveProjectContent( MavenProject p, Archiver archiver )\n        throws MojoExecutionException\n    {\n        if ( includePom )\n        {\n            try\n            {\n                archiver.addFile( p.getFile(), p.getFile().getName() );\n            }\n            catch ( ArchiverException e )\n            {\n                throw new MojoExecutionException( \"Error adding POM file to target jar file.\", e );\n            }\n        }\n\n        for ( Iterator i = getSources( p ).iterator(); i.hasNext(); )\n        {\n            String s = (String) i.next();\n\n            File sourceDirectory = new File( s );\n\n            if ( sourceDirectory.exists() )\n            {\n                addDirectory( archiver, sourceDirectory, getCombinedIncludes( null ), getCombinedExcludes( null ) );\n            }\n        }\n\n        //MAPI: this should be taken from the resources plugin\n        for ( Iterator i = getResources( p ).iterator(); i.hasNext(); )\n        {\n            Resource resource = (Resource) i.next();\n\n            File sourceDirectory = new File( resource.getDirectory() );\n\n            if ( !sourceDirectory.exists() )\n            {\n                continue;\n            }\n\n            List resourceIncludes = resource.getIncludes();\n\n            String[] combinedIncludes = getCombinedIncludes( resourceIncludes );\n\n            List resourceExcludes = resource.getExcludes();\n\n            String[] combinedExcludes = getCombinedExcludes( resourceExcludes );\n\n            String targetPath = resource.getTargetPath();\n            if ( targetPath != null )\n            {\n                if ( !targetPath.trim().endsWith( \"/\" ) )\n                {\n                    targetPath += \"/\";\n                }\n                addDirectory( archiver, sourceDirectory, targetPath, combinedIncludes, combinedExcludes );\n            }\n            else\n            {\n                addDirectory( archiver, sourceDirectory, combinedIncludes, combinedExcludes );\n            }\n        }\n    }","id":60384,"modified_method":"protected void archiveProjectContent( MavenProject p, Archiver archiver )\n        throws MojoExecutionException\n    {\n        if ( includePom )\n        {\n            try\n            {\n                archiver.addFile( p.getFile(), p.getFile().getName() );\n            }\n            catch ( ArchiverException e )\n            {\n                throw new MojoExecutionException( \"Error adding POM file to target jar file.\", e );\n            }\n        }\n\n        for ( String s : getSources( p ))\n        {\n\n            File sourceDirectory = new File( s );\n\n            if ( sourceDirectory.exists() )\n            {\n                addDirectory( archiver, sourceDirectory, getCombinedIncludes( null ), getCombinedExcludes( null ) );\n            }\n        }\n\n        //MAPI: this should be taken from the resources plugin\n        for ( Resource resource : getResources( p ) )\n        {\n\n            File sourceDirectory = new File( resource.getDirectory() );\n\n            if ( !sourceDirectory.exists() )\n            {\n                continue;\n            }\n\n            List resourceIncludes = resource.getIncludes();\n\n            String[] combinedIncludes = getCombinedIncludes( resourceIncludes );\n\n            List resourceExcludes = resource.getExcludes();\n\n            String[] combinedExcludes = getCombinedExcludes( resourceExcludes );\n\n            String targetPath = resource.getTargetPath();\n            if ( targetPath != null )\n            {\n                if ( !targetPath.trim().endsWith( \"/\" ) )\n                {\n                    targetPath += \"/\";\n                }\n                addDirectory( archiver, sourceDirectory, targetPath, combinedIncludes, combinedExcludes );\n            }\n            else\n            {\n                addDirectory( archiver, sourceDirectory, combinedIncludes, combinedExcludes );\n            }\n        }\n    }","commit_id":"221fdafb6c540cbb250479c1c97d3686dbbbce42","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Combines the includes parameter and additional includes. Defaults to {@link #DEFAULT_INCLUDES} If the\n     * additionalIncludes parameter is null, it is not added to the combined includes.\n     * \n     * @param additionalIncludes The includes specified in the pom resources section\n     * @return The combined array of includes.\n     */\n    private String[] getCombinedIncludes( List additionalIncludes )\n    {\n        ArrayList combinedIncludes = new ArrayList();\n\n        if ( includes != null && includes.length > 0 )\n        {\n            combinedIncludes.addAll( Arrays.asList( includes ) );\n        }\n\n        if ( additionalIncludes != null && additionalIncludes.size() > 0 )\n        {\n            combinedIncludes.addAll( additionalIncludes );\n        }\n\n        // If there are no other includes, use the default.\n        if ( combinedIncludes.size() == 0 )\n        {\n            combinedIncludes.addAll( Arrays.asList( DEFAULT_INCLUDES ) );\n        }\n\n        return (String[]) combinedIncludes.toArray( new String[combinedIncludes.size()] );\n    }","id":60385,"modified_method":"/**\n     * Combines the includes parameter and additional includes. Defaults to {@link #DEFAULT_INCLUDES} If the\n     * additionalIncludes parameter is null, it is not added to the combined includes.\n     *\n     * @param additionalIncludes The includes specified in the pom resources section\n     * @return The combined array of includes.\n     */\n    private String[] getCombinedIncludes( List additionalIncludes )\n    {\n        List<String> combinedIncludes = new ArrayList<String>();\n\n        if ( includes != null && includes.length > 0 )\n        {\n            combinedIncludes.addAll( Arrays.asList( includes ) );\n        }\n\n        if ( additionalIncludes != null && additionalIncludes.size() > 0 )\n        {\n            combinedIncludes.addAll( additionalIncludes );\n        }\n\n        // If there are no other includes, use the default.\n        if ( combinedIncludes.size() == 0 )\n        {\n            combinedIncludes.addAll( Arrays.asList( DEFAULT_INCLUDES ) );\n        }\n\n        return combinedIncludes.toArray( new String[combinedIncludes.size()] );\n    }","commit_id":"221fdafb6c540cbb250479c1c97d3686dbbbce42","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    protected List getResources( MavenProject p )\n    {\n        if ( excludeResources )\n        {\n            return Collections.EMPTY_LIST;\n        }\n\n        return p.getResources();\n    }","id":60386,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    protected List<Resource> getResources( MavenProject p )\n    {\n        if ( excludeResources )\n        {\n            return Collections.emptyList();\n        }\n\n        return p.getResources();\n    }","commit_id":"221fdafb6c540cbb250479c1c97d3686dbbbce42","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    protected List getResources( MavenProject p )\n    {\n        if ( excludeResources )\n        {\n            return Collections.EMPTY_LIST;\n        }\n\n        return p.getTestResources();\n    }","id":60387,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    protected List<Resource> getResources( MavenProject p )\n    {\n        if ( excludeResources )\n        {\n            return Collections.emptyList();\n        }\n\n        return p.getTestResources();\n    }","commit_id":"221fdafb6c540cbb250479c1c97d3686dbbbce42","url":"https://github.com/apache/maven-plugins"},{"original_method":"public WorkResult execute(VersionedRoutesCompileSpec spec) {\n        boolean didWork = false;\n        Iterable<File> sources = spec.getSources();\n\n        ArrayList<File> secondaryRoutes = Lists.newArrayList();\n        CollectionUtils.filter(sources, secondaryRoutes, new Spec<File>() {\n            @Override\n            public boolean isSatisfiedBy(File file) {\n                return !file.getName().equals(\"routes\");\n            }\n        });\n\n        ArrayList<File> routes = Lists.newArrayList();\n        CollectionUtils.filter(sources, routes, new Spec<File>() {\n            @Override\n            public boolean isSatisfiedBy(File file) {\n                return file.getName().equals(\"routes\");\n            }\n        });\n\n        // Compile all secondary routes files first\n        for (File sourceFile : secondaryRoutes) {\n            Boolean ret = compile(sourceFile, spec);\n            didWork = ret || didWork;\n        }\n\n        // Compile all main routes files last\n        for (File sourceFile : routes) {\n            Boolean ret = compile(sourceFile, spec);\n            didWork = ret || didWork;\n        }\n\n        return new SimpleWorkResult(didWork);\n    }","id":60388,"modified_method":"public WorkResult execute(VersionedRoutesCompileSpec spec) {\n        boolean didWork = false;\n        // Need to compile all secondary routes (\"Foo.routes\") before primary (\"routes\")\n        ArrayList<File> primaryRoutes = Lists.newArrayList();\n        ArrayList<File> secondaryRoutes = Lists.newArrayList();\n        for (File source : spec.getSources()) {\n            if (source.getName().equals(\"routes\")) {\n                primaryRoutes.add(source);\n            } else {\n                secondaryRoutes.add(source);\n            }\n        }\n\n        // Compile all secondary routes files first\n        for (File sourceFile : secondaryRoutes) {\n            Boolean ret = compile(sourceFile, spec);\n            didWork = ret || didWork;\n        }\n\n        // Compile all main routes files last\n        for (File sourceFile : primaryRoutes) {\n            Boolean ret = compile(sourceFile, spec);\n            didWork = ret || didWork;\n        }\n\n        return new SimpleWorkResult(didWork);\n    }","commit_id":"0b63d1d963294a885b9eeb2ae465b4d1a787ba9f","url":"https://github.com/gradle/gradle"},{"original_method":"private void configureCompilerArguments(@NotNull A arguments) throws MojoExecutionException {\n        if (LOG.isDebugEnabled()) {\n            arguments.verbose = true;\n        }\n\n        List<String> sources = getSources();\n        if (sources == null || sources.isEmpty()) {\n            throw new MojoExecutionException(\"No source roots to compile\");\n        }\n\n        arguments.suppressWarnings = nowarn;\n\n        arguments.freeArgs.addAll(sources);\n        LOG.info(\"Compiling Kotlin sources from \" + sources );\n\n        configureSpecificCompilerArguments(arguments);\n\n        try {\n            Args.parse(arguments, ArrayUtil.toStringArray(args));\n        }\n        catch (IllegalArgumentException e) {\n            throw new MojoExecutionException(e.getMessage());\n        }\n\n        if (arguments.noInline) {\n            LOG.info(\"Method inlining is turned off\");\n        }\n    }","id":60389,"modified_method":"private void configureCompilerArguments(@NotNull A arguments) throws MojoExecutionException {\n        if (LOG.isDebugEnabled()) {\n            arguments.verbose = true;\n        }\n\n        List<String> sources = new ArrayList<String>();\n        for (String source : getSources()) {\n            if (new File(source).exists()) {\n                sources.add(source);\n            }\n            else {\n                LOG.warn(\"Source root doesn't exist: \" + source);\n            }\n        }\n\n        if (sources == null || sources.isEmpty()) {\n            throw new MojoExecutionException(\"No source roots to compile\");\n        }\n\n        arguments.suppressWarnings = nowarn;\n\n        arguments.freeArgs.addAll(sources);\n        LOG.info(\"Compiling Kotlin sources from \" + sources);\n\n        configureSpecificCompilerArguments(arguments);\n\n        try {\n            Args.parse(arguments, ArrayUtil.toStringArray(args));\n        }\n        catch (IllegalArgumentException e) {\n            throw new MojoExecutionException(e.getMessage());\n        }\n\n        if (arguments.noInline) {\n            LOG.info(\"Method inlining is turned off\");\n        }\n    }","commit_id":"606ea7bb70cfe58d9de757da3ed52ed98a39a18a","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n     * Returns the document type factory used for the given resource in this index, or <code>null<\/code>  \n     * in case the resource is not indexed by this index.<p>\n     * \n     * A resource is indexed if the following is all true: <ol>\n     * <li>The index contains at last one index source matching the root path of the given resource.\n     * <li>For this matching index source, the document type factory needed by the resource is also configured.\n     * <\/ol>\n     * \n     * @param res the resource to check\n     * \n     * @return he document type factory used for the given resource in this index, or <code>null<\/code>  \n     * in case the resource is not indexed by this index\n     */\n    public I_CmsDocumentFactory getDocumentFactory(CmsResource res) {\n\n        if ((res != null) && (getSources() != null)) {\n            // the result can only be null or the type configured for the resource\n            I_CmsDocumentFactory result = OpenCms.getSearchManager().getDocumentFactory(res);\n            if (result != null) {\n                // check the path of the resource if it matches with one (or more) of the configured index sources\n                Iterator<CmsSearchIndexSource> i = getSources().iterator();\n                while (i.hasNext()) {\n                    CmsSearchIndexSource source = i.next();\n                    if (source.isIndexing(res.getRootPath(), result.getName())) {\n                        // we found an index source that indexes the resource\n                        return result;\n                    }\n                }\n            }\n        }\n        return null;\n    }","id":60390,"modified_method":"/**\n     * Returns the document type factory used for the given resource in this index, or <code>null<\/code>  \n     * in case the resource is not indexed by this index.<p>\n     * \n     * A resource is indexed if the following is all true: <ol>\n     * <li>The index contains at last one index source matching the root path of the given resource.\n     * <li>For this matching index source, the document type factory needed by the resource is also configured.\n     * <\/ol>\n     * \n     * @param res the resource to check\n     * \n     * @return he document type factory used for the given resource in this index, or <code>null<\/code>  \n     * in case the resource is not indexed by this index\n     */\n    public I_CmsDocumentFactory getDocumentFactory(CmsResource res) {\n\n        if ((res != null) && (getSources() != null)) {\n            // the result can only be null or the type configured for the resource\n            I_CmsDocumentFactory result = OpenCms.getSearchManager().getDocumentFactory(res);\n            if (result != null) {\n                // check the path of the resource if it matches with one (or more) of the configured index sources\n                for (CmsSearchIndexSource source : getSources()) {\n                    if (source.isIndexing(res.getRootPath(), result.getName())\n                        || (source.isIndexing(res.getRootPath(), TYPE_XMLCONTENT) && CmsResourceTypeXmlContent.isXmlContent(res))) {\n                        // we found an index source that indexes the resource\n                        return result;\n                    }\n                }\n            }\n        }\n        return null;\n    }","commit_id":"9439933c94237dcde5bffbcac95030547b3685e8","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public SendableRequest removeFirst() {\n\t\t// Priorities start at 0\n\t\tif(logMINOR) Logger.minor(this, \"removeFirst()\");\n\t\tint choosenPriorityClass = removeFirstAccordingToPriorities();\n\t\tif(choosenPriorityClass == -1) {\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Nothing to do\");\n\t\t\treturn null;\n\t\t}\n\t\tSortedVectorByNumber s = priorities[choosenPriorityClass];\n\t\tif(s != null){\n\t\t\twhile(true) {\n\t\t\t\tSectoredRandomGrabArrayWithInt rga = (SectoredRandomGrabArrayWithInt) s.getFirst();\n\t\t\t\tif(rga == null) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"No retrycount's left\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Got retry count tracker \"+rga);\n\t\t\t\tSendableRequest req = (SendableRequest) rga.removeRandom();\n\t\t\t\tif(rga.isEmpty()) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Removing retrycount \"+rga.getNumber());\n\t\t\t\t\ts.remove(rga.getNumber());\n\t\t\t\t\tif(s.isEmpty()) {\n\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Should remove priority \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(req == null) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"No requests, adjusted retrycount \"+rga.getNumber()+\" (\"+rga+ ')');\n\t\t\t\t\tbreak;\n\t\t\t\t} else if(req.getPriorityClass() != choosenPriorityClass) {\n\t\t\t\t\t// Reinsert it : shouldn't happen if we are calling reregisterAll,\n\t\t\t\t\t// maybe we should ask people to report that error if seen\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"In wrong priority class: \"+req+\" (req.prio=\"+req.getPriorityClass()+\" but chosen=\"+choosenPriorityClass+ ')');\n\t\t\t\t\tinnerRegister(req);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(logMINOR) Logger.minor(this, \"removeFirst() returning \"+req+\" (\"+rga.getNumber()+\", prio \"+\n\t\t\t\t\t\treq.getPriorityClass()+\", retries \"+req.getRetryCount()+\", client \"+req.getClient()+\", client-req \"+req.getClientRequest()+ ')');\n\t\t\t\tClientRequester cr = req.getClientRequest();\n\t\t\t\tif(req.canRemove()) {\n\t\t\t\t\tHashSet v = (HashSet) allRequestsByClientRequest.get(cr);\n\t\t\t\t\tif(v == null) {\n\t\t\t\t\t\tLogger.error(this, \"No HashSet registered for \"+cr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv.remove(req);\n\t\t\t\t\t\tif(v.isEmpty())\n\t\t\t\t\t\t\tallRequestsByClientRequest.remove(cr);\n\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Removed from \"+v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(logMINOR) Logger.minor(this, \"removeFirst() returning \"+req);\n\t\t\t\treturn req;\n\t\t\t}\n\t\t}\n\t\tif(logMINOR) Logger.minor(this, \"No requests to run\");\n\t\treturn null;\n\t}","id":60391,"modified_method":"public SendableRequest removeFirst() {\n\t\t// Priorities start at 0\n\t\tif(logMINOR) Logger.minor(this, \"removeFirst()\");\n\t\tint choosenPriorityClass = removeFirstAccordingToPriorities();\n\t\tif(choosenPriorityClass == -1) {\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Nothing to do\");\n\t\t\treturn null;\n\t\t}\n\t\tSortedVectorByNumber s = priorities[choosenPriorityClass];\n\t\tif(s != null){\n\t\t\twhile(true) {\n\t\t\t\tSectoredRandomGrabArrayWithInt rga = (SectoredRandomGrabArrayWithInt) s.getFirst();\n\t\t\t\tif(rga == null) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"No retrycount's left\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Got retry count tracker \"+rga);\n\t\t\t\tSendableRequest req = (SendableRequest) rga.removeRandom();\n\t\t\t\tif(rga.isEmpty()) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Removing retrycount \"+rga.getNumber());\n\t\t\t\t\ts.remove(rga.getNumber());\n\t\t\t\t\tif(s.isEmpty()) {\n\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Should remove priority \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(req == null) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"No requests, adjusted retrycount \"+rga.getNumber()+\" (\"+rga+ ')');\n\t\t\t\t\tbreak;\n\t\t\t\t} else if(req.getPriorityClass() != choosenPriorityClass) {\n\t\t\t\t\t// Reinsert it : shouldn't happen if we are calling reregisterAll,\n\t\t\t\t\t// maybe we should ask people to report that error if seen\n\t\t\t\t\tLogger.normal(this, \"In wrong priority class: \"+req+\" (req.prio=\"+req.getPriorityClass()+\" but chosen=\"+choosenPriorityClass+ ')');\n\t\t\t\t\tinnerRegister(req);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(logMINOR) Logger.debug(this, \"removeFirst() returning \"+req+\" (\"+rga.getNumber()+\", prio \"+\n\t\t\t\t\t\treq.getPriorityClass()+\", retries \"+req.getRetryCount()+\", client \"+req.getClient()+\", client-req \"+req.getClientRequest()+ ')');\n\t\t\t\tClientRequester cr = req.getClientRequest();\n\t\t\t\tif(req.canRemove()) {\n\t\t\t\t\tHashSet v = (HashSet) allRequestsByClientRequest.get(cr);\n\t\t\t\t\tif(v == null) {\n\t\t\t\t\t\tLogger.error(this, \"No HashSet registered for \"+cr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv.remove(req);\n\t\t\t\t\t\tif(v.isEmpty())\n\t\t\t\t\t\t\tallRequestsByClientRequest.remove(cr);\n\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Removed from \"+v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(logMINOR) Logger.minor(this, \"removeFirst() returning \"+req);\n\t\t\t\treturn req;\n\t\t\t}\n\t\t}\n\t\tif(logMINOR) Logger.minor(this, \"No requests to run\");\n\t\treturn null;\n\t}","commit_id":"5a4828d2def12a5dc4f95ea287d75f7013190a2c","url":"https://github.com/freenet/fred"},{"original_method":"public void handleRequestJar(Message m, final PeerNode source, boolean isExt) {\n\t\tfinal String name = isExt ? \"ext\" : \"main\";\n\n                if(source.isOpennet() && updateManager.isSeednode()) {\n                    if(logMINOR) Logger.minor(this, \"Peer \"+source+\" asked us for the blob file for \"+name+\"; We are a seenode, so we ignore it!\");\n                    return;\n                }\n                // Do we have the data?\n\n\t\tint version = isExt ? updateManager.newExtJarVersion() : updateManager.newMainJarVersion();\n\t\tFile data = isExt ? updateManager.getExtBlob(version) : updateManager.getMainBlob(version);\n\n\t\tif(data == null) {\n\t\t\tLogger.normal(this, \"Peer \" + source + \" asked us for the blob file for the \"+name+\" jar but we don't have it!\");\n\t\t\t// Probably a race condition on reconnect, hopefully we'll be asked again\n\t\t\treturn;\n\t\t}\n\n\t\tfinal long uid = m.getLong(DMT.UID);\n\n\t\tfinal RandomAccessFileWrapper raf;\n\t\ttry {\n\t\t\traf = new RandomAccessFileWrapper(data, \"r\");\n\t\t} catch(FileNotFoundException e) {\n\t\t\tLogger.error(this, \"Peer \" + source + \" asked us for the blob file for the \"+name+\" jar, we have downloaded it but don't have the file even though we did have it when we checked!: \" + e, e);\n\t\t\treturn;\n\t\t}\n\n\t\tfinal PartiallyReceivedBulk prb;\n\t\tlong length;\n\t\ttry {\n\t\t\tlength = raf.size();\n\t\t\tprb = new PartiallyReceivedBulk(updateManager.node.getUSM(), length,\n\t\t\t\tNode.PACKET_SIZE, raf, true);\n\t\t} catch(IOException e) {\n\t\t\tLogger.error(this, \"Peer \" + source + \" asked us for the blob file for the \"+name+\" jar, we have downloaded it but we can't determine the file size: \" + e, e);\n\t\t\traf.close();\n\t\t\treturn;\n\t\t}\n\n\t\tfinal BulkTransmitter bt;\n\t\ttry {\n\t\t\tbt = new BulkTransmitter(prb, source, uid, false, updateManager.ctr);\n\t\t} catch(DisconnectedException e) {\n\t\t\tLogger.error(this, \"Peer \" + source + \" asked us for the blob file for the \"+name+\" jar, then disconnected: \" + e, e);\n\t\t\traf.close();\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Runnable r = new Runnable() {\n\n\t\t\tpublic void run() {\n\t\t\t\tif(!bt.send())\n\t\t\t\t\tLogger.error(this, \"Failed to send \"+name+\" jar blob to \" + source.userToString() + \" : \" + bt.getCancelReason());\n\t\t\t\telse\n\t\t\t\t\tLogger.normal(this, \"Sent \"+name+\" jar blob to \" + source.userToString());\n\t\t\t\traf.close();\n\t\t\t}\n\t\t};\n\n\t\tMessage msg =\n\t\t\tisExt ? DMT.createUOMSendingExtra(uid, length, updateManager.extURI.toString(), version) :\n\t\t\t\tDMT.createUOMSendingMain(uid, length, updateManager.updateURI.toString(), version);\n\n\t\ttry {\n\t\t\tsource.sendAsync(msg, new AsyncMessageCallback() {\n\n\t\t\t\tpublic void acknowledged() {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Sending data...\");\n\t\t\t\t\t// Send the data\n\n\t\t\t\t\tupdateManager.node.executor.execute(r, name+\" jar send for \" + uid + \" to \" + source.userToString());\n\t\t\t\t}\n\n\t\t\t\tpublic void disconnected() {\n\t\t\t\t\t// Argh\n\t\t\t\t\tLogger.error(this, \"Peer \" + source + \" asked us for the blob file for the \"+name+\" jar, then disconnected when we tried to send the UOMSendingMain\");\n\t\t\t\t}\n\n\t\t\t\tpublic void fatalError() {\n\t\t\t\t\t// Argh\n\t\t\t\t\tLogger.error(this, \"Peer \" + source + \" asked us for the blob file for the \"+name+\" jar, then got a fatal error when we tried to send the UOMSendingMain\");\n\t\t\t\t}\n\n\t\t\t\tpublic void sent() {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Message sent, data soon\");\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic String toString() {\n\t\t\t\t\treturn super.toString() + \"(\" + uid + \":\" + source.getPeer() + \")\";\n\t\t\t\t}\n\t\t\t}, updateManager.ctr);\n\t\t} catch(NotConnectedException e) {\n\t\t\tLogger.error(this, \"Peer \" + source + \" asked us for the blob file for the \"+name+\" jar, then disconnected when we tried to send the UOMSendingExt: \" + e, e);\n\t\t\treturn;\n\t\t}\n\n\t}","id":60392,"modified_method":"public void handleRequestJar(Message m, final PeerNode source, boolean isExt) {\n\t\tfinal String name = isExt ? \"ext\" : \"main\";\n\n                if(source.isOpennet() && updateManager.isSeednode()) {\n\t\t\t\t\tLogger.normal(this, \"Peer \"+source+\" asked us for the blob file for \"+name+\"; We are a seenode, so we ignore it!\");\n                    return;\n                }\n                // Do we have the data?\n\n\t\tint version = isExt ? updateManager.newExtJarVersion() : updateManager.newMainJarVersion();\n\t\tFile data = isExt ? updateManager.getExtBlob(version) : updateManager.getMainBlob(version);\n\n\t\tif(data == null) {\n\t\t\tLogger.normal(this, \"Peer \" + source + \" asked us for the blob file for the \"+name+\" jar but we don't have it!\");\n\t\t\t// Probably a race condition on reconnect, hopefully we'll be asked again\n\t\t\treturn;\n\t\t}\n\n\t\tfinal long uid = m.getLong(DMT.UID);\n\n\t\tfinal RandomAccessFileWrapper raf;\n\t\ttry {\n\t\t\traf = new RandomAccessFileWrapper(data, \"r\");\n\t\t} catch(FileNotFoundException e) {\n\t\t\tLogger.error(this, \"Peer \" + source + \" asked us for the blob file for the \"+name+\" jar, we have downloaded it but don't have the file even though we did have it when we checked!: \" + e, e);\n\t\t\treturn;\n\t\t}\n\n\t\tfinal PartiallyReceivedBulk prb;\n\t\tlong length;\n\t\ttry {\n\t\t\tlength = raf.size();\n\t\t\tprb = new PartiallyReceivedBulk(updateManager.node.getUSM(), length,\n\t\t\t\tNode.PACKET_SIZE, raf, true);\n\t\t} catch(IOException e) {\n\t\t\tLogger.error(this, \"Peer \" + source + \" asked us for the blob file for the \"+name+\" jar, we have downloaded it but we can't determine the file size: \" + e, e);\n\t\t\traf.close();\n\t\t\treturn;\n\t\t}\n\n\t\tfinal BulkTransmitter bt;\n\t\ttry {\n\t\t\tbt = new BulkTransmitter(prb, source, uid, false, updateManager.ctr);\n\t\t} catch(DisconnectedException e) {\n\t\t\tLogger.error(this, \"Peer \" + source + \" asked us for the blob file for the \"+name+\" jar, then disconnected: \" + e, e);\n\t\t\traf.close();\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Runnable r = new Runnable() {\n\n\t\t\tpublic void run() {\n\t\t\t\tif(!bt.send())\n\t\t\t\t\tLogger.error(this, \"Failed to send \"+name+\" jar blob to \" + source.userToString() + \" : \" + bt.getCancelReason());\n\t\t\t\telse\n\t\t\t\t\tLogger.normal(this, \"Sent \"+name+\" jar blob to \" + source.userToString());\n\t\t\t\traf.close();\n\t\t\t}\n\t\t};\n\n\t\tMessage msg =\n\t\t\tisExt ? DMT.createUOMSendingExtra(uid, length, updateManager.extURI.toString(), version) :\n\t\t\t\tDMT.createUOMSendingMain(uid, length, updateManager.updateURI.toString(), version);\n\n\t\ttry {\n\t\t\tsource.sendAsync(msg, new AsyncMessageCallback() {\n\n\t\t\t\tpublic void acknowledged() {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Sending data...\");\n\t\t\t\t\t// Send the data\n\n\t\t\t\t\tupdateManager.node.executor.execute(r, name+\" jar send for \" + uid + \" to \" + source.userToString());\n\t\t\t\t}\n\n\t\t\t\tpublic void disconnected() {\n\t\t\t\t\t// Argh\n\t\t\t\t\tLogger.error(this, \"Peer \" + source + \" asked us for the blob file for the \"+name+\" jar, then disconnected when we tried to send the UOMSendingMain\");\n\t\t\t\t}\n\n\t\t\t\tpublic void fatalError() {\n\t\t\t\t\t// Argh\n\t\t\t\t\tLogger.error(this, \"Peer \" + source + \" asked us for the blob file for the \"+name+\" jar, then got a fatal error when we tried to send the UOMSendingMain\");\n\t\t\t\t}\n\n\t\t\t\tpublic void sent() {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Message sent, data soon\");\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic String toString() {\n\t\t\t\t\treturn super.toString() + \"(\" + uid + \":\" + source.getPeer() + \")\";\n\t\t\t\t}\n\t\t\t}, updateManager.ctr);\n\t\t} catch(NotConnectedException e) {\n\t\t\tLogger.error(this, \"Peer \" + source + \" asked us for the blob file for the \"+name+\" jar, then disconnected when we tried to send the UOMSendingExt: \" + e, e);\n\t\t\treturn;\n\t\t}\n\n\t}","commit_id":"73e85c45b19c02a438e6fdde91bd808cf9e1511f","url":"https://github.com/freenet/fred"},{"original_method":"private void sendUOMRequest(final PeerNode source, boolean addOnFail, final boolean isExt) {\n\t\tfinal String name = isExt ? \"Extra\" : \"Main\";\n\t\tString lname = isExt ? \"ext\" : \"main\";\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"sendUOMRequest\"+name+\"(\" + source + \",\" + addOnFail + \")\");\n\t\tif(!source.isConnected() || source.isSeed())\n\t\t\treturn;\n\t\tfinal HashSet<PeerNode> sendingJar = isExt ? nodesSendingExtJar : nodesSendingMainJar;\n\t\tfinal HashSet<PeerNode> askedSendJar = isExt ? nodesAskedSendExtJar : nodesAskedSendMainJar;\n\t\tsynchronized(this) {\n\t\t\tlong offeredVersion = isExt ? source.getExtJarOfferedVersion() : source.getMainJarOfferedVersion();\n\t\t\tlong updateVersion = isExt ? updateManager.newExtJarVersion() : updateManager.newMainJarVersion();\n\t\t\tif(offeredVersion < updateVersion) {\n\t\t\t\tif(offeredVersion <= 0)\n\t\t\t\t\tLogger.error(this, \"Not sending UOM \"+lname+\" request to \" + source + \" because it hasn't offered anything!\");\n\t\t\t\telse\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Not sending UOM \"+lname+\" request to \" + source + \" because we already have its offered version \" + offeredVersion);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint curVersion = isExt ? updateManager.getExtVersion() : updateManager.getMainVersion();\n\t\t\tif(curVersion >= offeredVersion) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Not fetching from \" + source + \" because current \"+lname+\" jar version \" + curVersion + \" is more recent than \" + offeredVersion);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(askedSendJar.contains(source)) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Recently asked node \" + source + \" (\"+lname+\") so not re-asking yet.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(addOnFail && askedSendJar.size() + sendingJar.size() >= MAX_NODES_SENDING_JAR) {\n\t\t\t\tHashSet<PeerNode> offeredJar = isExt ? nodesOfferedExtJar : nodesOfferedMainJar;\n\t\t\t\tif(offeredJar.add(source))\n\t\t\t\t\tSystem.err.println(\"Offered \"+lname+\" jar by \" + source.userToString() + \" (already fetching from \" + sendingJar.size() + \"), but will use this offer if our current fetches fail).\");\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tif(sendingJar.contains(source)) {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Not fetching \"+lname+\" jar from \" + source.userToString() + \" because already fetching from that node\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsendingJar.add(source);\n\t\t\t}\n\t\t}\n\n\t\tMessage msg = isExt ? DMT.createUOMRequestExtra(updateManager.node.random.nextLong()) :\n\t\t\tDMT.createUOMRequestMain(updateManager.node.random.nextLong());\n\n\t\ttry {\n\t\t\tSystem.err.println(\"Fetching \"+lname+\" jar from \" + source.userToString());\n\t\t\tsource.sendAsync(msg, new AsyncMessageCallback() {\n\n\t\t\t\tpublic void acknowledged() {\n\t\t\t\t\t// Cool! Wait for the actual transfer.\n\t\t\t\t}\n\n\t\t\t\tpublic void disconnected() {\n\t\t\t\t\tLogger.normal(this, \"Disconnected from \" + source.userToString() + \" after sending UOMRequest\"+name);\n\t\t\t\t\tsynchronized(UpdateOverMandatoryManager.this) {\n\t\t\t\t\t\tsendingJar.remove(source);\n\t\t\t\t\t}\n\t\t\t\t\tif(isExt)\n\t\t\t\t\t\tmaybeRequestExtJar();\n\t\t\t\t\telse\n\t\t\t\t\t\tmaybeRequestMainJar();\n\t\t\t\t}\n\n\t\t\t\tpublic void fatalError() {\n\t\t\t\t\tLogger.normal(this, \"Fatal error from \" + source.userToString() + \" after sending UOMRequest\"+name);\n\t\t\t\t\tsynchronized(UpdateOverMandatoryManager.this) {\n\t\t\t\t\t\taskedSendJar.remove(source);\n\t\t\t\t\t}\n\t\t\t\t\tif(isExt)\n\t\t\t\t\t\tmaybeRequestExtJar();\n\t\t\t\t\telse\n\t\t\t\t\t\tmaybeRequestMainJar();\n\t\t\t\t}\n\n\t\t\t\tpublic void sent() {\n\t\t\t\t\t// Timeout...\n\t\t\t\t\tupdateManager.node.ticker.queueTimedJob(new Runnable() {\n\n\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\tsynchronized(UpdateOverMandatoryManager.this) {\n\t\t\t\t\t\t\t\tif(!askedSendJar.contains(source))\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\taskedSendJar.remove(source); // free up a slot\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(isExt)\n\t\t\t\t\t\t\t\tmaybeRequestExtJar();\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tmaybeRequestMainJar();\n\t\t\t\t\t\t}\n\t\t\t\t\t}, REQUEST_MAIN_JAR_TIMEOUT);\n\t\t\t\t}\n\t\t\t}, updateManager.ctr);\n\t\t} catch(NotConnectedException e) {\n\t\t\tsynchronized(this) {\n\t\t\t\taskedSendJar.remove(source);\n\t\t\t}\n\t\t\tif(isExt)\n\t\t\t\tmaybeRequestExtJar();\n\t\t\telse\n\t\t\t\tmaybeRequestMainJar();\n\t\t}\n\t}","id":60393,"modified_method":"private void sendUOMRequest(final PeerNode source, boolean addOnFail, final boolean isExt) {\n\t\tfinal String name = isExt ? \"Extra\" : \"Main\";\n\t\tString lname = isExt ? \"ext\" : \"main\";\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"sendUOMRequest\"+name+\"(\" + source + \",\" + addOnFail + \")\");\n\t\tif(!source.isConnected() || source.isSeed()) {\n                    if(logMINOR) Logger.minor(this, \"Not sending UOM \"+lname+\" request to \"+source+\" (disconnected or seednode)\");\n                    return;\n                }\n\t\tfinal HashSet<PeerNode> sendingJar = isExt ? nodesSendingExtJar : nodesSendingMainJar;\n\t\tfinal HashSet<PeerNode> askedSendJar = isExt ? nodesAskedSendExtJar : nodesAskedSendMainJar;\n\t\tsynchronized(this) {\n\t\t\tlong offeredVersion = isExt ? source.getExtJarOfferedVersion() : source.getMainJarOfferedVersion();\n\t\t\tlong updateVersion = isExt ? updateManager.newExtJarVersion() : updateManager.newMainJarVersion();\n\t\t\tif(offeredVersion < updateVersion) {\n\t\t\t\tif(offeredVersion <= 0)\n\t\t\t\t\tLogger.error(this, \"Not sending UOM \"+lname+\" request to \" + source + \" because it hasn't offered anything!\");\n\t\t\t\telse\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Not sending UOM \"+lname+\" request to \" + source + \" because we already have its offered version \" + offeredVersion);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint curVersion = isExt ? updateManager.getExtVersion() : updateManager.getMainVersion();\n\t\t\tif(curVersion >= offeredVersion) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Not fetching from \" + source + \" because current \"+lname+\" jar version \" + curVersion + \" is more recent than \" + offeredVersion);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(askedSendJar.contains(source)) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Recently asked node \" + source + \" (\"+lname+\") so not re-asking yet.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(addOnFail && askedSendJar.size() + sendingJar.size() >= MAX_NODES_SENDING_JAR) {\n\t\t\t\tHashSet<PeerNode> offeredJar = isExt ? nodesOfferedExtJar : nodesOfferedMainJar;\n\t\t\t\tif(offeredJar.add(source))\n\t\t\t\t\tSystem.err.println(\"Offered \"+lname+\" jar by \" + source.userToString() + \" (already fetching from \" + sendingJar.size() + \"), but will use this offer if our current fetches fail).\");\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tif(sendingJar.contains(source)) {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Not fetching \"+lname+\" jar from \" + source.userToString() + \" because already fetching from that node\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsendingJar.add(source);\n\t\t\t}\n\t\t}\n\n\t\tMessage msg = isExt ? DMT.createUOMRequestExtra(updateManager.node.random.nextLong()) :\n\t\t\tDMT.createUOMRequestMain(updateManager.node.random.nextLong());\n\n\t\ttry {\n\t\t\tSystem.err.println(\"Fetching \"+lname+\" jar from \" + source.userToString());\n\t\t\tsource.sendAsync(msg, new AsyncMessageCallback() {\n\n\t\t\t\tpublic void acknowledged() {\n\t\t\t\t\t// Cool! Wait for the actual transfer.\n\t\t\t\t}\n\n\t\t\t\tpublic void disconnected() {\n\t\t\t\t\tLogger.normal(this, \"Disconnected from \" + source.userToString() + \" after sending UOMRequest\"+name);\n\t\t\t\t\tsynchronized(UpdateOverMandatoryManager.this) {\n\t\t\t\t\t\tsendingJar.remove(source);\n\t\t\t\t\t}\n\t\t\t\t\tif(isExt)\n\t\t\t\t\t\tmaybeRequestExtJar();\n\t\t\t\t\telse\n\t\t\t\t\t\tmaybeRequestMainJar();\n\t\t\t\t}\n\n\t\t\t\tpublic void fatalError() {\n\t\t\t\t\tLogger.normal(this, \"Fatal error from \" + source.userToString() + \" after sending UOMRequest\"+name);\n\t\t\t\t\tsynchronized(UpdateOverMandatoryManager.this) {\n\t\t\t\t\t\taskedSendJar.remove(source);\n\t\t\t\t\t}\n\t\t\t\t\tif(isExt)\n\t\t\t\t\t\tmaybeRequestExtJar();\n\t\t\t\t\telse\n\t\t\t\t\t\tmaybeRequestMainJar();\n\t\t\t\t}\n\n\t\t\t\tpublic void sent() {\n\t\t\t\t\t// Timeout...\n\t\t\t\t\tupdateManager.node.ticker.queueTimedJob(new Runnable() {\n\n\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\tsynchronized(UpdateOverMandatoryManager.this) {\n\t\t\t\t\t\t\t\tif(!askedSendJar.contains(source))\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\taskedSendJar.remove(source); // free up a slot\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(isExt)\n\t\t\t\t\t\t\t\tmaybeRequestExtJar();\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tmaybeRequestMainJar();\n\t\t\t\t\t\t}\n\t\t\t\t\t}, REQUEST_MAIN_JAR_TIMEOUT);\n\t\t\t\t}\n\t\t\t}, updateManager.ctr);\n\t\t} catch(NotConnectedException e) {\n\t\t\tsynchronized(this) {\n\t\t\t\taskedSendJar.remove(source);\n\t\t\t}\n\t\t\tif(isExt)\n\t\t\t\tmaybeRequestExtJar();\n\t\t\telse\n\t\t\t\tmaybeRequestMainJar();\n\t\t}\n\t}","commit_id":"73e85c45b19c02a438e6fdde91bd808cf9e1511f","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Send a block of encoded bytes to a peer. This is called by\n\t * send, and by IncomingPacketFilter.processOutgoing(..).\n     * @param blockToSend The data block to send.\n     * @param destination The peer to send it to.\n     */\n    public void sendPacket(byte[] blockToSend, Peer destination, boolean allowLocalAddresses) throws LocalAddressException {\n    \tassert(blockToSend != null);\n    \tif(!_active) {\n    \t\tLogger.error(this, \"Trying to send packet but no longer active\");\n    \t\t// It is essential that for recording accurate AddressTracker data that we don't send any more\n    \t\t// packets after shutdown.\n    \t\treturn;\n    \t}\n\t\t// there should be no DNS needed here, but go ahead if we can, but complain doing it\n\t\tif( destination.getAddress(false, allowLocalAddresses) == null ) {\n  \t\t\tLogger.error(this, \"Tried sending to destination without pre-looked up IP address(needs a real Peer.getHostname()): null:\" + destination.getPort(), new Exception(\"error\"));\n\t\t\tif( destination.getAddress(true, allowLocalAddresses) == null ) {\n  \t\t\t\tLogger.error(this, \"Tried sending to bad destination address: null:\" + destination.getPort(), new Exception(\"error\"));\n  \t\t\t\treturn;\n  \t\t\t}\n  \t\t}\n\t\tif (_dropProbability > 0) {\n\t\t\tif (dropRandom.nextInt() % _dropProbability == 0) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"DROPPED: \" + _sock.getLocalPort() + \" -> \" + destination.getPort());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tInetAddress address = destination.getAddress(false, allowLocalAddresses);\n\t\tassert(address != null);\n\t\tint port = destination.getPort();\n\t\tDatagramPacket packet = new DatagramPacket(blockToSend, blockToSend.length);\n\t\tpacket.setAddress(address);\n\t\tpacket.setPort(port);\n\t\t\n\t\t\n\t\ttry {\n\t\t\t_sock.send(packet);\n\t\t\ttracker.sentPacketTo(destination);\n\t\t\tcollector.addInfo(address + \":\" + port, 0, blockToSend.length + UDP_HEADERS_LENGTH); \n\t\t\tif(logMINOR) Logger.minor(this, \"Sent packet length \"+blockToSend.length+\" to \"+address+':'+port);\n\t\t} catch (IOException e) {\n\t\t\tif(packet.getAddress() instanceof Inet6Address)\n\t\t\t\tLogger.normal(this, \"Error while sending packet to IPv6 address: \"+destination+\": \"+e, e);\n\t\t\telse\n\t\t\t\tLogger.error(this, \"Error while sending packet to \" + destination+\": \"+e, e);\n\t\t}\n    }","id":60394,"modified_method":"/**\n\t * Send a block of encoded bytes to a peer. This is called by\n\t * send, and by IncomingPacketFilter.processOutgoing(..).\n     * @param blockToSend The data block to send.\n     * @param destination The peer to send it to.\n     */\n    public void sendPacket(byte[] blockToSend, Peer destination, boolean allowLocalAddresses) throws LocalAddressException {\n    \tassert(blockToSend != null);\n    \tif(!_active) {\n    \t\tLogger.error(this, \"Trying to send packet but no longer active\");\n    \t\t// It is essential that for recording accurate AddressTracker data that we don't send any more\n    \t\t// packets after shutdown.\n    \t\treturn;\n    \t}\n\t\t// there should be no DNS needed here, but go ahead if we can, but complain doing it\n\t\tif( destination.getAddress(false, allowLocalAddresses) == null ) {\n  \t\t\tLogger.error(this, \"Tried sending to destination without pre-looked up IP address(needs a real Peer.getHostname()): null:\" + destination.getPort(), new Exception(\"error\"));\n\t\t\tif( destination.getAddress(true, allowLocalAddresses) == null ) {\n  \t\t\t\tLogger.error(this, \"Tried sending to bad destination address: null:\" + destination.getPort(), new Exception(\"error\"));\n  \t\t\t\treturn;\n  \t\t\t}\n  \t\t}\n\t\tif (_dropProbability > 0) {\n\t\t\tif (dropRandom.nextInt() % _dropProbability == 0) {\n\t\t\t\tLogger.normal(this, \"DROPPED: \" + _sock.getLocalPort() + \" -> \" + destination.getPort());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tInetAddress address = destination.getAddress(false, allowLocalAddresses);\n\t\tassert(address != null);\n\t\tint port = destination.getPort();\n\t\tDatagramPacket packet = new DatagramPacket(blockToSend, blockToSend.length);\n\t\tpacket.setAddress(address);\n\t\tpacket.setPort(port);\n\t\t\n\t\t\n\t\ttry {\n\t\t\t_sock.send(packet);\n\t\t\ttracker.sentPacketTo(destination);\n\t\t\tcollector.addInfo(address + \":\" + port, 0, blockToSend.length + UDP_HEADERS_LENGTH); \n\t\t\tif(logMINOR) Logger.minor(this, \"Sent packet length \"+blockToSend.length+\" to \"+address+':'+port);\n\t\t} catch (IOException e) {\n\t\t\tif(packet.getAddress() instanceof Inet6Address)\n\t\t\t\tLogger.normal(this, \"Error while sending packet to IPv6 address: \"+destination+\": \"+e, e);\n\t\t\telse\n\t\t\t\tLogger.error(this, \"Error while sending packet to \" + destination+\": \"+e, e);\n\t\t}\n    }","commit_id":"3ef63aeeda77d75a151354ba3ef639a0ab609e76","url":"https://github.com/freenet/fred"},{"original_method":"public static NativeBigInteger[] getParams() {\n\t\tsynchronized (precalcBuffer) {\n\t\t\t//Ensure that we will have something to pop (at least pretty soon)\n\t\t\taskRefill(); \n\n\t\t\tif(!precalcBuffer.isEmpty()) {\n\t\t\t\treturn (NativeBigInteger[]) precalcBuffer.pop();\n\t\t\t}\n\n\t\t}\n\t\treturn genParams();\n\t}","id":60395,"modified_method":"public static NativeBigInteger[] getParams() {\n\t\tsynchronized (precalcBuffer) {\n\t\t\t//Ensure that we will have something to pop (at least pretty soon)\n\t\t\taskRefill(); \n\n\t\t\tif(!precalcBuffer.isEmpty()) {\n\t\t\t\treturn (NativeBigInteger[]) precalcBuffer.pop();\n\t\t\t}\n\n\t\t}\n\t\tLogger.normal(DiffieHellman.class, \"DiffieHellman had to generate a parameter on thread! (report if that happens often)\");\n\t\treturn genParams();\n\t}","commit_id":"0381d9a1e5a0ae456b580478aa706677667cf995","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Change the transient key used by JFK.\n\t * \n\t * It will determine the PFS interval, hence we call it at least once every 30mins.\n\t * \n\t * @return True if we reset the transient key and therefore the authenticator cache.\n\t */\n\tprivate boolean maybeResetTransientKey() {\n\t\tlong now = System.currentTimeMillis();\n\t\tboolean isCacheTooBig = true;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tif(authenticatorCache.size() < AUTHENTICATOR_CACHE_SIZE) {\n\t\t\t\tisCacheTooBig = false;\n\t\t\t\tif(now - timeLastReset < TRANSIENT_KEY_REKEYING_MIN_INTERVAL)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttimeLastReset = now;\n\n\t\t\tnode.random.nextBytes(transientKey);\n\t\t\t\n\t\t\t// reset the authenticator cache\n\t\t\tauthenticatorCache.clear();\n\t\t}\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Reset the JFK transitent key because \"+(isCacheTooBig ? (\"the cache's capacity is exeeded (\"+authenticatorCache.size()+')') : \"it's time to rekey\") + this);\n\t\tnode.getTicker().queueTimedJob(transientKeyRekeyer, \"JFKmaybeResetTransitentKey \"+now, TRANSIENT_KEY_REKEYING_MIN_INTERVAL, false);\n\t\tLogger.normal(this, \"JFK's TransientKey has been changed and the message cache flushed.\");\n\t\treturn true;\n\t}","id":60396,"modified_method":"/**\n\t * Change the transient key used by JFK.\n\t * \n\t * It will determine the PFS interval, hence we call it at least once every 30mins.\n\t * \n\t * @return True if we reset the transient key and therefore the authenticator cache.\n\t */\n\tprivate boolean maybeResetTransientKey() {\n\t\tlong now = System.currentTimeMillis();\n\t\tboolean isCacheTooBig = true;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tif(authenticatorCache.size() < AUTHENTICATOR_CACHE_SIZE) {\n\t\t\t\tisCacheTooBig = false;\n\t\t\t\tif(now - timeLastReset < TRANSIENT_KEY_REKEYING_MIN_INTERVAL)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttimeLastReset = now;\n\n\t\t\tnode.random.nextBytes(transientKey);\n\t\t\t\n\t\t\t// reset the authenticator cache\n\t\t\tauthenticatorCache.clear();\n\t\t}\n\t\tnode.getTicker().queueTimedJob(transientKeyRekeyer, \"JFKmaybeResetTransitentKey \"+now, TRANSIENT_KEY_REKEYING_MIN_INTERVAL, false);\n\t\tLogger.normal(this, \"JFK's TransientKey has been changed and the message cache flushed because \"+(isCacheTooBig ? (\"the cache is oversized (\"+authenticatorCache.size()+')') : \"it's time to rekey\")+ \" on \" + this);\n\t\treturn true;\n\t}","commit_id":"0381d9a1e5a0ae456b580478aa706677667cf995","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Decrypt and authenticate packet.\n\t * Then feed it to USM.checkFilters.\n\t * Packets generated should have a PeerNode on them.\n\t * Note that the buffer can be modified by this method.\n\t */\n    public void process(byte[] buf, int offset, int length, Peer peer) {\n        node.random.acceptTimerEntropy(fnpTimingSource, 0.25);\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tif(logMINOR) Logger.minor(this, \"Packet length \"+length+\" from \"+peer);\n\n        /**\n         * Look up the Peer.\n         * If we know it, check the packet with that key.\n         * Otherwise try all of them (on the theory that nodes \n         * occasionally change their IP addresses).\n         */\n        PeerNode opn = pm.getByPeer(peer);\n        PeerNode pn;\n        \n        if(opn != null) {\n            if(logMINOR) Logger.minor(this, \"Trying exact match\");\n            if(length > HEADERS_LENGTH_MINIMUM) {\n                if(tryProcess(buf, offset, length, opn.getCurrentKeyTracker())) return;\n                // Try with old key\n                if(tryProcess(buf, offset, length, opn.getPreviousKeyTracker())) return;\n                // Try with unverified key\n                if(tryProcess(buf, offset, length, opn.getUnverifiedKeyTracker())) return;\n            }\n            if(length > Node.SYMMETRIC_KEY_LENGTH /* iv */ + HASH_LENGTH + 2) {\n                // Might be an auth packet\n                if(tryProcessAuth(buf, offset, length, opn, peer)) return;\n            }\n        }\n        if(length > HASH_LENGTH + RANDOM_BYTES_LENGTH + 4 + 6) {\n            for(int i=0;i<pm.connectedPeers.length;i++) {\n                pn = pm.myPeers[i];\n                if(pn == opn) continue;\n                if(tryProcess(buf, offset, length, pn.getCurrentKeyTracker())) {\n                    // IP address change\n                    pn.changedIP(peer);\n                    return;\n                }\n                if(tryProcess(buf, offset, length, pn.getPreviousKeyTracker())) {\n                    // IP address change\n                    pn.changedIP(peer);\n                    return;\n                }\n                if(tryProcess(buf, offset, length, pn.getUnverifiedKeyTracker())) {\n                    // IP address change\n                    pn.changedIP(peer);\n                    return;\n                }\n            }\n        }\n        if(length > Node.SYMMETRIC_KEY_LENGTH /* iv */ + HASH_LENGTH + 2) {\n            for(int i=0;i<pm.myPeers.length;i++) {\n                pn = pm.myPeers[i];\n                if(pn == opn) continue;\n                if(tryProcessAuth(buf, offset, length, pn, peer)) return;\n            }\n        }\n        if((opn != null) && !opn.isConnected()) {\n            if(logMINOR) Logger.minor(this,\"Unmatchable packet from \"+peer);\n        } else\n            Logger.error(this,\"Unmatchable packet from \"+peer);\n    }","id":60397,"modified_method":"/**\n\t * Decrypt and authenticate packet.\n\t * Then feed it to USM.checkFilters.\n\t * Packets generated should have a PeerNode on them.\n\t * Note that the buffer can be modified by this method.\n\t */\n    public void process(byte[] buf, int offset, int length, Peer peer) {\n        node.random.acceptTimerEntropy(fnpTimingSource, 0.25);\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tif(logMINOR) Logger.minor(this, \"Packet length \"+length+\" from \"+peer);\n\n        /**\n         * Look up the Peer.\n         * If we know it, check the packet with that key.\n         * Otherwise try all of them (on the theory that nodes \n         * occasionally change their IP addresses).\n         */\n        PeerNode opn = pm.getByPeer(peer);\n        PeerNode pn;\n        \n        if(opn != null) {\n            if(logMINOR) Logger.minor(this, \"Trying exact match\");\n            if(length > HEADERS_LENGTH_MINIMUM) {\n                if(tryProcess(buf, offset, length, opn.getCurrentKeyTracker())) return;\n                // Try with old key\n                if(tryProcess(buf, offset, length, opn.getPreviousKeyTracker())) return;\n                // Try with unverified key\n                if(tryProcess(buf, offset, length, opn.getUnverifiedKeyTracker())) return;\n            }\n            if(length > Node.SYMMETRIC_KEY_LENGTH /* iv */ + HASH_LENGTH + 2) {\n                // Might be an auth packet\n                if(tryProcessAuth(buf, offset, length, opn, peer)) return;\n            }\n        }\n        if(length > HASH_LENGTH + RANDOM_BYTES_LENGTH + 4 + 6) {\n            for(int i=0;i<pm.connectedPeers.length;i++) {\n                pn = pm.myPeers[i];\n                if(pn == opn) continue;\n                if(tryProcess(buf, offset, length, pn.getCurrentKeyTracker())) {\n                    // IP address change\n                    pn.changedIP(peer);\n                    return;\n                }\n                if(tryProcess(buf, offset, length, pn.getPreviousKeyTracker())) {\n                    // IP address change\n                    pn.changedIP(peer);\n                    return;\n                }\n                if(tryProcess(buf, offset, length, pn.getUnverifiedKeyTracker())) {\n                    // IP address change\n                    pn.changedIP(peer);\n                    return;\n                }\n            }\n        }\n        if(length > Node.SYMMETRIC_KEY_LENGTH /* iv */ + HASH_LENGTH + 2) {\n            for(int i=0;i<pm.myPeers.length;i++) {\n                pn = pm.myPeers[i];\n                if(pn == opn) continue;\n                if(tryProcessAuth(buf, offset, length, pn, peer)) return;\n            }\n        }\n        Logger.normal(this,\"Unmatchable packet from \"+peer);\n    }","commit_id":"bf674682994ae3e7da7142009ea1f65f576c0ce8","url":"https://github.com/freenet/fred"},{"original_method":"public byte[] receive() throws RetrievalException {\n\t\tint consecutiveMissingPacketReports = 0;\n\t\tboolean logMINOR=Logger.shouldLog(Logger.MINOR, this);\n\t\ttry {\n\t\twhile (!_prb.allReceived()) {\n\t\t\tMessage m1;\n            try {\n            \tMessageFilter mfPacketTransmit = MessageFilter.create().setTimeout(RECEIPT_TIMEOUT).setType(DMT.packetTransmit).setField(DMT.UID, _uid).setSource(_sender);\n            \tMessageFilter mfAllSent = MessageFilter.create().setType(DMT.allSent).setField(DMT.UID, _uid).setSource(_sender);\n            \tMessageFilter mfSendAborted = MessageFilter.create().setType(DMT.sendAborted).setField(DMT.UID, _uid).setSource(_sender);\n                m1 = _usm.waitFor(mfPacketTransmit.or(mfAllSent.or(mfSendAborted)), _ctr);\n                if(!_sender.isConnected()) throw new DisconnectedException();\n            } catch (DisconnectedException e1) {\n                Logger.normal(this, \"Disconnected during receive: \"+_uid+\" from \"+_sender);\n                _prb.abort(RetrievalException.SENDER_DIED, \"Disconnected during receive\");\n                throw new RetrievalException(RetrievalException.SENDER_DISCONNECTED);\n            }\n            if(logMINOR)\n            \tLogger.minor(this, \"Received \"+m1);\n            if ((m1 != null) && m1.getSpec().equals(DMT.sendAborted)) {\n\t\t\t\t_prb.abort(m1.getInt(DMT.REASON), m1.getString(DMT.DESCRIPTION));\n\t\t\t\tthrow new RetrievalException(m1.getInt(DMT.REASON), m1.getString(DMT.DESCRIPTION));\n\t\t\t}\n\t\t\tif ((m1 != null) && (m1.getSpec().equals(DMT.packetTransmit))) {\n\t\t\t\tconsecutiveMissingPacketReports = 0;\n\t\t\t\t// packetTransmit received\n\t\t\t\tint packetNo = m1.getInt(DMT.PACKET_NO);\n\t\t\t\tBitArray sent = (BitArray) m1.getObject(DMT.SENT);\n\t\t\t\tBuffer data = (Buffer) m1.getObject(DMT.DATA);\n\t\t\t\t_prb.addPacket(packetNo, data);\n\t\t\t\t// Remove it from rrmp if its in there\n\t\t\t\t_recentlyReportedMissingPackets.remove(new Integer(packetNo));\n\t\t\t\t// Check that we have what the sender thinks we have\n\t\t\t\tLinkedList missing = new LinkedList();\n\t\t\t\tfor (int x = 0; x < sent.getSize(); x++) {\n\t\t\t\t\tif (sent.bitAt(x) && !_prb.isReceived(x)) {\n\t\t\t\t\t\t// Sender thinks we have a block which we don't, but have we already\n\t\t\t\t\t\t// re-requested it recently?\n\t\t\t\t\t\tLong resendTime = (Long) _recentlyReportedMissingPackets.get(new Integer(x));\n\t\t\t\t\t\tif ((resendTime == null) || (System.currentTimeMillis() > resendTime.longValue())) {\n\t\t\t\t\t\t\t// Make a note of the earliest time we should resend this, based on the number of other\n\t\t\t\t\t\t\t// packets we are already waiting for\n\t\t\t\t\t\t\tlong resendWait = System.currentTimeMillis()\n\t\t\t\t\t\t\t\t\t+ (MAX_ROUND_TRIP_TIME + (_recentlyReportedMissingPackets.size() * MAX_SEND_INTERVAL));\n\t\t\t\t\t\t\t_recentlyReportedMissingPackets.put(new Integer(x), (new Long(resendWait)));\n\t\t\t\t\t\t\tmissing.add(new Integer(x));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Missing: \"+missing.size());\n\t\t\t\tif (missing.size() > 0) {\n\t\t\t\t\tMessage mn = DMT.createMissingPacketNotification(_uid, missing);\n\t\t\t\t\t_usm.send(_sender, mn, _ctr);\n\t\t\t\t\tconsecutiveMissingPacketReports++;\n\t\t\t\t\tif (missing.size() > 50) {\n\t\t\t\t\t\tLogger.normal(this, \"Excessive packet loss : \"+mn);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif ((m1 == null) || (m1.getSpec().equals(DMT.allSent))) {\n\t\t\t\tif (consecutiveMissingPacketReports >= MAX_CONSECUTIVE_MISSING_PACKET_REPORTS) {\n\t\t\t\t\t_prb.abort(RetrievalException.SENDER_DIED, \"Sender unresponsive to resend requests\");\n\t\t\t\t\tthrow new RetrievalException(RetrievalException.SENDER_DIED,\n\t\t\t\t\t\t\t\"Sender unresponsive to resend requests\");\n\t\t\t\t}\n\t\t\t\tLinkedList missing = new LinkedList();\n\t\t\t\tfor (int x = 0; x < _prb.getNumPackets(); x++) {\n\t\t\t\t\tif (!_prb.isReceived(x)) {\n\t\t\t\t\t\tmissing.add(new Integer(x));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tMessage mn = DMT.createMissingPacketNotification(_uid, missing);\n\t\t\t\t_usm.send(_sender, mn, _ctr);\n\t\t\t\tconsecutiveMissingPacketReports++;\n\t\t\t\tif (missing.size() > 50) {\n\t\t\t\t\tLogger.normal(this, \"Sending large missingPacketNotification due to packet receiver timeout after \"+RECEIPT_TIMEOUT+\"ms\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_usm.send(_sender, DMT.createAllReceived(_uid), _ctr);\n\t\treturn _prb.getBlock();\n\t\t} catch(NotConnectedException e) {\n\t\t    throw new RetrievalException(RetrievalException.SENDER_DISCONNECTED);\n\t\t} catch(AbortedException e) {\n\t\t\t// We didn't cause it?!\n\t\t\tLogger.error(this, \"Caught in receive - probably a bug as receive sets it: \"+e);\n\t\t\tthrow new RetrievalException(RetrievalException.UNKNOWN);\n\t\t}\n\t}","id":60398,"modified_method":"public byte[] receive() throws RetrievalException {\n\t\tint consecutiveMissingPacketReports = 0;\n\t\tboolean logMINOR=Logger.shouldLog(Logger.MINOR, this);\n\t\ttry {\n\t\twhile (!_prb.allReceived()) {\n\t\t\tMessage m1;\n            try {\n            \tMessageFilter mfPacketTransmit = MessageFilter.create().setTimeout(RECEIPT_TIMEOUT).setType(DMT.packetTransmit).setField(DMT.UID, _uid).setSource(_sender);\n            \tMessageFilter mfAllSent = MessageFilter.create().setType(DMT.allSent).setField(DMT.UID, _uid).setSource(_sender);\n            \tMessageFilter mfSendAborted = MessageFilter.create().setType(DMT.sendAborted).setField(DMT.UID, _uid).setSource(_sender);\n                m1 = _usm.waitFor(mfPacketTransmit.or(mfAllSent.or(mfSendAborted)), _ctr);\n                if(!_sender.isConnected()) throw new DisconnectedException();\n            } catch (DisconnectedException e1) {\n                Logger.normal(this, \"Disconnected during receive: \"+_uid+\" from \"+_sender);\n                _prb.abort(RetrievalException.SENDER_DISCONNECTED, \"Disconnected during receive\");\n                throw new RetrievalException(RetrievalException.SENDER_DISCONNECTED);\n            }\n            if(logMINOR)\n            \tLogger.minor(this, \"Received \"+m1);\n            if ((m1 != null) && m1.getSpec().equals(DMT.sendAborted)) {\n\t\t\t\t_prb.abort(m1.getInt(DMT.REASON), m1.getString(DMT.DESCRIPTION));\n\t\t\t\tthrow new RetrievalException(m1.getInt(DMT.REASON), m1.getString(DMT.DESCRIPTION));\n\t\t\t}\n\t\t\tif ((m1 != null) && (m1.getSpec().equals(DMT.packetTransmit))) {\n\t\t\t\tconsecutiveMissingPacketReports = 0;\n\t\t\t\t// packetTransmit received\n\t\t\t\tint packetNo = m1.getInt(DMT.PACKET_NO);\n\t\t\t\tBitArray sent = (BitArray) m1.getObject(DMT.SENT);\n\t\t\t\tBuffer data = (Buffer) m1.getObject(DMT.DATA);\n\t\t\t\t_prb.addPacket(packetNo, data);\n\t\t\t\t// Remove it from rrmp if its in there\n\t\t\t\t_recentlyReportedMissingPackets.remove(new Integer(packetNo));\n\t\t\t\t// Check that we have what the sender thinks we have\n\t\t\t\tLinkedList missing = new LinkedList();\n\t\t\t\tfor (int x = 0; x < sent.getSize(); x++) {\n\t\t\t\t\tif (sent.bitAt(x) && !_prb.isReceived(x)) {\n\t\t\t\t\t\t// Sender thinks we have a block which we don't, but have we already\n\t\t\t\t\t\t// re-requested it recently?\n\t\t\t\t\t\tLong resendTime = (Long) _recentlyReportedMissingPackets.get(new Integer(x));\n\t\t\t\t\t\tif ((resendTime == null) || (System.currentTimeMillis() > resendTime.longValue())) {\n\t\t\t\t\t\t\t// Make a note of the earliest time we should resend this, based on the number of other\n\t\t\t\t\t\t\t// packets we are already waiting for\n\t\t\t\t\t\t\tlong resendWait = System.currentTimeMillis()\n\t\t\t\t\t\t\t\t\t+ (MAX_ROUND_TRIP_TIME + (_recentlyReportedMissingPackets.size() * MAX_SEND_INTERVAL));\n\t\t\t\t\t\t\t_recentlyReportedMissingPackets.put(new Integer(x), (new Long(resendWait)));\n\t\t\t\t\t\t\tmissing.add(new Integer(x));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Missing: \"+missing.size());\n\t\t\t\tif (missing.size() > 0) {\n\t\t\t\t\tMessage mn = DMT.createMissingPacketNotification(_uid, missing);\n\t\t\t\t\t_usm.send(_sender, mn, _ctr);\n\t\t\t\t\tconsecutiveMissingPacketReports++;\n\t\t\t\t\tif (missing.size() > 50) {\n\t\t\t\t\t\tLogger.normal(this, \"Excessive packet loss : \"+mn);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif ((m1 == null) || (m1.getSpec().equals(DMT.allSent))) {\n\t\t\t\tif (consecutiveMissingPacketReports >= MAX_CONSECUTIVE_MISSING_PACKET_REPORTS) {\n\t\t\t\t\t_prb.abort(RetrievalException.SENDER_DIED, \"Sender unresponsive to resend requests\");\n\t\t\t\t\tthrow new RetrievalException(RetrievalException.SENDER_DIED,\n\t\t\t\t\t\t\t\"Sender unresponsive to resend requests\");\n\t\t\t\t}\n\t\t\t\tLinkedList missing = new LinkedList();\n\t\t\t\tfor (int x = 0; x < _prb.getNumPackets(); x++) {\n\t\t\t\t\tif (!_prb.isReceived(x)) {\n\t\t\t\t\t\tmissing.add(new Integer(x));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tMessage mn = DMT.createMissingPacketNotification(_uid, missing);\n\t\t\t\t_usm.send(_sender, mn, _ctr);\n\t\t\t\tconsecutiveMissingPacketReports++;\n\t\t\t\tif (missing.size() > 50) {\n\t\t\t\t\tLogger.normal(this, \"Sending large missingPacketNotification due to packet receiver timeout after \"+RECEIPT_TIMEOUT+\"ms\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_usm.send(_sender, DMT.createAllReceived(_uid), _ctr);\n\t\treturn _prb.getBlock();\n\t\t} catch(NotConnectedException e) {\n\t\t    throw new RetrievalException(RetrievalException.SENDER_DISCONNECTED);\n\t\t} catch(AbortedException e) {\n\t\t\t// We didn't cause it?!\n\t\t\tLogger.error(this, \"Caught in receive - probably a bug as receive sets it: \"+e);\n\t\t\tthrow new RetrievalException(RetrievalException.UNKNOWN, \"Aborted?\");\n\t\t}\n\t}","commit_id":"b47858c18dfcc01854c8123ccbc290d9976dec23","url":"https://github.com/freenet/fred"},{"original_method":"public BlockTransmitter(MessageCore usm, PeerContext destination, long uid, PartiallyReceivedBlock source, DoubleTokenBucket masterThrottle, ByteCounter ctr) {\n\t\t_usm = usm;\n\t\t_destination = destination;\n\t\t_uid = uid;\n\t\t_prb = source;\n\t\t_ctr = ctr;\n\t\t_masterThrottle = masterThrottle;\n\t\tPACKET_SIZE = DMT.packetTransmitSize(_prb._packetSize, _prb._packets)\n\t\t\t+ destination.getOutgoingMangler().fullHeadersLengthOneMessage();\n\t\ttry {\n\t\t\t_sentPackets = new BitArray(_prb.getNumPackets());\n\t\t} catch (AbortedException e) {\n\t\t\tLogger.error(this, \"Aborted during setup\");\n\t\t\t// Will throw on running\n\t\t}\n\t\tthrottle = _destination.getThrottle();\n\t\t_senderThread = new Runnable() {\n\t\t\n\t\t\tpublic void run() {\n\t\t\t\twhile (!_sendComplete) {\n\t\t\t\t\tlong startCycleTime = System.currentTimeMillis();\n\t\t\t\t\ttry {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tsynchronized(_senderThread) {\n\t\t\t\t\t\t\t\tif(_unsent.size() != 0) {\n\t\t\t\t\t\t\t\t\ttimeAllSent = -1;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// No unsent packets\n\t\t\t\t\t\t\t\tif(getNumSent() == _prb.getNumPackets()) {\n\t\t\t\t\t\t\t\t\t//No unreceived packets\n\t\t\t\t\t\t\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\t\t\t\t\t\t\tLogger.minor(this, \"Sent all blocks, none unsent\");\n\t\t\t\t\t\t\t\t\tif(timeAllSent <= 0)\n\t\t\t\t\t\t\t\t\t\ttimeAllSent = System.currentTimeMillis();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(_sendComplete) return;\n\t\t\t\t\t\t\t\t_senderThread.wait(10*1000);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t} catch (AbortedException e) {\n\t\t\t\t\t\tsynchronized(_senderThread) {\n\t\t\t\t\t\t\t_sendComplete = true;\n\t\t\t\t\t\t\t_senderThread.notifyAll();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tint packetNo;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tsynchronized(_senderThread) {\n\t\t\t\t\t\t\tpacketNo = ((Integer) _unsent.removeFirst()).intValue();\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (NoSuchElementException nsee) {\n\t\t\t\t\t\t// back up to the top to check for completion\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdelay(startCycleTime);\n\t\t\t\t\tif(_sendComplete) break;\n\t\t\t\t\t_sentPackets.setBit(packetNo, true);\n\t\t\t\t\ttry {\n\t\t\t\t\t\t_destination.sendAsync(DMT.createPacketTransmit(_uid, packetNo, _sentPackets, _prb.getPacket(packetNo)), null, PACKET_SIZE, _ctr);\n\t\t\t\t\t\t_ctr.sentPayload(PACKET_SIZE);\n\t\t\t\t\t} catch (NotConnectedException e) {\n\t\t\t\t\t\tLogger.normal(this, \"Terminating send: \"+e);\n\t\t\t\t\t\tsynchronized(_senderThread) {\n\t\t\t\t\t\t\t_sendComplete = true;\n\t\t\t\t\t\t\t_senderThread.notifyAll();\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (AbortedException e) {\n\t\t\t\t\t\tLogger.normal(this, \"Terminating send due to abort: \"+e);\n\t\t\t\t\t\tsynchronized(_senderThread) {\n\t\t\t\t\t\t\t_sendComplete = true;\n\t\t\t\t\t\t\t_senderThread.notifyAll();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprivate void delay(long startCycleTime) {\n\t\t\t\t//FIXME: startCycleTime is not used in this function, why is it passed in?\n\t\t\t\tlong startThrottle = System.currentTimeMillis();\n\n\t\t\t\t// Get the current inter-packet delay\n\t\t\t\tlong end = throttle.scheduleDelay(startThrottle);\n\n\t\t\t\tif(IPUtil.isValidAddress(_destination.getPeer().getAddress(), false))\n\t\t\t\t\t_masterThrottle.blockingGrab(PACKET_SIZE);\n\t\t\t\t\n\t\t\t\tlong now = System.currentTimeMillis();\n\t\t\t\t\n\t\t\t\tlong delayTime = now - startThrottle;\n\t\t\t\t\n\t\t\t\t// Report the delay caused by bandwidth limiting, NOT the delay caused by congestion control.\n\t\t\t\t((PeerNode)_destination).reportThrottledPacketSendTime(delayTime);\n\t\t\t\t\n\t\t\t\tif(now > end) return;\n\t\t\t\twhile(now < end) {\n\t\t\t\t\tlong l = end - now;\n\t\t\t\t\tsynchronized(_senderThread) {\n\t\t\t\t\t\tif(_sendComplete) return;\n\t\t\t\t\t}\n\t\t\t\t\t// Check for completion every 2 minutes\n\t\t\t\t\tint x = (int) (Math.min(l, 120*1000));\n\t\t\t\t\tif(x > 0) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t//FIXME: if the senderThread sleeps here for two minutes, that will timeout the receiver, no? Should this be a wait()?\n\t\t\t\t\t\t\tThread.sleep(x);\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnow = System.currentTimeMillis();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}","id":60399,"modified_method":"public BlockTransmitter(MessageCore usm, PeerContext destination, long uid, PartiallyReceivedBlock source, DoubleTokenBucket masterThrottle, ByteCounter ctr) {\n\t\t_usm = usm;\n\t\t_destination = destination;\n\t\t_uid = uid;\n\t\t_prb = source;\n\t\t_ctr = ctr;\n\t\t_masterThrottle = masterThrottle;\n\t\tPACKET_SIZE = DMT.packetTransmitSize(_prb._packetSize, _prb._packets)\n\t\t\t+ destination.getOutgoingMangler().fullHeadersLengthOneMessage();\n\t\ttry {\n\t\t\t_sentPackets = new BitArray(_prb.getNumPackets());\n\t\t} catch (AbortedException e) {\n\t\t\tLogger.error(this, \"Aborted during setup\");\n\t\t\t// Will throw on running\n\t\t}\n\t\tthrottle = _destination.getThrottle();\n\t\t_senderThread = new Runnable() {\n\t\t\n\t\t\tpublic void run() {\n\t\t\t\twhile (!_sendComplete) {\n\t\t\t\t\tlong startCycleTime = System.currentTimeMillis();\n\t\t\t\t\ttry {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tsynchronized(_senderThread) {\n\t\t\t\t\t\t\t\tif(_unsent.size() != 0) {\n\t\t\t\t\t\t\t\t\ttimeAllSent = -1;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// No unsent packets\n\t\t\t\t\t\t\t\tif(getNumSent() == _prb.getNumPackets()) {\n\t\t\t\t\t\t\t\t\t//No unreceived packets\n\t\t\t\t\t\t\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\t\t\t\t\t\t\tLogger.minor(this, \"Sent all blocks, none unsent\");\n\t\t\t\t\t\t\t\t\tif(timeAllSent <= 0)\n\t\t\t\t\t\t\t\t\t\ttimeAllSent = System.currentTimeMillis();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(_sendComplete) return;\n\t\t\t\t\t\t\t\t_senderThread.wait(10*1000);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t} catch (AbortedException e) {\n\t\t\t\t\t\tsynchronized(_senderThread) {\n\t\t\t\t\t\t\t_sendComplete = true;\n\t\t\t\t\t\t\t_senderThread.notifyAll();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tint packetNo;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tsynchronized(_senderThread) {\n\t\t\t\t\t\t\tpacketNo = ((Integer) _unsent.removeFirst()).intValue();\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (NoSuchElementException nsee) {\n\t\t\t\t\t\t// back up to the top to check for completion\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdelay(startCycleTime);\n\t\t\t\t\tif(_sendComplete) break;\n\t\t\t\t\t_sentPackets.setBit(packetNo, true);\n\t\t\t\t\ttry {\n\t\t\t\t\t\t_destination.sendAsync(DMT.createPacketTransmit(_uid, packetNo, _sentPackets, _prb.getPacket(packetNo)), null, PACKET_SIZE, _ctr);\n\t\t\t\t\t\t_ctr.sentPayload(PACKET_SIZE);\n\t\t\t\t\t} catch (NotConnectedException e) {\n\t\t\t\t\t\tLogger.normal(this, \"Terminating send: \"+e);\n\t\t\t\t\t\tsynchronized(_senderThread) {\n\t\t\t\t\t\t\t_sendComplete = true;\n\t\t\t\t\t\t\t_senderThread.notifyAll();\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (AbortedException e) {\n\t\t\t\t\t\tLogger.normal(this, \"Terminating send due to abort: \"+e);\n\t\t\t\t\t\tsynchronized(_senderThread) {\n\t\t\t\t\t\t\t_sendComplete = true;\n\t\t\t\t\t\t\t_senderThread.notifyAll();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprivate void delay(long startCycleTime) {\n\t\t\t\t//FIXME: startCycleTime is not used in this function, why is it passed in?\n\t\t\t\tlong startThrottle = System.currentTimeMillis();\n\n\t\t\t\t// Get the current inter-packet delay\n\t\t\t\tlong end = throttle.scheduleDelay(startThrottle);\n\n\t\t\t\tif(IPUtil.isValidAddress(_destination.getPeer().getAddress(), false))\n\t\t\t\t\t_masterThrottle.blockingGrab(PACKET_SIZE);\n\t\t\t\t\n\t\t\t\tlong now = System.currentTimeMillis();\n\t\t\t\t\n\t\t\t\tlong delayTime = now - startThrottle;\n\t\t\t\t\n\t\t\t\t// Report the delay caused by bandwidth limiting, NOT the delay caused by congestion control.\n\t\t\t\t((PeerNode)_destination).reportThrottledPacketSendTime(delayTime);\n\t\t\t\t\n\t\t\t\tif (end - now > 2*60*1000)\n\t\t\t\t\tLogger.error(this, \"per-packet congestion control delay: \"+(end-now));\n\t\t\t\t\n\t\t\t\tif(now > end) return;\n\t\t\t\twhile(now < end) {\n\t\t\t\t\tlong l = end - now;\n\t\t\t\t\tsynchronized(_senderThread) {\n\t\t\t\t\t\tif(_sendComplete) return;\n\t\t\t\t\t}\n\t\t\t\t\t// Check for completion every 2 minutes\n\t\t\t\t\tint x = (int) (Math.min(l, 120*1000));\n\t\t\t\t\tif(x > 0) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t//FIXME: if the senderThread sleeps here for two minutes, that will timeout the receiver, no? Should this be a wait()?\n\t\t\t\t\t\t\tThread.sleep(x);\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnow = System.currentTimeMillis();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}","commit_id":"b47858c18dfcc01854c8123ccbc290d9976dec23","url":"https://github.com/freenet/fred"},{"original_method":"public void run() {\n\t\t    freenet.support.Logger.OSThread.logPID(this);\n        \tif(logMINOR) Logger.minor(this, \"Receiving data for \"+InsertHandler.this);\n            try {\n                br.receive();\n                if(logMINOR) Logger.minor(this, \"Received data for \"+InsertHandler.this);\n            \tsynchronized(InsertHandler.this) {\n            \t\treceiveCompleted = true;\n            \t\tInsertHandler.this.notifyAll();\n            \t}\n            } catch (RetrievalException e) {\n            \tsynchronized(InsertHandler.this) {\n            \t\treceiveCompleted = true;\n            \t\treceiveFailed = true;\n            \t\tInsertHandler.this.notifyAll();\n            \t}\n                // Cancel the sender\n            \tif(sender != null)\n            \t\tsender.receiveFailed(); // tell it to stop if it hasn't already failed... unless it's sending from store\n                runThread.interrupt();\n                Message msg = DMT.createFNPDataInsertRejected(uid, DMT.DATA_INSERT_REJECTED_RECEIVE_FAILED);\n                try {\n                    source.sendSync(msg, InsertHandler.this);\n                } catch (NotConnectedException ex) {\n\t\t\t\t\t//If they are not connected, that's probably why the receive failed!\n                    if (logMINOR) Logger.minor(this, \"Can't send \"+msg+\" to \"+source+\": \"+ex);\n                }\n                if(logMINOR) Logger.minor(this, \"Failed to retrieve: \"+e, e);\n                return;\n            } catch (Throwable t) {\n                Logger.error(this, \"Caught \"+t, t);\n            }\n        }","id":60400,"modified_method":"public void run() {\n\t\t    freenet.support.Logger.OSThread.logPID(this);\n        \tif(logMINOR) Logger.minor(this, \"Receiving data for \"+InsertHandler.this);\n            try {\n                br.receive();\n                if(logMINOR) Logger.minor(this, \"Received data for \"+InsertHandler.this);\n            \tsynchronized(InsertHandler.this) {\n            \t\treceiveCompleted = true;\n            \t\tInsertHandler.this.notifyAll();\n            \t}\n            } catch (RetrievalException e) {\n            \tsynchronized(InsertHandler.this) {\n            \t\treceiveCompleted = true;\n            \t\treceiveFailed = true;\n            \t\tInsertHandler.this.notifyAll();\n            \t}\n                // Cancel the sender\n            \tif(sender != null)\n            \t\tsender.receiveFailed(); // tell it to stop if it hasn't already failed... unless it's sending from store\n                runThread.interrupt();\n                Message msg = DMT.createFNPDataInsertRejected(uid, DMT.DATA_INSERT_REJECTED_RECEIVE_FAILED);\n                try {\n                    source.sendSync(msg, InsertHandler.this);\n                } catch (NotConnectedException ex) {\n\t\t\t\t\t//If they are not connected, that's probably why the receive failed!\n                    if (logMINOR) Logger.minor(this, \"Can't send \"+msg+\" to \"+source+\": \"+ex);\n                }\n\t\t\t\tif (e.getReason()==RetrievalException.SENDER_DISCONNECTED)\n\t\t\t\t\tLogger.normal(this, \"Failed to retrieve: \"+e, e);\n\t\t\t\telse\n\t\t\t\t\tLogger.error(this, \"Failed to retrieve: \"+e, e);\n                return;\n            } catch (Throwable t) {\n                Logger.error(this, \"Caught \"+t, t);\n            }\n        }","commit_id":"b47858c18dfcc01854c8123ccbc290d9976dec23","url":"https://github.com/freenet/fred"},{"original_method":"private void realRun() {\n\t    freenet.support.Logger.OSThread.logPID(this);\n        if((key instanceof NodeSSK) && (pubKey == null)) {\n        \tpubKey = ((NodeSSK)key).getPubKey();\n        }\n        \n\t\tint routeAttempts=0;\n\t\tint rejectOverloads=0;\n        HashSet nodesRoutedTo = new HashSet();\n        HashSet nodesNotIgnored = new HashSet();\n\t\tArrayList busyPeers = new ArrayList();\n        while(true) {\n            if(logMINOR) Logger.minor(this, \"htl=\"+htl);\n            if(htl == 0) {\n            \t// This used to be RNF, I dunno why\n\t\t\t\t//???: finish(GENERATED_REJECTED_OVERLOAD, null);\n                finish(DATA_NOT_FOUND, null);\n                return;\n            }\n\n\t\t\trouteAttempts++;\n            \n            // Route it\n\t\t\tlong sendTimeout = SEND_TIMEOUT;\n\t\t\tboolean usingBusyPeer=false;\n            PeerNode next;\n            next = node.peers.closerPeer(source, nodesRoutedTo, nodesNotIgnored, target, true, node.isAdvancedModeEnabled(), -1, null);\n            \n\t\t\tif (next == null && !busyPeers.isEmpty()) {\n\t\t\t\tnext = (PeerNode)busyPeers.remove(0);\n\t\t\t\tusingBusyPeer=true;\n\t\t\t\tif (logMINOR) Logger.minor(this, \"trying previously-found busy peer: \"+next);\n\t\t\t\tsendTimeout = MAX_SEND_TIMEOUT;\n\t\t\t}\n\t\t\t\n            if(next == null) {\n\t\t\t\tif (logMINOR && rejectOverloads>0)\n\t\t\t\t\tLogger.minor(this, \"no more peers, but overloads (\"+rejectOverloads+\"/\"+routeAttempts+\" overloaded)\");\n                // Backtrack\n                finish(ROUTE_NOT_FOUND, null);\n                return;\n            }\n\t\t\t\n            double nextValue=next.getLocation();\n\t\t\t\n            if(logMINOR) Logger.minor(this, \"Routing request to \"+next);\n            nodesRoutedTo.add(next);\n            \n            if(Location.distance(target, nextValue) > Location.distance(target, nearestLoc)) {\n                htl = node.decrementHTL(source, htl);\n                if(logMINOR) Logger.minor(this, \"Backtracking: target=\"+target+\" next=\"+nextValue+\" closest=\"+nearestLoc+\" so htl=\"+htl);\n            }\n            \n            Message req = createDataRequest();\n            \n            // Not possible to get an accurate time for sending, guaranteed to be not later than the time of receipt.\n            // Why? Because by the time the sent() callback gets called, it may already have been acked, under heavy load.\n            // So take it from when we first started to try to send the request.\n            // See comments below when handling FNPRecentlyFailed for why we need this.\n            long timeSentRequest = System.currentTimeMillis();\n\t\t\t\n            try {\n            \t//This is the first contact to this node, it is more likely to timeout\n\t\t\t\t/*\n\t\t\t\t * using sendSync could:\n\t\t\t\t *   make ACCEPTED_TIMEOUT more accurate (as it is measured from the send-time),\n\t\t\t\t *   use a lot of our time that we have to fulfill this request (simply waiting on the send queue, or longer if the node just went down),\n\t\t\t\t * using sendAsync could:\n\t\t\t\t *   make ACCEPTED_TIMEOUT much more likely,\n\t\t\t\t *   leave many hanging-requests/unclaimedFIFO items,\n\t\t\t\t *   potentially make overloaded peers MORE overloaded (we make a request and promptly forget about them).\n\t\t\t\t * using conditionalSend could:\n\t\t\t\t *   make ACCEPTED_TIMEOUT as accurate as sendSync (as it to waits for transmittion)\n\t\t\t\t *   reduce general latency around peers which have slow network links\n\t\t\t\t *   not needlessly overload nodes w/ forgotten requests (as conditonalSend will try and withdraw the request if it times out)\n\t\t\t\t *!!!make us skip peers which would otherwise have the data (they are closer, but slower)\n\t\t\t\t *\n\t\t\t\t * To avoid the pitfall of conditionalSend (potentially skipping a good peer), we will come back to them when it is\n\t\t\t\t * apparent that we cannot fill the request quickly. Using conditionalSend this way might actually approximate\n\t\t\t\t * Q-routing (for load balancing/latency) across the network; if SEND_TIMEOUT is too high... this reduces to\n\t\t\t\t * using sendSync w/ a good error catch, and if SEND_TIMEOUT is too low... this reduces to creating a cache-backbone\n\t\t\t\t * of fast links in the network which will always be queried before general nodes in the network are.\n\t\t\t\t */\n            \tif (!next.conditionalSend(req, this, sendTimeout)) {\n\t\t\t\t\tif (usingBusyPeer)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tLogger.normal(this, \"will try this peer later if no others are available\");\n\t\t\t\t\tbusyPeers.add(next);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n            } catch (NotConnectedException e) {\n            \tLogger.minor(this, \"Not connected\");\n            \tcontinue;\n            }\n            \n            synchronized(this) {\n            \thasForwarded = true;\n            }\n            \n            Message msg = null;\n            \n            while(true) {\n            \t\n                /**\n                 * What are we waiting for?\n                 * FNPAccepted - continue\n                 * FNPRejectedLoop - go to another node\n                 * FNPRejectedOverload - propagate back to source, go to another node if local\n                 */\n                \n                MessageFilter mfAccepted = MessageFilter.create().setSource(next).setField(DMT.UID, uid).setTimeout(ACCEPTED_TIMEOUT).setType(DMT.FNPAccepted);\n                MessageFilter mfRejectedLoop = MessageFilter.create().setSource(next).setField(DMT.UID, uid).setTimeout(ACCEPTED_TIMEOUT).setType(DMT.FNPRejectedLoop);\n                MessageFilter mfRejectedOverload = MessageFilter.create().setSource(next).setField(DMT.UID, uid).setTimeout(ACCEPTED_TIMEOUT).setType(DMT.FNPRejectedOverload);\n\n                // mfRejectedOverload must be the last thing in the or\n                // So its or pointer remains null\n                // Otherwise we need to recreate it below\n                MessageFilter mf = mfAccepted.or(mfRejectedLoop.or(mfRejectedOverload));\n                \n                try {\n                    msg = node.usm.waitFor(mf, this);\n                    if(logMINOR) Logger.minor(this, \"first part got \"+msg);\n                } catch (DisconnectedException e) {\n                    Logger.normal(this, \"Disconnected from \"+next+\" while waiting for Accepted on \"+uid);\n                    break;\n                }\n                \n            \tif(msg == null) {\n            \t\tif(logMINOR) Logger.minor(this, \"Timeout waiting for Accepted\");\n            \t\t// Timeout waiting for Accepted\n            \t\tnext.localRejectedOverload(\"AcceptedTimeout\");\n            \t\tforwardRejectedOverload();\n            \t\t// Try next node\n            \t\tbreak;\n            \t}\n            \t\n            \tif(msg.getSpec() == DMT.FNPRejectedLoop) {\n            \t\tif(logMINOR) Logger.minor(this, \"Rejected loop\");\n            \t\tnext.successNotOverload();\n            \t\t// Find another node to route to\n            \t\tbreak;\n            \t}\n            \t\n            \tif(msg.getSpec() == DMT.FNPRejectedOverload) {\n            \t\tif(logMINOR) Logger.minor(this, \"Rejected: overload\");\n\t\t\t\t\t// Non-fatal - probably still have time left\n\t\t\t\t\tforwardRejectedOverload();\n\t\t\t\t\tif (msg.getBoolean(DMT.IS_LOCAL)) {\n\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Is local\");\n\t\t\t\t\t\tnext.localRejectedOverload(\"ForwardRejectedOverload\");\n\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Local RejectedOverload, moving on to next peer\");\n\t\t\t\t\t\t// Give up on this one, try another\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//Could be a previous rejection, the timeout to incur another ACCEPTED_TIMEOUT is minimal...\n\t\t\t\t\tcontinue;\n            \t}\n            \t\n            \tif(msg.getSpec() != DMT.FNPAccepted) {\n            \t\tLogger.error(this, \"Unrecognized message: \"+msg);\n            \t\tcontinue;\n            \t}\n            \t\n            \tbreak;\n            }\n            \n            if((msg == null) || (msg.getSpec() != DMT.FNPAccepted)) {\n            \t// Try another node\n            \tcontinue;\n            }\n\n            if(logMINOR) Logger.minor(this, \"Got Accepted\");\n            \n            // Otherwise, must be Accepted\n            \n            // So wait...\n            int gotMessages=0;\n            String lastMessage=null;\n            while(true) {\n            \t\n                MessageFilter mfDNF = MessageFilter.create().setSource(next).setField(DMT.UID, uid).setTimeout(FETCH_TIMEOUT).setType(DMT.FNPDataNotFound);\n                MessageFilter mfRF = MessageFilter.create().setSource(next).setField(DMT.UID, uid).setTimeout(FETCH_TIMEOUT).setType(DMT.FNPRecentlyFailed);\n                MessageFilter mfDF = makeDataFoundFilter(next);\n                MessageFilter mfRouteNotFound = MessageFilter.create().setSource(next).setField(DMT.UID, uid).setTimeout(FETCH_TIMEOUT).setType(DMT.FNPRouteNotFound);\n                MessageFilter mfRejectedOverload = MessageFilter.create().setSource(next).setField(DMT.UID, uid).setTimeout(FETCH_TIMEOUT).setType(DMT.FNPRejectedOverload);\n                MessageFilter mfPubKey = MessageFilter.create().setSource(next).setField(DMT.UID, uid).setTimeout(FETCH_TIMEOUT).setType(DMT.FNPSSKPubKey);\n            \tMessageFilter mfRealDFCHK = MessageFilter.create().setSource(next).setField(DMT.UID, uid).setTimeout(FETCH_TIMEOUT).setType(DMT.FNPCHKDataFound);\n            \tMessageFilter mfRealDFSSK = MessageFilter.create().setSource(next).setField(DMT.UID, uid).setTimeout(FETCH_TIMEOUT).setType(DMT.FNPSSKDataFound);\n                MessageFilter mf = mfDNF.or(mfRF.or(mfRouteNotFound.or(mfRejectedOverload.or(mfDF.or(mfPubKey.or(mfRealDFCHK.or(mfRealDFSSK)))))));\n\n                \n            \ttry {\n            \t\tmsg = node.usm.waitFor(mf, this);\n            \t} catch (DisconnectedException e) {\n            \t\tLogger.normal(this, \"Disconnected from \"+next+\" while waiting for data on \"+uid);\n            \t\tbreak;\n            \t}\n            \t\n            \tif(logMINOR) Logger.minor(this, \"second part got \"+msg);\n                \n            \tif(msg == null) {\n\t\t\t\t\tLogger.normal(this, \"request fatal-timeout (null) after accept (\"+gotMessages+\" messages; last=\"+lastMessage+\")\");\n            \t\t// Fatal timeout\n            \t\tnext.localRejectedOverload(\"FatalTimeout\");\n            \t\tforwardRejectedOverload();\n            \t\tfinish(TIMED_OUT, next);\n            \t\treturn;\n            \t}\n\t\t\t\t\n\t\t\t\t//For debugging purposes, remember the number of responses AFTER the insert, and the last message type we received.\n\t\t\t\tgotMessages++;\n\t\t\t\tlastMessage=msg.getSpec().getName();\n            \t\n            \tif(msg.getSpec() == DMT.FNPDataNotFound) {\n            \t\tnext.successNotOverload();\n            \t\tfinish(DATA_NOT_FOUND, next);\n            \t\treturn;\n            \t}\n            \t\n            \tif(msg.getSpec() == DMT.FNPRecentlyFailed) {\n            \t\tnext.successNotOverload();\n            \t\t/*\n            \t\t * Must set a correct recentlyFailedTimeLeft before calling this finish(), because it will be\n            \t\t * passed to the handler.\n            \t\t * \n            \t\t * It is *VITAL* that the TIME_LEFT we pass on is not larger than it should be.\n            \t\t * It is somewhat less important that it is not too much smaller than it should be.\n            \t\t * \n            \t\t * Why? Because:\n            \t\t * 1) We have to use FNPRecentlyFailed to create failure table entries. Because otherwise,\n            \t\t * the failure table is of little value: A request is routed through a node, which gets a DNF,\n            \t\t * and adds a failure table entry. Other requests then go through that node via other paths.\n            \t\t * They are rejected with FNPRecentlyFailed - not with DataNotFound. If this does not create\n            \t\t * failure table entries, more requests will be pointlessly routed through that chain.\n            \t\t * \n            \t\t * 2) If we use a fixed timeout on receiving FNPRecentlyFailed, they can be self-seeding. \n            \t\t * What this means is A sends a request to B, which DNFs. This creates a failure table entry \n            \t\t * which lasts for 10 minutes. 5 minutes later, A sends another request to B, which is killed\n            \t\t * with FNPRecentlyFailed because of the failure table entry. B's failure table lasts for \n            \t\t * another 5 minutes, but A's lasts for the full 10 minutes i.e. until 5 minutes after B's. \n            \t\t * After B's failure table entry has expired, but before A's expires, B sends a request to A. \n            \t\t * A replies with FNPRecentlyFailed. Repeat ad infinitum: A reinforces B's blocks, and B \n            \t\t * reinforces A's blocks!\n            \t\t * \n            \t\t * 3) This can still happen even if we check where the request is coming from. A loop could \n            \t\t * very easily form: A - B - C - A. A requests from B, DNFs (assume the request comes in from \n            \t\t * outside, there are more nodes. C requests from A, sets up a block. B's block expires, C's \n            \t\t * is still active. A requests from B which requests from C ... and it goes round again.\n            \t\t * \n            \t\t * 4) It is exactly the same if we specify a timeout, unless the timeout can be guaranteed to \n            \t\t * not increase the expiry time.\n            \t\t */\n            \t\t\n            \t\t// First take the original TIME_LEFT. This will start at 10 minutes if we get rejected in\n            \t\t// the same millisecond as the failure table block was added.\n            \t\tint timeLeft = msg.getInt(DMT.TIME_LEFT);\n            \t\tint origTimeLeft = timeLeft;\n            \t\t\n            \t\tif(timeLeft <= 0) {\n            \t\t\tLogger.error(this, \"Impossible: timeLeft=\"+timeLeft);\n            \t\t\torigTimeLeft = 0;\n            \t\t\ttimeLeft=1000; // arbitrary default...\n            \t\t}\n            \t\t\n            \t\t// This is in theory relative to when the request was received by the node. Lets make it relative\n            \t\t// to a known event before that: the time when we sent the request.\n            \t\t\n            \t\tlong timeSinceSent = Math.max(0, (System.currentTimeMillis() - timeSentRequest));\n            \t\ttimeLeft -= timeSinceSent;\n            \t\t\n            \t\t// Subtract 1% for good measure / to compensate for dodgy clocks\n            \t\ttimeLeft -= origTimeLeft / 100;\n            \t\t\n            \t\tif(timeLeft <= 0) {\n            \t\t\t// No timeout left, cool\n            \t\t\tfinish(DATA_NOT_FOUND, next);\n            \t\t} else {\n            \t\t\t// Some timeout left\n            \t\t\tfinish(RECENTLY_FAILED, next);\n            \t\t}\n            \t\treturn;\n            \t}\n            \t\n            \tif(msg.getSpec() == DMT.FNPRouteNotFound) {\n            \t\t// Backtrack within available hops\n            \t\tshort newHtl = msg.getShort(DMT.HTL);\n            \t\tif(newHtl < htl) htl = newHtl;\n            \t\tnext.successNotOverload();\n            \t\tbreak;\n            \t}\n            \t\n            \tif(msg.getSpec() == DMT.FNPRejectedOverload) {\n\t\t\t\t\t// Non-fatal - probably still have time left\n\t\t\t\t\tforwardRejectedOverload();\n\t\t\t\t\trejectOverloads++;\n\t\t\t\t\tif (msg.getBoolean(DMT.IS_LOCAL)) {\n\t\t\t\t\t\t//NB: IS_LOCAL means it's terminal. not(IS_LOCAL) implies that the rejection message was forwarded from a downstream node.\n\t\t\t\t\t\t//\"Local\" from our peers perspective, this has nothing to do with local requests (source==null)\n\t\t\t\t\t\tnext.localRejectedOverload(\"ForwardRejectedOverload2\");\n\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Local RejectedOverload, moving on to next peer\");\n\t\t\t\t\t\t// Give up on this one, try another\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//so long as the node does not send a (IS_LOCAL) message. Interestingly messages can often timeout having only received this message.\n\t\t\t\t\tcontinue;\n            \t}\n\n            \tif(msg.getSpec() == DMT.FNPCHKDataFound) {\n            \t\tif(!(key instanceof NodeCHK)) {\n            \t\t\tLogger.error(this, \"Got \"+msg+\" but expected a different key type from \"+next);\n            \t\t\tbreak;\n            \t\t}\n            \t\t\n                \t// Found data\n                \tnext.successNotOverload();\n                \t\n                \t// First get headers\n                \t\n                \theaders = ((ShortBuffer)msg.getObject(DMT.BLOCK_HEADERS)).getData();\n                \t\n                \t// FIXME: Validate headers\n                \t\n                \tnode.addTransferringSender((NodeCHK)key, this);\n                \t\n                \ttry {\n                \t\t\n                \t\tprb = new PartiallyReceivedBlock(Node.PACKETS_IN_BLOCK, Node.PACKET_SIZE);\n                \t\t\n                \t\tsynchronized(this) {\n                \t\t\tnotifyAll();\n                \t\t}\n                \t\t\n                \t\tBlockReceiver br = new BlockReceiver(node.usm, next, uid, prb, this);\n                \t\t\n                \t\ttry {\n                \t\t\tif(logMINOR) Logger.minor(this, \"Receiving data\");\n                \t\t\tbyte[] data = br.receive();\n                \t\t\tif(logMINOR) Logger.minor(this, \"Received data\");\n                \t\t\t// Received data\n                \t\t\ttry {\n                \t\t\t\tverifyAndCommit(data);\n                \t\t\t} catch (KeyVerifyException e1) {\n                \t\t\t\tLogger.normal(this, \"Got data but verify failed: \"+e1, e1);\n                \t\t\t\tfinish(VERIFY_FAILURE, next);\n                \t\t\t\treturn;\n                \t\t\t}\n                \t\t\tfinish(SUCCESS, next);\n                \t\t\treturn;\n                \t\t} catch (RetrievalException e) {\n                \t\t\tLogger.normal(this, \"Transfer failed: \"+e, e);\n                \t\t\tfinish(TRANSFER_FAILED, next);\n                \t\t\treturn;\n                \t\t}\n                \t} finally {\n                \t\tnode.removeTransferringSender((NodeCHK)key, this);\n                \t}\n            \t}\n            \t\n            \tif(msg.getSpec() == DMT.FNPSSKPubKey) {\n            \t\t\n            \t\tif(logMINOR) Logger.minor(this, \"Got pubkey on \"+uid);\n            \t\t\n            \t\tif(!(key instanceof NodeSSK)) {\n            \t\t\tLogger.error(this, \"Got \"+msg+\" but expected a different key type from \"+next);\n            \t\t\tbreak;\n            \t\t}\n    \t\t\t\tbyte[] pubkeyAsBytes = ((ShortBuffer)msg.getObject(DMT.PUBKEY_AS_BYTES)).getData();\n    \t\t\t\ttry {\n    \t\t\t\t\tif(pubKey == null)\n    \t\t\t\t\t\tpubKey = DSAPublicKey.create(pubkeyAsBytes);\n    \t\t\t\t\t((NodeSSK)key).setPubKey(pubKey);\n    \t\t\t\t} catch (SSKVerifyException e) {\n    \t\t\t\t\tpubKey = null;\n    \t\t\t\t\tLogger.error(this, \"Invalid pubkey from \"+source+\" on \"+uid+\" (\"+e.getMessage()+ ')', e);\n    \t\t\t\t\tbreak; // try next node\n    \t\t\t\t} catch (CryptFormatException e) {\n    \t\t\t\t\tLogger.error(this, \"Invalid pubkey from \"+source+\" on \"+uid+\" (\"+e+ ')');\n    \t\t\t\t\tbreak; // try next node\n    \t\t\t\t}\n    \t\t\t\tif(sskData != null) {\n    \t\t\t\t\tfinishSSK(next);\n    \t\t\t\t\treturn;\n    \t\t\t\t}\n    \t\t\t\tcontinue;\n            \t}\n            \t\n            \tif(msg.getSpec() == DMT.FNPSSKDataFound) {\n\n            \t\tif(logMINOR) Logger.minor(this, \"Got data on \"+uid);\n            \t\t\n            \t\tif(!(key instanceof NodeSSK)) {\n            \t\t\tLogger.error(this, \"Got \"+msg+\" but expected a different key type from \"+next);\n            \t\t\tbreak;\n            \t\t}\n            \t\t\n                \theaders = ((ShortBuffer)msg.getObject(DMT.BLOCK_HEADERS)).getData();\n            \t\t\n                \tsskData = ((ShortBuffer)msg.getObject(DMT.DATA)).getData();\n                \t\n                \tif(pubKey != null) {\n                \t\tfinishSSK(next);\n                \t\treturn;\n                \t}\n                \tcontinue;\n            \t}\n            \t\n           \t\tLogger.error(this, \"Unexpected message: \"+msg);\n            \t\n            }\n        }\n\t}","id":60401,"modified_method":"private void realRun() {\n\t    freenet.support.Logger.OSThread.logPID(this);\n        if((key instanceof NodeSSK) && (pubKey == null)) {\n        \tpubKey = ((NodeSSK)key).getPubKey();\n        }\n        \n\t\tint routeAttempts=0;\n\t\tint rejectOverloads=0;\n        HashSet nodesRoutedTo = new HashSet();\n        HashSet nodesNotIgnored = new HashSet();\n\t\tArrayList busyPeers = new ArrayList();\n        while(true) {\n            if(logMINOR) Logger.minor(this, \"htl=\"+htl);\n            if(htl == 0) {\n            \t// This used to be RNF, I dunno why\n\t\t\t\t//???: finish(GENERATED_REJECTED_OVERLOAD, null);\n                finish(DATA_NOT_FOUND, null);\n                return;\n            }\n\n\t\t\trouteAttempts++;\n            \n            // Route it\n\t\t\tlong sendTimeout = SEND_TIMEOUT;\n\t\t\tboolean usingBusyPeer=false;\n            PeerNode next;\n            next = node.peers.closerPeer(source, nodesRoutedTo, nodesNotIgnored, target, true, node.isAdvancedModeEnabled(), -1, null);\n            \n\t\t\tif (next == null && !busyPeers.isEmpty()) {\n\t\t\t\tnext = (PeerNode)busyPeers.remove(0);\n\t\t\t\tusingBusyPeer=true;\n\t\t\t\tif (logMINOR) Logger.minor(this, \"trying previously-found busy peer: \"+next);\n\t\t\t\tsendTimeout = MAX_SEND_TIMEOUT;\n\t\t\t}\n\t\t\t\n            if(next == null) {\n\t\t\t\tif (logMINOR && rejectOverloads>0)\n\t\t\t\t\tLogger.minor(this, \"no more peers, but overloads (\"+rejectOverloads+\"/\"+routeAttempts+\" overloaded)\");\n                // Backtrack\n                finish(ROUTE_NOT_FOUND, null);\n                return;\n            }\n\t\t\t\n            double nextValue=next.getLocation();\n\t\t\t\n            if(logMINOR) Logger.minor(this, \"Routing request to \"+next);\n            nodesRoutedTo.add(next);\n            \n            if(Location.distance(target, nextValue) > Location.distance(target, nearestLoc)) {\n                htl = node.decrementHTL(source, htl);\n                if(logMINOR) Logger.minor(this, \"Backtracking: target=\"+target+\" next=\"+nextValue+\" closest=\"+nearestLoc+\" so htl=\"+htl);\n            }\n            \n            Message req = createDataRequest();\n            \n            // Not possible to get an accurate time for sending, guaranteed to be not later than the time of receipt.\n            // Why? Because by the time the sent() callback gets called, it may already have been acked, under heavy load.\n            // So take it from when we first started to try to send the request.\n            // See comments below when handling FNPRecentlyFailed for why we need this.\n            long timeSentRequest = System.currentTimeMillis();\n\t\t\t\n            try {\n            \t//This is the first contact to this node, it is more likely to timeout\n\t\t\t\t/*\n\t\t\t\t * using sendSync could:\n\t\t\t\t *   make ACCEPTED_TIMEOUT more accurate (as it is measured from the send-time),\n\t\t\t\t *   use a lot of our time that we have to fulfill this request (simply waiting on the send queue, or longer if the node just went down),\n\t\t\t\t * using sendAsync could:\n\t\t\t\t *   make ACCEPTED_TIMEOUT much more likely,\n\t\t\t\t *   leave many hanging-requests/unclaimedFIFO items,\n\t\t\t\t *   potentially make overloaded peers MORE overloaded (we make a request and promptly forget about them).\n\t\t\t\t * using conditionalSend could:\n\t\t\t\t *   make ACCEPTED_TIMEOUT as accurate as sendSync (as it to waits for transmittion)\n\t\t\t\t *   reduce general latency around peers which have slow network links\n\t\t\t\t *   not needlessly overload nodes w/ forgotten requests (as conditonalSend will try and withdraw the request if it times out)\n\t\t\t\t *!!!make us skip peers which would otherwise have the data (they are closer, but slower)\n\t\t\t\t *\n\t\t\t\t * To avoid the pitfall of conditionalSend (potentially skipping a good peer), we will come back to them when it is\n\t\t\t\t * apparent that we cannot fill the request quickly. Using conditionalSend this way might actually approximate\n\t\t\t\t * Q-routing (for load balancing/latency) across the network; if SEND_TIMEOUT is too high... this reduces to\n\t\t\t\t * using sendSync w/ a good error catch, and if SEND_TIMEOUT is too low... this reduces to creating a cache-backbone\n\t\t\t\t * of fast links in the network which will always be queried before general nodes in the network are.\n\t\t\t\t */\n            \tif (!next.conditionalSend(req, this, sendTimeout)) {\n\t\t\t\t\tif (usingBusyPeer)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tLogger.normal(this, \"will try this peer later if no others are available\");\n\t\t\t\t\tbusyPeers.add(next);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n            } catch (NotConnectedException e) {\n            \tLogger.minor(this, \"Not connected\");\n            \tcontinue;\n            }\n            \n            synchronized(this) {\n            \thasForwarded = true;\n            }\n            \n            Message msg = null;\n            \n            while(true) {\n            \t\n                /**\n                 * What are we waiting for?\n                 * FNPAccepted - continue\n                 * FNPRejectedLoop - go to another node\n                 * FNPRejectedOverload - propagate back to source, go to another node if local\n                 */\n                \n                MessageFilter mfAccepted = MessageFilter.create().setSource(next).setField(DMT.UID, uid).setTimeout(ACCEPTED_TIMEOUT).setType(DMT.FNPAccepted);\n                MessageFilter mfRejectedLoop = MessageFilter.create().setSource(next).setField(DMT.UID, uid).setTimeout(ACCEPTED_TIMEOUT).setType(DMT.FNPRejectedLoop);\n                MessageFilter mfRejectedOverload = MessageFilter.create().setSource(next).setField(DMT.UID, uid).setTimeout(ACCEPTED_TIMEOUT).setType(DMT.FNPRejectedOverload);\n\n                // mfRejectedOverload must be the last thing in the or\n                // So its or pointer remains null\n                // Otherwise we need to recreate it below\n                MessageFilter mf = mfAccepted.or(mfRejectedLoop.or(mfRejectedOverload));\n                \n                try {\n                    msg = node.usm.waitFor(mf, this);\n                    if(logMINOR) Logger.minor(this, \"first part got \"+msg);\n                } catch (DisconnectedException e) {\n                    Logger.normal(this, \"Disconnected from \"+next+\" while waiting for Accepted on \"+uid);\n                    break;\n                }\n                \n            \tif(msg == null) {\n            \t\tif(logMINOR) Logger.minor(this, \"Timeout waiting for Accepted\");\n            \t\t// Timeout waiting for Accepted\n            \t\tnext.localRejectedOverload(\"AcceptedTimeout\");\n            \t\tforwardRejectedOverload();\n            \t\t// Try next node\n            \t\tbreak;\n            \t}\n            \t\n            \tif(msg.getSpec() == DMT.FNPRejectedLoop) {\n            \t\tif(logMINOR) Logger.minor(this, \"Rejected loop\");\n            \t\tnext.successNotOverload();\n            \t\t// Find another node to route to\n            \t\tbreak;\n            \t}\n            \t\n            \tif(msg.getSpec() == DMT.FNPRejectedOverload) {\n            \t\tif(logMINOR) Logger.minor(this, \"Rejected: overload\");\n\t\t\t\t\t// Non-fatal - probably still have time left\n\t\t\t\t\tforwardRejectedOverload();\n\t\t\t\t\tif (msg.getBoolean(DMT.IS_LOCAL)) {\n\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Is local\");\n\t\t\t\t\t\tnext.localRejectedOverload(\"ForwardRejectedOverload\");\n\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Local RejectedOverload, moving on to next peer\");\n\t\t\t\t\t\t// Give up on this one, try another\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//Could be a previous rejection, the timeout to incur another ACCEPTED_TIMEOUT is minimal...\n\t\t\t\t\tcontinue;\n            \t}\n            \t\n            \tif(msg.getSpec() != DMT.FNPAccepted) {\n            \t\tLogger.error(this, \"Unrecognized message: \"+msg);\n            \t\tcontinue;\n            \t}\n            \t\n            \tbreak;\n            }\n            \n            if((msg == null) || (msg.getSpec() != DMT.FNPAccepted)) {\n            \t// Try another node\n            \tcontinue;\n            }\n\n            if(logMINOR) Logger.minor(this, \"Got Accepted\");\n            \n            // Otherwise, must be Accepted\n            \n            // So wait...\n            int gotMessages=0;\n            String lastMessage=null;\n            while(true) {\n            \t\n                MessageFilter mfDNF = MessageFilter.create().setSource(next).setField(DMT.UID, uid).setTimeout(FETCH_TIMEOUT).setType(DMT.FNPDataNotFound);\n                MessageFilter mfRF = MessageFilter.create().setSource(next).setField(DMT.UID, uid).setTimeout(FETCH_TIMEOUT).setType(DMT.FNPRecentlyFailed);\n                MessageFilter mfDF = makeDataFoundFilter(next);\n                MessageFilter mfRouteNotFound = MessageFilter.create().setSource(next).setField(DMT.UID, uid).setTimeout(FETCH_TIMEOUT).setType(DMT.FNPRouteNotFound);\n                MessageFilter mfRejectedOverload = MessageFilter.create().setSource(next).setField(DMT.UID, uid).setTimeout(FETCH_TIMEOUT).setType(DMT.FNPRejectedOverload);\n                MessageFilter mfPubKey = MessageFilter.create().setSource(next).setField(DMT.UID, uid).setTimeout(FETCH_TIMEOUT).setType(DMT.FNPSSKPubKey);\n            \tMessageFilter mfRealDFCHK = MessageFilter.create().setSource(next).setField(DMT.UID, uid).setTimeout(FETCH_TIMEOUT).setType(DMT.FNPCHKDataFound);\n            \tMessageFilter mfRealDFSSK = MessageFilter.create().setSource(next).setField(DMT.UID, uid).setTimeout(FETCH_TIMEOUT).setType(DMT.FNPSSKDataFound);\n                MessageFilter mf = mfDNF.or(mfRF.or(mfRouteNotFound.or(mfRejectedOverload.or(mfDF.or(mfPubKey.or(mfRealDFCHK.or(mfRealDFSSK)))))));\n\n                \n            \ttry {\n            \t\tmsg = node.usm.waitFor(mf, this);\n            \t} catch (DisconnectedException e) {\n            \t\tLogger.normal(this, \"Disconnected from \"+next+\" while waiting for data on \"+uid);\n            \t\tbreak;\n            \t}\n            \t\n            \tif(logMINOR) Logger.minor(this, \"second part got \"+msg);\n                \n            \tif(msg == null) {\n\t\t\t\t\tLogger.normal(this, \"request fatal-timeout (null) after accept (\"+gotMessages+\" messages; last=\"+lastMessage+\")\");\n            \t\t// Fatal timeout\n            \t\tnext.localRejectedOverload(\"FatalTimeout\");\n            \t\tforwardRejectedOverload();\n            \t\tfinish(TIMED_OUT, next);\n            \t\treturn;\n            \t}\n\t\t\t\t\n\t\t\t\t//For debugging purposes, remember the number of responses AFTER the insert, and the last message type we received.\n\t\t\t\tgotMessages++;\n\t\t\t\tlastMessage=msg.getSpec().getName();\n            \t\n            \tif(msg.getSpec() == DMT.FNPDataNotFound) {\n            \t\tnext.successNotOverload();\n            \t\tfinish(DATA_NOT_FOUND, next);\n            \t\treturn;\n            \t}\n            \t\n            \tif(msg.getSpec() == DMT.FNPRecentlyFailed) {\n            \t\tnext.successNotOverload();\n            \t\t/*\n            \t\t * Must set a correct recentlyFailedTimeLeft before calling this finish(), because it will be\n            \t\t * passed to the handler.\n            \t\t * \n            \t\t * It is *VITAL* that the TIME_LEFT we pass on is not larger than it should be.\n            \t\t * It is somewhat less important that it is not too much smaller than it should be.\n            \t\t * \n            \t\t * Why? Because:\n            \t\t * 1) We have to use FNPRecentlyFailed to create failure table entries. Because otherwise,\n            \t\t * the failure table is of little value: A request is routed through a node, which gets a DNF,\n            \t\t * and adds a failure table entry. Other requests then go through that node via other paths.\n            \t\t * They are rejected with FNPRecentlyFailed - not with DataNotFound. If this does not create\n            \t\t * failure table entries, more requests will be pointlessly routed through that chain.\n            \t\t * \n            \t\t * 2) If we use a fixed timeout on receiving FNPRecentlyFailed, they can be self-seeding. \n            \t\t * What this means is A sends a request to B, which DNFs. This creates a failure table entry \n            \t\t * which lasts for 10 minutes. 5 minutes later, A sends another request to B, which is killed\n            \t\t * with FNPRecentlyFailed because of the failure table entry. B's failure table lasts for \n            \t\t * another 5 minutes, but A's lasts for the full 10 minutes i.e. until 5 minutes after B's. \n            \t\t * After B's failure table entry has expired, but before A's expires, B sends a request to A. \n            \t\t * A replies with FNPRecentlyFailed. Repeat ad infinitum: A reinforces B's blocks, and B \n            \t\t * reinforces A's blocks!\n            \t\t * \n            \t\t * 3) This can still happen even if we check where the request is coming from. A loop could \n            \t\t * very easily form: A - B - C - A. A requests from B, DNFs (assume the request comes in from \n            \t\t * outside, there are more nodes. C requests from A, sets up a block. B's block expires, C's \n            \t\t * is still active. A requests from B which requests from C ... and it goes round again.\n            \t\t * \n            \t\t * 4) It is exactly the same if we specify a timeout, unless the timeout can be guaranteed to \n            \t\t * not increase the expiry time.\n            \t\t */\n            \t\t\n            \t\t// First take the original TIME_LEFT. This will start at 10 minutes if we get rejected in\n            \t\t// the same millisecond as the failure table block was added.\n            \t\tint timeLeft = msg.getInt(DMT.TIME_LEFT);\n            \t\tint origTimeLeft = timeLeft;\n            \t\t\n            \t\tif(timeLeft <= 0) {\n            \t\t\tLogger.error(this, \"Impossible: timeLeft=\"+timeLeft);\n            \t\t\torigTimeLeft = 0;\n            \t\t\ttimeLeft=1000; // arbitrary default...\n            \t\t}\n            \t\t\n            \t\t// This is in theory relative to when the request was received by the node. Lets make it relative\n            \t\t// to a known event before that: the time when we sent the request.\n            \t\t\n            \t\tlong timeSinceSent = Math.max(0, (System.currentTimeMillis() - timeSentRequest));\n            \t\ttimeLeft -= timeSinceSent;\n            \t\t\n            \t\t// Subtract 1% for good measure / to compensate for dodgy clocks\n            \t\ttimeLeft -= origTimeLeft / 100;\n            \t\t\n            \t\tif(timeLeft <= 0) {\n            \t\t\t// No timeout left, cool\n            \t\t\tfinish(DATA_NOT_FOUND, next);\n            \t\t} else {\n            \t\t\t// Some timeout left\n            \t\t\tfinish(RECENTLY_FAILED, next);\n            \t\t}\n            \t\treturn;\n            \t}\n            \t\n            \tif(msg.getSpec() == DMT.FNPRouteNotFound) {\n            \t\t// Backtrack within available hops\n            \t\tshort newHtl = msg.getShort(DMT.HTL);\n            \t\tif(newHtl < htl) htl = newHtl;\n            \t\tnext.successNotOverload();\n            \t\tbreak;\n            \t}\n            \t\n            \tif(msg.getSpec() == DMT.FNPRejectedOverload) {\n\t\t\t\t\t// Non-fatal - probably still have time left\n\t\t\t\t\tforwardRejectedOverload();\n\t\t\t\t\trejectOverloads++;\n\t\t\t\t\tif (msg.getBoolean(DMT.IS_LOCAL)) {\n\t\t\t\t\t\t//NB: IS_LOCAL means it's terminal. not(IS_LOCAL) implies that the rejection message was forwarded from a downstream node.\n\t\t\t\t\t\t//\"Local\" from our peers perspective, this has nothing to do with local requests (source==null)\n\t\t\t\t\t\tnext.localRejectedOverload(\"ForwardRejectedOverload2\");\n\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Local RejectedOverload, moving on to next peer\");\n\t\t\t\t\t\t// Give up on this one, try another\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//so long as the node does not send a (IS_LOCAL) message. Interestingly messages can often timeout having only received this message.\n\t\t\t\t\tcontinue;\n            \t}\n\n            \tif(msg.getSpec() == DMT.FNPCHKDataFound) {\n            \t\tif(!(key instanceof NodeCHK)) {\n            \t\t\tLogger.error(this, \"Got \"+msg+\" but expected a different key type from \"+next);\n            \t\t\tbreak;\n            \t\t}\n            \t\t\n                \t// Found data\n                \tnext.successNotOverload();\n                \t\n                \t// First get headers\n                \t\n                \theaders = ((ShortBuffer)msg.getObject(DMT.BLOCK_HEADERS)).getData();\n                \t\n                \t// FIXME: Validate headers\n                \t\n                \tnode.addTransferringSender((NodeCHK)key, this);\n                \t\n                \ttry {\n                \t\t\n                \t\tprb = new PartiallyReceivedBlock(Node.PACKETS_IN_BLOCK, Node.PACKET_SIZE);\n                \t\t\n                \t\tsynchronized(this) {\n                \t\t\tnotifyAll();\n                \t\t}\n                \t\t\n                \t\tBlockReceiver br = new BlockReceiver(node.usm, next, uid, prb, this);\n                \t\t\n                \t\ttry {\n                \t\t\tif(logMINOR) Logger.minor(this, \"Receiving data\");\n                \t\t\tbyte[] data = br.receive();\n                \t\t\tif(logMINOR) Logger.minor(this, \"Received data\");\n                \t\t\t// Received data\n                \t\t\ttry {\n                \t\t\t\tverifyAndCommit(data);\n                \t\t\t} catch (KeyVerifyException e1) {\n                \t\t\t\tLogger.normal(this, \"Got data but verify failed: \"+e1, e1);\n                \t\t\t\tfinish(VERIFY_FAILURE, next);\n                \t\t\t\treturn;\n                \t\t\t}\n                \t\t\tfinish(SUCCESS, next);\n                \t\t\treturn;\n                \t\t} catch (RetrievalException e) {\n\t\t\t\t\t\t\tif (e.getReason()==RetrievalException.SENDER_DISCONNECTED)\n\t\t\t\t\t\t\t\tLogger.normal(this, \"Transfer failed: \"+e, e);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tLogger.error(this, \"Transfer failed: \"+e, e);\n                \t\t\tfinish(TRANSFER_FAILED, next);\n                \t\t\treturn;\n                \t\t}\n                \t} finally {\n                \t\tnode.removeTransferringSender((NodeCHK)key, this);\n                \t}\n            \t}\n            \t\n            \tif(msg.getSpec() == DMT.FNPSSKPubKey) {\n            \t\t\n            \t\tif(logMINOR) Logger.minor(this, \"Got pubkey on \"+uid);\n            \t\t\n            \t\tif(!(key instanceof NodeSSK)) {\n            \t\t\tLogger.error(this, \"Got \"+msg+\" but expected a different key type from \"+next);\n            \t\t\tbreak;\n            \t\t}\n    \t\t\t\tbyte[] pubkeyAsBytes = ((ShortBuffer)msg.getObject(DMT.PUBKEY_AS_BYTES)).getData();\n    \t\t\t\ttry {\n    \t\t\t\t\tif(pubKey == null)\n    \t\t\t\t\t\tpubKey = DSAPublicKey.create(pubkeyAsBytes);\n    \t\t\t\t\t((NodeSSK)key).setPubKey(pubKey);\n    \t\t\t\t} catch (SSKVerifyException e) {\n    \t\t\t\t\tpubKey = null;\n    \t\t\t\t\tLogger.error(this, \"Invalid pubkey from \"+source+\" on \"+uid+\" (\"+e.getMessage()+ ')', e);\n    \t\t\t\t\tbreak; // try next node\n    \t\t\t\t} catch (CryptFormatException e) {\n    \t\t\t\t\tLogger.error(this, \"Invalid pubkey from \"+source+\" on \"+uid+\" (\"+e+ ')');\n    \t\t\t\t\tbreak; // try next node\n    \t\t\t\t}\n    \t\t\t\tif(sskData != null) {\n    \t\t\t\t\tfinishSSK(next);\n    \t\t\t\t\treturn;\n    \t\t\t\t}\n    \t\t\t\tcontinue;\n            \t}\n            \t\n            \tif(msg.getSpec() == DMT.FNPSSKDataFound) {\n\n            \t\tif(logMINOR) Logger.minor(this, \"Got data on \"+uid);\n            \t\t\n            \t\tif(!(key instanceof NodeSSK)) {\n            \t\t\tLogger.error(this, \"Got \"+msg+\" but expected a different key type from \"+next);\n            \t\t\tbreak;\n            \t\t}\n            \t\t\n                \theaders = ((ShortBuffer)msg.getObject(DMT.BLOCK_HEADERS)).getData();\n            \t\t\n                \tsskData = ((ShortBuffer)msg.getObject(DMT.DATA)).getData();\n                \t\n                \tif(pubKey != null) {\n                \t\tfinishSSK(next);\n                \t\treturn;\n                \t}\n                \tcontinue;\n            \t}\n            \t\n           \t\tLogger.error(this, \"Unexpected message: \"+msg);\n            \t\n            }\n        }\n\t}","commit_id":"b47858c18dfcc01854c8123ccbc290d9976dec23","url":"https://github.com/freenet/fred"},{"original_method":"public RetrievalException(int reason) {\n\t\t_reason = reason;\n\t}","id":60402,"modified_method":"public RetrievalException(int reason) {\n\t\t_reason = reason;\n\t\t_cause = getErrString(reason);\n\t}","commit_id":"b47858c18dfcc01854c8123ccbc290d9976dec23","url":"https://github.com/freenet/fred"},{"original_method":"public RetrievalException(int reason, String cause) {\n\t\tthis(reason);\n\t\t_cause = cause;\n\t}","id":60403,"modified_method":"public RetrievalException(int reason, String cause) {\n\t\tthis(reason);\n\t\t_cause = cause;\n\t\tif (cause==null || cause.length()==0 || cause.equals(\"null\"))\n\t\t\t_cause=getErrString(reason);\n\t}","commit_id":"b47858c18dfcc01854c8123ccbc290d9976dec23","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n    protected void setUp() throws Exception\n    {\n        super.setUp();\n\n        // Statically store the component manager in {@link Utils} to be able to access it without\n        // the context.\n        Utils.setComponentManager(getComponentManager());\n        \n        this.context = new XWikiContext();\n\n        this.context.setWikiId(\"xwiki\");\n        this.context.setMainXWiki(\"xwiki\");\n\n        // Make sure response.encodeURL() calls don't fail\n        Mock xwikiResponse = mock(XWikiResponse.class);\n        xwikiResponse.stubs().method(\"setLocale\");\n        xwikiResponse.stubs().method(\"encodeURL\").will(\n            new CustomStub(\"Implements XWikiResponse.encodeURL\")\n            {\n                @Override\n                public Object invoke(Invocation invocation) throws Throwable\n                {\n                    return invocation.parameterValues.get(0);\n                }\n            });\n        this.context.setResponse((XWikiResponse) xwikiResponse.proxy());\n\n        // We need to initialize the Component Manager so that the components can be looked up\n        getContext().put(ComponentManager.class.getName(), getComponentManager());\n\n        // Bridge with old XWiki Context, required for old code.\n        Execution execution = getComponentManager().getInstance(Execution.class);\n        this.context.declareInExecutionContext(execution.getContext());\n        XWikiStubContextProvider stubContextProvider =\n            getComponentManager().getInstance(XWikiStubContextProvider.class);\n        stubContextProvider.initialize(this.context);\n\n        // Since the oldcore module draws the Servlet Environment in its dependencies we need to ensure it's set up\n        // correctly with a Servlet Context.\n        ServletEnvironment environment = getComponentManager().getInstance(Environment.class);\n        Mock mockServletContext = mock(ServletContext.class); \n        environment.setServletContext((ServletContext) mockServletContext.proxy());\n        mockServletContext.stubs().method(\"getResourceAsStream\").with(eq(\"/WEB-INF/cache/infinispan/config.xml\"))\n            .will(returnValue(null));\n        mockServletContext.stubs().method(\"getAttribute\").with(eq(\"javax.servlet.context.tempdir\"))\n            .will(returnValue(new File(System.getProperty(\"java.io.tmpdir\"))));\n        mockServletContext.stubs().method(\"getResourceAsStream\").with(eq(\"/WEB-INF/xwiki.cfg\"))\n        .will(returnValue(null));\n\n        Mock mockCoreConfiguration = registerMockComponent(CoreConfiguration.class);\n        mockCoreConfiguration.stubs().method(\"getDefaultDocumentSyntax\").will(returnValue(Syntax.XWIKI_1_0));\n    }","id":60404,"modified_method":"@Override\n    protected void setUp() throws Exception\n    {\n        super.setUp();\n\n        // Statically store the component manager in {@link Utils} to be able to access it without\n        // the context.\n        Utils.setComponentManager(getComponentManager());\n        \n        this.context = new XWikiContext();\n\n        this.context.setWikiId(\"xwiki\");\n        this.context.setMainXWiki(\"xwiki\");\n\n        // Make sure response.encodeURL() calls don't fail\n        Mock xwikiResponse = mock(XWikiResponse.class);\n        xwikiResponse.stubs().method(\"setLocale\");\n        xwikiResponse.stubs().method(\"encodeURL\").will(\n            new CustomStub(\"Implements XWikiResponse.encodeURL\")\n            {\n                @Override\n                public Object invoke(Invocation invocation) throws Throwable\n                {\n                    return invocation.parameterValues.get(0);\n                }\n            });\n        this.context.setResponse((XWikiResponse) xwikiResponse.proxy());\n\n        // We need to initialize the Component Manager so that the components can be looked up\n        getContext().put(ComponentManager.class.getName(), getComponentManager());\n\n        // Bridge with old XWiki Context, required for old code.\n        Execution execution = getComponentManager().getInstance(Execution.class);\n        this.context.declareInExecutionContext(execution.getContext());\n        XWikiStubContextProvider stubContextProvider =\n            getComponentManager().getInstance(XWikiStubContextProvider.class);\n        stubContextProvider.initialize(this.context);\n\n        // Since the oldcore module draws the Servlet Environment in its dependencies we need to ensure it's set up\n        // correctly with a Servlet Context.\n        ServletEnvironment environment = getComponentManager().getInstance(Environment.class);\n        Mock mockServletContext = mock(ServletContext.class); \n        environment.setServletContext((ServletContext) mockServletContext.proxy());\n        mockServletContext.stubs().method(\"getResourceAsStream\").will(returnValue(null));\n        mockServletContext.stubs().method(\"getResource\").will(returnValue(null));\n        mockServletContext.stubs().method(\"getAttribute\").with(eq(\"javax.servlet.context.tempdir\"))\n            .will(returnValue(new File(System.getProperty(\"java.io.tmpdir\"))));\n\n        Mock mockCoreConfiguration = registerMockComponent(CoreConfiguration.class);\n        mockCoreConfiguration.stubs().method(\"getDefaultDocumentSyntax\").will(returnValue(Syntax.XWIKI_1_0));\n    }","commit_id":"a1605692b8227378d2b048cd255d1f0a709811bd","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private TemplateContent getTemplateContentFromSkin(String template, String skin)\n    {\n        TemplateContent content;\n\n        // Try from wiki pages\n        XWikiDocument skinDocument = getSkinDocument(skin);\n        if (skinDocument != null) {\n            content = getTemplateContentFromDocumentSkin(template, skinDocument);\n        } else {\n            // If not a wiki based skin try from filesystem skins\n            content = getResourceAsStringContent(\"/skins/\" + skin + '/', template);\n        }\n\n        return content;\n    }","id":60405,"modified_method":"private TemplateContent getTemplateContentFromSkin(String template, String skin)\n    {\n        TemplateContent content;\n\n        // Try from wiki pages\n        // FIXME: macros.vm from document based skins is not supported by default VelocityManager yet\n        XWikiDocument skinDocument = template.equals(\"macros.vm\") ? null : getSkinDocument(skin);\n        if (skinDocument != null) {\n            content = getTemplateContentFromDocumentSkin(template, skinDocument);\n        } else {\n            // If not a wiki based skin try from filesystem skins\n            content = getResourceAsStringContent(\"/skins/\" + skin + '/', template);\n        }\n\n        return content;\n    }","commit_id":"a1605692b8227378d2b048cd255d1f0a709811bd","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private String getPathFromSkin(String template, String skin)\n    {\n        String path;\n\n        // Try from wiki pages\n        // FIXME: macros.vm from document based skins is not supported by default VelocityManager yet\n        XWikiDocument skinDocument = template.equals(\"macros.vm\") ? null : getSkinDocument(skin);\n        if (skinDocument != null) {\n            path = getPathFromDocumentSkin(template, skinDocument);\n        } else {\n            // If not a wiki based skin try from filesystem skins\n            path = getResourcePath(\"/skins/\" + skin + '/', template);\n        }\n\n        return path;\n    }","id":60406,"modified_method":"private String getPathFromSkin(String template, String skin)\n    {\n        String path;\n\n        // Try from wiki pages\n        // FIXME: macros.vm from document based skins is not supported by default VelocityManager yet\n        XWikiDocument skinDocument = template.equals(\"macros.vm\") ? null : getSkinDocument(skin);\n        if (skinDocument != null) {\n            path = getPathFromDocumentSkin(template, skinDocument);\n        } else {\n            // If not a wiki based skin try from filesystem skins\n            path = getResourcePath(\"/skins/\" + skin + '/', template, true);\n        }\n\n        return path;\n    }","commit_id":"a1605692b8227378d2b048cd255d1f0a709811bd","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private TemplateContent getResourceAsStringContent(String suffixPath, String template)\n    {\n        String templatePath = getResourcePath(suffixPath, template);\n\n        InputStream inputStream = this.environment.getResourceAsStream(templatePath);\n        if (inputStream != null) {\n            try {\n                return new FilesystemTemplateContent(IOUtils.toString(inputStream, \"UTF-8\"), templatePath);\n            } catch (IOException e) {\n                this.logger.error(\"Faied to get content of resource [{}]\", templatePath, e);\n            } finally {\n                IOUtils.closeQuietly(inputStream);\n            }\n        }\n\n        return null;\n    }","id":60407,"modified_method":"private TemplateContent getResourceAsStringContent(String suffixPath, String template)\n    {\n        String templatePath = getResourcePath(suffixPath, template, false);\n\n        InputStream inputStream = this.environment.getResourceAsStream(templatePath);\n        if (inputStream != null) {\n            try {\n                return new FilesystemTemplateContent(IOUtils.toString(inputStream, \"UTF-8\"), templatePath);\n            } catch (IOException e) {\n                this.logger.error(\"Faied to get content of resource [{}]\", templatePath, e);\n            } finally {\n                IOUtils.closeQuietly(inputStream);\n            }\n        }\n\n        return null;\n    }","commit_id":"a1605692b8227378d2b048cd255d1f0a709811bd","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public String getPath(String template)\n    {\n        String path = null;\n\n        // Try from skin\n        String skin = getSkin();\n        if (skin != null) {\n            path = getPathFromSkin(template, skin);\n        }\n\n        // Try from base skin\n        if (path == null) {\n            String baseSkin = getBaseSkin();\n            if (baseSkin != null) {\n                path = getPathFromSkin(template, baseSkin);\n            }\n        }\n\n        // Try from /template/ resources\n        if (path == null) {\n            path = getResourcePath(\"/templates/\", template);\n        }\n\n        return path;\n    }","id":60408,"modified_method":"public String getPath(String template)\n    {\n        String path = null;\n\n        // Try from skin\n        String skin = getSkin();\n        if (skin != null) {\n            path = getPathFromSkin(template, skin);\n        }\n\n        // Try from base skin\n        if (path == null) {\n            String baseSkin = getBaseSkin();\n            if (baseSkin != null) {\n                path = getPathFromSkin(template, baseSkin);\n            }\n        }\n\n        // Try from /template/ resources\n        if (path == null) {\n            path = getResourcePath(\"/templates/\", template, true);\n        }\n\n        return path;\n    }","commit_id":"a1605692b8227378d2b048cd255d1f0a709811bd","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private String getResourcePath(String suffixPath, String template)\n    {\n        String templatePath = suffixPath + template;\n\n        // Prevent inclusion of templates from other directories\n        String normalizedTemplate = URI.create(templatePath).normalize().toString();\n        if (!normalizedTemplate.startsWith(suffixPath)) {\n            this.logger.warn(\"Direct access to template file [{}] refused. Possible break-in attempt!\",\n                normalizedTemplate);\n\n            return null;\n        }\n\n        return templatePath;\n    }","id":60409,"modified_method":"private String getResourcePath(String suffixPath, String template, boolean testExist)\n    {\n        String templatePath = suffixPath + template;\n\n        // Prevent inclusion of templates from other directories\n        String normalizedTemplate = URI.create(templatePath).normalize().toString();\n        if (!normalizedTemplate.startsWith(suffixPath)) {\n            this.logger.warn(\"Direct access to template file [{}] refused. Possible break-in attempt!\",\n                normalizedTemplate);\n\n            return null;\n        }\n\n        if (testExist) {\n            // Check if the resource exist\n            if (this.environment.getResource(templatePath) == null) {\n                return null;\n            }\n        }\n\n        return templatePath;\n    }","commit_id":"a1605692b8227378d2b048cd255d1f0a709811bd","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    protected void setUp() throws Exception\n    {\n        super.setUp();\n\n        this.renderer = new XWikiVelocityRenderer();\n\n        this.mockXWiki = mock(XWiki.class);\n        this.mockXWiki.stubs().method(\"getSkin\").will(returnValue(\"default\"));\n        this.mockXWiki.stubs().method(\"getSkinFile\").will(returnValue(null));\n        this.mockXWiki.stubs().method(\"getResourceContent\").will(returnValue(null));\n        this.mockXWiki.stubs().method(\"prepareResources\");\n        getContext().setWiki((XWiki) this.mockXWiki.proxy());\n\n        this.mockContentDocument = mock(XWikiDocument.class);\n        this.contentDocument = (XWikiDocument) this.mockContentDocument.proxy();\n\n        this.mockDocument = mock(XWikiDocument.class);\n        this.document = (XWikiDocument) this.mockDocument.proxy();\n\n        Mock mockApiDocument =\n            mock(Document.class, new Class[] {XWikiDocument.class, XWikiContext.class}, new Object[] {this.document,\n            getContext()});\n        this.mockDocument.stubs().method(\"newDocument\").will(returnValue(mockApiDocument.proxy()));\n    }","id":60410,"modified_method":"@Override\n    protected void setUp() throws Exception\n    {\n        super.setUp();\n\n        this.renderer = new XWikiVelocityRenderer();\n\n        this.mockXWiki = mock(XWiki.class);\n        this.mockXWiki.stubs().method(\"getSkin\").will(returnValue(\"default\"));\n        this.mockXWiki.stubs().method(\"getSkinFile\").will(returnValue(null));\n        this.mockXWiki.stubs().method(\"getResourceContent\").will(returnValue(null));\n        this.mockXWiki.stubs().method(\"prepareResources\");\n        this.mockXWiki.stubs().method(\"getStore\").will(returnValue(null));\n        getContext().setWiki((XWiki) this.mockXWiki.proxy());\n\n        this.mockContentDocument = mock(XWikiDocument.class);\n        this.contentDocument = (XWikiDocument) this.mockContentDocument.proxy();\n\n        this.mockDocument = mock(XWikiDocument.class);\n        this.document = (XWikiDocument) this.mockDocument.proxy();\n\n        Mock mockApiDocument =\n            mock(Document.class, new Class[] {XWikiDocument.class, XWikiContext.class}, new Object[] {this.document,\n            getContext()});\n        this.mockDocument.stubs().method(\"newDocument\").will(returnValue(mockApiDocument.proxy()));\n    }","commit_id":"a1605692b8227378d2b048cd255d1f0a709811bd","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see junit.framework.TestCase#setUp()\n     */\n    protected void setUp()\n    {\n        this.rightService = new XWikiRightServiceImpl();\n\n        this.context = new XWikiContext();\n        this.context.setMainXWiki(\"xwiki\");\n        this.context.setDatabase(\"xwiki\");\n\n        this.mockAuthService = mock(XWikiGroupService.class, new Class[] {}, new Object[] {});\n        this.mockAuthService.stubs().method(\"listGroupsForUser\").will(\n            new CustomStub(\"Implements XWikiGroupService.listGroupsForUser\")\n            {\n                public Object invoke(Invocation invocation) throws Throwable\n                {\n                    String member = (String) invocation.parameterValues.get(0);\n                    XWikiContext context = (XWikiContext) invocation.parameterValues.get(1);\n\n                    if (context.getDatabase().equals(\"xwiki\") && member.equals(LOCALUSERNAME)) {\n                        return Collections.singleton(SHORTGROUPNAME);\n                    } else {\n                        return Collections.emptyList();\n                    }\n                }\n            });\n\n        this.mockXWiki =\n            mock(XWiki.class, new Class[] {XWikiConfig.class, XWikiContext.class}, new Object[] {\n            new XWikiConfig(), context});\n        this.mockXWiki.stubs().method(\"isVirtualMode\").will(\n            new CustomStub(\"Implements XWiki.isVirtualMode\")\n            {\n                public Object invoke(Invocation invocation) throws Throwable\n                {\n                    return true;\n                }\n            });\n        this.mockXWiki.stubs().method(\"getGroupService\").will(\n            new CustomStub(\"Implements XWiki.getGroupService\")\n            {\n                public Object invoke(Invocation invocation) throws Throwable\n                {\n                    return mockAuthService.proxy();\n                }\n            });\n        this.context.setWiki((XWiki) this.mockXWiki.proxy());\n    }","id":60411,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see junit.framework.TestCase#setUp()\n     */\n    protected void setUp()\n    {\n        this.rightService = new XWikiRightServiceImpl();\n\n        this.context = new XWikiContext();\n        this.context.setMainXWiki(\"xwiki\");\n        this.context.setDatabase(\"xwiki\");\n\n        this.mockAuthService = mock(XWikiGroupService.class, new Class[] {}, new Object[] {});\n        this.mockAuthService.stubs().method(\"listGroupsForUser\").will(\n            new CustomStub(\"Implements XWikiGroupService.listGroupsForUser\")\n            {\n                public Object invoke(Invocation invocation) throws Throwable\n                {\n                    String member = (String) invocation.parameterValues.get(0);\n                    XWikiContext context = (XWikiContext) invocation.parameterValues.get(1);\n\n                    if (context.getDatabase().equals(\"xwiki\") && member.equals(LOCALUSERNAME)) {\n                        return Collections.singleton(SHORTGROUPNAME);\n                    } else {\n                        return Collections.emptyList();\n                    }\n                }\n            });\n\n        this.mockXWiki =\n            mock(XWiki.class, new Class[] {XWikiConfig.class, XWikiContext.class}, new Object[] {\n            new XWikiConfig(), context});\n        this.mockXWiki.stubs().method(\"isVirtualMode\").will(returnValue(true));\n        this.mockXWiki.stubs().method(\"getGroupService\").will(returnValue(mockAuthService.proxy()));\n        \n        this.context.setWiki((XWiki) this.mockXWiki.proxy());\n    }","commit_id":"1d0d4efefda0e9b509f64fe55f5eb10460d94475","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Test if checkRight() take care of users's groups from other wikis.\n     */\n    public void testCheckRight() throws XWikiRightNotFoundException, XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument();\n        doc.setDatabase(\"wiki2\");\n        doc.setSpace(\"Space\");\n        doc.setName(\"Page\");\n\n        Mock mockGlobalRightObj = mock(BaseObject.class, new Class[] {}, new Object[] {});\n        mockGlobalRightObj.stubs().method(\"getStringValue\").will(\n            new CustomStub(\"Implements BaseObject.getStringValue\")\n            {\n                public Object invoke(Invocation invocation) throws Throwable\n                {\n                    String fieldName = (String) invocation.parameterValues.get(0);\n\n                    String value = null;\n                    if (fieldName.equals(\"levels\")) {\n                        value = \"view\";\n                    } else if (fieldName.equals(\"groups\")) {\n                        value = GLOBALGROUPNAME;\n                    } else if (fieldName.equals(\"users\")) {\n                        value = \"\";\n                    }\n\n                    return value;\n                }\n            });\n        mockGlobalRightObj.stubs().method(\"getIntValue\").will(\n            new CustomStub(\"Implements BaseObject.getIntValue\")\n            {\n                public Object invoke(Invocation invocation) throws Throwable\n                {\n                    String fieldName = (String) invocation.parameterValues.get(0);\n\n                    int value = 0;\n                    if (fieldName.equals(\"allow\")) {\n                        value = 1;\n                    }\n\n                    return value;\n                }\n            });\n        mockGlobalRightObj.stubs().method(\"setNumber\").will(\n            new CustomStub(\"Implements BaseObject.setNumber\")\n            {\n                public Object invoke(Invocation invocation) throws Throwable\n                {\n                    return null;\n                }\n            });\n\n        doc.addObject(\"XWiki.XWikiGlobalRights\", (BaseObject) mockGlobalRightObj.proxy());\n\n        this.context.setDatabase(\"wiki2\");\n\n        boolean result =\n            rightService.checkRight(GLOBALUSERNAME, doc, \"view\", true, true, true, context);\n\n        assertTrue(GLOBALUSERNAME + \"does not have global view right on wiki2\", result);\n    }","id":60412,"modified_method":"/**\n     * Test if checkRight() take care of users's groups from other wikis.\n     */\n    public void testCheckRight() throws XWikiRightNotFoundException, XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument();\n        doc.setDatabase(\"wiki2\");\n        doc.setSpace(\"Space\");\n        doc.setName(\"Page\");\n\n        Mock mockGlobalRightObj = mock(BaseObject.class, new Class[] {}, new Object[] {});\n        mockGlobalRightObj.stubs().method(\"getStringValue\").with(eq(\"levels\")).will(returnValue(\"view\"));\n        mockGlobalRightObj.stubs().method(\"getStringValue\").with(eq(\"groups\")).will(returnValue(GLOBALGROUPNAME));\n        mockGlobalRightObj.stubs().method(\"getStringValue\").with(eq(\"users\")).will(returnValue(\"\"));\n        mockGlobalRightObj.stubs().method(\"getIntValue\").with(eq(\"allow\")).will(returnValue(1));\n        mockGlobalRightObj.stubs().method(\"setNumber\");\n\n        doc.addObject(\"XWiki.XWikiGlobalRights\", (BaseObject) mockGlobalRightObj.proxy());\n\n        this.context.setDatabase(\"wiki2\");\n\n        boolean result =\n            rightService.checkRight(GLOBALUSERNAME, doc, \"view\", true, true, true, context);\n\n        assertTrue(GLOBALUSERNAME + \"does not have global view right on wiki2\", result);\n    }","commit_id":"1d0d4efefda0e9b509f64fe55f5eb10460d94475","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void test1() throws Exception {\n        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\n        kbuilder.add( ResourceFactory.newClassPathResource( \"model.drl\", getClass() ),\n                      ResourceType.DRL );      \n        if ( kbuilder.hasErrors() ) {\n            fail( kbuilder.getErrors().toString() );\n        }\n        \n        kbuilder.add( ResourceFactory.newClassPathResource( \"./commands/commands-model.drl\", getClass() ),\n                      ResourceType.DRL );        \n        if ( kbuilder.hasErrors() ) {\n            fail( kbuilder.getErrors().toString() );\n        }\n        \n        kbuilder.add( ResourceFactory.newClassPathResource( \"queries.drl\", getClass() ),\n                      ResourceType.DRL );      \n        if ( kbuilder.hasErrors() ) {\n            fail( kbuilder.getErrors().toString() );\n        }\n        \n        kbuilder.add( ResourceFactory.newClassPathResource( \"commands.drl\", getClass() ),\n                      ResourceType.DRL );          \n        if ( kbuilder.hasErrors() ) {\n            fail( kbuilder.getErrors().toString() );\n        }\n\n\n        KnowledgeBaseConfiguration kbaseConf = KnowledgeBaseFactory.newKnowledgeBaseConfiguration();\n        kbaseConf.setOption( AssertBehaviorOption.EQUALITY );\n        \n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase( kbaseConf );\n        kbase.addKnowledgePackages( kbuilder.getKnowledgePackages() );\n\n        \n//        KnowledgeSessionConfiguration ksessionConf = KnowledgeBaseFactory.newKnowledgeSessionConfiguration();\n//        ksessionConf.setOption( AssertBehaviorOption.EQUALITY );\n        \n        Counter c = new Counter();\n        StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession();\n        ksession.setGlobal( \"counter\",c );\n        \n//        ksession.getChannels().put( \"io\", new Channel() {            \n//            public void send(Object arg) {\n//                System.out.println(arg);\n//            }\n//        } );\n        \n        \n        Thread.currentThread().setContextClassLoader( (((InternalRuleBase)((KnowledgeBaseImpl) kbase).ruleBase).getRootClassLoader() )  );        \n        Map vars = new HashMap();\n        vars.put(\"c\", c);\n        Map<String,Map> map = (Map<String,Map>) MVEL.executeExpression( MVEL.compileExpression(new String( StreamUtils.getBytes(  getClass().getResource( \"data.mvel\" ).openStream() ) ) ), vars);\n        \n        for ( Object o : map.get( \"rooms\" ).values() ) {\n            ksession.insert( o );\n        }\n        \n        for ( Object o : map.get( \"doors\" ).values() ) {\n            ksession.insert( o );\n        }         \n        \n        for ( Object o : map.get( \"characters\" ).values() ) {\n            ksession.insert( o );\n        }           \n        \n        for ( Object o : map.get( \"items\" ).values() ) {\n            ksession.insert( o );\n        } \n        \n        for ( Object o : map.get( \"locations\" ).values() ) {\n            ksession.insert( o );\n        }       \n        \n        Map<String, Integer> things = ( Map<String, Integer> ) map.get( \"vars\" );\n               \n        String baseStr = \"import  org.drools.adventures.*;  import org.drools.adventures.commands.*;\\n\";\n        \n        MapVariableResolverFactory f = new MapVariableResolverFactory( map.get( \"vars\") );       \n        \n        FactHandle fh = null;\n        \n        fh = ksession.insert(new Request(  MVEL.eval( baseStr + \"new LookCommand( characters['hero'] )\", f) ) );\n        ksession.fireAllRules();\n        \n        fh = ksession.insert(new Request(  MVEL.eval( baseStr + \"new MoveCommand( characters['hero'], rooms['basement'] )\", f) ) );\n        ksession.fireAllRules();\n        \n        fh = ksession.insert( new Request( MVEL.eval( baseStr + \"new MoveCommand( characters['hero'], rooms['kitchen'] )\", f) ) );        \n        ksession.fireAllRules();\n\n        fh = ksession.insert(new Request(  MVEL.eval( baseStr + \"new LookCommand( characters['hero'] )\", f) ) );\n        ksession.fireAllRules();                      \n        \n        fh = ksession.insert( new Request( MVEL.eval( baseStr + \"new MoveCommand( characters['hero'], rooms['basement'] )\", f ) ) );\n        ksession.fireAllRules( );     \n        \n        fh = ksession.insert(new Request(  MVEL.eval( baseStr + \"new LookCommand( characters['hero'] )\", f) ) );\n        ksession.fireAllRules();        \n        \n        \n        fh = ksession.insert(new Request(  MVEL.eval( baseStr + \"new PickupCommand( characters['hero'], items['torch'] )\", f) ) );\n        ksession.fireAllRules( );\n        \n        fh = ksession.insert( new Request( MVEL.eval( baseStr + \"new PickupCommand( characters['hero'], items['mace'] )\", f ) ) );        \n        ksession.fireAllRules();        \n\n        fh = ksession.insert(new Request(  MVEL.eval( baseStr + \"new LookCommand( characters['hero'] )\", f) ) );\n        ksession.fireAllRules();\n        \n        fh = ksession.insert(new Request(  MVEL.eval( baseStr + \"new MoveCommand( characters['hero'], rooms['kitchen'] )\", f ) ) );        \n        ksession.fireAllRules();\n               \n        fh = ksession.insert(new Request(  MVEL.eval( baseStr + \"new LookCommand( characters['hero'] )\", f) ) );\n        ksession.fireAllRules();\n        \n        fh = ksession.insert( new Request( MVEL.eval( baseStr + \"new DropCommand( characters['hero'], items['mace'] )\", f ) ) );        \n        ksession.fireAllRules();        \n\n        fh = ksession.insert(new Request(  MVEL.eval( baseStr + \"new LookCommand( characters['hero'] )\", f) ) );\n        ksession.fireAllRules();        \n    }","id":60413,"modified_method":"public void test1() throws Exception {\n        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\n        kbuilder.add( ResourceFactory.newClassPathResource( \"model.drl\", getClass() ),\n                      ResourceType.DRL );      \n        if ( kbuilder.hasErrors() ) {\n            System.out.println( kbuilder.getErrors().toString() );\n            System.exit(1);\n        }\n        \n        kbuilder.add( ResourceFactory.newClassPathResource( \"./commands/commands-model.drl\", getClass() ),\n                      ResourceType.DRL );        \n        if ( kbuilder.hasErrors() ) {\n            System.out.println( kbuilder.getErrors().toString() );\n            System.exit(1);\n        }\n        \n        kbuilder.add( ResourceFactory.newClassPathResource( \"queries.drl\", getClass() ),\n                      ResourceType.DRL );      \n        if ( kbuilder.hasErrors() ) {\n            System.out.println( kbuilder.getErrors().toString() );\n            System.exit(1);\n        }\n        \n        kbuilder.add( ResourceFactory.newClassPathResource( \"commands.drl\", getClass() ),\n                      ResourceType.DRL );          \n        if ( kbuilder.hasErrors() ) {\n            System.out.println( kbuilder.getErrors().toString() );\n            System.exit(1);\n        }\n\n\n        KnowledgeBaseConfiguration kbaseConf = KnowledgeBaseFactory.newKnowledgeBaseConfiguration();\n        kbaseConf.setOption( AssertBehaviorOption.EQUALITY );\n        \n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase( kbaseConf );\n        kbase.addKnowledgePackages( kbuilder.getKnowledgePackages() );\n\n        \n//        KnowledgeSessionConfiguration ksessionConf = KnowledgeBaseFactory.newKnowledgeSessionConfiguration();\n//        ksessionConf.setOption( AssertBehaviorOption.EQUALITY );\n        \n        Counter c = new Counter();\n        StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession();\n        ksession.setGlobal( \"counter\",c );\n        \n//        ksession.getChannels().put( \"io\", new Channel() {            \n//            public void send(Object arg) {\n//                System.out.println(arg);\n//            }\n//        } );\n        \n        \n        Thread.currentThread().setContextClassLoader( (((InternalRuleBase)((KnowledgeBaseImpl) kbase).ruleBase).getRootClassLoader() )  );        \n        Map vars = new HashMap();\n        vars.put(\"c\", c);\n        Map<String,Map> map = (Map<String,Map>) MVEL.executeExpression( MVEL.compileExpression(new String( StreamUtils.getBytes(  getClass().getResource( \"data.mvel\" ).openStream() ) ) ), vars);\n        \n        for ( Object o : map.get( \"rooms\" ).values() ) {\n            ksession.insert( o );\n        }\n        \n        for ( Object o : map.get( \"doors\" ).values() ) {\n            ksession.insert( o );\n        }         \n        \n        for ( Object o : map.get( \"characters\" ).values() ) {\n            ksession.insert( o );\n        }           \n        \n        for ( Object o : map.get( \"items\" ).values() ) {\n            ksession.insert( o );\n        } \n        \n        for ( Object o : map.get( \"locations\" ).values() ) {\n            ksession.insert( o );\n        }       \n        \n        Map<String, Integer> things = ( Map<String, Integer> ) map.get( \"vars\" );\n               \n        String baseStr = \"import  org.drools.adventures.*;  import org.drools.adventures.commands.*;\\n\";\n        \n        MapVariableResolverFactory f = new MapVariableResolverFactory( map.get( \"vars\") );       \n        \n        FactHandle fh = null;\n        \n        fh = ksession.insert(new Request(  MVEL.eval( baseStr + \"new LookCommand( characters['hero'] )\", f) ) );\n        ksession.fireAllRules();\n        \n        fh = ksession.insert(new Request(  MVEL.eval( baseStr + \"new MoveCommand( characters['hero'], rooms['basement'] )\", f) ) );\n        ksession.fireAllRules();\n        \n        fh = ksession.insert( new Request( MVEL.eval( baseStr + \"new MoveCommand( characters['hero'], rooms['kitchen'] )\", f) ) );        \n        ksession.fireAllRules();\n\n        fh = ksession.insert(new Request(  MVEL.eval( baseStr + \"new LookCommand( characters['hero'] )\", f) ) );\n        ksession.fireAllRules();                      \n        \n        fh = ksession.insert( new Request( MVEL.eval( baseStr + \"new MoveCommand( characters['hero'], rooms['basement'] )\", f ) ) );\n        ksession.fireAllRules( );     \n        \n        fh = ksession.insert(new Request(  MVEL.eval( baseStr + \"new LookCommand( characters['hero'] )\", f) ) );\n        ksession.fireAllRules();        \n        \n        \n        fh = ksession.insert(new Request(  MVEL.eval( baseStr + \"new PickupCommand( characters['hero'], items['torch'] )\", f) ) );\n        ksession.fireAllRules( );\n        \n        fh = ksession.insert( new Request( MVEL.eval( baseStr + \"new PickupCommand( characters['hero'], items['mace'] )\", f ) ) );        \n        ksession.fireAllRules();        \n\n        fh = ksession.insert(new Request(  MVEL.eval( baseStr + \"new LookCommand( characters['hero'] )\", f) ) );\n        ksession.fireAllRules();\n        \n        fh = ksession.insert(new Request(  MVEL.eval( baseStr + \"new MoveCommand( characters['hero'], rooms['kitchen'] )\", f ) ) );        \n        ksession.fireAllRules();\n               \n        fh = ksession.insert(new Request(  MVEL.eval( baseStr + \"new LookCommand( characters['hero'] )\", f) ) );\n        ksession.fireAllRules();\n        \n        fh = ksession.insert( new Request( MVEL.eval( baseStr + \"new DropCommand( characters['hero'], items['mace'] )\", f ) ) );        \n        ksession.fireAllRules();        \n\n        fh = ksession.insert(new Request(  MVEL.eval( baseStr + \"new LookCommand( characters['hero'] )\", f) ) );\n        ksession.fireAllRules();        \n    }","commit_id":"99530769704a4f841535649b5c70affd79e2d069","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Override\n\tpublic int putResource(WebDAVRequest webDavRequest) throws WebDAVException {\n\t\tFile file = null;\n\n\t\ttry {\n\t\t\tHttpServletRequest request = webDavRequest.getHttpServletRequest();\n\n\t\t\tString[] pathArray = webDavRequest.getPathArray();\n\n\t\t\tlong companyId = webDavRequest.getCompanyId();\n\t\t\tlong groupId = webDavRequest.getGroupId();\n\t\t\tlong parentFolderId = getParentFolderId(companyId, pathArray);\n\t\t\tString title = WebDAVUtil.getResourceName(pathArray);\n\t\t\tString description = StringPool.BLANK;\n\t\t\tString changeLog = StringPool.BLANK;\n\n\t\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\t\trequest);\n\n\t\t\tserviceContext.setAddGroupPermissions(\n\t\t\t\tisAddGroupPermissions(groupId));\n\t\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\t\tString contentType = GetterUtil.get(\n\t\t\t\trequest.getHeader(HttpHeaders.CONTENT_TYPE),\n\t\t\t\tContentTypes.APPLICATION_OCTET_STREAM);\n\n\t\t\tString extension = FileUtil.getExtension(title);\n\n\t\t\tfile = FileUtil.createTempFile(extension);\n\n\t\t\tFileUtil.write(file, request.getInputStream());\n\n\t\t\tif (contentType.equals(ContentTypes.APPLICATION_OCTET_STREAM)) {\n\t\t\t\tcontentType = MimeTypesUtil.getContentType(file, title);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tFileEntry fileEntry = DLAppServiceUtil.getFileEntry(\n\t\t\t\t\tgroupId, parentFolderId, title);\n\n\t\t\t\tif (isLocked(fileEntry, webDavRequest.getLockUuid())) {\n\t\t\t\t\treturn WebDAVUtil.SC_LOCKED;\n\t\t\t\t}\n\n\t\t\t\tlong fileEntryId = fileEntry.getFileEntryId();\n\n\t\t\t\tdescription = fileEntry.getDescription();\n\n\t\t\t\tString[] assetTagNames = AssetTagLocalServiceUtil.getTagNames(\n\t\t\t\t\tFileEntry.class.getName(), fileEntry.getFileEntryId());\n\n\t\t\t\tserviceContext.setAssetTagNames(assetTagNames);\n\n\t\t\t\tDLAppServiceUtil.updateFileEntry(\n\t\t\t\t\tfileEntryId, title, contentType, title, description,\n\t\t\t\t\tchangeLog, false, file, serviceContext);\n\t\t\t}\n\t\t\tcatch (NoSuchFileEntryException nsfee) {\n\t\t\t\tDLAppServiceUtil.addFileEntry(\n\t\t\t\t\tgroupId, parentFolderId, title, contentType, title,\n\t\t\t\t\tdescription, changeLog, file, serviceContext);\n\t\t\t}\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\n\t\t\t\t\t\"Added \" + StringUtil.merge(pathArray, StringPool.SLASH));\n\t\t\t}\n\n\t\t\treturn HttpServletResponse.SC_CREATED;\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\treturn HttpServletResponse.SC_FORBIDDEN;\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\treturn HttpServletResponse.SC_CONFLICT;\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(pe, pe);\n\t\t\t}\n\n\t\t\treturn HttpServletResponse.SC_CONFLICT;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WebDAVException(e);\n\t\t}\n\t\tfinally {\n\t\t\tFileUtil.delete(file);\n\t\t}\n\t}","id":60414,"modified_method":"@Override\n\tpublic int putResource(WebDAVRequest webDavRequest) throws WebDAVException {\n\t\tFile file = null;\n\n\t\ttry {\n\t\t\tHttpServletRequest request = webDavRequest.getHttpServletRequest();\n\n\t\t\tString[] pathArray = webDavRequest.getPathArray();\n\n\t\t\tlong companyId = webDavRequest.getCompanyId();\n\t\t\tlong groupId = webDavRequest.getGroupId();\n\t\t\tlong parentFolderId = getParentFolderId(companyId, pathArray);\n\t\t\tString title = WebDAVUtil.getResourceName(pathArray);\n\t\t\tString description = StringPool.BLANK;\n\t\t\tString changeLog = StringPool.BLANK;\n\n\t\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\t\trequest);\n\n\t\t\tserviceContext.setAddGroupPermissions(\n\t\t\t\tisAddGroupPermissions(groupId));\n\t\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\t\tString contentType = GetterUtil.get(\n\t\t\t\trequest.getHeader(HttpHeaders.CONTENT_TYPE),\n\t\t\t\tContentTypes.APPLICATION_OCTET_STREAM);\n\n\t\t\tString extension = FileUtil.getExtension(title);\n\n\t\t\tfile = FileUtil.createTempFile(extension);\n\n\t\t\tFileUtil.write(file, request.getInputStream());\n\n\t\t\tif (contentType.equals(ContentTypes.APPLICATION_OCTET_STREAM)) {\n\t\t\t\tcontentType = MimeTypesUtil.getContentType(file, title);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tFileEntry fileEntry = DLAppServiceUtil.getFileEntry(\n\t\t\t\t\tgroupId, parentFolderId, title);\n\n\t\t\t\tif (!hasLock(fileEntry, webDavRequest.getLockUuid()) &&\n\t\t\t\t\t(fileEntry.getLock() != null)) {\n\n\t\t\t\t\treturn WebDAVUtil.SC_LOCKED;\n\t\t\t\t}\n\n\t\t\t\tlong fileEntryId = fileEntry.getFileEntryId();\n\n\t\t\t\tdescription = fileEntry.getDescription();\n\n\t\t\t\tString[] assetTagNames = AssetTagLocalServiceUtil.getTagNames(\n\t\t\t\t\tFileEntry.class.getName(), fileEntry.getFileEntryId());\n\n\t\t\t\tserviceContext.setAssetTagNames(assetTagNames);\n\n\t\t\t\tDLAppServiceUtil.updateFileEntry(\n\t\t\t\t\tfileEntryId, title, contentType, title, description,\n\t\t\t\t\tchangeLog, false, file, serviceContext);\n\t\t\t}\n\t\t\tcatch (NoSuchFileEntryException nsfee) {\n\t\t\t\tif (file.length() == 0) {\n\t\t\t\t\tserviceContext.setWorkflowAction(\n\t\t\t\t\t\tWorkflowConstants.ACTION_SAVE_DRAFT);\n\t\t\t\t}\n\n\t\t\t\tDLAppServiceUtil.addFileEntry(\n\t\t\t\t\tgroupId, parentFolderId, title, contentType, title,\n\t\t\t\t\tdescription, changeLog, file, serviceContext);\n\t\t\t}\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\n\t\t\t\t\t\"Added \" + StringUtil.merge(pathArray, StringPool.SLASH));\n\t\t\t}\n\n\t\t\treturn HttpServletResponse.SC_CREATED;\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\treturn HttpServletResponse.SC_FORBIDDEN;\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\treturn HttpServletResponse.SC_CONFLICT;\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(pe, pe);\n\t\t\t}\n\n\t\t\treturn HttpServletResponse.SC_CONFLICT;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WebDAVException(e);\n\t\t}\n\t\tfinally {\n\t\t\tFileUtil.delete(file);\n\t\t}\n\t}","commit_id":"c66bf37be1af042b8ac145a00571e25fee0c825d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic int moveSimpleResource(\n\t\t\tWebDAVRequest webDavRequest, Resource resource, String destination,\n\t\t\tboolean overwrite)\n\t\tthrows WebDAVException {\n\n\t\tFile file = null;\n\n\t\ttry {\n\t\t\tString[] destinationArray = WebDAVUtil.getPathArray(\n\t\t\t\tdestination, true);\n\n\t\t\tFileEntry fileEntry = (FileEntry)resource.getModel();\n\n\t\t\tif (isLocked(fileEntry, webDavRequest.getLockUuid())) {\n\t\t\t\treturn WebDAVUtil.SC_LOCKED;\n\t\t\t}\n\n\t\t\tlong companyId = webDavRequest.getCompanyId();\n\t\t\tlong groupId = WebDAVUtil.getGroupId(companyId, destinationArray);\n\t\t\tlong newParentFolderId = getParentFolderId(\n\t\t\t\tcompanyId, destinationArray);\n\t\t\tString sourceFileName = WebDAVUtil.getResourceName(\n\t\t\t\tdestinationArray);\n\t\t\tString title = WebDAVUtil.getResourceName(destinationArray);\n\t\t\tString description = fileEntry.getDescription();\n\t\t\tString changeLog = StringPool.BLANK;\n\n\t\t\tString[] assetTagNames = AssetTagLocalServiceUtil.getTagNames(\n\t\t\t\tFileEntry.class.getName(), fileEntry.getFileEntryId());\n\n\t\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\t\tserviceContext.setAssetTagNames(assetTagNames);\n\n\t\t\tint status = HttpServletResponse.SC_CREATED;\n\n\t\t\tif (overwrite) {\n\t\t\t\tif (deleteResource(\n\t\t\t\t\t\tgroupId, newParentFolderId, title,\n\t\t\t\t\t\twebDavRequest.getLockUuid())) {\n\n\t\t\t\t\tstatus = HttpServletResponse.SC_NO_CONTENT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// LPS-5415\n\n\t\t\tif (webDavRequest.isMac()) {\n\t\t\t\ttry {\n\t\t\t\t\tFileEntry destFileEntry =\n\t\t\t\t\t\tDLAppServiceUtil.getFileEntry(\n\t\t\t\t\t\t\tgroupId, newParentFolderId, title);\n\n\t\t\t\t\tInputStream is = fileEntry.getContentStream();\n\n\t\t\t\t\tfile = FileUtil.createTempFile(is);\n\n\t\t\t\t\tDLAppServiceUtil.updateFileEntry(\n\t\t\t\t\t\tdestFileEntry.getFileEntryId(),\n\t\t\t\t\t\tdestFileEntry.getTitle(), destFileEntry.getMimeType(),\n\t\t\t\t\t\tdestFileEntry.getTitle(),\n\t\t\t\t\t\tdestFileEntry.getDescription(), changeLog, false, file,\n\t\t\t\t\t\tserviceContext);\n\n\t\t\t\t\tDLAppServiceUtil.deleteFileEntry(\n\t\t\t\t\t\tfileEntry.getFileEntryId());\n\n\t\t\t\t\treturn status;\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchFileEntryException nsfee) {\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tDLAppServiceUtil.updateFileEntry(\n\t\t\t\tfileEntry.getFileEntryId(), sourceFileName,\n\t\t\t\tfileEntry.getMimeType(), title, description, changeLog, false,\n\t\t\t\tfile, serviceContext);\n\n\t\t\tif (fileEntry.getFolderId() != newParentFolderId) {\n\t\t\t\tfileEntry = DLAppServiceUtil.moveFileEntry(\n\t\t\t\t\tfileEntry.getFileEntryId(), newParentFolderId,\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\n\t\t\treturn status;\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\treturn HttpServletResponse.SC_FORBIDDEN;\n\t\t}\n\t\tcatch (DuplicateFileException dfe) {\n\t\t\treturn HttpServletResponse.SC_PRECONDITION_FAILED;\n\t\t}\n\t\tcatch (DuplicateFolderNameException dfne) {\n\t\t\treturn HttpServletResponse.SC_PRECONDITION_FAILED;\n\t\t}\n\t\tcatch (LockException le) {\n\t\t\treturn WebDAVUtil.SC_LOCKED;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WebDAVException(e);\n\t\t}\n\t\tfinally {\n\t\t\tFileUtil.delete(file);\n\t\t}\n\t}","id":60415,"modified_method":"@Override\n\tpublic int moveSimpleResource(\n\t\t\tWebDAVRequest webDavRequest, Resource resource, String destination,\n\t\t\tboolean overwrite)\n\t\tthrows WebDAVException {\n\n\t\tFile file = null;\n\n\t\ttry {\n\t\t\tString[] destinationArray = WebDAVUtil.getPathArray(\n\t\t\t\tdestination, true);\n\n\t\t\tFileEntry fileEntry = (FileEntry)resource.getModel();\n\n\t\t\tif (!hasLock(fileEntry, webDavRequest.getLockUuid()) &&\n\t\t\t\t(fileEntry.getLock() != null)) {\n\n\t\t\t\treturn WebDAVUtil.SC_LOCKED;\n\t\t\t}\n\n\t\t\tlong companyId = webDavRequest.getCompanyId();\n\t\t\tlong groupId = WebDAVUtil.getGroupId(companyId, destinationArray);\n\t\t\tlong newParentFolderId = getParentFolderId(\n\t\t\t\tcompanyId, destinationArray);\n\t\t\tString sourceFileName = WebDAVUtil.getResourceName(\n\t\t\t\tdestinationArray);\n\t\t\tString title = WebDAVUtil.getResourceName(destinationArray);\n\t\t\tString description = fileEntry.getDescription();\n\t\t\tString changeLog = StringPool.BLANK;\n\n\t\t\tString[] assetTagNames = AssetTagLocalServiceUtil.getTagNames(\n\t\t\t\tFileEntry.class.getName(), fileEntry.getFileEntryId());\n\n\t\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\t\tserviceContext.setAssetTagNames(assetTagNames);\n\n\t\t\tint status = HttpServletResponse.SC_CREATED;\n\n\t\t\tif (overwrite) {\n\t\t\t\tif (deleteResource(\n\t\t\t\t\t\tgroupId, newParentFolderId, title,\n\t\t\t\t\t\twebDavRequest.getLockUuid())) {\n\n\t\t\t\t\tstatus = HttpServletResponse.SC_NO_CONTENT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// LPS-5415\n\n\t\t\tif (webDavRequest.isMac()) {\n\t\t\t\ttry {\n\t\t\t\t\tFileEntry destFileEntry =\n\t\t\t\t\t\tDLAppServiceUtil.getFileEntry(\n\t\t\t\t\t\t\tgroupId, newParentFolderId, title);\n\n\t\t\t\t\tInputStream is = fileEntry.getContentStream();\n\n\t\t\t\t\tfile = FileUtil.createTempFile(is);\n\n\t\t\t\t\tDLAppServiceUtil.updateFileEntry(\n\t\t\t\t\t\tdestFileEntry.getFileEntryId(),\n\t\t\t\t\t\tdestFileEntry.getTitle(), destFileEntry.getMimeType(),\n\t\t\t\t\t\tdestFileEntry.getTitle(),\n\t\t\t\t\t\tdestFileEntry.getDescription(), changeLog, false, file,\n\t\t\t\t\t\tserviceContext);\n\n\t\t\t\t\tDLAppServiceUtil.deleteFileEntry(\n\t\t\t\t\t\tfileEntry.getFileEntryId());\n\n\t\t\t\t\treturn status;\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchFileEntryException nsfee) {\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tDLAppServiceUtil.updateFileEntry(\n\t\t\t\tfileEntry.getFileEntryId(), sourceFileName,\n\t\t\t\tfileEntry.getMimeType(), title, description, changeLog, false,\n\t\t\t\tfile, serviceContext);\n\n\t\t\tif (fileEntry.getFolderId() != newParentFolderId) {\n\t\t\t\tfileEntry = DLAppServiceUtil.moveFileEntry(\n\t\t\t\t\tfileEntry.getFileEntryId(), newParentFolderId,\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\n\t\t\treturn status;\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\treturn HttpServletResponse.SC_FORBIDDEN;\n\t\t}\n\t\tcatch (DuplicateFileException dfe) {\n\t\t\treturn HttpServletResponse.SC_PRECONDITION_FAILED;\n\t\t}\n\t\tcatch (DuplicateFolderNameException dfne) {\n\t\t\treturn HttpServletResponse.SC_PRECONDITION_FAILED;\n\t\t}\n\t\tcatch (LockException le) {\n\t\t\treturn WebDAVUtil.SC_LOCKED;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WebDAVException(e);\n\t\t}\n\t\tfinally {\n\t\t\tFileUtil.delete(file);\n\t\t}\n\t}","commit_id":"c66bf37be1af042b8ac145a00571e25fee0c825d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean deleteResource(\n\t\t\tlong groupId, long parentFolderId, String name, String lockUuid)\n\t\tthrows Exception {\n\n\t\ttry {\n\t\t\tFolder folder = DLAppServiceUtil.getFolder(\n\t\t\t\tgroupId, parentFolderId, name);\n\n\t\t\tDLAppServiceUtil.deleteFolder(folder.getFolderId());\n\n\t\t\treturn true;\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\ttry {\n\t\t\t\tFileEntry fileEntry = DLAppServiceUtil.getFileEntry(\n\t\t\t\t\tgroupId, parentFolderId, name);\n\n\t\t\t\tif (isLocked(fileEntry, lockUuid)) {\n\t\t\t\t\tthrow new LockException();\n\t\t\t\t}\n\n\t\t\t\tDLAppServiceUtil.deleteFileEntryByTitle(\n\t\t\t\t\tgroupId, parentFolderId, name);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch (NoSuchFileEntryException nsfee) {\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","id":60416,"modified_method":"protected boolean deleteResource(\n\t\t\tlong groupId, long parentFolderId, String name, String lockUuid)\n\t\tthrows Exception {\n\n\t\ttry {\n\t\t\tFolder folder = DLAppServiceUtil.getFolder(\n\t\t\t\tgroupId, parentFolderId, name);\n\n\t\t\tDLAppServiceUtil.deleteFolder(folder.getFolderId());\n\n\t\t\treturn true;\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\ttry {\n\t\t\t\tFileEntry fileEntry = DLAppServiceUtil.getFileEntry(\n\t\t\t\t\tgroupId, parentFolderId, name);\n\n\t\t\t\tif (!hasLock(fileEntry, lockUuid) &&\n\t\t\t\t\t(fileEntry.getLock() != null)) {\n\n\t\t\t\t\tthrow new LockException();\n\t\t\t\t}\n\n\t\t\t\tDLAppServiceUtil.deleteFileEntryByTitle(\n\t\t\t\t\tgroupId, parentFolderId, name);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch (NoSuchFileEntryException nsfee) {\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"c66bf37be1af042b8ac145a00571e25fee0c825d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean isLocked(FileEntry fileEntry, String lockUuid)\n\t\tthrows Exception {\n\n\t\tif (Validator.isNull(lockUuid)) {\n\n\t\t\t// Client does not claim to know of a lock\n\n\t\t\treturn fileEntry.hasLock();\n\t\t}\n\t\telse {\n\n\t\t\t// Client claims to know of a lock. Verify the lock UUID.\n\n\t\t\ttry {\n\t\t\t\tboolean verified = DLAppServiceUtil.verifyFileEntryCheckOut(\n\t\t\t\t\tfileEntry.getRepositoryId(), fileEntry.getFileEntryId(),\n\t\t\t\t\tlockUuid);\n\n\t\t\t\treturn !verified;\n\t\t\t}\n\t\t\tcatch (NoSuchLockException nsle) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}","id":60417,"modified_method":"protected boolean hasLock(FileEntry fileEntry, String lockUuid)\n\t\tthrows Exception {\n\n\t\tif (Validator.isNull(lockUuid)) {\n\n\t\t\t// Client does not claim to know of a lock\n\n\t\t\treturn fileEntry.hasLock();\n\t\t}\n\t\telse {\n\n\t\t\t// Client claims to know of a lock. Verify the lock UUID.\n\n\t\t\ttry {\n\t\t\t\treturn DLAppServiceUtil.verifyFileEntryLock(\n\t\t\t\t\tfileEntry.getRepositoryId(), fileEntry.getFileEntryId(),\n\t\t\t\t\tlockUuid);\n\t\t\t}\n\t\t\tcatch (NoSuchLockException nsle) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}","commit_id":"c66bf37be1af042b8ac145a00571e25fee0c825d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic int deleteResource(WebDAVRequest webDavRequest)\n\t\tthrows WebDAVException {\n\n\t\ttry {\n\t\t\tResource resource = getResource(webDavRequest);\n\n\t\t\tif (resource == null) {\n\t\t\t\tif (webDavRequest.isAppleDoubleRequest()) {\n\t\t\t\t\treturn HttpServletResponse.SC_NO_CONTENT;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn HttpServletResponse.SC_NOT_FOUND;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tObject model = resource.getModel();\n\n\t\t\tif (model instanceof Folder) {\n\t\t\t\tFolder folder = (Folder)model;\n\n\t\t\t\tDLAppServiceUtil.deleteFolder(folder.getFolderId());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tFileEntry fileEntry = (FileEntry)model;\n\n\t\t\t\tif (isLocked(fileEntry, webDavRequest.getLockUuid())) {\n\t\t\t\t\treturn WebDAVUtil.SC_LOCKED;\n\t\t\t\t}\n\n\t\t\t\tDLAppServiceUtil.deleteFileEntry(fileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\treturn HttpServletResponse.SC_NO_CONTENT;\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\treturn HttpServletResponse.SC_FORBIDDEN;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WebDAVException(e);\n\t\t}\n\t}","id":60418,"modified_method":"@Override\n\tpublic int deleteResource(WebDAVRequest webDavRequest)\n\t\tthrows WebDAVException {\n\n\t\ttry {\n\t\t\tResource resource = getResource(webDavRequest);\n\n\t\t\tif (resource == null) {\n\t\t\t\tif (webDavRequest.isAppleDoubleRequest()) {\n\t\t\t\t\treturn HttpServletResponse.SC_NO_CONTENT;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn HttpServletResponse.SC_NOT_FOUND;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tObject model = resource.getModel();\n\n\t\t\tif (model instanceof Folder) {\n\t\t\t\tFolder folder = (Folder)model;\n\n\t\t\t\tDLAppServiceUtil.deleteFolder(folder.getFolderId());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tFileEntry fileEntry = (FileEntry)model;\n\n\t\t\t\tif (!hasLock(fileEntry, webDavRequest.getLockUuid()) &&\n\t\t\t\t\t(fileEntry.getLock() != null)) {\n\n\t\t\t\t\treturn WebDAVUtil.SC_LOCKED;\n\t\t\t\t}\n\n\t\t\t\tDLAppServiceUtil.deleteFileEntry(fileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\treturn HttpServletResponse.SC_NO_CONTENT;\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\treturn HttpServletResponse.SC_FORBIDDEN;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WebDAVException(e);\n\t\t}\n\t}","commit_id":"c66bf37be1af042b8ac145a00571e25fee0c825d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic boolean unlockResource(WebDAVRequest webDavRequest, String token)\n\t\tthrows WebDAVException {\n\n\t\tResource resource = getResource(webDavRequest);\n\n\t\ttry {\n\t\t\tif (resource instanceof DLFileEntryResourceImpl) {\n\t\t\t\tFileEntry fileEntry = (FileEntry)resource.getModel();\n\n\t\t\t\tDLAppServiceUtil.checkInFileEntry(\n\t\t\t\t\tfileEntry.getFileEntryId(), token);\n\n\t\t\t\tif (webDavRequest.isAppleDoubleRequest()) {\n\t\t\t\t\tDLAppServiceUtil.deleteFileEntry(\n\t\t\t\t\t\tfileEntry.getFileEntryId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tFolder folder = (Folder)resource.getModel();\n\n\t\t\t\tDLAppServiceUtil.unlockFolder(\n\t\t\t\t\tfolder.getRepositoryId(), folder.getParentFolderId(),\n\t\t\t\t\tfolder.getName(), token);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof InvalidLockException) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\"Unable to unlock file entry\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","id":60419,"modified_method":"@Override\n\tpublic boolean unlockResource(WebDAVRequest webDavRequest, String token)\n\t\tthrows WebDAVException {\n\n\t\tResource resource = getResource(webDavRequest);\n\n\t\ttry {\n\t\t\tif (resource instanceof DLFileEntryResourceImpl) {\n\t\t\t\tFileEntry fileEntry = (FileEntry)resource.getModel();\n\n\t\t\t\tDLAppServiceUtil.unlockFileEntry(\n\t\t\t\t\tfileEntry.getFileEntryId(), token);\n\n\t\t\t\tif (webDavRequest.isAppleDoubleRequest()) {\n\t\t\t\t\tDLAppServiceUtil.deleteFileEntry(\n\t\t\t\t\t\tfileEntry.getFileEntryId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tFolder folder = (Folder)resource.getModel();\n\n\t\t\t\tDLAppServiceUtil.unlockFolder(\n\t\t\t\t\tfolder.getRepositoryId(), folder.getParentFolderId(),\n\t\t\t\t\tfolder.getName(), token);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof InvalidLockException) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\"Unable to unlock file entry\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"c66bf37be1af042b8ac145a00571e25fee0c825d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic Status lockResource(\n\t\t\tWebDAVRequest webDavRequest, String owner, long timeout)\n\t\tthrows WebDAVException {\n\n\t\tResource resource = getResource(webDavRequest);\n\n\t\tLock lock = null;\n\t\tint status = HttpServletResponse.SC_OK;\n\n\t\ttry {\n\t\t\tif (resource == null) {\n\t\t\t\tstatus = HttpServletResponse.SC_CREATED;\n\n\t\t\t\tHttpServletRequest request =\n\t\t\t\t\twebDavRequest.getHttpServletRequest();\n\n\t\t\t\tString[] pathArray = webDavRequest.getPathArray();\n\n\t\t\t\tlong companyId = webDavRequest.getCompanyId();\n\t\t\t\tlong groupId = webDavRequest.getGroupId();\n\t\t\t\tlong parentFolderId = getParentFolderId(companyId, pathArray);\n\t\t\t\tString title = WebDAVUtil.getResourceName(pathArray);\n\n\t\t\t\tString contentType = GetterUtil.get(\n\t\t\t\t\trequest.getHeader(HttpHeaders.CONTENT_TYPE),\n\t\t\t\t\tContentTypes.APPLICATION_OCTET_STREAM);\n\n\t\t\t\tif (contentType.equals(ContentTypes.APPLICATION_OCTET_STREAM)) {\n\t\t\t\t\tcontentType = MimeTypesUtil.getContentType(\n\t\t\t\t\t\trequest.getInputStream(), title);\n\t\t\t\t}\n\n\t\t\t\tString description = StringPool.BLANK;\n\t\t\t\tString changeLog = StringPool.BLANK;\n\n\t\t\t\tFile file = FileUtil.createTempFile(\n\t\t\t\t\tFileUtil.getExtension(title));\n\n\t\t\t\tfile.createNewFile();\n\n\t\t\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\t\t\tserviceContext.setAddGroupPermissions(\n\t\t\t\t\tisAddGroupPermissions(groupId));\n\t\t\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\t\t\tFileEntry fileEntry = DLAppServiceUtil.addFileEntry(\n\t\t\t\t\tgroupId, parentFolderId, title, contentType, title,\n\t\t\t\t\tdescription, changeLog, file, serviceContext);\n\n\t\t\t\tresource = toResource(webDavRequest, fileEntry, false);\n\t\t\t}\n\n\t\t\tif (resource instanceof DLFileEntryResourceImpl) {\n\t\t\t\tFileEntry fileEntry = (FileEntry)resource.getModel();\n\n\t\t\t\tfileEntry = DLAppServiceUtil.checkOutFileEntry(\n\t\t\t\t\tfileEntry.getFileEntryId(), owner, timeout);\n\n\t\t\t\tlock = fileEntry.getLock();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tboolean inheritable = false;\n\n\t\t\t\tlong depth = WebDAVUtil.getDepth(\n\t\t\t\t\twebDavRequest.getHttpServletRequest());\n\n\t\t\t\tif (depth != 0) {\n\t\t\t\t\tinheritable = true;\n\t\t\t\t}\n\n\t\t\t\tFolder folder = (Folder)resource.getModel();\n\n\t\t\t\tlock = DLAppServiceUtil.lockFolder(\n\t\t\t\t\tfolder.getRepositoryId(), folder.getFolderId(), owner,\n\t\t\t\t\tinheritable, timeout);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\n\t\t\t// DuplicateLock is 423 not 501\n\n\t\t\tif (!(e instanceof DuplicateLockException)) {\n\t\t\t\tthrow new WebDAVException(e);\n\t\t\t}\n\n\t\t\tstatus = WebDAVUtil.SC_LOCKED;\n\t\t}\n\n\t\treturn new Status(lock, status);\n\t}","id":60420,"modified_method":"@Override\n\tpublic Status lockResource(\n\t\t\tWebDAVRequest webDavRequest, String owner, long timeout)\n\t\tthrows WebDAVException {\n\n\t\tResource resource = getResource(webDavRequest);\n\n\t\tLock lock = null;\n\t\tint status = HttpServletResponse.SC_OK;\n\n\t\ttry {\n\t\t\tif (resource == null) {\n\t\t\t\tstatus = HttpServletResponse.SC_CREATED;\n\n\t\t\t\tHttpServletRequest request =\n\t\t\t\t\twebDavRequest.getHttpServletRequest();\n\n\t\t\t\tString[] pathArray = webDavRequest.getPathArray();\n\n\t\t\t\tlong companyId = webDavRequest.getCompanyId();\n\t\t\t\tlong groupId = webDavRequest.getGroupId();\n\t\t\t\tlong parentFolderId = getParentFolderId(companyId, pathArray);\n\t\t\t\tString title = WebDAVUtil.getResourceName(pathArray);\n\n\t\t\t\tString contentType = GetterUtil.get(\n\t\t\t\t\trequest.getHeader(HttpHeaders.CONTENT_TYPE),\n\t\t\t\t\tContentTypes.APPLICATION_OCTET_STREAM);\n\n\t\t\t\tif (contentType.equals(ContentTypes.APPLICATION_OCTET_STREAM)) {\n\t\t\t\t\tcontentType = MimeTypesUtil.getContentType(\n\t\t\t\t\t\trequest.getInputStream(), title);\n\t\t\t\t}\n\n\t\t\t\tString description = StringPool.BLANK;\n\t\t\t\tString changeLog = StringPool.BLANK;\n\n\t\t\t\tFile file = FileUtil.createTempFile(\n\t\t\t\t\tFileUtil.getExtension(title));\n\n\t\t\t\tfile.createNewFile();\n\n\t\t\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\t\t\tserviceContext.setAddGroupPermissions(\n\t\t\t\t\tisAddGroupPermissions(groupId));\n\t\t\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\t\t\tFileEntry fileEntry = DLAppServiceUtil.addFileEntry(\n\t\t\t\t\tgroupId, parentFolderId, title, contentType, title,\n\t\t\t\t\tdescription, changeLog, file, serviceContext);\n\n\t\t\t\tresource = toResource(webDavRequest, fileEntry, false);\n\t\t\t}\n\n\t\t\tif (resource instanceof DLFileEntryResourceImpl) {\n\t\t\t\tFileEntry fileEntry = (FileEntry)resource.getModel();\n\n\t\t\t\tlock = DLAppServiceUtil.lockFileEntry(\n\t\t\t\t\tfileEntry.getFileEntryId(), owner, timeout);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tboolean inheritable = false;\n\n\t\t\t\tlong depth = WebDAVUtil.getDepth(\n\t\t\t\t\twebDavRequest.getHttpServletRequest());\n\n\t\t\t\tif (depth != 0) {\n\t\t\t\t\tinheritable = true;\n\t\t\t\t}\n\n\t\t\t\tFolder folder = (Folder)resource.getModel();\n\n\t\t\t\tlock = DLAppServiceUtil.lockFolder(\n\t\t\t\t\tfolder.getRepositoryId(), folder.getFolderId(), owner,\n\t\t\t\t\tinheritable, timeout);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\n\t\t\t// DuplicateLock is 423 not 501\n\n\t\t\tif (!(e instanceof DuplicateLockException)) {\n\t\t\t\tthrow new WebDAVException(e);\n\t\t\t}\n\n\t\t\tstatus = WebDAVUtil.SC_LOCKED;\n\t\t}\n\n\t\treturn new Status(lock, status);\n\t}","commit_id":"c66bf37be1af042b8ac145a00571e25fee0c825d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addInequation(IWrapper subType, IWrapper supertype, EquationInfo equationInfo, boolean isWeak, boolean solveOnlyConcrete, boolean checkOnly) {\n    IWrapper subtypeRepresentator = getRepresentatorWrapper(subType);\n    IWrapper supertypeRepresentator = getRepresentatorWrapper(supertype);\n\n    // no equation needed\n    if (NodeWrapper.fromWrapper(subtypeRepresentator) == NodeWrapper.fromWrapper(supertypeRepresentator)) return;\n\n    // RuntimeTypeVariable varSubtype = subtypeRepresentator == null ? null : subtypeRepresentator.getVariable();\n    RuntimeTypeVariable varSupertype = supertypeRepresentator == null ? null : supertypeRepresentator.getVariable();\n    isConcrete(subtypeRepresentator);\n    boolean subtypeHasNonConcreteVars = !isConcrete(subtypeRepresentator);\n    boolean supertypeHasNonConcreteVars = !isConcrete(supertypeRepresentator);\n\n    //if check only\n    if (checkOnly) {\n      if (subtypeHasNonConcreteVars || supertypeHasNonConcreteVars) {\n        if (isWeak) {\n          addSubtyping(subtypeRepresentator, supertypeRepresentator, equationInfo, true);\n        } else {\n          addStrongSubtyping(subtypeRepresentator, supertypeRepresentator, equationInfo, true);\n        }\n        return;\n      }\n    }\n\n    //elimination rules:\n    if (subtypeRepresentator instanceof NodeWrapper && supertypeRepresentator instanceof NodeWrapper) {\n      SNode node1 = subtypeRepresentator.getNode();\n      SNode node2 = supertypeRepresentator.getNode();\n      Set<InequationReplacementRule_Runtime> inequationReplacementRules = myTypeChecker.getRulesManager().getReplacementRules(node1, node2);\n      for (InequationReplacementRule_Runtime inequationReplacementRule : inequationReplacementRules) {\n        inequationReplacementRule.processInequation(node1, node2, equationInfo);\n        return;\n      }\n    }\n\n    // if one of them is a var\n    if (subtypeHasNonConcreteVars && solveOnlyConcrete || varSupertype != null) {\n      if (isWeak) {\n        addSubtyping(subtypeRepresentator, supertypeRepresentator, equationInfo, false);\n      } else {\n        addStrongSubtyping(subtypeRepresentator, supertypeRepresentator, equationInfo, false);\n      }\n      return;\n    }\n\n    //expand, if contains some vars.\n    if (subtypeRepresentator instanceof NodeWrapper) {\n      NodeWrapper subtypeNodeWrapper = (NodeWrapper) subtypeRepresentator;\n      SModel typesModel = myTypeChecker.getRuntimeTypesModel();\n      NodeWrapper representatorCopy = NodeWrapper.fromNode(CopyUtil.copy(subtypeNodeWrapper.getNode()), this);\n      subtypeRepresentator = expandWrapper(null, representatorCopy, typesModel);\n    }\n    if (supertypeRepresentator instanceof NodeWrapper) {\n      NodeWrapper supertypeNodeWrapper = (NodeWrapper) supertypeRepresentator;\n      SModel typesModel = myTypeChecker.getRuntimeTypesModel();\n      NodeWrapper representatorCopy = NodeWrapper.fromNode(CopyUtil.copy(supertypeNodeWrapper.getNode()), this);\n      supertypeRepresentator = expandWrapper(null, representatorCopy, typesModel);\n    }\n\n    // if subtyping\n    if (myTypeChecker.getSubtypingManager().isSubtype(subtypeRepresentator, supertypeRepresentator, this, equationInfo, isWeak)) {\n      return;\n    }\n\n    if (equationInfo.getErrorString() != null) {\n      myTypeChecker.reportTypeError(equationInfo.getNodeWithError(), equationInfo.getErrorString());\n      return;\n    }\n    String strongString = isWeak ? \"\" : \" strong\";\n    IErrorReporter errorReporter =\n      new EquationErrorReporter(this, \"type \", subtypeRepresentator,\n        \" is not a\" + strongString + \" subtype of \", supertypeRepresentator, \"\", equationInfo.getRuleModel(), equationInfo.getRuleId());\n    myTypeChecker.getSubtypingManager().isSubtype(subtypeRepresentator, supertypeRepresentator, this, equationInfo, isWeak);\n    myTypeChecker.reportTypeError(equationInfo.getNodeWithError(), errorReporter);\n\n    //4debug\n    // myTypeChecker.getSubtypingManager().isSubtype(subtypeRepresentator, supertypeRepresentator, this, errorInfo, isWeak);\n  }","id":60421,"modified_method":"public void addInequation(IWrapper subType, IWrapper supertype, EquationInfo equationInfo, boolean isWeak, boolean solveOnlyConcrete, boolean checkOnly) {\n    IWrapper subtypeRepresentator = getRepresentatorWrapper(subType);\n    IWrapper supertypeRepresentator = getRepresentatorWrapper(supertype);\n\n    // no equation needed\n    if (NodeWrapper.fromWrapper(subtypeRepresentator) == NodeWrapper.fromWrapper(supertypeRepresentator)) return;\n\n    // RuntimeTypeVariable varSubtype = subtypeRepresentator == null ? null : subtypeRepresentator.getVariable();\n    RuntimeTypeVariable varSupertype = supertypeRepresentator == null ? null : supertypeRepresentator.getVariable();\n    isConcrete(subtypeRepresentator);\n    boolean subtypeHasNonConcreteVars = !isConcrete(subtypeRepresentator);\n    boolean supertypeHasNonConcreteVars = !isConcrete(supertypeRepresentator);\n\n    //if check only\n    if (checkOnly) {\n      if (subtypeHasNonConcreteVars || supertypeHasNonConcreteVars) {\n        if (isWeak) {\n          addSubtyping(subtypeRepresentator, supertypeRepresentator, equationInfo, true);\n        } else {\n          addStrongSubtyping(subtypeRepresentator, supertypeRepresentator, equationInfo, true);\n        }\n        return;\n      }\n    }\n\n    //elimination rules:\n    if (subtypeRepresentator instanceof NodeWrapper && supertypeRepresentator instanceof NodeWrapper) {\n      SNode node1 = subtypeRepresentator.getNode();\n      SNode node2 = supertypeRepresentator.getNode();\n      Set<InequationReplacementRule_Runtime> inequationReplacementRules = myTypeChecker.getRulesManager().getReplacementRules(node1, node2);\n      for (InequationReplacementRule_Runtime inequationReplacementRule : inequationReplacementRules) {\n        inequationReplacementRule.processInequation(node1, node2, equationInfo);\n        return;\n      }\n    }\n\n    // if one of them is a var\n    if (subtypeHasNonConcreteVars && solveOnlyConcrete || varSupertype != null) {\n      if (isWeak) {\n        addSubtyping(subtypeRepresentator, supertypeRepresentator, equationInfo, false);\n      } else {\n        addStrongSubtyping(subtypeRepresentator, supertypeRepresentator, equationInfo, false);\n      }\n      return;\n    }\n\n    //expand, if contains some vars.\n    if (subtypeRepresentator instanceof NodeWrapper) {\n      NodeWrapper subtypeNodeWrapper = (NodeWrapper) subtypeRepresentator;\n      SModel typesModel = myTypeChecker.getRuntimeTypesModel();\n      NodeWrapper representatorCopy = NodeWrapper.fromNode(CopyUtil.copy(subtypeNodeWrapper.getNode()), this);\n      subtypeRepresentator = expandWrapper(null, representatorCopy, typesModel);\n    }\n    if (supertypeRepresentator instanceof NodeWrapper) {\n      NodeWrapper supertypeNodeWrapper = (NodeWrapper) supertypeRepresentator;\n      SModel typesModel = myTypeChecker.getRuntimeTypesModel();\n      NodeWrapper representatorCopy = NodeWrapper.fromNode(CopyUtil.copy(supertypeNodeWrapper.getNode()), this);\n      supertypeRepresentator = expandWrapper(null, representatorCopy, typesModel);\n    }\n\n    // if subtyping\n    if (myTypeChecker.getSubtypingManager().isSubtype(subtypeRepresentator, supertypeRepresentator, this, equationInfo, isWeak)) {\n      return;\n    }\n\n    if (equationInfo.getErrorString() != null) {\n      myTypeChecker.reportTypeError(equationInfo.getNodeWithError(), equationInfo.getErrorString());\n      return;\n    }\n    String strongString = isWeak ? \"\" : \" strong\";\n    IErrorReporter errorReporter =\n      new EquationErrorReporter(this, \"type \", subtypeRepresentator,\n        \" is not a\" + strongString + \" subtype of \", supertypeRepresentator, \"\", equationInfo.getRuleModel(), equationInfo.getRuleId());\n    myTypeChecker.reportTypeError(equationInfo.getNodeWithError(), errorReporter);\n\n    //4debug\n    // myTypeChecker.getSubtypingManager().isSubtype(subtypeRepresentator, supertypeRepresentator, this, errorInfo, isWeak);\n  }","commit_id":"d9d18764dd296d74e9720cf8d0745d3c06d5375a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void processInequation(SNode subtype, SNode supertype, EquationInfo equationInfo) {\n    if (SNodeOperations.isInstanceOf(supertype, \"jetbrains.mps.baseLanguage.structure.PrimitiveType\")) {\n      {\n        BaseIntentionProvider intentionProvider = null;\n        TypeChecker.getInstance().reportTypeError(equationInfo.getNodeWithError(), \"null type is not a subtype of primitive type\", \"jetbrains.mps.baseLanguage.helgins@5_0\", \"1216199000767\", intentionProvider);\n      }\n    }\n  }","id":60422,"modified_method":"public void processInequation(SNode subtype, SNode supertype, EquationInfo equationInfo) {\n    if (SNodeOperations.isInstanceOf(supertype, \"jetbrains.mps.baseLanguage.structure.PrimitiveType\")) {\n      {\n        BaseIntentionProvider intentionProvider = null;\n        TypeChecker.getInstance().reportTypeError(equationInfo.getNodeWithError(), \"null type is not a subtype of primitive type\", \"jetbrains.mps.baseLanguage.helgins@5_0\", \"1216203743487\", intentionProvider);\n      }\n    }\n  }","commit_id":"d9d18764dd296d74e9720cf8d0745d3c06d5375a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode parameter) {\n    SNode conceptFunction = SNodeOperations.getAncestor(parameter, \"jetbrains.mps.baseLanguage.structure.ConceptFunction\", false, false);\n    if (SNodeOperations.isInstanceOf(conceptFunction, \"jetbrains.mps.baseLanguage.structure.Closure\")) {\n      {\n        BaseIntentionProvider intentionProvider = null;\n        TypeChecker.getInstance().reportTypeError(parameter, \"concept function parameter can not be used in closure\", \"jetbrains.mps.baseLanguage.helgins@5_0\", \"1216198997973\", intentionProvider);\n      }\n    } else\n    {\n      final SNode parameterConcept = SNodeOperations.getConceptDeclaration(parameter);\n      Iterable<SNode> seq = ListSequence.fromList(ConceptFunction_Behavior.call_getParameters_1213877374450(conceptFunction)).where(new IWhereFilter <SNode>() {\n\n        public boolean accept(SNode it) {\n          return SConceptOperations.isSubConceptOf(parameterConcept, NameUtil.nodeFQName(it));\n        }\n\n      });\n      if (Sequence.fromIterable(seq).isEmpty()) {\n        {\n          BaseIntentionProvider intentionProvider = null;\n          TypeChecker.getInstance().reportTypeError(parameter, \"not applicable in this context\", \"jetbrains.mps.baseLanguage.helgins@5_0\", \"1216198998006\", intentionProvider);\n        }\n      }\n    }\n  }","id":60423,"modified_method":"public void applyRule(final SNode parameter) {\n    SNode conceptFunction = SNodeOperations.getAncestor(parameter, \"jetbrains.mps.baseLanguage.structure.ConceptFunction\", false, false);\n    if (SNodeOperations.isInstanceOf(conceptFunction, \"jetbrains.mps.baseLanguage.structure.Closure\")) {\n      {\n        BaseIntentionProvider intentionProvider = null;\n        TypeChecker.getInstance().reportTypeError(parameter, \"concept function parameter can not be used in closure\", \"jetbrains.mps.baseLanguage.helgins@5_0\", \"1216203740696\", intentionProvider);\n      }\n    } else\n    {\n      final SNode parameterConcept = SNodeOperations.getConceptDeclaration(parameter);\n      Iterable<SNode> seq = ListSequence.fromList(ConceptFunction_Behavior.call_getParameters_1213877374450(conceptFunction)).where(new IWhereFilter <SNode>() {\n\n        public boolean accept(SNode it) {\n          return SConceptOperations.isSubConceptOf(parameterConcept, NameUtil.nodeFQName(it));\n        }\n\n      });\n      if (Sequence.fromIterable(seq).isEmpty()) {\n        {\n          BaseIntentionProvider intentionProvider = null;\n          TypeChecker.getInstance().reportTypeError(parameter, \"not applicable in this context\", \"jetbrains.mps.baseLanguage.helgins@5_0\", \"1216203740729\", intentionProvider);\n        }\n      }\n    }\n  }","commit_id":"d9d18764dd296d74e9720cf8d0745d3c06d5375a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode bmd) {\n    for(SNode throwsItem : SLinkOperations.getTargets(bmd, \"throwsItem\", true)) {\n      {\n        SNode _nodeToCheck_1029348928467 = bmd;\n        TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(throwsItem, new QuotationClass_103().createNode(), _nodeToCheck_1029348928467, null, \"jetbrains.mps.baseLanguage.helgins\", \"1215105338790\", false, 0);\n      }\n    }\n    // ==========\n    if (SLinkOperations.getTarget(bmd, \"body\", true) == null) {\n      return;\n    }\n    if (SConceptPropertyOperations.getBoolean(bmd, \"abstract\")) {\n      return;\n    }\n    if (SNodeOperations.isInstanceOf(bmd, \"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\") && SPropertyOperations.getBoolean(bmd, \"isAbstract\")) {\n      return;\n    }\n    // =============\n    SNode expectedRetType = SLinkOperations.getTarget(bmd, \"returnType\", true);\n    if (SConceptOperations.isExactly(SNodeOperations.getConceptDeclaration(expectedRetType), \"jetbrains.mps.baseLanguage.structure.Type\") || SNodeOperations.isInstanceOf(expectedRetType, \"jetbrains.mps.baseLanguage.structure.VoidType\") || SNodeOperations.isInstanceOf(bmd, \"jetbrains.mps.baseLanguage.structure.ConstructorDeclaration\")) {\n      // actually - no return type\n      expectedRetType = null;\n    }\n    // =============\n    Iterable<SNode> returnStatements = RulesFunctions_BaseLanguage.collectReturnStatements(SLinkOperations.getTarget(bmd, \"body\", true));\n    if (expectedRetType == null) {\n      // shouldn't return any values\n      for(SNode returnStatement : returnStatements) {\n        if ((SLinkOperations.getTarget(returnStatement, \"expression\", true) != null)) {\n          {\n            BaseIntentionProvider intentionProvider = null;\n            TypeChecker.getInstance().reportTypeError(returnStatement, \"no return value expected\", \"jetbrains.mps.baseLanguage.helgins@5_0\", \"1216199009533\", intentionProvider);\n          }\n        }\n      }\n    } else\n    {\n      // should return subtypes of the 'expected type'\n      for(SNode returnStatement : returnStatements) {\n        if ((SLinkOperations.getTarget(returnStatement, \"expression\", true) == null)) {\n          {\n            BaseIntentionProvider intentionProvider = null;\n            TypeChecker.getInstance().reportTypeError(returnStatement, \"should return value\", \"jetbrains.mps.baseLanguage.helgins@5_0\", \"1216199009548\", intentionProvider);\n          }\n        } else\n        {\n          SNode returnType = TypeChecker.getInstance().getRuntimeSupport().typeOf(SLinkOperations.getTarget(returnStatement, \"expression\", true), \"jetbrains.mps.baseLanguage.helgins\", \"1178765405776\", true);\n          {\n            SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(returnStatement, \"expression\", true);\n            TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(returnType, expectedRetType, _nodeToCheck_1029348928467, \"\" + expectedRetType + \" is expected\", \"jetbrains.mps.baseLanguage.helgins\", \"1185363921400\", false, 0);\n          }\n        }\n      }\n    }\n    // =============\n    if (expectedRetType != null) {\n      // last expression statement can serve as return statement\n      SNode lastStatement = ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(bmd, \"body\", true), \"statement\", true)).last();\n      if (SNodeOperations.isInstanceOf(lastStatement, \"jetbrains.mps.baseLanguage.structure.ExpressionStatement\")) {\n        SNode returnType = TypeChecker.getInstance().getRuntimeSupport().typeOf(SLinkOperations.getTarget(lastStatement, \"expression\", true), \"jetbrains.mps.baseLanguage.helgins\", \"1178765601477\", true);\n        {\n          SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(lastStatement, \"expression\", true);\n          TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(returnType, expectedRetType, _nodeToCheck_1029348928467, expectedRetType + \" is expected\", \"jetbrains.mps.baseLanguage.helgins\", \"1185363855090\", false, 0);\n        }\n      }\n    }\n  }","id":60424,"modified_method":"public void applyRule(final SNode bmd) {\n    for(SNode throwsItem : SLinkOperations.getTargets(bmd, \"throwsItem\", true)) {\n      {\n        SNode _nodeToCheck_1029348928467 = bmd;\n        TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(throwsItem, new QuotationClass_103().createNode(), _nodeToCheck_1029348928467, null, \"jetbrains.mps.baseLanguage.helgins\", \"1215105338790\", false, 0);\n      }\n    }\n    // ==========\n    if (SLinkOperations.getTarget(bmd, \"body\", true) == null) {\n      return;\n    }\n    if (SConceptPropertyOperations.getBoolean(bmd, \"abstract\")) {\n      return;\n    }\n    if (SNodeOperations.isInstanceOf(bmd, \"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\") && SPropertyOperations.getBoolean(bmd, \"isAbstract\")) {\n      return;\n    }\n    // =============\n    SNode expectedRetType = SLinkOperations.getTarget(bmd, \"returnType\", true);\n    if (SConceptOperations.isExactly(SNodeOperations.getConceptDeclaration(expectedRetType), \"jetbrains.mps.baseLanguage.structure.Type\") || SNodeOperations.isInstanceOf(expectedRetType, \"jetbrains.mps.baseLanguage.structure.VoidType\") || SNodeOperations.isInstanceOf(bmd, \"jetbrains.mps.baseLanguage.structure.ConstructorDeclaration\")) {\n      // actually - no return type\n      expectedRetType = null;\n    }\n    // =============\n    Iterable<SNode> returnStatements = RulesFunctions_BaseLanguage.collectReturnStatements(SLinkOperations.getTarget(bmd, \"body\", true));\n    if (expectedRetType == null) {\n      // shouldn't return any values\n      for(SNode returnStatement : returnStatements) {\n        if ((SLinkOperations.getTarget(returnStatement, \"expression\", true) != null)) {\n          {\n            BaseIntentionProvider intentionProvider = null;\n            TypeChecker.getInstance().reportTypeError(returnStatement, \"no return value expected\", \"jetbrains.mps.baseLanguage.helgins@5_0\", \"1216203751263\", intentionProvider);\n          }\n        }\n      }\n    } else\n    {\n      // should return subtypes of the 'expected type'\n      for(SNode returnStatement : returnStatements) {\n        if ((SLinkOperations.getTarget(returnStatement, \"expression\", true) == null)) {\n          {\n            BaseIntentionProvider intentionProvider = null;\n            TypeChecker.getInstance().reportTypeError(returnStatement, \"should return value\", \"jetbrains.mps.baseLanguage.helgins@5_0\", \"1216203751278\", intentionProvider);\n          }\n        } else\n        {\n          SNode returnType = TypeChecker.getInstance().getRuntimeSupport().typeOf(SLinkOperations.getTarget(returnStatement, \"expression\", true), \"jetbrains.mps.baseLanguage.helgins\", \"1178765405776\", true);\n          {\n            SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(returnStatement, \"expression\", true);\n            TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(returnType, expectedRetType, _nodeToCheck_1029348928467, \"\" + expectedRetType + \" is expected\", \"jetbrains.mps.baseLanguage.helgins\", \"1185363921400\", false, 0);\n          }\n        }\n      }\n    }\n    // =============\n    if (expectedRetType != null) {\n      // last expression statement can serve as return statement\n      SNode lastStatement = ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(bmd, \"body\", true), \"statement\", true)).last();\n      if (SNodeOperations.isInstanceOf(lastStatement, \"jetbrains.mps.baseLanguage.structure.ExpressionStatement\")) {\n        SNode returnType = TypeChecker.getInstance().getRuntimeSupport().typeOf(SLinkOperations.getTarget(lastStatement, \"expression\", true), \"jetbrains.mps.baseLanguage.helgins\", \"1178765601477\", true);\n        {\n          SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(lastStatement, \"expression\", true);\n          TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(returnType, expectedRetType, _nodeToCheck_1029348928467, expectedRetType + \" is expected\", \"jetbrains.mps.baseLanguage.helgins\", \"1185363855090\", false, 0);\n        }\n      }\n    }\n  }","commit_id":"d9d18764dd296d74e9720cf8d0745d3c06d5375a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode func) {\n    SNode expectedRetType = ConceptFunction_Behavior.call_getExpectedReturnType_1213877374441(func);\n    boolean noReturnExpected = ((expectedRetType == null) || TypeChecker.getInstance().getSubtypingManager().isSubtype(expectedRetType, new QuotationClass_67().createNode()));\n    if (SConceptOperations.isExactly(SNodeOperations.getConceptDeclaration(expectedRetType), \"jetbrains.mps.baseLanguage.structure.WildCardType\")) {\n      // function is expected to return value of any type\n      expectedRetType = null;\n    }\n    // =============\n    Iterable<SNode> returnStatements = RulesFunctions_BaseLanguage.collectReturnStatements(SLinkOperations.getTarget(func, \"body\", true));\n    boolean somethingReturned = Sequence.fromIterable(returnStatements).isNotEmpty();\n    // =============\n    final SNode LCS_typevar_1186052624152 = TypeChecker.getInstance().getRuntimeSupport().createNewRuntimeTypesVariable();\n    if (noReturnExpected) {\n      // shouldn't return any values\n      for(SNode returnStatement : returnStatements) {\n        if ((SLinkOperations.getTarget(returnStatement, \"expression\", true) != null)) {\n          {\n            BaseIntentionProvider intentionProvider = null;\n            TypeChecker.getInstance().reportTypeError(returnStatement, \"no return value expected\", \"jetbrains.mps.baseLanguage.helgins@5_0\", \"1216199009653\", intentionProvider);\n          }\n        }\n      }\n      TypeChecker.getInstance().getRuntimeSupport().givetype(null, func, \"jetbrains.mps.baseLanguage.helgins\", \"1179436909754\");\n    } else\n    {\n      // should return subtypes of the 'expected type'\n      // if 'expected type' is null - should still return some value (of any type)\n      for(SNode returnStatement : returnStatements) {\n        if ((SLinkOperations.getTarget(returnStatement, \"expression\", true) == null)) {\n          {\n            BaseIntentionProvider intentionProvider = null;\n            TypeChecker.getInstance().reportTypeError(returnStatement, \"should return value\", \"jetbrains.mps.baseLanguage.helgins@5_0\", \"1216199009668\", intentionProvider);\n          }\n        } else\n        {\n          {\n            SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(returnStatement, \"expression\", true);\n            TypeChecker.getInstance().getRuntimeSupport().createGreaterThanInequation(TypeChecker.getInstance().getEquationManager().getRepresentator(LCS_typevar_1186052624152), TypeChecker.getInstance().getRuntimeSupport().typeOf(_nodeToCheck_1029348928467, \"jetbrains.mps.baseLanguage.helgins\", \"1186053304515\", true), _nodeToCheck_1029348928467, null, \"jetbrains.mps.baseLanguage.helgins\", \"1186053304511\", false, 0);\n          }\n        }\n      }\n      // last expression statement can serve as return statement\n      SNode lastStatement = ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(func, \"body\", true), \"statement\", true)).last();\n      if (SNodeOperations.isInstanceOf(lastStatement, \"jetbrains.mps.baseLanguage.structure.ExpressionStatement\")) {\n        SNode expression = SLinkOperations.getTarget(lastStatement, \"expression\", true);\n        {\n          SNode _nodeToCheck_1029348928467 = expression;\n          TypeChecker.getInstance().getRuntimeSupport().createGreaterThanInequation(TypeChecker.getInstance().getEquationManager().getRepresentator(LCS_typevar_1186052624152), TypeChecker.getInstance().getRuntimeSupport().typeOf(_nodeToCheck_1029348928467, \"jetbrains.mps.baseLanguage.helgins\", \"1186053084979\", true), _nodeToCheck_1029348928467, null, \"jetbrains.mps.baseLanguage.helgins\", \"1186053063874\", false, 0);\n        }\n        somethingReturned = true;\n      }\n      if (!(somethingReturned)) {\n        String whatExpected = ((expectedRetType == null) ?\n          \"some value\" :\n          \"\" + expectedRetType\n        );\n        {\n          BaseIntentionProvider intentionProvider = null;\n          TypeChecker.getInstance().reportTypeError(func, \"function should return \" + whatExpected, \"jetbrains.mps.baseLanguage.helgins@5_0\", \"1216198997186\", intentionProvider);\n        }\n      }\n      {\n        SNode _nodeToCheck_1029348928467 = func;\n        TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getRuntimeSupport().typeOf(_nodeToCheck_1029348928467, \"jetbrains.mps.baseLanguage.helgins\", \"1186053169643\", true), TypeChecker.getInstance().getEquationManager().getRepresentator(LCS_typevar_1186052624152), _nodeToCheck_1029348928467, null, \"jetbrains.mps.baseLanguage.helgins\", \"1186053174208\");\n      }\n      if ((expectedRetType != null)) {\n        {\n          SNode _nodeToCheck_1029348928467 = func;\n          TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(TypeChecker.getInstance().getRuntimeSupport().typeOf(_nodeToCheck_1029348928467, \"jetbrains.mps.baseLanguage.helgins\", \"1186053540851\", true), expectedRetType, _nodeToCheck_1029348928467, null, \"jetbrains.mps.baseLanguage.helgins\", \"1186053540847\", false, 0);\n        }\n      }\n    }\n  }","id":60425,"modified_method":"public void applyRule(final SNode func) {\n    SNode expectedRetType = ConceptFunction_Behavior.call_getExpectedReturnType_1213877374441(func);\n    boolean noReturnExpected = ((expectedRetType == null) || TypeChecker.getInstance().getSubtypingManager().isSubtype(expectedRetType, new QuotationClass_67().createNode()));\n    if (SConceptOperations.isExactly(SNodeOperations.getConceptDeclaration(expectedRetType), \"jetbrains.mps.baseLanguage.structure.WildCardType\")) {\n      // function is expected to return value of any type\n      expectedRetType = null;\n    }\n    // =============\n    Iterable<SNode> returnStatements = RulesFunctions_BaseLanguage.collectReturnStatements(SLinkOperations.getTarget(func, \"body\", true));\n    boolean somethingReturned = Sequence.fromIterable(returnStatements).isNotEmpty();\n    // =============\n    final SNode LCS_typevar_1186052624152 = TypeChecker.getInstance().getRuntimeSupport().createNewRuntimeTypesVariable();\n    if (noReturnExpected) {\n      // shouldn't return any values\n      for(SNode returnStatement : returnStatements) {\n        if ((SLinkOperations.getTarget(returnStatement, \"expression\", true) != null)) {\n          {\n            BaseIntentionProvider intentionProvider = null;\n            TypeChecker.getInstance().reportTypeError(returnStatement, \"no return value expected\", \"jetbrains.mps.baseLanguage.helgins@5_0\", \"1216203751384\", intentionProvider);\n          }\n        }\n      }\n      TypeChecker.getInstance().getRuntimeSupport().givetype(null, func, \"jetbrains.mps.baseLanguage.helgins\", \"1179436909754\");\n    } else\n    {\n      // should return subtypes of the 'expected type'\n      // if 'expected type' is null - should still return some value (of any type)\n      for(SNode returnStatement : returnStatements) {\n        if ((SLinkOperations.getTarget(returnStatement, \"expression\", true) == null)) {\n          {\n            BaseIntentionProvider intentionProvider = null;\n            TypeChecker.getInstance().reportTypeError(returnStatement, \"should return value\", \"jetbrains.mps.baseLanguage.helgins@5_0\", \"1216203751399\", intentionProvider);\n          }\n        } else\n        {\n          {\n            SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(returnStatement, \"expression\", true);\n            TypeChecker.getInstance().getRuntimeSupport().createGreaterThanInequation(TypeChecker.getInstance().getEquationManager().getRepresentator(LCS_typevar_1186052624152), TypeChecker.getInstance().getRuntimeSupport().typeOf(_nodeToCheck_1029348928467, \"jetbrains.mps.baseLanguage.helgins\", \"1186053304515\", true), _nodeToCheck_1029348928467, null, \"jetbrains.mps.baseLanguage.helgins\", \"1186053304511\", false, 0);\n          }\n        }\n      }\n      // last expression statement can serve as return statement\n      SNode lastStatement = ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(func, \"body\", true), \"statement\", true)).last();\n      if (SNodeOperations.isInstanceOf(lastStatement, \"jetbrains.mps.baseLanguage.structure.ExpressionStatement\")) {\n        SNode expression = SLinkOperations.getTarget(lastStatement, \"expression\", true);\n        {\n          SNode _nodeToCheck_1029348928467 = expression;\n          TypeChecker.getInstance().getRuntimeSupport().createGreaterThanInequation(TypeChecker.getInstance().getEquationManager().getRepresentator(LCS_typevar_1186052624152), TypeChecker.getInstance().getRuntimeSupport().typeOf(_nodeToCheck_1029348928467, \"jetbrains.mps.baseLanguage.helgins\", \"1186053084979\", true), _nodeToCheck_1029348928467, null, \"jetbrains.mps.baseLanguage.helgins\", \"1186053063874\", false, 0);\n        }\n        somethingReturned = true;\n      }\n      if (!(somethingReturned)) {\n        String whatExpected = ((expectedRetType == null) ?\n          \"some value\" :\n          \"\" + expectedRetType\n        );\n        {\n          BaseIntentionProvider intentionProvider = null;\n          TypeChecker.getInstance().reportTypeError(func, \"function should return \" + whatExpected, \"jetbrains.mps.baseLanguage.helgins@5_0\", \"1216203739909\", intentionProvider);\n        }\n      }\n      {\n        SNode _nodeToCheck_1029348928467 = func;\n        TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getRuntimeSupport().typeOf(_nodeToCheck_1029348928467, \"jetbrains.mps.baseLanguage.helgins\", \"1186053169643\", true), TypeChecker.getInstance().getEquationManager().getRepresentator(LCS_typevar_1186052624152), _nodeToCheck_1029348928467, null, \"jetbrains.mps.baseLanguage.helgins\", \"1186053174208\");\n      }\n      if ((expectedRetType != null)) {\n        {\n          SNode _nodeToCheck_1029348928467 = func;\n          TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(TypeChecker.getInstance().getRuntimeSupport().typeOf(_nodeToCheck_1029348928467, \"jetbrains.mps.baseLanguage.helgins\", \"1186053540851\", true), expectedRetType, _nodeToCheck_1029348928467, null, \"jetbrains.mps.baseLanguage.helgins\", \"1186053540847\", false, 0);\n        }\n      }\n    }\n  }","commit_id":"d9d18764dd296d74e9720cf8d0745d3c06d5375a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode creator) {\n    if (SLinkOperations.getTarget(creator, \"baseMethodDeclaration\", false) == null) {\n      return;\n    }\n    if (!(SLinkOperations.getCount(creator, \"actualArgument\") == SLinkOperations.getCount(SLinkOperations.getTarget(creator, \"baseMethodDeclaration\", false), \"parameter\"))) {\n      TypeChecker.getInstance().reportTypeError(creator, \"wrong number of arguments\", \"jetbrains.mps.baseLanguage.helgins\", \"1212781605955\");\n    }\n    if (!(SLinkOperations.getCount(creator, \"typeParameter\") == 0 || SLinkOperations.getCount(creator, \"typeParameter\") == SLinkOperations.getCount(SNodeOperations.getAncestor(SLinkOperations.getTarget(creator, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false), \"typeVariableDeclaration\"))) {\n      TypeChecker.getInstance().reportTypeError(creator, \"wrong number of type parameters\", \"jetbrains.mps.baseLanguage.helgins\", \"1212781605971\");\n    }\n    for(SNode parameter : SLinkOperations.getTargets(creator, \"typeParameter\", true)) {\n      if (!(!(TypeChecker.getInstance().getSubtypingManager().isSubtype(parameter, SLinkOperations.getTarget(new QuotationClass_97().createNode(), \"descriptor\", false), false, false)))) {\n        TypeChecker.getInstance().reportTypeError(parameter, \"primitive type not allowed\", \"jetbrains.mps.baseLanguage.helgins\", \"1212781606006\");\n      }\n    }\n    // ---\n    final SNode methodClassifier = SNodeOperations.getAncestor(SLinkOperations.getTarget(creator, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false);\n    SNode constructedType = new QuotationClass_98().createNode(SLinkOperations.getTargets(creator, \"typeParameter\", true), methodClassifier);\n    {\n      SNode _nodeToCheck_1029348928467 = creator;\n      TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getRuntimeSupport().typeOf(_nodeToCheck_1029348928467, \"jetbrains.mps.baseLanguage.helgins\", \"1212781606043\", true), constructedType, _nodeToCheck_1029348928467, null, \"jetbrains.mps.baseLanguage.helgins\", \"1212781606039\");\n    }\n    final SNode instanceType_typevar_1212781606045 = TypeChecker.getInstance().getRuntimeSupport().createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = creator;\n      TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getEquationManager().getRepresentator(instanceType_typevar_1212781606045), constructedType, _nodeToCheck_1029348928467, null, \"jetbrains.mps.baseLanguage.helgins\", \"1212781606046\");\n    }\n    // --- following piece of cake is identical for any method call ---\n    {\n      final SNode _representatorVar3 = TypeChecker.getInstance().getEquationManager().getRepresentator(instanceType_typevar_1212781606045);\n      TypeChecker.getInstance().getRuntimeSupport().whenConcrete(_representatorVar3, new Runnable() {\n\n        public void run() {\n          Map<SNode, List<SNode>> mmap = new HashMap<SNode, List<SNode>>();\n          RulesFunctions_BaseLanguage.inference_equateParametersAndReturnType(creator, null, mmap);\n          RulesFunctions_BaseLanguage.inference_matchConcreteTypesWithTypeVariables(methodClassifier, TypeChecker.getInstance().getEquationManager().getRepresentator(instanceType_typevar_1212781606045), mmap);\n          RulesFunctions_BaseLanguage.inference_equateMatchingTypeVariables(mmap);\n        }\n\n      }, \"jetbrains.mps.baseLanguage.helgins\", \"1212781606052\");\n    }\n  }","id":60426,"modified_method":"public void applyRule(final SNode creator) {\n    if (SLinkOperations.getTarget(creator, \"baseMethodDeclaration\", false) == null) {\n      return;\n    }\n    final SNode methodClassifier = SNodeOperations.getAncestor(SLinkOperations.getTarget(creator, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false);\n    if (!(SLinkOperations.getCount(creator, \"actualArgument\") == SLinkOperations.getCount(SLinkOperations.getTarget(creator, \"baseMethodDeclaration\", false), \"parameter\"))) {\n      {\n        BaseIntentionProvider intentionProvider = null;\n        intentionProvider = new BaseIntentionProvider(\"jetbrains.mps.baseLanguage.helgins@5_0.ChooseAppropriateConstructorDeclaration_Intention\", true);\n        intentionProvider.putArgument(\"classConcept\", methodClassifier);\n        intentionProvider.putArgument(\"constructorCall\", creator);\n        TypeChecker.getInstance().reportTypeError(creator, \"wrong number of arguments\", \"jetbrains.mps.baseLanguage.helgins@5_0\", \"1216203742574\", intentionProvider);\n      }\n    }\n    if (!(SLinkOperations.getCount(creator, \"typeParameter\") == 0 || SLinkOperations.getCount(creator, \"typeParameter\") == SLinkOperations.getCount(SNodeOperations.getAncestor(SLinkOperations.getTarget(creator, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false), \"typeVariableDeclaration\"))) {\n      {\n        BaseIntentionProvider intentionProvider = null;\n        TypeChecker.getInstance().reportTypeError(creator, \"wrong number of type parameters\", \"jetbrains.mps.baseLanguage.helgins@5_0\", \"1216203742594\", intentionProvider);\n      }\n    }\n    for(SNode parameter : SLinkOperations.getTargets(creator, \"typeParameter\", true)) {\n      if (!(!(TypeChecker.getInstance().getSubtypingManager().isSubtype(parameter, SLinkOperations.getTarget(new QuotationClass_97().createNode(), \"descriptor\", false), false, false)))) {\n        TypeChecker.getInstance().reportTypeError(parameter, \"primitive type not allowed\", \"jetbrains.mps.baseLanguage.helgins\", \"1212781606006\");\n      }\n    }\n    // ---\n    SNode constructedType = new QuotationClass_98().createNode(SLinkOperations.getTargets(creator, \"typeParameter\", true), methodClassifier);\n    {\n      SNode _nodeToCheck_1029348928467 = creator;\n      TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getRuntimeSupport().typeOf(_nodeToCheck_1029348928467, \"jetbrains.mps.baseLanguage.helgins\", \"1212781606043\", true), constructedType, _nodeToCheck_1029348928467, null, \"jetbrains.mps.baseLanguage.helgins\", \"1212781606039\");\n    }\n    final SNode instanceType_typevar_1212781606045 = TypeChecker.getInstance().getRuntimeSupport().createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = creator;\n      TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getEquationManager().getRepresentator(instanceType_typevar_1212781606045), constructedType, _nodeToCheck_1029348928467, null, \"jetbrains.mps.baseLanguage.helgins\", \"1212781606046\");\n    }\n    // --- following piece of cake is identical for any method call ---\n    {\n      final SNode _representatorVar3 = TypeChecker.getInstance().getEquationManager().getRepresentator(instanceType_typevar_1212781606045);\n      TypeChecker.getInstance().getRuntimeSupport().whenConcrete(_representatorVar3, new Runnable() {\n\n        public void run() {\n          Map<SNode, List<SNode>> mmap = new HashMap<SNode, List<SNode>>();\n          RulesFunctions_BaseLanguage.inference_equateParametersAndReturnType(creator, null, mmap);\n          RulesFunctions_BaseLanguage.inference_matchConcreteTypesWithTypeVariables(methodClassifier, TypeChecker.getInstance().getEquationManager().getRepresentator(instanceType_typevar_1212781606045), mmap);\n          RulesFunctions_BaseLanguage.inference_equateMatchingTypeVariables(mmap);\n        }\n\n      }, \"jetbrains.mps.baseLanguage.helgins\", \"1212781606052\");\n    }\n  }","commit_id":"d9d18764dd296d74e9720cf8d0745d3c06d5375a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode imco) {\n    if (SLinkOperations.getTarget(imco, \"baseMethodDeclaration\", false) == null) {\n      return;\n    }\n    final SNode methodClassifier = SNodeOperations.getAncestor(SLinkOperations.getTarget(imco, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false);\n    if (!(SLinkOperations.getCount(imco, \"actualArgument\") == SLinkOperations.getCount(SLinkOperations.getTarget(imco, \"baseMethodDeclaration\", false), \"parameter\"))) {\n      {\n        BaseIntentionProvider intentionProvider = null;\n        intentionProvider = new BaseIntentionProvider(\"jetbrains.mps.baseLanguage.helgins@5_0.ChooseAppropriateInstanceMethodDeclaration_Intention\", true);\n        intentionProvider.putArgument(\"classifier\", methodClassifier);\n        intentionProvider.putArgument(\"methodCall\", imco);\n        TypeChecker.getInstance().reportTypeError(imco, \"wrong number of parameters\", \"jetbrains.mps.baseLanguage.helgins@5_0\", \"1216198998514\", intentionProvider);\n      }\n    }\n    // ---\n    final SNode instanceType_typevar_1204064731338 = TypeChecker.getInstance().getRuntimeSupport().createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = IOperation_Behavior.call_getOperand_1213877410070(imco);\n      TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getEquationManager().getRepresentator(instanceType_typevar_1204064731338), TypeChecker.getInstance().getRuntimeSupport().typeOf(_nodeToCheck_1029348928467, \"jetbrains.mps.baseLanguage.helgins\", \"1204064784351\", false), _nodeToCheck_1029348928467, null, \"jetbrains.mps.baseLanguage.helgins\", \"1204064763142\");\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = imco;\n      TypeChecker.getInstance().getRuntimeSupport().createLessThanInequationStrong(TypeChecker.getInstance().getEquationManager().getRepresentator(instanceType_typevar_1204064731338), new QuotationClass_74().createNode(methodClassifier), _nodeToCheck_1029348928467, null, \"jetbrains.mps.baseLanguage.helgins\", \"1204065906120\", true, 0);\n    }\n    // --- following piece of cake is identical for any method call ---\n    {\n      final SNode _representatorVar2 = TypeChecker.getInstance().getEquationManager().getRepresentator(instanceType_typevar_1204064731338);\n      TypeChecker.getInstance().getRuntimeSupport().whenConcrete(_representatorVar2, new Runnable() {\n\n        public void run() {\n          Map<SNode, List<SNode>> mmap = new HashMap<SNode, List<SNode>>();\n          RulesFunctions_BaseLanguage.inference_equateParametersAndReturnType(imco, SLinkOperations.getTarget(SLinkOperations.getTarget(imco, \"baseMethodDeclaration\", false), \"returnType\", true), mmap);\n          RulesFunctions_BaseLanguage.inference_matchConcreteTypesWithTypeVariables(methodClassifier, TypeChecker.getInstance().getEquationManager().getRepresentator(instanceType_typevar_1204064731338), mmap);\n          RulesFunctions_BaseLanguage.inference_equateMatchingTypeVariables(mmap);\n        }\n\n      }, \"jetbrains.mps.baseLanguage.helgins\", \"1204065986803\");\n    }\n  }","id":60427,"modified_method":"public void applyRule(final SNode imco) {\n    if (SLinkOperations.getTarget(imco, \"baseMethodDeclaration\", false) == null) {\n      return;\n    }\n    final SNode methodClassifier = SNodeOperations.getAncestor(SLinkOperations.getTarget(imco, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false);\n    if (!(SLinkOperations.getCount(imco, \"actualArgument\") == SLinkOperations.getCount(SLinkOperations.getTarget(imco, \"baseMethodDeclaration\", false), \"parameter\"))) {\n      {\n        BaseIntentionProvider intentionProvider = null;\n        intentionProvider = new BaseIntentionProvider(\"jetbrains.mps.baseLanguage.helgins@5_0.ChooseAppropriateMethodDeclaration_Intention\", true);\n        intentionProvider.putArgument(\"classifier\", methodClassifier);\n        intentionProvider.putArgument(\"methodCall\", imco);\n        TypeChecker.getInstance().reportTypeError(imco, \"wrong number of parameters\", \"jetbrains.mps.baseLanguage.helgins@5_0\", \"1216203741253\", intentionProvider);\n      }\n    }\n    // ---\n    final SNode instanceType_typevar_1204064731338 = TypeChecker.getInstance().getRuntimeSupport().createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = IOperation_Behavior.call_getOperand_1213877410070(imco);\n      TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getEquationManager().getRepresentator(instanceType_typevar_1204064731338), TypeChecker.getInstance().getRuntimeSupport().typeOf(_nodeToCheck_1029348928467, \"jetbrains.mps.baseLanguage.helgins\", \"1204064784351\", false), _nodeToCheck_1029348928467, null, \"jetbrains.mps.baseLanguage.helgins\", \"1204064763142\");\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = imco;\n      TypeChecker.getInstance().getRuntimeSupport().createLessThanInequationStrong(TypeChecker.getInstance().getEquationManager().getRepresentator(instanceType_typevar_1204064731338), new QuotationClass_74().createNode(methodClassifier), _nodeToCheck_1029348928467, null, \"jetbrains.mps.baseLanguage.helgins\", \"1204065906120\", true, 0);\n    }\n    // --- following piece of cake is identical for any method call ---\n    {\n      final SNode _representatorVar2 = TypeChecker.getInstance().getEquationManager().getRepresentator(instanceType_typevar_1204064731338);\n      TypeChecker.getInstance().getRuntimeSupport().whenConcrete(_representatorVar2, new Runnable() {\n\n        public void run() {\n          Map<SNode, List<SNode>> mmap = new HashMap<SNode, List<SNode>>();\n          RulesFunctions_BaseLanguage.inference_equateParametersAndReturnType(imco, SLinkOperations.getTarget(SLinkOperations.getTarget(imco, \"baseMethodDeclaration\", false), \"returnType\", true), mmap);\n          RulesFunctions_BaseLanguage.inference_matchConcreteTypesWithTypeVariables(methodClassifier, TypeChecker.getInstance().getEquationManager().getRepresentator(instanceType_typevar_1204064731338), mmap);\n          RulesFunctions_BaseLanguage.inference_equateMatchingTypeVariables(mmap);\n        }\n\n      }, \"jetbrains.mps.baseLanguage.helgins\", \"1204065986803\");\n    }\n  }","commit_id":"d9d18764dd296d74e9720cf8d0745d3c06d5375a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void processInequation(SNode subtype, SNode supertype, EquationInfo equationInfo) {\n    SNode classifier = SLinkOperations.getTarget(supertype, \"classifier\", false);\n    String errorMsg = \"\";\n    if (SNodeOperations.isInstanceOf(classifier, \"jetbrains.mps.baseLanguage.structure.Interface\")) {\n      List<SNode> methods = SLinkOperations.getTargets(classifier, \"method\", true);\n      if (methods != null && methods.size() == 1) {\n        SNode md = methods.get(0);\n        if (SLinkOperations.getCount(subtype, \"parameterType\") == SLinkOperations.getCount(md, \"parameter\")) {\n          TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(SLinkOperations.getTarget(subtype, \"resultType\", true), ClassifierTypeUtil.resolveType(SLinkOperations.getTarget(md, \"returnType\", true), supertype), equationInfo.getNodeWithError(), null, \"jetbrains.mps.closures.helgins\", \"1202742499735\", false);\n          {\n            SNode fpt;\n            SNode mpt;\n            Iterator<SNode> fpt_iterator = SLinkOperations.getTargets(subtype, \"parameterType\", true).iterator();\n            Iterator<SNode> mpt_iterator = SLinkOperations.getTargets(md, \"parameter\", true).iterator();\n            while(true) {\n              if (!(fpt_iterator.hasNext())) {\n                break;\n              }\n              if (!(mpt_iterator.hasNext())) {\n                break;\n              }\n              fpt = fpt_iterator.next();\n              mpt = mpt_iterator.next();\n              TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(ClassifierTypeUtil.resolveType(SLinkOperations.getTarget(mpt, \"type\", true), supertype), fpt, equationInfo.getNodeWithError(), null, \"jetbrains.mps.closures.helgins\", \"1202746383183\", false);\n            }\n          }\n          return;\n        } else\n        {\n          errorMsg = \": wrong parameter number\";\n        }\n      } else\n      {\n        errorMsg = \": interface must have only one method\";\n      }\n    } else\n    {\n      errorMsg = \": not an interface\";\n    }\n    TypeChecker.getInstance().reportTypeError(equationInfo.getNodeWithError(), BaseConcept_Behavior.call_getPresentation_1180102203531(subtype) + \" is not a subtype of \" + BaseConcept_Behavior.call_getPresentation_1180102203531(supertype) + errorMsg, \"jetbrains.mps.closures.helgins\", \"1202742336483\");\n  }","id":60428,"modified_method":"public void processInequation(SNode subtype, SNode supertype, EquationInfo equationInfo) {\n    SNode classifier = SLinkOperations.getTarget(supertype, \"classifier\", false);\n    String errorMsg = \"\";\n    if (SNodeOperations.isInstanceOf(classifier, \"jetbrains.mps.baseLanguage.structure.Interface\")) {\n      List<SNode> methods = SLinkOperations.getTargets(classifier, \"method\", true);\n      if (methods != null && methods.size() == 1) {\n        SNode md = methods.get(0);\n        if (SLinkOperations.getCount(subtype, \"parameterType\") == SLinkOperations.getCount(md, \"parameter\")) {\n          TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(SLinkOperations.getTarget(subtype, \"resultType\", true), ClassifierTypeUtil.resolveType(SLinkOperations.getTarget(md, \"returnType\", true), supertype), equationInfo.getNodeWithError(), null, \"jetbrains.mps.closures.helgins\", \"1202742499735\", false);\n          {\n            SNode fpt;\n            SNode mpt;\n            Iterator<SNode> fpt_iterator = SLinkOperations.getTargets(subtype, \"parameterType\", true).iterator();\n            Iterator<SNode> mpt_iterator = SLinkOperations.getTargets(md, \"parameter\", true).iterator();\n            while(true) {\n              if (!(fpt_iterator.hasNext())) {\n                break;\n              }\n              if (!(mpt_iterator.hasNext())) {\n                break;\n              }\n              fpt = fpt_iterator.next();\n              mpt = mpt_iterator.next();\n              TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(ClassifierTypeUtil.resolveType(SLinkOperations.getTarget(mpt, \"type\", true), supertype), fpt, equationInfo.getNodeWithError(), null, \"jetbrains.mps.closures.helgins\", \"1202746383183\", false);\n            }\n          }\n          return;\n        } else\n        {\n          errorMsg = \": wrong parameter number\";\n        }\n      } else\n      {\n        errorMsg = \": interface must have only one method\";\n      }\n    } else\n    {\n      errorMsg = \": not an interface\";\n    }\n    {\n      BaseIntentionProvider intentionProvider = null;\n      TypeChecker.getInstance().reportTypeError(equationInfo.getNodeWithError(), BaseConcept_Behavior.call_getPresentation_1180102203531(subtype) + \" is not a subtype of \" + BaseConcept_Behavior.call_getPresentation_1180102203531(supertype) + errorMsg, \"jetbrains.mps.closures.helgins\", \"1202742336483\", intentionProvider);\n    }\n  }","commit_id":"116811aea3c3e115cb9cb01faafa533a2951a846","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void processInequation(SNode subtype, SNode supertype, EquationInfo equationInfo) {\n    if (SLinkOperations.getCount(subtype, \"parameterType\") != SLinkOperations.getCount(supertype, \"parameterType\")) {\n      TypeChecker.getInstance().reportTypeError(equationInfo.getNodeWithError(), \"different parameter numbers\", \"jetbrains.mps.closures.helgins\", \"1201618945543\");\n      return;\n    }\n    TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(SLinkOperations.getTarget(subtype, \"resultType\", true), SLinkOperations.getTarget(supertype, \"resultType\", true), equationInfo.getNodeWithError(), null, \"jetbrains.mps.closures.helgins\", \"1201614892741\", false);\n    {\n      SNode paramType1;\n      SNode paramType2;\n      Iterator<SNode> paramType1_iterator = SLinkOperations.getTargets(subtype, \"parameterType\", true).iterator();\n      Iterator<SNode> paramType2_iterator = SLinkOperations.getTargets(supertype, \"parameterType\", true).iterator();\n      while(true) {\n        if (!(paramType1_iterator.hasNext())) {\n          break;\n        }\n        if (!(paramType2_iterator.hasNext())) {\n          break;\n        }\n        paramType1 = paramType1_iterator.next();\n        paramType2 = paramType2_iterator.next();\n        TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(paramType2, paramType1, equationInfo.getNodeWithError(), null, \"jetbrains.mps.closures.helgins\", \"1201614990748\", false);\n      }\n    }\n  }","id":60429,"modified_method":"public void processInequation(SNode subtype, SNode supertype, EquationInfo equationInfo) {\n    if (SLinkOperations.getCount(subtype, \"parameterType\") != SLinkOperations.getCount(supertype, \"parameterType\")) {\n      {\n        BaseIntentionProvider intentionProvider = null;\n        TypeChecker.getInstance().reportTypeError(equationInfo.getNodeWithError(), \"different parameter numbers\", \"jetbrains.mps.closures.helgins\", \"1201618945543\", intentionProvider);\n      }\n      return;\n    }\n    TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(SLinkOperations.getTarget(subtype, \"resultType\", true), SLinkOperations.getTarget(supertype, \"resultType\", true), equationInfo.getNodeWithError(), null, \"jetbrains.mps.closures.helgins\", \"1201614892741\", false);\n    {\n      SNode paramType1;\n      SNode paramType2;\n      Iterator<SNode> paramType1_iterator = SLinkOperations.getTargets(subtype, \"parameterType\", true).iterator();\n      Iterator<SNode> paramType2_iterator = SLinkOperations.getTargets(supertype, \"parameterType\", true).iterator();\n      while(true) {\n        if (!(paramType1_iterator.hasNext())) {\n          break;\n        }\n        if (!(paramType2_iterator.hasNext())) {\n          break;\n        }\n        paramType1 = paramType1_iterator.next();\n        paramType2 = paramType2_iterator.next();\n        TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(paramType2, paramType1, equationInfo.getNodeWithError(), null, \"jetbrains.mps.closures.helgins\", \"1201614990748\", false);\n      }\n    }\n  }","commit_id":"116811aea3c3e115cb9cb01faafa533a2951a846","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<SNode> getSubOrSuperTypes(SNode ft) {\n    List<SNode> supertypes = Collections.emptyList();\n    String rtSig = \"FunctionTypes.\" + FunctionType_Behavior.call_getRuntimeSignature_1202756382806(ft);\n    for(SNode ice : SModelOperations.getNodes(SNodeOperations.getModel(SLinkOperations.getTarget(new QuotationClass_4().createNode(), \"classifier\", false)), \"jetbrains.mps.baseLanguage.structure.Interface\")) {\n      if (rtSig.equals(SPropertyOperations.getString(ice, \"name\"))) {\n        SNode ct = new QuotationClass_5().createNode(ice);\n        if ((SLinkOperations.getTarget(ft, \"resultType\", true) != null) && !(SNodeOperations.isInstanceOf(SLinkOperations.getTarget(ft, \"resultType\", true), \"jetbrains.mps.baseLanguage.structure.VoidType\"))) {\n          SLinkOperations.addChild(ct, \"parameter\", SNodeOperations.copyNode(SLinkOperations.getTarget(ft, \"resultType\", true)));\n        }\n        for(SNode pt : SLinkOperations.getTargets(ft, \"parameterType\", true)) {\n          SLinkOperations.addChild(ct, \"parameter\", SNodeOperations.copyNode(pt));\n        }\n        supertypes = Collections.singletonList(ct);\n        break;\n      }\n    }\n    return supertypes;\n  }","id":60430,"modified_method":"public List<SNode> getSubOrSuperTypes(SNode ft) {\n    List<SNode> supertypes = Collections.emptyList();\n    String rtSig = \"FunctionTypes.\" + FunctionType_Behavior.call_getRuntimeSignature_1202756382806(ft);\n    List<SNode> interfaces = RulesUtil_Closures.getInterfaces();\n    for(SNode ice : interfaces) {\n      if (rtSig.equals(SPropertyOperations.getString(ice, \"name\"))) {\n        SNode ct = new QuotationClass_4().createNode(ice);\n        if ((SLinkOperations.getTarget(ft, \"resultType\", true) != null) && !(SNodeOperations.isInstanceOf(SLinkOperations.getTarget(ft, \"resultType\", true), \"jetbrains.mps.baseLanguage.structure.VoidType\"))) {\n          SLinkOperations.addChild(ct, \"parameter\", SNodeOperations.copyNode(SLinkOperations.getTarget(ft, \"resultType\", true)));\n        }\n        for(SNode pt : SLinkOperations.getTargets(ft, \"parameterType\", true)) {\n          SLinkOperations.addChild(ct, \"parameter\", SNodeOperations.copyNode(pt));\n        }\n        supertypes = Collections.singletonList(ct);\n        break;\n      }\n    }\n    return supertypes;\n  }","commit_id":"116811aea3c3e115cb9cb01faafa533a2951a846","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode refCell) {\n    if (!(SPropertyOperations.hasValue(SLinkOperations.getTarget(refCell, \"relationDeclaration\", false), \"metaClass\", null, null))) {\n      TypeChecker.getInstance().reportTypeError(refCell, \"reference link expected\", \"jetbrains.mps.bootstrap.editorLanguage.helgins\", \"1180280232711\");\n    }\n  }","id":60431,"modified_method":"public void applyRule(final SNode refCell) {\n    if (!(SPropertyOperations.hasValue(SLinkOperations.getTarget(refCell, \"relationDeclaration\", false), \"metaClass\", \"reference\", \"reference\"))) {\n      TypeChecker.getInstance().reportTypeError(refCell, \"reference link expected\", \"jetbrains.mps.bootstrap.editorLanguage.helgins\", \"1180280232711\");\n    }\n  }","commit_id":"f150e039d18d0696ca318a04008c9bc1548cb442","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode refNodeList) {\n    SNode lnk = SLinkOperations.getTarget(refNodeList, \"relationDeclaration\", false);\n    if (!(SPropertyOperations.hasValue(lnk, \"metaClass\", \"aggregation\", null))) {\n      TypeChecker.getInstance().reportTypeError(refNodeList, \"aggregation link expected\", \"jetbrains.mps.bootstrap.editorLanguage.helgins\", \"1180295464579\");\n    }\n    if (!(SPropertyOperations.hasValue(lnk, \"sourceCardinality\", \"0..n\", \"0..1\") || SPropertyOperations.hasValue(lnk, \"sourceCardinality\", \"1..n\", \"0..1\"))) {\n      TypeChecker.getInstance().reportTypeError(refNodeList, \"multiple cardinality expected\", \"jetbrains.mps.bootstrap.editorLanguage.helgins\", \"1180295464588\");\n    }\n  }","id":60432,"modified_method":"public void applyRule(final SNode refNodeList) {\n    SNode lnk = SLinkOperations.getTarget(refNodeList, \"relationDeclaration\", false);\n    if (!(SPropertyOperations.hasValue(lnk, \"metaClass\", \"aggregation\", \"reference\"))) {\n      TypeChecker.getInstance().reportTypeError(refNodeList, \"aggregation link expected\", \"jetbrains.mps.bootstrap.editorLanguage.helgins\", \"1180295464579\");\n    }\n    if (!(SPropertyOperations.hasValue(lnk, \"sourceCardinality\", \"0..n\", \"0..1\") || SPropertyOperations.hasValue(lnk, \"sourceCardinality\", \"1..n\", \"0..1\"))) {\n      TypeChecker.getInstance().reportTypeError(refNodeList, \"multiple cardinality expected\", \"jetbrains.mps.bootstrap.editorLanguage.helgins\", \"1180295464588\");\n    }\n  }","commit_id":"f150e039d18d0696ca318a04008c9bc1548cb442","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode refNode) {\n    SNode lnk = SLinkOperations.getTarget(refNode, \"relationDeclaration\", false);\n    if (!(SPropertyOperations.hasValue(lnk, \"metaClass\", \"aggregation\", null))) {\n      TypeChecker.getInstance().reportTypeError(refNode, \"aggregation link expected\", \"jetbrains.mps.bootstrap.editorLanguage.helgins\", \"1180280667546\");\n    }\n    if (!(SPropertyOperations.hasValue(lnk, \"sourceCardinality\", \"0..1\", \"0..1\") || SPropertyOperations.hasValue(lnk, \"sourceCardinality\", \"1\", \"0..1\"))) {\n      TypeChecker.getInstance().reportTypeError(refNode, \"single cardinality expected\", \"jetbrains.mps.bootstrap.editorLanguage.helgins\", \"1180280735244\");\n    }\n  }","id":60433,"modified_method":"public void applyRule(final SNode refNode) {\n    SNode lnk = SLinkOperations.getTarget(refNode, \"relationDeclaration\", false);\n    if (!(SPropertyOperations.hasValue(lnk, \"metaClass\", \"aggregation\", \"reference\"))) {\n      TypeChecker.getInstance().reportTypeError(refNode, \"aggregation link expected\", \"jetbrains.mps.bootstrap.editorLanguage.helgins\", \"1180280667546\");\n    }\n    if (!(SPropertyOperations.hasValue(lnk, \"sourceCardinality\", \"0..1\", \"0..1\") || SPropertyOperations.hasValue(lnk, \"sourceCardinality\", \"1\", \"0..1\"))) {\n      TypeChecker.getInstance().reportTypeError(refNode, \"single cardinality expected\", \"jetbrains.mps.bootstrap.editorLanguage.helgins\", \"1180280735244\");\n    }\n  }","commit_id":"f150e039d18d0696ca318a04008c9bc1548cb442","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode node) {\n    SNode hostMenuPart = SNodeOperations.getAncestor(node, \"jetbrains.mps.bootstrap.editorLanguage.structure.CellMenuPart_Abstract\", false, false);\n    SNode editedFeature = CellMenuUtil.getEditedFeature(hostMenuPart);\n    if (SNodeOperations.isInstanceOf(editedFeature, \"jetbrains.mps.bootstrap.structureLanguage.structure.LinkDeclaration\")) {\n      SNode conceptOfChild = SLinkOperations.getTarget(editedFeature, \"target\", false);\n      TypeChecker.getInstance().getRuntimeSupport().givetype(new QuotationClass_3().createNode(conceptOfChild), node, \"jetbrains.mps.bootstrap.editorLanguage.helgins\", \"1179782398208\");\n      return;\n    }\n    TypeChecker.getInstance().reportTypeError(node, \"couldn't define concept of child node\", \"jetbrains.mps.bootstrap.editorLanguage.helgins\", \"1179782438058\");\n    TypeChecker.getInstance().getRuntimeSupport().givetype(new QuotationClass_4().createNode(), node, \"jetbrains.mps.bootstrap.editorLanguage.helgins\", \"1179766709137\");\n  }","id":60434,"modified_method":"public void applyRule(final SNode node) {\n    SNode hostMenuPart = SNodeOperations.getAncestor(node, \"jetbrains.mps.bootstrap.editorLanguage.structure.CellMenuPart_Abstract\", false, false);\n    SNode editedFeature = CellMenuUtil.getEditedFeature(hostMenuPart);\n    if (SNodeOperations.isInstanceOf(editedFeature, \"jetbrains.mps.bootstrap.structureLanguage.structure.LinkDeclaration\")) {\n      SNode conceptOfChild = SLinkOperations.getTarget(editedFeature, \"target\", false);\n      TypeChecker.getInstance().getRuntimeSupport().givetype(new QuotationClass_3().createNode(conceptOfChild), node, \"jetbrains.mps.bootstrap.editorLanguage.helgins\", \"1179782398208\");\n      return;\n    }\n    {\n      BaseIntentionProvider intentionProvider = null;\n      TypeChecker.getInstance().reportTypeError(node, \"couldn't define concept of child node\", \"jetbrains.mps.bootstrap.editorLanguage.helgins\", \"1179782438058\", intentionProvider);\n    }\n    TypeChecker.getInstance().getRuntimeSupport().givetype(new QuotationClass_4().createNode(), node, \"jetbrains.mps.bootstrap.editorLanguage.helgins\", \"1179766709137\");\n  }","commit_id":"f150e039d18d0696ca318a04008c9bc1548cb442","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode nodeToCheck) {\n    TypeChecker.getInstance().getRuntimeSupport().createLessThanInequationStrong(TypeChecker.getInstance().getRuntimeSupport().typeOf(SLinkOperations.getTarget(nodeToCheck, \"editorContext\", true), \"jetbrains.mps.bootstrap.editorLanguage.helgins\", \"1201270098250\", true), new QuotationClass_8().createNode(), SLinkOperations.getTarget(nodeToCheck, \"editorContext\", true), null, \"jetbrains.mps.bootstrap.editorLanguage.helgins\", \"1201270048564\", false);\n  }","id":60435,"modified_method":"public void applyRule(final SNode nodeToCheck) {\n    TypeChecker.getInstance().getRuntimeSupport().createLessThanInequationStrong(TypeChecker.getInstance().getRuntimeSupport().typeOf(SLinkOperations.getTarget(nodeToCheck, \"editorContext\", true), \"jetbrains.mps.bootstrap.editorLanguage.helgins\", \"1201270098250\", true), new QuotationClass_8().createNode(), SLinkOperations.getTarget(nodeToCheck, \"editorContext\", true), null, \"jetbrains.mps.bootstrap.editorLanguage.helgins\", \"1201270048564\", false, 0);\n  }","commit_id":"f150e039d18d0696ca318a04008c9bc1548cb442","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void createEquation(SNode node1, SNode node2, SNode nodeToCheck, String errorString, String ruleModel, String ruleId) {\n    myTypeChecker.getEquationManager().addEquation(node1, node2, new EquationInfo(nodeToCheck, errorString, ruleModel, ruleId));\n  }","id":60436,"modified_method":"public void createEquation(SNode node1, SNode node2, SNode nodeToCheck, String errorString, String ruleModel, String ruleId) {\n    myTypeChecker.getEquationManager().addEquation(node1, node2, new EquationInfo(nodeToCheck, errorString, ruleModel, ruleId, 0));\n  }","commit_id":"398310b4f35a57421e7178929167cc75ab03ae0b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode antiquotation) {\n    SNode annotatedNode = SNodeOperations.getParent(antiquotation, null, false, false);\n    do {\n      SNode matchedNode_1202840723683 = SNodeOperations.getParent(annotatedNode, null, false, false);\n      {\n        boolean matches_1202840723685 = false;\n        matches_1202840723685 = SModelUtil_new.isAssignableConcept(SNodeOperations.getParent(annotatedNode, null, false, false).getConceptFqName(), \"jetbrains.mps.quotation.structure.Quotation\");\n        if(matches_1202840723685) {\n          if(SLinkOperations.getTarget(matchedNode_1202840723683, \"quotedNode\", true) == annotatedNode) {\n            TypeChecker.getInstance().reportTypeError(antiquotation, \"node antiquotation should not be used on a quoted node itself\", \"jetbrains.mps.quotation.helgins\", \"1202840754879\");\n          }\n          break;\n        }\n      }\n    } while(false);\n  }","id":60437,"modified_method":"public void applyRule(final SNode antiquotation) {\n    SNode annotatedNode = SNodeOperations.getParent(antiquotation, null, false, false);\n    do {\n      SNode matchedNode_1202840723683 = SNodeOperations.getParent(annotatedNode, null, false, false);\n      {\n        boolean matches_1202840723685 = false;\n        matches_1202840723685 = SModelUtil_new.isAssignableConcept(SNodeOperations.getParent(annotatedNode, null, false, false).getConceptFqName(), \"jetbrains.mps.quotation.structure.Quotation\");\n        if (matches_1202840723685) {\n          if (SLinkOperations.getTarget(matchedNode_1202840723683, \"quotedNode\", true) == annotatedNode) {\n            {\n              BaseIntentionProvider intentionProvider = null;\n              TypeChecker.getInstance().reportTypeError(antiquotation, \"node antiquotation should not be used on a quoted node itself\", \"jetbrains.mps.quotation.helgins\", \"1202840754879\", intentionProvider);\n            }\n          }\n          break;\n        }\n      }\n    } while(false);\n  }","commit_id":"398310b4f35a57421e7178929167cc75ab03ae0b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode listAntiquotation) {\n    SNode annotatedNode = SNodeOperations.getParent(listAntiquotation, null, false, false);\n    do {\n      SNode matchedNode_1202840835241 = SNodeOperations.getParent(annotatedNode, null, false, false);\n      {\n        boolean matches_1202840835245 = false;\n        matches_1202840835245 = SModelUtil_new.isAssignableConcept(SNodeOperations.getParent(annotatedNode, null, false, false).getConceptFqName(), \"jetbrains.mps.quotation.structure.Quotation\");\n        if(matches_1202840835245) {\n          if(SLinkOperations.getTarget(matchedNode_1202840835241, \"quotedNode\", true) == annotatedNode) {\n            TypeChecker.getInstance().reportTypeError(listAntiquotation, \"list antiquotation should not be used on a quoted node itself\", \"jetbrains.mps.quotation.helgins\", \"1202840835255\");\n          }\n          break;\n        }\n      }\n    } while(false);\n  }","id":60438,"modified_method":"public void applyRule(final SNode listAntiquotation) {\n    SNode annotatedNode = SNodeOperations.getParent(listAntiquotation, null, false, false);\n    do {\n      SNode matchedNode_1202840835241 = SNodeOperations.getParent(annotatedNode, null, false, false);\n      {\n        boolean matches_1202840835245 = false;\n        matches_1202840835245 = SModelUtil_new.isAssignableConcept(SNodeOperations.getParent(annotatedNode, null, false, false).getConceptFqName(), \"jetbrains.mps.quotation.structure.Quotation\");\n        if (matches_1202840835245) {\n          if (SLinkOperations.getTarget(matchedNode_1202840835241, \"quotedNode\", true) == annotatedNode) {\n            {\n              BaseIntentionProvider intentionProvider = null;\n              TypeChecker.getInstance().reportTypeError(listAntiquotation, \"list antiquotation should not be used on a quoted node itself\", \"jetbrains.mps.quotation.helgins\", \"1202840835255\", intentionProvider);\n            }\n          }\n          break;\n        }\n      }\n    } while(false);\n  }","commit_id":"398310b4f35a57421e7178929167cc75ab03ae0b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode nodeToCheck) {\n    TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(TypeChecker.getInstance().getRuntimeSupport().typeOf(SLinkOperations.getTarget(nodeToCheck, \"expression\", true), \"jetbrains.mps.quotation.helgins\", \"1196864206417\", true), new QuotationClass_1().createNode(), SLinkOperations.getTarget(nodeToCheck, \"expression\", true), null, \"jetbrains.mps.quotation.helgins\", \"1196863846268\");\n  }","id":60439,"modified_method":"public void applyRule(final SNode nodeToCheck) {\n    TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(TypeChecker.getInstance().getRuntimeSupport().typeOf(SLinkOperations.getTarget(nodeToCheck, \"expression\", true), \"jetbrains.mps.quotation.helgins\", \"1196864206417\", true), new QuotationClass_1().createNode(), SLinkOperations.getTarget(nodeToCheck, \"expression\", true), null, \"jetbrains.mps.quotation.helgins\", \"1196863846268\", false);\n  }","commit_id":"398310b4f35a57421e7178929167cc75ab03ae0b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode nodeToCheck) {\n    TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(TypeChecker.getInstance().getRuntimeSupport().typeOf(SLinkOperations.getTarget(nodeToCheck, \"expression\", true), \"jetbrains.mps.quotation.helgins\", \"1196864123848\", true), new QuotationClass_3().createNode(), SLinkOperations.getTarget(nodeToCheck, \"expression\", true), null, \"jetbrains.mps.quotation.helgins\", \"1196864131532\");\n  }","id":60440,"modified_method":"public void applyRule(final SNode nodeToCheck) {\n    TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(TypeChecker.getInstance().getRuntimeSupport().typeOf(SLinkOperations.getTarget(nodeToCheck, \"expression\", true), \"jetbrains.mps.quotation.helgins\", \"1196864123848\", true), new QuotationClass_3().createNode(), SLinkOperations.getTarget(nodeToCheck, \"expression\", true), null, \"jetbrains.mps.quotation.helgins\", \"1196864131532\", false);\n  }","commit_id":"398310b4f35a57421e7178929167cc75ab03ae0b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode nodeToCheck) {\n    TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(TypeChecker.getInstance().getRuntimeSupport().typeOf(SLinkOperations.getTarget(nodeToCheck, \"expression\", true), \"jetbrains.mps.quotation.helgins\", \"1196866830959\", true), new QuotationClass_4().createNode(), SLinkOperations.getTarget(nodeToCheck, \"expression\", true), null, \"jetbrains.mps.quotation.helgins\", \"1196866840326\");\n  }","id":60441,"modified_method":"public void applyRule(final SNode nodeToCheck) {\n    TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(TypeChecker.getInstance().getRuntimeSupport().typeOf(SLinkOperations.getTarget(nodeToCheck, \"expression\", true), \"jetbrains.mps.quotation.helgins\", \"1196866830959\", true), new QuotationClass_4().createNode(), SLinkOperations.getTarget(nodeToCheck, \"expression\", true), null, \"jetbrains.mps.quotation.helgins\", \"1196866840326\", false);\n  }","commit_id":"398310b4f35a57421e7178929167cc75ab03ae0b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode nodeToCheck) {\n    TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(TypeChecker.getInstance().getRuntimeSupport().typeOf(SLinkOperations.getTarget(nodeToCheck, \"expression\", true), \"jetbrains.mps.quotation.helgins\", \"1196864100630\", true), new QuotationClass_2().createNode(), SLinkOperations.getTarget(nodeToCheck, \"expression\", true), null, \"jetbrains.mps.quotation.helgins\", \"1196864105033\");\n  }","id":60442,"modified_method":"public void applyRule(final SNode nodeToCheck) {\n    TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(TypeChecker.getInstance().getRuntimeSupport().typeOf(SLinkOperations.getTarget(nodeToCheck, \"expression\", true), \"jetbrains.mps.quotation.helgins\", \"1196864100630\", true), new QuotationClass_2().createNode(), SLinkOperations.getTarget(nodeToCheck, \"expression\", true), null, \"jetbrains.mps.quotation.helgins\", \"1196864105033\", false);\n  }","commit_id":"398310b4f35a57421e7178929167cc75ab03ae0b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static MessageViewTool getMessageViewTool(MPSProject project) {\n    assert project != null;\n    Project ideaProject = project.getComponent(Project.class);\n    assert ideaProject != null;\n    return ideaProject.getComponent(MessageViewTool.class);\n  }","id":60443,"modified_method":"public static MessageViewTool getMessageViewTool(MPSProject project) {\n    return getTool(project, MessageViewTool.class);\n  }","commit_id":"b70375dae95c587174a3929f958ff659ba0e2875","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull ActionContext context) {\n    IOperationContext operationContext = context.getSafe(IOperationContext.class);\n    List<SModelDescriptor> selectedModels = GenerateGroup_autoplan.getModelsToGenerate(context);\n\n    // no multiple input models\n    SModel inputModel = selectedModels.get(0).getSModel();\n\n    List<Generator> generators = GenerationPartitioningUtil.getAllPossiblyEngagedGenerators(inputModel, operationContext.getScope());\n    GenerationPartitioner partitioner = new GenerationPartitioner();\n    List<List<MappingConfiguration>> mappingSets = partitioner.createMappingSets(generators);\n\n    MessageViewTool messageView = MessageViewTool.getMessageViewTool(operationContext.getProject());\n    // print all rules\n    messageView.add(new Message(MessageKind.INFORMATION, \"=================================\"));\n    for (Generator generator : generators) {\n      List<MappingPriorityRule> rules = ((GeneratorDescriptor) generator.getModuleDescriptor()).getPriorityRules();\n      List<String> strings = GenerationPartitioningUtil.toStrings(rules, true);\n      for (String string : strings) {\n        messageView.add(new Message(MessageKind.INFORMATION, \" \" + string));\n      }\n    }\n    messageView.add(new Message(MessageKind.INFORMATION, \"=================================\"));\n    if (partitioner.hasConflictingPriorityRules()) {\n      // message view\n      messageView.showTool(true);\n      List<String> messagesFull = GenerationPartitioningUtil.toStrings(partitioner.getConflictingPriorityRules(), true);\n      for (String message : messagesFull) {\n        messageView.add(new Message(MessageKind.ERROR, \"conflicting rule: \" + message));\n      }\n      messageView.add(new Message(MessageKind.INFORMATION, \"=================================\"));\n\n      IDEProjectFrame frame = context.get(IDEProjectFrame.class);\n      JOptionPane.showMessageDialog(frame.getMainFrame(), \"Conflicting mapping priority rules encountered\", \"Generation plan error\", JOptionPane.WARNING_MESSAGE);\n    }\n\n    // show partitioning\n    String text = \"\";\n    int count = 0;\n    for (List<MappingConfiguration> mappingSet : mappingSets) {\n      text = text + \" [ \" + (count++) + \" ]\\n\";\n      List<String> strings = GenerationPartitioningUtil.toStrings(mappingSet);\n      for (String string : strings) {\n        text = text + \" \" + string + \"\\n\";\n      }\n      text += \"\\n\";\n    }\n    OutputView view = operationContext.getComponent(OutputView.class);\n    view.clear();\n    view.append(\"---------------------  mappings partitioning  -----------------------------------\\n\\n\");\n    view.append(text);\n    view.append(\"---------------------------------------------------------------------------------\\n\");\n    view.activate();\n  }","id":60444,"modified_method":"public void doExecute(@NotNull ActionContext context) {\n    IOperationContext operationContext = context.getSafe(IOperationContext.class);\n    List<SModelDescriptor> selectedModels = GenerateGroup_autoplan.getModelsToGenerate(context);\n\n    // no multiple input models\n    SModel inputModel = selectedModels.get(0).getSModel();\n\n    List<Generator> generators = GenerationPartitioningUtil.getAllPossiblyEngagedGenerators(inputModel, operationContext.getScope());\n    GenerationPartitioner partitioner = new GenerationPartitioner();\n    List<List<MappingConfiguration>> mappingSets = partitioner.createMappingSets(generators);\n\n    MessageViewTool messageView = MessageViewTool.getMessageViewTool(operationContext.getProject());\n    // print all rules\n    messageView.add(new Message(MessageKind.INFORMATION, \"=================================\"));\n    for (Generator generator : generators) {\n      List<MappingPriorityRule> rules = ((GeneratorDescriptor) generator.getModuleDescriptor()).getPriorityRules();\n      List<String> strings = GenerationPartitioningUtil.toStrings(rules, true);\n      for (String string : strings) {\n        messageView.add(new Message(MessageKind.INFORMATION, \" \" + string));\n      }\n    }\n    messageView.add(new Message(MessageKind.INFORMATION, \"=================================\"));\n    if (partitioner.hasConflictingPriorityRules()) {\n      // message view\n      messageView.showTool(true);\n      List<String> messagesFull = GenerationPartitioningUtil.toStrings(partitioner.getConflictingPriorityRules(), true);\n      for (String message : messagesFull) {\n        messageView.add(new Message(MessageKind.ERROR, \"conflicting rule: \" + message));\n      }\n      messageView.add(new Message(MessageKind.INFORMATION, \"=================================\"));\n\n      IDEProjectFrame frame = context.get(IDEProjectFrame.class);\n      JOptionPane.showMessageDialog(frame.getMainFrame(), \"Conflicting mapping priority rules encountered\", \"Generation plan error\", JOptionPane.WARNING_MESSAGE);\n    }\n\n    // show partitioning\n    String text = \"\";\n    int count = 0;\n    for (List<MappingConfiguration> mappingSet : mappingSets) {\n      text = text + \" [ \" + (count++) + \" ]\\n\";\n      List<String> strings = GenerationPartitioningUtil.toStrings(mappingSet);\n      for (String string : strings) {\n        text = text + \" \" + string + \"\\n\";\n      }\n      text += \"\\n\";\n    }\n    OutputViewTool viewTool = OutputViewTool.getOutputViewTool(operationContext.getProject());\n    viewTool.clear();\n    viewTool.append(\"---------------------  mappings partitioning  -----------------------------------\\n\\n\");\n    viewTool.append(text);\n    viewTool.append(\"---------------------------------------------------------------------------------\\n\");\n    viewTool.showTool(true);\n  }","commit_id":"b70375dae95c587174a3929f958ff659ba0e2875","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void showTool() {\n    if (myUsageViewsData.size() > 0) {\n      super.showTool(true);\n    }\n  }","id":60445,"modified_method":"public void showTool(boolean activate) {\n    if (myUsageViewsData.size() > 0) {\n      super.showTool(activate);\n    }\n  }","commit_id":"b70375dae95c587174a3929f958ff659ba0e2875","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void showResults(final SearchResults searchResults, boolean showOne, boolean newTab, IResultProvider provider, SearchQuery query, boolean isRerunnable) {\n    int resCount = searchResults.getSearchResults().size();\n    if (resCount == 0) {\n      ThreadUtils.runInUIThreadNoWait(new Runnable() {\n        public void run() {\n          new HintDialog(getFrame(), \"Not found\", \"No usages for that node\").showDialog();\n        }\n      });\n    } else if (resCount == 1 && !showOne) {\n      SwingUtilities.invokeLater(new Runnable() {\n        public void run() {\n          SNode node = ((SearchResult<SNode>) searchResults.getSearchResults().get(0)).getObject();\n          if (node != null) {\n            NavigationActionProcessor.getInstance().executeNavigationAction(\n              new EditorNavigationCommand(node, null, getMPSProject().getComponent(EditorsPane.class)),\n              getMPSProject(), true);\n          }\n        }\n      });\n    } else {\n      if (!newTab) {\n        if (currentTabIndex() != -1) {\n          closeTab(currentTabIndex());\n        }\n      }\n      UsageViewData usageViewData = new UsageViewData();\n      usageViewData.createUsageView();\n      myUsageViewsData.add(usageViewData);\n\n      myTabbedPane.addTab(\"\", usageViewData.myUsagesView.getComponent());\n      myTabbedPane.setSelectedIndex(myTabbedPane.getTabCount() - 1);\n\n      usageViewData.myUsagesView.setRunOptions(provider, query, new ButtonConfiguration(isRerunnable), searchResults);\n\n      myTabbedPane.setTitleAt(currentTabIndex(), usageViewData.myUsagesView.getCaption());\n      myTabbedPane.setIconAt(currentTabIndex(), usageViewData.myUsagesView.getIcon());\n\n      showTool();\n    }\n  }","id":60446,"modified_method":"private void showResults(final SearchResults searchResults, boolean showOne, boolean newTab, IResultProvider provider, SearchQuery query, boolean isRerunnable) {\n    int resCount = searchResults.getSearchResults().size();\n    if (resCount == 0) {\n      ThreadUtils.runInUIThreadNoWait(new Runnable() {\n        public void run() {\n          new HintDialog(getFrame(), \"Not found\", \"No usages for that node\").showDialog();\n        }\n      });\n    } else if (resCount == 1 && !showOne) {\n      SwingUtilities.invokeLater(new Runnable() {\n        public void run() {\n          SNode node = ((SearchResult<SNode>) searchResults.getSearchResults().get(0)).getObject();\n          if (node != null) {\n            NavigationActionProcessor.getInstance().executeNavigationAction(\n              new EditorNavigationCommand(node, null, getMPSProject().getComponent(EditorsPane.class)),\n              getMPSProject(), true);\n          }\n        }\n      });\n    } else {\n      if (!newTab) {\n        if (currentTabIndex() != -1) {\n          closeTab(currentTabIndex());\n        }\n      }\n      UsageViewData usageViewData = new UsageViewData();\n      usageViewData.createUsageView();\n      myUsageViewsData.add(usageViewData);\n\n      myTabbedPane.addTab(\"\", usageViewData.myUsagesView.getComponent());\n      myTabbedPane.setSelectedIndex(myTabbedPane.getTabCount() - 1);\n\n      usageViewData.myUsagesView.setRunOptions(provider, query, new ButtonConfiguration(isRerunnable), searchResults);\n\n      myTabbedPane.setTitleAt(currentTabIndex(), usageViewData.myUsagesView.getCaption());\n      myTabbedPane.setIconAt(currentTabIndex(), usageViewData.myUsagesView.getIcon());\n\n      showTool(true);\n    }\n  }","commit_id":"b70375dae95c587174a3929f958ff659ba0e2875","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode nodeToCheck) {\n    {\n      final SNode operandType = TypeChecker.getInstance().getRuntimeSupport().typeOf(IOperation_Behavior.call_getOperand_1197028596169(nodeToCheck), \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205921836720\", true);\n      TypeChecker.getInstance().getRuntimeSupport().whenConcrete(operandType, new Runnable() {\n\n        public void run() {\n          {\n            IMatchingPattern pattern_1205921883369 = HUtil.createMatchingPatternByConceptFQName(\"jetbrains.mps.baseLanguage.classifiers.structure.BaseClassifierType\");\n            SNode coercedNode_1205921883368 = TypeChecker.getInstance().getRuntimeSupport().coerce(TypeChecker.getInstance().getEquationManager().getRepresentator(operandType), pattern_1205921883369);\n            if (coercedNode_1205921883368 != null) {\n              if (!(ListSequence.fromList(BaseClassifierType_Behavior.call_getMembers_1205837324654(coercedNode_1205921883368, nodeToCheck)).contains(SLinkOperations.getTarget(nodeToCheck, \"member\", false)))) {\n                TypeChecker.getInstance().reportTypeError(nodeToCheck, \"Declaration is out of scope\", \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205921883388\");\n              }\n            }\n          }\n        }\n\n      }, \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205921833059\");\n    }\n  }","id":60447,"modified_method":"public void applyRule(final SNode nodeToCheck) {\n    {\n      final SNode operandType = TypeChecker.getInstance().getRuntimeSupport().typeOf(IOperation_Behavior.call_getOperand_1197028596169(nodeToCheck), \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205921836720\", true);\n      TypeChecker.getInstance().getRuntimeSupport().whenConcrete(operandType, new Runnable() {\n\n        public void run() {\n          {\n            IMatchingPattern pattern_ = HUtil.createMatchingPatternByConceptFQName(\"jetbrains.mps.baseLanguage.classifiers.structure.BaseClassifierType\");\n            SNode coercedNode_ = TypeChecker.getInstance().getRuntimeSupport().coerce(TypeChecker.getInstance().getEquationManager().getRepresentator(operandType), pattern_);\n            if (coercedNode_ != null) {\n              if (!(ListSequence.fromList(BaseClassifierType_Behavior.call_getMembers_1205837324654(coercedNode_, nodeToCheck)).contains(SLinkOperations.getTarget(nodeToCheck, \"member\", false)))) {\n                {\n                  BaseIntentionProvider intentionProvider = null;\n                  TypeChecker.getInstance().reportTypeError(nodeToCheck, \"Declaration is out of scope\", \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205921883388\", intentionProvider);\n                }\n              }\n            }\n          }\n        }\n\n      }, \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205921833059\");\n    }\n  }","commit_id":"b70375dae95c587174a3929f958ff659ba0e2875","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode nodeToCheck) {\n    TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getRuntimeSupport().typeOf(nodeToCheck, \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205769685435\", true), SLinkOperations.getTarget(SLinkOperations.getTarget(nodeToCheck, \"member\", false), \"returnType\", true), nodeToCheck, null, \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205769679712\");\n    {\n      SNode parameter;\n      SNode argument;\n      Iterator<SNode> parameter_iterator = SLinkOperations.getTargets(SLinkOperations.getTarget(nodeToCheck, \"member\", false), \"parameter\", true).iterator();\n      Iterator<SNode> argument_iterator = SLinkOperations.getTargets(nodeToCheck, \"actualArgument\", true).iterator();\n      while(true) {\n        if (!(parameter_iterator.hasNext())) {\n          break;\n        }\n        if (!(argument_iterator.hasNext())) {\n          break;\n        }\n        parameter = parameter_iterator.next();\n        argument = argument_iterator.next();\n        TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(TypeChecker.getInstance().getRuntimeSupport().typeOf(argument, \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205854575356\", true), SLinkOperations.getTarget(parameter, \"type\", true), argument, null, \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205854571586\", false);\n      }\n    }\n    if (ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(nodeToCheck, \"member\", false), \"parameter\", true)).count() != SLinkOperations.getCount(nodeToCheck, \"actualArgument\")) {\n      TypeChecker.getInstance().reportTypeError(nodeToCheck, \"Number of parameters doesn't match\", \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205854659855\");\n    }\n  }","id":60448,"modified_method":"public void applyRule(final SNode nodeToCheck) {\n    TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getRuntimeSupport().typeOf(nodeToCheck, \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205769685435\", true), SLinkOperations.getTarget(SLinkOperations.getTarget(nodeToCheck, \"member\", false), \"returnType\", true), nodeToCheck, null, \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205769679712\");\n    {\n      SNode parameter;\n      SNode argument;\n      Iterator<SNode> parameter_iterator = SLinkOperations.getTargets(SLinkOperations.getTarget(nodeToCheck, \"member\", false), \"parameter\", true).iterator();\n      Iterator<SNode> argument_iterator = SLinkOperations.getTargets(nodeToCheck, \"actualArgument\", true).iterator();\n      while (true) {\n        if (!(parameter_iterator.hasNext())) {\n          break;\n        }\n        if (!(argument_iterator.hasNext())) {\n          break;\n        }\n        parameter = parameter_iterator.next();\n        argument = argument_iterator.next();\n        TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(TypeChecker.getInstance().getRuntimeSupport().typeOf(argument, \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205854575356\", true), SLinkOperations.getTarget(parameter, \"type\", true), argument, null, \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205854571586\", false);\n      }\n    }\n    if (ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(nodeToCheck, \"member\", false), \"parameter\", true)).count() != SLinkOperations.getCount(nodeToCheck, \"actualArgument\")) {\n      {\n        BaseIntentionProvider intentionProvider = null;\n        TypeChecker.getInstance().reportTypeError(nodeToCheck, \"Number of parameters doesn't match\", \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205854659855\", intentionProvider);\n      }\n    }\n  }","commit_id":"b70375dae95c587174a3929f958ff659ba0e2875","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode nodeToCheck) {\n    SNode classifier = ThisClassifierExpresson_Behavior.call_getClassifier_1205753961441(nodeToCheck);\n    if (classifier != null) {\n      TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getRuntimeSupport().typeOf(nodeToCheck, \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205753197519\", true), IClassifier_Behavior.call_createType_1205753057931(classifier), nodeToCheck, null, \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205753196184\");\n    } else\n    {\n      TypeChecker.getInstance().reportTypeError(nodeToCheck, \"this classifier expression isn't applicable in this place\", \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205753211126\");\n    }\n  }","id":60449,"modified_method":"public void applyRule(final SNode nodeToCheck) {\n    SNode classifier = ThisClassifierExpresson_Behavior.call_getClassifier_1205753961441(nodeToCheck);\n    if (classifier != null) {\n      TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getRuntimeSupport().typeOf(nodeToCheck, \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205753197519\", true), IClassifier_Behavior.call_createType_1205753057931(classifier), nodeToCheck, null, \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205753196184\");\n    } else {\n      {\n        BaseIntentionProvider intentionProvider = null;\n        TypeChecker.getInstance().reportTypeError(nodeToCheck, \"this classifier expression isn't applicable in this place\", \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205753211126\", intentionProvider);\n      }\n    }\n  }","commit_id":"b70375dae95c587174a3929f958ff659ba0e2875","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode nodeToCheck) {\n    List<SNode> methodDeclarations = AbstractConceptDeclaration_Behavior.call_getNotImplementedConceptMethods_1198232898469(SLinkOperations.getTarget(nodeToCheck, \"concept\", false), GlobalScope.getInstance());\n    if (SConceptPropertyOperations.getBoolean(SLinkOperations.getTarget(nodeToCheck, \"concept\", false), \"abstract\")) {\n      return;\n    }\n    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(nodeToCheck, \"concept\", false), \"jetbrains.mps.bootstrap.structureLanguage.structure.InterfaceConceptDeclaration\")) {\n      return;\n    }\n    if (!(ListSequence.fromList(methodDeclarations).isEmpty())) {\n      boolean notImplementedMethods = false;\n      for(SNode cm : methodDeclarations) {\n        if (!(ListSequence.fromList(SLinkOperations.getTargets(nodeToCheck, \"method\", true)).contains(cm))) {\n          notImplementedMethods = true;\n        }\n      }\n      if (notImplementedMethods) {\n        TypeChecker.getInstance().reportTypeError(nodeToCheck, \"Concept \" + SPropertyOperations.getString(SLinkOperations.getTarget(nodeToCheck, \"concept\", false), \"name\") + \" doesn't implement \" + methodDeclarations, \"jetbrains.mps.bootstrap.constraintsLanguage.helgins\", \"1198950378289\");\n      }\n    }\n    for(SNode cmd : SLinkOperations.getTargets(nodeToCheck, \"method\", true)) {\n      if (SConceptPropertyOperations.getBoolean(cmd, \"abstract\")) {\n        TypeChecker.getInstance().reportTypeError(cmd, \"Abstract method in non abstract concept\", \"jetbrains.mps.bootstrap.constraintsLanguage.helgins\", \"1198949983025\");\n      }\n    }\n  }","id":60450,"modified_method":"public void applyRule(final SNode nodeToCheck) {\n    List<SNode> methodDeclarations = AbstractConceptDeclaration_Behavior.call_getNotImplementedConceptMethods_1198232898469(SLinkOperations.getTarget(nodeToCheck, \"concept\", false), GlobalScope.getInstance());\n    if (SConceptPropertyOperations.getBoolean(SLinkOperations.getTarget(nodeToCheck, \"concept\", false), \"abstract\")) {\n      return;\n    }\n    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(nodeToCheck, \"concept\", false), \"jetbrains.mps.bootstrap.structureLanguage.structure.InterfaceConceptDeclaration\")) {\n      return;\n    }\n    if (!(ListSequence.fromList(methodDeclarations).isEmpty())) {\n      boolean notImplementedMethods = false;\n      for(SNode cm : methodDeclarations) {\n        if (!(ListSequence.fromList(SLinkOperations.getTargets(nodeToCheck, \"method\", true)).contains(cm))) {\n          notImplementedMethods = true;\n        }\n      }\n      if (notImplementedMethods) {\n        {\n          BaseIntentionProvider intentionProvider = null;\n          TypeChecker.getInstance().reportTypeError(nodeToCheck, \"Concept \" + SPropertyOperations.getString(SLinkOperations.getTarget(nodeToCheck, \"concept\", false), \"name\") + \" doesn't implement \" + methodDeclarations, \"jetbrains.mps.bootstrap.constraintsLanguage.helgins\", \"1198950378289\", intentionProvider);\n        }\n      }\n    }\n    for(SNode cmd : SLinkOperations.getTargets(nodeToCheck, \"method\", true)) {\n      if (SConceptPropertyOperations.getBoolean(cmd, \"abstract\")) {\n        {\n          BaseIntentionProvider intentionProvider = null;\n          TypeChecker.getInstance().reportTypeError(cmd, \"Abstract method in non abstract concept\", \"jetbrains.mps.bootstrap.constraintsLanguage.helgins\", \"1198949983025\", intentionProvider);\n        }\n      }\n    }\n  }","commit_id":"db23fb68c6338dd554c98893726febd10363524a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Results search(RuleQuery query, QueryOptions options) {\n\n    SearchRequestBuilder esSearch = getClient()\n      .prepareSearch(this.getIndexName())\n      .setIndices(this.getIndexName());\n\n    /* Build main query (search based) */\n    QueryBuilder qb;\n    if (query.getQueryText() != null && !query.getQueryText().isEmpty()) {\n      qb = QueryBuilders.multiMatchQuery(query.getQueryText(),\n        \"_id\",\n        RuleField.NAME.key(),\n        RuleField.NAME.key()+\".search\",\n        RuleField.DESCRIPTION.key(),\n        RuleField.KEY.key(),\n        RuleField.LANGUAGE.key(),\n        RuleField.TAGS.key());\n    } else {\n      qb = QueryBuilders.matchAllQuery();\n    }\n\n    /* Build main filter (match based) */\n    BoolFilterBuilder fb = FilterBuilders.boolFilter();\n    this.addTermFilter(RuleField.LANGUAGE.key(), query.getLanguages(), fb);\n    this.addTermFilter(RuleField.REPOSITORY.key(), query.getRepositories(), fb);\n    this.addTermFilter(RuleField.SEVERITY.key(), query.getSeverities(), fb);\n    this.addTermFilter(RuleField.KEY.key(), query.getKey(), fb);\n\n    /* Integrate Query */\n    QueryBuilder mainQuery;\n    if((query.getLanguages() != null && !query.getLanguages().isEmpty()) ||\n      (query.getRepositories() != null && !query.getRepositories().isEmpty()) ||\n      (query.getSeverities() != null && !query.getSeverities().isEmpty()) ||\n      (query.getKey() != null && !query.getKey().isEmpty())) {\n      mainQuery = QueryBuilders.filteredQuery(qb, fb);\n    } else {\n      mainQuery = qb;\n    }\n    esSearch.setQuery(mainQuery);\n    System.out.println(mainQuery.toString());\n\n    /* integrate Option's Fields */\n    if (options.getFieldsToReturn() != null &&\n      !options.getFieldsToReturn().isEmpty()) {\n      for(String field:options.getFieldsToReturn()) {\n        esSearch.addField(field);\n      }\n    } else {\n      for (RuleField field : RuleField.values()) {\n        esSearch.addField(field.key());\n      }\n    }\n\n\n    /* Get results */\n    SearchResponse esResult = esSearch.get();\n\n    System.out.println(esResult);\n\n    /* Integrate ES Results */\n    Results results = new Results()\n      .setTotal((int) esResult.getHits().totalHits())\n      .setTime(esResult.getTookInMillis())\n      .setHits(this.toHit(esResult.getHits()));\n\n    return results;\n  }","id":60451,"modified_method":"public Results search(RuleQuery query, QueryOptions options) {\n\n    SearchRequestBuilder esSearch = getClient()\n      .prepareSearch(this.getIndexName())\n      .setIndices(this.getIndexName());\n\n    /* Build main query (search based) */\n    QueryBuilder qb;\n    if (query.getQueryText() != null && !query.getQueryText().isEmpty()) {\n      qb = QueryBuilders.multiMatchQuery(query.getQueryText(),\n        \"_id\",\n        RuleField.NAME.key(),\n        RuleField.NAME.key()+\".search\",\n        RuleField.DESCRIPTION.key(),\n        RuleField.KEY.key(),\n        RuleField.LANGUAGE.key(),\n        RuleField.TAGS.key());\n    } else {\n      qb = QueryBuilders.matchAllQuery();\n    }\n\n    /* Build main filter (match based) */\n    BoolFilterBuilder fb = FilterBuilders.boolFilter();\n    this.addTermFilter(RuleField.LANGUAGE.key(), query.getLanguages(), fb);\n    this.addTermFilter(RuleField.REPOSITORY.key(), query.getRepositories(), fb);\n    this.addTermFilter(RuleField.SEVERITY.key(), query.getSeverities(), fb);\n    this.addTermFilter(RuleField.KEY.key(), query.getKey(), fb);\n    if(query.getStatuses() != null && !query.getStatuses().isEmpty()) {\n      Collection<String> stringStatus = new ArrayList<String>();\n      for (RuleStatus status : query.getStatuses()) {\n        stringStatus.add(status.name());\n      }\n      this.addTermFilter(RuleField.STATUS.key(), stringStatus, fb);\n    }\n\n    /* Integrate Query */\n    QueryBuilder mainQuery;\n    if((query.getLanguages() != null && !query.getLanguages().isEmpty()) ||\n      (query.getRepositories() != null && !query.getRepositories().isEmpty()) ||\n      (query.getSeverities() != null && !query.getSeverities().isEmpty()) ||\n      (query.getStatuses() != null && !query.getStatuses().isEmpty()) ||\n      (query.getKey() != null && !query.getKey().isEmpty())) {\n      mainQuery = QueryBuilders.filteredQuery(qb, fb);\n    } else {\n      mainQuery = qb;\n    }\n    esSearch.setQuery(mainQuery);\n    System.out.println(mainQuery.toString());\n\n    /* integrate Option's Fields */\n    if (options.getFieldsToReturn() != null &&\n      !options.getFieldsToReturn().isEmpty()) {\n      for(String field:options.getFieldsToReturn()) {\n        esSearch.addField(field);\n      }\n    } else {\n      for (RuleField field : RuleField.values()) {\n        esSearch.addField(field.key());\n      }\n    }\n\n\n    /* Get results */\n    SearchResponse esResult = esSearch.get();\n\n    System.out.println(esResult);\n\n    /* Integrate ES Results */\n    Results results = new Results()\n      .setTotal((int) esResult.getHits().totalHits())\n      .setTime(esResult.getTookInMillis())\n      .setHits(this.toHit(esResult.getHits()));\n\n    return results;\n  }","commit_id":"25976d11097c4493191c7f03d6dcd25cc426ca8d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  protected XContentBuilder getMapping() throws IOException {\n    XContentBuilder mapping = jsonBuilder().startObject()\n      .startObject(this.getType())\n      .field(\"dynamic\", true)\n      .startObject(\"properties\");\n\n    addMatchField(mapping, RuleField.KEY.key(), \"string\");\n    addMatchField(mapping, RuleField.REPOSITORY.key(), \"string\");\n    addMatchField(mapping, RuleField.SEVERITY.key(), \"string\");\n\n    mapping.startObject(RuleField.NAME.key())\n        .field(\"type\", \"multi_field\")\n        .startObject(\"fields\")\n          .startObject(\"raw\")\n            .field(\"type\", \"string\")\n            .field(\"index\", \"analyzed\")\n          .endObject()\n          .startObject(\"search\")\n            .field(\"type\", \"string\")\n            .field(\"index\", \"analyzed\")\n            .field(\"index_analyzer\", \"rule_name\")\n            .field(\"search_analyzer\", \"standard\")\n          .endObject()\n        .endObject()\n      .endObject();\n\n    mapping.startObject(\"active\")\n      .field(\"type\", \"nested\")\n      .field(\"dynamic\", true)\n      .endObject();\n\n    return mapping.endObject()\n      .endObject().endObject();\n  }","id":60452,"modified_method":"@Override\n  protected XContentBuilder getMapping() throws IOException {\n    XContentBuilder mapping = jsonBuilder().startObject()\n      .startObject(this.getType())\n      .field(\"dynamic\", true)\n      .startObject(\"properties\");\n\n    addMatchField(mapping, RuleField.KEY.key(), \"string\");\n    addMatchField(mapping, RuleField.REPOSITORY.key(), \"string\");\n    addMatchField(mapping, RuleField.SEVERITY.key(), \"string\");\n\n    mapping.startObject(RuleField.NAME.key())\n        .field(\"type\", \"multi_field\")\n        .startObject(\"fields\")\n          .startObject(RuleField.NAME.key())\n            .field(\"type\", \"string\")\n            .field(\"index\", \"analyzed\")\n          .endObject()\n          .startObject(\"search\")\n            .field(\"type\", \"string\")\n            .field(\"index\", \"analyzed\")\n            .field(\"index_analyzer\", \"rule_name\")\n            .field(\"search_analyzer\", \"standard\")\n          .endObject()\n        .endObject()\n      .endObject();\n\n    mapping.startObject(\"active\")\n      .field(\"type\", \"nested\")\n      .field(\"dynamic\", true)\n      .endObject();\n\n    return mapping.endObject()\n      .endObject().endObject();\n  }","commit_id":"25976d11097c4493191c7f03d6dcd25cc426ca8d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  @Ignore\n  public void search_rules_by_any_of_languages() {\n    dao.insert(newRuleDto(RuleKey.of(\"java\", \"S001\"))).setLanguage(\"java\");\n    dao.insert(newRuleDto(RuleKey.of(\"javascript\", \"S002\"))).setLanguage(\"js\");\n    index.refresh();\n\n    RuleQuery query = new RuleQuery().setLanguages(Arrays.asList(\"cobol\", \"js\"));\n    Results results = index.search(query, new QueryOptions());\n    assertThat(results.getHits()).hasSize(1);\n    assertThat(Iterables.getFirst(results.getHits(), null).getFieldAsString(\"key\")).isEqualTo(\"S002\");\n\n    // no results\n    query = new RuleQuery().setLanguages(Arrays.asList(\"cpp\"));\n    assertThat(index.search(query, new QueryOptions()).getHits()).isEmpty();\n\n    // empty list => no filter\n    query = new RuleQuery().setLanguages(Collections.<String>emptyList());\n    assertThat(index.search(query, new QueryOptions()).getHits()).isEmpty();\n\n    // null list => no filter\n    query = new RuleQuery().setLanguages(null);\n    assertThat(index.search(query, new QueryOptions()).getHits()).isEmpty();\n  }","id":60453,"modified_method":"@Test\n  public void search_rules_by_any_of_languages() throws InterruptedException {\n    dao.insert(newRuleDto(RuleKey.of(\"java\", \"S001\")).setLanguage(\"java\"));\n    dao.insert(newRuleDto(RuleKey.of(\"javascript\", \"S002\")).setLanguage(\"js\"));\n    index.refresh();\n\n    RuleQuery query = new RuleQuery().setLanguages(Arrays.asList(\"cobol\", \"js\"));\n    Results results = index.search(query, new QueryOptions());\n    assertThat(results.getHits()).hasSize(1);\n    assertThat(Iterables.getFirst(results.getHits(), null).getFieldAsString(\"key\")).isEqualTo(\"S002\");\n\n    // no results\n    query = new RuleQuery().setLanguages(Arrays.asList(\"cpp\"));\n    assertThat(index.search(query, new QueryOptions()).getHits()).isEmpty();\n\n    // empty list => no filter\n    query = new RuleQuery().setLanguages(Collections.<String>emptyList());\n    assertThat(index.search(query, new QueryOptions()).getHits()).hasSize(2);\n\n    // null list => no filter\n    query = new RuleQuery().setLanguages(null);\n    assertThat(index.search(query, new QueryOptions()).getHits()).hasSize(2);\n  }","commit_id":"25976d11097c4493191c7f03d6dcd25cc426ca8d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  @Ignore\n  public void search_rules_by_any_of_statuses() {\n    dao.insert(newRuleDto(RuleKey.of(\"java\", \"S001\"))).setStatus(RuleStatus.BETA.name());\n    dao.insert(newRuleDto(RuleKey.of(\"java\", \"S002\"))).setStatus(RuleStatus.READY.name());\n    index.refresh();\n\n    RuleQuery query = new RuleQuery().setStatuses(Arrays.asList(RuleStatus.DEPRECATED, RuleStatus.READY));\n    Results results = index.search(query, new QueryOptions());\n    assertThat(results.getHits()).hasSize(1);\n    assertThat(Iterables.getFirst(results.getHits(), null).getFieldAsString(\"key\")).isEqualTo(\"S002\");\n\n    // no results\n    query = new RuleQuery().setStatuses(Arrays.asList(RuleStatus.DEPRECATED));\n    assertThat(index.search(query, new QueryOptions()).getHits()).isEmpty();\n\n    // empty list => no filter\n    query = new RuleQuery().setStatuses(Collections.<RuleStatus>emptyList());\n    assertThat(index.search(query, new QueryOptions()).getHits()).isEmpty();\n\n    // null list => no filter\n    query = new RuleQuery().setStatuses(null);\n    assertThat(index.search(query, new QueryOptions()).getHits()).isEmpty();\n  }","id":60454,"modified_method":"@Test\n  public void search_rules_by_any_of_statuses() throws InterruptedException {\n    dao.insert(newRuleDto(RuleKey.of(\"java\", \"S001\")).setStatus(RuleStatus.BETA.name()));\n    dao.insert(newRuleDto(RuleKey.of(\"java\", \"S002\")).setStatus(RuleStatus.READY.name()));\n    index.refresh();\n\n    RuleQuery query = new RuleQuery().setStatuses(Arrays.asList(RuleStatus.DEPRECATED, RuleStatus.READY));\n    Results results = index.search(query, new QueryOptions());\n    assertThat(results.getHits()).hasSize(1);\n    assertThat(Iterables.getFirst(results.getHits(), null).getFieldAsString(\"key\")).isEqualTo(\"S002\");\n\n    // no results\n    query = new RuleQuery().setStatuses(Arrays.asList(RuleStatus.DEPRECATED));\n    assertThat(index.search(query, new QueryOptions()).getHits()).isEmpty();\n\n    // empty list => no filter\n    query = new RuleQuery().setStatuses(Collections.<RuleStatus>emptyList());\n    assertThat(index.search(query, new QueryOptions()).getHits()).hasSize(2);\n\n    // null list => no filter\n    query = new RuleQuery().setStatuses(null);\n    assertThat(index.search(query, new QueryOptions()).getHits()).hasSize(2);\n  }","commit_id":"25976d11097c4493191c7f03d6dcd25cc426ca8d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  @Ignore\n  public void search_rules_by_any_of_repositories() {\n    dao.insert(newRuleDto(RuleKey.of(\"findbugs\", \"S001\")));\n    dao.insert(newRuleDto(RuleKey.of(\"pmd\", \"S002\")));\n    index.refresh();\n\n    RuleQuery query = new RuleQuery().setRepositories(Arrays.asList(\"checkstyle\", \"pmd\"));\n    Results results = index.search(query, new QueryOptions());\n    assertThat(results.getHits()).hasSize(1);\n    assertThat(Iterables.getFirst(results.getHits(), null).getFieldAsString(\"key\")).isEqualTo(\"S002\");\n\n    // no results\n    query = new RuleQuery().setRepositories(Arrays.asList(\"checkstyle\"));\n    assertThat(index.search(query, new QueryOptions()).getHits()).isEmpty();\n\n    // empty list => no filter\n    query = new RuleQuery().setRepositories(Collections.<String>emptyList());\n    assertThat(index.search(query, new QueryOptions()).getHits()).isEmpty();\n  }","id":60455,"modified_method":"@Test\n  public void search_rules_by_any_of_repositories() {\n    dao.insert(newRuleDto(RuleKey.of(\"findbugs\", \"S001\")));\n    dao.insert(newRuleDto(RuleKey.of(\"pmd\", \"S002\")));\n    index.refresh();\n\n    RuleQuery query = new RuleQuery().setRepositories(Arrays.asList(\"checkstyle\", \"pmd\"));\n    Results results = index.search(query, new QueryOptions());\n    assertThat(results.getHits()).hasSize(1);\n    assertThat(Iterables.getFirst(results.getHits(), null).getFieldAsString(\"key\")).isEqualTo(\"S002\");\n\n    // no results\n    query = new RuleQuery().setRepositories(Arrays.asList(\"checkstyle\"));\n    assertThat(index.search(query, new QueryOptions()).getHits()).isEmpty();\n\n    // empty list => no filter\n    query = new RuleQuery().setRepositories(Collections.<String>emptyList());\n    assertThat(index.search(query, new QueryOptions()).getHits()).hasSize(2);\n  }","commit_id":"25976d11097c4493191c7f03d6dcd25cc426ca8d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  @Ignore\n  public void search_rules_by_any_of_severities() {\n    dao.insert(newRuleDto(RuleKey.of(\"java\", \"S001\"))).setSeverity(Severity.BLOCKER);\n    dao.insert(newRuleDto(RuleKey.of(\"java\", \"S002\"))).setSeverity(Severity.INFO);\n    index.refresh();\n\n    RuleQuery query = new RuleQuery().setSeverities(Arrays.asList(Severity.INFO, Severity.MINOR));\n    Results results = index.search(query, new QueryOptions());\n    assertThat(results.getHits()).hasSize(1);\n    assertThat(Iterables.getFirst(results.getHits(), null).getFieldAsString(\"key\")).isEqualTo(\"S002\");\n\n    // no results\n    query = new RuleQuery().setSeverities(Arrays.asList(Severity.MINOR));\n    assertThat(index.search(query, new QueryOptions()).getHits()).isEmpty();\n\n    // empty list => no filter\n    query = new RuleQuery().setSeverities(Collections.<String>emptyList());\n    assertThat(index.search(query, new QueryOptions()).getHits()).isEmpty();\n\n    // null list => no filter\n    query = new RuleQuery().setSeverities(null);\n    assertThat(index.search(query, new QueryOptions()).getHits()).isEmpty();\n  }","id":60456,"modified_method":"@Test\n  public void search_rules_by_any_of_severities() throws InterruptedException {\n    dao.insert(newRuleDto(RuleKey.of(\"java\", \"S001\")).setSeverity(Severity.BLOCKER));\n    dao.insert(newRuleDto(RuleKey.of(\"java\", \"S002\")).setSeverity(Severity.INFO));\n    index.refresh();\n\n    RuleQuery query = new RuleQuery().setSeverities(Arrays.asList(Severity.INFO, Severity.MINOR));\n    Results results = index.search(query, new QueryOptions());\n    assertThat(results.getHits()).hasSize(1);\n    assertThat(Iterables.getFirst(results.getHits(), null).getFieldAsString(\"key\")).isEqualTo(\"S002\");\n\n    // no results\n    query = new RuleQuery().setSeverities(Arrays.asList(Severity.MINOR));\n    assertThat(index.search(query, new QueryOptions()).getHits()).isEmpty();\n\n    // empty list => no filter\n    query = new RuleQuery().setSeverities(Collections.<String>emptyList());\n    assertThat(index.search(query, new QueryOptions()).getHits()).hasSize(2);\n\n    // null list => no filter\n    query = new RuleQuery().setSeverities(null);\n    assertThat(index.search(query, new QueryOptions()).getHits()).hasSize(2);\n  }","commit_id":"25976d11097c4493191c7f03d6dcd25cc426ca8d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n    public void testCustomScriptBoost() throws Exception {\n        wipeIndices(\"test\");\n        createIndex(\"test\");\n        index(\"test\", \"type1\", \"1\", jsonBuilder().startObject().field(\"test\", \"value beck\").field(\"num1\", 1.0f).endObject());\n        index(\"test\", \"type1\", \"2\", jsonBuilder().startObject().field(\"test\", \"value beck\").field(\"num1\", 2.0f).endObject());\n        refresh();\n\n        logger.info(\"--- QUERY_THEN_FETCH\");\n\n        logger.info(\" --> running doc['num1'].value\");\n        SearchResponse response = client().search(searchRequest()\n                .searchType(SearchType.QUERY_THEN_FETCH)\n                .source(searchSource().explain(true).query(customScoreQuery(termQuery(\"test\", \"value\")).script(\"doc['num1'].value\").lang(\"python\")))\n        ).actionGet();\n\n        assertThat(\"Failures \" + Arrays.toString(response.getShardFailures()), response.getShardFailures().length, equalTo(0));\n\n        assertThat(response.getHits().totalHits(), equalTo(2l));\n        logger.info(\" --> Hit[0] {} Explanation {}\", response.getHits().getAt(0).id(), response.getHits().getAt(0).explanation());\n        logger.info(\" --> Hit[1] {} Explanation {}\", response.getHits().getAt(1).id(), response.getHits().getAt(1).explanation());\n        assertThat(response.getHits().getAt(0).id(), equalTo(\"2\"));\n        assertThat(response.getHits().getAt(1).id(), equalTo(\"1\"));\n\n        logger.info(\" --> running -doc['num1'].value\");\n        response = client().search(searchRequest()\n                .searchType(SearchType.QUERY_THEN_FETCH)\n                .source(searchSource().explain(true).query(customScoreQuery(termQuery(\"test\", \"value\")).script(\"-doc['num1'].value\").lang(\"python\")))\n        ).actionGet();\n\n        assertThat(\"Failures \" + Arrays.toString(response.getShardFailures()), response.getShardFailures().length, equalTo(0));\n\n        assertThat(response.getHits().totalHits(), equalTo(2l));\n        logger.info(\" --> Hit[0] {} Explanation {}\", response.getHits().getAt(0).id(), response.getHits().getAt(0).explanation());\n        logger.info(\" --> Hit[1] {} Explanation {}\", response.getHits().getAt(1).id(), response.getHits().getAt(1).explanation());\n        assertThat(response.getHits().getAt(0).id(), equalTo(\"1\"));\n        assertThat(response.getHits().getAt(1).id(), equalTo(\"2\"));\n\n\n        logger.info(\" --> running doc['num1'].value * _score\");\n        response = client().search(searchRequest()\n                .searchType(SearchType.QUERY_THEN_FETCH)\n                .source(searchSource().explain(true).query(customScoreQuery(termQuery(\"test\", \"value\")).script(\"doc['num1'].value * _score\").lang(\"python\")))\n        ).actionGet();\n\n        assertThat(\"Failures \" + Arrays.toString(response.getShardFailures()), response.getShardFailures().length, equalTo(0));\n\n        assertThat(response.getHits().totalHits(), equalTo(2l));\n        logger.info(\" --> Hit[0] {} Explanation {}\", response.getHits().getAt(0).id(), response.getHits().getAt(0).explanation());\n        logger.info(\" --> Hit[1] {} Explanation {}\", response.getHits().getAt(1).id(), response.getHits().getAt(1).explanation());\n        assertThat(response.getHits().getAt(0).id(), equalTo(\"2\"));\n        assertThat(response.getHits().getAt(1).id(), equalTo(\"1\"));\n\n        logger.info(\" --> running param1 * param2 * _score\");\n        response = client().search(searchRequest()\n                .searchType(SearchType.QUERY_THEN_FETCH)\n                .source(searchSource().explain(true).query(customScoreQuery(termQuery(\"test\", \"value\")).script(\"param1 * param2 * _score\").param(\"param1\", 2).param(\"param2\", 2).lang(\"python\")))\n        ).actionGet();\n\n        assertThat(\"Failures \" + Arrays.toString(response.getShardFailures()), response.getShardFailures().length, equalTo(0));\n\n        assertThat(response.getHits().totalHits(), equalTo(2l));\n        logger.info(\" --> Hit[0] {} Explanation {}\", response.getHits().getAt(0).id(), response.getHits().getAt(0).explanation());\n        logger.info(\" --> Hit[1] {} Explanation {}\", response.getHits().getAt(1).id(), response.getHits().getAt(1).explanation());\n    }","id":60457,"modified_method":"@Test\n    public void testCustomScriptBoost() throws Exception {\n        wipeIndices(\"test\");\n        createIndex(\"test\");\n        index(\"test\", \"type1\", \"1\", jsonBuilder().startObject().field(\"test\", \"value beck\").field(\"num1\", 1.0f).endObject());\n        index(\"test\", \"type1\", \"2\", jsonBuilder().startObject().field(\"test\", \"value beck\").field(\"num1\", 2.0f).endObject());\n        refresh();\n\n        logger.info(\"--- QUERY_THEN_FETCH\");\n\n        logger.info(\" --> running doc['num1'].value\");\n        SearchResponse response = client().search(searchRequest()\n                .searchType(SearchType.QUERY_THEN_FETCH)\n                .source(searchSource().explain(true).query(functionScoreQuery(termQuery(\"test\", \"value\"))\n                        .add(ScoreFunctionBuilders.scriptFunction(\"doc['num1'].value\").lang(\"python\"))))\n        ).actionGet();\n\n        assertThat(\"Failures \" + Arrays.toString(response.getShardFailures()), response.getShardFailures().length, equalTo(0));\n\n        assertThat(response.getHits().totalHits(), equalTo(2l));\n        logger.info(\" --> Hit[0] {} Explanation {}\", response.getHits().getAt(0).id(), response.getHits().getAt(0).explanation());\n        logger.info(\" --> Hit[1] {} Explanation {}\", response.getHits().getAt(1).id(), response.getHits().getAt(1).explanation());\n        assertThat(response.getHits().getAt(0).id(), equalTo(\"2\"));\n        assertThat(response.getHits().getAt(1).id(), equalTo(\"1\"));\n\n        logger.info(\" --> running -doc['num1'].value\");\n        response = client().search(searchRequest()\n                .searchType(SearchType.QUERY_THEN_FETCH)\n                .source(searchSource().explain(true).query(functionScoreQuery(termQuery(\"test\", \"value\"))\n                        .add(ScoreFunctionBuilders.scriptFunction(\"-doc['num1'].value\").lang(\"python\"))))\n        ).actionGet();\n\n        assertThat(\"Failures \" + Arrays.toString(response.getShardFailures()), response.getShardFailures().length, equalTo(0));\n\n        assertThat(response.getHits().totalHits(), equalTo(2l));\n        logger.info(\" --> Hit[0] {} Explanation {}\", response.getHits().getAt(0).id(), response.getHits().getAt(0).explanation());\n        logger.info(\" --> Hit[1] {} Explanation {}\", response.getHits().getAt(1).id(), response.getHits().getAt(1).explanation());\n        assertThat(response.getHits().getAt(0).id(), equalTo(\"1\"));\n        assertThat(response.getHits().getAt(1).id(), equalTo(\"2\"));\n\n\n        logger.info(\" --> running doc['num1'].value * _score\");\n        response = client().search(searchRequest()\n                .searchType(SearchType.QUERY_THEN_FETCH)\n                .source(searchSource().explain(true).query(functionScoreQuery(termQuery(\"test\", \"value\"))\n                        .add(ScoreFunctionBuilders.scriptFunction(\"doc['num1'].value * _score\").lang(\"python\"))))\n        ).actionGet();\n\n        assertThat(\"Failures \" + Arrays.toString(response.getShardFailures()), response.getShardFailures().length, equalTo(0));\n\n        assertThat(response.getHits().totalHits(), equalTo(2l));\n        logger.info(\" --> Hit[0] {} Explanation {}\", response.getHits().getAt(0).id(), response.getHits().getAt(0).explanation());\n        logger.info(\" --> Hit[1] {} Explanation {}\", response.getHits().getAt(1).id(), response.getHits().getAt(1).explanation());\n        assertThat(response.getHits().getAt(0).id(), equalTo(\"2\"));\n        assertThat(response.getHits().getAt(1).id(), equalTo(\"1\"));\n\n        logger.info(\" --> running param1 * param2 * _score\");\n        response = client().search(searchRequest()\n                .searchType(SearchType.QUERY_THEN_FETCH)\n                .source(searchSource().explain(true).query(functionScoreQuery(termQuery(\"test\", \"value\"))\n                        .add(ScoreFunctionBuilders.scriptFunction(\"param1 * param2 * _score\").param(\"param1\", 2).param(\"param2\", 2).lang(\"python\"))))\n        ).actionGet();\n\n        assertThat(\"Failures \" + Arrays.toString(response.getShardFailures()), response.getShardFailures().length, equalTo(0));\n\n        assertThat(response.getHits().totalHits(), equalTo(2l));\n        logger.info(\" --> Hit[0] {} Explanation {}\", response.getHits().getAt(0).id(), response.getHits().getAt(0).explanation());\n        logger.info(\" --> Hit[1] {} Explanation {}\", response.getHits().getAt(1).id(), response.getHits().getAt(1).explanation());\n    }","commit_id":"491e2e3958a0e80a15477b7f0beede49b4055c76","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testScriptFieldUsingSource() throws Exception {\n        wipeIndices(\"test\");\n        createIndex(\"test\");\n        index(\"test\", \"type1\", \"1\",\n                jsonBuilder().startObject()\n                        .startObject(\"obj1\").field(\"test\", \"something\").endObject()\n                        .startObject(\"obj2\").startArray(\"arr2\").value(\"arr_value1\").value(\"arr_value2\").endArray().endObject()\n                        .endObject());\n        refresh();\n\n        SearchResponse response = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addField(\"_source.obj1\") // we also automatically detect _source in fields\n                .addScriptField(\"s_obj1\", \"python\", \"_source['obj1']\", null)\n                .addScriptField(\"s_obj1_test\", \"python\", \"_source['obj1']['test']\", null)\n                .addScriptField(\"s_obj2\", \"python\", \"_source['obj2']\", null)\n                .addScriptField(\"s_obj2_arr2\", \"python\", \"_source['obj2']['arr2']\", null)\n                .execute().actionGet();\n\n        Map<String, Object> sObj1 = (Map<String, Object>) response.getHits().getAt(0).field(\"_source.obj1\").value();\n        assertThat(sObj1.get(\"test\").toString(), equalTo(\"something\"));\n        assertThat(response.getHits().getAt(0).field(\"s_obj1_test\").value().toString(), equalTo(\"something\"));\n\n        sObj1 = (Map<String, Object>) response.getHits().getAt(0).field(\"s_obj1\").value();\n        assertThat(sObj1.get(\"test\").toString(), equalTo(\"something\"));\n        assertThat(response.getHits().getAt(0).field(\"s_obj1_test\").value().toString(), equalTo(\"something\"));\n\n        Map<String, Object> sObj2 = (Map<String, Object>) response.getHits().getAt(0).field(\"s_obj2\").value();\n        List sObj2Arr2 = (List) sObj2.get(\"arr2\");\n        assertThat(sObj2Arr2.size(), equalTo(2));\n        assertThat(sObj2Arr2.get(0).toString(), equalTo(\"arr_value1\"));\n        assertThat(sObj2Arr2.get(1).toString(), equalTo(\"arr_value2\"));\n\n        sObj2Arr2 = (List) response.getHits().getAt(0).field(\"s_obj2_arr2\").value();\n        assertThat(sObj2Arr2.size(), equalTo(2));\n        assertThat(sObj2Arr2.get(0).toString(), equalTo(\"arr_value1\"));\n        assertThat(sObj2Arr2.get(1).toString(), equalTo(\"arr_value2\"));\n    }","id":60458,"modified_method":"@Test\n    public void testScriptFieldUsingSource() throws Exception {\n        wipeIndices(\"test\");\n        createIndex(\"test\");\n        index(\"test\", \"type1\", \"1\",\n                jsonBuilder().startObject()\n                        .startObject(\"obj1\").field(\"test\", \"something\").endObject()\n                        .startObject(\"obj2\").startArray(\"arr2\").value(\"arr_value1\").value(\"arr_value2\").endArray().endObject()\n                        .endObject());\n        refresh();\n\n        SearchResponse response = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addScriptField(\"s_obj1\", \"python\", \"_source['obj1']\", null)\n                .addScriptField(\"s_obj1_test\", \"python\", \"_source['obj1']['test']\", null)\n                .addScriptField(\"s_obj2\", \"python\", \"_source['obj2']\", null)\n                .addScriptField(\"s_obj2_arr2\", \"python\", \"_source['obj2']['arr2']\", null)\n                .execute().actionGet();\n\n        Map<String, Object> sObj1 = (Map<String, Object>) response.getHits().getAt(0).field(\"s_obj1\").value();\n        assertThat(sObj1.get(\"test\").toString(), equalTo(\"something\"));\n        assertThat(response.getHits().getAt(0).field(\"s_obj1_test\").value().toString(), equalTo(\"something\"));\n\n        Map<String, Object> sObj2 = (Map<String, Object>) response.getHits().getAt(0).field(\"s_obj2\").value();\n        List sObj2Arr2 = (List) sObj2.get(\"arr2\");\n        assertThat(sObj2Arr2.size(), equalTo(2));\n        assertThat(sObj2Arr2.get(0).toString(), equalTo(\"arr_value1\"));\n        assertThat(sObj2Arr2.get(1).toString(), equalTo(\"arr_value2\"));\n\n        sObj2Arr2 = (List) response.getHits().getAt(0).field(\"s_obj2_arr2\").value();\n        assertThat(sObj2Arr2.size(), equalTo(2));\n        assertThat(sObj2Arr2.get(0).toString(), equalTo(\"arr_value1\"));\n        assertThat(sObj2Arr2.get(1).toString(), equalTo(\"arr_value2\"));\n    }","commit_id":"491e2e3958a0e80a15477b7f0beede49b4055c76","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testScriptFieldUsingSource() throws Exception {\n        wipeIndices(\"test\");\n        createIndex(\"test\");\n        index(\"test\", \"type1\", \"1\",\n                jsonBuilder().startObject()\n                        .startObject(\"obj1\").field(\"test\", \"something\").endObject()\n                        .startObject(\"obj2\").startArray(\"arr2\").value(\"arr_value1\").value(\"arr_value2\").endArray().endObject()\n                        .endObject());\n        refresh();\n\n        SearchResponse response = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addField(\"_source.obj1\") // we also automatically detect _source in fields\n                .addScriptField(\"s_obj1\", \"js\", \"_source.obj1\", null)\n                .addScriptField(\"s_obj1_test\", \"js\", \"_source.obj1.test\", null)\n                .addScriptField(\"s_obj2\", \"js\", \"_source.obj2\", null)\n                .addScriptField(\"s_obj2_arr2\", \"js\", \"_source.obj2.arr2\", null)\n                .execute().actionGet();\n\n        Map<String, Object> sObj1 = (Map<String, Object>) response.getHits().getAt(0).field(\"_source.obj1\").value();\n        assertThat(sObj1.get(\"test\").toString(), equalTo(\"something\"));\n        assertThat(response.getHits().getAt(0).field(\"s_obj1_test\").value().toString(), equalTo(\"something\"));\n\n        sObj1 = (Map<String, Object>) response.getHits().getAt(0).field(\"s_obj1\").value();\n        assertThat(sObj1.get(\"test\").toString(), equalTo(\"something\"));\n        assertThat(response.getHits().getAt(0).field(\"s_obj1_test\").value().toString(), equalTo(\"something\"));\n\n        Map<String, Object> sObj2 = (Map<String, Object>) response.getHits().getAt(0).field(\"s_obj2\").value();\n        List sObj2Arr2 = (List) sObj2.get(\"arr2\");\n        assertThat(sObj2Arr2.size(), equalTo(2));\n        assertThat(sObj2Arr2.get(0).toString(), equalTo(\"arr_value1\"));\n        assertThat(sObj2Arr2.get(1).toString(), equalTo(\"arr_value2\"));\n\n        sObj2Arr2 = (List) response.getHits().getAt(0).field(\"s_obj2_arr2\").value();\n        assertThat(sObj2Arr2.size(), equalTo(2));\n        assertThat(sObj2Arr2.get(0).toString(), equalTo(\"arr_value1\"));\n        assertThat(sObj2Arr2.get(1).toString(), equalTo(\"arr_value2\"));\n    }","id":60459,"modified_method":"@Test\n    public void testScriptFieldUsingSource() throws Exception {\n        wipeIndices(\"test\");\n        createIndex(\"test\");\n        index(\"test\", \"type1\", \"1\",\n                jsonBuilder().startObject()\n                        .startObject(\"obj1\").field(\"test\", \"something\").endObject()\n                        .startObject(\"obj2\").startArray(\"arr2\").value(\"arr_value1\").value(\"arr_value2\").endArray().endObject()\n                        .endObject());\n        refresh();\n\n        SearchResponse response = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addField(\"_source.obj1\") // we also automatically detect _source in fields\n                .addScriptField(\"s_obj1\", \"js\", \"_source.obj1\", null)\n                .addScriptField(\"s_obj1_test\", \"js\", \"_source.obj1.test\", null)\n                .addScriptField(\"s_obj2\", \"js\", \"_source.obj2\", null)\n                .addScriptField(\"s_obj2_arr2\", \"js\", \"_source.obj2.arr2\", null)\n                .execute().actionGet();\n\n        Map<String, Object> sObj1 = (Map<String, Object>) response.getHits().getAt(0).field(\"s_obj1\").value();\n        assertThat(sObj1.get(\"test\").toString(), equalTo(\"something\"));\n        assertThat(response.getHits().getAt(0).field(\"s_obj1_test\").value().toString(), equalTo(\"something\"));\n\n        Map<String, Object> sObj2 = (Map<String, Object>) response.getHits().getAt(0).field(\"s_obj2\").value();\n        List sObj2Arr2 = (List) sObj2.get(\"arr2\");\n        assertThat(sObj2Arr2.size(), equalTo(2));\n        assertThat(sObj2Arr2.get(0).toString(), equalTo(\"arr_value1\"));\n        assertThat(sObj2Arr2.get(1).toString(), equalTo(\"arr_value2\"));\n\n        sObj2Arr2 = (List) response.getHits().getAt(0).field(\"s_obj2_arr2\").value();\n        assertThat(sObj2Arr2.size(), equalTo(2));\n        assertThat(sObj2Arr2.get(0).toString(), equalTo(\"arr_value1\"));\n        assertThat(sObj2Arr2.get(1).toString(), equalTo(\"arr_value2\"));\n    }","commit_id":"4d90405ba961d6345a7b1a86507438a3244924c3","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testCustomScriptBoost() throws Exception {\n        wipeIndices(\"test\");\n        createIndex(\"test\");\n        index(\"test\", \"type1\", \"1\", jsonBuilder().startObject().field(\"test\", \"value beck\").field(\"num1\", 1.0f).endObject());\n        index(\"test\", \"type1\", \"2\", jsonBuilder().startObject().field(\"test\", \"value beck\").field(\"num1\", 2.0f).endObject());\n        refresh();\n\n        logger.info(\"--- QUERY_THEN_FETCH\");\n\n        logger.info(\" --> running doc['num1'].value\");\n        SearchResponse response = client().search(searchRequest()\n                .searchType(SearchType.QUERY_THEN_FETCH)\n                .source(searchSource().explain(true).query(customScoreQuery(termQuery(\"test\", \"value\")).script(\"doc['num1'].value\").lang(\"js\")))\n        ).actionGet();\n\n        assertThat(\"Failures \" + Arrays.toString(response.getShardFailures()), response.getShardFailures().length, equalTo(0));\n\n        assertThat(response.getHits().totalHits(), equalTo(2l));\n        logger.info(\" --> Hit[0] {} Explanation {}\", response.getHits().getAt(0).id(), response.getHits().getAt(0).explanation());\n        logger.info(\" --> Hit[1] {} Explanation {}\", response.getHits().getAt(1).id(), response.getHits().getAt(1).explanation());\n        assertThat(response.getHits().getAt(0).id(), equalTo(\"2\"));\n        assertThat(response.getHits().getAt(1).id(), equalTo(\"1\"));\n\n        logger.info(\" --> running -doc['num1'].value\");\n        response = client().search(searchRequest()\n                .searchType(SearchType.QUERY_THEN_FETCH)\n                .source(searchSource().explain(true).query(customScoreQuery(termQuery(\"test\", \"value\")).script(\"-doc['num1'].value\").lang(\"js\")))\n        ).actionGet();\n\n        assertThat(\"Failures \" + Arrays.toString(response.getShardFailures()), response.getShardFailures().length, equalTo(0));\n\n        assertThat(response.getHits().totalHits(), equalTo(2l));\n        logger.info(\" --> Hit[0] {} Explanation {}\", response.getHits().getAt(0).id(), response.getHits().getAt(0).explanation());\n        logger.info(\" --> Hit[1] {} Explanation {}\", response.getHits().getAt(1).id(), response.getHits().getAt(1).explanation());\n        assertThat(response.getHits().getAt(0).id(), equalTo(\"1\"));\n        assertThat(response.getHits().getAt(1).id(), equalTo(\"2\"));\n\n\n        logger.info(\" --> running pow(doc['num1'].value, 2)\");\n        response = client().search(searchRequest()\n                .searchType(SearchType.QUERY_THEN_FETCH)\n                .source(searchSource().explain(true).query(customScoreQuery(termQuery(\"test\", \"value\")).script(\"Math.pow(doc['num1'].value, 2)\").lang(\"js\")))\n        ).actionGet();\n\n        assertThat(\"Failures \" + Arrays.toString(response.getShardFailures()), response.getShardFailures().length, equalTo(0));\n\n        assertThat(response.getHits().totalHits(), equalTo(2l));\n        logger.info(\" --> Hit[0] {} Explanation {}\", response.getHits().getAt(0).id(), response.getHits().getAt(0).explanation());\n        logger.info(\" --> Hit[1] {} Explanation {}\", response.getHits().getAt(1).id(), response.getHits().getAt(1).explanation());\n        assertThat(response.getHits().getAt(0).id(), equalTo(\"2\"));\n        assertThat(response.getHits().getAt(1).id(), equalTo(\"1\"));\n\n        logger.info(\" --> running max(doc['num1'].value, 1)\");\n        response = client().search(searchRequest()\n                .searchType(SearchType.QUERY_THEN_FETCH)\n                .source(searchSource().explain(true).query(customScoreQuery(termQuery(\"test\", \"value\")).script(\"Math.max(doc['num1'].value, 1)\").lang(\"js\")))\n        ).actionGet();\n\n        assertThat(\"Failures \" + Arrays.toString(response.getShardFailures()), response.getShardFailures().length, equalTo(0));\n\n        assertThat(response.getHits().totalHits(), equalTo(2l));\n        logger.info(\" --> Hit[0] {} Explanation {}\", response.getHits().getAt(0).id(), response.getHits().getAt(0).explanation());\n        logger.info(\" --> Hit[1] {} Explanation {}\", response.getHits().getAt(1).id(), response.getHits().getAt(1).explanation());\n        assertThat(response.getHits().getAt(0).id(), equalTo(\"2\"));\n        assertThat(response.getHits().getAt(1).id(), equalTo(\"1\"));\n\n        logger.info(\" --> running doc['num1'].value * _score\");\n        response = client().search(searchRequest()\n                .searchType(SearchType.QUERY_THEN_FETCH)\n                .source(searchSource().explain(true).query(customScoreQuery(termQuery(\"test\", \"value\")).script(\"doc['num1'].value * _score\").lang(\"js\")))\n        ).actionGet();\n\n        assertThat(\"Failures \" + Arrays.toString(response.getShardFailures()), response.getShardFailures().length, equalTo(0));\n\n        assertThat(response.getHits().totalHits(), equalTo(2l));\n        logger.info(\" --> Hit[0] {} Explanation {}\", response.getHits().getAt(0).id(), response.getHits().getAt(0).explanation());\n        logger.info(\" --> Hit[1] {} Explanation {}\", response.getHits().getAt(1).id(), response.getHits().getAt(1).explanation());\n        assertThat(response.getHits().getAt(0).id(), equalTo(\"2\"));\n        assertThat(response.getHits().getAt(1).id(), equalTo(\"1\"));\n\n        logger.info(\" --> running param1 * param2 * _score\");\n        response = client().search(searchRequest()\n                .searchType(SearchType.QUERY_THEN_FETCH)\n                .source(searchSource().explain(true).query(customScoreQuery(termQuery(\"test\", \"value\")).script(\"param1 * param2 * _score\").param(\"param1\", 2).param(\"param2\", 2).lang(\"js\")))\n        ).actionGet();\n\n        assertThat(\"Failures \" + Arrays.toString(response.getShardFailures()), response.getShardFailures().length, equalTo(0));\n\n        assertThat(response.getHits().totalHits(), equalTo(2l));\n        logger.info(\" --> Hit[0] {} Explanation {}\", response.getHits().getAt(0).id(), response.getHits().getAt(0).explanation());\n        logger.info(\" --> Hit[1] {} Explanation {}\", response.getHits().getAt(1).id(), response.getHits().getAt(1).explanation());\n    }","id":60460,"modified_method":"@Test\n    public void testCustomScriptBoost() throws Exception {\n        wipeIndices(\"test\");\n        createIndex(\"test\");\n        index(\"test\", \"type1\", \"1\", jsonBuilder().startObject().field(\"test\", \"value beck\").field(\"num1\", 1.0f).endObject());\n        index(\"test\", \"type1\", \"2\", jsonBuilder().startObject().field(\"test\", \"value beck\").field(\"num1\", 2.0f).endObject());\n        refresh();\n\n        logger.info(\"--- QUERY_THEN_FETCH\");\n\n        logger.info(\" --> running doc['num1'].value\");\n        SearchResponse response = client().search(searchRequest()\n                .searchType(SearchType.QUERY_THEN_FETCH)\n                .source(searchSource().explain(true).query(functionScoreQuery(termQuery(\"test\", \"value\"))\n                        .add(ScoreFunctionBuilders.scriptFunction(\"doc['num1'].value\").lang(\"js\"))))\n        ).actionGet();\n\n        assertThat(\"Failures \" + Arrays.toString(response.getShardFailures()), response.getShardFailures().length, equalTo(0));\n\n        assertThat(response.getHits().totalHits(), equalTo(2l));\n        logger.info(\" --> Hit[0] {} Explanation {}\", response.getHits().getAt(0).id(), response.getHits().getAt(0).explanation());\n        logger.info(\" --> Hit[1] {} Explanation {}\", response.getHits().getAt(1).id(), response.getHits().getAt(1).explanation());\n        assertThat(response.getHits().getAt(0).id(), equalTo(\"2\"));\n        assertThat(response.getHits().getAt(1).id(), equalTo(\"1\"));\n\n        logger.info(\" --> running -doc['num1'].value\");\n        response = client().search(searchRequest()\n                .searchType(SearchType.QUERY_THEN_FETCH)\n                .source(searchSource().explain(true).query(functionScoreQuery(termQuery(\"test\", \"value\"))\n                        .add(ScoreFunctionBuilders.scriptFunction(\"-doc['num1'].value\").lang(\"js\"))))\n        ).actionGet();\n\n        assertThat(\"Failures \" + Arrays.toString(response.getShardFailures()), response.getShardFailures().length, equalTo(0));\n\n        assertThat(response.getHits().totalHits(), equalTo(2l));\n        logger.info(\" --> Hit[0] {} Explanation {}\", response.getHits().getAt(0).id(), response.getHits().getAt(0).explanation());\n        logger.info(\" --> Hit[1] {} Explanation {}\", response.getHits().getAt(1).id(), response.getHits().getAt(1).explanation());\n        assertThat(response.getHits().getAt(0).id(), equalTo(\"1\"));\n        assertThat(response.getHits().getAt(1).id(), equalTo(\"2\"));\n\n\n        logger.info(\" --> running pow(doc['num1'].value, 2)\");\n        response = client().search(searchRequest()\n                .searchType(SearchType.QUERY_THEN_FETCH)\n                .source(searchSource().explain(true).query(functionScoreQuery(termQuery(\"test\", \"value\"))\n                        .add(ScoreFunctionBuilders.scriptFunction(\"Math.pow(doc['num1'].value, 2)\").lang(\"js\"))))\n        ).actionGet();\n\n        assertThat(\"Failures \" + Arrays.toString(response.getShardFailures()), response.getShardFailures().length, equalTo(0));\n\n        assertThat(response.getHits().totalHits(), equalTo(2l));\n        logger.info(\" --> Hit[0] {} Explanation {}\", response.getHits().getAt(0).id(), response.getHits().getAt(0).explanation());\n        logger.info(\" --> Hit[1] {} Explanation {}\", response.getHits().getAt(1).id(), response.getHits().getAt(1).explanation());\n        assertThat(response.getHits().getAt(0).id(), equalTo(\"2\"));\n        assertThat(response.getHits().getAt(1).id(), equalTo(\"1\"));\n\n        logger.info(\" --> running max(doc['num1'].value, 1)\");\n        response = client().search(searchRequest()\n                .searchType(SearchType.QUERY_THEN_FETCH)\n                .source(searchSource().explain(true).query(functionScoreQuery(termQuery(\"test\", \"value\"))\n                        .add(ScoreFunctionBuilders.scriptFunction(\"Math.max(doc['num1'].value, 1)\").lang(\"js\"))))\n        ).actionGet();\n\n        assertThat(\"Failures \" + Arrays.toString(response.getShardFailures()), response.getShardFailures().length, equalTo(0));\n\n        assertThat(response.getHits().totalHits(), equalTo(2l));\n        logger.info(\" --> Hit[0] {} Explanation {}\", response.getHits().getAt(0).id(), response.getHits().getAt(0).explanation());\n        logger.info(\" --> Hit[1] {} Explanation {}\", response.getHits().getAt(1).id(), response.getHits().getAt(1).explanation());\n        assertThat(response.getHits().getAt(0).id(), equalTo(\"2\"));\n        assertThat(response.getHits().getAt(1).id(), equalTo(\"1\"));\n\n        logger.info(\" --> running doc['num1'].value * _score\");\n        response = client().search(searchRequest()\n                .searchType(SearchType.QUERY_THEN_FETCH)\n                .source(searchSource().explain(true).query(functionScoreQuery(termQuery(\"test\", \"value\"))\n                        .add(ScoreFunctionBuilders.scriptFunction(\"doc['num1'].value * _score\").lang(\"js\"))))\n        ).actionGet();\n\n        assertThat(\"Failures \" + Arrays.toString(response.getShardFailures()), response.getShardFailures().length, equalTo(0));\n\n        assertThat(response.getHits().totalHits(), equalTo(2l));\n        logger.info(\" --> Hit[0] {} Explanation {}\", response.getHits().getAt(0).id(), response.getHits().getAt(0).explanation());\n        logger.info(\" --> Hit[1] {} Explanation {}\", response.getHits().getAt(1).id(), response.getHits().getAt(1).explanation());\n        assertThat(response.getHits().getAt(0).id(), equalTo(\"2\"));\n        assertThat(response.getHits().getAt(1).id(), equalTo(\"1\"));\n\n        logger.info(\" --> running param1 * param2 * _score\");\n        response = client().search(searchRequest()\n                .searchType(SearchType.QUERY_THEN_FETCH)\n                .source(searchSource().explain(true).query(functionScoreQuery(termQuery(\"test\", \"value\"))\n                        .add(ScoreFunctionBuilders.scriptFunction(\"param1 * param2 * _score\").param(\"param1\", 2).param(\"param2\", 2).lang(\"js\"))))\n        ).actionGet();\n\n        assertThat(\"Failures \" + Arrays.toString(response.getShardFailures()), response.getShardFailures().length, equalTo(0));\n\n        assertThat(response.getHits().totalHits(), equalTo(2l));\n        logger.info(\" --> Hit[0] {} Explanation {}\", response.getHits().getAt(0).id(), response.getHits().getAt(0).explanation());\n        logger.info(\" --> Hit[1] {} Explanation {}\", response.getHits().getAt(1).id(), response.getHits().getAt(1).explanation());\n    }","commit_id":"4d90405ba961d6345a7b1a86507438a3244924c3","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public Connection newConnection(Connector connector, EndPoint endPoint)\n    {\n        List<String> negotiated = this.negotiatedProtocols;\n        if (negotiated.isEmpty())\n        {\n            // Generate list of protocols that we can negotiate\n            negotiated = connector.getProtocols().stream()\n            .map(p->connector.getConnectionFactory(p))\n            .filter(f->!(f instanceof SslConnectionFactory)&&!(f instanceof NegotiatingServerConnectionFactory))\n            .map(p->p.getProtocol())\n            .collect(Collectors.toList());\n        }\n\n        // if default protocol is not set, then it is either HTTP/1.1 or \n        // the first protocol given\n        String dft = defaultProtocol;\n        if (dft == null && !negotiated.isEmpty())\n        {\n            if (negotiated.contains(HttpVersion.HTTP_1_1.asString()))\n                dft = HttpVersion.HTTP_1_1.asString();\n            else\n                dft = negotiated.get(0);\n        }\n\n        SSLEngine engine = null;\n        EndPoint ep = endPoint;\n        while (engine == null && ep != null)\n        {\n            // TODO make more generic\n            if (ep instanceof SslConnection.DecryptedEndPoint)\n                engine = ((SslConnection.DecryptedEndPoint)ep).getSslConnection().getSSLEngine();\n            else\n                ep = null;\n        }\n\n        return configure(newServerConnection(connector, endPoint, engine, negotiated, dft), connector, endPoint);\n    }","id":60461,"modified_method":"@Override\n    public Connection newConnection(Connector connector, EndPoint endPoint)\n    {\n        List<String> negotiated = this.negotiatedProtocols;\n        if (negotiated.isEmpty())\n        {\n            // Generate list of protocols that we can negotiate\n            negotiated = connector.getProtocols().stream()\n            .filter(p->\n            {\n                ConnectionFactory f=connector.getConnectionFactory(p);\n                return !(f instanceof SslConnectionFactory)&&!(f instanceof NegotiatingServerConnectionFactory);\n            })\n            .collect(Collectors.toList());            \n        }\n\n        // if default protocol is not set, then it is either HTTP/1.1 or \n        // the first protocol given\n        String dft = defaultProtocol;\n        if (dft == null && !negotiated.isEmpty())\n        {\n            if (negotiated.contains(HttpVersion.HTTP_1_1.asString()))\n                dft = HttpVersion.HTTP_1_1.asString();\n            else\n                dft = negotiated.get(0);\n        }\n\n        SSLEngine engine = null;\n        EndPoint ep = endPoint;\n        while (engine == null && ep != null)\n        {\n            // TODO make more generic\n            if (ep instanceof SslConnection.DecryptedEndPoint)\n                engine = ((SslConnection.DecryptedEndPoint)ep).getSslConnection().getSSLEngine();\n            else\n                ep = null;\n        }\n\n        return configure(newServerConnection(connector, endPoint, engine, negotiated, dft), connector, endPoint);\n    }","commit_id":"5718726a8c7ed7cf85d65d4d199ffb46eaa12131","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n\tpublic List<StagedModel> fetchChildrenStagedModels(\n\t\tPortletDataContext portletDataContext,\n\t\tBookmarksFolder bookmarksFolder) {\n\n\t\tList<BookmarksEntry> bookmarksEntries =\n\t\t\t_bookmarksEntryLocalService.getEntries(\n\t\t\t\tbookmarksFolder.getGroupId(), bookmarksFolder.getFolderId(),\n\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\tStream<StagedModel> mappedStream = bookmarksEntries.stream().map(\n\t\t\t(bookmarksEntry) -> (StagedModel)bookmarksEntry);\n\n\t\treturn mappedStream.collect(Collectors.toList());\n\t}","id":60462,"modified_method":"@Override\n\tpublic List<StagedModel> fetchChildrenStagedModels(\n\t\tPortletDataContext portletDataContext,\n\t\tBookmarksFolder bookmarksFolder) {\n\n\t\tList<BookmarksEntry> bookmarksEntries =\n\t\t\t_bookmarksEntryLocalService.getEntries(\n\t\t\t\tbookmarksFolder.getGroupId(), bookmarksFolder.getFolderId(),\n\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\tStream<BookmarksEntry> bookmarksEntriesStream =\n\t\t\tbookmarksEntries.stream();\n\n\t\tStream<StagedModel> stagedModelsStream = bookmarksEntriesStream.map(\n\t\t\t(bookmarksEntry) -> (StagedModel)bookmarksEntry);\n\n\t\treturn stagedModelsStream.collect(Collectors.toList());\n\t}","commit_id":"5b30c4d8a14e0b7c68d35c641f352794e053d00b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<StagedModel> fetchChildrenStagedModels(\n\t\tPortletDataContext portletDataContext, DDLRecordSet ddlRecordSet) {\n\n\t\tList<DDLRecord> ddlRecords = ddlRecordSet.getRecords();\n\n\t\tStream<StagedModel> mappedStream = ddlRecords.stream().map(\n\t\t\t(ddlRecord) -> (StagedModel)ddlRecord);\n\n\t\treturn mappedStream.collect(Collectors.toList());\n\t}","id":60463,"modified_method":"public List<StagedModel> fetchChildrenStagedModels(\n\t\tPortletDataContext portletDataContext, DDLRecordSet ddlRecordSet) {\n\n\t\tList<DDLRecord> ddlRecords = ddlRecordSet.getRecords();\n\n\t\tStream<DDLRecord> ddlRecordsStream = ddlRecords.stream();\n\n\t\tStream<StagedModel> stagedModelsStream = ddlRecordsStream.map(\n\t\t\t(ddlRecord) -> (StagedModel)ddlRecord);\n\n\t\treturn stagedModelsStream.collect(Collectors.toList());\n\t}","commit_id":"5b30c4d8a14e0b7c68d35c641f352794e053d00b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public <S extends StagedModel, T extends Serializable> boolean\n\t\tvalidateContentReferences(\n\t\t\tClass<S> stagedModelClass, long groupId, T content) {\n\n\t\tList<ExportImportContentProcessor<?, ?>> exportImportContentProcessors =\n\t\t\tExportImportContentProcessorRegistryUtil.\n\t\t\t\tgetExportImportContentProcessors(stagedModelClass.getName());\n\n\t\treturn exportImportContentProcessors.stream().map(\n\t\t\tthis::_castExportImportContentProcessor).filter(\n\t\t\t\tObjects::nonNull).allMatch(\n\t\t\t\t\teicp -> eicp.validateContentReferences(groupId, content));\n\t}","id":60464,"modified_method":"public <S extends StagedModel, T extends Serializable> boolean\n\t\tvalidateContentReferences(\n\t\t\tClass<S> stagedModelClass, long groupId, T content) {\n\n\t\tList<ExportImportContentProcessor<?, ?>> exportImportContentProcessors =\n\t\t\tExportImportContentProcessorRegistryUtil.\n\t\t\t\tgetExportImportContentProcessors(stagedModelClass.getName());\n\n\t\tStream<ExportImportContentProcessor<?, ?>>\n\t\t\texportImportContentProcessorsStream =\n\t\t\t\texportImportContentProcessors.stream();\n\n\t\treturn exportImportContentProcessorsStream.map(this::_castExportImportContentProcessor).filter(Objects::nonNull).allMatch(eicp -> eicp.validateContentReferences(groupId, content));\n\t}","commit_id":"5b30c4d8a14e0b7c68d35c641f352794e053d00b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<StagedModel> fetchChildrenStagedModels(\n\t\tPortletDataContext portletDataContext,\n\t\tStagedLayoutSet stagedLayoutSet) {\n\n\t\tList<Layout> layouts = _layoutLocalService.getLayouts(\n\t\t\tstagedLayoutSet.getGroupId(), stagedLayoutSet.isPrivateLayout());\n\n\t\tlong[] layoutIds = portletDataContext.getLayoutIds();\n\n\t\treturn layouts.stream().filter(\n\t\t\t(layout) -> ArrayUtil.contains(layoutIds, layout.getLayoutId())).\n\t\t\t\tcollect(Collectors.toList());\n\t}","id":60465,"modified_method":"public List<StagedModel> fetchChildrenStagedModels(\n\t\tPortletDataContext portletDataContext,\n\t\tStagedLayoutSet stagedLayoutSet) {\n\n\t\tList<Layout> layouts = _layoutLocalService.getLayouts(\n\t\t\tstagedLayoutSet.getGroupId(), stagedLayoutSet.isPrivateLayout());\n\n\t\tlong[] layoutIds = portletDataContext.getLayoutIds();\n\n\t\tStream<Layout> layoutsStream = layouts.stream();\n\n\t\treturn layoutsStream.filter(\n\t\t\t(layout) -> ArrayUtil.contains(layoutIds, layout.getLayoutId())).collect(Collectors.toList());\n\t}","commit_id":"5b30c4d8a14e0b7c68d35c641f352794e053d00b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<StagedLayoutSet> fetchStagedModelsByUuidAndCompanyId(\n\t\tString uuid, long companyId) {\n\n\t\tboolean privateLayout = GetterUtil.getBoolean(uuid);\n\n\t\tDynamicQuery dynamicQuery = _layoutSetLocalService.dynamicQuery();\n\n\t\tProperty companyIdProperty = PropertyFactoryUtil.forName(\"companyId\");\n\n\t\tdynamicQuery.add(companyIdProperty.eq(companyId));\n\n\t\tProperty privateLayoutProperty = PropertyFactoryUtil.forName(\n\t\t\t\"privateLayout\");\n\n\t\tdynamicQuery.add(privateLayoutProperty.eq(privateLayout));\n\n\t\tList<LayoutSet> companyLayoutSets = dynamicQuery.list();\n\n\t\tStream<StagedLayoutSet> mappedStream = companyLayoutSets.stream().map(\n\t\t\t(layoutSet) ->\n\t\t\t\tModelAdapterUtil.adapt(\n\t\t\t\t\tlayoutSet, LayoutSet.class, StagedLayoutSet.class));\n\n\t\treturn mappedStream.collect(Collectors.toList());\n\t}","id":60466,"modified_method":"public List<StagedLayoutSet> fetchStagedModelsByUuidAndCompanyId(\n\t\tString uuid, long companyId) {\n\n\t\tboolean privateLayout = GetterUtil.getBoolean(uuid);\n\n\t\tDynamicQuery dynamicQuery = _layoutSetLocalService.dynamicQuery();\n\n\t\tProperty companyIdProperty = PropertyFactoryUtil.forName(\"companyId\");\n\n\t\tdynamicQuery.add(companyIdProperty.eq(companyId));\n\n\t\tProperty privateLayoutProperty = PropertyFactoryUtil.forName(\n\t\t\t\"privateLayout\");\n\n\t\tdynamicQuery.add(privateLayoutProperty.eq(privateLayout));\n\n\t\tList<LayoutSet> layoutSets = dynamicQuery.list();\n\n\t\tStream<LayoutSet> layoutSetsStream = layoutSets.stream();\n\n\t\tStream<StagedLayoutSet> stagedLayoutSetsStream = layoutSetsStream.map(\n\t\t\t(layoutSet) ->\n\t\t\t\tModelAdapterUtil.adapt(\n\t\t\t\t\tlayoutSet, LayoutSet.class, StagedLayoutSet.class));\n\n\t\treturn stagedLayoutSetsStream.collect(Collectors.toList());\n\t}","commit_id":"5b30c4d8a14e0b7c68d35c641f352794e053d00b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private int calculateAllFilesCount() {\n    return getSubOperations().stream().map(cvsOperation -> (AddFileOperation)cvsOperation)\n      .mapToInt(CvsOperationOnFiles::getFilesCount).sum();\n  }","id":60467,"modified_method":"private int calculateAllFilesCount() {\n    return getSubOperations().stream().mapToInt(cvsOperation -> ((AddFileOperation)cvsOperation).getFilesCount()).sum();\n  }","commit_id":"bcc0990204a55ff5cb64803206ff2588ef27402a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Prepare to send an outbound HTTP message over this http conduit to a \n     * particular endpoint.\n     * <P>\n     * If the Message.PATH_INFO property is set it gets appended\n     * to the Conduit's endpoint URL. If the Message.QUERY_STRING\n     * property is set, it gets appended to the resultant URL following\n     * a \"?\".\n     * <P>\n     * If the Message.HTTP_REQUEST_METHOD property is NOT set, the\n     * Http request method defaults to \"POST\".\n     * <P>\n     * If the Message.PROTOCOL_HEADERS is not set on the message, it is\n     * initialized to an empty map.\n     * <P>\n     * This call creates the OutputStream for the content of the message.\n     * It also assigns the created Http(s)URLConnection to the Message\n     * Map.\n     * \n     * @param message The message to be sent.\n     */\n    public void prepare(Message message) throws IOException {\n        Map<String, List<String>> headers = getSetProtocolHeaders(message);\n        \n        // This call can possibly change the conduit endpoint address and \n        // protocol from the default set in EndpointInfo that is associated\n        // with the Conduit.\n        URL currentURL = setupURL(message);       \n        \n        HttpBasicAuthSupplier.UserPass userPass = null;\n        \n        // The need to cache the request is off by default\n        boolean needToCacheRequest = false;\n        \n        HttpURLConnection connection = \n            connectionFactory.createConnection(\n                      getProxy(clientSidePolicy), currentURL);\n        connection.setDoOutput(true);  \n        \n        //TODO using Message context to decided HTTP send properties \n             \n        connection.setConnectTimeout((int)clientSidePolicy.getConnectionTimeout());\n        connection.setReadTimeout((int)clientSidePolicy.getReceiveTimeout());\n        connection.setUseCaches(false);\n        // We implement redirects in this conduit. We do not\n        // rely on the underlying URLConnection implementation\n        // because of trust issues.\n        connection.setInstanceFollowRedirects(false);\n        \n        // If the HTTP_REQUEST_METHOD is not set, the default is \"POST\".\n        String httpRequestMethod = \n            (String)message.get(Message.HTTP_REQUEST_METHOD);        \n\n        if (null != httpRequestMethod) {\n            connection.setRequestMethod(httpRequestMethod);\n        } else {\n            connection.setRequestMethod(\"POST\");\n        }\n        \n        boolean isChunking = false;\n        // We must cache the request if we have basic auth supplier\n        // without preemptive basic auth.\n        if (basicAuthSupplier != null) {\n            userPass = basicAuthSupplier.getPreemptiveUserPass(\n                    getConduitName(), currentURL, message);\n            needToCacheRequest = userPass == null;\n            LOG.log(Level.INFO,\n                \"Basic Auth Supplier, but no Premeptive User Pass.\" \n                + \" We must cache request.\");\n        }\n        if (getClient().isAutoRedirect()) {\n            // If the AutoRedirect property is set then we cannot\n            // use chunked streaming mode. We ignore the \"AllowChunking\" \n            // property if AutoRedirect is turned on.\n            \n            needToCacheRequest = true;\n            LOG.log(Level.INFO, \"AutoRedirect is turned on.\");\n        } else {\n            if (!connection.getRequestMethod().equals(\"GET\")\n                && getClient().isAllowChunking()\n                && !needToCacheRequest) {\n                //TODO: The chunking mode be configured or at least some\n                // documented client constant.\n                //use -1 and allow the URL connection to pick a default value\n                connection.setChunkedStreamingMode(-1);\n                isChunking = true;\n            }\n        }\n        \n        //Do we need to maintain a session?\n        maintainSession = Boolean.TRUE.equals((Boolean)message.get(Message.MAINTAIN_SESSION));\n        \n        //If we have any cookies and we are maintaining sessions, then use them\n        if (maintainSession && sessionCookies.size() > 0) {\n            for (Cookie c : sessionCookies.values()) {\n                connection.addRequestProperty(HttpHeaderHelper.COOKIE, \n                                              c.requestCookieHeader());\n            }\n        }\n\n        // The trust decision is relegated to after the \"flushing\" of the\n        // request headers.\n        \n        // We place the connection on the message to pick it up\n        // in the WrappedOutputStream.\n        \n        message.put(KEY_HTTP_CONNECTION, connection);\n        \n        // Set the headers on the message according to configured \n        // client side policy.\n        \n        setHeadersByPolicy(message, currentURL, headers);\n     \n        \n        message.setContent(OutputStream.class,\n                new WrappedOutputStream(\n                        message, connection,\n                        needToCacheRequest, isChunking));\n        \n        // We are now \"ready\" to \"send\" the message. \n    }","id":60468,"modified_method":"/**\n     * Prepare to send an outbound HTTP message over this http conduit to a \n     * particular endpoint.\n     * <P>\n     * If the Message.PATH_INFO property is set it gets appended\n     * to the Conduit's endpoint URL. If the Message.QUERY_STRING\n     * property is set, it gets appended to the resultant URL following\n     * a \"?\".\n     * <P>\n     * If the Message.HTTP_REQUEST_METHOD property is NOT set, the\n     * Http request method defaults to \"POST\".\n     * <P>\n     * If the Message.PROTOCOL_HEADERS is not set on the message, it is\n     * initialized to an empty map.\n     * <P>\n     * This call creates the OutputStream for the content of the message.\n     * It also assigns the created Http(s)URLConnection to the Message\n     * Map.\n     * \n     * @param message The message to be sent.\n     */\n    public void prepare(Message message) throws IOException {\n        Map<String, List<String>> headers = getSetProtocolHeaders(message);\n        \n        // This call can possibly change the conduit endpoint address and \n        // protocol from the default set in EndpointInfo that is associated\n        // with the Conduit.\n        URL currentURL = setupURL(message);       \n        \n        HttpBasicAuthSupplier.UserPass userPass = null;\n        \n        // The need to cache the request is off by default\n        boolean needToCacheRequest = false;\n        \n        HttpURLConnection connection = \n            connectionFactory.createConnection(\n                      getProxy(clientSidePolicy), currentURL);\n        connection.setDoOutput(true);  \n        \n        //TODO using Message context to decided HTTP send properties \n             \n        long timeout = clientSidePolicy.getConnectionTimeout();\n        if (timeout > Integer.MAX_VALUE) {\n            timeout = Integer.MAX_VALUE;\n        }\n        connection.setConnectTimeout((int)timeout);\n        timeout = clientSidePolicy.getReceiveTimeout();\n        if (timeout > Integer.MAX_VALUE) {\n            timeout = Integer.MAX_VALUE;\n        }\n        connection.setReadTimeout((int)timeout);\n        connection.setUseCaches(false);\n        // We implement redirects in this conduit. We do not\n        // rely on the underlying URLConnection implementation\n        // because of trust issues.\n        connection.setInstanceFollowRedirects(false);\n        \n        // If the HTTP_REQUEST_METHOD is not set, the default is \"POST\".\n        String httpRequestMethod = \n            (String)message.get(Message.HTTP_REQUEST_METHOD);        \n\n        if (null != httpRequestMethod) {\n            connection.setRequestMethod(httpRequestMethod);\n        } else {\n            connection.setRequestMethod(\"POST\");\n        }\n        \n        boolean isChunking = false;\n        // We must cache the request if we have basic auth supplier\n        // without preemptive basic auth.\n        if (basicAuthSupplier != null) {\n            userPass = basicAuthSupplier.getPreemptiveUserPass(\n                    getConduitName(), currentURL, message);\n            needToCacheRequest = userPass == null;\n            LOG.log(Level.INFO,\n                \"Basic Auth Supplier, but no Premeptive User Pass.\" \n                + \" We must cache request.\");\n        }\n        if (getClient().isAutoRedirect()) {\n            // If the AutoRedirect property is set then we cannot\n            // use chunked streaming mode. We ignore the \"AllowChunking\" \n            // property if AutoRedirect is turned on.\n            \n            needToCacheRequest = true;\n            LOG.log(Level.INFO, \"AutoRedirect is turned on.\");\n        } else {\n            if (!connection.getRequestMethod().equals(\"GET\")\n                && getClient().isAllowChunking()\n                && !needToCacheRequest) {\n                //TODO: The chunking mode be configured or at least some\n                // documented client constant.\n                //use -1 and allow the URL connection to pick a default value\n                connection.setChunkedStreamingMode(-1);\n                isChunking = true;\n            }\n        }\n        \n        //Do we need to maintain a session?\n        maintainSession = Boolean.TRUE.equals((Boolean)message.get(Message.MAINTAIN_SESSION));\n        \n        //If we have any cookies and we are maintaining sessions, then use them\n        if (maintainSession && sessionCookies.size() > 0) {\n            for (Cookie c : sessionCookies.values()) {\n                connection.addRequestProperty(HttpHeaderHelper.COOKIE, \n                                              c.requestCookieHeader());\n            }\n        }\n\n        // The trust decision is relegated to after the \"flushing\" of the\n        // request headers.\n        \n        // We place the connection on the message to pick it up\n        // in the WrappedOutputStream.\n        \n        message.put(KEY_HTTP_CONNECTION, connection);\n        \n        // Set the headers on the message according to configured \n        // client side policy.\n        \n        setHeadersByPolicy(message, currentURL, headers);\n     \n        \n        message.setContent(OutputStream.class,\n                new WrappedOutputStream(\n                        message, connection,\n                        needToCacheRequest, isChunking));\n        \n        // We are now \"ready\" to \"send\" the message. \n    }","commit_id":"8e3d64c04598dc1899dda0dbd0a0b014f8b447fc","url":"https://github.com/apache/cxf"},{"original_method":"public Connection connectSync(CallbackHandler handler, Map<String, String> saslOptions) throws IOException {\n        final IoFuture<Connection> future = connect(handler, saslOptions);\n        final IoFuture.Status status = future.await(configuration.getConnectionTimeout(), TimeUnit.MILLISECONDS);\n        if(status == IoFuture.Status.DONE) {\n            return future.get();\n        }\n        if (status == IoFuture.Status.FAILED) {\n            throw ProtocolMessages.MESSAGES.failedToConnect(uri, future.getException());\n        }\n        throw ProtocolMessages.MESSAGES.couldNotConnect(uri);\n    }","id":60469,"modified_method":"public Connection connectSync(CallbackHandler handler, Map<String, String> saslOptions) throws IOException {\n        WrapperCallbackHandler wrapperHandler = new WrapperCallbackHandler(handler);\n        final IoFuture<Connection> future = connect(wrapperHandler, saslOptions);\n        long timeoutMillis = configuration.getConnectionTimeout();\n        IoFuture.Status status = future.await(timeoutMillis, TimeUnit.MILLISECONDS);\n        while (status == IoFuture.Status.WAITING) {\n            if (wrapperHandler.isInCall()) {\n                // If there is currently an interaction with the user just wait again.\n                status = future.await(timeoutMillis, TimeUnit.MILLISECONDS);\n            } else {\n                long lastInteraction = wrapperHandler.getCallFinished();\n                if (lastInteraction > 0) {\n                    long now = System.currentTimeMillis();\n                    long timeSinceLast = now - lastInteraction;\n                    if (timeSinceLast < timeoutMillis) {\n                        // As this point we are setting the timeout based on the time of the last interaction\n                        // with the user, if there is any time left we will wait for that time but dont wait for\n                        // a full timeout.\n                        status = future.await(timeoutMillis - timeSinceLast, TimeUnit.MILLISECONDS);\n                    } else {\n                        status = null;\n                    }\n                } else {\n                    status = null; // Just terminate status processing.\n                }\n            }\n        }\n\n        if (status == IoFuture.Status.DONE) {\n            return future.get();\n        }\n        if (status == IoFuture.Status.FAILED) {\n            throw ProtocolMessages.MESSAGES.failedToConnect(uri, future.getException());\n        }\n        throw ProtocolMessages.MESSAGES.couldNotConnect(uri);\n    }","commit_id":"f0370f4b01a4d3a03532c2f82130574f2894a358","url":"https://github.com/wildfly/wildfly"},{"original_method":"public IoFuture<Connection> connect(CallbackHandler handler, Map<String, String> saslOptions) throws IOException {\n\n        OptionMap.Builder builder = OptionMap.builder();\n        builder.set(SASL_POLICY_NOANONYMOUS, Boolean.FALSE);\n        builder.set(SASL_POLICY_NOPLAINTEXT, Boolean.FALSE);\n        if (isLocal() == false) {\n            builder.set(Options.SASL_DISALLOWED_MECHANISMS, Sequence.of(JBOSS_LOCAL_USER));\n        }\n        List<Property> tempProperties = new ArrayList<Property>(saslOptions != null ? saslOptions.size() : 1);\n        tempProperties.add(Property.of(\"jboss.sasl.local-user.quiet-auth\", \"true\"));\n        if (saslOptions != null) {\n            for (String currentKey : saslOptions.keySet()) {\n                tempProperties.add(Property.of(currentKey, saslOptions.get(currentKey)));\n            }\n        }\n        builder.set(Options.SASL_PROPERTIES, Sequence.of(tempProperties));\n\n        builder.set(Options.SSL_ENABLED, true);\n        builder.set(Options.SSL_STARTTLS, true);\n\n        CallbackHandler actualHandler = handler != null ? handler : new AnonymousCallbackHandler();\n        WrapperCallbackHandler wrapperHandler = new WrapperCallbackHandler(actualHandler);\n        return endpoint.connect(uri, builder.getMap(), wrapperHandler);\n    }","id":60470,"modified_method":"public IoFuture<Connection> connect(CallbackHandler handler, Map<String, String> saslOptions) throws IOException {\n\n        OptionMap.Builder builder = OptionMap.builder();\n        builder.set(SASL_POLICY_NOANONYMOUS, Boolean.FALSE);\n        builder.set(SASL_POLICY_NOPLAINTEXT, Boolean.FALSE);\n        if (isLocal() == false) {\n            builder.set(Options.SASL_DISALLOWED_MECHANISMS, Sequence.of(JBOSS_LOCAL_USER));\n        }\n        List<Property> tempProperties = new ArrayList<Property>(saslOptions != null ? saslOptions.size() : 1);\n        tempProperties.add(Property.of(\"jboss.sasl.local-user.quiet-auth\", \"true\"));\n        if (saslOptions != null) {\n            for (String currentKey : saslOptions.keySet()) {\n                tempProperties.add(Property.of(currentKey, saslOptions.get(currentKey)));\n            }\n        }\n        builder.set(Options.SASL_PROPERTIES, Sequence.of(tempProperties));\n\n        builder.set(Options.SSL_ENABLED, true);\n        builder.set(Options.SSL_STARTTLS, true);\n\n        CallbackHandler actualHandler = handler != null ? handler : new AnonymousCallbackHandler();\n        return endpoint.connect(uri, builder.getMap(), actualHandler);\n    }","commit_id":"f0370f4b01a4d3a03532c2f82130574f2894a358","url":"https://github.com/wildfly/wildfly"},{"original_method":"public ClientConnectionManagerImpl(HazelcastClient client,\n                                       LoadBalancer loadBalancer,\n                                       AddressTranslator addressTranslator) {\n        this.client = client;\n        this.addressTranslator = addressTranslator;\n        final ClientConfig config = client.getClientConfig();\n        final ClientNetworkConfig networkConfig = config.getNetworkConfig();\n\n        connectionTimeout = networkConfig.getConnectionTimeout();\n\n        final ClientProperties clientProperties = client.getClientProperties();\n        int timeout = clientProperties.getHeartbeatTimeout().getInteger();\n        this.heartBeatTimeout = timeout > 0 ? timeout : Integer.parseInt(PROP_HEARTBEAT_TIMEOUT_DEFAULT);\n\n        int interval = clientProperties.getHeartbeatInterval().getInteger();\n        heartBeatInterval = interval > 0 ? interval : Integer.parseInt(PROP_HEARTBEAT_INTERVAL_DEFAULT);\n\n        smartRouting = networkConfig.isSmartRouting();\n        executionService = (ClientExecutionServiceImpl) client.getClientExecutionService();\n        credentials = initCredentials(config);\n        router = new Router(loadBalancer);\n\n        inSelector = new InSelectorImpl(\n                client.getThreadGroup(),\n                \"InSelector\",\n                Logger.getLogger(InSelectorImpl.class),\n                OUT_OF_MEMORY_HANDLER);\n        outSelector = new OutSelectorImpl(\n                client.getThreadGroup(),\n                \"OutSelector\",\n                Logger.getLogger(OutSelectorImpl.class),\n                OUT_OF_MEMORY_HANDLER);\n\n        socketInterceptor = initSocketInterceptor(networkConfig.getSocketInterceptorConfig());\n        socketOptions = networkConfig.getSocketOptions();\n        socketChannelWrapperFactory = initSocketChannel(networkConfig);\n    }","id":60471,"modified_method":"public ClientConnectionManagerImpl(HazelcastClient client,\n                                       LoadBalancer loadBalancer,\n                                       AddressTranslator addressTranslator) {\n        this.client = client;\n        this.addressTranslator = addressTranslator;\n        final ClientConfig config = client.getClientConfig();\n        final ClientNetworkConfig networkConfig = config.getNetworkConfig();\n\n        final int connTimeout = networkConfig.getConnectionTimeout();\n        connectionTimeout = connTimeout == 0 ? Integer.MAX_VALUE : connTimeout;\n\n        final ClientProperties clientProperties = client.getClientProperties();\n        int timeout = clientProperties.getHeartbeatTimeout().getInteger();\n        this.heartBeatTimeout = timeout > 0 ? timeout : Integer.parseInt(PROP_HEARTBEAT_TIMEOUT_DEFAULT);\n\n        int interval = clientProperties.getHeartbeatInterval().getInteger();\n        heartBeatInterval = interval > 0 ? interval : Integer.parseInt(PROP_HEARTBEAT_INTERVAL_DEFAULT);\n\n        smartRouting = networkConfig.isSmartRouting();\n        executionService = (ClientExecutionServiceImpl) client.getClientExecutionService();\n        credentials = initCredentials(config);\n        router = new Router(loadBalancer);\n\n        inSelector = new InSelectorImpl(\n                client.getThreadGroup(),\n                \"InSelector\",\n                Logger.getLogger(InSelectorImpl.class),\n                OUT_OF_MEMORY_HANDLER);\n        outSelector = new OutSelectorImpl(\n                client.getThreadGroup(),\n                \"OutSelector\",\n                Logger.getLogger(OutSelectorImpl.class),\n                OUT_OF_MEMORY_HANDLER);\n\n        socketInterceptor = initSocketInterceptor(networkConfig.getSocketInterceptorConfig());\n        socketOptions = networkConfig.getSocketOptions();\n        socketChannelWrapperFactory = initSocketChannel(networkConfig);\n    }","commit_id":"ba77f03db7dd1ffb4d66cf1f37cca1fe40f29c7f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private ClientConnection createNew(Address address) throws RetryableIOException {\n            final ManagerAuthenticator authenticator = new ManagerAuthenticator();\n            final ConnectionProcessor connectionProcessor = new ConnectionProcessor(address, authenticator, true);\n            ICompletableFuture<ClientConnection> future = executionService.submitInternal(connectionProcessor);\n            try {\n                ClientConnection conn = future.get(connectionTimeout + TIMEOUT_PLUS, TimeUnit.MILLISECONDS);\n                synchronized (ownerConnectionLock) {\n                    ownerConnection = conn;\n                    ownerConnectionLock.notifyAll();\n                }\n                return conn;\n            } catch (Exception e) {\n                future.cancel(true);\n                throw new RetryableIOException(e);\n            }\n        }","id":60472,"modified_method":"private ClientConnection createNew(Address address) throws RetryableIOException {\n            final ManagerAuthenticator authenticator = new ManagerAuthenticator();\n            final ConnectionProcessor connectionProcessor = new ConnectionProcessor(address, authenticator, true);\n            ICompletableFuture<ClientConnection> future = executionService.submitInternal(connectionProcessor);\n            try {\n                ClientConnection conn = future.get(connectionTimeout, TimeUnit.MILLISECONDS);\n                synchronized (ownerConnectionLock) {\n                    ownerConnection = conn;\n                    ownerConnectionLock.notifyAll();\n                }\n                return conn;\n            } catch (Exception e) {\n                future.cancel(true);\n                throw new RetryableIOException(e);\n            }\n        }","commit_id":"ba77f03db7dd1ffb4d66cf1f37cca1fe40f29c7f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private ClientConnection getOrConnect(Address target, Authenticator authenticator) throws Exception {\n        if (!smartRouting) {\n            target = ownerConnectionFuture.getOrWaitForCreation().getEndPoint();\n        }\n\n        Address address = addressTranslator.translate(target);\n\n        if (address == null) {\n            throw new IOException(\"Address is required!\");\n        }\n\n        ClientConnection clientConnection = connections.get(address);\n        if (clientConnection == null) {\n            final Object lock = getLock(address);\n            synchronized (lock) {\n                clientConnection = connections.get(address);\n                if (clientConnection == null) {\n                    final ConnectionProcessor connectionProcessor = new ConnectionProcessor(address, authenticator, false);\n                    final ICompletableFuture<ClientConnection> future = executionService.submitInternal(connectionProcessor);\n                    try {\n                        clientConnection = future.get(connectionTimeout + TIMEOUT_PLUS, TimeUnit.MILLISECONDS);\n                    } catch (Exception e) {\n                        future.cancel(true);\n                        throw new RetryableIOException(e);\n                    }\n                    ClientConnection current = connections.putIfAbsent(address, clientConnection);\n                    if (current != null) {\n                        clientConnection.close();\n                        clientConnection = current;\n                    }\n                }\n            }\n        }\n        return clientConnection;\n    }","id":60473,"modified_method":"private ClientConnection getOrConnect(Address target, Authenticator authenticator) throws Exception {\n        if (!smartRouting) {\n            target = ownerConnectionFuture.getOrWaitForCreation().getEndPoint();\n        }\n\n        Address address = addressTranslator.translate(target);\n\n        if (address == null) {\n            throw new IOException(\"Address is required!\");\n        }\n\n        ClientConnection clientConnection = connections.get(address);\n        if (clientConnection == null) {\n            final Object lock = getLock(address);\n            synchronized (lock) {\n                clientConnection = connections.get(address);\n                if (clientConnection == null) {\n                    final ConnectionProcessor connectionProcessor = new ConnectionProcessor(address, authenticator, false);\n                    final ICompletableFuture<ClientConnection> future = executionService.submitInternal(connectionProcessor);\n                    try {\n                        clientConnection = future.get(connectionTimeout, TimeUnit.MILLISECONDS);\n                    } catch (Exception e) {\n                        future.cancel(true);\n                        throw new RetryableIOException(e);\n                    }\n                    ClientConnection current = connections.putIfAbsent(address, clientConnection);\n                    if (current != null) {\n                        clientConnection.close();\n                        clientConnection = current;\n                    }\n                }\n            }\n        }\n        return clientConnection;\n    }","commit_id":"ba77f03db7dd1ffb4d66cf1f37cca1fe40f29c7f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public ClientConnectionManagerImpl(HazelcastClient client,\n                                       LoadBalancer loadBalancer,\n                                       AddressTranslator addressTranslator) {\n        this.client = client;\n        this.addressTranslator = addressTranslator;\n        final ClientConfig config = client.getClientConfig();\n        final ClientNetworkConfig networkConfig = config.getNetworkConfig();\n\n        connectionTimeout = networkConfig.getConnectionTimeout();\n\n        final ClientProperties clientProperties = client.getClientProperties();\n        int timeout = clientProperties.getHeartbeatTimeout().getInteger();\n        this.heartBeatTimeout = timeout > 0 ? timeout : Integer.parseInt(PROP_HEARTBEAT_TIMEOUT_DEFAULT);\n\n        int interval = clientProperties.getHeartbeatInterval().getInteger();\n        heartBeatInterval = interval > 0 ? interval : Integer.parseInt(PROP_HEARTBEAT_INTERVAL_DEFAULT);\n\n        smartRouting = networkConfig.isSmartRouting();\n        executionService = (ClientExecutionServiceImpl) client.getClientExecutionService();\n        credentials = initCredentials(config);\n        router = new Router(loadBalancer);\n\n        inSelector = new InSelectorImpl(\n                client.getThreadGroup(),\n                \"InSelector\",\n                Logger.getLogger(InSelectorImpl.class),\n                OUT_OF_MEMORY_HANDLER);\n        outSelector = new OutSelectorImpl(\n                client.getThreadGroup(),\n                \"OutSelector\",\n                Logger.getLogger(OutSelectorImpl.class),\n                OUT_OF_MEMORY_HANDLER);\n\n        socketInterceptor = initSocketInterceptor(networkConfig.getSocketInterceptorConfig());\n        socketOptions = networkConfig.getSocketOptions();\n        socketChannelWrapperFactory = initSocketChannel(networkConfig);\n    }","id":60474,"modified_method":"public ClientConnectionManagerImpl(HazelcastClient client,\n                                       LoadBalancer loadBalancer,\n                                       AddressTranslator addressTranslator) {\n        this.client = client;\n        this.addressTranslator = addressTranslator;\n        final ClientConfig config = client.getClientConfig();\n        final ClientNetworkConfig networkConfig = config.getNetworkConfig();\n\n        final int connTimeout = networkConfig.getConnectionTimeout();\n        connectionTimeout = connTimeout == 0 ? Integer.MAX_VALUE : connTimeout;\n\n        final ClientProperties clientProperties = client.getClientProperties();\n        int timeout = clientProperties.getHeartbeatTimeout().getInteger();\n        this.heartBeatTimeout = timeout > 0 ? timeout : Integer.parseInt(PROP_HEARTBEAT_TIMEOUT_DEFAULT);\n\n        int interval = clientProperties.getHeartbeatInterval().getInteger();\n        heartBeatInterval = interval > 0 ? interval : Integer.parseInt(PROP_HEARTBEAT_INTERVAL_DEFAULT);\n\n        smartRouting = networkConfig.isSmartRouting();\n        executionService = (ClientExecutionServiceImpl) client.getClientExecutionService();\n        credentials = initCredentials(config);\n        router = new Router(loadBalancer);\n\n        inSelector = new InSelectorImpl(\n                client.getThreadGroup(),\n                \"InSelector\",\n                Logger.getLogger(InSelectorImpl.class),\n                OUT_OF_MEMORY_HANDLER);\n        outSelector = new OutSelectorImpl(\n                client.getThreadGroup(),\n                \"OutSelector\",\n                Logger.getLogger(OutSelectorImpl.class),\n                OUT_OF_MEMORY_HANDLER);\n\n        socketInterceptor = initSocketInterceptor(networkConfig.getSocketInterceptorConfig());\n        socketOptions = networkConfig.getSocketOptions();\n        socketChannelWrapperFactory = initSocketChannel(networkConfig);\n    }","commit_id":"67ac158cf59283c6b6bfb7efc88e146f01942e18","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private ClientConnection getOrConnect(Address target, Authenticator authenticator) throws Exception {\n        if (!smartRouting) {\n            target = ownerConnectionFuture.getOrWaitForCreation().getEndPoint();\n        }\n\n        Address address = addressTranslator.translate(target);\n\n        if (address == null) {\n            throw new IOException(\"Address is required!\");\n        }\n\n        ClientConnection clientConnection = connections.get(address);\n        if (clientConnection == null) {\n            final Object lock = getLock(address);\n            synchronized (lock) {\n                clientConnection = connections.get(address);\n                if (clientConnection == null) {\n                    final ConnectionProcessor connectionProcessor = new ConnectionProcessor(address, authenticator, false);\n                    final ICompletableFuture<ClientConnection> future = executionService.submitInternal(connectionProcessor);\n                    try {\n                        clientConnection = future.get(connectionTimeout + TIMEOUT_PLUS, TimeUnit.MILLISECONDS);\n                    } catch (Exception e) {\n                        future.cancel(true);\n                        throw new RetryableIOException(e);\n                    }\n                    ClientConnection current = connections.putIfAbsent(address, clientConnection);\n                    if (current != null) {\n                        clientConnection.close();\n                        clientConnection = current;\n                    }\n                }\n            }\n        }\n        return clientConnection;\n    }","id":60475,"modified_method":"private ClientConnection getOrConnect(Address target, Authenticator authenticator) throws Exception {\n        if (!smartRouting) {\n            target = ownerConnectionFuture.getOrWaitForCreation().getEndPoint();\n        }\n\n        Address address = addressTranslator.translate(target);\n\n        if (address == null) {\n            throw new IOException(\"Address is required!\");\n        }\n\n        ClientConnection clientConnection = connections.get(address);\n        if (clientConnection == null) {\n            final Object lock = getLock(address);\n            synchronized (lock) {\n                clientConnection = connections.get(address);\n                if (clientConnection == null) {\n                    final ConnectionProcessor connectionProcessor = new ConnectionProcessor(address, authenticator, false);\n                    final ICompletableFuture<ClientConnection> future = executionService.submitInternal(connectionProcessor);\n                    try {\n                        clientConnection = future.get(connectionTimeout, TimeUnit.MILLISECONDS);\n                    } catch (Exception e) {\n                        future.cancel(true);\n                        throw new RetryableIOException(e);\n                    }\n                    ClientConnection current = connections.putIfAbsent(address, clientConnection);\n                    if (current != null) {\n                        clientConnection.close();\n                        clientConnection = current;\n                    }\n                }\n            }\n        }\n        return clientConnection;\n    }","commit_id":"67ac158cf59283c6b6bfb7efc88e146f01942e18","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private ClientConnection createNew(Address address) throws RetryableIOException {\n            final ManagerAuthenticator authenticator = new ManagerAuthenticator();\n            final ConnectionProcessor connectionProcessor = new ConnectionProcessor(address, authenticator, true);\n            ICompletableFuture<ClientConnection> future = executionService.submitInternal(connectionProcessor);\n            try {\n                ClientConnection conn = future.get(connectionTimeout + TIMEOUT_PLUS, TimeUnit.MILLISECONDS);\n                synchronized (ownerConnectionLock) {\n                    ownerConnection = conn;\n                    ownerConnectionLock.notifyAll();\n                }\n                return conn;\n            } catch (Exception e) {\n                future.cancel(true);\n                throw new RetryableIOException(e);\n            }\n        }","id":60476,"modified_method":"private ClientConnection createNew(Address address) throws RetryableIOException {\n            final ManagerAuthenticator authenticator = new ManagerAuthenticator();\n            final ConnectionProcessor connectionProcessor = new ConnectionProcessor(address, authenticator, true);\n            ICompletableFuture<ClientConnection> future = executionService.submitInternal(connectionProcessor);\n            try {\n                ClientConnection conn = future.get(connectionTimeout, TimeUnit.MILLISECONDS);\n                synchronized (ownerConnectionLock) {\n                    ownerConnection = conn;\n                    ownerConnectionLock.notifyAll();\n                }\n                return conn;\n            } catch (Exception e) {\n                future.cancel(true);\n                throw new RetryableIOException(e);\n            }\n        }","commit_id":"67ac158cf59283c6b6bfb7efc88e146f01942e18","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"protected CoderResult encodeLoop(CharBuffer in, ByteBuffer out) {\n    while (in.position() < in.limit()) {\n      in.mark();\n      try {\n        char c = in.get();\n        if (c < '\\u0080') {\n          ByteBuffer byteBuffer = myBaseCharset.encode(Character.toString(c));\n          out.put(byteBuffer);\n        }\n        else {\n          if (out.remaining() < 6) throw new BufferOverflowException();\n          out.put((byte)'\\\\');\n          out.put((byte)'u');\n          out.put((byte)Character.forDigit(c >> 12, 16));\n          out.put((byte)Character.forDigit((c >> 8) & 0xf, 16));\n          out.put((byte)Character.forDigit((c >> 4) & 0xf, 16));\n          out.put((byte)Character.forDigit(c & 0xf, 16));\n        }\n      }\n      catch (BufferUnderflowException e) {\n        in.reset();\n      }\n      catch (BufferOverflowException e) {\n        in.reset();\n        return CoderResult.OVERFLOW;\n      }\n    }\n    return CoderResult.UNDERFLOW;\n  }","id":60477,"modified_method":"protected CoderResult encodeLoop(CharBuffer in, ByteBuffer out) {\n    while (in.position() < in.limit()) {\n      in.mark();\n      try {\n        char c = in.get();\n        if (c < '\\u0080') {\n          ByteBuffer byteBuffer = myBaseCharset.encode(Character.toString(c));\n          out.put(byteBuffer);\n        }\n        else {\n          if (out.remaining() < 6) throw new BufferOverflowException();\n          out.put((byte)'\\\\');\n          out.put((byte)'u');\n          out.put((byte)Character.toUpperCase(Character.forDigit(c >> 12, 16)));\n          out.put((byte)Character.toUpperCase(Character.forDigit((c >> 8) & 0xf, 16)));\n          out.put((byte)Character.toUpperCase(Character.forDigit((c >> 4) & 0xf, 16)));\n          out.put((byte)Character.toUpperCase(Character.forDigit(c & 0xf, 16)));\n        }\n      }\n      catch (BufferUnderflowException e) {\n        in.reset();\n      }\n      catch (BufferOverflowException e) {\n        in.reset();\n        return CoderResult.OVERFLOW;\n      }\n    }\n    return CoderResult.UNDERFLOW;\n  }","commit_id":"6213f35e9f34188b24781a1c68aff03dfde94907","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public final void processMessage() {\n        beforeProcess();\n        Operation op = prepareOperation();\n        op.setCallerUuid(endpoint.getUuid());\n        InvocationBuilder builder = nodeEngine.getOperationService()\n                .createInvocationBuilder(getServiceName(), op, getPartitionId())\n                .setExecutionCallback(this)\n                .setResultDeserialized(false);\n\n        builder.invoke();\n    }","id":60478,"modified_method":"@Override\n    public final void processMessage() {\n        beforeProcess();\n        Operation op = prepareOperation();\n        op.setCallerUuid(endpoint.getUuid());\n        ICompletableFuture f = nodeEngine.getOperationService()\n                .createInvocationBuilder(getServiceName(), op, getPartitionId())\n                .setResultDeserialized(false)\n                .invoke();\n\n        f.andThen(this, this);\n    }","commit_id":"20958b6b6c5e3c39680b4b53b365598d8f20513d","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public final void process() {\n        beforeProcess();\n        ClientEndpoint endpoint = getEndpoint();\n        Operation op = prepareOperation();\n        op.setCallerUuid(endpoint.getUuid());\n        InvocationBuilder builder = operationService.createInvocationBuilder(getServiceName(), op, getPartition())\n                .setReplicaIndex(getReplicaIndex())\n                .setTryCount(TRY_COUNT)\n                .setResultDeserialized(false)\n                .setCallback(new CallbackImpl(endpoint));\n        builder.invoke();\n    }","id":60479,"modified_method":"@Override\n    public final void process() {\n        beforeProcess();\n        ClientEndpoint endpoint = getEndpoint();\n        Operation op = prepareOperation();\n        op.setCallerUuid(endpoint.getUuid());\n        InvocationBuilder builder = operationService.createInvocationBuilder(getServiceName(), op, getPartition())\n                .setReplicaIndex(getReplicaIndex())\n                .setTryCount(TRY_COUNT)\n                .setResultDeserialized(false);\n\n        ICompletableFuture future = builder.invoke();\n        future.andThen(this);\n    }","commit_id":"b8e9eeefcad4be7b868367eda9f0465ffd4361e4","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public final void process() throws Exception {\n        final ClientEndpoint endpoint = getEndpoint();\n        Operation op = prepareOperation();\n        op.setCallerUuid(endpoint.getUuid());\n        InvocationBuilder builder = getInvocationBuilder(op)\n                .setTryCount(TRY_COUNT)\n                .setResultDeserialized(false)\n                .setCallback(new Callback<Object>() {\n                    public void notify(Object object) {\n                        endpoint.sendResponse(filter(object), getCallId());\n                    }\n                });\n        builder.invoke();\n    }","id":60480,"modified_method":"@Override\n    public final void process() throws Exception {\n        final ClientEndpoint endpoint = getEndpoint();\n        Operation op = prepareOperation();\n        op.setCallerUuid(endpoint.getUuid());\n\n        InvocationBuilder builder = getInvocationBuilder(op)\n                .setTryCount(TRY_COUNT)\n                .setResultDeserialized(false);\n        InternalCompletableFuture f = builder.invoke();\n        f.andThen(this);\n    }","commit_id":"b8e9eeefcad4be7b868367eda9f0465ffd4361e4","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"protected void resolveTransitiveDependencies( MavenSession context,\n                                                  MavenRepositorySystem repositorySystem,\n                                                  String scope,\n                                                  MavenProject project,\n                                                  boolean isAggregator )\n        throws ArtifactResolutionException, ArtifactNotFoundException, InvalidDependencyVersionException\n    {\n        // TODO: such a call in MavenMetadataSource too - packaging not really the intention of type\n        Artifact artifact = repositorySystem.createBuildArtifact( project.getGroupId(), project.getArtifactId(), project.getVersion(), project.getPackaging() );\n\n        // TODO: we don't need to resolve over and over again, as long as we are sure that the parameters are the same\n        // check this with yourkit as a hot spot.\n        // Don't recreate if already created - for effeciency, and because clover plugin adds to it\n        if ( project.getDependencyArtifacts() == null )\n        {\n            // NOTE: Don't worry about covering this case with the error-reporter bindings...it's already handled by the project error reporter.\n            try\n            {\n                project.setDependencyArtifacts( repositorySystem.createArtifacts( project.getDependencies(), null, null, project ) );\n            }\n            catch ( VersionNotFoundException e )\n            {\n                throw new InvalidDependencyVersionException( e.getProjectId(), e.getDependency(), e.getPomFile(), e.getCauseException() );\n            }\n        }\n\n        ArtifactFilter filter = new ScopeArtifactFilter( scope );\n\n        ArtifactResolutionRequest request = new ArtifactResolutionRequest()\n            .setArtifact( artifact )\n            .setArtifactDependencies( project.getDependencyArtifacts() )\n            .setLocalRepository( context.getLocalRepository() )\n            .setRemoteRepostories( project.getRemoteArtifactRepositories() )\n            .setManagedVersionMap( project.getManagedVersionMap() )\n            .setFilter( filter )                \n            .setMetadataSource( repositorySystem );\n                         \n        ArtifactResolutionResult result = repositorySystem.resolve( request );\n\n        if ( result.hasErrorArtifactExceptions() )\n        {\n            /*\n             \n            only do this if we are an aggregating plugin: MNG-2277\n            if the dependency doesn't yet exist but is in the reactor, then\n            all we can do is warn and skip it. A better fix can be inserted into 2.1\n            \n            */\n            if ( isAggregator && checkMissingArtifactsInReactor( context.getSortedProjects(), result.getMissingArtifacts() ) )\n            {\n            }\n            else\n            {\n                //we can't find all the artifacts in the reactor so bubble the exception up.\n                throw result.getErrorArtifactExceptions().get( 0 );\n            }\n        }\n        \n        project.setArtifacts( result.getArtifacts() );\n    }","id":60481,"modified_method":"protected void resolveTransitiveDependencies( MavenSession context,\n                                                  MavenRepositorySystem repositorySystem,\n                                                  String scope,\n                                                  MavenProject project,\n                                                  boolean isAggregator )\n        throws ArtifactResolutionException, ArtifactNotFoundException, InvalidDependencyVersionException\n    {\n        // TODO: such a call in MavenMetadataSource too - packaging not really the intention of type\n        Artifact artifact = repositorySystem.createBuildArtifact( project.getGroupId(), project.getArtifactId(), project.getVersion(), project.getPackaging() );\n\n        // TODO: we don't need to resolve over and over again, as long as we are sure that the parameters are the same\n        // check this with yourkit as a hot spot.\n        // Don't recreate if already created - for effeciency, and because clover plugin adds to it\n        if ( project.getDependencyArtifacts() == null )\n        {\n            // NOTE: Don't worry about covering this case with the error-reporter bindings...it's already handled by the project error reporter.\n            try\n            {\n                project.setDependencyArtifacts( repositorySystem.createArtifacts( project.getDependencies(), null, null, project ) );\n            }\n            catch ( VersionNotFoundException e )\n            {\n                throw new InvalidDependencyVersionException( e.getProjectId(), e.getDependency(), e.getPomFile(), e.getCauseException() );\n            }\n        }\n\n        ArtifactFilter filter = new ScopeArtifactFilter( scope );\n\n        ArtifactResolutionRequest request = new ArtifactResolutionRequest()\n            .setArtifact( artifact )\n            .setResolveRoot( false )\n            .setArtifactDependencies( project.getDependencyArtifacts() )\n            .setLocalRepository( context.getLocalRepository() )\n            .setRemoteRepostories( project.getRemoteArtifactRepositories() )\n            .setManagedVersionMap( project.getManagedVersionMap() )\n            .setFilter( filter )                \n            .setMetadataSource( repositorySystem );\n                         \n        ArtifactResolutionResult result = repositorySystem.resolve( request );\n\n        if ( result.hasErrorArtifactExceptions() )\n        {\n            /*\n             \n            only do this if we are an aggregating plugin: MNG-2277\n            if the dependency doesn't yet exist but is in the reactor, then\n            all we can do is warn and skip it. A better fix can be inserted into 2.1\n            \n            */\n            if ( isAggregator && checkMissingArtifactsInReactor( context.getSortedProjects(), result.getMissingArtifacts() ) )\n            {\n            }\n            else\n            {\n                //we can't find all the artifacts in the reactor so bubble the exception up.\n                throw result.getErrorArtifactExceptions().get( 0 );\n            }\n        }\n        \n        project.setArtifacts( result.getArtifacts() );\n    }","commit_id":"374ef3a15b0fd2296570d87c5896aedcaf72b824","url":"https://github.com/apache/maven"},{"original_method":"public void testTransitiveResolutionWhereAllArtifactsAreNotPresentInTheLocalRepositoryAndMustBeRetrievedFromTheRemoteRepository()\n        throws Exception\n    {\n        Artifact i = createRemoteArtifact( \"i\", \"1.0-SNAPSHOT\" );\n        deleteLocalArtifact( i );\n\n        Artifact j = createRemoteArtifact( \"j\", \"1.0-SNAPSHOT\" );\n        deleteLocalArtifact( j );\n\n        ArtifactResolutionResult result = artifactResolver.resolveTransitively( Collections.singleton( i ), projectArtifact, remoteRepositories(), localRepository(), null );\n\n        assertEquals( 3, result.getArtifacts().size() );\n\n        assertTrue( result.getArtifacts().contains( i ) );\n\n        assertTrue( result.getArtifacts().contains( j ) );\n\n        assertLocalArtifactPresent( i );\n\n        assertLocalArtifactPresent( j );\n    }","id":60482,"modified_method":"public void testTransitiveResolutionWhereAllArtifactsAreNotPresentInTheLocalRepositoryAndMustBeRetrievedFromTheRemoteRepository()\n        throws Exception\n    {\n        Artifact i = createRemoteArtifact( \"i\", \"1.0-SNAPSHOT\" );\n        deleteLocalArtifact( i );\n\n        Artifact j = createRemoteArtifact( \"j\", \"1.0-SNAPSHOT\" );\n        deleteLocalArtifact( j );\n\n        ArtifactResolutionResult result = artifactResolver.resolveTransitively( Collections.singleton( i ), projectArtifact, remoteRepositories(), localRepository(), null );\n\n        assertEquals( 2, result.getArtifacts().size() );\n\n        assertTrue( result.getArtifacts().contains( i ) );\n\n        assertTrue( result.getArtifacts().contains( j ) );\n\n        assertLocalArtifactPresent( i );\n\n        assertLocalArtifactPresent( j );\n    }","commit_id":"8b22b2dffa01a5276cbae8fd22444275e82cd74c","url":"https://github.com/apache/maven"},{"original_method":"public void testTransitiveResolutionOrder()\n        throws Exception\n    {\n        Artifact m = createLocalArtifact( \"m\", \"1.0\" );\n\n        Artifact n = createLocalArtifact( \"n\", \"1.0\" );\n\n        ArtifactMetadataSource mds = new ArtifactMetadataSource()\n        {\n            public ResolutionGroup retrieve( Artifact artifact, ArtifactRepository localRepository,\n                                             List<ArtifactRepository> remoteRepositories )\n                throws ArtifactMetadataRetrievalException\n            {\n                Set dependencies = new HashSet();\n\n                return new ResolutionGroup( artifact, dependencies, remoteRepositories );\n            }\n\n            public List<ArtifactVersion> retrieveAvailableVersions( Artifact artifact,\n                                                                    ArtifactRepository localRepository,\n                                                                    List<ArtifactRepository> remoteRepositories )\n                throws ArtifactMetadataRetrievalException\n            {\n                throw new UnsupportedOperationException( \"Cannot get available versions in this test case\" );\n            }\n\n            public List<ArtifactVersion> retrieveAvailableVersionsFromDeploymentRepository(\n                                                                                            Artifact artifact,\n                                                                                            ArtifactRepository localRepository,\n                                                                                            ArtifactRepository remoteRepository )\n                throws ArtifactMetadataRetrievalException\n            {\n                throw new UnsupportedOperationException( \"Cannot get available versions in this test case\" );\n            }\n\n            public Artifact retrieveRelocatedArtifact( Artifact artifact,\n                                                       ArtifactRepository localRepository,\n                                                       List<ArtifactRepository> remoteRepositories )\n                throws ArtifactMetadataRetrievalException\n            {\n                return artifact;\n            }\n        };\n\n        ArtifactResolutionResult result = null;\n\n        Set set = new LinkedHashSet();\n        set.add( n );\n        set.add( m );\n\n        result =\n            artifactResolver.resolveTransitively( set, projectArtifact, remoteRepositories(), localRepository(), mds );\n\n        Iterator i = result.getArtifacts().iterator();\n        i.next();\n        assertEquals( \"n should be first\", n, i.next() );\n        assertEquals( \"m should be second\", m, i.next() );\n\n        // inverse order\n        set = new LinkedHashSet();\n        set.add( m );\n        set.add( n );\n\n        result =\n            artifactResolver.resolveTransitively( set, projectArtifact, remoteRepositories(), localRepository(), mds );\n\n        i = result.getArtifacts().iterator();\n        i.next();\n        assertEquals( \"m should be first\", m, i.next() );\n        assertEquals( \"n should be second\", n, i.next() );\n    }","id":60483,"modified_method":"public void testTransitiveResolutionOrder()\n        throws Exception\n    {\n        Artifact m = createLocalArtifact( \"m\", \"1.0\" );\n\n        Artifact n = createLocalArtifact( \"n\", \"1.0\" );\n\n        ArtifactMetadataSource mds = new ArtifactMetadataSource()\n        {\n            public ResolutionGroup retrieve( Artifact artifact, ArtifactRepository localRepository,\n                                             List<ArtifactRepository> remoteRepositories )\n                throws ArtifactMetadataRetrievalException\n            {\n                Set dependencies = new HashSet();\n\n                return new ResolutionGroup( artifact, dependencies, remoteRepositories );\n            }\n\n            public List<ArtifactVersion> retrieveAvailableVersions( Artifact artifact,\n                                                                    ArtifactRepository localRepository,\n                                                                    List<ArtifactRepository> remoteRepositories )\n                throws ArtifactMetadataRetrievalException\n            {\n                throw new UnsupportedOperationException( \"Cannot get available versions in this test case\" );\n            }\n\n            public List<ArtifactVersion> retrieveAvailableVersionsFromDeploymentRepository(\n                                                                                            Artifact artifact,\n                                                                                            ArtifactRepository localRepository,\n                                                                                            ArtifactRepository remoteRepository )\n                throws ArtifactMetadataRetrievalException\n            {\n                throw new UnsupportedOperationException( \"Cannot get available versions in this test case\" );\n            }\n\n            public Artifact retrieveRelocatedArtifact( Artifact artifact,\n                                                       ArtifactRepository localRepository,\n                                                       List<ArtifactRepository> remoteRepositories )\n                throws ArtifactMetadataRetrievalException\n            {\n                return artifact;\n            }\n        };\n\n        ArtifactResolutionResult result = null;\n\n        Set set = new LinkedHashSet();\n        set.add( n );\n        set.add( m );\n\n        result =\n            artifactResolver.resolveTransitively( set, projectArtifact, remoteRepositories(), localRepository(), mds );\n\n        Iterator i = result.getArtifacts().iterator();\n        assertEquals( \"n should be first\", n, i.next() );\n        assertEquals( \"m should be second\", m, i.next() );\n\n        // inverse order\n        set = new LinkedHashSet();\n        set.add( m );\n        set.add( n );\n\n        result =\n            artifactResolver.resolveTransitively( set, projectArtifact, remoteRepositories(), localRepository(), mds );\n\n        i = result.getArtifacts().iterator();\n        assertEquals( \"m should be first\", m, i.next() );\n        assertEquals( \"n should be second\", n, i.next() );\n    }","commit_id":"8b22b2dffa01a5276cbae8fd22444275e82cd74c","url":"https://github.com/apache/maven"},{"original_method":"public void testTransitiveResolutionWhereAllArtifactsArePresentInTheLocalRepository()\n        throws Exception\n    {\n        Artifact g = createLocalArtifact( \"g\", \"1.0\" );\n\n        Artifact h = createLocalArtifact( \"h\", \"1.0\" );\n\n        ArtifactResolutionResult result = artifactResolver.resolveTransitively( Collections.singleton( g ), projectArtifact, remoteRepositories(), localRepository(), null );\n\n        assertEquals( 3, result.getArtifacts().size() );\n\n        assertTrue( result.getArtifacts().contains( g ) );\n\n        assertTrue( result.getArtifacts().contains( h ) );\n\n        assertLocalArtifactPresent( g );\n\n        assertLocalArtifactPresent( h );\n    }","id":60484,"modified_method":"public void testTransitiveResolutionWhereAllArtifactsArePresentInTheLocalRepository()\n        throws Exception\n    {\n        Artifact g = createLocalArtifact( \"g\", \"1.0\" );\n\n        Artifact h = createLocalArtifact( \"h\", \"1.0\" );\n\n        ArtifactResolutionResult result = artifactResolver.resolveTransitively( Collections.singleton( g ), projectArtifact, remoteRepositories(), localRepository(), null );\n\n        assertEquals( 2, result.getArtifacts().size() );\n\n        assertTrue( result.getArtifacts().contains( g ) );\n\n        assertTrue( result.getArtifacts().contains( h ) );\n\n        assertLocalArtifactPresent( g );\n\n        assertLocalArtifactPresent( h );\n    }","commit_id":"8b22b2dffa01a5276cbae8fd22444275e82cd74c","url":"https://github.com/apache/maven"},{"original_method":"public ArtifactResolutionResult resolveTransitively( Set<Artifact> artifacts, Artifact originatingArtifact, Map managedVersions, ArtifactRepository localRepository,\n                                                         List<ArtifactRepository> remoteRepositories, ArtifactMetadataSource source, ArtifactFilter filter, List<ResolutionListener> listeners,\n                                                         List<ConflictResolver> conflictResolvers )\n        throws ArtifactResolutionException, ArtifactNotFoundException\n    {\n        ArtifactResolutionRequest request = new ArtifactResolutionRequest()\n            .setArtifact( originatingArtifact )\n            // This is required by the surefire plugin\n            .setArtifactDependencies( artifacts )            \n            .setManagedVersionMap( managedVersions )\n            .setLocalRepository( localRepository )\n            .setRemoteRepostories( remoteRepositories )\n            .setFilter( filter )\n            .setListeners( listeners );\n\n        return resolveWithExceptions( request );\n    }","id":60485,"modified_method":"public ArtifactResolutionResult resolveTransitively( Set<Artifact> artifacts, Artifact originatingArtifact, Map managedVersions, ArtifactRepository localRepository,\n                                                         List<ArtifactRepository> remoteRepositories, ArtifactMetadataSource source, ArtifactFilter filter, List<ResolutionListener> listeners,\n                                                         List<ConflictResolver> conflictResolvers )\n        throws ArtifactResolutionException, ArtifactNotFoundException\n    {\n        ArtifactResolutionRequest request = new ArtifactResolutionRequest()\n            .setArtifact( originatingArtifact )\n            .setResolveRoot( false )\n            // This is required by the surefire plugin\n            .setArtifactDependencies( artifacts )            \n            .setManagedVersionMap( managedVersions )\n            .setLocalRepository( localRepository )\n            .setRemoteRepostories( remoteRepositories )\n            .setFilter( filter )\n            .setListeners( listeners );\n\n        return resolveWithExceptions( request );\n    }","commit_id":"8b22b2dffa01a5276cbae8fd22444275e82cd74c","url":"https://github.com/apache/maven"},{"original_method":"public ArtifactResolutionResult resolve( ArtifactResolutionRequest request )\n    {\n        Artifact rootArtifact = request.getArtifact();\n        Set<Artifact> artifacts = request.getArtifactDependencies();\n        Map managedVersions = request.getManagedVersionMap();\n        ArtifactRepository localRepository = request.getLocalRepository();\n        List<ArtifactRepository> remoteRepositories = request.getRemoteRepostories();\n        List<ResolutionListener> listeners = request.getListeners();\n        ArtifactFilter filter = request.getFilter();                       \n        \n        //TODO: hack because metadata isn't generated in m2e correctly and i want to run the maven i have in the workspace\n        if ( source == null )\n        {\n            try\n            {\n                source = container.lookup( ArtifactMetadataSource.class );\n            }\n            catch ( ComponentLookupException e )\n            {\n                e.printStackTrace();\n                // won't happen\n            }\n        }\n        \n        // This is an extreme hack because of the ridiculous APIs we have a root that is disconnected and\n        // useless. The SureFire plugin passes in a dummy root artifact that is actually used in the production\n        // plugin ... We have no choice but to put this hack in the core.\n        if ( isDummy( request ) )\n        {\n            request.setResolveRoot( false );\n        }\n                \n        if ( listeners == null )\n        {\n            listeners = new ArrayList<ResolutionListener>();\n\n            if ( logger.isDebugEnabled() )\n            {\n                listeners.add( new DebugResolutionListener( logger ) );\n            }\n\n            listeners.add( new WarningResolutionListener( logger ) );\n        }\n\n        ArtifactResolutionResult result = new ArtifactResolutionResult();\n\n        // The root artifact may, or may not be resolved so we need to check before we attempt to resolve.\n        // This is often an artifact like a POM that is taken from disk and we already have hold of the\n        // file reference. But this may be a Maven Plugin that we need to resolve from a remote repository\n        // as well as its dependencies.\n                        \n        if ( request.isResolveRoot() && rootArtifact.getFile() == null )\n        {            \n            try\n            {\n                resolve( rootArtifact, remoteRepositories, localRepository );\n            }\n            catch ( ArtifactResolutionException e )\n            {\n                result.addErrorArtifactException( e );\n                return result;\n            }\n            catch ( ArtifactNotFoundException e )\n            {\n                result.addMissingArtifact( request.getArtifact() );\n                return result;\n            }\n        }\n        \n        if ( request.isResolveTransitively() )\n        {\n            try\n            {\n                Set<Artifact> directArtifacts = source.retrieve( rootArtifact, localRepository, remoteRepositories ).getArtifacts();\n\n                if ( artifacts == null || artifacts.isEmpty() )\n                {\n                    artifacts = directArtifacts;\n                }\n                else\n                {\n                    List<Artifact> allArtifacts = new ArrayList<Artifact>();\n                    allArtifacts.addAll( artifacts );\n                    allArtifacts.addAll( directArtifacts );\n\n                    Map<String, Artifact> mergedArtifacts = new LinkedHashMap<String, Artifact>();\n                    for ( Artifact artifact : allArtifacts )\n                    {\n                        String conflictId = artifact.getDependencyConflictId();\n                        if ( !mergedArtifacts.containsKey( conflictId ) )\n                        {\n                            mergedArtifacts.put( conflictId, artifact );\n                        }\n                    }\n\n                    artifacts = new LinkedHashSet<Artifact>( mergedArtifacts.values() );\n                }\n            }\n            catch ( ArtifactMetadataRetrievalException e )\n            {\n                // need to add metadata resolution exception\n                return result;\n            }\n        }\n        \n        if ( artifacts == null || artifacts.size() == 0 )\n        {\n            result.addArtifact( rootArtifact );            \n            return result;\n        } \n                                \n        // After the collection we will have the artifact object in the result but they will not be resolved yet.\n        result = artifactCollector.collect( artifacts, rootArtifact, managedVersions, localRepository, remoteRepositories, source, filter, listeners, null );\n                        \n        // We have metadata retrieval problems, or there are cycles that have been detected\n        // so we give this back to the calling code and let them deal with this information\n        // appropriately.\n\n        if ( result.hasMetadataResolutionExceptions() || result.hasVersionRangeViolations() || result.hasCircularDependencyExceptions() )\n        {\n            return result;\n        }\n                \n        if ( result.getArtifacts() != null )\n        {\n            for ( Artifact artifact : result.getArtifacts() )\n            {\n                try\n                {\n                    resolve( artifact, remoteRepositories, localRepository, request.getTransferListener() );\n                }\n                catch ( ArtifactNotFoundException anfe )\n                {\n                    // These are cases where the artifact just isn't present in any of the remote repositories\n                    // because it wasn't deployed, or it was deployed in the wrong place.\n\n                    result.addMissingArtifact( artifact );\n                }\n                catch ( ArtifactResolutionException e )\n                {\n                    // This is really a wagon TransferFailedException so something went wrong after we successfully\n                    // retrieved the metadata.\n\n                    result.addErrorArtifactException( e );\n                }\n            }\n        }\n                \n        // We want to send the root artifact back in the result but we need to do this after the other dependencies\n        // have been resolved.\n        if ( request.isResolveRoot() && !isDummy( request ) )\n        {\n            // Add the root artifact (as the first artifact to retain logical order of class path!)\n            Set<Artifact> allArtifacts = new LinkedHashSet<Artifact>();\n            allArtifacts.add( rootArtifact );\n            allArtifacts.addAll( result.getArtifacts() );\n            result.setArtifacts( allArtifacts );\n        }                        \n                 \n        return result;\n    }","id":60486,"modified_method":"public ArtifactResolutionResult resolve( ArtifactResolutionRequest request )\n    {\n        Artifact rootArtifact = request.getArtifact();\n        Set<Artifact> artifacts = request.getArtifactDependencies();\n        Map managedVersions = request.getManagedVersionMap();\n        ArtifactRepository localRepository = request.getLocalRepository();\n        List<ArtifactRepository> remoteRepositories = request.getRemoteRepostories();\n        List<ResolutionListener> listeners = request.getListeners();\n        ArtifactFilter filter = request.getFilter();                       \n        \n        //TODO: hack because metadata isn't generated in m2e correctly and i want to run the maven i have in the workspace\n        if ( source == null )\n        {\n            try\n            {\n                source = container.lookup( ArtifactMetadataSource.class );\n            }\n            catch ( ComponentLookupException e )\n            {\n                e.printStackTrace();\n                // won't happen\n            }\n        }\n\n        if ( listeners == null )\n        {\n            listeners = new ArrayList<ResolutionListener>();\n\n            if ( logger.isDebugEnabled() )\n            {\n                listeners.add( new DebugResolutionListener( logger ) );\n            }\n\n            listeners.add( new WarningResolutionListener( logger ) );\n        }\n\n        ArtifactResolutionResult result = new ArtifactResolutionResult();\n\n        // The root artifact may, or may not be resolved so we need to check before we attempt to resolve.\n        // This is often an artifact like a POM that is taken from disk and we already have hold of the\n        // file reference. But this may be a Maven Plugin that we need to resolve from a remote repository\n        // as well as its dependencies.\n                        \n        if ( request.isResolveRoot() && rootArtifact.getFile() == null )\n        {            \n            try\n            {\n                resolve( rootArtifact, remoteRepositories, localRepository );\n            }\n            catch ( ArtifactResolutionException e )\n            {\n                result.addErrorArtifactException( e );\n                return result;\n            }\n            catch ( ArtifactNotFoundException e )\n            {\n                result.addMissingArtifact( request.getArtifact() );\n                return result;\n            }\n        }\n        \n        if ( request.isResolveTransitively() )\n        {\n            try\n            {\n                Set<Artifact> directArtifacts = source.retrieve( rootArtifact, localRepository, remoteRepositories ).getArtifacts();\n\n                if ( artifacts == null || artifacts.isEmpty() )\n                {\n                    artifacts = directArtifacts;\n                }\n                else\n                {\n                    List<Artifact> allArtifacts = new ArrayList<Artifact>();\n                    allArtifacts.addAll( artifacts );\n                    allArtifacts.addAll( directArtifacts );\n\n                    Map<String, Artifact> mergedArtifacts = new LinkedHashMap<String, Artifact>();\n                    for ( Artifact artifact : allArtifacts )\n                    {\n                        String conflictId = artifact.getDependencyConflictId();\n                        if ( !mergedArtifacts.containsKey( conflictId ) )\n                        {\n                            mergedArtifacts.put( conflictId, artifact );\n                        }\n                    }\n\n                    artifacts = new LinkedHashSet<Artifact>( mergedArtifacts.values() );\n                }\n            }\n            catch ( ArtifactMetadataRetrievalException e )\n            {\n                // need to add metadata resolution exception\n                return result;\n            }\n        }\n        \n        if ( artifacts == null || artifacts.size() == 0 )\n        {\n            result.addArtifact( rootArtifact );            \n            return result;\n        } \n                                \n        // After the collection we will have the artifact object in the result but they will not be resolved yet.\n        result = artifactCollector.collect( artifacts, rootArtifact, managedVersions, localRepository, remoteRepositories, source, filter, listeners, null );\n                        \n        // We have metadata retrieval problems, or there are cycles that have been detected\n        // so we give this back to the calling code and let them deal with this information\n        // appropriately.\n\n        if ( result.hasMetadataResolutionExceptions() || result.hasVersionRangeViolations() || result.hasCircularDependencyExceptions() )\n        {\n            return result;\n        }\n                \n        if ( result.getArtifacts() != null )\n        {\n            for ( Artifact artifact : result.getArtifacts() )\n            {\n                try\n                {\n                    resolve( artifact, remoteRepositories, localRepository, request.getTransferListener() );\n                }\n                catch ( ArtifactNotFoundException anfe )\n                {\n                    // These are cases where the artifact just isn't present in any of the remote repositories\n                    // because it wasn't deployed, or it was deployed in the wrong place.\n\n                    result.addMissingArtifact( artifact );\n                }\n                catch ( ArtifactResolutionException e )\n                {\n                    // This is really a wagon TransferFailedException so something went wrong after we successfully\n                    // retrieved the metadata.\n\n                    result.addErrorArtifactException( e );\n                }\n            }\n        }\n                \n        // We want to send the root artifact back in the result but we need to do this after the other dependencies\n        // have been resolved.\n        if ( request.isResolveRoot() )\n        {\n            // Add the root artifact (as the first artifact to retain logical order of class path!)\n            Set<Artifact> allArtifacts = new LinkedHashSet<Artifact>();\n            allArtifacts.add( rootArtifact );\n            allArtifacts.addAll( result.getArtifacts() );\n            result.setArtifacts( allArtifacts );\n        }                        \n                 \n        return result;\n    }","commit_id":"8b22b2dffa01a5276cbae8fd22444275e82cd74c","url":"https://github.com/apache/maven"},{"original_method":"public ArtifactResolutionResult resolveTransitively( Set<Artifact> artifacts, Artifact originatingArtifact, Map managedVersions, ArtifactRepository localRepository,\n                                                         List<ArtifactRepository> remoteRepositories, ArtifactMetadataSource source, ArtifactFilter filter, List<ResolutionListener> listeners,\n                                                         List<ConflictResolver> conflictResolvers )\n        throws ArtifactResolutionException, ArtifactNotFoundException\n    {\n        ArtifactResolutionRequest request = new ArtifactResolutionRequest().setArtifact( originatingArtifact ).setArtifactDependencies( artifacts ).setManagedVersionMap( managedVersions )\n            .setLocalRepository( localRepository ).setRemoteRepostories( remoteRepositories ).setMetadataSource( source ).setFilter( filter ).setListeners( listeners );\n\n        return resolveWithExceptions( request );\n    }","id":60487,"modified_method":"public ArtifactResolutionResult resolveTransitively( Set<Artifact> artifacts, Artifact originatingArtifact, Map managedVersions, ArtifactRepository localRepository,\n                                                         List<ArtifactRepository> remoteRepositories, ArtifactMetadataSource source, ArtifactFilter filter, List<ResolutionListener> listeners,\n                                                         List<ConflictResolver> conflictResolvers )\n        throws ArtifactResolutionException, ArtifactNotFoundException\n    {\n        ArtifactResolutionRequest request = new ArtifactResolutionRequest().setArtifact( originatingArtifact ).setResolveRoot( false ).setArtifactDependencies( artifacts ).setManagedVersionMap( managedVersions )\n            .setLocalRepository( localRepository ).setRemoteRepostories( remoteRepositories ).setMetadataSource( source ).setFilter( filter ).setListeners( listeners );\n\n        return resolveWithExceptions( request );\n    }","commit_id":"5ad4dc1cc6dc84fb981d863e68e4614f9da15be1","url":"https://github.com/apache/maven"},{"original_method":"public ArtifactResolutionResult resolve( ArtifactResolutionRequest request )\n    {\n        Artifact rootArtifact = request.getArtifact();\n        Set<Artifact> artifacts = request.getArtifactDependencies();\n        Map managedVersions = request.getManagedVersionMap();\n        ArtifactRepository localRepository = request.getLocalRepository();\n        List<ArtifactRepository> remoteRepositories = request.getRemoteRepostories();\n        ArtifactMetadataSource source = request.getMetadataSource();\n        List<ResolutionListener> listeners = request.getListeners();\n        ArtifactFilter filter = request.getFilter();\n\n        if ( listeners == null )\n        {\n            listeners = new ArrayList<ResolutionListener>();\n\n            if ( getLogger().isDebugEnabled() )\n            {\n                listeners.add( new DebugResolutionListener( getLogger() ) );\n            }\n\n            listeners.add( new WarningResolutionListener( getLogger() ) );\n        }\n\n        ArtifactResolutionResult result = new ArtifactResolutionResult();\n\n        // The root artifact may, or may not be resolved so we need to check before we attempt to resolve.\n        // This is often an artifact like a POM that is taken from disk and we already have hold of the\n        // file reference. But this may be a Maven Plugin that we need to resolve from a remote repository\n        // as well as its dependencies.\n        \n        if ( rootArtifact.getFile() == null )\n        {\n            try\n            {\n                resolve( rootArtifact, remoteRepositories, localRepository );\n                result.addArtifact( rootArtifact );\n            }\n            catch ( ArtifactResolutionException e )\n            {\n                result.addErrorArtifactException( e );\n                return result;\n            }\n            catch ( ArtifactNotFoundException e )\n            {\n                result.addMissingArtifact( request.getArtifact() );\n                return result;\n            }\n        }\n\n        if ( artifacts == null || artifacts.size() == 0 )\n        {\n            return result;\n        } \n        \n        // After the collection we will have the artifact object in the result but they will not be resolved yet.\n        result = artifactCollector.collect( artifacts, rootArtifact, managedVersions, localRepository, remoteRepositories, source, filter, listeners );\n\n        // We have metadata retrieval problems, or there are cycles that have been detected\n        // so we give this back to the calling code and let them deal with this information\n        // appropriately.\n\n        if ( result.hasMetadataResolutionExceptions() || result.hasVersionRangeViolations() || result.hasCircularDependencyExceptions() )\n        {\n            return result;\n        }\n\n        if ( result.getArtifacts() != null )\n        {\n            for ( Artifact artifact : result.getArtifacts() )\n            {\n                try\n                {\n                    resolve( artifact, remoteRepositories, localRepository );\n                }\n                catch ( ArtifactNotFoundException anfe )\n                {\n                    // These are cases where the artifact just isn't present in any of the remote repositories\n                    // because it wasn't deployed, or it was deployed in the wrong place.\n\n                    result.addMissingArtifact( artifact );\n                }\n                catch ( ArtifactResolutionException e )\n                {\n                    // This is really a wagon TransferFailedException so something went wrong after we successfully\n                    // retrieved the metadata.\n\n                    result.addErrorArtifactException( e );\n                }\n            }\n        }\n\n        return result;\n    }","id":60488,"modified_method":"public ArtifactResolutionResult resolve( ArtifactResolutionRequest request )\n    {\n        Artifact rootArtifact = request.getArtifact();\n        Set<Artifact> artifacts = request.getArtifactDependencies();\n        Map managedVersions = request.getManagedVersionMap();\n        ArtifactRepository localRepository = request.getLocalRepository();\n        List<ArtifactRepository> remoteRepositories = request.getRemoteRepostories();\n        ArtifactMetadataSource source = request.getMetadataSource();\n        List<ResolutionListener> listeners = request.getListeners();\n        ArtifactFilter filter = request.getFilter();\n\n        if ( listeners == null )\n        {\n            listeners = new ArrayList<ResolutionListener>();\n\n            if ( getLogger().isDebugEnabled() )\n            {\n                listeners.add( new DebugResolutionListener( getLogger() ) );\n            }\n\n            listeners.add( new WarningResolutionListener( getLogger() ) );\n        }\n\n        ArtifactResolutionResult result = new ArtifactResolutionResult();\n\n        // The root artifact may, or may not be resolved so we need to check before we attempt to resolve.\n        // This is often an artifact like a POM that is taken from disk and we already have hold of the\n        // file reference. But this may be a Maven Plugin that we need to resolve from a remote repository\n        // as well as its dependencies.\n        \n        if ( request.isResolveRoot() && rootArtifact.getFile() == null )\n        {\n            try\n            {\n                resolve( rootArtifact, remoteRepositories, localRepository );\n                result.addArtifact( rootArtifact );\n            }\n            catch ( ArtifactResolutionException e )\n            {\n                result.addErrorArtifactException( e );\n                return result;\n            }\n            catch ( ArtifactNotFoundException e )\n            {\n                result.addMissingArtifact( request.getArtifact() );\n                return result;\n            }\n        }\n\n        if ( artifacts == null || artifacts.size() == 0 )\n        {\n            return result;\n        } \n        \n        // After the collection we will have the artifact object in the result but they will not be resolved yet.\n        result = artifactCollector.collect( artifacts, rootArtifact, managedVersions, localRepository, remoteRepositories, source, filter, listeners );\n\n        // We have metadata retrieval problems, or there are cycles that have been detected\n        // so we give this back to the calling code and let them deal with this information\n        // appropriately.\n\n        if ( result.hasMetadataResolutionExceptions() || result.hasVersionRangeViolations() || result.hasCircularDependencyExceptions() )\n        {\n            return result;\n        }\n\n        if ( result.getArtifacts() != null )\n        {\n            for ( Artifact artifact : result.getArtifacts() )\n            {\n                try\n                {\n                    resolve( artifact, remoteRepositories, localRepository );\n                }\n                catch ( ArtifactNotFoundException anfe )\n                {\n                    // These are cases where the artifact just isn't present in any of the remote repositories\n                    // because it wasn't deployed, or it was deployed in the wrong place.\n\n                    result.addMissingArtifact( artifact );\n                }\n                catch ( ArtifactResolutionException e )\n                {\n                    // This is really a wagon TransferFailedException so something went wrong after we successfully\n                    // retrieved the metadata.\n\n                    result.addErrorArtifactException( e );\n                }\n            }\n        }\n\n        return result;\n    }","commit_id":"5ad4dc1cc6dc84fb981d863e68e4614f9da15be1","url":"https://github.com/apache/maven"},{"original_method":"protected SearchContext(ParseFieldMatcher parseFieldMatcher) {\n        this.parseFieldMatcher = parseFieldMatcher;\n    }","id":60489,"modified_method":"protected SearchContext(ParseFieldMatcher parseFieldMatcher) {\n        super(\"search_context\");\n        this.parseFieldMatcher = parseFieldMatcher;\n    }","commit_id":"29336b231bf67eaf39b179a6c8f041762e1699b6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public final void close() {\n        if (closed.compareAndSet(false, true)) { // prevent double release\n            try {\n                clearReleasables(Lifetime.CONTEXT);\n            } finally {\n                doClose();\n            }\n        }\n    }","id":60490,"modified_method":"@Override\n    public final void close() {\n        if (closed.compareAndSet(false, true)) { // prevent double closing\n            decRef();\n        }\n    }","commit_id":"29336b231bf67eaf39b179a6c8f041762e1699b6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void cleanContext(SearchContext context) {\n        assert context == SearchContext.current();\n        context.clearReleasables(Lifetime.PHASE);\n        SearchContext.removeCurrent();\n    }","id":60491,"modified_method":"private void cleanContext(SearchContext context) {\n        try {\n            assert context == SearchContext.current();\n            context.clearReleasables(Lifetime.PHASE);\n            SearchContext.removeCurrent();\n        } finally {\n            context.decRef();\n        }\n    }","commit_id":"29336b231bf67eaf39b179a6c8f041762e1699b6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public DfsSearchResult executeDfsPhase(ShardSearchRequest request) throws IOException {\n        final SearchContext context = createAndPutContext(request);\n        try {\n            contextProcessing(context);\n            dfsPhase.execute(context);\n            contextProcessedSuccessfully(context);\n            return context.dfsResult();\n        } catch (Exception e) {\n            logger.trace(\"Dfs phase failed\", e);\n            processFailure(context, e);\n            throw ExceptionsHelper.convertToRuntime(e);\n        } finally {\n            cleanContext(context);\n        }\n    }","id":60492,"modified_method":"public DfsSearchResult executeDfsPhase(ShardSearchRequest request) throws IOException {\n        final SearchContext context = createAndPutContext(request);\n        context.incRef();\n        try {\n            contextProcessing(context);\n            dfsPhase.execute(context);\n            contextProcessedSuccessfully(context);\n            return context.dfsResult();\n        } catch (Exception e) {\n            logger.trace(\"Dfs phase failed\", e);\n            processFailure(context, e);\n            throw ExceptionsHelper.convertToRuntime(e);\n        } finally {\n            cleanContext(context);\n        }\n    }","commit_id":"29336b231bf67eaf39b179a6c8f041762e1699b6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public QuerySearchResultProvider executeQueryPhase(ShardSearchRequest request) throws IOException {\n        final SearchContext context = createAndPutContext(request);\n        final SearchOperationListener operationListener = context.indexShard().getSearchOperationListener();\n        try {\n            operationListener.onPreQueryPhase(context);\n            long time = System.nanoTime();\n            contextProcessing(context);\n\n            loadOrExecuteQueryPhase(request, context);\n\n            if (context.queryResult().hasHits() == false && context.scrollContext() == null) {\n                freeContext(context.id());\n            } else {\n                contextProcessedSuccessfully(context);\n            }\n            operationListener.onQueryPhase(context, System.nanoTime() - time);\n\n            return context.queryResult();\n        } catch (Exception e) {\n            // execution exception can happen while loading the cache, strip it\n            if (e instanceof ExecutionException) {\n                e = (e.getCause() == null || e.getCause() instanceof Exception) ?\n                        (Exception) e.getCause() : new ElasticsearchException(e.getCause());\n            }\n            operationListener.onFailedQueryPhase(context);\n            logger.trace(\"Query phase failed\", e);\n            processFailure(context, e);\n            throw ExceptionsHelper.convertToRuntime(e);\n        } finally {\n            cleanContext(context);\n        }\n    }","id":60493,"modified_method":"public QuerySearchResultProvider executeQueryPhase(ShardSearchRequest request) throws IOException {\n        final SearchContext context = createAndPutContext(request);\n        final SearchOperationListener operationListener = context.indexShard().getSearchOperationListener();\n        context.incRef();\n        try {\n            operationListener.onPreQueryPhase(context);\n            long time = System.nanoTime();\n            contextProcessing(context);\n\n            loadOrExecuteQueryPhase(request, context);\n\n            if (context.queryResult().hasHits() == false && context.scrollContext() == null) {\n                freeContext(context.id());\n            } else {\n                contextProcessedSuccessfully(context);\n            }\n            operationListener.onQueryPhase(context, System.nanoTime() - time);\n\n            return context.queryResult();\n        } catch (Exception e) {\n            // execution exception can happen while loading the cache, strip it\n            if (e instanceof ExecutionException) {\n                e = (e.getCause() == null || e.getCause() instanceof Exception) ?\n                        (Exception) e.getCause() : new ElasticsearchException(e.getCause());\n            }\n            operationListener.onFailedQueryPhase(context);\n            logger.trace(\"Query phase failed\", e);\n            processFailure(context, e);\n            throw ExceptionsHelper.convertToRuntime(e);\n        } finally {\n            cleanContext(context);\n        }\n    }","commit_id":"29336b231bf67eaf39b179a6c8f041762e1699b6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public FetchSearchResult executeFetchPhase(ShardFetchRequest request) {\n        final SearchContext context = findContext(request.id());\n        contextProcessing(context);\n        final SearchOperationListener operationListener = context.indexShard().getSearchOperationListener();\n        try {\n            if (request.lastEmittedDoc() != null) {\n                context.scrollContext().lastEmittedDoc = request.lastEmittedDoc();\n            }\n            context.docIdsToLoad(request.docIds(), 0, request.docIdsSize());\n            operationListener.onPreFetchPhase(context);\n            long time = System.nanoTime();\n            fetchPhase.execute(context);\n            if (fetchPhaseShouldFreeContext(context)) {\n                freeContext(request.id());\n            } else {\n                contextProcessedSuccessfully(context);\n            }\n            operationListener.onFetchPhase(context, System.nanoTime() - time);\n            return context.fetchResult();\n        } catch (Exception e) {\n            operationListener.onFailedFetchPhase(context);\n            logger.trace(\"Fetch phase failed\", e);\n            processFailure(context, e);\n            throw ExceptionsHelper.convertToRuntime(e);\n        } finally {\n            cleanContext(context);\n        }\n    }","id":60494,"modified_method":"public FetchSearchResult executeFetchPhase(ShardFetchRequest request) {\n        final SearchContext context = findContext(request.id());\n        final SearchOperationListener operationListener = context.indexShard().getSearchOperationListener();\n        context.incRef();\n        try {\n            contextProcessing(context);\n            if (request.lastEmittedDoc() != null) {\n                context.scrollContext().lastEmittedDoc = request.lastEmittedDoc();\n            }\n            context.docIdsToLoad(request.docIds(), 0, request.docIdsSize());\n            operationListener.onPreFetchPhase(context);\n            long time = System.nanoTime();\n            fetchPhase.execute(context);\n            if (fetchPhaseShouldFreeContext(context)) {\n                freeContext(request.id());\n            } else {\n                contextProcessedSuccessfully(context);\n            }\n            operationListener.onFetchPhase(context, System.nanoTime() - time);\n            return context.fetchResult();\n        } catch (Exception e) {\n            operationListener.onFailedFetchPhase(context);\n            logger.trace(\"Fetch phase failed\", e);\n            processFailure(context, e);\n            throw ExceptionsHelper.convertToRuntime(e);\n        } finally {\n            cleanContext(context);\n        }\n    }","commit_id":"29336b231bf67eaf39b179a6c8f041762e1699b6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public ScrollQuerySearchResult executeQueryPhase(InternalScrollSearchRequest request) {\n        final SearchContext context = findContext(request.id());\n        SearchOperationListener operationListener = context.indexShard().getSearchOperationListener();\n        try {\n            operationListener.onPreQueryPhase(context);\n            long time = System.nanoTime();\n            contextProcessing(context);\n            processScroll(request, context);\n            queryPhase.execute(context);\n            contextProcessedSuccessfully(context);\n            operationListener.onQueryPhase(context, System.nanoTime() - time);\n            return new ScrollQuerySearchResult(context.queryResult(), context.shardTarget());\n        } catch (Exception e) {\n            operationListener.onFailedQueryPhase(context);\n            logger.trace(\"Query phase failed\", e);\n            processFailure(context, e);\n            throw ExceptionsHelper.convertToRuntime(e);\n        } finally {\n            cleanContext(context);\n        }\n    }","id":60495,"modified_method":"public ScrollQuerySearchResult executeQueryPhase(InternalScrollSearchRequest request) {\n        final SearchContext context = findContext(request.id());\n        SearchOperationListener operationListener = context.indexShard().getSearchOperationListener();\n        context.incRef();\n        try {\n            operationListener.onPreQueryPhase(context);\n            long time = System.nanoTime();\n            contextProcessing(context);\n            processScroll(request, context);\n            queryPhase.execute(context);\n            contextProcessedSuccessfully(context);\n            operationListener.onQueryPhase(context, System.nanoTime() - time);\n            return new ScrollQuerySearchResult(context.queryResult(), context.shardTarget());\n        } catch (Exception e) {\n            operationListener.onFailedQueryPhase(context);\n            logger.trace(\"Query phase failed\", e);\n            processFailure(context, e);\n            throw ExceptionsHelper.convertToRuntime(e);\n        } finally {\n            cleanContext(context);\n        }\n    }","commit_id":"29336b231bf67eaf39b179a6c8f041762e1699b6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public boolean freeContext(long id) {\n        final SearchContext context = removeContext(id);\n        if (context != null) {\n            try {\n                context.indexShard().getSearchOperationListener().onFreeContext(context);\n                if (context.scrollContext() != null) {\n                    context.indexShard().getSearchOperationListener().onFreeScrollContext(context);\n                }\n            } finally {\n                context.close();\n            }\n            return true;\n        }\n        return false;\n    }","id":60496,"modified_method":"public boolean freeContext(long id) {\n        final SearchContext context = removeContext(id);\n        if (context != null) {\n            assert context.refCount() > 0 : \" refCount must be > 0: \" + context.refCount();\n            try {\n                context.indexShard().getSearchOperationListener().onFreeContext(context);\n                if (context.scrollContext() != null) {\n                    context.indexShard().getSearchOperationListener().onFreeScrollContext(context);\n                }\n            } finally {\n                context.close();\n            }\n            return true;\n        }\n        return false;\n    }","commit_id":"29336b231bf67eaf39b179a6c8f041762e1699b6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public ScrollQueryFetchSearchResult executeFetchPhase(InternalScrollSearchRequest request) {\n        final SearchContext context = findContext(request.id());\n        contextProcessing(context);\n        try {\n            SearchOperationListener operationListener = context.indexShard().getSearchOperationListener();\n            processScroll(request, context);\n            operationListener.onPreQueryPhase(context);\n            long time = System.nanoTime();\n            try {\n                queryPhase.execute(context);\n            } catch (Exception e) {\n                operationListener.onFailedQueryPhase(context);\n                throw ExceptionsHelper.convertToRuntime(e);\n            }\n            long time2 = System.nanoTime();\n            operationListener.onQueryPhase(context, time2 - time);\n            operationListener.onPreFetchPhase(context);\n            try {\n                shortcutDocIdsToLoad(context);\n                fetchPhase.execute(context);\n                if (fetchPhaseShouldFreeContext(context)) {\n                    freeContext(request.id());\n                } else {\n                    contextProcessedSuccessfully(context);\n                }\n            } catch (Exception e) {\n                operationListener.onFailedFetchPhase(context);\n                throw ExceptionsHelper.convertToRuntime(e);\n            }\n            operationListener.onFetchPhase(context, System.nanoTime() - time2);\n            return new ScrollQueryFetchSearchResult(new QueryFetchSearchResult(context.queryResult(), context.fetchResult()), context.shardTarget());\n        } catch (Exception e) {\n            logger.trace(\"Fetch phase failed\", e);\n            processFailure(context, e);\n            throw ExceptionsHelper.convertToRuntime(e);\n        } finally {\n            cleanContext(context);\n        }\n    }","id":60497,"modified_method":"public ScrollQueryFetchSearchResult executeFetchPhase(InternalScrollSearchRequest request) {\n        final SearchContext context = findContext(request.id());\n        context.incRef();\n        try {\n            contextProcessing(context);\n            SearchOperationListener operationListener = context.indexShard().getSearchOperationListener();\n            processScroll(request, context);\n            operationListener.onPreQueryPhase(context);\n            long time = System.nanoTime();\n            try {\n                queryPhase.execute(context);\n            } catch (Exception e) {\n                operationListener.onFailedQueryPhase(context);\n                throw ExceptionsHelper.convertToRuntime(e);\n            }\n            long time2 = System.nanoTime();\n            operationListener.onQueryPhase(context, time2 - time);\n            operationListener.onPreFetchPhase(context);\n            try {\n                shortcutDocIdsToLoad(context);\n                fetchPhase.execute(context);\n                if (fetchPhaseShouldFreeContext(context)) {\n                    freeContext(request.id());\n                } else {\n                    contextProcessedSuccessfully(context);\n                }\n            } catch (Exception e) {\n                operationListener.onFailedFetchPhase(context);\n                throw ExceptionsHelper.convertToRuntime(e);\n            }\n            operationListener.onFetchPhase(context, System.nanoTime() - time2);\n            return new ScrollQueryFetchSearchResult(new QueryFetchSearchResult(context.queryResult(), context.fetchResult()), context.shardTarget());\n        } catch (Exception e) {\n            logger.trace(\"Fetch phase failed\", e);\n            processFailure(context, e);\n            throw ExceptionsHelper.convertToRuntime(e);\n        } finally {\n            cleanContext(context);\n        }\n    }","commit_id":"29336b231bf67eaf39b179a6c8f041762e1699b6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public QueryFetchSearchResult executeFetchPhase(QuerySearchRequest request) {\n        final SearchContext context = findContext(request.id());\n        contextProcessing(context);\n        context.searcher().setAggregatedDfs(request.dfs());\n        try {\n            SearchOperationListener operationListener = context.indexShard().getSearchOperationListener();\n            operationListener.onPreQueryPhase(context);\n            long time = System.nanoTime();\n            try {\n                queryPhase.execute(context);\n            } catch (Exception e) {\n                operationListener.onFailedQueryPhase(context);\n                throw ExceptionsHelper.convertToRuntime(e);\n            }\n            long time2 = System.nanoTime();\n            operationListener.onQueryPhase(context, time2 - time);\n            operationListener.onPreFetchPhase(context);\n            try {\n                shortcutDocIdsToLoad(context);\n                fetchPhase.execute(context);\n                if (fetchPhaseShouldFreeContext(context)) {\n                    freeContext(request.id());\n                } else {\n                    contextProcessedSuccessfully(context);\n                }\n            } catch (Exception e) {\n                operationListener.onFailedFetchPhase(context);\n                throw ExceptionsHelper.convertToRuntime(e);\n            }\n            operationListener.onFetchPhase(context, System.nanoTime() - time2);\n            return new QueryFetchSearchResult(context.queryResult(), context.fetchResult());\n        } catch (Exception e) {\n            logger.trace(\"Fetch phase failed\", e);\n            processFailure(context, e);\n            throw ExceptionsHelper.convertToRuntime(e);\n        } finally {\n            cleanContext(context);\n        }\n    }","id":60498,"modified_method":"public QueryFetchSearchResult executeFetchPhase(QuerySearchRequest request) {\n        final SearchContext context = findContext(request.id());\n        context.incRef();\n        try {\n            contextProcessing(context);\n            context.searcher().setAggregatedDfs(request.dfs());\n            SearchOperationListener operationListener = context.indexShard().getSearchOperationListener();\n            operationListener.onPreQueryPhase(context);\n            long time = System.nanoTime();\n            try {\n                queryPhase.execute(context);\n            } catch (Exception e) {\n                operationListener.onFailedQueryPhase(context);\n                throw ExceptionsHelper.convertToRuntime(e);\n            }\n            long time2 = System.nanoTime();\n            operationListener.onQueryPhase(context, time2 - time);\n            operationListener.onPreFetchPhase(context);\n            try {\n                shortcutDocIdsToLoad(context);\n                fetchPhase.execute(context);\n                if (fetchPhaseShouldFreeContext(context)) {\n                    freeContext(request.id());\n                } else {\n                    contextProcessedSuccessfully(context);\n                }\n            } catch (Exception e) {\n                operationListener.onFailedFetchPhase(context);\n                throw ExceptionsHelper.convertToRuntime(e);\n            }\n            operationListener.onFetchPhase(context, System.nanoTime() - time2);\n            return new QueryFetchSearchResult(context.queryResult(), context.fetchResult());\n        } catch (Exception e) {\n            logger.trace(\"Fetch phase failed\", e);\n            processFailure(context, e);\n            throw ExceptionsHelper.convertToRuntime(e);\n        } finally {\n            cleanContext(context);\n        }\n    }","commit_id":"29336b231bf67eaf39b179a6c8f041762e1699b6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public QuerySearchResult executeQueryPhase(QuerySearchRequest request) {\n        final SearchContext context = findContext(request.id());\n        contextProcessing(context);\n        context.searcher().setAggregatedDfs(request.dfs());\n        IndexShard indexShard = context.indexShard();\n        SearchOperationListener operationListener = indexShard.getSearchOperationListener();\n        try {\n            operationListener.onPreQueryPhase(context);\n            long time = System.nanoTime();\n            queryPhase.execute(context);\n            if (context.queryResult().hasHits() == false && context.scrollContext() == null) {\n                // no hits, we can release the context since there will be no fetch phase\n                freeContext(context.id());\n            } else {\n                contextProcessedSuccessfully(context);\n            }\n            operationListener.onQueryPhase(context, System.nanoTime() - time);\n            return context.queryResult();\n        } catch (Exception e) {\n            operationListener.onFailedQueryPhase(context);\n            logger.trace(\"Query phase failed\", e);\n            processFailure(context, e);\n            throw ExceptionsHelper.convertToRuntime(e);\n        } finally {\n            cleanContext(context);\n        }\n    }","id":60499,"modified_method":"public QuerySearchResult executeQueryPhase(QuerySearchRequest request) {\n        final SearchContext context = findContext(request.id());\n        IndexShard indexShard = context.indexShard();\n        SearchOperationListener operationListener = indexShard.getSearchOperationListener();\n        context.incRef();\n        try {\n            contextProcessing(context);\n            context.searcher().setAggregatedDfs(request.dfs());\n\n            operationListener.onPreQueryPhase(context);\n            long time = System.nanoTime();\n            queryPhase.execute(context);\n            if (context.queryResult().hasHits() == false && context.scrollContext() == null) {\n                // no hits, we can release the context since there will be no fetch phase\n                freeContext(context.id());\n            } else {\n                contextProcessedSuccessfully(context);\n            }\n            operationListener.onQueryPhase(context, System.nanoTime() - time);\n            return context.queryResult();\n        } catch (Exception e) {\n            operationListener.onFailedQueryPhase(context);\n            logger.trace(\"Query phase failed\", e);\n            processFailure(context, e);\n            throw ExceptionsHelper.convertToRuntime(e);\n        } finally {\n            cleanContext(context);\n        }\n    }","commit_id":"29336b231bf67eaf39b179a6c8f041762e1699b6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public QueryFetchSearchResult executeFetchPhase(ShardSearchRequest request) throws IOException {\n        final SearchContext context = createAndPutContext(request);\n        contextProcessing(context);\n        try {\n            SearchOperationListener operationListener = context.indexShard().getSearchOperationListener();\n            operationListener.onPreQueryPhase(context);\n            long time = System.nanoTime();\n            try {\n                loadOrExecuteQueryPhase(request, context);\n            } catch (Exception e) {\n                operationListener.onFailedQueryPhase(context);\n                throw ExceptionsHelper.convertToRuntime(e);\n            }\n            long time2 = System.nanoTime();\n            operationListener.onQueryPhase(context, time2 - time);\n            operationListener.onPreFetchPhase(context);\n            try {\n                shortcutDocIdsToLoad(context);\n                fetchPhase.execute(context);\n                if (fetchPhaseShouldFreeContext(context)) {\n                    freeContext(context.id());\n                } else {\n                    contextProcessedSuccessfully(context);\n                }\n            } catch (Exception e) {\n                operationListener.onFailedFetchPhase(context);\n                throw ExceptionsHelper.convertToRuntime(e);\n            }\n            operationListener.onFetchPhase(context, System.nanoTime() - time2);\n            return new QueryFetchSearchResult(context.queryResult(), context.fetchResult());\n        } catch (Exception e) {\n            logger.trace(\"Fetch phase failed\", e);\n            processFailure(context, e);\n            throw ExceptionsHelper.convertToRuntime(e);\n        } finally {\n            cleanContext(context);\n        }\n    }","id":60500,"modified_method":"public QueryFetchSearchResult executeFetchPhase(ShardSearchRequest request) throws IOException {\n        final SearchContext context = createAndPutContext(request);\n        context.incRef();\n        try {\n            contextProcessing(context);\n            SearchOperationListener operationListener = context.indexShard().getSearchOperationListener();\n            operationListener.onPreQueryPhase(context);\n            long time = System.nanoTime();\n            try {\n                loadOrExecuteQueryPhase(request, context);\n            } catch (Exception e) {\n                operationListener.onFailedQueryPhase(context);\n                throw ExceptionsHelper.convertToRuntime(e);\n            }\n            long time2 = System.nanoTime();\n            operationListener.onQueryPhase(context, time2 - time);\n            operationListener.onPreFetchPhase(context);\n            try {\n                shortcutDocIdsToLoad(context);\n                fetchPhase.execute(context);\n                if (fetchPhaseShouldFreeContext(context)) {\n                    freeContext(context.id());\n                } else {\n                    contextProcessedSuccessfully(context);\n                }\n            } catch (Exception e) {\n                operationListener.onFailedFetchPhase(context);\n                throw ExceptionsHelper.convertToRuntime(e);\n            }\n            operationListener.onFetchPhase(context, System.nanoTime() - time2);\n            return new QueryFetchSearchResult(context.queryResult(), context.fetchResult());\n        } catch (Exception e) {\n            logger.trace(\"Fetch phase failed\", e);\n            processFailure(context, e);\n            throw ExceptionsHelper.convertToRuntime(e);\n        } finally {\n            cleanContext(context);\n        }\n    }","commit_id":"29336b231bf67eaf39b179a6c8f041762e1699b6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    void installActionButtons() {\n        super.installActionButtons();\n        if (plusButton == null) {\n            plusButton = ActionUtils.createButton(new ExpandClusterAction(this), ActionUtils.ActionTextBehavior.HIDE);\n            minusButton = ActionUtils.createButton(new CollapseClusterAction(this), ActionUtils.ActionTextBehavior.HIDE);\n            controlsHBox.getChildren().addAll(minusButton, plusButton);\n\n            configureActionButton(plusButton);\n            configureActionButton(minusButton);\n        }\n    }","id":60501,"modified_method":"@Override\n    void installActionButtons() {\n        super.installActionButtons();\n        if (plusButton == null) {\n            plusButton = getNewExpandButton();\n            minusButton = getNewCollapseButton();\n            controlsHBox.getChildren().addAll(minusButton, plusButton);\n            \n            configureActionButton(plusButton);\n            configureActionButton(minusButton);\n        }\n    }","commit_id":"f041783a193ccedd81044123d25e7f74eacc695a","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * loads sub-bundles at the given Description LOD, continues\n     *\n     * @param requestedDescrLoD\n     * @param expand\n     */\n    @NbBundle.Messages(value = \"EventClusterNode.loggedTask.name=Load sub events\")\n    @ThreadConfined(type = ThreadConfined.ThreadType.JFX)\n    private synchronized void loadSubStripes(DescriptionLoD.RelativeDetail relativeDetail) {\n        getChartLane().setCursor(Cursor.WAIT);\n\n        /*\n         * make new ZoomParams to query with\n         *\n         * We need to extend end time because for the query by one second,\n         * because it is treated as an open interval but we want to include\n         * events at exactly the time of the last event in this cluster\n         */\n        final RootFilter subClusterFilter = getSubClusterFilter();\n        final Interval subClusterSpan = new Interval(getStartMillis(), getEndMillis() + 1000);\n        final EventTypeZoomLevel eventTypeZoomLevel = eventsModel.eventTypeZoomProperty().get();\n        final ZoomParams zoomParams = new ZoomParams(subClusterSpan, eventTypeZoomLevel, subClusterFilter, getDescriptionLoD());\n\n        Task<List<EventStripe>> loggedTask = new LoggedTask<List<EventStripe>>(Bundle.EventClusterNode_loggedTask_name(), false) {\n\n            private volatile DescriptionLoD loadedDescriptionLoD = getDescriptionLoD().withRelativeDetail(relativeDetail);\n\n            @Override\n            protected List<EventStripe> call() throws Exception {\n                List<EventStripe> stripes;\n                DescriptionLoD next = loadedDescriptionLoD;\n                do {\n                    loadedDescriptionLoD = next;\n                    if (loadedDescriptionLoD == getEvent().getDescriptionLoD()) {\n                        return Collections.emptyList();\n                    }\n                    stripes = eventsModel.getEventStripes(zoomParams.withDescrLOD(loadedDescriptionLoD));\n\n                    next = loadedDescriptionLoD.withRelativeDetail(relativeDetail);\n                } while (stripes.size() == 1 && nonNull(next));\n\n                // return list of EventStripes representing sub-bundles\n                return stripes.stream()\n                        .map(eventStripe -> eventStripe.withParent(getEvent()))\n                        .collect(Collectors.toList());\n            }\n\n            @Override\n            protected void succeeded() {\n                try {\n                    List<EventStripe> newSubStripes = get();\n\n                    //clear the existing subnodes\n                    List<TimeLineEvent> oldSubEvents = subNodes.stream().flatMap(new StripeFlattener()).collect(Collectors.toList());\n                    getChartLane().getParentChart().getAllNestedEvents().removeAll(oldSubEvents);\n                    subNodes.clear();\n                    if (newSubStripes.isEmpty()) {\n                        getChildren().setAll(subNodePane, infoHBox);\n                        setDescriptionLOD(getEvent().getDescriptionLoD());\n                    } else {\n                        subNodes.addAll(Lists.transform(newSubStripes, EventClusterNode.this::createChildNode));\n                        List<TimeLineEvent> newSubEvents = subNodes.stream().flatMap(new StripeFlattener()).collect(Collectors.toList());\n                        getChartLane().getParentChart().getAllNestedEvents().addAll(newSubEvents);\n                        getChildren().setAll(new VBox(infoHBox, subNodePane));\n                        setDescriptionLOD(loadedDescriptionLoD);\n                    }\n                } catch (InterruptedException | ExecutionException ex) {\n                    LOGGER.log(Level.SEVERE, \"Error loading subnodes\", ex); //NON-NLS\n                }\n                getChartLane().requestChartLayout();\n                getChartLane().setCursor(null);\n            }\n\n        };\n\n        new Thread(loggedTask).start();\n        //start task\n        getChartLane().getController().monitorTask(loggedTask);\n    }","id":60502,"modified_method":"/**\n     * Load sub-stripes of this cluster at a description level of detail\n     * determined by the given RelativeDetail\n     *\n     * @param relativeDetail the relative detail level to load.\n     */\n    @NbBundle.Messages(value = \"EventClusterNode.loggedTask.name=Load sub events\")\n    @ThreadConfined(type = ThreadConfined.ThreadType.JFX)\n    private synchronized void loadSubStripes(DescriptionLoD.RelativeDetail relativeDetail) {\n        getChartLane().setCursor(Cursor.WAIT);\n\n        /*\n         * make new ZoomParams to query with\n         *\n         * We need to extend end time for the query by one second, because it is\n         * treated as an open interval but we want to include events at exactly\n         * the time of the last event in this cluster. Restrict the sub stripes\n         * to the type and description of this cluster by intersecting a new\n         * filter with the existing root filter.\n         */\n        final RootFilter subClusterFilter = eventsModel.filterProperty().get().copyOf();\n        subClusterFilter.getSubFilters().addAll(\n                new DescriptionFilter(getEvent().getDescriptionLoD(), getDescription(), DescriptionFilter.FilterMode.INCLUDE),\n                new TypeFilter(getEventType()));\n        final Interval subClusterSpan = new Interval(getStartMillis(), getEndMillis() + 1000);\n        final EventTypeZoomLevel eventTypeZoomLevel = eventsModel.eventTypeZoomProperty().get();\n        final ZoomParams zoomParams = new ZoomParams(subClusterSpan, eventTypeZoomLevel, subClusterFilter, getDescriptionLoD());\n\n        /*\n         * task to load sub-stripes in a background thread\n         */\n        Task<List<EventStripe>> loggedTask;\n        loggedTask = new LoggedTask<List<EventStripe>>(Bundle.EventClusterNode_loggedTask_name(), false) {\n            \n            private volatile DescriptionLoD loadedDescriptionLoD = getDescriptionLoD().withRelativeDetail(relativeDetail);\n            \n            @Override\n            protected List<EventStripe> call() throws Exception {\n                //newly loaded substripes                \n                List<EventStripe> stripes;\n                //next LoD in diraction of given relativeDetail\n                DescriptionLoD next = loadedDescriptionLoD;\n                do {\n                    \n                    loadedDescriptionLoD = next;\n                    if (loadedDescriptionLoD == getEvent().getDescriptionLoD()) {\n                        //if we are back at the level of detail of the original cluster, return empty list to inidicate.\n                        return Collections.emptyList();\n                    }\n\n                    //query for stripes at the desired level of detail\n                    stripes = eventsModel.getEventStripes(zoomParams.withDescrLOD(loadedDescriptionLoD));\n                    //setup next for subsequent go through the \"do\" loop\n                    next = loadedDescriptionLoD.withRelativeDetail(relativeDetail);\n                } while (stripes.size() == 1 && nonNull(next)); //keep going while there was only on stripe and we havne't reached the end of the LoD continuum.\n\n                // return list of EventStripes with parents set to this cluster\n                return stripes.stream()\n                        .map(eventStripe -> eventStripe.withParent(getEvent()))\n                        .collect(Collectors.toList());\n            }\n            \n            @Override\n            protected void succeeded() {\n                ObservableList<TimeLineEvent> chartNestedEvents = getChartLane().getParentChart().getAllNestedEvents();\n\n                //clear the existing subnodes/events\n                chartNestedEvents.removeAll(StripeFlattener.flatten(subNodes));\n                subNodes.clear();\n                \n                try {\n                    setDescriptionLOD(loadedDescriptionLoD);\n                    List<EventStripe> newSubStripes = get();\n                    if (newSubStripes.isEmpty()) {\n                        //restore original display\n                        getChildren().setAll(subNodePane, infoHBox);\n                    } else {\n                        //display new sub stripes\n                        subNodes.addAll(Lists.transform(newSubStripes, EventClusterNode.this::createChildNode)); //map stripes to nodes\n                        chartNestedEvents.addAll(StripeFlattener.flatten(subNodes));\n                        getChildren().setAll(new VBox(infoHBox, subNodePane));\n                    }\n                } catch (InterruptedException | ExecutionException ex) {\n                    LOGGER.log(Level.SEVERE, \"Error loading subnodes\", ex); //NON-NLS\n                }\n                \n                getChartLane().requestChartLayout();\n                getChartLane().setCursor(null);\n            }\n        };\n\n        //start task\n        new Thread(loggedTask).start();\n        getChartLane().getController().monitorTask(loggedTask);\n    }","commit_id":"f041783a193ccedd81044123d25e7f74eacc695a","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    EventNodeBase<?> createChildNode(EventStripe stripe) {\n        if (stripe.getEventIDs().size() == 1) {\n            return new SingleEventNode(getChartLane(), getChartLane().getController().getEventsModel().getEventById(Iterables.getOnlyElement(stripe.getEventIDs())).withParent(stripe), this);\n        } else {\n            return new EventStripeNode(getChartLane(), stripe, this);\n        }\n    }","id":60503,"modified_method":"@Override\n    EventNodeBase<?> createChildNode(EventStripe stripe) {\n        ImmutableSet<Long> eventIDs = stripe.getEventIDs();\n        if (eventIDs.size() == 1) {\n            //If the stripe is a single event, make a single event node rather than a stripe node.\n            SingleEvent singleEvent = getController().getEventsModel().getEventById(Iterables.getOnlyElement(eventIDs)).withParent(stripe);\n            return new SingleEventNode(getChartLane(), singleEvent, this);\n        } else {\n            return new EventStripeNode(getChartLane(), stripe, this);\n        }\n    }","commit_id":"f041783a193ccedd81044123d25e7f74eacc695a","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"EventClusterNode(DetailsChartLane<?> chartLane, EventCluster eventCluster, EventStripeNode parentNode) {\n        super(chartLane, eventCluster, parentNode);\n\n        subNodePane.setBorder(clusterBorder);\n        subNodePane.setBackground(defaultBackground);\n        subNodePane.setMinWidth(1);\n        subNodePane.setMaxWidth(USE_PREF_SIZE);\n        setMinHeight(24);\n        setAlignment(Pos.CENTER_LEFT);\n\n        setCursor(Cursor.HAND);\n        getChildren().addAll(subNodePane, infoHBox);\n\n        if (parentNode == null) {\n            setDescriptionVisibility(DescriptionVisibility.SHOWN);\n        }\n    }","id":60504,"modified_method":"/**\n     * Constructor\n     *\n     * @param chartLane    the DetailsChartLane this node belongs to\n     * @param eventCluster the EventCluster represented by this node\n     * @param parentNode   the EventStripeNode that is the parent of this node.\n     */\n    EventClusterNode(DetailsChartLane<?> chartLane, EventCluster eventCluster, EventStripeNode parentNode) {\n        super(chartLane, eventCluster, parentNode);\n        \n        subNodePane.setBorder(clusterBorder);\n        subNodePane.setBackground(defaultBackground);\n        subNodePane.setMinWidth(1);\n        subNodePane.setMaxWidth(USE_PREF_SIZE);\n        setMinHeight(24);\n        setAlignment(Pos.CENTER_LEFT);\n        \n        setCursor(Cursor.HAND);\n        getChildren().addAll(subNodePane, infoHBox);\n        \n        if (parentNode == null) {\n            setDescriptionVisibility(DescriptionVisibility.SHOWN);\n        }\n    }","commit_id":"f041783a193ccedd81044123d25e7f74eacc695a","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"EventStripeNode(DetailsChartLane<?> chartLane, EventStripe eventStripe, EventClusterNode parentNode) {\n        super(chartLane, eventStripe, parentNode);\n        setMinHeight(24);\n        //setup description label\n        descrLabel.setTextOverrun(OverrunStyle.CENTER_ELLIPSIS);\n        descrLabel.setPrefWidth(USE_COMPUTED_SIZE);\n\n        setAlignment(subNodePane, Pos.BOTTOM_LEFT);\n\n        if (eventStripe.getClusters().size() > 1) {\n            for (EventCluster cluster : eventStripe.getClusters()) {\n                subNodes.add(createChildNode(cluster.withParent(eventStripe)));\n            }\n            getChildren().addAll(new VBox(infoHBox, subNodePane));\n        } else {\n            EventNodeBase<?> childNode;\n            EventCluster cluster = Iterables.getOnlyElement(eventStripe.getClusters()).withParent(eventStripe);\n            if (cluster.getEventIDs().size() == 1) {\n                childNode = createChildNode(cluster);\n            } else {\n                EventClusterNode eventClusterNode = (EventClusterNode) createChildNode(cluster);\n                eventClusterNode.installActionButtons();\n                controlsHBox.getChildren().addAll(eventClusterNode.minusButton, eventClusterNode.plusButton);\n                eventClusterNode.infoHBox.getChildren().remove(eventClusterNode.countLabel);\n                childNode = eventClusterNode;\n            }\n\n            childNode.setDescriptionVisibility(DescriptionVisibility.HIDDEN);\n            subNodes.add(childNode);\n            getChildren().addAll(infoHBox, subNodePane);\n        }\n    }","id":60505,"modified_method":"EventStripeNode(DetailsChartLane<?> chartLane, EventStripe eventStripe, EventClusterNode parentNode) {\n        super(chartLane, eventStripe, parentNode);\n        setMinHeight(24);\n        //setup description label\n        descrLabel.setTextOverrun(OverrunStyle.CENTER_ELLIPSIS);\n        descrLabel.setPrefWidth(USE_COMPUTED_SIZE);\n\n        setAlignment(subNodePane, Pos.BOTTOM_LEFT);\n\n        if (eventStripe.getClusters().size() > 1) {\n            for (EventCluster cluster : eventStripe.getClusters()) {\n                subNodes.add(createChildNode(cluster.withParent(eventStripe)));\n            }\n            getChildren().addAll(new VBox(infoHBox, subNodePane));\n        } else {\n            EventNodeBase<?> childNode;\n            EventCluster cluster = Iterables.getOnlyElement(eventStripe.getClusters()).withParent(eventStripe);\n            if (cluster.getEventIDs().size() == 1) {\n                childNode = createChildNode(cluster);\n            } else {\n                EventClusterNode eventClusterNode = (EventClusterNode) createChildNode(cluster);\n                eventClusterNode.installActionButtons();\n                controlsHBox.getChildren().addAll(eventClusterNode.getNewCollapseButton(), eventClusterNode.getNewExpandButton());\n                eventClusterNode.infoHBox.getChildren().remove(eventClusterNode.countLabel);\n                childNode = eventClusterNode;\n            }\n\n            childNode.setDescriptionVisibility(DescriptionVisibility.HIDDEN);\n            subNodes.add(childNode);\n            getChildren().addAll(infoHBox, subNodePane);\n        }\n    }","commit_id":"f041783a193ccedd81044123d25e7f74eacc695a","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private EventCluster(Interval spanningInterval, EventType type, Set<Long> eventIDs, Set<Long> hashHits, Set<Long> tagged, String description, DescriptionLoD lod, EventStripe parent) {\n\n        this.span = spanningInterval;\n        this.type = type;\n        this.hashHits = hashHits;\n        this.tagged = tagged;\n        this.description = description;\n        this.eventIDs = eventIDs;\n        this.lod = lod;\n        this.parent = parent;\n    }","id":60506,"modified_method":"private EventCluster(Interval spanningInterval, EventType type, Set<Long> eventIDs, Set<Long> hashHits, Set<Long> tagged, String description, DescriptionLoD lod, EventStripe parent) {\n\n        this.span = spanningInterval;\n        this.type = type;\n        this.hashHits = ImmutableSet.copyOf(hashHits);\n        this.tagged = ImmutableSet.copyOf(tagged);\n        this.description = description;\n        this.eventIDs = ImmutableSet.copyOf(eventIDs);\n        this.lod = lod;\n        this.parent = parent;\n    }","commit_id":"b36d3732dd19500d4428dc862ee95e539268a7d0","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public Set<Long> getEventIDsWithHashHits() {\n        return Collections.unmodifiableSet(hashHits);\n    }","id":60507,"modified_method":"@Override\n    @SuppressWarnings(\"ReturnOfCollectionOrArrayField\")\n    public ImmutableSet<Long> getEventIDsWithHashHits() {\n        return hashHits;\n    }","commit_id":"b36d3732dd19500d4428dc862ee95e539268a7d0","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public Set<Long> getEventIDsWithTags() {\n        return Collections.unmodifiableSet(tagged);\n    }","id":60508,"modified_method":"@Override\n    @SuppressWarnings(\"ReturnOfCollectionOrArrayField\")\n    public ImmutableSet<Long> getEventIDsWithTags() {\n        return tagged;\n    }","commit_id":"b36d3732dd19500d4428dc862ee95e539268a7d0","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public Set<Long> getEventIDs() {\n        return Collections.unmodifiableSet(eventIDs);\n    }","id":60509,"modified_method":"@Override\n    @SuppressWarnings(\"ReturnOfCollectionOrArrayField\")\n    public ImmutableSet<Long> getEventIDs() {\n        return eventIDs;\n    }","commit_id":"b36d3732dd19500d4428dc862ee95e539268a7d0","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    void setDescriptionVisibiltiyImpl(DescriptionVisibility descrVis) {\n        final int size = getEventBundle().getEventIDs().size();\n        switch (descrVis) {\n            case HIDDEN:\n                countLabel.setText(\"\");\n                descrLabel.setText(\"\");\n                break;\n            case COUNT_ONLY:\n                descrLabel.setText(\"\");\n                countLabel.setText(String.valueOf(size));\n                break;\n            default:\n            case SHOWN:\n                countLabel.setText(String.valueOf(size));\n                break;\n        }\n    }","id":60510,"modified_method":"@Override\n    void setDescriptionVisibiltiyImpl(DescriptionVisibility descrVis) {\n        final int size = getEventCluster().getCount();\n        switch (descrVis) {\n            case HIDDEN:\n                countLabel.setText(\"\");\n                descrLabel.setText(\"\");\n                break;\n            case COUNT_ONLY:\n                descrLabel.setText(\"\");\n                countLabel.setText(String.valueOf(size));\n                break;\n            default:\n            case SHOWN:\n                countLabel.setText(String.valueOf(size));\n                break;\n        }\n    }","commit_id":"b36d3732dd19500d4428dc862ee95e539268a7d0","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public EventStripe(EventCluster cluster, EventCluster parent) {\n        clusters.add(cluster);\n\n        type = cluster.getEventType();\n        description = cluster.getDescription();\n        lod = cluster.getDescriptionLoD();\n        eventIDs.addAll(cluster.getEventIDs());\n        tagged.addAll(cluster.getEventIDsWithTags());\n        hashHits.addAll(cluster.getEventIDsWithHashHits());\n        this.parent = parent;\n    }","id":60511,"modified_method":"public EventStripe(EventCluster cluster, EventCluster parent) {\n        this.clusters = ImmutableSortedSet.orderedBy(Comparator.comparing(EventCluster::getStartMillis))\n                .add(cluster).build();\n\n        type = cluster.getEventType();\n        description = cluster.getDescription();\n        lod = cluster.getDescriptionLoD();\n        eventIDs = cluster.getEventIDs();\n        tagged = cluster.getEventIDsWithTags();\n        hashHits = cluster.getEventIDsWithHashHits();\n        this.parent = parent;\n    }","commit_id":"b36d3732dd19500d4428dc862ee95e539268a7d0","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public EventStripe withParent(EventCluster parent) {\n        EventStripe eventStripe = new EventStripe(parent, this.type, this.description, this.lod);\n        eventStripe.clusters.addAll(clusters);\n        eventStripe.eventIDs.addAll(eventIDs);\n        eventStripe.tagged.addAll(tagged);\n        eventStripe.hashHits.addAll(hashHits);\n        return eventStripe;\n    }","id":60512,"modified_method":"public EventStripe withParent(EventCluster parent) {\n        EventStripe eventStripe = new EventStripe(parent, this.type, this.description, this.lod, clusters, eventIDs, tagged, hashHits);\n        return eventStripe;\n    }","commit_id":"b36d3732dd19500d4428dc862ee95e539268a7d0","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public Set<Long> getEventIDs() {\n        return Collections.unmodifiableSet(eventIDs);\n    }","id":60513,"modified_method":"@Override\n    @SuppressWarnings(\"ReturnOfCollectionOrArrayField\")\n    public ImmutableSet<Long> getEventIDs() {\n        return eventIDs;\n    }","commit_id":"b36d3732dd19500d4428dc862ee95e539268a7d0","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private EventStripe(EventStripe u, EventStripe v) {\n        clusters.addAll(u.clusters);\n        clusters.addAll(v.clusters);\n        type = u.getEventType();\n        description = u.getDescription();\n        lod = u.getDescriptionLoD();\n        eventIDs.addAll(u.getEventIDs());\n        eventIDs.addAll(v.getEventIDs());\n        tagged.addAll(u.getEventIDsWithTags());\n        tagged.addAll(v.getEventIDsWithTags());\n        hashHits.addAll(u.getEventIDsWithHashHits());\n        hashHits.addAll(v.getEventIDsWithHashHits());\n        parent = u.getParentBundle().orElse(v.getParentBundle().orElse(null));\n    }","id":60514,"modified_method":"private EventStripe(EventStripe u, EventStripe v) {\n        clusters = ImmutableSortedSet.orderedBy(Comparator.comparing(EventCluster::getStartMillis))\n                .addAll(u.getClusters())\n                .addAll(v.getClusters())\n                .build();\n\n        type = u.getEventType();\n        description = u.getDescription();\n        lod = u.getDescriptionLoD();\n        eventIDs = ImmutableSet.<Long>builder()\n                .addAll(u.getEventIDs())\n                .addAll(v.getEventIDs())\n                .build();\n        tagged = ImmutableSet.<Long>builder()\n                .addAll(u.getEventIDsWithTags())\n                .addAll(v.getEventIDsWithTags())\n                .build();\n        hashHits = ImmutableSet.<Long>builder()\n                .addAll(u.getEventIDsWithHashHits())\n                .addAll(v.getEventIDsWithHashHits())\n                .build();\n        parent = u.getParentBundle().orElse(v.getParentBundle().orElse(null));\n    }","commit_id":"b36d3732dd19500d4428dc862ee95e539268a7d0","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public Set<Long> getEventIDsWithHashHits() {\n        return Collections.unmodifiableSet(hashHits);\n    }","id":60515,"modified_method":"@Override\n    @SuppressWarnings(\"ReturnOfCollectionOrArrayField\")\n    public ImmutableSet<Long> getEventIDsWithHashHits() {\n        return hashHits;\n    }","commit_id":"b36d3732dd19500d4428dc862ee95e539268a7d0","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public SortedSet< EventCluster> getClusters() {\n        return Collections.unmodifiableSortedSet(clusters);\n    }","id":60516,"modified_method":"@Override\n    @SuppressWarnings(\"ReturnOfCollectionOrArrayField\")\n    public ImmutableSortedSet< EventCluster> getClusters() {\n        return clusters;\n    }","commit_id":"b36d3732dd19500d4428dc862ee95e539268a7d0","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private EventStripe(EventCluster parent, EventType type, String description, DescriptionLoD lod) {\n        this.parent = parent;\n        this.type = type;\n        this.description = description;\n        this.lod = lod;\n    }","id":60517,"modified_method":"private EventStripe(EventCluster parent, EventType type, String description, DescriptionLoD lod, SortedSet<EventCluster> clusters, ImmutableSet<Long> eventIDs, ImmutableSet<Long> tagged, ImmutableSet<Long> hashHits) {\n        this.parent = parent;\n        this.type = type;\n        this.description = description;\n        this.lod = lod;\n        this.clusters = ImmutableSortedSet.copyOf(Comparator.comparing(EventCluster::getStartMillis), clusters);\n\n        this.eventIDs = eventIDs;\n        this.tagged = tagged;\n        this.hashHits = hashHits;\n    }","commit_id":"b36d3732dd19500d4428dc862ee95e539268a7d0","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public Set<Long> getEventIDsWithTags() {\n        return Collections.unmodifiableSet(tagged);\n    }","id":60518,"modified_method":"@Override\n    @SuppressWarnings(\"ReturnOfCollectionOrArrayField\")\n    public ImmutableSet<Long> getEventIDsWithTags() {\n        return tagged;\n    }","commit_id":"b36d3732dd19500d4428dc862ee95e539268a7d0","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    void setDescriptionVisibiltiyImpl(DescriptionVisibility descrVis) {\n        final int size = getEventStripe().getEventIDs().size();\n\n        switch (descrVis) {\n            case HIDDEN:\n                countLabel.setText(\"\");\n                descrLabel.setText(\"\");\n                break;\n            case COUNT_ONLY:\n                descrLabel.setText(\"\");\n                countLabel.setText(String.valueOf(size));\n                break;\n            default:\n            case SHOWN:\n                String description = getEventStripe().getDescription();\n                description = parentNode != null\n                        ? \"    ...\" + StringUtils.substringAfter(description, parentNode.getDescription())\n                        : description;\n                descrLabel.setText(description);\n                countLabel.setText(((size == 1) ? \"\" : \" (\" + size + \")\")); // NON-NLS\n                break;\n        }\n    }","id":60519,"modified_method":"@Override\n    void setDescriptionVisibiltiyImpl(DescriptionVisibility descrVis) {\n        final int size = getEventStripe().getCount();\n\n        switch (descrVis) {\n            case HIDDEN:\n                countLabel.setText(\"\");\n                descrLabel.setText(\"\");\n                break;\n            case COUNT_ONLY:\n                descrLabel.setText(\"\");\n                countLabel.setText(String.valueOf(size));\n                break;\n            default:\n            case SHOWN:\n                String description = getEventStripe().getDescription();\n                description = parentNode != null\n                        ? \"    ...\" + StringUtils.substringAfter(description, parentNode.getDescription())\n                        : description;\n                descrLabel.setText(description);\n                countLabel.setText(((size == 1) ? \"\" : \" (\" + size + \")\")); // NON-NLS\n                break;\n        }\n    }","commit_id":"b36d3732dd19500d4428dc862ee95e539268a7d0","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"EventStripeNode(DetailsChartLane<?> chartLane, EventStripe eventStripe, EventClusterNode parentNode) {\n        super(chartLane, eventStripe, parentNode);\n        setMinHeight(24);\n        //setup description label\n        descrLabel.setTextOverrun(OverrunStyle.CENTER_ELLIPSIS);\n        descrLabel.setPrefWidth(USE_COMPUTED_SIZE);\n\n        setAlignment(subNodePane, Pos.BOTTOM_LEFT);\n\n        if (eventStripe.getClusters().size() > 1) {\n            for (EventCluster cluster : eventStripe.getClusters()) {\n                subNodes.add(createChildNode(cluster.withParent(eventStripe)));\n            }\n            getChildren().addAll(new VBox(infoHBox, subNodePane));\n        } else {\n            EventNodeBase<?> childNode;\n            EventCluster cluster = Iterables.getOnlyElement(eventStripe.getClusters()).withParent(eventStripe);\n            if (cluster.getEventIDs().size() == 1) {\n                childNode = createChildNode(cluster);\n            } else {\n                EventClusterNode eventClusterNode = (EventClusterNode) createChildNode(cluster);\n                eventClusterNode.installActionButtons();\n                controlsHBox.getChildren().addAll(eventClusterNode.getNewCollapseButton(), eventClusterNode.getNewExpandButton());\n                eventClusterNode.infoHBox.getChildren().remove(eventClusterNode.countLabel);\n                childNode = eventClusterNode;\n            }\n\n            childNode.setDescriptionVisibility(DescriptionVisibility.HIDDEN);\n            subNodes.add(childNode);\n            getChildren().addAll(infoHBox, subNodePane);\n        }\n    }","id":60520,"modified_method":"/**\n     * Constructor\n     *\n     * @param chartLane   the DetailsChartLane this node belongs to\n     * @param eventStripe the EventStripe represented by this node\n     * @param parentNode  the EventClusterNode that is the parent of this node.\n     */\n    EventStripeNode(DetailsChartLane<?> chartLane, EventStripe eventStripe, EventClusterNode parentNode) {\n        super(chartLane, eventStripe, parentNode);\n\n        //setup description label\n        descrLabel.setTextOverrun(OverrunStyle.CENTER_ELLIPSIS);\n        descrLabel.setPrefWidth(USE_COMPUTED_SIZE);\n\n        setMinHeight(24);\n        setAlignment(subNodePane, Pos.BOTTOM_LEFT);\n\n        if (eventStripe.getClusters().size() > 1) {\n            for (EventCluster cluster : eventStripe.getClusters()) {\n                subNodes.add(createChildNode(cluster.withParent(eventStripe)));\n            }\n            //stack componenets vertically\n            getChildren().addAll(new VBox(infoHBox, subNodePane));\n        } else {\n            //if the stripe only has one cluster, use alternate simpler layout\n            EventNodeBase<?> childNode;\n            EventCluster cluster = Iterables.getOnlyElement(eventStripe.getClusters()).withParent(eventStripe);\n            if (cluster.getEventIDs().size() == 1) {\n                childNode = createChildNode(cluster);\n            } else {\n                //if the cluster has more than one event, add the clusters controls to this stripe node directly.\n                EventClusterNode eventClusterNode = (EventClusterNode) createChildNode(cluster);\n                eventClusterNode.installActionButtons();\n                controlsHBox.getChildren().addAll(eventClusterNode.getNewCollapseButton(), eventClusterNode.getNewExpandButton());\n                eventClusterNode.infoHBox.getChildren().remove(eventClusterNode.countLabel);\n                childNode = eventClusterNode;\n            }\n\n            //hide the cluster description\n            childNode.setDescriptionVisibility(DescriptionVisibility.HIDDEN);\n\n            subNodes.add(childNode);\n            //stack componenet in z rather than vertically\n            getChildren().addAll(infoHBox, subNodePane);\n        }\n    }","commit_id":"a1eea710a9ce4af1bc8b0bd51580a1e88cd9aadc","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    EventNodeBase<?> createChildNode(EventCluster cluster) {\n        if (cluster.getEventIDs().size() == 1) {\n            return new SingleEventNode(getChartLane(), getChartLane().getController().getEventsModel().getEventById(Iterables.getOnlyElement(cluster.getEventIDs())).withParent(cluster), this);\n        } else {\n            return new EventClusterNode(getChartLane(), cluster, this);\n        }\n    }","id":60521,"modified_method":"@Override\n    EventNodeBase<?> createChildNode(EventCluster cluster) {\n        ImmutableSet<Long> eventIDs = cluster.getEventIDs();\n        if (eventIDs.size() == 1) {\n            SingleEvent singleEvent = getController().getEventsModel().getEventById(Iterables.getOnlyElement(eventIDs)).withParent(cluster);\n            return new SingleEventNode(getChartLane(), singleEvent, this);\n        } else {\n            return new EventClusterNode(getChartLane(), cluster, this);\n        }\n    }","commit_id":"a1eea710a9ce4af1bc8b0bd51580a1e88cd9aadc","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private Action newHideAction() {\n        return new HideDescriptionAction(getDescription(), getEvent().getDescriptionLoD(), chartLane.getParentChart());\n    }","id":60522,"modified_method":"/**\n     * Get a new Action that hides stripes with the same description as this\n     * one.\n     *\n     * @return a new Action that hides stripes with the same description as this\n     *         one.\n     */\n    private Action newHideAction() {\n        return new HideDescriptionAction(getDescription(), getEvent().getDescriptionLoD(), chartLane.getParentChart());\n    }","commit_id":"a1eea710a9ce4af1bc8b0bd51580a1e88cd9aadc","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller == null) {\r\n            return false;\r\n        }\r\n        Card sourceCard = game.getCard(source.getSourceId());\r\n        if (sourceCard == null) {\r\n            return false;\r\n        }\r\n        Cards cards = new CardsImpl(Zone.PICK);\r\n        while (controller.getLibrary().size() > 0) {\r\n            Card card = controller.getLibrary().getFromTop(game);\r\n            if (card != null) {\r\n                cards.add(card);\r\n                if(filter.match(card, game)){\r\n                    card.moveToZone(Zone.HAND, source.getSourceId(), game, false);\r\n                    break;\r\n                }\r\n                else{\r\n                    card.moveToZone(Zone.GRAVEYARD, source.getSourceId(), game, false);\r\n                }\r\n            }\r\n        }\r\n        controller.revealCards(sourceCard.getName(), cards, game);\r\n        return true;\r\n    }","id":60523,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        MageObject sourceObject = source.getSourceObject(game);\r\n        if (controller == null || sourceObject == null) {\r\n            return false;\r\n        }\r\n        \r\n        Cards cards = new CardsImpl();\r\n        Card cardFound = null;\r\n        while (controller.getLibrary().size() > 0) {\r\n            Card card = controller.getLibrary().removeFromTop(game);\r\n            if (card != null) {\r\n                cards.add(card);                \r\n                if (filter.match(card, game)){\r\n                    cardFound = card;\r\n                    break;\r\n                }\r\n            }            \r\n        }\r\n        if (!cards.isEmpty()) {\r\n            controller.revealCards(sourceObject.getName(), cards, game);\r\n            if (cardFound != null) {\r\n                controller.moveCards(cardFound, Zone.LIBRARY, Zone.HAND, source, game);\r\n                cards.remove(cardFound);\r\n            }\r\n            controller.moveCards(cards, Zone.LIBRARY, Zone.GRAVEYARD, source, game);\r\n        }\r\n        return true;\r\n    }","commit_id":"6a7b43f71c12b09d7b8ff7d39a28eed53cf52dff","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player damagedPlayer = game.getPlayer(targetPointer.getFirst(game, source));\r\n        if (damagedPlayer != null) {\r\n            damagedPlayer.revealCards(\"Shimian Specter\", damagedPlayer.getHand(), game);\r\n            Player you = game.getPlayer(source.getControllerId());\r\n            if (you != null) {\r\n                TargetCard target = new TargetCard(Constants.Zone.PICK, filter);\r\n                target.setRequired(true);\r\n                target.setNotTarget(true);\r\n                if (you.choose(Constants.Outcome.Benefit, damagedPlayer.getHand(), target, game)) {\r\n                    Card chosenCard = damagedPlayer.getHand().get(target.getFirstTarget(), game);\r\n                    if (chosenCard != null) {\r\n                        if (damagedPlayer != null) {\r\n                            \r\n                            //cards in Library\r\n                            Cards cardsInLibrary = new CardsImpl(Constants.Zone.LIBRARY);\r\n                            cardsInLibrary.addAll(damagedPlayer.getLibrary().getCards(game));\r\n\r\n                            // cards in Graveyard\r\n                            Cards cardsInGraveyard = new CardsImpl(Constants.Zone.GRAVEYARD);\r\n                            cardsInGraveyard.addAll(damagedPlayer.getGraveyard());\r\n                                \r\n                            // cards in Hand\r\n                            Cards cardsInHand = new CardsImpl(Constants.Zone.HAND);\r\n                            cardsInHand.addAll(damagedPlayer.getHand());\r\n                            \r\n                            // exile same named cards from zones\r\n                            for (Card checkCard : cardsInLibrary.getCards(game)) {\r\n                                if (checkCard.getName().equals(chosenCard.getName())) {\r\n                                    checkCard.moveToExile(id, \"Library\", id, game);\r\n                                }\r\n                            }\r\n                            for (Card checkCard : cardsInGraveyard.getCards(game)) {\r\n                                if (checkCard.getName().equals(chosenCard.getName())) {\r\n                                    checkCard.moveToExile(id, \"Graveyard\", id, game);\r\n                                }\r\n                            }\r\n                            for (Card checkCard : cardsInHand.getCards(game)) {\r\n                                if (checkCard.getName().equals(chosenCard.getName())) {\r\n                                    checkCard.moveToExile(id, \"Hand\", id, game);\r\n                                }\r\n                            }\r\n                            \r\n                            damagedPlayer.shuffleLibrary(game);\r\n                            \r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }","id":60524,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player damagedPlayer = game.getPlayer(targetPointer.getFirst(game, source));\r\n        Player you = game.getPlayer(source.getControllerId());\r\n        if (damagedPlayer != null && you != null) {\r\n            damagedPlayer.revealCards(\"Shimian Specter\", damagedPlayer.getHand(), game);\r\n\r\n            TargetCard target = new TargetCard(Constants.Zone.PICK, filter);\r\n            target.setRequired(true);\r\n            target.setNotTarget(true);\r\n            if (you.choose(Constants.Outcome.Benefit, damagedPlayer.getHand(), target, game)) {\r\n                Card chosenCard = damagedPlayer.getHand().get(target.getFirstTarget(), game);\r\n                if (chosenCard != null && damagedPlayer != null) {\r\n\r\n                    //cards in Library\r\n                    Cards cardsInLibrary = new CardsImpl(Constants.Zone.LIBRARY);\r\n                    cardsInLibrary.addAll(damagedPlayer.getLibrary().getCards(game));\r\n                    you.lookAtCards(damagedPlayer.getName() + \": cards in library\", cardsInLibrary, game);\r\n\r\n                    // cards in Graveyard\r\n                    Cards cardsInGraveyard = new CardsImpl(Constants.Zone.GRAVEYARD);\r\n                    cardsInGraveyard.addAll(damagedPlayer.getGraveyard());\r\n\r\n                    // cards in Hand\r\n                    Cards cardsInHand = new CardsImpl(Constants.Zone.HAND);\r\n                    cardsInHand.addAll(damagedPlayer.getHand());\r\n                    you.lookAtCards(damagedPlayer.getName() + \": cards in hand\", cardsInHand, game);\r\n\r\n                    // exile same named cards from zones\r\n                    for (Card checkCard : cardsInLibrary.getCards(game)) {\r\n                        if (checkCard.getName().equals(chosenCard.getName())) {\r\n                            checkCard.moveToExile(id, \"Library\", id, game);\r\n                        }\r\n                    }\r\n                    for (Card checkCard : cardsInGraveyard.getCards(game)) {\r\n                        if (checkCard.getName().equals(chosenCard.getName())) {\r\n                            checkCard.moveToExile(id, \"Graveyard\", id, game);\r\n                        }\r\n                    }\r\n                    for (Card checkCard : cardsInHand.getCards(game)) {\r\n                        if (checkCard.getName().equals(chosenCard.getName())) {\r\n                            checkCard.moveToExile(id, \"Hand\", id, game);\r\n                        }\r\n                    }\r\n\r\n                    damagedPlayer.shuffleLibrary(game);\r\n\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"20c1a2e36b7fd1cc79e45a7c2ba329d0eef53cab","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        MageObject sourceObject = game.getObject(source.getSourceId());\n        if (controller != null && controller.getLibrary().size() > 0) {        \n            Cards cards = new CardsImpl();\n            Library library = controller.getLibrary();\n            Card card = null;\n            do {\n                card = library.removeFromTop(game);\n                if (card != null) {\n                    cards.add(card);\n                }\n            } while (library.size() > 0 && card != null && !filter.match(card, game));\n            // reveal cards\n            if (!cards.isEmpty()) {\n                controller.revealCards(sourceObject.getName(), cards, game);\n            }\n            // put creature card in hand\n             controller.moveCards(card, Zone.LIBRARY, Zone.HAND, source, game);\n            // remove it from revealed card list\n            cards.remove(card);\n            // Put the rest on the bottom of your library in a random order\n            while (cards.size() > 0) {\n                card = cards.getRandom(game);\n                if (card != null) {\n                    cards.remove(card);\n                    controller.moveCardToLibraryWithInfo(card, source.getSourceId(), game, Zone.HAND, false, false);\n                }\n            }\n            return true;\n        }\n        return false;\n    }","id":60525,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        MageObject sourceObject = game.getObject(source.getSourceId());\n        if (controller != null && controller.getLibrary().size() > 0) {\n            Cards cards = new CardsImpl();\n            Library library = controller.getLibrary();\n            Card card = null;\n            do {\n                card = library.removeFromTop(game);\n                if (card != null) {\n                    cards.add(card);\n                }\n            } while (library.size() > 0 && card != null && !filter.match(card, game));\n            // reveal cards\n            if (!cards.isEmpty()) {\n                controller.revealCards(sourceObject.getIdName(), cards, game);\n                if (filter.match(card, game)) {\n                    // put creature card in hand\n                    controller.moveCards(card, Zone.LIBRARY, Zone.HAND, source, game);\n                    // remove it from revealed card list\n                    cards.remove(card);\n                }\n                // Put the rest on the bottom of your library in a random order\n                Cards randomOrder = new CardsImpl();\n                while (cards.size() > 0) {\n                    card = cards.getRandom(game);\n                    if (card != null) {\n                        cards.remove(card);\n                        randomOrder.add(card);\n                        controller.moveCardToLibraryWithInfo(card, source.getSourceId(), game, Zone.HAND, false, false);\n                    }\n                }\n                controller.putCardsOnBottomOfLibrary(randomOrder, game, source, false);\n            }\n            return true;\n        }\n        return false;\n    }","commit_id":"75bb39cae83bf5818a1ee35508bc99a517f981e7","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public void setNode(final Node selectedNode) {\n        // to clear the viewer\n        if (selectedNode == null) {\n            currentNode = null;\n            resetComponent();\n            return;\n        }\n\n        //TODO why setNode() is called twice for the same node sometimes (when selected in dir tree first)\n        //for now, do not update second time\n        if (selectedNode == currentNode) {\n            return;\n        } else {\n            currentNode = selectedNode;\n        }\n\n        /*\n         * Sources contain implementations that will markup the text in\n         * different ways. The original behavior for this was a source for the\n         * text markedup by SOLR and another that just displayed raw text.\n         */\n        final List<TextMarkup> sources = new ArrayList<TextMarkup>();\n\n        // See if the node has any sources attached to it and add them to our\n        // internal list\n        sources.addAll(selectedNode.getLookup().lookupAll(TextMarkup.class));\n\n        // Q: Can this be moved up? Is is possible to have \"sources\" when the\n        // node doesn't have a content object or the content size is 0?\n        Content content = selectedNode.getLookup().lookup(Content.class);\n        if (content == null || content.getSize() == 0) {\n            setPanel(sources);\n            return;\n        }\n\n        long objectId = getDocumentId(selectedNode);\n        boolean isDir = content.accept(isDirVisitor);\n\n        if (!isDir && solrHasContent(objectId) == false) {\n            setPanel(sources);\n            return;\n        }\n\n        // make a new source for the raw content\n        TextMarkup rawSource = new RawTextMarkup(content, objectId);\n\n        currentSource = rawSource;\n        sources.add(rawSource);\n\n        //init pages\n        int currentPage = currentSource.getCurrentPage();\n        if (currentPage == 0 && currentSource.hasNextPage()) {\n            currentSource.nextPage();\n        }\n        updatePageControls();\n\n        // first source will be the default displayed\n        setPanel(sources);\n    }","id":60526,"modified_method":"@Override\n    public void setNode(final Node selectedNode) {\n        /*\n         * Clear the viewer.\n         */\n        if (selectedNode == null) {\n            currentNode = null;\n            resetComponent();\n            return;\n        }\n\n        /*\n         * This deals with the known bug with an unknown cause where setNode is\n         * sometimes called twice for the same node.\n         */\n        if (selectedNode == currentNode) {\n            return;\n        } else {\n            currentNode = selectedNode;\n        }\n\n        /*\n         * Assemble a collection of all of the \"sources\" of extracted and\n         * indexed text to present in a paged display. First look for the text\n         * marked up with HTML to highlight keyword hits that will be present if\n         * the node is a keyword hit blakcboard artifact.\n         */\n        final List<TextMarkup> sources = new ArrayList<>();\n        sources.addAll(selectedNode.getLookup().lookupAll(TextMarkup.class));\n\n        /*\n         * Now look for the \"raw\" extracted text if this is a node for another\n         * type of artifact or for content.\n         */\n        long documentID = getDocumentId(currentNode);\n        if (INVALID_DOCUMENT_ID == documentID) {\n            setPanel(sources);\n            return;\n        }\n\n        /*\n         * KDM TODO: Make RawTextMarkup able to handle artifacts as well as\n         * Content, or use RawTextMarkup as a base class for subclasses that\n         * handle artifacts and content.\n         */\n        if (documentID > INVALID_DOCUMENT_ID) {\n            /*\n             * Add a source for the raw text.\n             */\n            Content content = currentNode.getLookup().lookup(Content.class);\n            TextMarkup rawSource = new RawTextMarkup(content, content.getId());\n            currentSource = rawSource;\n            sources.add(rawSource);\n        }\n\n        /*\n         * Initialize the pages for the sources. The first source in the list\n         * of sources will be displayed.\n         */\n        int currentPage = currentSource.getCurrentPage();\n        if (currentPage == 0 && currentSource.hasNextPage()) {\n            currentSource.nextPage();\n        }\n        updatePageControls();\n        setPanel(sources);\n    }","commit_id":"eeef9ef4af7f21ec7115b832ea0a5723d81107e6","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public boolean isSupported(Node node) {\n        if (node == null) {\n            return false;\n        }\n\n        // see if the node has a MarkupSource object in it\n        // BC @@@ This seems to be added from the upper right search.\n        /*\n         * \n         */\n        Collection<? extends TextMarkup> sources = node.getLookup().lookupAll(TextMarkup.class);\n        if (sources.isEmpty() == false) {\n            return true;\n        }\n\n        // see if the node has a Highlight object in it.  \n        // BC @@@ This seems to be added by BlackboardArtifactNode from the tree\n        if (node.getLookup().lookup(TextMarkupLookup.class) != null) {\n            return true;\n        }\n\n        return solrHasContent(getDocumentId(node));\n    }","id":60527,"modified_method":"@Override\n    public boolean isSupported(Node node) {\n        if (node == null) {\n            return false;\n        }\n\n        /**\n         * Is there any marked up indexed text in the look up of this node? This\n         * will be the case if the node is for a keyword hit artifact produced\n         * by either an ad hoc keyword search result (keyword search toolbar\n         * widgets) or a keyword search by the keyword search ingest module.\n         */\n        Collection<? extends TextMarkup> sources = node.getLookup().lookupAll(TextMarkup.class);\n        if (sources.isEmpty() == false) {\n            return true;\n        }\n\n        /*\n         * No highlighted text for a keyword hit, so is there any indexed text\n         * at all for this node?\n         */\n        long documentID = getDocumentId(node);\n        if (INVALID_DOCUMENT_ID == documentID) {\n            return false;\n        }\n\n        return solrHasContent(documentID);\n    }","commit_id":"eeef9ef4af7f21ec7115b832ea0a5723d81107e6","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Check if Solr has extracted content for a given node\n     *\n     * @param objectId\n     *\n     * @return true if Solr has content, else false\n     */\n    private boolean solrHasContent(Long objectId) {\n        final Server solrServer = KeywordSearch.getServer();\n\n        try {\n            return solrServer.queryIsIndexed(objectId);\n        } catch (NoOpenCoreException ex) {\n            logger.log(Level.WARNING, \"Couldn't determine whether content is supported.\", ex); //NON-NLS\n            return false;\n        } catch (KeywordSearchModuleException ex) {\n            logger.log(Level.WARNING, \"Couldn't determine whether content is supported.\", ex); //NON-NLS\n            return false;\n        }\n    }","id":60528,"modified_method":"/**\n     * Check if Solr has extracted content for a given node\n     *\n     * @param objectId\n     *\n     * @return true if Solr has content, else false\n     */\n    private boolean solrHasContent(Long objectId) {\n        final Server solrServer = KeywordSearch.getServer();\n        try {\n            return solrServer.queryIsIndexed(objectId);\n        } catch (NoOpenCoreException | KeywordSearchModuleException ex) {\n            logger.log(Level.SEVERE, \"Error querying Solr server\", ex); //NON-NLS\n            return false;\n        }\n    }","commit_id":"eeef9ef4af7f21ec7115b832ea0a5723d81107e6","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Get the correct document id for the given node. If the node contains a\n     * HighlightedTextMarkup object, its object id will have been set. Otherwise\n     * the document id is obtained from the Content object.\n     *\n     * @param node\n     *\n     * @return Either the artifact id, file id or 0.\n     */\n    private Long getDocumentId(Node node) {\n        HighlightedTextMarkup markup = node.getLookup().lookup(HighlightedTextMarkup.class);\n\n        if (markup != null) {\n            return markup.getObjectId();\n        }\n\n        Content content = node.getLookup().lookup(Content.class);\n\n        if (content != null) {\n            return content.getId();\n        }\n\n        return 0L;\n    }","id":60529,"modified_method":"/**\n     * Gets the object ID to use as the document ID for accessing any indexed\n     * text for the given node.\n     *\n     * @param node The node.\n     *\n     * @return The document ID or zero, which is an invalid document ID.\n     */\n    private Long getDocumentId(Node node) {\n        /*\n         * If the node is a balackboard artifact node for anything other than a\n         * keyword hit, the document ID for the text extracted from the artifact\n         * (the concatenation of its attributes) is the artifact ID, a large,\n         * negative integer.\n         */\n        BlackboardArtifact artifact = node.getLookup().lookup(BlackboardArtifact.class);\n        if (null != artifact && artifact.getArtifactTypeID() != BlackboardArtifact.ARTIFACT_TYPE.TSK_KEYWORD_HIT.getTypeID()) {\n            return artifact.getArtifactID();\n        }\n\n        /*\n         * For keyword search hit artifact nodes and all other nodes, the\n         * document ID for the extracted text is the ID of the associated\n         * content, if any.\n         */\n        Content content = node.getLookup().lookup(Content.class);\n        if (content != null) {\n            return content.getId();\n        }\n\n        /*\n         * No extracted text, return an invalid docuemnt ID.\n         */\n        return 0L;\n    }","commit_id":"eeef9ef4af7f21ec7115b832ea0a5723d81107e6","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public ExtractedContentViewer() {\n        logger.log(Level.INFO, \"Created TextView instance: \" + this); //NON-NLS\n    }","id":60530,"modified_method":"public ExtractedContentViewer() {\n    }","commit_id":"eeef9ef4af7f21ec7115b832ea0a5723d81107e6","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n   public GetTransUnitListResult execute(GetTransUnitList action, ExecutionContext context) throws ActionException\n   {\n      ZanataIdentity.instance().checkLoggedIn();\n      log.debug(\"Fetching TransUnits for document {}\", action.getDocumentId());\n\n      HLocale hLocale;\n      try\n      {\n         hLocale = localeServiceImpl.validateLocaleByProjectIteration(action.getWorkspaceId().getLocaleId(), action.getWorkspaceId().getProjectIterationId().getProjectSlug(), action.getWorkspaceId().getProjectIterationId().getIterationSlug());\n      }\n      catch (ZanataServiceException e)\n      {\n         throw new ActionException(e);\n      }\n\n      int gotoRow = -1;\n\n      List<HTextFlow> textFlows;\n\n      // FIXME use hibernate search instead of string comparison here\n      TextFlowFilter filter;\n\n      if ((action.getPhrase() != null && !action.getPhrase().isEmpty()) || (action.isFilterTranslated() || action.isFilterNeedReview() || action.isFilterUntranslated()))\n      {\n         log.debug(\"Fetch TransUnits: {}\", action.getPhrase());\n         filter = new TextFlowFilterImpl(action.getPhrase(), action.isFilterTranslated(), action.isFilterNeedReview(), action.isFilterUntranslated());\n         textFlows = textFlowDAO.getTransUnitList(action.getDocumentId().getValue());\n      }\n      else\n      {\n         log.debug(\"Fetch TransUnits:*\");\n         filter = new TextFlowFilterImpl();\n         textFlows = textFlowDAO.getTransUnitList(action.getDocumentId().getValue());\n      }\n\n      ArrayList<TransUnit> units = new ArrayList<TransUnit>();\n      for (HTextFlow textFlow : textFlows)\n      {\n         if (!filter.isFilterOut(textFlow, hLocale))\n         {\n            TransUnit tu = transUnitTransformer.transform(textFlow, hLocale);\n            if (action.getTargetTransUnitId() != null && tu.getId().equals(action.getTargetTransUnitId()))\n            {\n               gotoRow = units.size();\n            }\n            units.add(tu);\n         }\n      }\n      int size = units.size();\n\n      if ((action.getOffset() + action.getCount()) < units.size())\n      {\n         units.subList(action.getOffset() + action.getCount(), units.size()).clear();\n         units.subList(0, action.getOffset()).clear();\n      }\n      else if (action.getOffset() < units.size())\n      {\n         units.subList(0, action.getOffset()).clear();\n      }\n      return new GetTransUnitListResult(action.getDocumentId(), units, size, gotoRow);\n   }","id":60531,"modified_method":"@Override\n   public GetTransUnitListResult execute(GetTransUnitList action, ExecutionContext context) throws ActionException\n   {\n      identity.checkLoggedIn();\n      log.debug(\"Fetching TransUnits for document {}\", action.getDocumentId());\n\n      HLocale hLocale;\n      try\n      {\n         hLocale = localeServiceImpl.validateLocaleByProjectIteration(action.getWorkspaceId().getLocaleId(), action.getWorkspaceId().getProjectIterationId().getProjectSlug(), action.getWorkspaceId().getProjectIterationId().getIterationSlug());\n      }\n      catch (ZanataServiceException e)\n      {\n         throw new ActionException(e);\n      }\n\n      List<HTextFlow> textFlows;\n\n      if (hasSearchPhrase(action))\n      {\n         log.debug(\"Fetch TransUnits: {}\", action.getPhrase());\n         textFlows = searchByPhrase(action);\n      }\n      else if (action.isAcceptAllStatus())\n      {\n         log.debug(\"Fetch TransUnits:*\");\n         textFlows = textFlowDAO.getTextFlows(action.getDocumentId().getValue());\n      }\n      else\n      {\n         log.debug(\"Fetch TransUnits filtered by status: {}\", action);\n         textFlows = textFlowDAO.getTextFlowsByStatus(action.getDocumentId(), hLocale, action.isFilterTranslated(), action.isFilterNeedReview(), action.isFilterUntranslated());\n      }\n\n      int gotoRow = -1;\n      int size = textFlows.size();\n      int startIndex = action.getOffset();\n      int endIndex = Math.min(action.getOffset() + action.getCount(), size);\n      log.debug(\"loading index from {} to {}\", startIndex, endIndex);\n\n      ArrayList<TransUnit> units = new ArrayList<TransUnit>();\n      for (int i = startIndex; i < endIndex; i++)\n      {\n         HTextFlow textFlow = textFlows.get(i);\n         TransUnit tu = transUnitTransformer.transform(textFlow, hLocale);\n         if (action.getTargetTransUnitId() != null && tu.getId().equals(action.getTargetTransUnitId()))\n         {\n            gotoRow = i;\n         }\n         units.add(tu);\n      }\n      log.debug(\"go to index {}\", gotoRow);\n      return new GetTransUnitListResult(action.getDocumentId(), units, size, gotoRow);\n   }","commit_id":"722b5d89750998ccc6de4821a03a862a73bc2e32","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n    * for a given locale, we first find text flow where has no target (targets map has no key equals the locale),\n    * or (the text flow target has zero size contents OR content state is NEW).\n    *\n    * @param documentId document id (NOT the String type docId)\n    * @param hLocale locale\n    * @return a list of HTextFlow that has no translation for given locale.\n    */\n   public List<HTextFlow> getAllUntranslatedTextFlowByDocumentId(Long documentId, HLocale hLocale)\n   {\n      // @formatter:off\n      String query = \"select distinct tf from HTextFlow tf left join tf.targets \" +\n            \"where tf.obsolete = 0 and tf.document.id = :docId and \" +\n            \"(:locale not in indices(tf.targets) or exists \" + //text flow does not have a target for given locale\n            \"  (select tft.id from HTextFlowTarget tft where tft.textFlow.id = tf.id and tft.locale = :locale and \" +\n            \"     (size(tft.contents) = 0 or tft.state = :contentState)\" +\n            \"  )\" + //text flow has target but target has either empty contents or content state is NEW\n            \") order by tf.pos\";\n      // @formatter:on\n\n      Query textFlowQuery = getSession().createQuery(query);\n      textFlowQuery.setParameter(\"docId\", documentId);\n      textFlowQuery.setParameter(\"locale\", hLocale);\n      textFlowQuery.setParameter(\"contentState\", ContentState.New);\n      textFlowQuery.setCacheable(true).setComment(\"TextFlowDAO.getAllUntranslatedTextFlowByDocId\");\n\n      @SuppressWarnings(\"unchecked\")\n      List<HTextFlow> result = textFlowQuery.list();\n      log.debug(\"doc {} has {} untranslated textFlow for locale {}\",\n            new Object [] { documentId, result.size(), hLocale.getLocaleId()});\n      return result;\n   }","id":60532,"modified_method":"/**\n    * for a given locale, we first find text flow where has no target (targets map has no key equals the locale),\n    * or (the text flow target has zero size contents OR content state is NEW).\n    *\n    * @param documentId document id (NOT the String type docId)\n    * @param hLocale locale\n    * @return a list of HTextFlow that has no translation for given locale.\n    */\n   public List<HTextFlow> getAllUntranslatedTextFlowByDocumentId(DocumentId documentId, HLocale hLocale)\n   {\n      // @formatter:off\n      String query = \"select distinct tf from HTextFlow tf left join tf.targets \" +\n            \"where tf.obsolete = 0 and tf.document.id = :docId and \" +\n            \"(:locale not in indices(tf.targets) or exists \" + //text flow does not have a target for given locale\n            \"  (select tft.id from HTextFlowTarget tft where tft.textFlow.id = tf.id and tft.locale = :locale and tft.state = :contentState)\" + //text flow has target but target has either empty contents or content state is NEW\n            \") order by tf.pos\";\n      // @formatter:on\n\n      Query textFlowQuery = getSession().createQuery(query);\n      textFlowQuery.setParameter(\"docId\", documentId.getId());\n      textFlowQuery.setParameter(\"locale\", hLocale);\n      textFlowQuery.setParameter(\"contentState\", ContentState.New);\n      textFlowQuery.setCacheable(true).setComment(\"TextFlowDAO.getAllUntranslatedTextFlowByDocId\");\n\n      @SuppressWarnings(\"unchecked\")\n      List<HTextFlow> result = textFlowQuery.list();\n      log.debug(\"doc {} has {} untranslated textFlow for locale {}\",\n            new Object [] { documentId, result.size(), hLocale.getLocaleId()});\n      return result;\n   }","commit_id":"722b5d89750998ccc6de4821a03a862a73bc2e32","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void canGetAllUntranslatedTextFlowForADocument() {\n      HLocale deLocale = getEm().find(HLocale.class, 3L);\n      log.info(\"locale: {}\", deLocale);\n      List<HTextFlow> all = dao.getTransUnitList(1L);\n      log.info(\"all text flow: {}\", all);\n\n      List<HTextFlow> result = dao.getAllUntranslatedTextFlowByDocumentId(1L, deLocale);\n      assertThat(result.size(), is(0));\n\n      HLocale frLocale = getEm().find(HLocale.class, 6L);\n      result = dao.getAllUntranslatedTextFlowByDocumentId(1L, frLocale);\n      assertThat(result.size(), is(1));\n   }","id":60533,"modified_method":"@Test\n   public void canGetAllUntranslatedTextFlowForADocument() {\n      HLocale deLocale = getEm().find(HLocale.class, 3L);\n      log.info(\"locale: {}\", deLocale);\n\n      List<HTextFlow> result = dao.getAllUntranslatedTextFlowByDocumentId(new DocumentId(1L), deLocale);\n      assertThat(result.size(), is(0));\n\n      HLocale frLocale = getEm().find(HLocale.class, 6L);\n      result = dao.getAllUntranslatedTextFlowByDocumentId(new DocumentId(1L), frLocale);\n      assertThat(result.size(), is(1));\n\n   }","commit_id":"722b5d89750998ccc6de4821a03a862a73bc2e32","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   protected void prepareDBUnitOperations()\n   {\n      beforeTestOperations.add(new DataSetOperation(\"org/zanata/test/model/ProjectsData.dbunit.xml\", DatabaseOperation.CLEAN_INSERT));\n      beforeTestOperations.add(new DataSetOperation(\"org/zanata/test/model/TextFlowTestData.dbunit.xml\", DatabaseOperation.CLEAN_INSERT));\n      beforeTestOperations.add(new DataSetOperation(\"org/zanata/test/model/LocalesData.dbunit.xml\", DatabaseOperation.CLEAN_INSERT));\n   }","id":60534,"modified_method":"@Override\n   protected void prepareDBUnitOperations()\n   {\n      beforeTestOperations.add(new DataSetOperation(\"org/zanata/test/model/ProjectsData.dbunit.xml\", DatabaseOperation.CLEAN_INSERT));\n      beforeTestOperations.add(new DataSetOperation(\"org/zanata/test/model/TextFlowTestData.dbunit.xml\", DatabaseOperation.CLEAN_INSERT));\n      beforeTestOperations.add(new DataSetOperation(\"org/zanata/test/model/LocalesData.dbunit.xml\", DatabaseOperation.CLEAN_INSERT));\n      beforeTestOperations.add(new DataSetOperation(\"org/zanata/test/model/AccountData.dbunit.xml\", DatabaseOperation.CLEAN_INSERT));\n   }","commit_id":"722b5d89750998ccc6de4821a03a862a73bc2e32","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n    * @param workspace\n    * @param documentPaths null or empty to search entire project, otherwise\n    *           only results for the given document paths will be returned\n    * @param constraints\n    * @return\n    */\n   private List<HTextFlowTarget> findTextFlowTargetsByDocumentPaths(WorkspaceId workspace, List<String> documentPaths, FilterConstraints constraints)\n   {\n      LocaleId localeId = workspace.getLocaleId();\n      String projectSlug = workspace.getProjectIterationId().getProjectSlug();\n      String iterationSlug = workspace.getProjectIterationId().getIterationSlug();\n\n      // TODO consider whether to allow null and empty search strings.\n      // May want to fork to use a different method to retrieve all targets if\n      // empty targets are required.\n\n      // check that locale is valid for the workspace\n      try\n      {\n         localeServiceImpl.validateLocaleByProjectIteration(localeId, projectSlug, iterationSlug);\n      }\n      catch (ZanataServiceException e)\n      {\n         throw new ZanataServiceException(\"Failed to validate locale\", e);\n      }\n\n      if (!constraints.isSearchInSource() && !constraints.isSearchInTarget())\n      {\n         //searching nowhere\n         return new ArrayList<HTextFlowTarget>();\n      }\n\n      // FIXME remove .trim() and zero-length check when ngram analyzer is updated to respect leading and trailing whitespace\n      int searchLength = Math.min(3, constraints.getSearchString().trim().length());\n      if (searchLength == 0)\n      {\n         return new ArrayList<HTextFlowTarget>();\n      }\n      Analyzer ngramAnalyzer = new ConfigurableNgramAnalyzer(searchLength, !constraints.isCaseSensitive());\n\n      String[] searchFields = (constraints.isCaseSensitive() ? IndexFieldLabels.CONTENT_FIELDS_CASE_PRESERVED : IndexFieldLabels.CONTENT_FIELDS_CASE_FOLDED);\n\n      Query searchPhraseQuery;\n      QueryParser parser = new MultiFieldQueryParser(Version.LUCENE_29, searchFields, ngramAnalyzer);\n      try\n      {\n         searchPhraseQuery = parser.parse(\"\\\"\" + QueryParser.escape(constraints.getSearchString()) + \"\\\"\");\n      }\n      catch (ParseException e)\n      {\n         throw new ZanataServiceException(\"Failed to parse query\", e);\n      }\n\n      TermQuery projectQuery = new TermQuery(new Term(IndexFieldLabels.PROJECT_FIELD, projectSlug));\n      TermQuery iterationQuery = new TermQuery(new Term(IndexFieldLabels.ITERATION_FIELD, iterationSlug));\n      TermQuery localeQuery = new TermQuery(new Term(IndexFieldLabels.LOCALE_ID_FIELD, localeId.getId()));\n\n      BooleanQuery sourceQuery = new BooleanQuery();\n      sourceQuery.add(projectQuery, Occur.MUST);\n      sourceQuery.add(iterationQuery, Occur.MUST);\n      sourceQuery.add(searchPhraseQuery, Occur.MUST);\n\n      if (documentPaths != null && !documentPaths.isEmpty())\n      {\n         ArrayList<Term> docPathTerms = new ArrayList<Term>();\n         for (String s : documentPaths)\n         {\n            docPathTerms.add(new Term(IndexFieldLabels.DOCUMENT_ID_FIELD, s));\n         }\n         MultiPhraseQuery documentsQuery = new MultiPhraseQuery();\n         documentsQuery.add(docPathTerms.toArray(new Term[docPathTerms.size()]));\n         sourceQuery.add(documentsQuery, Occur.MUST);\n      }\n\n      List<HTextFlowTarget> resultList = new ArrayList<HTextFlowTarget>();\n      if (constraints.isSearchInTarget())\n      {\n         BooleanQuery targetQuery = (BooleanQuery) sourceQuery.clone();\n         targetQuery.add(localeQuery, Occur.MUST);\n         if (!constraints.isIncludeApproved())\n         {\n            TermQuery approvedStateQuery = new TermQuery(new Term(IndexFieldLabels.CONTENT_STATE_FIELD, ContentState.Approved.toString()));\n            targetQuery.add(approvedStateQuery, Occur.MUST_NOT);\n         }\n\n         if (!constraints.isIncludeFuzzy())\n         {\n            TermQuery approvedStateQuery = new TermQuery(new Term(IndexFieldLabels.CONTENT_STATE_FIELD, ContentState.NeedReview.toString()));\n            targetQuery.add(approvedStateQuery, Occur.MUST_NOT);\n         }\n\n         if (!constraints.isIncludeNew())\n         {\n            TermQuery approvedStateQuery = new TermQuery(new Term(IndexFieldLabels.CONTENT_STATE_FIELD, ContentState.New.toString()));\n            targetQuery.add(approvedStateQuery, Occur.MUST_NOT);\n         }\n\n         FullTextQuery ftQuery = entityManager.createFullTextQuery(targetQuery, HTextFlowTarget.class);\n         @SuppressWarnings(\"unchecked\")\n         List<HTextFlowTarget> matchedTargets = (List<HTextFlowTarget>) ftQuery.getResultList();\n         log.info(\"got {} HTextFLowTarget results\", matchedTargets.size());\n         resultList.addAll(matchedTargets);\n      }\n\n      if (constraints.isSearchInSource())\n      {\n         FullTextQuery ftQuery = entityManager.createFullTextQuery(sourceQuery, HTextFlow.class);\n         @SuppressWarnings(\"unchecked\")\n         List<HTextFlow> matchedSources = (List<HTextFlow>) ftQuery.getResultList();\n         log.info(\"got {} HTextFLow results\", matchedSources.size());\n         HLocale hLocale = localeServiceImpl.getByLocaleId(localeId);\n         for (HTextFlow htf : matchedSources)\n         {\n            HTextFlowTarget htft = htf.getTargets().get(hLocale.getId());\n            if (htft != null && htft.getState() != ContentState.New)\n            {\n               // TODO filter other states?\n               if (!resultList.contains(htft))\n               {\n                  resultList.add(htf.getTargets().get(hLocale.getId()));\n               }\n            }\n         }\n      }\n\n      return resultList;\n   }","id":60535,"modified_method":"/**\n    * @param workspace\n    * @param documentPaths null or empty to search entire project, otherwise\n    *           only results for the given document paths will be returned\n    * @param constraints\n    * @return\n    */\n   private List<HTextFlowTarget> findTextFlowTargetsByDocumentPaths(WorkspaceId workspace, List<String> documentPaths, FilterConstraints constraints)\n   {\n      LocaleId localeId = workspace.getLocaleId();\n      String projectSlug = workspace.getProjectIterationId().getProjectSlug();\n      String iterationSlug = workspace.getProjectIterationId().getIterationSlug();\n\n      // TODO consider whether to allow null and empty search strings.\n      // May want to fork to use a different method to retrieve all targets if\n      // empty targets are required.\n\n      // check that locale is valid for the workspace\n      try\n      {\n         localeServiceImpl.validateLocaleByProjectIteration(localeId, projectSlug, iterationSlug);\n      }\n      catch (ZanataServiceException e)\n      {\n         throw new ZanataServiceException(\"Failed to validate locale\", e);\n      }\n\n      if (!constraints.isSearchInSource() && !constraints.isSearchInTarget())\n      {\n         //searching nowhere\n         return Collections.emptyList();\n      }\n\n      // FIXME remove .trim() and zero-length check when ngram analyzer is updated to respect leading and trailing whitespace\n      int searchLength = Math.min(3, constraints.getSearchString().trim().length());\n      if (searchLength == 0)\n      {\n         return Collections.emptyList();\n      }\n      Analyzer ngramAnalyzer = new ConfigurableNgramAnalyzer(searchLength, !constraints.isCaseSensitive());\n\n      String[] searchFields = (constraints.isCaseSensitive() ? IndexFieldLabels.CONTENT_FIELDS_CASE_PRESERVED : IndexFieldLabels.CONTENT_FIELDS_CASE_FOLDED);\n\n      Query searchPhraseQuery;\n      QueryParser parser = new MultiFieldQueryParser(Version.LUCENE_29, searchFields, ngramAnalyzer);\n      try\n      {\n         searchPhraseQuery = parser.parse(\"\\\"\" + QueryParser.escape(constraints.getSearchString()) + \"\\\"\");\n      }\n      catch (ParseException e)\n      {\n         throw new ZanataServiceException(\"Failed to parse query\", e);\n      }\n\n      TermQuery projectQuery = new TermQuery(new Term(IndexFieldLabels.PROJECT_FIELD, projectSlug));\n      TermQuery iterationQuery = new TermQuery(new Term(IndexFieldLabels.ITERATION_FIELD, iterationSlug));\n      TermQuery localeQuery = new TermQuery(new Term(IndexFieldLabels.LOCALE_ID_FIELD, localeId.getId()));\n\n      BooleanQuery sourceQuery = new BooleanQuery();\n      sourceQuery.add(projectQuery, Occur.MUST);\n      sourceQuery.add(iterationQuery, Occur.MUST);\n      sourceQuery.add(searchPhraseQuery, Occur.MUST);\n\n      if (documentPaths != null && !documentPaths.isEmpty())\n      {\n         ArrayList<Term> docPathTerms = new ArrayList<Term>();\n         for (String s : documentPaths)\n         {\n            docPathTerms.add(new Term(IndexFieldLabels.DOCUMENT_ID_FIELD, s));\n         }\n         MultiPhraseQuery documentsQuery = new MultiPhraseQuery();\n         documentsQuery.add(docPathTerms.toArray(new Term[docPathTerms.size()]));\n         sourceQuery.add(documentsQuery, Occur.MUST);\n      }\n\n      List<HTextFlowTarget> resultList = new ArrayList<HTextFlowTarget>();\n      if (constraints.isSearchInTarget())\n      {\n         BooleanQuery targetQuery = (BooleanQuery) sourceQuery.clone();\n         targetQuery.add(localeQuery, Occur.MUST);\n         if (!constraints.isIncludeApproved())\n         {\n            TermQuery approvedStateQuery = new TermQuery(new Term(IndexFieldLabels.CONTENT_STATE_FIELD, ContentState.Approved.toString()));\n            targetQuery.add(approvedStateQuery, Occur.MUST_NOT);\n         }\n\n         if (!constraints.isIncludeFuzzy())\n         {\n            TermQuery approvedStateQuery = new TermQuery(new Term(IndexFieldLabels.CONTENT_STATE_FIELD, ContentState.NeedReview.toString()));\n            targetQuery.add(approvedStateQuery, Occur.MUST_NOT);\n         }\n\n         if (!constraints.isIncludeNew())\n         {\n            TermQuery approvedStateQuery = new TermQuery(new Term(IndexFieldLabels.CONTENT_STATE_FIELD, ContentState.New.toString()));\n            targetQuery.add(approvedStateQuery, Occur.MUST_NOT);\n         }\n\n         FullTextQuery ftQuery = entityManager.createFullTextQuery(targetQuery, HTextFlowTarget.class);\n         @SuppressWarnings(\"unchecked\")\n         List<HTextFlowTarget> matchedTargets = (List<HTextFlowTarget>) ftQuery.getResultList();\n         log.info(\"got {} HTextFLowTarget results\", matchedTargets.size());\n         resultList.addAll(matchedTargets);\n      }\n\n      if (constraints.isSearchInSource())\n      {\n         FullTextQuery ftQuery = entityManager.createFullTextQuery(sourceQuery, HTextFlow.class);\n         @SuppressWarnings(\"unchecked\")\n         List<HTextFlow> matchedSources = (List<HTextFlow>) ftQuery.getResultList();\n         log.info(\"got {} HTextFLow results\", matchedSources.size());\n         HLocale hLocale = localeServiceImpl.getByLocaleId(localeId);\n         for (HTextFlow htf : matchedSources)\n         {\n            HTextFlowTarget htft = htf.getTargets().get(hLocale.getId());\n            if (htft != null && htft.getState() != ContentState.New)\n            {\n               // TODO filter other states?\n               if (!resultList.contains(htft))\n               {\n                  resultList.add(htf.getTargets().get(hLocale.getId()));\n               }\n            }\n         }\n      }\n\n      return resultList;\n   }","commit_id":"722b5d89750998ccc6de4821a03a862a73bc2e32","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public List<HTextFlow> findTextFlows(WorkspaceId workspace, DocumentId doc, FilterConstraints constraints)\n   {\n      // TODO Implement findTextFlows within document\n      return null;\n   }","id":60536,"modified_method":"@Override\n   public List<HTextFlow> findTextFlows(WorkspaceId workspace, DocumentId doc, FilterConstraints constraints)\n   {\n      //TODO this method has high percentage of duplication from the above method. Refactor.\n      LocaleId localeId = workspace.getLocaleId();\n      String projectSlug = workspace.getProjectIterationId().getProjectSlug();\n      String iterationSlug = workspace.getProjectIterationId().getIterationSlug();\n\n      localeServiceImpl.validateLocaleByProjectIteration(localeId, projectSlug, iterationSlug);\n\n      if (!constraints.isSearchInSource() && !constraints.isSearchInTarget())\n      {\n         //searching nowhere\n         return Collections.emptyList();\n      }\n\n      // FIXME remove .trim() and zero-length check when ngram analyzer is updated to respect leading and trailing whitespace\n      int searchLength = Math.min(3, constraints.getSearchString().trim().length());\n      if (searchLength == 0)\n      {\n         return Collections.emptyList();\n      }\n      Analyzer ngramAnalyzer = new ConfigurableNgramAnalyzer(searchLength, !constraints.isCaseSensitive());\n\n      String[] searchFields = (constraints.isCaseSensitive() ? IndexFieldLabels.CONTENT_FIELDS_CASE_PRESERVED : IndexFieldLabels.CONTENT_FIELDS_CASE_FOLDED);\n\n      Query searchPhraseQuery;\n      QueryParser parser = new MultiFieldQueryParser(Version.LUCENE_29, searchFields, ngramAnalyzer);\n      try\n      {\n         searchPhraseQuery = parser.parse(\"\\\"\" + QueryParser.escape(constraints.getSearchString()) + \"\\\"\");\n      }\n      catch (ParseException e)\n      {\n         throw new ZanataServiceException(\"Failed to parse query\", e);\n      }\n\n      TermQuery projectQuery = new TermQuery(new Term(IndexFieldLabels.PROJECT_FIELD, projectSlug));\n      TermQuery iterationQuery = new TermQuery(new Term(IndexFieldLabels.ITERATION_FIELD, iterationSlug));\n      TermQuery localeQuery = new TermQuery(new Term(IndexFieldLabels.LOCALE_ID_FIELD, localeId.getId()));\n      HDocument hDocument = documentDAO.getById(doc.getId());\n      TermQuery documentQuery = new TermQuery(new Term(IndexFieldLabels.DOCUMENT_ID_FIELD, hDocument.getDocId()));\n\n      BooleanQuery sourceQuery = new BooleanQuery();\n      sourceQuery.add(projectQuery, Occur.MUST);\n      sourceQuery.add(iterationQuery, Occur.MUST);\n      sourceQuery.add(searchPhraseQuery, Occur.MUST);\n      sourceQuery.add(documentQuery, Occur.MUST);\n\n      List<HTextFlow> resultList = Lists.newArrayList();\n      if (constraints.isSearchInTarget())\n      {\n         BooleanQuery targetQuery = (BooleanQuery) sourceQuery.clone();\n         targetQuery.add(localeQuery, Occur.MUST);\n         if (!constraints.isIncludeApproved())\n         {\n            TermQuery approvedStateQuery = new TermQuery(new Term(IndexFieldLabels.CONTENT_STATE_FIELD, ContentState.Approved.toString()));\n            targetQuery.add(approvedStateQuery, Occur.MUST_NOT);\n         }\n\n         if (!constraints.isIncludeFuzzy())\n         {\n            TermQuery approvedStateQuery = new TermQuery(new Term(IndexFieldLabels.CONTENT_STATE_FIELD, ContentState.NeedReview.toString()));\n            targetQuery.add(approvedStateQuery, Occur.MUST_NOT);\n         }\n\n         if (!constraints.isIncludeNew())\n         {\n            TermQuery approvedStateQuery = new TermQuery(new Term(IndexFieldLabels.CONTENT_STATE_FIELD, ContentState.New.toString()));\n            targetQuery.add(approvedStateQuery, Occur.MUST_NOT);\n         }\n\n         FullTextQuery ftQuery = entityManager.createFullTextQuery(targetQuery, HTextFlowTarget.class);\n         @SuppressWarnings(\"unchecked\")\n         List<HTextFlowTarget> matchedTargets = (List<HTextFlowTarget>) ftQuery.getResultList();\n         log.info(\"got {} HTextFLowTarget results\", matchedTargets.size());\n         List<HTextFlow> hTextFlows = Lists.transform(matchedTargets, new Function<HTextFlowTarget, HTextFlow>()\n         {\n            @Override\n            public HTextFlow apply(HTextFlowTarget target)\n            {\n               return target.getTextFlow();\n            }\n         });\n         resultList.addAll(hTextFlows);\n      }\n\n      if (constraints.isSearchInSource())\n      {\n         FullTextQuery ftQuery = entityManager.createFullTextQuery(sourceQuery, HTextFlow.class);\n         @SuppressWarnings(\"unchecked\")\n         List<HTextFlow> matchedSources = (List<HTextFlow>) ftQuery.getResultList();\n         log.info(\"got {} HTextFLow results\", matchedSources.size());\n         HLocale hLocale = localeServiceImpl.getByLocaleId(localeId);\n         for (HTextFlow hTextFlow : matchedSources)\n         {\n            if (!resultList.contains(hTextFlow))\n            {\n               HTextFlowTarget hTextFlowTarget = hTextFlow.getTargets().get(hLocale.getId());\n               if (isContentStateValid(hTextFlowTarget, constraints))\n               {\n                  resultList.add(hTextFlow);\n               }\n            }\n         }\n      }\n\n      return resultList;\n   }","commit_id":"722b5d89750998ccc6de4821a03a862a73bc2e32","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   protected void onBind()\n   {\n\n      display.getFilterText().addValueChangeHandler(new ValueChangeHandler<String>()\n      {\n         @Override\n         public void onValueChange(ValueChangeEvent<String> event)\n         {\n            if (event.getValue() != currentState.getSearchText())\n            {\n               HistoryToken newToken = history.getHistoryToken();\n               newToken.setSearchText(event.getValue());\n               history.newItem(newToken);\n            }\n         }\n      });\n\n      registerHandler(history.addValueChangeHandler(new ValueChangeHandler<String>()\n      {\n\n         @Override\n         public void onValueChange(ValueChangeEvent<String> event)\n         {\n            HistoryToken token = history.getHistoryToken();\n            if (token.getSearchText() != currentState.getSearchText())\n            {\n               eventBus.fireEvent(new FindMessageEvent(token.getSearchText()));\n               display.getFilterText().setValue(token.getSearchText(), false);\n            }\n            currentState = token;\n         }\n      }));\n\n   }","id":60537,"modified_method":"@Override\n   protected void onBind()\n   {\n\n      display.getFilterText().addValueChangeHandler(new ValueChangeHandler<String>()\n      {\n         @Override\n         public void onValueChange(ValueChangeEvent<String> event)\n         {\n            if (!event.getValue().equals(currentState.getSearchText()))\n            {\n               HistoryToken newToken = history.getHistoryToken();\n               newToken.setSearchText(event.getValue());\n               history.newItem(newToken);\n            }\n         }\n      });\n\n      registerHandler(history.addValueChangeHandler(new ValueChangeHandler<String>()\n      {\n\n         @Override\n         public void onValueChange(ValueChangeEvent<String> event)\n         {\n            HistoryToken token = history.getHistoryToken();\n            if (!token.getSearchText().equals(currentState.getSearchText()))\n            {\n               display.getFilterText().setValue(token.getSearchText(), false);\n               eventBus.fireEvent(new FindMessageEvent(token.getSearchText()));\n            }\n            currentState = token;\n         }\n      }));\n\n   }","commit_id":"722b5d89750998ccc6de4821a03a862a73bc2e32","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n    protected void init(VaadinRequest request) {\n        VerticalLayout rootLayout = new VerticalLayout();\n        rootLayout.setSpacing(true);\n        rootLayout.setSizeFull();\n\n        View view = SurveillanceViewProvider.getInstance().getView(\"default\");\n\n        SurveillanceViewTable surveillanceViewTable = new SurveillanceViewTable(view, m_surveillanceViewService);\n\n        rootLayout.addComponent(surveillanceViewTable);\n\n        VerticalLayout secondLayout = new VerticalLayout();\n        secondLayout.setSpacing(true);\n\n        SurveillanceViewAlarmTable surveillanceViewAlarmTable = new SurveillanceViewAlarmTable(m_surveillanceViewService);\n        SurveillanceViewNotificationTable surveillanceViewNotificationTable = new SurveillanceViewNotificationTable(m_surveillanceViewService);\n        SurveillanceViewNodeRtcTable surveillanceViewNodeRtcTable = new SurveillanceViewNodeRtcTable(m_surveillanceViewService);\n\n        secondLayout.addComponent(surveillanceViewAlarmTable);\n        secondLayout.addComponent(surveillanceViewNotificationTable);\n        secondLayout.addComponent(surveillanceViewNodeRtcTable);\n\n        surveillanceViewTable.addDetailsTable(surveillanceViewAlarmTable);\n        surveillanceViewTable.addDetailsTable(surveillanceViewNotificationTable);\n        surveillanceViewTable.addDetailsTable(surveillanceViewNodeRtcTable);\n\n        rootLayout.addComponent(secondLayout);\n        rootLayout.setExpandRatio(secondLayout, 1.0f);\n        setContent(rootLayout);\n    }","id":60538,"modified_method":"@Override\n    protected void init(VaadinRequest request) {\n\n        VerticalLayout rootLayout = new VerticalLayout();\n        rootLayout.setSpacing(true);\n        //rootLayout.setSizeFull();\n\n        String viewName = request.getParameter(\"viewName\") == null ? \"default\" : request.getParameter(\"viewName\");\n        boolean dashboard = request.getParameter(\"dashboard\") != null && \"true\".equals(request.getParameter(\"dashboard\"));\n\n        View view = SurveillanceViewProvider.getInstance().getView(\"default\");\n\n        SurveillanceViewTable surveillanceViewTable = new SurveillanceViewTable(view, m_surveillanceViewService);\n/*\n        for (Map.Entry<String, String[]> entry : request.getParameterMap().entrySet()) {\n            rootLayout.addComponent(new Label(\"Key: '\" + entry.getKey() + \"'\"));\n        }\n*/\n        rootLayout.addComponent(new Label(\"viewName=\" + viewName));\n        rootLayout.addComponent(new Label(\"dashboard=\" + dashboard));\n\n        rootLayout.addComponent(surveillanceViewTable);\n\n        if (dashboard) {\n            VerticalLayout secondLayout = new VerticalLayout();\n            secondLayout.setSpacing(true);\n\n            SurveillanceViewAlarmTable surveillanceViewAlarmTable = new SurveillanceViewAlarmTable(m_surveillanceViewService);\n            SurveillanceViewNotificationTable surveillanceViewNotificationTable = new SurveillanceViewNotificationTable(m_surveillanceViewService);\n            SurveillanceViewNodeRtcTable surveillanceViewNodeRtcTable = new SurveillanceViewNodeRtcTable(m_surveillanceViewService);\n\n            secondLayout.addComponent(surveillanceViewAlarmTable);\n            secondLayout.addComponent(surveillanceViewNotificationTable);\n            secondLayout.addComponent(surveillanceViewNodeRtcTable);\n\n            surveillanceViewTable.addDetailsTable(surveillanceViewAlarmTable);\n            surveillanceViewTable.addDetailsTable(surveillanceViewNotificationTable);\n            surveillanceViewTable.addDetailsTable(surveillanceViewNodeRtcTable);\n\n            rootLayout.addComponent(secondLayout);\n            rootLayout.setExpandRatio(secondLayout, 1.0f);\n        }\n\n        setContent(rootLayout);\n    }","commit_id":"a4b5eddfefb984ab79871b22b895428b7a7c6a3e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n\tpublic boolean handleReceivedPacket(byte[] buf, int offset, int length, long now, Peer replyTo) {\n\t\tNPFPacket packet = null;\n\t\tSessionKey s = null;\n\t\tfor(int i = 0; i < 3; i++) {\n\t\t\tif(i == 0) {\n\t\t\t\ts = pn.getCurrentKeyTracker();\n\t\t\t} else if (i == 1) {\n\t\t\t\ts = pn.getPreviousKeyTracker();\n\t\t\t} else {\n\t\t\t\ts = pn.getUnverifiedKeyTracker();\n\t\t\t}\n\t\t\tif(s == null) continue;\n\t\t\tpacket = tryDecipherPacket(buf, offset, length, s);\n\t\t\tif(packet != null) {\n\t\t\t\tif(logDEBUG) Logger.debug(this, \"Decrypted packet with tracker \" + i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(packet == null) {\n\t\t\tLogger.warning(this, \"Could not decrypt received packet\");\n\t\t\treturn false;\n\t\t}\n\n\t\tpn.receivedPacket(false, true);\n\t\tpn.verified(s);\n\t\tpn.maybeRekey();\n\t\tpn.reportIncomingPacket(buf, offset, length, now);\n\n\t\tLinkedList<byte[]> finished = handleDecryptedPacket(packet, s);\n\t\tif(logMINOR && !finished.isEmpty()) \n\t\t\tLogger.minor(this, \"Decoded messages: \"+finished.size());\n\t\tDecodingMessageGroup group = pn.startProcessingDecryptedMessages(finished.size());\n\t\tfor(byte[] buffer : finished) {\n\t\t\tgroup.processDecryptedMessage(buffer, 0, buffer.length, 0);\n\t\t}\n\t\tgroup.complete();\n\n\t\treturn true;\n\t}","id":60539,"modified_method":"@Override\n\tpublic boolean handleReceivedPacket(byte[] buf, int offset, int length, long now, Peer replyTo) {\n\t\tNPFPacket packet = null;\n\t\tSessionKey s = null;\n\t\tfor(int i = 0; i < 3; i++) {\n\t\t\tif(i == 0) {\n\t\t\t\ts = pn.getCurrentKeyTracker();\n\t\t\t} else if (i == 1) {\n\t\t\t\ts = pn.getPreviousKeyTracker();\n\t\t\t} else {\n\t\t\t\ts = pn.getUnverifiedKeyTracker();\n\t\t\t}\n\t\t\tif(s == null) continue;\n\t\t\tpacket = tryDecipherPacket(buf, offset, length, s);\n\t\t\tif(packet != null) {\n\t\t\t\tif(logDEBUG) Logger.debug(this, \"Decrypted packet with tracker \" + i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(packet == null) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Could not decrypt received packet\");\n\t\t\treturn false;\n\t\t}\n\n\t\tpn.receivedPacket(false, true);\n\t\tpn.verified(s);\n\t\tpn.maybeRekey();\n\t\tpn.reportIncomingPacket(buf, offset, length, now);\n\n\t\tLinkedList<byte[]> finished = handleDecryptedPacket(packet, s);\n\t\tif(logMINOR && !finished.isEmpty()) \n\t\t\tLogger.minor(this, \"Decoded messages: \"+finished.size());\n\t\tDecodingMessageGroup group = pn.startProcessingDecryptedMessages(finished.size());\n\t\tfor(byte[] buffer : finished) {\n\t\t\tgroup.processDecryptedMessage(buffer, 0, buffer.length, 0);\n\t\t}\n\t\tgroup.complete();\n\n\t\treturn true;\n\t}","commit_id":"e5d13e760265ff31301f5f02067e3be172ff6950","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\tprotected void timedOutWhileWaiting(double load) {\n\t\t// Calculate the reject period based on the proportion of requests being timed out.\n\t\t// If the vast majority are being accepted, then try again after the timeout.\n\t\t// If more are being rejected, it makes sense to wait longer, up to the limit of the maximum recently failed time.\n\t\tint period = (int) Math.min(((fetchTimeout / 5) / (1.0 - load)), FailureTable.RECENTLY_FAILED_TIME);\n\t\tif(source != null)\n\t\t\tLogger.error(this, \"Timed out while waiting for a slot, period = \"+period+\" because average reject proportion for peers is \"+load+\" on \"+this);\n\t\telse\n\t\t\tLogger.warning(this, \"Local request timed out while waiting for a slot, period = \"+period+\" because average reject proportion for peers is \"+load+\" on \"+this);\n    \tsynchronized(this) {\n    \t\trecentlyFailedTimeLeft = period;\n    \t}\n    \tfinish(RECENTLY_FAILED, null, false);\n        node.failureTable.onFinalFailure(key, null, htl, origHTL, -1, -1, source);\n\t}","id":60540,"modified_method":"@Override\n\tprotected void timedOutWhileWaiting(double load) {\n\t\t// Calculate the reject period based on the proportion of requests being timed out.\n\t\t// If the vast majority are being accepted, then try again after the timeout.\n\t\t// If more are being rejected, it makes sense to wait longer, up to the limit of the maximum recently failed time.\n\t\tint period = (int) Math.min(((fetchTimeout / 5) / (1.0 - load)), FailureTable.RECENTLY_FAILED_TIME);\n\t\t// Timeouts while waiting for a slot are relatively normal.\n\t\t// That is, in an ideal world they wouldn't happen.\n\t\t// They happen when the network is very small, or when there is a capacity bottleneck.\n\t\t// They are best considered statistically, see the stats page.\n\t\t// Individual timeouts are therefore not very interesting...\n\t\tif(logMINOR) {\n\t\t\tif(source != null)\n\t\t\t\tLogger.minor(this, \"Timed out while waiting for a slot, period = \"+period+\" because average reject proportion for peers is \"+load+\" on \"+this);\n\t\t\telse if(logMINOR)\n\t\t\t\tLogger.minor(this, \"Local request timed out while waiting for a slot, period = \"+period+\" because average reject proportion for peers is \"+load+\" on \"+this);\n\t\t}\n    \tsynchronized(this) {\n    \t\trecentlyFailedTimeLeft = period;\n    \t}\n    \tfinish(RECENTLY_FAILED, null, false);\n        node.failureTable.onFinalFailure(key, null, htl, origHTL, -1, -1, source);\n\t}","commit_id":"cda11eee5fd223d6fa25129d3da6e1bb807f7f24","url":"https://github.com/freenet/fred"},{"original_method":"NPFPacket createPacket(int maxPacketSize, PeerMessageQueue messageQueue) {\n\t\t//Mark packets as lost\n\t\tsynchronized(sentPackets) {\n\t\t\tint maxRtt = maxRTT();\n\t\t\tlong curTime = System.currentTimeMillis();\n\n\t\t\tIterator<Long> it = sentPackets.keySet().iterator();\n\t\t\twhile(it.hasNext()) {\n\t\t\t\tLong l = it.next();\n\t\t\t\tSentPacket s = sentPackets.get(l);\n\t\t\t\tif(s.getSentTime() < (curTime - NUM_RTTS_TO_LOOSE * maxRtt)) {\n\t\t\t\t\tif(logMINOR) {\n\t\t\t\t\t\tLogger.minor(this, \"Assuming packet \" + l + \" has been lost. \"\n\t\t\t\t\t\t                + \"Delay \" + (curTime - s.getSentTime()) + \"ms, \"\n\t\t\t\t\t\t                + \"threshold \" + (NUM_RTTS_TO_LOOSE * maxRtt) + \"ms\");\n\t\t\t\t\t}\n\t\t\t\t\ts.lost();\n\t\t\t\t\tit.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSentPacket sentPacket = new SentPacket();\n\t\tNPFPacket packet = new NPFPacket();\n\t\tpacket.setSequenceNumber(nextSequenceNumber++);\n\n\t\tint numAcks = 0;\n\t\tsynchronized(acks) {\n\t\t\tlong firstAck = 0;\n\t\t\tIterator<Long> it = acks.iterator();\n\t\t\twhile (it.hasNext() && numAcks < 256 && packet.getLength() < maxPacketSize) {\n\t\t\t\tlong ack = it.next();\n\t\t\t\tif(numAcks == 0) {\n\t\t\t\t\tfirstAck = ack;\n\t\t\t\t} else {\n\t\t\t\t\t// Check that it can be compressed\n\t\t\t\t\tlong compressedAck = ack - firstAck;\n\t\t\t\t\tif((compressedAck < 0) || (compressedAck > 255)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpacket.addAck(ack);\n\t\t\t\t++numAcks;\n\t\t\t\tit.remove();\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < startedByPrio.size(); i++) {\n\t\t\tHashMap<Integer, MessageWrapper> started = startedByPrio.get(i);\n\n\t\t\t//Try to finish messages that have been started\n\t\t\tsynchronized(started) {\n\t\t\t\tIterator<MessageWrapper> it = started.values().iterator();\n\t\t\t\twhile(it.hasNext() && packet.getLength() < maxPacketSize) {\n\t\t\t\t\tMessageWrapper wrapper = it.next();\n\t\t\t\t\tMessageFragment frag = wrapper.getMessageFragment(maxPacketSize - packet.getLength());\n\t\t\t\t\tif(frag == null) continue;\n\t\t\t\t\tpacket.addMessageFragment(frag);\n\t\t\t\t\tsentPacket.addFragment(wrapper, frag.fragmentOffset, frag.fragmentLength);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Add messages from the message queue\n\t\t\twhile ((packet.getLength() + 10) < maxPacketSize) { //Fragment header is max 9 bytes, allow min 1 byte data\n\t\t\t\tMessageItem item = null;\n\t\t\t\tsynchronized(messageQueue) {\n\t\t\t\t\titem = messageQueue.grabQueuedMessageItem(i);\n\t\t\t\t}\n\t\t\t\tif(item == null) break;\n\n\t\t\t\tint messageID = getMessageID();\n\t\t\t\tif(messageID == -1) {\n\t\t\t\t\tLogger.warning(this, \"No availiable message ID, requeuing and sending packet\");\n\t\t\t\t\tmessageQueue.pushfrontPrioritizedMessageItem(item);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tMessageWrapper wrapper = new MessageWrapper(item, messageID);\n\t\t\t\tMessageFragment frag = wrapper.getMessageFragment(maxPacketSize - packet.getLength());\n\t\t\t\tif(frag == null) break;\n\t\t\t\tpacket.addMessageFragment(frag);\n\t\t\t\tsentPacket.addFragment(wrapper, frag.fragmentOffset, frag.fragmentLength);\n\n\t\t\t\t//Priority of the one we grabbed might be higher than i\n\t\t\t\tHashMap<Integer, MessageWrapper> queue = startedByPrio.get(item.getPriority());\n\t\t\t\tsynchronized(queue) {\n\t\t\t\t\tqueue.put(messageID, wrapper);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(packet.getLength() == 5) return null;\n\n\t\tif(packet.getFragments().size() != 0) {\n\t\t\tsynchronized(sentPackets) {\n\t\t\t\tsentPackets.put(packet.getSequenceNumber(), sentPacket);\n\t\t\t}\n\t\t}\n\n\t\tsentPacket.sent();\n\t\t\n\t\treturn packet;\n\t}","id":60541,"modified_method":"NPFPacket createPacket(int maxPacketSize, PeerMessageQueue messageQueue) {\n\t\t//Mark packets as lost\n\t\tsynchronized(sentPackets) {\n\t\t\tint maxRtt = maxRTT();\n\t\t\tlong curTime = System.currentTimeMillis();\n\n\t\t\tIterator<Long> it = sentPackets.keySet().iterator();\n\t\t\twhile(it.hasNext()) {\n\t\t\t\tLong l = it.next();\n\t\t\t\tSentPacket s = sentPackets.get(l);\n\t\t\t\tif(s.getSentTime() < (curTime - NUM_RTTS_TO_LOOSE * maxRtt)) {\n\t\t\t\t\tif(logMINOR) {\n\t\t\t\t\t\tLogger.minor(this, \"Assuming packet \" + l + \" has been lost. \"\n\t\t\t\t\t\t                + \"Delay \" + (curTime - s.getSentTime()) + \"ms, \"\n\t\t\t\t\t\t                + \"threshold \" + (NUM_RTTS_TO_LOOSE * maxRtt) + \"ms\");\n\t\t\t\t\t}\n\t\t\t\t\ts.lost();\n\t\t\t\t\tit.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSentPacket sentPacket = new SentPacket();\n\t\tNPFPacket packet = new NPFPacket();\n\t\tpacket.setSequenceNumber(nextSequenceNumber++);\n\n\t\tint numAcks = 0;\n\t\tsynchronized(acks) {\n\t\t\tlong firstAck = 0;\n\t\t\tIterator<Long> it = acks.iterator();\n\t\t\twhile (it.hasNext() && numAcks < 256 && packet.getLength() < maxPacketSize) {\n\t\t\t\tlong ack = it.next();\n\t\t\t\tif(numAcks == 0) {\n\t\t\t\t\tfirstAck = ack;\n\t\t\t\t} else {\n\t\t\t\t\t// Check that it can be compressed\n\t\t\t\t\tlong compressedAck = ack - firstAck;\n\t\t\t\t\tif((compressedAck < 0) || (compressedAck > 255)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpacket.addAck(ack);\n\t\t\t\t++numAcks;\n\t\t\t\tit.remove();\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < startedByPrio.size(); i++) {\n\t\t\tHashMap<Integer, MessageWrapper> started = startedByPrio.get(i);\n\n\t\t\t//Try to finish messages that have been started\n\t\t\tsynchronized(started) {\n\t\t\t\tIterator<MessageWrapper> it = started.values().iterator();\n\t\t\t\twhile(it.hasNext() && packet.getLength() < maxPacketSize) {\n\t\t\t\t\tMessageWrapper wrapper = it.next();\n\t\t\t\t\tMessageFragment frag = wrapper.getMessageFragment(maxPacketSize - packet.getLength());\n\t\t\t\t\tif(frag == null) continue;\n\t\t\t\t\tpacket.addMessageFragment(frag);\n\t\t\t\t\tsentPacket.addFragment(wrapper, frag.fragmentOffset, frag.fragmentLength);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Add messages from the message queue\n\t\t\twhile ((packet.getLength() + 10) < maxPacketSize) { //Fragment header is max 9 bytes, allow min 1 byte data\n\t\t\t\tMessageItem item = null;\n\t\t\t\tsynchronized(messageQueue) {\n\t\t\t\t\titem = messageQueue.grabQueuedMessageItem(i);\n\t\t\t\t}\n\t\t\t\tif(item == null) break;\n\n\t\t\t\tint messageID = getMessageID();\n\t\t\t\tif(messageID == -1) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"No availiable message ID, requeuing and sending packet\");\n\t\t\t\t\tmessageQueue.pushfrontPrioritizedMessageItem(item);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tMessageWrapper wrapper = new MessageWrapper(item, messageID);\n\t\t\t\tMessageFragment frag = wrapper.getMessageFragment(maxPacketSize - packet.getLength());\n\t\t\t\tif(frag == null) break;\n\t\t\t\tpacket.addMessageFragment(frag);\n\t\t\t\tsentPacket.addFragment(wrapper, frag.fragmentOffset, frag.fragmentLength);\n\n\t\t\t\t//Priority of the one we grabbed might be higher than i\n\t\t\t\tHashMap<Integer, MessageWrapper> queue = startedByPrio.get(item.getPriority());\n\t\t\t\tsynchronized(queue) {\n\t\t\t\t\tqueue.put(messageID, wrapper);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(packet.getLength() == 5) return null;\n\n\t\tif(packet.getFragments().size() != 0) {\n\t\t\tsynchronized(sentPackets) {\n\t\t\t\tsentPackets.put(packet.getSequenceNumber(), sentPacket);\n\t\t\t}\n\t\t}\n\n\t\tsentPacket.sent();\n\t\t\n\t\treturn packet;\n\t}","commit_id":"f873453e37e93fe040f5753a70b0d68ef7282f41","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\tprotected void timedOutWhileWaiting(double load) {\n\t\t// Calculate the reject period based on the proportion of requests being timed out.\n\t\t// If the vast majority are being accepted, then try again after the timeout.\n\t\t// If more are being rejected, it makes sense to wait longer, up to the limit of the maximum recently failed time.\n\t\tint period = (int) Math.min(((fetchTimeout / 5) / (1.0 - load)), FailureTable.RECENTLY_FAILED_TIME);\n\t\tif(source != null)\n\t\t\tLogger.error(this, \"Timed out while waiting for a slot, period = \"+period+\" because average reject proportion for peers is \"+load+\" on \"+this);\n\t\telse\n\t\t\tLogger.warning(this, \"Local request timed out while waiting for a slot, period = \"+period+\" because average reject proportion for peers is \"+load+\" on \"+this);\n    \tsynchronized(this) {\n    \t\trecentlyFailedTimeLeft = period;\n    \t}\n    \tfinish(RECENTLY_FAILED, null, false);\n        node.failureTable.onFinalFailure(key, null, htl, origHTL, -1, -1, source);\n\t}","id":60542,"modified_method":"@Override\n\tprotected void timedOutWhileWaiting(double load) {\n\t\t// Calculate the reject period based on the proportion of requests being timed out.\n\t\t// If the vast majority are being accepted, then try again after the timeout.\n\t\t// If more are being rejected, it makes sense to wait longer, up to the limit of the maximum recently failed time.\n\t\tint period = (int) Math.min(((fetchTimeout / 5) / (1.0 - load)), FailureTable.RECENTLY_FAILED_TIME);\n\t\t// Timeouts while waiting for a slot are relatively normal.\n\t\t// That is, in an ideal world they wouldn't happen.\n\t\t// They happen when the network is very small, or when there is a capacity bottleneck.\n\t\t// They are best considered statistically, see the stats page.\n\t\t// Individual timeouts are therefore not very interesting...\n\t\tif(logMINOR) {\n\t\t\tif(source != null)\n\t\t\t\tLogger.minor(this, \"Timed out while waiting for a slot, period = \"+period+\" because average reject proportion for peers is \"+load+\" on \"+this);\n\t\t\telse if(logMINOR)\n\t\t\t\tLogger.minor(this, \"Local request timed out while waiting for a slot, period = \"+period+\" because average reject proportion for peers is \"+load+\" on \"+this);\n\t\t}\n    \tsynchronized(this) {\n    \t\trecentlyFailedTimeLeft = period;\n    \t}\n    \tfinish(RECENTLY_FAILED, null, false);\n        node.failureTable.onFinalFailure(key, null, htl, origHTL, -1, -1, source);\n\t}","commit_id":"fccfeaf9dd3c7e072f9c6792858ce551e1d42687","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n    public boolean destroy(Network config) throws ConcurrentOperationException, ResourceUnavailableException{\n        List<DomainRouterVO> routers = _routerDao.findByNetwork(config.getId());\n        if (routers.isEmpty()) {\n            return true;\n        }\n        boolean result = true;\n        for (DomainRouterVO router : routers) {\n            result = result && _routerMgr.destroyRouter(router.getId());\n        }\n        return result;\n    }","id":60543,"modified_method":"@Override\n    public boolean destroy(Network config) throws ConcurrentOperationException, ResourceUnavailableException{\n        List<DomainRouterVO> routers = _routerDao.findByNetwork(config.getId());\n        if (routers == null || routers.isEmpty()) {\n            return true;\n        }\n        boolean result = true;\n        for (DomainRouterVO router : routers) {\n            result = result && _routerMgr.destroyRouter(router.getId());\n        }\n        return result;\n    }","commit_id":"872116890b4d1323cc8e7ccdfb9db672c426c5af","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public boolean restart(Network network, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException{\n        DataCenter dc = _configMgr.getZone(network.getDataCenterId());\n        NetworkOffering offering = _configMgr.getNetworkOffering(network.getNetworkOfferingId());\n        DeployDestination dest = new DeployDestination(dc, null, null, null);\n        List<DomainRouterVO> routers = _routerDao.findByNetwork(network.getId());\n        if (routers.isEmpty()) {\n            s_logger.trace(\"Can't find dhcp element in network \" + network.getId());\n            return true;\n        }\n        \n        VirtualRouter result = null;\n        boolean ret = true;\n        for (DomainRouterVO router : routers) {\n            if (canHandle(network.getGuestType(), dest, offering.getTrafficType())) {\n                if (router.getState() == State.Stopped) {\n                    result = _routerMgr.startRouter(router.getId(), false);\n                } else {\n                    result = _routerMgr.rebootRouter(router.getId(), false);\n                }\n                if (result == null) {\n                    s_logger.warn(\"Failed to restart dhcp element \" + router + \" as a part of netowrk \" + network + \" restart\");\n                    ret = false;\n                }\n            } else {\n                s_logger.trace(\"Dhcp element doesn't handle network restart for the network \" + network);\n            }\n        }\n        return ret;\n    }","id":60544,"modified_method":"@Override\n    public boolean restart(Network network, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException{\n        DataCenter dc = _configMgr.getZone(network.getDataCenterId());\n        NetworkOffering offering = _configMgr.getNetworkOffering(network.getNetworkOfferingId());\n        DeployDestination dest = new DeployDestination(dc, null, null, null);\n        List<DomainRouterVO> routers = _routerDao.findByNetwork(network.getId());\n        if (routers == null || routers.isEmpty()) {\n            s_logger.trace(\"Can't find dhcp element in network \" + network.getId());\n            return true;\n        }\n        \n        VirtualRouter result = null;\n        boolean ret = true;\n        for (DomainRouterVO router : routers) {\n            if (canHandle(network.getGuestType(), dest, offering.getTrafficType())) {\n                if (router.getState() == State.Stopped) {\n                    result = _routerMgr.startRouter(router.getId(), false);\n                } else {\n                    result = _routerMgr.rebootRouter(router.getId(), false);\n                }\n                if (result == null) {\n                    s_logger.warn(\"Failed to restart dhcp element \" + router + \" as a part of netowrk \" + network + \" restart\");\n                    ret = false;\n                }\n            } else {\n                s_logger.trace(\"Dhcp element doesn't handle network restart for the network \" + network);\n            }\n        }\n        return ret;\n    }","commit_id":"872116890b4d1323cc8e7ccdfb9db672c426c5af","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public boolean shutdown(Network network, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException {\n        List<DomainRouterVO> routers = _routerDao.findByNetwork(network.getId());\n        if (routers.isEmpty()) {\n            return true;\n        }\n        boolean result = true;\n        for (DomainRouterVO router : routers) {\n            result = result && _routerMgr.stop(router, false, context.getCaller(), context.getAccount()) != null;\n        }\n        return result;\n    }","id":60545,"modified_method":"@Override\n    public boolean shutdown(Network network, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException {\n        List<DomainRouterVO> routers = _routerDao.findByNetwork(network.getId());\n        if (routers == null || routers.isEmpty()) {\n            return true;\n        }\n        boolean result = true;\n        for (DomainRouterVO router : routers) {\n            result = result && _routerMgr.stop(router, false, context.getCaller(), context.getAccount()) != null;\n        }\n        return result;\n    }","commit_id":"872116890b4d1323cc8e7ccdfb9db672c426c5af","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    @DB\n    public List<DomainRouterVO> deployDhcp(Network guestNetwork, DeployDestination dest, Account owner, Map<Param, Object> params) throws InsufficientCapacityException, StorageUnavailableException,\n            ConcurrentOperationException, ResourceUnavailableException {\n        long dcId = dest.getDataCenter().getId();\n\n        // lock guest network\n        Long guestNetworkId = guestNetwork.getId();\n        guestNetwork = _networkDao.acquireInLockTable(guestNetworkId);\n\n        if (guestNetwork == null) {\n            throw new ConcurrentOperationException(\"Unable to acquire network configuration: \" + guestNetworkId);\n        }\n\n        try {\n\n            NetworkOffering offering = _networkOfferingDao.findByIdIncludingRemoved(guestNetwork.getNetworkOfferingId());\n            if (offering.isSystemOnly() || guestNetwork.getIsShared()) {\n                owner = _accountMgr.getAccount(Account.ACCOUNT_ID_SYSTEM);\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Starting a dhcp for network configurations: dhcp=\" + guestNetwork + \" in \" + dest);\n            }\n            assert guestNetwork.getState() == Network.State.Implemented || guestNetwork.getState() == Network.State.Setup || guestNetwork.getState() == Network.State.Implementing : \"Network is not yet fully implemented: \"\n                    + guestNetwork;\n\n            DataCenterDeployment plan = null;\n            DataCenter dc = _dcDao.findById(dcId);\n            DomainRouterVO router = null;\n            Long podId = dest.getPod().getId();\n\n            // In Basic zone and Guest network we have to start domR per pod, not per network\n            if ((dc.getNetworkType() == NetworkType.Basic || guestNetwork.isSecurityGroupEnabled()) && guestNetwork.getTrafficType() == TrafficType.Guest) {\n                router = _routerDao.findByNetworkAndPod(guestNetwork.getId(), podId).get(0);\n                plan = new DataCenterDeployment(dcId, podId, null, null, null);\n            } else {\n                router = _routerDao.findByNetwork(guestNetwork.getId()).get(0);\n                plan = new DataCenterDeployment(dcId);\n            }\n\n            if (router == null) {\n                long id = _routerDao.getNextInSequence(Long.class, \"id\");\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"Creating the router \" + id);\n                }\n\n                List<NetworkOfferingVO> offerings = _networkMgr.getSystemAccountNetworkOfferings(NetworkOfferingVO.SystemControlNetwork);\n                NetworkOfferingVO controlOffering = offerings.get(0);\n                NetworkVO controlConfig = _networkMgr.setupNetwork(_systemAcct, controlOffering, plan, null, null, false, false).get(0);\n\n                List<Pair<NetworkVO, NicProfile>> networks = new ArrayList<Pair<NetworkVO, NicProfile>>(3);\n                NicProfile gatewayNic = new NicProfile();\n                gatewayNic.setDefaultNic(true);\n                networks.add(new Pair<NetworkVO, NicProfile>((NetworkVO) guestNetwork, gatewayNic));\n                networks.add(new Pair<NetworkVO, NicProfile>(controlConfig, null));\n\n                /* Before starting router, already know the hypervisor type */\n                VMTemplateVO template = _templateDao.findRoutingTemplate(dest.getCluster().getHypervisorType());\n\n                router = new DomainRouterVO(id, _offering.getId(), VirtualMachineName.getRouterName(id, _instance), template.getId(), template.getHypervisorType(), template.getGuestOSId(),\n                        owner.getDomainId(), owner.getId(), guestNetwork.getId(), false, 0, false, _offering.getOfferHA());\n                router.setRole(Role.DHCP_USERDATA);\n                router = _itMgr.allocate(router, template, _offering, networks, plan, null, owner);\n            }\n\n            State state = router.getState();\n            if (state != State.Running) {\n                router = this.start(router, _accountService.getSystemUser(), _accountService.getSystemAccount(), params);\n            }\n            // Creating stats entry for router\n            UserStatisticsVO stats = _userStatsDao.findBy(owner.getId(), dcId, router.getNetworkId(), null, router.getId(), router.getType().toString());\n            if (stats == null) {\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"Creating user statistics for the account: \" + owner.getId() + \" Router Id: \" + router.getId());\n                }\n                stats = new UserStatisticsVO(owner.getId(), dcId, null, router.getId(), router.getType().toString(), guestNetwork.getId());\n                _userStatsDao.persist(stats);\n            }\n\n            List<DomainRouterVO> router_list = new ArrayList<DomainRouterVO>(1);\n            router_list.add(router);\n            return router_list;\n        } finally {\n            _networkDao.releaseFromLockTable(guestNetworkId);\n        }\n    }","id":60546,"modified_method":"@Override\n    @DB\n    public List<DomainRouterVO> deployDhcp(Network guestNetwork, DeployDestination dest, Account owner, Map<Param, Object> params) throws InsufficientCapacityException, StorageUnavailableException,\n            ConcurrentOperationException, ResourceUnavailableException {\n        long dcId = dest.getDataCenter().getId();\n\n        // lock guest network\n        Long guestNetworkId = guestNetwork.getId();\n        guestNetwork = _networkDao.acquireInLockTable(guestNetworkId);\n\n        if (guestNetwork == null) {\n            throw new ConcurrentOperationException(\"Unable to acquire network configuration: \" + guestNetworkId);\n        }\n\n        try {\n\n            NetworkOffering offering = _networkOfferingDao.findByIdIncludingRemoved(guestNetwork.getNetworkOfferingId());\n            if (offering.isSystemOnly() || guestNetwork.getIsShared()) {\n                owner = _accountMgr.getAccount(Account.ACCOUNT_ID_SYSTEM);\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Starting a dhcp for network configurations: dhcp=\" + guestNetwork + \" in \" + dest);\n            }\n            assert guestNetwork.getState() == Network.State.Implemented || guestNetwork.getState() == Network.State.Setup || guestNetwork.getState() == Network.State.Implementing : \"Network is not yet fully implemented: \"\n                    + guestNetwork;\n\n            DataCenterDeployment plan = null;\n            DataCenter dc = _dcDao.findById(dcId);\n            DomainRouterVO router = null;\n            List<DomainRouterVO> routers = null;\n            Long podId = dest.getPod().getId();\n\n            // In Basic zone and Guest network we have to start domR per pod, not per network\n            if ((dc.getNetworkType() == NetworkType.Basic || guestNetwork.isSecurityGroupEnabled()) && guestNetwork.getTrafficType() == TrafficType.Guest) {\n                routers = _routerDao.findByNetworkAndPod(guestNetwork.getId(), podId);\n                plan = new DataCenterDeployment(dcId, podId, null, null, null);\n            } else {\n                routers = _routerDao.findByNetwork(guestNetwork.getId());\n                plan = new DataCenterDeployment(dcId);\n            }\n\n            if (routers != null && !routers.isEmpty()) {\n                router = routers.get(0);\n            }\n\n            if (router == null) {\n                long id = _routerDao.getNextInSequence(Long.class, \"id\");\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"Creating the router \" + id);\n                }\n\n                List<NetworkOfferingVO> offerings = _networkMgr.getSystemAccountNetworkOfferings(NetworkOfferingVO.SystemControlNetwork);\n                NetworkOfferingVO controlOffering = offerings.get(0);\n                NetworkVO controlConfig = _networkMgr.setupNetwork(_systemAcct, controlOffering, plan, null, null, false, false).get(0);\n\n                List<Pair<NetworkVO, NicProfile>> networks = new ArrayList<Pair<NetworkVO, NicProfile>>(3);\n                NicProfile gatewayNic = new NicProfile();\n                gatewayNic.setDefaultNic(true);\n                networks.add(new Pair<NetworkVO, NicProfile>((NetworkVO) guestNetwork, gatewayNic));\n                networks.add(new Pair<NetworkVO, NicProfile>(controlConfig, null));\n\n                /* Before starting router, already know the hypervisor type */\n                VMTemplateVO template = _templateDao.findRoutingTemplate(dest.getCluster().getHypervisorType());\n\n                router = new DomainRouterVO(id, _offering.getId(), VirtualMachineName.getRouterName(id, _instance), template.getId(), template.getHypervisorType(), template.getGuestOSId(),\n                        owner.getDomainId(), owner.getId(), guestNetwork.getId(), false, 0, false, _offering.getOfferHA());\n                router.setRole(Role.DHCP_USERDATA);\n                router = _itMgr.allocate(router, template, _offering, networks, plan, null, owner);\n            }\n\n            State state = router.getState();\n            if (state != State.Running) {\n                router = this.start(router, _accountService.getSystemUser(), _accountService.getSystemAccount(), params);\n            }\n            // Creating stats entry for router\n            UserStatisticsVO stats = _userStatsDao.findBy(owner.getId(), dcId, router.getNetworkId(), null, router.getId(), router.getType().toString());\n            if (stats == null) {\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"Creating user statistics for the account: \" + owner.getId() + \" Router Id: \" + router.getId());\n                }\n                stats = new UserStatisticsVO(owner.getId(), dcId, null, router.getId(), router.getType().toString(), guestNetwork.getId());\n                _userStatsDao.persist(stats);\n            }\n\n            List<DomainRouterVO> router_list = new ArrayList<DomainRouterVO>(1);\n            router_list.add(router);\n            return router_list;\n        } finally {\n            _networkDao.releaseFromLockTable(guestNetworkId);\n        }\n    }","commit_id":"872116890b4d1323cc8e7ccdfb9db672c426c5af","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public String[] applyVpnUsers(Network network, List<? extends VpnUser> users) throws ResourceUnavailableException {\n        List<DomainRouterVO> routers = _routerDao.findByNetwork(network.getId());\n        if (routers.size() == 0) {\n            s_logger.warn(\"Failed to add/remove VPN users: no router found for account and zone\");\n            throw new ResourceUnavailableException(\"Unable to assign ip addresses, domR doesn't exist for network \" + network.getId(), DataCenter.class, network.getDataCenterId());\n        }\n        boolean agentResults = true;\n        for (DomainRouterVO router : routers) {\n            if (router.getState() != State.Running) {\n                s_logger.warn(\"Failed to add/remove VPN users: router not in running state\");\n                throw new ResourceUnavailableException(\"Unable to assign ip addresses, domR is not in right state \" + router.getState(), DataCenter.class, network.getDataCenterId());\n            }\n\n            Commands cmds = new Commands(OnError.Continue);\n            List<VpnUser> addUsers = new ArrayList<VpnUser>();\n            List<VpnUser> removeUsers = new ArrayList<VpnUser>();\n            for (VpnUser user : users) {\n                if (user.getState() == VpnUser.State.Add || user.getState() == VpnUser.State.Active) {\n                    addUsers.add(user);\n                } else if (user.getState() == VpnUser.State.Revoke) {\n                    removeUsers.add(user);\n                }\n            }\n\n            VpnUsersCfgCommand cmd = new VpnUsersCfgCommand(addUsers, removeUsers);\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_IP, router.getPrivateIpAddress());\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_NAME, router.getInstanceName());\n            cmds.addCommand(cmd);\n\n            // Currently we receive just one answer from the agent. In the future we have to parse individual answers and set\n            // results accordingly\n            boolean agentResult = sendCommandsToRouter(router, cmds);\n            agentResults = agentResults && agentResult;\n        }\n        \n        String[] result = new String[users.size()];\n        for (int i = 0; i < result.length; i++) {\n            if (agentResults) {\n                result[i] = null;\n            } else {\n                result[i] = String.valueOf(agentResults);\n            }\n        }\n\n        return result;\n    }","id":60547,"modified_method":"@Override\n    public String[] applyVpnUsers(Network network, List<? extends VpnUser> users) throws ResourceUnavailableException {\n        List<DomainRouterVO> routers = _routerDao.findByNetwork(network.getId());\n        if (routers == null || routers.isEmpty()) {\n            s_logger.warn(\"Failed to add/remove VPN users: no router found for account and zone\");\n            throw new ResourceUnavailableException(\"Unable to assign ip addresses, domR doesn't exist for network \" + network.getId(), DataCenter.class, network.getDataCenterId());\n        }\n        boolean agentResults = true;\n        for (DomainRouterVO router : routers) {\n            if (router.getState() != State.Running) {\n                s_logger.warn(\"Failed to add/remove VPN users: router not in running state\");\n                throw new ResourceUnavailableException(\"Unable to assign ip addresses, domR is not in right state \" + router.getState(), DataCenter.class, network.getDataCenterId());\n            }\n\n            Commands cmds = new Commands(OnError.Continue);\n            List<VpnUser> addUsers = new ArrayList<VpnUser>();\n            List<VpnUser> removeUsers = new ArrayList<VpnUser>();\n            for (VpnUser user : users) {\n                if (user.getState() == VpnUser.State.Add || user.getState() == VpnUser.State.Active) {\n                    addUsers.add(user);\n                } else if (user.getState() == VpnUser.State.Revoke) {\n                    removeUsers.add(user);\n                }\n            }\n\n            VpnUsersCfgCommand cmd = new VpnUsersCfgCommand(addUsers, removeUsers);\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_IP, router.getPrivateIpAddress());\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_NAME, router.getInstanceName());\n            cmds.addCommand(cmd);\n\n            // Currently we receive just one answer from the agent. In the future we have to parse individual answers and set\n            // results accordingly\n            boolean agentResult = sendCommandsToRouter(router, cmds);\n            agentResults = agentResults && agentResult;\n        }\n        \n        String[] result = new String[users.size()];\n        for (int i = 0; i < result.length; i++) {\n            if (agentResults) {\n                result[i] = null;\n            } else {\n                result[i] = String.valueOf(agentResults);\n            }\n        }\n\n        return result;\n    }","commit_id":"872116890b4d1323cc8e7ccdfb9db672c426c5af","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public boolean applyFirewallRules(Network network, List<? extends FirewallRule> rules) throws ResourceUnavailableException {\n        List<DomainRouterVO> routers = _routerDao.findByNetwork(network.getId());\n        if (routers.isEmpty()) {\n            s_logger.warn(\"Unable to apply lb rules, virtual router doesn't exist in the network \" + network.getId());\n            throw new ResourceUnavailableException(\"Unable to apply lb rules\", DataCenter.class, network.getDataCenterId());\n        }\n\n        boolean result = true;\n        for (DomainRouterVO router : routers) {\n            if (router.getState() == State.Running) {\n                if (rules != null && !rules.isEmpty()) {\n                    if (rules.get(0).getPurpose() == Purpose.LoadBalancing) {\n                        // for load balancer we have to resend all lb rules for the network\n                        List<LoadBalancerVO> lbs = _loadBalancerDao.listByNetworkId(network.getId());\n                        List<LoadBalancingRule> lbRules = new ArrayList<LoadBalancingRule>();\n                        for (LoadBalancerVO lb : lbs) {\n                            List<LbDestination> dstList = _lbMgr.getExistingDestinations(lb.getId());\n                            LoadBalancingRule loadBalancing = new LoadBalancingRule(lb, dstList);\n                            lbRules.add(loadBalancing);\n                        }\n\n                        result = result && applyLBRules(router, lbRules);\n                    } else if (rules.get(0).getPurpose() == Purpose.PortForwarding) {\n                        result = result && applyPortForwardingRules(router, (List<PortForwardingRule>) rules);\n                    } else if (rules.get(0).getPurpose() == Purpose.StaticNat) {\n                        result = result && applyStaticNatRules(router, (List<StaticNatRule>) rules);\n                    } else {\n                        s_logger.warn(\"Unable to apply rules of purpose: \" + rules.get(0).getPurpose());\n                        result = false;\n                    }\n                }\n            } else if (router.getState() == State.Stopped || router.getState() == State.Stopping) {\n                s_logger.debug(\"Router is in \" + router.getState() + \", so not sending apply firewall rules commands to the backend\");\n            } else {\n                s_logger.warn(\"Unable to apply firewall rules, virtual router is not in the right state \" + router.getState());\n                throw new ResourceUnavailableException(\"Unable to apply firewall rules, virtual router is not in the right state\", VirtualRouter.class, router.getId());\n            }\n        }\n        return result;\n    }","id":60548,"modified_method":"@Override\n    public boolean applyFirewallRules(Network network, List<? extends FirewallRule> rules) throws ResourceUnavailableException {\n        List<DomainRouterVO> routers = _routerDao.findByNetwork(network.getId());\n        if (routers == null || routers.isEmpty()) {\n            s_logger.warn(\"Unable to apply lb rules, virtual router doesn't exist in the network \" + network.getId());\n            throw new ResourceUnavailableException(\"Unable to apply lb rules\", DataCenter.class, network.getDataCenterId());\n        }\n\n        boolean result = true;\n        for (DomainRouterVO router : routers) {\n            if (router.getState() == State.Running) {\n                if (rules != null && !rules.isEmpty()) {\n                    if (rules.get(0).getPurpose() == Purpose.LoadBalancing) {\n                        // for load balancer we have to resend all lb rules for the network\n                        List<LoadBalancerVO> lbs = _loadBalancerDao.listByNetworkId(network.getId());\n                        List<LoadBalancingRule> lbRules = new ArrayList<LoadBalancingRule>();\n                        for (LoadBalancerVO lb : lbs) {\n                            List<LbDestination> dstList = _lbMgr.getExistingDestinations(lb.getId());\n                            LoadBalancingRule loadBalancing = new LoadBalancingRule(lb, dstList);\n                            lbRules.add(loadBalancing);\n                        }\n\n                        result = result && applyLBRules(router, lbRules);\n                    } else if (rules.get(0).getPurpose() == Purpose.PortForwarding) {\n                        result = result && applyPortForwardingRules(router, (List<PortForwardingRule>) rules);\n                    } else if (rules.get(0).getPurpose() == Purpose.StaticNat) {\n                        result = result && applyStaticNatRules(router, (List<StaticNatRule>) rules);\n                    } else {\n                        s_logger.warn(\"Unable to apply rules of purpose: \" + rules.get(0).getPurpose());\n                        result = false;\n                    }\n                }\n            } else if (router.getState() == State.Stopped || router.getState() == State.Stopping) {\n                s_logger.debug(\"Router is in \" + router.getState() + \", so not sending apply firewall rules commands to the backend\");\n            } else {\n                s_logger.warn(\"Unable to apply firewall rules, virtual router is not in the right state \" + router.getState());\n                throw new ResourceUnavailableException(\"Unable to apply firewall rules, virtual router is not in the right state\", VirtualRouter.class, router.getId());\n            }\n        }\n        return result;\n    }","commit_id":"872116890b4d1323cc8e7ccdfb9db672c426c5af","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public boolean associateIP(Network network, List<? extends PublicIpAddress> ipAddress) throws ResourceUnavailableException {\n        List<DomainRouterVO> routers = _routerDao.findByNetwork(network.getId());\n        if (routers.isEmpty()) {\n            s_logger.warn(\"Unable to associate ip addresses, virtual router doesn't exist in the network \" + network.getId());\n            throw new ResourceUnavailableException(\"Unable to assign ip addresses\", DataCenter.class, network.getDataCenterId());\n        }\n\n        boolean result = true;\n        for (DomainRouterVO router : routers) {\n            if (router.getState() == State.Running) {\n                Commands cmds = new Commands(OnError.Continue);\n                // Have to resend all already associated ip addresses\n                createAssociateIPCommands(router, ipAddress, cmds, 0);\n\n                result = result && sendCommandsToRouter(router, cmds);\n            } else if (router.getState() != State.Stopped) {\n                s_logger.warn(\"Unable to associate ip addresses, virtual router is not in the right state \" + router.getState());\n                throw new ResourceUnavailableException(\"Unable to assign ip addresses, domR is not in right state \" + router.getState(), DataCenter.class, network.getDataCenterId());\n            }\n        }\n        return result;\n    }","id":60549,"modified_method":"@Override\n    public boolean associateIP(Network network, List<? extends PublicIpAddress> ipAddress) throws ResourceUnavailableException {\n        List<DomainRouterVO> routers = _routerDao.findByNetwork(network.getId());\n        if (routers == null || routers.isEmpty()) {\n            s_logger.warn(\"Unable to associate ip addresses, virtual router doesn't exist in the network \" + network.getId());\n            throw new ResourceUnavailableException(\"Unable to assign ip addresses\", DataCenter.class, network.getDataCenterId());\n        }\n\n        boolean result = true;\n        for (DomainRouterVO router : routers) {\n            if (router.getState() == State.Running) {\n                Commands cmds = new Commands(OnError.Continue);\n                // Have to resend all already associated ip addresses\n                createAssociateIPCommands(router, ipAddress, cmds, 0);\n\n                result = result && sendCommandsToRouter(router, cmds);\n            } else if (router.getState() != State.Stopped) {\n                s_logger.warn(\"Unable to associate ip addresses, virtual router is not in the right state \" + router.getState());\n                throw new ResourceUnavailableException(\"Unable to assign ip addresses, domR is not in right state \" + router.getState(), DataCenter.class, network.getDataCenterId());\n            }\n        }\n        return result;\n    }","commit_id":"872116890b4d1323cc8e7ccdfb9db672c426c5af","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public boolean savePasswordToRouter(Network network, NicProfile nic, VirtualMachineProfile<UserVm> profile) throws ResourceUnavailableException {\n        List<DomainRouterVO> routers = _routerDao.findByNetwork(network.getId());\n        if (routers.isEmpty()) {\n            s_logger.warn(\"Unable save password, router doesn't exist in network \" + network.getId());\n            throw new CloudRuntimeException(\"Unable to save password to router\");\n        }\n\n        UserVm userVm = profile.getVirtualMachine();\n        String password = (String) profile.getParameter(Param.VmPassword);\n        String encodedPassword = PasswordGenerator.rot13(password);\n\n        boolean result = true;\n        for (DomainRouterVO router : routers) {\n            Commands cmds = new Commands(OnError.Continue);\n            SavePasswordCommand cmd = new SavePasswordCommand(encodedPassword, nic.getIp4Address(), userVm.getHostName());\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_IP, router.getPrivateIpAddress());\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_NAME, router.getInstanceName());\n            cmds.addCommand(\"password\", cmd);\n\n            result = result && sendCommandsToRouter(router, cmds);\n        }\n        return result;\n    }","id":60550,"modified_method":"@Override\n    public boolean savePasswordToRouter(Network network, NicProfile nic, VirtualMachineProfile<UserVm> profile) throws ResourceUnavailableException {\n        List<DomainRouterVO> routers = _routerDao.findByNetwork(network.getId());\n        if (routers == null || routers.isEmpty()) {\n            s_logger.warn(\"Unable save password, router doesn't exist in network \" + network.getId());\n            throw new CloudRuntimeException(\"Unable to save password to router\");\n        }\n\n        UserVm userVm = profile.getVirtualMachine();\n        String password = (String) profile.getParameter(Param.VmPassword);\n        String encodedPassword = PasswordGenerator.rot13(password);\n\n        boolean result = true;\n        for (DomainRouterVO router : routers) {\n            Commands cmds = new Commands(OnError.Continue);\n            SavePasswordCommand cmd = new SavePasswordCommand(encodedPassword, nic.getIp4Address(), userVm.getHostName());\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_IP, router.getPrivateIpAddress());\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_NAME, router.getInstanceName());\n            cmds.addCommand(\"password\", cmd);\n\n            result = result && sendCommandsToRouter(router, cmds);\n        }\n        return result;\n    }","commit_id":"872116890b4d1323cc8e7ccdfb9db672c426c5af","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public boolean restart(Network network, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException{\n        DataCenter dc = _configMgr.getZone(network.getDataCenterId());\n        DeployDestination dest = new DeployDestination(dc, null, null, null);\n        List<DomainRouterVO> routers = _routerDao.findByNetwork(network.getId());\n        if (routers.isEmpty()) {\n            s_logger.trace(\"Can't find virtual router element in network \" + network.getId());\n            return true;\n        }\n        \n        VirtualRouter result = null;\n        boolean ret = true;\n        for (DomainRouterVO router : routers) {\n            if (canHandle(network.getGuestType(), dest.getDataCenter())) {\n                if (router.getState() == State.Stopped) {\n                    result = _routerMgr.startRouter(router.getId(), false);\n                } else {\n                    result = _routerMgr.rebootRouter(router.getId(), false);\n                }\n                if (result == null) {\n                    s_logger.warn(\"Failed to restart virtual router element \" + router + \" as a part of netowrk \" + network + \" restart\");\n                    ret = false;\n                }\n            } else {\n                s_logger.trace(\"Virtual router element doesn't handle network restart for the network \" + network);\n            }\n        }\n        return ret;\n    }","id":60551,"modified_method":"@Override\n    public boolean restart(Network network, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException{\n        DataCenter dc = _configMgr.getZone(network.getDataCenterId());\n        DeployDestination dest = new DeployDestination(dc, null, null, null);\n        List<DomainRouterVO> routers = _routerDao.findByNetwork(network.getId());\n        if (routers == null || routers.isEmpty()) {\n            s_logger.trace(\"Can't find virtual router element in network \" + network.getId());\n            return true;\n        }\n        \n        VirtualRouter result = null;\n        boolean ret = true;\n        for (DomainRouterVO router : routers) {\n            if (canHandle(network.getGuestType(), dest.getDataCenter())) {\n                if (router.getState() == State.Stopped) {\n                    result = _routerMgr.startRouter(router.getId(), false);\n                } else {\n                    result = _routerMgr.rebootRouter(router.getId(), false);\n                }\n                if (result == null) {\n                    s_logger.warn(\"Failed to restart virtual router element \" + router + \" as a part of netowrk \" + network + \" restart\");\n                    ret = false;\n                }\n            } else {\n                s_logger.trace(\"Virtual router element doesn't handle network restart for the network \" + network);\n            }\n        }\n        return ret;\n    }","commit_id":"872116890b4d1323cc8e7ccdfb9db672c426c5af","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public boolean applyRules(Network config, List<? extends FirewallRule> rules) throws ResourceUnavailableException {\n    \n        DataCenter dc = _configMgr.getZone(config.getDataCenterId());\n        if (canHandle(config.getGuestType(),dc)) {\n            long networkId = config.getId();\n            List<DomainRouterVO> routers = _routerDao.findByNetwork(networkId);\n            if (routers.isEmpty()) {\n                s_logger.debug(\"Virtual router elemnt doesn't need to apply firewall rules on the backend; virtual router doesn't exist in the network \" + config.getId());\n                return true;\n            }\n            \n            return _routerMgr.applyFirewallRules(config, rules);\n        } else {\n            return true;\n        }\n    }","id":60552,"modified_method":"@Override\n    public boolean applyRules(Network config, List<? extends FirewallRule> rules) throws ResourceUnavailableException {\n    \n        DataCenter dc = _configMgr.getZone(config.getDataCenterId());\n        if (canHandle(config.getGuestType(),dc)) {\n            long networkId = config.getId();\n            List<DomainRouterVO> routers = _routerDao.findByNetwork(networkId);\n            if (routers == null || routers.isEmpty()) {\n                s_logger.debug(\"Virtual router elemnt doesn't need to apply firewall rules on the backend; virtual router doesn't exist in the network \" + config.getId());\n                return true;\n            }\n            \n            return _routerMgr.applyFirewallRules(config, rules);\n        } else {\n            return true;\n        }\n    }","commit_id":"872116890b4d1323cc8e7ccdfb9db672c426c5af","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public boolean applyIps(Network network, List<? extends PublicIpAddress> ipAddress) throws ResourceUnavailableException {\n        DataCenter dc = _configMgr.getZone(network.getDataCenterId());\n        if (canHandle(network.getGuestType(),dc)) {\n            \n            List<DomainRouterVO> routers = _routerDao.findByNetwork(network.getId());\n            if (routers.isEmpty()) {\n                s_logger.debug(\"Virtual router elemnt doesn't need to associate ip addresses on the backend; virtual router doesn't exist in the network \" + network.getId());\n                return true;\n            }\n            \n            return _routerMgr.associateIP(network, ipAddress);\n        } else {\n            return false;\n        }\n    }","id":60553,"modified_method":"@Override\n    public boolean applyIps(Network network, List<? extends PublicIpAddress> ipAddress) throws ResourceUnavailableException {\n        DataCenter dc = _configMgr.getZone(network.getDataCenterId());\n        if (canHandle(network.getGuestType(),dc)) {\n            \n            List<DomainRouterVO> routers = _routerDao.findByNetwork(network.getId());\n            if (routers == null || routers.isEmpty()) {\n                s_logger.debug(\"Virtual router elemnt doesn't need to associate ip addresses on the backend; virtual router doesn't exist in the network \" + network.getId());\n                return true;\n            }\n            \n            return _routerMgr.associateIP(network, ipAddress);\n        } else {\n            return false;\n        }\n    }","commit_id":"872116890b4d1323cc8e7ccdfb9db672c426c5af","url":"https://github.com/apache/cloudstack"},{"original_method":"protected OWorkLoadResult executeOperation(final ODatabaseIdentifier dbIdentifier, final int operationTotal,\n      final int concurrencyLevel, final OCallable<Void, OWorkLoadContext> callback) {\n    final OWorkLoadResult result = new OWorkLoadResult();\n\n    if (operationTotal == 0)\n      return result;\n\n    final int totalPerThread = operationTotal / concurrencyLevel;\n    final int totalPerLastThread = totalPerThread + operationTotal % concurrencyLevel;\n\n    final ArrayList<Long> operationTiming = new ArrayList<Long>(operationTotal);\n    for (int i = 0; i < operationTotal; ++i)\n      operationTiming.add(null);\n\n    final Thread[] thread = new Thread[concurrencyLevel];\n    for (int t = 0; t < concurrencyLevel; ++t) {\n      final OWorkLoadContext context = new OWorkLoadContext();\n\n      context.threadId = t;\n\n      thread[t] = new Thread(new Runnable() {\n        @Override\n        public void run() {\n          final int threadTotal = context.threadId < concurrencyLevel - 1 ? totalPerThread : totalPerLastThread;\n\n          context.db = getDocumentDatabase(dbIdentifier);\n          try {\n            final int startIdx = totalPerThread * context.threadId;\n\n            for (int i = 0; i < threadTotal; ++i) {\n              context.currentIdx = startIdx + i;\n\n              final long startOp = System.nanoTime();\n              try {\n                callback.call(context);\n              } catch (Exception e) {\n                errors.add(e.toString());\n                if (errors.size() > MAX_ERRORS) {\n                  e.printStackTrace();\n                  break;\n                }\n              } finally {\n                operationTiming.set(context.currentIdx, System.nanoTime() - startOp);\n              }\n            }\n\n          } finally {\n            context.db.close();\n          }\n        }\n      });\n    }\n\n    final long startTime = System.currentTimeMillis();\n\n    // START ALL THE THREADS\n    for (int t = 0; t < concurrencyLevel; ++t) {\n      thread[t].start();\n    }\n\n    // WAIT FOR ALL THE THREADS\n    for (int t = 0; t < concurrencyLevel; ++t) {\n      try {\n        thread[t].join();\n      } catch (InterruptedException e) {\n        e.printStackTrace();\n      }\n    }\n\n    // STOP THE COUNTER\n    result.totalTime = System.currentTimeMillis() - startTime;\n\n    Collections.sort(operationTiming);\n\n    // COMPUTE THE PERCENTILE\n    result.avgNs = (int) (result.totalTime * 1000000 / operationTiming.size());\n    result.percentileAvg = getPercentile(operationTiming, result.avgNs);\n    result.percentile99Ns = operationTiming.get((int) (operationTiming.size() * 99f / 100f));\n    result.percentile99_9Ns = operationTiming.get((int) (operationTiming.size() * 99.9f / 100f));\n\n    return result;\n  }","id":60554,"modified_method":"protected OWorkLoadResult executeOperation(final ODatabaseIdentifier dbIdentifier, final int operationTotal,\n      final int concurrencyLevel, final OCallable<Void, OBaseWorkLoadContext> callback) {\n    final OWorkLoadResult result = new OWorkLoadResult();\n\n    if (operationTotal == 0)\n      return result;\n\n    final int totalPerThread = operationTotal / concurrencyLevel;\n    final int totalPerLastThread = totalPerThread + operationTotal % concurrencyLevel;\n\n    final ArrayList<Long> operationTiming = new ArrayList<Long>(operationTotal);\n    for (int i = 0; i < operationTotal; ++i)\n      operationTiming.add(null);\n\n    final Thread[] thread = new Thread[concurrencyLevel];\n    for (int t = 0; t < concurrencyLevel; ++t) {\n      final int currentThread = t;\n\n      thread[t] = new Thread(new Runnable() {\n        @Override\n        public void run() {\n          final OBaseWorkLoadContext context = getContext();\n\n          context.threadId = currentThread;\n          context.totalPerThread = context.threadId < concurrencyLevel - 1 ? totalPerThread : totalPerLastThread;\n\n          context.init(dbIdentifier);\n          try {\n            final int startIdx = totalPerThread * context.threadId;\n\n            for (int i = 0; i < context.totalPerThread; ++i) {\n              context.currentIdx = startIdx + i;\n\n              final long startOp = System.nanoTime();\n              try {\n                callback.call(context);\n              } catch (Exception e) {\n                errors.add(e.toString());\n                if (errors.size() > MAX_ERRORS) {\n                  e.printStackTrace();\n                  break;\n                }\n              } finally {\n                operationTiming.set(context.currentIdx, System.nanoTime() - startOp);\n              }\n            }\n\n          } finally {\n            context.close();\n          }\n        }\n      });\n    }\n\n    final long startTime = System.currentTimeMillis();\n\n    // START ALL THE THREADS\n    for (int t = 0; t < concurrencyLevel; ++t) {\n      thread[t].start();\n    }\n\n    // WAIT FOR ALL THE THREADS\n    for (int t = 0; t < concurrencyLevel; ++t) {\n      try {\n        thread[t].join();\n      } catch (InterruptedException e) {\n        e.printStackTrace();\n      }\n    }\n\n    // STOP THE COUNTER\n    result.totalTime = System.currentTimeMillis() - startTime;\n\n    Collections.sort(operationTiming);\n\n    // COMPUTE THE PERCENTILE\n    result.avgNs = (int) (result.totalTime * 1000000 / operationTiming.size());\n    result.percentileAvg = getPercentile(operationTiming, result.avgNs);\n    result.percentile99Ns = operationTiming.get((int) (operationTiming.size() * 99f / 100f));\n    result.percentile99_9Ns = operationTiming.get((int) (operationTiming.size() * 99.9f / 100f));\n\n    return result;\n  }","commit_id":"f5199f0fca1148140fec1e89fff660de394344eb","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public void parseParameters(final String args) {\n    final String ops = args.toUpperCase();\n    char state = ' ';\n    final StringBuilder number = new StringBuilder();\n\n    for (int pos = 0; pos < ops.length(); ++pos) {\n      final char c = ops.charAt(pos);\n\n      if (c == 'C' || c == 'R' || c == 'U' || c == 'D') {\n        state = assignState(state, number, c);\n      } else if (c >= '0' && c <= '9')\n        number.append(c);\n      else\n        throw new IllegalArgumentException(\"Character '\" + c + \"' is not valid on CRUD workload. \" + INVALID_FORM_MESSAGE);\n    }\n    assignState(state, number, ' ');\n\n    total = creates + reads + updates + deletes;\n\n    if (reads > creates || updates > creates || deletes > creates)\n      throw new IllegalArgumentException(INVALID_NUMBERS);\n\n    if (total == 0)\n      throw new IllegalArgumentException(INVALID_FORM_MESSAGE);\n  }","id":60555,"modified_method":"@Override\n  public void parseParameters(final String args) {\n    final String ops = args.toUpperCase();\n    char state = ' ';\n    final StringBuilder number = new StringBuilder();\n\n    for (int pos = 0; pos < ops.length(); ++pos) {\n      final char c = ops.charAt(pos);\n\n      if (c == 'C' || c == 'R' || c == 'U' || c == 'D') {\n        state = assignState(state, number, c);\n      } else if (c >= '0' && c <= '9')\n        number.append(c);\n      else\n        throw new IllegalArgumentException(\"Character '\" + c + \"' is not valid on CRUD workload. \" + INVALID_FORM_MESSAGE);\n    }\n    assignState(state, number, ' ');\n\n    total = createsResult.total + readsResult.total + updatesResult.total + deletesResult.total;\n\n    if (readsResult.total > createsResult.total || updatesResult.total > createsResult.total\n        || deletesResult.total > createsResult.total)\n      throw new IllegalArgumentException(INVALID_NUMBERS);\n\n    if (total == 0)\n      throw new IllegalArgumentException(INVALID_FORM_MESSAGE);\n  }","commit_id":"f5199f0fca1148140fec1e89fff660de394344eb","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public int getDeletes() {\n    return deletes;\n  }","id":60556,"modified_method":"public int getDeletes() {\n    return deletesResult.total;\n  }","commit_id":"f5199f0fca1148140fec1e89fff660de394344eb","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public String getPartialResult() {\n    final long current = currentCreates.get() + currentReads.get() + currentUpdates.get() + currentDeletes.get();\n    return String.format(\"%d%% [Creates: %d%% - Reads: %d%% - Updates: %d%% - Deletes: %d%%]\", ((int) (100 * current / total)),\n        100 * currentCreates.get() / creates, 100 * currentReads.get() / reads, 100 * currentUpdates.get() / updates,\n        100 * currentDeletes.get() / deletes);\n  }","id":60557,"modified_method":"@Override\n  public String getPartialResult() {\n    final long current = createsResult.current.get() + readsResult.current.get() + updatesResult.current.get()\n        + deletesResult.current.get();\n    return String.format(\"%d%% [Creates: %d%% - Reads: %d%% - Updates: %d%% - Deletes: %d%%]\", ((int) (100 * current / total)),\n        100 * createsResult.current.get() / createsResult.total, 100 * readsResult.current.get() / readsResult.total,\n        100 * updatesResult.current.get() / updatesResult.total, 100 * deletesResult.current.get() / deletesResult.total);\n  }","commit_id":"f5199f0fca1148140fec1e89fff660de394344eb","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public int getUpdates() {\n    return updates;\n  }","id":60558,"modified_method":"public int getUpdates() {\n    return updatesResult.total;\n  }","commit_id":"f5199f0fca1148140fec1e89fff660de394344eb","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public String getFinalResult() {\n    final StringBuilder buffer = new StringBuilder(getErrors());\n\n    buffer.append(String.format(\n        \"\\nCreated %d records in %.3f secs - Throughput: %.3f/sec - Avg: %.3fms/op (%dth percentile) - 99th Perc: %.3fms - 99.9th Perc: %.3fms\",\n        creates, (createsResult.totalTime / 1000f), creates * 1000 / (float) createsResult.totalTime,\n        createsResult.avgNs / 1000000f, createsResult.percentileAvg, createsResult.percentile99Ns / 1000000f,\n        createsResult.percentile99_9Ns / 1000000f));\n\n    buffer.append(String.format(\n        \"\\nRead    %d records in %.3f secs - Throughput: %.3f/sec - Avg: %.3fms/op (%dth percentile) - 99th perc: %.3fms - 99.9th Perc: %.3fms\",\n        reads, (readsResult.totalTime / 1000f), reads * 1000 / (float) readsResult.totalTime, readsResult.avgNs / 1000000f,\n        readsResult.percentileAvg, readsResult.percentile99Ns / 1000000f, readsResult.percentile99_9Ns / 1000000f));\n\n    buffer.append(String.format(\n        \"\\nUpdated %d records in %.3f secs - Throughput: %.3f/sec - Avg: %.3fms/op (%dth percentile) - 99th perc: %.3fms - 99.9th Perc: %.3fms\",\n        updates, (updatesResult.totalTime / 1000f), updates * 1000 / (float) updatesResult.totalTime,\n        updatesResult.avgNs / 1000000f, updatesResult.percentileAvg, updatesResult.percentile99Ns / 1000000f,\n        updatesResult.percentile99_9Ns / 1000000f));\n\n    buffer.append(String.format(\n        \"\\nDeleted %d records in %.3f secs - Throughput: %.3f/sec - Avg: %.3fms/op (%dth percentile) - 99th perc: %.3fms - 99.9th Perc: %.3fms\",\n        deletes, (deletesResult.totalTime / 1000f), deletes * 1000 / (float) deletesResult.totalTime,\n        deletesResult.avgNs / 1000000f, deletesResult.percentileAvg, deletesResult.percentile99Ns / 1000000f,\n        deletesResult.percentile99_9Ns / 1000000f));\n\n    return buffer.toString();\n  }","id":60559,"modified_method":"@Override\n  public String getFinalResult() {\n    final StringBuilder buffer = new StringBuilder(getErrors());\n\n    buffer.append(String.format(\n        \"\\nCreated %d records in %.3f secs - Throughput: %.3f/sec - Avg: %.3fms/op (%dth percentile) - 99th Perc: %.3fms - 99.9th Perc: %.3fms\",\n        createsResult.total, (createsResult.totalTime / 1000f), createsResult.total * 1000 / (float) createsResult.totalTime,\n        createsResult.avgNs / 1000000f, createsResult.percentileAvg, createsResult.percentile99Ns / 1000000f,\n        createsResult.percentile99_9Ns / 1000000f));\n\n    buffer.append(String.format(\n        \"\\nRead    %d records in %.3f secs - Throughput: %.3f/sec - Avg: %.3fms/op (%dth percentile) - 99th perc: %.3fms - 99.9th Perc: %.3fms\",\n        readsResult.total, (readsResult.totalTime / 1000f), readsResult.total * 1000 / (float) readsResult.totalTime,\n        readsResult.avgNs / 1000000f, readsResult.percentileAvg, readsResult.percentile99Ns / 1000000f,\n        readsResult.percentile99_9Ns / 1000000f));\n\n    buffer.append(String.format(\n        \"\\nUpdated %d records in %.3f secs - Throughput: %.3f/sec - Avg: %.3fms/op (%dth percentile) - 99th perc: %.3fms - 99.9th Perc: %.3fms\",\n        updatesResult.total, (updatesResult.totalTime / 1000f), updatesResult.total * 1000 / (float) updatesResult.totalTime,\n        updatesResult.avgNs / 1000000f, updatesResult.percentileAvg, updatesResult.percentile99Ns / 1000000f,\n        updatesResult.percentile99_9Ns / 1000000f));\n\n    buffer.append(String.format(\n        \"\\nDeleted %d records in %.3f secs - Throughput: %.3f/sec - Avg: %.3fms/op (%dth percentile) - 99th perc: %.3fms - 99.9th Perc: %.3fms\",\n        deletesResult.total, (deletesResult.totalTime / 1000f), deletesResult.total * 1000 / (float) deletesResult.totalTime,\n        deletesResult.avgNs / 1000000f, deletesResult.percentileAvg, deletesResult.percentile99Ns / 1000000f,\n        deletesResult.percentile99_9Ns / 1000000f));\n\n    return buffer.toString();\n  }","commit_id":"f5199f0fca1148140fec1e89fff660de394344eb","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public void execute(final int concurrencyLevel, final ODatabaseIdentifier databaseIdentifier) {\n    createSchema(databaseIdentifier);\n\n    final ArrayList<ORID> records = new ArrayList<ORID>(creates);\n    for (int i = 0; i < creates; ++i)\n      records.add(null);\n\n    createsResult = executeOperation(databaseIdentifier, creates, concurrencyLevel, new OCallable<Void, OWorkLoadContext>() {\n      @Override\n      public Void call(final OWorkLoadContext context) {\n        final ODocument doc = createOperation(context.currentIdx);\n        synchronized (records) {\n          if (records.set(context.currentIdx, doc.getIdentity()) != null)\n            throw new RuntimeException(\n                \"Error on creating record with id \" + context.currentIdx + \" because has been already created\");\n        }\n        currentCreates.incrementAndGet();\n        return null;\n      }\n    });\n\n    if (records.size() != creates)\n      throw new RuntimeException(\"Error on creating records: found \" + records.size() + \" but expected \" + creates);\n\n    readsResult = executeOperation(databaseIdentifier, reads, concurrencyLevel, new OCallable<Void, OWorkLoadContext>() {\n      @Override\n      public Void call(final OWorkLoadContext context) {\n        readOperation(context.db, context.currentIdx);\n        currentReads.incrementAndGet();\n        return null;\n      }\n    });\n\n    updatesResult = executeOperation(databaseIdentifier, updates, concurrencyLevel, new OCallable<Void, OWorkLoadContext>() {\n      @Override\n      public Void call(final OWorkLoadContext context) {\n        updateOperation(context.db, records.get(context.currentIdx));\n        currentUpdates.incrementAndGet();\n        return null;\n      }\n    });\n\n    deletesResult = executeOperation(databaseIdentifier, deletes, concurrencyLevel, new OCallable<Void, OWorkLoadContext>() {\n      @Override\n      public Void call(final OWorkLoadContext context) {\n        deleteOperation(context.db, records.get(context.currentIdx));\n        records.set(context.currentIdx, null);\n        currentDeletes.incrementAndGet();\n        return null;\n      }\n    });\n  }","id":60560,"modified_method":"@Override\n  public void execute(final int concurrencyLevel, final ODatabaseIdentifier databaseIdentifier) {\n    createSchema(databaseIdentifier);\n\n    final ArrayList<ORID> records = new ArrayList<ORID>(createsResult.total);\n    for (int i = 0; i < createsResult.total; ++i)\n      records.add(null);\n\n    executeOperation(databaseIdentifier, createsResult.total, concurrencyLevel, new OCallable<Void, OBaseWorkLoadContext>() {\n      @Override\n      public Void call(final OBaseWorkLoadContext context) {\n        final ODocument doc = createOperation(context.currentIdx);\n        synchronized (records) {\n          if (records.set(context.currentIdx, doc.getIdentity()) != null)\n            throw new RuntimeException(\n                \"Error on creating record with id \" + context.currentIdx + \" because has been already created\");\n        }\n        createsResult.current.incrementAndGet();\n        return null;\n      }\n    });\n\n    if (records.size() != createsResult.total)\n      throw new RuntimeException(\"Error on creating records: found \" + records.size() + \" but expected \" + createsResult.total);\n\n    executeOperation(databaseIdentifier, readsResult.total, concurrencyLevel, new OCallable<Void, OBaseWorkLoadContext>() {\n      @Override\n      public Void call(final OBaseWorkLoadContext context) {\n        readOperation(((OWorkLoadContext) context).getDb(), context.currentIdx);\n        readsResult.current.incrementAndGet();\n        return null;\n      }\n    });\n\n    updatesResult = executeOperation(databaseIdentifier, updatesResult.total, concurrencyLevel,\n        new OCallable<Void, OBaseWorkLoadContext>() {\n          @Override\n          public Void call(final OBaseWorkLoadContext context) {\n            updateOperation(((OWorkLoadContext) context).getDb(), records.get(context.currentIdx));\n            updatesResult.current.incrementAndGet();\n            return null;\n          }\n        });\n\n    deletesResult = executeOperation(databaseIdentifier, deletesResult.total, concurrencyLevel,\n        new OCallable<Void, OBaseWorkLoadContext>() {\n          @Override\n          public Void call(final OBaseWorkLoadContext context) {\n            deleteOperation(((OWorkLoadContext) context).getDb(), records.get(context.currentIdx));\n            records.set(context.currentIdx, null);\n            deletesResult.current.incrementAndGet();\n            return null;\n          }\n        });\n  }","commit_id":"f5199f0fca1148140fec1e89fff660de394344eb","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private char assignState(final char state, final StringBuilder number, final char c) {\n    if (number.length() == 0)\n      number.append(\"0\");\n\n    if (state == 'C')\n      creates = Integer.parseInt(number.toString());\n    else if (state == 'R')\n      reads = Integer.parseInt(number.toString());\n    else if (state == 'U')\n      updates = Integer.parseInt(number.toString());\n    else if (state == 'D')\n      deletes = Integer.parseInt(number.toString());\n\n    number.setLength(0);\n    return c;\n  }","id":60561,"modified_method":"private char assignState(final char state, final StringBuilder number, final char c) {\n    if (number.length() == 0)\n      number.append(\"0\");\n\n    if (state == 'C')\n      createsResult.total = Integer.parseInt(number.toString());\n    else if (state == 'R')\n      readsResult.total = Integer.parseInt(number.toString());\n    else if (state == 'U')\n      updatesResult.total = Integer.parseInt(number.toString());\n    else if (state == 'D')\n      deletesResult.total = Integer.parseInt(number.toString());\n\n    number.setLength(0);\n    return c;\n  }","commit_id":"f5199f0fca1148140fec1e89fff660de394344eb","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public int getCreates() {\n    return creates;\n  }","id":60562,"modified_method":"public int getCreates() {\n    return createsResult.total;\n  }","commit_id":"f5199f0fca1148140fec1e89fff660de394344eb","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public int getReads() {\n    return reads;\n  }","id":60563,"modified_method":"public int getReads() {\n    return readsResult.total;\n  }","commit_id":"f5199f0fca1148140fec1e89fff660de394344eb","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n   * Waits until the minimum responses are collected or timeout occurs. If \"waitForLocalNode\" wait also for local node.\n   *\n   * @return True if the received responses are major or equals then the expected synchronous responses, otherwise false\n   * @throws InterruptedException\n   */\n  public boolean waitForSynchronousResponses() throws InterruptedException {\n    final long beginTime = System.currentTimeMillis();\n\n    synchronousResponsesLock.lock();\n    try {\n\n      long currentTimeout = synchTimeout;\n      while (currentTimeout > 0 && receivedResponses < totalExpectedResponses && !isMinimumQuorumReached()) {\n\n        // WAIT FOR THE RESPONSES\n        try {\n          synchronousResponsesArrived.await(currentTimeout, TimeUnit.MILLISECONDS);\n        } catch (InterruptedException e) {\n          // IGNORE IT\n        }\n\n        if (isMinimumQuorumReached() || receivedResponses >= totalExpectedResponses)\n          // OK\n          return true;\n\n        if (Thread.currentThread().isInterrupted()) {\n          // INTERRUPTED\n          ODistributedServerLog.warn(this, dManager.getLocalNodeName(), null, DIRECTION.NONE,\n              \"Thread has been interrupted wait for request (%s)\", request);\n          Thread.currentThread().interrupt();\n          break;\n        }\n\n        final long now = System.currentTimeMillis();\n        final long elapsed = now - beginTime;\n        currentTimeout = synchTimeout - elapsed;\n\n        // CHECK IF ANY NODE ARE UNREACHABLE IN THE MEANWHILE\n        int synchronizingNodes = 0;\n        int missingActiveNodes = 0;\n\n        synchronousResponsesLock.lock();\n        try {\n          for (Iterator<Map.Entry<String, Object>> iter = responses.entrySet().iterator(); iter.hasNext();) {\n            final Map.Entry<String, Object> curr = iter.next();\n\n            if (curr.getValue() == NO_RESPONSE) {\n              // ANALYZE THE NODE WITHOUT A RESPONSE\n              final ODistributedServerManager.DB_STATUS dbStatus = dManager.getDatabaseStatus(curr.getKey(), getDatabaseName());\n              switch (dbStatus) {\n              case SYNCHRONIZING:\n                synchronizingNodes++;\n                missingActiveNodes++;\n                break;\n              case ONLINE:\n                missingActiveNodes++;\n                break;\n              }\n            }\n          }\n\n        } finally {\n          synchronousResponsesLock.unlock();\n        }\n\n        if (missingActiveNodes == 0) {\n          // NO MORE ACTIVE NODES TO WAIT\n          ODistributedServerLog.debug(this, dManager.getLocalNodeName(), null, DIRECTION.NONE,\n              \"no more active nodes to wait for request (%s): anticipate timeout (saved %d ms)\", request, currentTimeout);\n          break;\n        }\n\n        final long lastClusterChange = dManager.getLastClusterChangeOn();\n        if (lastClusterChange > 0 && now - lastClusterChange < (synchTimeout + ADDITIONAL_TIMEOUT_CLUSTER_SHAPE)) {\n          // CHANGED CLUSTER SHAPE DURING WAIT: ENLARGE TIMEOUT\n          currentTimeout = synchTimeout;\n          ODistributedServerLog.debug(this, dManager.getLocalNodeName(), null, DIRECTION.NONE,\n              \"cluster shape changed during request (%s): enlarge timeout +%dms, wait again for %dms\", request, synchTimeout,\n              currentTimeout);\n          continue;\n        } else if (synchronizingNodes > 0) {\n          // SOME NODE IS SYNCHRONIZING: WAIT FOR THEM\n          currentTimeout = synchTimeout;\n          ODistributedServerLog.debug(this, dManager.getLocalNodeName(), null, DIRECTION.NONE,\n              \"%d nodes are in synchronization mode during request (%s): enlarge timeout +%dms, wait again for %dms\",\n              synchronizingNodes, request, synchTimeout, currentTimeout);\n        }\n      }\n\n      return isMinimumQuorumReached() || receivedResponses >= totalExpectedResponses;\n\n    } finally {\n      synchronousResponsesLock.unlock();\n\n      Orient.instance().getProfiler().stopChrono(\"distributed.synchResponses\",\n          \"Time to collect all the synchronous responses from distributed nodes\", beginTime);\n    }\n  }","id":60564,"modified_method":"/**\n   * Waits until the minimum responses are collected or timeout occurs. If \"waitForLocalNode\" wait also for local node.\n   *\n   * @return True if the received responses are major or equals then the expected synchronous responses, otherwise false\n   * @throws InterruptedException\n   */\n  public boolean waitForSynchronousResponses() throws InterruptedException {\n    final long beginTime = System.currentTimeMillis();\n\n    synchronousResponsesLock.lock();\n    try {\n\n      long currentTimeout = synchTimeout;\n      while (currentTimeout > 0 && receivedResponses < totalExpectedResponses && !isMinimumQuorumReached()) {\n\n        // WAIT FOR THE RESPONSES\n        synchronousResponsesArrived.await(currentTimeout, TimeUnit.MILLISECONDS);\n\n        if (isMinimumQuorumReached() || receivedResponses >= totalExpectedResponses)\n          // OK\n          return true;\n\n        if (Thread.currentThread().isInterrupted()) {\n          // INTERRUPTED\n          ODistributedServerLog.warn(this, dManager.getLocalNodeName(), null, DIRECTION.NONE,\n              \"Thread has been interrupted wait for request (%s)\", request);\n          Thread.currentThread().interrupt();\n          break;\n        }\n\n        final long now = System.currentTimeMillis();\n        final long elapsed = now - beginTime;\n        currentTimeout = synchTimeout - elapsed;\n\n        // CHECK IF ANY NODE ARE UNREACHABLE IN THE MEANWHILE\n        int synchronizingNodes = 0;\n        int missingActiveNodes = 0;\n\n        synchronousResponsesLock.lock();\n        try {\n          for (Iterator<Map.Entry<String, Object>> iter = responses.entrySet().iterator(); iter.hasNext();) {\n            final Map.Entry<String, Object> curr = iter.next();\n\n            if (curr.getValue() == NO_RESPONSE) {\n              // ANALYZE THE NODE WITHOUT A RESPONSE\n              final ODistributedServerManager.DB_STATUS dbStatus = dManager.getDatabaseStatus(curr.getKey(), getDatabaseName());\n              switch (dbStatus) {\n              case SYNCHRONIZING:\n                synchronizingNodes++;\n                missingActiveNodes++;\n                break;\n              case ONLINE:\n                missingActiveNodes++;\n                break;\n              }\n            }\n          }\n\n        } finally {\n          synchronousResponsesLock.unlock();\n        }\n\n        if (missingActiveNodes == 0) {\n          // NO MORE ACTIVE NODES TO WAIT\n          ODistributedServerLog.debug(this, dManager.getLocalNodeName(), null, DIRECTION.NONE,\n              \"no more active nodes to wait for request (%s): anticipate timeout (saved %d ms)\", request, currentTimeout);\n          break;\n        }\n\n        final long lastClusterChange = dManager.getLastClusterChangeOn();\n        if (lastClusterChange > 0 && now - lastClusterChange < (synchTimeout + ADDITIONAL_TIMEOUT_CLUSTER_SHAPE)) {\n          // CHANGED CLUSTER SHAPE DURING WAIT: ENLARGE TIMEOUT\n          currentTimeout = synchTimeout;\n          ODistributedServerLog.debug(this, dManager.getLocalNodeName(), null, DIRECTION.NONE,\n              \"cluster shape changed during request (%s): enlarge timeout +%dms, wait again for %dms\", request, synchTimeout,\n              currentTimeout);\n          continue;\n        } else if (synchronizingNodes > 0) {\n          // SOME NODE IS SYNCHRONIZING: WAIT FOR THEM\n          currentTimeout = synchTimeout;\n          ODistributedServerLog.debug(this, dManager.getLocalNodeName(), null, DIRECTION.NONE,\n              \"%d nodes are in synchronization mode during request (%s): enlarge timeout +%dms, wait again for %dms\",\n              synchronizingNodes, request, synchTimeout, currentTimeout);\n        }\n      }\n\n      return isMinimumQuorumReached() || receivedResponses >= totalExpectedResponses;\n\n    } finally {\n      synchronousResponsesLock.unlock();\n\n      Orient.instance().getProfiler().stopChrono(\"distributed.synchResponses\",\n          \"Time to collect all the synchronous responses from distributed nodes\", beginTime);\n    }\n  }","commit_id":"f5199f0fca1148140fec1e89fff660de394344eb","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unchecked\")\n  private int execute() throws Exception {\n\n    int returnCode = 0;\n\n    // we don't want logs from DB\n    OLogManager.instance().setConsoleLevel(\"SEVERE\");\n\n    // creates the temporary DB where to execute the test\n    ODatabaseUtils.createDatabase(databaseIdentifier);\n    consoleProgressWriter.printMessage(String.format(\"Created database [%s].\", databaseIdentifier.getUrl()));\n\n    try {\n      new Thread(consoleProgressWriter).start();\n\n      consoleProgressWriter\n          .printMessage(String.format(\"Starting workload %s - concurrencyLevel=%d...\", workload.getName(), threadsNumber));\n\n      final long startTime = System.currentTimeMillis();\n\n      workload.execute(threadsNumber, databaseIdentifier);\n\n      final long endTime = System.currentTimeMillis();\n\n      consoleProgressWriter.sendShutdown();\n\n      System.out.println(String.format(\"\\nTotal execution time: %.3f secs\", ((float) (endTime - startTime) / 1000f)));\n\n      System.out.println(workload.getFinalResult());\n\n      // if specified, writes output (in JSON format) to file\n      if (outputResultFile != null) {\n        // OIOUtils.writeFile(new File(outputResultFile), OJsonResultsFormatter.format(stressTestResults));\n      }\n    } catch (Exception ex) {\n      System.err.println(\"\\nAn error has occurred while running the stress test: \" + ex.getMessage());\n      returnCode = 1;\n    } finally {\n      // we don't need to drop the in-memory DB\n      if (databaseIdentifier.getMode() != OMode.MEMORY) {\n        ODatabaseUtils.dropDatabase(databaseIdentifier);\n        consoleProgressWriter.printMessage(String.format(\"\\nDropped database [%s].\", databaseIdentifier.getUrl()));\n      }\n    }\n\n    return returnCode;\n  }","id":60565,"modified_method":"@SuppressWarnings(\"unchecked\")\n  private int execute() throws Exception {\n\n    int returnCode = 0;\n\n    // we don't want logs from DB\n    OLogManager.instance().setConsoleLevel(\"SEVERE\");\n\n    // creates the temporary DB where to execute the test\n    ODatabaseUtils.createDatabase(databaseIdentifier);\n    consoleProgressWriter.printMessage(String.format(\"Created database [%s].\", databaseIdentifier.getUrl()));\n\n    try {\n      new Thread(consoleProgressWriter).start();\n\n      consoleProgressWriter\n          .printMessage(String.format(\"Starting workload %s - concurrencyLevel=%d...\", workload.getName(), threadsNumber));\n\n      final long startTime = System.currentTimeMillis();\n\n      workload.execute(threadsNumber, databaseIdentifier);\n\n      final long endTime = System.currentTimeMillis();\n\n      consoleProgressWriter.sendShutdown();\n\n      System.out.println(String.format(\"\\nTotal execution time: %.3f secs\", ((float) (endTime - startTime) / 1000f)));\n\n      System.out.println(workload.getFinalResult());\n\n      if (outputResultFile != null)\n        writeFile(workload);\n\n    } catch (Exception ex) {\n      System.err.println(\"\\nAn error has occurred while running the stress test: \" + ex.getMessage());\n      returnCode = 1;\n    } finally {\n      // we don't need to drop the in-memory DB\n      if (databaseIdentifier.getMode() != OMode.MEMORY) {\n        ODatabaseUtils.dropDatabase(databaseIdentifier);\n        consoleProgressWriter.printMessage(String.format(\"\\nDropped database [%s].\", databaseIdentifier.getUrl()));\n      }\n    }\n\n    return returnCode;\n  }","commit_id":"f5199f0fca1148140fec1e89fff660de394344eb","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OWorkloadFactory() {\n    register(new OCRUDWorkload());\n  }","id":60566,"modified_method":"public OWorkloadFactory() {\n    register(new OCRUDWorkload());\n\n    final ClassLoader orientClassLoader = OWorkloadFactory.class.getClassLoader();\n\n    final Iterator<OWorkload> ite = lookupProviderWithOrientClassLoader(OWorkload.class, orientClassLoader);\n    while (ite.hasNext()) {\n      final OWorkload strategy = ite.next();\n      register(strategy);\n    }\n  }","commit_id":"f5199f0fca1148140fec1e89fff660de394344eb","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected OWorkLoadResult executeOperation(final ODatabaseIdentifier dbIdentifier, final int operationTotal,\n      final int concurrencyLevel, final OCallable<Void, OBaseWorkLoadContext> callback) {\n    final OWorkLoadResult result = new OWorkLoadResult();\n\n    if (operationTotal == 0)\n      return result;\n\n    final int totalPerThread = operationTotal / concurrencyLevel;\n    final int totalPerLastThread = totalPerThread + operationTotal % concurrencyLevel;\n\n    final ArrayList<Long> operationTiming = new ArrayList<Long>(operationTotal);\n    for (int i = 0; i < operationTotal; ++i)\n      operationTiming.add(null);\n\n    final Thread[] thread = new Thread[concurrencyLevel];\n    for (int t = 0; t < concurrencyLevel; ++t) {\n      final int currentThread = t;\n\n      thread[t] = new Thread(new Runnable() {\n        @Override\n        public void run() {\n          final OBaseWorkLoadContext context = getContext();\n\n          context.threadId = currentThread;\n          context.totalPerThread = context.threadId < concurrencyLevel - 1 ? totalPerThread : totalPerLastThread;\n\n          context.init(dbIdentifier);\n          try {\n            final int startIdx = totalPerThread * context.threadId;\n\n            for (int i = 0; i < context.totalPerThread; ++i) {\n              context.currentIdx = startIdx + i;\n\n              final long startOp = System.nanoTime();\n              try {\n                callback.call(context);\n              } catch (Exception e) {\n                errors.add(e.toString());\n                if (errors.size() > MAX_ERRORS) {\n                  e.printStackTrace();\n                  break;\n                }\n              } finally {\n                operationTiming.set(context.currentIdx, System.nanoTime() - startOp);\n              }\n            }\n\n          } finally {\n            context.close();\n          }\n        }\n      });\n    }\n\n    final long startTime = System.currentTimeMillis();\n\n    // START ALL THE THREADS\n    for (int t = 0; t < concurrencyLevel; ++t) {\n      thread[t].start();\n    }\n\n    // WAIT FOR ALL THE THREADS\n    for (int t = 0; t < concurrencyLevel; ++t) {\n      try {\n        thread[t].join();\n      } catch (InterruptedException e) {\n        e.printStackTrace();\n      }\n    }\n\n    // STOP THE COUNTER\n    result.totalTime = System.currentTimeMillis() - startTime;\n\n    Collections.sort(operationTiming);\n\n    // COMPUTE THE PERCENTILE\n    result.avgNs = (int) (result.totalTime * 1000000 / operationTiming.size());\n    result.percentileAvg = getPercentile(operationTiming, result.avgNs);\n    result.percentile99Ns = operationTiming.get((int) (operationTiming.size() * 99f / 100f));\n    result.percentile99_9Ns = operationTiming.get((int) (operationTiming.size() * 99.9f / 100f));\n\n    return result;\n  }","id":60567,"modified_method":"protected OWorkLoadResult executeOperation(final ODatabaseIdentifier dbIdentifier, final OWorkLoadResult result,\n      final int concurrencyLevel, final OCallable<Void, OBaseWorkLoadContext> callback) {\n    if (result.total == 0)\n      return result;\n\n    final int totalPerThread = result.total / concurrencyLevel;\n    final int totalPerLastThread = totalPerThread + result.total % concurrencyLevel;\n\n    final ArrayList<Long> operationTiming = new ArrayList<Long>(result.total);\n    for (int i = 0; i < result.total; ++i)\n      operationTiming.add(null);\n\n    final Thread[] thread = new Thread[concurrencyLevel];\n    for (int t = 0; t < concurrencyLevel; ++t) {\n      final int currentThread = t;\n\n      thread[t] = new Thread(new Runnable() {\n        @Override\n        public void run() {\n          final OBaseWorkLoadContext context = getContext();\n\n          context.threadId = currentThread;\n          context.totalPerThread = context.threadId < concurrencyLevel - 1 ? totalPerThread : totalPerLastThread;\n\n          context.init(dbIdentifier);\n          try {\n            final int startIdx = totalPerThread * context.threadId;\n\n            for (int i = 0; i < context.totalPerThread; ++i) {\n              context.currentIdx = startIdx + i;\n\n              final long startOp = System.nanoTime();\n              try {\n                callback.call(context);\n              } catch (Exception e) {\n                errors.add(e.toString());\n                if (errors.size() > MAX_ERRORS) {\n                  e.printStackTrace();\n                  break;\n                }\n              } finally {\n                operationTiming.set(context.currentIdx, System.nanoTime() - startOp);\n              }\n            }\n\n          } finally {\n            context.close();\n          }\n        }\n      });\n    }\n\n    final long startTime = System.currentTimeMillis();\n\n    // START ALL THE THREADS\n    for (int t = 0; t < concurrencyLevel; ++t) {\n      thread[t].start();\n    }\n\n    // WAIT FOR ALL THE THREADS\n    for (int t = 0; t < concurrencyLevel; ++t) {\n      try {\n        thread[t].join();\n      } catch (InterruptedException e) {\n        e.printStackTrace();\n      }\n    }\n\n    // STOP THE COUNTER\n    result.totalTime = System.currentTimeMillis() - startTime;\n\n    Collections.sort(operationTiming);\n\n    // COMPUTE THE PERCENTILE\n    result.avgNs = (int) (result.totalTime * 1000000 / operationTiming.size());\n    result.percentileAvg = getPercentile(operationTiming, result.avgNs);\n    result.percentile99Ns = operationTiming.get((int) (operationTiming.size() * 99f / 100f));\n    result.percentile99_9Ns = operationTiming.get((int) (operationTiming.size() * 99.9f / 100f));\n\n    return result;\n  }","commit_id":"1a535f3e46f1d47047d3d695cb7e4614267bbe04","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public void execute(final int concurrencyLevel, final ODatabaseIdentifier databaseIdentifier) {\n    createSchema(databaseIdentifier);\n\n    final ArrayList<ORID> records = new ArrayList<ORID>(createsResult.total);\n    for (int i = 0; i < createsResult.total; ++i)\n      records.add(null);\n\n    executeOperation(databaseIdentifier, createsResult.total, concurrencyLevel, new OCallable<Void, OBaseWorkLoadContext>() {\n      @Override\n      public Void call(final OBaseWorkLoadContext context) {\n        final ODocument doc = createOperation(context.currentIdx);\n        synchronized (records) {\n          if (records.set(context.currentIdx, doc.getIdentity()) != null)\n            throw new RuntimeException(\n                \"Error on creating record with id \" + context.currentIdx + \" because has been already created\");\n        }\n        createsResult.current.incrementAndGet();\n        return null;\n      }\n    });\n\n    if (records.size() != createsResult.total)\n      throw new RuntimeException(\"Error on creating records: found \" + records.size() + \" but expected \" + createsResult.total);\n\n    executeOperation(databaseIdentifier, readsResult.total, concurrencyLevel, new OCallable<Void, OBaseWorkLoadContext>() {\n      @Override\n      public Void call(final OBaseWorkLoadContext context) {\n        readOperation(((OWorkLoadContext) context).getDb(), context.currentIdx);\n        readsResult.current.incrementAndGet();\n        return null;\n      }\n    });\n\n    updatesResult = executeOperation(databaseIdentifier, updatesResult.total, concurrencyLevel,\n        new OCallable<Void, OBaseWorkLoadContext>() {\n          @Override\n          public Void call(final OBaseWorkLoadContext context) {\n            updateOperation(((OWorkLoadContext) context).getDb(), records.get(context.currentIdx));\n            updatesResult.current.incrementAndGet();\n            return null;\n          }\n        });\n\n    deletesResult = executeOperation(databaseIdentifier, deletesResult.total, concurrencyLevel,\n        new OCallable<Void, OBaseWorkLoadContext>() {\n          @Override\n          public Void call(final OBaseWorkLoadContext context) {\n            deleteOperation(((OWorkLoadContext) context).getDb(), records.get(context.currentIdx));\n            records.set(context.currentIdx, null);\n            deletesResult.current.incrementAndGet();\n            return null;\n          }\n        });\n  }","id":60568,"modified_method":"@Override\n  public void execute(final int concurrencyLevel, final ODatabaseIdentifier databaseIdentifier) {\n    createSchema(databaseIdentifier);\n\n    final ArrayList<ORID> records = new ArrayList<ORID>(createsResult.total);\n    for (int i = 0; i < createsResult.total; ++i)\n      records.add(null);\n\n    executeOperation(databaseIdentifier, createsResult,concurrencyLevel, new OCallable<Void, OBaseWorkLoadContext>() {\n      @Override\n      public Void call(final OBaseWorkLoadContext context) {\n        final ODocument doc = createOperation(context.currentIdx);\n        synchronized (records) {\n          if (records.set(context.currentIdx, doc.getIdentity()) != null)\n            throw new RuntimeException(\n                \"Error on creating record with id \" + context.currentIdx + \" because has been already created\");\n        }\n        createsResult.current.incrementAndGet();\n        return null;\n      }\n    });\n\n    if (records.size() != createsResult.total)\n      throw new RuntimeException(\"Error on creating records: found \" + records.size() + \" but expected \" + createsResult.total);\n\n    executeOperation(databaseIdentifier, readsResult, concurrencyLevel, new OCallable<Void, OBaseWorkLoadContext>() {\n      @Override\n      public Void call(final OBaseWorkLoadContext context) {\n        readOperation(((OWorkLoadContext) context).getDb(), context.currentIdx);\n        readsResult.current.incrementAndGet();\n        return null;\n      }\n    });\n\n    executeOperation(databaseIdentifier, updatesResult,  concurrencyLevel, new OCallable<Void, OBaseWorkLoadContext>() {\n      @Override\n      public Void call(final OBaseWorkLoadContext context) {\n        updateOperation(((OWorkLoadContext) context).getDb(), records.get(context.currentIdx));\n        updatesResult.current.incrementAndGet();\n        return null;\n      }\n    });\n\n    executeOperation(databaseIdentifier, deletesResult, concurrencyLevel, new OCallable<Void, OBaseWorkLoadContext>() {\n      @Override\n      public Void call(final OBaseWorkLoadContext context) {\n        deleteOperation(((OWorkLoadContext) context).getDb(), records.get(context.currentIdx));\n        records.set(context.currentIdx, null);\n        deletesResult.current.incrementAndGet();\n        return null;\n      }\n    });\n  }","commit_id":"1a535f3e46f1d47047d3d695cb7e4614267bbe04","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  protected void execute() throws Exception {\n    final String result = workload.getPartialResult();\n    if (lastResult == null || !lastResult.equals(result))\n      System.out.print(\"\\rStress test in progress \" + result);\n    lastResult = result;\n    Thread.sleep(20);\n  }","id":60569,"modified_method":"@Override\n  protected void execute() throws Exception {\n    final String result = workload.getPartialResult();\n    if (lastResult == null || !lastResult.equals(result))\n      System.out.print(\"\\rStress test in progress \" + result);\n    lastResult = result;\n    try {\n      Thread.sleep(200);\n    } catch (InterruptedException e) {\n      interruptCurrentOperation();\n    }\n  }","commit_id":"1a535f3e46f1d47047d3d695cb7e4614267bbe04","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public String getPartialResult() {\n    return String.format(\"%d%% [Vertices: %d - Edges: %d]\", ((100 * resultVertices.current.get() / vertices)),\n        resultVertices.current.get(), resultEdges.current.get());\n  }","id":60570,"modified_method":"@Override\n  public String getPartialResult() {\n    return String.format(\"%d%% [Vertices: %d - Edges: %d]\", ((100 * resultVertices.current.get() / resultVertices.total)),\n        resultVertices.current.get(), resultEdges.current.get());\n  }","commit_id":"1a535f3e46f1d47047d3d695cb7e4614267bbe04","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public void parseParameters(final String args) {\n    final String ops = args.toUpperCase();\n    char state = ' ';\n    final StringBuilder number = new StringBuilder();\n\n    for (int pos = 0; pos < ops.length(); ++pos) {\n      final char c = ops.charAt(pos);\n\n      if (c == ' ' || c == 'V' || c == 'F') {\n        state = assignState(state, number, c);\n      } else if (c >= '0' && c <= '9')\n        number.append(c);\n      else\n        throw new IllegalArgumentException(\n            \"Character '\" + c + \"' is not valid on \" + getName() + \" workload. \" + INVALID_FORM_MESSAGE);\n    }\n    assignState(state, number, ' ');\n\n    if (vertices == 0)\n      throw new IllegalArgumentException(INVALID_FORM_MESSAGE);\n  }","id":60571,"modified_method":"@Override\n  public void parseParameters(final String args) {\n    final String ops = args.toUpperCase();\n    char state = ' ';\n    final StringBuilder number = new StringBuilder();\n\n    for (int pos = 0; pos < ops.length(); ++pos) {\n      final char c = ops.charAt(pos);\n\n      if (c == ' ' || c == 'V' || c == 'F') {\n        state = assignState(state, number, c);\n      } else if (c >= '0' && c <= '9')\n        number.append(c);\n      else\n        throw new IllegalArgumentException(\n            \"Character '\" + c + \"' is not valid on \" + getName() + \" workload. \" + INVALID_FORM_MESSAGE);\n    }\n    assignState(state, number, ' ');\n\n    if (resultVertices.total == 0)\n      throw new IllegalArgumentException(INVALID_FORM_MESSAGE);\n  }","commit_id":"1a535f3e46f1d47047d3d695cb7e4614267bbe04","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public String getFinalResult() {\n    final StringBuilder buffer = new StringBuilder(getErrors());\n\n    buffer.append(String.format(\"\\nCreated %d vertices and %d edges in %.3f secs\", resultVertices.total, resultEdges.total,\n        resultVertices.totalTime / 1000f));\n\n    buffer.append(String.format(\n        \"\\n- Vertices Throughput: %.3f/sec - Avg: %.3fms/op (%dth percentile) - 99th Perc: %.3fms - 99.9th Perc: %.3fms\",\n        resultVertices.total * 1000 / (float) resultVertices.totalTime, resultVertices.avgNs / 1000000f,\n        resultVertices.percentileAvg, resultVertices.percentile99Ns / 1000000f, resultVertices.percentile99_9Ns / 1000000f));\n\n    buffer.append(String.format(\n        \"\\n- Edges    Throughput: %.3f/sec - Avg: %.3fms/op (%dth percentile) - 99th Perc: %.3fms - 99.9th Perc: %.3fms\",\n        resultEdges.total * 1000 / (float) resultEdges.totalTime, resultEdges.avgNs / 1000000f, resultEdges.percentileAvg,\n        resultEdges.percentile99Ns / 1000000f, resultEdges.percentile99_9Ns / 1000000f));\n\n    return buffer.toString();\n  }","id":60572,"modified_method":"@Override\n  public String getFinalResult() {\n    final StringBuilder buffer = new StringBuilder(getErrors());\n\n    buffer.append(String.format(\"\\nCreated %d vertices and %d edges in %.3f secs\", resultVertices.current.get(),\n        resultEdges.current.get(), resultVertices.totalTime / 1000f));\n\n    buffer.append(\n        String.format(\"\\n- Throughput: %.3f/sec - Avg: %.3fms/op (%dth percentile) - 99th Perc: %.3fms - 99.9th Perc: %.3fms\",\n            resultVertices.total * 1000 / (float) resultVertices.totalTime, resultVertices.avgNs / 1000000f,\n            resultVertices.percentileAvg, resultVertices.percentile99Ns / 1000000f, resultVertices.percentile99_9Ns / 1000000f));\n\n    return buffer.toString();\n  }","commit_id":"1a535f3e46f1d47047d3d695cb7e4614267bbe04","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public int getVertices() {\n    return vertices;\n  }","id":60573,"modified_method":"public int getVertices() {\n    return resultVertices.total;\n  }","commit_id":"1a535f3e46f1d47047d3d695cb7e4614267bbe04","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public void execute(final int concurrencyLevel, final ODatabaseIdentifier databaseIdentifier) {\n    // TODO: aggregation, shortest path, hard path, neighbors, neighbors2, look also at XDBench\n    executeOperation(databaseIdentifier, vertices, concurrencyLevel, new OCallable<Void, OBaseWorkLoadContext>() {\n      OrientVertex lastVertexToConnect;\n      int          lastVertexEdges;\n\n      @Override\n      public Void call(final OBaseWorkLoadContext context) {\n        final OrientBaseGraph graph = ((OBaseGraphWorkload.OWorkLoadContext) context).graph;\n\n        final OrientVertex v = graph.addVertex(null, \"_id\", resultVertices.current.get());\n\n        if (lastVertexToConnect != null) {\n          v.addEdge(\"E\", lastVertexToConnect);\n          resultEdges.current.incrementAndGet();\n\n          lastVertexEdges++;\n\n          if (lastVertexEdges > factor) {\n            lastVertexEdges = 0;\n            lastVertexToConnect = v;\n          }\n        } else\n          lastVertexToConnect = v;\n\n        resultVertices.current.incrementAndGet();\n\n        return null;\n      }\n    });\n  }","id":60574,"modified_method":"@Override\n  public void execute(final int concurrencyLevel, final ODatabaseIdentifier databaseIdentifier) {\n    executeOperation(databaseIdentifier, resultVertices, concurrencyLevel, new OCallable<Void, OBaseWorkLoadContext>() {\n      @Override\n      public Void call(final OBaseWorkLoadContext context) {\n        final OWorkLoadContext graphContext = ((OWorkLoadContext) context);\n        final OrientBaseGraph graph = graphContext.graph;\n\n        final OrientVertex v = graph.addVertex(null, \"_id\", resultVertices.current.get());\n\n        if (graphContext.lastVertexToConnect != null) {\n          v.addEdge(\"E\", graphContext.lastVertexToConnect);\n          resultEdges.current.incrementAndGet();\n\n          graphContext.lastVertexEdges++;\n\n          if (graphContext.lastVertexEdges > factor) {\n            graphContext.lastVertexEdges = 0;\n            graphContext.lastVertexToConnect = v;\n          }\n        } else\n          graphContext.lastVertexToConnect = v;\n\n        resultVertices.current.incrementAndGet();\n\n        return null;\n      }\n    });\n  }","commit_id":"1a535f3e46f1d47047d3d695cb7e4614267bbe04","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private char assignState(final char state, final StringBuilder number, final char c) {\n    if (number.length() == 0)\n      number.append(\"0\");\n\n    if (state == 'V')\n      vertices = Integer.parseInt(number.toString());\n    else if (state == 'F')\n      factor = Integer.parseInt(number.toString());\n\n    number.setLength(0);\n    return c;\n  }","id":60575,"modified_method":"private char assignState(final char state, final StringBuilder number, final char c) {\n    if (number.length() == 0)\n      number.append(\"0\");\n\n    if (state == 'V')\n      resultVertices.total = Integer.parseInt(number.toString());\n    else if (state == 'F')\n      factor = Integer.parseInt(number.toString());\n\n    number.setLength(0);\n    return c;\n  }","commit_id":"1a535f3e46f1d47047d3d695cb7e4614267bbe04","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unchecked\")\n  private int execute() throws Exception {\n\n    int returnCode = 0;\n\n    // we don't want logs from DB\n    OLogManager.instance().setConsoleLevel(\"SEVERE\");\n\n    // creates the temporary DB where to execute the test\n    ODatabaseUtils.createDatabase(databaseIdentifier);\n    consoleProgressWriter.printMessage(String.format(\"Created database [%s].\", databaseIdentifier.getUrl()));\n\n    try {\n      new Thread(consoleProgressWriter).start();\n\n      consoleProgressWriter\n          .printMessage(String.format(\"Starting workload %s - concurrencyLevel=%d...\", workload.getName(), threadsNumber));\n\n      final long startTime = System.currentTimeMillis();\n\n      workload.execute(threadsNumber, databaseIdentifier);\n\n      final long endTime = System.currentTimeMillis();\n\n      consoleProgressWriter.sendShutdown();\n\n      System.out.println(String.format(\"\\nTotal execution time: %.3f secs\", ((float) (endTime - startTime) / 1000f)));\n\n      System.out.println(workload.getFinalResult());\n\n      if (outputResultFile != null)\n        writeFile(workload);\n\n    } catch (Exception ex) {\n      System.err.println(\"\\nAn error has occurred while running the stress test: \" + ex.getMessage());\n      returnCode = 1;\n    } finally {\n      // we don't need to drop the in-memory DB\n      if (databaseIdentifier.getMode() != OMode.MEMORY) {\n        ODatabaseUtils.dropDatabase(databaseIdentifier);\n        consoleProgressWriter.printMessage(String.format(\"\\nDropped database [%s].\", databaseIdentifier.getUrl()));\n      }\n    }\n\n    return returnCode;\n  }","id":60576,"modified_method":"@SuppressWarnings(\"unchecked\")\n  private int execute() throws Exception {\n\n    int returnCode = 0;\n\n    // we don't want logs from DB\n    OLogManager.instance().setConsoleLevel(\"SEVERE\");\n\n    // creates the temporary DB where to execute the test\n    ODatabaseUtils.createDatabase(databaseIdentifier);\n    System.out.println(String.format(\"Created database [%s].\", databaseIdentifier.getUrl()));\n\n    try {\n      for (OWorkload workload : workloads) {\n        consoleProgressWriter = new OConsoleProgressWriter(workload);\n\n        consoleProgressWriter.start();\n\n        consoleProgressWriter\n            .printMessage(String.format(\"Starting workload %s - concurrencyLevel=%d...\", workload.getName(), threadsNumber));\n\n        final long startTime = System.currentTimeMillis();\n\n        workload.execute(threadsNumber, databaseIdentifier);\n\n        final long endTime = System.currentTimeMillis();\n\n        consoleProgressWriter.sendShutdown();\n\n        System.out.println(String.format(\"\\nTotal execution time: %.3f secs\", ((float) (endTime - startTime) / 1000f)));\n\n        System.out.println(workload.getFinalResult());\n      }\n\n      if (outputResultFile != null)\n        writeFile();\n\n    } catch (Exception ex) {\n      System.err.println(\"\\nAn error has occurred while running the stress test: \" + ex.getMessage());\n      returnCode = 1;\n    } finally {\n      // we don't need to drop the in-memory DB\n      if (databaseIdentifier.getMode() != OMode.MEMORY) {\n        ODatabaseUtils.dropDatabase(databaseIdentifier);\n        consoleProgressWriter.printMessage(String.format(\"\\nDropped database [%s].\", databaseIdentifier.getUrl()));\n      }\n    }\n\n    return returnCode;\n  }","commit_id":"1a535f3e46f1d47047d3d695cb7e4614267bbe04","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OStressTester(final OWorkload workload, ODatabaseIdentifier databaseIdentifier, int threadsNumber, int opsInTx,\n      String outputResultFile) throws Exception {\n    this.workload = workload;\n    this.threadsNumber = threadsNumber;\n    this.databaseIdentifier = databaseIdentifier;\n    this.opsInTx = opsInTx;\n    this.outputResultFile = outputResultFile;\n    consoleProgressWriter = new OConsoleProgressWriter(this.workload);\n  }","id":60577,"modified_method":"public OStressTester(final List<OWorkload> workloads, ODatabaseIdentifier databaseIdentifier, int threadsNumber, int opsInTx,\n      String outputResultFile) throws Exception {\n    this.workloads = workloads;\n    this.threadsNumber = threadsNumber;\n    this.databaseIdentifier = databaseIdentifier;\n    this.opsInTx = opsInTx;\n    this.outputResultFile = outputResultFile;\n  }","commit_id":"1a535f3e46f1d47047d3d695cb7e4614267bbe04","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void writeFile(final OWorkload workload) {\n    try {\n      OIOUtils.writeFile(new File(outputResultFile), workload.getFinalResultAsJson());\n    } catch (IOException e) {\n      System.err.println(\"\\nError on writing the result file : \" + e.getMessage());\n    }\n  }","id":60578,"modified_method":"private void writeFile() {\n    try {\n      final StringBuilder output = new StringBuilder();\n      output.append(\"{\\\"result\\\":[\");\n      int i = 0;\n      for (OWorkload workload : workloads) {\n        if (i++ > 0)\n          output.append(\",\");\n        workload.getFinalResultAsJson();\n      }\n      output.append(\"]}\");\n\n      OIOUtils.writeFile(new File(outputResultFile), output.toString());\n    } catch (IOException e) {\n      System.err.println(\"\\nError on writing the result file : \" + e.getMessage());\n    }\n  }","commit_id":"1a535f3e46f1d47047d3d695cb7e4614267bbe04","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n   * builds a StressTester object using the command line arguments\n   *\n   * @param args\n   * @return\n   * @throws Exception\n   */\n  public static OStressTester getStressTester(String[] args) throws Exception {\n\n    final Map<String, String> options = checkOptions(readOptions(args));\n\n    String dbName = TEMP_DATABASE_NAME + new SimpleDateFormat(\"yyyyMMdd_HHmmss\").format(new Date());\n    OStressTester.OMode mode = OStressTester.OMode.valueOf(options.get(OPTION_MODE).toUpperCase());\n    String rootPassword = options.get(OPTION_ROOT_PASSWORD);\n    String resultOutputFile = options.get(OPTION_OUTPUT_FILE);\n    String plocalPath = options.get(OPTION_PLOCAL_PATH);\n    int operationsPerTransaction = getNumber(options.get(OPTION_TRANSACTIONS), \"transactions\");\n    int threadsNumber = getNumber(options.get(OPTION_CONCURRENCY), \"concurrency\");\n    String remoteIp = options.get(OPTION_REMOTE_IP);\n    String workloadCfg = options.get(OPTION_WORKLOAD);\n    int remotePort = 2424;\n\n    if (plocalPath != null) {\n      if (plocalPath.endsWith(File.separator)) {\n        plocalPath = plocalPath.substring(0, plocalPath.length() - File.separator.length());\n      }\n      File plocalFile = new File(plocalPath);\n      if (!plocalFile.exists()) {\n        throw new IllegalArgumentException(String.format(COMMAND_LINE_PARSER_NOT_EXISTING_PLOCAL_PATH, plocalPath));\n      }\n      if (!plocalFile.canWrite()) {\n        throw new IllegalArgumentException(String.format(COMMAND_LINE_PARSER_NO_WRITE_PERMISSION_PLOCAL_PATH, plocalPath));\n      }\n      if (!plocalFile.isDirectory()) {\n        throw new IllegalArgumentException(String.format(COMMAND_LINE_PARSER_PLOCAL_PATH_IS_NOT_DIRECTORY, plocalPath));\n      }\n    }\n\n    if (resultOutputFile != null) {\n\n      File outputFile = new File(resultOutputFile);\n      if (outputFile.exists()) {\n        throw new IllegalArgumentException(String.format(COMMAND_LINE_PARSER_EXISTING_OUTPUT_FILE, resultOutputFile));\n      }\n\n      File parentFile = outputFile.getParentFile();\n\n      // if the filename does not contain a path (both relative and absolute)\n      if (parentFile == null) {\n        parentFile = new File(\".\");\n      }\n\n      if (!parentFile.exists()) {\n        throw new IllegalArgumentException(\n            String.format(COMMAND_LINE_PARSER_NOT_EXISTING_OUTPUT_DIRECTORY, parentFile.getAbsoluteFile()));\n      }\n      if (!parentFile.canWrite()) {\n        throw new IllegalArgumentException(\n            String.format(COMMAND_LINE_PARSER_NO_WRITE_PERMISSION_OUTPUT_FILE, parentFile.getAbsoluteFile()));\n      }\n    }\n\n    if (options.get(OPTION_REMOTE_PORT) != null) {\n      remotePort = getNumber(options.get(OPTION_REMOTE_PORT), \"remotePort\");\n      if (remotePort > 65535) {\n        throw new IllegalArgumentException(String.format(COMMAND_LINE_PARSER_INVALID_REMOTE_PORT_NUMBER, remotePort));\n      }\n    }\n\n    if (mode == OStressTester.OMode.DISTRIBUTED) {\n      throw new IllegalArgumentException(String.format(\"OMode [%s] not yet supported.\", mode));\n    }\n\n    if (mode == OStressTester.OMode.REMOTE && remoteIp == null) {\n      throw new IllegalArgumentException(COMMAND_LINE_PARSER_MISSING_REMOTE_IP);\n    }\n\n    if (rootPassword == null && mode == OStressTester.OMode.REMOTE) {\n      Console console = System.console();\n      if (console != null) {\n        rootPassword = String.valueOf(console.readPassword(String.format(CONSOLE_REMOTE_PASSWORD_PROMPT, remoteIp, remotePort)));\n      } else {\n        throw new Exception(ERROR_OPENING_CONSOLE);\n      }\n    }\n\n    final OWorkload workload = parseWorkload(workloadCfg);\n\n    final ODatabaseIdentifier databaseIdentifier = new ODatabaseIdentifier(mode, dbName, rootPassword, remoteIp, remotePort,\n        plocalPath);\n\n    return new OStressTester(workload, databaseIdentifier, threadsNumber, operationsPerTransaction, resultOutputFile);\n  }","id":60579,"modified_method":"/**\n   * builds a StressTester object using the command line arguments\n   *\n   * @param args\n   * @return\n   * @throws Exception\n   */\n  public static OStressTester getStressTester(String[] args) throws Exception {\n\n    final Map<String, String> options = checkOptions(readOptions(args));\n\n    String dbName = TEMP_DATABASE_NAME + new SimpleDateFormat(\"yyyyMMdd_HHmmss\").format(new Date());\n    OStressTester.OMode mode = OStressTester.OMode.valueOf(options.get(OPTION_MODE).toUpperCase());\n    String rootPassword = options.get(OPTION_ROOT_PASSWORD);\n    String resultOutputFile = options.get(OPTION_OUTPUT_FILE);\n    String plocalPath = options.get(OPTION_PLOCAL_PATH);\n    int operationsPerTransaction = getNumber(options.get(OPTION_TRANSACTIONS), \"transactions\");\n    int threadsNumber = getNumber(options.get(OPTION_CONCURRENCY), \"concurrency\");\n    String remoteIp = options.get(OPTION_REMOTE_IP);\n    String workloadCfg = options.get(OPTION_WORKLOAD);\n    int remotePort = 2424;\n\n    if (plocalPath != null) {\n      if (plocalPath.endsWith(File.separator)) {\n        plocalPath = plocalPath.substring(0, plocalPath.length() - File.separator.length());\n      }\n      File plocalFile = new File(plocalPath);\n      if (!plocalFile.exists()) {\n        throw new IllegalArgumentException(String.format(COMMAND_LINE_PARSER_NOT_EXISTING_PLOCAL_PATH, plocalPath));\n      }\n      if (!plocalFile.canWrite()) {\n        throw new IllegalArgumentException(String.format(COMMAND_LINE_PARSER_NO_WRITE_PERMISSION_PLOCAL_PATH, plocalPath));\n      }\n      if (!plocalFile.isDirectory()) {\n        throw new IllegalArgumentException(String.format(COMMAND_LINE_PARSER_PLOCAL_PATH_IS_NOT_DIRECTORY, plocalPath));\n      }\n    }\n\n    if (resultOutputFile != null) {\n\n      File outputFile = new File(resultOutputFile);\n      if (outputFile.exists()) {\n        throw new IllegalArgumentException(String.format(COMMAND_LINE_PARSER_EXISTING_OUTPUT_FILE, resultOutputFile));\n      }\n\n      File parentFile = outputFile.getParentFile();\n\n      // if the filename does not contain a path (both relative and absolute)\n      if (parentFile == null) {\n        parentFile = new File(\".\");\n      }\n\n      if (!parentFile.exists()) {\n        throw new IllegalArgumentException(\n            String.format(COMMAND_LINE_PARSER_NOT_EXISTING_OUTPUT_DIRECTORY, parentFile.getAbsoluteFile()));\n      }\n      if (!parentFile.canWrite()) {\n        throw new IllegalArgumentException(\n            String.format(COMMAND_LINE_PARSER_NO_WRITE_PERMISSION_OUTPUT_FILE, parentFile.getAbsoluteFile()));\n      }\n    }\n\n    if (options.get(OPTION_REMOTE_PORT) != null) {\n      remotePort = getNumber(options.get(OPTION_REMOTE_PORT), \"remotePort\");\n      if (remotePort > 65535) {\n        throw new IllegalArgumentException(String.format(COMMAND_LINE_PARSER_INVALID_REMOTE_PORT_NUMBER, remotePort));\n      }\n    }\n\n    if (mode == OStressTester.OMode.DISTRIBUTED) {\n      throw new IllegalArgumentException(String.format(\"OMode [%s] not yet supported.\", mode));\n    }\n\n    if (mode == OStressTester.OMode.REMOTE && remoteIp == null) {\n      throw new IllegalArgumentException(COMMAND_LINE_PARSER_MISSING_REMOTE_IP);\n    }\n\n    if (rootPassword == null && mode == OStressTester.OMode.REMOTE) {\n      Console console = System.console();\n      if (console != null) {\n        rootPassword = String.valueOf(console.readPassword(String.format(CONSOLE_REMOTE_PASSWORD_PROMPT, remoteIp, remotePort)));\n      } else {\n        throw new Exception(ERROR_OPENING_CONSOLE);\n      }\n    }\n\n    final List<OWorkload> workloads = parseWorkloads(workloadCfg);\n\n    final ODatabaseIdentifier databaseIdentifier = new ODatabaseIdentifier(mode, dbName, rootPassword, remoteIp, remotePort,\n        plocalPath);\n\n    return new OStressTester(workloads, databaseIdentifier, threadsNumber, operationsPerTransaction, resultOutputFile);\n  }","commit_id":"1a535f3e46f1d47047d3d695cb7e4614267bbe04","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private static OWorkload parseWorkload(final String workloadConfig) {\n    if (workloadConfig == null || workloadConfig.isEmpty())\n      throw new IllegalArgumentException(\"Workload parameter is mandatory. Syntax: <workload:params>\");\n\n    String workloadName;\n    String workloadParams;\n\n    final int pos = workloadConfig.indexOf(\":\");\n    if (pos > -1) {\n      workloadName = workloadConfig.substring(0, pos);\n      workloadParams = workloadConfig.substring(pos + 1);\n    } else {\n      workloadName = workloadConfig;\n      workloadParams = null;\n    }\n\n    final OWorkload workload = OStressTester.getWorkloadFactory().get(workloadName);\n    if (workload == null)\n      throw new IllegalArgumentException(\"Workload '\" + workloadName + \"' is not configured. Use one of the following: \"\n          + OStressTester.getWorkloadFactory().getRegistered());\n\n    workload.parseParameters(workloadParams);\n\n    return workload;\n  }","id":60580,"modified_method":"private static List<OWorkload> parseWorkloads(final String workloadConfig) {\n    if (workloadConfig == null || workloadConfig.isEmpty())\n      throw new IllegalArgumentException(\"Workload parameter is mandatory. Syntax: <workload-name:workload-params>\");\n\n    final List<OWorkload> result = new ArrayList<OWorkload>();\n\n    final String[] parts = workloadConfig.split(\",\");\n    for (String part : parts) {\n      String workloadName;\n      String workloadParams;\n\n      final int pos = part.indexOf(\":\");\n      if (pos > -1) {\n        workloadName = part.substring(0, pos);\n        workloadParams = part.substring(pos + 1);\n      } else {\n        workloadName = part;\n        workloadParams = null;\n      }\n\n      final OWorkload workload = OStressTester.getWorkloadFactory().get(workloadName);\n      if (workload == null)\n        throw new IllegalArgumentException(\"Workload '\" + workloadName + \"' is not configured. Use one of the following: \"\n            + OStressTester.getWorkloadFactory().getRegistered());\n      workload.parseParameters(workloadParams);\n\n      result.add(workload);\n    }\n\n    return result;\n  }","commit_id":"1a535f3e46f1d47047d3d695cb7e4614267bbe04","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void registerProjectLevelProviders(Project project) {\n    StateStorageManager manager = ((ProjectEx)project).getStateStore().getStateStorageManager();\n    ICSStreamProvider provider = new ICSStreamProvider(getProjectId(project));\n    manager.registerStreamProvider(provider, RoamingType.PER_PLATFORM);\n    manager.registerStreamProvider(provider, RoamingType.PER_USER);\n  }","id":60581,"modified_method":"public void registerProjectLevelProviders(Project project) {\n    StateStorageManager manager = ((ProjectEx)project).getStateStore().getStateStorageManager();\n    String projectId = getProjectId(project);\n    manager.registerStreamProvider(new ICSStreamProvider(projectId), RoamingType.PER_PLATFORM);\n    manager.registerStreamProvider(new ICSStreamProvider(projectId) {\n      @Override\n      public void saveContent(@NotNull String fileSpec, @NotNull InputStream content, long size, @NotNull RoamingType roamingType, boolean async) throws IOException {\n        if (isShareable(fileSpec)) {\n          super.saveContent(fileSpec, content, size, roamingType, async);\n        }\n      }\n\n      private boolean isShareable(String fileSpec) {\n        return settings.shareProjectWorkspace || !fileSpec.equals(StoragePathMacros.WORKSPACE_FILE);\n      }\n\n      @Nullable\n      @Override\n      public InputStream loadContent(@NotNull String fileSpec, @NotNull RoamingType roamingType) throws IOException {\n        return isShareable(fileSpec) ? super.loadContent(fileSpec, roamingType) : null;\n      }\n    }, RoamingType.PER_USER);\n  }","commit_id":"32245b8f489e1f33507a2106fc8c2f6d5822e313","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    @Nullable\n    public InputStream loadContent(@NotNull String fileSpec, @NotNull RoamingType roamingType) throws IOException {\n      if (projectId == null || roamingType == RoamingType.PER_PLATFORM) {\n        return repositoryManager.read(IcsUrlBuilder.buildPath(fileSpec, roamingType, projectId));\n      }\n      else if (StoragePathMacros.WORKSPACE_FILE.equals(fileSpec)) {\n        return repositoryManager.read(IcsUrlBuilder.buildPath(fileSpec, roamingType, projectId));\n      }\n      else {\n        return null;\n      }\n    }","id":60582,"modified_method":"@Override\n    @Nullable\n    public InputStream loadContent(@NotNull String fileSpec, @NotNull RoamingType roamingType) throws IOException {\n      return repositoryManager.read(IcsUrlBuilder.buildPath(fileSpec, roamingType, projectId));\n    }","commit_id":"32245b8f489e1f33507a2106fc8c2f6d5822e313","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void apply() {\n    IcsSettings settings = IcsManager.getInstance().getIdeaServerSettings();\n    settings.update(loginTextField.getText(), tokenTextField.getText());\n    settings.token = tokenTextField.getText();\n    settings.url = urlTextField.getText();\n    settings.updateOnStart = updateRepositoryFromRemoteCheckBox.isSelected();\n  }","id":60583,"modified_method":"public void apply() {\n    IcsSettings settings = IcsManager.getInstance().getIdeaServerSettings();\n    settings.update(loginTextField.getText(), tokenTextField.getText());\n    settings.token = tokenTextField.getText();\n    settings.url = urlTextField.getText();\n    settings.updateOnStart = updateRepositoryFromRemoteCheckBox.isSelected();\n    settings.shareProjectWorkspace = shareProjectWorkspaceCheckBox.isSelected();\n  }","commit_id":"32245b8f489e1f33507a2106fc8c2f6d5822e313","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public IcsSettingsPanel() {\n    IcsSettings settings = IcsManager.getInstance().getIdeaServerSettings();\n\n    loginTextField.setText(settings.getLogin());\n    tokenTextField.setText(settings.token);\n    urlTextField.setText(settings.url);\n    updateRepositoryFromRemoteCheckBox.setSelected(settings.updateOnStart);\n  }","id":60584,"modified_method":"public IcsSettingsPanel() {\n    IcsSettings settings = IcsManager.getInstance().getIdeaServerSettings();\n\n    loginTextField.setText(settings.getLogin());\n    tokenTextField.setText(settings.token);\n    urlTextField.setText(settings.url);\n    updateRepositoryFromRemoteCheckBox.setSelected(settings.updateOnStart);\n    shareProjectWorkspaceCheckBox.setSelected(settings.shareProjectWorkspace);\n  }","commit_id":"32245b8f489e1f33507a2106fc8c2f6d5822e313","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void login() throws Exception {\n    try {\n      String sessionId = login(createBuilder(null, null, null));\n      if (sessionId != null) {\n        settings.updateSession(sessionId);\n        settings.setStatus(IdeaConfigurationServerStatus.LOGGED_IN);\n      }\n    }\n    catch (Exception e) {\n      settings.setStatus(IdeaConfigurationServerStatus.CONNECTION_FAILED);\n      throw e;\n    }\n  }","id":60585,"modified_method":"public void login() {\n    try {\n      serverConnector = new IdeaServerConnector();\n      settings.setStatus(IdeaConfigurationServerStatus.LOGGED_IN);\n    }\n    catch (IOException e) {\n      settings.setStatus(IdeaConfigurationServerStatus.CONNECTION_FAILED);\n      LOG.error(e);\n    }\n  }","commit_id":"a6e5393b1e796a55da5fb37e8e9b8ebc03d05d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void registerProvider(final StateStorageManager storageManager, final RoamingType type) {\n    storageManager.registerStreamProvider(new MyStreamProvider() {\n      @Override\n      public void saveContent(final String fileSpec, @NotNull final InputStream content, final long size, final RoamingType roamingType,\n                              boolean async) throws IOException {\n\n        saveFileContent(content, size, createBuilder(fileSpec, type, null), async);\n      }\n\n      @Override\n      public InputStream loadContent(final String fileSpec, final RoamingType roamingType) throws IOException {\n        return loadUserPreferences(createBuilder(fileSpec, type, null));\n      }\n\n      @Override\n      public String[] listSubFiles(final String fileSpec) {\n        return listSubFileNames(createBuilder(fileSpec, type, null));\n      }\n\n      @Override\n      public void deleteFile(final String fileSpec, final RoamingType roamingType) {\n        deleteUserPreferencesAsync(createBuilder(fileSpec, type, null));\n      }\n\n      @Override\n      protected IdeaServerUrlBuilder createBuilderInt(final String fileSpec) {\n        return createBuilder(fileSpec, type, null);\n      }\n    }, type);\n  }","id":60586,"modified_method":"private void registerProvider(StateStorageManager storageManager, RoamingType type) {\n    storageManager.registerStreamProvider(new ICSStreamProvider(null, type) {\n      @Override\n      public String[] listSubFiles(final String fileSpec) {\n        return listSubFileNames(createBuilder(fileSpec, roamingType, null));\n      }\n\n      @Override\n      public void deleteFile(String fileSpec, RoamingType roamingType) {\n        deleteUserPreferencesAsync(createBuilder(fileSpec, this.roamingType, null));\n      }\n    }, type);\n  }","commit_id":"a6e5393b1e796a55da5fb37e8e9b8ebc03d05d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private IdeaServerUrlBuilder createBuilder(final String fileSpec, final RoamingType type, final String projectKey) {\n    try {\n      return new IdeaServerUrlBuilder(fileSpec, type, projectKey, settings.getSessionId(), settings.getUserName(), settings.getPassword()) {\n        @Override\n        protected void onSessionIdUpdated(final String id) {\n          settings.updateSession(id);\n        }\n\n        @Override\n        public void setDisconnectedStatus() {\n          settings.setStatus(IdeaConfigurationServerStatus.CONNECTION_FAILED);\n        }\n\n        @Override\n        public void setUnauthorizedStatus() {\n          settings.setStatus(IdeaConfigurationServerStatus.UNAUTHORIZED);\n        }\n      }.setReloginAutomatically(true);\n    }\n    finally {\n      if (projectKey != null) {\n        checkIfProjectKeyMappingIsStored(projectKey);\n      }\n    }\n  }","id":60587,"modified_method":"private IdeaServerUrlBuilder createBuilder(final String fileSpec, final RoamingType type, final String projectKey) {\n    try {\n      return new IdeaServerUrlBuilder(fileSpec, type, projectKey) {\n\n        @Override\n        public void setDisconnectedStatus() {\n          settings.setStatus(IdeaConfigurationServerStatus.CONNECTION_FAILED);\n        }\n\n        @Override\n        public void setUnauthorizedStatus() {\n          settings.setStatus(IdeaConfigurationServerStatus.UNAUTHORIZED);\n        }\n      };\n    }\n    finally {\n      if (projectKey != null) {\n        checkIfProjectKeyMappingIsStored(projectKey);\n      }\n    }\n  }","commit_id":"a6e5393b1e796a55da5fb37e8e9b8ebc03d05d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public boolean isEnabled() {\n      return areProvidersEnabled();\n    }","id":60588,"modified_method":"@Override\n    public boolean isEnabled() {\n      // todo configurable\n      return true;\n    }","commit_id":"a6e5393b1e796a55da5fb37e8e9b8ebc03d05d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private InputStream loadUserPreferences(IdeaServerUrlBuilder builder) throws IOException {\n    try {\n      if (canUseLocalCopy(builder)) {\n        File localFileCopy = new File(myLocalCopyDir, builder.buildPath());\n        if (!localFileCopy.isFile()) {\n          return null;\n        }\n        return new FileInputStream(localFileCopy);\n      }\n    }\n    catch (FileNotFoundException e) {\n      return IdeaServerConnector.loadUserPreferences(builder);\n    }\n    return IdeaServerConnector.loadUserPreferences(builder);\n  }","id":60589,"modified_method":"@Nullable\n  private InputStream loadUserPreferences(IdeaServerUrlBuilder builder) throws IOException {\n    try {\n      if (canUseLocalCopy(builder)) {\n        File localFileCopy = new File(myLocalCopyDir, builder.buildPath());\n        if (!localFileCopy.isFile()) {\n          return null;\n        }\n        return new FileInputStream(localFileCopy);\n      }\n    }\n    catch (FileNotFoundException ignored) {\n    }\n    return serverConnector.loadUserPreferences(builder.buildPath());\n  }","commit_id":"a6e5393b1e796a55da5fb37e8e9b8ebc03d05d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static IdeaConfigurationServerManager getInstance() {\n    return ourInstance;\n  }","id":60590,"modified_method":"public static IdeaConfigurationServerManager getInstance() {\n    return instance;\n  }","commit_id":"a6e5393b1e796a55da5fb37e8e9b8ebc03d05d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String getProjectKey(final Project project) {\n    String id = PropertiesComponent.getInstance(project).getValue(PROJECT_ID_KEY);\n    if (id == null) {\n      id = UUID.randomUUID().toString();\n      PropertiesComponent.getInstance(project).setValue(PROJECT_ID_KEY, id);\n    }\n    return id;\n  }","id":60591,"modified_method":"private static String getProjectId(final Project project) {\n    String id = PropertiesComponent.getInstance(project).getValue(PROJECT_ID_KEY);\n    if (id == null) {\n      id = UUID.randomUUID().toString();\n      PropertiesComponent.getInstance(project).setValue(PROJECT_ID_KEY, id);\n    }\n    return id;\n  }","commit_id":"a6e5393b1e796a55da5fb37e8e9b8ebc03d05d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void registerProjectLevelProviders(Project project) {\n    final String projectKey = getProjectKey(project);\n    final StateStorageManager manager = ((ProjectEx)project).getStateStore().getStateStorageManager();\n    manager.registerStreamProvider(new MyStreamProvider() {\n      @Override\n      public void saveContent(String fileSpec, @NotNull InputStream content, long size, RoamingType roamingType, boolean async) throws IOException {\n        saveFileContent(content, size, createBuilder(fileSpec, RoamingType.PER_PLATFORM, projectKey), async);\n      }\n\n      @Override\n      protected IdeaServerUrlBuilder createBuilderInt(final String fileSpec) {\n        return createBuilder(fileSpec, RoamingType.PER_PLATFORM, projectKey);\n      }\n\n      @Override\n      public InputStream loadContent(final String fileSpec, final RoamingType roamingType) throws IOException {\n        return loadUserPreferences(createBuilder(fileSpec, RoamingType.PER_PLATFORM, projectKey));\n      }\n    }, RoamingType.PER_PLATFORM);\n\n    manager.registerStreamProvider(new MyStreamProvider() {\n      @Override\n      public void saveContent(final String fileSpec, @NotNull final InputStream content, final long size, final RoamingType roamingType,\n                              boolean async) throws IOException {\n\n        saveFileContent(content, size, createBuilder(fileSpec, RoamingType.PER_USER, projectKey), async);\n      }\n\n      @Override\n      protected IdeaServerUrlBuilder createBuilderInt(final String fileSpec) {\n        return createBuilder(fileSpec, RoamingType.PER_USER, projectKey);\n      }\n\n      @Override\n      public InputStream loadContent(final String fileSpec, final RoamingType roamingType) throws IOException {\n        if (StoragePathMacros.WORKSPACE_FILE.equals(fileSpec)) {\n          return loadUserPreferences(createBuilderInt(fileSpec));\n        }\n        else {\n          return null;\n        }\n      }\n    }, RoamingType.PER_USER);\n  }","id":60592,"modified_method":"public void registerProjectLevelProviders(Project project) {\n    String projectKey = getProjectId(project);\n    StateStorageManager manager = ((ProjectEx)project).getStateStore().getStateStorageManager();\n    manager.registerStreamProvider(new ICSStreamProvider(projectKey, RoamingType.PER_PLATFORM), RoamingType.PER_PLATFORM);\n    manager.registerStreamProvider(new ICSStreamProvider(projectKey, RoamingType.PER_USER), RoamingType.PER_USER);\n  }","commit_id":"a6e5393b1e796a55da5fb37e8e9b8ebc03d05d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void registerApplicationLevelProviders(final Application application) {\n    settings.loadCredentials();\n\n    if (settings.REMEMBER_SETTINGS || GraphicsEnvironment.isHeadless()) {\n      if (settings.DO_LOGIN) {\n        if (settings.getUserName() != null && settings.getPassword() != null) {\n          performLogin();\n        }\n        else {\n          requestCredentials(\"Login failed, user name and password should not be empty\", true);\n        }\n      }\n    }\n    else {\n      requestCredentials(null, true);\n    }\n\n\n    StateStorageManager storageManager = ((ApplicationImpl)application).getStateStore().getStateStorageManager();\n    registerProvider(storageManager, RoamingType.PER_USER);\n    registerProvider(storageManager, RoamingType.PER_PLATFORM);\n    registerProvider(storageManager, RoamingType.GLOBAL);\n  }","id":60593,"modified_method":"public void registerApplicationLevelProviders(Application application) {\n    settings.load();\n\n    if (settings.REMEMBER_SETTINGS || GraphicsEnvironment.isHeadless()) {\n      if (settings.DO_LOGIN) {\n        if (settings.getUserName() != null && settings.getPassword() != null) {\n          login();\n        }\n        else {\n          requestCredentials(\"Login failed, user name and password should not be empty\", true);\n        }\n      }\n    }\n    else {\n      requestCredentials(null, true);\n    }\n\n    StateStorageManager storageManager = ((ApplicationImpl)application).getStateStore().getStateStorageManager();\n    registerProvider(storageManager, RoamingType.PER_USER);\n    registerProvider(storageManager, RoamingType.PER_PLATFORM);\n    registerProvider(storageManager, RoamingType.GLOBAL);\n  }","commit_id":"a6e5393b1e796a55da5fb37e8e9b8ebc03d05d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Document createCredentialsDocument() {\n    Element user = new Element(\"user\");\n    if (myUserName != null) user.setAttribute(LOGIN, myUserName);\n    if (myPassword != null) user.setAttribute(PASSWORD, PasswordUtil.encodePassword(myPassword));\n    user.setAttribute(REMEMBER_SETTINGS_ATTR, String.valueOf(REMEMBER_SETTINGS));\n    user.setAttribute(DO_LOGIN_ATTR, String.valueOf(DO_LOGIN));\n    user.setAttribute(SETTINGS_LOADED_ATTR, String.valueOf(mySettingsAlreadySynchronized));\n    try {\n      myProxySettings.writeExternal(user);\n    }\n    catch (WriteExternalException e) {\n      //ignore\n    }\n    return new Document(user);\n  }","id":60594,"modified_method":"private Document createCredentialsDocument() {\n    Element user = new Element(\"user\");\n    if (userName != null) {\n      user.setAttribute(LOGIN, userName);\n    }\n    if (password != null) {\n      user.setAttribute(PASSWORD, PasswordUtil.encodePassword(password));\n    }\n    user.setAttribute(REMEMBER_SETTINGS_ATTR, String.valueOf(REMEMBER_SETTINGS));\n    user.setAttribute(DO_LOGIN_ATTR, String.valueOf(DO_LOGIN));\n    user.setAttribute(SETTINGS_LOADED_ATTR, String.valueOf(settingsAlreadySynchronized));\n    try {\n      proxySettings.writeExternal(user);\n    }\n    catch (WriteExternalException e) {\n      //ignore\n    }\n    return new Document(user);\n  }","commit_id":"a6e5393b1e796a55da5fb37e8e9b8ebc03d05d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public IdeaConfigurationServerSettings() {\n    settingsFile = new File(PathManager.getSystemPath(), \"idea-server/server-credentials.xml\");\n  }","id":60595,"modified_method":"public IdeaConfigurationServerSettings() {\n    settingsFile = new File(PathManager.getSystemPath(), \"ideaConfigurationServer/state.xml\");\n  }","commit_id":"a6e5393b1e796a55da5fb37e8e9b8ebc03d05d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getUserName() {\n    return myUserName;\n  }","id":60596,"modified_method":"public String getUserName() {\n    return userName;\n  }","commit_id":"a6e5393b1e796a55da5fb37e8e9b8ebc03d05d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void update(final String login, final String password) {\n    myUserName = login;\n    myPassword = password;\n  }","id":60597,"modified_method":"public void update(final String login, final String password) {\n    userName = login;\n    this.password = password;\n  }","commit_id":"a6e5393b1e796a55da5fb37e8e9b8ebc03d05d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean wereSettingsSynchronized() {\n    return mySettingsAlreadySynchronized;\n  }","id":60598,"modified_method":"public boolean wereSettingsSynchronized() {\n    return settingsAlreadySynchronized;\n  }","commit_id":"a6e5393b1e796a55da5fb37e8e9b8ebc03d05d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void settingsWereSynchronized() {\n    mySettingsAlreadySynchronized = true;\n  }","id":60599,"modified_method":"public void settingsWereSynchronized() {\n    settingsAlreadySynchronized = true;\n  }","commit_id":"a6e5393b1e796a55da5fb37e8e9b8ebc03d05d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getPassword() {\n    return myPassword;\n  }","id":60600,"modified_method":"public String getPassword() {\n    return password;\n  }","commit_id":"a6e5393b1e796a55da5fb37e8e9b8ebc03d05d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void logout() {\n    sessionId = null;\n    setStatus(IdeaConfigurationServerStatus.LOGGED_OUT);\n  }","id":60601,"modified_method":"public void logout() {\n    setStatus(IdeaConfigurationServerStatus.LOGGED_OUT);\n  }","commit_id":"a6e5393b1e796a55da5fb37e8e9b8ebc03d05d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public HttpConfigurable getHttpProxySettings() {\n    return myProxySettings;\n  }","id":60602,"modified_method":"public HttpConfigurable getHttpProxySettings() {\n    return proxySettings;\n  }","commit_id":"a6e5393b1e796a55da5fb37e8e9b8ebc03d05d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void doPostImpl(final IdeaServerUrlBuilder builder, final String actionName, File file, ContentProcessor processor, boolean relogin)\n    throws IOException {\n    try {\n      final Pair<HttpClient, HttpConnection> pair = createConnection(builder);\n\n      try {\n        final PostMethod postMethod = new PostMethod(builder.getServerUrl() + \"/\" + actionName);\n\n        postMethod.setQueryString(builder.getQueryString());\n\n\n        final BufferedInputStream content = file != null ? new BufferedInputStream(new FileInputStream(file)) : null;\n        try {\n          if (content != null) {\n            postMethod.setRequestEntity(new InputStreamRequestEntity(content, file.length()));\n          }\n\n      /*an attempt to pass proxy credentials to Apache HttpClient API used for connection\n      -> with no success since Apache only pass credentials if secure connection protocol is used (a bug)\n       did not work before common proxy, so keep as is for now*/\n          postMethod.execute(pair.getFirst().getState(), pair.getSecond());\n\n          int code = postMethod.getStatusCode();\n          if (code != HttpStatus.SC_OK) {\n\n            String reason = postMethod.getResponseBodyAsString().trim();\n\n            if (relogin && HttpStatus.SC_UNAUTHORIZED == code && (\"Session expired\".equals(reason) || \"Session disconnected\".equals(reason))) {\n              String sessionId = login(builder.createLoginBuilder());\n              builder.updateSessionId(sessionId);\n              doPostImpl(builder, actionName, file, processor, false);\n              return;\n            }\n\n            else if (HttpStatus.SC_UNAUTHORIZED == code) {\n              builder.setUnauthorizedStatus();\n              return;\n            }\n\n            else if (HttpStatus.SC_SERVICE_UNAVAILABLE == code) {\n              builder.setDisconnectedStatus();\n              return;\n            }\n\n            else {\n              throw new IOException(reason);\n            }\n          }\n\n          InputStream in = postMethod.getResponseBodyAsStream();\n          try {\n            processor.processStream(in);\n          }\n          finally {\n            in.close();\n          }\n        }\n        finally {\n          if (content != null) {\n            content.close();\n          }\n        }\n      }\n      finally {\n        pair.getSecond().close();\n      }\n    }\n    catch (ConnectException e) {\n      builder.setDisconnectedStatus();\n    }\n  }","id":60603,"modified_method":"private static void doPostImpl(final IdeaServerUrlBuilder builder, final String actionName, File file, ContentProcessor processor)\n    throws IOException {\n    try {\n      final Pair<HttpClient, HttpConnection> pair = createConnection(builder);\n\n      try {\n        final PostMethod postMethod = new PostMethod(builder.getServerUrl() + \"/\" + actionName);\n\n        postMethod.setQueryString(builder.getQueryString());\n\n\n        final BufferedInputStream content = file != null ? new BufferedInputStream(new FileInputStream(file)) : null;\n        try {\n          if (content != null) {\n            postMethod.setRequestEntity(new InputStreamRequestEntity(content, file.length()));\n          }\n\n      /*an attempt to pass proxy credentials to Apache HttpClient API used for connection\n      -> with no success since Apache only pass credentials if secure connection protocol is used (a bug)\n       did not work before common proxy, so keep as is for now*/\n          postMethod.execute(pair.getFirst().getState(), pair.getSecond());\n\n          int code = postMethod.getStatusCode();\n          if (code != HttpStatus.SC_OK) {\n\n            String reason = postMethod.getResponseBodyAsString().trim();\n            if (HttpStatus.SC_UNAUTHORIZED == code) {\n              builder.setUnauthorizedStatus();\n              return;\n            }\n\n            else if (HttpStatus.SC_SERVICE_UNAVAILABLE == code) {\n              builder.setDisconnectedStatus();\n              return;\n            }\n\n            else {\n              throw new IOException(reason);\n            }\n          }\n\n          InputStream in = postMethod.getResponseBodyAsStream();\n          try {\n            processor.processStream(in);\n          }\n          finally {\n            in.close();\n          }\n        }\n        finally {\n          if (content != null) {\n            content.close();\n          }\n        }\n      }\n      finally {\n        pair.getSecond().close();\n      }\n    }\n    catch (ConnectException e) {\n      builder.setDisconnectedStatus();\n    }\n  }","commit_id":"a6e5393b1e796a55da5fb37e8e9b8ebc03d05d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static String[] listSubFileNames(IdeaServerUrlBuilder builder) throws IOException {\n    final List<String> result = new ArrayList<String>();\n    doPost(builder, \"list\", null, new ContentProcessor() {\n      public void processStream(final InputStream stream) throws IOException {\n        final BufferedReader reader = new BufferedReader(new InputStreamReader(stream));\n        String line;\n        while ((line = reader.readLine()) != null) {\n          if (line.length() > 0) {\n            result.add(line);\n          }\n        }\n      }\n    });\n    return ArrayUtil.toStringArray(result);\n  }","id":60604,"modified_method":"public static String[] listSubFileNames(IdeaServerUrlBuilder builder) throws IOException {\n    final List<String> result = new ArrayList<String>();\n    doPost(builder, \"list\", null, new ContentProcessor() {\n      @Override\n      public void processStream(final InputStream stream) throws IOException {\n        final BufferedReader reader = new BufferedReader(new InputStreamReader(stream));\n        String line;\n        while ((line = reader.readLine()) != null) {\n          if (line.length() > 0) {\n            result.add(line);\n          }\n        }\n      }\n    });\n    return ArrayUtil.toStringArray(result);\n  }","commit_id":"a6e5393b1e796a55da5fb37e8e9b8ebc03d05d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private IdeaServerConnector() {\n  }","id":60605,"modified_method":"public IdeaServerConnector() throws IOException {\n    File gitDir = new File(PathManager.getSystemPath(), \"ideaConfigurationServer/data\");\n    FileRepositoryBuilder repositoryBuilder = new FileRepositoryBuilder();\n    repositoryBuilder.setGitDir(new File(gitDir, Constants.DOT_GIT));\n    repository = repositoryBuilder.build();\n    if (!gitDir.exists()) {\n      repository.create();\n    }\n\n    // todo sync with remote\n  }","commit_id":"a6e5393b1e796a55da5fb37e8e9b8ebc03d05d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void doPost(final IdeaServerUrlBuilder builder, final String actionName, File input, ContentProcessor processor)\n    throws IOException {\n    doPostImpl(builder, actionName, input, processor, builder.isReloginAutomatically());\n  }","id":60606,"modified_method":"private static void doPost(final IdeaServerUrlBuilder builder, final String actionName, File input, ContentProcessor processor)\n    throws IOException {\n    doPostImpl(builder, actionName, input, processor);\n  }","commit_id":"a6e5393b1e796a55da5fb37e8e9b8ebc03d05d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public IdeaServerUrlBuilder(final String filePath, final RoamingType roamingType, String projectKey, String sessionId,\n                              String login, String password) {\n    this.filePath = filePath;\n    this.roamingType = roamingType;\n    this.projectKey = projectKey;\n    mySessionId = sessionId;\n    myLogin = login;\n    myPassword = password;\n  }","id":60607,"modified_method":"public IdeaServerUrlBuilder(final String filePath, final RoamingType roamingType, String projectKey) {\n    this.filePath = filePath;\n    this.roamingType = roamingType;\n    this.projectKey = projectKey;\n  }","commit_id":"a6e5393b1e796a55da5fb37e8e9b8ebc03d05d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public NameValuePair[] getPingQueryString() {\n    return new NameValuePair[]{\n      new NameValuePair(\"session\", mySessionId)\n    };\n  }","id":60608,"modified_method":"public NameValuePair[] getPingQueryString() {\n    return new NameValuePair[]{\n    };\n  }","commit_id":"a6e5393b1e796a55da5fb37e8e9b8ebc03d05d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public NameValuePair[] getQueryString() {\n    if (roamingType != RoamingType.GLOBAL) {\n      return new NameValuePair[]{\n        new NameValuePair(\"session\", mySessionId),\n        new NameValuePair(\"path\", buildPath())\n      };\n    }\n    else {\n      return new NameValuePair[]{\n        new NameValuePair(\"session\", mySessionId),\n        new NameValuePair(\"path\", buildPath()),\n        new NameValuePair(\"global\", \"true\")\n      };\n    }\n  }","id":60609,"modified_method":"public NameValuePair[] getQueryString() {\n    if (roamingType != RoamingType.GLOBAL) {\n      return new NameValuePair[]{\n        new NameValuePair(\"path\", buildPath())\n      };\n    }\n    else {\n      return new NameValuePair[]{\n        new NameValuePair(\"path\", buildPath()),\n        new NameValuePair(\"global\", \"true\")\n      };\n    }\n  }","commit_id":"a6e5393b1e796a55da5fb37e8e9b8ebc03d05d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doLogin(final boolean onTimer) {\n    try {\n      IdeaConfigurationServerSettings settings = IdeaConfigurationServerManager.getInstance().getIdeaServerSettings();\n\n      myProxySettingsPanel.apply();\n\n\n      settings.update(myLogin.getText(), new String(myPassword.getPassword()));\n      IdeaConfigurationServerManager.getInstance().login();\n      closeDialog(true);\n    }\n    catch (ConnectException e) {\n      showErrorMessage(prepareMessage(exceptionMessage(e)), onTimer);\n      if (onTimer) {\n        closeDialog(true);\n      }\n      else {\n        myTimerLabel.stopCounter();\n      }\n    }\n    catch (Exception e) {\n      showErrorMessage(prepareMessage(exceptionMessage(e)), onTimer);\n      if (onTimer) {\n        closeDialog(true);\n      }\n      else {\n        myTimerLabel.stopCounter();\n      }\n    }\n  }","id":60610,"modified_method":"private void doLogin(final boolean onTimer) {\n    try {\n      IdeaConfigurationServerSettings settings = IdeaConfigurationServerManager.getInstance().getIdeaServerSettings();\n\n      myProxySettingsPanel.apply();\n\n\n      settings.update(myLogin.getText(), new String(myPassword.getPassword()));\n      IdeaConfigurationServerManager.getInstance().login();\n      closeDialog(true);\n    }\n    catch (Exception e) {\n      showErrorMessage(prepareMessage(exceptionMessage(e)), onTimer);\n      if (onTimer) {\n        closeDialog(true);\n      }\n      else {\n        myTimerLabel.stopCounter();\n      }\n    }\n  }","commit_id":"a6e5393b1e796a55da5fb37e8e9b8ebc03d05d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static Map postItem(String token, String postItemsUrl, String developerKey, StringBuffer dataItems) throws IOException {\n        HttpURLConnection connection = (HttpURLConnection)(new URL(postItemsUrl)).openConnection();\n      \n        connection.setDoInput(true);\n        connection.setDoOutput(true);\n        connection.setRequestMethod(\"POST\");\n        connection.setRequestProperty(\"Content-Type\", \"application/atom+xml\");\n        connection.setRequestProperty(\"Authorization\", \"GoogleLogin auth=\" + token);\n        connection.setRequestProperty(\"X-Google-Key\", \"key=\" + developerKey);\n    \n        OutputStream outputStream = connection.getOutputStream();\n        outputStream.write(dataItems.toString().getBytes());\n        outputStream.close();\n    \n        int responseCode = connection.getResponseCode();\n        InputStream inputStream;\n        Map result = FastMap.newInstance();\n        if (responseCode == HttpURLConnection.HTTP_CREATED) {\n            inputStream = connection.getInputStream();\n            result = ServiceUtil.returnSuccess(toString(inputStream));\n        } else if (responseCode == HttpURLConnection.HTTP_OK) {\n            inputStream = connection.getInputStream();\n            result = ServiceUtil.returnSuccess(toString(inputStream));\n        } else {\n            inputStream = connection.getErrorStream();\n            result = ServiceUtil.returnFailure(toString(inputStream));\n        }\n        return result;\n    }","id":60611,"modified_method":"private static Map postItem(String token, String postItemsUrl, String developerKey, StringBuffer dataItems, Locale locale) throws IOException {\n        HttpURLConnection connection = (HttpURLConnection)(new URL(postItemsUrl)).openConnection();\n      \n        connection.setDoInput(true);\n        connection.setDoOutput(true);\n        connection.setRequestMethod(\"POST\");\n        connection.setRequestProperty(\"Content-Type\", \"application/atom+xml\");\n        connection.setRequestProperty(\"Authorization\", \"GoogleLogin auth=\" + token);\n        connection.setRequestProperty(\"X-Google-Key\", \"key=\" + developerKey);\n    \n        OutputStream outputStream = connection.getOutputStream();\n        outputStream.write(dataItems.toString().getBytes());\n        outputStream.close();\n    \n        int responseCode = connection.getResponseCode();\n        InputStream inputStream;\n        Map result = FastMap.newInstance();\n        if (responseCode == HttpURLConnection.HTTP_CREATED || responseCode == HttpURLConnection.HTTP_OK) {\n            inputStream = connection.getInputStream();\n            String response = toString(inputStream);\n            if (response != null && response.length() > 0) {\n                result = readResponseFromGoogle(response, locale);\n                String msg = ServiceUtil.getErrorMessage(result);\n                if (msg != null && msg.length() > 0) {\n                    return ServiceUtil.returnFailure(msg);\n                } else {\n                    return ServiceUtil.returnSuccess();\n                }\n            } \n        } else {\n            inputStream = connection.getErrorStream();\n            result = ServiceUtil.returnFailure(toString(inputStream));\n        }\n        return result;\n    }","commit_id":"5b31c71520de67facad2405c66ef5310a21f1a72","url":"https://github.com/apache/ofbiz"},{"original_method":"public static Map exportToGoogle(DispatchContext dctx, Map context) {\n        Locale locale = (Locale) context.get(\"locale\");\n        try {\n            String configString = \"productsExport.properties\";\n                            \n            // get the Developer Key\n            String developerKey = UtilProperties.getPropertyValue(configString, \"productsExport.google.developerKey\");\n            \n            // get the Authentication Url\n            String authenticationUrl = UtilProperties.getPropertyValue(configString, \"productsExport.google.authenticationUrl\");\n            \n            // get the Google Account Email\n            String accountEmail = UtilProperties.getPropertyValue(configString, \"productsExport.google.accountEmail\");\n            \n            // get the Google Account Password\n            String accountPassword = UtilProperties.getPropertyValue(configString, \"productsExport.google.accountPassword\");\n            \n            // get the Url to Post Items\n            String postItemsUrl = UtilProperties.getPropertyValue(configString, \"productsExport.google.postItemsUrl\");\n        \n            StringBuffer dataItemsXml = new StringBuffer();\n            \n            Map result = buildDataItemsXml(dctx, context, dataItemsXml);\n            if (!ServiceUtil.isFailure(result)) { \n                String token = authenticate(authenticationUrl, accountEmail, accountPassword);\n\n                if (token != null) {    \n                    result = postItem(token, postItemsUrl, developerKey, dataItemsXml);\n                    if (ServiceUtil.isFailure(result))\n                        return ServiceUtil.returnFailure(ServiceUtil.getErrorMessage(result));\n                } else {\n                    Debug.logError(\"Error during authentication to Google Account\", module);\n                    return ServiceUtil.returnFailure(UtilProperties.getMessage(resource, \"productsExportToGoogle.errorDuringAuthenticationToGoogle\", locale));\n                }\n            } else {\n                return ServiceUtil.returnFailure(ServiceUtil.getErrorMessage(result));\n            }\n        } catch (Exception e) {        \n            Debug.logError(\"Exception in exportToGoogle\", module);\n            return ServiceUtil.returnFailure(UtilProperties.getMessage(resource, \"productsExportToGoogle.exceptionInExportToGoogle\", locale));\n        }\n        return ServiceUtil.returnSuccess(UtilProperties.getMessage(resource, \"productsExportToGoogle.productItemsSentCorrecltyToGoogle\", locale));\n    }","id":60612,"modified_method":"public static Map exportToGoogle(DispatchContext dctx, Map context) {\n        Locale locale = (Locale) context.get(\"locale\");\n        try {\n            String configString = \"productsExport.properties\";\n                            \n            // get the Developer Key\n            String developerKey = UtilProperties.getPropertyValue(configString, \"productsExport.google.developerKey\");\n            \n            // get the Authentication Url\n            String authenticationUrl = UtilProperties.getPropertyValue(configString, \"productsExport.google.authenticationUrl\");\n            \n            // get the Google Account Email\n            String accountEmail = UtilProperties.getPropertyValue(configString, \"productsExport.google.accountEmail\");\n            \n            // get the Google Account Password\n            String accountPassword = UtilProperties.getPropertyValue(configString, \"productsExport.google.accountPassword\");\n            \n            // get the Url to Post Items\n            String postItemsUrl = UtilProperties.getPropertyValue(configString, \"productsExport.google.postItemsUrl\");\n        \n            StringBuffer dataItemsXml = new StringBuffer();\n            \n            Map result = buildDataItemsXml(dctx, context, dataItemsXml);\n            if (!ServiceUtil.isFailure(result)) { \n                String token = authenticate(authenticationUrl, accountEmail, accountPassword);\n                if (token != null) {    \n                    result = postItem(token, postItemsUrl, developerKey, dataItemsXml, locale);\n                    String msg = ServiceUtil.getErrorMessage(result);\n                    if (msg != null && msg.length() > 0) {\n                        return ServiceUtil.returnFailure(msg);\n                    }\n                } else {\n                    Debug.logError(\"Error during authentication to Google Account\", module);\n                    return ServiceUtil.returnFailure(UtilProperties.getMessage(resource, \"productsExportToGoogle.errorDuringAuthenticationToGoogle\", locale));\n                }\n            } else {\n                return ServiceUtil.returnFailure(ServiceUtil.getErrorMessage(result));\n            }\n        } catch (Exception e) {        \n            Debug.logError(\"Exception in exportToGoogle\", module);\n            return ServiceUtil.returnFailure(UtilProperties.getMessage(resource, \"productsExportToGoogle.exceptionInExportToGoogle\", locale));\n        }\n        return ServiceUtil.returnSuccess(UtilProperties.getMessage(resource, \"productsExportToGoogle.productItemsSentCorrecltyToGoogle\", locale));\n    }","commit_id":"5b31c71520de67facad2405c66ef5310a21f1a72","url":"https://github.com/apache/ofbiz"},{"original_method":"private static String authenticate(String authenticationUrl, String accountEmail, String accountPassword) {\n        String postOutput = null;\n        String token = null;\n        try {\n            postOutput = makeLoginRequest(authenticationUrl, accountEmail, accountPassword);\n        } catch (IOException e) {\n            Debug.logError(\"Could not connect to authentication server: \" + e.toString(), module);\n            return token;\n        }\n\n        // Parse the result of the login request. If everything went fine, the \n        // response will look like\n        //      HTTP/1.0 200 OK\n        //      Server: GFE/1.3\n        //      Content-Type: text/plain \n        //      SID=DQAAAGgA...7Zg8CTN\n        //      LSID=DQAAAGsA...lk8BBbG\n        //      Auth=DQAAAGgA...dk3fA5N\n        // so all we need to do is look for \"Auth\" and get the token that comes after it\n\n        StringTokenizer tokenizer = new StringTokenizer(postOutput, \"=\\n \");\n      \n        while (tokenizer.hasMoreElements()) {\n            if (tokenizer.nextToken().equals(\"Auth\")) {\n                if (tokenizer.hasMoreElements()) {\n                    token = tokenizer.nextToken(); \n                }\n                break;\n            }\n        }\n        if (token == null) {\n            Debug.logError(\"Authentication error. Response from server:\\n\" + postOutput, module);\n        }\n        return token;\n    }","id":60613,"modified_method":"private static String authenticate(String authenticationUrl, String accountEmail, String accountPassword) {\n        String postOutput = null;\n        String token = null;\n        try {\n            postOutput = makeLoginRequest(authenticationUrl, accountEmail, accountPassword);\n        } catch (IOException e) {\n            Debug.logError(\"Could not connect to authentication server: \" + e.toString(), module);\n            return token;\n        }\n\n        // Parse the result of the login request. If everything went fine, the \n        // response will look like\n        //      HTTP/1.0 200 OK\n        //      Server: GFE/1.3\n        //      Content-Type: text/plain \n        //      SID=DQAAAGgA...7Zg8CTN\n        //      LSID=DQAAAGsA...lk8BBbG\n        //      Auth=DQAAAGgA...dk3fA5N\n        // so all we need to do is look for \"Auth\" and get the token that comes after it\n\n        StringTokenizer tokenizer = new StringTokenizer(postOutput, \"=\\n \");\n      \n        while (tokenizer.hasMoreElements()) {\n            if (\"Auth\".equals(tokenizer.nextToken())) {\n                if (tokenizer.hasMoreElements()) {\n                    token = tokenizer.nextToken(); \n                }\n                break;\n            }\n        }\n        if (token == null) {\n            Debug.logError(\"Authentication error. Response from server:\\n\" + postOutput, module);\n        }\n        return token;\n    }","commit_id":"5b31c71520de67facad2405c66ef5310a21f1a72","url":"https://github.com/apache/ofbiz"},{"original_method":"private static Map buildDataItemsXml(DispatchContext dctx, Map context, StringBuffer dataItemsXml) {\n        Locale locale = (Locale)context.get(\"locale\");\n        try {\n             GenericDelegator delegator = dctx.getDelegator();\n             LocalDispatcher dispatcher = dctx.getDispatcher();\n             List selectResult = (List)context.get(\"selectResult\");\n             String webSiteUrl = (String)context.get(\"webSiteUrl\");\n             String imageUrl = (String)context.get(\"imageUrl\");\n             String actionType = (String)context.get(\"actionType\");\n             String statusId = (String)context.get(\"statusId\");\n             String trackingCodeId = (String)context.get(\"trackingCodeId\");\n             \n             // Get the list of products to be exported to Google Base\n             List productsList  = delegator.findByCondition(\"Product\", new EntityExpr(\"productId\", EntityOperator.IN, selectResult), null, null);\n             \n             // Get the tracking code\n             if (UtilValidate.isEmpty(trackingCodeId) || \"_NA_\".equals(trackingCodeId)) {\n                 trackingCodeId = \"\";\n             } else {\n                 trackingCodeId = \"?atc=\" + trackingCodeId;\n             }\n             \n             try {\n                 Document feedDocument = UtilXml.makeEmptyXmlDocument(\"feed\");\n                 Element feedElem = feedDocument.getDocumentElement();\n                 feedElem.setAttribute(\"xmlns\", \"http://www.w3.org/2005/Atom\");\n                 feedElem.setAttribute(\"xmlns:openSearch\", \"http://a9.com/-/spec/opensearchrss/1.0/\");\n                 feedElem.setAttribute(\"xmlns:g\", \"http://base.google.com/ns/1.0\");\n                 feedElem.setAttribute(\"xmlns:batch\", \"http://schemas.google.com/gdata/batch\");\n                 \n                 // Iterate the product list getting all the relevant data\n                 Iterator productsListItr = productsList.iterator();\n                 while(productsListItr.hasNext()) {\n                     GenericValue prod = (GenericValue)productsListItr.next();\n                     String price = getProductPrice(dispatcher, prod);\n                     if (price == null) {\n                         Debug.logInfo(\"Price not found for product [\" + prod.getString(\"productId\")+ \"]; product will not be exported.\", module);\n                         continue;\n                     }\n                     String link = webSiteUrl + \"/control/product/~product_id=\" + prod.getString(\"productId\") + trackingCodeId;\n                     String title = UtilFormatOut.encodeXmlValue(prod.getString(\"productName\"));\n                     String description = UtilFormatOut.encodeXmlValue(prod.getString(\"description\"));\n                     String image_link = \"\";\n                     if (UtilValidate.isNotEmpty(prod.getString(\"largeImageUrl\"))) {\n                         image_link = imageUrl + prod.getString(\"largeImageUrl\");\n                     }\n                     \n                     Element entryElem = UtilXml.addChildElement(feedElem, \"entry\", feedDocument);\n                     Element batchElem = UtilXml.addChildElement(entryElem, \"batch:operation\", feedDocument);\n                     batchElem.setAttribute(\"type\", actionType);\n                     \n                     UtilXml.addChildElementValue(entryElem, \"title\", title, feedDocument);\n                     \n                     Element contentElem = UtilXml.addChildElementValue(entryElem, \"content\", description, feedDocument);\n                     contentElem.setAttribute(\"type\", \"xhtml\");\n                     \n                     UtilXml.addChildElementValue(entryElem, \"id\", link, feedDocument);\n                     \n                     Element linkElem = UtilXml.addChildElement(entryElem, \"link\", feedDocument);\n                     linkElem.setAttribute(\"rel\", \"alternate\");\n                     linkElem.setAttribute(\"type\", \"text/html\");\n                     linkElem.setAttribute(\"href\", link);\n                     \n                     UtilXml.addChildElementValue(entryElem, \"g:item_type\", \"products\", feedDocument);\n                     UtilXml.addChildElementValue(entryElem, \"g:price\", price, feedDocument);\n                     \n                     if (UtilValidate.isNotEmpty(image_link)) {\n                         UtilXml.addChildElementValue(entryElem, \"g:image_link\", image_link, feedDocument);\n                     }\n                     \n                     Element appControlElem = UtilXml.addChildElement(entryElem, \"app:control\", feedDocument);\n                     appControlElem.setAttribute(\"xmlns:app\", \"http://purl.org/atom/app#\");\n                     UtilXml.addChildElementValue(appControlElem, \"app:draft\", \"yes\", feedDocument);\n                 }\n                 \n                 dataItemsXml.append(UtilXml.writeXmlDocument(feedDocument));\n             } catch (Exception e) {\n                 Debug.logError(\"Exception during building data items to Google\", module);\n                 return ServiceUtil.returnFailure(UtilProperties.getMessage(resource, \"productsExportToGoogle.exceptionDuringBuildingDataItemsToGoogle\", locale));\n             }\n         } catch (Exception e) {\n            Debug.logError(\"Exception during building data items to Google\", module);\n            return ServiceUtil.returnFailure(UtilProperties.getMessage(resource, \"productsExportToGoogle.exceptionDuringBuildingDataItemsToGoogle\", locale));\n         } \n         return ServiceUtil.returnSuccess();\n    }","id":60614,"modified_method":"private static Map buildDataItemsXml(DispatchContext dctx, Map context, StringBuffer dataItemsXml) {\n        Locale locale = (Locale)context.get(\"locale\");\n        try {\n             GenericDelegator delegator = dctx.getDelegator();\n             LocalDispatcher dispatcher = dctx.getDispatcher();\n             List selectResult = (List)context.get(\"selectResult\");\n             String webSiteUrl = (String)context.get(\"webSiteUrl\");\n             String imageUrl = (String)context.get(\"imageUrl\");\n             String actionType = (String)context.get(\"actionType\");\n             String statusId = (String)context.get(\"statusId\");\n             String trackingCodeId = (String)context.get(\"trackingCodeId\");\n             \n             // Get the list of products to be exported to Google Base\n             List productsList  = delegator.findByCondition(\"Product\", new EntityExpr(\"productId\", EntityOperator.IN, selectResult), null, null);\n             \n             // Get the tracking code\n             if (UtilValidate.isEmpty(trackingCodeId) || \"_NA_\".equals(trackingCodeId)) {\n                 trackingCodeId = \"\";\n             } else {\n                 trackingCodeId = \"?atc=\" + trackingCodeId;\n             }\n             \n             try {\n                 Document feedDocument = UtilXml.makeEmptyXmlDocument(\"feed\");\n                 Element feedElem = feedDocument.getDocumentElement();\n                 feedElem.setAttribute(\"xmlns\", \"http://www.w3.org/2005/Atom\");\n                 feedElem.setAttribute(\"xmlns:openSearch\", \"http://a9.com/-/spec/opensearchrss/1.0/\");\n                 feedElem.setAttribute(\"xmlns:g\", \"http://base.google.com/ns/1.0\");\n                 feedElem.setAttribute(\"xmlns:batch\", \"http://schemas.google.com/gdata/batch\");\n                 \n                 // Iterate the product list getting all the relevant data\n                 Iterator productsListItr = productsList.iterator();\n                 while(productsListItr.hasNext()) {\n                     GenericValue prod = (GenericValue)productsListItr.next();\n                     String price = getProductPrice(dispatcher, prod);\n                     if (price == null) {\n                         Debug.logInfo(\"Price not found for product [\" + prod.getString(\"productId\")+ \"]; product will not be exported.\", module);\n                         continue;\n                     }\n                     String link = webSiteUrl + \"/control/product/~product_id=\" + prod.getString(\"productId\") + trackingCodeId;\n                     String title = UtilFormatOut.encodeXmlValue(prod.getString(\"productName\"));\n                     String description = UtilFormatOut.encodeXmlValue(prod.getString(\"description\"));\n                     String image_link = \"\";\n                     if (UtilValidate.isNotEmpty(prod.getString(\"largeImageUrl\"))) {\n                         image_link = imageUrl + prod.getString(\"largeImageUrl\");\n                     }\n                     \n                     Element entryElem = UtilXml.addChildElement(feedElem, \"entry\", feedDocument);\n                     Element batchElem = UtilXml.addChildElement(entryElem, \"batch:operation\", feedDocument);\n                     batchElem.setAttribute(\"type\", actionType);\n                     \n                     // status is draft or deactivate\n                     if (statusId != null && (\"draft\".equals(statusId) || \"deactivate\".equals(statusId))) {\n                         Element appControlElem = UtilXml.addChildElement(entryElem, \"app:control\", feedDocument);\n                         appControlElem.setAttribute(\"xmlns:app\", \"http://purl.org/atom/app&#35;\");\n                         UtilXml.addChildElementValue(appControlElem, \"app:draft\", \"yes\", feedDocument);\n                         \n                         // status is deactivate\n                         if (\"deactivate\".equals(statusId)) {\n                             UtilXml.addChildElement(appControlElem, \"gm:disapproved\", feedDocument);\n                         }\n                     }\n                     \n                     UtilXml.addChildElementValue(entryElem, \"title\", title, feedDocument);\n                     \n                     Element contentElem = UtilXml.addChildElementValue(entryElem, \"content\", description, feedDocument);\n                     contentElem.setAttribute(\"type\", \"xhtml\");\n                     \n                     UtilXml.addChildElementValue(entryElem, \"id\", link, feedDocument);\n                     \n                     Element linkElem = UtilXml.addChildElement(entryElem, \"link\", feedDocument);\n                     linkElem.setAttribute(\"rel\", \"alternate\");\n                     linkElem.setAttribute(\"type\", \"text/html\");\n                     linkElem.setAttribute(\"href\", link);\n                     \n                     UtilXml.addChildElementValue(entryElem, \"g:item_type\", \"products\", feedDocument);\n                     UtilXml.addChildElementValue(entryElem, \"g:price\", price, feedDocument);\n                     \n                     // if the product has an image it will be published on Google Product Search\n                     if (UtilValidate.isNotEmpty(image_link)) {\n                         UtilXml.addChildElementValue(entryElem, \"g:image_link\", image_link, feedDocument);\n                     }\n                 }\n                 \n                 dataItemsXml.append(UtilXml.writeXmlDocument(feedDocument));\n             } catch (Exception e) {\n                 Debug.logError(\"Exception during building data items to Google\", module);\n                 return ServiceUtil.returnFailure(UtilProperties.getMessage(resource, \"productsExportToGoogle.exceptionDuringBuildingDataItemsToGoogle\", locale));\n             }\n         } catch (Exception e) {\n            Debug.logError(\"Exception during building data items to Google\", module);\n            return ServiceUtil.returnFailure(UtilProperties.getMessage(resource, \"productsExportToGoogle.exceptionDuringBuildingDataItemsToGoogle\", locale));\n         } \n         return ServiceUtil.returnSuccess();\n    }","commit_id":"5b31c71520de67facad2405c66ef5310a21f1a72","url":"https://github.com/apache/ofbiz"},{"original_method":"protected void inspectDDMFormEvaluationResult(\n\t\t\tDDMFormEvaluationResult ddmFormEvaluationResult)\n\t\tthrows DDMFormEvaluationException {\n\n\t\tMap<String, DDMFormFieldEvaluationResult>\n\t\t\tddmFormFieldEvaluationResultsMap =\n\t\t\t\tddmFormEvaluationResult.getDDMFormFieldEvaluationResultsMap();\n\n\t\tStringBundler sb = new StringBundler(\n\t\t\tddmFormFieldEvaluationResultsMap.size() * 3);\n\n\t\tfor (Map.Entry<String, DDMFormFieldEvaluationResult> entry :\n\t\t\t\tddmFormFieldEvaluationResultsMap.entrySet()) {\n\n\t\t\tinspectDDMFormFieldEvaluationResult(entry, sb);\n\t\t}\n\n\t\tif (sb.index() > 0) {\n\t\t\tthrow new DDMFormEvaluationException(sb.toString());\n\t\t}\n\t}","id":60615,"modified_method":"protected void inspectDDMFormEvaluationResult(\n\t\t\tDDMFormEvaluationResult ddmFormEvaluationResult)\n\t\tthrows DDMFormValuesValidationException {\n\n\t\tMap<String, DDMFormFieldEvaluationResult>\n\t\t\tddmFormFieldEvaluationResultsMap =\n\t\t\t\tddmFormEvaluationResult.getDDMFormFieldEvaluationResultsMap();\n\n\t\tStringBundler sb = new StringBundler(\n\t\t\tddmFormFieldEvaluationResultsMap.size());\n\n\t\tfor (DDMFormFieldEvaluationResult ddmFormFieldEvaluationResult :\n\t\t\t\tddmFormFieldEvaluationResultsMap.values()) {\n\n\t\t\tinspectDDMFormFieldEvaluationResult(\n\t\t\t\tddmFormFieldEvaluationResult, sb);\n\t\t}\n\n\t\tif (sb.index() > 0) {\n\t\t\tthrow new MustSetValidValues(sb.toString());\n\t\t}\n\t}","commit_id":"f4b1091add677e30e87afcf8504b36212370c962","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void evaluateDDMFormFieldValidationExpressions(\n\t\t\tDDMFormValues ddmFormValues, DDMForm ddmForm)\n\t\tthrows DDMFormEvaluationException {\n\n\t\tDDMFormEvaluationResult ddmFormEvaluationResult =\n\t\t\t_ddmFormEvaluator.evaluate(\n\t\t\t\tddmForm, ddmFormValues, ddmFormValues.getDefaultLocale());\n\n\t\tinspectDDMFormEvaluationResult(ddmFormEvaluationResult);\n\t}","id":60616,"modified_method":"protected void evaluateDDMFormFieldValidationExpressions(\n\t\t\tDDMFormValues ddmFormValues, DDMForm ddmForm)\n\t\tthrows DDMFormValuesValidationException {\n\n\t\ttry {\n\t\t\tDDMFormEvaluationResult ddmFormEvaluationResult =\n\t\t\t\t_ddmFormEvaluator.evaluate(\n\t\t\t\t\tddmForm, ddmFormValues, ddmFormValues.getDefaultLocale());\n\n\t\t\tinspectDDMFormEvaluationResult(ddmFormEvaluationResult);\n\t\t}\n\t\tcatch (DDMFormEvaluationException ddmfee) {\n\t\t\tthrow new DDMFormValuesValidationException(ddmfee);\n\t\t}\n\t}","commit_id":"f4b1091add677e30e87afcf8504b36212370c962","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void inspectDDMFormFieldEvaluationResult(\n\t\tMap.Entry<String, DDMFormFieldEvaluationResult> entry,\n\t\tStringBundler sb) {\n\n\t\tDDMFormFieldEvaluationResult ddmFormFieldEvaluationResult =\n\t\t\tentry.getValue();\n\n\t\tif (!ddmFormFieldEvaluationResult.isValid()) {\n\t\t\tsb.append(entry.getKey().concat(StringPool.COLON));\n\t\t\tsb.append(ddmFormFieldEvaluationResult.getErrorMessage());\n\t\t\tsb.append(StringPool.NEW_LINE);\n\t\t}\n\t}","id":60617,"modified_method":"protected void inspectDDMFormFieldEvaluationResult(\n\t\tDDMFormFieldEvaluationResult ddmFormFieldEvaluationResult,\n\t\tStringBundler sb) {\n\n\t\tif (ddmFormFieldEvaluationResult.isValid()) {\n\t\t\treturn;\n\t\t}\n\n\t\tString errorMessage = String.format(\n\t\t\t\"%s : %s \\n\", ddmFormFieldEvaluationResult.getName(),\n\t\t\tddmFormFieldEvaluationResult.getErrorMessage());\n\n\t\tsb.append(errorMessage);\n\t}","commit_id":"f4b1091add677e30e87afcf8504b36212370c962","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void validateDDMFormFieldValue(\n\t\t\tDDMFormField ddmFormField, Set<Locale> availableLocales,\n\t\t\tLocale defaultLocale, Value value)\n\t\tthrows StorageException {\n\n\t\tif (Validator.isNull(ddmFormField.getDataType())) {\n\t\t\tif (value != null) {\n\t\t\t\tthrow new StorageFieldValueException(\n\t\t\t\t\t\"Value should not be set for field \" +\n\t\t\t\t\t\tddmFormField.getName());\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ((value == null) ||\n\t\t\t\t(ddmFormField.isRequired() && isNull(value))) {\n\n\t\t\t\tthrow new RequiredValue(ddmFormField.getName());\n\t\t\t}\n\n\t\t\tif ((ddmFormField.isLocalizable() && !value.isLocalized()) ||\n\t\t\t\t(!ddmFormField.isLocalizable() && value.isLocalized())) {\n\n\t\t\t\tthrow new StorageFieldValueException(\n\t\t\t\t\t\"Invalid value set for field \" + ddmFormField.getName());\n\t\t\t}\n\n\t\t\tvalidateDDMFormFieldValueLocales(\n\t\t\t\tddmFormField, availableLocales, defaultLocale, value);\n\t\t}\n\t}","id":60618,"modified_method":"protected void validateDDMFormFieldValue(\n\t\t\tDDMFormField ddmFormField, Set<Locale> availableLocales,\n\t\t\tLocale defaultLocale, Value value)\n\t\tthrows DDMFormValuesValidationException {\n\n\t\tif (Validator.isNull(ddmFormField.getDataType())) {\n\t\t\tif (value != null) {\n\t\t\t\tthrow new MustNotSetValue(ddmFormField.getName());\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ((value == null) ||\n\t\t\t\t(ddmFormField.isRequired() && isNull(value))) {\n\n\t\t\t\tthrow new RequiredValue(ddmFormField.getName());\n\t\t\t}\n\n\t\t\tif ((ddmFormField.isLocalizable() && !value.isLocalized()) ||\n\t\t\t\t(!ddmFormField.isLocalizable() && value.isLocalized())) {\n\n\t\t\t\tthrow new MustSetValidValue(ddmFormField.getName());\n\t\t\t}\n\n\t\t\tvalidateDDMFormFieldValueLocales(\n\t\t\t\tddmFormField, availableLocales, defaultLocale, value);\n\t\t}\n\t}","commit_id":"f4b1091add677e30e87afcf8504b36212370c962","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void validateDDMFormFieldValueLocales(\n\t\t\tDDMFormField ddmFormField, Set<Locale> availableLocales,\n\t\t\tLocale defaultLocale, Value value)\n\t\tthrows StorageException {\n\n\t\tif (!value.isLocalized()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!availableLocales.equals(value.getAvailableLocales())) {\n\t\t\tthrow new StorageFieldValueException(\n\t\t\t\t\"Invalid available locales set for field \" +\n\t\t\t\t\tddmFormField.getName());\n\t\t}\n\n\t\tif (!defaultLocale.equals(value.getDefaultLocale())) {\n\t\t\tthrow new StorageFieldValueException(\n\t\t\t\t\"Invalid default locale set for field \" +\n\t\t\t\t\tddmFormField.getName());\n\t\t}\n\t}","id":60619,"modified_method":"protected void validateDDMFormFieldValueLocales(\n\t\t\tDDMFormField ddmFormField, Set<Locale> availableLocales,\n\t\t\tLocale defaultLocale, Value value)\n\t\tthrows DDMFormValuesValidationException {\n\n\t\tif (!value.isLocalized()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!availableLocales.equals(value.getAvailableLocales())) {\n\t\t\tthrow new MustSetValidAvailableLocales(ddmFormField.getName());\n\t\t}\n\n\t\tif (!defaultLocale.equals(value.getDefaultLocale())) {\n\t\t\tthrow new MustSetValidDefaultLocale(ddmFormField.getName());\n\t\t}\n\t}","commit_id":"f4b1091add677e30e87afcf8504b36212370c962","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void validateDDMFormFieldValue(\n\t\t\tDDMFormField ddmFormField, DDMFormFieldValue ddmFormFieldValue)\n\t\tthrows StorageException {\n\n\t\tif (ddmFormField == null) {\n\t\t\tthrow new StorageFieldNameException(\n\t\t\t\t\"There is no such field name defined on DDM Form \" +\n\t\t\t\t\tddmFormFieldValue.getName());\n\t\t}\n\n\t\tDDMFormValues ddmFormValues = ddmFormFieldValue.getDDMFormValues();\n\n\t\tvalidateDDMFormFieldValue(\n\t\t\tddmFormField, ddmFormValues.getAvailableLocales(),\n\t\t\tddmFormValues.getDefaultLocale(), ddmFormFieldValue.getValue());\n\n\t\ttraverseDDMFormFieldValues(\n\t\t\tddmFormFieldValue.getNestedDDMFormFieldValues(),\n\t\t\tddmFormField.getNestedDDMFormFieldsMap());\n\t}","id":60620,"modified_method":"protected void validateDDMFormFieldValue(\n\t\t\tDDMFormField ddmFormField, DDMFormFieldValue ddmFormFieldValue)\n\t\tthrows DDMFormValuesValidationException {\n\n\t\tif (ddmFormField == null) {\n\t\t\tthrow new MustSetValidField(ddmFormFieldValue.getName());\n\t\t}\n\n\t\tDDMFormValues ddmFormValues = ddmFormFieldValue.getDDMFormValues();\n\n\t\tvalidateDDMFormFieldValue(\n\t\t\tddmFormField, ddmFormValues.getAvailableLocales(),\n\t\t\tddmFormValues.getDefaultLocale(), ddmFormFieldValue.getValue());\n\n\t\ttraverseDDMFormFieldValues(\n\t\t\tddmFormFieldValue.getNestedDDMFormFieldValues(),\n\t\t\tddmFormField.getNestedDDMFormFieldsMap());\n\t}","commit_id":"f4b1091add677e30e87afcf8504b36212370c962","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void validateDDMFormFieldValues(\n\t\t\tDDMFormField ddmFormField,\n\t\t\tList<DDMFormFieldValue> ddmFormFieldValues)\n\t\tthrows StorageException {\n\n\t\tif (ddmFormField.isRequired() && (ddmFormFieldValues.size() == 0)) {\n\t\t\tthrow new RequiredValue(ddmFormField.getName());\n\t\t}\n\n\t\tif (!ddmFormField.isRepeatable() && (ddmFormFieldValues.size() > 1)) {\n\t\t\tthrow new StorageFieldValueException(\n\t\t\t\t\"Incorrect number of values set for field \" +\n\t\t\t\t\tddmFormField.getName());\n\t\t}\n\t}","id":60621,"modified_method":"protected void validateDDMFormFieldValues(\n\t\t\tDDMFormField ddmFormField,\n\t\t\tList<DDMFormFieldValue> ddmFormFieldValues)\n\t\tthrows DDMFormValuesValidationException {\n\n\t\tif (ddmFormField.isRequired() && (ddmFormFieldValues.size() == 0)) {\n\t\t\tthrow new RequiredValue(ddmFormField.getName());\n\t\t}\n\n\t\tif (!ddmFormField.isRepeatable() && (ddmFormFieldValues.size() > 1)) {\n\t\t\tthrow new MustSetValidValuesSize(ddmFormField.getName());\n\t\t}\n\t}","commit_id":"f4b1091add677e30e87afcf8504b36212370c962","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n    public void testStatsIssue2039() throws InterruptedException {\n        final Config config = new Config();\n        final String name = \"testStatsIssue2039\";\n        config.addExecutorConfig(new ExecutorConfig(name).setQueueCapacity(1).setPoolSize(1));\n        final HazelcastInstance instance = createHazelcastInstance(config);\n        final IExecutorService executorService = instance.getExecutorService(name);\n\n        final CountDownLatch sleepLatch = new CountDownLatch(1);\n        final CountDownLatch secondLatch = new CountDownLatch(1);\n\n        executorService.execute(new Runnable() {\n            @Override\n            public void run() {\n                assertOpenEventually(sleepLatch);\n            }\n        });\n\n        executorService.execute(new Runnable() {\n            public void run() {\n                secondLatch.countDown();\n            }\n        });\n\n        final Future rejected = executorService.submit(new Runnable() {\n            public void run() {\n            }\n        });\n\n        try {\n            rejected.get();\n        } catch (ExecutionException ignored) {\n        } finally {\n            sleepLatch.countDown();\n        }\n\n        assertOpenEventually(secondLatch);\n\n        final LocalExecutorStats stats = executorService.getLocalExecutorStats();\n        assertEquals(2, stats.getStartedTaskCount());\n        assertEquals(0, stats.getPendingTaskCount());\n    }","id":60622,"modified_method":"@Test\n    public void testStatsIssue2039() throws InterruptedException {\n        final Config config = new Config();\n        final String name = \"testStatsIssue2039\";\n        config.addExecutorConfig(new ExecutorConfig(name).setQueueCapacity(1).setPoolSize(1));\n        final HazelcastInstance instance = createHazelcastInstance(config);\n        final IExecutorService executorService = instance.getExecutorService(name);\n\n        final CountDownLatch sleepLatch = new CountDownLatch(1);\n        final CountDownLatch secondLatch = new CountDownLatch(1);\n\n        executorService.execute(new Runnable() {\n            @Override\n            public void run() {\n                assertOpenEventually(sleepLatch);\n            }\n        });\n\n        final Future submit = executorService.submit(new Runnable() {\n            public void run() {\n                secondLatch.countDown();\n            }\n        });\n\n        final Future rejected = executorService.submit(new Runnable() {\n            public void run() {\n            }\n        });\n\n        try {\n            rejected.get();\n        } catch (ExecutionException ignored) {\n        } finally {\n            sleepLatch.countDown();\n        }\n\n        assertOpenEventually(secondLatch);\n\n        try {\n            submit.get();\n        } catch (ExecutionException ignored) {\n        }\n\n        final LocalExecutorStats stats = executorService.getLocalExecutorStats();\n        assertEquals(2, stats.getStartedTaskCount());\n        assertEquals(0, stats.getPendingTaskCount());\n    }","commit_id":"84116c505a01f73655e61a4923e1619a1065a309","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void sendDirectMessage(final DirectClientMessage msg) {\r\n    if (log.isTraceEnabled()) {\r\n      Gson gson = new Gson();\r\n      String json = gson.toJson(msg.getMessage());\r\n      log.trace(\"Handle direct message: \" + msg.getMessageName() + \" msg=\" + json);\r\n    }\r\n\r\n    final String sessionId = CONN + msg.getUserID();\r\n    Runnable sender = new Runnable() {\r\n      public void run() {\r\n        IScope meetingScope = getScope(msg.getMeetingID());\r\n        if (meetingScope != null) {\r\n\r\n          IConnection conn = getConnection(meetingScope, sessionId);\r\n          if (conn != null) {\r\n            if (conn.isConnected()) {\r\n              List<Object> params = new ArrayList<Object>();\r\n              params.add(msg.getMessageName());\r\n              params.add(msg.getMessage());\r\n              if (log.isTraceEnabled()) {\r\n                Gson gson = new Gson();\r\n                String json = gson.toJson(msg.getMessage());\r\n                log.trace(\"Send direct message: \" + msg.getMessageName() + \" msg=\" + json);\r\n              }\r\n              ServiceUtils.invokeOnConnection(conn, \"onMessageFromServer\", params.toArray());\r\n            }\r\n          } else {\r\n            log.info(\"Cannot send message=[\" + msg.getMessageName() + \"] to [\" + sessionId \r\n                + \"] as no such session on meeting=[\" + msg.getMeetingID() + \"]\");\r\n          }\r\n        }\t\r\n      }\r\n    };\t\t\r\n    runExec.execute(sender);\r\n  }","id":60623,"modified_method":"private void sendDirectMessage(final DirectClientMessage msg) {\r\n    if (log.isTraceEnabled()) {\r\n      Gson gson = new Gson();\r\n      String json = gson.toJson(msg.getMessage());\r\n      log.trace(\"Handle direct message: \" + msg.getMessageName() + \" msg=\" + json);\r\n    }\r\n\r\n    final String sessionId = CONN + msg.getUserID();\r\n    Runnable sender = new Runnable() {\r\n      public void run() {\r\n        IScope meetingScope = getScope(msg.getMeetingID());\r\n        if (meetingScope != null) {\r\n\r\n          IConnection conn = getConnection(meetingScope, sessionId);\r\n          if (conn != null) {\r\n            if (conn.isConnected()) {\r\n              List<Object> params = new ArrayList<Object>();\r\n              params.add(msg.getMessageName());\r\n              params.add(msg.getMessage());\r\n\r\n              if (log.isTraceEnabled()) {\r\n                Gson gson = new Gson();\r\n                String json = gson.toJson(msg.getMessage());\r\n                log.trace(\"Send direct message: \" + msg.getMessageName() + \" msg=\" + json);\r\n              }\r\n\r\n              ServiceUtils.invokeOnConnection(conn, \"onMessageFromServer\", params.toArray());\r\n            }\r\n          } else {\r\n            log.info(\"Cannot send message=[\" + msg.getMessageName() + \"] to [\" + sessionId \r\n                + \"] as no such session on meeting=[\" + msg.getMeetingID() + \"]\");\r\n          }\r\n        }\t\r\n      }\r\n    };\t\t\r\n\r\n    /**\r\n     * We need to add a way to cancel sending when the thread is blocked.\r\n     * Red5 uses a semaphore to guard the rtmp connection and we've seen\r\n     * instances where our thread is blocked preventing us from sending messages\r\n     * to other connections. (ralam nov 19, 2015)\r\n     */\r\n    long endNanos = System.nanoTime() + SEND_TIMEOUT;     \r\n    Future<?> f = runExec.submit(sender);\r\n    try {         \r\n      // Only wait for the remaining time budget         \r\n      long timeLeft = endNanos - System.nanoTime();         \r\n      f.get(timeLeft, TimeUnit.NANOSECONDS);   \r\n    } catch (ExecutionException e) {       \r\n      log.warn(\"ExecutionException while sending direct message on connection[\" + sessionId + \"]\");\r\n    } catch (InterruptedException e) {        \r\n      log.warn(\"Interrupted exception while sending direct message on connection[\" + sessionId + \"]\");\r\n      Thread.currentThread().interrupt();         \r\n    } catch (TimeoutException e) {               \r\n      log.warn(\"Timeout exception while sending direct message on connection[\" + sessionId + \"]\");\r\n      f.cancel(true);     \r\n    } \r\n  }","commit_id":"22b3a4e2a063ce188a1b0966b26b1123a978d340","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void stop() {\r\n    sendMessages = false;\r\n  }","id":60624,"modified_method":"public void stop() {\r\n    sendMessages = false;\r\n    runExec.shutdown();\r\n  }","commit_id":"22b3a4e2a063ce188a1b0966b26b1123a978d340","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"private void sendBroadcastMessage(final BroadcastClientMessage msg) {\r\n    if (log.isTraceEnabled()) {\r\n      Gson gson = new Gson();\r\n      String json = gson.toJson(msg.getMessage());\r\n      log.trace(\"Handle broadcast message: \" + msg.getMessageName() + \" msg=\" + json);\r\n    }\r\n    \r\n    Runnable sender = new Runnable() {\r\n      public void run() {\r\n        IScope meetingScope = getScope(msg.getMeetingID());\r\n        if (meetingScope != null) {\r\n          List<Object> params = new ArrayList<Object>();\r\n          params.add(msg.getMessageName());\r\n          params.add(msg.getMessage());\r\n          if (log.isTraceEnabled()) {\r\n            Gson gson = new Gson();\r\n            String json = gson.toJson(msg.getMessage());\r\n            log.trace(\"Broadcast message: \" + msg.getMessageName() + \" msg=\" + json);\r\n          }\r\n          ServiceUtils.invokeOnAllScopeConnections(meetingScope, \"onMessageFromServer\", params.toArray(), null);\r\n        }\r\n      }\r\n    };\t\r\n    runExec.execute(sender);\r\n  }","id":60625,"modified_method":"private void sendBroadcastMessage(final BroadcastClientMessage msg) {\r\n    if (log.isTraceEnabled()) {\r\n      Gson gson = new Gson();\r\n      String json = gson.toJson(msg.getMessage());\r\n      log.trace(\"Handle broadcast message: \" + msg.getMessageName() + \" msg=\" + json);\r\n    }\r\n    \r\n    Runnable sender = new Runnable() {\r\n      public void run() {\r\n        IScope meetingScope = getScope(msg.getMeetingID());\r\n        if (meetingScope != null) {\r\n          List<Object> params = new ArrayList<Object>();\r\n          params.add(msg.getMessageName());\r\n          params.add(msg.getMessage());\r\n          if (log.isTraceEnabled()) {\r\n            Gson gson = new Gson();\r\n            String json = gson.toJson(msg.getMessage());\r\n            log.trace(\"Broadcast message: \" + msg.getMessageName() + \" msg=\" + json);\r\n          }\r\n          ServiceUtils.invokeOnAllScopeConnections(meetingScope, \"onMessageFromServer\", params.toArray(), null);\r\n        }\r\n      }\r\n    };\t\r\n    \r\n    /**\r\n     * We need to add a way to cancel sending when the thread is blocked.\r\n     * Red5 uses a semaphore to guard the rtmp connection and we've seen\r\n     * instances where our thread is blocked preventing us from sending messages\r\n     * to other connections. (ralam nov 19, 2015)\r\n     */\r\n    long endNanos = System.nanoTime() + SEND_TIMEOUT;     \r\n    Future<?> f = runExec.submit(sender);\r\n    try {         \r\n    \t// Only wait for the remaining time budget         \r\n    \tlong timeLeft = endNanos - System.nanoTime();         \r\n    \tf.get(timeLeft, TimeUnit.NANOSECONDS);   \r\n    } catch (ExecutionException e) {       \r\n    \tlog.warn(\"ExecutionException while sending broadcast message[\" + msg.getMessageName() + \"]\");\r\n    } catch (InterruptedException e) {        \r\n    \tlog.warn(\"Interrupted exception while sending direct message[\" + msg.getMessageName() + \"]\");\r\n    \tThread.currentThread().interrupt();         \r\n    } catch (TimeoutException e) {               \r\n    \tlog.warn(\"Timeout exception while sending direct message[\" + msg.getMessageName() + \"]\");\r\n    \tf.cancel(true);     \r\n    } \r\n  }","commit_id":"22b3a4e2a063ce188a1b0966b26b1123a978d340","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"private void createListener() {\n      RadRootContainer root = (RadRootContainer)FormEditingUtil.getRoot(mySelection.get(0));\n      final PsiField[] boundFields = new PsiField[mySelection.size()];\n      for (int i = 0; i < mySelection.size(); i++) {\n        boundFields[i] = BindingProperty.findBoundField(root, mySelection.get(i).getBinding());\n      }\n      final PsiClass myClass = boundFields[0].getContainingClass();\n\n      if (!FileModificationService.getInstance().preparePsiElementForWrite(myClass)) return;\n\n      try {\n        PsiMethod constructor = findConstructorToInsert(myClass);\n        final Module module = ModuleUtil.findModuleForPsiElement(myClass);\n        PsiClass listenerClass = null;\n        final String listenerClassName = myDescriptor.getListenerType().getName();\n        if (listenerClassName.endsWith(LISTENER_SUFFIX)) {\n          String adapterClassName = listenerClassName.substring(0, listenerClassName.length() - LISTENER_SUFFIX.length()) + ADAPTER_SUFFIX;\n          listenerClass = JavaPsiFacade.getInstance(myClass.getProject())\n            .findClass(adapterClassName, GlobalSearchScope.moduleWithDependenciesAndLibrariesScope(module));\n        }\n        if (listenerClass == null) {\n          listenerClass = JavaPsiFacade.getInstance(myClass.getProject())\n            .findClass(listenerClassName, GlobalSearchScope.moduleWithDependenciesAndLibrariesScope(module));\n        }\n        if (listenerClass == null) {\n          Messages.showErrorDialog(myClass.getProject(), UIDesignerBundle.message(\"create.listener.class.not.found\"), CommonBundle.getErrorTitle());\n          return;\n        }\n\n        PsiElementFactory factory = JavaPsiFacade.getInstance(myClass.getProject()).getElementFactory();\n        final PsiCodeBlock body = constructor.getBody();\n        LOG.assertTrue(body != null);\n\n        @NonNls StringBuilder builder = new StringBuilder();\n        @NonNls String variableName = null;\n        if (boundFields.length == 1) {\n          builder.append(boundFields[0].getName());\n          builder.append(\".\");\n          builder.append(myDescriptor.getAddListenerMethod().getName());\n          builder.append(\"(\");\n        }\n        else {\n          builder.append(listenerClass.getQualifiedName()).append(\" \");\n          if (body.getLastBodyElement() == null) {\n            variableName = \"listener\";\n          }\n          else {\n            final JavaCodeStyleManager codeStyleManager = JavaCodeStyleManager.getInstance(myClass.getProject());\n            variableName = codeStyleManager.suggestUniqueVariableName(\"listener\", body.getLastBodyElement(), false);\n          }\n          builder.append(variableName).append(\"=\");\n        }\n        builder.append(\"new \");\n        builder.append(listenerClass.getQualifiedName());\n        builder.append(\"() { } \");\n        if (boundFields.length == 1) {\n          builder.append(\");\");\n        }\n        else {\n          builder.append(\";\");\n        }\n\n        PsiStatement stmt = factory.createStatementFromText(builder.toString(), constructor);\n        stmt = (PsiStatement)body.addAfter(stmt, body.getLastBodyElement());\n        JavaCodeStyleManager.getInstance(body.getProject()).shortenClassReferences(stmt);\n\n        if (boundFields.length > 1) {\n          PsiElement anchor = stmt;\n          for (PsiField field : boundFields) {\n            PsiElement addStmt = factory\n              .createStatementFromText(field.getName() + \".\" + myDescriptor.getAddListenerMethod().getName() + \"(\" + variableName + \");\",\n                                       constructor);\n            addStmt = body.addAfter(addStmt, anchor);\n            anchor = addStmt;\n          }\n        }\n\n        final Ref<PsiClass> newClassRef = new Ref<PsiClass>();\n        stmt.accept(new JavaRecursiveElementWalkingVisitor() {\n          @Override\n          public void visitClass(PsiClass aClass) {\n            newClassRef.set(aClass);\n          }\n        });\n        final PsiClass newClass = newClassRef.get();\n        final SmartPsiElementPointer ptr = SmartPointerManager.getInstance(myClass.getProject()).createSmartPsiElementPointer(newClass);\n        final VirtualFile virtualFile = PsiUtilCore.getVirtualFile(newClass);\n        final FileEditor[] fileEditors =\n          virtualFile != null ? FileEditorManager.getInstance(newClass.getProject()).openFile(virtualFile, true, true) : null;\n        IdeFocusManager.findInstance().doWhenFocusSettlesDown(new Runnable() {\n          public void run() {\n            final PsiClass newClass = (PsiClass)ptr.getElement();\n            final Editor editor = getEditor();\n            if (editor != null && newClass != null) {\n              CommandProcessor.getInstance().executeCommand(myClass.getProject(), new Runnable() {\n                public void run() {\n                  if (!OverrideImplementExploreUtil.getMethodSignaturesToImplement(newClass).isEmpty()) {\n                    OverrideImplementUtil.chooseAndImplementMethods(newClass.getProject(), editor, newClass);\n                  }\n                  else {\n                    OverrideImplementUtil.chooseAndOverrideMethods(newClass.getProject(), editor, newClass);\n                  }\n                }\n              }, \"\", null);\n            }\n          }\n\n          private Editor getEditor() {\n            if (fileEditors != null) {\n              for (FileEditor fileEditor : fileEditors) {\n                if (fileEditor instanceof TextEditor) {\n                  return ((TextEditor)fileEditor).getEditor();\n                }\n              }\n            }\n            return null;\n          }\n        });\n      }\n      catch (IncorrectOperationException ex) {\n        LOG.error(ex);\n      }\n    }","id":60626,"modified_method":"private void createListener() {\n      RadRootContainer root = (RadRootContainer)FormEditingUtil.getRoot(mySelection.get(0));\n      final PsiField[] boundFields = new PsiField[mySelection.size()];\n      for (int i = 0; i < mySelection.size(); i++) {\n        boundFields[i] = BindingProperty.findBoundField(root, mySelection.get(i).getBinding());\n      }\n      final PsiClass myClass = boundFields[0].getContainingClass();\n\n      if (!FileModificationService.getInstance().preparePsiElementForWrite(myClass)) return;\n\n      try {\n        PsiMethod constructor = findConstructorToInsert(myClass);\n        final Module module = ModuleUtil.findModuleForPsiElement(myClass);\n        PsiClass listenerClass = null;\n        final String listenerClassName = myDescriptor.getListenerType().getName();\n        if (listenerClassName.endsWith(LISTENER_SUFFIX)) {\n          String adapterClassName = listenerClassName.substring(0, listenerClassName.length() - LISTENER_SUFFIX.length()) + ADAPTER_SUFFIX;\n          listenerClass = JavaPsiFacade.getInstance(myClass.getProject())\n            .findClass(adapterClassName, GlobalSearchScope.moduleWithDependenciesAndLibrariesScope(module));\n        }\n        if (listenerClass == null) {\n          listenerClass = JavaPsiFacade.getInstance(myClass.getProject())\n            .findClass(listenerClassName, GlobalSearchScope.moduleWithDependenciesAndLibrariesScope(module));\n        }\n        if (listenerClass == null) {\n          Messages.showErrorDialog(myClass.getProject(), UIDesignerBundle.message(\"create.listener.class.not.found\"), CommonBundle.getErrorTitle());\n          return;\n        }\n\n        PsiElementFactory factory = JavaPsiFacade.getInstance(myClass.getProject()).getElementFactory();\n        final PsiCodeBlock body = constructor.getBody();\n        LOG.assertTrue(body != null);\n\n        @NonNls StringBuilder builder = new StringBuilder();\n        @NonNls String variableName = null;\n        if (boundFields.length == 1) {\n          builder.append(boundFields[0].getName());\n          builder.append(\".\");\n          builder.append(myDescriptor.getAddListenerMethod().getName());\n          builder.append(\"(\");\n        }\n        else {\n          builder.append(listenerClass.getQualifiedName()).append(\" \");\n          if (body.getLastBodyElement() == null) {\n            variableName = \"listener\";\n          }\n          else {\n            final JavaCodeStyleManager codeStyleManager = JavaCodeStyleManager.getInstance(myClass.getProject());\n            variableName = codeStyleManager.suggestUniqueVariableName(\"listener\", body.getLastBodyElement(), false);\n          }\n          builder.append(variableName).append(\"=\");\n        }\n        builder.append(\"new \");\n        builder.append(listenerClass.getQualifiedName());\n        builder.append(\"() { } \");\n        if (boundFields.length == 1) {\n          builder.append(\");\");\n        }\n        else {\n          builder.append(\";\");\n        }\n\n        PsiStatement stmt = factory.createStatementFromText(builder.toString(), constructor);\n        stmt = (PsiStatement)body.addAfter(stmt, body.getLastBodyElement());\n        stmt = (PsiStatement)JavaCodeStyleManager.getInstance(body.getProject()).shortenClassReferences(stmt);\n\n        if (boundFields.length > 1) {\n          PsiElement anchor = stmt;\n          for (PsiField field : boundFields) {\n            PsiElement addStmt = factory\n              .createStatementFromText(field.getName() + \".\" + myDescriptor.getAddListenerMethod().getName() + \"(\" + variableName + \");\",\n                                       constructor);\n            addStmt = body.addAfter(addStmt, anchor);\n            anchor = addStmt;\n          }\n        }\n\n        final SmartPsiElementPointer ptr = SmartPointerManager.getInstance(myClass.getProject()).createSmartPsiElementPointer(stmt);\n        final VirtualFile virtualFile = PsiUtilCore.getVirtualFile(myClass);\n        final FileEditor[] fileEditors =\n          virtualFile != null ? FileEditorManager.getInstance(myClass.getProject()).openFile(virtualFile, true, true) : null;\n        IdeFocusManager.findInstance().doWhenFocusSettlesDown(new Runnable() {\n          public void run() {\n            final PsiElement anonymousClassStatement = ptr.getElement();\n            if (anonymousClassStatement == null) {\n              return;\n            }\n\n            final Ref<PsiClass> newClassRef = new Ref<PsiClass>();\n            anonymousClassStatement.accept(new JavaRecursiveElementWalkingVisitor() {\n              @Override\n              public void visitClass(PsiClass aClass) {\n                newClassRef.set(aClass);\n              }\n            });\n            final PsiClass newClass = newClassRef.get();\n\n            final Editor editor = getEditor();\n            if (editor != null && newClass != null) {\n              PsiElement brace = newClass.getLBrace();\n              if (brace != null) {\n                editor.getCaretModel().moveToOffset(brace.getTextOffset());\n              }\n              CommandProcessor.getInstance().executeCommand(myClass.getProject(), new Runnable() {\n                public void run() {\n                  if (!OverrideImplementExploreUtil.getMethodSignaturesToImplement(newClass).isEmpty()) {\n                    OverrideImplementUtil.chooseAndImplementMethods(newClass.getProject(), editor, newClass);\n                  }\n                  else {\n                    OverrideImplementUtil.chooseAndOverrideMethods(newClass.getProject(), editor, newClass);\n                  }\n                }\n              }, \"\", null);\n            }\n          }\n\n          private Editor getEditor() {\n            if (fileEditors != null) {\n              for (FileEditor fileEditor : fileEditors) {\n                if (fileEditor instanceof TextEditor) {\n                  return ((TextEditor)fileEditor).getEditor();\n                }\n              }\n            }\n            return null;\n          }\n        });\n      }\n      catch (IncorrectOperationException ex) {\n        LOG.error(ex);\n      }\n    }","commit_id":"0846f4aea626ffa31faab6a0a45d14cb3f864092","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public PsiField createField(@NotNull final String name, @NotNull final PsiType type) throws IncorrectOperationException {\n    PsiUtil.checkIsIdentifier(myManager, name);\n    if (PsiType.NULL.equals(type)) {\n      throw new IncorrectOperationException(\"Cannot create field with type \\\"null\\\".\");\n    }\n\n    final String text = join(\"class _Dummy_ { private \", type.getCanonicalText(), \" \", name, \"; }\");\n    final PsiJavaFile aFile = createDummyJavaFile(text);\n    final PsiClass[] classes = aFile.getClasses();\n    if (classes.length < 1) {\n      throw new IncorrectOperationException(\"Class was not created \" + text);\n    }\n    final PsiClass psiClass = classes[0];\n    final PsiField[] fields = psiClass.getFields();\n    if (fields.length < 1) {\n      throw new IncorrectOperationException(\"Field was not created \" + text);\n    }\n    final PsiField field = fields[0];\n    JavaCodeStyleManager.getInstance(myManager.getProject()).shortenClassReferences(field);\n    return (PsiField)CodeStyleManager.getInstance(myManager.getProject()).reformat(field);\n  }","id":60627,"modified_method":"@NotNull\n  @Override\n  public PsiField createField(@NotNull final String name, @NotNull final PsiType type) throws IncorrectOperationException {\n    PsiUtil.checkIsIdentifier(myManager, name);\n    if (PsiType.NULL.equals(type)) {\n      throw new IncorrectOperationException(\"Cannot create field with type \\\"null\\\".\");\n    }\n\n    final String text = join(\"class _Dummy_ { private \", type.getCanonicalText(), \" \", name, \"; }\");\n    final PsiJavaFile aFile = createDummyJavaFile(text);\n    final PsiClass[] classes = aFile.getClasses();\n    if (classes.length < 1) {\n      throw new IncorrectOperationException(\"Class was not created \" + text);\n    }\n    final PsiClass psiClass = classes[0];\n    final PsiField[] fields = psiClass.getFields();\n    if (fields.length < 1) {\n      throw new IncorrectOperationException(\"Field was not created \" + text);\n    }\n    PsiField field = fields[0];\n    field = (PsiField)JavaCodeStyleManager.getInstance(myManager.getProject()).shortenClassReferences(field);\n    return (PsiField)CodeStyleManager.getInstance(myManager.getProject()).reformat(field);\n  }","commit_id":"ed9b7d65233b7d5a5bf0d6d78c4a46ccf337895b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public PsiMethod createMethod(@NotNull final String name, final PsiType returnType) throws IncorrectOperationException {\n    PsiUtil.checkIsIdentifier(myManager, name);\n    if (PsiType.NULL.equals(returnType)) {\n      throw new IncorrectOperationException(\"Cannot create method with type \\\"null\\\".\");\n    }\n\n    final PsiJavaFile aFile = createDummyJavaFile(join(\"class _Dummy_ { public \" + returnType.getCanonicalText(), \" \", name, \"() {} }\"));\n    final PsiMethod method = aFile.getClasses()[0].getMethods()[0];\n    JavaCodeStyleManager.getInstance(myManager.getProject()).shortenClassReferences(method);\n    return (PsiMethod)CodeStyleManager.getInstance(myManager.getProject()).reformat(method);\n  }","id":60628,"modified_method":"@NotNull\n  @Override\n  public PsiMethod createMethod(@NotNull final String name, final PsiType returnType) throws IncorrectOperationException {\n    PsiUtil.checkIsIdentifier(myManager, name);\n    if (PsiType.NULL.equals(returnType)) {\n      throw new IncorrectOperationException(\"Cannot create method with type \\\"null\\\".\");\n    }\n\n    final String canonicalText = returnType.getCanonicalText();\n    final PsiJavaFile aFile = createDummyJavaFile(join(\"class _Dummy_ { public \" + canonicalText, \" \", name, \"() {} }\"));\n    final PsiClass[] classes = aFile.getClasses();\n    if (classes.length < 1) {\n      throw new IncorrectOperationException(\"Class was not created. Method name: \" + name + \"; return type: \" + canonicalText);\n    }\n    final PsiMethod[] methods = classes[0].getMethods();\n    if (methods.length < 1) {\n      throw new IncorrectOperationException(\"Method was not created. Method name: \" + name + \"; return type: \" + canonicalText);\n    }\n    PsiMethod method = methods[0];\n    method = (PsiMethod)JavaCodeStyleManager.getInstance(myManager.getProject()).shortenClassReferences(method);\n    return (PsiMethod)CodeStyleManager.getInstance(myManager.getProject()).reformat(method);\n  }","commit_id":"ed9b7d65233b7d5a5bf0d6d78c4a46ccf337895b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public PsiParameter createParameter(@NotNull final String name, @NotNull final PsiType type) throws IncorrectOperationException {\n    PsiUtil.checkIsIdentifier(myManager, name);\n    if (PsiType.NULL.equals(type)) {\n      throw new IncorrectOperationException(\"Cannot create parameter with type \\\"null\\\".\");\n    }\n\n    final String text = join(type.getCanonicalText() + \" \" + name);\n    final PsiParameter parameter = createParameterFromText(text, null);\n    final CodeStyleManager codeStyleManager = CodeStyleManager.getInstance(myManager.getProject());\n    PsiUtil.setModifierProperty(parameter, PsiModifier.FINAL,\n                                CodeStyleSettingsManager.getSettings(myManager.getProject()).GENERATE_FINAL_PARAMETERS);\n    markGenerated(parameter);\n    JavaCodeStyleManager.getInstance(myManager.getProject()).shortenClassReferences(parameter);\n    return (PsiParameter)codeStyleManager.reformat(parameter);\n  }","id":60629,"modified_method":"@NotNull\n  @Override\n  public PsiParameter createParameter(@NotNull final String name, @NotNull final PsiType type) throws IncorrectOperationException {\n    PsiUtil.checkIsIdentifier(myManager, name);\n    if (PsiType.NULL.equals(type)) {\n      throw new IncorrectOperationException(\"Cannot create parameter with type \\\"null\\\".\");\n    }\n\n    final String text = join(type.getCanonicalText() + \" \" + name);\n    PsiParameter parameter = createParameterFromText(text, null);\n    final CodeStyleManager codeStyleManager = CodeStyleManager.getInstance(myManager.getProject());\n    PsiUtil.setModifierProperty(parameter, PsiModifier.FINAL,\n                                CodeStyleSettingsManager.getSettings(myManager.getProject()).GENERATE_FINAL_PARAMETERS);\n    markGenerated(parameter);\n    parameter = (PsiParameter)JavaCodeStyleManager.getInstance(myManager.getProject()).shortenClassReferences(parameter);\n    return (PsiParameter)codeStyleManager.reformat(parameter);\n  }","commit_id":"ed9b7d65233b7d5a5bf0d6d78c4a46ccf337895b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void importDependencyManagement( Model model, ModelBuildingRequest request,\n                                             DefaultModelProblemCollector problems, Collection<String> importIds )\n    {\n        DependencyManagement depMngt = model.getDependencyManagement();\n\n        if ( depMngt == null )\n        {\n            return;\n        }\n\n        String importing = model.getGroupId() + ':' + model.getArtifactId() + ':' + model.getVersion();\n\n        importIds.add( importing );\n\n        ModelResolver modelResolver = request.getModelResolver();\n\n        ModelBuildingRequest importRequest = null;\n\n        List<DependencyManagement> importMngts = null;\n\n        for ( Iterator<Dependency> it = depMngt.getDependencies().iterator(); it.hasNext(); )\n        {\n            Dependency dependency = it.next();\n\n            if ( !\"pom\".equals( dependency.getType() ) || !\"import\".equals( dependency.getScope() ) )\n            {\n                continue;\n            }\n\n            it.remove();\n\n            String groupId = dependency.getGroupId();\n            String artifactId = dependency.getArtifactId();\n            String version = dependency.getVersion();\n\n            String imported = groupId + ':' + artifactId + ':' + version;\n\n            if ( importIds.contains( imported ) )\n            {\n                String message = \"The dependencies of type=pom and with scope=import form a cycle: \";\n                for ( String modelId : importIds )\n                {\n                    message += modelId + \" -> \";\n                }\n                message += imported;\n                problems.add( Severity.ERROR, message, null, null );\n\n                continue;\n            }\n\n            DependencyManagement importMngt =\n                getCache( request.getModelCache(), groupId, artifactId, version, ModelCacheTag.IMPORT );\n\n            if ( importMngt == null )\n            {\n                if ( modelResolver == null )\n                {\n                    throw new IllegalArgumentException( \"no model resolver provided, cannot resolve import POM \"\n                        + ModelProblemUtils.toId( groupId, artifactId, version ) + \" for POM \"\n                        + ModelProblemUtils.toSourceHint( model ) );\n                }\n\n                ModelSource importSource;\n                try\n                {\n                    importSource = modelResolver.resolveModel( groupId, artifactId, version );\n                }\n                catch ( UnresolvableModelException e )\n                {\n                    problems.add( Severity.ERROR, \"Non-resolvable import POM \"\n                        + ModelProblemUtils.toId( groupId, artifactId, version ) + \": \" + e.getMessage(),\n                                  dependency.getLocation( \"\" ), e );\n                    continue;\n                }\n\n                if ( importRequest == null )\n                {\n                    importRequest = new DefaultModelBuildingRequest();\n                    importRequest.setValidationLevel( ModelBuildingRequest.VALIDATION_LEVEL_MINIMAL );\n                    importRequest.setModelCache( request.getModelCache() );\n                    importRequest.setSystemProperties( request.getSystemProperties() );\n                    importRequest.setUserProperties( request.getUserProperties() );\n                }\n\n                importRequest.setModelSource( importSource );\n                importRequest.setModelResolver( modelResolver.newCopy() );\n\n                ModelBuildingResult importResult;\n                try\n                {\n                    importResult = build( importRequest, importIds );\n                }\n                catch ( ModelBuildingException e )\n                {\n                    problems.addAll( e.getProblems() );\n                    continue;\n                }\n\n                problems.addAll( importResult.getProblems() );\n\n                Model importModel = importResult.getEffectiveModel();\n\n                importMngt = importModel.getDependencyManagement();\n\n                if ( importMngt == null )\n                {\n                    importMngt = new DependencyManagement();\n                }\n\n                putCache( request.getModelCache(), groupId, artifactId, version, ModelCacheTag.IMPORT, importMngt );\n            }\n\n            if ( importMngts == null )\n            {\n                importMngts = new ArrayList<DependencyManagement>();\n            }\n\n            importMngts.add( importMngt );\n        }\n\n        importIds.remove( importing );\n\n        dependencyManagementImporter.importManagement( model, importMngts, request, problems );\n    }","id":60630,"modified_method":"private void importDependencyManagement( Model model, ModelBuildingRequest request,\n                                             DefaultModelProblemCollector problems, Collection<String> importIds )\n    {\n        DependencyManagement depMngt = model.getDependencyManagement();\n\n        if ( depMngt == null )\n        {\n            return;\n        }\n\n        String importing = model.getGroupId() + ':' + model.getArtifactId() + ':' + model.getVersion();\n\n        importIds.add( importing );\n\n        ModelResolver modelResolver = request.getModelResolver();\n\n        ModelBuildingRequest importRequest = null;\n\n        List<DependencyManagement> importMngts = null;\n\n        for ( Iterator<Dependency> it = depMngt.getDependencies().iterator(); it.hasNext(); )\n        {\n            Dependency dependency = it.next();\n\n            if ( !\"pom\".equals( dependency.getType() ) || !\"import\".equals( dependency.getScope() ) )\n            {\n                continue;\n            }\n\n            it.remove();\n\n            String groupId = dependency.getGroupId();\n            String artifactId = dependency.getArtifactId();\n            String version = dependency.getVersion();\n\n            String imported = groupId + ':' + artifactId + ':' + version;\n\n            if ( importIds.contains( imported ) )\n            {\n                String message = \"The dependencies of type=pom and with scope=import form a cycle: \";\n                for ( String modelId : importIds )\n                {\n                    message += modelId + \" -> \";\n                }\n                message += imported;\n                problems.add( Severity.ERROR, message, null, null );\n\n                continue;\n            }\n\n            DependencyManagement importMngt =\n                getCache( request.getModelCache(), groupId, artifactId, version, ModelCacheTag.IMPORT );\n\n            if ( importMngt == null )\n            {\n                if ( modelResolver == null )\n                {\n                    throw new IllegalArgumentException( \"no model resolver provided, cannot resolve import POM \"\n                        + ModelProblemUtils.toId( groupId, artifactId, version ) + \" for POM \"\n                        + ModelProblemUtils.toSourceHint( model ) );\n                }\n\n                ModelSource importSource;\n                try\n                {\n                    importSource = modelResolver.resolveModel( groupId, artifactId, version );\n                }\n                catch ( UnresolvableModelException e )\n                {\n                    StringBuilder buffer = new StringBuilder( 256 );\n                    buffer.append( \"Non-resolvable import POM\" );\n                    if ( !containsCoordinates( e.getMessage(), groupId, artifactId, version ) )\n                    {\n                        buffer.append( \" \" ).append( ModelProblemUtils.toId( groupId, artifactId, version ) );\n                    }\n                    buffer.append( \": \" ).append( e.getMessage() );\n\n                    problems.add( Severity.ERROR, buffer.toString(), dependency.getLocation( \"\" ), e );\n                    continue;\n                }\n\n                if ( importRequest == null )\n                {\n                    importRequest = new DefaultModelBuildingRequest();\n                    importRequest.setValidationLevel( ModelBuildingRequest.VALIDATION_LEVEL_MINIMAL );\n                    importRequest.setModelCache( request.getModelCache() );\n                    importRequest.setSystemProperties( request.getSystemProperties() );\n                    importRequest.setUserProperties( request.getUserProperties() );\n                }\n\n                importRequest.setModelSource( importSource );\n                importRequest.setModelResolver( modelResolver.newCopy() );\n\n                ModelBuildingResult importResult;\n                try\n                {\n                    importResult = build( importRequest, importIds );\n                }\n                catch ( ModelBuildingException e )\n                {\n                    problems.addAll( e.getProblems() );\n                    continue;\n                }\n\n                problems.addAll( importResult.getProblems() );\n\n                Model importModel = importResult.getEffectiveModel();\n\n                importMngt = importModel.getDependencyManagement();\n\n                if ( importMngt == null )\n                {\n                    importMngt = new DependencyManagement();\n                }\n\n                putCache( request.getModelCache(), groupId, artifactId, version, ModelCacheTag.IMPORT, importMngt );\n            }\n\n            if ( importMngts == null )\n            {\n                importMngts = new ArrayList<DependencyManagement>();\n            }\n\n            importMngts.add( importMngt );\n        }\n\n        importIds.remove( importing );\n\n        dependencyManagementImporter.importManagement( model, importMngts, request, problems );\n    }","commit_id":"1be90a985a25e206682a9220b78dfe1f66700ab5","url":"https://github.com/apache/maven"},{"original_method":"private ModelData readParentExternally( Model childModel, ModelBuildingRequest request,\n                                            DefaultModelProblemCollector problems )\n        throws ModelBuildingException\n    {\n        problems.setSource( childModel );\n\n        Parent parent = childModel.getParent();\n\n        String groupId = parent.getGroupId();\n        String artifactId = parent.getArtifactId();\n        String version = parent.getVersion();\n\n        ModelResolver modelResolver = request.getModelResolver();\n\n        if ( modelResolver == null )\n        {\n            throw new IllegalArgumentException( \"no model resolver provided, cannot resolve parent POM \"\n                + ModelProblemUtils.toId( groupId, artifactId, version ) + \" for POM \"\n                + ModelProblemUtils.toSourceHint( childModel ) );\n        }\n\n        ModelSource modelSource;\n        try\n        {\n            modelSource = modelResolver.resolveModel( groupId, artifactId, version );\n        }\n        catch ( UnresolvableModelException e )\n        {\n            problems.add( Severity.FATAL, \"Non-resolvable parent POM \"\n                + ModelProblemUtils.toId( groupId, artifactId, version ) + \" for \"\n                + ModelProblemUtils.toId( childModel ) + \": \" + e.getMessage(), childModel.getLocation( \"parent\" ), e );\n            throw new ModelBuildingException( problems.getRootModel(), problems.getRootModelId(),\n                                              problems.getProblems() );\n        }\n\n        ModelBuildingRequest lenientRequest = request;\n        if ( request.getValidationLevel() > ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0 )\n        {\n            lenientRequest = new FilterModelBuildingRequest( request )\n            {\n                @Override\n                public int getValidationLevel()\n                {\n                    return ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0;\n                }\n            };\n        }\n\n        Model parentModel = readModel( modelSource, null, lenientRequest, problems );\n\n        ModelData parentData =\n            new ModelData( parentModel, parent.getGroupId(), parent.getArtifactId(), parent.getVersion() );\n\n        return parentData;\n    }","id":60631,"modified_method":"private ModelData readParentExternally( Model childModel, ModelBuildingRequest request,\n                                            DefaultModelProblemCollector problems )\n        throws ModelBuildingException\n    {\n        problems.setSource( childModel );\n\n        Parent parent = childModel.getParent();\n\n        String groupId = parent.getGroupId();\n        String artifactId = parent.getArtifactId();\n        String version = parent.getVersion();\n\n        ModelResolver modelResolver = request.getModelResolver();\n\n        if ( modelResolver == null )\n        {\n            throw new IllegalArgumentException( \"no model resolver provided, cannot resolve parent POM \"\n                + ModelProblemUtils.toId( groupId, artifactId, version ) + \" for POM \"\n                + ModelProblemUtils.toSourceHint( childModel ) );\n        }\n\n        ModelSource modelSource;\n        try\n        {\n            modelSource = modelResolver.resolveModel( groupId, artifactId, version );\n        }\n        catch ( UnresolvableModelException e )\n        {\n            StringBuilder buffer = new StringBuilder( 256 );\n            buffer.append( \"Non-resolvable parent POM\" );\n            if ( !containsCoordinates( e.getMessage(), groupId, artifactId, version ) )\n            {\n                buffer.append( \" \" ).append( ModelProblemUtils.toId( groupId, artifactId, version ) );\n            }\n            if ( childModel != problems.getRootModel() )\n            {\n                buffer.append( \" for \" ).append( ModelProblemUtils.toId( childModel ) );\n            }\n            buffer.append( \": \" ).append( e.getMessage() );\n            buffer.append( \" and 'parent.relativePath' points at wrong local POM\" );\n\n            problems.add( Severity.FATAL, buffer.toString(), parent.getLocation( \"\" ), e );\n            throw new ModelBuildingException( problems.getRootModel(), problems.getRootModelId(),\n                                              problems.getProblems() );\n        }\n\n        ModelBuildingRequest lenientRequest = request;\n        if ( request.getValidationLevel() > ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0 )\n        {\n            lenientRequest = new FilterModelBuildingRequest( request )\n            {\n                @Override\n                public int getValidationLevel()\n                {\n                    return ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0;\n                }\n            };\n        }\n\n        Model parentModel = readModel( modelSource, null, lenientRequest, problems );\n\n        ModelData parentData =\n            new ModelData( parentModel, parent.getGroupId(), parent.getArtifactId(), parent.getVersion() );\n\n        return parentData;\n    }","commit_id":"1be90a985a25e206682a9220b78dfe1f66700ab5","url":"https://github.com/apache/maven"},{"original_method":"private ModelData readParentLocally( Model childModel, ModelBuildingRequest request,\n                                         DefaultModelProblemCollector problems )\n        throws ModelBuildingException\n    {\n        File pomFile = getParentPomFile( childModel );\n\n        if ( pomFile == null || !pomFile.isFile() )\n        {\n            return null;\n        }\n\n        Model candidateModel = readModel( null, pomFile, request, problems );\n\n        String groupId = candidateModel.getGroupId();\n        if ( groupId == null && candidateModel.getParent() != null )\n        {\n            groupId = candidateModel.getParent().getGroupId();\n        }\n        String artifactId = candidateModel.getArtifactId();\n        String version = candidateModel.getVersion();\n        if ( version == null && candidateModel.getParent() != null )\n        {\n            version = candidateModel.getParent().getVersion();\n        }\n\n        Parent parent = childModel.getParent();\n\n        if ( groupId == null || !groupId.equals( parent.getGroupId() ) || artifactId == null\n            || !artifactId.equals( parent.getArtifactId() ) )\n        {\n            problems.setSource( childModel );\n            problems.add( Severity.WARNING, \"'parent.relativePath' of POM \"\n                + ModelProblemUtils.toSourceHint( childModel ) + \" points at \" + groupId + \":\" + artifactId\n                + \" instead of \" + parent.getGroupId() + \":\" + parent.getArtifactId()\n                + \", please verify your project structure\", childModel.getLocation( \"parent\" ), null );\n            return null;\n        }\n        if ( version == null || !version.equals( parent.getVersion() ) )\n        {\n            return null;\n        }\n\n        ModelData parentData = new ModelData( candidateModel, groupId, artifactId, version );\n\n        return parentData;\n    }","id":60632,"modified_method":"private ModelData readParentLocally( Model childModel, ModelBuildingRequest request,\n                                         DefaultModelProblemCollector problems )\n        throws ModelBuildingException\n    {\n        File pomFile = getParentPomFile( childModel );\n\n        if ( pomFile == null || !pomFile.isFile() )\n        {\n            return null;\n        }\n\n        Model candidateModel = readModel( null, pomFile, request, problems );\n\n        String groupId = candidateModel.getGroupId();\n        if ( groupId == null && candidateModel.getParent() != null )\n        {\n            groupId = candidateModel.getParent().getGroupId();\n        }\n        String artifactId = candidateModel.getArtifactId();\n        String version = candidateModel.getVersion();\n        if ( version == null && candidateModel.getParent() != null )\n        {\n            version = candidateModel.getParent().getVersion();\n        }\n\n        Parent parent = childModel.getParent();\n\n        if ( groupId == null || !groupId.equals( parent.getGroupId() ) || artifactId == null\n            || !artifactId.equals( parent.getArtifactId() ) )\n        {\n            StringBuilder buffer = new StringBuilder( 256 );\n            buffer.append( \"'parent.relativePath'\" );\n            if ( childModel != problems.getRootModel() )\n            {\n                buffer.append( \" of POM \" ).append( ModelProblemUtils.toSourceHint( childModel ) );\n            }\n            buffer.append( \" points at \" ).append( groupId ).append( \":\" ).append( artifactId );\n            buffer.append( \" instead of \" ).append( parent.getGroupId() ).append( \":\" ).append( parent.getArtifactId() );\n            buffer.append( \", please verify your project structure\" );\n\n            problems.setSource( childModel );\n            problems.add( Severity.WARNING, buffer.toString(), parent.getLocation( \"\" ), null );\n            return null;\n        }\n        if ( version == null || !version.equals( parent.getVersion() ) )\n        {\n            return null;\n        }\n\n        ModelData parentData = new ModelData( candidateModel, groupId, artifactId, version );\n\n        return parentData;\n    }","commit_id":"1be90a985a25e206682a9220b78dfe1f66700ab5","url":"https://github.com/apache/maven"},{"original_method":"public ModelSource resolveModel( String groupId, String artifactId, String version )\n        throws UnresolvableModelException\n    {\n        Artifact pomArtifact = new DefaultArtifact( groupId, artifactId, \"\", \"pom\", version );\n\n        try\n        {\n            ArtifactRequest request = new ArtifactRequest( pomArtifact, repositories, context );\n            pomArtifact = resolver.resolveArtifact( session, request ).getArtifact();\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            throw new UnresolvableModelException( \"Failed to resolve POM for \" + groupId + \":\" + artifactId + \":\"\n                + version + \" due to \" + e.getMessage(), groupId, artifactId, version, e );\n        }\n\n        File pomFile = pomArtifact.getFile();\n\n        return new FileModelSource( pomFile );\n    }","id":60633,"modified_method":"public ModelSource resolveModel( String groupId, String artifactId, String version )\n        throws UnresolvableModelException\n    {\n        Artifact pomArtifact = new DefaultArtifact( groupId, artifactId, \"\", \"pom\", version );\n\n        try\n        {\n            ArtifactRequest request = new ArtifactRequest( pomArtifact, repositories, context );\n            pomArtifact = resolver.resolveArtifact( session, request ).getArtifact();\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            throw new UnresolvableModelException( e.getMessage(), groupId, artifactId, version, e );\n        }\n\n        File pomFile = pomArtifact.getFile();\n\n        return new FileModelSource( pomFile );\n    }","commit_id":"1be90a985a25e206682a9220b78dfe1f66700ab5","url":"https://github.com/apache/maven"},{"original_method":"public ModelSource resolveModel( String groupId, String artifactId, String version )\n        throws UnresolvableModelException\n    {\n        File pomFile = null;\n\n        if ( modelPool != null )\n        {\n            pomFile = modelPool.get( groupId, artifactId, version );\n        }\n\n        if ( pomFile == null )\n        {\n            Artifact pomArtifact = new DefaultArtifact( groupId, artifactId, \"\", \"pom\", version );\n\n            try\n            {\n                ArtifactRequest request = new ArtifactRequest( pomArtifact, repositories, context );\n                pomArtifact = resolver.resolveArtifact( session, request ).getArtifact();\n            }\n            catch ( ArtifactResolutionException e )\n            {\n                throw new UnresolvableModelException( \"Failed to resolve POM for \" + groupId + \":\" + artifactId + \":\"\n                    + version + \" due to \" + e.getMessage(), groupId, artifactId, version, e );\n            }\n\n            pomFile = pomArtifact.getFile();\n        }\n\n        return new FileModelSource( pomFile );\n    }","id":60634,"modified_method":"public ModelSource resolveModel( String groupId, String artifactId, String version )\n        throws UnresolvableModelException\n    {\n        File pomFile = null;\n\n        if ( modelPool != null )\n        {\n            pomFile = modelPool.get( groupId, artifactId, version );\n        }\n\n        if ( pomFile == null )\n        {\n            Artifact pomArtifact = new DefaultArtifact( groupId, artifactId, \"\", \"pom\", version );\n\n            try\n            {\n                ArtifactRequest request = new ArtifactRequest( pomArtifact, repositories, context );\n                pomArtifact = resolver.resolveArtifact( session, request ).getArtifact();\n            }\n            catch ( ArtifactResolutionException e )\n            {\n                throw new UnresolvableModelException( e.getMessage(), groupId, artifactId, version, e );\n            }\n\n            pomFile = pomArtifact.getFile();\n        }\n\n        return new FileModelSource( pomFile );\n    }","commit_id":"1be90a985a25e206682a9220b78dfe1f66700ab5","url":"https://github.com/apache/maven"},{"original_method":"/**\n     * Locates the field with the given name as a writable property. Searches only public properties.\n     *\n     * @throws NoSuchPropertyException when the given property does not exist.\n     */\n    public static PropertyMutator writeableField(Class<?> target, String fieldName) throws NoSuchPropertyException {\n        Field field;\n        try {\n            field = target.getField(fieldName);\n            return new FieldBackedPropertyMutator(fieldName, field);\n        } catch (java.lang.NoSuchFieldException e) {\n            throw new NoSuchPropertyException(String.format(\"Could not find writeable field '%s' on class %s.\", fieldName, target.getSimpleName()));\n        }\n    }","id":60635,"modified_method":"/**\n     * Locates the field with the given name as a writable property. Searches only public properties.\n     *\n     * @throws NoSuchPropertyException when the given property does not exist.\n     */\n    public static PropertyMutator writeableField(Class<?> target, String fieldName) throws NoSuchPropertyException {\n        Field field = findField(target, fieldName);\n        if (field != null) {\n            return new FieldBackedPropertyMutator(fieldName, field);\n        }\n        throw new NoSuchPropertyException(String.format(\"Could not find writeable field '%s' on class %s.\", fieldName, target.getSimpleName()));\n    }","commit_id":"67d9cb85fc6d3ea4a839e98de759cafdfc3369c7","url":"https://github.com/gradle/gradle"},{"original_method":"public static boolean propertyExists(Object target, String propertyName) {\n        Class<?> targetType = target.getClass();\n        Method getterMethod = findGetterMethod(target.getClass(), propertyName);\n        if (getterMethod == null) {\n            try {\n                targetType.getField(propertyName);\n                return true;\n            } catch (NoSuchFieldException ignore) {\n                // ignore\n            }\n        } else {\n            return true;\n        }\n\n        return false;\n    }","id":60636,"modified_method":"public static boolean propertyExists(Object target, String propertyName) {\n        Class<?> targetType = target.getClass();\n        Method getterMethod = findGetterMethod(target.getClass(), propertyName);\n        if (getterMethod == null) {\n            if (findField(targetType, propertyName) == null) {\n                return false;\n            }\n        }\n        return true;\n    }","commit_id":"67d9cb85fc6d3ea4a839e98de759cafdfc3369c7","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * Locates the field with the given name as a readable property.  Searches only public fields.\n     *\n     * @throws NoSuchPropertyException\n     */\n    public static <T, F> PropertyAccessor<T, F> readableField(Class<T> target, Class<F> fieldType, String fieldName) throws NoSuchPropertyException {\n        Field field;\n        try {\n            field = target.getField(fieldName);\n        } catch (java.lang.NoSuchFieldException e) {\n            throw new NoSuchPropertyException(String.format(\"Could not find field '%s' on class %s.\", fieldName, target.getSimpleName()));\n        }\n\n        return new FieldBackedPropertyAccessor<T, F>(fieldName, fieldType, field);\n    }","id":60637,"modified_method":"/**\n     * Locates the field with the given name as a readable property.  Searches only public fields.\n     *\n     * @throws NoSuchPropertyException\n     */\n    public static <T, F> PropertyAccessor<T, F> readableField(Class<T> target, Class<F> fieldType, String fieldName) throws NoSuchPropertyException {\n        Field field = findField(target, fieldName);\n        if (field == null) {\n            throw new NoSuchPropertyException(String.format(\"Could not find field '%s' on class %s.\", fieldName, target.getSimpleName()));\n        }\n\n        return new FieldBackedPropertyAccessor<T, F>(fieldName, fieldType, field);\n    }","commit_id":"67d9cb85fc6d3ea4a839e98de759cafdfc3369c7","url":"https://github.com/gradle/gradle"},{"original_method":"private static Method findGetterMethod(Class<?> target, String property) {\n        try {\n            Method getterMethod = target.getMethod(toMethodName(\"get\", property));\n            if (isGetter(getterMethod)) {\n                return getterMethod;\n            }\n        } catch (java.lang.NoSuchMethodException e) {\n            // Ignore\n        }\n        try {\n            Method getterMethod = target.getMethod(toMethodName(\"is\", property));\n            if (isBooleanGetter(getterMethod)) {\n                return getterMethod;\n            }\n        } catch (java.lang.NoSuchMethodException e2) {\n            // Ignore\n        }\n        return null;\n    }","id":60638,"modified_method":"private static Method findGetterMethod(Class<?> target, String property) {\n        Method[] methods = target.getMethods();\n        String getter = toMethodName(\"get\", property);\n        String iser = toMethodName(\"is\", property);\n        for (Method method : methods) {\n            String methodName = method.getName();\n            if (getter.equals(methodName) && isGetter(method)) {\n                return method;\n            }\n            if (iser.equals(methodName) && isBooleanGetter(method)) {\n                return method;\n            }\n        }\n        return null;\n    }","commit_id":"67d9cb85fc6d3ea4a839e98de759cafdfc3369c7","url":"https://github.com/gradle/gradle"},{"original_method":"public AddLibraryDialog(DataSourceList dataSourceList)\n\t{\n        super(VUE.getDialogParentAsFrame(),TITLE,true);\n\t\tthis.dataSourceList = dataSourceList;\n\t\t\n\t\ttry {\n\t\t\tfactory = edu.tufts.vue.dsm.impl.VueOsidFactory.getInstance();\n\t\t} catch (Throwable t) {\n\t\t\tt.printStackTrace();\n\t\t\tVueUtil.alert(\"Error instantiating Provider support\",\"Error\");\n\t\t}\n\n\t\ttry {\n\t\t\taddLibraryList = new JList(listModel);\n\t\t\taddLibraryList.setSelectionMode(DefaultListSelectionModel.SINGLE_SELECTION);\n\t\t\taddLibraryList.setPreferredSize(new Dimension(300,180));\n\t\t\taddLibraryList.addListSelectionListener(this);\n\n\t\t\tproviderListRenderer = new ProviderListCellRenderer();\n\t\t\taddLibraryList.setCellRenderer(providerListRenderer);\n\n\t\t\t\n\t\t\tdescriptionTextArea = new JTextArea();\n\t\t\tdescriptionTextArea.setLineWrap(true);\n\t\t\tdescriptionTextArea.setWrapStyleWord(true);\n\t\t\tdescriptionTextArea.setPreferredSize(new Dimension(300,180));\n\t\t\t\n\t\t\tpopulate();\n\t\t\t\n\t\t\tlistJsp = new JScrollPane(addLibraryList);\n\t\t\tlistJsp.setVerticalScrollBarPolicy(javax.swing.JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);\n\t\t\tlistJsp.setHorizontalScrollBarPolicy(javax.swing.JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);\n\t\t\t\n\t\t\tdescriptionTextArea.setText(\"description\");\n\t\t\tdescriptionJsp = new JScrollPane(descriptionTextArea);\n\t\t\tdescriptionJsp.setVerticalScrollBarPolicy(javax.swing.JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);\n\t\t\tdescriptionJsp.setHorizontalScrollBarPolicy(javax.swing.JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED); \n\t\t\t\n\t\t\taddLibraryPanel.setBackground(VueResources.getColor(\"White\"));\n\t\t\tsetBackground(VueResources.getColor(\"White\"));\n\t\t\t\n\t\t\tjava.awt.GridBagLayout gbLayout = new java.awt.GridBagLayout();\n\t\t\tjava.awt.GridBagConstraints gbConstraints = new java.awt.GridBagConstraints();\n\t\t\tgbConstraints.anchor = java.awt.GridBagConstraints.WEST;\n\t\t\tgbConstraints.insets = new java.awt.Insets(2,2,2,2);\n\t\t\taddLibraryPanel.setLayout(gbLayout);\n\t\t\t\n\t\t\tgbConstraints.gridx = 0;\n\t\t\tgbConstraints.gridy = 0;\n\t\t\taddLibraryPanel.add(new JLabel(AVAILABLE),gbConstraints);\n\t\t\t\n\t\t\tgbConstraints.gridx = 0;\n\t\t\tgbConstraints.gridy = 1;\n\t\t\taddLibraryPanel.add(listJsp,gbConstraints);\n\t\t\t\n\t\t\tgbConstraints.gridx = 0;\n\t\t\tgbConstraints.gridy = 2;\n\t\t\taddLibraryPanel.add(descriptionJsp,gbConstraints);\n\t\t\t\n\t\t\tbuttonPanel.add(cancelButton);\n\t\t\tcancelButton.addActionListener(this);\n\t\t\tbuttonPanel.add(addButton);\n\t\t\taddButton.addActionListener(this);\t\t\t\n\t\t\tgetRootPane().setDefaultButton(addButton);\n\t\t\t\n\t\t\tgbConstraints.gridx = 0;\n\t\t\tgbConstraints.gridy = 3;\n\t\t\taddLibraryPanel.add(buttonPanel,gbConstraints);\n\t\t\t\n\t\t\tgetContentPane().add(addLibraryPanel,BorderLayout.CENTER);\n\t\t\tpack();\n\t\t\tsetLocation(300,300);\n\t\t} catch (Throwable t) {\n\t\t\tt.printStackTrace();\n\t\t}\n\t\tsetVisible(true);\n    }","id":60639,"modified_method":"public AddLibraryDialog(DataSourceList dataSourceList)\n\t{\n        super(VUE.getDialogParentAsFrame(),TITLE,true);\n\t\tthis.dataSourceList = dataSourceList;\n\t\t\n\t\ttry {\n\t\t\tfactory = edu.tufts.vue.dsm.impl.VueOsidFactory.getInstance();\n\t\t} catch (Throwable t) {\n\t\t\tt.printStackTrace();\n\t\t\tVueUtil.alert(\"Error instantiating Provider support\",\"Error\");\n\t\t}\n\n\t\ttry {\n\t\t\taddLibraryList = new JList(listModel);\n\t\t\taddLibraryList.setSelectionMode(DefaultListSelectionModel.SINGLE_SELECTION);\n\t\t\taddLibraryList.addListSelectionListener(this);\n\t\t\taddLibraryList.setFixedCellHeight(25);\n\n\t\t\tproviderListRenderer = new ProviderListCellRenderer();\n\t\t\taddLibraryList.setCellRenderer(providerListRenderer);\n\n\t\t\tdescriptionTextArea = new JTextArea();\n\t\t\tdescriptionTextArea.setLineWrap(true);\n\t\t\tdescriptionTextArea.setWrapStyleWord(true);\n\t\t\t\n\t\t\tpopulate();\n\t\t\t\n\t\t\tlistJsp = new JScrollPane(addLibraryList);\n\t\t\tlistJsp.setVerticalScrollBarPolicy(javax.swing.JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);\n\t\t\tlistJsp.setHorizontalScrollBarPolicy(javax.swing.JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n\t\t\tlistJsp.setPreferredSize(new Dimension(300,180));\n\t\t\t\n\t\t\tdescriptionTextArea.setText(\"description\");\n\t\t\tdescriptionJsp = new JScrollPane(descriptionTextArea);\n\t\t\tdescriptionJsp.setVerticalScrollBarPolicy(javax.swing.JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);\n\t\t\tdescriptionJsp.setHorizontalScrollBarPolicy(javax.swing.JScrollPane.HORIZONTAL_SCROLLBAR_NEVER); \n\t\t\tdescriptionJsp.setPreferredSize(new Dimension(300,180));\n\t\t\t\n\t\t\taddLibraryPanel.setBackground(VueResources.getColor(\"White\"));\n\t\t\tsetBackground(VueResources.getColor(\"White\"));\n\t\t\t\n\t\t\tjava.awt.GridBagLayout gbLayout = new java.awt.GridBagLayout();\n\t\t\tjava.awt.GridBagConstraints gbConstraints = new java.awt.GridBagConstraints();\n\t\t\tgbConstraints.anchor = java.awt.GridBagConstraints.WEST;\n\t\t\tgbConstraints.insets = new java.awt.Insets(2,2,2,2);\n\t\t\taddLibraryPanel.setLayout(gbLayout);\n\t\t\t\n\t\t\tgbConstraints.gridx = 0;\n\t\t\tgbConstraints.gridy = 0;\n\t\t\taddLibraryPanel.add(new JLabel(AVAILABLE),gbConstraints);\n\t\t\t\n\t\t\tgbConstraints.gridx = 0;\n\t\t\tgbConstraints.gridy = 1;\n\t\t\taddLibraryPanel.add(listJsp,gbConstraints);\n\t\t\t\n\t\t\tgbConstraints.gridx = 0;\n\t\t\tgbConstraints.gridy = 2;\n\t\t\taddLibraryPanel.add(descriptionJsp,gbConstraints);\n\t\t\t\n\t\t\tbuttonPanel.add(cancelButton);\n\t\t\tcancelButton.addActionListener(this);\n\t\t\tbuttonPanel.add(addButton);\n\t\t\taddButton.addActionListener(this);\t\t\t\n\t\t\tgetRootPane().setDefaultButton(addButton);\n\t\t\t\n\t\t\tgbConstraints.gridx = 0;\n\t\t\tgbConstraints.gridy = 3;\n\t\t\taddLibraryPanel.add(buttonPanel,gbConstraints);\n\t\t\t\n\t\t\tgetContentPane().add(addLibraryPanel,BorderLayout.CENTER);\n\t\t\tpack();\n\t\t\tsetLocation(300,300);\n\t\t} catch (Throwable t) {\n\t\t\tt.printStackTrace();\n\t\t}\n\t\tsetVisible(true);\n    }","commit_id":"53a1c48ec64abda8e55cff95b8e85b1813da2be1","url":"https://github.com/VUE/VUE"},{"original_method":"public ProviderListCellRenderer()\n    {\n\t\ttry {\n\t\t\tfactory = edu.tufts.vue.dsm.impl.VueOsidFactory.getInstance();\n\t\t} catch (Throwable t) {\n\t\t\t\n\t\t}\n        mRow.setLayout(new BoxLayout(mRow, BoxLayout.X_AXIS));\n        mRow.setOpaque(true);\n        \n        mLabel.setMinimumSize(new Dimension(10, mLabel.getHeight()));\n        mLabel.setPreferredSize(new Dimension(Short.MAX_VALUE, mLabel.getHeight()));\n        \n        waitLabel = new JLabel();\n        waitLabel.setDoubleBuffered(true);\n        waitLabel.setIcon(waitIcon);\n        \n        \n        mRow.add(Box.createHorizontalStrut(GUI.WidgetInsets.left));\n        mRow.add(mCheckBox);\n        mRow.add(Box.createHorizontalStrut(GUI.WidgetInsets.left));\n        mRow.add(mLabel);\n        mRow.add(mIconLabel);\n        mRow.add(Box.createHorizontalStrut(GUI.WidgetInsets.right));\n    }","id":60640,"modified_method":"public ProviderListCellRenderer()\n    {\n\t\ttry {\n\t\t\tfactory = edu.tufts.vue.dsm.impl.VueOsidFactory.getInstance();\n\t\t} catch (Throwable t) {\n\t\t\t\n\t\t}\n        mRow.setLayout(new BoxLayout(mRow, BoxLayout.X_AXIS));\n        mRow.setOpaque(true);\n        \n        mLabel.setMinimumSize(new Dimension(10, mLabel.getHeight()));\n        mLabel.setPreferredSize(new Dimension(Short.MAX_VALUE, mLabel.getHeight()));\n        \n        waitLabel = new JLabel();\n        waitLabel.setDoubleBuffered(true);\n        waitLabel.setIcon(waitIcon);\n        \n        \n        mRow.add(Box.createHorizontalStrut(GUI.WidgetInsets.left));\n        mRow.add(mCheckBox);\n        mRow.add(Box.createHorizontalStrut(GUI.WidgetInsets.left));\n        mRow.add(mLabel);\n        mRow.add(Box.createHorizontalStrut(GUI.WidgetInsets.right));\n        mRow.add(mIconLabel);\n    }","commit_id":"53a1c48ec64abda8e55cff95b8e85b1813da2be1","url":"https://github.com/VUE/VUE"},{"original_method":"/**\r\n     * The dependent service is available and the bundle will start.\r\n     * @param dependentService the UIService this activator is waiting.\r\n     */\r\n    @Override\r\n    public void start(Object dependentService)\r\n    {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Update checker [STARTED]\");\r\n\r\n        ConfigurationService cfg = getConfiguration();\r\n\r\n        if (OSUtils.IS_WINDOWS)\r\n        {\r\n            updateService = new Update();\r\n\r\n            bundleContext.registerService(\r\n                UpdateService.class.getName(),\r\n                updateService,\r\n                null);\r\n\r\n            // Register the \"Check for Updates\" menu item if\r\n            // the \"Check for Updates\" property isn't disabled.\r\n            if(!cfg.getBoolean(CHECK_FOR_UPDATES_MENU_DISABLED_PROP, false))\r\n            {\r\n                // Register the \"Check for Updates\" menu item.\r\n                CheckForUpdatesMenuItemComponent\r\n                    checkForUpdatesMenuItemComponent\r\n                    = new CheckForUpdatesMenuItemComponent(\r\n                            Container.CONTAINER_HELP_MENU);\r\n\r\n                Hashtable<String, String> toolsMenuFilter\r\n                    = new Hashtable<String, String>();\r\n                toolsMenuFilter.put(\r\n                        Container.CONTAINER_ID,\r\n                        Container.CONTAINER_HELP_MENU.getID());\r\n\r\n                bundleContext.registerService(\r\n                        PluginComponent.class.getName(),\r\n                        checkForUpdatesMenuItemComponent,\r\n                        toolsMenuFilter);\r\n            }\r\n\r\n            // Check for software update upon startup if enabled.\r\n            if(cfg.getBoolean(UPDATE_ENABLED, true))\r\n                updateService.checkForUpdates(false);\r\n        }\r\n\r\n        if (cfg.getBoolean(CHECK_FOR_UPDATES_DAILY_ENABLED_PROP,\r\n                                     false))\r\n        {\r\n            logger.info(\"Scheduled update checking enabled\");\r\n\r\n            // Schedule a \"check for updates\" task that will run once a day\r\n            int hoursToWait = calcHoursToWait();\r\n            Runnable updateRunnable = new Runnable()\r\n            {\r\n                public void run()\r\n                {\r\n                    logger.debug(\"Performing scheduled update check\");\r\n                    getUpdateService().checkForUpdates(false);\r\n                }\r\n            };\r\n\r\n            mUpdateExecutor = Executors.newSingleThreadScheduledExecutor();\r\n            mUpdateExecutor.scheduleAtFixedRate(updateRunnable,\r\n                                                hoursToWait,\r\n                                                24*60*60,\r\n                                                TimeUnit.SECONDS);\r\n        }\r\n\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Update checker [REGISTERED]\");\r\n    }","id":60641,"modified_method":"/**\r\n     * The dependent service is available and the bundle will start.\r\n     * @param dependentService the UIService this activator is waiting.\r\n     */\r\n    @Override\r\n    public void start(Object dependentService)\r\n    {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Update checker [STARTED]\");\r\n\r\n        ConfigurationService cfg = getConfiguration();\r\n\r\n        if (OSUtils.IS_WINDOWS)\r\n        {\r\n            updateService = new UpdateServiceImpl();\r\n\r\n            bundleContext.registerService(\r\n                UpdateService.class.getName(),\r\n                updateService,\r\n                null);\r\n\r\n            // Register the \"Check for Updates\" menu item if\r\n            // the \"Check for Updates\" property isn't disabled.\r\n            if(!cfg.getBoolean(CHECK_FOR_UPDATES_MENU_DISABLED_PROP, false))\r\n            {\r\n                // Register the \"Check for Updates\" menu item.\r\n                CheckForUpdatesMenuItemComponent\r\n                    checkForUpdatesMenuItemComponent\r\n                    = new CheckForUpdatesMenuItemComponent(\r\n                            Container.CONTAINER_HELP_MENU);\r\n\r\n                Hashtable<String, String> toolsMenuFilter\r\n                    = new Hashtable<String, String>();\r\n                toolsMenuFilter.put(\r\n                        Container.CONTAINER_ID,\r\n                        Container.CONTAINER_HELP_MENU.getID());\r\n\r\n                bundleContext.registerService(\r\n                        PluginComponent.class.getName(),\r\n                        checkForUpdatesMenuItemComponent,\r\n                        toolsMenuFilter);\r\n            }\r\n\r\n            // Check for software update upon startup if enabled.\r\n            if(cfg.getBoolean(UPDATE_ENABLED, true))\r\n                updateService.checkForUpdates(false);\r\n        }\r\n\r\n        if (cfg.getBoolean(CHECK_FOR_UPDATES_DAILY_ENABLED_PROP,\r\n                                     false))\r\n        {\r\n            logger.info(\"Scheduled update checking enabled\");\r\n\r\n            // Schedule a \"check for updates\" task that will run once a day\r\n            int hoursToWait = calcHoursToWait();\r\n            Runnable updateRunnable = new Runnable()\r\n            {\r\n                public void run()\r\n                {\r\n                    logger.debug(\"Performing scheduled update check\");\r\n                    getUpdateService().checkForUpdates(false);\r\n                }\r\n            };\r\n\r\n            mUpdateExecutor = Executors.newSingleThreadScheduledExecutor();\r\n            mUpdateExecutor.scheduleAtFixedRate(updateRunnable,\r\n                                                hoursToWait,\r\n                                                24*60*60,\r\n                                                TimeUnit.SECONDS);\r\n        }\r\n\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Update checker [REGISTERED]\");\r\n    }","commit_id":"f7f58da22029c7a07397856a700760118d30c1aa","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Shows dialog informing about new version with button Install\n     * which triggers the update process.\n     */\n    private static void showWindowsNewVersionAvailableDialog()\n    {\n        /*\n         * Before showing the dialog, we'll enterCheckForUpdates() in order to\n         * notify that it is not safe to enter \"Check for Updates\" again. If we\n         * don't manage to show the dialog, we'll have to exitCheckForUpdates().\n         * If we manage though, we'll have to exitCheckForUpdates() but only\n         * once depending on its modality.\n         */\n        final boolean[] exitCheckForUpdates = new boolean[] { false };\n        final JDialog dialog = new SIPCommDialog()\n        {\n            private static final long serialVersionUID = 0L;\n\n            @Override\n            protected void close(boolean escaped)\n            {\n                synchronized (exitCheckForUpdates)\n                {\n                    if (exitCheckForUpdates[0])\n                        exitCheckForUpdates(this);\n                }\n            }\n        };\n        ResourceManagementService r = Resources.getResources();\n\n        dialog.setTitle(r.getI18NString(\"plugin.updatechecker.DIALOG_TITLE\"));\n\n        JEditorPane contentMessage = new JEditorPane();\n        contentMessage.setContentType(\"text/html\");\n        contentMessage.setOpaque(false);\n        contentMessage.setEditable(false);\n\n        /*\n         * Use the font of the dialog because contentMessage is just like a\n         * label.\n         */\n        contentMessage.putClientProperty(\n                JEditorPane.HONOR_DISPLAY_PROPERTIES,\n                Boolean.TRUE);\n\n        String dialogMsg\n            = r.getI18NString(\n                    \"plugin.updatechecker.DIALOG_MESSAGE\",\n                    new String[]\n                            {\n                                r.getSettingsString(\n                                        \"service.gui.APPLICATION_NAME\")\n                            });\n\n        if(latestVersion != null)\n        {\n            dialogMsg\n                += r.getI18NString(\n                        \"plugin.updatechecker.DIALOG_MESSAGE_2\",\n                        new String[]\n                                {\n                                    r.getSettingsString(\n                                            \"service.gui.APPLICATION_NAME\"),\n                                    latestVersion\n                                });\n        }\n\n        contentMessage.setText(dialogMsg);\n\n        JPanel contentPane = new SIPCommFrame.MainContentPane();\n        contentMessage.setBorder(BorderFactory.createEmptyBorder(10, 0, 20, 0));\n        contentPane.setBorder(BorderFactory.createEmptyBorder(0, 10, 0, 10));\n        contentPane.add(contentMessage, BorderLayout.NORTH);\n\n        JScrollPane scrollChanges = new JScrollPane();\n        scrollChanges.setPreferredSize(new Dimension(550, 200));\n        JEditorPane changesHtml = new JEditorPane();\n        changesHtml.setContentType(\"text/html\");\n        changesHtml.setEditable(false);\n        changesHtml.setBorder(BorderFactory.createLoweredBevelBorder());\n        scrollChanges.setViewportView(changesHtml);\n        contentPane.add(scrollChanges, BorderLayout.CENTER);\n        try\n        {\n            Document changesHtmlDocument = changesHtml.getDocument();\n\n            if (changesHtmlDocument instanceof AbstractDocument)\n            {\n                ((AbstractDocument) changesHtmlDocument)\n                    .setAsynchronousLoadPriority(0);\n            }\n            changesHtml.setPage(new URL(changesLink));\n        }\n        catch (Exception e)\n        {\n            logger.error(\"Cannot set changes Page\", e);\n        }\n\n        JPanel buttonPanel\n            = new TransparentPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));\n        final JButton closeButton\n            = new JButton(\n                    r.getI18NString(\n                            \"plugin.updatechecker.BUTTON_CLOSE\"));\n\n        closeButton.addActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                dialog.dispose();\n                if (exitCheckForUpdates[0])\n                    exitCheckForUpdates(dialog);\n            }\n        });\n\n        if(downloadLink != null)\n        {\n            JButton installButton\n                = new JButton(\n                        r.getI18NString(\"plugin.updatechecker.BUTTON_INSTALL\"));\n\n            installButton.addActionListener(new ActionListener()\n            {\n                public void actionPerformed(ActionEvent e)\n                {\n                    if(OSUtils.IS_WINDOWS64)\n                        downloadLink = downloadLink.replace(\"x86\", \"x64\");\n\n                    enterCheckForUpdates(null);\n                    try\n                    {\n                        /*\n                         * Do the same as the Close button in order to not\n                         * duplicate the code.\n                         */\n                        closeButton.doClick();\n                    }\n                    finally\n                    {\n                        boolean windowsUpdateThreadHasStarted = false;\n\n                        try\n                        {\n                            new Thread()\n                            {\n                                @Override\n                                public void run()\n                                {\n                                    try\n                                    {\n                                        windowsUpdate();\n                                    }\n                                    finally\n                                    {\n                                        exitCheckForUpdates(null);\n                                    }\n                                }\n                            }.start();\n                            windowsUpdateThreadHasStarted = true;\n                        }\n                        finally\n                        {\n                            if (!windowsUpdateThreadHasStarted)\n                                exitCheckForUpdates(null);\n                        }\n                    }\n                }\n            });\n\n            buttonPanel.add(installButton);\n        }\n\n        buttonPanel.add(closeButton);\n\n        contentPane.add(buttonPanel, BorderLayout.SOUTH);\n\n        dialog.setContentPane(contentPane);\n\n        dialog.pack();\n\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n        dialog.setLocation(\n                screenSize.width/2 - dialog.getWidth()/2,\n                screenSize.height/2 - dialog.getHeight()/2);\n\n        synchronized (exitCheckForUpdates)\n        {\n            enterCheckForUpdates(dialog);\n            exitCheckForUpdates[0] = true;\n        }\n        try\n        {\n            dialog.setVisible(true);\n        }\n        finally\n        {\n            synchronized (exitCheckForUpdates)\n            {\n                if (exitCheckForUpdates[0] && dialog.isModal())\n                    exitCheckForUpdates(dialog);\n            }\n        }\n    }","id":60642,"modified_method":"/**\n     * Shows dialog informing about new version with button Install\n     * which triggers the update process.\n     */\n    private static void showWindowsNewVersionAvailableDialog()\n    {\n        /*\n         * Before showing the dialog, we'll enterCheckForUpdates() in order to\n         * notify that it is not safe to enter \"Check for Updates\" again. If we\n         * don't manage to show the dialog, we'll have to exitCheckForUpdates().\n         * If we manage though, we'll have to exitCheckForUpdates() but only\n         * once depending on its modality.\n         */\n        final boolean[] exitCheckForUpdates = new boolean[] { false };\n        final JDialog dialog = new SIPCommDialog()\n        {\n            private static final long serialVersionUID = 0L;\n\n            @Override\n            protected void close(boolean escaped)\n            {\n                synchronized (exitCheckForUpdates)\n                {\n                    if (exitCheckForUpdates[0])\n                        exitCheckForUpdates(this);\n                }\n            }\n        };\n        ResourceManagementService r = Resources.getResources();\n\n        dialog.setTitle(r.getI18NString(\"plugin.updatechecker.DIALOG_TITLE\"));\n\n        JEditorPane contentMessage = new JEditorPane();\n        contentMessage.setContentType(\"text/html\");\n        contentMessage.setOpaque(false);\n        contentMessage.setEditable(false);\n\n        /*\n         * Use the font of the dialog because contentMessage is just like a\n         * label.\n         */\n        contentMessage.putClientProperty(\n                JEditorPane.HONOR_DISPLAY_PROPERTIES,\n                Boolean.TRUE);\n\n        String dialogMsg\n            = r.getI18NString(\n                    \"plugin.updatechecker.DIALOG_MESSAGE\",\n                    new String[]\n                            {\n                                r.getSettingsString(\n                                        \"service.gui.APPLICATION_NAME\")\n                            });\n\n        if(latestVersion != null)\n        {\n            dialogMsg\n                += r.getI18NString(\n                        \"plugin.updatechecker.DIALOG_MESSAGE_2\",\n                        new String[]\n                                {\n                                    r.getSettingsString(\n                                            \"service.gui.APPLICATION_NAME\"),\n                                    latestVersion\n                                });\n        }\n\n        contentMessage.setText(dialogMsg);\n\n        JPanel contentPane = new SIPCommFrame.MainContentPane();\n        contentMessage.setBorder(BorderFactory.createEmptyBorder(10, 0, 20, 0));\n        contentPane.setBorder(BorderFactory.createEmptyBorder(0, 10, 0, 10));\n        contentPane.add(contentMessage, BorderLayout.NORTH);\n\n        Component browser = createBrowser(changesLink);\n\n        if (browser != null)\n        {\n            browser.setPreferredSize(new Dimension(550, 200));\n            contentPane.add(browser, BorderLayout.CENTER);\n        }\n\n        JPanel buttonPanel\n            = new TransparentPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));\n        final JButton closeButton\n            = new JButton(\n                    r.getI18NString(\n                            \"plugin.updatechecker.BUTTON_CLOSE\"));\n\n        closeButton.addActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                dialog.dispose();\n                if (exitCheckForUpdates[0])\n                    exitCheckForUpdates(dialog);\n            }\n        });\n\n        if(downloadLink != null)\n        {\n            JButton installButton\n                = new JButton(\n                        r.getI18NString(\"plugin.updatechecker.BUTTON_INSTALL\"));\n\n            installButton.addActionListener(new ActionListener()\n            {\n                public void actionPerformed(ActionEvent e)\n                {\n                    if(OSUtils.IS_WINDOWS64)\n                        downloadLink = downloadLink.replace(\"x86\", \"x64\");\n\n                    enterCheckForUpdates(null);\n                    try\n                    {\n                        /*\n                         * Do the same as the Close button in order to not\n                         * duplicate the code.\n                         */\n                        closeButton.doClick();\n                    }\n                    finally\n                    {\n                        boolean windowsUpdateThreadHasStarted = false;\n\n                        try\n                        {\n                            new Thread()\n                            {\n                                @Override\n                                public void run()\n                                {\n                                    try\n                                    {\n                                        windowsUpdate();\n                                    }\n                                    finally\n                                    {\n                                        exitCheckForUpdates(null);\n                                    }\n                                }\n                            }.start();\n                            windowsUpdateThreadHasStarted = true;\n                        }\n                        finally\n                        {\n                            if (!windowsUpdateThreadHasStarted)\n                                exitCheckForUpdates(null);\n                        }\n                    }\n                }\n            });\n\n            buttonPanel.add(installButton);\n        }\n\n        buttonPanel.add(closeButton);\n\n        contentPane.add(buttonPanel, BorderLayout.SOUTH);\n\n        dialog.setContentPane(contentPane);\n\n        dialog.pack();\n\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n        dialog.setLocation(\n                screenSize.width/2 - dialog.getWidth()/2,\n                screenSize.height/2 - dialog.getHeight()/2);\n\n        synchronized (exitCheckForUpdates)\n        {\n            enterCheckForUpdates(dialog);\n            exitCheckForUpdates[0] = true;\n        }\n        try\n        {\n            dialog.setVisible(true);\n        }\n        finally\n        {\n            synchronized (exitCheckForUpdates)\n            {\n                if (exitCheckForUpdates[0] && dialog.isModal())\n                    exitCheckForUpdates(dialog);\n            }\n        }\n    }","commit_id":"f7f58da22029c7a07397856a700760118d30c1aa","url":"https://github.com/jitsi/jitsi"},{"original_method":"public String toString() {\n        return \"BlobIcon[\" + mColor + \"]\";\n    }","id":60643,"modified_method":"public String toString() {\n        return \"BlobIcon[\" + paramString() + \"]\";\n    }","commit_id":"cacf3a1ceee4871096c989bd47c5f8b4baa3b1b5","url":"https://github.com/VUE/VUE"},{"original_method":"public String toString() {\n        return \"LineIcon[\" + (mColor==null?\"\":(mColor + \", \")) + mWeight + \"]\";\n    }","id":60644,"modified_method":"public String toString() {\n        return \"LineIcon[\" + paramString() + \"]\";\n    }","commit_id":"cacf3a1ceee4871096c989bd47c5f8b4baa3b1b5","url":"https://github.com/VUE/VUE"},{"original_method":"/**\n     * Set the raw icon used for displaying as a button (may be additionally decorated).\n     * Intended for use during initialization.\n     **/\n    public void setButtonIcon(Icon i) {\n        System.out.println(\"MenuButton \" + this + \" setButtonIcon \" + i);\n        if (DEBUG.Enabled) new Throwable().printStackTrace();\n        _setIcon(mButtonIcon = i);\n    }","id":60645,"modified_method":"/**\n     * Set the raw icon used for displaying as a button (may be additionally decorated).\n     * Intended for use during initialization.\n     **/\n    public void setButtonIcon(Icon i) {\n        if (DEBUG.BOXES||DEBUG.TOOL) System.out.println(\"MenuButton \" + this + \" setButtonIcon \" + i);\n        //if (DEBUG.Enabled) new Throwable().printStackTrace();\n        _setIcon(mButtonIcon = i);\n    }","commit_id":"cacf3a1ceee4871096c989bd47c5f8b4baa3b1b5","url":"https://github.com/VUE/VUE"},{"original_method":"public void paint(java.awt.Graphics g) {\n        ((java.awt.Graphics2D)g).setRenderingHint\n            (java.awt.RenderingHints.KEY_TEXT_ANTIALIASING,\n             java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n        super.paint(g);\n    }","id":60646,"modified_method":"public void paint(java.awt.Graphics g) {\n        ((java.awt.Graphics2D)g).setRenderingHint\n            (java.awt.RenderingHints.KEY_TEXT_ANTIALIASING,\n             java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n        super.paint(g);\n        if (true) setToolTipText(null);//tmp debug\n        /*\n        int w = getWidth();\n        int h = getHeight();\n        g.setColor(Color.black);\n        final int arrowWidth = 5; // make sure is odd #\n        int x = w - (arrowWidth + 3);\n        int y = h / 2 - 1;\n        for (int len = arrowWidth; len > 0; len -= 2) {\n            g.drawLine(x,y,x+len,y);\n            y++;\n            x++;\n        }\n        */\n    }","commit_id":"cacf3a1ceee4871096c989bd47c5f8b4baa3b1b5","url":"https://github.com/VUE/VUE"},{"original_method":"private void _setIcon(Icon i) {\n        if (false) {\n            super.setIcon(i);\n            super.setRolloverIcon(new VueButtonIcon(i, VueButtonIcon.ROLLOVER));\n        } else {\n            final int pad = 7;\n            Dimension d = new Dimension(i.getIconWidth()+pad, i.getIconHeight()+pad);\n            if (d.width < 21) d.width = 21; // todo: config\n            if (d.height < 21) d.height = 21; // todo: config\n            VueButtonIcon.installGenerated(this, i, d);\n            System.out.println(\"MenuButton \" + this + \" *** installed generated, setPreferredSize \" + d);\n            setPreferredSize(d);\n        }\n    }","id":60647,"modified_method":"private void _setIcon(Icon i) {\n        /*\n            super.setIcon(i);\n            super.setRolloverIcon(new VueButtonIcon(i, VueButtonIcon.ROLLOVER));\n        */\n        /*\n          final int pad = 7;\n          Dimension d = new Dimension(i.getIconWidth()+pad, i.getIconHeight()+pad);\n          if (d.width < 21) d.width = 21; // todo: config\n          if (d.height < 21) d.height = 21; // todo: config\n        */\n        Dimension d = getButtonSize();\n        VueButtonIcon.installGenerated(this, new MenuProxyIcon(i), d);\n        System.out.println(\"MenuButton \" + this + \" *** installed generated, setPreferredSize \" + d);\n        setPreferredSize(d);\n    }","commit_id":"cacf3a1ceee4871096c989bd47c5f8b4baa3b1b5","url":"https://github.com/VUE/VUE"},{"original_method":"public void add() {\n        \n        try {\n\t\t\tboolean proceed = true;\n            this.oldDataSource = null;\n            Object o = addLibraryList.getSelectedValue();\n            String xml = null;\n            String s = null;\n            \n            if (o instanceof String) {\n                s = (String)o;\n                if (s.equals(MY_COMPUTER)) {\n                    LocalFileDataSource ds = new LocalFileDataSource(MY_COMPUTER,\"\");\n                    xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><configuration><field><key>name<\/key><title>Name<\/title><description>Name for this datasource<\/description><default>DEFAULT_NAME<\/default><mandatory>true<\/mandatory><maxChars><\/maxChars><ui>0<\/ui><\/field><field><key>address<\/key><title>Starting path<\/title><description>The path to start from<\/description><default>DEFAULT_ADDRESS<\/default><mandatory>true<\/mandatory><maxChars>512<\/maxChars><ui>0<\/ui><\/field><\/configuration>\";\n                    String name = ds.getDisplayName();\n                    String address = ds.getAddress();\n                    xml = xml.replaceFirst(\"DEFAULT_NAME\",name);\n                    xml = xml.replaceFirst(\"DEFAULT_ADDRESS\",address);\n                    this.oldDataSource = ds;\n                } else if (s.equals(MY_SAVED_CONTENT)) {\n                    FavoritesDataSource ds = new FavoritesDataSource(MY_SAVED_CONTENT);\n                    xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><configuration><field><key>name<\/key><title>Name<\/title><description>Name for this datasource<\/description><default>DEFAULT_NAME<\/default><mandatory>true<\/mandatory><maxChars><\/maxChars><ui>0<\/ui><\/field><\/configuration>\";\n                    String name = ds.getDisplayName();\n                    xml = xml.replaceFirst(\"DEFAULT_NAME\",name);\n                    this.oldDataSource = ds;\n                } else if (s.equals(FTP)) {\n                    RemoteFileDataSource ds = new RemoteFileDataSource();\n                    xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><configuration><field><key>name<\/key><title>Display Name<\/title><description>Dane for this datasource<\/description><default>DEFAULT_NAME<\/default><mandatory>true<\/mandatory><maxChars><\/maxChars><ui>0<\/ui><\/field><field><key>address<\/key><title>Address<\/title><description>FTP Address<\/description><default>DEFAULT_ADDRESS<\/default><mandatory>true<\/mandatory><maxChars>256<\/maxChars><ui>0<\/ui><\/field><field><key>username<\/key><title>Username<\/title><description>FTP site username<\/description><default>DEFAULT_USERNAME<\/default><mandatory>true<\/mandatory><maxChars>64<\/maxChars><ui>0<\/ui><\/field><field><key>password<\/key><title>Password<\/title><description>FTP site password for username<\/description><default>DEFAULT_PASSWORD<\/default><mandatory>true<\/mandatory><maxChars><\/maxChars><ui>1<\/ui><\/field><\/configuration>\";\n                    String name = ds.getDisplayName();\n                    if (name == null) name = \"\";\n                    String address = ds.getAddress();\n                    if (address == null) address = \"\";\n                    String username = ds.getUserName();\n                    if (username == null) username = \"\";\n                    String password = ds.getPassword();\n                    if (password == null) password = \"\";\n                    xml = xml.replaceFirst(\"DEFAULT_NAME\",name);\n                    xml = xml.replaceFirst(\"DEFAULT_ADDRESS\",address);\n                    xml = xml.replaceFirst(\"DEFAULT_USERNAME\",username);\n                    xml = xml.replaceFirst(\"DEFAULT_PASSWORD\",password);\n                    this.oldDataSource = ds;\n                }\n            } else {\n                org.osid.provider.Provider provider = (org.osid.provider.Provider)o;\n                \n                edu.tufts.vue.dsm.DataSource ds = null;\n                // show dialog containing license, if any\n                try {\n                    if (provider.requestsLicenseAcknowledgement()) {\n                        String license = provider.getLicense();\n                        if (license != null) {\n                            javax.swing.JTextArea area = new javax.swing.JTextArea();\n                            area.setLineWrap(true);\n                            area.setText(license);\n                            area.setEditable(false);\n                            area.setSize(new Dimension(500,300));\n                            if (javax.swing.JOptionPane.showOptionDialog(this,\n                                    area,\n                                    \"License Acknowledgement\",\n                                    javax.swing.JOptionPane.DEFAULT_OPTION,\n                                    javax.swing.JOptionPane.QUESTION_MESSAGE,\n                                    null,\n                                    new Object[] {\n                                \"Accept\", \"Decline\"\n                            },\n                                    \"Decline\") != 0) {\n                                return;\n                            }\n                        }\n                    }\n                    \n                    //System.out.println(\"checking if installed\");\n                    if (proceed && (!provider.isInstalled())) {\n                        System.out.println(\"installing...\");\n                        factory = edu.tufts.vue.dsm.impl.VueOsidFactory.getInstance();\n                        try {\n                            GUI.activateWaitCursor();\n                            factory.installProvider(provider.getId());\n                        } catch (Throwable t1) {\n                            System.out.println(\"install failed \" + provider.getId().getIdString());\n                            VueUtil.alert(\"Installation Failed\",\"Error\");\n                            return;\n                        } finally {\n                            GUI.clearWaitCursor();\n                        }\n                    } else {\n                        //System.out.println(\"No need to install\");\n                    }\n                    \n                    if (proceed) {\n                        // add to data sources list\n                        try {\n                            //System.out.println(\"creating data source\");\n                            ds = new edu.tufts.vue.dsm.impl.VueDataSource(factory.getIdManagerInstance().createId(),\n                                    provider.getId(),\n                                    true);\n                        } catch (Throwable t) {\n                            VueUtil.alert(\"Loading Manager Failed\",\"Error\");\n                            return;\n                        }\n                        //System.out.println(\"created data source\");\n                        \n                        // show configuration, if needed\n                        if (ds.hasConfiguration()) {\n                            xml = ds.getConfigurationUIHints();\n                        } else {\n                            //System.out.println(\"No configuration to show\");\n                        }\n                        this.newDataSource = ds;\n                    }\n                } catch (Throwable t) {\n                    //System.out.println(\"configuration setup failed\");\n                    VueUtil.alert(t.getMessage(),\"OSID Installation Error\");\n                    t.printStackTrace();\n                    return;\n                }\n            }\n            \n            if (xml != null) {\n                edu.tufts.vue.ui.ConfigurationUI cui =\n                        new edu.tufts.vue.ui.ConfigurationUI(new java.io.ByteArrayInputStream(xml.getBytes()));\n                cui.setPreferredSize(new Dimension(400,200));\n                \n                if (javax.swing.JOptionPane.showOptionDialog(this,\n                        cui,\n                        \"Configuration\",\n                        javax.swing.JOptionPane.DEFAULT_OPTION,\n                        javax.swing.JOptionPane.QUESTION_MESSAGE,\n                        null,\n                        new Object[] {\n                    \"Cancel\", \"Continue\"\n                },\n                        \"Continue\") == 0) {\n\t\t\t\t\tproceed = false;\n\t\t\t\t} else {\n                    if (s != null) {\n                        if (s.equals(MY_COMPUTER)) {\n                            java.util.Properties p = cui.getProperties();\n                            LocalFileDataSource ds = (LocalFileDataSource)this.oldDataSource;\n                            ds.setDisplayName(p.getProperty(\"name\"));\n                            ds.setAddress(p.getProperty(\"address\"));\n                        } else if (s.equals(MY_SAVED_CONTENT)) {\n                            java.util.Properties p = cui.getProperties();\n                            FavoritesDataSource ds = (FavoritesDataSource)this.oldDataSource;\n                            ds.setDisplayName(p.getProperty(\"name\"));\n                        } else if (s.equals(FTP)) {\n                            java.util.Properties p = cui.getProperties();\n                            RemoteFileDataSource ds = (RemoteFileDataSource)this.oldDataSource;\n                            ds.setDisplayName(p.getProperty(\"name\"));\n                            ds.setUserName(p.getProperty(\"username\"));\n                            ds.setPassword(p.getProperty(\"password\"));\n                            try {\n                                ds.setAddress(p.getProperty(\"address\")); // this must be set last\n                            } catch (Exception ex) {\n                                // ignore any error for now\n                            }\n                        }\n                    } else {\n                        try {\n                            GUI.activateWaitCursor();\n                            this.newDataSource.setConfiguration(cui.getProperties());\n                            GUI.invokeAfterAWT(new Runnable() { public void run() {\n                                try {\n                                    synchronized (dataSourceManager) {\n                                        dataSourceManager.save();\n                                    }\n                                } catch (Throwable t) {\n                                    System.out.println(t.getMessage());\n                                }\n                            }});\n                            \n                        } catch (Throwable t2) {\n                            \n                        } finally {\n                            GUI.clearWaitCursor();\n                        }\n                    }\n                }\n            }\n\t\t\tif (proceed) {\n\t\t\t\tif (this.oldDataSource != null) {\n\t\t\t\t\tdataSourceList.addOrdered(this.oldDataSource);\n\t\t\t\t} else {\n\t\t\t\t\tdataSourceList.addOrdered(this.newDataSource);\n\t\t\t\t\tdataSourceManager.add(this.newDataSource);\n\t\t\t\t}\n\t\t\t\tproviderListRenderer.setChecked(addLibraryList.getSelectedIndex());\n\t\t\t}\n        } catch (Throwable t) {\n            t.printStackTrace();\n        } finally {\n            providerListRenderer.endWaitingMode();\n            addLibraryList.repaint();\n            GUI.clearWaitCursor();\n            timer.stop();\n            this.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));\n        }\n        DataSourceViewer.saveDataSourceViewer();\n    }","id":60648,"modified_method":"public void add() {\n        \n        try {\n\t\t\tboolean proceed = true;\n            this.oldDataSource = null;\n            Object o = addLibraryList.getSelectedValue();\n            String xml = null;\n            String s = null;\n            \n            if (o instanceof String) {\n                s = (String)o;\n                if (s.equals(MY_COMPUTER)) {\n                    LocalFileDataSource ds = new LocalFileDataSource(MY_COMPUTER,\"\");\n                    xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><configuration><field><key>name<\/key><title>Name<\/title><description>Name for this datasource<\/description><default>DEFAULT_NAME<\/default><mandatory>true<\/mandatory><maxChars><\/maxChars><ui>0<\/ui><\/field><field><key>address<\/key><title>Starting path<\/title><description>The path to start from<\/description><default>DEFAULT_ADDRESS<\/default><mandatory>true<\/mandatory><maxChars>512<\/maxChars><ui>0<\/ui><\/field><\/configuration>\";\n                    String name = ds.getDisplayName();\n                    String address = ds.getAddress();\n                    xml = xml.replaceFirst(\"DEFAULT_NAME\",name);\n                    xml = xml.replaceFirst(\"DEFAULT_ADDRESS\",address);\n                    this.oldDataSource = ds;\n                } else if (s.equals(MY_SAVED_CONTENT)) {\n                    FavoritesDataSource ds = new FavoritesDataSource(MY_SAVED_CONTENT);\n                    xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><configuration><field><key>name<\/key><title>Name<\/title><description>Name for this datasource<\/description><default>DEFAULT_NAME<\/default><mandatory>true<\/mandatory><maxChars><\/maxChars><ui>0<\/ui><\/field><\/configuration>\";\n                    String name = ds.getDisplayName();\n                    xml = xml.replaceFirst(\"DEFAULT_NAME\",name);\n                    this.oldDataSource = ds;\n                } else if (s.equals(FTP)) {\n                    RemoteFileDataSource ds = new RemoteFileDataSource();\n                    xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><configuration><field><key>name<\/key><title>Display Name<\/title><description>Dane for this datasource<\/description><default>DEFAULT_NAME<\/default><mandatory>true<\/mandatory><maxChars><\/maxChars><ui>0<\/ui><\/field><field><key>address<\/key><title>Address<\/title><description>FTP Address<\/description><default>DEFAULT_ADDRESS<\/default><mandatory>true<\/mandatory><maxChars>256<\/maxChars><ui>0<\/ui><\/field><field><key>username<\/key><title>Username<\/title><description>FTP site username<\/description><default>DEFAULT_USERNAME<\/default><mandatory>true<\/mandatory><maxChars>64<\/maxChars><ui>0<\/ui><\/field><field><key>password<\/key><title>Password<\/title><description>FTP site password for username<\/description><default>DEFAULT_PASSWORD<\/default><mandatory>true<\/mandatory><maxChars><\/maxChars><ui>1<\/ui><\/field><\/configuration>\";\n                    String name = ds.getDisplayName();\n                    if (name == null) name = \"\";\n                    String address = ds.getAddress();\n                    if (address == null) address = \"\";\n                    String username = ds.getUserName();\n                    if (username == null) username = \"\";\n                    String password = ds.getPassword();\n                    if (password == null) password = \"\";\n                    xml = xml.replaceFirst(\"DEFAULT_NAME\",name);\n                    xml = xml.replaceFirst(\"DEFAULT_ADDRESS\",address);\n                    xml = xml.replaceFirst(\"DEFAULT_USERNAME\",username);\n                    xml = xml.replaceFirst(\"DEFAULT_PASSWORD\",password);\n                    this.oldDataSource = ds;\n                }\n            } else {\n                org.osid.provider.Provider provider = (org.osid.provider.Provider)o;\n                \n                edu.tufts.vue.dsm.DataSource ds = null;\n                // show dialog containing license, if any\n                try {\n                    if (provider.requestsLicenseAcknowledgement()) {\n                        String license = provider.getLicense();\n                        if (license != null) {\n                            javax.swing.JTextArea area = new javax.swing.JTextArea();\n                            area.setLineWrap(true);\n                            area.setText(license);\n                            area.setEditable(false);\n                            area.setSize(new Dimension(500,300));\n                            if (javax.swing.JOptionPane.showOptionDialog(this,\n                                    area,\n                                    \"License Acknowledgement\",\n                                    javax.swing.JOptionPane.DEFAULT_OPTION,\n                                    javax.swing.JOptionPane.QUESTION_MESSAGE,\n                                    null,\n                                    new Object[] {\n                                \"Accept\", \"Decline\"\n                            },\n                                    \"Decline\") != 0) {\n                                return;\n                            }\n                        }\n                    }\n                    \n                    //System.out.println(\"checking if installed\");\n                    if (proceed && (!provider.isInstalled())) {\n                        //System.out.println(\"installing...\");\n                        factory = edu.tufts.vue.dsm.impl.VueOsidFactory.getInstance();\n                        try {\n                            GUI.activateWaitCursor();\n                            factory.installProvider(provider.getId());\n                        } catch (Throwable t1) {\n                            //System.out.println(\"install failed \" + provider.getId().getIdString());\n                            VueUtil.alert(\"Installation Failed\",\"Error\");\n                            return;\n                        } finally {\n                            GUI.clearWaitCursor();\n                        }\n                    } else {\n                        //System.out.println(\"No need to install\");\n                    }\n                    \n                    if (proceed) {\n                        // add to data sources list\n                        try {\n                            //System.out.println(\"creating data source\");\n                            ds = new edu.tufts.vue.dsm.impl.VueDataSource(factory.getIdManagerInstance().createId(),\n                                    provider.getId(),\n                                    true);\n                        } catch (Throwable t) {\n                            VueUtil.alert(\"Loading Manager Failed\",\"Error\");\n                            return;\n                        }\n                        //System.out.println(\"created data source\");\n                        \n                        // show configuration, if needed\n                        if (ds.hasConfiguration()) {\n                            xml = ds.getConfigurationUIHints();\n                        } else {\n                            //System.out.println(\"No configuration to show\");\n                        }\n                        this.newDataSource = ds;\n                    }\n                } catch (Throwable t) {\n                    //System.out.println(\"configuration setup failed\");\n                    VueUtil.alert(t.getMessage(),\"OSID Installation Error\");\n                    t.printStackTrace();\n                    return;\n                }\n            }\n            \n            if (xml != null) {\n                edu.tufts.vue.ui.ConfigurationUI cui =\n                        new edu.tufts.vue.ui.ConfigurationUI(new java.io.ByteArrayInputStream(xml.getBytes()));\n                cui.setPreferredSize(new Dimension(400,200));\n                \n                if (javax.swing.JOptionPane.showOptionDialog(this,\n                        cui,\n                        \"Configuration\",\n                        javax.swing.JOptionPane.DEFAULT_OPTION,\n                        javax.swing.JOptionPane.QUESTION_MESSAGE,\n                        null,\n                        new Object[] {\n                    \"Cancel\", \"Continue\"\n                },\n                        \"Continue\") == 0) {\n\t\t\t\t\tproceed = false;\n\t\t\t\t} else {\n                    if (s != null) {\n                        if (s.equals(MY_COMPUTER)) {\n                            java.util.Properties p = cui.getProperties();\n                            LocalFileDataSource ds = (LocalFileDataSource)this.oldDataSource;\n                            ds.setDisplayName(p.getProperty(\"name\"));\n                            ds.setAddress(p.getProperty(\"address\"));\n                        } else if (s.equals(MY_SAVED_CONTENT)) {\n                            java.util.Properties p = cui.getProperties();\n                            FavoritesDataSource ds = (FavoritesDataSource)this.oldDataSource;\n                            ds.setDisplayName(p.getProperty(\"name\"));\n                        } else if (s.equals(FTP)) {\n                            java.util.Properties p = cui.getProperties();\n                            RemoteFileDataSource ds = (RemoteFileDataSource)this.oldDataSource;\n                            ds.setDisplayName(p.getProperty(\"name\"));\n                            ds.setUserName(p.getProperty(\"username\"));\n                            ds.setPassword(p.getProperty(\"password\"));\n                            try {\n                                ds.setAddress(p.getProperty(\"address\")); // this must be set last\n                            } catch (Exception ex) {\n                                // ignore any error for now\n                            }\n                        }\n                    } else {\n                        try {\n                            GUI.activateWaitCursor();\n                            this.newDataSource.setConfiguration(cui.getProperties());\n                            GUI.invokeAfterAWT(new Runnable() { public void run() {\n                                try {\n                                    synchronized (dataSourceManager) {\n                                        dataSourceManager.save();\n                                    }\n                                } catch (Throwable t) {\n                                    System.out.println(t.getMessage());\n                                }\n                            }});\n                            \n                        } catch (Throwable t2) {\n                            \n                        } finally {\n                            GUI.clearWaitCursor();\n                        }\n                    }\n                }\n            }\n\t\t\tif (proceed) {\n\t\t\t\tif (this.oldDataSource != null) {\n\t\t\t\t\tdataSourceList.addOrdered(this.oldDataSource);\n\t\t\t\t} else {\n\t\t\t\t\tdataSourceList.addOrdered(this.newDataSource);\n\t\t\t\t\tdataSourceManager.add(this.newDataSource);\n\t\t\t\t}\n\t\t\t\tproviderListRenderer.setChecked(addLibraryList.getSelectedIndex());\n\t\t\t}\n        } catch (Throwable t) {\n            t.printStackTrace();\n        } finally {\n            providerListRenderer.endWaitingMode();\n            addLibraryList.repaint();\n            GUI.clearWaitCursor();\n            timer.stop();\n            this.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));\n        }\n        DataSourceViewer.saveDataSourceViewer();\n    }","commit_id":"36d1670f563e3ecad69ce63162d1f0c0eb699e62","url":"https://github.com/VUE/VUE"},{"original_method":"private void populate() {\n        listModel.removeAllElements();\n\t\tthis.oldDataSource = null;\n\t\tthis.newDataSource = null;\n        try {\n            GUI.activateWaitCursor();\n            if (dataSourceManager == null) {\n                dataSourceManager = edu.tufts.vue.dsm.impl.VueDataSourceManager.getInstance();\n            }\n            \n            listModel.removeAllElements();\n            org.osid.provider.ProviderIterator providerIterator = factory.getProviders();\n            while (providerIterator.hasNextProvider()) {\n                org.osid.provider.Provider nextProvider = providerIterator.getNextProvider();\n                // place all providers on list, whether installed or not, whether duplicates or not\n                listModel.addElement(nextProvider);\n                descriptionTextArea.setText(nextProvider.getDescription());\n                checkedVector.addElement(nextProvider);\n            }\n            // copy to an array\n            int size = listModel.size();\n            checked = new org.osid.provider.Provider[size];\n            for (int i=0; i < size; i++) {\n                checked[i] = (org.osid.provider.Provider)checkedVector.elementAt(i);\n            }\n            \n        } catch (Throwable t) {\n            t.printStackTrace();\n            VueUtil.alert(t.getMessage(),\"Error\");\n        } finally {\n            GUI.clearWaitCursor();\n        }\n        // add all data sources we include with VUE\n        listModel.addElement(MY_COMPUTER);\n        listModel.addElement(MY_SAVED_CONTENT);\n        listModel.addElement(FTP);\n    }","id":60649,"modified_method":"private void populate() {\n        listModel.removeAllElements();\n\t\tthis.oldDataSource = null;\n\t\tthis.newDataSource = null;\n        try {\n            GUI.activateWaitCursor();\n            if (dataSourceManager == null) {\n                dataSourceManager = edu.tufts.vue.dsm.impl.VueDataSourceManager.getInstance();\n            }\n            \n            listModel.removeAllElements();\n            org.osid.provider.ProviderIterator providerIterator = factory.getProviders();\n            while (providerIterator.hasNextProvider()) {\n                org.osid.provider.Provider nextProvider = providerIterator.getNextProvider();\n                // place all providers on list, whether installed or not, whether duplicates or not\n                listModel.addElement(nextProvider);\n                checkedVector.addElement(nextProvider);\n            }\n            // copy to an array\n            int size = listModel.size();\n            checked = new org.osid.provider.Provider[size];\n            for (int i=0; i < size; i++) {\n                checked[i] = (org.osid.provider.Provider)checkedVector.elementAt(i);\n            }\n            \n        } catch (Throwable t) {\n            t.printStackTrace();\n            VueUtil.alert(t.getMessage(),\"Error\");\n        } finally {\n            GUI.clearWaitCursor();\n        }\n        // add all data sources we include with VUE\n        listModel.addElement(MY_COMPUTER);\n        listModel.addElement(MY_SAVED_CONTENT);\n        listModel.addElement(FTP);\n    }","commit_id":"36d1670f563e3ecad69ce63162d1f0c0eb699e62","url":"https://github.com/VUE/VUE"},{"original_method":"public void setActiveDataSource(DataSource ds){\n        if (DEBUG.DR) out(\"Set active data source: \" + ds);\n        this.activeDataSource = ds;\n        dataSourceList.setSelectedValue(ds,true);\n        Widget.setExpanded(DRB.searchPane, false);\n        if (ds instanceof LocalFileDataSource || ds instanceof FavoritesDataSource || ds instanceof RemoteFileDataSource) {\n            try {\n                Widget.setTitle(DRB.browsePane, \"Browse: \" + ds.getDisplayName());\n                Widget.setExpanded(DRB.browsePane, true);\n                DRB.browsePane.removeAll();\n                DRB.browsePane.add(ds.getResourceViewer());\n                DRB.browsePane.revalidate();\n            } catch (Exception ex) {\n                // probably Remote File Data Source is no initialized\n            }\n        } else\n            Widget.setExpanded(DRB.browsePane, false);\n        \n    }","id":60650,"modified_method":"public void setActiveDataSource(DataSource ds){\n        if (DEBUG.DR) out(\"Set active data source: \" + ds);\n        this.activeDataSource = ds;\n        dataSourceList.setSelectedValue(ds,true);\n        Widget.setExpanded(DRB.searchPane, false);\n\t\tWidget.setExpanded(DRB.browsePane, true);\n\t\tWidget.setTitle(DRB.browsePane, \"Browse: \" + ds.getDisplayName());\n\t\tDRB.browsePane.removeAll();\n\t\tDRB.browsePane.add(ds.getResourceViewer());\n\t\tDRB.browsePane.revalidate();\n    }","commit_id":"36d1670f563e3ecad69ce63162d1f0c0eb699e62","url":"https://github.com/VUE/VUE"},{"original_method":"private void populate()\n\t{\n\t\tlistModel.removeAllElements();\n\t\ttry\n\t\t{\n\t\t\tGUI.activateWaitCursor();\n\n\t\t\tif (dataSourceManager == null) {\n\t\t\t\tdataSourceManager = edu.tufts.vue.dsm.impl.VueDataSourceManager.getInstance();\n\t\t\t\tfactory = edu.tufts.vue.dsm.impl.VueOsidFactory.getInstance();\n\t\t\t}\n\t\t\t\n\t\t\tlistModel.removeAllElements();\n\n\t\t\torg.osid.provider.ProviderIterator providerIterator = factory.getProvidersNeedingUpdate();\n\t\t\twhile (providerIterator.hasNextProvider()) {\n\t\t\t\torg.osid.provider.Provider nextProvider = providerIterator.getNextProvider();\n\t\t\t\t// place all providers on list, whether installed or not, whether duplicates or not\n\t\t\t\tlistModel.addElement(nextProvider);\n\t\t\t\tdescriptionTextArea.setText(nextProvider.getDescription());\n\t\t\t\tcheckedVector.addElement(nextProvider);\n\t\t\t}\n\t\t\t// copy to an array\n\t\t\tint size = listModel.size();\n\t\t\tchecked = new org.osid.provider.Provider[size];\n\t\t\tfor (int i=0; i < size; i++) {\n\t\t\t\tchecked[i] = (org.osid.provider.Provider)checkedVector.elementAt(i);\n\t\t\t}\n\t\t\t\n\t\t} catch (Throwable t) {\n\t\t\tt.printStackTrace();\n\t\t\tjavax.swing.JOptionPane.showMessageDialog(null,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  t.getMessage(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  \"Error\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t  javax.swing.JOptionPane.ERROR_MESSAGE);\n\t\t} finally {\n\t\t\tGUI.clearWaitCursor();\n\t\t}\n\t}","id":60651,"modified_method":"private void populate() {\n        listModel.removeAllElements();\n\t\tthis.newDataSource = null;\n        try {\n            GUI.activateWaitCursor();\n            if (dataSourceManager == null) {\n                dataSourceManager = edu.tufts.vue.dsm.impl.VueDataSourceManager.getInstance();\n            }\n            \n            listModel.removeAllElements();\n            org.osid.provider.ProviderIterator providerIterator = factory.getProvidersNeedingUpdate();\n            while (providerIterator.hasNextProvider()) {\n                org.osid.provider.Provider nextProvider = providerIterator.getNextProvider();\n                // place all providers on list, whether installed or not, whether duplicates or not\n                listModel.addElement(nextProvider);\n                descriptionTextArea.setText(nextProvider.getDescription());\n                checkedVector.addElement(nextProvider);\n            }\n            // copy to an array\n            int size = listModel.size();\n            checked = new org.osid.provider.Provider[size];\n            for (int i=0; i < size; i++) {\n                checked[i] = (org.osid.provider.Provider)checkedVector.elementAt(i);\n            }\n            \n        } catch (Throwable t) {\n            t.printStackTrace();\n            VueUtil.alert(t.getMessage(),\"Error\");\n        } finally {\n            GUI.clearWaitCursor();\n        }\n    }","commit_id":"36d1670f563e3ecad69ce63162d1f0c0eb699e62","url":"https://github.com/VUE/VUE"},{"original_method":"public void actionPerformed(ActionEvent ae) {\n\t\tif (ae.getActionCommand().equals(\"Update\")) {\n\t\t\ttry {\n\t\t\t\tObject o = addLibraryList.getSelectedValue();\n\t\t\t\tString xml = null;\n\t\t\t\torg.osid.provider.Provider provider = (org.osid.provider.Provider)o;\n\t\t\t\t\n\t\t\t\tboolean proceed = true;\n\t\t\t\tedu.tufts.vue.dsm.DataSource ds = null;\n\t\t\t\t// show dialog containing license, if any\n\t\t\t\ttry {\n\t\t\t\t\tif (provider.requestsLicenseAcknowledgement()) {\n\t\t\t\t\t\tString license = provider.getLicense();\n\t\t\t\t\t\tif (license != null) {\n\t\t\t\t\t\t\tjavax.swing.JTextArea area = new javax.swing.JTextArea();\n\t\t\t\t\t\t\tarea.setLineWrap(true);\n\t\t\t\t\t\t\tarea.setText(license);\n\t\t\t\t\t\t\tarea.setEditable(false);\n\t\t\t\t\t\t\tarea.setSize(new Dimension(500,300));\n\t\t\t\t\t\t\tif (javax.swing.JOptionPane.showOptionDialog(this,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t area,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \"License Acknowledgement\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t javax.swing.JOptionPane.DEFAULT_OPTION,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t javax.swing.JOptionPane.QUESTION_MESSAGE,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t null,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t new Object[] {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \"Accept\", \"Decline\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t },\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \"Decline\") != 0) {\n\t\t\t\t\t\t\t\tproceed = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (proceed) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tGUI.activateWaitCursor();\n\t\t\t\t\t\t\tfactory.updateProvider(provider.getId());\n\t\t\t\t\t\t\t// show configuration, if needed\n\t\t\t\t\t\t\tif (ds.hasConfiguration()) {\n\t\t\t\t\t\t\t\txml = ds.getConfigurationUIHints();\n\t\t\t\t\t\t\t\tthis.newDataSource = ds;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tSystem.out.println(\"No configuration to show\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (Throwable t1) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tGUI.clearWaitCursor();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tjavax.swing.JOptionPane.showMessageDialog(null,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  t.getMessage(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \"OSID Installation Error\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  javax.swing.JOptionPane.ERROR_MESSAGE);\n\t\t\t\t\tt.printStackTrace();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tif (xml != null) {\n\t\t\t\t\tedu.tufts.vue.ui.ConfigurationUI cui = \n\t\t\t\t\tnew edu.tufts.vue.ui.ConfigurationUI(new java.io.ByteArrayInputStream(xml.getBytes()));\n\t\t\t\t\tcui.setPreferredSize(new Dimension(400,200));\n\t\t\t\t\t\n\t\t\t\t\tif (javax.swing.JOptionPane.showOptionDialog(this,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t cui,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \"Configuration\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t javax.swing.JOptionPane.DEFAULT_OPTION,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t javax.swing.JOptionPane.QUESTION_MESSAGE,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t null,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t new Object[] {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \"Cancel\", \"Update\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t },\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \"Update\") != 0) {\n\t\t\t\t\t\tthis.newDataSource.setConfiguration(cui.getProperties());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (Throwable t) {\n\t\t\t\tt.printStackTrace();\n\t\t\t}\n\t\t} else {\n\t\t\tsetVisible(false);\n\t\t}\n\t}","id":60652,"modified_method":"public void actionPerformed(ActionEvent ae) {\n        \n        \n        if (ae.getActionCommand().equals(\"Update\")) {\n            this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n            GUI.activateWaitCursor();\n            providerListRenderer.invokeWaitingMode();\n            repaint();\n            int ONE_TNTH_SECOND = 100;\n            \n            timer = new Timer(ONE_TNTH_SECOND, new ActionListener() {\n                public void actionPerformed(ActionEvent evt) {\n                    repaint();\n                }});\n\t\t\ttimer.start();\n\t\t\t\n\t\t\tUpdateDSThread t = new UpdateDSThread();\n\t\t\tt.start();\n\t\t\t\n        } else {\n            providerListRenderer.clearAllChecked();\n            setVisible(false);\n        }\n    }","commit_id":"36d1670f563e3ecad69ce63162d1f0c0eb699e62","url":"https://github.com/VUE/VUE"},{"original_method":"public UpdateLibraryDialog(DataSourceList dataSourceList)\n\t{\n        super(VUE.getDialogParentAsFrame(),TITLE,true);\n\t\tthis.dataSourceList = dataSourceList;\n\t\t\n\t\ttry {\n\t\t\taddLibraryList = new JList(listModel);\n\t\t\taddLibraryList.setSelectionMode(DefaultListSelectionModel.SINGLE_SELECTION);\n\t\t\taddLibraryList.setPreferredSize(new Dimension(300,180));\n\t\t\taddLibraryList.addListSelectionListener(this);\n\t\t\taddLibraryList.setCellRenderer(new ProviderListCellRenderer());\n\t\t\t\n\t\t\tdescriptionTextArea = new JTextArea();\n\t\t\tdescriptionTextArea.setLineWrap(true);\n\t\t\tdescriptionTextArea.setWrapStyleWord(true);\n\t\t\tdescriptionTextArea.setPreferredSize(new Dimension(300,180));\n\t\t\t\n\t\t\tpopulate();\n\n\t\t\tlistJsp = new JScrollPane(addLibraryList);\n\t\t\tlistJsp.setVerticalScrollBarPolicy(javax.swing.JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);\n\t\t\tlistJsp.setHorizontalScrollBarPolicy(javax.swing.JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n\t\t\t\n\t\t\tdescriptionTextArea.setText(\"description\");\n\t\t\tdescriptionJsp = new JScrollPane(descriptionTextArea);\n\t\t\tdescriptionJsp.setVerticalScrollBarPolicy(javax.swing.JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);\n\t\t\tdescriptionJsp.setHorizontalScrollBarPolicy(javax.swing.JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED); \n\n\t\t\taddLibraryPanel.setBackground(VueResources.getColor(\"White\"));\n\t\t\tsetBackground(VueResources.getColor(\"White\"));\n\n\t\t\tjava.awt.GridBagLayout gbLayout = new java.awt.GridBagLayout();\n\t\t\tjava.awt.GridBagConstraints gbConstraints = new java.awt.GridBagConstraints();\n\t\t\tgbConstraints.anchor = java.awt.GridBagConstraints.WEST;\n\t\t\tgbConstraints.insets = new java.awt.Insets(2,2,2,2);\n\t\t\taddLibraryPanel.setLayout(gbLayout);\n\t\t\t\n\t\t\tgbConstraints.gridx = 0;\n\t\t\tgbConstraints.gridy = 0;\n\t\t\taddLibraryPanel.add(new JLabel(AVAILABLE),gbConstraints);\n\t\t\t\n\t\t\tgbConstraints.gridx = 0;\n\t\t\tgbConstraints.gridy = 1;\n\t\t\taddLibraryPanel.add(listJsp,gbConstraints);\n\t\t\t\n\t\t\tgbConstraints.gridx = 0;\n\t\t\tgbConstraints.gridy = 2;\n\t\t\taddLibraryPanel.add(descriptionJsp,gbConstraints);\n\t\t\t\n\t\t\tbuttonPanel.add(cancelButton);\n\t\t\tcancelButton.addActionListener(this);\n\t\t\tbuttonPanel.add(addButton);\n\t\t\taddButton.addActionListener(this);\n\t\t\tgetRootPane().setDefaultButton(addButton);\n\t\t\t\n\t\t\tgbConstraints.gridx = 0;\n\t\t\tgbConstraints.gridy = 3;\n\t\t\taddLibraryPanel.add(buttonPanel,gbConstraints);\n\n\t\t\tgetContentPane().add(addLibraryPanel,BorderLayout.CENTER);\n\t\t\tpack();\n\t\t\tsetLocation(300,300);\n\t\t\t//setSize(new Dimension(300,400));\n\t\t\t\n\t\t\t//addLibraryList.getSelectionMdoel().setSelectionInterval(0,1);\n\t\t} catch (Throwable t) {\n\t\t\tt.printStackTrace();\n\t\t}\n\t\tsetVisible(true);\n    }","id":60653,"modified_method":"public UpdateLibraryDialog(DataSourceList dataSourceList) {\n        super(VUE.getDialogParentAsFrame(),TITLE,true);\n        this.dataSourceList = dataSourceList;\n        \n        try {\n            factory = edu.tufts.vue.dsm.impl.VueOsidFactory.getInstance();\n        } catch (Throwable t) {\n            t.printStackTrace();\n            VueUtil.alert(\"Error instantiating Provider support\",\"Error\");\n        }\n        \n        try {\n            addLibraryList = new JList(listModel);\n            addLibraryList.setSelectionMode(DefaultListSelectionModel.SINGLE_SELECTION);\n            addLibraryList.addListSelectionListener(this);\n            addLibraryList.setFixedCellHeight(25);\n            \n            providerListRenderer = new ProviderListCellRenderer();\n            addLibraryList.setCellRenderer(providerListRenderer);\n            \n            descriptionTextArea = new JTextArea();\n            descriptionTextArea.setLineWrap(true);\n            descriptionTextArea.setWrapStyleWord(true);\n            \n            populate();\n            \n            listJsp = new JScrollPane(addLibraryList);\n            listJsp.setVerticalScrollBarPolicy(javax.swing.JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);\n            listJsp.setHorizontalScrollBarPolicy(javax.swing.JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n            listJsp.setPreferredSize(new Dimension(300,180));\n            \n            descriptionTextArea.setText(\"description\");\n            descriptionJsp = new JScrollPane(descriptionTextArea);\n            descriptionJsp.setVerticalScrollBarPolicy(javax.swing.JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);\n            descriptionJsp.setHorizontalScrollBarPolicy(javax.swing.JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n            descriptionJsp.setPreferredSize(new Dimension(300,180));\n            \n            addLibraryPanel.setBackground(VueResources.getColor(\"White\"));\n            setBackground(VueResources.getColor(\"White\"));\n            \n            java.awt.GridBagLayout gbLayout = new java.awt.GridBagLayout();\n            java.awt.GridBagConstraints gbConstraints = new java.awt.GridBagConstraints();\n            gbConstraints.anchor = java.awt.GridBagConstraints.WEST;\n            gbConstraints.insets = new java.awt.Insets(2,2,2,2);\n            addLibraryPanel.setLayout(gbLayout);\n            \n            gbConstraints.gridx = 0;\n            gbConstraints.gridy = 0;\n            addLibraryPanel.add(new JLabel(AVAILABLE),gbConstraints);\n            \n            gbConstraints.gridx = 0;\n            gbConstraints.gridy = 1;\n            addLibraryPanel.add(listJsp,gbConstraints);\n            \n            gbConstraints.gridx = 0;\n            gbConstraints.gridy = 2;\n            addLibraryPanel.add(descriptionJsp,gbConstraints);\n            \n            buttonPanel.add(cancelButton);\n            cancelButton.addActionListener(this);\n            buttonPanel.add(addButton);\n            addButton.addActionListener(this);\n            getRootPane().setDefaultButton(addButton);\n            \n            gbConstraints.gridx = 0;\n            gbConstraints.gridy = 3;\n            addLibraryPanel.add(buttonPanel,gbConstraints);\n            \n            getContentPane().add(addLibraryPanel,BorderLayout.CENTER);\n            pack();\n            setLocation(300,300);\n        } catch (Throwable t) {\n            t.printStackTrace();\n        }\n        setVisible(true);\n    }","commit_id":"36d1670f563e3ecad69ce63162d1f0c0eb699e62","url":"https://github.com/VUE/VUE"},{"original_method":"public static int showErrorMessageQuery(final String message, final Throwable t) {\n        JScrollPane scroll = null;\n        final JTextArea msgArea = new JTextArea(message);\n        msgArea.setBorder(BorderFactory.createTitledBorder(Messages.getString(\"ClientFrame.217\"))); //$NON-NLS-1$\n        msgArea.setEditable(false);\n        msgArea.setBackground(null);\n        if (t != null) {\n            final StringWriter out = new StringWriter();\n            final PrintWriter writer = new PrintWriter(out);\n            t.printStackTrace(writer);\n            final JTextArea stacktrace = new JTextArea(out.toString(), 20, 50);\n            stacktrace.setBackground(null);\n            stacktrace.setEditable(false);\n            scroll = new JScrollPane(stacktrace);\n            scroll.setPreferredSize(new Dimension(250, 300));\n            scroll.setBorder(BorderFactory\n                    .createTitledBorder(Messages.getString(\"ClientFrame.218\"))); //$NON-NLS-1$\n        }\n        final JOptionPane optionPane = new JOptionPane();\n        \n        optionPane.setMessage(new Object[]{msgArea, scroll});\n        optionPane.setMessageType(JOptionPane.ERROR_MESSAGE);\n        optionPane.setOptionType(JOptionPane.OK_CANCEL_OPTION);\n        final JDialog dialog = optionPane.createDialog(null, Messages.getString(\"ClientFrame.219\")); //$NON-NLS-1$\n        dialog.setResizable(true);\n        dialog.pack();\n        dialog.setVisible(true);\n       \n        final Object result = optionPane.getValue();\n        if (result == null){\n            return 2;\n        }\n        return ((Integer)optionPane.getValue()).intValue();\n    }","id":60654,"modified_method":"public static int showErrorMessageQuery(final String message, final Throwable t) {\n        final JTextArea msgArea = new JTextArea(message);\n        msgArea.setLineWrap(true);\n        msgArea.setWrapStyleWord(true);\n        msgArea.setEditable(false);\n        msgArea.setBackground(null);\n        JScrollPane scrollMsgArea = new JScrollPane(msgArea);\n        scrollMsgArea.setPreferredSize(new Dimension(600, 300));\n        scrollMsgArea.setBorder(BorderFactory\n                .createTitledBorder(Messages.getString(\"ClientFrame.217\"))); //$NON-NLS-1$\n\n        JScrollPane scrollStacktrace = null;\n        if (t != null) {\n            try(final StringWriter out = new StringWriter();\n                    final PrintWriter writer = new PrintWriter(out)) {\n                t.printStackTrace(writer);\n                final JTextArea stacktrace = new JTextArea(out.toString(), 20, 50);\n                stacktrace.setLineWrap(true);\n                stacktrace.setWrapStyleWord(true);\n                stacktrace.setBackground(null);\n                stacktrace.setEditable(false);\n                scrollStacktrace = new JScrollPane(stacktrace);\n                scrollStacktrace.setPreferredSize(new Dimension(600, 300));\n                scrollStacktrace.setBorder(BorderFactory\n                        .createTitledBorder(Messages.getString(\"ClientFrame.218\"))); //$NON-NLS-1$\n            } catch(final IOException ioe) {\n                    ioe.printStackTrace();\n            }\n        }\n\n        final JOptionPane optionPane = new JOptionPane();\n        optionPane.setMessage(new Object[]{scrollMsgArea, scrollStacktrace});\n        optionPane.setMessageType(JOptionPane.ERROR_MESSAGE);\n        optionPane.setOptionType(JOptionPane.OK_CANCEL_OPTION);\n        final JDialog dialog = optionPane.createDialog(null, Messages.getString(\"ClientFrame.219\")); //$NON-NLS-1$\n        dialog.setResizable(true);\n        dialog.pack();\n        dialog.setVisible(true);\n       \n        final Object result = optionPane.getValue();\n        if (result == null){\n            return 2;\n        }\n        return ((Integer)optionPane.getValue()).intValue();\n    }","commit_id":"6fd83d400374047e77710f51b41e7e978771aa68","url":"https://github.com/eXist-db/exist"},{"original_method":"public static void readOperation(ODatabase database, int n) throws Exception {\n        String query = String.format(\"SELECT FROM %s WHERE name = ?\", OConstants.CLASS_NAME);\n        List<ODocument> result = database.command(new OSQLSynchQuery<>(query)).execute(getThreadValue(n));\n        if (result.size() != 1) {\n            throw new Exception(String.format(\"The query [%s] result size is %d. Expected size is 1.\", query, result.size()));\n        }\n    }","id":60655,"modified_method":"public static void readOperation(ODatabase database, int n) throws Exception {\n        String query = String.format(\"SELECT FROM %s WHERE name = ?\", OConstants.CLASS_NAME);\n        List<ODocument> result = database.command(new OSQLSynchQuery<ODocument>(query)).execute(getThreadValue(n));\n        if (result.size() != 1) {\n            throw new Exception(String.format(\"The query [%s] result size is %d. Expected size is 1.\", query, result.size()));\n        }\n    }","commit_id":"0f9a4effa472cc0a0c03f98e67466e31b78dd12a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OOperationsExecutor(String dbName, String password, OOperationsSet operationsSet, OConsoleWriter consoleWriter) {\n        this.dbName = dbName;\n        this.password = password;\n        this.consoleWriter = consoleWriter;\n        this.operationsSet = operationsSet;\n        insertedDocs = new ArrayList<>();\n    }","id":60656,"modified_method":"public OOperationsExecutor(String dbName, String password, OOperationsSet operationsSet, OConsoleWriter consoleWriter) {\n        this.dbName = dbName;\n        this.password = password;\n        this.consoleWriter = consoleWriter;\n        this.operationsSet = operationsSet;\n        insertedDocs = new ArrayList<ODocument>();\n    }","commit_id":"0f9a4effa472cc0a0c03f98e67466e31b78dd12a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n     * creates an OperationSet\n     *\n     * @param ops\n     * @throws Exception if the param format is not correct\n     */\n    public OOperationsSet(String ops) throws OInitException {\n\n        ops = ops.toUpperCase();\n        if (!(ops.contains(\"C\") && ops.contains(\"R\") && ops.contains(\"U\") && ops.contains(\"D\"))) {\n            throw new OInitException(OErrorMessages.OPERATION_SET_SHOULD_CONTAIN_ALL_MESSAGE);\n        }\n\n        int pos = 0;\n        while (pos < ops.length()) {\n\n            ValuePosition valPos = getValue(ops, pos + 1);\n            switch (ops.charAt(pos)) {\n                case 'C':\n                    creates = valPos.value;\n                    break;\n                case 'R':\n                    reads = valPos.value;\n                    if (reads > creates) {\n                        throw new OInitException(String.format(OErrorMessages.COMMAND_LINE_PARSER_READS_GT_CREATES, reads, creates));\n                    }\n                    break;\n                case 'U':\n                    updates = valPos.value;\n                    break;\n                case 'D':\n                    deletes = valPos.value;\n                    if (deletes > creates) {\n                        throw new OInitException(String.format(OErrorMessages.COMMAND_LINE_PARSER_DELETES_GT_CREATES, deletes, creates));\n                    }\n                    break;\n                default:\n                    throw new OInitException(OErrorMessages.OPERATION_SET_INVALID_FORM_MESSAGE);\n            }\n            pos += valPos.position + 1;\n        }\n    }","id":60657,"modified_method":"/**\n     * creates an OperationSet\n     *\n     * @param ops\n     * @throws Exception if the param format is not correct\n     */\n    public OOperationsSet(String ops, int threads, int iterations) throws OInitException {\n\n        ops = ops.toUpperCase();\n        if (!(ops.contains(\"C\") && ops.contains(\"R\") && ops.contains(\"U\") && ops.contains(\"D\"))) {\n            throw new OInitException(OErrorMessages.OPERATION_SET_SHOULD_CONTAIN_ALL_MESSAGE);\n        }\n\n        int pos = 0;\n        while (pos < ops.length()) {\n\n            ValuePosition valPos = getValue(ops, pos + 1);\n            switch (ops.charAt(pos)) {\n                case 'C':\n                    creates = valPos.value;\n                    break;\n                case 'R':\n                    reads = valPos.value;\n                    if (reads > creates) {\n                        throw new OInitException(String.format(OErrorMessages.COMMAND_LINE_PARSER_READS_GT_CREATES, reads, creates));\n                    }\n                    break;\n                case 'U':\n                    updates = valPos.value;\n                    break;\n                case 'D':\n                    deletes = valPos.value;\n                    if (deletes > creates) {\n                        throw new OInitException(String.format(OErrorMessages.COMMAND_LINE_PARSER_DELETES_GT_CREATES, deletes, creates));\n                    }\n                    break;\n                default:\n                    throw new OInitException(OErrorMessages.OPERATION_SET_INVALID_FORM_MESSAGE);\n            }\n            pos += valPos.position + 1;\n        }\n        \n        creates = (creates / iterations) / threads; \n        reads = (reads / iterations) / threads;\n        updates = (updates / iterations) / threads;\n        deletes = (deletes / iterations) / threads;\n    }","commit_id":"0f9a4effa472cc0a0c03f98e67466e31b78dd12a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@org.junit.Test\n    public void testEmptyOperationsSet() throws Exception {\n\n        try {\n            new OOperationsSet(\"\");\n            fail();\n        }\n        catch (Exception e) {\n            assertTrue(e.getMessage().contains(OPERATION_SET_SHOULD_CONTAIN_ALL_MESSAGE));\n        }\n\n        try {\n            new OOperationsSet(\"crd\");\n            fail();\n        }\n        catch (Exception e) {\n            assertTrue(e.getMessage().contains(OPERATION_SET_SHOULD_CONTAIN_ALL_MESSAGE));\n        }\n\n        try {\n            new OOperationsSet(\"c1r1u1d1p1\");\n            fail();\n        }\n        catch (Exception e) {\n            assertTrue(e.getMessage().contains(OPERATION_SET_INVALID_FORM_MESSAGE));\n        }\n\n        try {\n            new OOperationsSet(\"c1r1u1d\");\n            fail();\n        }\n        catch (Exception e) {\n            assertTrue(e.getMessage().contains(OPERATION_SET_INVALID_FORM_MESSAGE));\n        }\n\n        try {\n            new OOperationsSet(\"c1r1ud1\");\n            fail();\n        }\n        catch (Exception e) {\n            assertTrue(e.getMessage().contains(OPERATION_SET_INVALID_FORM_MESSAGE));\n        }\n\n        try {\n            new OOperationsSet(\"c100r1u01d9999\");\n            fail();\n        }\n        catch (Exception e) {\n            assertTrue(e.getMessage().contains(String.format(OErrorMessages.COMMAND_LINE_PARSER_DELETES_GT_CREATES, 9999, 100)));\n        }\n\n        try {\n            new OOperationsSet(\"c100r101u1d99\");\n            fail();\n        }\n        catch (Exception e) {\n            assertTrue(e.getMessage().contains(String.format(OErrorMessages.COMMAND_LINE_PARSER_READS_GT_CREATES, 101, 100)));\n        }\n\n\n        OOperationsSet set = new OOperationsSet(\"C1R1U1D1\");\n        assertEquals(1, set.getNumberOfCreates());\n        assertEquals(1, set.getNumberOfReads());\n        assertEquals(1, set.getNumberOfUpdates());\n        assertEquals(1, set.getNumberOfDeletes());\n\n        set = new OOperationsSet(\"c1r1u1d1\");\n        assertEquals(1, set.getNumberOfCreates());\n        assertEquals(1, set.getNumberOfReads());\n        assertEquals(1, set.getNumberOfUpdates());\n        assertEquals(1, set.getNumberOfDeletes());\n\n        set = new OOperationsSet(\"c100r99u01d99\");\n        assertEquals(100, set.getNumberOfCreates());\n        assertEquals(99, set.getNumberOfReads());\n        assertEquals(1, set.getNumberOfUpdates());\n        assertEquals(99, set.getNumberOfDeletes());\n    }","id":60658,"modified_method":"@org.junit.Test\n    public void testEmptyOperationsSet() throws Exception {\n\n        try {\n            new OOperationsSet(\"\", 1, 1);\n            fail();\n        } catch (Exception e) {\n            assertTrue(e.getMessage().contains(OPERATION_SET_SHOULD_CONTAIN_ALL_MESSAGE));\n        }\n\n        try {\n            new OOperationsSet(\"crd\", 1, 1);\n            fail();\n        } catch (Exception e) {\n            assertTrue(e.getMessage().contains(OPERATION_SET_SHOULD_CONTAIN_ALL_MESSAGE));\n        }\n\n        try {\n            new OOperationsSet(\"c1r1u1d1p1\", 1, 1);\n            fail();\n        } catch (Exception e) {\n            assertTrue(e.getMessage().contains(OPERATION_SET_INVALID_FORM_MESSAGE));\n        }\n\n        try {\n            new OOperationsSet(\"c1r1u1d\", 1, 1);\n            fail();\n        } catch (Exception e) {\n            assertTrue(e.getMessage().contains(OPERATION_SET_INVALID_FORM_MESSAGE));\n        }\n\n        try {\n            new OOperationsSet(\"c1r1ud1\", 1, 1);\n            fail();\n        } catch (Exception e) {\n            assertTrue(e.getMessage().contains(OPERATION_SET_INVALID_FORM_MESSAGE));\n        }\n\n        try {\n            new OOperationsSet(\"c100r1u01d9999\", 1, 1);\n            fail();\n        } catch (Exception e) {\n            assertTrue(e.getMessage().contains(String.format(OErrorMessages.COMMAND_LINE_PARSER_DELETES_GT_CREATES, 9999, 100)));\n        }\n\n        try {\n            new OOperationsSet(\"c100r101u1d99\", 1, 1);\n            fail();\n        } catch (Exception e) {\n            assertTrue(e.getMessage().contains(String.format(OErrorMessages.COMMAND_LINE_PARSER_READS_GT_CREATES, 101, 100)));\n        }\n\n\n        OOperationsSet set = new OOperationsSet(\"C1R1U1D1\", 1, 1);\n        assertEquals(1, set.getNumberOfCreates());\n        assertEquals(1, set.getNumberOfReads());\n        assertEquals(1, set.getNumberOfUpdates());\n        assertEquals(1, set.getNumberOfDeletes());\n\n        set = new OOperationsSet(\"c1r1u1d1\", 1, 1);\n        assertEquals(1, set.getNumberOfCreates());\n        assertEquals(1, set.getNumberOfReads());\n        assertEquals(1, set.getNumberOfUpdates());\n        assertEquals(1, set.getNumberOfDeletes());\n\n        set = new OOperationsSet(\"c100r99u01d99\", 1, 1);\n        assertEquals(100, set.getNumberOfCreates());\n        assertEquals(99, set.getNumberOfReads());\n        assertEquals(1, set.getNumberOfUpdates());\n        assertEquals(99, set.getNumberOfDeletes());\n\n        set = new OOperationsSet(\"c100r50u1d60\", 10, 2);\n        assertEquals(5, set.getNumberOfCreates());\n        assertEquals(2, set.getNumberOfReads());\n        assertEquals(0, set.getNumberOfUpdates());\n        assertEquals(3, set.getNumberOfDeletes());\n    }","commit_id":"0f9a4effa472cc0a0c03f98e67466e31b78dd12a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OStressTestResults(OOperationsSet operationsSet, OMode mode, int threadsNumber, int iterationsNumber) {\n        this.operationsSet = operationsSet;\n        this.mode = mode;\n        this.threadsNumber = threadsNumber;\n        this.iterationsNumber = iterationsNumber;\n        results = new StringBuffer();\n        operationsExecutorResultses = new ArrayList<>();\n    }","id":60659,"modified_method":"public OStressTestResults(OOperationsSet operationsSet, OMode mode, int threadsNumber, int iterationsNumber) {\n        this.operationsSet = operationsSet;\n        this.mode = mode;\n        this.threadsNumber = threadsNumber;\n        this.iterationsNumber = iterationsNumber;\n    }","commit_id":"0f9a4effa472cc0a0c03f98e67466e31b78dd12a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n    public String toString() {\n\n        results.append(\"OrientDB Stress Test v\")\n                .append(OConstants.VERSION)\n                .append(\"\\n\")\n                .append(getParameters())\n                .append(\"\\n\");\n\n        if (totalTime != 0) {\n            results.append(\"\\nTotal execution time: \")\n                    .append(String.format(\"%.2f\", totalTime / (float) 1_000))\n                    .append(\" seconds.\");\n        }\n\n        long totalCreatesTime = 1;\n        long totalReadsTime = 1;\n        long totalUpdatesTime = 1;\n        long totalDeletesTime = 1;\n\n        for (OOperationsExecutorResults result : operationsExecutorResultses) {\n            totalCreatesTime += result.getCreatesTime();\n            totalReadsTime += result.getReadsTime();\n            totalUpdatesTime += result.getUpdatesTime();\n            totalDeletesTime += result.getDeletesTime();\n        }\n\n        final double averageCreatesTime = (totalCreatesTime / (double) (threadsNumber * iterationsNumber)) / 1000;\n        final double averageReadsTime = (totalReadsTime / (double) (threadsNumber * iterationsNumber)) / 1000;\n        final double averageUpdatesTime = (totalUpdatesTime / (double) (threadsNumber * iterationsNumber)) / 1000;\n        final double averageDeletesTime = (totalDeletesTime / (double) (threadsNumber * iterationsNumber)) / 1000;\n\n        final long createsPerSecond = (int) ((operationsSet.getNumberOfCreates() / (float) averageCreatesTime));\n        final long readsPerSecond = (int) ((operationsSet.getNumberOfReads() / (float) averageReadsTime));\n        final long updatesPerSecond = (int) ((operationsSet.getNumberOfUpdates() / (float) averageUpdatesTime));\n        final long deletesPerSecond = (int) ((operationsSet.getNumberOfDeletes() / (float) averageDeletesTime));\n\n        results.append(String.format(\"\\nAverage time for %,d Creates: %.2f secs (%,d/s).\", operationsSet.getNumberOfCreates(), averageCreatesTime, createsPerSecond))\n                .append(String.format(\"\\nAverage time for %,d Reads: %.2f secs (%,d/s).\", operationsSet.getNumberOfReads(), averageReadsTime, readsPerSecond))\n                .append(String.format(\"\\nAverage time for %,d Updates: %.2f secs (%,d/s).\", operationsSet.getNumberOfUpdates(), averageUpdatesTime, updatesPerSecond))\n                .append(String.format(\"\\nAverage time for %,d Deletes: %.2f secs (%,d/s).\", operationsSet.getNumberOfDeletes(), averageDeletesTime, deletesPerSecond))\n                .append(\"\\n\");\n\n        return results.toString();\n    }","id":60660,"modified_method":"@Override\n    public String toString() {\n\n        StringBuilder results = new StringBuilder();\n        results.append(\"OrientDB Stress Test v\")\n                .append(OConstants.VERSION)\n                .append(\"\\n\")\n                .append(getParameters())\n                .append(\"\\n\");\n\n        if (totalTime != 0) {\n            results.append(\"\\nTotal execution time: \")\n                    .append(String.format(\"%.2f\", totalTime / (float) 1000))\n                    .append(\" seconds.\");\n        }\n\n        times = threadsNumber * iterationsNumber;\n        long totalCreatesTime = 1;\n        long totalReadsTime = 1;\n        long totalUpdatesTime = 1;\n        long totalDeletesTime = 1;\n\n        for (int j = 0; j < operationsExecutorCreatesResults.size(); j++) {\n            totalCreatesTime += operationsExecutorCreatesResults.get(j);\n            totalReadsTime += operationsExecutorReadsResults.get(j);\n            totalUpdatesTime += operationsExecutorUpdatesResults.get(j);\n            totalDeletesTime += operationsExecutorDeletesResults.get(j);\n        }\n\n        final double averageCreatesTime = computeAverage(totalCreatesTime);\n        final double averageReadsTime = computeAverage(totalReadsTime);\n        final double averageUpdatesTime = computeAverage(totalUpdatesTime);\n        final double averageDeletesTime = computeAverage(totalDeletesTime);\n\n        final int createsPercentile = getPercentile(averageCreatesTime, operationsExecutorCreatesResults);\n        final int readsPercentile = getPercentile(averageReadsTime, operationsExecutorReadsResults);\n        final int updatesPercentile = getPercentile(averageUpdatesTime, operationsExecutorUpdatesResults);\n        final int deletesPercentile = getPercentile(averageDeletesTime, operationsExecutorDeletesResults);\n\n        final long createsThroughput = (int) ((operationsSet.getNumberOfCreates() / (float) averageCreatesTime));\n        final long readsThroughput = (int) ((operationsSet.getNumberOfReads() / (float) averageReadsTime));\n        final long updatesThroughput = (int) ((operationsSet.getNumberOfUpdates() / (float) averageUpdatesTime));\n        final long deletesThroughput = (int) ((operationsSet.getNumberOfDeletes() / (float) averageDeletesTime));\n\n        results.append(String.format(OPERATION_RESULT, operationsSet.getNumberOfCreates(), \"Creates\", averageCreatesTime, createsPercentile, createsThroughput))\n                .append(String.format(OPERATION_RESULT, operationsSet.getNumberOfReads(), \"Reads\", averageReadsTime, readsPercentile, readsThroughput))\n                .append(String.format(OPERATION_RESULT, operationsSet.getNumberOfReads(), \"Updates\", averageUpdatesTime, updatesPercentile, updatesThroughput))\n                .append(String.format(OPERATION_RESULT, operationsSet.getNumberOfReads(), \"Deletes\", averageDeletesTime, deletesPercentile, deletesThroughput))\n                .append(\"\\n\");\n\n        return results.toString();\n    }","commit_id":"0f9a4effa472cc0a0c03f98e67466e31b78dd12a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n     * Adds the output of a single executor. It will be called N times\n     * (where N is the number of threads defined for the test)\n     *\n     * @param operationsExecutorResults\n     */\n    public void addThreadResults(OOperationsExecutorResults operationsExecutorResults) {\n        operationsExecutorResultses.add(operationsExecutorResults);\n    }","id":60661,"modified_method":"/**\n     * Adds the output of a single executor. It will be called N times\n     * (where N is the number of threads defined for the test by the number of iterations)\n     *\n     * @param operationsExecutorResults\n     */\n    public void addThreadResults(OOperationsExecutorResults operationsExecutorResults) {\n        operationsExecutorCreatesResults.add(operationsExecutorResults.getCreatesTime());\n        operationsExecutorReadsResults.add(operationsExecutorResults.getReadsTime());\n        operationsExecutorUpdatesResults.add(operationsExecutorResults.getUpdatesTime());\n        operationsExecutorDeletesResults.add(operationsExecutorResults.getDeletesTime());\n        counter++;\n    }","commit_id":"0f9a4effa472cc0a0c03f98e67466e31b78dd12a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OStressTester(OMode mode, OOperationsSet operationsSet, int iterationsNumber, int threadsNumber, String password) throws Exception {\n        this.mode = mode;\n        this.operationsSet = operationsSet;\n        this.iterationsNumber = iterationsNumber;\n        this.threadsNumber = threadsNumber;\n        stressTestResults = new OStressTestResults(operationsSet, mode, threadsNumber, iterationsNumber);\n        consoleProgressWriter = new OConsoleWriter(operationsSet, threadsNumber, iterationsNumber);\n\n        this.password = password;\n        if (password == null) {\n            Console console = System.console();\n            if (console != null) {\n                this.password = new String(console.readPassword(\"Server Root Password: \"));\n            } else {\n//                throw new Exception(\"An error has occurred opening the console.\");\n            }\n        }\n\n    }","id":60662,"modified_method":"public OStressTester(OMode mode, OOperationsSet operationsSet, int iterationsNumber, int threadsNumber, String password) throws Exception {\n        this.mode = mode;\n        this.operationsSet = operationsSet;\n        this.iterationsNumber = iterationsNumber;\n        this.threadsNumber = threadsNumber;\n        stressTestResults = new OStressTestResults(operationsSet, mode, threadsNumber, iterationsNumber);\n        consoleProgressWriter = new OConsoleWriter(operationsSet, threadsNumber, iterationsNumber);\n\n        this.password = password;\n        if (password == null) {\n            Console console = System.console();\n            if (console != null) {\n                this.password = new String(console.readPassword(\"Server Root Password: \"));\n            } else {\n                throw new Exception(\"An error has occurred opening the console. Please supply the root password as the -p parameter.\");\n            }\n        }\n\n    }","commit_id":"0f9a4effa472cc0a0c03f98e67466e31b78dd12a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    private int execute() throws Exception {\n\n        long startTime;\n        long totalTime = 0;\n        int returnCode = 0;\n\n        // we don't want logs from DB\n        OLogManager.instance().setConsoleLevel(\"SEVERE\");\n\n        // creates the temporary DB where to execute the test\n        String dbName = OConstants.TEMP_DATABASE_NAME + new SimpleDateFormat(\"yyyyMMdd_HHmmss\").format(new Date());\n        ODatabaseUtils.createDatabase(dbName, mode, password);\n\n        // opens the newly created db and creates an index on the class we're going to use\n        ODatabase database = ODatabaseUtils.openDatabase(dbName, password);\n        try {\n\n            final OSchema schema = database.getMetadata().getSchema();\n            final OClass oClass = schema.createClass(OConstants.CLASS_NAME);\n            oClass.createProperty(\"name\", OType.STRING);\n            OIndexManager indexManager = database.getMetadata().getIndexManager();\n            indexManager.createIndex(\n                    OConstants.INDEX_NAME,\n                    OClass.INDEX_TYPE.UNIQUE.toString(),\n                    new OPropertyIndexDefinition(\n                            OConstants.CLASS_NAME,\n                            \"name\",\n                            OType.STRING\n                    ),\n                    oClass.getClusterIds(),\n                    null,\n                    null);\n        } finally {\n            database.close();\n        }\n\n        // starts the test\n        try {\n\n            // iterates n times\n            for (int i = 0; i < iterationsNumber; i++) {\n\n                // creates the operations executors\n                List<Callable<OOperationsExecutorResults>> operationsExecutors = new ArrayList<>();\n                for (int j = 0; j < threadsNumber; j++) {\n                    operationsExecutors.add(new OOperationsExecutor(dbName, password, operationsSet, consoleProgressWriter));\n                }\n\n                // starts parallel execution (blocking)\n                startTime = System.currentTimeMillis();\n                List<Future<OOperationsExecutorResults>> threadsResults = Executors.newFixedThreadPool(threadsNumber).invokeAll(operationsExecutors);\n                totalTime += System.currentTimeMillis() - startTime;\n\n                // add the output of every executor\n                for (Future<OOperationsExecutorResults> threadResults : threadsResults) {\n                    stressTestResults.addThreadResults(threadResults.get());\n                }\n            }\n            // stops total benchmarking\n            stressTestResults.addTotalExecutionTime(totalTime);\n\n            // prints out total output\n            System.out.println(\"\\r                                                                                             \");\n            System.out.println(stressTestResults.toString());\n\n        } catch (Exception ex) {\n            System.err.println(\"\\nAn error has occurred while running the stress test: \" + ex.getMessage());\n            returnCode = 1;\n            // ex.printStackTrace();\n        } finally {\n            ODatabaseUtils.dropDatabase(dbName, mode, password);\n        }\n\n        return returnCode;\n    }","id":60663,"modified_method":"@SuppressWarnings(\"unchecked\")\n    private int execute() throws Exception {\n\n        long startTime;\n        long totalTime = 0;\n        int returnCode = 0;\n\n        // we don't want logs from DB\n        OLogManager.instance().setConsoleLevel(\"SEVERE\");\n\n        // creates the temporary DB where to execute the test\n        String dbName = OConstants.TEMP_DATABASE_NAME + new SimpleDateFormat(\"yyyyMMdd_HHmmss\").format(new Date());\n        ODatabaseUtils.createDatabase(dbName, mode, password);\n\n        // opens the newly created db and creates an index on the class we're going to use\n        ODatabase database = ODatabaseUtils.openDatabase(dbName, password);\n        try {\n\n            final OSchema schema = database.getMetadata().getSchema();\n            final OClass oClass = schema.createClass(OConstants.CLASS_NAME);\n            oClass.createProperty(\"name\", OType.STRING);\n            OIndexManager indexManager = database.getMetadata().getIndexManager();\n            indexManager.createIndex(\n                    OConstants.INDEX_NAME,\n                    OClass.INDEX_TYPE.UNIQUE.toString(),\n                    new OPropertyIndexDefinition(\n                            OConstants.CLASS_NAME,\n                            \"name\",\n                            OType.STRING\n                    ),\n                    oClass.getClusterIds(),\n                    null,\n                    null);\n        } finally {\n            database.close();\n        }\n\n        // starts the test\n        try {\n\n            // iterates n times\n            for (int i = 0; i < iterationsNumber; i++) {\n\n                // creates the operations executors\n                List<Callable<OOperationsExecutorResults>> operationsExecutors = new ArrayList<Callable<OOperationsExecutorResults>>();\n                for (int j = 0; j < threadsNumber; j++) {\n                    operationsExecutors.add(new OOperationsExecutor(dbName, password, operationsSet, consoleProgressWriter));\n                }\n\n                // starts parallel execution (blocking)\n                startTime = System.currentTimeMillis();\n                List<Future<OOperationsExecutorResults>> threadsResults = Executors.newFixedThreadPool(threadsNumber).invokeAll(operationsExecutors);\n                totalTime += System.currentTimeMillis() - startTime;\n\n                // add the output of every executor\n                for (Future<OOperationsExecutorResults> threadResults : threadsResults) {\n                    stressTestResults.addThreadResults(threadResults.get());\n                }\n            }\n            // stops total benchmarking\n            stressTestResults.addTotalExecutionTime(totalTime);\n\n            // prints out total output\n            System.out.println(\"\\r                                                                                             \");\n            System.out.println(stressTestResults.toString());\n\n        } catch (Exception ex) {\n            System.err.println(\"\\nAn error has occurred while running the stress test: \" + ex.getMessage());\n            returnCode = 1;\n            // ex.printStackTrace();\n        } finally {\n            ODatabaseUtils.dropDatabase(dbName, mode, password);\n        }\n\n        return returnCode;\n    }","commit_id":"0f9a4effa472cc0a0c03f98e67466e31b78dd12a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private static Map<String, String> checkOptions(Map<String, String> options) throws OInitException {\n\n        options = setDefaultIfNotPresent(options, OConstants.OPTION_MODE, com.orientechnologies.orient.stresstest.OMode.PLOCAL.name());\n        options = setDefaultIfNotPresent(options, OConstants.OPTION_ITERATIONS, \"10\");\n        options = setDefaultIfNotPresent(options, OConstants.OPTION_THREADS, \"4\");\n        options = setDefaultIfNotPresent(options, OConstants.OPTION_OPERATIONS, \"C1000R1000U500D500\");\n\n        try {\n            OMode.valueOf(options.get(OConstants.OPTION_MODE).toUpperCase());\n        } catch (IllegalArgumentException ex) {\n            throw new OInitException(String.format(OErrorMessages.COMMAND_LINE_PARSER_INVALID_MODE, options.get(OConstants.OPTION_MODE)));\n        }\n\n        return options;\n    }","id":60664,"modified_method":"private static Map<String, String> checkOptions(Map<String, String> options) throws OInitException {\n\n        options = setDefaultIfNotPresent(options, OConstants.OPTION_MODE, com.orientechnologies.orient.stresstest.OMode.PLOCAL.name());\n        options = setDefaultIfNotPresent(options, OConstants.OPTION_ITERATIONS, \"10\");\n        options = setDefaultIfNotPresent(options, OConstants.OPTION_THREADS, \"4\");\n        options = setDefaultIfNotPresent(options, OConstants.OPTION_OPERATIONS, \"C5000R5000U5000D5000\");\n\n        try {\n            OMode.valueOf(options.get(OConstants.OPTION_MODE).toUpperCase());\n        } catch (IllegalArgumentException ex) {\n            throw new OInitException(String.format(OErrorMessages.COMMAND_LINE_PARSER_INVALID_MODE, options.get(OConstants.OPTION_MODE)));\n        }\n\n        return options;\n    }","commit_id":"0f9a4effa472cc0a0c03f98e67466e31b78dd12a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public static OStressTester getStressTester(String[] args) throws Exception {\n\n        Map<String, String> options = checkOptions(readOptions(args));\n        int iterationsNumber = getNumber(options.get(OConstants.OPTION_ITERATIONS), \"iterations\");\n        int threadsNumber = getNumber(options.get(OConstants.OPTION_THREADS), \"threads\");\n        OMode mode = com.orientechnologies.orient.stresstest.OMode.valueOf(options.get(OConstants.OPTION_MODE).toUpperCase());\n        if (mode != com.orientechnologies.orient.stresstest.OMode.PLOCAL) {\n            throw new OInitException(\"OMode [\" + mode + \"] not yet supported. Use PLOCAL.\");\n        }\n        OOperationsSet operationsSet = new OOperationsSet(options.get(OConstants.OPTION_OPERATIONS));\n        String rootPassword = options.get(OConstants.OPTION_ROOT_PASSWORD);\n        return new OStressTester(mode, operationsSet, iterationsNumber, threadsNumber, rootPassword);\n    }","id":60665,"modified_method":"public static OStressTester getStressTester(String[] args) throws Exception {\n\n        Map<String, String> options = checkOptions(readOptions(args));\n        int iterationsNumber = getNumber(options.get(OConstants.OPTION_ITERATIONS), \"iterations\");\n        int threadsNumber = getNumber(options.get(OConstants.OPTION_THREADS), \"threads\");\n        OMode mode = com.orientechnologies.orient.stresstest.OMode.valueOf(options.get(OConstants.OPTION_MODE).toUpperCase());\n        if (mode != com.orientechnologies.orient.stresstest.OMode.PLOCAL) {\n            throw new OInitException(\"OMode [\" + mode + \"] not yet supported. Use PLOCAL.\");\n        }\n        OOperationsSet operationsSet = new OOperationsSet(options.get(OConstants.OPTION_OPERATIONS), threadsNumber, iterationsNumber);\n        String rootPassword = options.get(OConstants.OPTION_ROOT_PASSWORD);\n        return new OStressTester(mode, operationsSet, iterationsNumber, threadsNumber, rootPassword);\n    }","commit_id":"0f9a4effa472cc0a0c03f98e67466e31b78dd12a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test\n    public void testCommandLineArgs() throws Exception {\n        try {\n            OStressTesterCommandLineParser.getStressTester(new String[]{\"\"});\n            fail();\n        }\n        catch (Exception ex) {\n            assertTrue(ex.getMessage().contains(String.format(OErrorMessages.COMMAND_LINE_PARSER_INVALID_OPTION, \"\")));\n        }\n\n        try {\n            OStressTesterCommandLineParser.getStressTester(new String[]{\"-i foo\"});\n            fail();\n        }\n        catch (Exception ex) {\n        }\n\n        try {\n            OStressTesterCommandLineParser.getStressTester(new String[]{\"-i\"});\n            fail();\n        }\n        catch (Exception ex) {\n            assertTrue(ex.getMessage().contains(String.format(OErrorMessages.COMMAND_LINE_PARSER_EXPECTED_VALUE, \"-i\")));\n        }\n\n        try {\n            OStressTesterCommandLineParser.getStressTester(new String[]{\"-m\", \"foo\"});\n            fail();\n        }\n        catch (Exception ex) {\n            assertTrue(ex.getMessage().contains(String.format(OErrorMessages.COMMAND_LINE_PARSER_INVALID_MODE, \"foo\")));\n        }\n\n        OStressTester stressTester = OStressTesterCommandLineParser.getStressTester(new String[]{\"-n\",\"100\"});\n        assertEquals(100, stressTester.getIterationsNumber());\n        assertNull(stressTester.getPassword());\n\n        stressTester = OStressTesterCommandLineParser.getStressTester(new String[]{\"-n\",\"100\", \"-p\", \"foo\"});\n        assertEquals(100, stressTester.getIterationsNumber());\n        assertEquals(\"foo\", stressTester.getPassword());\n\n        stressTester = OStressTesterCommandLineParser.getStressTester(new String[]{\"-n\",\"100\", \"-t\", \"4\"});\n        assertEquals(100, stressTester.getIterationsNumber());\n        assertEquals(4, stressTester.getThreadsNumber());\n        assertNull(stressTester.getPassword());\n\n        stressTester = OStressTesterCommandLineParser.getStressTester(new String[]{\"-n\",\"100\",\"-t\",\"4\",\"-m\",\"plocal\"});\n        assertEquals(100, stressTester.getIterationsNumber());\n        assertEquals(4, stressTester.getThreadsNumber());\n        assertEquals(com.orientechnologies.orient.stresstest.OMode.PLOCAL, stressTester.getMode());\n        assertNull(stressTester.getPassword());\n\n        stressTester = OStressTesterCommandLineParser.getStressTester(new String[]{\"-n\",\"100\",\"-t\",\"4\",\"-m\",\"plocal\",\"-s\",\"c1r1u1d1\"});\n        assertEquals(100, stressTester.getIterationsNumber());\n        assertEquals(4, stressTester.getThreadsNumber());\n        assertEquals(com.orientechnologies.orient.stresstest.OMode.PLOCAL, stressTester.getMode());\n        assertNull(stressTester.getPassword());\n\n    }","id":60666,"modified_method":"@Test\n    public void testCommandLineArgs() throws Exception {\n        try {\n            OStressTesterCommandLineParser.getStressTester(new String[]{\"\"});\n            fail();\n        }\n        catch (Exception ex) {\n            assertTrue(ex.getMessage().contains(String.format(OErrorMessages.COMMAND_LINE_PARSER_INVALID_OPTION, \"\")));\n        }\n\n        try {\n            OStressTesterCommandLineParser.getStressTester(new String[]{\"-i foo\"});\n            fail();\n        }\n        catch (Exception ex) {\n        }\n\n        try {\n            OStressTesterCommandLineParser.getStressTester(new String[]{\"-i\"});\n            fail();\n        }\n        catch (Exception ex) {\n            assertTrue(ex.getMessage().contains(String.format(OErrorMessages.COMMAND_LINE_PARSER_EXPECTED_VALUE, \"-i\")));\n        }\n\n        try {\n            OStressTesterCommandLineParser.getStressTester(new String[]{\"-m\", \"foo\"});\n            fail();\n        }\n        catch (Exception ex) {\n            assertTrue(ex.getMessage().contains(String.format(OErrorMessages.COMMAND_LINE_PARSER_INVALID_MODE, \"foo\")));\n        }\n\n        OStressTester stressTester = OStressTesterCommandLineParser.getStressTester(new String[]{\"-n\",\"100\", \"-p\", \"foo\"});\n        assertEquals(100, stressTester.getIterationsNumber());\n        assertEquals(\"foo\", stressTester.getPassword());\n\n        stressTester = OStressTesterCommandLineParser.getStressTester(new String[]{\"-n\",\"100\", \"-t\", \"4\", \"-p\", \"foo\"});\n        assertEquals(100, stressTester.getIterationsNumber());\n        assertEquals(4, stressTester.getThreadsNumber());\n        assertEquals(\"foo\", stressTester.getPassword());\n\n        stressTester = OStressTesterCommandLineParser.getStressTester(new String[]{\"-n\",\"100\",\"-t\",\"4\",\"-m\",\"plocal\", \"-p\", \"foo\"});\n        assertEquals(100, stressTester.getIterationsNumber());\n        assertEquals(4, stressTester.getThreadsNumber());\n        assertEquals(com.orientechnologies.orient.stresstest.OMode.PLOCAL, stressTester.getMode());\n        assertEquals(\"foo\", stressTester.getPassword());\n\n        stressTester = OStressTesterCommandLineParser.getStressTester(new String[]{\"-n\",\"100\",\"-t\",\"4\",\"-m\",\"plocal\",\"-s\",\"c1r1u1d1\", \"-p\", \"foo\"});\n        assertEquals(100, stressTester.getIterationsNumber());\n        assertEquals(4, stressTester.getThreadsNumber());\n        assertEquals(com.orientechnologies.orient.stresstest.OMode.PLOCAL, stressTester.getMode());\n        assertEquals(\"foo\", stressTester.getPassword());\n    }","commit_id":"0f9a4effa472cc0a0c03f98e67466e31b78dd12a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n    public Object call() throws Exception {\n\n        // the database must be opened in the executing thread\n        ODatabase database = ODatabaseUtils.openDatabase(mode, dbName, password);\n\n        // executes all the operations defined for this test\n        long start = System.currentTimeMillis();\n        executeCreates(operationsSet.getNumberOfCreates());\n        long createsTime = (System.currentTimeMillis() - start);\n\n        start = System.currentTimeMillis();\n        executeReads(operationsSet.getNumberOfReads(), database);\n        long insertsTime = (System.currentTimeMillis() - start);\n\n        start = System.currentTimeMillis();\n        executeUpdates(operationsSet.getNumberOfUpdates());\n        long updatesTime = (System.currentTimeMillis() - start);\n\n        start = System.currentTimeMillis();\n        executeDeletes(operationsSet.getNumberOfDeletes());\n        long deletesTime = (System.currentTimeMillis() - start);\n\n        // and return the timings of this run of the test\n        return new OOperationsExecutorResults(\n                createsTime,\n                insertsTime,\n                updatesTime,\n                deletesTime);\n    }","id":60667,"modified_method":"@Override\n    public Object call() throws Exception {\n\n        // the database must be opened in the executing thread\n        ODatabase database = ODatabaseUtils.openDatabase(databaseIdentifier);\n\n        // executes all the operations defined for this test\n        long start = System.currentTimeMillis();\n        executeCreates(operationsSet.getNumberOfCreates());\n        long createsTime = (System.currentTimeMillis() - start);\n\n        start = System.currentTimeMillis();\n        executeReads(operationsSet.getNumberOfReads(), database);\n        long insertsTime = (System.currentTimeMillis() - start);\n\n        start = System.currentTimeMillis();\n        executeUpdates(operationsSet.getNumberOfUpdates());\n        long updatesTime = (System.currentTimeMillis() - start);\n\n        start = System.currentTimeMillis();\n        executeDeletes(operationsSet.getNumberOfDeletes());\n        long deletesTime = (System.currentTimeMillis() - start);\n\n        // and return the timings of this run of the test\n        return new OOperationsExecutorResults(\n                createsTime,\n                insertsTime,\n                updatesTime,\n                deletesTime);\n    }","commit_id":"7720cac745d85116452695aa26fb6c298777cb4c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OOperationsExecutor(String dbName, String password, OMode mode, OOperationsSet operationsSet, OConsoleWriter consoleWriter) {\n        this.dbName = dbName;\n        this.password = password;\n        this.mode = mode;\n        this.consoleWriter = consoleWriter;\n        this.operationsSet = operationsSet;\n        insertedDocs = new ArrayList<ODocument>();\n    }","id":60668,"modified_method":"public OOperationsExecutor(ODatabaseIdentifier databaseIdentifier, OOperationsSet operationsSet, OConsoleWriter consoleWriter) {\n        this.databaseIdentifier = databaseIdentifier;\n        this.consoleWriter = consoleWriter;\n        this.operationsSet = operationsSet;\n        insertedDocs = new ArrayList<ODocument>();\n    }","commit_id":"7720cac745d85116452695aa26fb6c298777cb4c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private StringBuilder getParameters() {\n        return new StringBuilder(\"OMode: \")\n                .append(mode.toString())\n                .append(\", Threads: \")\n                .append(threadsNumber)\n                .append(\", Iterations: \")\n                .append(iterationsNumber)\n                .append(\", Operations: \")\n                .append(operationsSet.toString());\n    }","id":60669,"modified_method":"private StringBuilder getParameters() {\n        return new StringBuilder(\"Mode: \")\n                .append(mode.toString())\n                .append(\", Threads: \")\n                .append(threadsNumber)\n                .append(\", Iterations: \")\n                .append(iterationsNumber)\n                .append(\", Operations: \")\n                .append(operationsSet.toString());\n    }","commit_id":"7720cac745d85116452695aa26fb6c298777cb4c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    private int execute() throws Exception {\n\n        long startTime;\n        long totalTime = 0;\n        int returnCode = 0;\n\n        // we don't want logs from DB\n        OLogManager.instance().setConsoleLevel(\"SEVERE\");\n\n        // creates the temporary DB where to execute the test\n        String dbName = OConstants.TEMP_DATABASE_NAME + new SimpleDateFormat(\"yyyyMMdd_HHmmss\").format(new Date());\n        ODatabaseUtils.createDatabase(dbName, mode, password);\n\n        // opens the newly created db and creates an index on the class we're going to use\n        ODatabase database = ODatabaseUtils.openDatabase(mode, dbName, password);\n        if (database == null) {\n            throw new Exception(\"Couldn't open database \" + dbName + \".\");\n        }\n\n        try {\n\n            final OSchema schema = database.getMetadata().getSchema();\n            final OClass oClass = schema.createClass(OConstants.CLASS_NAME);\n            oClass.createProperty(\"name\", OType.STRING);\n            OIndexManager indexManager = database.getMetadata().getIndexManager();\n            indexManager.createIndex(\n                    OConstants.INDEX_NAME,\n                    OClass.INDEX_TYPE.UNIQUE.toString(),\n                    new OPropertyIndexDefinition(\n                            OConstants.CLASS_NAME,\n                            \"name\",\n                            OType.STRING\n                    ),\n                    oClass.getClusterIds(),\n                    null,\n                    null);\n        } finally {\n            database.close();\n        }\n\n        // starts the test\n        try {\n\n            // iterates n times\n            for (int i = 0; i < iterationsNumber; i++) {\n\n                // creates the operations executors\n                List<Callable<OOperationsExecutorResults>> operationsExecutors = new ArrayList<Callable<OOperationsExecutorResults>>();\n                for (int j = 0; j < threadsNumber; j++) {\n                    operationsExecutors.add(new OOperationsExecutor(dbName, password, mode, operationsSet, consoleProgressWriter));\n                }\n\n                // starts parallel execution (blocking)\n                startTime = System.currentTimeMillis();\n                List<Future<OOperationsExecutorResults>> threadsResults = Executors.newFixedThreadPool(threadsNumber).invokeAll(operationsExecutors);\n                totalTime += System.currentTimeMillis() - startTime;\n\n                // add the output of every executor\n                for (Future<OOperationsExecutorResults> threadResults : threadsResults) {\n                    stressTestResults.addThreadResults(threadResults.get());\n                }\n            }\n            // stops total benchmarking\n            stressTestResults.addTotalExecutionTime(totalTime);\n\n            // prints out total output\n            System.out.println(\"\\r                                                                                             \");\n            System.out.println(stressTestResults.toString());\n\n        } catch (Exception ex) {\n            System.err.println(\"\\nAn error has occurred while running the stress test: \" + ex.getMessage());\n            returnCode = 1;\n            // ex.printStackTrace();\n        } finally {\n            // we don't need to drop the in memory DB\n            if (mode != OMode.MEMORY) {\n                ODatabaseUtils.dropDatabase(dbName, mode, password);\n            }\n        }\n\n        return returnCode;\n    }","id":60670,"modified_method":"@SuppressWarnings(\"unchecked\")\n    private int execute() throws Exception {\n\n        long startTime;\n        long totalTime = 0;\n        int returnCode = 0;\n\n        // we don't want logs from DB\n        OLogManager.instance().setConsoleLevel(\"SEVERE\");\n\n        // creates the temporary DB where to execute the test\n        ODatabaseUtils.createDatabase(databaseIdentifier);\n\n        // opens the newly created db and creates an index on the class we're going to use\n        ODatabase database = ODatabaseUtils.openDatabase(databaseIdentifier);\n        if (database == null) {\n            throw new Exception(\"Couldn't open database \" + databaseIdentifier.getName() + \".\");\n        }\n\n        try {\n\n            final OSchema schema = database.getMetadata().getSchema();\n            final OClass oClass = schema.createClass(OConstants.CLASS_NAME);\n            oClass.createProperty(\"name\", OType.STRING);\n            OIndexManager indexManager = database.getMetadata().getIndexManager();\n            indexManager.createIndex(\n                    OConstants.INDEX_NAME,\n                    OClass.INDEX_TYPE.UNIQUE.toString(),\n                    new OPropertyIndexDefinition(\n                            OConstants.CLASS_NAME,\n                            \"name\",\n                            OType.STRING\n                    ),\n                    oClass.getClusterIds(),\n                    null,\n                    null);\n        } finally {\n            database.close();\n        }\n\n        // starts the test\n        try {\n\n            // iterates n times\n            for (int i = 0; i < iterationsNumber; i++) {\n\n                // creates the operations executors\n                List<Callable<OOperationsExecutorResults>> operationsExecutors = new ArrayList<Callable<OOperationsExecutorResults>>();\n                for (int j = 0; j < threadsNumber; j++) {\n                    operationsExecutors.add(new OOperationsExecutor(databaseIdentifier, operationsSet, consoleProgressWriter));\n                }\n\n                // starts parallel execution (blocking)\n                startTime = System.currentTimeMillis();\n                List<Future<OOperationsExecutorResults>> threadsResults = Executors.newFixedThreadPool(threadsNumber).invokeAll(operationsExecutors);\n                totalTime += System.currentTimeMillis() - startTime;\n\n                // add the output of every executor\n                for (Future<OOperationsExecutorResults> threadResults : threadsResults) {\n                    stressTestResults.addThreadResults(threadResults.get());\n                }\n            }\n            // stops total benchmarking\n            stressTestResults.addTotalExecutionTime(totalTime);\n\n            // prints out total output\n            System.out.println(\"\\r                                                                                             \");\n            System.out.println(stressTestResults.toString());\n\n        } catch (Exception ex) {\n            System.err.println(\"\\nAn error has occurred while running the stress test: \" + ex.getMessage());\n            returnCode = 1;\n            // ex.printStackTrace();\n        } finally {\n            // we don't need to drop the in-memory DB\n            if (databaseIdentifier.getMode() != OMode.MEMORY) {\n                ODatabaseUtils.dropDatabase(databaseIdentifier);\n            }\n        }\n\n        return returnCode;\n    }","commit_id":"7720cac745d85116452695aa26fb6c298777cb4c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public String getPassword() {\n        return password;\n    }","id":60671,"modified_method":"public String getPassword() {\n        return databaseIdentifier.getPassword();\n    }","commit_id":"7720cac745d85116452695aa26fb6c298777cb4c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OStressTester(OMode mode, OOperationsSet operationsSet, int iterationsNumber, int threadsNumber, String password) throws Exception {\n        this.mode = mode;\n        this.operationsSet = operationsSet;\n        this.iterationsNumber = iterationsNumber;\n        this.threadsNumber = threadsNumber;\n        stressTestResults = new OStressTestResults(operationsSet, mode, threadsNumber, iterationsNumber);\n        consoleProgressWriter = new OConsoleWriter(operationsSet, threadsNumber, iterationsNumber);\n\n        this.password = password;\n        if (password == null) {\n            Console console = System.console();\n            if (console != null) {\n                this.password = new String(console.readPassword(\"Server Root Password: \"));\n            } else {\n                throw new Exception(\"An error has occurred opening the console. Please supply the root password as the -p parameter.\");\n            }\n        }\n\n    }","id":60672,"modified_method":"public OStressTester(ODatabaseIdentifier databaseIdentifier, OOperationsSet operationsSet, int iterationsNumber, int threadsNumber) throws Exception {\n        this.operationsSet = operationsSet;\n        this.iterationsNumber = iterationsNumber;\n        this.threadsNumber = threadsNumber;\n        this.databaseIdentifier = databaseIdentifier;\n        stressTestResults = new OStressTestResults(operationsSet, databaseIdentifier.getMode(), threadsNumber, iterationsNumber);\n        consoleProgressWriter = new OConsoleWriter(operationsSet, threadsNumber, iterationsNumber);\n    }","commit_id":"7720cac745d85116452695aa26fb6c298777cb4c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OMode getMode() {\n        return mode;\n    }","id":60673,"modified_method":"public OMode getMode() {\n        return databaseIdentifier.getMode();\n    }","commit_id":"7720cac745d85116452695aa26fb6c298777cb4c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private static int getNumber(String value, String option) throws OInitException {\n        try {\n            int val = Integer.parseInt(value);\n            if (val < 0) {\n                throw new NumberFormatException();\n            }\n            return val;\n        } catch (NumberFormatException ex) {\n            throw new OInitException(String.format(OErrorMessages.COMMAND_LINE_PARSER_INVALID_NUMBER, option, value));\n        }\n    }","id":60674,"modified_method":"private static int getNumber(String value, String option) throws OInitException {\n        try {\n            int val = Integer.parseInt(value);\n            if (val < 0) {\n                throw new OInitException(String.format(OErrorMessages.COMMAND_LINE_PARSER_LESSER_THAN_ZERO_NUMBER, option));\n            }\n            return val;\n        } catch (NumberFormatException ex) {\n            throw new OInitException(String.format(OErrorMessages.COMMAND_LINE_PARSER_INVALID_NUMBER, option, value));\n        }\n    }","commit_id":"7720cac745d85116452695aa26fb6c298777cb4c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public static OStressTester getStressTester(String[] args) throws Exception {\n\n        Map<String, String> options = checkOptions(readOptions(args));\n        int iterationsNumber = getNumber(options.get(OConstants.OPTION_ITERATIONS), \"iterations\");\n        int threadsNumber = getNumber(options.get(OConstants.OPTION_THREADS), \"threads\");\n        OMode mode = OMode.valueOf(options.get(OConstants.OPTION_MODE).toUpperCase());\n        if (mode == OMode.DISTRIBUTED) {\n            throw new OInitException(\"OMode [\" + mode + \"] not yet supported.\");\n        }\n        OOperationsSet operationsSet = new OOperationsSet(options.get(OConstants.OPTION_OPERATIONS), threadsNumber, iterationsNumber);\n        String rootPassword = options.get(OConstants.OPTION_ROOT_PASSWORD);\n        return new OStressTester(mode, operationsSet, iterationsNumber, threadsNumber, rootPassword);\n    }","id":60675,"modified_method":"/**\n     * builds a StressTester object using the command line arguments\n     * @param args\n     * @return\n     * @throws Exception\n     */\n    public static OStressTester getStressTester(String[] args) throws Exception {\n\n        Map<String, String> options = checkOptions(readOptions(args));\n        String dbName = OConstants.TEMP_DATABASE_NAME + new SimpleDateFormat(\"yyyyMMdd_HHmmss\").format(new Date());\n        OMode mode = OMode.valueOf(options.get(OConstants.OPTION_MODE).toUpperCase());\n        String rootPassword = options.get(OConstants.OPTION_ROOT_PASSWORD);\n        int iterationsNumber = getNumber(options.get(OConstants.OPTION_ITERATIONS), \"iterations\");\n        int threadsNumber = getNumber(options.get(OConstants.OPTION_THREADS), \"threads\");\n        OOperationsSet operationsSet = new OOperationsSet(options.get(OConstants.OPTION_OPERATIONS), threadsNumber, iterationsNumber);\n        String remoteIp = options.get(OConstants.OPTION_REMOTE_IP);\n        int remotePort = 2424;\n\n        if (options.get(OConstants.OPTION_REMOTE_PORT) != null) {\n            remotePort = getNumber(options.get(OConstants.OPTION_REMOTE_PORT), \"remotePort\");\n            if (remotePort > 65535) {\n                throw new OInitException(String.format(OErrorMessages.COMMAND_LINE_PARSER_INVALID_REMOTE_PORT_NUMBER, remotePort));\n            }\n        }\n\n        if (mode == OMode.DISTRIBUTED) {\n            throw new OInitException(String.format(\"OMode [%s] not yet supported.\", mode));\n        }\n\n        if (mode == OMode.REMOTE && remoteIp == null) {\n            throw new OInitException(OErrorMessages.COMMAND_LINE_PARSER_MISSING_REMOTE_IP);\n        }\n\n        if (rootPassword == null && mode == OMode.REMOTE) {\n            Console console = System.console();\n            if (console != null) {\n                rootPassword = String.valueOf(console.readPassword(String.format(OConstants.CONSOLE_REMOTE_PASSWORD_PROMPT, remoteIp , remotePort)));\n            } else {\n                throw new Exception(OErrorMessages.ERROR_OPENING_CONSOLE);\n            }\n        }\n\n        ODatabaseIdentifier databaseIdentifier = new ODatabaseIdentifier(mode, dbName, rootPassword, remoteIp, remotePort);\n        return new OStressTester(databaseIdentifier, operationsSet, iterationsNumber, threadsNumber);\n    }","commit_id":"7720cac745d85116452695aa26fb6c298777cb4c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private static Map<String, String> checkOptions(Map<String, String> options) throws OInitException {\n\n        options = setDefaultIfNotPresent(options, OConstants.OPTION_MODE, OMode.PLOCAL.name());\n        options = setDefaultIfNotPresent(options, OConstants.OPTION_ITERATIONS, \"10\");\n        options = setDefaultIfNotPresent(options, OConstants.OPTION_THREADS, \"4\");\n        options = setDefaultIfNotPresent(options, OConstants.OPTION_OPERATIONS, \"C5000R5000U5000D5000\");\n\n        try {\n            OMode.valueOf(options.get(OConstants.OPTION_MODE).toUpperCase());\n        } catch (IllegalArgumentException ex) {\n            throw new OInitException(String.format(OErrorMessages.COMMAND_LINE_PARSER_INVALID_MODE, options.get(OConstants.OPTION_MODE)));\n        }\n\n        return options;\n    }","id":60676,"modified_method":"private static Map<String, String> checkOptions(Map<String, String> options) throws OInitException {\n\n        if (options.get(OConstants.OPTION_MODE) == null) {\n            throw new OInitException(String.format(OErrorMessages.COMMAND_LINE_PARSER_MODE_PARAM_MANDATORY));\n        }\n\n        options = setDefaultIfNotPresent(options, OConstants.OPTION_MODE, OMode.PLOCAL.name());\n        options = setDefaultIfNotPresent(options, OConstants.OPTION_ITERATIONS, \"10\");\n        options = setDefaultIfNotPresent(options, OConstants.OPTION_THREADS, \"4\");\n        options = setDefaultIfNotPresent(options, OConstants.OPTION_OPERATIONS, \"C5000R5000U5000D5000\");\n\n        try {\n            OMode.valueOf(options.get(OConstants.OPTION_MODE).toUpperCase());\n        } catch (IllegalArgumentException ex) {\n            throw new OInitException(String.format(OErrorMessages.COMMAND_LINE_PARSER_INVALID_MODE, options.get(OConstants.OPTION_MODE)));\n        }\n\n        return options;\n    }","commit_id":"7720cac745d85116452695aa26fb6c298777cb4c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test\n    public void testCommandLineArgs() throws Exception {\n        try {\n            OStressTesterCommandLineParser.getStressTester(new String[]{\"\"});\n            fail();\n        }\n        catch (Exception ex) {\n            assertTrue(ex.getMessage().contains(String.format(OErrorMessages.COMMAND_LINE_PARSER_INVALID_OPTION, \"\")));\n        }\n\n        try {\n            OStressTesterCommandLineParser.getStressTester(new String[]{\"-i foo\"});\n            fail();\n        }\n        catch (Exception ex) {\n        }\n\n        try {\n            OStressTesterCommandLineParser.getStressTester(new String[]{\"-i\"});\n            fail();\n        }\n        catch (Exception ex) {\n            assertTrue(ex.getMessage().contains(String.format(OErrorMessages.COMMAND_LINE_PARSER_EXPECTED_VALUE, \"-i\")));\n        }\n\n        try {\n            OStressTesterCommandLineParser.getStressTester(new String[]{\"-m\", \"foo\"});\n            fail();\n        }\n        catch (Exception ex) {\n            assertTrue(ex.getMessage().contains(String.format(OErrorMessages.COMMAND_LINE_PARSER_INVALID_MODE, \"foo\")));\n        }\n\n        OStressTester stressTester = OStressTesterCommandLineParser.getStressTester(new String[]{\"-n\",\"100\", \"-p\", \"foo\"});\n        assertEquals(100, stressTester.getIterationsNumber());\n        assertEquals(\"foo\", stressTester.getPassword());\n\n        stressTester = OStressTesterCommandLineParser.getStressTester(new String[]{\"-n\",\"100\", \"-t\", \"4\", \"-p\", \"foo\"});\n        assertEquals(100, stressTester.getIterationsNumber());\n        assertEquals(4, stressTester.getThreadsNumber());\n        assertEquals(\"foo\", stressTester.getPassword());\n\n        stressTester = OStressTesterCommandLineParser.getStressTester(new String[]{\"-n\",\"100\",\"-t\",\"4\",\"-m\",\"plocal\", \"-p\", \"foo\"});\n        assertEquals(100, stressTester.getIterationsNumber());\n        assertEquals(4, stressTester.getThreadsNumber());\n        assertEquals(com.orientechnologies.orient.stresstest.OMode.PLOCAL, stressTester.getMode());\n        assertEquals(\"foo\", stressTester.getPassword());\n\n        stressTester = OStressTesterCommandLineParser.getStressTester(new String[]{\"-n\",\"100\",\"-t\",\"4\",\"-m\",\"plocal\",\"-s\",\"c1r1u1d1\", \"-p\", \"foo\"});\n        assertEquals(100, stressTester.getIterationsNumber());\n        assertEquals(4, stressTester.getThreadsNumber());\n        assertEquals(com.orientechnologies.orient.stresstest.OMode.PLOCAL, stressTester.getMode());\n        assertEquals(\"foo\", stressTester.getPassword());\n    }","id":60677,"modified_method":"@Test\n    public void testCommandLineArgs() throws Exception {\n        try {\n            OStressTesterCommandLineParser.getStressTester(new String[]{\"\"});\n            fail();\n        }\n        catch (Exception ex) {\n            assertTrue(ex.getMessage().contains(String.format(OErrorMessages.COMMAND_LINE_PARSER_INVALID_OPTION, \"\")));\n        }\n\n        try {\n            OStressTesterCommandLineParser.getStressTester(new String[]{\"-i foo\"});\n            fail();\n        }\n        catch (Exception ex) {\n            assertTrue(ex.getMessage().contains(String.format(OErrorMessages.COMMAND_LINE_PARSER_EXPECTED_VALUE, \"-i foo\")));\n        }\n\n        try {\n            OStressTesterCommandLineParser.getStressTester(new String[]{\"-i\"});\n            fail();\n        }\n        catch (Exception ex) {\n            assertTrue(ex.getMessage().contains(String.format(OErrorMessages.COMMAND_LINE_PARSER_EXPECTED_VALUE, \"-i\")));\n        }\n\n        try {\n            OStressTesterCommandLineParser.getStressTester(new String[]{\"-t\", \"10\", \"-p\"});\n            fail();\n        }\n        catch (Exception ex) {\n            assertTrue(ex.getMessage().contains(String.format(OErrorMessages.COMMAND_LINE_PARSER_EXPECTED_VALUE, \"-p\")));\n        }\n\n        try {\n            OStressTesterCommandLineParser.getStressTester(new String[]{\"-m\", \"foo\"});\n            fail();\n        }\n        catch (Exception ex) {\n            assertTrue(ex.getMessage().contains(String.format(OErrorMessages.COMMAND_LINE_PARSER_INVALID_MODE, \"foo\")));\n        }\n\n        try {\n            OStressTesterCommandLineParser.getStressTester(new String[]{\"-m\", \"remote\"});\n            fail();\n        }\n        catch (Exception ex) {\n            assertTrue(ex.getMessage().contains(OErrorMessages.COMMAND_LINE_PARSER_MISSING_REMOTE_IP));\n        }\n\n        try {\n            OStressTesterCommandLineParser.getStressTester(new String[]{\"-n\", \"10\"});\n            fail();\n        }\n        catch (Exception ex) {\n            assertTrue(ex.getMessage().contains(OErrorMessages.COMMAND_LINE_PARSER_MODE_PARAM_MANDATORY));\n        }\n\n        OStressTester stressTester = OStressTesterCommandLineParser.getStressTester(new String[]{\"-n\",\"100\", \"-p\", \"foo\", \"-m\", \"plocal\"});\n        assertEquals(100, stressTester.getIterationsNumber());\n        assertEquals(\"foo\", stressTester.getPassword());\n        assertEquals(OMode.PLOCAL, stressTester.getDatabaseIdentifier().getMode());\n\n        stressTester = OStressTesterCommandLineParser.getStressTester(new String[]{\"-m\", \"memory\", \"-p\", \"foo\"});\n        assertEquals(\"foo\", stressTester.getPassword());\n        assertEquals(OMode.MEMORY, stressTester.getDatabaseIdentifier().getMode());\n\n        stressTester = OStressTesterCommandLineParser.getStressTester(new String[]{\"-n\",\"100\", \"-t\", \"4\", \"-p\", \"foo\", \"-m\", \"plocal\"});\n        assertEquals(100, stressTester.getIterationsNumber());\n        assertEquals(4, stressTester.getThreadsNumber());\n        assertNull(stressTester.getDatabaseIdentifier().getRemoteIp());\n        assertEquals(2424, stressTester.getDatabaseIdentifier().getRemotePort());\n\n        stressTester = OStressTesterCommandLineParser.getStressTester(new String[]{\"-m\",\"remote\", \"--remote-ip\", \"127.0.0.1\", \"-p\", \"foo\"});\n        assertEquals(\"foo\", stressTester.getPassword());\n        assertEquals(\"127.0.0.1\", stressTester.getDatabaseIdentifier().getRemoteIp());\n        assertEquals(2424, stressTester.getDatabaseIdentifier().getRemotePort());\n\n        stressTester = OStressTesterCommandLineParser.getStressTester(new String[]{\"-m\",\"remote\", \"--remote-ip\", \"127.0.0.1\", \"-p\", \"foo\", \"--remote-port\", \"1025\"});\n        assertEquals(\"foo\", stressTester.getPassword());\n        assertEquals(\"127.0.0.1\", stressTester.getDatabaseIdentifier().getRemoteIp());\n        assertEquals(1025, stressTester.getDatabaseIdentifier().getRemotePort());\n\n        stressTester = OStressTesterCommandLineParser.getStressTester(new String[]{\"-n\",\"100\",\"-t\",\"4\",\"-m\",\"plocal\", \"-p\", \"foo\"});\n        assertEquals(100, stressTester.getIterationsNumber());\n        assertEquals(4, stressTester.getThreadsNumber());\n        assertEquals(com.orientechnologies.orient.stresstest.OMode.PLOCAL, stressTester.getMode());\n        assertEquals(\"foo\", stressTester.getPassword());\n\n        stressTester = OStressTesterCommandLineParser.getStressTester(new String[]{\"-n\",\"100\",\"-t\",\"4\",\"-m\",\"plocal\",\"-s\",\"c1r1u1d1\", \"-p\", \"foo\"});\n        assertEquals(100, stressTester.getIterationsNumber());\n        assertEquals(4, stressTester.getThreadsNumber());\n        assertEquals(com.orientechnologies.orient.stresstest.OMode.PLOCAL, stressTester.getMode());\n        assertEquals(\"foo\", stressTester.getPassword());\n    }","commit_id":"7720cac745d85116452695aa26fb6c298777cb4c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void copy(TextFlow tf, HTextFlow htf) {\n\t\t\thtf.setContent(tf.getContent());\n\t\t\tList<Object> extensions = tf.getExtensions();\n\t\t\tif (extensions != null) {\n\t\t\t\tfor (Object ext : extensions) {\n\t\t\t\t\tif (ext instanceof TextFlowTargets) {\n\t\t\t\t\t\tTextFlowTargets targets = (TextFlowTargets) ext;\n\t\t\t\t\t\tfor (TextFlowTarget target : targets.getTargets()) {\n\t\t\t\t\t\t\tHTextFlowTarget hTarget = null;\n\t\t\t\t\t\t\tif (session.contains(htf)) {\n\t\t\t\t\t\t\t\thTarget = textFlowTargetDAO.getByNaturalId(htf, target.getLang());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (hTarget == null) {\n\t\t\t\t\t\t\t\thTarget = new HTextFlowTarget();\n\t\t\t\t\t\t\t\thTarget.setLocale(target.getLang());\n\t\t\t\t\t\t\t\thTarget.setTextFlow(htf);\n\t\t\t\t\t\t\t\thTarget.setState(target.getState());\n//\t\t\t\t\t\thTarget.setRevision(revision); // TODO\n\t\t\t\t\t\t\t\thTarget.setContent(target.getContent());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcopy(target, hTarget, htf);\n\t\t\t\t\t\t\thtf.getTargets().put(target.getLang(), hTarget);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ext instanceof SimpleComment) {\n\t\t\t\t\t\tSimpleComment simpleComment = (SimpleComment) ext;\n\t\t\t\t\t\tHSimpleComment hComment = htf.getComment();\n\t\t\t\t\t\tif (hComment == null)\n\t\t\t\t\t\t\thComment = new HSimpleComment();\n\t\t\t\t\t\thComment.setComment(simpleComment.getValue());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RuntimeException(\"Unknown TextFlow extension \"+ext.getClass());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t    }","id":60678,"modified_method":"private void copy(TextFlow tf, HTextFlow htf) {\n\t\t\thtf.setContent(tf.getContent());\n\t\t\tList<Object> extensions = tf.getExtensions();\n\t\t\tif (extensions != null) {\n\t\t\t\tfor (Object ext : extensions) {\n\t\t\t\t\tif (ext instanceof TextFlowTargets) {\n\t\t\t\t\t\tTextFlowTargets targets = (TextFlowTargets) ext;\n\t\t\t\t\t\tfor (TextFlowTarget target : targets.getTargets()) {\n\t\t\t\t\t\t\tHTextFlowTarget hTarget = null;\n\t\t\t\t\t\t\tif (session.contains(htf)) {\n\t\t\t\t\t\t\t\thTarget = textFlowTargetDAO.getByNaturalId(htf, target.getLang());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (hTarget == null) {\n\t\t\t\t\t\t\t\thTarget = new HTextFlowTarget();\n\t\t\t\t\t\t\t\thTarget.setLocale(target.getLang());\n\t\t\t\t\t\t\t\thTarget.setTextFlow(htf);\n\t\t\t\t\t\t\t\thTarget.setState(target.getState());\n//\t\t\t\t\t\thTarget.setRevision(revision); // TODO\n\t\t\t\t\t\t\t\thTarget.setContent(target.getContent());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcopy(target, hTarget, htf);\n\t\t\t\t\t\t\thtf.getTargets().put(target.getLang(), hTarget);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ext instanceof SimpleComment) {\n\t\t\t\t\t\tSimpleComment simpleComment = (SimpleComment) ext;\n\t\t\t\t\t\tHSimpleComment hComment = htf.getComment();\n\t\t\t\t\t\tif (hComment == null) {\n\t\t\t\t\t\t\thComment = new HSimpleComment();\n\t\t\t\t\t\t\thtf.setComment(hComment);\n\t\t\t\t\t\t}\n\t\t\t\t\t\thComment.setComment(simpleComment.getValue());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RuntimeException(\"Unknown TextFlow extension \"+ext.getClass());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t    }","commit_id":"125396a7563f84f7579952fc364f2ee15e78f04f","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void copy(TextFlowTarget target, HTextFlowTarget hTarget,\n\t\t\tHTextFlow htf) {\n\t\thTarget.setContent(target.getContent());\n\t\thTarget.setLocale(target.getLang());\n\t\thTarget.setRevision(target.getVersion());\n\t\thTarget.setState(target.getState());\n\t\thTarget.setTextFlow(htf);\n\t\tif(target.hasComment()) {\n\t\t\thTarget.setComment(new HSimpleComment(target.getComment().getValue()));\n\t\t}\n\t}","id":60679,"modified_method":"private void copy(TextFlowTarget target, HTextFlowTarget hTarget,\n\t\t\tHTextFlow htf) {\n\t\thTarget.setContent(target.getContent());\n\t\thTarget.setLocale(target.getLang());\n\t\thTarget.setRevision(target.getVersion());\n\t\thTarget.setState(target.getState());\n\t\thTarget.setTextFlow(htf);\n\t\tif(target.hasComment()) {\n\t\t\tHSimpleComment hComment = hTarget.getComment();\n\t\t\tif (hComment == null) {\n\t\t\t\thComment = new HSimpleComment();\n\t\t\t\thTarget.setComment(hComment);\n\t\t\t}\n\t\t\thComment.setComment(target.getComment().getValue());\n\t\t}\n\t}","commit_id":"125396a7563f84f7579952fc364f2ee15e78f04f","url":"https://github.com/zanata/zanata-server"},{"original_method":"private TextFlow newTextFlow(String id, String sourceContent, String sourceComment, String targetLocale, String targetContent, String targetComment) {\n\t\tTextFlow textFlow = new TextFlow(id, LocaleId.EN);\n\t    textFlow.setContent(sourceContent);\n\t    // FIXME disabled until we get comment persistence working\n//\t    if (sourceComment != null)\n//\t    \ttextFlow.getOrAddComment().setValue(sourceComment);\n\t    TextFlowTarget target = new TextFlowTarget(textFlow, LocaleId.fromJavaName(targetLocale));\n\t    target.setContent(targetContent);\n\t    // FIXME disabled until we get comment persistence working\n//\t    if (targetComment != null)\n//\t    \ttarget.getOrAddComment().setValue(targetComment);\n\t\ttextFlow.addTarget(target);\n\t\treturn textFlow;\n\t}","id":60680,"modified_method":"private TextFlow newTextFlow(String id, String sourceContent, String sourceComment, String targetLocale, String targetContent, String targetComment) {\n\t\tTextFlow textFlow = new TextFlow(id, LocaleId.EN);\n\t    textFlow.setContent(sourceContent);\n\t    // FIXME disabled until we get comment persistence working\n\t    if (sourceComment != null)\n\t    \ttextFlow.getOrAddComment().setValue(sourceComment);\n\t    TextFlowTarget target = new TextFlowTarget(textFlow, LocaleId.fromJavaName(targetLocale));\n\t    target.setContent(targetContent);\n\t    // FIXME disabled until we get comment persistence working\n\t    if (targetComment != null)\n\t    \ttarget.getOrAddComment().setValue(targetComment);\n\t\ttextFlow.addTarget(target);\n\t\treturn textFlow;\n\t}","commit_id":"125396a7563f84f7579952fc364f2ee15e78f04f","url":"https://github.com/zanata/zanata-server"},{"original_method":"private HSimpleComment createComment(HTextFlowTarget target) \n   {\n      String authorname;\n      HDocument document = target.getTextFlow().getDocument();\n      String projectname = document.getProjectIteration().getProject().getName();\n      String version = document.getProjectIteration().getSlug();\n      String documentid = document.getDocId();\n      if (target.getLastModifiedBy()!=null)\n      {\n         authorname = target.getLastModifiedBy().getName();\n      }\n      else\n      {\n         authorname = \"\";\n      }\n\n      return new HSimpleComment(\"translation auto-copied from project \"+projectname+\", version \"+version+\", document \"+documentid+\", author \"+authorname);\n   }","id":60681,"modified_method":"private String createComment(HTextFlowTarget target) \n   {\n      String authorname;\n      HDocument document = target.getTextFlow().getDocument();\n      String projectname = document.getProjectIteration().getProject().getName();\n      String version = document.getProjectIteration().getSlug();\n      String documentid = document.getDocId();\n      if (target.getLastModifiedBy()!=null)\n      {\n         authorname = target.getLastModifiedBy().getName();\n      }\n      else\n      {\n         authorname = \"\";\n      }\n\n      return \"translation auto-copied from project \"+projectname+\", version \"+version+\", document \"+documentid+\", author \"+authorname;\n   }","commit_id":"0160ac950580818deb4d51a289e5f3606d6de7cb","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void copyClosestEquivalentTranslation(HDocument document) \n   {\n      List<HTextFlowTarget> newTargets = new ArrayList<HTextFlowTarget>();\n\n      for (HTextFlow textFlow : document.getTextFlows())\n      {\n         // find closest equivalent textflowtarget\n         List<HLocale> localelist = localeDAO.findAllActive();\n         for (HLocale locale : localelist)\n         {\n            // check whether the textFlow have textflowtarget\n            HTextFlowTarget result = textFlow.getTargets().get(locale);\n            if (result == null)\n            {\n               HTextFlowTarget from = textFlowTargetDAO.findClosestEquivalentTranslation(textFlow, locale.getLocaleId());\n               if (from != null)\n               {\n                  HTextFlowTarget hTarget = new HTextFlowTarget(textFlow, from.getLocale());\n                  hTarget.setVersionNum(from.getVersionNum());\n                  hTarget.setContent(from.getContent());\n                  hTarget.setState(from.getState());\n                  HSimpleComment hcomment = createComment(from);\n                  hTarget.setComment(hcomment);\n                  textFlow.getTargets().put(from.getLocale(), hTarget);\n                  newTargets.add(hTarget);\n               }\n            }\n\n         }\n\n      }\n\n      if (!newTargets.isEmpty() )\n      {\n\n         for (HTextFlowTarget target : newTargets)\n         {\n            textFlowTargetDAO.makePersistent(target);\n         }\n\n         textFlowTargetDAO.flush();\n         documentDAO.flush();\n\n      }\n\t    \t \n   }","id":60682,"modified_method":"public void copyClosestEquivalentTranslation(HDocument document) \n   {\n      int copyCount = 0;\n      List<HLocale> localelist = localeDAO.findAllActive();\n\n      for (HTextFlow textFlow : document.getTextFlows())\n      {\n         // find closest equivalent textflowtarget\n         for (HLocale locale : localelist)\n         {\n            HTextFlowTarget hTarget = textFlow.getTargets().get(locale);\n            if (hTarget != null && hTarget.getState() == ContentState.Approved)\n               continue;\n\n            HTextFlowTarget oldTFT = textFlowTargetDAO.findClosestEquivalentTranslation(textFlow, locale.getLocaleId());\n            if (oldTFT != null)\n            {\n               if (hTarget == null)\n               {\n                  hTarget = new HTextFlowTarget(textFlow, locale);\n                  hTarget.setVersionNum(1);\n                  textFlow.getTargets().put(locale, hTarget);\n               }\n               else\n               {\n                  // DB trigger will copy old value to history table, if we change the versionNum\n                  hTarget.setVersionNum(hTarget.getVersionNum()+1);\n               }\n               hTarget.setContent(oldTFT.getContent());\n               hTarget.setState(oldTFT.getState());\n               HSimpleComment hcomment = hTarget.getComment();\n               if (hcomment == null)\n               {\n                  hcomment = new HSimpleComment();\n                  hTarget.setComment(hcomment);\n               }\n               hcomment.setComment(createComment(oldTFT));\n               textFlowTargetDAO.makePersistent(hTarget);\n               ++copyCount;\n            }\n         }\n      }\n\n      {\n         log.info(\"copied {0} existing translations for document {1}{2}\", copyCount, document.getPath(), document.getName());\n      }\n   }","commit_id":"0160ac950580818deb4d51a289e5f3606d6de7cb","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n    public List<? extends PersistentResourceDefinition> getChildren() {\n        return Collections.singletonList(JspDefinition.INSTANCE);\n\n    }","id":60683,"modified_method":"@Override\n    public List<? extends PersistentResourceDefinition> getChildren() {\n        return CHILDREN;\n    }","commit_id":"589921c4d293894aeada98289b00f412043426cb","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public synchronized void start(final StartContext startContext) throws StartException {\n        ClassLoader oldTccl = Thread.currentThread().getContextClassLoader();\n        try {\n            Thread.currentThread().setContextClassLoader(module.getClassLoader());\n            DeploymentInfo deploymentInfo = createServletConfig();\n            handleDistributable(deploymentInfo);\n            handleIdentityManager(deploymentInfo);\n\n            SessionConfigMetaData sessionConfig = mergedMetaData.getSessionConfig();\n            if (sessionConfig != null) {\n                if (sessionConfig.getSessionTimeoutSet()) {\n                    deploymentInfo.setDefaultSessionTimeout(sessionConfig.getSessionTimeout() * 60);\n                }\n                CookieConfigMetaData cookieConfig = sessionConfig.getCookieConfig();\n                if (cookieConfig != null) {\n                    SessionCookieConfig config = new SessionCookieConfigImpl();\n                    if (cookieConfig.getName() != null) {\n                        config.setName(cookieConfig.getName());\n                    }\n                    config.setSecure(cookieConfig.getSecure());\n                    config.setPath(cookieConfig.getPath());\n                    config.setMaxAge(cookieConfig.getMaxAge());\n                    config.setDomain(cookieConfig.getDomain());\n                    config.setComment(cookieConfig.getComment());\n                    config.setHttpOnly(cookieConfig.getHttpOnly());\n                    deploymentInfo.setSessionCookieConfig(config);\n                }\n                //todo: session tracking modes\n\n            }\n\n            for (final SetupAction action : setupActions) {\n                deploymentInfo.addThreadSetupAction(new ThreadSetupAction() {\n\n                    private final Handle handle = new Handle() {\n                        @Override\n                        public void tearDown() {\n                            action.teardown(Collections.<String, Object>emptyMap());\n                        }\n                    };\n\n                    @Override\n                    public Handle setup(final HttpServerExchange exchange) {\n                        action.setup(Collections.<String, Object>emptyMap());\n                        return handle;\n                    }\n                });\n            }\n\n\n            this.deploymentInfo = deploymentInfo;\n        } finally {\n            Thread.currentThread().setContextClassLoader(oldTccl);\n        }\n\n    }","id":60684,"modified_method":"@Override\n    public synchronized void start(final StartContext startContext) throws StartException {\n        ClassLoader oldTccl = Thread.currentThread().getContextClassLoader();\n        try {\n            Thread.currentThread().setContextClassLoader(module.getClassLoader());\n            DeploymentInfo deploymentInfo = createServletConfig();\n            handleDistributable(deploymentInfo);\n            handleIdentityManager(deploymentInfo);\n\n\n            SessionConfigMetaData sessionConfig = mergedMetaData.getSessionConfig();\n            SessionCookieConfig config = null;\n            //default session config\n            SessionCookieConfigService defaultSessionConfig = defaultSessionCookieConfig.getOptionalValue();\n            if(defaultSessionConfig != null) {\n                config = new SessionCookieConfigImpl();\n                if(defaultSessionConfig.getName() != null) {\n                    config.setName(defaultSessionConfig.getName());\n                }\n                if(defaultSessionConfig.getDomain() != null) {\n                    config.setDomain(defaultSessionConfig.getDomain());\n                }\n                if(defaultSessionConfig.getHttpOnly() != null) {\n                    config.setHttpOnly(defaultSessionConfig.getHttpOnly());\n                }\n                if(defaultSessionConfig.getSecure() != null) {\n                    config.setSecure(defaultSessionConfig.getSecure());\n                }\n                if(defaultSessionConfig.getMaxAge() != null) {\n                    config.setMaxAge(defaultSessionConfig.getMaxAge());\n                }\n                if(defaultSessionConfig.getComment() != null) {\n                    config.setComment(defaultSessionConfig.getComment());\n                }\n            }\n\n            if (sessionConfig != null) {\n                if (sessionConfig.getSessionTimeoutSet()) {\n                    deploymentInfo.setDefaultSessionTimeout(sessionConfig.getSessionTimeout() * 60);\n                }\n                CookieConfigMetaData cookieConfig = sessionConfig.getCookieConfig();\n                if (cookieConfig != null) {\n                    if(config == null) {\n                        config = new SessionCookieConfigImpl();\n                    }\n                    if (cookieConfig.getName() != null) {\n                        config.setName(cookieConfig.getName());\n                    }\n                    if(cookieConfig.getDomain() != null) {\n                        config.setDomain(cookieConfig.getDomain());\n                    }\n                    if(cookieConfig.getDomain() != null) {\n                        config.setComment(cookieConfig.getComment());\n                    }\n                    config.setSecure(cookieConfig.getSecure());\n                    config.setPath(cookieConfig.getPath());\n                    config.setMaxAge(cookieConfig.getMaxAge());\n                    config.setHttpOnly(cookieConfig.getHttpOnly());\n                }\n                //todo: session tracking modes\n            }\n            if(config != null) {\n                deploymentInfo.setSessionCookieConfig(config);\n            }\n\n            for (final SetupAction action : setupActions) {\n                deploymentInfo.addThreadSetupAction(new ThreadSetupAction() {\n\n                    private final Handle handle = new Handle() {\n                        @Override\n                        public void tearDown() {\n                            action.teardown(Collections.<String, Object>emptyMap());\n                        }\n                    };\n\n                    @Override\n                    public Handle setup(final HttpServerExchange exchange) {\n                        action.setup(Collections.<String, Object>emptyMap());\n                        return handle;\n                    }\n                });\n            }\n\n\n            this.deploymentInfo = deploymentInfo;\n        } finally {\n            Thread.currentThread().setContextClassLoader(oldTccl);\n        }\n\n    }","commit_id":"589921c4d293894aeada98289b00f412043426cb","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void processDeployment(final WarMetaData warMetaData, final DeploymentUnit deploymentUnit, final ServiceTarget serviceTarget, String hostName)\n            throws DeploymentUnitProcessingException {\n        final VirtualFile deploymentRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT).getRoot();\n        final Module module = deploymentUnit.getAttachment(Attachments.MODULE);\n        if (module == null) {\n            throw new DeploymentUnitProcessingException(MESSAGES.failedToResolveModule(deploymentUnit));\n        }\n        final JBossWebMetaData metaData = warMetaData.getMergedJBossWebMetaData();\n        final List<SetupAction> setupActions = deploymentUnit.getAttachmentList(org.jboss.as.ee.component.Attachments.WEB_SETUP_ACTIONS);\n        metaData.resolveRunAs();\n\n        ScisMetaData scisMetaData = deploymentUnit.getAttachment(ScisMetaData.ATTACHMENT_KEY);\n\n        final Set<ServiceName> dependentComponents = new HashSet<>();\n        // see AS7-2077\n        // basically we want to ignore components that have failed for whatever reason\n        // if they are important they will be picked up when the web deployment actually starts\n        final List<ServiceName> components = deploymentUnit.getAttachmentList(WebComponentDescription.WEB_COMPONENTS);\n        final Set<ServiceName> failed = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.FAILED_COMPONENTS);\n        for (final ServiceName component : components) {\n            if (!failed.contains(component)) {\n                dependentComponents.add(component);\n            }\n        }\n\n        ComponentRegistry componentRegistry = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.COMPONENT_REGISTRY);\n        if (componentRegistry == null) {\n            //we do this to avoid lots of other null checks\n            //this will only happen if the EE subsystem is not installed\n            componentRegistry = new ComponentRegistry(null);\n        }\n\n        final WebInjectionContainer injectionContainer = new WebInjectionContainer(module.getClassLoader(), componentRegistry);\n\n        String securityContextId = deploymentUnit.getName();\n        if (deploymentUnit.getParent() != null) {\n            securityContextId = deploymentUnit.getParent().getName() + \"!\" + securityContextId;\n        }\n\n        final String pathName = pathNameOfDeployment(deploymentUnit, metaData);\n\n\n        String metaDataSecurityDomain = metaData.getSecurityDomain();\n        if (metaDataSecurityDomain == null) {\n            metaDataSecurityDomain = getJBossAppSecurityDomain(deploymentUnit);\n        }\n        if (metaDataSecurityDomain != null) {\n            metaDataSecurityDomain = metaDataSecurityDomain.trim();\n        }\n\n        String securityDomain = metaDataSecurityDomain == null ? SecurityConstants.DEFAULT_APPLICATION_POLICY : SecurityUtil\n                .unprefixSecurityDomain(metaDataSecurityDomain);\n\n        final ServiceName deploymentServiceName = UndertowService.deploymentServiceName(hostName,pathName);\n\n        TldsMetaData tldsMetaData = deploymentUnit.getAttachment(TldsMetaData.ATTACHMENT_KEY);\n        UndertowDeploymentInfoService undertowDeploymentInfoService = UndertowDeploymentInfoService.builder()\n                        .setAttributes(deploymentUnit.getAttachment(ServletContextAttribute.ATTACHMENT_KEY))\n                .setComponentRegistry(componentRegistry)\n                .setContextPath(pathName)\n                .setDeploymentName(deploymentUnit.getName())\n                .setDeploymentRoot(deploymentRoot)\n                .setInjectionContainer(injectionContainer)\n                .setMergedMetaData(warMetaData.getMergedJBossWebMetaData())\n                .setModule(module)\n                .setScisMetaData(scisMetaData)\n                .setSecurityContextId(securityContextId)\n                .setSecurityDomain(securityDomain)\n                .setSharedTlds(tldsMetaData == null ? Collections.<TldMetaData>emptyList() : tldsMetaData.getSharedTlds(deploymentUnit))\n                .setTldsMetaData(tldsMetaData)\n                .setSetupActions(setupActions)\n                .setOverlays(warMetaData.getOverlays())\n                .setExpressionFactoryWrappers(deploymentUnit.getAttachmentList(ExpressionFactoryWrapper.ATTACHMENT_KEY))\n                .createUndertowDeploymentInfoService();\n\n        final ServiceName deploymentInfoServiceName = deploymentServiceName.append(UndertowDeploymentInfoService.SERVICE_NAME);\n        ServiceBuilder<DeploymentInfo> infoBuilder = serviceTarget.addService(deploymentInfoServiceName, undertowDeploymentInfoService)\n                .addDependency(UndertowService.SERVLET_CONTAINER.append(defaultContainer), ServletContainerService.class, undertowDeploymentInfoService.getContainer())\n                .addDependency(SecurityDomainService.SERVICE_NAME.append(securityDomain), SecurityDomainContext.class, undertowDeploymentInfoService.getSecurityDomainContextValue())\n                .addDependency(UndertowService.UNDERTOW, UndertowService.class, undertowDeploymentInfoService.getUndertowService())\n                .addDependency(ServiceBuilder.DependencyType.OPTIONAL, BufferCacheService.SERVICE_NAME.append(\"default\"), DirectBufferCache.class, undertowDeploymentInfoService.getBufferCacheInjectedValue())\n                .addDependencies(deploymentUnit.getAttachmentList(Attachments.WEB_DEPENDENCIES));\n\n        if (metaData.getDistributable() != null) {\n            SessionManagerFactoryBuilderService factoryBuilderService = new SessionManagerFactoryBuilderService();\n            SessionManagerFactoryBuilder factoryBuilder = factoryBuilderService.getValue();\n            if (factoryBuilder != null) {\n                ServiceName factoryName = deploymentServiceName.append(\"session\");\n                factoryBuilder.build(serviceTarget, factoryName, deploymentServiceName, module, metaData)\n                    .setInitialMode(Mode.ON_DEMAND)\n                    .install()\n                ;\n                infoBuilder.addDependency(factoryName, SessionManagerFactory.class, undertowDeploymentInfoService.getSessionManagerFactoryInjector());\n            } else {\n                UndertowLogger.ROOT_LOGGER.clusteringNotSupported();\n            }\n        }\n\n        infoBuilder.install();\n\n        final ServiceName hostServiceName = UndertowService.virtualHostName(defaultServer, hostName);\n        final UndertowDeploymentService service = new UndertowDeploymentService(injectionContainer);\n        final ServiceBuilder<UndertowDeploymentService> builder = serviceTarget.addService(deploymentServiceName, service)\n                .addDependencies(dependentComponents)\n                .addDependency(UndertowService.SERVLET_CONTAINER.append(defaultContainer), ServletContainerService.class, service.getContainer())\n                .addDependency(hostServiceName, Host.class, service.getHost())\n                .addDependencies(deploymentUnit.getAttachmentList(Attachments.WEB_DEPENDENCIES))\n                .addDependency(deploymentInfoServiceName, DeploymentInfo.class, service.getDeploymentInfoInjectedValue());\n\n        deploymentUnit.addToAttachmentList(Attachments.DEPLOYMENT_COMPLETE_SERVICES, deploymentServiceName);\n\n        // OSGi web applications are activated in {@link WebContextActivationProcessor} according to bundle lifecycle changes\n        if (deploymentUnit.hasAttachment(Attachments.OSGI_MANIFEST)) {\n            builder.setInitialMode(Mode.NEVER);\n            UndertowDeploymentService.ContextActivatorImpl activator = new UndertowDeploymentService.ContextActivatorImpl(builder.install());\n            deploymentUnit.putAttachment(ContextActivator.ATTACHMENT_KEY, activator);\n        } else {\n            builder.setInitialMode(Mode.ACTIVE);\n            builder.install();\n        }\n\n        // Process the web related mgmt information\n        final ModelNode node = deploymentUnit.getDeploymentSubsystemModel(UndertowExtension.SUBSYSTEM_NAME);\n        node.get(DeploymentDefinition.CONTEXT_ROOT.getName()).set(\"\".equals(pathName) ? \"/\" : pathName);\n        node.get(DeploymentDefinition.VIRTUAL_HOST.getName()).set(hostName);\n        processManagement(deploymentUnit, metaData);\n    }","id":60685,"modified_method":"private void processDeployment(final WarMetaData warMetaData, final DeploymentUnit deploymentUnit, final ServiceTarget serviceTarget, String hostName)\n            throws DeploymentUnitProcessingException {\n        final VirtualFile deploymentRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT).getRoot();\n        final Module module = deploymentUnit.getAttachment(Attachments.MODULE);\n        if (module == null) {\n            throw new DeploymentUnitProcessingException(MESSAGES.failedToResolveModule(deploymentUnit));\n        }\n        final JBossWebMetaData metaData = warMetaData.getMergedJBossWebMetaData();\n        final List<SetupAction> setupActions = deploymentUnit.getAttachmentList(org.jboss.as.ee.component.Attachments.WEB_SETUP_ACTIONS);\n        metaData.resolveRunAs();\n\n        ScisMetaData scisMetaData = deploymentUnit.getAttachment(ScisMetaData.ATTACHMENT_KEY);\n\n        final Set<ServiceName> dependentComponents = new HashSet<>();\n        // see AS7-2077\n        // basically we want to ignore components that have failed for whatever reason\n        // if they are important they will be picked up when the web deployment actually starts\n        final List<ServiceName> components = deploymentUnit.getAttachmentList(WebComponentDescription.WEB_COMPONENTS);\n        final Set<ServiceName> failed = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.FAILED_COMPONENTS);\n        for (final ServiceName component : components) {\n            if (!failed.contains(component)) {\n                dependentComponents.add(component);\n            }\n        }\n\n        ComponentRegistry componentRegistry = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.COMPONENT_REGISTRY);\n        if (componentRegistry == null) {\n            //we do this to avoid lots of other null checks\n            //this will only happen if the EE subsystem is not installed\n            componentRegistry = new ComponentRegistry(null);\n        }\n\n        final WebInjectionContainer injectionContainer = new WebInjectionContainer(module.getClassLoader(), componentRegistry);\n\n        String securityContextId = deploymentUnit.getName();\n        if (deploymentUnit.getParent() != null) {\n            securityContextId = deploymentUnit.getParent().getName() + \"!\" + securityContextId;\n        }\n\n        final String pathName = pathNameOfDeployment(deploymentUnit, metaData);\n\n\n        String metaDataSecurityDomain = metaData.getSecurityDomain();\n        if (metaDataSecurityDomain == null) {\n            metaDataSecurityDomain = getJBossAppSecurityDomain(deploymentUnit);\n        }\n        if (metaDataSecurityDomain != null) {\n            metaDataSecurityDomain = metaDataSecurityDomain.trim();\n        }\n\n        String securityDomain = metaDataSecurityDomain == null ? SecurityConstants.DEFAULT_APPLICATION_POLICY : SecurityUtil\n                .unprefixSecurityDomain(metaDataSecurityDomain);\n\n        final ServiceName deploymentServiceName = UndertowService.deploymentServiceName(hostName,pathName);\n\n        TldsMetaData tldsMetaData = deploymentUnit.getAttachment(TldsMetaData.ATTACHMENT_KEY);\n        UndertowDeploymentInfoService undertowDeploymentInfoService = UndertowDeploymentInfoService.builder()\n                        .setAttributes(deploymentUnit.getAttachment(ServletContextAttribute.ATTACHMENT_KEY))\n                .setComponentRegistry(componentRegistry)\n                .setContextPath(pathName)\n                .setDeploymentName(deploymentUnit.getName())\n                .setDeploymentRoot(deploymentRoot)\n                .setInjectionContainer(injectionContainer)\n                .setMergedMetaData(warMetaData.getMergedJBossWebMetaData())\n                .setModule(module)\n                .setScisMetaData(scisMetaData)\n                .setSecurityContextId(securityContextId)\n                .setSecurityDomain(securityDomain)\n                .setSharedTlds(tldsMetaData == null ? Collections.<TldMetaData>emptyList() : tldsMetaData.getSharedTlds(deploymentUnit))\n                .setTldsMetaData(tldsMetaData)\n                .setSetupActions(setupActions)\n                .setOverlays(warMetaData.getOverlays())\n                .setExpressionFactoryWrappers(deploymentUnit.getAttachmentList(ExpressionFactoryWrapper.ATTACHMENT_KEY))\n                .createUndertowDeploymentInfoService();\n\n        final ServiceName deploymentInfoServiceName = deploymentServiceName.append(UndertowDeploymentInfoService.SERVICE_NAME);\n        ServiceBuilder<DeploymentInfo> infoBuilder = serviceTarget.addService(deploymentInfoServiceName, undertowDeploymentInfoService)\n                .addDependency(UndertowService.SERVLET_CONTAINER.append(defaultContainer), ServletContainerService.class, undertowDeploymentInfoService.getContainer())\n                .addDependency(ServiceBuilder.DependencyType.OPTIONAL, SessionCookieConfigService.SERVICE_NAME.append(defaultContainer), SessionCookieConfigService.class, undertowDeploymentInfoService.getDefaultSessionCookieConfig())\n                .addDependency(SecurityDomainService.SERVICE_NAME.append(securityDomain), SecurityDomainContext.class, undertowDeploymentInfoService.getSecurityDomainContextValue())\n                .addDependency(UndertowService.UNDERTOW, UndertowService.class, undertowDeploymentInfoService.getUndertowService())\n                .addDependency(ServiceBuilder.DependencyType.OPTIONAL, BufferCacheService.SERVICE_NAME.append(\"default\"), DirectBufferCache.class, undertowDeploymentInfoService.getBufferCacheInjectedValue())\n                .addDependencies(deploymentUnit.getAttachmentList(Attachments.WEB_DEPENDENCIES));\n\n        if (metaData.getDistributable() != null) {\n            SessionManagerFactoryBuilderService factoryBuilderService = new SessionManagerFactoryBuilderService();\n            SessionManagerFactoryBuilder factoryBuilder = factoryBuilderService.getValue();\n            if (factoryBuilder != null) {\n                ServiceName factoryName = deploymentServiceName.append(\"session\");\n                factoryBuilder.build(serviceTarget, factoryName, deploymentServiceName, module, metaData)\n                    .setInitialMode(Mode.ON_DEMAND)\n                    .install()\n                ;\n                infoBuilder.addDependency(factoryName, SessionManagerFactory.class, undertowDeploymentInfoService.getSessionManagerFactoryInjector());\n            } else {\n                UndertowLogger.ROOT_LOGGER.clusteringNotSupported();\n            }\n        }\n\n        infoBuilder.install();\n\n        final ServiceName hostServiceName = UndertowService.virtualHostName(defaultServer, hostName);\n        final UndertowDeploymentService service = new UndertowDeploymentService(injectionContainer);\n        final ServiceBuilder<UndertowDeploymentService> builder = serviceTarget.addService(deploymentServiceName, service)\n                .addDependencies(dependentComponents)\n                .addDependency(UndertowService.SERVLET_CONTAINER.append(defaultContainer), ServletContainerService.class, service.getContainer())\n                .addDependency(hostServiceName, Host.class, service.getHost())\n                .addDependencies(deploymentUnit.getAttachmentList(Attachments.WEB_DEPENDENCIES))\n                .addDependency(deploymentInfoServiceName, DeploymentInfo.class, service.getDeploymentInfoInjectedValue());\n\n        deploymentUnit.addToAttachmentList(Attachments.DEPLOYMENT_COMPLETE_SERVICES, deploymentServiceName);\n\n        // OSGi web applications are activated in {@link WebContextActivationProcessor} according to bundle lifecycle changes\n        if (deploymentUnit.hasAttachment(Attachments.OSGI_MANIFEST)) {\n            builder.setInitialMode(Mode.NEVER);\n            UndertowDeploymentService.ContextActivatorImpl activator = new UndertowDeploymentService.ContextActivatorImpl(builder.install());\n            deploymentUnit.putAttachment(ContextActivator.ATTACHMENT_KEY, activator);\n        } else {\n            builder.setInitialMode(Mode.ACTIVE);\n            builder.install();\n        }\n\n        // Process the web related mgmt information\n        final ModelNode node = deploymentUnit.getDeploymentSubsystemModel(UndertowExtension.SUBSYSTEM_NAME);\n        node.get(DeploymentDefinition.CONTEXT_ROOT.getName()).set(\"\".equals(pathName) ? \"/\" : pathName);\n        node.get(DeploymentDefinition.VIRTUAL_HOST.getName()).set(hostName);\n        processManagement(deploymentUnit, metaData);\n    }","commit_id":"589921c4d293894aeada98289b00f412043426cb","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n  public void handle(String s, HttpServletRequest request, HttpServletResponse response, int dispatch)\n    throws IOException, ServletException {\n\n    String[] roles = Constants.Security.BASIC_USER_ROLES;\n    String username = request.getUserPrincipal().getName();\n    Collection<String> userRoles = new ArrayList<String>();\n    for (String role: roles) {\n      if (request.isUserInRole(role)) {\n        userRoles.add(role);\n      }\n    }\n\n    long tokenValidity = cConf.getLong(Constants.Security.TOKEN_EXPIRATION,\n                                       Constants.Security.DEFAULT_TOKEN_EXPIRATION);\n    long issueTime = System.currentTimeMillis();\n    long expireTime = issueTime + tokenValidity;\n    // Create and sign a new AccessTokenIdentifier to generate the AccessToken.\n    AccessTokenIdentifier tokenIdentifier = new AccessTokenIdentifier(username, userRoles, issueTime, expireTime);\n    AccessToken token = tokenManager.signIdentifier(tokenIdentifier);\n\n    // Set response headers\n    response.setContentType(\"application/json;charset=UTF-8\");\n    response.addHeader(\"Cache-Control\", \"no-store\");\n    response.addHeader(\"Pragma\", \"no-cache\");\n\n    // Set response body\n    JsonObject json = new JsonObject();\n    byte[] encodedIdentifier = Base64.encodeBase64(tokenCodec.encode(token));\n    json.addProperty(ExternalAuthenticationServer.ResponseFields.ACCESS_TOKEN,\n                     new String(encodedIdentifier, Charsets.UTF_8));\n    json.addProperty(ExternalAuthenticationServer.ResponseFields.TOKEN_TYPE,\n                     ExternalAuthenticationServer.ResponseFields.TOKEN_TYPE_BODY);\n    json.addProperty(ExternalAuthenticationServer.ResponseFields.EXPIRES_IN, tokenValidity / 1000);\n\n    response.getOutputStream().print(json.toString());\n    response.setStatus(HttpServletResponse.SC_OK);\n    ((Request) request).setHandled(true);\n  }","id":60686,"modified_method":"@Override\n  public void handle(String s, HttpServletRequest request, HttpServletResponse response, int dispatch)\n    throws IOException, ServletException, NumberFormatException {\n\n    String[] roles = Constants.Security.BASIC_USER_ROLES;\n    String username = request.getUserPrincipal().getName();\n    Collection<String> userRoles = new ArrayList<String>();\n    for (String role: roles) {\n      if (request.isUserInRole(role)) {\n        userRoles.add(role);\n      }\n    }\n\n    long tokenValidity = Long.parseLong(cConf.get(Constants.Security.TOKEN_EXPIRATION));\n\n    long issueTime = System.currentTimeMillis();\n    long expireTime = issueTime + tokenValidity;\n    // Create and sign a new AccessTokenIdentifier to generate the AccessToken.\n    AccessTokenIdentifier tokenIdentifier = new AccessTokenIdentifier(username, userRoles, issueTime, expireTime);\n    AccessToken token = tokenManager.signIdentifier(tokenIdentifier);\n\n    // Set response headers\n    response.setContentType(\"application/json;charset=UTF-8\");\n    response.addHeader(\"Cache-Control\", \"no-store\");\n    response.addHeader(\"Pragma\", \"no-cache\");\n\n    // Set response body\n    JsonObject json = new JsonObject();\n    byte[] encodedIdentifier = Base64.encodeBase64(tokenCodec.encode(token));\n\n    json.addProperty(ExternalAuthenticationServer.ResponseFields.ACCESS_TOKEN,\n                     new String(encodedIdentifier, Charsets.UTF_8));\n    json.addProperty(ExternalAuthenticationServer.ResponseFields.TOKEN_TYPE,\n                     ExternalAuthenticationServer.ResponseFields.TOKEN_TYPE_BODY);\n    json.addProperty(ExternalAuthenticationServer.ResponseFields.EXPIRES_IN, tokenValidity / 1000);\n\n    response.getOutputStream().print(json.toString());\n    response.setStatus(HttpServletResponse.SC_OK);\n    ((Request) request).setHandled(true);\n  }","commit_id":"db2852a96d74869eed6582bcf1f344468011a0cb","url":"https://github.com/caskdata/cdap"},{"original_method":"private void openOutboundAndWrite(MessageEvent e) throws Exception {\n    final ChannelBuffer msg = (ChannelBuffer) e.getMessage();\n    msg.markReaderIndex();\n\n    // Suspend incoming traffic until connected to the outbound service.\n    final Channel inboundChannel = e.getChannel();\n    inboundChannel.setReadable(false);\n\n    // Discover endpoint.\n    int inboundPort = ((InetSocketAddress) inboundChannel.getLocalAddress()).getPort();\n    Discoverable discoverable = serviceLookup.getDiscoverable(inboundPort, new Supplier<HeaderDecoder.HeaderInfo>() {\n      @Override\n      public HeaderDecoder.HeaderInfo get() {\n        return HeaderDecoder.decodeHeader(msg);\n      }\n    });\n\n    if (discoverable == null) {\n      inboundChannel.close();\n      return;\n    }\n\n    // Connect to outbound service.\n    final InetSocketAddress address = discoverable.getSocketAddress();\n    LOG.trace(\"Opening connection from {} to {} for {}\",\n              inboundChannel.getLocalAddress(), address, inboundChannel.getRemoteAddress());\n    ChannelFuture outFuture = clientBootstrap.connect(address);\n\n    outboundChannel = outFuture.getChannel();\n    outFuture.addListener(new ChannelFutureListener() {\n      public void operationComplete(ChannelFuture future) throws Exception {\n        if (future.isSuccess()) {\n          outboundChannel.getPipeline().addLast(\"outbound-handler\", new OutboundHandler(inboundChannel));\n\n          // Connection attempt succeeded.\n\n          // Write the message to outBoundChannel.\n          msg.resetReaderIndex();\n          outboundChannel.write(msg);\n\n          // Begin to accept incoming traffic.\n          inboundChannel.setReadable(true);\n          LOG.trace(\"Connection opened from {} to {} for {}\",\n                    inboundChannel.getLocalAddress(), address, inboundChannel.getRemoteAddress());\n        } else {\n          // Close the connection if the connection attempt has failed.\n          inboundChannel.close();\n          LOG.trace(\"Failed to open connection from {} to {} for {}\",\n                    inboundChannel.getLocalAddress(), address, inboundChannel.getRemoteAddress(), future.getCause());\n        }\n      }\n    });\n  }","id":60687,"modified_method":"private void openOutboundAndWrite(MessageEvent e) throws Exception {\n    final HttpRequest msg = (HttpRequest) e.getMessage();\n\n    // Suspend incoming traffic until connected to the outbound service.\n    final Channel inboundChannel = e.getChannel();\n    inboundChannel.setReadable(false);\n\n    String auth = msg.getHeader(HttpHeaders.Names.AUTHORIZATION);\n    String path = msg.getUri();\n    String host = msg.getHeader(HttpHeaders.Names.HOST);\n    String httpMethod = msg.getMethod().getName();\n    String accessToken = null;\n\n    if (auth != null) {\n      int spIndex = auth.trim().indexOf(' ') + 1;\n      if (spIndex != -1) {\n        accessToken = auth.substring(spIndex).trim();\n      }\n    }\n    //Decoding the header\n    final HeaderInfo headerInfo = new HeaderInfo(path, host, httpMethod);\n\n    if (securityEnabled) {\n      TokenValidator.State tokenState = tokenValidator.validate(accessToken);\n      HttpResponse httpResponse = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.UNAUTHORIZED);\n      switch (tokenState) {\n        case TOKEN_MISSING:\n          httpResponse.addHeader(HttpHeaders.Names.WWW_AUTHENTICATE, \"Bearer realm=\\\"\" + realm + \"\\\"\");\n          httpResponse.setHeader(HttpHeaders.Names.CONTENT_LENGTH, 0);\n          break;\n\n        case TOKEN_INVALID:\n        case TOKEN_EXPIRED:\n        case TOKEN_INTERNAL:\n          httpResponse.addHeader(HttpHeaders.Names.WWW_AUTHENTICATE, \"Bearer realm=\\\"\" + realm + \"\\\"\" +\n            \"  error=\\\"invalid_token\\\"\" +\n            \"  error_description=\\\"\" + tokenState.getMsg() + \"\\\"\");\n          httpResponse.setHeader(HttpHeaders.Names.CONTENT_LENGTH, 0);\n          break;\n      }\n      if (tokenState != TokenValidator.State.TOKEN_VALID) {\n        inboundChannel.getPipeline().addLast(\"encoder\", new HttpResponseEncoder());\n        e.getChannel().write(httpResponse).addListener(ChannelFutureListener.CLOSE);\n        return;\n      }\n    }\n\n    // Discover endpoint.\n    int inboundPort = ((InetSocketAddress) inboundChannel.getLocalAddress()).getPort();\n    Discoverable discoverable = serviceLookup.getDiscoverable(inboundPort, new Supplier<HeaderInfo>() {\n      @Override\n      public HeaderInfo get() {\n        return headerInfo;\n      }\n    });\n\n    if (discoverable == null) {\n      inboundChannel.close();\n      return;\n    }\n\n    // Connect to outbound service.\n    final InetSocketAddress address = discoverable.getSocketAddress();\n    LOG.trace(\"Opening connection from {} to {} for {}\",\n              inboundChannel.getLocalAddress(), address, inboundChannel.getRemoteAddress());\n    ChannelFuture outFuture = clientBootstrap.connect(address);\n\n    outboundChannel = outFuture.getChannel();\n    outFuture.addListener(new ChannelFutureListener() {\n      public void operationComplete(ChannelFuture future) throws Exception {\n        if (future.isSuccess()) {\n\n          outboundChannel.getPipeline().addLast(\"outbound-handler\", new OutboundHandler(inboundChannel));\n\n          // the decoder is added after Outboundhandler in the pipeline as it is a downstream channel\n          outboundChannel.getPipeline().addLast(\"HttpRequestEncoder\", new HttpRequestEncoder());\n\n          // Write the message to outBoundChannel.\n          outboundChannel.write(msg);\n\n          // Begin to accept incoming traffic.\n          inboundChannel.setReadable(true);\n          LOG.trace(\"Connection opened from {} to {} for {}\",\n                    inboundChannel.getLocalAddress(), address, inboundChannel.getRemoteAddress());\n        } else {\n          // Close the connection if the connection attempt has failed.\n          inboundChannel.close();\n          LOG.trace(\"Failed to open connection from {} to {} for {}\",\n                    inboundChannel.getLocalAddress(), address, inboundChannel.getRemoteAddress(), future.getCause());\n        }\n      }\n    });\n  }","commit_id":"db2852a96d74869eed6582bcf1f344468011a0cb","url":"https://github.com/caskdata/cdap"},{"original_method":"public InboundHandler(ClientBootstrap clientBootstrap, final RouterServiceLookup serviceLookup) {\n    this.clientBootstrap = clientBootstrap;\n    this.serviceLookup = serviceLookup;\n  }","id":60688,"modified_method":"public InboundHandler(String realm, ClientBootstrap clientBootstrap, final RouterServiceLookup serviceLookup,\n                        TokenValidator tokenValidator, boolean securityEnabled) {\n    this.clientBootstrap = clientBootstrap;\n    this.serviceLookup = serviceLookup;\n    this.tokenValidator = tokenValidator;\n    this.securityEnabled = securityEnabled;\n    this.realm = realm;\n\n  }","commit_id":"db2852a96d74869eed6582bcf1f344468011a0cb","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n    if (outboundChannel == null) {\n      openOutboundAndWrite(e);\n      return;\n    }\n\n    ChannelBuffer msg = (ChannelBuffer) e.getMessage();\n    outboundChannel.write(msg);\n  }","id":60689,"modified_method":"@Override\n  public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n    if (outboundChannel == null) {\n      openOutboundAndWrite(e);\n      return;\n    }\n    outboundChannel.write(e.getMessage());\n  }","commit_id":"db2852a96d74869eed6582bcf1f344468011a0cb","url":"https://github.com/caskdata/cdap"},{"original_method":"private void bootstrapServer(final ChannelUpstreamHandler connectionTracker) {\n    ExecutorService serverBossExecutor = createExecutorService(serverBossThreadPoolSize,\n                                                               \"router-server-boss-thread-%d\");\n    ExecutorService serverWorkerExecutor = createExecutorService(serverWorkerThreadPoolSize,\n                                                                 \"router-server-worker-thread-%d\");\n    serverBootstrap = new ServerBootstrap(\n      new NioServerSocketChannelFactory(serverBossExecutor, serverWorkerExecutor));\n    serverBootstrap.setOption(\"backlog\", serverConnectionBacklog);\n    serverBootstrap.setOption(\"child.bufferFactory\", new DirectChannelBufferFactory());\n\n    // Setup the pipeline factory\n    serverBootstrap.setPipelineFactory(\n      new ChannelPipelineFactory() {\n        @Override\n        public ChannelPipeline getPipeline() throws Exception {\n          ChannelPipeline pipeline = Channels.pipeline();\n          pipeline.addLast(\"tracker\", connectionTracker);\n          pipeline.addLast(\"inbound-handler\",\n                           new InboundHandler(clientBootstrap, serviceLookup));\n          return pipeline;\n        }\n      }\n    );\n\n    InetAddress address = hostname;\n    if (address.isAnyLocalAddress()) {\n      try {\n        address = InetAddress.getLocalHost();\n      } catch (UnknownHostException e) {\n        throw Throwables.propagate(e);\n      }\n    }\n\n    // Start listening on ports.\n    ImmutableMap.Builder<Integer, String> serviceMapBuilder = ImmutableMap.builder();\n    for (String forward : forwards) {\n      int ind = forward.indexOf(':');\n      int port = Integer.parseInt(forward.substring(0, ind));\n      String service = forward.substring(ind + 1);\n\n      String boundService = serviceLookup.getService(port);\n      if (boundService != null) {\n        LOG.warn(\"Port {} is already configured to service {}, ignoring forward for service {}\",\n                 port, boundService, service);\n        continue;\n      }\n\n      InetSocketAddress bindAddress = new InetSocketAddress(address.getCanonicalHostName(), port);\n      LOG.info(\"Starting Netty Router for service {} on address {}...\", service, bindAddress);\n      Channel channel = serverBootstrap.bind(bindAddress);\n      InetSocketAddress boundAddress = (InetSocketAddress) channel.getLocalAddress();\n      serviceMapBuilder.put(boundAddress.getPort(), service);\n      channelGroup.add(channel);\n\n      // Update service map\n      serviceLookup.updateServiceMap(serviceMapBuilder.build());\n\n      LOG.info(\"Started Netty Router for service {} on address {}.\", service, boundAddress);\n    }\n  }","id":60690,"modified_method":"private void bootstrapServer(final ChannelUpstreamHandler connectionTracker) {\n    ExecutorService serverBossExecutor = createExecutorService(serverBossThreadPoolSize,\n                                                               \"router-server-boss-thread-%d\");\n    ExecutorService serverWorkerExecutor = createExecutorService(serverWorkerThreadPoolSize,\n                                                                 \"router-server-worker-thread-%d\");\n    serverBootstrap = new ServerBootstrap(\n      new NioServerSocketChannelFactory(serverBossExecutor, serverWorkerExecutor));\n    serverBootstrap.setOption(\"backlog\", serverConnectionBacklog);\n    serverBootstrap.setOption(\"child.bufferFactory\", new DirectChannelBufferFactory());\n\n    // Setup the pipeline factory\n    serverBootstrap.setPipelineFactory(\n      new ChannelPipelineFactory() {\n        @Override\n        public ChannelPipeline getPipeline() throws Exception {\n          ChannelPipeline pipeline = Channels.pipeline();\n          pipeline.addLast(\"tracker\", connectionTracker);\n          pipeline.addLast(\"HttpDecode\", new HttpRequestDecoder());\n          pipeline.addLast(\"inbound-handler\",\n                           new InboundHandler(realm, clientBootstrap, serviceLookup, tokenValidator, securityEnabled));\n          return pipeline;\n        }\n      }\n    );\n\n    InetAddress address = hostname;\n    if (address.isAnyLocalAddress()) {\n      try {\n        address = InetAddress.getLocalHost();\n      } catch (UnknownHostException e) {\n        throw Throwables.propagate(e);\n      }\n    }\n\n    // Start listening on ports.\n    ImmutableMap.Builder<Integer, String> serviceMapBuilder = ImmutableMap.builder();\n    for (String forward : forwards) {\n      int ind = forward.indexOf(':');\n      int port = Integer.parseInt(forward.substring(0, ind));\n      String service = forward.substring(ind + 1);\n\n      String boundService = serviceLookup.getService(port);\n      if (boundService != null) {\n        LOG.warn(\"Port {} is already configured to service {}, ignoring forward for service {}\",\n                 port, boundService, service);\n        continue;\n      }\n\n      InetSocketAddress bindAddress = new InetSocketAddress(address.getCanonicalHostName(), port);\n      LOG.info(\"Starting Netty Router for service {} on address {}...\", service, bindAddress);\n      Channel channel = serverBootstrap.bind(bindAddress);\n      InetSocketAddress boundAddress = (InetSocketAddress) channel.getLocalAddress();\n      serviceMapBuilder.put(boundAddress.getPort(), service);\n      channelGroup.add(channel);\n\n      // Update service map\n      serviceLookup.updateServiceMap(serviceMapBuilder.build());\n\n      LOG.info(\"Started Netty Router for service {} on address {}.\", service, boundAddress);\n    }\n  }","commit_id":"db2852a96d74869eed6582bcf1f344468011a0cb","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    protected void before() throws Throwable {\n      CConfiguration cConf = CConfiguration.create();\n      cConf.set(Constants.Router.ADDRESS, hostname);\n      cConf.setStrings(Constants.Router.FORWARD, forwards.toArray(new String[forwards.size()]));\n      router =\n        new NettyRouter(cConf, InetAddresses.forString(hostname),\n                        new RouterServiceLookup((DiscoveryServiceClient) discoveryService));\n      router.startAndWait();\n\n      for (Map.Entry<Integer, String> entry : router.getServiceLookup().getServiceMap().entrySet()) {\n        serviceMap.put(entry.getValue(), entry.getKey());\n      }\n    }","id":60691,"modified_method":"@Override\n    protected void before() throws Throwable {\n      CConfiguration cConf = CConfiguration.create();\n      cConf.set(Constants.Router.ADDRESS, hostname);\n      cConf.setStrings(Constants.Router.FORWARD, forwards.toArray(new String[forwards.size()]));\n      router =\n        new NettyRouter(cConf, InetAddresses.forString(hostname),\n                        new RouterServiceLookup((DiscoveryServiceClient) discoveryService),\n                        new TokenValidator() {\n                          @Override\n                          public State validate(String token) {\n                            return State.TOKEN_VALID;\n                          }\n                        });\n      router.startAndWait();\n\n      for (Map.Entry<Integer, String> entry : router.getServiceLookup().getServiceMap().entrySet()) {\n        serviceMap.put(entry.getValue(), entry.getKey());\n      }\n    }","commit_id":"db2852a96d74869eed6582bcf1f344468011a0cb","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Returns the discoverable mapped to the given port.\n   *\n   * @param port port to lookup.\n   * @param hostHeaderSupplier supplies the header information for the lookup.\n   * @return discoverable based on port and host header.\n   */\n  public Discoverable getDiscoverable(int port, Supplier<HeaderDecoder.HeaderInfo> hostHeaderSupplier)\n    throws Exception {\n    final String service = serviceMapRef.get().get(port);\n    if (service == null) {\n      LOG.debug(\"No service found for port {}\", port);\n      return null;\n    }\n\n    HeaderDecoder.HeaderInfo headerInfo = hostHeaderSupplier.get();\n    if (headerInfo == null) {\n      LOG.debug(\"Cannot find host header for service {} on port {}\", service, port);\n      return null;\n    }\n\n    try {\n      String path = headerInfo.getPath();\n      String method = headerInfo.getMethod();\n      String destService = RouterPathLookup.getRoutingPath(path, method);\n      CacheKey cacheKey;\n      if (destService != null) {\n        cacheKey = new CacheKey(destService, headerInfo);\n        LOG.trace(\"Request was routed from {} to: {}\", path, destService);\n      } else {\n        cacheKey = new CacheKey(service, headerInfo);\n        LOG.trace(\"Request was routed from {} to: {}\", path, service);\n      }\n      Discoverable discoverable = discoverableCache.get(cacheKey).pick();\n      if (discoverable == null) {\n        // Looks like the service is no longer running.\n        LOG.debug(\"Invalidating cache for service {} on port {}\", service, port);\n        discoverableCache.invalidate(cacheKey);\n      }\n      return discoverable;\n    } catch (ExecutionException e) {\n      return null;\n    }\n  }","id":60692,"modified_method":"/**\n     * Returns the discoverable mapped to the given port.\n     *\n     * @param port port to lookup.\n     * @param hostHeaderSupplier supplies the header information for the lookup.\n     * @return discoverable based on port and host header.\n     */\n  public Discoverable getDiscoverable(int port, Supplier<HeaderInfo> hostHeaderSupplier)\n    throws Exception {\n    final String service = serviceMapRef.get().get(port);\n    if (service == null) {\n      LOG.debug(\"No service found for port {}\", port);\n      return null;\n    }\n\n    HeaderInfo headerInfo = hostHeaderSupplier.get();\n    if (headerInfo == null) {\n      LOG.debug(\"Cannot find host header for service {} on port {}\", service, port);\n      return null;\n    }\n\n    try {\n      String path = headerInfo.getPath();\n      String method = headerInfo.getMethod();\n      String destService = RouterPathLookup.getRoutingPath(path, method);\n      CacheKey cacheKey;\n      if (destService != null) {\n        cacheKey = new CacheKey(destService, headerInfo);\n        LOG.trace(\"Request was routed from {} to: {}\", path, destService);\n      } else {\n        cacheKey = new CacheKey(service, headerInfo);\n        LOG.trace(\"Request was routed from {} to: {}\", path, service);\n      }\n      Discoverable discoverable = discoverableCache.get(cacheKey).pick();\n      if (discoverable == null) {\n        // Looks like the service is no longer running.\n        LOG.debug(\"Invalidating cache for service {} on port {}\", service, port);\n        discoverableCache.invalidate(cacheKey);\n      }\n      return discoverable;\n    } catch (ExecutionException e) {\n      return null;\n    }\n  }","commit_id":"db2852a96d74869eed6582bcf1f344468011a0cb","url":"https://github.com/caskdata/cdap"},{"original_method":"private CacheKey(String service, HeaderDecoder.HeaderInfo headerInfo) {\n      this.service = service;\n      this.hostHeaader = headerInfo.getHost();\n\n      String path = headerInfo.getPath().replaceAll(\"/+\", \"/\");\n      int ind = path.indexOf('/', 1);\n      this.firstPathPart = ind == -1 ? path : path.substring(0, ind);\n    }","id":60693,"modified_method":"private CacheKey(String service, HeaderInfo headerInfo) {\n      this.service = service;\n      this.hostHeaader = headerInfo.getHost();\n\n      String path = headerInfo.getPath().replaceAll(\"/+\", \"/\");\n      int ind = path.indexOf('/', 1);\n      this.firstPathPart = ind == -1 ? path : path.substring(0, ind);\n    }","commit_id":"db2852a96d74869eed6582bcf1f344468011a0cb","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected final void configure() {\n    bind(new TypeLiteral<Codec<AccessToken>>() { }).to(AccessTokenCodec.class).in(Scopes.SINGLETON);\n    bind(new TypeLiteral<Codec<AccessTokenIdentifier>>() { }).to(AccessTokenIdentifierCodec.class).in(Scopes.SINGLETON);\n    bind(new TypeLiteral<Codec<KeyIdentifier>>() { }).to(KeyIdentifierCodec.class).in(Scopes.SINGLETON);\n\n    bindKeyManager(binder());\n    bind(TokenManager.class).in(Scopes.SINGLETON);\n\n    bind(ExternalAuthenticationServer.class).in(Scopes.SINGLETON);\n\n    Multibinder<Handler> handlerBinder = Multibinder.newSetBinder(binder(), Handler.class,\n                                                                  Names.named(\"security.handlers.set\"));\n    handlerBinder.addBinding().to(BasicAuthenticationHandler.class);\n    handlerBinder.addBinding().to(GrantAccessTokenHandler.class);\n    bind(HandlerList.class).annotatedWith(Names.named(\"security.handlers\"))\n                           .toProvider(HandlerListProvider.class)\n                           .in(Scopes.SINGLETON);\n\n    expose(TokenManager.class);\n    expose(ExternalAuthenticationServer.class);\n  }","id":60694,"modified_method":"@Override\n  protected final void configure() {\n    bind(new TypeLiteral<Codec<AccessToken>>() { }).to(AccessTokenCodec.class).in(Scopes.SINGLETON);\n    bind(new TypeLiteral<Codec<AccessTokenIdentifier>>() { }).to(AccessTokenIdentifierCodec.class).in(Scopes.SINGLETON);\n    bind(new TypeLiteral<Codec<KeyIdentifier>>() { }).to(KeyIdentifierCodec.class).in(Scopes.SINGLETON);\n\n    bindKeyManager(binder());\n    bind(TokenManager.class).in(Scopes.SINGLETON);\n\n    bind(ExternalAuthenticationServer.class).in(Scopes.SINGLETON);\n\n    Multibinder<Handler> handlerBinder = Multibinder.newSetBinder(binder(), Handler.class,\n                                                                  Names.named(\"security.handlers.set\"));\n    handlerBinder.addBinding().to(BasicAuthenticationHandler.class);\n    handlerBinder.addBinding().to(GrantAccessTokenHandler.class);\n    bind(HandlerList.class).annotatedWith(Names.named(\"security.handlers\"))\n                           .toProvider(HandlerListProvider.class)\n                           .in(Scopes.SINGLETON);\n\n    expose(TokenManager.class);\n\n    bind(TokenValidator.class).to(AccessTokenValidator.class);\n    expose(TokenValidator.class);\n    expose(ExternalAuthenticationServer.class);\n  }","commit_id":"db2852a96d74869eed6582bcf1f344468011a0cb","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Test an authorized request to server.\n   * @throws Exception\n   */\n  @Test\n  public void testValidAuthentication() throws Exception {\n    server.startAndWait();\n    HttpClient client = new DefaultHttpClient();\n    String uri = String.format(\"http://localhost:%d/\", port);\n    HttpGet request = new HttpGet(uri);\n    request.addHeader(\"Authorization\", \"Basic YWRtaW46cmVhbHRpbWU=\");\n    HttpResponse response = client.execute(request);\n\n    assertTrue(response.getStatusLine().getStatusCode() == 200);\n\n    // Test correct headers being returned\n    String cacheControlHeader = response.getFirstHeader(\"Cache-Control\").getValue();\n    String pragmaHeader = response.getFirstHeader(\"Pragma\").getValue();\n    String contentType = response.getFirstHeader(\"Content-Type\").getValue();\n\n    assertTrue((cacheControlHeader.equals(\"no-store\")));\n    assertTrue((pragmaHeader.equals(\"no-cache\")));\n    assertTrue((contentType.equals(\"application/json;charset=UTF-8\")));\n\n    // Test correct response body\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n    ByteStreams.copy(response.getEntity().getContent(), bos);\n    String responseBody = bos.toString(\"UTF-8\");\n    bos.close();\n\n    JsonParser parser = new JsonParser();\n    JsonObject responseJson = (JsonObject) parser.parse(responseBody);\n    String tokenType = responseJson.get(ExternalAuthenticationServer.ResponseFields.TOKEN_TYPE).toString();\n    int expiration = responseJson.get(ExternalAuthenticationServer.ResponseFields.EXPIRES_IN).getAsInt();\n\n    assertTrue(tokenType.equals(String.format(\"\\\"%s\\\"\", ExternalAuthenticationServer.ResponseFields.TOKEN_TYPE_BODY)));\n\n    long expectedExpiration =  configuration.getInt(Constants.Security.TOKEN_EXPIRATION,\n                                                    Constants.Security.DEFAULT_TOKEN_EXPIRATION);\n    // Test expiration time in seconds\n    assertTrue(expiration == expectedExpiration / 1000);\n\n    // Test that the server passes back an AccessToken object which can be decoded correctly.\n    String encodedToken = responseJson.get(ExternalAuthenticationServer.ResponseFields.ACCESS_TOKEN).getAsString();\n    AccessToken token = tokenCodec.decode(Base64.decodeBase64(encodedToken));\n    LOG.info(\"AccessToken got from ExternalAuthenticationServer is: \" + Bytes.toStringBinary(tokenCodec.encode(token)));\n\n    server.stopAndWait();\n  }","id":60695,"modified_method":"/**\n   * Test an authorized request to server.\n   * @throws Exception\n   */\n  @Test\n  public void testValidAuthentication() throws Exception {\n    server.startAndWait();\n    HttpClient client = new DefaultHttpClient();\n    String uri = String.format(\"http://localhost:%d/\", port);\n    HttpGet request = new HttpGet(uri);\n    request.addHeader(\"Authorization\", \"Basic YWRtaW46cmVhbHRpbWU=\");\n    HttpResponse response = client.execute(request);\n\n    assertTrue(response.getStatusLine().getStatusCode() == 200);\n\n    // Test correct headers being returned\n    String cacheControlHeader = response.getFirstHeader(\"Cache-Control\").getValue();\n    String pragmaHeader = response.getFirstHeader(\"Pragma\").getValue();\n    String contentType = response.getFirstHeader(\"Content-Type\").getValue();\n\n    assertTrue((cacheControlHeader.equals(\"no-store\")));\n    assertTrue((pragmaHeader.equals(\"no-cache\")));\n    assertTrue((contentType.equals(\"application/json;charset=UTF-8\")));\n\n    // Test correct response body\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n    ByteStreams.copy(response.getEntity().getContent(), bos);\n    String responseBody = bos.toString(\"UTF-8\");\n    bos.close();\n\n    JsonParser parser = new JsonParser();\n    JsonObject responseJson = (JsonObject) parser.parse(responseBody);\n    String tokenType = responseJson.get(ExternalAuthenticationServer.ResponseFields.TOKEN_TYPE).toString();\n    int expiration = responseJson.get(ExternalAuthenticationServer.ResponseFields.EXPIRES_IN).getAsInt();\n\n    assertTrue(tokenType.equals(String.format(\"\\\"%s\\\"\", ExternalAuthenticationServer.ResponseFields.TOKEN_TYPE_BODY)));\n\n    long expectedExpiration = Long.parseLong(configuration.get(Constants.Security.TOKEN_EXPIRATION));\n\n    // Test expiration time in seconds\n    assertTrue(expiration == expectedExpiration / 1000);\n\n    // Test that the server passes back an AccessToken object which can be decoded correctly.\n    String encodedToken = responseJson.get(ExternalAuthenticationServer.ResponseFields.ACCESS_TOKEN).getAsString();\n    AccessToken token = tokenCodec.decode(Base64.decodeBase64(encodedToken));\n    LOG.info(\"AccessToken got from ExternalAuthenticationServer is: \" + Bytes.toStringBinary(tokenCodec.encode(token)));\n\n    server.stopAndWait();\n  }","commit_id":"db2852a96d74869eed6582bcf1f344468011a0cb","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testCommands() throws Exception {\n    CLIConfig cliConfig = new CLIConfig(\"localhost\");\n    CLIMain cliMain = new CLIMain(cliConfig);\n    CLI cli = cliMain.getCLI();\n\n    testCommandOutputContains(cli, \"connect fakehost\", \"could not be reached\");\n    testCommandOutputContains(cli, \"connect localhost\", \"Successfully connected\");\n    testCommandOutputContains(cli, \"connect http://localhost\", \"Successfully connected\");\n    testCommandOutputContains(cli, \"connect http://localhost:10000\", \"Successfully connected\");\n\n    testCommandOutputNotContains(cli, \"list apps\", FakeApp.NAME);\n\n    File appJarFile = createAppJarFile(FakeApp.class);\n    testCommandOutputContains(cli, \"deploy app \" + appJarFile.getAbsolutePath(), \"Successfully deployed app\");\n    if (!appJarFile.delete()) {\n      LOG.warn(\"Failed to delete temporary app jar file: {}\", appJarFile.getAbsolutePath());\n    }\n\n    testCommandOutputContains(cli, \"list apps\", FakeApp.NAME);\n    testCommandOutputContains(cli, \"list dataset instances\", FakeApp.DS_NAME);\n    testCommandOutputContains(cli, \"list streams\", FakeApp.STREAM_NAME);\n    testCommandOutputContains(cli, \"list flows\", FakeApp.FLOWS.get(0));\n\n    // test program-related commands\n    String flowId = FakeApp.FLOWS.get(0);\n    String qualifiedFlowId = FakeApp.NAME + \".\" + flowId;\n    testCommandOutputContains(cli, \"start flow \" + qualifiedFlowId, \"Successfully started Flow\");\n    testCommandOutputContains(cli, \"stop flow \" + qualifiedFlowId, \"Successfully stopped Flow\");\n    ProgramClient programClient = new ProgramClient(cliConfig.getClientConfig());\n    assertProgramStatus(programClient, FakeApp.NAME, ProgramType.FLOW, flowId, \"STOPPED\");\n    testCommandOutputContains(cli, \"get flow status \" + qualifiedFlowId, \"STOPPED\");\n    testCommandOutputContains(cli, \"get flow history \" + qualifiedFlowId, \"STOPPED\");\n    testCommandOutputContains(cli, \"get flow live \" + qualifiedFlowId, flowId);\n\n    // test stream commands\n    String streamId = \"sdf123\";\n    testCommandOutputContains(cli, \"create stream \" + streamId, \"Successfully created stream\");\n    testCommandOutputContains(cli, \"list streams\", streamId);\n    testCommandOutputNotContains(cli, \"get stream \" + streamId, \"helloworld\");\n    testCommandOutputContains(cli, \"send stream \" + streamId + \" helloworld\", \"Successfully send stream event\");\n    testCommandOutputContains(cli, \"get stream \" + streamId, \"helloworld\");\n    testCommandOutputContains(cli, \"truncate stream \" + streamId, \"Successfully truncated stream\");\n    testCommandOutputNotContains(cli, \"get stream \" + streamId, \"helloworld\");\n    testCommandOutputContains(cli, \"set stream ttl \" + streamId + \" 123\", \"Successfully set TTL of stream\");\n    testCommandOutputContains(cli, \"describe stream \" + streamId, \"123\");\n\n    // test dataset commands\n    String datasetName = \"sdf123lkj\";\n    DatasetTypeClient datasetTypeClient = new DatasetTypeClient(cliConfig.getClientConfig());\n    DatasetTypeMeta datasetType = datasetTypeClient.list().get(0);\n    testCommandOutputContains(cli, \"create dataset instance \" + datasetType.getName() + \" \" + datasetName,\n                              \"Successfully created dataset\");\n    testCommandOutputContains(cli, \"truncate dataset instance \" + datasetName, \"Successfully truncated dataset\");\n    testCommandOutputContains(cli, \"delete dataset instance \" + datasetName, \"Successfully deleted dataset\");\n\n    // test procedure commands\n    String qualifiedProcedureId = String.format(\"%s.%s\", FakeApp.NAME, FakeProcedure.NAME);\n    testCommandOutputContains(cli, \"start procedure \" + qualifiedProcedureId, \"Successfully started Procedure\");\n    testCommandOutputContains(cli, \"call procedure \" + qualifiedProcedureId\n      + \" \" + FakeProcedure.METHOD_NAME + \" 'customer bob'\", \"realbob\");\n    testCommandOutputContains(cli, \"stop procedure \" + qualifiedProcedureId, \"Successfully stopped Procedure\");\n\n    // test spark commands\n    String sparkId = FakeApp.SPARK.get(0);\n    String qualifiedSparkId = FakeApp.NAME + \".\" + sparkId;\n    testCommandOutputContains(cli, \"list spark\", sparkId);\n    testCommandOutputContains(cli, \"start spark \" + qualifiedSparkId, \"Successfully started Spark\");\n    assertProgramStatus(programClient, FakeApp.NAME, ProgramType.SPARK, FakeSpark.NAME, \"STARTING\");\n    assertProgramStatus(programClient, FakeApp.NAME, ProgramType.SPARK, FakeSpark.NAME, \"RUNNING\", 180);\n    assertProgramStatus(programClient, FakeApp.NAME, ProgramType.SPARK, FakeSpark.NAME, \"STOPPED\", 180);\n    testCommandOutputContains(cli, \"get spark status \" + qualifiedSparkId, \"STOPPED\");\n    testCommandOutputContains(cli, \"get spark history \" + qualifiedSparkId, \"STOPPED\");\n    testCommandOutputContains(cli, \"get spark logs \" + qualifiedSparkId, \"HelloFakeSpark\");\n\n    // cleanup\n    testCommandOutputContains(cli, \"delete app \" + FakeApp.NAME, \"Successfully deleted app\");\n    testCommandOutputContains(cli, \"delete dataset instance \" + FakeApp.DS_NAME, \"Successfully deleted dataset\");\n  }","id":60696,"modified_method":"@Test\n  public void testCommands() throws Exception {\n    CLIConfig cliConfig = new CLIConfig(\"localhost\");\n    CLIMain cliMain = new CLIMain(cliConfig);\n    CLI cli = cliMain.getCLI();\n\n    testCommandOutputContains(cli, \"connect fakehost\", \"could not be reached\");\n    testCommandOutputContains(cli, \"connect localhost\", \"Successfully connected\");\n    testCommandOutputContains(cli, \"connect http://localhost\", \"Successfully connected\");\n    testCommandOutputContains(cli, \"connect http://localhost:10000\", \"Successfully connected\");\n\n    testCommandOutputNotContains(cli, \"list apps\", FakeApp.NAME);\n\n    File appJarFile = createAppJarFile(FakeApp.class);\n    testCommandOutputContains(cli, \"deploy app \" + appJarFile.getAbsolutePath(), \"Successfully deployed app\");\n    if (!appJarFile.delete()) {\n      LOG.warn(\"Failed to delete temporary app jar file: {}\", appJarFile.getAbsolutePath());\n    }\n\n    testCommandOutputContains(cli, \"list apps\", FakeApp.NAME);\n    testCommandOutputContains(cli, \"list dataset instances\", FakeApp.DS_NAME);\n    testCommandOutputContains(cli, \"list streams\", FakeApp.STREAM_NAME);\n    testCommandOutputContains(cli, \"list flows\", FakeApp.FLOWS.get(0));\n\n    // test program-related commands\n    String flowId = FakeApp.FLOWS.get(0);\n    String qualifiedFlowId = FakeApp.NAME + \".\" + flowId;\n    testCommandOutputContains(cli, \"start flow \" + qualifiedFlowId, \"Successfully started Flow\");\n    testCommandOutputContains(cli, \"stop flow \" + qualifiedFlowId, \"Successfully stopped Flow\");\n    ProgramClient programClient = new ProgramClient(cliConfig.getClientConfig());\n    assertProgramStatus(programClient, FakeApp.NAME, ProgramType.FLOW, flowId, \"STOPPED\");\n    testCommandOutputContains(cli, \"get flow status \" + qualifiedFlowId, \"STOPPED\");\n    testCommandOutputContains(cli, \"get flow history \" + qualifiedFlowId, \"STOPPED\");\n    testCommandOutputContains(cli, \"get flow live \" + qualifiedFlowId, flowId);\n\n    // test stream commands\n    String streamId = \"sdf123\";\n    testCommandOutputContains(cli, \"create stream \" + streamId, \"Successfully created stream\");\n    testCommandOutputContains(cli, \"list streams\", streamId);\n    testCommandOutputNotContains(cli, \"get stream \" + streamId, \"helloworld\");\n    testCommandOutputContains(cli, \"send stream \" + streamId + \" helloworld\", \"Successfully send stream event\");\n    testCommandOutputContains(cli, \"get stream \" + streamId, \"helloworld\");\n    testCommandOutputContains(cli, \"get stream \" + streamId + \" -10m -0s 1\", \"helloworld\");\n    testCommandOutputContains(cli, \"get stream \" + streamId + \" -10m -0s\", \"helloworld\");\n    testCommandOutputContains(cli, \"get stream \" + streamId + \" -10m\", \"helloworld\");\n    testCommandOutputContains(cli, \"truncate stream \" + streamId, \"Successfully truncated stream\");\n    testCommandOutputNotContains(cli, \"get stream \" + streamId, \"helloworld\");\n    testCommandOutputContains(cli, \"set stream ttl \" + streamId + \" 123\", \"Successfully set TTL of stream\");\n    testCommandOutputContains(cli, \"describe stream \" + streamId, \"123\");\n\n    // test dataset commands\n    String datasetName = \"sdf123lkj\";\n    DatasetTypeClient datasetTypeClient = new DatasetTypeClient(cliConfig.getClientConfig());\n    DatasetTypeMeta datasetType = datasetTypeClient.list().get(0);\n    testCommandOutputContains(cli, \"create dataset instance \" + datasetType.getName() + \" \" + datasetName,\n                              \"Successfully created dataset\");\n    testCommandOutputContains(cli, \"truncate dataset instance \" + datasetName, \"Successfully truncated dataset\");\n    testCommandOutputContains(cli, \"delete dataset instance \" + datasetName, \"Successfully deleted dataset\");\n\n    // test procedure commands\n    String qualifiedProcedureId = String.format(\"%s.%s\", FakeApp.NAME, FakeProcedure.NAME);\n    testCommandOutputContains(cli, \"start procedure \" + qualifiedProcedureId, \"Successfully started Procedure\");\n    testCommandOutputContains(cli, \"call procedure \" + qualifiedProcedureId\n      + \" \" + FakeProcedure.METHOD_NAME + \" 'customer bob'\", \"realbob\");\n    testCommandOutputContains(cli, \"stop procedure \" + qualifiedProcedureId, \"Successfully stopped Procedure\");\n\n    // test spark commands\n    String sparkId = FakeApp.SPARK.get(0);\n    String qualifiedSparkId = FakeApp.NAME + \".\" + sparkId;\n    testCommandOutputContains(cli, \"list spark\", sparkId);\n    testCommandOutputContains(cli, \"start spark \" + qualifiedSparkId, \"Successfully started Spark\");\n    assertProgramStatus(programClient, FakeApp.NAME, ProgramType.SPARK, FakeSpark.NAME, \"STARTING\");\n    assertProgramStatus(programClient, FakeApp.NAME, ProgramType.SPARK, FakeSpark.NAME, \"RUNNING\", 180);\n    assertProgramStatus(programClient, FakeApp.NAME, ProgramType.SPARK, FakeSpark.NAME, \"STOPPED\", 180);\n    testCommandOutputContains(cli, \"get spark status \" + qualifiedSparkId, \"STOPPED\");\n    testCommandOutputContains(cli, \"get spark history \" + qualifiedSparkId, \"STOPPED\");\n    testCommandOutputContains(cli, \"get spark logs \" + qualifiedSparkId, \"HelloFakeSpark\");\n\n    // cleanup\n    testCommandOutputContains(cli, \"delete app \" + FakeApp.NAME, \"Successfully deleted app\");\n    testCommandOutputContains(cli, \"delete dataset instance \" + FakeApp.DS_NAME, \"Successfully deleted dataset\");\n  }","commit_id":"2755229b941e0dd960031a3933ffebc252394a11","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void execute(Arguments arguments, PrintStream output) throws Exception {\n    String streamId = arguments.get(ArgumentName.STREAM.toString());\n    long startTime = arguments.getLong(ArgumentName.START_TIME.toString(), 0L);\n    long endTime = arguments.getLong(ArgumentName.END_TIME.toString(), Long.MAX_VALUE);\n    int limit = arguments.getInt(ArgumentName.LIMIT.toString(), Integer.MAX_VALUE);\n\n    // Get a list of stream events and prints it.\n    List<StreamEvent> events = streamClient.getEvents(streamId, startTime, endTime,\n                                                      limit, Lists.<StreamEvent>newArrayList());\n    new AsciiTable<StreamEvent>(\n      new String[] { \"timestamp\", \"headers\", \"body size\", \"body\"},\n      events,\n      new RowMaker<StreamEvent>() {\n        @Override\n        public Object[] makeRow(StreamEvent event) {\n          long bodySize = event.getBody().remaining();\n\n          return new Object[] {\n            event.getTimestamp(),\n            event.getHeaders().isEmpty() ? \"\" : formatHeader(event.getHeaders()),\n            bodySize,\n            getBody(event.getBody())\n          };\n        }\n      }\n    ).print(output);\n  }","id":60697,"modified_method":"@Override\n  public void execute(Arguments arguments, PrintStream output) throws Exception {\n    long currentTime = System.currentTimeMillis();\n\n    String streamId = arguments.get(ArgumentName.STREAM.toString());\n    long startTime = getTimestamp(arguments.get(ArgumentName.START_TIME.toString(), \"min\"), currentTime);\n    long endTime = getTimestamp(arguments.get(ArgumentName.END_TIME.toString(), \"max\"), currentTime);\n    int limit = arguments.getInt(ArgumentName.LIMIT.toString(), Integer.MAX_VALUE);\n\n    // Get a list of stream events and prints it.\n    List<StreamEvent> events = streamClient.getEvents(streamId, startTime, endTime,\n                                                      limit, Lists.<StreamEvent>newArrayList());\n    new AsciiTable<StreamEvent>(\n      new String[] { \"timestamp\", \"headers\", \"body size\", \"body\"},\n      events,\n      new RowMaker<StreamEvent>() {\n        @Override\n        public Object[] makeRow(StreamEvent event) {\n          long bodySize = event.getBody().remaining();\n\n          return new Object[] {\n            event.getTimestamp(),\n            event.getHeaders().isEmpty() ? \"\" : formatHeader(event.getHeaders()),\n            bodySize,\n            getBody(event.getBody())\n          };\n        }\n      }\n    ).print(output);\n  }","commit_id":"2755229b941e0dd960031a3933ffebc252394a11","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Returns a timestamp in milliseconds.\n   *\n   * @param arg The string argument user provided.\n   * @param base The base timestamp to relative from if the time format provided is a relative time.\n   * @return Timestamp in milliseconds\n   * @throws CommandInputError if failed to parse input.\n   */\n  private long getTimestamp(String arg, long base) {\n    try {\n      if (arg.startsWith(\"+\") || arg.startsWith(\"-\")) {\n        int dir = arg.startsWith(\"+\") ? 1 : -1;\n        char type = arg.charAt(arg.length() - 1);\n        int offset = Integer.parseInt(arg.substring(1, arg.length() - 1));\n        switch (type) {\n          case 's':\n            return base + dir * TimeUnit.SECONDS.toMillis(offset);\n          case 'm':\n            return base + dir * TimeUnit.MINUTES.toMillis(offset);\n          case 'h':\n            return base + dir * TimeUnit.HOURS.toMillis(offset);\n          case 'd':\n            return base + dir * TimeUnit.DAYS.toMillis(offset);\n          default:\n            throw new CommandInputError(\"Unsupported time type \" + type);\n        }\n      }\n      if (arg.equalsIgnoreCase(\"min\")) {\n        return 0L;\n      }\n      if (arg.equalsIgnoreCase(\"max\")) {\n        return Long.MAX_VALUE;\n      }\n\n      return Long.parseLong(arg);\n    } catch (NumberFormatException e) {\n      throw new CommandInputError(\"Invalid number value: \" + arg + \". Reason: \" + e.getMessage());\n    }\n  }","id":60698,"modified_method":"/**\n   * Returns a timestamp in milliseconds.\n   *\n   * @param arg The string argument user provided.\n   * @param base The base timestamp to relative from if the time format provided is a relative time.\n   * @return Timestamp in milliseconds\n   * @throws CommandInputError if failed to parse input.\n   */\n  private long getTimestamp(String arg, long base) {\n    try {\n      if (arg.startsWith(\"+\") || arg.startsWith(\"-\")) {\n        int dir = arg.startsWith(\"+\") ? 1 : -1;\n        char type = arg.charAt(arg.length() - 1);\n        int offset = Integer.parseInt(arg.substring(1, arg.length() - 1));\n        switch (type) {\n          case 's':\n            return base + dir * TimeUnit.SECONDS.toMillis(offset);\n          case 'm':\n            return base + dir * TimeUnit.MINUTES.toMillis(offset);\n          case 'h':\n            return base + dir * TimeUnit.HOURS.toMillis(offset);\n          case 'd':\n            return base + dir * TimeUnit.DAYS.toMillis(offset);\n          default:\n            throw new CommandInputError(\"Unsupported relative time format: \" + type);\n        }\n      }\n      if (arg.equalsIgnoreCase(\"min\")) {\n        return 0L;\n      }\n      if (arg.equalsIgnoreCase(\"max\")) {\n        return Long.MAX_VALUE;\n      }\n\n      return Long.parseLong(arg);\n    } catch (NumberFormatException e) {\n      throw new CommandInputError(\"Invalid number value: \" + arg + \". Reason: \" + e.getMessage());\n    }\n  }","commit_id":"2755229b941e0dd960031a3933ffebc252394a11","url":"https://github.com/caskdata/cdap"},{"original_method":"public void append(LogWriteEvent event) throws IOException {\n      try {\n        dataFileWriter.append(event.getGenericRecord());\n        lastModifiedTs = System.currentTimeMillis();\n      } catch (Exception e) {\n        close();\n        throw new IOException(\"Exception while appending to file \" + location, e);\n      }\n    }","id":60699,"modified_method":"public void append(LogWriteEvent event) throws IOException {\n      try {\n        dataFileWriter.append(event.getGenericRecord());\n      } catch (Exception e) {\n        close();\n        throw new IOException(\"Exception while appending to file \" + location, e);\n      }\n    }","commit_id":"fd858d538ded18c9ef049faacea102b060edd9cb","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Constructs an AvroFileWriter object.\n   * @param fileMetaDataManager used to store file meta data.\n   * @param namespacedLocationFactory the namespaced location factory\n   * @param logBaseDir the basedirectory for logs as defined in configuration\n   * @param schema schema of the Avro data to be written.\n   * @param maxFileSize Avro files greater than maxFileSize will get rotated.\n   * @param syncIntervalBytes the approximate number of uncompressed bytes to write in each block.\n   * @param inactiveIntervalMs files that have no data written for more than inactiveIntervalMs will be closed.\n   */\n  public AvroFileWriter(FileMetaDataManager fileMetaDataManager, NamespacedLocationFactory namespacedLocationFactory,\n                        String logBaseDir, Schema schema, long maxFileSize, int syncIntervalBytes,\n                        long inactiveIntervalMs, Impersonator impersonator) {\n    this.fileMetaDataManager = fileMetaDataManager;\n    this.namespacedLocationFactory = namespacedLocationFactory;\n    this.logBaseDir = logBaseDir;\n    this.schema = schema;\n    this.syncIntervalBytes = syncIntervalBytes;\n    this.fileMap = Maps.newHashMap();\n    this.maxFileSize = maxFileSize;\n    this.inactiveIntervalMs = inactiveIntervalMs;\n    this.impersonator = impersonator;\n  }","id":60700,"modified_method":"/**\n   * Constructs an AvroFileWriter object.\n   * @param fileMetaDataManager used to store file meta data.\n   * @param namespacedLocationFactory the namespaced location factory\n   * @param logBaseDir the basedirectory for logs as defined in configuration\n   * @param schema schema of the Avro data to be written.\n   * @param maxFileSize Avro files greater than maxFileSize will get rotated.\n   * @param syncIntervalBytes the approximate number of uncompressed bytes to write in each block.\n   * @param maxFileLifetimeMs files that are older than maxFileLifetimeMs will be closed.\n   */\n  public AvroFileWriter(FileMetaDataManager fileMetaDataManager, NamespacedLocationFactory namespacedLocationFactory,\n                        String logBaseDir, Schema schema, long maxFileSize, int syncIntervalBytes,\n                        long maxFileLifetimeMs, Impersonator impersonator) {\n    this.fileMetaDataManager = fileMetaDataManager;\n    this.namespacedLocationFactory = namespacedLocationFactory;\n    this.logBaseDir = logBaseDir;\n    this.schema = schema;\n    this.syncIntervalBytes = syncIntervalBytes;\n    this.fileMap = Maps.newHashMap();\n    this.maxFileSize = maxFileSize;\n    this.maxFileLifetimeMs = maxFileLifetimeMs;\n    this.impersonator = impersonator;\n  }","commit_id":"fd858d538ded18c9ef049faacea102b060edd9cb","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Opens the underlying file for writing.\n     * If open throws an exception then underlying file may still need to be deleted.\n     *\n     * @throws IOException\n     */\n    void open() throws IOException {\n      try {\n        this.outputStream = new FSDataOutputStream(location.getOutputStream(), null);\n        this.dataFileWriter = new DataFileWriter<>(new GenericDatumWriter<GenericRecord>(schema));\n        this.dataFileWriter.create(schema, this.outputStream);\n        this.dataFileWriter.setSyncInterval(syncIntervalBytes);\n        this.lastModifiedTs = System.currentTimeMillis();\n      } catch (Exception e) {\n        close();\n        throw new IOException(\"Exception while creating file \" + location, e);\n      }\n      this.isOpen = true;\n    }","id":60701,"modified_method":"/**\n     * Opens the underlying file for writing.\n     * If open throws an exception then underlying file may still need to be deleted.\n     *\n     * @throws IOException\n     */\n    void open() throws IOException {\n      try {\n        this.outputStream = new FSDataOutputStream(location.getOutputStream(), null);\n        this.dataFileWriter = new DataFileWriter<>(new GenericDatumWriter<GenericRecord>(schema));\n        this.dataFileWriter.create(schema, this.outputStream);\n        this.dataFileWriter.setSyncInterval(syncIntervalBytes);\n        this.createTime = System.currentTimeMillis();\n      } catch (Exception e) {\n        close();\n        throw new IOException(\"Exception while creating file \" + location, e);\n      }\n      this.isOpen = true;\n    }","commit_id":"fd858d538ded18c9ef049faacea102b060edd9cb","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void flush() throws IOException {\n    long currentTs = System.currentTimeMillis();\n\n    for (Iterator<Map.Entry<String, AvroFile>> it = fileMap.entrySet().iterator(); it.hasNext();) {\n      AvroFile avroFile = it.next().getValue();\n      // TODO: refactor fileMap into a class so that all these checks (and creation of files) can move there CDAP-6475\n      if (!avroFile.isOpen()) {\n        // If the file is already closed (due to an exception),\n        // then remove it from the map so that a new one gets created later\n        it.remove();\n      } else {\n        avroFile.sync();\n\n        // Close inactive files\n        if (currentTs - avroFile.getLastModifiedTs() > inactiveIntervalMs) {\n          avroFile.close();\n          it.remove();\n        }\n      }\n    }\n  }","id":60702,"modified_method":"@Override\n  public void flush() throws IOException {\n    long currentTs = System.currentTimeMillis();\n\n    for (Iterator<Map.Entry<String, AvroFile>> it = fileMap.entrySet().iterator(); it.hasNext();) {\n      AvroFile avroFile = it.next().getValue();\n      // TODO: refactor fileMap into a class so that all these checks (and creation of files) can move there CDAP-6475\n      if (!avroFile.isOpen()) {\n        // If the file is already closed (due to an exception),\n        // then remove it from the map so that a new one gets created later\n        it.remove();\n      } else {\n        avroFile.sync();\n\n        // Close old files\n        long timeSinceFileCreate = currentTs - avroFile.getCreateTime();\n        if (timeSinceFileCreate > maxFileLifetimeMs) {\n          avroFile.close();\n          it.remove();\n        }\n      }\n    }\n  }","commit_id":"fd858d538ded18c9ef049faacea102b060edd9cb","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void append(List<KafkaLogEvent> events) throws Exception {\n    if (events.isEmpty()) {\n      return;\n    }\n\n    KafkaLogEvent event = events.get(0);\n    int partition = event.getPartition();\n    Checkpoint maxCheckpoint = partitionCheckpointMap.get(partition);\n    maxCheckpoint = maxCheckpoint == null ? new Checkpoint(-1, -1) : maxCheckpoint;\n\n    for (KafkaLogEvent e : events) {\n      if (e.getNextOffset() > maxCheckpoint.getNextOffset()) {\n        maxCheckpoint = new Checkpoint(e.getNextOffset(), e.getLogEvent().getTimeStamp());\n      }\n    }\n\n    partitionCheckpointMap.put(partition, maxCheckpoint);\n\n    avroFileWriter.append(events);\n    flush(false);\n  }","id":60703,"modified_method":"@Override\n  public void append(List<KafkaLogEvent> events) throws Exception {\n    if (events.isEmpty()) {\n      return;\n    }\n\n    KafkaLogEvent event = events.get(0);\n    int partition = event.getPartition();\n    Checkpoint maxCheckpoint = partitionCheckpointMap.get(partition);\n    maxCheckpoint = maxCheckpoint == null ? new Checkpoint(-1, -1) : maxCheckpoint;\n\n    for (KafkaLogEvent e : events) {\n      if (e.getNextOffset() > maxCheckpoint.getNextOffset()) {\n        maxCheckpoint = new Checkpoint(e.getNextOffset(), e.getLogEvent().getTimeStamp());\n      }\n    }\n\n    partitionCheckpointMap.put(partition, maxCheckpoint);\n\n    avroFileWriter.append(events);\n  }","commit_id":"fd858d538ded18c9ef049faacea102b060edd9cb","url":"https://github.com/caskdata/cdap"},{"original_method":"private void flush(boolean force) throws Exception {\n    long currentTs = System.currentTimeMillis();\n    if (!force && currentTs - lastCheckpointTime < flushIntervalMs) {\n      return;\n    }\n\n    avroFileWriter.flush();\n\n    // Save the max checkpoint seen for each partition\n    checkpointManager.saveCheckpoint(partitionCheckpointMap);\n    lastCheckpointTime = currentTs;\n  }","id":60704,"modified_method":"@Override\n  public void flush(boolean force) throws IOException {\n    try {\n      long currentTs = System.currentTimeMillis();\n      if (!force && currentTs - lastCheckpointTime < flushIntervalMs) {\n        return;\n      }\n\n      avroFileWriter.flush();\n\n      // Save the max checkpoint seen for each partition\n      checkpointManager.saveCheckpoint(partitionCheckpointMap);\n      lastCheckpointTime = currentTs;\n    } catch (Exception e) {\n      LOG.error(\"Got exception: \", e);\n      throw new IOException(e);\n    }\n  }","commit_id":"fd858d538ded18c9ef049faacea102b060edd9cb","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void flush() throws IOException {\n    try {\n      flush(true);\n    } catch (Exception e) {\n      LOG.error(\"Got exception: \", e);\n      throw new IOException(e);\n    }\n  }","id":60705,"modified_method":"@Override\n  public void flush() throws IOException {\n    flush(true);\n  }","commit_id":"fd858d538ded18c9ef049faacea102b060edd9cb","url":"https://github.com/caskdata/cdap"},{"original_method":"@Inject\n  public FileLogAppender(CConfiguration cConfig,\n                         DatasetFramework dsFramework,\n                         TransactionExecutorFactory txExecutorFactory,\n                         NamespacedLocationFactory namespacedLocationFactory,\n                         RootLocationFactory rootLocationFactory, Impersonator impersonator) {\n    setName(APPENDER_NAME);\n    this.cConf = cConfig;\n    this.tableUtil = new LogSaverTableUtil(dsFramework, cConfig);\n    this.txExecutorFactory = txExecutorFactory;\n    this.namespacedLocationFactory = namespacedLocationFactory;\n    this.rootLocationFactory = rootLocationFactory;\n    this.impersonator = impersonator;\n\n    this.logBaseDir = cConfig.get(LoggingConfiguration.LOG_BASE_DIR);\n    Preconditions.checkNotNull(logBaseDir, \"Log base dir cannot be null\");\n\n    // Sync interval should be around 10 times smaller than file size as we use sync points to navigate\n    this.syncIntervalBytes = cConfig.getInt(LoggingConfiguration.LOG_FILE_SYNC_INTERVAL_BYTES, 2 * 1024 * 1024);\n    Preconditions.checkArgument(this.syncIntervalBytes > 0,\n                                \"Log file sync interval is invalid: %s\", this.syncIntervalBytes);\n\n    long retentionDurationDays = cConfig.getLong(LoggingConfiguration.LOG_RETENTION_DURATION_DAYS, -1);\n    Preconditions.checkArgument(retentionDurationDays > 0,\n                                \"Log file retention duration is invalid: %s\", retentionDurationDays);\n    this.retentionDurationMs = TimeUnit.MILLISECONDS.convert(retentionDurationDays, TimeUnit.DAYS);\n\n    maxLogFileSizeBytes = cConfig.getLong(LoggingConfiguration.LOG_MAX_FILE_SIZE_BYTES, 20 * 1024 * 1024);\n    Preconditions.checkArgument(maxLogFileSizeBytes > 0,\n                                \"Max log file size is invalid: %s\", maxLogFileSizeBytes);\n\n    inactiveIntervalMs = cConfig.getLong(LoggingConfiguration.LOG_SAVER_INACTIVE_FILE_INTERVAL_MS,\n                                              LoggingConfiguration.DEFAULT_LOG_SAVER_INACTIVE_FILE_INTERVAL_MS);\n    Preconditions.checkArgument(inactiveIntervalMs > 0,\n                                \"Inactive interval is invalid: %s\", inactiveIntervalMs);\n\n    checkpointIntervalMs = cConfig.getLong(LoggingConfiguration.LOG_SAVER_CHECKPOINT_INTERVAL_MS,\n                                                LoggingConfiguration.DEFAULT_LOG_SAVER_CHECKPOINT_INTERVAL_MS);\n    Preconditions.checkArgument(checkpointIntervalMs > 0,\n                                \"Checkpoint interval is invalid: %s\", checkpointIntervalMs);\n\n    logCleanupIntervalMins = cConfig.getInt(LoggingConfiguration.LOG_CLEANUP_RUN_INTERVAL_MINS,\n                                            LoggingConfiguration.DEFAULT_LOG_CLEANUP_RUN_INTERVAL_MINS);\n    Preconditions.checkArgument(logCleanupIntervalMins > 0,\n                                \"Log cleanup run interval is invalid: %s\", logCleanupIntervalMins);\n\n    this.scheduledExecutor =\n      MoreExecutors.listeningDecorator(Executors.newSingleThreadScheduledExecutor(\n        Threads.createDaemonThreadFactory(\"file-log-appender\")));\n  }","id":60706,"modified_method":"@Inject\n  public FileLogAppender(CConfiguration cConfig,\n                         DatasetFramework dsFramework,\n                         TransactionExecutorFactory txExecutorFactory,\n                         NamespacedLocationFactory namespacedLocationFactory,\n                         RootLocationFactory rootLocationFactory, Impersonator impersonator) {\n    setName(APPENDER_NAME);\n    this.cConf = cConfig;\n    this.tableUtil = new LogSaverTableUtil(dsFramework, cConfig);\n    this.txExecutorFactory = txExecutorFactory;\n    this.namespacedLocationFactory = namespacedLocationFactory;\n    this.rootLocationFactory = rootLocationFactory;\n    this.impersonator = impersonator;\n\n    this.logBaseDir = cConfig.get(LoggingConfiguration.LOG_BASE_DIR);\n    Preconditions.checkNotNull(logBaseDir, \"Log base dir cannot be null\");\n\n    // Sync interval should be around 10 times smaller than file size as we use sync points to navigate\n    this.syncIntervalBytes = cConfig.getInt(LoggingConfiguration.LOG_FILE_SYNC_INTERVAL_BYTES, 2 * 1024 * 1024);\n    Preconditions.checkArgument(this.syncIntervalBytes > 0,\n                                \"Log file sync interval is invalid: %s\", this.syncIntervalBytes);\n\n    long retentionDurationDays = cConfig.getLong(LoggingConfiguration.LOG_RETENTION_DURATION_DAYS, -1);\n    Preconditions.checkArgument(retentionDurationDays > 0,\n                                \"Log file retention duration is invalid: %s\", retentionDurationDays);\n    this.retentionDurationMs = TimeUnit.MILLISECONDS.convert(retentionDurationDays, TimeUnit.DAYS);\n\n    maxLogFileSizeBytes = cConfig.getLong(LoggingConfiguration.LOG_MAX_FILE_SIZE_BYTES, 20 * 1024 * 1024);\n    Preconditions.checkArgument(maxLogFileSizeBytes > 0,\n                                \"Max log file size is invalid: %s\", maxLogFileSizeBytes);\n\n    maxFileLifetimeMs = cConfig.getLong(LoggingConfiguration.LOG_SAVER_MAX_FILE_LIFETIME,\n                                        LoggingConfiguration.DEFAULT_LOG_SAVER_MAX_FILE_LIFETIME_MS);\n    Preconditions.checkArgument(maxFileLifetimeMs > 0,\n                                \"Max file lifetime is invalid: %s\", maxFileLifetimeMs);\n\n    if (cConf.get(LoggingConfiguration.LOG_SAVER_INACTIVE_FILE_INTERVAL_MS) != null) {\n      LOG.warn(\"Parameter '{}' is no longer supported. Instead, use '{}'.\",\n               LoggingConfiguration.LOG_SAVER_INACTIVE_FILE_INTERVAL_MS,\n               LoggingConfiguration.LOG_SAVER_MAX_FILE_LIFETIME);\n    }\n\n    checkpointIntervalMs = cConfig.getLong(LoggingConfiguration.LOG_SAVER_CHECKPOINT_INTERVAL_MS,\n                                                LoggingConfiguration.DEFAULT_LOG_SAVER_CHECKPOINT_INTERVAL_MS);\n    Preconditions.checkArgument(checkpointIntervalMs > 0,\n                                \"Checkpoint interval is invalid: %s\", checkpointIntervalMs);\n\n    logCleanupIntervalMins = cConfig.getInt(LoggingConfiguration.LOG_CLEANUP_RUN_INTERVAL_MINS,\n                                            LoggingConfiguration.DEFAULT_LOG_CLEANUP_RUN_INTERVAL_MINS);\n    Preconditions.checkArgument(logCleanupIntervalMins > 0,\n                                \"Log cleanup run interval is invalid: %s\", logCleanupIntervalMins);\n\n    this.scheduledExecutor =\n      MoreExecutors.listeningDecorator(Executors.newSingleThreadScheduledExecutor(\n        Threads.createDaemonThreadFactory(\"file-log-appender\")));\n  }","commit_id":"fd858d538ded18c9ef049faacea102b060edd9cb","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void start() {\n    super.start();\n    try {\n      logSchema = new LogSchema().getAvroSchema();\n      FileMetaDataManager fileMetaDataManager = new FileMetaDataManager(tableUtil, txExecutorFactory,\n                                                                        rootLocationFactory, namespacedLocationFactory,\n                                                                        cConf, impersonator);\n\n      AvroFileWriter avroFileWriter = new AvroFileWriter(fileMetaDataManager, namespacedLocationFactory, logBaseDir,\n                                                         logSchema, maxLogFileSizeBytes, syncIntervalBytes,\n                                                         inactiveIntervalMs, impersonator);\n      logFileWriter = new SimpleLogFileWriter(avroFileWriter, checkpointIntervalMs);\n\n      LogCleanup logCleanup = new LogCleanup(fileMetaDataManager, rootLocationFactory, retentionDurationMs,\n                                             impersonator);\n      scheduledExecutor.scheduleAtFixedRate(logCleanup, 10,\n                                            logCleanupIntervalMins, TimeUnit.MINUTES);\n    } catch (Exception e) {\n      close();\n      throw Throwables.propagate(e);\n    }\n  }","id":60707,"modified_method":"@Override\n  public void start() {\n    super.start();\n    try {\n      logSchema = new LogSchema().getAvroSchema();\n      FileMetaDataManager fileMetaDataManager = new FileMetaDataManager(tableUtil, txExecutorFactory,\n                                                                        rootLocationFactory, namespacedLocationFactory,\n                                                                        cConf, impersonator);\n\n      AvroFileWriter avroFileWriter = new AvroFileWriter(fileMetaDataManager, namespacedLocationFactory, logBaseDir,\n                                                         logSchema, maxLogFileSizeBytes, syncIntervalBytes,\n                                                         maxFileLifetimeMs, impersonator);\n      logFileWriter = new SimpleLogFileWriter(avroFileWriter, checkpointIntervalMs);\n\n      LogCleanup logCleanup = new LogCleanup(fileMetaDataManager, rootLocationFactory, retentionDurationMs,\n                                             impersonator);\n      scheduledExecutor.scheduleAtFixedRate(logCleanup, 10,\n                                            logCleanupIntervalMins, TimeUnit.MINUTES);\n    } catch (Exception e) {\n      close();\n      throw Throwables.propagate(e);\n    }\n  }","commit_id":"fd858d538ded18c9ef049faacea102b060edd9cb","url":"https://github.com/caskdata/cdap"},{"original_method":"@Inject\n  KafkaLogWriterPlugin(CConfiguration cConf, FileMetaDataManager fileMetaDataManager,\n                       CheckpointManagerFactory checkpointManagerFactory, RootLocationFactory rootLocationFactory,\n                       NamespacedLocationFactory namespacedLocationFactory, Impersonator impersonator)\n    throws Exception {\n\n    this.serializer = new LoggingEventSerializer();\n    this.messageTable = TreeBasedTable.create();\n\n    this.logBaseDir = cConf.get(LoggingConfiguration.LOG_BASE_DIR);\n    Preconditions.checkNotNull(this.logBaseDir, \"Log base dir cannot be null\");\n    LOG.debug(String.format(\"Log base dir is %s\", this.logBaseDir));\n\n    long retentionDurationDays = cConf.getLong(LoggingConfiguration.LOG_RETENTION_DURATION_DAYS,\n                                                 LoggingConfiguration.DEFAULT_LOG_RETENTION_DURATION_DAYS);\n    Preconditions.checkArgument(retentionDurationDays > 0,\n                                \"Log file retention duration is invalid: %s\", retentionDurationDays);\n\n    // Keep max file size a little less than the default HDFS block size (128 MB)\n    long maxLogFileSizeBytes = cConf.getLong(LoggingConfiguration.LOG_MAX_FILE_SIZE_BYTES, 100 * 1000 * 1000);\n    Preconditions.checkArgument(maxLogFileSizeBytes > 0,\n                                \"Max log file size is invalid: %s\", maxLogFileSizeBytes);\n\n    // Sync interval should be around 10 times smaller than file size as we use sync points to navigate\n    int syncIntervalBytes = cConf.getInt(LoggingConfiguration.LOG_FILE_SYNC_INTERVAL_BYTES, 10 * 1000 * 1000);\n    Preconditions.checkArgument(syncIntervalBytes > 0,\n                                \"Log file sync interval is invalid: %s\", syncIntervalBytes);\n\n    long checkpointIntervalMs = cConf.getLong(LoggingConfiguration.LOG_SAVER_CHECKPOINT_INTERVAL_MS,\n                                                LoggingConfiguration.DEFAULT_LOG_SAVER_CHECKPOINT_INTERVAL_MS);\n    Preconditions.checkArgument(checkpointIntervalMs > 0,\n                                \"Checkpoint interval is invalid: %s\", checkpointIntervalMs);\n\n    long inactiveIntervalMs = cConf.getLong(LoggingConfiguration.LOG_SAVER_INACTIVE_FILE_INTERVAL_MS,\n                                              LoggingConfiguration.DEFAULT_LOG_SAVER_INACTIVE_FILE_INTERVAL_MS);\n    Preconditions.checkArgument(inactiveIntervalMs > 0,\n                                \"Inactive interval is invalid: %s\", inactiveIntervalMs);\n\n    this.eventBucketIntervalMs = cConf.getLong(LoggingConfiguration.LOG_SAVER_EVENT_BUCKET_INTERVAL_MS,\n                                                 LoggingConfiguration.DEFAULT_LOG_SAVER_EVENT_BUCKET_INTERVAL_MS);\n    Preconditions.checkArgument(this.eventBucketIntervalMs > 0,\n                                \"Event bucket interval is invalid: %s\", this.eventBucketIntervalMs);\n\n    this.maxNumberOfBucketsInTable = cConf.getLong\n      (LoggingConfiguration.LOG_SAVER_MAXIMUM_INMEMORY_EVENT_BUCKETS,\n       LoggingConfiguration.DEFAULT_LOG_SAVER_MAXIMUM_INMEMORY_EVENT_BUCKETS);\n    Preconditions.checkArgument(this.maxNumberOfBucketsInTable > 0,\n                                \"Maximum number of event buckets in memory is invalid: %s\",\n                                this.maxNumberOfBucketsInTable);\n\n    long topicCreationSleepMs = cConf.getLong(LoggingConfiguration.LOG_SAVER_TOPIC_WAIT_SLEEP_MS,\n                                                LoggingConfiguration.DEFAULT_LOG_SAVER_TOPIC_WAIT_SLEEP_MS);\n    Preconditions.checkArgument(topicCreationSleepMs > 0,\n                                \"Topic creation wait sleep is invalid: %s\", topicCreationSleepMs);\n\n    logCleanupIntervalMins = cConf.getInt(LoggingConfiguration.LOG_CLEANUP_RUN_INTERVAL_MINS,\n                                            LoggingConfiguration.DEFAULT_LOG_CLEANUP_RUN_INTERVAL_MINS);\n    Preconditions.checkArgument(logCleanupIntervalMins > 0,\n                                \"Log cleanup run interval is invalid: %s\", logCleanupIntervalMins);\n\n    AvroFileWriter avroFileWriter = new AvroFileWriter(fileMetaDataManager, namespacedLocationFactory, logBaseDir,\n                                                       serializer.getAvroSchema(), maxLogFileSizeBytes,\n                                                       syncIntervalBytes, inactiveIntervalMs, impersonator);\n\n    checkpointManager = checkpointManagerFactory.create(cConf.get(Constants.Logging.KAFKA_TOPIC),\n                                                        CHECKPOINT_ROW_KEY_PREFIX);\n\n    this.logFileWriter = new CheckpointingLogFileWriter(avroFileWriter, checkpointManager, checkpointIntervalMs);\n    long retentionDurationMs = TimeUnit.MILLISECONDS.convert(retentionDurationDays, TimeUnit.DAYS);\n    this.logCleanup = new LogCleanup(fileMetaDataManager, rootLocationFactory, retentionDurationMs, impersonator);\n  }","id":60708,"modified_method":"@Inject\n  KafkaLogWriterPlugin(CConfiguration cConf, FileMetaDataManager fileMetaDataManager,\n                       CheckpointManagerFactory checkpointManagerFactory, RootLocationFactory rootLocationFactory,\n                       NamespacedLocationFactory namespacedLocationFactory, Impersonator impersonator)\n    throws Exception {\n\n    this.serializer = new LoggingEventSerializer();\n    this.messageTable = TreeBasedTable.create();\n\n    this.logBaseDir = cConf.get(LoggingConfiguration.LOG_BASE_DIR);\n    Preconditions.checkNotNull(this.logBaseDir, \"Log base dir cannot be null\");\n    LOG.debug(String.format(\"Log base dir is %s\", this.logBaseDir));\n\n    long retentionDurationDays = cConf.getLong(LoggingConfiguration.LOG_RETENTION_DURATION_DAYS,\n                                                 LoggingConfiguration.DEFAULT_LOG_RETENTION_DURATION_DAYS);\n    Preconditions.checkArgument(retentionDurationDays > 0,\n                                \"Log file retention duration is invalid: %s\", retentionDurationDays);\n\n    // Keep max file size a little less than the default HDFS block size (128 MB)\n    long maxLogFileSizeBytes = cConf.getLong(LoggingConfiguration.LOG_MAX_FILE_SIZE_BYTES, 100 * 1000 * 1000);\n    Preconditions.checkArgument(maxLogFileSizeBytes > 0,\n                                \"Max log file size is invalid: %s\", maxLogFileSizeBytes);\n\n    // Sync interval should be around 10 times smaller than file size as we use sync points to navigate\n    int syncIntervalBytes = cConf.getInt(LoggingConfiguration.LOG_FILE_SYNC_INTERVAL_BYTES, 10 * 1000 * 1000);\n    Preconditions.checkArgument(syncIntervalBytes > 0,\n                                \"Log file sync interval is invalid: %s\", syncIntervalBytes);\n\n    long checkpointIntervalMs = cConf.getLong(LoggingConfiguration.LOG_SAVER_CHECKPOINT_INTERVAL_MS,\n                                                LoggingConfiguration.DEFAULT_LOG_SAVER_CHECKPOINT_INTERVAL_MS);\n    Preconditions.checkArgument(checkpointIntervalMs > 0,\n                                \"Checkpoint interval is invalid: %s\", checkpointIntervalMs);\n\n    long maxFileLifetimeMs = cConf.getLong(LoggingConfiguration.LOG_SAVER_MAX_FILE_LIFETIME,\n                                           LoggingConfiguration.DEFAULT_LOG_SAVER_MAX_FILE_LIFETIME_MS);\n    Preconditions.checkArgument(maxFileLifetimeMs > 0,\n                                \"Max file lifetime is invalid: %s\", maxFileLifetimeMs);\n\n    if (cConf.get(LoggingConfiguration.LOG_SAVER_INACTIVE_FILE_INTERVAL_MS) != null) {\n      LOG.warn(\"Parameter '{}' is no longer supported. Instead, use '{}'.\",\n               LoggingConfiguration.LOG_SAVER_INACTIVE_FILE_INTERVAL_MS,\n               LoggingConfiguration.LOG_SAVER_MAX_FILE_LIFETIME);\n    }\n\n    this.eventBucketIntervalMs = cConf.getLong(LoggingConfiguration.LOG_SAVER_EVENT_BUCKET_INTERVAL_MS,\n                                                 LoggingConfiguration.DEFAULT_LOG_SAVER_EVENT_BUCKET_INTERVAL_MS);\n    Preconditions.checkArgument(this.eventBucketIntervalMs > 0,\n                                \"Event bucket interval is invalid: %s\", this.eventBucketIntervalMs);\n\n    this.maxNumberOfBucketsInTable = cConf.getLong\n      (LoggingConfiguration.LOG_SAVER_MAXIMUM_INMEMORY_EVENT_BUCKETS,\n       LoggingConfiguration.DEFAULT_LOG_SAVER_MAXIMUM_INMEMORY_EVENT_BUCKETS);\n    Preconditions.checkArgument(this.maxNumberOfBucketsInTable > 0,\n                                \"Maximum number of event buckets in memory is invalid: %s\",\n                                this.maxNumberOfBucketsInTable);\n\n    long topicCreationSleepMs = cConf.getLong(LoggingConfiguration.LOG_SAVER_TOPIC_WAIT_SLEEP_MS,\n                                                LoggingConfiguration.DEFAULT_LOG_SAVER_TOPIC_WAIT_SLEEP_MS);\n    Preconditions.checkArgument(topicCreationSleepMs > 0,\n                                \"Topic creation wait sleep is invalid: %s\", topicCreationSleepMs);\n\n    logCleanupIntervalMins = cConf.getInt(LoggingConfiguration.LOG_CLEANUP_RUN_INTERVAL_MINS,\n                                          LoggingConfiguration.DEFAULT_LOG_CLEANUP_RUN_INTERVAL_MINS);\n    Preconditions.checkArgument(logCleanupIntervalMins > 0,\n                                \"Log cleanup run interval is invalid: %s\", logCleanupIntervalMins);\n\n    AvroFileWriter avroFileWriter = new AvroFileWriter(fileMetaDataManager, namespacedLocationFactory, logBaseDir,\n                                                       serializer.getAvroSchema(), maxLogFileSizeBytes,\n                                                       syncIntervalBytes, maxFileLifetimeMs, impersonator);\n\n    checkpointManager = checkpointManagerFactory.create(cConf.get(Constants.Logging.KAFKA_TOPIC),\n                                                        CHECKPOINT_ROW_KEY_PREFIX);\n\n    this.logFileWriter = new CheckpointingLogFileWriter(avroFileWriter, checkpointManager, checkpointIntervalMs);\n    long retentionDurationMs = TimeUnit.MILLISECONDS.convert(retentionDurationDays, TimeUnit.DAYS);\n    this.logCleanup = new LogCleanup(fileMetaDataManager, rootLocationFactory, retentionDurationMs, impersonator);\n  }","commit_id":"fd858d538ded18c9ef049faacea102b060edd9cb","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void run() {\n    while (true) {\n      try {\n        // Read new messages only if previous write was successful.\n        if (writeListMap.isEmpty()) {\n          int messages = 0;\n\n          // The newest event that we can write to disk\n          // We try to buffer events up to (eventBucketIntervalMs * maxNumberOfBucketsInTable) time\n          // so that we collect almost all events for a time bucket before we sort it.\n          long limitKey = (System.currentTimeMillis() / eventBucketIntervalMs) - maxNumberOfBucketsInTable;\n          synchronized (messageTable) {\n            SortedSet<Long> rowKeySet = messageTable.rowKeySet();\n            if (!rowKeySet.isEmpty()) {\n              int numBuckets = rowKeySet.size();\n              long oldestBucketKey = rowKeySet.first();\n\n              Map<String, Entry<Long, List<KafkaLogEvent>>> row = messageTable.row(oldestBucketKey);\n              for (Iterator<Map.Entry<String, Entry<Long, List<KafkaLogEvent>>>> it = row.entrySet().iterator();\n                   it.hasNext(); ) {\n                Map.Entry<String, Entry<Long, List<KafkaLogEvent>>> mapEntry = it.next();\n                // Stop if event arrival time is more than the limit (this is for events being generated now)\n                // However, if we have reached maxNumberOfBucketsInTable then it means we are reading old\n                // events and we can write as soon as we fill up maxNumberOfBucketsInTable\n                if (numBuckets < maxNumberOfBucketsInTable &&\n                  limitKey < mapEntry.getValue().getKey()) {\n                  break;\n                }\n                writeListMap.putAll(mapEntry.getKey(), mapEntry.getValue().getValue());\n                messages += mapEntry.getValue().getValue().size();\n                it.remove();\n              }\n            }\n          }\n\n          LOG.trace(\"Got {} log messages to save\", messages);\n        }\n\n        long sleepTimeNanos = writeListMap.isEmpty() ? SLEEP_TIME_NS : 1;\n\n        // Wait for more data to arrive if writeListMap is empty, otherwise check if stopped\n        if (stopLatch.await(sleepTimeNanos, TimeUnit.NANOSECONDS)) {\n          // if count down occurred return\n          LOG.debug(\"Returning since stop latch is cancelled\");\n          return;\n        } else {\n          LOG.trace(\"Waiting for events, sleeping for {} ns\", sleepTimeNanos);\n        }\n\n        for (Iterator<Entry<String, Collection<KafkaLogEvent>>> it = writeListMap.asMap().entrySet().iterator();\n             it.hasNext(); ) {\n          Entry<String, Collection<KafkaLogEvent>> mapEntry = it.next();\n          List<KafkaLogEvent> list = (List<KafkaLogEvent>) mapEntry.getValue();\n          Collections.sort(list);\n          logFileWriter.append(list);\n          // Remove successfully written message\n          it.remove();\n        }\n\n        // Reset backoff after a successful save\n        exponentialBackoff.reset();\n      } catch (Throwable e) {\n        LOG.error(\"Caught exception during save, will try again with backoff.\", e);\n        try {\n          exponentialBackoff.backoff();\n        } catch (InterruptedException e1) {\n          // Okay to ignore since we'll check stop latch in the next run, and exit if stopped\n        }\n      }\n    }\n  }","id":60709,"modified_method":"@Override\n  public void run() {\n    while (true) {\n      try {\n        // Read new messages only if previous write was successful.\n        if (writeListMap.isEmpty()) {\n          int messages = 0;\n\n          // The newest event that we can write to disk\n          // We try to buffer events up to (eventBucketIntervalMs * maxNumberOfBucketsInTable) time\n          // so that we collect almost all events for a time bucket before we sort it.\n          long limitKey = (System.currentTimeMillis() / eventBucketIntervalMs) - maxNumberOfBucketsInTable;\n          synchronized (messageTable) {\n            SortedSet<Long> rowKeySet = messageTable.rowKeySet();\n            if (!rowKeySet.isEmpty()) {\n              int numBuckets = rowKeySet.size();\n              long oldestBucketKey = rowKeySet.first();\n\n              Map<String, Entry<Long, List<KafkaLogEvent>>> row = messageTable.row(oldestBucketKey);\n              for (Iterator<Map.Entry<String, Entry<Long, List<KafkaLogEvent>>>> it = row.entrySet().iterator();\n                   it.hasNext(); ) {\n                Map.Entry<String, Entry<Long, List<KafkaLogEvent>>> mapEntry = it.next();\n                // Stop if event arrival time is more than the limit (this is for events being generated now)\n                // However, if we have reached maxNumberOfBucketsInTable then it means we are reading old\n                // events and we can write as soon as we fill up maxNumberOfBucketsInTable\n                if (numBuckets < maxNumberOfBucketsInTable &&\n                  limitKey < mapEntry.getValue().getKey()) {\n                  break;\n                }\n                writeListMap.putAll(mapEntry.getKey(), mapEntry.getValue().getValue());\n                messages += mapEntry.getValue().getValue().size();\n                it.remove();\n              }\n            }\n          }\n\n          LOG.trace(\"Got {} log messages to save\", messages);\n        }\n\n        long sleepTimeNanos = writeListMap.isEmpty() ? SLEEP_TIME_NS : 1;\n\n        // Wait for more data to arrive if writeListMap is empty, otherwise check if stopped\n        if (stopLatch.await(sleepTimeNanos, TimeUnit.NANOSECONDS)) {\n          // if count down occurred return\n          LOG.debug(\"Returning since stop latch is cancelled\");\n          return;\n        } else {\n          LOG.trace(\"Waiting for events, sleeping for {} ns\", sleepTimeNanos);\n        }\n\n        for (Iterator<Entry<String, Collection<KafkaLogEvent>>> it = writeListMap.asMap().entrySet().iterator();\n             it.hasNext(); ) {\n          Entry<String, Collection<KafkaLogEvent>> mapEntry = it.next();\n          List<KafkaLogEvent> list = (List<KafkaLogEvent>) mapEntry.getValue();\n          Collections.sort(list);\n          logFileWriter.append(list);\n          // Remove successfully written message\n          it.remove();\n        }\n\n        logFileWriter.flush(false);\n\n        // Reset backoff after a successful save\n        exponentialBackoff.reset();\n      } catch (Throwable e) {\n        LOG.error(\"Caught exception during save, will try again with backoff.\", e);\n        try {\n          exponentialBackoff.backoff();\n        } catch (InterruptedException e1) {\n          // Okay to ignore since we'll check stop latch in the next run, and exit if stopped\n        }\n      }\n    }\n  }","commit_id":"fd858d538ded18c9ef049faacea102b060edd9cb","url":"https://github.com/caskdata/cdap"},{"original_method":"private void flush(boolean force) throws Exception {\n    long currentTs = System.currentTimeMillis();\n    if (!force && currentTs - lastCheckpointTime < flushIntervalMs) {\n      return;\n    }\n\n    avroFileWriter.flush();\n    lastCheckpointTime = currentTs;\n  }","id":60710,"modified_method":"public void flush(boolean force) throws IOException {\n    try {\n      long currentTs = System.currentTimeMillis();\n      if (!force && currentTs - lastCheckpointTime < flushIntervalMs) {\n        return;\n      }\n\n      avroFileWriter.flush();\n      lastCheckpointTime = currentTs;\n    } catch (Exception e) {\n      LOG.error(\"Got exception: \", e);\n      throw new IOException(e);\n    }\n  }","commit_id":"fd858d538ded18c9ef049faacea102b060edd9cb","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void flush() throws IOException {\n    try {\n      flush(true);\n    } catch (Exception e) {\n      LOG.error(\"Got exception: \", e);\n      throw new IOException(e);\n    }\n  }","id":60711,"modified_method":"@Override\n  public void flush() throws IOException {\n    flush(true);\n  }","commit_id":"fd858d538ded18c9ef049faacea102b060edd9cb","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * <p>\n     * This is a method implementation for the <tt>URLStreamHandlerFactory<\/tt>\n     * interface. It simply creates a stream handler proxy object for the\n     * specified protocol. It caches the returned proxy; therefore, subsequent\n     * requests for the same protocol will receive the same handler proxy.\n     * <\/p>\n     * @param protocol the protocol for which a stream handler should be returned.\n     * @return a stream handler proxy for the specified protocol.\n    **/\n    public URLStreamHandler createURLStreamHandler(String protocol)\n    {\n        // See if there is a cached stream handler.\n        // IMPLEMENTATION NOTE: Caching is not strictly necessary for\n        // stream handlers since the Java runtime caches them. Caching is\n        // performed for code consistency between stream and content\n        // handlers and also because caching behavior may not be guaranteed\n        // across different JRE implementations.\n        URLStreamHandler handler = getFromStreamCache(protocol);\n        \n        if (handler != null)\n        {\n            return handler;\n        }\n        // If this is the framework's \"bundle:\" protocol, then return\n        // a handler for that immediately, since no one else can be\n        // allowed to deal with it.\n        if (protocol.equals(FelixConstants.BUNDLE_URL_PROTOCOL))\n        {\n            return addToStreamCache(protocol, \n                new URLHandlersBundleStreamHandler(m_secureAction));\n        }\n    \n        // If this is the framework's \"felix:\" extension protocol, then\n        // return the ExtensionManager.m_extensionManager handler for \n        // that immediately - this is a workaround for certain jvms that\n        // do a toString() on the extension url we add to the global\n        // URLClassloader.\n        if (protocol.equals(\"felix\"))\n        {\n            return addToStreamCache(protocol, new URLStreamHandler()\n            {\n                protected URLConnection openConnection(URL url)\n                    throws IOException\n                {\n                    Object framework = getFrameworkFromContext();\n                    \n                    try\n                    {\n                        Object handler =  m_secureAction.getDeclaredField(\n                            framework.getClass(),\"m_extensionManager\", framework);\n\n                        return (URLConnection) m_secureAction.invoke(\n                            m_secureAction.getMethod(handler.getClass(), \n                            \"openConnection\", new Class[]{URL.class}), handler, \n                            new Object[]{url});\n                    }\n                    catch (Exception ex)\n                    {\n                        throw new IOException(ex.getMessage());\n                    }\n                }\n            });\n        }\n\n        if (!OVERRIDE)\n        {\n            // If there was a custom factory then try to get the handler form it\n            if (m_streamHandlerFactory != this)\n            {\n                handler = \n                    addToStreamCache(protocol, m_streamHandlerFactory.createURLStreamHandler(protocol));\n    \n                if (handler != null)\n                {\n                    return handler;\n                }\n            }\n            // Check for built-in handlers for the protocol.\n            String pkgs = m_secureAction.getSystemProperty(STREAM_HANDLER_PACKAGE_PROP, \"\");\n            pkgs = (pkgs.equals(\"\"))\n                ? DEFAULT_STREAM_HANDLER_PACKAGE\n                : pkgs + \"|\" + DEFAULT_STREAM_HANDLER_PACKAGE;\n    \n            // Iterate over built-in packages.\n            StringTokenizer pkgTok = new StringTokenizer(pkgs, \"| \");\n            while (pkgTok.hasMoreTokens())\n            {\n                String pkg = pkgTok.nextToken().trim();\n                String className = pkg + \".\" + protocol + \".Handler\";\n                try\n                {\n                    // If a built-in handler is found then let the\n                    // JRE handle it.\n                    if (m_secureAction.forName(className) != null)\n                    {\n                        return null;\n                    }\n                }\n                catch (Exception ex)\n                {\n                    // This could be a class not found exception or an\n                    // instantiation exception, not much we can do in either\n                    // case other than ignore it.\n                }\n            }\n        }\n        // If built-in content handler, then create a proxy handler.\n        return addToStreamCache(protocol, new URLHandlersStreamHandlerProxy(protocol, m_secureAction, \n            (m_streamHandlerFactory != this) ? m_streamHandlerFactory : null, OVERRIDE));\n    }","id":60712,"modified_method":"/**\n     * <p>\n     * This is a method implementation for the <tt>URLStreamHandlerFactory<\/tt>\n     * interface. It simply creates a stream handler proxy object for the\n     * specified protocol. It caches the returned proxy; therefore, subsequent\n     * requests for the same protocol will receive the same handler proxy.\n     * <\/p>\n     * @param protocol the protocol for which a stream handler should be returned.\n     * @return a stream handler proxy for the specified protocol.\n    **/\n    public URLStreamHandler createURLStreamHandler(String protocol)\n    {\n        // See if there is a cached stream handler.\n        // IMPLEMENTATION NOTE: Caching is not strictly necessary for\n        // stream handlers since the Java runtime caches them. Caching is\n        // performed for code consistency between stream and content\n        // handlers and also because caching behavior may not be guaranteed\n        // across different JRE implementations.\n        URLStreamHandler handler = getFromStreamCache(protocol);\n        \n        if (handler != null)\n        {\n            return handler;\n        }\n        // If this is the framework's \"bundle:\" protocol, then return\n        // a handler for that immediately, since no one else can be\n        // allowed to deal with it.\n        if (protocol.equals(FelixConstants.BUNDLE_URL_PROTOCOL))\n        {\n            return addToStreamCache(protocol, \n                new URLHandlersBundleStreamHandler(m_secureAction));\n        }\n    \n        // If this is the framework's \"felix:\" extension protocol, then\n        // return the ExtensionManager.m_extensionManager handler for \n        // that immediately - this is a workaround for certain jvms that\n        // do a toString() on the extension url we add to the global\n        // URLClassloader.\n        if (protocol.equals(\"felix\"))\n        {\n            return addToStreamCache(protocol, new URLStreamHandler()\n            {\n                protected URLConnection openConnection(URL url)\n                    throws IOException\n                {\n                    Object framework = getFrameworkFromContext();\n                    \n                    try\n                    {\n                        Object handler =  m_secureAction.getDeclaredField(\n                            framework.getClass(),\"m_extensionManager\", framework);\n\n                        return (URLConnection) m_secureAction.invoke(\n                            m_secureAction.getMethod(handler.getClass(), \n                            \"openConnection\", new Class[]{URL.class}), handler, \n                            new Object[]{url});\n                    }\n                    catch (Exception ex)\n                    {\n                        throw new IOException(ex.getMessage());\n                    }\n                }\n            });\n        }\n\n        // If built-in content handler, then create a proxy handler.\n        return addToStreamCache(protocol, new URLHandlersStreamHandlerProxy(protocol, m_secureAction, \n            (m_streamHandlerFactory != this) ? m_streamHandlerFactory : null));\n    }","commit_id":"18af769a4d8ee98d00160ff290701c956e1fdd2e","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * <p>\n     * This is a method implementation for the <tt>ContentHandlerFactory<\/tt>\n     * interface. It simply creates a content handler proxy object for the\n     * specified mime type. It caches the returned proxy; therefore, subsequent\n     * requests for the same content type will receive the same handler proxy.\n     * <\/p>\n     * @param mimeType the mime type for which a content handler should be returned.\n     * @return a content handler proxy for the specified mime type.\n    **/\n    public ContentHandler createContentHandler(String mimeType)\n    {\n        // See if there is a cached stream handler.\n        // IMPLEMENTATION NOTE: Caching is not strictly necessary for\n        // stream handlers since the Java runtime caches them. Caching is\n        // performed for code consistency between stream and content\n        // handlers and also because caching behavior may not be guaranteed\n        // across different JRE implementations.\n        ContentHandler handler = getFromContentCache(mimeType);\n        \n        if (handler != null)\n        {\n            return handler;\n        }\n        if (!OVERRIDE)\n        {\n            // If there was a custom factory then try to get the handler form it\n            if (m_contentHandlerFactory != this)\n            {\n                handler = addToContentCache(mimeType, \n                    m_contentHandlerFactory.createContentHandler(mimeType));\n                \n                if (handler != null)\n                {\n                    return handler;\n                }\n            }\n    \n            // Check for built-in handlers for the mime type.\n            String pkgs = m_secureAction.getSystemProperty(CONTENT_HANDLER_PACKAGE_PROP, \"\");\n            pkgs = (pkgs.equals(\"\"))\n                ? DEFAULT_CONTENT_HANDLER_PACKAGE\n                : pkgs + \"|\" + DEFAULT_CONTENT_HANDLER_PACKAGE;\n    \n            // Remove periods, slashes, and dashes from mime type.\n            String fixedType = mimeType.replace('.', '_').replace('/', '.').replace('-', '_');\n    \n            // Iterate over built-in packages.\n            StringTokenizer pkgTok = new StringTokenizer(pkgs, \"| \");\n            while (pkgTok.hasMoreTokens())\n            {\n                String pkg = pkgTok.nextToken().trim();\n                String className = pkg + \".\" + fixedType;\n                try\n                {\n                    // If a built-in handler is found then let the\n                    // JRE handle it.\n                    if (m_secureAction.forName(className) != null)\n                    {\n                        return null;\n                    }\n                }\n                catch (Exception ex)\n                {\n                    // This could be a class not found exception or an\n                    // instantiation exception, not much we can do in either\n                    // case other than ignore it.\n                }\n            }\n        }\n            \n        return addToContentCache(mimeType, \n            new URLHandlersContentHandlerProxy(mimeType, m_secureAction, \n            (m_contentHandlerFactory != this) ? m_contentHandlerFactory : null, OVERRIDE));\n    }","id":60713,"modified_method":"/**\n     * <p>\n     * This is a method implementation for the <tt>ContentHandlerFactory<\/tt>\n     * interface. It simply creates a content handler proxy object for the\n     * specified mime type. It caches the returned proxy; therefore, subsequent\n     * requests for the same content type will receive the same handler proxy.\n     * <\/p>\n     * @param mimeType the mime type for which a content handler should be returned.\n     * @return a content handler proxy for the specified mime type.\n    **/\n    public ContentHandler createContentHandler(String mimeType)\n    {\n        // See if there is a cached stream handler.\n        // IMPLEMENTATION NOTE: Caching is not strictly necessary for\n        // stream handlers since the Java runtime caches them. Caching is\n        // performed for code consistency between stream and content\n        // handlers and also because caching behavior may not be guaranteed\n        // across different JRE implementations.\n        ContentHandler handler = getFromContentCache(mimeType);\n        \n        if (handler != null)\n        {\n            return handler;\n        }\n\n        return addToContentCache(mimeType, \n            new URLHandlersContentHandlerProxy(mimeType, m_secureAction, \n            (m_contentHandlerFactory != this) ? m_contentHandlerFactory : null));\n    }","commit_id":"18af769a4d8ee98d00160ff290701c956e1fdd2e","url":"https://github.com/apache/felix"},{"original_method":"public URLHandlersContentHandlerProxy(String mimeType, SecureAction action, \n        ContentHandlerFactory factory, boolean override)\n    {\n        m_mimeType = mimeType;\n        m_action = action;\n        m_factory = factory;\n        m_override = override;\n    }","id":60714,"modified_method":"public URLHandlersContentHandlerProxy(String mimeType, SecureAction action, \n        ContentHandlerFactory factory)\n    {\n        m_mimeType = mimeType;\n        m_action = action;\n        m_factory = factory;\n    }","commit_id":"18af769a4d8ee98d00160ff290701c956e1fdd2e","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * <p>\n     * Private method to retrieve the content handler service from the\n     * framework instance associated with the current call stack. A\n     * simple service tracker is created and cached for the associated\n     * framework instance when this method is called.\n     * <\/p>\n     * @return the content handler service from the framework instance\n     *         associated with the current call stack or <tt>null<\/tt>\n     *         is no service is available.\n    **/\n    private ContentHandler getContentHandlerService()\n    {\n        // Get the framework instance associated with call stack.\n        Object framework = URLHandlers.getFrameworkFromContext();\n\n        if (framework == null) \n        {\n            return m_override ? getBuiltIn() : null;\n        }\n\n        // Get the service tracker for the framework instance or create one.\n        Object tracker;\n        synchronized (m_trackerMap)\n        {\n            tracker = m_trackerMap.get(framework);\n        }\n        try\n        {\n            if (tracker == null)\n            {\n                // Create a filter for the mime type.\n                String filter = \n                    \"(&(objectClass=\"\n                    + ContentHandler.class.getName()\n                    + \")(\"\n                    + URLConstants.URL_CONTENT_MIMETYPE\n                    + \"=\"\n                    + m_mimeType\n                    + \"))\";\n                // Create a simple service tracker for the framework.\n                tracker = m_action.invoke(m_action.getConstructor(\n                    framework.getClass().getClassLoader().loadClass(\n                    URLHandlersServiceTracker.class.getName()),\n                    new Class[]{framework.getClass().getClassLoader().loadClass(\n                    Felix.class.getName()), String.class}), \n                    new Object[]{framework, filter});\n                // Cache the simple service tracker.\n                synchronized (m_trackerMap) \n                {\n                    if (!m_trackerMap.containsKey(framework))\n                    {\n                        m_trackerMap.put(framework, tracker);\n                    }\n                    else\n                    {\n                        tracker = m_trackerMap.get(framework);\n                    }\n                }\n            }\n            ContentHandler result;\n            if (tracker instanceof URLHandlersServiceTracker)\n            {\n                result = (ContentHandler) \n                    ((URLHandlersServiceTracker) tracker).getService();\n            }\n            else\n            {\n                result = (ContentHandler) m_action.invoke(\n                    m_action.getMethod(tracker.getClass(), \"getService\", null), \n                    tracker, null);\n            }\n            if ((result == null) && m_override)\n            {\n                result = getBuiltIn();\n            }\n            return result;\n        }\n        catch (Exception ex)\n        {\n            // TODO: log this or something\n            ex.printStackTrace();\n            return null;\n        }\n    }","id":60715,"modified_method":"/**\n     * <p>\n     * Private method to retrieve the content handler service from the\n     * framework instance associated with the current call stack. A\n     * simple service tracker is created and cached for the associated\n     * framework instance when this method is called.\n     * <\/p>\n     * @return the content handler service from the framework instance\n     *         associated with the current call stack or <tt>null<\/tt>\n     *         is no service is available.\n    **/\n    private ContentHandler getContentHandlerService()\n    {\n        // Get the framework instance associated with call stack.\n        Object framework = URLHandlers.getFrameworkFromContext();\n\n        if (framework == null) \n        {\n            return getBuiltIn();\n        }\n\n        // Get the service tracker for the framework instance or create one.\n        Object tracker;\n        synchronized (m_trackerMap)\n        {\n            tracker = m_trackerMap.get(framework);\n        }\n        try\n        {\n            if (tracker == null)\n            {\n                // Create a filter for the mime type.\n                String filter = \n                    \"(&(objectClass=\"\n                    + ContentHandler.class.getName()\n                    + \")(\"\n                    + URLConstants.URL_CONTENT_MIMETYPE\n                    + \"=\"\n                    + m_mimeType\n                    + \"))\";\n                // Create a simple service tracker for the framework.\n                tracker = m_action.invoke(m_action.getConstructor(\n                    framework.getClass().getClassLoader().loadClass(\n                    URLHandlersServiceTracker.class.getName()),\n                    new Class[]{framework.getClass().getClassLoader().loadClass(\n                    Felix.class.getName()), String.class}), \n                    new Object[]{framework, filter});\n                // Cache the simple service tracker.\n                synchronized (m_trackerMap) \n                {\n                    if (!m_trackerMap.containsKey(framework))\n                    {\n                        m_trackerMap.put(framework, tracker);\n                    }\n                    else\n                    {\n                        tracker = m_trackerMap.get(framework);\n                    }\n                }\n            }\n            ContentHandler result;\n            if (tracker instanceof URLHandlersServiceTracker)\n            {\n                result = (ContentHandler) \n                    ((URLHandlersServiceTracker) tracker).getService();\n            }\n            else\n            {\n                result = (ContentHandler) m_action.invoke(\n                    m_action.getMethod(tracker.getClass(), \"getService\", null), \n                    tracker, null);\n            }\n            if (result == null)\n            {\n                result = getBuiltIn();\n            }\n            return result;\n        }\n        catch (Exception ex)\n        {\n            // TODO: log this or something\n            ex.printStackTrace();\n            return null;\n        }\n    }","commit_id":"18af769a4d8ee98d00160ff290701c956e1fdd2e","url":"https://github.com/apache/felix"},{"original_method":"public URLHandlersStreamHandlerProxy(String protocol, SecureAction action, \n        URLStreamHandlerFactory factory, boolean override)\n    {\n        m_protocol = protocol;\n        m_service = null;\n        m_action = action;\n        m_factory = factory;\n        m_override = override;\n    }","id":60716,"modified_method":"public URLHandlersStreamHandlerProxy(String protocol, SecureAction action, \n        URLStreamHandlerFactory factory)\n    {\n        m_protocol = protocol;\n        m_service = null;\n        m_action = action;\n        m_factory = factory;\n    }","commit_id":"18af769a4d8ee98d00160ff290701c956e1fdd2e","url":"https://github.com/apache/felix"},{"original_method":"private URLHandlersStreamHandlerProxy(Object service, SecureAction action)\n    {\n        m_protocol = null;\n        m_service = service;\n        m_action = action;\n        m_factory = null;\n        m_override = false;\n    }","id":60717,"modified_method":"private URLHandlersStreamHandlerProxy(Object service, SecureAction action)\n    {\n        m_protocol = null;\n        m_service = service;\n        m_action = action;\n        m_factory = null;\n    }","commit_id":"18af769a4d8ee98d00160ff290701c956e1fdd2e","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * <p>\n     * Private method to retrieve the stream handler service from the\n     * framework instance associated with the current call stack. A\n     * simple service tracker is created and cached for the associated\n     * framework instance when this method is called.\n     * <\/p>\n     * @return the stream handler service from the framework instance\n     *         associated with the current call stack or <tt>null<\/tt>\n     *         is no service is available.\n    **/\n    private Object getStreamHandlerService()\n    {\n        // Get the framework instance associated with call stack.\n        Object framework = URLHandlers.getFrameworkFromContext();\n\n        if (framework == null) \n        {\n            return m_override ? getBuiltIn() : null;\n        }\n\n        // Get the service tracker for the framework instance or create one.\n        Object tracker;\n        synchronized (m_trackerMap)\n        {\n            tracker = m_trackerMap.get(framework);\n        }\n        try\n        {\n            if (tracker == null)\n            {\n                // Create a filter for the protocol.\n                String filter = \n                    \"(&(objectClass=\"\n                    + URLStreamHandlerService.class.getName()\n                    + \")(\"\n                    + URLConstants.URL_HANDLER_PROTOCOL\n                    + \"=\"\n                    + m_protocol\n                    + \"))\";\n                // Create a simple service tracker for the framework.\n                tracker = m_action.invoke(m_action.getConstructor(\n                    framework.getClass().getClassLoader().loadClass(\n                    URLHandlersServiceTracker.class.getName()), \n                    new Class[]{framework.getClass().getClassLoader().loadClass(\n                    Felix.class.getName()), String.class}), \n                    new Object[]{framework, filter});\n\n                // Cache the simple service tracker.\n                synchronized (m_trackerMap) \n                {\n                    if (!m_trackerMap.containsKey(framework))\n                    {\n                        m_trackerMap.put(framework, tracker);\n                    }\n                    else\n                    {\n                        tracker = m_trackerMap.get(framework);\n                    }\n                }\n            }\n            Object service;\n            if (tracker instanceof URLHandlersServiceTracker)\n            {\n                service = ((URLHandlersServiceTracker) tracker).getService();\n            }\n            else\n            {\n                service = m_action.invoke(m_action.getMethod(\n                    tracker.getClass(), \"getService\", null), tracker, null);\n            }\n            if (service == null) \n            {\n                return m_override ? getBuiltIn() : null;\n            }\n            if (service instanceof URLStreamHandlerService)\n            {\n                return (URLStreamHandlerService) service;\n            }\n            return (URLStreamHandlerService) Proxy.newProxyInstance(\n                URLStreamHandlerService.class.getClassLoader(), \n                new Class[]{URLStreamHandlerService.class}, \n                new URLHandlersStreamHandlerProxy(service, m_action));\n        }\n        catch (Exception ex)\n        {\n            // TODO: log this or something\n            ex.printStackTrace();\n            return null;\n        }\n    }","id":60718,"modified_method":"/**\n     * <p>\n     * Private method to retrieve the stream handler service from the\n     * framework instance associated with the current call stack. A\n     * simple service tracker is created and cached for the associated\n     * framework instance when this method is called.\n     * <\/p>\n     * @return the stream handler service from the framework instance\n     *         associated with the current call stack or <tt>null<\/tt>\n     *         is no service is available.\n    **/\n    private Object getStreamHandlerService()\n    {\n        // Get the framework instance associated with call stack.\n        Object framework = URLHandlers.getFrameworkFromContext();\n\n        if (framework == null) \n        {\n            return getBuiltIn();\n        }\n\n        // Get the service tracker for the framework instance or create one.\n        Object tracker;\n        synchronized (m_trackerMap)\n        {\n            tracker = m_trackerMap.get(framework);\n        }\n        try\n        {\n            if (tracker == null)\n            {\n                // Create a filter for the protocol.\n                String filter = \n                    \"(&(objectClass=\"\n                    + URLStreamHandlerService.class.getName()\n                    + \")(\"\n                    + URLConstants.URL_HANDLER_PROTOCOL\n                    + \"=\"\n                    + m_protocol\n                    + \"))\";\n                // Create a simple service tracker for the framework.\n                tracker = m_action.invoke(m_action.getConstructor(\n                    framework.getClass().getClassLoader().loadClass(\n                    URLHandlersServiceTracker.class.getName()), \n                    new Class[]{framework.getClass().getClassLoader().loadClass(\n                    Felix.class.getName()), String.class}), \n                    new Object[]{framework, filter});\n\n                // Cache the simple service tracker.\n                synchronized (m_trackerMap) \n                {\n                    if (!m_trackerMap.containsKey(framework))\n                    {\n                        m_trackerMap.put(framework, tracker);\n                    }\n                    else\n                    {\n                        tracker = m_trackerMap.get(framework);\n                    }\n                }\n            }\n            Object service;\n            if (tracker instanceof URLHandlersServiceTracker)\n            {\n                service = ((URLHandlersServiceTracker) tracker).getService();\n            }\n            else\n            {\n                service = m_action.invoke(m_action.getMethod(\n                    tracker.getClass(), \"getService\", null), tracker, null);\n            }\n            if (service == null) \n            {\n                return getBuiltIn();\n            }\n            if (service instanceof URLStreamHandlerService)\n            {\n                return (URLStreamHandlerService) service;\n            }\n            return (URLStreamHandlerService) Proxy.newProxyInstance(\n                URLStreamHandlerService.class.getClassLoader(), \n                new Class[]{URLStreamHandlerService.class}, \n                new URLHandlersStreamHandlerProxy(service, m_action));\n        }\n        catch (Exception ex)\n        {\n            // TODO: log this or something\n            ex.printStackTrace();\n            return null;\n        }\n    }","commit_id":"18af769a4d8ee98d00160ff290701c956e1fdd2e","url":"https://github.com/apache/felix"},{"original_method":"@Override\n    public void beforeTestMethod(TestContext testContext) throws Exception {\n        JUnitCollector config = findCollectorAnnotation(testContext);\n        if (config == null) {\n            return;\n        }\n\n        // FIXME: Is there a better way to inject the TestContext into the test class?  Seems that spring doesn't give direct access...\n        Method m = ReflectionUtils.findMethod(testContext.getTestClass(), \"setTestContext\", new Class[]{TestContext.class});\n        if (m != null && testContext.getTestInstance() != null) {\n            System.err.println(\"invoking setTestContext on \" + testContext.getTestInstance());\n            m.invoke(testContext.getTestInstance(), testContext);\n        }\n        \n        RrdTestUtils.initialize();\n\n        // make a fake database schema with hibernate\n        InputStream is = ConfigurationTestUtils.getInputStreamForResource(testContext.getTestInstance(), config.schemaConfig());\n        DatabaseSchemaConfigFactory.setInstance(new DatabaseSchemaConfigFactory(is));\n        is.close();\n\n        // set up temporary directories for RRD files\n        m_fileAnticipator = new FileAnticipator();\n        m_snmpRrdDirectory = m_fileAnticipator.tempDir(\"snmp\");\n        m_snmpRrdDirectory.mkdirs();\n        testContext.setAttribute(\"fileAnticipator\", m_fileAnticipator);\n        testContext.setAttribute(\"rrdDirectory\", m_snmpRrdDirectory);\n\n        // set up the collection configuration factory\n        if (config.datacollectionType().equalsIgnoreCase(\"http\")) {\n        \tis = ConfigurationTestUtils.getInputStreamForResourceWithReplacements(testContext.getTestInstance(), config.datacollectionConfig(), new String[] { \"%rrdRepository%\", m_snmpRrdDirectory.getAbsolutePath() });\n            HttpCollectionConfigFactory factory = new HttpCollectionConfigFactory(is);\n            HttpCollectionConfigFactory.setInstance(factory);\n            HttpCollectionConfigFactory.init();\n        } else if (config.datacollectionType().equalsIgnoreCase(\"snmp\")) {\n            Resource r = ConfigurationTestUtils.getSpringResourceForResourceWithReplacements(testContext.getTestInstance(), config.datacollectionConfig(), new String[] { \"%rrdRepository%\", m_snmpRrdDirectory.getAbsolutePath() });\n            DefaultDataCollectionConfigDao dataCollectionDao = new DefaultDataCollectionConfigDao();\n            dataCollectionDao.setConfigResource(r);\n            dataCollectionDao.afterPropertiesSet();\n            DataCollectionConfigFactory.setInstance(dataCollectionDao);\n        } else {\n            throw new UnsupportedOperationException(\"data collection type '\" + config.datacollectionType() + \"' not supported\");\n        }\n        IOUtils.closeQuietly(is);\n    }","id":60719,"modified_method":"@Override\n    public void beforeTestMethod(TestContext testContext) throws Exception {\n        JUnitCollector config = findCollectorAnnotation(testContext);\n        if (config == null) {\n            return;\n        }\n\n        // FIXME: Is there a better way to inject the instance into the test class?\n        if (testContext.getTestInstance() instanceof TestContextAware) {\n            System.err.println(\"injecting TestContext into TestContextAware test: \"\n                            + testContext.getTestInstance().getClass().getSimpleName() + \".\"\n                            + testContext.getTestMethod().getName());\n            ((TestContextAware) testContext.getTestInstance()).setTestContext(testContext);\n        }\n        \n        RrdTestUtils.initialize();\n\n        // make a fake database schema with hibernate\n        InputStream is = ConfigurationTestUtils.getInputStreamForResource(testContext.getTestInstance(), config.schemaConfig());\n        DatabaseSchemaConfigFactory.setInstance(new DatabaseSchemaConfigFactory(is));\n        is.close();\n\n        // set up temporary directories for RRD files\n        m_fileAnticipator = new FileAnticipator();\n        m_snmpRrdDirectory = m_fileAnticipator.tempDir(\"snmp\");\n        m_snmpRrdDirectory.mkdirs();\n        testContext.setAttribute(\"fileAnticipator\", m_fileAnticipator);\n        testContext.setAttribute(\"rrdDirectory\", m_snmpRrdDirectory);\n\n        // set up the collection configuration factory\n        if (config.datacollectionType().equalsIgnoreCase(\"http\")) {\n        \tis = ConfigurationTestUtils.getInputStreamForResourceWithReplacements(testContext.getTestInstance(), config.datacollectionConfig(), new String[] { \"%rrdRepository%\", m_snmpRrdDirectory.getAbsolutePath() });\n            HttpCollectionConfigFactory factory = new HttpCollectionConfigFactory(is);\n            HttpCollectionConfigFactory.setInstance(factory);\n            HttpCollectionConfigFactory.init();\n        } else if (config.datacollectionType().equalsIgnoreCase(\"snmp\")) {\n            Resource r = ConfigurationTestUtils.getSpringResourceForResourceWithReplacements(testContext.getTestInstance(), config.datacollectionConfig(), new String[] { \"%rrdRepository%\", m_snmpRrdDirectory.getAbsolutePath() });\n            DefaultDataCollectionConfigDao dataCollectionDao = new DefaultDataCollectionConfigDao();\n            dataCollectionDao.setConfigResource(r);\n            dataCollectionDao.afterPropertiesSet();\n            DataCollectionConfigFactory.setInstance(dataCollectionDao);\n        } else {\n            throw new UnsupportedOperationException(\"data collection type '\" + config.datacollectionType() + \"' not supported\");\n        }\n        IOUtils.closeQuietly(is);\n    }","commit_id":"ea00c75e39631b8a849fed2f25cb603072f715a3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testStdErrLogName()\n    {\n        StdErrLog log = new StdErrLog(\"test\");\n        Assert.assertEquals(\"test\",log.getName());\n        \n        Logger next=log.getLogger(\"next\");\n        \n        Assert.assertEquals(\"test.next\",next.getName());\n        \n        next.info(\"testing {} {}\",\"next\",\"info\");\n        logContains(\":test.next:testing next info\");\n        \n    }","id":60720,"modified_method":"@Test\n    public void testStdErrLogName()\n    {\n        StdErrLog log = new StdErrLog(\"test\");\n        log.setPrintLongNames(true);\n        Assert.assertEquals(\"test\",log.getName());\n        \n        Logger next=log.getLogger(\"next\");\n        \n        Assert.assertEquals(\"test.next\",next.getName());\n        \n        next.info(\"testing {} {}\",\"next\",\"info\");\n        logContains(\":test.next:testing next info\");\n        \n    }","commit_id":"953b3512f70d0a9f1a479130c358b3fd815bab7b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testStdErrLogFormat()\n    {\n        StdErrLog log = new StdErrLog(\"test\");\n\n        log.info(\"testing:{},{}\",\"test\",\"format\");\n        logContains(\"INFO:test:testing:test,format\");\n        \n        log.info(\"testing:{}\",\"test\",\"format\");\n        logContains(\"INFO:test:testing:test format\");\n        \n        log.info(\"testing\",\"test\",\"format\");\n        logContains(\"INFO:test:testing test format\");\n       \n        log.info(\"testing:{},{}\",\"test\",null);\n        logContains(\"INFO:test:testing:test,null\");\n       \n        log.info(\"testing {} {}\",null,null);\n        logContains(\"INFO:test:testing null null\");\n        \n        log.info(\"testing:{}\",null,null);\n        logContains(\"INFO:test:testing:null\");\n        \n        log.info(\"testing\",null,null);\n        logContains(\"INFO:test:testing\");\n    }","id":60721,"modified_method":"@Test\n    public void testStdErrLogFormat()\n    {\n        StdErrLog log = new StdErrLog(LogTest.class.getName());\n\n        log.info(\"testing:{},{}\",\"test\",\"format\");\n        logContains(\"INFO:oejul.LogTest:testing:test,format\");\n        \n        log.info(\"testing:{}\",\"test\",\"format\");\n        logContains(\"INFO:oejul.LogTest:testing:test format\");\n        \n        log.info(\"testing\",\"test\",\"format\");\n        logContains(\"INFO:oejul.LogTest:testing test format\");\n       \n        log.info(\"testing:{},{}\",\"test\",null);\n        logContains(\"INFO:oejul.LogTest:testing:test,null\");\n       \n        log.info(\"testing {} {}\",null,null);\n        logContains(\"INFO:oejul.LogTest:testing null null\");\n        \n        log.info(\"testing:{}\",null,null);\n        logContains(\"INFO:oejul.LogTest:testing:null\");\n        \n        log.info(\"testing\",null,null);\n        logContains(\"INFO:oejul.LogTest:testing\");\n    }","commit_id":"953b3512f70d0a9f1a479130c358b3fd815bab7b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@After\n    public void tearDown()\n    {\n        System.out.println(logstream.toString());\n        System.setErr(orig);\n    }","id":60722,"modified_method":"@After\n    public void tearDown()\n    {\n        System.out.println(logstream.toString());\n        System.setErr(orig);\n        \n        Log.setLog(origLogger);\n    }","commit_id":"953b3512f70d0a9f1a479130c358b3fd815bab7b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testNamedLogging()\n    {\n        Red red = new Red();\n        Green green = new Green();\n        Blue blue = new Blue();\n\n        red.generateLogs();\n        green.generateLogs();\n        blue.generateLogs();\n\n        String rawlog = logstream.toString();\n        \n        Assert.assertThat(rawlog,containsString(Red.class.getName()));\n        Assert.assertThat(rawlog,containsString(Green.class.getName()));\n        Assert.assertThat(rawlog,containsString(Blue.class.getName()));\n    }","id":60723,"modified_method":"@Test\n    public void testNamedLogging()\n    {\n        Red red = new Red();\n        Green green = new Green();\n        Blue blue = new Blue();\n        \n        setLoggerOptions(Red.class);\n        setLoggerOptions(Green.class);\n        setLoggerOptions(Blue.class);\n\n        red.generateLogs();\n        green.generateLogs();\n        blue.generateLogs();\n\n        String rawlog = logstream.toString();\n        \n        Assert.assertThat(rawlog,containsString(Red.class.getName()));\n        Assert.assertThat(rawlog,containsString(Green.class.getName()));\n        Assert.assertThat(rawlog,containsString(Blue.class.getName()));\n    }","commit_id":"953b3512f70d0a9f1a479130c358b3fd815bab7b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Before\n    public void setUp()\n    {\n        orig = System.err;\n        logstream = new ByteArrayOutputStream();\n        perr = new PrintStream(logstream);\n        System.setErr(perr);\n\n        StdErrLog logger = new StdErrLog();\n        logger.setDebugEnabled(true);\n        logger.setHideStacks(false);\n        Log.setLog(logger);\n    }","id":60724,"modified_method":"@Before\n    public void setUp()\n    {\n        origLogger = Log.getRootLogger();\n        \n        orig = System.err;\n        logstream = new ByteArrayOutputStream();\n        perr = new PrintStream(logstream);\n        System.setErr(perr);\n\n        StdErrLog logger = new StdErrLog();\n        Log.setLog(logger);\n    }","commit_id":"953b3512f70d0a9f1a479130c358b3fd815bab7b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public Logger getLogger(String name)\n    {\n        String fullname=_name == null || _name.length() == 0?name:_name + \".\" + name;\n        \n        if ((name == null && this._name == null) || fullname.equals(_name))\n            return this;\n        \n        StdErrLog logger = __loggers.get(name);\n        if (logger==null)\n        {\n            StdErrLog sel=new StdErrLog(fullname);\n            logger=__loggers.putIfAbsent(fullname,sel);\n            if (logger==null)\n                logger=sel;\n        }\n        \n        return logger;\n    }","id":60725,"modified_method":"public Logger getLogger(String name)\n    {\n        String fullname=_name == null || _name.length() == 0?name:_name + \".\" + name;\n        \n        if ((name == null && this._name == null) || fullname.equals(_name))\n            return this;\n        \n        StdErrLog logger = __loggers.get(name);\n        if (logger==null)\n        {\n            StdErrLog sel=new StdErrLog(fullname);\n            // Preserve configuration for new loggers configuration\n            sel.setPrintLongNames(_printLongNames);\n            sel.setDebugEnabled(_debug);\n            sel.setSource(_source);\n            logger=__loggers.putIfAbsent(fullname,sel);\n            if (logger==null)\n                logger=sel;\n        }\n        \n        return logger;\n    }","commit_id":"953b3512f70d0a9f1a479130c358b3fd815bab7b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public StdErrLog(String name)\n    {\n        this._name = name == null ? \"\" : name;\n\n        try\n        {\n            _debug = Boolean.parseBoolean(System.getProperty(_name + \".DEBUG\", Boolean.toString(_debug)));\n        }\n        catch (AccessControlException ace)\n        {\n            _debug = __debug;\n        }\n        \n        try\n        {\n            _source = Boolean.parseBoolean(System.getProperty(_name + \".SOURCE\", Boolean.toString(_source)));\n        }\n        catch (AccessControlException ace)\n        {\n            _source = __source;\n        }\n    }","id":60726,"modified_method":"public StdErrLog(String name)\n    {\n        this._name = name == null ? \"\" : name;\n        this._abbrevname = condensePackageString(this._name);\n\n        try\n        {\n            _debug = Boolean.parseBoolean(System.getProperty(_name + \".DEBUG\", Boolean.toString(_debug)));\n        }\n        catch (AccessControlException ace)\n        {\n            _debug = __debug;\n        }\n        \n        try\n        {\n            _source = Boolean.parseBoolean(System.getProperty(_name + \".SOURCE\", Boolean.toString(_source)));\n        }\n        catch (AccessControlException ace)\n        {\n            _source = __source;\n        }\n    }","commit_id":"953b3512f70d0a9f1a479130c358b3fd815bab7b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void tag(StringBuilder buffer, String d, int ms, String tag)\n    {\n        buffer.setLength(0);\n        buffer.append(d);\n        if (ms > 99)\n            buffer.append('.');\n        else if (ms > 9)\n            buffer.append(\".0\");\n        else\n            buffer.append(\".00\");\n        buffer.append(ms).append(tag).append(_name).append(':');\n        if (_source)\n        {\n            Throwable source = new Throwable();\n            StackTraceElement[] frames =  source.getStackTrace();\n            for (int i=0;i<frames.length;i++)\n            {\n                final StackTraceElement frame = frames[i];\n                String clazz = frame.getClassName();\n                if (clazz.equals(StdErrLog.class.getName())|| clazz.equals(Log.class.getName()))\n                    continue;\n                if (clazz.startsWith(\"org.eclipse.jetty.\"))\n                    buffer.append(\"o.e.j.\").append(clazz,18,clazz.length());\n                else\n                    buffer.append(clazz);\n                buffer.append('#').append(frame.getMethodName());\n                if (frame.getFileName()!=null)\n                    buffer.append('(').append(frame.getFileName()).append(':').append(frame.getLineNumber()).append(')');\n                buffer.append(':');\n                break;\n            }\n        }\n    }","id":60727,"modified_method":"private void tag(StringBuilder buffer, String d, int ms, String tag)\n    {\n        buffer.setLength(0);\n        buffer.append(d);\n        if (ms > 99)\n            buffer.append('.');\n        else if (ms > 9)\n            buffer.append(\".0\");\n        else\n            buffer.append(\".00\");\n        buffer.append(ms).append(tag);\n        if(_printLongNames) {\n            buffer.append(_name);\n        } else {\n            buffer.append(_abbrevname);\n        }\n        buffer.append(':');\n        if (_source)\n        {\n            Throwable source = new Throwable();\n            StackTraceElement[] frames =  source.getStackTrace();\n            for (int i=0;i<frames.length;i++)\n            {\n                final StackTraceElement frame = frames[i];\n                String clazz = frame.getClassName();\n                if (clazz.equals(StdErrLog.class.getName())|| clazz.equals(Log.class.getName()))\n                    continue;\n                if (!_printLongNames && clazz.startsWith(\"org.eclipse.jetty.\")) {\n                    buffer.append(condensePackageString(clazz));\n                } else {\n                    buffer.append(clazz);\n                }\n                buffer.append('#').append(frame.getMethodName());\n                if (frame.getFileName()!=null)\n                    buffer.append('(').append(frame.getFileName()).append(':').append(frame.getLineNumber()).append(')');\n                buffer.append(':');\n                break;\n            }\n        }\n    }","commit_id":"953b3512f70d0a9f1a479130c358b3fd815bab7b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void testNullValues()\n    {\n        StdErrLog log = new StdErrLog();\n        log.setDebugEnabled(true);\n        log.setHideStacks(true);\n\n        try {\n            log.info(\"Testing info(msg,null,null) - {} {}\",null,null);\n            log.info(\"Testing info(msg,null,null) - {}\",null,null);\n            log.info(\"Testing info(msg,null,null)\",null,null);\n            log.info(null,\"- Testing\",\"info(null,arg0,arg1)\");\n            log.info(null,null,null);\n\n            log.debug(\"Testing debug(msg,null,null) - {} {}\",null,null);\n            log.debug(\"Testing debug(msg,null,null) - {}\",null,null);\n            log.debug(\"Testing debug(msg,null,null)\",null,null);\n            log.debug(null,\"- Testing\",\"debug(null,arg0,arg1)\");\n            log.debug(null,null,null);\n\n            log.debug(\"Testing debug(msg,null)\");\n            log.debug(null,new Throwable(\"IGNORE::Testing debug(null,thrw)\").fillInStackTrace());\n\n            log.warn(\"Testing warn(msg,null,null) - {} {}\",null,null);\n            log.warn(\"Testing warn(msg,null,null) - {}\",null,null);\n            log.warn(\"Testing warn(msg,null,null)\",null,null);\n            log.warn(null,\"- Testing\",\"warn(msg,arg0,arg1)\");\n            log.warn(null,null,null);\n\n            log.warn(\"Testing warn(msg,null)\");\n            log.warn(null,new Throwable(\"IGNORE::Testing warn(msg,thrw)\").fillInStackTrace());\n        }\n        catch (NullPointerException npe)\n        {\n            System.err.println(npe);\n            npe.printStackTrace();\n            assertTrue(\"NullPointerException in StdErrLog.\", false);\n        }\n    }","id":60728,"modified_method":"public void testNullValues()\n    {\n        StdErrLog log = new StdErrLog(StdErrLogTest.class.getName());\n        log.setDebugEnabled(true);\n        log.setHideStacks(true);\n\n        try {\n            log.info(\"Testing info(msg,null,null) - {} {}\",null,null);\n            log.info(\"Testing info(msg,null,null) - {}\",null,null);\n            log.info(\"Testing info(msg,null,null)\",null,null);\n            log.info(null,\"- Testing\",\"info(null,arg0,arg1)\");\n            log.info(null,null,null);\n\n            log.debug(\"Testing debug(msg,null,null) - {} {}\",null,null);\n            log.debug(\"Testing debug(msg,null,null) - {}\",null,null);\n            log.debug(\"Testing debug(msg,null,null)\",null,null);\n            log.debug(null,\"- Testing\",\"debug(null,arg0,arg1)\");\n            log.debug(null,null,null);\n\n            log.debug(\"Testing debug(msg,null)\");\n            log.debug(null,new Throwable(\"IGNORE::Testing debug(null,thrw)\").fillInStackTrace());\n\n            log.warn(\"Testing warn(msg,null,null) - {} {}\",null,null);\n            log.warn(\"Testing warn(msg,null,null) - {}\",null,null);\n            log.warn(\"Testing warn(msg,null,null)\",null,null);\n            log.warn(null,\"- Testing\",\"warn(msg,arg0,arg1)\");\n            log.warn(null,null,null);\n\n            log.warn(\"Testing warn(msg,null)\");\n            log.warn(null,new Throwable(\"IGNORE::Testing warn(msg,thrw)\").fillInStackTrace());\n        }\n        catch (NullPointerException npe)\n        {\n            System.err.println(npe);\n            npe.printStackTrace();\n            assertTrue(\"NullPointerException in StdErrLog.\", false);\n        }\n    }","commit_id":"953b3512f70d0a9f1a479130c358b3fd815bab7b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void configureByModule(final Module module, final int classPathType, final Sdk jdk) throws CantRunException {\n    if ((classPathType & JDK_ONLY) != 0) {\n      if (jdk == null) {\n        throw CantRunException.noJdkConfigured();\n      }\n      setJdk(jdk);\n    }\n\n    if ((classPathType & CLASSES_ONLY) == 0) {\n      return;\n    }\n\n    setDefaultCharset(module.getProject());\n    final PairFunction<OrderEntry, OrderRootType, VirtualFile[]> substitutor = computeSubstitutor(classPathType, jdk);\n    configureEnumerator(OrderEnumerator.orderEntries(module).runtimeOnly().recursively().substituteFiles(substitutor)\n      , classPathType).classes().collectPaths(getClassPath());\n  }","id":60729,"modified_method":"public void configureByModule(final Module module, final int classPathType, final Sdk jdk) throws CantRunException {\n    if ((classPathType & JDK_ONLY) != 0) {\n      if (jdk == null) {\n        throw CantRunException.noJdkConfigured();\n      }\n      setJdk(jdk);\n    }\n\n    if ((classPathType & CLASSES_ONLY) == 0) {\n      return;\n    }\n\n    setDefaultCharset(module.getProject());\n    configureEnumerator(OrderEnumerator.orderEntries(module).runtimeOnly().recursively(), classPathType, jdk).collectPaths(getClassPath());\n  }","commit_id":"1a5d43b980e7c3797a868deae7a86646ea59a876","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void configureByProject(final Project project, final int classPathType, final Sdk jdk) throws CantRunException {\n    if ((classPathType & JDK_ONLY) != 0) {\n      if (jdk == null) {\n        throw CantRunException.noJdkConfigured();\n      }\n      setJdk(jdk);\n    }\n\n    if ((classPathType & CLASSES_ONLY) == 0) {\n      return;\n    }\n    final PairFunction<OrderEntry, OrderRootType, VirtualFile[]> substitutor = computeSubstitutor(classPathType, jdk);\n    configureEnumerator(OrderEnumerator.orderEntries(project).runtimeOnly().substituteFiles(substitutor), classPathType).classes().collectPaths(getClassPath());\n  }","id":60730,"modified_method":"public void configureByProject(final Project project, final int classPathType, final Sdk jdk) throws CantRunException {\n    if ((classPathType & JDK_ONLY) != 0) {\n      if (jdk == null) {\n        throw CantRunException.noJdkConfigured();\n      }\n      setJdk(jdk);\n    }\n\n    if ((classPathType & CLASSES_ONLY) == 0) {\n      return;\n    }\n    configureEnumerator(OrderEnumerator.orderEntries(project).runtimeOnly(), classPathType, jdk).collectPaths(getClassPath());\n  }","commit_id":"1a5d43b980e7c3797a868deae7a86646ea59a876","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static OrderEnumerator configureEnumerator(OrderEnumerator enumerator, int classPathType) {\n    if ((classPathType & JDK_ONLY) == 0) {\n      enumerator = enumerator.withoutSdk();\n    }\n    if ((classPathType & TESTS_ONLY) == 0) {\n      enumerator = enumerator.productionOnly();\n    }\n    return enumerator;\n  }","id":60731,"modified_method":"private static OrderRootsEnumerator configureEnumerator(OrderEnumerator enumerator, int classPathType, Sdk jdk) {\n    if ((classPathType & JDK_ONLY) == 0) {\n      enumerator = enumerator.withoutSdk();\n    }\n    if ((classPathType & TESTS_ONLY) == 0) {\n      enumerator = enumerator.productionOnly();\n    }\n    OrderRootsEnumerator rootsEnumerator = enumerator.classes();\n    final NotNullFunction<OrderEntry, VirtualFile[]> provider = computeRootProvider(classPathType, jdk);\n    if (provider != null) {\n      rootsEnumerator = rootsEnumerator.usingCustomRootProvider(provider);\n    }\n    return rootsEnumerator;\n  }","commit_id":"1a5d43b980e7c3797a868deae7a86646ea59a876","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public String[] getUrls() {\n    if (myUsingCache) {\n      final OrderRootsCache cache = myOrderEnumerator.getCache();\n      if (cache != null) {\n        final int flags = myOrderEnumerator.getFlags();\n        String[] cached = cache.getCachedUrls(myRootType, flags);\n        if (cached == null) {\n          return cache.setCachedRoots(myRootType, flags, computeRootsUrls()).getUrls();\n        }\n        else {\n          return cached;\n        }\n      }\n    }\n    return ArrayUtil.toStringArray(computeRootsUrls());\n  }","id":60732,"modified_method":"@NotNull\n  @Override\n  public String[] getUrls() {\n    if (myUsingCache) {\n      checkCanUseCache();\n      final OrderRootsCache cache = myOrderEnumerator.getCache();\n      if (cache != null) {\n        final int flags = myOrderEnumerator.getFlags();\n        String[] cached = cache.getCachedUrls(myRootType, flags);\n        if (cached == null) {\n          return cache.setCachedRoots(myRootType, flags, computeRootsUrls()).getUrls();\n        }\n        else {\n          return cached;\n        }\n      }\n    }\n    return ArrayUtil.toStringArray(computeRootsUrls());\n  }","commit_id":"1a5d43b980e7c3797a868deae7a86646ea59a876","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public VirtualFile[] getRoots() {\n    if (myUsingCache) {\n      final OrderRootsCache cache = myOrderEnumerator.getCache();\n      if (cache != null) {\n        final int flags = myOrderEnumerator.getFlags();\n        final VirtualFile[] cached = cache.getCachedRoots(myRootType, flags);\n        if (cached == null) {\n          return cache.setCachedRoots(myRootType, flags, computeRootsUrls()).getFiles();\n        }\n        else {\n          return cached;\n        }\n      }\n    }\n\n    return VfsUtil.toVirtualFileArray(computeRoots());\n  }","id":60733,"modified_method":"@NotNull\n  @Override\n  public VirtualFile[] getRoots() {\n    if (myUsingCache) {\n      checkCanUseCache();\n      final OrderRootsCache cache = myOrderEnumerator.getCache();\n      if (cache != null) {\n        final int flags = myOrderEnumerator.getFlags();\n        final VirtualFile[] cached = cache.getCachedRoots(myRootType, flags);\n        if (cached == null) {\n          return cache.setCachedRoots(myRootType, flags, computeRootsUrls()).getFiles();\n        }\n        else {\n          return cached;\n        }\n      }\n    }\n\n    return VfsUtil.toVirtualFileArray(computeRoots());\n  }","commit_id":"1a5d43b980e7c3797a868deae7a86646ea59a876","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Collection<String> computeRootsUrls() {\n    final Collection<String> result = new LinkedHashSet<String>();\n    myOrderEnumerator.forEach(new Processor<OrderEntry>() {\n      @Override\n      public boolean process(OrderEntry orderEntry) {\n        if (orderEntry instanceof ModuleSourceOrderEntry) {\n          collectModuleRootsUrls(((ModuleSourceOrderEntry)orderEntry).getRootModel(), result);\n        }\n        else if (orderEntry instanceof ModuleOrderEntry) {\n          ModuleOrderEntry moduleOrderEntry = (ModuleOrderEntry)orderEntry;\n          final Module module = moduleOrderEntry.getModule();\n          if (module != null) {\n            if (myOrderEnumerator.addCustomOutputUrls(moduleOrderEntry, result)) {\n              return true;\n            }\n            collectModuleRootsUrls(myOrderEnumerator.getRootModel(module), result);\n          }\n        }\n        else {\n          Collections.addAll(result, myOrderEnumerator.substituteUrls(orderEntry, myRootType));\n        }\n        return true;\n      }\n    });\n    return result;\n  }","id":60734,"modified_method":"private Collection<String> computeRootsUrls() {\n    final Collection<String> result = new LinkedHashSet<String>();\n    myOrderEnumerator.forEach(new Processor<OrderEntry>() {\n      @Override\n      public boolean process(OrderEntry orderEntry) {\n        if (orderEntry instanceof ModuleSourceOrderEntry) {\n          collectModuleRootsUrls(((ModuleSourceOrderEntry)orderEntry).getRootModel(), result);\n        }\n        else if (orderEntry instanceof ModuleOrderEntry) {\n          ModuleOrderEntry moduleOrderEntry = (ModuleOrderEntry)orderEntry;\n          final Module module = moduleOrderEntry.getModule();\n          if (module != null) {\n            if (myOrderEnumerator.addCustomOutputUrls(moduleOrderEntry, result)) {\n              return true;\n            }\n            collectModuleRootsUrls(myOrderEnumerator.getRootModel(module), result);\n          }\n        }\n        else {\n          Collections.addAll(result, orderEntry.getUrls(myRootType));\n        }\n        return true;\n      }\n    });\n    return result;\n  }","commit_id":"1a5d43b980e7c3797a868deae7a86646ea59a876","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Collection<VirtualFile> computeRoots() {\n    final Collection<VirtualFile> result = new LinkedHashSet<VirtualFile>();\n    myOrderEnumerator.forEach(new Processor<OrderEntry>() {\n      @Override\n      public boolean process(OrderEntry orderEntry) {\n        if (orderEntry instanceof ModuleSourceOrderEntry) {\n          collectModuleRoots(((ModuleSourceOrderEntry)orderEntry).getRootModel(), result);\n        }\n        else if (orderEntry instanceof ModuleOrderEntry) {\n          ModuleOrderEntry moduleOrderEntry = (ModuleOrderEntry)orderEntry;\n          final Module module = moduleOrderEntry.getModule();\n          if (module != null) {\n            if (myOrderEnumerator.addCustomOutput(moduleOrderEntry, result)) {\n              return true;\n            }\n            collectModuleRoots(myOrderEnumerator.getRootModel(module), result);\n          }\n        }\n        else {\n          Collections.addAll(result, myOrderEnumerator.substituteFiles(orderEntry, myRootType));\n        }\n        return true;\n      }\n    });\n    return result;\n  }","id":60735,"modified_method":"private Collection<VirtualFile> computeRoots() {\n    final Collection<VirtualFile> result = new LinkedHashSet<VirtualFile>();\n    myOrderEnumerator.forEach(new Processor<OrderEntry>() {\n      @Override\n      public boolean process(OrderEntry orderEntry) {\n        if (orderEntry instanceof ModuleSourceOrderEntry) {\n          collectModuleRoots(((ModuleSourceOrderEntry)orderEntry).getRootModel(), result);\n        }\n        else if (orderEntry instanceof ModuleOrderEntry) {\n          ModuleOrderEntry moduleOrderEntry = (ModuleOrderEntry)orderEntry;\n          final Module module = moduleOrderEntry.getModule();\n          if (module != null) {\n            if (myOrderEnumerator.addCustomOutput(moduleOrderEntry, result)) {\n              return true;\n            }\n            collectModuleRoots(myOrderEnumerator.getRootModel(module), result);\n          }\n        }\n        else {\n          Collections.addAll(result, myCustomRootProvider != null ? myCustomRootProvider.fun(orderEntry) : orderEntry.getFiles(myRootType));\n        }\n        return true;\n      }\n    });\n    return result;\n  }","commit_id":"1a5d43b980e7c3797a868deae7a86646ea59a876","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void configureByProject(final Project project, final int classPathType, final Sdk jdk) throws CantRunException {\n    if ((classPathType & JDK_ONLY) != 0) {\n      if (jdk == null) {\n        throw CantRunException.noJdkConfigured();\n      }\n      setJdk(jdk);\n    }\n\n    if ((classPathType & CLASSES_ONLY) == 0) {\n      return;\n    }\n\n    configureEnumerator(OrderEnumerator.orderEntries(project).runtimeOnly(), classPathType).classes().collectPaths(getClassPath());\n  }","id":60736,"modified_method":"public void configureByProject(final Project project, final int classPathType, final Sdk jdk) throws CantRunException {\n    if ((classPathType & JDK_ONLY) != 0) {\n      if (jdk == null) {\n        throw CantRunException.noJdkConfigured();\n      }\n      setJdk(jdk);\n    }\n\n    if ((classPathType & CLASSES_ONLY) == 0) {\n      return;\n    }\n\n    configureJdkAccordingToJreSelected(getJdk());\n    configureEnumerator(OrderEnumerator.orderEntries(project).runtimeOnly().withoutSdk(), classPathType).collectPaths(getClassPath());\n  }","commit_id":"368d7952ceecf0e29046295c6daf1af1241813b4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void configureByModule(final Module module, final int classPathType, final Sdk jdk) throws CantRunException {\n    if ((classPathType & JDK_ONLY) != 0) {\n      if (jdk == null) {\n        throw CantRunException.noJdkConfigured();\n      }\n      setJdk(jdk);\n    }\n\n    if ((classPathType & CLASSES_ONLY) == 0) {\n      return;\n    }\n\n    setDefaultCharset(module.getProject());\n    configureEnumerator(OrderEnumerator.orderEntries(module).runtimeOnly().recursively(), classPathType)\n      .classes().collectPaths(getClassPath());\n  }","id":60737,"modified_method":"public void configureByModule(final Module module, final int classPathType, final Sdk jdk) throws CantRunException {\n    if ((classPathType & JDK_ONLY) != 0) {\n      if (jdk == null) {\n        throw CantRunException.noJdkConfigured();\n      }\n      setJdk(jdk);\n    }\n\n    if ((classPathType & CLASSES_ONLY) == 0) {\n      return;\n    }\n\n    setDefaultCharset(module.getProject());\n    configureJdkAccordingToJreSelected(jdk);\n    configureEnumerator(OrderEnumerator.orderEntries(module).runtimeOnly().recursively().withoutSdk(), classPathType).collectPaths(getClassPath());\n  }","commit_id":"368d7952ceecf0e29046295c6daf1af1241813b4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void configureByProject(final Project project, final int classPathType, final Sdk jdk) throws CantRunException {\n    if ((classPathType & JDK_ONLY) != 0) {\n      if (jdk == null) {\n        throw CantRunException.noJdkConfigured();\n      }\n      setJdk(jdk);\n    }\n\n    if ((classPathType & CLASSES_ONLY) == 0) {\n      return;\n    }\n\n    configureJdkAccordingToJreSelected(getJdk());\n    configureEnumerator(OrderEnumerator.orderEntries(project).runtimeOnly().withoutSdk(), classPathType).collectPaths(getClassPath());\n  }","id":60738,"modified_method":"public void configureByProject(final Project project, final int classPathType, final Sdk jdk) throws CantRunException {\n    if ((classPathType & JDK_ONLY) != 0) {\n      if (jdk == null) {\n        throw CantRunException.noJdkConfigured();\n      }\n      setJdk(jdk);\n    }\n\n    if ((classPathType & CLASSES_ONLY) == 0) {\n      return;\n    }\n    final PairFunction<OrderEntry, OrderRootType, VirtualFile[]> substitutor = computeSubstitutor(classPathType, jdk);\n    configureEnumerator(OrderEnumerator.orderEntries(project).runtimeOnly().substituteFiles(substitutor), classPathType).classes().collectPaths(getClassPath());\n  }","commit_id":"2b3f7eb255504a5983596cf1d97d7341af96947a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void configureByModule(final Module module, final int classPathType, final Sdk jdk) throws CantRunException {\n    if ((classPathType & JDK_ONLY) != 0) {\n      if (jdk == null) {\n        throw CantRunException.noJdkConfigured();\n      }\n      setJdk(jdk);\n    }\n\n    if ((classPathType & CLASSES_ONLY) == 0) {\n      return;\n    }\n\n    setDefaultCharset(module.getProject());\n    configureJdkAccordingToJreSelected(jdk);\n    configureEnumerator(OrderEnumerator.orderEntries(module).runtimeOnly().recursively().withoutSdk(), classPathType).collectPaths(getClassPath());\n  }","id":60739,"modified_method":"public void configureByModule(final Module module, final int classPathType, final Sdk jdk) throws CantRunException {\n    if ((classPathType & JDK_ONLY) != 0) {\n      if (jdk == null) {\n        throw CantRunException.noJdkConfigured();\n      }\n      setJdk(jdk);\n    }\n\n    if ((classPathType & CLASSES_ONLY) == 0) {\n      return;\n    }\n\n    setDefaultCharset(module.getProject());\n    final PairFunction<OrderEntry, OrderRootType, VirtualFile[]> substitutor = computeSubstitutor(classPathType, jdk);\n    configureEnumerator(OrderEnumerator.orderEntries(module).runtimeOnly().recursively().substituteFiles(substitutor)\n      , classPathType).classes().collectPaths(getClassPath());\n  }","commit_id":"2b3f7eb255504a5983596cf1d97d7341af96947a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Collection<VirtualFile> computeRoots() {\n    final Collection<VirtualFile> result = new LinkedHashSet<VirtualFile>();\n    myOrderEnumerator.forEach(new Processor<OrderEntry>() {\n      @Override\n      public boolean process(OrderEntry orderEntry) {\n        if (orderEntry instanceof ModuleSourceOrderEntry) {\n          collectModuleRoots(((ModuleSourceOrderEntry)orderEntry).getRootModel(), result);\n        }\n        else if (orderEntry instanceof ModuleOrderEntry) {\n          ModuleOrderEntry moduleOrderEntry = (ModuleOrderEntry)orderEntry;\n          final Module module = moduleOrderEntry.getModule();\n          if (module != null) {\n            if (myOrderEnumerator.addCustomOutput(moduleOrderEntry, result)) {\n              return true;\n            }\n            collectModuleRoots(myOrderEnumerator.getRootModel(module), result);\n          }\n        }\n        else {\n          Collections.addAll(result, orderEntry.getFiles(myRootType));\n        }\n        return true;\n      }\n    });\n    return result;\n  }","id":60740,"modified_method":"private Collection<VirtualFile> computeRoots() {\n    final Collection<VirtualFile> result = new LinkedHashSet<VirtualFile>();\n    myOrderEnumerator.forEach(new Processor<OrderEntry>() {\n      @Override\n      public boolean process(OrderEntry orderEntry) {\n        if (orderEntry instanceof ModuleSourceOrderEntry) {\n          collectModuleRoots(((ModuleSourceOrderEntry)orderEntry).getRootModel(), result);\n        }\n        else if (orderEntry instanceof ModuleOrderEntry) {\n          ModuleOrderEntry moduleOrderEntry = (ModuleOrderEntry)orderEntry;\n          final Module module = moduleOrderEntry.getModule();\n          if (module != null) {\n            if (myOrderEnumerator.addCustomOutput(moduleOrderEntry, result)) {\n              return true;\n            }\n            collectModuleRoots(myOrderEnumerator.getRootModel(module), result);\n          }\n        }\n        else {\n          Collections.addAll(result, myOrderEnumerator.substituteFiles(orderEntry, myRootType));\n        }\n        return true;\n      }\n    });\n    return result;\n  }","commit_id":"2b3f7eb255504a5983596cf1d97d7341af96947a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Collection<String> computeRootsUrls() {\n    final Collection<String> result = new LinkedHashSet<String>();\n    myOrderEnumerator.forEach(new Processor<OrderEntry>() {\n      @Override\n      public boolean process(OrderEntry orderEntry) {\n        if (orderEntry instanceof ModuleSourceOrderEntry) {\n          collectModuleRootsUrls(((ModuleSourceOrderEntry)orderEntry).getRootModel(), result);\n        }\n        else if (orderEntry instanceof ModuleOrderEntry) {\n          ModuleOrderEntry moduleOrderEntry = (ModuleOrderEntry)orderEntry;\n          final Module module = moduleOrderEntry.getModule();\n          if (module != null) {\n            if (myOrderEnumerator.addCustomOutputUrls(moduleOrderEntry, result)) {\n              return true;\n            }\n            collectModuleRootsUrls(myOrderEnumerator.getRootModel(module), result);\n          }\n        }\n        else {\n          Collections.addAll(result, orderEntry.getUrls(myRootType));\n        }\n        return true;\n      }\n    });\n    return result;\n  }","id":60741,"modified_method":"private Collection<String> computeRootsUrls() {\n    final Collection<String> result = new LinkedHashSet<String>();\n    myOrderEnumerator.forEach(new Processor<OrderEntry>() {\n      @Override\n      public boolean process(OrderEntry orderEntry) {\n        if (orderEntry instanceof ModuleSourceOrderEntry) {\n          collectModuleRootsUrls(((ModuleSourceOrderEntry)orderEntry).getRootModel(), result);\n        }\n        else if (orderEntry instanceof ModuleOrderEntry) {\n          ModuleOrderEntry moduleOrderEntry = (ModuleOrderEntry)orderEntry;\n          final Module module = moduleOrderEntry.getModule();\n          if (module != null) {\n            if (myOrderEnumerator.addCustomOutputUrls(moduleOrderEntry, result)) {\n              return true;\n            }\n            collectModuleRootsUrls(myOrderEnumerator.getRootModel(module), result);\n          }\n        }\n        else {\n          Collections.addAll(result, myOrderEnumerator.substituteUrls(orderEntry, myRootType));\n        }\n        return true;\n      }\n    });\n    return result;\n  }","commit_id":"2b3f7eb255504a5983596cf1d97d7341af96947a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public IScope getScope(final EObject context, final EClass type) {\n\t\tif (context == null)\n\t\t\treturn getGlobalScope(type);\n\t\tIScope result = getScope(context.eContainer(), type);\n\t\tif (nameProvider.getQualifiedName(context) != null)\n\t\t\tresult = new SimpleScope(result, getLocalElements(context, type));\n\t\tIterable<IScopedElement> importedElements = getImportedElements(result, context, type);\n\t\tif (importedElements != null)\n\t\t\treturn new SimpleScope(result, importedElements);\n\t\treturn result;\n\t}","id":60742,"modified_method":"public IScope getScope(final EObject context, final EClass type) {\n\t\t// global scope\n\t\tif (context == null)\n\t\t\treturn getGlobalScope(type);\n\t\t\n\t\t// outer scope\n\t\tIScope result = getScope(context.eContainer(), type);\n\t\t\n\t\tIScope importScopeConfiguration = result;\n\t\t// local scope used by the import scope\n\t\tif (nameProvider.getQualifiedName(context) != null) {\n\t\t\tIterable<IScopedElement> localElements = getLocalElements(context, type);\n\t\t\timportScopeConfiguration = new SimpleScope(result, localElements);\n\t\t}\n\t\t// imports\n\t\tIterable<IScopedElement> importedElements = getImportedElements(importScopeConfiguration, context, type);\n\t\tif (importedElements != null) {\n\t\t\tresult = new SimpleScope(result, importedElements);\n\t\t}\n\t\t// local scope\n\t\tif (nameProvider.getQualifiedName(context) != null) {\n\t\t\tIterable<IScopedElement> localElements = getLocalElements(context, type);\n\t\t\tresult = new SimpleScope(result, localElements);\n\t\t}\n\t\treturn result;\n\t}","commit_id":"f95c54611f5d5c9e0194dbbcc9504d8150210697","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testReexports() throws Exception {\n\t\tfinal XtextResource resource = getResource(new StringInputStream(\n\t\t\t\t\"stuff { \" +\n\t\t\t\t\"  import baz.*\" +\n\t\t\t\t\"  baz { \" +\n\t\t\t\t\"    stuff {\" +\n\t\t\t\t\"      import stuff.*\" +\n\t\t\t\t\"      datatype String \" +\n\t\t\t\t\"    }\" +\n\t\t\t\t\"    entity Person {}\" +\n\t\t\t\t\"  }\" +\n\t\t\"}\"), URI.createURI(\"relative.indextestlanguage\"));\n\t\tIndexFeederImpl feeder = new IndexFeederImpl(store);\n\t\tindexer.resourceChanged(resource, feeder);\n\t\tfeeder.commit();\n\t\tIterable<EObject> allContents = new Iterable<EObject>() {\n\t\t\tpublic Iterator<EObject> iterator() {\n\t\t\t\treturn resource.getAllContents();\n\t\t\t}\n\t\t};\n\t\tDatatype datatype = filter(allContents, Datatype.class).iterator().next();\n\t\t\n\t\t// dataype String\n\t\tIScope scope = scopeProvider.getScope(datatype, IndexTestLanguagePackage.eINSTANCE.getEntity());\n\t\tList<String> names = toListOfNames(scope.getContents());\n\t\tassertEquals(names.toString(), 0, names.size());\n\t\t\n\t\tscope = scope.getOuterScope(); // import stuff.*\n\t\tnames = toListOfNames(scope.getContents());\n\t\tassertEquals(names.toString(), 1, names.size());\n\t\tassertTrue(names.toString(),names.contains(\"baz.Person\"));\n\t\t\n\t\tscope = scope.getOuterScope(); // stuff {\n\t\tnames = toListOfNames(scope.getContents());\n\t\tassertEquals(names.toString(), 0, names.size());\n\t\t\n\t\tscope = scope.getOuterScope(); // baz {\n\t\tnames = toListOfNames(scope.getContents());\n\t\tassertEquals(names.toString(), 1, names.size());\n\t\tassertTrue(names.contains(\"Person\"));\n\t\t\n\t\tscope = scope.getOuterScope(); // import baz.*\n\t\tnames = toListOfNames(scope.getContents());\n\t\tassertEquals(names.toString(), 1, names.size());\n\t\tassertTrue(names.contains(\"Person\"));\n\t\t\n\t\tscope = scope.getOuterScope(); // stuff {\n\t\tnames = toListOfNames(scope.getContents());\n\t\tassertEquals(names.toString(), 1, names.size());\n\t\tassertTrue(names.contains(\"baz.Person\"));\n\t\t\n\t\tscope = scope.getOuterScope(); // global scope\n\t\tnames = toListOfNames(scope.getContents());\n\t\tassertEquals(names.toString(), 1, names.size());\n\t\tassertTrue(names.contains(\"stuff.baz.Person\"));\n\t\t\n\t\tassertEquals(IScope.NULLSCOPE, scope.getOuterScope());\n\t\t\n\t}","id":60743,"modified_method":"public void testReexports() throws Exception {\n\t\tfinal XtextResource resource = getResource(new StringInputStream(\n\t\t\t\t\"stuff { \" +\n\t\t\t\t\"  import baz.*\" +\n\t\t\t\t\"  baz { \" +\n\t\t\t\t\"    stuff {\" +\n\t\t\t\t\"      import stuff.*\" +\n\t\t\t\t\"      datatype String \" +\n\t\t\t\t\"    }\" +\n\t\t\t\t\"    entity Person {}\" +\n\t\t\t\t\"  }\" +\n\t\t\"}\"), URI.createURI(\"relative.indextestlanguage\"));\n\t\tIndexFeederImpl feeder = new IndexFeederImpl(store);\n\t\tindexer.resourceChanged(resource, feeder);\n\t\tfeeder.commit();\n\t\tIterable<EObject> allContents = new Iterable<EObject>() {\n\t\t\tpublic Iterator<EObject> iterator() {\n\t\t\t\treturn resource.getAllContents();\n\t\t\t}\n\t\t};\n\t\tDatatype datatype = filter(allContents, Datatype.class).iterator().next();\n\t\t\n\t\t// datatype String\n\t\tIScope scope = scopeProvider.getScope(datatype, IndexTestLanguagePackage.eINSTANCE.getEntity());\n\t\tList<String> names = toListOfNames(scope.getContents());\n\t\tassertEquals(names.toString(), 0, names.size());\n\t\t\n\t\tscope = scope.getOuterScope(); // stuff {\n\t\tnames = toListOfNames(scope.getContents());\n\t\tassertEquals(names.toString(), 0, names.size());\n\n\t\tscope = scope.getOuterScope(); // import stuff.*\n\t\tnames = toListOfNames(scope.getContents());\n\t\tassertEquals(names.toString(), 1, names.size());\n\t\tassertTrue(names.toString(),names.contains(\"baz.Person\"));\n\t\t\n\t\tscope = scope.getOuterScope(); // baz {\n\t\tnames = toListOfNames(scope.getContents());\n\t\tassertEquals(names.toString(), 1, names.size());\n\t\tassertTrue(names.toString(), names.contains(\"Person\"));\n\n\t\tscope = scope.getOuterScope(); // stuff {\n\t\tnames = toListOfNames(scope.getContents());\n\t\tassertEquals(names.toString(), 1, names.size());\n\t\tassertTrue(names.contains(\"baz.Person\"));\n\n\t\tscope = scope.getOuterScope(); // import baz.*\n\t\tnames = toListOfNames(scope.getContents());\n\t\tassertEquals(names.toString(), 1, names.size());\n\t\tassertTrue(names.contains(\"Person\"));\n\t\t\n\t\tscope = scope.getOuterScope(); // global scope\n\t\tnames = toListOfNames(scope.getContents());\n\t\tassertEquals(names.toString(), 1, names.size());\n\t\tassertTrue(names.contains(\"stuff.baz.Person\"));\n\t\t\n\t\tassertEquals(IScope.NULLSCOPE, scope.getOuterScope());\n\t\t\n\t}","commit_id":"f95c54611f5d5c9e0194dbbcc9504d8150210697","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * @param result\n\t * @param context\n\t * @param type\n\t * @return\n\t */\n\tprivate IScope getResourceScope(IScope parent, final EObject context, final EClass type) {\n\t\tIterable<EObject> eObjects = new Iterable<EObject>() {\n\t\t\tpublic Iterator<EObject> iterator() {\n\t\t\t\treturn EcoreUtil.getAllProperContents(context.eResource(), true);\n\t\t\t}\n\t\t};\n\t\teObjects = filter(eObjects, new Predicate<EObject>() {\n\n\t\t\tpublic boolean apply(EObject input) {\n\t\t\t\treturn type.isInstance(input);\n\t\t\t}\n\t\t});\n\n\t\tIterable<IScopedElement> result = transform(eObjects, new Function<EObject, IScopedElement>() {\n\n\t\t\tpublic IScopedElement apply(EObject from) {\n\t\t\t\tString qualifiedName = nameProvider.getQualifiedName(from);\n\t\t\t\tif (qualifiedName != null) {\n\t\t\t\t\treturn ScopedElement.create(qualifiedName, from);\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t});\n\t\treturn new SimpleScope(parent, filter(result, Predicates.notNull()));\n\t}","id":60744,"modified_method":"protected IScope getResourceScope(IScope parent, final EObject context, final EClass type) {\n\t\tif (context.eResource()==null)\n\t\t\treturn parent;\n\t\tIterable<EObject> contents = new Iterable<EObject>() {\n\t\t\tpublic Iterator<EObject> iterator() {\n\t\t\t\treturn EcoreUtil.getAllProperContents(context.eResource(), true);\n\t\t\t}\n\t\t};\n\t\treturn createScopeWithQualifiedNames(parent, type, contents);\n\t}","commit_id":"dc337c15d762e6a0f31b374e8aa7b4123ceb7483","url":"https://github.com/eclipse/xtext"},{"original_method":"@SuppressWarnings(\"unchecked\")\n\tprivate Iterable<IScopedElement> getLocalElements(final EObject context, final EClass type) {\n\t\tfinal String commonPrefix = nameProvider.getQualifiedName(context) + nameProvider.getDelimiter();\n\t\tIterable<? extends EObject> contents = new Iterable<? extends EObject>() {\n\n\t\t\tpublic Iterator<? extends EObject> iterator() {\n\t\t\t\treturn (Iterator<? extends EObject>) EcoreUtil.getAllProperContents(context, true);\n\t\t\t}\n\n\t\t};\n\t\t// filter by type\n\t\tcontents = filter(contents, new Predicate<EObject>() {\n\n\t\t\tpublic boolean apply(EObject input) {\n\t\t\t\treturn type.isInstance(input);\n\t\t\t}\n\t\t});\n\t\t// transform to IScopedElements\n\t\tIterable<IScopedElement> scopedElements = transform(contents, new Function<EObject, IScopedElement>() {\n\n\t\t\tpublic IScopedElement apply(EObject from) {\n\t\t\t\tString name = nameProvider.getQualifiedName(from);\n\t\t\t\tif (name != null && name.startsWith(commonPrefix))\n\t\t\t\t\treturn ScopedElement.create(name.substring(commonPrefix.length()), from);\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t});\n\t\t// filter null values;\n\t\treturn filter(scopedElements, Predicates.notNull());\n\t}","id":60745,"modified_method":"protected IScope getLocalElements(IScope parent, final EObject context, final EClass type) {\n\t\tfinal String commonPrefix = nameProvider.getQualifiedName(context) + nameProvider.getDelimiter();\n\t\t\n\t\tIterable<EObject> contents = new Iterable<EObject>() {\n\t\t\tpublic Iterator<EObject> iterator() {\n\t\t\t\treturn EcoreUtil.getAllProperContents(context, true);\n\t\t\t}\n\t\t};\n\t\t// filter by type\n\t\tcontents = filter(contents, typeFilter(type));\n\t\t// transform to IScopedElements\n\t\tIterable<IScopedElement> scopedElements = Scopes.scopedElementsFor(contents,new Function<EObject, String>() {\n\t\t\tpublic String apply(EObject from) {\n\t\t\t\tString name = nameProvider.getQualifiedName(from);\n\t\t\t\tif (name != null && name.startsWith(commonPrefix))\n\t\t\t\t\treturn name.substring(commonPrefix.length());\n\t\t\t\treturn null;\n\t\t\t}\n\t\t});\n\t\t// filter null values;\n\t\treturn new SimpleScope(parent,filter(scopedElements, Predicates.notNull()));\n\t}","commit_id":"dc337c15d762e6a0f31b374e8aa7b4123ceb7483","url":"https://github.com/eclipse/xtext"},{"original_method":"public IScope getScope(final EObject context, final EClass type) {\n\t\tIScope result = null;\n\t\tif (context == null)\n\t\t\treturn getGlobalScope(null, type);\n\t\tif (context.eContainer() == null) {\n\t\t\t// global scope\n\t\t\tresult = getGlobalScope(context, type);\n\t\t\tresult = getResourceScope(result, context, type);\n\t\t}\n\t\telse {\n\t\t\t// outer scope\n\t\t\tresult = getScope(context.eContainer(), type);\n\t\t}\n\n\t\tIScope importScopeConfiguration = result;\n\t\t// local scope used by the import scope\n\t\tif (nameProvider.getQualifiedName(context) != null) {\n\t\t\tIterable<IScopedElement> localElements = getLocalElements(context, type);\n\t\t\timportScopeConfiguration = new SimpleScope(result, localElements);\n\t\t}\n\t\t// imports\n\t\tIterable<IScopedElement> importedElements = getImportedElements(importScopeConfiguration, context, type);\n\t\tif (importedElements != null) {\n\t\t\tresult = new SimpleScope(result, importedElements);\n\t\t}\n\t\t// local scope\n\t\tif (nameProvider.getQualifiedName(context) != null) {\n\t\t\tIterable<IScopedElement> localElements = getLocalElements(context, type);\n\t\t\tresult = new SimpleScope(result, localElements);\n\t\t}\n\t\treturn result;\n\t}","id":60746,"modified_method":"public IScope getScope(final EObject context, final EClass type) {\n\t\tif (context == null)\n\t\t\treturn getGlobalScope(null, type);\n\t\tIScope result = null;\n\t\tif (context.eContainer() == null) {\n\t\t\t// global scope\n\t\t\tresult = getGlobalScope(context, type);\n\t\t\tresult = getResourceSetScope(result,context, type);\n\t\t\tresult = getResourceScope(result, context, type);\n\t\t} else {\n\t\t\t// outer scope\n\t\t\tresult = getScope(context.eContainer(), type);\n\t\t}\n\n\t\tIScope importScopeConfiguration = result;\n\t\t// local scope used by the import scope\n\t\tif (nameProvider.getQualifiedName(context) != null) {\n\t\t\timportScopeConfiguration = getLocalElements(result, context, type);\n\t\t}\n\t\t// imports\n\t\tIterable<IScopedElement> importedElements = getImportedElements(importScopeConfiguration, context, type);\n\t\tif (importedElements != null) {\n\t\t\tresult = new SimpleScope(result, importedElements);\n\t\t}\n\t\t// local scope\n\t\tif (nameProvider.getQualifiedName(context) != null) {\n\t\t\tresult = getLocalElements(result, context, type);\n\t\t}\n\t\treturn result;\n\t}","commit_id":"dc337c15d762e6a0f31b374e8aa7b4123ceb7483","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void addCovariantMethods(ClassNode classNode) {\n        Map methodsToAdd = new HashMap();\n        Map genericsSpec = new HashMap();\n\n        // unimplemented abstract methods from interfaces\n        Map abstractMethods = new HashMap();\n        Map<String, MethodNode> allInterfaceMethods = new HashMap<String, MethodNode>();\n        ClassNode[] interfaces = classNode.getInterfaces();\n        for (int i = 0; i < interfaces.length; i++) {\n            ClassNode iface = interfaces[i];\n            Map ifaceMethodsMap = iface.getDeclaredMethodsMap();\n            abstractMethods.putAll(ifaceMethodsMap);\n            allInterfaceMethods.putAll(ifaceMethodsMap);\n        }\n        \n        collectSuperInterfaceMethods(classNode, allInterfaceMethods);\n        \n        List declaredMethods = new ArrayList(classNode.getMethods());\n        // remove all static, private and package private methods\n        for (Iterator methodsIterator = declaredMethods.iterator(); methodsIterator.hasNext();) {\n            MethodNode m = (MethodNode) methodsIterator.next();\n            abstractMethods.remove(m.getTypeDescriptor());\n            if (m.isStatic() || !(m.isPublic() || m.isProtected())) {\n                methodsIterator.remove();\n            }\n            MethodNode intfMethod = allInterfaceMethods.get(m.getTypeDescriptor());\n            if(intfMethod != null && ((m.getModifiers() & ACC_SYNTHETIC) == 0) \n                    && !m.isPublic() && !m.isStaticConstructor()) {\n                throw new RuntimeParserException(\"The method \" + m.getName() +\n                        \" should be public as it implements the corresponding method from interface \" + \n                        intfMethod.getDeclaringClass(), m);\n                \n            }\n        }\n        \n        addCovariantMethods(classNode, declaredMethods, abstractMethods, methodsToAdd, genericsSpec);\n\n        Map declaredMethodsMap = new HashMap();\n        if (methodsToAdd.size()>0) {\n            for (Iterator methodsIterator = declaredMethods.iterator(); methodsIterator.hasNext();) {\n                MethodNode m = (MethodNode) methodsIterator.next();\n                declaredMethodsMap.put(m.getTypeDescriptor(),m);\n            }\n        }\n        \n        for (Iterator it = methodsToAdd.entrySet().iterator(); it.hasNext();) {\n            Map.Entry entry = (Map.Entry) it.next();\n            MethodNode method = (MethodNode) entry.getValue();\n            // we skip bridge methods implemented in current class already\n            MethodNode mn = (MethodNode) declaredMethodsMap.get(entry.getKey());\n            if (mn!=null && mn.getDeclaringClass().equals(classNode)) continue;\n            addPropertyMethod(method);\n        }\n    }","id":60747,"modified_method":"protected void addCovariantMethods(ClassNode classNode) {\n        Map methodsToAdd = new HashMap();\n        Map genericsSpec = new HashMap();\n\n        // unimplemented abstract methods from interfaces\n        Map abstractMethods = new HashMap();\n        Map<String, MethodNode> allInterfaceMethods = new HashMap<String, MethodNode>();\n        ClassNode[] interfaces = classNode.getInterfaces();\n        for (ClassNode iface : interfaces) {\n            Map ifaceMethodsMap = iface.getDeclaredMethodsMap();\n            abstractMethods.putAll(ifaceMethodsMap);\n            allInterfaceMethods.putAll(ifaceMethodsMap);\n        }\n\n        collectSuperInterfaceMethods(classNode, allInterfaceMethods);\n\n        List<MethodNode> declaredMethods = new ArrayList<MethodNode>(classNode.getMethods());\n        // remove all static, private and package private methods\n        for (Iterator methodsIterator = declaredMethods.iterator(); methodsIterator.hasNext();) {\n            MethodNode m = (MethodNode) methodsIterator.next();\n            abstractMethods.remove(m.getTypeDescriptor());\n            if (m.isStatic() || !(m.isPublic() || m.isProtected())) {\n                methodsIterator.remove();\n            }\n            MethodNode intfMethod = allInterfaceMethods.get(m.getTypeDescriptor());\n            if (intfMethod != null && ((m.getModifiers() & ACC_SYNTHETIC) == 0)\n                    && !m.isPublic() && !m.isStaticConstructor()) {\n                throw new RuntimeParserException(\"The method \" + m.getName() +\n                        \" should be public as it implements the corresponding method from interface \" +\n                        intfMethod.getDeclaringClass(), m);\n\n            }\n        }\n\n        addCovariantMethods(classNode, declaredMethods, abstractMethods, methodsToAdd, genericsSpec);\n\n        Map<String, MethodNode> declaredMethodsMap = new HashMap<String, MethodNode>();\n        if (methodsToAdd.size() > 0) {\n            for (MethodNode mn : declaredMethods) {\n                declaredMethodsMap.put(mn.getTypeDescriptor(), mn);\n            }\n        }\n\n        for (Object o : methodsToAdd.entrySet()) {\n            Map.Entry entry = (Map.Entry) o;\n            MethodNode method = (MethodNode) entry.getValue();\n            // we skip bridge methods implemented in current class already\n            MethodNode mn = declaredMethodsMap.get(entry.getKey());\n            if (mn != null && mn.getDeclaringClass().equals(classNode)) continue;\n            addPropertyMethod(method);\n        }\n    }","commit_id":"825b7111a2a029e395ab6701a1bdfd4bd77b9c1a","url":"https://github.com/apache/groovy"},{"original_method":"private void storeMissingCovariantMethods(Collection methods, MethodNode method, Map methodsToAdd, Map genericsSpec) {\n        for (Iterator sit = methods.iterator(); sit.hasNext();) {\n            MethodNode toOverride = (MethodNode) sit.next();\n            MethodNode bridgeMethod = getCovariantImplementation(toOverride,method,genericsSpec);\n            if (bridgeMethod==null) continue;\n            methodsToAdd.put (bridgeMethod.getTypeDescriptor(),bridgeMethod);\n            return;\n        }\n    }","id":60748,"modified_method":"private void storeMissingCovariantMethods(Collection methods, MethodNode method, Map methodsToAdd, Map genericsSpec) {\n        for (Object method1 : methods) {\n            MethodNode toOverride = (MethodNode) method1;\n            MethodNode bridgeMethod = getCovariantImplementation(toOverride, method, genericsSpec);\n            if (bridgeMethod == null) continue;\n            methodsToAdd.put(bridgeMethod.getTypeDescriptor(), bridgeMethod);\n            return;\n        }\n    }","commit_id":"825b7111a2a029e395ab6701a1bdfd4bd77b9c1a","url":"https://github.com/apache/groovy"},{"original_method":"private void addCovariantMethods(ClassNode classNode, List declaredMethods, Map abstractMethods, Map methodsToAdd, Map oldGenericsSpec) {\n        ClassNode sn = classNode.getUnresolvedSuperClass(false);\n        \n        if (sn!=null) {\n            Map genericsSpec = createGenericsSpec(sn,oldGenericsSpec);\n            List classMethods = sn.getMethods();\n            // original class causing bridge methods for methods in super class\n            for (Iterator it = declaredMethods.iterator(); it.hasNext();) {\n                MethodNode method = (MethodNode) it.next();\n                if (method.isStatic()) continue;\n                storeMissingCovariantMethods(classMethods,method,methodsToAdd,genericsSpec);\n            }\n            // super class causing bridge methods for abstract methods in original class\n            if (!abstractMethods.isEmpty()) {\n                for (Iterator it = classMethods.iterator(); it.hasNext();) {\n                    MethodNode method = (MethodNode) it.next();\n                    if (method.isStatic()) continue;\n                    storeMissingCovariantMethods(abstractMethods.values(),method,methodsToAdd,Collections.EMPTY_MAP);\n                }\n            }\n            \n            addCovariantMethods(sn.redirect(),declaredMethods,abstractMethods,methodsToAdd,genericsSpec);\n        }\n        \n        ClassNode[] interfaces = classNode.getInterfaces();\n        for (int i=0; i<interfaces.length; i++) {\n            List interfacesMethods = interfaces[i].getMethods();\n            Map genericsSpec = createGenericsSpec(interfaces[i],oldGenericsSpec);\n            for (Iterator it = declaredMethods.iterator(); it.hasNext();) {\n                MethodNode method = (MethodNode) it.next();\n                if (method.isStatic()) continue;\n                storeMissingCovariantMethods(interfacesMethods,method,methodsToAdd,genericsSpec);\n            }\n            addCovariantMethods(interfaces[i],declaredMethods,abstractMethods,methodsToAdd,genericsSpec);\n        }\n        \n    }","id":60749,"modified_method":"private void addCovariantMethods(ClassNode classNode, List declaredMethods, Map abstractMethods, Map methodsToAdd, Map oldGenericsSpec) {\n        ClassNode sn = classNode.getUnresolvedSuperClass(false);\n\n        if (sn != null) {\n            Map genericsSpec = createGenericsSpec(sn, oldGenericsSpec);\n            List<MethodNode> classMethods = sn.getMethods();\n            // original class causing bridge methods for methods in super class\n            for (Object declaredMethod : declaredMethods) {\n                MethodNode method = (MethodNode) declaredMethod;\n                if (method.isStatic()) continue;\n                storeMissingCovariantMethods(classMethods, method, methodsToAdd, genericsSpec);\n            }\n            // super class causing bridge methods for abstract methods in original class\n            if (!abstractMethods.isEmpty()) {\n                for (Object classMethod : classMethods) {\n                    MethodNode method = (MethodNode) classMethod;\n                    if (method.isStatic()) continue;\n                    storeMissingCovariantMethods(abstractMethods.values(), method, methodsToAdd, Collections.EMPTY_MAP);\n                }\n            }\n\n            addCovariantMethods(sn.redirect(), declaredMethods, abstractMethods, methodsToAdd, genericsSpec);\n        }\n\n        ClassNode[] interfaces = classNode.getInterfaces();\n        for (ClassNode anInterface : interfaces) {\n            List interfacesMethods = anInterface.getMethods();\n            Map genericsSpec = createGenericsSpec(anInterface, oldGenericsSpec);\n            for (Object declaredMethod : declaredMethods) {\n                MethodNode method = (MethodNode) declaredMethod;\n                if (method.isStatic()) continue;\n                storeMissingCovariantMethods(interfacesMethods, method, methodsToAdd, genericsSpec);\n            }\n            addCovariantMethods(anInterface, declaredMethods, abstractMethods, methodsToAdd, genericsSpec);\n        }\n\n    }","commit_id":"825b7111a2a029e395ab6701a1bdfd4bd77b9c1a","url":"https://github.com/apache/groovy"},{"original_method":"/**\n     * add code to implement GroovyObject\n     * @param node\n     */\n    public void visitClass(final ClassNode node) {\n        this.classNode = node;\n\n        if ((classNode.getModifiers() & Opcodes.ACC_INTERFACE) >0) {\n            //interfaces have no constructors, but this code expects one,\n            //so create a dummy and don't add it to the class node\n            ConstructorNode dummy = new ConstructorNode(0,null);\n            addInitialization(node, dummy);\n            node.visitContents(this);\n            return;\n        }\n\n        ClassNode[] classNodes = classNode.getInterfaces();\n        List interfaces = new ArrayList();\n        for (int i = 0; i < classNodes.length; i++) {\n            ClassNode classNode = classNodes[i];\n            interfaces.add(classNode.getName());\n        }\n        Set interfaceSet = new HashSet(interfaces);\n        if (interfaceSet.size() != interfaces.size()) {\n            throw new RuntimeParserException(\"Duplicate interfaces in implements list: \" + interfaces, classNode);\n        }\n\n        addDefaultParameterMethods(node);\n        addDefaultParameterConstructors(node);\n\n        final String classInternalName = BytecodeHelper.getClassInternalName(node);\n\n        addStaticMetaClassField(node,classInternalName);\n\n        boolean knownSpecialCase =\n                node.isDerivedFrom(ClassHelper.GSTRING_TYPE)\n                        || node.isDerivedFrom(ClassHelper.make(GroovyObjectSupport.class));\n\n        if (!knownSpecialCase) addGroovyObjectInterfaceAndMethods(node,classInternalName);\n\n        addDefaultConstructor(node);\n\n        // add a static timestamp field to the class\n        if (!(node instanceof InnerClassNode)) addTimeStamp(node);\n\n        addInitialization(node);\n        checkReturnInObjectInitializer(node.getObjectInitializerStatements());\n        node.getObjectInitializerStatements().clear();\n        addCovariantMethods(node);\n        node.visitContents(this);\n    }","id":60750,"modified_method":"/**\n     * add code to implement GroovyObject\n     *\n     * @param node\n     */\n    public void visitClass(final ClassNode node) {\n        this.classNode = node;\n\n        if ((classNode.getModifiers() & Opcodes.ACC_INTERFACE) > 0) {\n            //interfaces have no constructors, but this code expects one,\n            //so create a dummy and don't add it to the class node\n            ConstructorNode dummy = new ConstructorNode(0, null);\n            addInitialization(node, dummy);\n            node.visitContents(this);\n            return;\n        }\n\n        ClassNode[] classNodes = classNode.getInterfaces();\n        List<String> interfaces = new ArrayList<String>();\n        for (ClassNode classNode : classNodes) {\n            interfaces.add(classNode.getName());\n        }\n        Set<String> interfaceSet = new HashSet<String>(interfaces);\n        if (interfaceSet.size() != interfaces.size()) {\n            throw new RuntimeParserException(\"Duplicate interfaces in implements list: \" + interfaces, classNode);\n        }\n\n        addDefaultParameterMethods(node);\n        addDefaultParameterConstructors(node);\n\n        final String classInternalName = BytecodeHelper.getClassInternalName(node);\n\n        addStaticMetaClassField(node, classInternalName);\n\n        boolean knownSpecialCase =\n                node.isDerivedFrom(ClassHelper.GSTRING_TYPE)\n                        || node.isDerivedFrom(ClassHelper.make(GroovyObjectSupport.class));\n\n        if (!knownSpecialCase) addGroovyObjectInterfaceAndMethods(node, classInternalName);\n\n        addDefaultConstructor(node);\n\n        // add a static timestamp field to the class\n        if (!(node instanceof InnerClassNode)) addTimeStamp(node);\n\n        addInitialization(node);\n        checkReturnInObjectInitializer(node.getObjectInitializerStatements());\n        node.getObjectInitializerStatements().clear();\n        addCovariantMethods(node);\n        node.visitContents(this);\n    }","commit_id":"825b7111a2a029e395ab6701a1bdfd4bd77b9c1a","url":"https://github.com/apache/groovy"},{"original_method":"protected void addDefaultParameters(DefaultArgsAction action, MethodNode method) {\n        Parameter[] parameters = method.getParameters();\n        int counter = 0;\n        List paramValues = new ArrayList();\n        int size = parameters.length;\n        for (int i = size - 1; i >= 0; i--) {\n            Parameter parameter = parameters[i];\n            if (parameter != null && parameter.hasInitialExpression()) {\n                paramValues.add(Integer.valueOf(i));\n                paramValues.add(\n                        new CastExpression(\n                                parameter.getType(),\n                                parameter.getInitialExpression()\n                        )\n                );\n                counter++;\n            }\n        }\n\n        for (int j = 1; j <= counter; j++) {\n            Parameter[] newParams =  new Parameter[parameters.length - j];\n            ArgumentListExpression arguments = new ArgumentListExpression();\n            int index = 0;\n            int k = 1;\n            for (int i = 0; i < parameters.length; i++) {\n                if (k > counter - j && parameters[i] != null && parameters[i].hasInitialExpression()) {\n                    arguments.addExpression(\n                            new CastExpression(\n                                    parameters[i].getType(),\n                                    parameters[i].getInitialExpression()\n                            )\n                    );\n                    k++;\n                }\n                else if (parameters[i] != null && parameters[i].hasInitialExpression()) {\n                    newParams[index++] = parameters[i];\n                    arguments.addExpression(\n                            new CastExpression(\n                                    parameters[i].getType(),\n                                    new VariableExpression(parameters[i].getName())\n                            )\n                    );\n                    k++;\n                }\n                else {\n                    newParams[index++] = parameters[i];\n                    arguments.addExpression(\n                            new CastExpression(\n                                    parameters[i].getType(),\n                                    new VariableExpression(parameters[i].getName())\n                            )\n                    );\n                }\n            }\n            action.call(arguments,newParams,method);\n        }\n\n        for (int i = 0; i < parameters.length; i++) {\n            // remove default expression\n            parameters[i].setInitialExpression(null);\n        }\n    }","id":60751,"modified_method":"protected void addDefaultParameters(DefaultArgsAction action, MethodNode method) {\n        Parameter[] parameters = method.getParameters();\n        int counter = 0;\n        List paramValues = new ArrayList();\n        int size = parameters.length;\n        for (int i = size - 1; i >= 0; i--) {\n            Parameter parameter = parameters[i];\n            if (parameter != null && parameter.hasInitialExpression()) {\n                paramValues.add(Integer.valueOf(i));\n                paramValues.add(\n                        new CastExpression(\n                                parameter.getType(),\n                                parameter.getInitialExpression()\n                        )\n                );\n                counter++;\n            }\n        }\n\n        for (int j = 1; j <= counter; j++) {\n            Parameter[] newParams = new Parameter[parameters.length - j];\n            ArgumentListExpression arguments = new ArgumentListExpression();\n            int index = 0;\n            int k = 1;\n            for (int i = 0; i < parameters.length; i++) {\n                if (k > counter - j && parameters[i] != null && parameters[i].hasInitialExpression()) {\n                    arguments.addExpression(\n                            new CastExpression(\n                                    parameters[i].getType(),\n                                    parameters[i].getInitialExpression()\n                            )\n                    );\n                    k++;\n                } else if (parameters[i] != null && parameters[i].hasInitialExpression()) {\n                    newParams[index++] = parameters[i];\n                    arguments.addExpression(\n                            new CastExpression(\n                                    parameters[i].getType(),\n                                    new VariableExpression(parameters[i].getName())\n                            )\n                    );\n                    k++;\n                } else {\n                    newParams[index++] = parameters[i];\n                    arguments.addExpression(\n                            new CastExpression(\n                                    parameters[i].getType(),\n                                    new VariableExpression(parameters[i].getName())\n                            )\n                    );\n                }\n            }\n            action.call(arguments, newParams, method);\n        }\n\n        for (Parameter parameter : parameters) {\n            // remove default expression\n            parameter.setInitialExpression(null);\n        }\n    }","commit_id":"825b7111a2a029e395ab6701a1bdfd4bd77b9c1a","url":"https://github.com/apache/groovy"},{"original_method":"protected void addInitialization(ClassNode node) {\n        for (Iterator iter = node.getDeclaredConstructors().iterator(); iter.hasNext();) {\n            addInitialization(node, (ConstructorNode) iter.next());\n        }\n    }","id":60752,"modified_method":"protected void addInitialization(ClassNode node) {\n        for (ConstructorNode cn : node.getDeclaredConstructors()) {\n            addInitialization(node, cn);\n        }\n    }","commit_id":"825b7111a2a029e395ab6701a1bdfd4bd77b9c1a","url":"https://github.com/apache/groovy"},{"original_method":"protected void addInitialization(ClassNode node, ConstructorNode constructorNode) {\n        Statement firstStatement = constructorNode.getFirstStatement();\n        // if some transformation decided to generate constructor then it probably knows who it does\n        if (firstStatement instanceof BytecodeSequence)\n            return;\n\n        ConstructorCallExpression first = getFirstIfSpecialConstructorCall(firstStatement);\n        \n        // in case of this(...) let the other constructor do the init\n        if (first!=null && (first.isThisCall())) return;\n        \n        List statements = new ArrayList();\n        List staticStatements = new ArrayList();\n        final boolean isEnum = node.isEnum();\n        List<Statement> initStmtsAfterEnumValuesInit = new ArrayList();\n        Set explicitStaticPropsInEnum = new HashSet();\n        if(isEnum) {\n            for (Iterator iter = node.getProperties().iterator(); iter.hasNext();) {\n                PropertyNode propNode = (PropertyNode) iter.next();\n                if(!propNode.isSynthetic() && propNode.getField().isStatic()) {\n                    explicitStaticPropsInEnum.add(propNode.getField().getName());\n                }\n            }\n            for (FieldNode fieldNode : node.getFields()) {\n                if(!fieldNode.isSynthetic() && fieldNode.isStatic() && fieldNode.getType() != node) {\n                    explicitStaticPropsInEnum.add(fieldNode.getName());\n                }\n            }\n        }\n        for (Iterator iter = node.getFields().iterator(); iter.hasNext();) {\n            addFieldInitialization(statements, staticStatements, \n                    (FieldNode) iter.next(), isEnum, \n                    initStmtsAfterEnumValuesInit, explicitStaticPropsInEnum);\n        }\n        statements.addAll(node.getObjectInitializerStatements());\n        if (!statements.isEmpty()) {\n            Statement code = constructorNode.getCode();\n            BlockStatement block = new BlockStatement();\n            List otherStatements = block.getStatements();\n            if (code instanceof BlockStatement) {\n                block = (BlockStatement) code;\n                otherStatements=block.getStatements();\n            }\n            else if (code != null) {\n                otherStatements.add(code);\n            }\n            if (!otherStatements.isEmpty()) {\n                if (first!=null) {\n                    // it is super(..) since this(..) is already covered\n                    otherStatements.remove(0);\n                    statements.add(0, firstStatement);\n                } \n                Statement stmtThis$0 = getImplicitThis$0StmtIfInnerClass(otherStatements);\n                if(stmtThis$0 != null) {\n                \t// since there can be field init statements that depend on method/property dispatching\n                \t// that uses this$0, it needs to bubble up just after the constructor call.\n                \tstatements.add(1, stmtThis$0);\n                }\n                statements.addAll(otherStatements);\n            }\n            BlockStatement newBlock = new BlockStatement(statements, block.getVariableScope());\n            newBlock.setSourcePosition(block);\n            constructorNode.setCode(newBlock);\n        }\n\n        if (!staticStatements.isEmpty()) {\n            if(isEnum) {\n                /*\n                 * GROOVY-3161: initialize statements for explicitly declared static fields \n                 * inside an enum should come after enum values are initialized\n                 */\n                staticStatements.removeAll(initStmtsAfterEnumValuesInit);\n                node.addStaticInitializerStatements(staticStatements, true);\n                if(!initStmtsAfterEnumValuesInit.isEmpty()) {\n                    node.positionStmtsAfterEnumInitStmts(initStmtsAfterEnumValuesInit);\n                }\n            } else {\n                node.addStaticInitializerStatements(staticStatements, true);\n            }\n        }\n    }","id":60753,"modified_method":"protected void addInitialization(ClassNode node, ConstructorNode constructorNode) {\n        Statement firstStatement = constructorNode.getFirstStatement();\n        // if some transformation decided to generate constructor then it probably knows who it does\n        if (firstStatement instanceof BytecodeSequence)\n            return;\n\n        ConstructorCallExpression first = getFirstIfSpecialConstructorCall(firstStatement);\n\n        // in case of this(...) let the other constructor do the init\n        if (first != null && (first.isThisCall())) return;\n\n        List<Statement> statements = new ArrayList<Statement>();\n        List<Statement> staticStatements = new ArrayList<Statement>();\n        final boolean isEnum = node.isEnum();\n        List<Statement> initStmtsAfterEnumValuesInit = new ArrayList<Statement>();\n        Set<String> explicitStaticPropsInEnum = new HashSet<String>();\n        if (isEnum) {\n            for (PropertyNode propNode : node.getProperties()) {\n                if (!propNode.isSynthetic() && propNode.getField().isStatic()) {\n                    explicitStaticPropsInEnum.add(propNode.getField().getName());\n                }\n            }\n            for (FieldNode fieldNode : node.getFields()) {\n                if (!fieldNode.isSynthetic() && fieldNode.isStatic() && fieldNode.getType() != node) {\n                    explicitStaticPropsInEnum.add(fieldNode.getName());\n                }\n            }\n        }\n        for (FieldNode fn : node.getFields()) {\n            addFieldInitialization(statements, staticStatements, fn, isEnum,\n                    initStmtsAfterEnumValuesInit, explicitStaticPropsInEnum);\n        }\n        statements.addAll(node.getObjectInitializerStatements());\n        if (!statements.isEmpty()) {\n            Statement code = constructorNode.getCode();\n            BlockStatement block = new BlockStatement();\n            List<Statement> otherStatements = block.getStatements();\n            if (code instanceof BlockStatement) {\n                block = (BlockStatement) code;\n                otherStatements = block.getStatements();\n            } else if (code != null) {\n                otherStatements.add(code);\n            }\n            if (!otherStatements.isEmpty()) {\n                if (first != null) {\n                    // it is super(..) since this(..) is already covered\n                    otherStatements.remove(0);\n                    statements.add(0, firstStatement);\n                }\n                Statement stmtThis$0 = getImplicitThis$0StmtIfInnerClass(otherStatements);\n                if (stmtThis$0 != null) {\n                    // since there can be field init statements that depend on method/property dispatching\n                    // that uses this$0, it needs to bubble up just after the constructor call.\n                    statements.add(1, stmtThis$0);\n                }\n                statements.addAll(otherStatements);\n            }\n            BlockStatement newBlock = new BlockStatement(statements, block.getVariableScope());\n            newBlock.setSourcePosition(block);\n            constructorNode.setCode(newBlock);\n        }\n\n        if (!staticStatements.isEmpty()) {\n            if (isEnum) {\n                /*\n                 * GROOVY-3161: initialize statements for explicitly declared static fields \n                 * inside an enum should come after enum values are initialized\n                 */\n                staticStatements.removeAll(initStmtsAfterEnumValuesInit);\n                node.addStaticInitializerStatements(staticStatements, true);\n                if (!initStmtsAfterEnumValuesInit.isEmpty()) {\n                    node.positionStmtsAfterEnumInitStmts(initStmtsAfterEnumValuesInit);\n                }\n            } else {\n                node.addStaticInitializerStatements(staticStatements, true);\n            }\n        }\n    }","commit_id":"825b7111a2a029e395ab6701a1bdfd4bd77b9c1a","url":"https://github.com/apache/groovy"},{"original_method":"private Parameter[] selectAccessibleConstructorFromSuper(ConstructorNode node) {\n        ClassNode type = node.getDeclaringClass();\n        ClassNode superType = type.getSuperClass();\n\n        boolean hadPrivateConstructor = false;\n        for (Iterator iter = superType.getDeclaredConstructors().iterator(); iter.hasNext();) {\n            ConstructorNode c = (ConstructorNode)iter.next();\n\n            // Only look at things we can actually call\n            if (c.isPublic() || c.isProtected()) {\n                return c.getParameters();\n            }\n        }\n        \n        // fall back for parameterless constructor \n        if (superType.isPrimaryClassNode()) {\n            return Parameter.EMPTY_ARRAY;\n        }\n        \n        return null;\n    }","id":60754,"modified_method":"private Parameter[] selectAccessibleConstructorFromSuper(ConstructorNode node) {\n        ClassNode type = node.getDeclaringClass();\n        ClassNode superType = type.getSuperClass();\n\n        for (ConstructorNode c : superType.getDeclaredConstructors()) {\n            // Only look at things we can actually call\n            if (c.isPublic() || c.isProtected()) {\n                return c.getParameters();\n            }\n        }\n\n        // fall back for parameterless constructor \n        if (superType.isPrimaryClassNode()) {\n            return Parameter.EMPTY_ARRAY;\n        }\n\n        return null;\n    }","commit_id":"1777c86e4c43195df1353e1fb62a1fe02336e015","url":"https://github.com/apache/groovy"},{"original_method":"private void genEnumFields(List fields, PrintWriter out) {\n        if (fields.size()==0) return;\n        boolean first = true;\n        for (Iterator iterator = fields.iterator(); iterator.hasNext();) {\n            FieldNode fieldNode = (FieldNode) iterator.next();\n            if (!first) {\n                out.print(\", \");\n            } else {\n                first = false;\n            }\n            out.print(fieldNode.getName());            \n        }\n        out.println(\";\");\n    }","id":60755,"modified_method":"private void genEnumFields(List<FieldNode> fields, PrintWriter out) {\n        if (fields.size()==0) return;\n        boolean first = true;\n        for (FieldNode field : fields) {\n            if (!first) {\n                out.print(\", \");\n            } else {\n                first = false;\n            }\n            out.print(field.getName());\n        }\n        out.println(\";\");\n    }","commit_id":"1777c86e4c43195df1353e1fb62a1fe02336e015","url":"https://github.com/apache/groovy"},{"original_method":"public void clean() {\n        for (Iterator it = toCompile.iterator(); it.hasNext();) {\n            String path = (String) it.next();\n            new File(outputPath, path + \".java\").delete();\n        }\n    }","id":60756,"modified_method":"public void clean() {\n        for (String path : toCompile) {\n            new File(outputPath, path + \".java\").delete();\n        }\n    }","commit_id":"1777c86e4c43195df1353e1fb62a1fe02336e015","url":"https://github.com/apache/groovy"},{"original_method":"private void genClassInner(ClassNode classNode, PrintWriter out) throws FileNotFoundException {\n        try {\n            Verifier verifier = new Verifier() {\n                public void addCovariantMethods(ClassNode cn) {}\n                protected void addTimeStamp(ClassNode node) {}\n                protected void addInitialization(ClassNode node) {}\n                protected void addPropertyMethod(MethodNode method) {\n                    propertyMethods.add(method);\n                }\n                protected void addReturnIfNeeded(MethodNode node) {}\n            };\n            verifier.visitClass(classNode);\n\n            boolean isInterface = classNode.isInterface();\n            boolean isEnum = (classNode.getModifiers() & Opcodes.ACC_ENUM) !=0;\n            printModifiers(out, classNode.getModifiers()\n                    & ~(isInterface ? Opcodes.ACC_ABSTRACT : 0));\n\n            if (isInterface) {\n                out.print (\"interface \");\n            } else if (isEnum) {\n                out.print (\"enum \");\n            } else {\n                out.print (\"class \");\n            }\n\n            String className = classNode.getNameWithoutPackage();\n            if (classNode instanceof InnerClassNode)\n                className = className.substring(className.lastIndexOf(\"$\")+1);\n            out.println(className);\n            writeGenericsBounds(out, classNode, true);\n\n            ClassNode superClass = classNode.getUnresolvedSuperClass(false);\n\n            if (!isInterface && !isEnum) {\n                out.print(\"  extends \");\n                printType(superClass,out);\n            }\n\n            ClassNode[] interfaces = classNode.getInterfaces();\n            if (interfaces != null && interfaces.length > 0) {\n                if (isInterface) {\n                    out.println(\"  extends\");\n                } else {\n                    out.println(\"  implements\");\n                }\n                for (int i = 0; i < interfaces.length - 1; ++i) {\n                    out.print(\"    \");\n                    printType(interfaces[i], out);\n                    out.print(\",\");\n                }\n                out.print(\"    \");\n                printType(interfaces[interfaces.length - 1],out);\n            }\n            out.println(\" {\");\n\n            genFields(classNode, out, isEnum);\n            genMethods(classNode, out, isEnum);\n\n            for (Iterator<InnerClassNode> inner = classNode.getInnerClasses(); inner.hasNext(); ) {\n                genClassInner(inner.next(), out);\n            }\n\n            out.println(\"}\");\n        }\n        finally {\n            propertyMethods.clear();\n        }\n    }","id":60757,"modified_method":"private void genClassInner(ClassNode classNode, PrintWriter out) throws FileNotFoundException {\n        try {\n            Verifier verifier = new Verifier() {\n                public void addCovariantMethods(ClassNode cn) {}\n                protected void addTimeStamp(ClassNode node) {}\n                protected void addInitialization(ClassNode node) {}\n                protected void addPropertyMethod(MethodNode method) {\n                    propertyMethods.add(method);\n                }\n                protected void addReturnIfNeeded(MethodNode node) {}\n            };\n            verifier.visitClass(classNode);\n\n            boolean isInterface = classNode.isInterface();\n            boolean isEnum = (classNode.getModifiers() & Opcodes.ACC_ENUM) !=0;\n            printModifiers(out, classNode.getModifiers()\n                    & ~(isInterface ? Opcodes.ACC_ABSTRACT : 0));\n\n            if (isInterface) {\n                out.print (\"interface \");\n            } else if (isEnum) {\n                out.print (\"enum \");\n            } else {\n                out.print (\"class \");\n            }\n\n            String className = classNode.getNameWithoutPackage();\n            if (classNode instanceof InnerClassNode)\n                className = className.substring(className.lastIndexOf(\"$\")+1);\n            out.println(className);\n            writeGenericsBounds(out, classNode, true);\n\n            ClassNode superClass = classNode.getUnresolvedSuperClass(false);\n\n            if (!isInterface && !isEnum) {\n                out.print(\"  extends \");\n                printType(superClass,out);\n            }\n\n            ClassNode[] interfaces = classNode.getInterfaces();\n            if (interfaces != null && interfaces.length > 0) {\n                if (isInterface) {\n                    out.println(\"  extends\");\n                } else {\n                    out.println(\"  implements\");\n                }\n                for (int i = 0; i < interfaces.length - 1; ++i) {\n                    out.print(\"    \");\n                    printType(interfaces[i], out);\n                    out.print(\",\");\n                }\n                out.print(\"    \");\n                printType(interfaces[interfaces.length - 1],out);\n            }\n            out.println(\" {\");\n\n            genFields(classNode, out);\n            genMethods(classNode, out, isEnum);\n\n            for (Iterator<InnerClassNode> inner = classNode.getInnerClasses(); inner.hasNext(); ) {\n                genClassInner(inner.next(), out);\n            }\n\n            out.println(\"}\");\n        }\n        finally {\n            propertyMethods.clear();\n        }\n    }","commit_id":"1777c86e4c43195df1353e1fb62a1fe02336e015","url":"https://github.com/apache/groovy"},{"original_method":"private void genSpecialConstructorArgs(PrintWriter out, ConstructorNode node, ConstructorCallExpression constrCall) {\n        // Select a constructor from our class, or super-class which is legal to call,\n        // then write out an invoke w/nulls using casts to avoid abigous crapo\n\n        Parameter[] params = selectAccessibleConstructorFromSuper(node);\n        if (params != null) {\n            out.print(\"super (\");\n\n            for (int i=0; i<params.length; i++) {\n                printDefaultValue(out, params[i].getType());\n                if (i + 1 < params.length) {\n                    out.print(\", \");\n                }\n            }\n            \n            out.println(\");\");\n            return;\n        }\n\n        // Otherwise try the older method based on the constructor's call expression\n        Expression arguments = constrCall.getArguments();\n\n        if (constrCall.isSuperCall()) {\n            out.print(\"super(\");\n        }\n        else {\n            out.print(\"this(\");\n        }\n\n        // Else try to render some arguments\n        if (arguments instanceof ArgumentListExpression) {\n            ArgumentListExpression argumentListExpression = (ArgumentListExpression) arguments;\n            List args = argumentListExpression.getExpressions();\n\n            for (Iterator it = args.iterator(); it.hasNext();) {\n                Expression arg = (Expression) it.next();\n\n                if (arg instanceof ConstantExpression) {\n                    ConstantExpression expression = (ConstantExpression) arg;\n                    Object o = expression.getValue();\n\n                    if (o instanceof String) {\n                        out.print(\"(String)null\");\n                    } else {\n                        out.print(expression.getText());\n                    }\n                } else {\n                    ClassNode type = getConstructorArgumentType(arg, node);\n                    printDefaultValue(out, type);\n                }\n\n                if (arg != args.get(args.size() - 1)) {\n                    out.print(\", \");\n                }\n            }\n        }\n\n        out.println(\");\");\n    }","id":60758,"modified_method":"private void genSpecialConstructorArgs(PrintWriter out, ConstructorNode node, ConstructorCallExpression constrCall) {\n        // Select a constructor from our class, or super-class which is legal to call,\n        // then write out an invoke w/nulls using casts to avoid abigous crapo\n\n        Parameter[] params = selectAccessibleConstructorFromSuper(node);\n        if (params != null) {\n            out.print(\"super (\");\n\n            for (int i=0; i<params.length; i++) {\n                printDefaultValue(out, params[i].getType());\n                if (i + 1 < params.length) {\n                    out.print(\", \");\n                }\n            }\n\n            out.println(\");\");\n            return;\n        }\n\n        // Otherwise try the older method based on the constructor's call expression\n        Expression arguments = constrCall.getArguments();\n\n        if (constrCall.isSuperCall()) {\n            out.print(\"super(\");\n        }\n        else {\n            out.print(\"this(\");\n        }\n\n        // Else try to render some arguments\n        if (arguments instanceof ArgumentListExpression) {\n            ArgumentListExpression argumentListExpression = (ArgumentListExpression) arguments;\n            List<Expression> args = argumentListExpression.getExpressions();\n\n            for (Expression arg : args) {\n                if (arg instanceof ConstantExpression) {\n                    ConstantExpression expression = (ConstantExpression) arg;\n                    Object o = expression.getValue();\n\n                    if (o instanceof String) {\n                        out.print(\"(String)null\");\n                    } else {\n                        out.print(expression.getText());\n                    }\n                } else {\n                    ClassNode type = getConstructorArgumentType(arg, node);\n                    printDefaultValue(out, type);\n                }\n\n                if (arg != args.get(args.size() - 1)) {\n                    out.print(\", \");\n                }\n            }\n        }\n\n        out.println(\");\");\n    }","commit_id":"1777c86e4c43195df1353e1fb62a1fe02336e015","url":"https://github.com/apache/groovy"},{"original_method":"private void getConstructors(ClassNode classNode, PrintWriter out) {\n        List constrs = classNode.getDeclaredConstructors();\n        if (constrs != null)\n            for (Iterator it = constrs.iterator(); it.hasNext();) {\n                ConstructorNode constrNode = (ConstructorNode) it.next();\n                genConstructor(classNode, constrNode, out);\n            }\n    }","id":60759,"modified_method":"private void getConstructors(ClassNode classNode, PrintWriter out) {\n        List<ConstructorNode> constrs = classNode.getDeclaredConstructors();\n        if (constrs != null)\n            for (ConstructorNode constr : constrs) {\n                genConstructor(classNode, constr, out);\n            }\n    }","commit_id":"1777c86e4c43195df1353e1fb62a1fe02336e015","url":"https://github.com/apache/groovy"},{"original_method":"private void genMethods(ClassNode classNode, PrintWriter out, boolean isEnum) {\n        if (!isEnum) getConstructors(classNode, out);\n\n        List methods = (List) propertyMethods.clone();\n        methods.addAll(classNode.getMethods());\n        if (methods != null)\n            for (Iterator it = methods.iterator(); it.hasNext();) {\n                MethodNode methodNode = (MethodNode) it.next();\n                if(isEnum && methodNode.isSynthetic()) {\n                    // skip values() method and valueOf(String)\n                    String name = methodNode.getName();\n                    Parameter[] params = methodNode.getParameters();\n                    if (name.equals(\"values\") && params.length==0) continue;\n                    if (name.equals(\"valueOf\") && \n                        params.length==1 &&\n                        params[0].getType().equals(ClassHelper.STRING_TYPE))\n                    {\n                        continue;\n                    }\n                }\n                genMethod(classNode, methodNode, out);\n            }\n    }","id":60760,"modified_method":"private void genMethods(ClassNode classNode, PrintWriter out, boolean isEnum) {\n        if (!isEnum) getConstructors(classNode, out);\n\n        @SuppressWarnings(\"unchecked\")\n        List<MethodNode> methods = (List)propertyMethods.clone();\n        methods.addAll(classNode.getMethods());\n        for (MethodNode method : methods) {\n            if (isEnum && method.isSynthetic()) {\n                // skip values() method and valueOf(String)\n                String name = method.getName();\n                Parameter[] params = method.getParameters();\n                if (name.equals(\"values\") && params.length == 0) continue;\n                if (name.equals(\"valueOf\") &&\n                        params.length == 1 &&\n                        params[0].getType().equals(ClassHelper.STRING_TYPE)) {\n                    continue;\n                }\n            }\n            genMethod(classNode, method, out);\n        }\n    }","commit_id":"1777c86e4c43195df1353e1fb62a1fe02336e015","url":"https://github.com/apache/groovy"},{"original_method":"private void genFields(ClassNode classNode, PrintWriter out, boolean isEnum) {\n        List fields = classNode.getFields();\n        if (fields == null) return;\n        ArrayList enumFields = new ArrayList(fields.size());\n        ArrayList normalFields = new ArrayList(fields.size());\n        for (Iterator it = fields.iterator(); it.hasNext();) {\n            FieldNode fieldNode = (FieldNode) it.next();\n            boolean isEnumField = (fieldNode.getModifiers() & Opcodes.ACC_ENUM) !=0;\n            boolean isSynthetic = (fieldNode.getModifiers() & Opcodes.ACC_SYNTHETIC) !=0;\n            if (isEnumField) {\n                enumFields.add(fieldNode);\n            } else if (!isSynthetic) {\n                normalFields.add(fieldNode);\n            }\n        }\n        genEnumFields(enumFields, out);\n        for (Iterator iterator = normalFields.iterator(); iterator.hasNext();) {\n            FieldNode fieldNode = (FieldNode) iterator.next();\n            genField(fieldNode, out);            \n        } \n    }","id":60761,"modified_method":"private void genFields(ClassNode classNode, PrintWriter out) {\n        List<FieldNode> fields = classNode.getFields();\n        if (fields == null) return;\n        List<FieldNode> enumFields = new ArrayList<FieldNode>(fields.size());\n        List<FieldNode> normalFields = new ArrayList<FieldNode>(fields.size());\n        for (FieldNode field : fields) {\n            boolean isSynthetic = (field.getModifiers() & Opcodes.ACC_SYNTHETIC) != 0;\n            if (field.isEnum()) {\n                enumFields.add(field);\n            } else if (!isSynthetic) {\n                normalFields.add(field);\n            }\n        }\n        genEnumFields(enumFields, out);\n        for (FieldNode normalField : normalFields) {\n            genField(normalField, out);\n        }\n    }","commit_id":"1777c86e4c43195df1353e1fb62a1fe02336e015","url":"https://github.com/apache/groovy"},{"original_method":"private ClassNode getConstructorArgumentType(Expression arg, ConstructorNode node) {\n        if (!(arg instanceof VariableExpression)) return arg.getType();\n        VariableExpression vexp = (VariableExpression) arg;\n        String name = vexp.getName();\n        Parameter[] params = node.getParameters();\n        for (int i=0; i<params.length; i++) {\n            if (params[i].getName().equals(name)) {\n                return params[i].getType();\n            }\n        }\n        return vexp.getType();\n    }","id":60762,"modified_method":"private ClassNode getConstructorArgumentType(Expression arg, ConstructorNode node) {\n        if (!(arg instanceof VariableExpression)) return arg.getType();\n        VariableExpression vexp = (VariableExpression) arg;\n        String name = vexp.getName();\n        for (Parameter param : node.getParameters()) {\n            if (param.getName().equals(name)) {\n                return param.getType();\n            }\n        }\n        return vexp.getType();\n    }","commit_id":"1777c86e4c43195df1353e1fb62a1fe02336e015","url":"https://github.com/apache/groovy"},{"original_method":"protected void onSuccess(FetchResult result, ObjectContainer container, ClientContext context) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(decompressors, 1);\n\t\t\tcontainer.activate(parent, 1);\n\t\t\tcontainer.activate(ctx, 1);\n\t\t\tcontainer.activate(rcb, 1);\n\t\t}\n\t\tif(parent.isCancelled()) {\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Parent is cancelled\");\n\t\t\tresult.asBucket().free();\n\t\t\tonFailure(new FetchException(FetchException.CANCELLED), false, container, context);\n\t\t\treturn;\n\t\t}\n\t\tif(!decompressors.isEmpty()) {\n\t\t\tBucket data = result.asBucket();\n\t\t\twhile(!decompressors.isEmpty()) {\n\t\t\t\tCompressor c = (Compressor) decompressors.remove(decompressors.size()-1);\n\t\t\t\ttry {\n\t\t\t\t\tlong maxLen = Math.max(ctx.maxTempLength, ctx.maxOutputLength);\n\t\t\t\t\tdata = c.decompress(data, context.getBucketFactory(parent.persistent()), maxLen, maxLen * 4, decompressors.isEmpty() ? returnBucket : null);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tonFailure(new FetchException(FetchException.BUCKET_ERROR, e), false, container, context);\n\t\t\t\t\treturn;\n\t\t\t\t} catch (CompressionOutputSizeException e) {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Too big: limit=\"+ctx.maxOutputLength+\" temp=\"+ctx.maxTempLength);\n\t\t\t\t\tonFailure(new FetchException(FetchException.TOO_BIG, e.estimatedSize, (rcb == parent), result.getMimeType()), false, container, context);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult = new FetchResult(result, data);\n\t\t\tif(persistent) {\n\t\t\t\tcontainer.set(this);\n\t\t\t\tcontainer.set(decompressors);\n\t\t\t}\n\t\t}\n\t\tif((!ctx.ignoreTooManyPathComponents) && (!metaStrings.isEmpty()) && isFinal) {\n\t\t\t// Some meta-strings left\n\t\t\tif(addedMetaStrings > 0) {\n\t\t\t\t// Should this be an error?\n\t\t\t\t// It would be useful to be able to fetch the data ...\n\t\t\t\t// On the other hand such inserts could cause unpredictable results?\n\t\t\t\t// Would be useful to make a redirect to the key we actually fetched.\n\t\t\t\trcb.onFailure(new FetchException(FetchException.INVALID_METADATA, \"Invalid metadata: too many path components in redirects\", thisKey), this, container, context);\n\t\t\t} else {\n\t\t\t\t// TOO_MANY_PATH_COMPONENTS\n\t\t\t\t// report to user\n\t\t\t\tif(logMINOR) {\n\t\t\t\t\tLogger.minor(this, \"Too many path components: for \"+uri+\" meta=\"+metaStrings.toString());\n\t\t\t\t}\n\t\t\t\tFreenetURI tryURI = uri;\n\t\t\t\ttryURI = tryURI.dropLastMetaStrings(metaStrings.size());\n\t\t\t\trcb.onFailure(new FetchException(FetchException.TOO_MANY_PATH_COMPONENTS, result.size(), (rcb == parent), result.getMimeType(), tryURI), this, container, context);\n\t\t\t}\n\t\t\tresult.asBucket().free();\n\t\t\treturn;\n\t\t} else if(result.size() > ctx.maxOutputLength) {\n\t\t\trcb.onFailure(new FetchException(FetchException.TOO_BIG, result.size(), (rcb == parent), result.getMimeType()), this, container, context);\n\t\t\tresult.asBucket().free();\n\t\t} else {\n\t\t\trcb.onSuccess(result, this, container, context);\n\t\t}\n\t}","id":60763,"modified_method":"protected void onSuccess(FetchResult result, ObjectContainer container, ClientContext context) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(decompressors, 1);\n\t\t\tcontainer.activate(parent, 1);\n\t\t\tcontainer.activate(ctx, 1);\n\t\t\tcontainer.activate(rcb, 1);\n\t\t}\n\t\tif(parent.isCancelled()) {\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Parent is cancelled\");\n\t\t\tresult.asBucket().free();\n\t\t\tonFailure(new FetchException(FetchException.CANCELLED), false, container, context);\n\t\t\treturn;\n\t\t}\n\t\tif(!decompressors.isEmpty()) {\n\t\t\tBucket data = result.asBucket();\n\t\t\tboolean tooManyDecompressors = decompressors.size() > 1;\n\t\t\twhile(!decompressors.isEmpty()) {\n\t\t\t\tCompressor c = (Compressor) decompressors.remove(decompressors.size()-1);\n\t\t\t\ttry {\n\t\t\t\t\tlong maxLen = Math.max(ctx.maxTempLength, ctx.maxOutputLength);\n\t\t\t\t\tBucket out;\n\t\t\t\t\tif(tooManyDecompressors)\n\t\t\t\t\t\tout = null;\n\t\t\t\t\telse\n\t\t\t\t\t\tout = decompressors.isEmpty() ? returnBucket : null;\n\t\t\t\t\tdata = c.decompress(data, context.getBucketFactory(parent.persistent()), maxLen, maxLen * 4, out);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tonFailure(new FetchException(FetchException.BUCKET_ERROR, e), false, container, context);\n\t\t\t\t\treturn;\n\t\t\t\t} catch (CompressionOutputSizeException e) {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Too big: limit=\"+ctx.maxOutputLength+\" temp=\"+ctx.maxTempLength);\n\t\t\t\t\tonFailure(new FetchException(FetchException.TOO_BIG, e.estimatedSize, (rcb == parent), result.getMimeType()), false, container, context);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult = new FetchResult(result, data);\n\t\t\tif(persistent) {\n\t\t\t\tcontainer.set(this);\n\t\t\t\tcontainer.set(decompressors);\n\t\t\t}\n\t\t}\n\t\tif((!ctx.ignoreTooManyPathComponents) && (!metaStrings.isEmpty()) && isFinal) {\n\t\t\t// Some meta-strings left\n\t\t\tif(addedMetaStrings > 0) {\n\t\t\t\t// Should this be an error?\n\t\t\t\t// It would be useful to be able to fetch the data ...\n\t\t\t\t// On the other hand such inserts could cause unpredictable results?\n\t\t\t\t// Would be useful to make a redirect to the key we actually fetched.\n\t\t\t\trcb.onFailure(new FetchException(FetchException.INVALID_METADATA, \"Invalid metadata: too many path components in redirects\", thisKey), this, container, context);\n\t\t\t} else {\n\t\t\t\t// TOO_MANY_PATH_COMPONENTS\n\t\t\t\t// report to user\n\t\t\t\tif(logMINOR) {\n\t\t\t\t\tLogger.minor(this, \"Too many path components: for \"+uri+\" meta=\"+metaStrings.toString());\n\t\t\t\t}\n\t\t\t\tFreenetURI tryURI = uri;\n\t\t\t\ttryURI = tryURI.dropLastMetaStrings(metaStrings.size());\n\t\t\t\trcb.onFailure(new FetchException(FetchException.TOO_MANY_PATH_COMPONENTS, result.size(), (rcb == parent), result.getMimeType(), tryURI), this, container, context);\n\t\t\t}\n\t\t\tresult.asBucket().free();\n\t\t\treturn;\n\t\t} else if(result.size() > ctx.maxOutputLength) {\n\t\t\trcb.onFailure(new FetchException(FetchException.TOO_BIG, result.size(), (rcb == parent), result.getMimeType()), this, container, context);\n\t\t\tresult.asBucket().free();\n\t\t} else {\n\t\t\trcb.onSuccess(result, this, container, context);\n\t\t}\n\t}","commit_id":"03bdcad62dc394b1f925b30c17d92e44a686faa3","url":"https://github.com/freenet/fred"},{"original_method":"public void onBlockSetFinished(ClientGetState state, ObjectContainer container, ClientContext context) {\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(rcb, 1);\n\t\t\tif(wasFetchingFinalData) {\n\t\t\t\trcb.onBlockSetFinished(SingleFileFetcher.this, container, context);\n\t\t\t}\n\t\t}","id":60764,"modified_method":"public void onBlockSetFinished(ClientGetState state, ObjectContainer container, ClientContext context) {\n\t\t\tboolean wasActive = true;\n\t\t\tif(persistent) {\n\t\t\t\twasActive = container.ext().isActive(SingleFileFetcher.this);\n\t\t\t\tif(!wasActive)\n\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t}\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(rcb, 1);\n\t\t\tif(wasFetchingFinalData) {\n\t\t\t\trcb.onBlockSetFinished(SingleFileFetcher.this, container, context);\n\t\t\t}\n\t\t\tif(!wasActive)\n\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t}","commit_id":"03bdcad62dc394b1f925b30c17d92e44a686faa3","url":"https://github.com/freenet/fred"},{"original_method":"public void onFailure(FetchException e, ClientGetState state, ObjectContainer container, ClientContext context) {\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t// Pass it on; fetcher is assumed to have retried as appropriate already, so this is fatal.\n\t\t\tSingleFileFetcher.this.onFailure(e, true, container, context);\n\t\t}","id":60765,"modified_method":"public void onFailure(FetchException e, ClientGetState state, ObjectContainer container, ClientContext context) {\n\t\t\tboolean wasActive = true;\n\t\t\tif(persistent) {\n\t\t\t\twasActive = container.ext().isActive(SingleFileFetcher.this);\n\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t}\n\t\t\t// Pass it on; fetcher is assumed to have retried as appropriate already, so this is fatal.\n\t\t\tSingleFileFetcher.this.onFailure(e, true, container, context);\n\t\t\tif(!wasActive)\n\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t}","commit_id":"03bdcad62dc394b1f925b30c17d92e44a686faa3","url":"https://github.com/freenet/fred"},{"original_method":"public void onFailure(FetchException e, ClientGetState state, ObjectContainer container, ClientContext context) {\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t// Force fatal as the fetcher is presumed to have made a reasonable effort.\n\t\t\tSingleFileFetcher.this.onFailure(e, true, container, context);\n\t\t}","id":60766,"modified_method":"public void onFailure(FetchException e, ClientGetState state, ObjectContainer container, ClientContext context) {\n\t\t\tboolean wasActive = true;\n\t\t\tif(persistent) {\n\t\t\t\twasActive = container.ext().isActive(SingleFileFetcher.this);\n\t\t\t\tif(!wasActive)\n\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t}\n\t\t\t// Force fatal as the fetcher is presumed to have made a reasonable effort.\n\t\t\tSingleFileFetcher.this.onFailure(e, true, container, context);\n\t\t\tif(wasActive)\n\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t}","commit_id":"03bdcad62dc394b1f925b30c17d92e44a686faa3","url":"https://github.com/freenet/fred"},{"original_method":"private void innerSuccess(FetchResult result, ObjectContainer container, ClientContext context) {\n\t\t\tif(persistent) {\n\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\tah.activateForExecution(container);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tah.extractToCache(result.asBucket(), actx, element, callback, context.archiveManager, container, context);\n\t\t\t} catch (ArchiveFailureException e) {\n\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e), false, container, context);\n\t\t\t\treturn;\n\t\t\t} catch (ArchiveRestartException e) {\n\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e), false, container, context);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(callback != null) return;\n\t\t\twrapHandleMetadata(true, container, context);\n\t\t}","id":60767,"modified_method":"private void innerSuccess(FetchResult result, ObjectContainer container, ClientContext context) {\n\t\t\ttry {\n\t\t\t\tah.extractToCache(result.asBucket(), actx, element, callback, context.archiveManager, container, context);\n\t\t\t} catch (ArchiveFailureException e) {\n\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e), false, container, context);\n\t\t\t\treturn;\n\t\t\t} catch (ArchiveRestartException e) {\n\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e), false, container, context);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(callback != null) return;\n\t\t\twrapHandleMetadata(true, container, context);\n\t\t}","commit_id":"03bdcad62dc394b1f925b30c17d92e44a686faa3","url":"https://github.com/freenet/fred"},{"original_method":"public void onSuccess(FetchResult result, ClientGetState state, ObjectContainer container, ClientContext context) {\n\t\t\tif(!persistent) {\n\t\t\t\t// Run directly - we are running on some thread somewhere, don't worry about it.\n\t\t\t\tinnerSuccess(result, container, context);\n\t\t\t} else {\n\t\t\t\t// We are running on the database thread.\n\t\t\t\t// Add a tag, unpack on a separate thread, copy the data to a persistent bucket, then schedule on the database thread,\n\t\t\t\t// remove the tag, and call the callback.\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\t\tah.activateForExecution(container);\n\t\t\t\t}\n\t\t\t\tah.extractPersistentOffThread(result.asBucket(), actx, element, callback, container, context);\n\t\t\t}\n\t\t}","id":60768,"modified_method":"public void onSuccess(FetchResult result, ClientGetState state, ObjectContainer container, ClientContext context) {\n\t\t\tif(!persistent) {\n\t\t\t\t// Run directly - we are running on some thread somewhere, don't worry about it.\n\t\t\t\tinnerSuccess(result, container, context);\n\t\t\t} else {\n\t\t\t\tboolean wasActive;\n\t\t\t\t// We are running on the database thread.\n\t\t\t\t// Add a tag, unpack on a separate thread, copy the data to a persistent bucket, then schedule on the database thread,\n\t\t\t\t// remove the tag, and call the callback.\n\t\t\t\twasActive = container.ext().isActive(SingleFileFetcher.this);\n\t\t\t\tif(!wasActive)\n\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\tah.activateForExecution(container);\n\t\t\t\tah.extractPersistentOffThread(result.asBucket(), actx, element, callback, container, context);\n\t\t\t\tif(!wasActive)\n\t\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t\t}\n\t\t}","commit_id":"03bdcad62dc394b1f925b30c17d92e44a686faa3","url":"https://github.com/freenet/fred"},{"original_method":"private void fetchArchive(boolean forData, Metadata meta, String element, ArchiveExtractCallback callback, final ObjectContainer container, ClientContext context) throws FetchException, MetadataParseException, ArchiveFailureException, ArchiveRestartException {\n\t\tif(logMINOR) Logger.minor(this, \"fetchArchive()\");\n\t\t// Fetch the archive\n\t\t// How?\n\t\t// Spawn a separate SingleFileFetcher,\n\t\t// which fetches the archive, then calls\n\t\t// our Callback, which unpacks the archive, then\n\t\t// reschedules us.\n\t\tMetadata newMeta = (Metadata) meta.clone();\n\t\tnewMeta.setSimpleRedirect();\n\t\tfinal SingleFileFetcher f;\n\t\tf = new SingleFileFetcher(this, newMeta, new ArchiveFetcherCallback(forData, element, callback), new FetchContext(ctx, FetchContext.SET_RETURN_ARCHIVES, true), container, context);\n\t\tif(logMINOR) Logger.minor(this, \"fetchArchive(): \"+f);\n\t\t// Fetch the archive. The archive fetcher callback will unpack it, and either call the element \n\t\t// callback, or just go back around handleMetadata() on this, which will see that the data is now\n\t\t// available.\n\t\tf.wrapHandleMetadata(true, container, context);\n\t}","id":60769,"modified_method":"private void fetchArchive(boolean forData, Metadata meta, String element, ArchiveExtractCallback callback, final ObjectContainer container, ClientContext context) throws FetchException, MetadataParseException, ArchiveFailureException, ArchiveRestartException {\n\t\tif(logMINOR) Logger.minor(this, \"fetchArchive()\");\n\t\t// Fetch the archive\n\t\t// How?\n\t\t// Spawn a separate SingleFileFetcher,\n\t\t// which fetches the archive, then calls\n\t\t// our Callback, which unpacks the archive, then\n\t\t// reschedules us.\n\t\tMetadata newMeta = (Metadata) meta.clone();\n\t\tnewMeta.setSimpleRedirect();\n\t\tfinal SingleFileFetcher f;\n\t\tf = new SingleFileFetcher(this, newMeta, new ArchiveFetcherCallback(forData, element, callback), new FetchContext(ctx, FetchContext.SET_RETURN_ARCHIVES, true), container, context);\n\t\tif(persistent) container.set(f);\n\t\tif(logMINOR) Logger.minor(this, \"fetchArchive(): \"+f);\n\t\t// Fetch the archive. The archive fetcher callback will unpack it, and either call the element \n\t\t// callback, or just go back around handleMetadata() on this, which will see that the data is now\n\t\t// available.\n\t\tf.wrapHandleMetadata(true, container, context);\n\t\tif(persistent) container.deactivate(f, 1);\n\t}","commit_id":"03bdcad62dc394b1f925b30c17d92e44a686faa3","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Handle the current metadata. I.e. do something with it: transition to a splitfile, look up a manifest, etc.\n\t * LOCKING: Synchronized as it changes so many variables; if we want to write the structure to disk, we don't\n\t * want this running at the same time.\n\t * @throws FetchException\n\t * @throws MetadataParseException\n\t * @throws ArchiveFailureException\n\t * @throws ArchiveRestartException\n\t */\n\tprivate synchronized void handleMetadata(final ObjectContainer container, final ClientContext context) throws FetchException, MetadataParseException, ArchiveFailureException, ArchiveRestartException {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(this, 2);\n\t\t\t// ,1's are probably redundant\n\t\t\tcontainer.activate(metadata, 100);\n\t\t\tcontainer.activate(metaStrings, Integer.MAX_VALUE);\n\t\t\tcontainer.activate(thisKey, 5);\n\t\t\tcontainer.activate(ctx, 2); // for event producer and allowed mime types\n\t\t\tif(ah != null)\n\t\t\t\tah.activateForExecution(container);\n\t\t\tcontainer.activate(parent, 1);\n\t\t\tcontainer.activate(actx, 5);\n\t\t\tcontainer.activate(clientMetadata, 5);\n\t\t\tcontainer.activate(rcb, 1);\n\t\t\tcontainer.activate(returnBucket, 5);\n\t\t}\n\t\twhile(true) {\n\t\t\tif(metadata.isSimpleManifest()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Is simple manifest\");\n\t\t\t\tString name;\n\t\t\t\tif(metaStrings.isEmpty())\n\t\t\t\t\tthrow new FetchException(FetchException.NOT_ENOUGH_PATH_COMPONENTS, -1, false, null, uri.addMetaStrings(new String[] { \"\" }));\n\t\t\t\telse name = removeMetaString();\n\t\t\t\t// Since metadata is a document, we just replace metadata here\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Next meta-string: \"+name+\" length \"+name.length()+\" for \"+this);\n\t\t\t\tif(name == null) {\n\t\t\t\t\tmetadata = metadata.getDefaultDocument();\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tcontainer.set(this);\n\t\t\t\t\t\tcontainer.set(metaStrings);\n\t\t\t\t\t}\n\t\t\t\t\tif(metadata == null)\n\t\t\t\t\t\tthrow new FetchException(FetchException.NOT_ENOUGH_PATH_COMPONENTS, -1, false, null, uri.addMetaStrings(new String[] { \"\" }));\n\t\t\t\t} else {\n\t\t\t\t\tmetadata = metadata.getDocument(name);\n\t\t\t\t\tthisKey = thisKey.pushMetaString(name);\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tcontainer.set(this);\n\t\t\t\t\t\tcontainer.set(metaStrings);\n\t\t\t\t\t\tcontainer.set(thisKey);\n\t\t\t\t\t}\n\t\t\t\t\tif(metadata == null)\n\t\t\t\t\t\tthrow new FetchException(FetchException.NOT_IN_ARCHIVE);\n\t\t\t\t}\n\t\t\t\tcontinue; // loop\n\t\t\t} else if(metadata.isArchiveManifest()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Is archive manifest\");\n\t\t\t\tif(metaStrings.isEmpty() && ctx.returnZIPManifests) {\n\t\t\t\t\t// Just return the archive, whole.\n\t\t\t\t\tmetadata.setSimpleRedirect();\n\t\t\t\t\tif(persistent) container.set(metadata);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// First we need the archive metadata.\n\t\t\t\t// Then parse it. Then we may need to fetch something from inside the archive.\n\t\t\t\t// It's more efficient to keep the existing ah if we can, and it is vital in\n\t\t\t\t// the case of binary blobs.\n\t\t\t\tif(ah == null || !ah.getKey().equals(thisKey))\n\t\t\t\t\tah = context.archiveManager.makeHandler(thisKey, metadata.getArchiveType(),\n\t\t\t\t\t\t\t(parent instanceof ClientGetter ? ((ClientGetter)parent).collectingBinaryBlob() : false));\n\t\t\t\tarchiveMetadata = metadata;\n\t\t\t\t// ah is set. This means we are currently handling an archive.\n\t\t\t\tBucket metadataBucket;\n\t\t\t\tmetadataBucket = ah.getMetadata(actx, null, recursionLevel+1, true, context.archiveManager);\n\t\t\t\tif(metadataBucket != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tmetadata = Metadata.construct(metadataBucket);\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t// Bucket error?\n\t\t\t\t\t\tthrow new FetchException(FetchException.BUCKET_ERROR, e);\n\t\t\t\t\t}\n\t\t\t\t\tif(persistent) container.set(this);\n\t\t\t\t} else {\n\t\t\t\t\tfinal boolean persistent = this.persistent;\n\t\t\t\t\tfetchArchive(false, archiveMetadata, ArchiveManager.METADATA_NAME, new ArchiveExtractCallback() {\n\t\t\t\t\t\tpublic void gotBucket(Bucket data, ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tmetadata = Metadata.construct(data);\n\t\t\t\t\t\t\t\twrapHandleMetadata(true, container, context);\n\t\t\t\t\t\t\t} catch (MetadataParseException e) {\n\t\t\t\t\t\t\t\t// Invalid metadata\n\t\t\t\t\t\t\t\tonFailure(new FetchException(FetchException.INVALID_METADATA, e), false, container, context);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\t// Bucket error?\n\t\t\t\t\t\t\t\tonFailure(new FetchException(FetchException.BUCKET_ERROR, e), false, container, context);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void notInArchive(ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t\tonFailure(new FetchException(FetchException.INTERNAL_ERROR, \"No metadata in container! Cannot happen as ArchiveManager should synthesise some!\"), false, container, context);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void onFailed(ArchiveRestartException e, ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e), false, container, context);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void onFailed(ArchiveFailureException e, ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e), false, container, context);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, container, context); // will result in this function being called again\n\t\t\t\t\tif(persistent) container.set(this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if(metadata.isArchiveInternalRedirect()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Is archive-internal redirect\");\n\t\t\t\tclientMetadata.mergeNoOverwrite(metadata.getClientMetadata());\n\t\t\t\tif(persistent) container.set(clientMetadata);\n\t\t\t\tString mime = clientMetadata.getMIMEType();\n\t\t\t\tif(mime != null) rcb.onExpectedMIME(mime, container);\n\t\t\t\tif(metaStrings.isEmpty() && isFinal && clientMetadata.getMIMETypeNoParams() != null && ctx.allowedMIMETypes != null &&\n\t\t\t\t\t\t!ctx.allowedMIMETypes.contains(clientMetadata.getMIMETypeNoParams())) {\n\t\t\t\t\tthrow new FetchException(FetchException.WRONG_MIME_TYPE, -1, false, clientMetadata.getMIMEType());\n\t\t\t\t}\n\t\t\t\t// Fetch it from the archive\n\t\t\t\tif(ah == null)\n\t\t\t\t\tthrow new FetchException(FetchException.UNKNOWN_METADATA, \"Archive redirect not in an archive manifest\");\n\t\t\t\tString filename = metadata.getZIPInternalName();\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Fetching \"+filename);\n\t\t\t\tBucket dataBucket = ah.get(filename, actx, null, recursionLevel+1, true, context.archiveManager);\n\t\t\t\tif(dataBucket != null) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Returning data\");\n\t\t\t\t\tfinal Bucket out;\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Data will not be freed until client is finished with it.\n\t\t\t\t\t\tif(returnBucket != null) {\n\t\t\t\t\t\t\tout = returnBucket;\n\t\t\t\t\t\t\tBucketTools.copy(dataBucket, out);\n\t\t\t\t\t\t\tdataBucket.free();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tout = dataBucket;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tthrow new FetchException(FetchException.BUCKET_ERROR);\n\t\t\t\t\t}\n\t\t\t\t\t// Return the data\n\t\t\t\t\tonSuccess(new FetchResult(clientMetadata, out), container, context);\n\t\t\t\t\t\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Fetching archive (thisKey=\"+thisKey+ ')');\n\t\t\t\t\t// Metadata cannot contain pointers to files which don't exist.\n\t\t\t\t\t// We enforce this in ArchiveHandler.\n\t\t\t\t\t// Therefore, the archive needs to be fetched.\n\t\t\t\t\tfinal boolean persistent = this.persistent;\n\t\t\t\t\tfetchArchive(true, archiveMetadata, filename, new ArchiveExtractCallback() {\n\t\t\t\t\t\tpublic void gotBucket(Bucket data, ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Returning data\");\n\t\t\t\t\t\t\tBucket out;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t// Data will not be freed until client is finished with it.\n\t\t\t\t\t\t\t\tif(returnBucket != null) {\n\t\t\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\t\t\tcontainer.activate(returnBucket, 5);\n\t\t\t\t\t\t\t\t\tout = returnBucket;\n\t\t\t\t\t\t\t\t\tBucketTools.copy(data, out);\n\t\t\t\t\t\t\t\t\tdata.free();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tout = data;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\tonFailure(new FetchException(FetchException.BUCKET_ERROR), false, container, context);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Return the data\n\t\t\t\t\t\t\tonSuccess(new FetchResult(clientMetadata, out), container, context);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void notInArchive(ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t\tonFailure(new FetchException(FetchException.NOT_IN_ARCHIVE), false, container, context);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void onFailed(ArchiveRestartException e, ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e), false, container, context);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void onFailed(ArchiveFailureException e, ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e), false, container, context);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, container, context);\n\t\t\t\t\t// Will call back into this function when it has been fetched.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if(metadata.isMultiLevelMetadata()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Is multi-level metadata\");\n\t\t\t\t// Fetch on a second SingleFileFetcher, like with archives.\n\t\t\t\tmetadata.setSimpleRedirect();\n\t\t\t\tfinal SingleFileFetcher f = new SingleFileFetcher(this, metadata, new MultiLevelMetadataCallback(), ctx, container, context);\n\t\t\t\t// Clear our own metadata so it can be garbage collected, it will be replaced by whatever is fetched.\n\t\t\t\tthis.metadata = null;\n\t\t\t\tif(persistent) container.set(this);\n\t\t\t\tif(persistent) container.set(f);\n\t\t\t\tf.wrapHandleMetadata(true, container, context);\n\t\t\t\treturn;\n\t\t\t} else if(metadata.isSingleFileRedirect()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Is single-file redirect\");\n\t\t\t\tclientMetadata.mergeNoOverwrite(metadata.getClientMetadata()); // even splitfiles can have mime types!\n\t\t\t\tif(persistent) container.set(clientMetadata);\n\t\t\t\tString mime = clientMetadata.getMIMEType();\n\t\t\t\tif(mime != null) rcb.onExpectedMIME(mime, container);\n\n\t\t\t\tString mimeType = clientMetadata.getMIMETypeNoParams();\n\t\t\t\tif(mimeType != null && ArchiveManager.isUsableArchiveType(mimeType) && metaStrings.size() > 0) {\n\t\t\t\t\t// Looks like an implicit archive, handle as such\n\t\t\t\t\tmetadata.setArchiveManifest();\n\t\t\t\t\tif(persistent) container.set(metadata);\n\t\t\t\t\t// Pick up MIME type from inside archive\n\t\t\t\t\tclientMetadata.clear();\n\t\t\t\t\tif(persistent) container.set(clientMetadata);\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Handling implicit container... (redirect)\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(metaStrings.isEmpty() && isFinal && mimeType != null && ctx.allowedMIMETypes != null && \n\t\t\t\t\t\t!ctx.allowedMIMETypes.contains(mimeType)) {\n\t\t\t\t\tthrow new FetchException(FetchException.WRONG_MIME_TYPE, -1, false, clientMetadata.getMIMEType());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Simple redirect\n\t\t\t\t// Just create a new SingleFileFetcher\n\t\t\t\t// Which will then fetch the target URI, and call the rcd.success\n\t\t\t\t// Hopefully!\n\t\t\t\tFreenetURI newURI = metadata.getSingleTarget();\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Redirecting to \"+newURI);\n\t\t\t\tClientKey redirectedKey;\n\t\t\t\ttry {\n\t\t\t\t\tBaseClientKey k = BaseClientKey.getBaseKey(newURI);\n\t\t\t\t\tif(k instanceof ClientKey)\n\t\t\t\t\t\tredirectedKey = (ClientKey) k;\n\t\t\t\t\telse\n\t\t\t\t\t\t// FIXME do we want to allow redirects to USKs?\n\t\t\t\t\t\t// Without redirects to USKs, all SSK and CHKs are static.\n\t\t\t\t\t\t// This may be a desirable property.\n\t\t\t\t\t\tthrow new FetchException(FetchException.UNKNOWN_METADATA, \"Redirect to a USK\");\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\tthrow new FetchException(FetchException.INVALID_URI, e);\n\t\t\t\t}\n\t\t\t\tArrayList newMetaStrings = newURI.listMetaStrings();\n\t\t\t\t\n\t\t\t\t// Move any new meta strings to beginning of our list of remaining meta strings\n\t\t\t\twhile(!newMetaStrings.isEmpty()) {\n\t\t\t\t\tObject o = newMetaStrings.remove(newMetaStrings.size()-1);\n\t\t\t\t\tmetaStrings.add(0, o);\n\t\t\t\t\taddedMetaStrings++;\n\t\t\t\t}\n\n\t\t\t\tfinal SingleFileFetcher f = new SingleFileFetcher(parent, rcb, clientMetadata, redirectedKey, metaStrings, this.uri, addedMetaStrings, ctx, actx, ah, archiveMetadata, maxRetries, recursionLevel, false, token, true, returnBucket, isFinal, container, context);\n\t\t\t\tif((redirectedKey instanceof ClientCHK) && !((ClientCHK)redirectedKey).isMetadata())\n\t\t\t\t\trcb.onBlockSetFinished(this, container, context);\n\t\t\t\tif(metadata.isCompressed()) {\n\t\t\t\t\tCompressor codec = Compressor.getCompressionAlgorithmByMetadataID(metadata.getCompressionCodec());\n\t\t\t\t\tf.addDecompressor(codec);\n\t\t\t\t}\n\t\t\t\tparent.onTransition(this, f, container);\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.set(metaStrings);\n\t\t\t\t\tcontainer.set(f); // Store *before* scheduling to avoid activation problems.\n\t\t\t\t\tcontainer.set(this);\n\t\t\t\t}\n\t\t\t\tf.schedule(container, context);\n\t\t\t\t// All done! No longer our problem!\n\t\t\t\tmetadata = null; // Get rid just in case we stick around somehow.\n\t\t\t\treturn;\n\t\t\t} else if(metadata.isSplitfile()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Fetching splitfile\");\n\t\t\t\t\n\t\t\t\tclientMetadata.mergeNoOverwrite(metadata.getClientMetadata()); // even splitfiles can have mime types!\n\t\t\t\tif(persistent) container.set(clientMetadata);\n\t\t\t\tString mime = clientMetadata.getMIMEType();\n\t\t\t\tif(mime != null) rcb.onExpectedMIME(mime, container);\n\t\t\t\t\n\t\t\t\tString mimeType = clientMetadata.getMIMETypeNoParams();\n\t\t\t\tif(mimeType != null && ArchiveManager.isUsableArchiveType(mimeType) && metaStrings.size() > 0) {\n\t\t\t\t\t// Looks like an implicit archive, handle as such\n\t\t\t\t\tmetadata.setArchiveManifest();\n\t\t\t\t\t// Pick up MIME type from inside archive\n\t\t\t\t\tclientMetadata.clear();\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tcontainer.set(metadata);\n\t\t\t\t\t\tcontainer.set(clientMetadata);\n\t\t\t\t\t}\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Handling implicit container... (splitfile)\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(metaStrings.isEmpty() && isFinal && mimeType != null && ctx.allowedMIMETypes != null &&\n\t\t\t\t\t\t!ctx.allowedMIMETypes.contains(mimeType)) {\n\t\t\t\t\t// Just in case...\n\t\t\t\t\tlong len = metadata.uncompressedDataLength();\n\t\t\t\t\tmetadata = null;\n\t\t\t\t\tthrow new FetchException(FetchException.WRONG_MIME_TYPE, len, false, clientMetadata.getMIMEType());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Splitfile (possibly compressed)\n\t\t\t\t\n\t\t\t\tif(metadata.isCompressed()) {\n\t\t\t\t\tCompressor codec = Compressor.getCompressionAlgorithmByMetadataID(metadata.getCompressionCodec());\n\t\t\t\t\taddDecompressor(codec);\n\t\t\t\t\tif(persistent)\n\t\t\t\t\t\tcontainer.set(decompressors);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(isFinal && !ctx.ignoreTooManyPathComponents) {\n\t\t\t\t\tif(!metaStrings.isEmpty()) {\n\t\t\t\t\t\t// Some meta-strings left\n\t\t\t\t\t\tif(addedMetaStrings > 0) {\n\t\t\t\t\t\t\t// Should this be an error?\n\t\t\t\t\t\t\t// It would be useful to be able to fetch the data ...\n\t\t\t\t\t\t\t// On the other hand such inserts could cause unpredictable results?\n\t\t\t\t\t\t\t// Would be useful to make a redirect to the key we actually fetched.\n\t\t\t\t\t\t\trcb.onFailure(new FetchException(FetchException.INVALID_METADATA, \"Invalid metadata: too many path components in redirects\", thisKey), this, container, context);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// TOO_MANY_PATH_COMPONENTS\n\t\t\t\t\t\t\t// report to user\n\t\t\t\t\t\t\tFreenetURI tryURI = uri;\n\t\t\t\t\t\t\ttryURI = tryURI.dropLastMetaStrings(metaStrings.size());\n\t\t\t\t\t\t\trcb.onFailure(new FetchException(FetchException.TOO_MANY_PATH_COMPONENTS, metadata.uncompressedDataLength(), (rcb == parent), clientMetadata.getMIMEType(), tryURI), this, container, context);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Just in case...\n\t\t\t\t\t\tmetadata = null;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Not finished: rcb=\"+rcb+\" for \"+this); \n\t\t\t\t\n\t\t\t\tlong len = metadata.dataLength();\n\t\t\t\tif(metadata.uncompressedDataLength() > len)\n\t\t\t\t\tlen = metadata.uncompressedDataLength();\n\t\t\t\t\n\t\t\t\tif((len > ctx.maxOutputLength) ||\n\t\t\t\t\t\t(len > ctx.maxTempLength)) {\n\t\t\t\t\t// Just in case...\n\t\t\t\t\tboolean compressed = metadata.isCompressed();\n\t\t\t\t\tmetadata = null;\n\t\t\t\t\tthrow new FetchException(FetchException.TOO_BIG, len, isFinal && decompressors.size() <= (compressed ? 1 : 0), clientMetadata.getMIMEType());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSplitFileFetcher sf = new SplitFileFetcher(metadata, rcb, parent, ctx, \n\t\t\t\t\t\tdecompressors, clientMetadata, actx, recursionLevel, returnBucket, token, container, context);\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.set(sf); // Avoid problems caused by storing a deactivated sf\n\t\t\t\tparent.onTransition(this, sf, container);\n\t\t\t\ttry {\n\t\t\t\t\tsf.schedule(container, context);\n\t\t\t\t} catch (KeyListenerConstructionException e) {\n\t\t\t\t\tonFailure(e.getFetchException(), false, container, context);\n\t\t\t\t\tif(persistent) container.deactivate(sf, 1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(persistent) container.deactivate(sf, 1);\n\t\t\t\trcb.onBlockSetFinished(this, container, context);\n\t\t\t\t// Clear our own metadata, we won't need it any more.\n\t\t\t\t// For multi-level metadata etc see above.\n\t\t\t\tmetadata = null; \n\t\t\t\t\n\t\t\t\t// SplitFile will now run.\n\t\t\t\t// Then it will return data to rcd.\n\t\t\t\t// We are now out of the loop. Yay!\n\t\t\t\tif(persistent) container.set(this);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tLogger.error(this, \"Don't know what to do with metadata: \"+metadata);\n\t\t\t\tthrow new FetchException(FetchException.UNKNOWN_METADATA);\n\t\t\t}\n\t\t}\n\t}","id":60770,"modified_method":"/**\n\t * Handle the current metadata. I.e. do something with it: transition to a splitfile, look up a manifest, etc.\n\t * LOCKING: Synchronized as it changes so many variables; if we want to write the structure to disk, we don't\n\t * want this running at the same time.\n\t * @throws FetchException\n\t * @throws MetadataParseException\n\t * @throws ArchiveFailureException\n\t * @throws ArchiveRestartException\n\t */\n\tprivate synchronized void handleMetadata(final ObjectContainer container, final ClientContext context) throws FetchException, MetadataParseException, ArchiveFailureException, ArchiveRestartException {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(this, 2);\n\t\t\t// ,1's are probably redundant\n\t\t\tcontainer.activate(metadata, 100);\n\t\t\tcontainer.activate(metaStrings, Integer.MAX_VALUE);\n\t\t\tcontainer.activate(thisKey, 5);\n\t\t\tcontainer.activate(ctx, 2); // for event producer and allowed mime types\n\t\t\tif(ah != null)\n\t\t\t\tah.activateForExecution(container);\n\t\t\tcontainer.activate(parent, 1);\n\t\t\tcontainer.activate(actx, 5);\n\t\t\tcontainer.activate(clientMetadata, 5);\n\t\t\tcontainer.activate(rcb, 1);\n\t\t\tcontainer.activate(returnBucket, 5);\n\t\t}\n\t\twhile(true) {\n\t\t\tif(metadata.isSimpleManifest()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Is simple manifest\");\n\t\t\t\tString name;\n\t\t\t\tif(metaStrings.isEmpty())\n\t\t\t\t\tthrow new FetchException(FetchException.NOT_ENOUGH_PATH_COMPONENTS, -1, false, null, uri.addMetaStrings(new String[] { \"\" }));\n\t\t\t\telse name = removeMetaString();\n\t\t\t\t// Since metadata is a document, we just replace metadata here\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Next meta-string: \"+name+\" length \"+name.length()+\" for \"+this);\n\t\t\t\tif(name == null) {\n\t\t\t\t\tmetadata = metadata.getDefaultDocument();\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tcontainer.set(this);\n\t\t\t\t\t\tcontainer.set(metaStrings);\n\t\t\t\t\t}\n\t\t\t\t\tif(metadata == null)\n\t\t\t\t\t\tthrow new FetchException(FetchException.NOT_ENOUGH_PATH_COMPONENTS, -1, false, null, uri.addMetaStrings(new String[] { \"\" }));\n\t\t\t\t} else {\n\t\t\t\t\tmetadata = metadata.getDocument(name);\n\t\t\t\t\tthisKey = thisKey.pushMetaString(name);\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tcontainer.set(this);\n\t\t\t\t\t\tcontainer.set(metaStrings);\n\t\t\t\t\t\tcontainer.set(thisKey);\n\t\t\t\t\t}\n\t\t\t\t\tif(metadata == null)\n\t\t\t\t\t\tthrow new FetchException(FetchException.NOT_IN_ARCHIVE);\n\t\t\t\t}\n\t\t\t\tcontinue; // loop\n\t\t\t} else if(metadata.isArchiveManifest()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Is archive manifest\");\n\t\t\t\tif(metaStrings.isEmpty() && ctx.returnZIPManifests) {\n\t\t\t\t\t// Just return the archive, whole.\n\t\t\t\t\tmetadata.setSimpleRedirect();\n\t\t\t\t\tif(persistent) container.set(metadata);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// First we need the archive metadata.\n\t\t\t\t// Then parse it. Then we may need to fetch something from inside the archive.\n\t\t\t\t// It's more efficient to keep the existing ah if we can, and it is vital in\n\t\t\t\t// the case of binary blobs.\n\t\t\t\tif(ah == null || !ah.getKey().equals(thisKey))\n\t\t\t\t\tah = context.archiveManager.makeHandler(thisKey, metadata.getArchiveType(),\n\t\t\t\t\t\t\t(parent instanceof ClientGetter ? ((ClientGetter)parent).collectingBinaryBlob() : false));\n\t\t\t\tarchiveMetadata = metadata;\n\t\t\t\t// ah is set. This means we are currently handling an archive.\n\t\t\t\tBucket metadataBucket;\n\t\t\t\tmetadataBucket = ah.getMetadata(actx, null, recursionLevel+1, true, context.archiveManager);\n\t\t\t\tif(metadataBucket != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tmetadata = Metadata.construct(metadataBucket);\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t// Bucket error?\n\t\t\t\t\t\tthrow new FetchException(FetchException.BUCKET_ERROR, e);\n\t\t\t\t\t}\n\t\t\t\t\tif(persistent) container.set(this);\n\t\t\t\t} else {\n\t\t\t\t\tfinal boolean persistent = this.persistent;\n\t\t\t\t\tfetchArchive(false, archiveMetadata, ArchiveManager.METADATA_NAME, new ArchiveExtractCallback() {\n\t\t\t\t\t\tpublic void gotBucket(Bucket data, ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tmetadata = Metadata.construct(data);\n\t\t\t\t\t\t\t\twrapHandleMetadata(true, container, context);\n\t\t\t\t\t\t\t} catch (MetadataParseException e) {\n\t\t\t\t\t\t\t\t// Invalid metadata\n\t\t\t\t\t\t\t\tonFailure(new FetchException(FetchException.INVALID_METADATA, e), false, container, context);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\t// Bucket error?\n\t\t\t\t\t\t\t\tonFailure(new FetchException(FetchException.BUCKET_ERROR, e), false, container, context);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void notInArchive(ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t\tonFailure(new FetchException(FetchException.INTERNAL_ERROR, \"No metadata in container! Cannot happen as ArchiveManager should synthesise some!\"), false, container, context);\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void onFailed(ArchiveRestartException e, ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e), false, container, context);\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void onFailed(ArchiveFailureException e, ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e), false, container, context);\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, container, context); // will result in this function being called again\n\t\t\t\t\tif(persistent) container.set(this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if(metadata.isArchiveInternalRedirect()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Is archive-internal redirect\");\n\t\t\t\tclientMetadata.mergeNoOverwrite(metadata.getClientMetadata());\n\t\t\t\tif(persistent) container.set(clientMetadata);\n\t\t\t\tString mime = clientMetadata.getMIMEType();\n\t\t\t\tif(mime != null) rcb.onExpectedMIME(mime, container);\n\t\t\t\tif(metaStrings.isEmpty() && isFinal && clientMetadata.getMIMETypeNoParams() != null && ctx.allowedMIMETypes != null &&\n\t\t\t\t\t\t!ctx.allowedMIMETypes.contains(clientMetadata.getMIMETypeNoParams())) {\n\t\t\t\t\tthrow new FetchException(FetchException.WRONG_MIME_TYPE, -1, false, clientMetadata.getMIMEType());\n\t\t\t\t}\n\t\t\t\t// Fetch it from the archive\n\t\t\t\tif(ah == null)\n\t\t\t\t\tthrow new FetchException(FetchException.UNKNOWN_METADATA, \"Archive redirect not in an archive manifest\");\n\t\t\t\tString filename = metadata.getZIPInternalName();\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Fetching \"+filename);\n\t\t\t\tBucket dataBucket = ah.get(filename, actx, null, recursionLevel+1, true, context.archiveManager);\n\t\t\t\tif(dataBucket != null) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Returning data\");\n\t\t\t\t\tfinal Bucket out;\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Data will not be freed until client is finished with it.\n\t\t\t\t\t\tif(returnBucket != null) {\n\t\t\t\t\t\t\tout = returnBucket;\n\t\t\t\t\t\t\tBucketTools.copy(dataBucket, out);\n\t\t\t\t\t\t\tdataBucket.free();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tout = dataBucket;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tthrow new FetchException(FetchException.BUCKET_ERROR);\n\t\t\t\t\t}\n\t\t\t\t\t// Return the data\n\t\t\t\t\tonSuccess(new FetchResult(clientMetadata, out), container, context);\n\t\t\t\t\t\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Fetching archive (thisKey=\"+thisKey+ ')');\n\t\t\t\t\t// Metadata cannot contain pointers to files which don't exist.\n\t\t\t\t\t// We enforce this in ArchiveHandler.\n\t\t\t\t\t// Therefore, the archive needs to be fetched.\n\t\t\t\t\tfinal boolean persistent = this.persistent;\n\t\t\t\t\tfetchArchive(true, archiveMetadata, filename, new ArchiveExtractCallback() {\n\t\t\t\t\t\tpublic void gotBucket(Bucket data, ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Returning data\");\n\t\t\t\t\t\t\tBucket out;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t// Data will not be freed until client is finished with it.\n\t\t\t\t\t\t\t\tif(returnBucket != null) {\n\t\t\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\t\t\tcontainer.activate(returnBucket, 5);\n\t\t\t\t\t\t\t\t\tout = returnBucket;\n\t\t\t\t\t\t\t\t\tBucketTools.copy(data, out);\n\t\t\t\t\t\t\t\t\tdata.free();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tout = data;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\tonFailure(new FetchException(FetchException.BUCKET_ERROR), false, container, context);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Return the data\n\t\t\t\t\t\t\tonSuccess(new FetchResult(clientMetadata, out), container, context);\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void notInArchive(ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t\tonFailure(new FetchException(FetchException.NOT_IN_ARCHIVE), false, container, context);\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void onFailed(ArchiveRestartException e, ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e), false, container, context);\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void onFailed(ArchiveFailureException e, ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e), false, container, context);\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, container, context);\n\t\t\t\t\t// Will call back into this function when it has been fetched.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if(metadata.isMultiLevelMetadata()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Is multi-level metadata\");\n\t\t\t\t// Fetch on a second SingleFileFetcher, like with archives.\n\t\t\t\tmetadata.setSimpleRedirect();\n\t\t\t\tfinal SingleFileFetcher f = new SingleFileFetcher(this, metadata, new MultiLevelMetadataCallback(), ctx, container, context);\n\t\t\t\t// Clear our own metadata so it can be garbage collected, it will be replaced by whatever is fetched.\n\t\t\t\tthis.metadata = null;\n\t\t\t\tif(persistent) container.set(this);\n\t\t\t\tif(persistent) container.set(f);\n\t\t\t\tf.wrapHandleMetadata(true, container, context);\n\t\t\t\tif(persistent) container.deactivate(f, 1);\n\t\t\t\treturn;\n\t\t\t} else if(metadata.isSingleFileRedirect()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Is single-file redirect\");\n\t\t\t\tclientMetadata.mergeNoOverwrite(metadata.getClientMetadata()); // even splitfiles can have mime types!\n\t\t\t\tif(persistent) container.set(clientMetadata);\n\t\t\t\tString mime = clientMetadata.getMIMEType();\n\t\t\t\tif(mime != null) rcb.onExpectedMIME(mime, container);\n\n\t\t\t\tString mimeType = clientMetadata.getMIMETypeNoParams();\n\t\t\t\tif(mimeType != null && ArchiveManager.isUsableArchiveType(mimeType) && metaStrings.size() > 0) {\n\t\t\t\t\t// Looks like an implicit archive, handle as such\n\t\t\t\t\tmetadata.setArchiveManifest();\n\t\t\t\t\tif(persistent) container.set(metadata);\n\t\t\t\t\t// Pick up MIME type from inside archive\n\t\t\t\t\tclientMetadata.clear();\n\t\t\t\t\tif(persistent) container.set(clientMetadata);\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Handling implicit container... (redirect)\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(metaStrings.isEmpty() && isFinal && mimeType != null && ctx.allowedMIMETypes != null && \n\t\t\t\t\t\t!ctx.allowedMIMETypes.contains(mimeType)) {\n\t\t\t\t\tthrow new FetchException(FetchException.WRONG_MIME_TYPE, -1, false, clientMetadata.getMIMEType());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Simple redirect\n\t\t\t\t// Just create a new SingleFileFetcher\n\t\t\t\t// Which will then fetch the target URI, and call the rcd.success\n\t\t\t\t// Hopefully!\n\t\t\t\tFreenetURI newURI = metadata.getSingleTarget();\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Redirecting to \"+newURI);\n\t\t\t\tClientKey redirectedKey;\n\t\t\t\ttry {\n\t\t\t\t\tBaseClientKey k = BaseClientKey.getBaseKey(newURI);\n\t\t\t\t\tif(k instanceof ClientKey)\n\t\t\t\t\t\tredirectedKey = (ClientKey) k;\n\t\t\t\t\telse\n\t\t\t\t\t\t// FIXME do we want to allow redirects to USKs?\n\t\t\t\t\t\t// Without redirects to USKs, all SSK and CHKs are static.\n\t\t\t\t\t\t// This may be a desirable property.\n\t\t\t\t\t\tthrow new FetchException(FetchException.UNKNOWN_METADATA, \"Redirect to a USK\");\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\tthrow new FetchException(FetchException.INVALID_URI, e);\n\t\t\t\t}\n\t\t\t\tArrayList newMetaStrings = newURI.listMetaStrings();\n\t\t\t\t\n\t\t\t\t// Move any new meta strings to beginning of our list of remaining meta strings\n\t\t\t\twhile(!newMetaStrings.isEmpty()) {\n\t\t\t\t\tObject o = newMetaStrings.remove(newMetaStrings.size()-1);\n\t\t\t\t\tmetaStrings.add(0, o);\n\t\t\t\t\taddedMetaStrings++;\n\t\t\t\t}\n\n\t\t\t\tfinal SingleFileFetcher f = new SingleFileFetcher(parent, rcb, clientMetadata, redirectedKey, metaStrings, this.uri, addedMetaStrings, ctx, actx, ah, archiveMetadata, maxRetries, recursionLevel, false, token, true, returnBucket, isFinal, container, context);\n\t\t\t\tif((redirectedKey instanceof ClientCHK) && !((ClientCHK)redirectedKey).isMetadata())\n\t\t\t\t\trcb.onBlockSetFinished(this, container, context);\n\t\t\t\tif(metadata.isCompressed()) {\n\t\t\t\t\tCompressor codec = Compressor.getCompressionAlgorithmByMetadataID(metadata.getCompressionCodec());\n\t\t\t\t\tf.addDecompressor(codec);\n\t\t\t\t}\n\t\t\t\tparent.onTransition(this, f, container);\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.set(metaStrings);\n\t\t\t\t\tcontainer.set(f); // Store *before* scheduling to avoid activation problems.\n\t\t\t\t\tcontainer.set(this);\n\t\t\t\t}\n\t\t\t\tf.schedule(container, context);\n\t\t\t\t// All done! No longer our problem!\n\t\t\t\tmetadata = null; // Get rid just in case we stick around somehow.\n\t\t\t\treturn;\n\t\t\t} else if(metadata.isSplitfile()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Fetching splitfile\");\n\t\t\t\t\n\t\t\t\tclientMetadata.mergeNoOverwrite(metadata.getClientMetadata()); // even splitfiles can have mime types!\n\t\t\t\tif(persistent) container.set(clientMetadata);\n\t\t\t\tString mime = clientMetadata.getMIMEType();\n\t\t\t\tif(mime != null) rcb.onExpectedMIME(mime, container);\n\t\t\t\t\n\t\t\t\tString mimeType = clientMetadata.getMIMETypeNoParams();\n\t\t\t\tif(mimeType != null && ArchiveManager.isUsableArchiveType(mimeType) && metaStrings.size() > 0) {\n\t\t\t\t\t// Looks like an implicit archive, handle as such\n\t\t\t\t\tmetadata.setArchiveManifest();\n\t\t\t\t\t// Pick up MIME type from inside archive\n\t\t\t\t\tclientMetadata.clear();\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tcontainer.set(metadata);\n\t\t\t\t\t\tcontainer.set(clientMetadata);\n\t\t\t\t\t}\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Handling implicit container... (splitfile)\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(metaStrings.isEmpty() && isFinal && mimeType != null && ctx.allowedMIMETypes != null &&\n\t\t\t\t\t\t!ctx.allowedMIMETypes.contains(mimeType)) {\n\t\t\t\t\t// Just in case...\n\t\t\t\t\tlong len = metadata.uncompressedDataLength();\n\t\t\t\t\tmetadata = null;\n\t\t\t\t\tthrow new FetchException(FetchException.WRONG_MIME_TYPE, len, false, clientMetadata.getMIMEType());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Splitfile (possibly compressed)\n\t\t\t\t\n\t\t\t\tif(metadata.isCompressed()) {\n\t\t\t\t\tCompressor codec = Compressor.getCompressionAlgorithmByMetadataID(metadata.getCompressionCodec());\n\t\t\t\t\taddDecompressor(codec);\n\t\t\t\t\tif(persistent)\n\t\t\t\t\t\tcontainer.set(decompressors);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(isFinal && !ctx.ignoreTooManyPathComponents) {\n\t\t\t\t\tif(!metaStrings.isEmpty()) {\n\t\t\t\t\t\t// Some meta-strings left\n\t\t\t\t\t\tif(addedMetaStrings > 0) {\n\t\t\t\t\t\t\t// Should this be an error?\n\t\t\t\t\t\t\t// It would be useful to be able to fetch the data ...\n\t\t\t\t\t\t\t// On the other hand such inserts could cause unpredictable results?\n\t\t\t\t\t\t\t// Would be useful to make a redirect to the key we actually fetched.\n\t\t\t\t\t\t\trcb.onFailure(new FetchException(FetchException.INVALID_METADATA, \"Invalid metadata: too many path components in redirects\", thisKey), this, container, context);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// TOO_MANY_PATH_COMPONENTS\n\t\t\t\t\t\t\t// report to user\n\t\t\t\t\t\t\tFreenetURI tryURI = uri;\n\t\t\t\t\t\t\ttryURI = tryURI.dropLastMetaStrings(metaStrings.size());\n\t\t\t\t\t\t\trcb.onFailure(new FetchException(FetchException.TOO_MANY_PATH_COMPONENTS, metadata.uncompressedDataLength(), (rcb == parent), clientMetadata.getMIMEType(), tryURI), this, container, context);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Just in case...\n\t\t\t\t\t\tmetadata = null;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Not finished: rcb=\"+rcb+\" for \"+this); \n\t\t\t\t\n\t\t\t\tlong len = metadata.dataLength();\n\t\t\t\tif(metadata.uncompressedDataLength() > len)\n\t\t\t\t\tlen = metadata.uncompressedDataLength();\n\t\t\t\t\n\t\t\t\tif((len > ctx.maxOutputLength) ||\n\t\t\t\t\t\t(len > ctx.maxTempLength)) {\n\t\t\t\t\t// Just in case...\n\t\t\t\t\tboolean compressed = metadata.isCompressed();\n\t\t\t\t\tmetadata = null;\n\t\t\t\t\tthrow new FetchException(FetchException.TOO_BIG, len, isFinal && decompressors.size() <= (compressed ? 1 : 0), clientMetadata.getMIMEType());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSplitFileFetcher sf = new SplitFileFetcher(metadata, rcb, parent, ctx, \n\t\t\t\t\t\tdecompressors, clientMetadata, actx, recursionLevel, returnBucket, token, container, context);\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.set(sf); // Avoid problems caused by storing a deactivated sf\n\t\t\t\tparent.onTransition(this, sf, container);\n\t\t\t\ttry {\n\t\t\t\t\tsf.schedule(container, context);\n\t\t\t\t} catch (KeyListenerConstructionException e) {\n\t\t\t\t\tonFailure(e.getFetchException(), false, container, context);\n\t\t\t\t\tif(persistent) container.deactivate(sf, 1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(persistent) container.deactivate(sf, 1);\n\t\t\t\trcb.onBlockSetFinished(this, container, context);\n\t\t\t\t// Clear our own metadata, we won't need it any more.\n\t\t\t\t// For multi-level metadata etc see above.\n\t\t\t\tmetadata = null; \n\t\t\t\t\n\t\t\t\t// SplitFile will now run.\n\t\t\t\t// Then it will return data to rcd.\n\t\t\t\t// We are now out of the loop. Yay!\n\t\t\t\tif(persistent) container.set(this);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tLogger.error(this, \"Don't know what to do with metadata: \"+metadata);\n\t\t\t\tthrow new FetchException(FetchException.UNKNOWN_METADATA);\n\t\t\t}\n\t\t}\n\t}","commit_id":"03bdcad62dc394b1f925b30c17d92e44a686faa3","url":"https://github.com/freenet/fred"},{"original_method":"public void onSuccess(FetchResult result, ClientGetState state, ObjectContainer container, ClientContext context) {\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\ttry {\n\t\t\t\tMetadata meta = Metadata.construct(result.asBucket());\n\t\t\t\tsynchronized(SingleFileFetcher.this) {\n\t\t\t\t\tmetadata = meta;\n\t\t\t\t}\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.set(SingleFileFetcher.this);\n\t\t\t} catch (MetadataParseException e) {\n\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(FetchException.INVALID_METADATA, e), false, container, context);\n\t\t\t\treturn;\n\t\t\t} catch (IOException e) {\n\t\t\t\t// Bucket error?\n\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(FetchException.BUCKET_ERROR, e), false, container, context);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twrapHandleMetadata(true, container, context);\n\t\t}","id":60771,"modified_method":"public void onSuccess(FetchResult result, ClientGetState state, ObjectContainer container, ClientContext context) {\n\t\t\tboolean wasActive = true;\n\t\t\tif(persistent) {\n\t\t\t\twasActive = container.ext().isActive(SingleFileFetcher.this);\n\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tMetadata meta = Metadata.construct(result.asBucket());\n\t\t\t\tsynchronized(SingleFileFetcher.this) {\n\t\t\t\t\tmetadata = meta;\n\t\t\t\t}\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.set(SingleFileFetcher.this);\n\t\t\t\twrapHandleMetadata(true, container, context);\n\t\t\t} catch (MetadataParseException e) {\n\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(FetchException.INVALID_METADATA, e), false, container, context);\n\t\t\t} catch (IOException e) {\n\t\t\t\t// Bucket error?\n\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(FetchException.BUCKET_ERROR, e), false, container, context);\n\t\t\t}\n\t\t\tif(!wasActive)\n\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t}","commit_id":"03bdcad62dc394b1f925b30c17d92e44a686faa3","url":"https://github.com/freenet/fred"},{"original_method":"public void onExpectedSize(long size, ObjectContainer container) {\n\t\t\tif(persistent) {\n\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\tcontainer.activate(rcb, 1);\n\t\t\t}\n\t\t\trcb.onExpectedSize(size, container);\n\t\t}","id":60772,"modified_method":"public void onExpectedSize(long size, ObjectContainer container) {\n\t\t\tboolean wasActive = true;\n\t\t\tboolean cbWasActive = true;\n\t\t\tif(persistent) {\n\t\t\t\twasActive = container.ext().isActive(SingleFileFetcher.this);\n\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\tcbWasActive = container.ext().isActive(rcb);\n\t\t\t\tcontainer.activate(rcb, 1);\n\t\t\t}\n\t\t\trcb.onExpectedSize(size, container);\n\t\t\tif(!wasActive)\n\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t\tif(!cbWasActive)\n\t\t\t\tcontainer.deactivate(rcb, 1);\n\t\t}","commit_id":"03bdcad62dc394b1f925b30c17d92e44a686faa3","url":"https://github.com/freenet/fred"},{"original_method":"public void register(final SendableRequest req, boolean onDatabaseThread) {\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tif(logMINOR) Logger.minor(this, \"Registering \"+req, new Exception(\"debug\"));\n\t\tboolean persistent = req.persistent();\n\t\tif(isInsertScheduler != (req instanceof SendableInsert))\n\t\t\tthrow new IllegalArgumentException(\"Expected a SendableInsert: \"+req);\n\t\tif(req instanceof SendableGet) {\n\t\t\tSendableGet getter = (SendableGet)req;\n\t\t\tif(!getter.ignoreStore()) {\n\t\t\t\tboolean anyValid = false;\n\t\t\t\tObject[] keyTokens = getter.sendableKeys();\n\t\t\t\tfor(int i=0;i<keyTokens.length;i++) {\n\t\t\t\t\tObject tok = keyTokens[i];\n\t\t\t\t\tClientKeyBlock block = null;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tClientKey key = getter.getKey(tok);\n\t\t\t\t\t\tif(key == null) {\n\t\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\t\tLogger.minor(this, \"No key for \"+tok+\" for \"+getter+\" - already finished?\");\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(getter.getContext().blocks != null)\n\t\t\t\t\t\t\t\tblock = getter.getContext().blocks.get(key);\n\t\t\t\t\t\t\tif(block == null)\n\t\t\t\t\t\t\t\tblock = node.fetchKey(key, getter.dontCache());\n\t\t\t\t\t\t\tif(block == null) {\n\t\t\t\t\t\t\t\tif(!persistent) {\n\t\t\t\t\t\t\t\t\tschedTransient.addPendingKey(key, getter);\n\t\t\t\t\t\t\t\t} // If persistent, when it is registered (in a later job) the keys will be added first.\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\t\t\tLogger.minor(this, \"Got \"+block);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (KeyVerifyException e) {\n\t\t\t\t\t\t// Verify exception, probably bogus at source;\n\t\t\t\t\t\t// verifies at low-level, but not at decode.\n\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\tLogger.minor(this, \"Decode failed: \"+e, e);\n\t\t\t\t\t\tgetter.onFailure(new LowLevelGetException(LowLevelGetException.DECODE_FAILED), tok, this);\n\t\t\t\t\t\tcontinue; // other keys might be valid\n\t\t\t\t\t}\n\t\t\t\t\tif(block != null) {\n\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Can fulfill \"+req+\" (\"+tok+\") immediately from store\");\n\t\t\t\t\t\tgetter.onSuccess(block, true, tok, this);\n\t\t\t\t\t\t// Even with working thread priorities, we still get very high latency accessing\n\t\t\t\t\t\t// the datastore when background threads are doing it in parallel.\n\t\t\t\t\t\t// So yield() here, unless priority is very high.\n\t\t\t\t\t\tif(req.getPriorityClass() > RequestStarter.IMMEDIATE_SPLITFILE_PRIORITY_CLASS)\n\t\t\t\t\t\t\tThread.yield();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tanyValid = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!anyValid) {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"No valid keys, returning without registering for \"+req);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(persistent) {\n\t\t\t// Add to the persistent registration queue\n\t\t\tif(onDatabaseThread) {\n\t\t\t\tif(!databaseExecutor.onThread()) {\n\t\t\t\t\tthrow new IllegalStateException(\"Not on database thread!\");\n\t\t\t\t}\n\t\t\t\tschedCore.queueRegister(req, databaseExecutor);\n\t\t\t} else {\n\t\t\t\tdatabaseExecutor.execute(new Runnable() {\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tschedCore.queueRegister(req, databaseExecutor);\n\t\t\t\t\t\tselectorContainer.commit();\n\t\t\t\t\t}\n\t\t\t\t}, NativeThread.NORM_PRIORITY, \"Add persistent job to queue\");\n\t\t\t}\n\t\t} else {\n\t\t\t// Register immediately.\n\t\t\tschedTransient.innerRegister(req, random);\n\t\t\tstarter.wakeUp();\n\t\t}\n\t}","id":60773,"modified_method":"public void register(final SendableRequest req, boolean onDatabaseThread) {\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tif(logMINOR) Logger.minor(this, \"Registering \"+req, new Exception(\"debug\"));\n\t\tboolean persistent = req.persistent();\n\t\tif(isInsertScheduler != (req instanceof SendableInsert))\n\t\t\tthrow new IllegalArgumentException(\"Expected a SendableInsert: \"+req);\n\t\tif(req instanceof SendableGet) {\n\t\t\tSendableGet getter = (SendableGet)req;\n\t\t\tif(!getter.ignoreStore()) {\n\t\t\t\tboolean anyValid = false;\n\t\t\t\tObject[] keyTokens = getter.sendableKeys();\n\t\t\t\tfor(int i=0;i<keyTokens.length;i++) {\n\t\t\t\t\tObject tok = keyTokens[i];\n\t\t\t\t\tClientKeyBlock block = null;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tClientKey key = getter.getKey(tok);\n\t\t\t\t\t\tif(key == null) {\n\t\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\t\tLogger.minor(this, \"No key for \"+tok+\" for \"+getter+\" - already finished?\");\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(getter.getContext().blocks != null)\n\t\t\t\t\t\t\t\tblock = getter.getContext().blocks.get(key);\n\t\t\t\t\t\t\tif(block == null)\n\t\t\t\t\t\t\t\tblock = node.fetchKey(key, getter.dontCache());\n\t\t\t\t\t\t\tif(block == null) {\n\t\t\t\t\t\t\t\tif(!persistent) {\n\t\t\t\t\t\t\t\t\tschedTransient.addPendingKey(key, getter);\n\t\t\t\t\t\t\t\t} // If persistent, when it is registered (in a later job) the keys will be added first.\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\t\t\tLogger.minor(this, \"Got \"+block);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (KeyVerifyException e) {\n\t\t\t\t\t\t// Verify exception, probably bogus at source;\n\t\t\t\t\t\t// verifies at low-level, but not at decode.\n\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\tLogger.minor(this, \"Decode failed: \"+e, e);\n\t\t\t\t\t\tif(onDatabaseThread)\n\t\t\t\t\t\t\tgetter.onFailure(new LowLevelGetException(LowLevelGetException.DECODE_FAILED), tok, this);\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tfinal SendableGet g = getter;\n\t\t\t\t\t\t\tfinal Object token = tok;\n\t\t\t\t\t\t\tdatabaseExecutor.execute(new Runnable() {\n\t\t\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\t\t\tg.onFailure(new LowLevelGetException(LowLevelGetException.DECODE_FAILED), token, ClientRequestScheduler.this);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}, NativeThread.NORM_PRIORITY, \"Block decode failed\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue; // other keys might be valid\n\t\t\t\t\t}\n\t\t\t\t\tif(block != null) {\n\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Can fulfill \"+req+\" (\"+tok+\") immediately from store\");\n\t\t\t\t\t\tgetter.onSuccess(block, true, tok, this);\n\t\t\t\t\t\t// Even with working thread priorities, we still get very high latency accessing\n\t\t\t\t\t\t// the datastore when background threads are doing it in parallel.\n\t\t\t\t\t\t// So yield() here, unless priority is very high.\n\t\t\t\t\t\tif(req.getPriorityClass() > RequestStarter.IMMEDIATE_SPLITFILE_PRIORITY_CLASS)\n\t\t\t\t\t\t\tThread.yield();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tanyValid = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!anyValid) {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"No valid keys, returning without registering for \"+req);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(persistent) {\n\t\t\t// Add to the persistent registration queue\n\t\t\tif(onDatabaseThread) {\n\t\t\t\tif(!databaseExecutor.onThread()) {\n\t\t\t\t\tthrow new IllegalStateException(\"Not on database thread!\");\n\t\t\t\t}\n\t\t\t\tschedCore.queueRegister(req, databaseExecutor);\n\t\t\t} else {\n\t\t\t\tdatabaseExecutor.execute(new Runnable() {\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tschedCore.queueRegister(req, databaseExecutor);\n\t\t\t\t\t\tselectorContainer.commit();\n\t\t\t\t\t}\n\t\t\t\t}, NativeThread.NORM_PRIORITY, \"Add persistent job to queue\");\n\t\t\t}\n\t\t} else {\n\t\t\t// Register immediately.\n\t\t\tschedTransient.innerRegister(req, random);\n\t\t\tstarter.wakeUp();\n\t\t}\n\t}","commit_id":"4c5762c936bf6c22b28f38846344984b82e3cc46","url":"https://github.com/freenet/fred"},{"original_method":"public void removeFetchingKey(final Key key) {\n\t\tsynchronized(keysFetching) {\n\t\t\tkeysFetching.remove(key);\n\t\t}\n\t\tsched.databaseExecutor.execute(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tObjectSet results = container.query(new Predicate() {\n\t\t\t\t\tpublic boolean match(PersistentChosenRequest req) {\n\t\t\t\t\t\tif(req.core != ClientRequestSchedulerCore.this) return false;\n\t\t\t\t\t\treturn req.key.equals(key);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif(results.hasNext()) {\n\t\t\t\t\tPersistentChosenRequest req = (PersistentChosenRequest) results.next();\n\t\t\t\t\tcontainer.delete(req);\n\t\t\t\t\tcontainer.commit();\n\t\t\t\t}\n\t\t\t}\n\t\t}, NativeThread.HIGH_PRIORITY, \"Remove fetching key\");\n\t}","id":60774,"modified_method":"public void removeFetchingKey(final Key key) {\n\t\tsynchronized(keysFetching) {\n\t\t\tkeysFetching.remove(key);\n\t\t}\n\t\tsched.databaseExecutor.execute(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tObjectSet results = container.query(new Predicate() {\n\t\t\t\t\tpublic boolean match(PersistentChosenRequest req) {\n\t\t\t\t\t\tif(req.core != ClientRequestSchedulerCore.this) return false;\n\t\t\t\t\t\treturn req.key.equals(key);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif(results.hasNext()) {\n\t\t\t\t\tPersistentChosenRequest req = (PersistentChosenRequest) results.next();\n\t\t\t\t\tcontainer.delete(req);\n\t\t\t\t\tcontainer.commit();\n\t\t\t\t}\n\t\t\t}\n\t\t}, NativeThread.NORM_PRIORITY, \"Remove fetching key\");\n\t}","commit_id":"4c5762c936bf6c22b28f38846344984b82e3cc46","url":"https://github.com/freenet/fred"},{"original_method":"public void internalError(Object keyNum, Throwable t, RequestScheduler sched) {\n\t\tonFailure(new LowLevelGetException(LowLevelGetException.INTERNAL_ERROR, t.getMessage(), t), keyNum, sched);\n\t}","id":60775,"modified_method":"public void internalError(final Object keyNum, final Throwable t, final RequestScheduler sched) {\n\t\tsched.getDatabaseExecutor().execute(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tonFailure(new LowLevelGetException(LowLevelGetException.INTERNAL_ERROR, t.getMessage(), t), keyNum, sched);\n\t\t\t}\n\t\t}, NativeThread.MAX_PRIORITY, // ensure this is run before the callback to remove the request from the running requests list \n\t\t\"Internal error\");\n\t}","commit_id":"4c5762c936bf6c22b28f38846344984b82e3cc46","url":"https://github.com/freenet/fred"},{"original_method":"/** Do the request, blocking. Called by RequestStarter. \n\t * @return True if a request was executed. False if caller should try to find another request, and remove\n\t * this one from the queue. */\n\tpublic boolean send(NodeClientCore core, RequestScheduler sched, Object keyNum) {\n\t\tClientKey key = getKey(keyNum);\n\t\tif(key == null) {\n\t\t\tLogger.error(this, \"Key is null in send(): keyNum = \"+keyNum+\" for \"+this);\n\t\t\treturn false;\n\t\t}\n\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\tLogger.minor(this, \"Sending get for key \"+keyNum+\" : \"+key);\n\t\tFetchContext ctx = getContext();\n\t\tlong now = System.currentTimeMillis();\n\t\tif(getCooldownWakeupByKey(key.getNodeKey()) > now) {\n\t\t\tLogger.error(this, \"Key is still on the cooldown queue in send() for \"+this+\" - key = \"+key, new Exception(\"error\"));\n\t\t\treturn false;\n\t\t}\n\t\tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tif(isCancelled()) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Cancelled: \"+this);\n\t\t\tonFailure(new LowLevelGetException(LowLevelGetException.CANCELLED), null, sched);\n\t\t\treturn false;\n\t\t}\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tcore.realGetKey(key, ctx.localRequestOnly, ctx.cacheLocalRequests, ctx.ignoreStore);\n\t\t\t} catch (LowLevelGetException e) {\n\t\t\t\tonFailure(e, keyNum, sched);\n\t\t\t\treturn true;\n\t\t\t} catch (Throwable t) {\n\t\t\t\tLogger.error(this, \"Caught \"+t, t);\n\t\t\t\tonFailure(new LowLevelGetException(LowLevelGetException.INTERNAL_ERROR), keyNum, sched);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// Don't call onSuccess(), it will be called for us by backdoor coalescing.\n\t\t\tsched.succeeded(this);\n\t\t} catch (Throwable t) {\n\t\t\tLogger.error(this, \"Caught \"+t, t);\n\t\t\tonFailure(new LowLevelGetException(LowLevelGetException.INTERNAL_ERROR), keyNum, sched);\n\t\t\treturn true;\n\t\t}\n\t\treturn true;\n\t}","id":60776,"modified_method":"/** Do the request, blocking. Called by RequestStarter. \n\t * @return True if a request was executed. False if caller should try to find another request, and remove\n\t * this one from the queue. */\n\tpublic boolean send(NodeClientCore core, final RequestScheduler sched, final Object keyNum) {\n\t\tClientKey key = getKey(keyNum);\n\t\tif(key == null) {\n\t\t\tLogger.error(this, \"Key is null in send(): keyNum = \"+keyNum+\" for \"+this);\n\t\t\treturn false;\n\t\t}\n\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\tLogger.minor(this, \"Sending get for key \"+keyNum+\" : \"+key);\n\t\tFetchContext ctx = getContext();\n\t\tlong now = System.currentTimeMillis();\n\t\tif(getCooldownWakeupByKey(key.getNodeKey()) > now) {\n\t\t\tLogger.error(this, \"Key is still on the cooldown queue in send() for \"+this+\" - key = \"+key, new Exception(\"error\"));\n\t\t\treturn false;\n\t\t}\n\t\tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tif(isCancelled()) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Cancelled: \"+this);\n\t\t\t// callbacks must initially run at HIGH_PRIORITY so they are executed before we remove the key from the currently running list\n\t\t\tsched.callFailure(this, new LowLevelGetException(LowLevelGetException.CANCELLED), null, NativeThread.HIGH_PRIORITY, \"onFailure(cancelled)\");\n\t\t\treturn false;\n\t\t}\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tcore.realGetKey(key, ctx.localRequestOnly, ctx.cacheLocalRequests, ctx.ignoreStore);\n\t\t\t} catch (final LowLevelGetException e) {\n\t\t\t\tsched.callFailure(this, e, keyNum, NativeThread.HIGH_PRIORITY, \"onFailure\");\n\t\t\t\treturn true;\n\t\t\t} catch (Throwable t) {\n\t\t\t\tLogger.error(this, \"Caught \"+t, t);\n\t\t\t\tsched.callFailure(this, new LowLevelGetException(LowLevelGetException.INTERNAL_ERROR), keyNum, NativeThread.HIGH_PRIORITY, \"onFailure(caught throwable)\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// Don't call onSuccess(), it will be called for us by backdoor coalescing.\n\t\t\tsched.succeeded(this);\n\t\t} catch (Throwable t) {\n\t\t\tLogger.error(this, \"Caught \"+t, t);\n\t\t\tsched.callFailure(this, new LowLevelGetException(LowLevelGetException.INTERNAL_ERROR), keyNum, NativeThread.HIGH_PRIORITY, \"onFailure(caught throwable)\");\n\t\t\treturn true;\n\t\t}\n\t\treturn true;\n\t}","commit_id":"4c5762c936bf6c22b28f38846344984b82e3cc46","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n    public Processor createProcessor(RouteContext routeContext) throws Exception {\n\n        ThreadProcessor thread = new ThreadProcessor();\n        thread.setExecutor(executor);\n        thread.setCoreSize(coreSize);\n        thread.setDaemon(daemon);\n        thread.setKeepAliveTime(keepAliveTime);\n        thread.setMaxSize(maxSize);\n        thread.setName(name);\n        thread.setPriority(priority);\n        thread.setStackSize(stackSize);\n        thread.setTaskQueue(taskQueue);\n        thread.setThreadGroup(threadGroup);\n\n        // TODO: see if we can avoid creating so many nested pipelines\n\n        ArrayList<Processor> pipe = new ArrayList<Processor>(2);\n        pipe.add(thread);\n        pipe.add(createOutputsProcessor(routeContext, outputs));\n        return new Pipeline(pipe);\n    }","id":60777,"modified_method":"@Override\n    public Processor createProcessor(RouteContext routeContext) throws Exception {\n\n        ThreadProcessor thread = new ThreadProcessor();\n        thread.setExecutor(executor);\n        if (coreSize != null) {\n            thread.setCoreSize(coreSize);\n        }\n        if (daemon != null) {\n            thread.setDaemon(daemon);\n        }\n        if (keepAliveTime != null) {\n            thread.setKeepAliveTime(keepAliveTime);\n        }\n        if (maxSize != null) {\n            thread.setMaxSize(maxSize);\n        }\n        thread.setName(name);\n        thread.setPriority(priority);\n        if (stackSize != null) {\n            thread.setStackSize(stackSize);\n        }\n        thread.setTaskQueue(taskQueue);\n        thread.setThreadGroup(threadGroup);\n\n        // TODO: see if we can avoid creating so many nested pipelines\n\n        ArrayList<Processor> pipe = new ArrayList<Processor>(2);\n        pipe.add(thread);\n        pipe.add(createOutputsProcessor(routeContext, outputs));\n        return new Pipeline(pipe);\n    }","commit_id":"71b3bdc869afde6befcd60a25dda2a0047b4f371","url":"https://github.com/apache/camel"},{"original_method":"protected void init()\n      throws Exception\n   {\n\n      TCP_NIO NIOreceiver = (TCP_NIO)receiver;\n      // Create worker thread pool for processing incoming buffers\n      m_requestProcessors = new PooledExecutor(new BoundedBuffer(NIOreceiver.getProcessorQueueSize()), NIOreceiver.getProcessorMaxThreads());\n      m_requestProcessors.setMinimumPoolSize(NIOreceiver.getProcessorMinThreads());\n      m_requestProcessors.setKeepAliveTime(NIOreceiver.getProcessormKeepAliveTime());\n      m_requestProcessors.waitWhenBlocked();\n      m_requestProcessors.createThreads(NIOreceiver.getProcessorThreads());\n      m_writeHandlers = WriteHandler.create(NIOreceiver.getWriterThreads());\n      m_readHandlers = new ReadHandler[NIOreceiver.getReaderThreads()];\n      for (int i = 0; i < m_readHandlers.length; i++)\n         m_readHandlers[i] = new ReadHandler();\n   }","id":60778,"modified_method":"protected void init()\n      throws Exception\n   {\n\n      TCP_NIO NIOreceiver = (TCP_NIO)receiver;\n      // use directExector if max thread pool size is less than or equal to zero\n      // this will be useful for small clusters where we will have a reader/writer\n      // thread for each cluster node.  In a small cluster, the readerThread will\n      // execute the request or response that we read.  In a large cluster, the\n      // ProcessorMaxThreads will be set to the number of threads that will handle\n      // processing the request/response that we read.\n      if(NIOreceiver.getProcessorMaxThreads() <= 0) {\n         m_requestProcessors = new DirectExecutor();\n      }\n      else\n      {\n         // Create worker thread pool for processing incoming buffers\n         PooledExecutor requestProcessors = new PooledExecutor(new BoundedBuffer(NIOreceiver.getProcessorQueueSize()), NIOreceiver.getProcessorMaxThreads());\n         requestProcessors.setMinimumPoolSize(NIOreceiver.getProcessorMinThreads());\n         requestProcessors.setKeepAliveTime(NIOreceiver.getProcessormKeepAliveTime());\n         requestProcessors.waitWhenBlocked();\n         requestProcessors.createThreads(NIOreceiver.getProcessorThreads());\n         m_requestProcessors = requestProcessors;\n      }\n\n      m_writeHandlers = WriteHandler.create(NIOreceiver.getWriterThreads());\n      m_readHandlers = new ReadHandler[NIOreceiver.getReaderThreads()];\n      for (int i = 0; i < m_readHandlers.length; i++)\n         m_readHandlers[i] = new ReadHandler();\n   }","commit_id":"4cd55bfa805cdd3f22a85aab05d170276fc00763","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n    * Closes all open sockets, the server socket and all threads waiting for incoming messages\n    */\n   public void stop()\n   {\n      if (m_serverSocketChannel.isOpen())\n      {\n         try\n         {\n            m_serverSocketChannel.close();\n         }\n         catch (Exception eat)\n         {\n\n         }\n      }\n\n      // Stop the main selector\n      m_acceptSelector.wakeup();\n      // Stop selector threads\n      for (int i = 0; i < m_readHandlers.length; i++)\n      {\n         try\n         {\n            m_readHandlers[i].add(new Shutdown());\n         } catch (InterruptedException e)\n         {\n            LOG.error(\"Thread (\"+Thread.currentThread().getName() +\") was interrupted, failed to shutdown selector\", e);\n         }\n      }\n      for (int i = 0; i < m_writeHandlers.length; i++)\n      {\n         try\n         {\n            m_writeHandlers[i].QUEUE.put(new Shutdown());\n            m_writeHandlers[i].m_selector.wakeup();\n         } catch (InterruptedException e)\n         {\n            LOG.error(\"Thread (\"+Thread.currentThread().getName() +\") was interrupted, failed to shutdown selector\", e);\n         }\n      }\n\n      // Stop the callback thread pool\n      m_requestProcessors.shutdownNow();\n\n      super.stop();\n\n   }","id":60779,"modified_method":"/**\n    * Closes all open sockets, the server socket and all threads waiting for incoming messages\n    */\n   public void stop()\n   {\n      if (m_serverSocketChannel.isOpen())\n      {\n         try\n         {\n            m_serverSocketChannel.close();\n         }\n         catch (Exception eat)\n         {\n\n         }\n      }\n\n      // Stop the main selector\n      m_acceptSelector.wakeup();\n      // Stop selector threads\n      for (int i = 0; i < m_readHandlers.length; i++)\n      {\n         try\n         {\n            m_readHandlers[i].add(new Shutdown());\n         } catch (InterruptedException e)\n         {\n            LOG.error(\"Thread (\"+Thread.currentThread().getName() +\") was interrupted, failed to shutdown selector\", e);\n         }\n      }\n      for (int i = 0; i < m_writeHandlers.length; i++)\n      {\n         try\n         {\n            m_writeHandlers[i].QUEUE.put(new Shutdown());\n            m_writeHandlers[i].m_selector.wakeup();\n         } catch (InterruptedException e)\n         {\n            LOG.error(\"Thread (\"+Thread.currentThread().getName() +\") was interrupted, failed to shutdown selector\", e);\n         }\n      }\n\n      // Stop the callback thread pool\n      if(m_requestProcessors instanceof PooledExecutor)\n         ((PooledExecutor)m_requestProcessors).shutdownNow();\n\n      super.stop();\n\n   }","commit_id":"4cd55bfa805cdd3f22a85aab05d170276fc00763","url":"https://github.com/belaban/JGroups"},{"original_method":"protected void init()\n      throws Exception\n   {\n\n      TCP_NIO NIOreceiver = (TCP_NIO)receiver;\n      // Create worker thread pool for processing incoming buffers\n      m_requestProcessors = new PooledExecutor(new BoundedBuffer(NIOreceiver.getProcessorQueueSize()), NIOreceiver.getProcessorMaxThreads());\n      m_requestProcessors.setMinimumPoolSize(NIOreceiver.getProcessorMinThreads());\n      m_requestProcessors.setKeepAliveTime(NIOreceiver.getProcessormKeepAliveTime());\n      m_requestProcessors.waitWhenBlocked();\n      m_requestProcessors.createThreads(NIOreceiver.getProcessorThreads());\n      m_writeHandlers = WriteHandler.create(NIOreceiver.getWriterThreads());\n      m_readHandlers = new ReadHandler[NIOreceiver.getReaderThreads()];\n      for (int i = 0; i < m_readHandlers.length; i++)\n         m_readHandlers[i] = new ReadHandler();\n   }","id":60780,"modified_method":"protected void init()\n      throws Exception\n   {\n\n      TCP_NIO NIOreceiver = (TCP_NIO)receiver;\n      // use directExector if max thread pool size is less than or equal to zero\n      // this will be useful for small clusters where we will have a reader/writer\n      // thread for each cluster node.  In a small cluster, the readerThread will\n      // execute the request or response that we read.  In a large cluster, the\n      // ProcessorMaxThreads will be set to the number of threads that will handle\n      // processing the request/response that we read.\n      if(NIOreceiver.getProcessorMaxThreads() <= 0) {\n         m_requestProcessors = new DirectExecutor();\n      }\n      else\n      {\n         // Create worker thread pool for processing incoming buffers\n         PooledExecutor requestProcessors = new PooledExecutor(new BoundedBuffer(NIOreceiver.getProcessorQueueSize()), NIOreceiver.getProcessorMaxThreads());\n         requestProcessors.setMinimumPoolSize(NIOreceiver.getProcessorMinThreads());\n         requestProcessors.setKeepAliveTime(NIOreceiver.getProcessormKeepAliveTime());\n         requestProcessors.waitWhenBlocked();\n         requestProcessors.createThreads(NIOreceiver.getProcessorThreads());\n         m_requestProcessors = requestProcessors;\n      }\n\n      m_writeHandlers = WriteHandler.create(NIOreceiver.getWriterThreads());\n      m_readHandlers = new ReadHandler[NIOreceiver.getReaderThreads()];\n      for (int i = 0; i < m_readHandlers.length; i++)\n         m_readHandlers[i] = new ReadHandler();\n   }","commit_id":"d2c8701fbf7fcbab6790e6f8698dcd772242638f","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n    * Closes all open sockets, the server socket and all threads waiting for incoming messages\n    */\n   public void stop()\n   {\n      if (m_serverSocketChannel.isOpen())\n      {\n         try\n         {\n            m_serverSocketChannel.close();\n         }\n         catch (Exception eat)\n         {\n\n         }\n      }\n\n      // Stop the main selector\n      m_acceptSelector.wakeup();\n      // Stop selector threads\n      for (int i = 0; i < m_readHandlers.length; i++)\n      {\n         try\n         {\n            m_readHandlers[i].add(new Shutdown());\n         } catch (InterruptedException e)\n         {\n            LOG.error(\"Thread (\"+Thread.currentThread().getName() +\") was interrupted, failed to shutdown selector\", e);\n         }\n      }\n      for (int i = 0; i < m_writeHandlers.length; i++)\n      {\n         try\n         {\n            m_writeHandlers[i].QUEUE.put(new Shutdown());\n            m_writeHandlers[i].m_selector.wakeup();\n         } catch (InterruptedException e)\n         {\n            LOG.error(\"Thread (\"+Thread.currentThread().getName() +\") was interrupted, failed to shutdown selector\", e);\n         }\n      }\n\n      // Stop the callback thread pool\n      m_requestProcessors.shutdownNow();\n\n      super.stop();\n\n   }","id":60781,"modified_method":"/**\n    * Closes all open sockets, the server socket and all threads waiting for incoming messages\n    */\n   public void stop()\n   {\n      if (m_serverSocketChannel.isOpen())\n      {\n         try\n         {\n            m_serverSocketChannel.close();\n         }\n         catch (Exception eat)\n         {\n\n         }\n      }\n\n      // Stop the main selector\n      m_acceptSelector.wakeup();\n      // Stop selector threads\n      for (int i = 0; i < m_readHandlers.length; i++)\n      {\n         try\n         {\n            m_readHandlers[i].add(new Shutdown());\n         } catch (InterruptedException e)\n         {\n            LOG.error(\"Thread (\"+Thread.currentThread().getName() +\") was interrupted, failed to shutdown selector\", e);\n         }\n      }\n      for (int i = 0; i < m_writeHandlers.length; i++)\n      {\n         try\n         {\n            m_writeHandlers[i].QUEUE.put(new Shutdown());\n            m_writeHandlers[i].m_selector.wakeup();\n         } catch (InterruptedException e)\n         {\n            LOG.error(\"Thread (\"+Thread.currentThread().getName() +\") was interrupted, failed to shutdown selector\", e);\n         }\n      }\n\n      // Stop the callback thread pool\n      if(m_requestProcessors instanceof PooledExecutor)\n         ((PooledExecutor)m_requestProcessors).shutdownNow();\n\n      super.stop();\n\n   }","commit_id":"d2c8701fbf7fcbab6790e6f8698dcd772242638f","url":"https://github.com/belaban/JGroups"},{"original_method":"public final void setInitParams(Dictionary map)\n    {\n        this.initParams.clear();\n        if (map == null)\n        {\n            return;\n        }\n\n        Enumeration e = map.keys();\n        while (e.hasMoreElements())\n        {\n            Object key = e.nextElement();\n            Object value = map.get(key);\n\n            if ((key instanceof String) && (value instanceof String))\n            {\n                this.initParams.put((String) key, (String) value);\n            }\n        }\n    }","id":60782,"modified_method":"/**\n     * TODO - We can remove this, once we switched to {@link #setInitParams(Map)}\n     * @param map\n     */\n    public final void setInitParams(Dictionary map)\n    {\n        this.initParams.clear();\n        if (map == null)\n        {\n            return;\n        }\n\n        Enumeration e = map.keys();\n        while (e.hasMoreElements())\n        {\n            Object key = e.nextElement();\n            Object value = map.get(key);\n\n            if ((key instanceof String) && (value instanceof String))\n            {\n                this.initParams.put((String) key, (String) value);\n            }\n        }\n    }","commit_id":"46d1c40a48c1d3bf9264841ac2d22d9865db6f32","url":"https://github.com/apache/felix"},{"original_method":"@Test\n    public void testInitParams()\n    {\n        AbstractHandler handler = createHandler();\n        Assert.assertEquals(0, handler.getInitParams().size());\n\n        Hashtable<String, String> map = new Hashtable<String, String>();\n        map.put(\"key1\", \"value1\");\n\n        handler.setInitParams(map);\n        Assert.assertEquals(1, handler.getInitParams().size());\n        Assert.assertEquals(\"value1\", handler.getInitParams().get(\"key1\"));\n    }","id":60783,"modified_method":"@Test\n    public void testInitParams()\n    {\n        AbstractHandler handler = createHandler();\n        Assert.assertEquals(0, handler.getInitParams().size());\n\n        Dictionary<String, String> map = new Hashtable<String, String>();\n        map.put(\"key1\", \"value1\");\n\n        handler.setInitParams(map);\n        Assert.assertEquals(1, handler.getInitParams().size());\n        Assert.assertEquals(\"value1\", handler.getInitParams().get(\"key1\"));\n    }","commit_id":"46d1c40a48c1d3bf9264841ac2d22d9865db6f32","url":"https://github.com/apache/felix"},{"original_method":"public void register(ServletContext servletContext)\n    {\n        this.contextAttributeListener.open();\n        this.requestListener.open();\n        this.requestAttributeListener.open();\n        this.sessionListener.open();\n        this.sessionAttributeListener.open();\n        this.plugin.register();\n\n        String[] ifaces = new String[] { HttpService.class.getName(), ExtHttpService.class.getName() };\n        HttpServiceFactory factory = new HttpServiceFactory(servletContext, this.registry, this.contextAttributeListener, this.sharedContextAttributes);\n\n        this.serviceReg = this.bundleContext.registerService(ifaces, factory, this.serviceProps);\n    }","id":60784,"modified_method":"public void register(ServletContext servletContext)\n    {\n        this.contextAttributeListener.open();\n        this.requestListener.open();\n        this.requestAttributeListener.open();\n        this.sessionListener.open();\n        this.sessionAttributeListener.open();\n        this.plugin.register();\n\n        String[] ifaces = new String[] { HttpService.class.getName(), ExtHttpService.class.getName() };\n        HttpServiceFactory factory = new HttpServiceFactory(servletContext, this.registry, this.contextAttributeListener, this.sharedContextAttributes);\n\n        this.serviceReg = this.bundleContext.registerService(ifaces, factory, this.serviceProps);\n        this.manager = new ExtenderManager((HttpService)factory.getService(this.bundleContext.getBundle(), this.serviceReg), this.bundleContext);\n\n        this.runtimeReg = this.bundleContext.registerService(HttpServiceRuntime.class, new HttpServiceRuntimeImpl(), null);\n    }","commit_id":"46d1c40a48c1d3bf9264841ac2d22d9865db6f32","url":"https://github.com/apache/felix"},{"original_method":"public void unregister()\n    {\n        if (this.serviceReg == null)\n        {\n            return;\n        }\n\n        this.sessionAttributeListener.close();\n        this.sessionListener.close();\n        this.contextAttributeListener.close();\n        this.requestListener.close();\n        this.requestAttributeListener.close();\n        this.plugin.unregister();\n\n        try\n        {\n            this.serviceReg.unregister();\n            this.registry.removeAll();\n        }\n        finally\n        {\n            this.serviceReg = null;\n        }\n    }","id":60785,"modified_method":"public void unregister()\n    {\n        if ( this.manager != null )\n        {\n            this.manager.close();\n            this.manager = null;\n        }\n\n        if ( this.runtimeReg != null )\n        {\n            this.runtimeReg.unregister();\n            this.runtimeReg = null;\n        }\n\n        this.sessionAttributeListener.close();\n        this.sessionListener.close();\n        this.contextAttributeListener.close();\n        this.requestListener.close();\n        this.requestAttributeListener.close();\n\n        this.plugin.unregister();\n\n        if ( this.serviceReg != null )\n        {\n            try\n            {\n                this.serviceReg.unregister();\n                this.registry.removeAll();\n            }\n            finally\n            {\n                this.serviceReg = null;\n            }\n        }\n    }","commit_id":"46d1c40a48c1d3bf9264841ac2d22d9865db6f32","url":"https://github.com/apache/felix"},{"original_method":"public void registerFilter(Filter filter, FilterInfo filterInfo) throws ServletException\n    {\n        if (filter == null)\n        {\n            throw new IllegalArgumentException(\"Filter cannot be null!\");\n        }\n        if (filterInfo == null)\n        {\n            throw new IllegalArgumentException(\"FilterInfo cannot be null!\");\n        }\n        if (isEmpty(filterInfo.patterns) && isEmpty(filterInfo.regexs) && isEmpty(filterInfo.servletNames))\n        {\n            throw new IllegalArgumentException(\"FilterInfo must have at least one pattern or regex, or provide at least one servlet name!\");\n        }\n        if (isEmpty(filterInfo.name))\n        {\n            filterInfo.name = filter.getClass().getName();\n        }\n\n        ExtServletContext servletContext = getServletContext(filterInfo.context);\n\n        try\n        {\n            FilterHandler handler = new FilterHandler(servletContext, filter, filterInfo);\n\n            synchronized (this)\n            {\n                if (this.localFilters.add(filter))\n                {\n                    this.handlerRegistry.addFilter(handler);\n                }\n            }\n        }\n        catch (Exception e)\n        {\n            if (e instanceof ServletException)\n            {\n                throw (ServletException) e;\n            }\n            else\n            {\n                throw new ServletException(\"Failed to register filter \" + filterInfo.name, e);\n            }\n        }\n    }","id":60786,"modified_method":"public void registerFilter(Filter filter, FilterInfo filterInfo) throws ServletException\n    {\n        if (filter == null)\n        {\n            throw new IllegalArgumentException(\"Filter cannot be null!\");\n        }\n        if (filterInfo == null)\n        {\n            throw new IllegalArgumentException(\"FilterInfo cannot be null!\");\n        }\n        if (isEmpty(filterInfo.patterns) && isEmpty(filterInfo.regexs) && isEmpty(filterInfo.servletNames))\n        {\n            throw new IllegalArgumentException(\"FilterInfo must have at least one pattern or regex, or provide at least one servlet name!\");\n        }\n        if (isEmpty(filterInfo.name))\n        {\n            filterInfo.name = filter.getClass().getName();\n        }\n\n        FilterHandler handler = new FilterHandler(getServletContext(filterInfo.context), filter, filterInfo);\n        handler.setInitParams(filterInfo.initParams);\n        this.handlerRegistry.addFilter(handler);\n        this.localFilters.add(filter);\n    }","commit_id":"46d1c40a48c1d3bf9264841ac2d22d9865db6f32","url":"https://github.com/apache/felix"},{"original_method":"public void registerServlet(Servlet servlet, ServletInfo servletInfo) throws ServletException, NamespaceException\n    {\n        if (servlet == null)\n        {\n            throw new IllegalArgumentException(\"Servlet cannot be null!\");\n        }\n        if (servletInfo == null)\n        {\n            throw new IllegalArgumentException(\"ServletInfo cannot be null!\");\n        }\n        if (isEmpty(servletInfo.patterns) && isEmpty(servletInfo.errorPage))\n        {\n            throw new IllegalArgumentException(\"ServletInfo must at least have one pattern or error page!\");\n        }\n        if (isEmpty(servletInfo.name))\n        {\n            servletInfo.name = servlet.getClass().getName();\n        }\n\n        ExtServletContext servletContext = getServletContext(servletInfo.context);\n\n        try\n        {\n            ServletHandler handler = new ServletHandler(servletContext, servlet, servletInfo);\n\n            synchronized (this)\n            {\n                if (this.localServlets.add(servlet))\n                {\n                    this.handlerRegistry.addServlet(handler);\n                    if (servletInfo.errorPage != null && servletInfo.errorPage.length != 0)\n                    {\n                        for (String errorPage : servletInfo.errorPage)\n                        {\n                            this.handlerRegistry.addErrorServlet(errorPage, handler);\n                        }\n                    }\n                }\n            }\n        }\n        catch (Exception e)\n        {\n            if (e instanceof ServletException)\n            {\n                throw (ServletException) e;\n            }\n            else if (e instanceof NamespaceException)\n            {\n                throw (NamespaceException) e;\n            }\n            else\n            {\n                throw new ServletException(\"Failed to register servlet \" + servletInfo.name, e);\n            }\n        }\n    }","id":60787,"modified_method":"public void registerServlet(Servlet servlet, ServletInfo servletInfo) throws ServletException, NamespaceException\n    {\n        if (servlet == null)\n        {\n            throw new IllegalArgumentException(\"Servlet cannot be null!\");\n        }\n        if (servletInfo == null)\n        {\n            throw new IllegalArgumentException(\"ServletInfo cannot be null!\");\n        }\n        if (isEmpty(servletInfo.patterns) && isEmpty(servletInfo.errorPage))\n        {\n            throw new IllegalArgumentException(\"ServletInfo must at least have one pattern or error page!\");\n        }\n        if (isEmpty(servletInfo.name))\n        {\n            servletInfo.name = servlet.getClass().getName();\n        }\n\n        ServletHandler handler = new ServletHandler(getServletContext(servletInfo.context), servlet, servletInfo);\n        handler.setInitParams(servletInfo.initParams);\n        this.handlerRegistry.addServlet(handler);\n        this.localServlets.add(servlet);\n    }","commit_id":"46d1c40a48c1d3bf9264841ac2d22d9865db6f32","url":"https://github.com/apache/felix"},{"original_method":"@Override\n\tpublic void deployConfig(WebApplicationContext cxt) {\n\t\tServletContextHandler contextHandler = new ServletContextHandler();\n\t\tServletHolder servletHolder = new ServletHolder(new DispatcherServlet(cxt));\n\t\tcontextHandler.addServlet(servletHolder, \"/\");\n\t\tthis.jettyServer.setHandler(contextHandler);\n\t}","id":60788,"modified_method":"@Override\n\tpublic void deployConfig(WebApplicationContext cxt, Filter... filters) {\n\t\tServletContextHandler contextHandler = new ServletContextHandler();\n\t\tServletHolder servletHolder = new ServletHolder(new DispatcherServlet(cxt));\n\t\tcontextHandler.addServlet(servletHolder, \"/\");\n\t\tfor (Filter filter : filters) {\n\t\t\tcontextHandler.addFilter(new FilterHolder(filter), \"/*\", getDispatcherTypes());\n\t\t}\n\t\tthis.jettyServer.setHandler(contextHandler);\n\t}","commit_id":"dc1d85d0459b19137687d1b0449ac2c0006a079e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic void deployConfig(WebApplicationContext wac) {\n        this.context = this.tomcatServer.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));\n        this.context.addApplicationListener(WS_APPLICATION_LISTENER);\n\t\tTomcat.addServlet(context, \"dispatcherServlet\", new DispatcherServlet(wac));\n\t\tthis.context.addServletMapping(\"/\", \"dispatcherServlet\");\n\t}","id":60789,"modified_method":"@Override\n\tpublic void deployConfig(WebApplicationContext wac, Filter... filters) {\n        this.context = this.tomcatServer.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));\n        this.context.addApplicationListener(WS_APPLICATION_LISTENER);\n\t\tTomcat.addServlet(this.context, \"dispatcherServlet\", new DispatcherServlet(wac)).setAsyncSupported(true);\n\t\tthis.context.addServletMapping(\"/\", \"dispatcherServlet\");\n\t\tfor (Filter filter : filters) {\n\t\t\tFilterDef filterDef = new FilterDef();\n\t\t\tfilterDef.setFilterName(filter.getClass().getName());\n\t\t\tfilterDef.setFilter(filter);\n\t\t\tfilterDef.setAsyncSupported(\"true\");\n\t\t\tthis.context.addFilterDef(filterDef);\n\t\t\tFilterMap filterMap = new FilterMap();\n\t\t\tfilterMap.setFilterName(filter.getClass().getName());\n\t\t\tfilterMap.addURLPattern(\"/*\");\n\t\t\tfilterMap.setDispatcher(\"REQUEST,FORWARD,INCLUDE,ASYNC\");\n\t\t\tthis.context.addFilterMap(filterMap);\n\t\t}\n\t}","commit_id":"dc1d85d0459b19137687d1b0449ac2c0006a079e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic void deployConfig(WebApplicationContext cxt) {\n\t\tDispatcherServletInstanceFactory servletFactory = new DispatcherServletInstanceFactory(cxt);\n\n\t\tDeploymentInfo servletBuilder = deployment()\n\t\t\t\t.setClassLoader(UndertowTestServer.class.getClassLoader())\n\t\t\t\t.setDeploymentName(\"undertow-websocket-test\")\n\t\t\t\t.setContextPath(\"/\")\n\t\t\t\t.addServlet(servlet(\"DispatcherServlet\", DispatcherServlet.class, servletFactory).addMapping(\"/\"))\n\t\t\t\t.addServletContextAttribute(WebSocketDeploymentInfo.ATTRIBUTE_NAME, new WebSocketDeploymentInfo());\n\n\t\tthis.manager = defaultContainer().addDeployment(servletBuilder);\n\t\tthis.manager.deploy();\n\n\t\ttry {\n\t\t\tthis.server = Undertow.builder()\n\t\t\t\t\t.addHttpListener(this.port, \"localhost\")\n\t\t\t\t\t.setHandler(this.manager.start()).build();\n\t\t}\n\t\tcatch (ServletException ex) {\n\t\t\tthrow new IllegalStateException(ex);\n\t\t}\n\t}","id":60790,"modified_method":"@Override\n\tpublic void deployConfig(WebApplicationContext cxt, Filter... filters) {\n\t\tDispatcherServletInstanceFactory servletFactory = new DispatcherServletInstanceFactory(cxt);\n\n\t\tDeploymentInfo servletBuilder = deployment()\n\t\t\t\t.setClassLoader(UndertowTestServer.class.getClassLoader())\n\t\t\t\t.setDeploymentName(\"undertow-websocket-test\")\n\t\t\t\t.setContextPath(\"/\")\n\t\t\t\t.addServlet(servlet(\"DispatcherServlet\", DispatcherServlet.class, servletFactory).addMapping(\"/\"))\n\t\t\t\t.addServletContextAttribute(WebSocketDeploymentInfo.ATTRIBUTE_NAME, new WebSocketDeploymentInfo());\n\n\t\tfor (final Filter filter : filters) {\n\t\t\tString filterName = filter.getClass().getName();\n\t\t\tservletBuilder.addFilter(new FilterInfo(filterName, filter.getClass(), new FilterInstanceFactory(filter)));\n\t\t\tfor (DispatcherType type : DispatcherType.values()) {\n\t\t\t\tservletBuilder.addFilterUrlMapping(filterName, \"/*\", type);\n\t\t\t}\n\t\t}\n\t\tthis.manager = defaultContainer().addDeployment(servletBuilder);\n\t\tthis.manager.deploy();\n\n\t\ttry {\n\t\t\tthis.server = Undertow.builder()\n\t\t\t\t\t.addHttpListener(this.port, \"localhost\")\n\t\t\t\t\t.setHandler(this.manager.start()).build();\n\t\t}\n\t\tcatch (ServletException ex) {\n\t\t\tthrow new IllegalStateException(ex);\n\t\t}\n\t}","commit_id":"dc1d85d0459b19137687d1b0449ac2c0006a079e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tprotected Class<?>[] getAnnotatedConfigClasses() {\n\t\treturn new Class<?>[] {TestWebSocketConfigurer.class};\n\t}","id":60791,"modified_method":"@Override\n\tprotected Class<?>[] getAnnotatedConfigClasses() {\n\t\treturn new Class<?>[] { TestConfig.class };\n\t}","commit_id":"dc1d85d0459b19137687d1b0449ac2c0006a079e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void registerWebSocketHandler() throws Exception {\n\t\tWebSocketSession session = this.webSocketClient.doHandshake(\n\t\t\t\tnew AbstractWebSocketHandler() {}, getWsBaseUrl() + \"/ws\").get();\n\n\t\tTestWebSocketHandler serverHandler = this.wac.getBean(TestWebSocketHandler.class);\n\t\tassertTrue(serverHandler.connectLatch.await(2, TimeUnit.SECONDS));\n\n\t\tsession.close();\n\t}","id":60792,"modified_method":"@Test\n\tpublic void registerWebSocketHandler() throws Exception {\n\t\tWebSocketSession session = this.webSocketClient.doHandshake(\n\t\t\t\tnew AbstractWebSocketHandler() {}, getWsBaseUrl() + \"/ws\").get();\n\n\t\tTestHandler serverHandler = this.wac.getBean(TestHandler.class);\n\t\tassertTrue(serverHandler.connectLatch.await(2, TimeUnit.SECONDS));\n\n\t\tsession.close();\n\t}","commit_id":"dc1d85d0459b19137687d1b0449ac2c0006a079e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void registerWebSocketHandlerWithSockJS() throws Exception {\n\t\tWebSocketSession session = this.webSocketClient.doHandshake(\n\t\t\t\tnew AbstractWebSocketHandler() {}, getWsBaseUrl() + \"/sockjs/websocket\").get();\n\n\t\tTestWebSocketHandler serverHandler = this.wac.getBean(TestWebSocketHandler.class);\n\t\tassertTrue(serverHandler.connectLatch.await(2, TimeUnit.SECONDS));\n\n\t\tsession.close();\n\t}","id":60793,"modified_method":"@Test\n\tpublic void registerWebSocketHandlerWithSockJS() throws Exception {\n\t\tWebSocketSession session = this.webSocketClient.doHandshake(\n\t\t\t\tnew AbstractWebSocketHandler() {}, getWsBaseUrl() + \"/sockjs/websocket\").get();\n\n\t\tTestHandler serverHandler = this.wac.getBean(TestHandler.class);\n\t\tassertTrue(serverHandler.connectLatch.await(2, TimeUnit.SECONDS));\n\n\t\tsession.close();\n\t}","commit_id":"dc1d85d0459b19137687d1b0449ac2c0006a079e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tprotected Class<?>[] getAnnotatedConfigClasses() {\n\t\treturn new Class<?>[] {TestWebSocketConfigurer.class};\n\t}","id":60794,"modified_method":"@Override\n\tprotected Class<?>[] getAnnotatedConfigClasses() {\n\t\treturn new Class<?>[] { TestConfig.class };\n\t}","commit_id":"dc1d85d0459b19137687d1b0449ac2c0006a079e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void subProtocolNegotiation() throws Exception {\n\t\tWebSocketHttpHeaders headers = new WebSocketHttpHeaders();\n\t\theaders.setSecWebSocketProtocol(\"foo\");\n\n\t\tWebSocketSession session = this.webSocketClient.doHandshake(\n\t\t\t\tnew AbstractWebSocketHandler() {}, headers, new URI(getWsBaseUrl() + \"/ws\")).get();\n\n\t\tassertEquals(\"foo\", session.getAcceptedProtocol());\n\t}","id":60795,"modified_method":"@Test\n\tpublic void subProtocolNegotiation() throws Exception {\n\t\tWebSocketHttpHeaders headers = new WebSocketHttpHeaders();\n\t\theaders.setSecWebSocketProtocol(\"foo\");\n\t\tURI url = new URI(getWsBaseUrl() + \"/ws\");\n\t\tWebSocketSession session = this.webSocketClient.doHandshake(new TextWebSocketHandler(), headers, url).get();\n\t\tassertEquals(\"foo\", session.getAcceptedProtocol());\n\t}","commit_id":"dc1d85d0459b19137687d1b0449ac2c0006a079e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n        protected void performBoottime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n            try {\n                Class.forName(\"org.apache.jasper.compiler.JspRuntimeContext\", true, this.getClass().getClassLoader());\n            } catch (ClassNotFoundException e) {\n                UndertowLogger.ROOT_LOGGER.couldNotInitJsp(e);\n            }\n        }","id":60796,"modified_method":"@Override\n        protected void performBoottime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n            try {\n                Class.forName(\"org.apache.jasper.compiler.JspRuntimeContext\", true, this.getClass().getClassLoader());\n\n                final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n                final PathAddress parent = address.subAddress(0, address.size() - 1);\n                String servletContainerName = parent.getLastElement().getValue();\n\n                ModelNode resolved = new ModelNode();\n                for (AttributeDefinition attribute : ATTRIBUTES) {\n                    resolved.get(attribute.getName()).set(attribute.resolveModelAttribute(context, model));\n                }\n                final JSPService jspService = new JSPService(resolved);\n                final ServiceTarget target = context.getServiceTarget();\n                ServiceBuilder<JSPService> svcBuilder = target.addService(UndertowService.SERVLET_CONTAINER.append(servletContainerName).append(Constants.JSP), jspService)\n                        .setInitialMode(ServiceController.Mode.ON_DEMAND);\n\n                if (verificationHandler != null) {\n                    svcBuilder.addListener(verificationHandler);\n                }\n                newControllers.add(svcBuilder.install());\n\n            } catch (ClassNotFoundException e) {\n                UndertowLogger.ROOT_LOGGER.couldNotInitJsp(e);\n            }\n        }","commit_id":"ce39eda03275b4831bcae7d65172dc531e749b69","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performBoottime(OperationContext context, ModelNode operation, final ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final String name = address.getLastElement().getValue();\n\n        final ServletContainerService container = new ServletContainerService();\n        final ServiceTarget target = context.getServiceTarget();\n        newControllers.add(target.addService(UndertowService.SERVLET_CONTAINER.append(name), container)\n                .setInitialMode(ServiceController.Mode.ON_DEMAND)\n                .install());\n\n    }","id":60797,"modified_method":"@Override\n    protected void performBoottime(OperationContext context, ModelNode operation, final ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final String name = address.getLastElement().getValue();\n\n        final ServletContainerService container = new ServletContainerService();\n        final ServiceTarget target = context.getServiceTarget();\n        newControllers.add(target.addService(UndertowService.SERVLET_CONTAINER.append(name), container)\n                .addDependency(UndertowService.SERVLET_CONTAINER.append(name).append(Constants.JSP), JSPService.class, container.getJspService())\n                .setInitialMode(ServiceController.Mode.ON_DEMAND)\n                .install());\n\n    }","commit_id":"ce39eda03275b4831bcae7d65172dc531e749b69","url":"https://github.com/wildfly/wildfly"},{"original_method":"WebMetaData create() {\n        final WebMetaData metadata = new WebMetaData();\n\n        metadata.setServlets(new ServletsMetaData());\n\n        // Add DefaultServlet\n        enableStaticResouces(metadata);\n        // Add JSPServlet\n        enableJsp(metadata);\n\n        // Session config\n        final SessionConfigMetaData sessionConfig = new SessionConfigMetaData();\n        sessionConfig.setSessionTimeout(30);\n        metadata.setSessionConfig(sessionConfig);\n\n        // Mime mappings\n        metadata.setMimeMappings(Collections.unmodifiableList(mimeMappings));\n\n        // Welcome files\n        metadata.setWelcomeFileList(new WelcomeFileListMetaData());\n        metadata.getWelcomeFileList().setWelcomeFiles(Collections.unmodifiableList(welcomeFiles));\n        return metadata;\n    }","id":60798,"modified_method":"WebMetaData create() {\n        final WebMetaData metadata = new WebMetaData();\n\n        metadata.setServlets(new ServletsMetaData());\n\n        // Session config\n        final SessionConfigMetaData sessionConfig = new SessionConfigMetaData();\n        sessionConfig.setSessionTimeout(30);\n        metadata.setSessionConfig(sessionConfig);\n\n        // Mime mappings\n        metadata.setMimeMappings(Collections.unmodifiableList(mimeMappings));\n\n        // Welcome files\n        metadata.setWelcomeFileList(new WelcomeFileListMetaData());\n        metadata.getWelcomeFileList().setWelcomeFiles(Collections.unmodifiableList(welcomeFiles));\n        return metadata;\n    }","commit_id":"ce39eda03275b4831bcae7d65172dc531e749b69","url":"https://github.com/wildfly/wildfly"},{"original_method":"private DeploymentInfo createServletConfig() throws StartException {\n        try {\n            mergedMetaData.resolveAnnotations();\n            final DeploymentInfo d = new DeploymentInfo();\n            d.setContextPath(contextPath);\n            if (mergedMetaData.getDescriptionGroup() != null) {\n                d.setDisplayName(mergedMetaData.getDescriptionGroup().getDisplayName());\n            }\n            d.setDeploymentName(deploymentName);\n            try {\n                //TODO: make the caching limits configurable\n                ResourceManager resourceManager = new ServletResourceManager(deploymentRoot, overlays);\n                d.setResourceManager(new CachingResourceManager(100, 10 * 1024 * 1024, bufferCacheInjectedValue.getOptionalValue(), resourceManager, -1));\n            } catch (IOException e) {\n                throw new StartException(e);\n            }\n\n            File tempFile = new File(pathManagerInjector.getValue().getPathEntry(TEMP_DIR).resolvePath(), deploymentName);\n            tempFile.mkdirs();\n            d.setTempDir(tempFile);\n\n            d.setClassLoader(module.getClassLoader());\n            final String servletVersion = mergedMetaData.getServletVersion();\n            if (servletVersion != null) {\n                d.setMajorVersion(Integer.parseInt(servletVersion.charAt(0) + \"\"));\n                d.setMinorVersion(Integer.parseInt(servletVersion.charAt(2) + \"\"));\n            } else {\n                d.setMajorVersion(3);\n                d.setMinorVersion(1);\n            }\n\n            //for 2.2 apps we do not require a leading / in path mappings\n            boolean is22OrOlder;\n            if (d.getMajorVersion() == 1) {\n                is22OrOlder = true;\n            } else if (d.getMajorVersion() == 2) {\n                is22OrOlder = d.getMinorVersion() < 3;\n            } else {\n                is22OrOlder = false;\n            }\n\n            HashMap<String, TagLibraryInfo> tldInfo = createTldsInfo(tldsMetaData, sharedTlds);\n            HashMap<String, JspPropertyGroup> propertyGroups = createJspConfig(mergedMetaData);\n\n            JspServletBuilder.setupDeployment(d, propertyGroups, tldInfo, new UndertowJSPInstanceManager(injectionContainer));\n\n            if(mergedMetaData.getJspConfig() != null) {\n                d.setJspConfigDescriptor(new JspConfigDescriptorImpl(tldInfo.values(), propertyGroups.values()));\n            }\n\n            d.setDefaultServletConfig(new DefaultServletConfig(true, Collections.<String>emptySet()));\n\n            //default JSP servlet\n            final ServletInfo jspServlet = new ServletInfo(\"Default JSP Servlet\", JspServlet.class)\n                    .addMapping(\"*.jsp\")\n                    .addMapping(\"*.jspx\")\n                    .addInitParam(\"development\", \"false\"); //todo: make configurable\n            d.addServlet(jspServlet);\n\n            final Set<String> jspPropertyGroupMappings = propertyGroups.keySet();\n            for (final String mapping : jspPropertyGroupMappings) {\n                jspServlet.addMapping(mapping);\n            }\n\n\n            //setup JSP expression factory wrapper\n            if (!expressionFactoryWrappers.isEmpty()) {\n                d.addListener(new ListenerInfo(JspInitializationListener.class));\n                d.addServletContextAttribute(JspInitializationListener.CONTEXT_KEY, expressionFactoryWrappers);\n            }\n\n            d.setClassIntrospecter(new ComponentClassIntrospector(componentRegistry));\n\n            final Map<String, List<ServletMappingMetaData>> servletMappings = new HashMap<>();\n\n            if (mergedMetaData.getServletMappings() != null) {\n                for (final ServletMappingMetaData mapping : mergedMetaData.getServletMappings()) {\n                    List<ServletMappingMetaData> list = servletMappings.get(mapping.getServletName());\n                    if (list == null) {\n                        servletMappings.put(mapping.getServletName(), list = new ArrayList<>());\n                    }\n                    list.add(mapping);\n                }\n            }\n            final Set<String> seenMappings = new HashSet<>(jspPropertyGroupMappings);\n            if (mergedMetaData.getServlets() != null) {\n                for (final JBossServletMetaData servlet : mergedMetaData.getServlets()) {\n                    final ServletInfo s;\n\n                    if (servlet.getJspFile() != null) {\n                        //TODO: real JSP support\n                        s = new ServletInfo(servlet.getName(), JspServlet.class);\n                        s.addHandlerChainWrapper(new JspFileWrapper(servlet.getJspFile()));\n                    } else {\n                        Class<? extends Servlet> servletClass = (Class<? extends Servlet>) module.getClassLoader().loadClass(servlet.getServletClass());\n                        ComponentRegistry.ComponentManagedReferenceFactory creator = componentRegistry.getComponentsByClass().get(servletClass);\n                        if (creator != null) {\n                            InstanceFactory<Servlet> factory = createInstanceFactory(creator);\n                            s = new ServletInfo(servlet.getName(), servletClass, factory);\n                        } else {\n                            s = new ServletInfo(servlet.getName(), servletClass);\n                        }\n                    }\n                    s.setAsyncSupported(servlet.isAsyncSupported())\n                            .setJspFile(servlet.getJspFile())\n                            .setEnabled(servlet.isEnabled());\n                    if (servlet.getRunAs() != null) {\n                        s.setRunAs(servlet.getRunAs().getRoleName());\n                    }\n                    if (servlet.getLoadOnStartupSet()) {//todo why not cleanup api and just use int everywhere\n                        s.setLoadOnStartup(servlet.getLoadOnStartupInt());\n                    }\n\n                    List<ServletMappingMetaData> mappings = servletMappings.get(servlet.getName());\n                    if (mappings != null) {\n                        for (ServletMappingMetaData mapping : mappings) {\n                            for (String pattern : mapping.getUrlPatterns()) {\n                                if (is22OrOlder && !pattern.startsWith(\"*\") && !pattern.startsWith(\"/\")) {\n                                    pattern = \"/\" + pattern;\n                                }\n                                if (!seenMappings.contains(pattern)) {\n                                    s.addMapping(pattern);\n                                    seenMappings.add(pattern);\n                                }\n                            }\n                        }\n                    }\n                    if (servlet.getInitParam() != null) {\n                        for (ParamValueMetaData initParam : servlet.getInitParam()) {\n                            if (!s.getInitParams().containsKey(initParam.getParamName())) {\n                                s.addInitParam(initParam.getParamName(), initParam.getParamValue());\n                            }\n                        }\n                    }\n                    if (servlet.getServletSecurity() != null) {\n                        ServletSecurityInfo securityInfo = new ServletSecurityInfo();\n                        s.setServletSecurityInfo(securityInfo);\n                        securityInfo.setEmptyRoleSemantic(servlet.getServletSecurity().getEmptyRoleSemantic() == EmptyRoleSemanticType.DENY ? DENY : PERMIT)\n                                .setTransportGuaranteeType(transportGuaranteeType(servlet.getServletSecurity().getTransportGuarantee()))\n                                .addRolesAllowed(servlet.getServletSecurity().getRolesAllowed());\n                        if (servlet.getServletSecurity().getHttpMethodConstraints() != null) {\n                            for (HttpMethodConstraintMetaData method : servlet.getServletSecurity().getHttpMethodConstraints()) {\n                                securityInfo.addHttpMethodSecurityInfo(\n                                        new HttpMethodSecurityInfo()\n                                                .setEmptyRoleSemantic(method.getEmptyRoleSemantic() == EmptyRoleSemanticType.DENY ? DENY : PERMIT)\n                                                .setTransportGuaranteeType(transportGuaranteeType(method.getTransportGuarantee()))\n                                                .addRolesAllowed(method.getRolesAllowed())\n                                                .setMethod(method.getMethod()));\n                            }\n                        }\n                    }\n                    if (servlet.getSecurityRoleRefs() != null) {\n                        for (final SecurityRoleRefMetaData ref : servlet.getSecurityRoleRefs()) {\n                            s.addSecurityRoleRef(ref.getRoleName(), ref.getRoleLink());\n                        }\n                    }\n\n                    if(servlet.getMultipartConfig() != null) {\n                        MultipartConfigMetaData mp = servlet.getMultipartConfig();\n                        s.setMultipartConfig(Servlets.multipartConfig(mp.getLocation(), mp.getMaxFileSize(), mp.getMaxRequestSize(), mp.getFileSizeThreshold()));\n                    }\n\n                    d.addServlet(s);\n                }\n            }\n\n            if (mergedMetaData.getFilters() != null) {\n                for (final FilterMetaData filter : mergedMetaData.getFilters()) {\n                    Class<? extends Filter> filterClass = (Class<? extends Filter>) module.getClassLoader().loadClass(filter.getFilterClass());\n                    ComponentRegistry.ComponentManagedReferenceFactory creator = componentRegistry.getComponentsByClass().get(filterClass);\n                    FilterInfo f;\n                    if (creator != null) {\n                        InstanceFactory<Filter> instanceFactory = createInstanceFactory(creator);\n                        f = new FilterInfo(filter.getName(), filterClass, instanceFactory);\n                    } else {\n                        f = new FilterInfo(filter.getName(), filterClass);\n                    }\n                    f.setAsyncSupported(filter.isAsyncSupported());\n                    d.addFilter(f);\n\n                    if (filter.getInitParam() != null) {\n                        for (ParamValueMetaData initParam : filter.getInitParam()) {\n                            f.addInitParam(initParam.getParamName(), initParam.getParamValue());\n                        }\n                    }\n                }\n            }\n            if (mergedMetaData.getFilterMappings() != null) {\n                for (final FilterMappingMetaData mapping : mergedMetaData.getFilterMappings()) {\n                    if (mapping.getUrlPatterns() != null) {\n                        for (String url : mapping.getUrlPatterns()) {\n                            if (is22OrOlder && !url.startsWith(\"*\") && !url.startsWith(\"/\")) {\n                                url = \"/\" + url;\n                            }\n                            if (mapping.getDispatchers() != null && !mapping.getDispatchers().isEmpty()) {\n                                for (DispatcherType dispatcher : mapping.getDispatchers()) {\n\n                                    d.addFilterUrlMapping(mapping.getFilterName(), url, javax.servlet.DispatcherType.valueOf(dispatcher.name()));\n                                }\n                            } else {\n                                d.addFilterUrlMapping(mapping.getFilterName(), url, javax.servlet.DispatcherType.REQUEST);\n                            }\n                        }\n                    }\n                    if (mapping.getServletNames() != null) {\n                        for (String servletName : mapping.getServletNames()) {\n                            if (mapping.getDispatchers() != null && !mapping.getDispatchers().isEmpty()) {\n                                for (DispatcherType dispatcher : mapping.getDispatchers()) {\n                                    d.addFilterServletNameMapping(mapping.getFilterName(), servletName, javax.servlet.DispatcherType.valueOf(dispatcher.name()));\n                                }\n                            } else {\n                                d.addFilterServletNameMapping(mapping.getFilterName(), servletName, javax.servlet.DispatcherType.REQUEST);\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (scisMetaData != null && scisMetaData.getHandlesTypes() != null) {\n                for (final ServletContainerInitializer sci : scisMetaData.getScis()) {\n                    final ImmediateInstanceFactory<ServletContainerInitializer> instanceFactory = new ImmediateInstanceFactory<>(sci);\n                    d.addServletContainerInitalizer(new ServletContainerInitializerInfo(sci.getClass(), instanceFactory, scisMetaData.getHandlesTypes().get(sci)));\n                }\n            }\n\n            if (mergedMetaData.getListeners() != null) {\n                for (ListenerMetaData listener : mergedMetaData.getListeners()) {\n                    addListener(module.getClassLoader(), componentRegistry, d, listener);\n                }\n\n            }\n            if (mergedMetaData.getContextParams() != null) {\n                for (ParamValueMetaData param : mergedMetaData.getContextParams()) {\n                    d.addInitParameter(param.getParamName(), param.getParamValue());\n                }\n            }\n\n            if (mergedMetaData.getWelcomeFileList() != null &&\n                    mergedMetaData.getWelcomeFileList().getWelcomeFiles() != null) {\n                List<String> welcomeFiles = mergedMetaData.getWelcomeFileList().getWelcomeFiles();\n                for (String file : welcomeFiles) {\n                    if (file.startsWith(\"/\")) {\n                        d.addWelcomePages(file.substring(1));\n                    } else {\n                        d.addWelcomePages(file);\n                    }\n                }\n            } else {\n                d.addWelcomePages(\"index.html\", \"index.htm\", \"index.jsp\");\n            }\n\n            if (mergedMetaData.getErrorPages() != null) {\n                for (final ErrorPageMetaData page : mergedMetaData.getErrorPages()) {\n                    final ErrorPage errorPage;\n                    if (page.getExceptionType() != null && !page.getExceptionType().isEmpty()) {\n                        errorPage = new ErrorPage(page.getLocation(), (Class<? extends Throwable>) module.getClassLoader().loadClass(page.getExceptionType()));\n                    } else if(page.getErrorCode() != null && !page.getErrorCode().isEmpty()){\n                        errorPage = new ErrorPage(page.getLocation(), Integer.parseInt(page.getErrorCode()));\n                    } else {\n                        errorPage = new ErrorPage(page.getLocation());\n                    }\n                    d.addErrorPages(errorPage);\n                }\n            }\n\n            if (mergedMetaData.getMimeMappings() != null) {\n                for (final MimeMappingMetaData mapping : mergedMetaData.getMimeMappings()) {\n                    d.addMimeMapping(new MimeMapping(mapping.getExtension(), mapping.getMimeType()));\n                }\n            }\n\n            d.setDenyUncoveredHttpMethods(mergedMetaData.getDenyUncoveredHttpMethods() != null);\n            Set<String> securityRoleNames = mergedMetaData.getSecurityRoleNames();\n            if (mergedMetaData.getSecurityConstraints() != null) {\n                for (SecurityConstraintMetaData constraint : mergedMetaData.getSecurityConstraints()) {\n                    SecurityConstraint securityConstraint = new SecurityConstraint()\n                            .setTransportGuaranteeType(transportGuaranteeType(constraint.getTransportGuarantee()));\n\n                    List<String> roleNames = constraint.getRoleNames();\n                    if (constraint.getAuthConstraint() == null) {\n                        // no auth constraint means we permit the empty roles\n                        securityConstraint.setEmptyRoleSemantic(PERMIT);\n                    } else if (roleNames.size() == 1 && roleNames.contains(\"*\") && securityRoleNames.contains(\"*\")) {\n                        // AS7-6932 - Trying to do a * to * mapping which JBossWeb passed through, for Undertow enable\n                        // authentication only mode.\n                        // TODO - AS7-6933 - Revisit workaround added to allow switching between JBoss Web and Undertow.\n                        securityConstraint.setEmptyRoleSemantic(AUTHENTICATE);\n                    } else {\n                        securityConstraint.addRolesAllowed(roleNames);\n                    }\n\n                    if (constraint.getResourceCollections() != null) {\n                        for (final WebResourceCollectionMetaData resourceCollection : constraint.getResourceCollections()) {\n                            securityConstraint.addWebResourceCollection(new WebResourceCollection()\n                                    .addHttpMethods(resourceCollection.getHttpMethods())\n                                    .addHttpMethodOmissions(resourceCollection.getHttpMethodOmissions())\n                                    .addUrlPatterns(resourceCollection.getUrlPatterns()));\n                        }\n                    }\n                    d.addSecurityConstraint(securityConstraint);\n                }\n            }\n            final LoginConfigMetaData loginConfig = mergedMetaData.getLoginConfig();\n            if (loginConfig != null) {\n                String authMethod = authMethod(loginConfig.getAuthMethod());\n                if (loginConfig.getFormLoginConfig() != null) {\n                    d.setLoginConfig(new LoginConfig(authMethod, loginConfig.getRealmName(), loginConfig.getFormLoginConfig().getLoginPage(), loginConfig.getFormLoginConfig().getErrorPage()));\n                } else {\n                    d.setLoginConfig(new LoginConfig(authMethod, loginConfig.getRealmName()));\n                }\n            }\n\n            d.addSecurityRoles(mergedMetaData.getSecurityRoleNames());\n\n\n            d.addOuterHandlerChainWrapper(SecurityContextCreationHandler.wrapper(securityDomain));\n            d.addInnerHandlerChainWrapper(SecurityContextAssociationHandler.wrapper(mergedMetaData.getPrincipalVersusRolesMap(), mergedMetaData.getRunAsIdentity(), securityContextId));\n\n            // Setup an deployer configured ServletContext attributes\n            for (ServletContextAttribute attribute : attributes) {\n                d.addServletContextAttribute(attribute.getName(), attribute.getValue());\n            }\n\n            if (mergedMetaData.getLocalEncodings() != null &&\n                    mergedMetaData.getLocalEncodings().getMappings() != null) {\n                for (LocaleEncodingMetaData locale : mergedMetaData.getLocalEncodings().getMappings()) {\n                    d.addLocaleCharsetMapping(locale.getLocale(), locale.getEncoding());\n                }\n            }\n\n            return d;\n        } catch (ClassNotFoundException e) {\n            throw new StartException(e);\n        }\n    }","id":60799,"modified_method":"private DeploymentInfo createServletConfig() throws StartException {\n        try {\n            mergedMetaData.resolveAnnotations();\n            final DeploymentInfo d = new DeploymentInfo();\n            d.setContextPath(contextPath);\n            if (mergedMetaData.getDescriptionGroup() != null) {\n                d.setDisplayName(mergedMetaData.getDescriptionGroup().getDisplayName());\n            }\n            d.setDeploymentName(deploymentName);\n            try {\n                //TODO: make the caching limits configurable\n                ResourceManager resourceManager = new ServletResourceManager(deploymentRoot, overlays);\n                d.setResourceManager(new CachingResourceManager(100, 10 * 1024 * 1024, bufferCacheInjectedValue.getOptionalValue(), resourceManager, -1));\n            } catch (IOException e) {\n                throw new StartException(e);\n            }\n\n            File tempFile = new File(pathManagerInjector.getValue().getPathEntry(TEMP_DIR).resolvePath(), deploymentName);\n            tempFile.mkdirs();\n            d.setTempDir(tempFile);\n\n            d.setClassLoader(module.getClassLoader());\n            final String servletVersion = mergedMetaData.getServletVersion();\n            if (servletVersion != null) {\n                d.setMajorVersion(Integer.parseInt(servletVersion.charAt(0) + \"\"));\n                d.setMinorVersion(Integer.parseInt(servletVersion.charAt(2) + \"\"));\n            } else {\n                d.setMajorVersion(3);\n                d.setMinorVersion(1);\n            }\n\n            //for 2.2 apps we do not require a leading / in path mappings\n            boolean is22OrOlder;\n            if (d.getMajorVersion() == 1) {\n                is22OrOlder = true;\n            } else if (d.getMajorVersion() == 2) {\n                is22OrOlder = d.getMinorVersion() < 3;\n            } else {\n                is22OrOlder = false;\n            }\n            JSPService jspService = container.getValue().getJspService().getOptionalValue();\n            final Set<String> seenMappings = new HashSet<>();\n\n            HashMap <String, TagLibraryInfo> tldInfo = createTldsInfo(tldsMetaData, sharedTlds);\n\n            d.setDefaultServletConfig(new DefaultServletConfig(true, Collections.<String>emptySet()));\n\n            //default JSP servlet\n            final ServletInfo jspServlet = jspService != null ? jspService.getJSPServletInfo() : null;\n            if (jspServlet != null) { //this would be null if jsp support is disabled\n                HashMap<String, JspPropertyGroup> propertyGroups = createJspConfig(mergedMetaData);\n                JspServletBuilder.setupDeployment(d, propertyGroups, tldInfo, new UndertowJSPInstanceManager(injectionContainer));\n\n                if (mergedMetaData.getJspConfig() != null) {\n                    d.setJspConfigDescriptor(new JspConfigDescriptorImpl(tldInfo.values(), propertyGroups.values()));\n                }\n\n                d.addServlet(jspServlet);\n\n                final Set<String> jspPropertyGroupMappings = propertyGroups.keySet();\n                for (final String mapping : jspPropertyGroupMappings) {\n                    jspServlet.addMapping(mapping);\n                }\n                seenMappings.addAll(jspPropertyGroupMappings);\n                //setup JSP expression factory wrapper\n                if (!expressionFactoryWrappers.isEmpty()) {\n                    d.addListener(new ListenerInfo(JspInitializationListener.class));\n                    d.addServletContextAttribute(JspInitializationListener.CONTEXT_KEY, expressionFactoryWrappers);\n                }\n            }\n\n            d.setClassIntrospecter(new ComponentClassIntrospector(componentRegistry));\n\n            final Map<String, List<ServletMappingMetaData>> servletMappings = new HashMap<>();\n\n            if (mergedMetaData.getServletMappings() != null) {\n                for (final ServletMappingMetaData mapping : mergedMetaData.getServletMappings()) {\n                    List<ServletMappingMetaData> list = servletMappings.get(mapping.getServletName());\n                    if (list == null) {\n                        servletMappings.put(mapping.getServletName(), list = new ArrayList<>());\n                    }\n                    list.add(mapping);\n                }\n            }\n\n            if (mergedMetaData.getServlets() != null) {\n                for (final JBossServletMetaData servlet : mergedMetaData.getServlets()) {\n                    final ServletInfo s;\n\n                    if (servlet.getJspFile() != null) {\n                        s = new ServletInfo(servlet.getName(), JspServlet.class);\n                        s.addHandlerChainWrapper(new JspFileWrapper(servlet.getJspFile()));\n                    } else {\n                        Class<? extends Servlet> servletClass = (Class<? extends Servlet>) module.getClassLoader().loadClass(servlet.getServletClass());\n                        ComponentRegistry.ComponentManagedReferenceFactory creator = componentRegistry.getComponentsByClass().get(servletClass);\n                        if (creator != null) {\n                            InstanceFactory<Servlet> factory = createInstanceFactory(creator);\n                            s = new ServletInfo(servlet.getName(), servletClass, factory);\n                        } else {\n                            s = new ServletInfo(servlet.getName(), servletClass);\n                        }\n                    }\n                    s.setAsyncSupported(servlet.isAsyncSupported())\n                            .setJspFile(servlet.getJspFile())\n                            .setEnabled(servlet.isEnabled());\n                    if (servlet.getRunAs() != null) {\n                        s.setRunAs(servlet.getRunAs().getRoleName());\n                    }\n                    if (servlet.getLoadOnStartupSet()) {//todo why not cleanup api and just use int everywhere\n                        s.setLoadOnStartup(servlet.getLoadOnStartupInt());\n                    }\n\n                    List<ServletMappingMetaData> mappings = servletMappings.get(servlet.getName());\n                    if (mappings != null) {\n                        for (ServletMappingMetaData mapping : mappings) {\n                            for (String pattern : mapping.getUrlPatterns()) {\n                                if (is22OrOlder && !pattern.startsWith(\"*\") && !pattern.startsWith(\"/\")) {\n                                    pattern = \"/\" + pattern;\n                                }\n                                if (!seenMappings.contains(pattern)) {\n                                    s.addMapping(pattern);\n                                    seenMappings.add(pattern);\n                                }\n                            }\n                        }\n                    }\n                    if (servlet.getInitParam() != null) {\n                        for (ParamValueMetaData initParam : servlet.getInitParam()) {\n                            if (!s.getInitParams().containsKey(initParam.getParamName())) {\n                                s.addInitParam(initParam.getParamName(), initParam.getParamValue());\n                            }\n                        }\n                    }\n                    if (servlet.getServletSecurity() != null) {\n                        ServletSecurityInfo securityInfo = new ServletSecurityInfo();\n                        s.setServletSecurityInfo(securityInfo);\n                        securityInfo.setEmptyRoleSemantic(servlet.getServletSecurity().getEmptyRoleSemantic() == EmptyRoleSemanticType.DENY ? DENY : PERMIT)\n                                .setTransportGuaranteeType(transportGuaranteeType(servlet.getServletSecurity().getTransportGuarantee()))\n                                .addRolesAllowed(servlet.getServletSecurity().getRolesAllowed());\n                        if (servlet.getServletSecurity().getHttpMethodConstraints() != null) {\n                            for (HttpMethodConstraintMetaData method : servlet.getServletSecurity().getHttpMethodConstraints()) {\n                                securityInfo.addHttpMethodSecurityInfo(\n                                        new HttpMethodSecurityInfo()\n                                                .setEmptyRoleSemantic(method.getEmptyRoleSemantic() == EmptyRoleSemanticType.DENY ? DENY : PERMIT)\n                                                .setTransportGuaranteeType(transportGuaranteeType(method.getTransportGuarantee()))\n                                                .addRolesAllowed(method.getRolesAllowed())\n                                                .setMethod(method.getMethod()));\n                            }\n                        }\n                    }\n                    if (servlet.getSecurityRoleRefs() != null) {\n                        for (final SecurityRoleRefMetaData ref : servlet.getSecurityRoleRefs()) {\n                            s.addSecurityRoleRef(ref.getRoleName(), ref.getRoleLink());\n                        }\n                    }\n\n                    if(servlet.getMultipartConfig() != null) {\n                        MultipartConfigMetaData mp = servlet.getMultipartConfig();\n                        s.setMultipartConfig(Servlets.multipartConfig(mp.getLocation(), mp.getMaxFileSize(), mp.getMaxRequestSize(), mp.getFileSizeThreshold()));\n                    }\n\n                    d.addServlet(s);\n                }\n            }\n\n            if (mergedMetaData.getFilters() != null) {\n                for (final FilterMetaData filter : mergedMetaData.getFilters()) {\n                    Class<? extends Filter> filterClass = (Class<? extends Filter>) module.getClassLoader().loadClass(filter.getFilterClass());\n                    ComponentRegistry.ComponentManagedReferenceFactory creator = componentRegistry.getComponentsByClass().get(filterClass);\n                    FilterInfo f;\n                    if (creator != null) {\n                        InstanceFactory<Filter> instanceFactory = createInstanceFactory(creator);\n                        f = new FilterInfo(filter.getName(), filterClass, instanceFactory);\n                    } else {\n                        f = new FilterInfo(filter.getName(), filterClass);\n                    }\n                    f.setAsyncSupported(filter.isAsyncSupported());\n                    d.addFilter(f);\n\n                    if (filter.getInitParam() != null) {\n                        for (ParamValueMetaData initParam : filter.getInitParam()) {\n                            f.addInitParam(initParam.getParamName(), initParam.getParamValue());\n                        }\n                    }\n                }\n            }\n            if (mergedMetaData.getFilterMappings() != null) {\n                for (final FilterMappingMetaData mapping : mergedMetaData.getFilterMappings()) {\n                    if (mapping.getUrlPatterns() != null) {\n                        for (String url : mapping.getUrlPatterns()) {\n                            if (is22OrOlder && !url.startsWith(\"*\") && !url.startsWith(\"/\")) {\n                                url = \"/\" + url;\n                            }\n                            if (mapping.getDispatchers() != null && !mapping.getDispatchers().isEmpty()) {\n                                for (DispatcherType dispatcher : mapping.getDispatchers()) {\n\n                                    d.addFilterUrlMapping(mapping.getFilterName(), url, javax.servlet.DispatcherType.valueOf(dispatcher.name()));\n                                }\n                            } else {\n                                d.addFilterUrlMapping(mapping.getFilterName(), url, javax.servlet.DispatcherType.REQUEST);\n                            }\n                        }\n                    }\n                    if (mapping.getServletNames() != null) {\n                        for (String servletName : mapping.getServletNames()) {\n                            if (mapping.getDispatchers() != null && !mapping.getDispatchers().isEmpty()) {\n                                for (DispatcherType dispatcher : mapping.getDispatchers()) {\n                                    d.addFilterServletNameMapping(mapping.getFilterName(), servletName, javax.servlet.DispatcherType.valueOf(dispatcher.name()));\n                                }\n                            } else {\n                                d.addFilterServletNameMapping(mapping.getFilterName(), servletName, javax.servlet.DispatcherType.REQUEST);\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (scisMetaData != null && scisMetaData.getHandlesTypes() != null) {\n                for (final ServletContainerInitializer sci : scisMetaData.getScis()) {\n                    final ImmediateInstanceFactory<ServletContainerInitializer> instanceFactory = new ImmediateInstanceFactory<>(sci);\n                    d.addServletContainerInitalizer(new ServletContainerInitializerInfo(sci.getClass(), instanceFactory, scisMetaData.getHandlesTypes().get(sci)));\n                }\n            }\n\n            if (mergedMetaData.getListeners() != null) {\n                for (ListenerMetaData listener : mergedMetaData.getListeners()) {\n                    addListener(module.getClassLoader(), componentRegistry, d, listener);\n                }\n\n            }\n            if (mergedMetaData.getContextParams() != null) {\n                for (ParamValueMetaData param : mergedMetaData.getContextParams()) {\n                    d.addInitParameter(param.getParamName(), param.getParamValue());\n                }\n            }\n\n            if (mergedMetaData.getWelcomeFileList() != null &&\n                    mergedMetaData.getWelcomeFileList().getWelcomeFiles() != null) {\n                List<String> welcomeFiles = mergedMetaData.getWelcomeFileList().getWelcomeFiles();\n                for (String file : welcomeFiles) {\n                    if (file.startsWith(\"/\")) {\n                        d.addWelcomePages(file.substring(1));\n                    } else {\n                        d.addWelcomePages(file);\n                    }\n                }\n            } else {\n                d.addWelcomePages(\"index.html\", \"index.htm\", \"index.jsp\");\n            }\n\n            if (mergedMetaData.getErrorPages() != null) {\n                for (final ErrorPageMetaData page : mergedMetaData.getErrorPages()) {\n                    final ErrorPage errorPage;\n                    if (page.getExceptionType() != null && !page.getExceptionType().isEmpty()) {\n                        errorPage = new ErrorPage(page.getLocation(), (Class<? extends Throwable>) module.getClassLoader().loadClass(page.getExceptionType()));\n                    } else if(page.getErrorCode() != null && !page.getErrorCode().isEmpty()){\n                        errorPage = new ErrorPage(page.getLocation(), Integer.parseInt(page.getErrorCode()));\n                    } else {\n                        errorPage = new ErrorPage(page.getLocation());\n                    }\n                    d.addErrorPages(errorPage);\n                }\n            }\n\n            if (mergedMetaData.getMimeMappings() != null) {\n                for (final MimeMappingMetaData mapping : mergedMetaData.getMimeMappings()) {\n                    d.addMimeMapping(new MimeMapping(mapping.getExtension(), mapping.getMimeType()));\n                }\n            }\n\n            d.setDenyUncoveredHttpMethods(mergedMetaData.getDenyUncoveredHttpMethods() != null);\n            Set<String> securityRoleNames = mergedMetaData.getSecurityRoleNames();\n            if (mergedMetaData.getSecurityConstraints() != null) {\n                for (SecurityConstraintMetaData constraint : mergedMetaData.getSecurityConstraints()) {\n                    SecurityConstraint securityConstraint = new SecurityConstraint()\n                            .setTransportGuaranteeType(transportGuaranteeType(constraint.getTransportGuarantee()));\n\n                    List<String> roleNames = constraint.getRoleNames();\n                    if (constraint.getAuthConstraint() == null) {\n                        // no auth constraint means we permit the empty roles\n                        securityConstraint.setEmptyRoleSemantic(PERMIT);\n                    } else if (roleNames.size() == 1 && roleNames.contains(\"*\") && securityRoleNames.contains(\"*\")) {\n                        // AS7-6932 - Trying to do a * to * mapping which JBossWeb passed through, for Undertow enable\n                        // authentication only mode.\n                        // TODO - AS7-6933 - Revisit workaround added to allow switching between JBoss Web and Undertow.\n                        securityConstraint.setEmptyRoleSemantic(AUTHENTICATE);\n                    } else {\n                        securityConstraint.addRolesAllowed(roleNames);\n                    }\n\n                    if (constraint.getResourceCollections() != null) {\n                        for (final WebResourceCollectionMetaData resourceCollection : constraint.getResourceCollections()) {\n                            securityConstraint.addWebResourceCollection(new WebResourceCollection()\n                                    .addHttpMethods(resourceCollection.getHttpMethods())\n                                    .addHttpMethodOmissions(resourceCollection.getHttpMethodOmissions())\n                                    .addUrlPatterns(resourceCollection.getUrlPatterns()));\n                        }\n                    }\n                    d.addSecurityConstraint(securityConstraint);\n                }\n            }\n            final LoginConfigMetaData loginConfig = mergedMetaData.getLoginConfig();\n            if (loginConfig != null) {\n                String authMethod = authMethod(loginConfig.getAuthMethod());\n                if (loginConfig.getFormLoginConfig() != null) {\n                    d.setLoginConfig(new LoginConfig(authMethod, loginConfig.getRealmName(), loginConfig.getFormLoginConfig().getLoginPage(), loginConfig.getFormLoginConfig().getErrorPage()));\n                } else {\n                    d.setLoginConfig(new LoginConfig(authMethod, loginConfig.getRealmName()));\n                }\n            }\n\n            d.addSecurityRoles(mergedMetaData.getSecurityRoleNames());\n\n\n            d.addOuterHandlerChainWrapper(SecurityContextCreationHandler.wrapper(securityDomain));\n            d.addInnerHandlerChainWrapper(SecurityContextAssociationHandler.wrapper(mergedMetaData.getPrincipalVersusRolesMap(), mergedMetaData.getRunAsIdentity(), securityContextId));\n\n            // Setup an deployer configured ServletContext attributes\n            for (ServletContextAttribute attribute : attributes) {\n                d.addServletContextAttribute(attribute.getName(), attribute.getValue());\n            }\n\n            if (mergedMetaData.getLocalEncodings() != null &&\n                    mergedMetaData.getLocalEncodings().getMappings() != null) {\n                for (LocaleEncodingMetaData locale : mergedMetaData.getLocalEncodings().getMappings()) {\n                    d.addLocaleCharsetMapping(locale.getLocale(), locale.getEncoding());\n                }\n            }\n\n            return d;\n        } catch (ClassNotFoundException e) {\n            throw new StartException(e);\n        }\n    }","commit_id":"ce39eda03275b4831bcae7d65172dc531e749b69","url":"https://github.com/wildfly/wildfly"},{"original_method":"@NotNull\n  @Override\n  public PsiPolyVariantReference getReference() {\n    return getReference(PyResolveContext.defaultContext());\n  }","id":60800,"modified_method":"@NotNull\n  @Override\n  public PsiPolyVariantReference getReference() {\n    //noinspection InstanceofIncompatibleInterface\n    assert !(this instanceof StubBasedPsiElement);\n    final TypeEvalContext context = TypeEvalContext.codeAnalysis(getProject(), getContainingFile());\n    return getReference(PyResolveContext.defaultContext().withTypeEvalContext(context));\n  }","commit_id":"971a9ee872dffa7d2e8544aedebd4cd50c03d198","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {\n    PsiElement elementAt = PyUtil.findNonWhitespaceAtOffset(file, editor.getCaretModel().getOffset());\n    PyExpression problemElement = PsiTreeUtil.getParentOfType(elementAt, PyReferenceExpression.class);\n    if (problemElement == null) return false;\n    if (problemElement.getParent() instanceof PyWithItem) return false;\n    if (problemElement instanceof PyQualifiedExpression) {\n      final PyExpression qualifier = ((PyQualifiedExpression)problemElement).getQualifier();\n      if (qualifier != null && !qualifier.getText().equals(PyNames.CANONICAL_SELF)) {\n        problemElement = qualifier;\n      }\n    }\n    final PsiReference reference = problemElement.getReference();\n    if (problemElement.getParent() instanceof PyCallExpression ||\n        PsiTreeUtil.getParentOfType(problemElement, PyListCompExpression.class) != null ||\n        PsiTreeUtil.getParentOfType(problemElement, PyLambdaExpression.class) != null ||\n        PsiTreeUtil.getParentOfType(problemElement, PyGeneratorExpression.class) != null ||\n        (reference != null && reference.resolve() == null)) {\n      return false;\n    }\n    final PyType type = problemElement.getType(TypeEvalContext.slow());\n    return (type == null || type instanceof PyReturnTypeReference);\n  }","id":60801,"modified_method":"public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {\n    PsiElement elementAt = PyUtil.findNonWhitespaceAtOffset(file, editor.getCaretModel().getOffset());\n    PyExpression problemElement = PsiTreeUtil.getParentOfType(elementAt, PyReferenceExpression.class);\n    if (problemElement == null) return false;\n    if (problemElement.getParent() instanceof PyWithItem) return false;\n    if (problemElement instanceof PyQualifiedExpression) {\n      final PyExpression qualifier = ((PyQualifiedExpression)problemElement).getQualifier();\n      if (qualifier != null && !qualifier.getText().equals(PyNames.CANONICAL_SELF)) {\n        problemElement = qualifier;\n      }\n    }\n    final PsiReference reference = problemElement.getReference();\n    if (problemElement.getParent() instanceof PyCallExpression ||\n        PsiTreeUtil.getParentOfType(problemElement, PyListCompExpression.class) != null ||\n        PsiTreeUtil.getParentOfType(problemElement, PyLambdaExpression.class) != null ||\n        PsiTreeUtil.getParentOfType(problemElement, PyGeneratorExpression.class) != null ||\n        (reference != null && reference.resolve() == null)) {\n      return false;\n    }\n    final PyType type = problemElement.getType(TypeEvalContext.fastStubOnly(file));\n    return (type == null || type instanceof PyReturnTypeReference);\n  }","commit_id":"c0c9f9a00a96364a035fdc3c38f9c37f6453c81a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isAvailableForReturn(PsiElement elementAt) {\n    PyCallExpression callExpression = getCallExpression(elementAt);\n\n    if (callExpression != null) {\n      final PyExpression callee = callExpression.getCallee();\n      if (callee instanceof PyQualifiedExpression) {\n        final Callable pyFunction = callExpression.resolveCalleeFunction(PyResolveContext.defaultContext());\n        if (pyFunction instanceof PyFunction) {\n          PyType type = pyFunction.getReturnType(TypeEvalContext.slow(), (PyQualifiedExpression)callee);\n          if (type == null || type instanceof PyReturnTypeReference) {\n            final PsiReference reference = callee.getReference();\n            if (reference instanceof PsiPolyVariantReference) {\n              final ResolveResult[] results = ((PsiPolyVariantReference)reference).multiResolve(false);\n              if (results.length == 1) {\n                updateText(true);\n                return true;\n              }\n            }\n          }\n        }\n      }\n    }\n    PyFunction parentFunction = PsiTreeUtil.getParentOfType(elementAt, PyFunction.class);\n    if (parentFunction != null) {\n      final ASTNode nameNode = parentFunction.getNameNode();\n      if (nameNode != null && nameNode.getPsi() == elementAt) {\n        updateText(true);\n        return true;\n      }\n    }\n    return false;\n  }","id":60802,"modified_method":"private boolean isAvailableForReturn(PsiElement elementAt) {\n    PyCallExpression callExpression = getCallExpression(elementAt);\n\n    if (callExpression != null) {\n      final PyExpression callee = callExpression.getCallee();\n      if (callee instanceof PyQualifiedExpression) {\n        final TypeEvalContext context = TypeEvalContext.fastStubOnly(callee.getContainingFile());\n        final Callable pyFunction = callExpression.resolveCalleeFunction(PyResolveContext.defaultContext().withTypeEvalContext(context));\n        if (pyFunction instanceof PyFunction) {\n          PyType type = pyFunction.getReturnType(context, (PyQualifiedExpression)callee);\n          if (type == null || type instanceof PyReturnTypeReference) {\n            final PsiReference reference = callee.getReference();\n            if (reference instanceof PsiPolyVariantReference) {\n              final ResolveResult[] results = ((PsiPolyVariantReference)reference).multiResolve(false);\n              if (results.length == 1) {\n                updateText(true);\n                return true;\n              }\n            }\n          }\n        }\n      }\n    }\n    PyFunction parentFunction = PsiTreeUtil.getParentOfType(elementAt, PyFunction.class);\n    if (parentFunction != null) {\n      final ASTNode nameNode = parentFunction.getNameNode();\n      if (nameNode != null && nameNode.getPsi() == elementAt) {\n        updateText(true);\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"c0c9f9a00a96364a035fdc3c38f9c37f6453c81a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  protected static Callable getCallable(PsiElement elementAt) {\n    PyCallExpression callExpression = getCallExpression(elementAt);\n\n    if (callExpression != null) {\n      final Callable callable = callExpression.resolveCalleeFunction(PyResolveContext.defaultContext());\n      return callable == null? PsiTreeUtil.getParentOfType(elementAt, PyFunction.class) : callable;\n    }\n    return PsiTreeUtil.getParentOfType(elementAt, PyFunction.class);\n  }","id":60803,"modified_method":"@Nullable\n  protected static Callable getCallable(PsiElement elementAt) {\n    PyCallExpression callExpression = getCallExpression(elementAt);\n\n    if (callExpression != null && elementAt != null) {\n      final Callable callable = callExpression.resolveCalleeFunction(getResolveContext(elementAt));\n      return callable == null ? PsiTreeUtil.getParentOfType(elementAt, PyFunction.class) : callable;\n    }\n    return PsiTreeUtil.getParentOfType(elementAt, PyFunction.class);\n  }","commit_id":"c0c9f9a00a96364a035fdc3c38f9c37f6453c81a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isDefinedInAnnotation(PyExpression problemElement, PsiReference reference) {\n    final PsiElement resolved = reference != null? reference.resolve() : null;\n    PyParameter parameter = getParameter(problemElement, resolved);\n\n    if (parameter instanceof PyNamedParameter && (((PyNamedParameter)parameter).getAnnotation() != null)) return true;\n\n    if (resolved instanceof PyTargetExpression) { // return type\n      final PyExpression assignedValue = ((PyTargetExpression)resolved).findAssignedValue();\n      if (assignedValue instanceof PyCallExpression) {\n        final PyExpression callee = ((PyCallExpression)assignedValue).getCallee();\n        if (callee != null) {\n          final PsiReference psiReference = callee.getReference();\n          if (psiReference != null && psiReference.resolve() == null) return false;\n        }\n        final Callable callable = ((PyCallExpression)assignedValue).resolveCalleeFunction(PyResolveContext.defaultContext());\n\n        if (callable instanceof PyFunction && ((PyFunction)callable).getAnnotation() != null) return true;\n      }\n    }\n    return false;\n  }","id":60804,"modified_method":"private static boolean isDefinedInAnnotation(PyExpression problemElement, PsiReference reference) {\n    if (LanguageLevel.forElement(problemElement).isOlderThan(LanguageLevel.PYTHON30)) {\n      return false;\n    }\n    final PsiElement resolved = reference != null? reference.resolve() : null;\n    PyParameter parameter = getParameter(problemElement, resolved);\n\n    if (parameter instanceof PyNamedParameter && (((PyNamedParameter)parameter).getAnnotation() != null)) return true;\n\n    if (resolved instanceof PyTargetExpression) { // return type\n      final PyExpression assignedValue = ((PyTargetExpression)resolved).findAssignedValue();\n      if (assignedValue instanceof PyCallExpression) {\n        final PyExpression callee = ((PyCallExpression)assignedValue).getCallee();\n        if (callee != null) {\n          final PsiReference psiReference = callee.getReference();\n          if (psiReference != null && psiReference.resolve() == null) return false;\n        }\n        final Callable callable = ((PyCallExpression)assignedValue).resolveCalleeFunction(getResolveContext(problemElement));\n\n        if (callable instanceof PyFunction && ((PyFunction)callable).getAnnotation() != null) return true;\n      }\n    }\n    return false;\n  }","commit_id":"c0c9f9a00a96364a035fdc3c38f9c37f6453c81a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isTypeUndefined(PyExpression problemElement) {\n    final PyType type = problemElement.getType(TypeEvalContext.slow());\n    if (type == null || type instanceof PyReturnTypeReference || type instanceof PyDynamicallyEvaluatedType) {\n      PsiReference reference = problemElement.getReference();\n      if (problemElement instanceof PyQualifiedExpression) {\n        final PyExpression qualifier = ((PyQualifiedExpression)problemElement).getQualifier();\n        if (qualifier != null && !qualifier.getText().equals(PyNames.CANONICAL_SELF)) reference = qualifier.getReference();\n      }\n\n      if (isDefinedInDocstring(problemElement, reference)) return false;\n      return !isDefinedInAnnotation(problemElement, reference);\n    }\n    return false;\n  }","id":60805,"modified_method":"private static boolean isTypeUndefined(PyExpression problemElement) {\n    final PyType type = problemElement.getType(TypeEvalContext.fastStubOnly(problemElement.getContainingFile()));\n    if (type == null || type instanceof PyReturnTypeReference || type instanceof PyDynamicallyEvaluatedType) {\n      PsiReference reference = problemElement.getReference();\n      if (problemElement instanceof PyQualifiedExpression) {\n        final PyExpression qualifier = ((PyQualifiedExpression)problemElement).getQualifier();\n        if (qualifier != null && !qualifier.getText().equals(PyNames.CANONICAL_SELF)) reference = qualifier.getReference();\n      }\n\n      if (isDefinedInDocstring(problemElement, reference)) return false;\n      return !isDefinedInAnnotation(problemElement, reference);\n    }\n    return false;\n  }","commit_id":"c0c9f9a00a96364a035fdc3c38f9c37f6453c81a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void collectFunctionArgNames(PyElement element, List<LookupElement> ret) {\n    PyCallExpression callExpr = PsiTreeUtil.getParentOfType(element, PyCallExpression.class);\n    if (callExpr != null) {\n      PyExpression callee = callExpr.getCallee();\n      if (callee instanceof PyReferenceExpression && element.getParent() == callExpr.getArgumentList()) {\n        final QualifiedResolveResult result = ((PyReferenceExpression)callee).followAssignmentsChain(PyResolveContext.defaultContext());\n        PsiElement def = result.getElement();\n        if (def instanceof PyFunction) {\n          addKeywordArgumentVariants((PyFunction)def, callExpr, ret);\n        }\n        else if (def instanceof PyClass) {\n          PyFunction init = ((PyClass)def).findMethodByName(PyNames.INIT, true);  // search in superclasses\n          if (init != null) {\n            addKeywordArgumentVariants(init, callExpr, ret);\n          }\n        }\n      }\n    }\n  }","id":60806,"modified_method":"public static void collectFunctionArgNames(PyElement element, List<LookupElement> ret,  final @NotNull TypeEvalContext context) {\n    PyCallExpression callExpr = PsiTreeUtil.getParentOfType(element, PyCallExpression.class);\n    if (callExpr != null) {\n      PyExpression callee = callExpr.getCallee();\n      if (callee instanceof PyReferenceExpression && element.getParent() == callExpr.getArgumentList()) {\n        final PyResolveContext resolveContext = PyResolveContext.defaultContext().withTypeEvalContext(context);\n        final QualifiedResolveResult result = ((PyReferenceExpression)callee).followAssignmentsChain(resolveContext);\n        PsiElement def = result.getElement();\n        if (def instanceof PyFunction) {\n          addKeywordArgumentVariants((PyFunction)def, callExpr, ret);\n        }\n        else if (def instanceof PyClass) {\n          PyFunction init = ((PyClass)def).findMethodByName(PyNames.INIT, true);  // search in superclasses\n          if (init != null) {\n            addKeywordArgumentVariants(init, callExpr, ret);\n          }\n        }\n      }\n    }\n  }","commit_id":"326d440c1302c73e9fe4513bf2d7aee0167cc853","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PyType getType(@NotNull final TypeEvalContext context, @NotNull TypeEvalContext.Key key) {\n    final PsiElement parent = getStubOrPsiParent();\n    if (parent instanceof PyParameterList) {\n      PyParameterList parameterList = (PyParameterList)parent;\n      PyFunction func = parameterList.getContainingFunction();\n      if (func != null) {\n        StructuredDocString docString = func.getStructuredDocString();\n        if (PyNames.INIT.equals(func.getName()) && docString == null) {\n          PyClass pyClass = func.getContainingClass();\n          if (pyClass != null) {\n            docString = pyClass.getStructuredDocString();\n          }\n        }\n        if (docString != null) {\n          String typeName = docString.getParamType(getName());\n          if (typeName != null) {\n            return PyTypeParser.getTypeByName(this, typeName);\n          }\n        }\n        if (isSelf()) {\n          // must be 'self' or 'cls'\n          final PyClass containingClass = func.getContainingClass();\n          if (containingClass != null) {\n            PyType initType = null;\n            final PyFunction init = containingClass.findInitOrNew(true, null);\n            if (init != null && init != func) {\n              initType = context.getReturnType(init);\n              if (init.getContainingClass() != containingClass) {\n                if (initType instanceof PyCollectionType) {\n                  final PyType elementType = ((PyCollectionType)initType).getElementType(context);\n                  return new PyCollectionTypeImpl(containingClass, false, elementType);\n                }\n              }\n            }\n            if (initType != null && !(initType instanceof PyNoneType)) {\n              return initType;\n            }\n            final PyFunction.Modifier modifier = func.getModifier();\n            return new PyClassTypeImpl(containingClass, modifier == PyFunction.Modifier.CLASSMETHOD);\n          }\n        }\n        if (isKeywordContainer()) {\n          return PyBuiltinCache.getInstance(this).getDictType();\n        }\n        if (isPositionalContainer()) {\n          return PyBuiltinCache.getInstance(this).getTupleType();\n        }\n        for(PyTypeProvider provider: Extensions.getExtensions(PyTypeProvider.EP_NAME)) {\n          final Ref<PyType> resultRef = provider.getParameterType(this, func, context);\n          if (resultRef != null) {\n            return resultRef.get();\n          }\n        }\n        if (context.maySwitchToAST(this)) {\n          final PyExpression defaultValue = getDefaultValue();\n          if (defaultValue != null) {\n            final PyType type = context.getType(defaultValue);\n            if (type != null && !(type instanceof PyNoneType)) {\n              if (type instanceof PyTupleType) {\n                return PyUnionType.createWeakType(type);\n              }\n              return type;\n            }\n          }\n        }\n        // Guess the type from file-local calls\n        if (context.allowCallContext(this)) {\n          final List<PyType> types = new ArrayList<PyType>();\n          processLocalCalls(func, new Processor<PyCallExpression>() {\n            @Override\n            public boolean process(@NotNull PyCallExpression call) {\n              final PyResolveContext resolveContext = PyResolveContext.noImplicits().withTypeEvalContext(context);\n              final PyArgumentList argumentList = call.getArgumentList();\n              if (argumentList != null) {\n                final CallArgumentsMapping mapping = argumentList.analyzeCall(resolveContext);\n                for (Map.Entry<PyExpression, PyNamedParameter> entry : mapping.getPlainMappedParams().entrySet()) {\n                  if (entry.getValue() == PyNamedParameterImpl.this) {\n                    final PyExpression argument = entry.getKey();\n                    if (argument != null) {\n                      final PyType type = context.getType(argument);\n                      if (type != null) {\n                        types.add(type);\n                        return true;\n                      }\n                    }\n                  }\n                }\n              }\n              return true;\n            }\n          });\n          if (!types.isEmpty()) {\n            return PyUnionType.createWeakType(PyUnionType.union(types));\n          }\n        }\n        if (context.maySwitchToAST(this)) {\n          final Set<String> attributes = collectUsedAttributes(context);\n          if (!attributes.isEmpty()) {\n            return new PyStructuralType(attributes, true);\n          }\n        }\n      }\n    }\n    return null;\n  }","id":60807,"modified_method":"public PyType getType(@NotNull final TypeEvalContext context, @NotNull TypeEvalContext.Key key) {\n    final PsiElement parent = getStubOrPsiParent();\n    if (parent instanceof PyParameterList) {\n      PyParameterList parameterList = (PyParameterList)parent;\n      PyFunction func = parameterList.getContainingFunction();\n      if (func != null) {\n        StructuredDocString docString = func.getStructuredDocString();\n        if (PyNames.INIT.equals(func.getName()) && docString == null) {\n          PyClass pyClass = func.getContainingClass();\n          if (pyClass != null) {\n            docString = pyClass.getStructuredDocString();\n          }\n        }\n        if (docString != null) {\n          String typeName = docString.getParamType(getName());\n          if (typeName != null) {\n            return PyTypeParser.getTypeByName(this, typeName);\n          }\n        }\n        if (isSelf()) {\n          // must be 'self' or 'cls'\n          final PyClass containingClass = func.getContainingClass();\n          if (containingClass != null) {\n            PyType initType = null;\n            final PyFunction init = containingClass.findInitOrNew(true, context);\n            if (init != null && init != func) {\n              initType = context.getReturnType(init);\n              if (init.getContainingClass() != containingClass) {\n                if (initType instanceof PyCollectionType) {\n                  final PyType elementType = ((PyCollectionType)initType).getElementType(context);\n                  return new PyCollectionTypeImpl(containingClass, false, elementType);\n                }\n              }\n            }\n            if (initType != null && !(initType instanceof PyNoneType)) {\n              return initType;\n            }\n            final PyFunction.Modifier modifier = func.getModifier();\n            return new PyClassTypeImpl(containingClass, modifier == PyFunction.Modifier.CLASSMETHOD);\n          }\n        }\n        if (isKeywordContainer()) {\n          return PyBuiltinCache.getInstance(this).getDictType();\n        }\n        if (isPositionalContainer()) {\n          return PyBuiltinCache.getInstance(this).getTupleType();\n        }\n        for(PyTypeProvider provider: Extensions.getExtensions(PyTypeProvider.EP_NAME)) {\n          final Ref<PyType> resultRef = provider.getParameterType(this, func, context);\n          if (resultRef != null) {\n            return resultRef.get();\n          }\n        }\n        if (context.maySwitchToAST(this)) {\n          final PyExpression defaultValue = getDefaultValue();\n          if (defaultValue != null) {\n            final PyType type = context.getType(defaultValue);\n            if (type != null && !(type instanceof PyNoneType)) {\n              if (type instanceof PyTupleType) {\n                return PyUnionType.createWeakType(type);\n              }\n              return type;\n            }\n          }\n        }\n        // Guess the type from file-local calls\n        if (context.allowCallContext(this)) {\n          final List<PyType> types = new ArrayList<PyType>();\n          processLocalCalls(func, new Processor<PyCallExpression>() {\n            @Override\n            public boolean process(@NotNull PyCallExpression call) {\n              final PyResolveContext resolveContext = PyResolveContext.noImplicits().withTypeEvalContext(context);\n              final PyArgumentList argumentList = call.getArgumentList();\n              if (argumentList != null) {\n                final CallArgumentsMapping mapping = argumentList.analyzeCall(resolveContext);\n                for (Map.Entry<PyExpression, PyNamedParameter> entry : mapping.getPlainMappedParams().entrySet()) {\n                  if (entry.getValue() == PyNamedParameterImpl.this) {\n                    final PyExpression argument = entry.getKey();\n                    if (argument != null) {\n                      final PyType type = context.getType(argument);\n                      if (type != null) {\n                        types.add(type);\n                        return true;\n                      }\n                    }\n                  }\n                }\n              }\n              return true;\n            }\n          });\n          if (!types.isEmpty()) {\n            return PyUnionType.createWeakType(PyUnionType.union(types));\n          }\n        }\n        if (context.maySwitchToAST(this)) {\n          final Set<String> attributes = collectUsedAttributes(context);\n          if (!attributes.isEmpty()) {\n            return new PyStructuralType(attributes, true);\n          }\n        }\n      }\n    }\n    return null;\n  }","commit_id":"326d440c1302c73e9fe4513bf2d7aee0167cc853","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @NotNull\n  public Object[] getVariants() {\n    final List<LookupElement> ret = Lists.newArrayList();\n\n    // Use real context here to enable correct completion and resolve in case of PyExpressionCodeFragment!!!\n    final PsiElement originalElement = CompletionUtil.getOriginalElement(myElement);\n    final PyQualifiedExpression element = originalElement instanceof PyQualifiedExpression ?\n                                          (PyQualifiedExpression)originalElement : myElement;\n    final PsiElement realContext = PyPsiUtils.getRealContext(element);\n\n    // include our own names\n    final int underscores = PyUtil.getInitialUnderscores(element.getName());\n    final CompletionVariantsProcessor processor = new CompletionVariantsProcessor(element);\n    final ScopeOwner owner = realContext instanceof ScopeOwner ? (ScopeOwner)realContext : ScopeUtil.getScopeOwner(realContext);\n    if (owner != null) {\n      PyResolveUtil.scopeCrawlUp(processor, owner, null, null);\n    }\n\n    // in a call, include function's arg names\n    KeywordArgumentCompletionUtil.collectFunctionArgNames(element, ret);\n\n    // include builtin names\n    final PyFile builtinsFile = PyBuiltinCache.getInstance(element).getBuiltinsFile();\n    if (builtinsFile != null) {\n      PyResolveUtil.scopeCrawlUp(processor, builtinsFile, null, null);\n    }\n\n    if (underscores >= 2) {\n      // if we're a normal module, add module's attrs\n      PsiFile f = realContext.getContainingFile();\n      if (f instanceof PyFile) {\n        for (String name : PyModuleType.getPossibleInstanceMembers()) {\n          ret.add(LookupElementBuilder.create(name).withIcon(PlatformIcons.FIELD_ICON));\n        }\n      }\n    }\n\n    // Throw away fake elements used for completion internally\n    for (LookupElement e : processor.getResultList()) {\n      final Object o = e.getObject();\n      if (o instanceof PsiElement) {\n        final PsiElement original = CompletionUtil.getOriginalElement((PsiElement)o);\n        if (original == null) {\n          continue;\n        }\n      }\n      ret.add(e);\n    }\n\n    return ret.toArray();\n  }","id":60808,"modified_method":"@Override\n  @NotNull\n  public Object[] getVariants() {\n    final List<LookupElement> ret = Lists.newArrayList();\n\n    // Use real context here to enable correct completion and resolve in case of PyExpressionCodeFragment!!!\n    final PsiElement originalElement = CompletionUtil.getOriginalElement(myElement);\n    final PyQualifiedExpression element = originalElement instanceof PyQualifiedExpression ?\n                                          (PyQualifiedExpression)originalElement : myElement;\n    final PsiElement realContext = PyPsiUtils.getRealContext(element);\n\n    // include our own names\n    final int underscores = PyUtil.getInitialUnderscores(element.getName());\n    final CompletionVariantsProcessor processor = new CompletionVariantsProcessor(element);\n    final ScopeOwner owner = realContext instanceof ScopeOwner ? (ScopeOwner)realContext : ScopeUtil.getScopeOwner(realContext);\n    if (owner != null) {\n      PyResolveUtil.scopeCrawlUp(processor, owner, null, null);\n    }\n\n    // This method is probably called for completion, so use appropriate context here\n    // in a call, include function's arg names\n    KeywordArgumentCompletionUtil.collectFunctionArgNames(element, ret, TypeEvalContext.codeCompletion(element.getProject(), element.getContainingFile()));\n\n    // include builtin names\n    final PyFile builtinsFile = PyBuiltinCache.getInstance(element).getBuiltinsFile();\n    if (builtinsFile != null) {\n      PyResolveUtil.scopeCrawlUp(processor, builtinsFile, null, null);\n    }\n\n    if (underscores >= 2) {\n      // if we're a normal module, add module's attrs\n      PsiFile f = realContext.getContainingFile();\n      if (f instanceof PyFile) {\n        for (String name : PyModuleType.getPossibleInstanceMembers()) {\n          ret.add(LookupElementBuilder.create(name).withIcon(PlatformIcons.FIELD_ICON));\n        }\n      }\n    }\n\n    // Throw away fake elements used for completion internally\n    for (LookupElement e : processor.getResultList()) {\n      final Object o = e.getObject();\n      if (o instanceof PsiElement) {\n        final PsiElement original = CompletionUtil.getOriginalElement((PsiElement)o);\n        if (original == null) {\n          continue;\n        }\n      }\n      ret.add(e);\n    }\n\n    return ret.toArray();\n  }","commit_id":"326d440c1302c73e9fe4513bf2d7aee0167cc853","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Defaults\n        public void copyTestBinariesToGlobalContainer(ModelMap<BinarySpec> binaries, TestSuiteContainer testSuites) {\n            for (TestSuiteSpec testSuite : testSuites.withType(TestSuiteSpec.class).values()) {\n                for (BinarySpec binary : testSuite.getBinaries().values()) {\n                    binaries.put(binary.getName(), binary);\n                }\n            }\n        }","id":60809,"modified_method":"@Defaults\n        public void copyTestBinariesToGlobalContainer(ModelMap<BinarySpec> binaries, TestSuiteContainer testSuites) {\n            for (TestSuiteSpec testSuite : testSuites.withType(TestSuiteSpec.class).values()) {\n                for (BinarySpecInternal binary : testSuite.getBinaries().withType(BinarySpecInternal.class).values()) {\n                    binaries.put(binary.getProjectScopedName(), binary);\n                }\n            }\n        }","commit_id":"f27a1cb3c1a9675e9ddb27d0e7ad0993b123eba9","url":"https://github.com/gradle/gradle"},{"original_method":"@Defaults\n        void collectBinaries(ModelMap<BinarySpec> binaries, ComponentSpecContainer componentSpecs) {\n            for (ComponentSpec componentSpec : componentSpecs.values()) {\n                for (BinarySpec binary : componentSpec.getBinaries().values()) {\n                    binaries.put(((BinarySpecInternal) binary).getProjectScopedName(), binary);\n                }\n            }\n        }","id":60810,"modified_method":"@Mutate\n        void collectBinaries(BinaryContainer binaries, ComponentSpecContainer componentSpecs) {\n            for (ComponentSpec componentSpec : componentSpecs.values()) {\n                for (BinarySpecInternal binary : componentSpec.getBinaries().withType(BinarySpecInternal.class).values()) {\n                    binaries.put(binary.getProjectScopedName(), binary);\n                }\n            }\n        }","commit_id":"f4fba0cb42a6adfd6fdb32089af8c2a90a697825","url":"https://github.com/gradle/gradle"},{"original_method":"private BaseBinarySpec(BinaryInfo info) {\n        if (info == null) {\n            throw new ModelInstantiationException(\"Direct instantiation of a BaseBinarySpec is not permitted. Use a BinaryTypeBuilder instead.\");\n        }\n        this.name = info.name;\n        this.publicType = info.publicType;\n        this.typeName = info.implementationType.getSimpleName();\n        this.owner = info.owner;\n        this.tasks = info.instantiator.newInstance(DefaultBinaryTasksCollection.class, this, info.taskFactory);\n        DefaultPolymorphicNamedEntityInstantiator<LanguageSourceSet> entityInstantiator = new DefaultPolymorphicNamedEntityInstantiator<LanguageSourceSet>(LanguageSourceSet.class, \"owned sources\");\n        this.entityInstantiator = entityInstantiator;\n        this.ownedSourceSets = new DomainObjectCollectionBackedModelMap<LanguageSourceSet>(\n            LanguageSourceSet.class,\n            new DefaultDomainObjectSet<LanguageSourceSet>(LanguageSourceSet.class),\n            entityInstantiator,\n            new Namer(),\n            Actions.doNothing());\n    }","id":60811,"modified_method":"private BaseBinarySpec(BinaryInfo info) {\n        if (info == null) {\n            throw new ModelInstantiationException(\"Direct instantiation of a BaseBinarySpec is not permitted. Use a BinaryTypeBuilder instead.\");\n        }\n        this.owner = info.owner;\n        this.name = info.name;\n        this.publicType = info.publicType;\n        this.typeName = info.implementationType.getSimpleName();\n        this.tasks = info.instantiator.newInstance(DefaultBinaryTasksCollection.class, this, info.taskFactory);\n        DefaultPolymorphicNamedEntityInstantiator<LanguageSourceSet> entityInstantiator = new DefaultPolymorphicNamedEntityInstantiator<LanguageSourceSet>(LanguageSourceSet.class, \"owned sources\");\n        this.entityInstantiator = entityInstantiator;\n        this.ownedSourceSets = new DomainObjectCollectionBackedModelMap<LanguageSourceSet>(\n            LanguageSourceSet.class,\n            new DefaultDomainObjectSet<LanguageSourceSet>(LanguageSourceSet.class),\n            entityInstantiator,\n            new Namer(),\n            Actions.doNothing());\n    }","commit_id":"fd523fd28827b1a0c3184ba78e18d5febd6fd18f","url":"https://github.com/gradle/gradle"},{"original_method":"public String getDisplayName() {\n        return String.format(\"%s '%s'\", getTypeName(), getName());\n    }","id":60812,"modified_method":"public String getDisplayName() {\n        if (owner == null) {\n            return String.format(\"%s '%s'\", getTypeName(), name);\n        } else {\n            return String.format(\"%s '%s:%s'\", getTypeName(), owner.getName(), name);\n        }\n    }","commit_id":"fd523fd28827b1a0c3184ba78e18d5febd6fd18f","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public String getProjectScopedName() {\n        return name;\n    }","id":60813,"modified_method":"@Override\n    public String getProjectScopedName() {\n        return owner == null ? name : owner.getName() + StringUtils.capitalize(name);\n    }","commit_id":"fd523fd28827b1a0c3184ba78e18d5febd6fd18f","url":"https://github.com/gradle/gradle"},{"original_method":"@Finalize\n        void createSourceTransformTasks(final TaskContainer tasks, final ModelMap<BinarySpecInternal> binaries, LanguageTransformContainer languageTransforms, ServiceRegistry serviceRegistry) {\n            for (LanguageTransform<?, ?> language : languageTransforms) {\n                for (final BinarySpecInternal binary : binaries) {\n                    if (binary.isLegacyBinary() || !language.applyToBinary(binary)) {\n                        continue;\n                    }\n\n                    final SourceTransformTaskConfig taskConfig = language.getTransformTask();\n                    for (LanguageSourceSet languageSourceSet : binary.getInputs()) {\n                        LanguageSourceSetInternal sourceSet = (LanguageSourceSetInternal) languageSourceSet;\n                        if (language.getSourceSetType().isInstance(sourceSet) && sourceSet.getMayHaveSources()) {\n                            String taskName = taskConfig.getTaskPrefix() + capitalize(binary.getName()) + capitalize(sourceSet.getFullName());\n                            Task task = tasks.create(taskName, taskConfig.getTaskType());\n                            taskConfig.configureTask(task, binary, sourceSet, serviceRegistry);\n\n                            task.dependsOn(sourceSet);\n                            binary.getTasks().add(task);\n                        }\n                    }\n                }\n            }\n        }","id":60814,"modified_method":"@Finalize\n        void createSourceTransformTasks(final TaskContainer tasks, final ModelMap<BinarySpecInternal> binaries, LanguageTransformContainer languageTransforms, ServiceRegistry serviceRegistry) {\n            for (LanguageTransform<?, ?> language : languageTransforms) {\n                for (final BinarySpecInternal binary : binaries) {\n                    if (binary.isLegacyBinary() || !language.applyToBinary(binary)) {\n                        continue;\n                    }\n\n                    final SourceTransformTaskConfig taskConfig = language.getTransformTask();\n                    for (LanguageSourceSet languageSourceSet : binary.getInputs()) {\n                        LanguageSourceSetInternal sourceSet = (LanguageSourceSetInternal) languageSourceSet;\n                        if (language.getSourceSetType().isInstance(sourceSet) && sourceSet.getMayHaveSources()) {\n                            String taskName = taskConfig.getTaskPrefix() + capitalize(binary.getProjectScopedName()) + capitalize(sourceSet.getFullName());\n                            Task task = tasks.create(taskName, taskConfig.getTaskType());\n                            taskConfig.configureTask(task, binary, sourceSet, serviceRegistry);\n\n                            task.dependsOn(sourceSet);\n                            binary.getTasks().add(task);\n                        }\n                    }\n                }\n            }\n        }","commit_id":"fd523fd28827b1a0c3184ba78e18d5febd6fd18f","url":"https://github.com/gradle/gradle"},{"original_method":"@Defaults\n        void collectBinaries(BinaryContainer binaries, ComponentSpecContainer componentSpecs) {\n            for (ComponentSpec componentSpec : componentSpecs.values()) {\n                for (BinarySpec binary : componentSpec.getBinaries().values()) {\n                    binaries.add(binary);\n                }\n            }\n        }","id":60815,"modified_method":"@Defaults\n        void collectBinaries(ModelMap<BinarySpec> binaries, ComponentSpecContainer componentSpecs) {\n            for (ComponentSpec componentSpec : componentSpecs.values()) {\n                for (BinarySpecInternal binary : componentSpec.getBinaries().withType(BinarySpecInternal.class).values()) {\n                    binaries.put(binary.getProjectScopedName(), binary);\n                }\n            }\n        }","commit_id":"fd523fd28827b1a0c3184ba78e18d5febd6fd18f","url":"https://github.com/gradle/gradle"},{"original_method":"private void applyRules(ModelRegistry modelRegistry) {\n        DefaultBinaryContainer binaries = instantiator.newInstance(DefaultBinaryContainer.class, instantiator);\n        final String descriptor = LanguageBasePlugin.class.getSimpleName() + \".apply()\";\n        final ModelRuleDescriptor ruleDescriptor = new SimpleModelRuleDescriptor(descriptor);\n        ModelPath binariesPath = ModelPath.path(\"binaries\");\n\n        ModelType<BinarySpec> binarySpecModelType = ModelType.of(BinarySpec.class);\n        // TODO:LPTR Remove once reuse is taken out\n        modelRegistry.createOrReplace(\n            BridgedCollections.creator(\n                ModelReference.of(binariesPath, DefaultBinaryContainer.class),\n                Transformers.constant(binaries),\n                Named.Namer.INSTANCE,\n                descriptor,\n                BridgedCollections.itemDescriptor(descriptor)\n            )\n                .descriptor(descriptor)\n                .ephemeral(true)\n                .withProjection(PolymorphicModelMapProjection.of(binarySpecModelType,\n                    ChildNodeInitializerStrategyAccessors.of(NodeBackedModelMap.createUsingParentNode(binarySpecModelType))))\n                .withProjection(UnmanagedModelProjection.of(DefaultBinaryContainer.class))\n                .build()\n        );\n\n        modelRegistry.configure(ModelActionRole.Defaults, DirectNodeNoInputsModelAction.of(ModelReference.of(binariesPath), ruleDescriptor, new Action<MutableModelNode>() {\n            @Override\n            public void execute(MutableModelNode binariesNode) {\n                binariesNode.applyToAllLinks(ModelActionRole.Finalize, InputUsingModelAction.single(ModelReference.of(BinarySpec.class), ruleDescriptor, ModelReference.of(ITaskFactory.class), new BiAction<BinarySpec, ITaskFactory>() {\n                    @Override\n                    public void execute(BinarySpec binary, ITaskFactory taskFactory) {\n                        if (!((BinarySpecInternal) binary).isLegacyBinary()) {\n                            TaskInternal binaryLifecycleTask = taskFactory.create(binary.getName(), DefaultTask.class);\n                            binaryLifecycleTask.setGroup(LifecycleBasePlugin.BUILD_GROUP);\n                            binaryLifecycleTask.setDescription(String.format(\"Assembles %s.\", binary));\n                            binary.setBuildTask(binaryLifecycleTask);\n                        }\n                    }\n                }));\n            }\n        }));\n\n        modelRegistry.getRoot().applyToAllLinksTransitive(ModelActionRole.Defaults,\n            DirectNodeNoInputsModelAction.of(\n                ModelReference.of(BinarySpec.class),\n                new SimpleModelRuleDescriptor(descriptor),\n                ComponentSpecInitializer.binaryAction()));\n    }","id":60816,"modified_method":"private void applyRules(ModelRegistry modelRegistry) {\n        DefaultBinaryContainer binaries = instantiator.newInstance(DefaultBinaryContainer.class, instantiator);\n        final String descriptor = LanguageBasePlugin.class.getSimpleName() + \".apply()\";\n        final ModelRuleDescriptor ruleDescriptor = new SimpleModelRuleDescriptor(descriptor);\n        ModelPath binariesPath = ModelPath.path(\"binaries\");\n\n        ModelType<BinarySpec> binarySpecModelType = ModelType.of(BinarySpec.class);\n        // TODO:LPTR Remove once reuse is taken out\n        modelRegistry.createOrReplace(\n            BridgedCollections.creator(\n                ModelReference.of(binariesPath, DefaultBinaryContainer.class),\n                Transformers.constant(binaries),\n                Named.Namer.INSTANCE,\n                descriptor,\n                BridgedCollections.itemDescriptor(descriptor)\n            )\n                .descriptor(descriptor)\n                .ephemeral(true)\n                .withProjection(PolymorphicModelMapProjection.of(binarySpecModelType,\n                    ChildNodeInitializerStrategyAccessors.of(NodeBackedModelMap.createUsingParentNode(binarySpecModelType))))\n                .withProjection(UnmanagedModelProjection.of(DefaultBinaryContainer.class))\n                .build()\n        );\n\n        modelRegistry.configure(ModelActionRole.Defaults, DirectNodeNoInputsModelAction.of(ModelReference.of(binariesPath), ruleDescriptor, new Action<MutableModelNode>() {\n            @Override\n            public void execute(MutableModelNode binariesNode) {\n                binariesNode.applyToAllLinks(ModelActionRole.Finalize, InputUsingModelAction.single(ModelReference.of(BinarySpec.class), ruleDescriptor, ModelReference.of(ITaskFactory.class), new BiAction<BinarySpec, ITaskFactory>() {\n                    @Override\n                    public void execute(BinarySpec binary, ITaskFactory taskFactory) {\n                        BinarySpecInternal binarySpecInternal = (BinarySpecInternal) binary;\n                        if (!binarySpecInternal.isLegacyBinary()) {\n                            TaskInternal binaryLifecycleTask = taskFactory.create(binarySpecInternal.getProjectScopedName(), DefaultTask.class);\n                            binaryLifecycleTask.setGroup(LifecycleBasePlugin.BUILD_GROUP);\n                            binaryLifecycleTask.setDescription(String.format(\"Assembles %s.\", binary));\n                            binary.setBuildTask(binaryLifecycleTask);\n                        }\n                    }\n                }));\n            }\n        }));\n\n        modelRegistry.getRoot().applyToAllLinksTransitive(ModelActionRole.Defaults,\n            DirectNodeNoInputsModelAction.of(\n                ModelReference.of(BinarySpec.class),\n                new SimpleModelRuleDescriptor(descriptor),\n                ComponentSpecInitializer.binaryAction()));\n    }","commit_id":"fd523fd28827b1a0c3184ba78e18d5febd6fd18f","url":"https://github.com/gradle/gradle"},{"original_method":"@Defaults\n    void initializeBinarySourceSets(final ComponentSpec component, final LanguageRegistry languageRegistry) {\n        component.getBinaries().beforeEach(new Action<BinarySpec>() {\n            @Override\n            public void execute(BinarySpec binary) {\n                for (LanguageRegistration<?> languageRegistration : languageRegistry) {\n                    // TODO - allow view as internal type and remove the cast\n                    registerLanguageSourceSets((BinarySpecInternal) binary, component.getName(), languageRegistration);\n                }\n                addComponentSourceSetsToBinaryInputs(binary, component);\n            }\n\n            private <U extends LanguageSourceSet> void registerLanguageSourceSets(BinarySpecInternal binary, String componentName, LanguageRegistration<U> languageRegistration) {\n                NamedDomainObjectFactory<? extends U> sourceSetFactory = languageRegistration.getSourceSetFactory(componentName);\n                binary.getEntityInstantiator().registerFactory(languageRegistration.getSourceSetType(), sourceSetFactory);\n            }\n\n            private void addComponentSourceSetsToBinaryInputs(BinarySpec binary, ComponentSpec component) {\n                binary.getInputs().addAll(component.getSources().values());\n            }\n        });\n    }","id":60817,"modified_method":"@Defaults\n    void initializeBinarySourceSets(final ComponentSpec component, final LanguageRegistry languageRegistry) {\n        component.getBinaries().withType(BinarySpecInternal.class).beforeEach(new Action<BinarySpecInternal>() {\n            @Override\n            public void execute(BinarySpecInternal binary) {\n                for (LanguageRegistration<?> languageRegistration : languageRegistry) {\n                    registerLanguageSourceSets(binary, component.getName(), languageRegistration);\n                }\n                addComponentSourceSetsToBinaryInputs(binary, component);\n            }\n\n            private <U extends LanguageSourceSet> void registerLanguageSourceSets(BinarySpecInternal binary, String componentName, LanguageRegistration<U> languageRegistration) {\n                NamedDomainObjectFactory<? extends U> sourceSetFactory = languageRegistration.getSourceSetFactory(componentName);\n                binary.getEntityInstantiator().registerFactory(languageRegistration.getSourceSetType(), sourceSetFactory);\n            }\n\n            private void addComponentSourceSetsToBinaryInputs(BinarySpec binary, ComponentSpec component) {\n                binary.getInputs().addAll(component.getSources().values());\n            }\n        });\n    }","commit_id":"da942baaf82b191f4af3e40662828bcc83620abf","url":"https://github.com/gradle/gradle"},{"original_method":"@Defaults\n        public void copyTestBinariesToGlobalContainer(ModelMap<BinarySpec> binaries, TestSuiteContainer testSuites) {\n            for (TestSuiteSpec testSuite : testSuites.withType(TestSuiteSpec.class).values()) {\n                for (BinarySpec binary : testSuite.getBinaries().values()) {\n                    binaries.put(((BinarySpecInternal) binary).getProjectScopedName(), binary);\n                }\n            }\n        }","id":60818,"modified_method":"@Defaults\n        public void copyTestBinariesToGlobalContainer(ModelMap<BinarySpec> binaries, TestSuiteContainer testSuites) {\n            for (TestSuiteSpec testSuite : testSuites.withType(TestSuiteSpec.class).values()) {\n                for (BinarySpecInternal binary : testSuite.getBinaries().withType(BinarySpecInternal.class).values()) {\n                    binaries.put(binary.getProjectScopedName(), binary);\n                }\n            }\n        }","commit_id":"229d8c7ef9995277e06362675606a0dfb90b9d5e","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n   * plugin extensions + all the components that depend on plugin extensions\n   */\n  private void startServiceComponents() {\n    servicesContainer = coreContainer.createChild();\n\n    servicesContainer.addSingleton(ESIndex.class);\n    servicesContainer.addSingleton(HttpDownloader.class);\n    servicesContainer.addSingleton(UriReader.class);\n    servicesContainer.addSingleton(UpdateCenterClient.class);\n    servicesContainer.addSingleton(UpdateCenterMatrixFactory.class);\n    servicesContainer.addSingleton(PluginDownloader.class);\n    servicesContainer.addSingleton(ServerIdGenerator.class);\n    // depends on plugins\n    servicesContainer.addSingleton(ChartFactory.class);\n    servicesContainer.addSingleton(Languages.class);\n    servicesContainer.addSingleton(Views.class);\n    servicesContainer.addSingleton(CodeColorizers.class);\n    servicesContainer.addComponent(RulesDao.class, false);\n    servicesContainer.addComponent(MeasuresDao.class, false);\n    servicesContainer.addComponent(org.sonar.api.database.daos.MeasuresDao.class, false);\n    servicesContainer.addComponent(ProfilesDao.class, false);\n    servicesContainer.addComponent(ProfilesManager.class, false);\n    servicesContainer.addSingleton(SecurityRealmFactory.class);\n    servicesContainer.addSingleton(ServerLifecycleNotifier.class);\n    servicesContainer.addSingleton(AnnotationProfileParser.class);\n    servicesContainer.addSingleton(XMLProfileParser.class);\n    servicesContainer.addSingleton(XMLProfileSerializer.class);\n    servicesContainer.addSingleton(AnnotationRuleParser.class);\n    servicesContainer.addSingleton(XMLRuleParser.class);\n    servicesContainer.addSingleton(DefaultRuleFinder.class);\n    servicesContainer.addSingleton(DefaultMetricFinder.class);\n    servicesContainer.addSingleton(ResourceTypes.class);\n    servicesContainer.addSingleton(SettingsChangeNotifier.class);\n    servicesContainer.addSingleton(PageDecorations.class);\n    servicesContainer.addSingleton(MeasureFilterFactory.class);\n    servicesContainer.addSingleton(MeasureFilterExecutor.class);\n    servicesContainer.addSingleton(MeasureFilterEngine.class);\n    servicesContainer.addSingleton(PreviewCache.class);\n    servicesContainer.addSingleton(DefaultResourcePermissions.class);\n    servicesContainer.addSingleton(Periods.class);\n\n    // quality profiles\n    servicesContainer.addSingleton(ProfileRules.class);\n    servicesContainer.addSingleton(QProfiles.class);\n    servicesContainer.addSingleton(QProfileLookup.class);\n    servicesContainer.addSingleton(QProfileOperations.class);\n    servicesContainer.addSingleton(QProfileActiveRuleOperations.class);\n    servicesContainer.addSingleton(QProfileRuleOperations.class);\n    servicesContainer.addSingleton(QProfileProjectOperations.class);\n    servicesContainer.addSingleton(QProfileProjectLookup.class);\n    servicesContainer.addSingleton(QProfileBackup.class);\n    servicesContainer.addSingleton(QProfilePluginExporter.class);\n\n    // users\n    servicesContainer.addSingleton(HibernateUserFinder.class);\n    servicesContainer.addSingleton(NewUserNotifier.class);\n    servicesContainer.addSingleton(DefaultUserFinder.class);\n    servicesContainer.addSingleton(DefaultUserService.class);\n\n    // groups\n    servicesContainer.addSingleton(InternalGroupMembershipService.class);\n    servicesContainer.addSingleton(GroupMembershipFinder.class);\n\n    // permissions\n    servicesContainer.addSingleton(PermissionFacade.class);\n    servicesContainer.addSingleton(InternalPermissionService.class);\n    servicesContainer.addSingleton(InternalPermissionTemplateService.class);\n    servicesContainer.addSingleton(PermissionFinder.class);\n\n    // components\n    servicesContainer.addSingleton(DefaultComponentFinder.class);\n    servicesContainer.addSingleton(DefaultRubyComponentService.class);\n\n    // issues\n    servicesContainer.addSingleton(ServerIssueStorage.class);\n    servicesContainer.addSingleton(IssueUpdater.class);\n    servicesContainer.addSingleton(FunctionExecutor.class);\n    servicesContainer.addSingleton(IssueWorkflow.class);\n    servicesContainer.addSingleton(IssueService.class);\n    servicesContainer.addSingleton(IssueCommentService.class);\n    servicesContainer.addSingleton(DefaultIssueFinder.class);\n    servicesContainer.addSingleton(IssueStatsFinder.class);\n    servicesContainer.addSingleton(PublicRubyIssueService.class);\n    servicesContainer.addSingleton(InternalRubyIssueService.class);\n    servicesContainer.addSingleton(ActionPlanService.class);\n    servicesContainer.addSingleton(IssueChangelogService.class);\n    servicesContainer.addSingleton(IssueNotifications.class);\n    servicesContainer.addSingleton(ActionService.class);\n    servicesContainer.addSingleton(Actions.class);\n    servicesContainer.addSingleton(IssueFilterSerializer.class);\n    servicesContainer.addSingleton(IssueFilterService.class);\n    servicesContainer.addSingleton(IssueBulkChangeService.class);\n    servicesContainer.addSingleton(IssueChangelogFormatter.class);\n    // issues actions\n    servicesContainer.addSingleton(AssignAction.class);\n    servicesContainer.addSingleton(PlanAction.class);\n    servicesContainer.addSingleton(SetSeverityAction.class);\n    servicesContainer.addSingleton(CommentAction.class);\n    servicesContainer.addSingleton(TransitionAction.class);\n\n    // rules\n    servicesContainer.addSingleton(RuleRegistry.class);\n    servicesContainer.addSingleton(RubyRuleService.class);\n    servicesContainer.addSingleton(RuleRepositories.class);\n\n    // technical debt\n    servicesContainer.addSingleton(InternalRubyTechnicalDebtService.class);\n    servicesContainer.addSingleton(TechnicalDebtModelSynchronizer.class);\n    servicesContainer.addSingleton(TechnicalDebtModelRepository.class);\n    servicesContainer.addSingleton(TechnicalDebtXMLImporter.class);\n    servicesContainer.addSingleton(TechnicalDebtConverter.class);\n    servicesContainer.addSingleton(TechnicalDebtFormatter.class);\n    servicesContainer.addSingleton(DefaultTechnicalDebtManager.class);\n\n    // text\n    servicesContainer.addSingleton(MacroInterpreter.class);\n    servicesContainer.addSingleton(RubyTextService.class);\n\n    // Notifications\n    servicesContainer.addSingleton(EmailSettings.class);\n    servicesContainer.addSingleton(NotificationService.class);\n    servicesContainer.addSingleton(NotificationCenter.class);\n    servicesContainer.addSingleton(DefaultNotificationManager.class);\n\n    // graphs and perspective related classes\n    servicesContainer.addSingleton(TestablePerspectiveLoader.class);\n    servicesContainer.addSingleton(TestPlanPerspectiveLoader.class);\n    servicesContainer.addSingleton(SnapshotPerspectives.class);\n    servicesContainer.addSingleton(HtmlSourceDecorator.class);\n\n    // Type validation\n    servicesContainer.addSingleton(TypeValidations.class);\n    servicesContainer.addSingleton(IntegerTypeValidation.class);\n    servicesContainer.addSingleton(FloatTypeValidation.class);\n    servicesContainer.addSingleton(BooleanTypeValidation.class);\n    servicesContainer.addSingleton(TextTypeValidation.class);\n    servicesContainer.addSingleton(StringTypeValidation.class);\n    servicesContainer.addSingleton(StringListTypeValidation.class);\n\n    ServerExtensionInstaller extensionRegistrar = servicesContainer.getComponentByType(ServerExtensionInstaller.class);\n    extensionRegistrar.registerExtensions(servicesContainer);\n\n    servicesContainer.startComponents();\n  }","id":60819,"modified_method":"/**\n   * plugin extensions + all the components that depend on plugin extensions\n   */\n  private void startServiceComponents() {\n    servicesContainer = coreContainer.createChild();\n\n    servicesContainer.addSingleton(ESIndex.class);\n    servicesContainer.addSingleton(HttpDownloader.class);\n    servicesContainer.addSingleton(UriReader.class);\n    servicesContainer.addSingleton(UpdateCenterClient.class);\n    servicesContainer.addSingleton(UpdateCenterMatrixFactory.class);\n    servicesContainer.addSingleton(PluginDownloader.class);\n    servicesContainer.addSingleton(ServerIdGenerator.class);\n    // depends on plugins\n    servicesContainer.addSingleton(ChartFactory.class);\n    servicesContainer.addSingleton(Languages.class);\n    servicesContainer.addSingleton(Views.class);\n    servicesContainer.addSingleton(CodeColorizers.class);\n    servicesContainer.addComponent(RulesDao.class, false);\n    servicesContainer.addComponent(MeasuresDao.class, false);\n    servicesContainer.addComponent(org.sonar.api.database.daos.MeasuresDao.class, false);\n    servicesContainer.addComponent(ProfilesDao.class, false);\n    servicesContainer.addComponent(ProfilesManager.class, false);\n    servicesContainer.addSingleton(SecurityRealmFactory.class);\n    servicesContainer.addSingleton(ServerLifecycleNotifier.class);\n    servicesContainer.addSingleton(AnnotationProfileParser.class);\n    servicesContainer.addSingleton(XMLProfileParser.class);\n    servicesContainer.addSingleton(XMLProfileSerializer.class);\n    servicesContainer.addSingleton(AnnotationRuleParser.class);\n    servicesContainer.addSingleton(XMLRuleParser.class);\n    servicesContainer.addSingleton(DefaultRuleFinder.class);\n    servicesContainer.addSingleton(DefaultMetricFinder.class);\n    servicesContainer.addSingleton(ResourceTypes.class);\n    servicesContainer.addSingleton(SettingsChangeNotifier.class);\n    servicesContainer.addSingleton(PageDecorations.class);\n    servicesContainer.addSingleton(MeasureFilterFactory.class);\n    servicesContainer.addSingleton(MeasureFilterExecutor.class);\n    servicesContainer.addSingleton(MeasureFilterEngine.class);\n    servicesContainer.addSingleton(PreviewCache.class);\n    servicesContainer.addSingleton(DefaultResourcePermissions.class);\n    servicesContainer.addSingleton(Periods.class);\n\n    // web services\n    servicesContainer.addSingleton(WebServiceEngine.class);\n    servicesContainer.addSingleton(ListingWebService.class);\n\n    // quality profiles\n    servicesContainer.addSingleton(ProfileRules.class);\n    servicesContainer.addSingleton(QProfiles.class);\n    servicesContainer.addSingleton(QProfileLookup.class);\n    servicesContainer.addSingleton(QProfileOperations.class);\n    servicesContainer.addSingleton(QProfileActiveRuleOperations.class);\n    servicesContainer.addSingleton(QProfileRuleOperations.class);\n    servicesContainer.addSingleton(QProfileProjectOperations.class);\n    servicesContainer.addSingleton(QProfileProjectLookup.class);\n    servicesContainer.addSingleton(QProfileBackup.class);\n    servicesContainer.addSingleton(QProfilePluginExporter.class);\n\n    // users\n    servicesContainer.addSingleton(HibernateUserFinder.class);\n    servicesContainer.addSingleton(NewUserNotifier.class);\n    servicesContainer.addSingleton(DefaultUserFinder.class);\n    servicesContainer.addSingleton(DefaultUserService.class);\n\n    // groups\n    servicesContainer.addSingleton(InternalGroupMembershipService.class);\n    servicesContainer.addSingleton(GroupMembershipFinder.class);\n\n    // permissions\n    servicesContainer.addSingleton(PermissionFacade.class);\n    servicesContainer.addSingleton(InternalPermissionService.class);\n    servicesContainer.addSingleton(InternalPermissionTemplateService.class);\n    servicesContainer.addSingleton(PermissionFinder.class);\n\n    // components\n    servicesContainer.addSingleton(DefaultComponentFinder.class);\n    servicesContainer.addSingleton(DefaultRubyComponentService.class);\n\n    // issues\n    servicesContainer.addSingleton(ServerIssueStorage.class);\n    servicesContainer.addSingleton(IssueUpdater.class);\n    servicesContainer.addSingleton(FunctionExecutor.class);\n    servicesContainer.addSingleton(IssueWorkflow.class);\n    servicesContainer.addSingleton(IssueService.class);\n    servicesContainer.addSingleton(IssueCommentService.class);\n    servicesContainer.addSingleton(DefaultIssueFinder.class);\n    servicesContainer.addSingleton(IssueStatsFinder.class);\n    servicesContainer.addSingleton(PublicRubyIssueService.class);\n    servicesContainer.addSingleton(InternalRubyIssueService.class);\n    servicesContainer.addSingleton(ActionPlanService.class);\n    servicesContainer.addSingleton(IssueChangelogService.class);\n    servicesContainer.addSingleton(IssueNotifications.class);\n    servicesContainer.addSingleton(ActionService.class);\n    servicesContainer.addSingleton(Actions.class);\n    servicesContainer.addSingleton(IssueFilterSerializer.class);\n    servicesContainer.addSingleton(IssueFilterService.class);\n    servicesContainer.addSingleton(IssueBulkChangeService.class);\n    servicesContainer.addSingleton(IssueChangelogFormatter.class);\n    // issues actions\n    servicesContainer.addSingleton(AssignAction.class);\n    servicesContainer.addSingleton(PlanAction.class);\n    servicesContainer.addSingleton(SetSeverityAction.class);\n    servicesContainer.addSingleton(CommentAction.class);\n    servicesContainer.addSingleton(TransitionAction.class);\n\n    // rules\n    servicesContainer.addSingleton(RuleRegistry.class);\n    servicesContainer.addSingleton(RubyRuleService.class);\n    servicesContainer.addSingleton(RuleRepositories.class);\n\n    // technical debt\n    servicesContainer.addSingleton(InternalRubyTechnicalDebtService.class);\n    servicesContainer.addSingleton(TechnicalDebtModelSynchronizer.class);\n    servicesContainer.addSingleton(TechnicalDebtModelRepository.class);\n    servicesContainer.addSingleton(TechnicalDebtXMLImporter.class);\n    servicesContainer.addSingleton(TechnicalDebtConverter.class);\n    servicesContainer.addSingleton(TechnicalDebtFormatter.class);\n    servicesContainer.addSingleton(DefaultTechnicalDebtManager.class);\n\n    // text\n    servicesContainer.addSingleton(MacroInterpreter.class);\n    servicesContainer.addSingleton(RubyTextService.class);\n\n    // Notifications\n    servicesContainer.addSingleton(EmailSettings.class);\n    servicesContainer.addSingleton(NotificationService.class);\n    servicesContainer.addSingleton(NotificationCenter.class);\n    servicesContainer.addSingleton(DefaultNotificationManager.class);\n\n    // graphs and perspective related classes\n    servicesContainer.addSingleton(TestablePerspectiveLoader.class);\n    servicesContainer.addSingleton(TestPlanPerspectiveLoader.class);\n    servicesContainer.addSingleton(SnapshotPerspectives.class);\n    servicesContainer.addSingleton(HtmlSourceDecorator.class);\n\n    // Type validation\n    servicesContainer.addSingleton(TypeValidations.class);\n    servicesContainer.addSingleton(IntegerTypeValidation.class);\n    servicesContainer.addSingleton(FloatTypeValidation.class);\n    servicesContainer.addSingleton(BooleanTypeValidation.class);\n    servicesContainer.addSingleton(TextTypeValidation.class);\n    servicesContainer.addSingleton(StringTypeValidation.class);\n    servicesContainer.addSingleton(StringListTypeValidation.class);\n\n    ServerExtensionInstaller extensionRegistrar = servicesContainer.getComponentByType(ServerExtensionInstaller.class);\n    extensionRegistrar.registerExtensions(servicesContainer);\n\n    servicesContainer.startComponents();\n  }","commit_id":"e98e570751ac57c6948fb3da8fdc978f927a975b","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void handle_request() {\n    MetricWebService metricWs = new MetricWebService();\n    metricWs.define(context);\n\n    assertThat(metricWs.showCalled).isFalse();\n    assertThat(metricWs.createCalled).isFalse();\n    context.controller(\"metric\").action(\"show\").handler().handle(mock(Request.class), mock(Response.class));\n    assertThat(metricWs.showCalled).isTrue();\n    assertThat(metricWs.createCalled).isFalse();\n    context.controller(\"metric\").action(\"create\").handler().handle(mock(Request.class), mock(Response.class));\n    assertThat(metricWs.createCalled).isTrue();\n  }","id":60820,"modified_method":"@Test\n  public void handle_request() throws Exception {\n    MetricWebService metricWs = new MetricWebService();\n    metricWs.define(context);\n\n    assertThat(metricWs.showCalled).isFalse();\n    assertThat(metricWs.createCalled).isFalse();\n    context.controller(\"api/metric\").action(\"show\").handler().handle(mock(Request.class), mock(Response.class));\n    assertThat(metricWs.showCalled).isTrue();\n    assertThat(metricWs.createCalled).isFalse();\n    context.controller(\"api/metric\").action(\"create\").handler().handle(mock(Request.class), mock(Response.class));\n    assertThat(metricWs.createCalled).isTrue();\n  }","commit_id":"e98e570751ac57c6948fb3da8fdc978f927a975b","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n    public void define(Context context) {\n      NewController newController = context.newController(\"metric\")\n          .setApi(true)\n          .setDescription(\"Metrics\")\n          .setSince(\"3.2\");\n      newController.newAction(\"show\")\n          .setDescription(\"Show metric\")\n          .setSince(\"4.1\")\n          .setHandler(new RequestHandler() {\n            @Override\n            public void handle(Request request, Response response) {\n              show(request, response);\n            }\n          });\n      newController.newAction(\"create\")\n          .setDescription(\"Create metric\")\n          .setPost(true)\n          .setHandler(new RequestHandler() {\n            @Override\n            public void handle(Request request, Response response) {\n              create(request, response);\n            }\n          });\n      newController.done();\n    }","id":60821,"modified_method":"@Override\n    public void define(Context context) {\n      NewController newController = context.newController(\"api/metric\")\n        .setDescription(\"Metrics\")\n        .setSince(\"3.2\");\n      newController.newAction(\"show\")\n          .setDescription(\"Show metric\")\n          .setHandler(new RequestHandler() {\n            @Override\n            public void handle(Request request, Response response) {\n              show(request, response);\n            }\n          });\n      newController.newAction(\"create\")\n        .setDescription(\"Create metric\")\n        .setSince(\"4.1\")\n        .setPost(true)\n        .setHandler(new RequestHandler() {\n          @Override\n          public void handle(Request request, Response response) {\n            create(request, response);\n          }\n        });\n      newController.done();\n    }","commit_id":"e98e570751ac57c6948fb3da8fdc978f927a975b","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void define_web_service() {\n    MetricWebService metricWs = new MetricWebService();\n\n    metricWs.define(context);\n\n    WebService.Controller controller = context.controller(\"metric\");\n    assertThat(controller).isNotNull();\n    assertThat(controller.key()).isEqualTo(\"metric\");\n    assertThat(controller.description()).isEqualTo(\"Metrics\");\n    assertThat(controller.since()).isEqualTo(\"3.2\");\n    assertThat(controller.isApi()).isTrue();\n    assertThat(controller.path()).isEqualTo(\"ws/metric\");\n    assertThat(controller.actions()).hasSize(2);\n    WebService.Action showAction = controller.action(\"show\");\n    assertThat(showAction).isNotNull();\n    assertThat(showAction.key()).isEqualTo(\"show\");\n    assertThat(showAction.description()).isEqualTo(\"Show metric\");\n    assertThat(showAction.handler()).isNotNull();\n    assertThat(showAction.since()).isEqualTo(\"4.1\");\n    assertThat(showAction.isPost()).isFalse();\n    assertThat(showAction.path()).isEqualTo(\"ws/metric/show\");\n    WebService.Action createAction = controller.action(\"create\");\n    assertThat(createAction).isNotNull();\n    assertThat(createAction.key()).isEqualTo(\"create\");\n    assertThat(createAction.isPost()).isTrue();\n  }","id":60822,"modified_method":"@Test\n  public void define_web_service() {\n    MetricWebService metricWs = new MetricWebService();\n\n    metricWs.define(context);\n\n    WebService.Controller controller = context.controller(\"api/metric\");\n    assertThat(controller).isNotNull();\n    assertThat(controller.path()).isEqualTo(\"api/metric\");\n    assertThat(controller.description()).isEqualTo(\"Metrics\");\n    assertThat(controller.since()).isEqualTo(\"3.2\");\n    assertThat(controller.isApi()).isTrue();\n    assertThat(controller.actions()).hasSize(2);\n    WebService.Action showAction = controller.action(\"show\");\n    assertThat(showAction).isNotNull();\n    assertThat(showAction.key()).isEqualTo(\"show\");\n    assertThat(showAction.description()).isEqualTo(\"Show metric\");\n    assertThat(showAction.handler()).isNotNull();\n    // same as controller\n    assertThat(showAction.since()).isEqualTo(\"3.2\");\n    assertThat(showAction.isPost()).isFalse();\n    assertThat(showAction.path()).isEqualTo(\"api/metric/show\");\n    WebService.Action createAction = controller.action(\"create\");\n    assertThat(createAction).isNotNull();\n    assertThat(createAction.key()).isEqualTo(\"create\");\n    // overrides controller version\n    assertThat(createAction.since()).isEqualTo(\"4.1\");\n    assertThat(createAction.isPost()).isTrue();\n  }","commit_id":"e98e570751ac57c6948fb3da8fdc978f927a975b","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_if_duplicated_ws_keys() {\n    MetricWebService metricWs = new MetricWebService();\n    metricWs.define(context);\n    try {\n      new WebService() {\n        @Override\n        public void define(Context context) {\n          NewController newController = context.newController(\"metric\");\n          newController.newAction(\"delete\");\n          newController.done();\n        }\n      }.define(context);\n      fail();\n    } catch (IllegalStateException e) {\n      assertThat(e).hasMessage(\"The web service 'metric' is defined multiple times\");\n    }\n  }","id":60823,"modified_method":"@Test\n  public void fail_if_duplicated_ws_keys() {\n    MetricWebService metricWs = new MetricWebService();\n    metricWs.define(context);\n    try {\n      new WebService() {\n        @Override\n        public void define(Context context) {\n          NewController newController = context.newController(\"api/metric\");\n          newController.newAction(\"delete\");\n          newController.done();\n        }\n      }.define(context);\n      fail();\n    } catch (IllegalStateException e) {\n      assertThat(e).hasMessage(\"The web service 'api/metric' is defined multiple times\");\n    }\n  }","commit_id":"e98e570751ac57c6948fb3da8fdc978f927a975b","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public QProfileBackuper(QProfileReset reset, DbClient db, ActiveRuleIndex2 activeRuleIndex) {\n    this.reset = reset;\n    this.db = db;\n    this.activeRuleIndex = activeRuleIndex;\n  }","id":60824,"modified_method":"public QProfileBackuper(QProfileReset reset, DbClient db) {\n    this.reset = reset;\n    this.db = db;\n  }","commit_id":"b0ae896d7abdfec5648ffd450caae368543a7d05","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void backup(String key, Writer writer) {\n    QualityProfileDto profile;\n    DbSession dbSession = db.openSession(false);\n    try {\n      profile = db.qualityProfileDao().selectOrFailByKey(dbSession, key);\n    } finally {\n      dbSession.close();\n    }\n    List<ActiveRuleDoc> activeRules = Lists.newArrayList(activeRuleIndex.findByProfile(profile.getKey()));\n    Collections.sort(activeRules, BackupActiveRuleComparator.INSTANCE);\n    writeXml(writer, profile, activeRules.iterator());\n  }","id":60825,"modified_method":"public void backup(String key, Writer writer) {\n    QualityProfileDto profile;\n    DbSession dbSession = db.openSession(false);\n    try {\n      profile = db.qualityProfileDao().selectOrFailByKey(dbSession, key);\n      List<ActiveRuleDto> activeRules = db.activeRuleDao().selectByProfileKey(dbSession, key);\n      Collections.sort(activeRules, BackupActiveRuleComparator.INSTANCE);\n      writeXml(dbSession, writer, profile, activeRules.iterator());\n    } finally {\n      db.closeSession(dbSession);\n    }\n  }","commit_id":"b0ae896d7abdfec5648ffd450caae368543a7d05","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static void writeXml(Writer writer, QualityProfileDto profile, Iterator<ActiveRuleDoc> activeRules) {\n    XmlWriter xml = XmlWriter.of(writer).declaration();\n    xml.begin(\"profile\");\n    xml.prop(\"name\", profile.getName());\n    xml.prop(\"language\", profile.getLanguage());\n    xml.begin(\"rules\");\n    while (activeRules.hasNext()) {\n      ActiveRule activeRule = activeRules.next();\n      xml.begin(\"rule\");\n      xml.prop(\"repositoryKey\", activeRule.key().ruleKey().repository());\n      xml.prop(\"key\", activeRule.key().ruleKey().rule());\n      xml.prop(\"priority\", activeRule.severity());\n      xml.begin(\"parameters\");\n      for (Map.Entry<String, String> param : activeRule.params().entrySet()) {\n        xml\n          .begin(\"parameter\")\n          .prop(\"key\", param.getKey())\n          .prop(\"value\", param.getValue())\n          .end();\n      }\n      xml.end(\"parameters\");\n      xml.end(\"rule\");\n    }\n    xml.end(\"rules\").end(\"profile\").close();\n  }","id":60826,"modified_method":"private void writeXml(DbSession dbSession, Writer writer, QualityProfileDto profile, Iterator<ActiveRuleDto> activeRules) {\n    XmlWriter xml = XmlWriter.of(writer).declaration();\n    xml.begin(\"profile\");\n    xml.prop(\"name\", profile.getName());\n    xml.prop(\"language\", profile.getLanguage());\n    xml.begin(\"rules\");\n    while (activeRules.hasNext()) {\n      ActiveRuleDto activeRule = activeRules.next();\n      xml.begin(\"rule\");\n      xml.prop(\"repositoryKey\", activeRule.getKey().ruleKey().repository());\n      xml.prop(\"key\", activeRule.getKey().ruleKey().rule());\n      xml.prop(\"priority\", activeRule.getSeverityString());\n      xml.begin(\"parameters\");\n      for (ActiveRuleParamDto param : db.activeRuleDao().selectParamsByActiveRuleKey(dbSession, activeRule.getKey())) {\n        xml\n          .begin(\"parameter\")\n          .prop(\"key\", param.getKey())\n          .prop(\"value\", param.getValue())\n          .end();\n      }\n      xml.end(\"parameters\");\n      xml.end(\"rule\");\n    }\n    xml.end(\"rules\").end(\"profile\").close();\n  }","commit_id":"b0ae896d7abdfec5648ffd450caae368543a7d05","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void keep_other_inherited_rules() throws Exception {\n    // define two parent/child profiles\n    db.qualityProfileDao().insert(dbSession,\n      QProfileTesting.newXooP1(),\n      QProfileTesting.newXooP2().setParentKee(QProfileTesting.XOO_P1_KEY));\n    dbSession.commit();\n\n    // rule x1 is activated on parent profile and is inherited by child profile\n    RuleActivation activation = new RuleActivation(RuleTesting.XOO_X1);\n    activation.setSeverity(Severity.INFO);\n    activation.setParameter(\"max\", \"10\");\n    tester.get(RuleActivator.class).activate(dbSession, activation, QProfileTesting.XOO_P1_KEY);\n    dbSession.commit();\n    dbSession.clearCache();\n\n    // backup of child profile contains x2 but not x1\n    tester.get(QProfileBackuper.class).restore(new StringReader(\n      Resources.toString(getClass().getResource(\"QProfileBackuperMediumTest/keep_other_inherited_rules.xml\"), StandardCharsets.UTF_8)), QProfileTesting.XOO_P2_NAME);\n\n    // x1 and x2\n    List<ActiveRuleDoc> activeRules = Lists.newArrayList(tester.get(QProfileLoader.class).findActiveRulesByProfile(QProfileTesting.XOO_P2_KEY));\n    assertThat(activeRules).hasSize(2);\n  }","id":60827,"modified_method":"@Test\n  public void keep_other_inherited_rules() throws Exception {\n    // define two parent/child profiles\n    db.qualityProfileDao().insert(dbSession,\n      QProfileTesting.newXooP1(),\n      QProfileTesting.newXooP2().setParentKee(QProfileTesting.XOO_P1_KEY));\n    dbSession.commit();\n\n    // rule x1 is activated on parent profile and is inherited by child profile\n    RuleActivation activation = new RuleActivation(RuleTesting.XOO_X1);\n    activation.setSeverity(Severity.INFO);\n    activation.setParameter(\"max\", \"10\");\n    tester.get(RuleActivator.class).activate(dbSession, activation, QProfileTesting.XOO_P1_KEY);\n    dbSession.commit();\n    dbSession.clearCache();\n    activeRuleIndexer.index();\n\n    // backup of child profile contains x2 but not x1\n    tester.get(QProfileBackuper.class).restore(new StringReader(\n      Resources.toString(getClass().getResource(\"QProfileBackuperMediumTest/keep_other_inherited_rules.xml\"), StandardCharsets.UTF_8)), QProfileTesting.XOO_P2_NAME);\n\n    // x1 and x2\n    List<ActiveRuleDoc> activeRules = Lists.newArrayList(tester.get(QProfileLoader.class).findActiveRulesByProfile(QProfileTesting.XOO_P2_KEY));\n    assertThat(activeRules).hasSize(2);\n  }","commit_id":"b0ae896d7abdfec5648ffd450caae368543a7d05","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void restore_and_create_profile() throws Exception {\n    // Backup file declares profile P1 on xoo\n    tester.get(QProfileBackuper.class).restore(new StringReader(\n      Resources.toString(getClass().getResource(\"QProfileBackuperMediumTest/restore.xml\"), StandardCharsets.UTF_8)),\n      null);\n\n    QualityProfileDto profile = db.qualityProfileDao().selectByNameAndLanguage(\"P1\", \"xoo\", dbSession);\n    assertThat(profile).isNotNull();\n\n    List<ActiveRuleDoc> activeRules = Lists.newArrayList(tester.get(QProfileLoader.class).findActiveRulesByProfile(profile.getKey()));\n    assertThat(activeRules).hasSize(1);\n    assertThat(activeRules.get(0).severity()).isEqualTo(\"BLOCKER\");\n    assertThat(activeRules.get(0).inheritance()).isEqualTo(ActiveRule.Inheritance.NONE);\n    assertThat(activeRules.get(0).params().get(\"max\")).isEqualTo(\"7\");\n  }","id":60828,"modified_method":"@Test\n  public void restore_and_create_profile() throws Exception {\n    // Backup file declares profile P1 on xoo\n    tester.get(QProfileBackuper.class).restore(new StringReader(\n      Resources.toString(getClass().getResource(\"QProfileBackuperMediumTest/restore.xml\"), StandardCharsets.UTF_8)),\n      null);\n\n    QualityProfileDto profile = db.qualityProfileDao().selectByNameAndLanguage(\"P1\", \"xoo\", dbSession);\n    assertThat(profile).isNotNull();\n\n    List<ActiveRuleDoc> activeRules = Lists.newArrayList(tester.get(QProfileLoader.class).findActiveRulesByProfile(profile.getKey()));\n    assertThat(activeRules).hasSize(1);\n    ActiveRuleDoc activeRuleDoc = activeRules.get(0);\n    assertThat(activeRuleDoc.severity()).isEqualTo(\"BLOCKER\");\n    assertThat(activeRuleDoc.inheritance()).isEqualTo(ActiveRule.Inheritance.NONE);\n\n    List<ActiveRuleParamDto> params = tester.get(ActiveRuleDao.class).selectParamsByActiveRuleKey(dbSession, activeRuleDoc.key());\n    assertThat(params).hasSize(1);\n    assertThat(params.get(0).getKey()).isEqualTo(\"max\");\n    assertThat(params.get(0).getValue()).isEqualTo(\"7\");\n  }","commit_id":"b0ae896d7abdfec5648ffd450caae368543a7d05","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void restore_and_update_profile() throws Exception {\n    // create profile P1 with rules x1 and x2 activated\n    db.qualityProfileDao().insert(dbSession, QProfileTesting.newXooP1());\n    RuleActivation activation = new RuleActivation(RuleTesting.XOO_X1);\n    activation.setSeverity(Severity.INFO);\n    activation.setParameter(\"max\", \"10\");\n    tester.get(RuleActivator.class).activate(dbSession, activation, QProfileTesting.XOO_P1_NAME);\n\n    activation = new RuleActivation(RuleTesting.XOO_X2);\n    activation.setSeverity(Severity.INFO);\n    tester.get(RuleActivator.class).activate(dbSession, activation, QProfileTesting.XOO_P1_NAME);\n    dbSession.commit();\n    dbSession.clearCache();\n\n    // restore backup, which activates only x1\n    // -> update x1 and deactivate x2\n    tester.get(QProfileBackuper.class).restore(new StringReader(\n      Resources.toString(getClass().getResource(\"QProfileBackuperMediumTest/restore.xml\"), StandardCharsets.UTF_8)), null);\n\n    List<ActiveRuleDoc> activeRules = Lists.newArrayList(tester.get(QProfileLoader.class).findActiveRulesByProfile(QProfileTesting.XOO_P1_KEY));\n    assertThat(activeRules).hasSize(1);\n    assertThat(activeRules.get(0).severity()).isEqualTo(\"BLOCKER\");\n    assertThat(activeRules.get(0).inheritance()).isEqualTo(ActiveRule.Inheritance.NONE);\n    assertThat(activeRules.get(0).params().get(\"max\")).isEqualTo(\"7\");\n  }","id":60829,"modified_method":"@Test\n  public void restore_and_update_profile() throws Exception {\n    // create profile P1 with rules x1 and x2 activated\n    db.qualityProfileDao().insert(dbSession, QProfileTesting.newXooP1());\n    RuleActivation activation = new RuleActivation(RuleTesting.XOO_X1);\n    activation.setSeverity(Severity.INFO);\n    activation.setParameter(\"max\", \"10\");\n    tester.get(RuleActivator.class).activate(dbSession, activation, QProfileTesting.XOO_P1_NAME);\n\n    activation = new RuleActivation(RuleTesting.XOO_X2);\n    activation.setSeverity(Severity.INFO);\n    tester.get(RuleActivator.class).activate(dbSession, activation, QProfileTesting.XOO_P1_NAME);\n    dbSession.commit();\n    dbSession.clearCache();\n    activeRuleIndexer.index();\n\n    // restore backup, which activates only x1\n    // -> update x1 and deactivate x2\n    tester.get(QProfileBackuper.class).restore(new StringReader(\n      Resources.toString(getClass().getResource(\"QProfileBackuperMediumTest/restore.xml\"), StandardCharsets.UTF_8)), null);\n\n    List<ActiveRuleDoc> activeRules = Lists.newArrayList(tester.get(QProfileLoader.class).findActiveRulesByProfile(QProfileTesting.XOO_P1_KEY));\n    assertThat(activeRules).hasSize(1);\n    ActiveRuleDoc activeRuleDoc = activeRules.get(0);\n    assertThat(activeRuleDoc.severity()).isEqualTo(\"BLOCKER\");\n    assertThat(activeRuleDoc.inheritance()).isEqualTo(ActiveRule.Inheritance.NONE);\n\n    List<ActiveRuleParamDto> params = tester.get(ActiveRuleDao.class).selectParamsByActiveRuleKey(dbSession, activeRuleDoc.key());\n    assertThat(params).hasSize(1);\n    assertThat(params.get(0).getKey()).isEqualTo(\"max\");\n    assertThat(params.get(0).getValue()).isEqualTo(\"7\");\n  }","commit_id":"b0ae896d7abdfec5648ffd450caae368543a7d05","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void restore_parent_profile() throws Exception {\n    // define two parent/child profiles\n    db.qualityProfileDao().insert(dbSession,\n      QProfileTesting.newXooP1(),\n      QProfileTesting.newXooP2().setParentKee(QProfileTesting.XOO_P1_KEY));\n    dbSession.commit();\n\n    // rule x1 is activated on parent profile (so inherited by child profile)\n    RuleActivation activation = new RuleActivation(RuleTesting.XOO_X1);\n    activation.setSeverity(Severity.INFO);\n    activation.setParameter(\"max\", \"10\");\n    tester.get(RuleActivator.class).activate(dbSession, activation, QProfileTesting.XOO_P1_KEY);\n    dbSession.commit();\n    dbSession.clearCache();\n\n    // restore backup of parent profile -> update x1 and propagates to child\n    tester.get(QProfileBackuper.class).restore(new StringReader(\n      Resources.toString(getClass().getResource(\"QProfileBackuperMediumTest/restore-parent.xml\"), StandardCharsets.UTF_8)), null);\n\n    // parent profile is updated\n    List<ActiveRuleDoc> activeRules = Lists.newArrayList(tester.get(QProfileLoader.class).findActiveRulesByProfile(QProfileTesting.XOO_P1_KEY));\n    assertThat(activeRules).hasSize(1);\n    assertThat(activeRules.get(0).severity()).isEqualTo(\"BLOCKER\");\n    assertThat(activeRules.get(0).inheritance()).isEqualTo(ActiveRule.Inheritance.NONE);\n    assertThat(activeRules.get(0).params().get(\"max\")).isEqualTo(\"7\");\n\n    // child profile is inherited\n    activeRules = Lists.newArrayList(tester.get(QProfileLoader.class).findActiveRulesByProfile(QProfileTesting.XOO_P2_KEY));\n    assertThat(activeRules).hasSize(1);\n    assertThat(activeRules.get(0).severity()).isEqualTo(\"BLOCKER\");\n    assertThat(activeRules.get(0).inheritance()).isEqualTo(ActiveRule.Inheritance.INHERITED);\n    assertThat(activeRules.get(0).params().get(\"max\")).isEqualTo(\"7\");\n  }","id":60830,"modified_method":"@Test\n  public void restore_parent_profile() throws Exception {\n    // define two parent/child profiles\n    db.qualityProfileDao().insert(dbSession,\n      QProfileTesting.newXooP1(),\n      QProfileTesting.newXooP2().setParentKee(QProfileTesting.XOO_P1_KEY));\n    dbSession.commit();\n\n    // rule x1 is activated on parent profile (so inherited by child profile)\n    RuleActivation activation = new RuleActivation(RuleTesting.XOO_X1);\n    activation.setSeverity(Severity.INFO);\n    activation.setParameter(\"max\", \"10\");\n    tester.get(RuleActivator.class).activate(dbSession, activation, QProfileTesting.XOO_P1_KEY);\n    dbSession.commit();\n    dbSession.clearCache();\n    activeRuleIndexer.index();\n\n    // restore backup of parent profile -> update x1 and propagates to child\n    tester.get(QProfileBackuper.class).restore(new StringReader(\n      Resources.toString(getClass().getResource(\"QProfileBackuperMediumTest/restore-parent.xml\"), StandardCharsets.UTF_8)), null);\n\n    // parent profile is updated\n    List<ActiveRuleDoc> activeRules = Lists.newArrayList(tester.get(QProfileLoader.class).findActiveRulesByProfile(QProfileTesting.XOO_P1_KEY));\n    assertThat(activeRules).hasSize(1);\n\n    ActiveRuleDoc activeRuleDoc = activeRules.get(0);\n    assertThat(activeRuleDoc.severity()).isEqualTo(\"BLOCKER\");\n    assertThat(activeRuleDoc.inheritance()).isEqualTo(ActiveRule.Inheritance.NONE);\n    List<ActiveRuleParamDto> params = tester.get(ActiveRuleDao.class).selectParamsByActiveRuleKey(dbSession, activeRuleDoc.key());\n    assertThat(params).hasSize(1);\n    assertThat(params.get(0).getKey()).isEqualTo(\"max\");\n    assertThat(params.get(0).getValue()).isEqualTo(\"7\");\n\n    // child profile is inherited\n    activeRules = Lists.newArrayList(tester.get(QProfileLoader.class).findActiveRulesByProfile(QProfileTesting.XOO_P2_KEY));\n    assertThat(activeRules).hasSize(1);\n    activeRuleDoc = activeRules.get(0);\n    assertThat(activeRuleDoc.severity()).isEqualTo(\"BLOCKER\");\n    assertThat(activeRuleDoc.inheritance()).isEqualTo(ActiveRule.Inheritance.INHERITED);\n    params = tester.get(ActiveRuleDao.class).selectParamsByActiveRuleKey(dbSession, activeRuleDoc.key());\n    assertThat(params).hasSize(1);\n    assertThat(params.get(0).getKey()).isEqualTo(\"max\");\n    assertThat(params.get(0).getValue()).isEqualTo(\"7\");\n  }","commit_id":"b0ae896d7abdfec5648ffd450caae368543a7d05","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Before\n  public void before() {\n    tester.clearDbAndIndexes();\n    db = tester.get(DbClient.class);\n    dbSession = db.openSession(false);\n\n    // create pre-defined rules\n    RuleDto xooRule1 = RuleTesting.newXooX1().setSeverity(\"MINOR\").setLanguage(\"xoo\");\n    RuleDto xooRule2 = RuleTesting.newXooX2().setSeverity(\"MAJOR\").setLanguage(\"xoo\");\n    db.deprecatedRuleDao().insert(dbSession, xooRule1, xooRule2);\n    db.deprecatedRuleDao().insertRuleParam(dbSession, xooRule1, RuleParamDto.createFor(xooRule1)\n      .setName(\"max\").setDefaultValue(\"10\").setType(RuleParamType.INTEGER.type()));\n    dbSession.commit();\n    dbSession.clearCache();\n  }","id":60831,"modified_method":"@Before\n  public void before() {\n    tester.clearDbAndIndexes();\n    db = tester.get(DbClient.class);\n    dbSession = db.openSession(false);\n    ruleIndexer = tester.get(RuleIndexer.class);\n    ruleIndexer.setEnabled(true);\n    activeRuleIndexer = tester.get(ActiveRuleIndexer.class);\n    activeRuleIndexer.setEnabled(true);\n\n    // create pre-defined rules\n    RuleDto xooRule1 = RuleTesting.newXooX1().setSeverity(\"MINOR\").setLanguage(\"xoo\");\n    RuleDto xooRule2 = RuleTesting.newXooX2().setSeverity(\"MAJOR\").setLanguage(\"xoo\");\n    db.ruleDao().insert(dbSession, xooRule1);\n    db.ruleDao().insert(dbSession, xooRule2);\n    db.ruleDao().insertRuleParam(dbSession, xooRule1, RuleParamDto.createFor(xooRule1)\n      .setName(\"max\").setDefaultValue(\"10\").setType(RuleParamType.INTEGER.type()));\n    dbSession.commit();\n    dbSession.clearCache();\n    ruleIndexer.index();\n  }","commit_id":"b0ae896d7abdfec5648ffd450caae368543a7d05","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void backup() throws Exception {\n    RuleKey blahRuleKey = RuleKey.of(\"blah\", \"my-rule\");\n    RuleDto blahRule = RuleTesting.newDto(blahRuleKey).setSeverity(\"INFO\").setLanguage(\"xoo\");\n    db.deprecatedRuleDao().insert(dbSession, blahRule);\n    dbSession.commit();\n    dbSession.clearCache();\n\n    // create profile P1 with rules x2 and x1 activated\n    db.qualityProfileDao().insert(dbSession, QProfileTesting.newXooP1());\n    RuleActivation activation1 = new RuleActivation(RuleTesting.XOO_X2).setSeverity(\"MINOR\");\n    RuleActivation activation2 = new RuleActivation(RuleTesting.XOO_X1);\n    RuleActivation activation3 = new RuleActivation(blahRuleKey);\n    activation2.setSeverity(Severity.BLOCKER);\n    activation2.setParameter(\"max\", \"7\");\n    tester.get(RuleActivator.class).activate(dbSession, activation1, QProfileTesting.XOO_P1_NAME);\n    tester.get(RuleActivator.class).activate(dbSession, activation2, QProfileTesting.XOO_P1_NAME);\n    tester.get(RuleActivator.class).activate(dbSession, activation3, QProfileTesting.XOO_P1_NAME);\n    dbSession.commit();\n    dbSession.clearCache();\n\n    StringWriter output = new StringWriter();\n    tester.get(QProfileBackuper.class).backup(QProfileTesting.XOO_P1_KEY, output);\n\n    XMLUnit.setIgnoreWhitespace(true);\n    XMLUnit.setIgnoreComments(true);\n    Diff diff = XMLUnit.compareXML(output.toString(),\n      Resources.toString(getClass().getResource(\"QProfileBackuperMediumTest/expected-backup.xml\"), StandardCharsets.UTF_8));\n\n    assertThat(diff.identical()).as(diff.toString()).isTrue();\n  }","id":60832,"modified_method":"@Test\n  public void backup() throws Exception {\n    RuleKey blahRuleKey = RuleKey.of(\"blah\", \"my-rule\");\n    RuleDto blahRule = RuleTesting.newDto(blahRuleKey).setSeverity(\"INFO\").setLanguage(\"xoo\");\n    db.ruleDao().insert(dbSession, blahRule);\n    dbSession.commit();\n    dbSession.clearCache();\n    ruleIndexer.index();\n\n    // create profile P1 with rules x2 and x1 activated\n    db.qualityProfileDao().insert(dbSession, QProfileTesting.newXooP1());\n    RuleActivation activation1 = new RuleActivation(RuleTesting.XOO_X2).setSeverity(\"MINOR\");\n    RuleActivation activation2 = new RuleActivation(RuleTesting.XOO_X1);\n    RuleActivation activation3 = new RuleActivation(blahRuleKey);\n    activation2.setSeverity(Severity.BLOCKER);\n    activation2.setParameter(\"max\", \"7\");\n    tester.get(RuleActivator.class).activate(dbSession, activation1, QProfileTesting.XOO_P1_NAME);\n    tester.get(RuleActivator.class).activate(dbSession, activation2, QProfileTesting.XOO_P1_NAME);\n    tester.get(RuleActivator.class).activate(dbSession, activation3, QProfileTesting.XOO_P1_NAME);\n    dbSession.commit();\n    dbSession.clearCache();\n    activeRuleIndexer.index();\n\n    StringWriter output = new StringWriter();\n    tester.get(QProfileBackuper.class).backup(QProfileTesting.XOO_P1_KEY, output);\n\n    XMLUnit.setIgnoreWhitespace(true);\n    XMLUnit.setIgnoreComments(true);\n    Diff diff = XMLUnit.compareXML(output.toString(),\n      Resources.toString(getClass().getResource(\"QProfileBackuperMediumTest/expected-backup.xml\"), StandardCharsets.UTF_8));\n\n    assertThat(diff.identical()).as(diff.toString()).isTrue();\n  }","commit_id":"b0ae896d7abdfec5648ffd450caae368543a7d05","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void restore_profile_with_zero_rules() throws Exception {\n    tester.get(QProfileBackuper.class).restore(new StringReader(\n      Resources.toString(getClass().getResource(\"QProfileBackuperMediumTest/empty.xml\"), StandardCharsets.UTF_8)),\n      null);\n\n    dbSession.clearCache();\n    assertThat(db.deprecatedActiveRuleDao().selectAll(dbSession)).hasSize(0);\n    List<QualityProfileDto> profiles = db.qualityProfileDao().selectAll(dbSession);\n    assertThat(profiles).hasSize(1);\n    assertThat(profiles.get(0).getName()).isEqualTo(\"P1\");\n  }","id":60833,"modified_method":"@Test\n  public void restore_profile_with_zero_rules() throws Exception {\n    tester.get(QProfileBackuper.class).restore(new StringReader(\n      Resources.toString(getClass().getResource(\"QProfileBackuperMediumTest/empty.xml\"), StandardCharsets.UTF_8)),\n      null);\n\n    dbSession.clearCache();\n    assertThat(db.activeRuleDao().selectAll(dbSession)).hasSize(0);\n    List<QualityProfileDto> profiles = db.qualityProfileDao().selectAll(dbSession);\n    assertThat(profiles).hasSize(1);\n    assertThat(profiles.get(0).getName()).isEqualTo(\"P1\");\n  }","commit_id":"b0ae896d7abdfec5648ffd450caae368543a7d05","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void restore_child_profile() throws Exception {\n    // define two parent/child profiles\n    db.qualityProfileDao().insert(dbSession,\n      QProfileTesting.newXooP1(),\n      QProfileTesting.newXooP2().setParentKee(QProfileTesting.XOO_P1_KEY));\n    dbSession.commit();\n\n    // rule x1 is activated on parent profile (so inherited by child profile)\n    RuleActivation activation = new RuleActivation(RuleTesting.XOO_X1);\n    activation.setSeverity(Severity.INFO);\n    activation.setParameter(\"max\", \"10\");\n    tester.get(RuleActivator.class).activate(dbSession, activation, QProfileTesting.XOO_P1_KEY);\n    dbSession.commit();\n    dbSession.clearCache();\n\n    // restore backup of child profile -> overrides x1\n    tester.get(QProfileBackuper.class).restore(new StringReader(\n      Resources.toString(getClass().getResource(\"QProfileBackuperMediumTest/restore-child.xml\"), StandardCharsets.UTF_8)), null);\n\n    // parent profile is unchanged\n    List<ActiveRuleDoc> activeRules = Lists.newArrayList(tester.get(QProfileLoader.class).findActiveRulesByProfile(QProfileTesting.XOO_P1_KEY));\n    assertThat(activeRules).hasSize(1);\n    assertThat(activeRules.get(0).severity()).isEqualTo(\"INFO\");\n    assertThat(activeRules.get(0).inheritance()).isEqualTo(ActiveRule.Inheritance.NONE);\n    assertThat(activeRules.get(0).params().get(\"max\")).isEqualTo(\"10\");\n\n    // child profile overrides parent\n    activeRules = Lists.newArrayList(tester.get(QProfileLoader.class).findActiveRulesByProfile(QProfileTesting.XOO_P2_KEY));\n    assertThat(activeRules).hasSize(1);\n    assertThat(activeRules.get(0).severity()).isEqualTo(\"BLOCKER\");\n    assertThat(activeRules.get(0).inheritance()).isEqualTo(ActiveRule.Inheritance.OVERRIDES);\n    assertThat(activeRules.get(0).params().get(\"max\")).isEqualTo(\"7\");\n  }","id":60834,"modified_method":"@Test\n  public void restore_child_profile() throws Exception {\n    // define two parent/child profiles\n    db.qualityProfileDao().insert(dbSession,\n      QProfileTesting.newXooP1(),\n      QProfileTesting.newXooP2().setParentKee(QProfileTesting.XOO_P1_KEY));\n    dbSession.commit();\n\n    // rule x1 is activated on parent profile (so inherited by child profile)\n    RuleActivation activation = new RuleActivation(RuleTesting.XOO_X1);\n    activation.setSeverity(Severity.INFO);\n    activation.setParameter(\"max\", \"10\");\n    tester.get(RuleActivator.class).activate(dbSession, activation, QProfileTesting.XOO_P1_KEY);\n    dbSession.commit();\n    dbSession.clearCache();\n    activeRuleIndexer.index();\n\n    // restore backup of child profile -> overrides x1\n    tester.get(QProfileBackuper.class).restore(new StringReader(\n      Resources.toString(getClass().getResource(\"QProfileBackuperMediumTest/restore-child.xml\"), StandardCharsets.UTF_8)), null);\n\n    // parent profile is unchanged\n    List<ActiveRuleDoc> activeRules = Lists.newArrayList(tester.get(QProfileLoader.class).findActiveRulesByProfile(QProfileTesting.XOO_P1_KEY));\n    assertThat(activeRules).hasSize(1);\n    ActiveRuleDoc activeRuleDoc = activeRules.get(0);\n    assertThat(activeRuleDoc.severity()).isEqualTo(\"INFO\");\n    assertThat(activeRuleDoc.inheritance()).isEqualTo(ActiveRule.Inheritance.NONE);\n    List<ActiveRuleParamDto> params = tester.get(ActiveRuleDao.class).selectParamsByActiveRuleKey(dbSession, activeRuleDoc.key());\n    assertThat(params).hasSize(1);\n    assertThat(params.get(0).getKey()).isEqualTo(\"max\");\n    assertThat(params.get(0).getValue()).isEqualTo(\"10\");\n\n    // child profile overrides parent\n    activeRules = Lists.newArrayList(tester.get(QProfileLoader.class).findActiveRulesByProfile(QProfileTesting.XOO_P2_KEY));\n    assertThat(activeRules).hasSize(1);\n    activeRuleDoc = activeRules.get(0);\n    assertThat(activeRuleDoc.severity()).isEqualTo(\"BLOCKER\");\n    assertThat(activeRuleDoc.inheritance()).isEqualTo(ActiveRule.Inheritance.OVERRIDES);\n    params = tester.get(ActiveRuleDao.class).selectParamsByActiveRuleKey(dbSession, activeRuleDoc.key());\n    assertThat(params).hasSize(1);\n    assertThat(params.get(0).getKey()).isEqualTo(\"max\");\n    assertThat(params.get(0).getValue()).isEqualTo(\"7\");\n  }","commit_id":"b0ae896d7abdfec5648ffd450caae368543a7d05","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"StringBuilder appendSqlCondition(StringBuilder sql) {\n    sql.append(\" pm.metric_id=\");\n    sql.append(metric.getId());\n    sql.append(\" AND \").append(valueColumn()).append(operator.getSql()).append(value);\n    return sql;\n  }","id":60835,"modified_method":"StringBuilder appendSqlCondition(StringBuilder sql, int conditionIndex) {\n    sql.append(\" pmcond\").append(conditionIndex).append(\".metric_id=\");\n    sql.append(metric.getId());\n    sql.append(\" AND \");\n    appendSqlColumn(sql, conditionIndex);\n    sql.append(operator.getSql()).append(value);\n    return sql;\n  }","commit_id":"189a12a09eb4fd34b632fb2582eb479e15a08125","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void variation_condition() {\n    Metric ncloc = new Metric.Builder(\"ncloc\", \"NCLOC\", Metric.ValueType.INT).create();\n    ncloc.setId(123);\n    MeasureFilterCondition condition = new MeasureFilterCondition(ncloc, MeasureFilterCondition.Operator.LESS_OR_EQUALS, 10.0);\n    condition.setPeriod(3);\n\n    assertThat(condition.metric()).isEqualTo(ncloc);\n    assertThat(condition.operator()).isEqualTo(MeasureFilterCondition.Operator.LESS_OR_EQUALS);\n    assertThat(condition.period()).isEqualTo(3);\n    assertThat(condition.value()).isEqualTo(10.0);\n    assertThat(condition.valueColumn()).isEqualTo(\"pm.variation_value_3\");\n    assertThat(condition.toString()).isNotEmpty();\n    assertThat(condition.appendSqlCondition(new StringBuilder()).toString()).isEqualTo(\" pm.metric_id=123 AND pm.variation_value_3<=10.0\");\n  }","id":60836,"modified_method":"@Test\n  public void variation_condition() {\n    Metric ncloc = new Metric.Builder(\"ncloc\", \"NCLOC\", Metric.ValueType.INT).create();\n    ncloc.setId(123);\n    MeasureFilterCondition condition = new MeasureFilterCondition(ncloc, MeasureFilterCondition.Operator.LESS_OR_EQUALS, 10.0);\n    condition.setPeriod(3);\n\n    assertThat(condition.metric()).isEqualTo(ncloc);\n    assertThat(condition.operator()).isEqualTo(MeasureFilterCondition.Operator.LESS_OR_EQUALS);\n    assertThat(condition.period()).isEqualTo(3);\n    assertThat(condition.value()).isEqualTo(10.0);\n    assertThat(condition.appendSqlColumn(new StringBuilder(), 2).toString()).isEqualTo(\"pmcond2.variation_value_3\");\n    assertThat(condition.toString()).isNotEmpty();\n    assertThat(condition.appendSqlCondition(new StringBuilder(), 2).toString()).isEqualTo(\" pmcond2.metric_id=123 AND pmcond2.variation_value_3<=10.0\");\n  }","commit_id":"189a12a09eb4fd34b632fb2582eb479e15a08125","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void value_condition() {\n    Metric ncloc = new Metric.Builder(\"ncloc\", \"NCLOC\", Metric.ValueType.INT).create();\n    ncloc.setId(123);\n    MeasureFilterCondition condition = new MeasureFilterCondition(ncloc, MeasureFilterCondition.Operator.GREATER, 10.0);\n\n    assertThat(condition.metric()).isEqualTo(ncloc);\n    assertThat(condition.operator()).isEqualTo(MeasureFilterCondition.Operator.GREATER);\n    assertThat(condition.period()).isNull();\n    assertThat(condition.value()).isEqualTo(10.0);\n    assertThat(condition.valueColumn()).isEqualTo(\"pm.value\");\n    assertThat(condition.toString()).isNotEmpty();\n    assertThat(condition.appendSqlCondition(new StringBuilder()).toString()).isEqualTo(\" pm.metric_id=123 AND pm.value>10.0\");\n  }","id":60837,"modified_method":"@Test\n  public void value_condition() {\n    Metric ncloc = new Metric.Builder(\"ncloc\", \"NCLOC\", Metric.ValueType.INT).create();\n    ncloc.setId(123);\n    MeasureFilterCondition condition = new MeasureFilterCondition(ncloc, MeasureFilterCondition.Operator.GREATER, 10.0);\n\n    assertThat(condition.metric()).isEqualTo(ncloc);\n    assertThat(condition.operator()).isEqualTo(MeasureFilterCondition.Operator.GREATER);\n    assertThat(condition.period()).isNull();\n    assertThat(condition.value()).isEqualTo(10.0);\n    assertThat(condition.appendSqlColumn(new StringBuilder(), 1).toString()).isEqualTo(\"pmcond1.value\");\n    assertThat(condition.toString()).isNotEmpty();\n    assertThat(condition.appendSqlCondition(new StringBuilder(), 1).toString()).isEqualTo(\" pmcond1.metric_id=123 AND pmcond1.value>10.0\");\n  }","commit_id":"189a12a09eb4fd34b632fb2582eb479e15a08125","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@VisibleForTesting\n  MeasureFilterResult execute(Map<String, Object> filterMap, @Nullable Long userId, Logger logger) {\n    long start = System.currentTimeMillis();\n    MeasureFilterResult result = new MeasureFilterResult();\n    MeasureFilterContext context = new MeasureFilterContext();\n    context.setUserId(userId);\n    context.setData(String.format(\"{%s}\", Joiner.on('|').withKeyValueSeparator(\"=\").join(filterMap)));\n    try {\n      MeasureFilter filter = factory.create(filterMap);\n      List<MeasureFilterRow> rows = executor.execute(filter, context);\n      if (rows.size() <= MAX_ROWS) {\n        result.setRows(rows);\n      } else {\n        result.setError(MeasureFilterResult.Error.TOO_MANY_RESULTS);\n      }\n      result.setDurationInMs(System.currentTimeMillis() - start);\n      log(context, result, logger);\n\n    } catch (Exception e) {\n      result.setError(MeasureFilterResult.Error.UNKNOWN);\n      logger.error(\"Fail to execute measure filter: \" + context, e);\n    }\n    return result;\n  }","id":60838,"modified_method":"@VisibleForTesting\n  MeasureFilterResult execute(Map<String, Object> filterMap, @Nullable Long userId, Logger logger) {\n    long start = System.currentTimeMillis();\n    MeasureFilterResult result = new MeasureFilterResult();\n    MeasureFilterContext context = new MeasureFilterContext();\n    context.setUserId(userId);\n    context.setData(String.format(\"{%s}\", Joiner.on('|').withKeyValueSeparator(\"=\").join(filterMap)));\n    try {\n      MeasureFilter filter = factory.create(filterMap);\n      List<MeasureFilterRow> rows = executor.execute(filter, context);\n      result.setRows(rows);\n      result.setDurationInMs(System.currentTimeMillis() - start);\n      log(context, result, logger);\n\n    } catch (Exception e) {\n      result.setError(MeasureFilterResult.Error.UNKNOWN);\n      logger.error(\"Fail to execute measure filter: \" + context, e);\n    }\n    return result;\n  }","commit_id":"189a12a09eb4fd34b632fb2582eb479e15a08125","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void sort_on_measure_variation() {\n    MeasureFilterFactory factory = new MeasureFilterFactory(newMetricFinder());\n    Map<String, Object> props = ImmutableMap.<String, Object>of(\"sort\", \"metric:ncloc:3\");\n    MeasureFilter filter = factory.create(props);\n\n    assertThat(filter.sort().column()).isEqualTo(\"pm.variation_value_3\");\n    assertThat(filter.sort().metric().getKey()).isEqualTo(\"ncloc\");\n    assertThat(filter.sort().period()).isEqualTo(3);\n  }","id":60839,"modified_method":"@Test\n  public void sort_on_measure_variation() {\n    MeasureFilterFactory factory = new MeasureFilterFactory(newMetricFinder());\n    Map<String, Object> props = ImmutableMap.<String, Object>of(\"sort\", \"metric:ncloc:3\");\n    MeasureFilter filter = factory.create(props);\n\n    assertThat(filter.sort().column()).isEqualTo(\"pmsort.variation_value_3\");\n    assertThat(filter.sort().metric().getKey()).isEqualTo(\"ncloc\");\n    assertThat(filter.sort().period()).isEqualTo(3);\n  }","commit_id":"189a12a09eb4fd34b632fb2582eb479e15a08125","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void sort_on_measure_value() {\n    MeasureFilterFactory factory = new MeasureFilterFactory(newMetricFinder());\n    Map<String, Object> props = ImmutableMap.<String, Object>of(\"sort\", \"metric:ncloc\");\n    MeasureFilter filter = factory.create(props);\n\n    assertThat(filter.sort().column()).isEqualTo(\"pm.value\");\n    assertThat(filter.sort().metric().getKey()).isEqualTo(\"ncloc\");\n    assertThat(filter.sort().period()).isNull();\n  }","id":60840,"modified_method":"@Test\n  public void sort_on_measure_value() {\n    MeasureFilterFactory factory = new MeasureFilterFactory(newMetricFinder());\n    Map<String, Object> props = ImmutableMap.<String, Object>of(\"sort\", \"metric:ncloc\");\n    MeasureFilter filter = factory.create(props);\n\n    assertThat(filter.sort().column()).isEqualTo(\"pmsort.value\");\n    assertThat(filter.sort().metric().getKey()).isEqualTo(\"ncloc\");\n    assertThat(filter.sort().period()).isNull();\n  }","commit_id":"189a12a09eb4fd34b632fb2582eb479e15a08125","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"MeasureFilterRow setSortText(String s) {\n    this.sortText = s;\n    return this;\n  }","id":60841,"modified_method":"void setSortText(String s) {\n    this.sortText = StringUtils.defaultString(s);\n  }","commit_id":"189a12a09eb4fd34b632fb2582eb479e15a08125","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"String column() {\n    // only numeric metrics can be sorted by database, else results are sorted programmatically.\n    String column;\n    switch (field) {\n      case KEY:\n        column = \"p.kee\";\n        break;\n      case NAME:\n        column = \"p.long_name\";\n        break;\n      case SHORT_NAME:\n        column = \"p.name\";\n        break;\n      case DESCRIPTION:\n        column = \"p.description\";\n        break;\n      case VERSION:\n        column = \"s.version\";\n        break;\n      case LANGUAGE:\n        column = \"p.language\";\n        break;\n      case DATE:\n        column = \"s.created_at\";\n        break;\n      case METRIC:\n        if (metric.isNumericType()) {\n          column = (period != null ? \"pm.variation_value_\" + period : \"pm.value\");\n        } else {\n          column = \"pm.text_value\";\n        }\n        break;\n      default:\n        throw new IllegalArgumentException(\"Unsupported sorting: \" + field);\n    }\n    return column;\n  }","id":60842,"modified_method":"String column() {\n    // only numeric metrics can be sorted by database, else results are sorted programmatically.\n    String column;\n    switch (field) {\n      case KEY:\n        column = \"p.kee\";\n        break;\n      case NAME:\n        column = \"p.long_name\";\n        break;\n      case SHORT_NAME:\n        column = \"p.name\";\n        break;\n      case DESCRIPTION:\n        column = \"p.description\";\n        break;\n      case VERSION:\n        column = \"s.version\";\n        break;\n      case LANGUAGE:\n        column = \"p.language\";\n        break;\n      case DATE:\n        column = \"s.created_at\";\n        break;\n      case METRIC:\n        if (metric.isNumericType()) {\n          column = (period != null ? \"pmsort.variation_value_\" + period : \"pmsort.value\");\n        } else {\n          column = \"pmsort.text_value\";\n        }\n        break;\n      default:\n        throw new IllegalArgumentException(\"Unsupported sorting: \" + field);\n    }\n    return column;\n  }","commit_id":"189a12a09eb4fd34b632fb2582eb479e15a08125","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"String sql() {\n    return sql.toString();\n  }","id":60843,"modified_method":"String sql() {\n    return sql;\n  }","commit_id":"189a12a09eb4fd34b632fb2582eb479e15a08125","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void appendResourceConditions() {\n    sql.append(\" s.status='P' AND s.islast=\").append(database.getDialect().getTrueSqlValue());\n    if (context.getBaseSnapshot() == null) {\n      sql.append(\" AND p.copy_resource_id IS NULL \");\n    }\n    if (!filter.getResourceQualifiers().isEmpty()) {\n      sql.append(\" AND s.qualifier IN \");\n      appendInStatement(filter.getResourceQualifiers(), sql);\n    }\n    if (!filter.getResourceScopes().isEmpty()) {\n      sql.append(\" AND s.scope IN \");\n      appendInStatement(filter.getResourceScopes(), sql);\n    }\n    if (!filter.getResourceLanguages().isEmpty()) {\n      sql.append(\" AND p.language IN \");\n      appendInStatement(filter.getResourceLanguages(), sql);\n    }\n    appendDateConditions();\n    appendFavouritesCondition();\n    appendResourceNameCondition();\n    appendResourceKeyCondition();\n    appendResourceBaseCondition();\n  }","id":60844,"modified_method":"private void appendResourceKeyCondition(StringBuilder sb) {\n    if (StringUtils.isNotBlank(filter.getResourceKeyRegexp())) {\n      sb.append(\" AND UPPER(p.kee) LIKE '\");\n      // limitation : special characters _ and % are not escaped\n      String regexp = StringEscapeUtils.escapeSql(filter.getResourceKeyRegexp());\n      regexp = StringUtils.replaceChars(regexp, '*', '%');\n      regexp = StringUtils.replaceChars(regexp, '?', '_');\n      sb.append(StringUtils.upperCase(regexp)).append(\"'\");\n    }\n  }","commit_id":"189a12a09eb4fd34b632fb2582eb479e15a08125","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"MeasureFilterSql(Database database, MeasureFilter filter, MeasureFilterContext context) {\n    this.database = database;\n    this.filter = filter;\n    this.context = context;\n    init();\n  }","id":60845,"modified_method":"MeasureFilterSql(Database database, MeasureFilter filter, MeasureFilterContext context) {\n    this.database = database;\n    this.filter = filter;\n    this.context = context;\n    this.sql = generateSql();\n  }","commit_id":"189a12a09eb4fd34b632fb2582eb479e15a08125","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"List<MeasureFilterRow> process(ResultSet rs) throws SQLException {\n    List<MeasureFilterRow> rows = Lists.newArrayList();\n    boolean sortTextValues = !filter.sort().isSortedByDatabase();\n    while (rs.next()) {\n      MeasureFilterRow row = new MeasureFilterRow(rs.getLong(1), rs.getLong(2), rs.getLong(3));\n      if (sortTextValues) {\n        row.setSortText(rs.getString(4));\n      }\n      rows.add(row);\n    }\n    if (sortTextValues) {\n      // database does not manage case-insensitive text sorting. It must be done programmatically\n      Function<MeasureFilterRow, String> function = new Function<MeasureFilterRow, String>() {\n        public String apply(@Nullable MeasureFilterRow row) {\n          return (row != null ? StringUtils.defaultString(row.getSortText()) : \"\");\n        }\n      };\n      Ordering<MeasureFilterRow> ordering = Ordering.from(String.CASE_INSENSITIVE_ORDER).onResultOf(function).nullsFirst();\n      if (!filter.sort().isAsc()) {\n        ordering = ordering.reverse();\n      }\n      rows = ordering.sortedCopy(rows);\n    }\n    return rows;\n  }","id":60846,"modified_method":"List<MeasureFilterRow> process(ResultSet rs) throws SQLException {\n    List<MeasureFilterRow> rows = Lists.newArrayList();\n    RowProcessor rowProcessor;\n    if (filter.sort().isOnNumericMeasure()) {\n      rowProcessor = new NumericSortRowProcessor();\n    } else if (filter.sort().isOnDate()) {\n      rowProcessor = new DateSortRowProcessor();\n    } else {\n      rowProcessor = new TextSortRowProcessor();\n    }\n\n    while (rs.next()) {\n      rows.add(rowProcessor.fetch(rs));\n    }\n\n    return rowProcessor.sort(rows, filter.sort().isAsc());\n  }","commit_id":"189a12a09eb4fd34b632fb2582eb479e15a08125","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void appendFavouritesCondition() {\n    if (filter.isOnFavourites()) {\n      sql.append(\" AND props.prop_key='favourite' AND props.resource_id IS NOT NULL AND props.user_id=\");\n      sql.append(context.getUserId());\n      sql.append(\" \");\n    }\n  }","id":60847,"modified_method":"private void appendFavouritesCondition(StringBuilder sb) {\n    if (filter.isOnFavourites()) {\n      sb.append(\" AND props.prop_key='favourite' AND props.resource_id IS NOT NULL AND props.user_id=\");\n      sb.append(context.getUserId());\n      sb.append(\" \");\n    }\n  }","commit_id":"189a12a09eb4fd34b632fb2582eb479e15a08125","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void appendSortBlock() {\n    sql.append(\" SELECT s.id, s.project_id AS rid, s.root_project_id AS rootid, \").append(filter.sort().column()).append(\" AS sortval \");\n    for (int index = 0; index < filter.getMeasureConditions().size(); index++) {\n      MeasureFilterCondition condition = filter.getMeasureConditions().get(index);\n      sql.append(\", \").append(nullSelect(condition.metric())).append(\" AS crit_\").append(index);\n    }\n    sql.append(\" FROM snapshots s INNER JOIN projects p ON s.project_id=p.id \");\n    if (filter.isOnFavourites()) {\n      sql.append(\" INNER JOIN properties props ON props.resource_id=s.project_id \");\n    }\n    if (filter.sort().onMeasures()) {\n      sql.append(\" LEFT OUTER JOIN project_measures pm ON s.id=pm.snapshot_id AND pm.metric_id=\");\n      sql.append(filter.sort().metric().getId());\n      sql.append(\" AND pm.rule_id IS NULL AND pm.rule_priority IS NULL AND pm.characteristic_id IS NULL AND pm.person_id IS NULL \");\n    }\n    sql.append(\" WHERE \");\n    appendResourceConditions();\n  }","id":60848,"modified_method":"private void appendResourceConditions(StringBuilder sb) {\n    sb.append(\" s.status='P' AND s.islast=\").append(database.getDialect().getTrueSqlValue());\n    if (context.getBaseSnapshot() == null) {\n      sb.append(\" AND p.copy_resource_id IS NULL \");\n    }\n    if (!filter.getResourceQualifiers().isEmpty()) {\n      sb.append(\" AND s.qualifier IN \");\n      appendInStatement(filter.getResourceQualifiers(), sb);\n    }\n    if (!filter.getResourceScopes().isEmpty()) {\n      sb.append(\" AND s.scope IN \");\n      appendInStatement(filter.getResourceScopes(), sb);\n    }\n    if (!filter.getResourceLanguages().isEmpty()) {\n      sb.append(\" AND p.language IN \");\n      appendInStatement(filter.getResourceLanguages(), sb);\n    }\n    appendDateConditions(sb);\n    appendFavouritesCondition(sb);\n    appendResourceNameCondition(sb);\n    appendResourceKeyCondition(sb);\n    appendResourceBaseCondition(sb);\n  }","commit_id":"189a12a09eb4fd34b632fb2582eb479e15a08125","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"List<MeasureFilterRow> execute(Connection connection) throws SQLException {\n    PreparedStatement statement = connection.prepareStatement(sql.toString());\n    ResultSet rs = null;\n    try {\n      for (int index = 0; index < dateParameters.size(); index++) {\n        statement.setDate(index + 1, dateParameters.get(index));\n      }\n      rs = statement.executeQuery();\n      return process(rs);\n\n    } finally {\n      DatabaseUtils.closeQuietly(rs);\n      DatabaseUtils.closeQuietly(statement);\n    }\n  }","id":60849,"modified_method":"List<MeasureFilterRow> execute(Connection connection) throws SQLException {\n    PreparedStatement statement = connection.prepareStatement(sql);\n    statement.setFetchSize(FETCH_SIZE);\n    ResultSet rs = null;\n    try {\n      for (int index = 0; index < dateParameters.size(); index++) {\n        statement.setDate(index + 1, dateParameters.get(index));\n      }\n      rs = statement.executeQuery();\n      return process(rs);\n\n    } finally {\n      DatabaseUtils.closeQuietly(rs);\n      DatabaseUtils.closeQuietly(statement);\n    }\n  }","commit_id":"189a12a09eb4fd34b632fb2582eb479e15a08125","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void appendConditionBlock(int conditionIndex, MeasureFilterCondition condition) {\n    sql.append(\" SELECT s.id, s.project_id AS rid, s.root_project_id AS rootid, null AS sortval \");\n    for (int j = 0; j < filter.getMeasureConditions().size(); j++) {\n      sql.append(\", \");\n      if (j == conditionIndex) {\n        sql.append(condition.valueColumn());\n      } else {\n        sql.append(nullSelect(filter.getMeasureConditions().get(j).metric()));\n      }\n      sql.append(\" AS crit_\").append(j);\n    }\n    sql.append(\" FROM snapshots s INNER JOIN projects p ON s.project_id=p.id INNER JOIN project_measures pm ON s.id=pm.snapshot_id \");\n    if (filter.isOnFavourites()) {\n      sql.append(\" INNER JOIN properties props ON props.resource_id=s.project_id \");\n    }\n    sql.append(\" WHERE \");\n    appendResourceConditions();\n    sql.append(\" AND pm.rule_id IS NULL AND pm.rule_priority IS NULL AND pm.characteristic_id IS NULL AND pm.person_id IS NULL AND \");\n    condition.appendSqlCondition(sql);\n  }","id":60850,"modified_method":"private void appendResourceBaseCondition(StringBuilder sb) {\n    SnapshotDto baseSnapshot = context.getBaseSnapshot();\n    if (baseSnapshot != null) {\n      if (filter.isOnBaseResourceChildren()) {\n        sb.append(\" AND s.parent_snapshot_id=\").append(baseSnapshot.getId());\n      } else {\n        Long rootSnapshotId = (baseSnapshot.getRootId() != null ? baseSnapshot.getRootId() : baseSnapshot.getId());\n        sb.append(\" AND s.root_snapshot_id=\").append(rootSnapshotId);\n        sb.append(\" AND s.path LIKE '\").append(StringUtils.defaultString(baseSnapshot.getPath())).append(baseSnapshot.getId()).append(\".%'\");\n      }\n    }\n  }","commit_id":"189a12a09eb4fd34b632fb2582eb479e15a08125","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void appendDateConditions() {\n    if (filter.getFromDate() != null) {\n      sql.append(\" AND s.created_at >= ? \");\n      dateParameters.add(new Date(filter.getFromDate().getTime()));\n    }\n    if (filter.getToDate() != null) {\n      sql.append(\" AND s.created_at <= ? \");\n      dateParameters.add(new Date(filter.getToDate().getTime()));\n    }\n  }","id":60851,"modified_method":"private void appendResourceNameCondition(StringBuilder sb) {\n    if (StringUtils.isNotBlank(filter.getResourceName())) {\n      sb.append(\" AND s.project_id IN (SELECT rindex.resource_id FROM resource_index rindex WHERE rindex.kee like '\");\n      sb.append(StringEscapeUtils.escapeSql(StringUtils.lowerCase(filter.getResourceName())));\n      sb.append(\"%'\");\n      if (!filter.getResourceQualifiers().isEmpty()) {\n        sb.append(\" AND rindex.qualifier IN \");\n        appendInStatement(filter.getResourceQualifiers(), sb);\n      }\n      sb.append(\") \");\n    }\n  }","commit_id":"189a12a09eb4fd34b632fb2582eb479e15a08125","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void render(Component comp, Writer out) throws IOException {\r\n\t\tfinal SmartWriter wh = new SmartWriter(out);\r\n\t\tfinal Radio self = (Radio)comp;\r\n\t\tfinal String uuid = self.getUuid();\r\n\t\twh.write(\"<span id=\\\"\").write(uuid).write(\"\\\" z.type=\\\"zul.widget.Radio\\\" \");\r\n\t\twh.write(self.getOuterAttrs()).write(\">\").write(\"<input type=\\\"radio\\\" id=\\\"\"+uuid+\"!real\\\"\");\r\n\t\twh.write(self.getInnerAttrs()).write(\"/>\");\r\n\t\twh.write(\"<label for=\\\"\"+uuid+\"!real\\\"\").write(self.getLabelAttrs()).write(\">\");\r\n\t\twh.write(self.getImgTag()).write(self.getLabel()).writeln(\"<\/label>\");\r\n\t\tif(self.getRadiogroup() != null\r\n\t\t&& self.getRadiogroup().getOrient().equals(\"vertical\")) {\r\n\t\t\twh.write(\"<br/>\");\r\n\t\t}\r\n\t\twh.writeln(\"<\/span>\");\r\n\t}","id":60852,"modified_method":"public void render(Component comp, Writer out) throws IOException {\r\n\t\tfinal SmartWriter wh = new SmartWriter(out);\r\n\t\tfinal Radio self = (Radio)comp;\r\n\t\tfinal String uuid = self.getUuid();\r\n\t\twh.write(\"<span id=\\\"\").write(uuid).write(\"\\\" z.type=\\\"zul.widget.Radio\\\"\")\r\n\t\t\t.write(self.getOuterAttrs()).write(\">\").write(\"<input type=\\\"radio\\\" id=\\\"\")\r\n\t\t\t.write(uuid).write(\"!real\\\"\").write(self.getInnerAttrs()).write(\"/>\");\r\n\t\twh.write(\"<label for=\\\"\").write(uuid).write(\"!real\\\"\")\r\n\t\t\t.write(self.getLabelAttrs()).write(\">\")\r\n\t\t\t.write(self.getImgTag()).write(self.getLabel()).write(\"<\/label>\");\r\n\r\n\t\tif(self.getRadiogroup() != null\r\n\t\t&& self.getRadiogroup().getOrient().equals(\"vertical\"))\r\n\t\t\twh.writeln(\"<br/>\");\r\n\r\n\t\twh.write(\"<\/span>\");\r\n\t}","commit_id":"dee006ae4edeff29b38f201c76a0a489ed794ef6","url":"https://github.com/zkoss/zk"},{"original_method":"public void render(Component comp, Writer out) throws IOException {\r\n\t\tfinal Tab self = (Tab) comp;\r\n\t\tfinal Tabbox tabbox = self.getTabbox();\r\n\t\tfinal SmartWriter wh = new SmartWriter(out);\r\n\t\tfinal Execution exec = Executions.getCurrent();\r\n\t\tfinal String tscls = tabbox.getTabSclass() + '-';\r\n\t\tfinal String suffix = self.isSelected() ? \"-sel\" : \"-uns\";\r\n\r\n\t\twh.write(\"<tr id=\\\"\").write(self.getUuid()).write(\"\\\" z.type=\\\"Tab\\\"\")\r\n\t\t\t.write(self.getOuterAttrs()).write(\" z.sel=\\\"\").write(self.isSelected())\r\n\t\t\t.write(\"\\\" z.box=\\\"\").write(tabbox.getUuid()).write(\"\\\" z.panel=\\\"\")\r\n\t\t\t.write(self.getLinkedPanel().getUuid()).writeln(\"\\\">\");\r\n\r\n\t\twh.write(\"<td align=\\\"right\\\"\").writeAttr(\"width\", self.getWidth())\r\n\t\t\t.writeln(\"><table border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\" width=\\\"100%\\\">\")\r\n\t\t\t.write(\"<tr><td class=\\\"\").write(tscls).write(\"tl\").write(suffix).writeln(\"\\\"><\/td>\")\r\n\t\t\t.write(\"<td colspan=\\\"3\\\" class=\\\"\").write(tscls).write(\"tm\").write(suffix).writeln(\"\\\"><\/td>\")\r\n\t\t\t.write(\"<td class=\\\"\").write(tscls).write(\"tr\").write(suffix).writeln(\"\\\"><\/td>\")\r\n\t\t\t.write(\"<\/tr>\");\r\n\r\n\t\twh.write(\"<tr height=\\\"22\\\">\")\r\n\t\t\t.write(\"<td class=\\\"\").write(tscls).write(\"ml\").write(suffix).writeln(\"\\\"><\/td>\")\r\n\t\t\t.write(\"<td width=\\\"3\\\" class=\\\"\").write(tscls).write(\"mm\").write(suffix).writeln(\"\\\"><\/td>\")\r\n\t\t\t.write(\"<td align=\\\"center\\\" class=\\\"\").write(tscls).write(\"mm\").write(suffix)\r\n\t\t\t.write(\"\\\" id=\\\"\").write(self.getUuid()).write(\"!real\\\"\").write(self.getInnerAttrs())\r\n\t\t\t.write(\"><a href=\\\"javascript:;\\\" id=\\\"\").write(self.getUuid()).write(\"!a\\\">\");\r\n\t\t\twh.write(self.getImgTag());\r\n\t\t\tnew Out(self.getLabel()).render(out);\r\n\t\t\twh.writeln( \"<\/a><\/td>\");\t\t\r\n\r\n\t\t\twh.write(\"<td width=\\\"3\\\" class=\\\"\").write(tscls).write(\"mm\").write(suffix).writeln(\"\\\"><\/td>\")\t\r\n\t\t\t\t.write(\"<td class=\\\"\").write(tscls).write(\"mr\").write(suffix).writeln(\"\\\"><\/td><\/tr>\");\t\t\r\n\t\t\r\n\t\tif(self.isClosable()){\r\n\t\t\twh.writeln(\"<tr height=\\\"8\\\">\")\r\n\t\t\t\t.write(\"<td class=\\\"\").write(tscls).write(\"ml\").write(suffix).writeln(\"\\\"><\/td>\")\r\n\t\t\t\t.write(\"<td width=\\\"3\\\" class=\\\"\").write(tscls).write(\"mm\").write(suffix).writeln(\"\\\"><\/td>\")\r\n\t\t\t\t.write(\"<td align=\\\"center\\\" valign=\\\"buttom\\\" class=\\\"\").write(tscls).write(\"mm\").write(suffix)\r\n\t\t\t\t.write(\"\\\"><img id=\\\"\"+ self.getUuid()).write(\"!close\\\" src=\\\"\")\r\n\t\t\t\t.write(exec.encodeURL(\"~./zul/img/close-off.gif\")).writeln(\"\\\"/><\/td>\")\r\n\t\t\t\t.write(\"<td width=\\\"3\\\" class=\\\"\").write(tscls).write(\"mm\").write(suffix).writeln(\"\\\"><\/td>\")\r\n\t\t\t\t.write(\"<td class=\\\"\").write(tscls).write(\"mr\").write(suffix).writeln(\"\\\"><\/td><\/tr>\");\r\n\t\t}\r\n\t\t\r\n\t\twh.write(\"<tr><td class=\\\"\").write(tscls).write(\"bl\").write(suffix).writeln(\"\\\"><\/td>\")\r\n\t\t\t.write(\"<td colspan=\\\"3\\\" class=\\\"\").write(tscls).write(\"bm\").write(suffix).writeln(\"\\\"><\/td>\")\r\n\t\t\t.write(\"<td class=\\\"\").write(tscls).write(\"br\").write(suffix).writeln(\"\\\"><\/td>\")\r\n\t\t\t.writeln(\"<\/tr><\/table><\/td><\/tr>\");\r\n\t}","id":60853,"modified_method":"public void render(Component comp, Writer out) throws IOException {\r\n\t\tfinal Tab self = (Tab) comp;\r\n\t\tfinal Tabbox tabbox = self.getTabbox();\r\n\t\tfinal SmartWriter wh = new SmartWriter(out);\r\n\t\tfinal Execution exec = Executions.getCurrent();\r\n\t\tfinal String tscls = tabbox.getTabSclass() + '-';\r\n\t\tfinal String suffix = self.isSelected() ? \"-sel\" : \"-uns\";\r\n\r\n\t\twh.write(\"<tr id=\\\"\").write(self.getUuid()).write(\"\\\" z.type=\\\"Tab\\\"\")\r\n\t\t\t.write(self.getOuterAttrs()).write(\" z.sel=\\\"\").write(self.isSelected())\r\n\t\t\t.write(\"\\\" z.box=\\\"\").write(tabbox.getUuid()).write(\"\\\" z.panel=\\\"\")\r\n\t\t\t.write(self.getLinkedPanel().getUuid()).writeln(\"\\\">\");\r\n\r\n\t\twh.write(\"<td align=\\\"right\\\"\").writeAttr(\"width\", self.getWidth())\r\n\t\t\t.writeln(\"><table border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\" width=\\\"100%\\\">\")\r\n\t\t\t.write(\"<tr><td class=\\\"\").write(tscls).write(\"tl\").write(suffix).writeln(\"\\\"><\/td>\")\r\n\t\t\t.write(\"<td colspan=\\\"3\\\" class=\\\"\").write(tscls).write(\"tm\").write(suffix).writeln(\"\\\"><\/td>\")\r\n\t\t\t.write(\"<td class=\\\"\").write(tscls).write(\"tr\").write(suffix).writeln(\"\\\"><\/td>\")\r\n\t\t\t.write(\"<\/tr>\");\r\n\r\n\t\twh.write(\"<tr height=\\\"22\\\">\")\r\n\t\t\t.write(\"<td class=\\\"\").write(tscls).write(\"ml\").write(suffix).writeln(\"\\\"><\/td>\")\r\n\t\t\t.write(\"<td width=\\\"3\\\" class=\\\"\").write(tscls).write(\"mm\").write(suffix).writeln(\"\\\"><\/td>\")\r\n\t\t\t.write(\"<td align=\\\"center\\\" class=\\\"\").write(tscls).write(\"mm\").write(suffix)\r\n\t\t\t.write(\"\\\" id=\\\"\").write(self.getUuid()).write(\"!real\\\"\").write(self.getInnerAttrs())\r\n\t\t\t.write(\"><a href=\\\"javascript:;\\\" id=\\\"\").write(self.getUuid()).write(\"!a\\\">\");\r\n\t\t\twh.write(self.getImgTag());\r\n\t\t\tnew Out(self.getLabel()).render(out);\r\n\t\t\twh.writeln( \"<\/a><\/td>\");\t\t\r\n\r\n\t\t\twh.write(\"<td width=\\\"3\\\" class=\\\"\").write(tscls).write(\"mm\").write(suffix).writeln(\"\\\"><\/td>\")\t\r\n\t\t\t\t.write(\"<td class=\\\"\").write(tscls).write(\"mr\").write(suffix).writeln(\"\\\"><\/td><\/tr>\");\t\t\r\n\t\t\r\n\t\tif(self.isClosable()){\r\n\t\t\twh.writeln(\"<tr height=\\\"8\\\">\")\r\n\t\t\t\t.write(\"<td class=\\\"\").write(tscls).write(\"ml\").write(suffix).writeln(\"\\\"><\/td>\")\r\n\t\t\t\t.write(\"<td width=\\\"3\\\" class=\\\"\").write(tscls).write(\"mm\").write(suffix).writeln(\"\\\"><\/td>\")\r\n\t\t\t\t.write(\"<td align=\\\"center\\\" valign=\\\"buttom\\\" class=\\\"\").write(tscls).write(\"mm\").write(suffix)\r\n\t\t\t\t.write(\"\\\"><img id=\\\"\").write(self.getUuid()).write(\"!close\\\" src=\\\"\")\r\n\t\t\t\t.write(exec.encodeURL(\"~./zul/img/close-off.gif\")).writeln(\"\\\"/><\/td>\")\r\n\t\t\t\t.write(\"<td width=\\\"3\\\" class=\\\"\").write(tscls).write(\"mm\").write(suffix).writeln(\"\\\"><\/td>\")\r\n\t\t\t\t.write(\"<td class=\\\"\").write(tscls).write(\"mr\").write(suffix).writeln(\"\\\"><\/td><\/tr>\");\r\n\t\t}\r\n\t\t\r\n\t\twh.write(\"<tr><td class=\\\"\").write(tscls).write(\"bl\").write(suffix).writeln(\"\\\"><\/td>\")\r\n\t\t\t.write(\"<td colspan=\\\"3\\\" class=\\\"\").write(tscls).write(\"bm\").write(suffix).writeln(\"\\\"><\/td>\")\r\n\t\t\t.write(\"<td class=\\\"\").write(tscls).write(\"br\").write(suffix).writeln(\"\\\"><\/td>\")\r\n\t\t\t.writeln(\"<\/tr><\/table><\/td><\/tr>\");\r\n\t}","commit_id":"dee006ae4edeff29b38f201c76a0a489ed794ef6","url":"https://github.com/zkoss/zk"},{"original_method":"/** Returns a portion of the sclass that are used by {@link Tabs} and\n\t * {@link Tab} to provide the style for tabs.\n\t *\n\t * <p>If the style class ({@link #getSclass}) of this tab box is not\n\t * defined, \"tab-3d\" and \"tab-v3d\" are returned for horizontal and vertical\n\t * orient, respectively.\n\t * If the style class is defined, say \"simple\",\n\t * then this method return \"tab-simple\" and \"tab-vsimple\" for\n\t * horizontal and vertical orient, respectively.\n\t *\n\t * <p>If the mold is \"default\", then, {@link Tab} generates\n\t * \"tab-3d-tl-sel\" for the top-left corner of the selected tab,\n\t * \"tab-3d-tm-uns\" for the top-middle border of the\n\t * non-selected tab, and so on.\n\t *\n\t * <p>It is currently used only the default mold (with both vertical\n\t * and horizontal orientation).\n\t *\n\t * @since 3.0,0\n\t */\n\tpublic String getTabSclass() {\n\t\tfinal String prefix = \"vertical\".equals(_orient) ? \"tab-v\": \"tab-\";\n\t\tfinal String scls = getSclass();\n\t\treturn scls != null && scls.length() > 0 ? prefix + scls: prefix + \"3d\";\n\t}","id":60854,"modified_method":"/** Returns a portion of the sclass that are used by {@link Tabs} and\n\t * {@link Tab} to provide the style for tabs.\n\t *\n\t * <p>If the style class ({@link #getSclass}) of this tab box is not\n\t * defined and the mold is default,\n\t * \"tab-3d\" and \"tab-v3d\" are returned for horizontal and vertical\n\t * orient, respectively.\n\t * If the style class not defined and the mold is accordion,\n\t * \"tabaccd-3d\" and \"tabaccd-v3d\" returned (note: accordion doesn't support vertical yet).\n\t *\n\t * <p>If the style class is defined, say \"simple\",\n\t * then this method return \"tab-simple\" and \"tab-vsimple\" for\n\t * horizontal and vertical orient, respectively, and \"tabacc-simple\" for horizontal accordion.\n\t *\n\t * <p>If the mold is not \"default\" nor \"accordion\", this method returns\n\t * \"tab\" + getMold() + \"-\" + (vertical ? 'v': '') + getOrient().\n\t *\n\t * <p>With this method, {@link Tab} and {@link Tabpanel} generate\n\t * the style class accordingly. For example, if the mold is \"default\"\n\t * and the style class not defined, then\n\t * \"tab-3d-tl-sel\" for the top-left corner of the selected tab,\n\t * \"tab-3d-tm-uns\" for the top-middle border of the\n\t * non-selected tab, and so on.\n\t *\n\t * @since 3.0,0\n\t */\n\tpublic String getTabSclass() {\n\t\tfinal String mold = getMold();\n\t\tString prefix = \"default\".equals(mold) ? \"tab-\":\n\t\t\t\t\"accordion\".equals(mold) ? \"tabaccd-\": \"tab\" + mold + '-';\n\n\t\tif (\"vertical\".equals(_orient))\n\t\t\tprefix += 'v';\n\n\t\tfinal String scls = getSclass();\n\t\treturn scls != null && scls.length() > 0 ? prefix + scls: prefix + \"3d\";\n\t}","commit_id":"dee006ae4edeff29b38f201c76a0a489ed794ef6","url":"https://github.com/zkoss/zk"},{"original_method":"public void render(Component comp, Writer out) throws IOException {\r\n\t\tfinal SmartWriter wh = new SmartWriter(out);\r\n\t\tfinal Tabbox self = (Tabbox) comp;\r\n\t\tfinal Tabs tabs = self.getTabs();\r\n\t\t\r\n\t\twh.write(\"<table id=\\\"\").write(self.getUuid()).write(\"\\\"\")\r\n\t\t\t.write(self.getOuterAttrs()).write(self.getInnerAttrs())\r\n\t\t\t.write(\" z.tabs=\\\"\").write(tabs==null ?null:tabs.getUuid())\r\n\t\t\t.writeln(\"\\\" z.type=\\\"zul.tab.Tabbox\\\" border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\">\");\t\t\r\n\r\n\t\tif(\"vertical\".equals(self.getOrient())){\r\n\t\t\twh.write(\"<tr valign=\\\"top\\\">\")\r\n\t\t\t\t.write(tabs)\r\n\t\t\t\t.writeln(self.getTabpanels())\r\n\t\t\t\t.writeln(\"<\/tr>\");\r\n\t\t} else {\r\n\t\t\twh.write(tabs)\r\n\t\t\t\t.writeln(self.getTabpanels());\r\n\t\t}\r\n\r\n\t\twh.write(\"<\/table>\");\r\n\t}","id":60855,"modified_method":"public void render(Component comp, Writer out) throws IOException {\r\n\t\tfinal Tabbox self = (Tabbox) comp;\r\n\t\tif(\"vertical\".equals(self.getOrient())){\r\n\t\t\t_vtabbox.render(comp, out);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfinal SmartWriter wh = new SmartWriter(out);\r\n\t\tfinal Tabs tabs = self.getTabs();\r\n\t\t\r\n\t\twh.write(\"<table id=\\\"\").write(self.getUuid()).write(\"\\\"\")\r\n\t\t\t.write(self.getOuterAttrs()).write(self.getInnerAttrs())\r\n\t\t\t.write(\" z.tabs=\\\"\").write(tabs==null ?null:tabs.getUuid())\r\n\t\t\t.writeln(\"\\\" z.type=\\\"zul.tab.Tabbox\\\" border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\">\")\r\n\t\t\t.write(tabs)\r\n\t\t\t.write(self.getTabpanels())\r\n\t\t\t.write(\"<\/table>\");\r\n\t}","commit_id":"dee006ae4edeff29b38f201c76a0a489ed794ef6","url":"https://github.com/zkoss/zk"},{"original_method":"public void render(Component comp, Writer out) throws IOException {\t\r\n\t\tfinal SmartWriter wh = new SmartWriter(out);\r\n\t\tfinal Execution exec = Executions.getCurrent();\r\n\t\tfinal Tabpanel self = (Tabpanel) comp;\r\n\t\tfinal Tab tab = self.getLinkedTab();\r\n\t\tfinal String suffix = (self.isSelected()) ? \"-sel\" : \"-uns\";\r\n\t\tfinal int colspan1 = (tab.isClosable()) ? 4:3;\r\n\t\tfinal int colspan2 = (tab.isClosable()) ? 6:5;\r\n\t\tfinal String height = Strings.isBlank(self.getHeight()) ? \"22\" : self.getHeight(); \t\t\r\n\t\t\r\n\t\twh.write(\"<tr id=\\\"\").write(self.getUuid()).write(\"\\\">\"); //no exteriorAttribute here because tab.js controls it diff\r\n\t\twh.write(\"<td>\");\r\n\t\twh.write(\"<table id=\\\"\").write(tab.getUuid()).write(\"\\\"\").write(tab.getOuterAttrs()).write(tab.getInnerAttrs() \r\n\t\t\t\t).write(\" z.sel=\\\"\").write(tab.isSelected()).write(\"\\\" z.type=\\\"zul.tab.Tab\\\" z.box=\\\"\" \r\n\t\t\t\t).write(tab.getTabbox().getUuid()).write(\"\\\" z.panel=\\\"\").write(self.getUuid() \r\n\t\t\t\t).write(\"\\\" width=\\\"100%\\\" border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\">\");\t\t\r\n\t\tif(!Strings.isBlank(self.getTabbox().getPanelSpacing()) && self.getIndex() != 0)\r\n\t\t\twh.write(\"<tr height=\\\"\").write(self.getTabbox().getPanelSpacing()).write(\"\\\"><td><\/td><\/tr>\");\r\n\t\t\r\n\t\twh.write(\"<tr>\");\r\n\t\t\twh.write(\"<td class=\\\"\").write(\"tabaccd-3d-tl\").write(suffix).write(\"\\\"><\/td>\");\t\t\t\r\n\t\t\twh.write(\"<td colspan=\\\"\").write(colspan1).write(\"\\\" class=\\\"\").write(\"tabaccd-3d-tm\").write(suffix).write(\"\\\"><\/td>\");\r\n\t\t\twh.write(\"<td class=\\\"\").write(\"tabaccd-3d-tr\").write(suffix).write(\"\\\"><\/td>\");\t\t\t\r\n\t\twh.write(\"<\/tr>\");\t\r\n\t    \r\n\t\twh.write(\"<tr height=\\\"\").write(height).write(\"\\\">\");\t\t\r\n\t\t\twh.write(\"<td class=\\\"\").write(\"tabaccd-3d-ml\").write(suffix).write(\"\\\"><\/td>\");\r\n\t\t\twh.write(\"<td width=\\\"3\\\" class=\\\"\").write(\"tabaccd-3d-mm\").write(suffix).write(\"\\\"><\/td>\");\r\n\t\t\twh.write(\"<td align=\\\"left\\\" class=\\\"\").write(\"tabaccd-3d-mm\").write(suffix).write(\"\\\"><a href=\\\"javascript:;\\\"\")\r\n\t\t\t.write(\" id=\\\"\").write(tab.getUuid()).write(\"!a\\\">\");\t\t\t\r\n\t\t\twh.write(tab.getImgTag());\r\n\t\t\tnew Out(tab.getLabel()).render(out);\r\n\t\t\twh.write( \"<\/a><\/td>\");\t\t\t\r\n\r\n\t\tif(tab.isClosable()){\r\n\t\t\twh.write(\"<td width=\\\"11\\\" align=\\\"right\\\" class=\\\"\").write(\"tabaccd-3d-mm\").write(suffix) \r\n\t\t\t.write(\"\\\"><img id=\\\"\").write(self.getUuid()).write(\"!close\\\" src=\\\"\")\r\n\t\t\t.write(exec.encodeURL(\"~./zul/img/close-off.gif\")).write(\"\\\"/><\/td>\");\r\n\t\t}\r\n\t\t\twh.write(\"<td width=\\\"3\\\" class=\\\"\").write(\"tabaccd-3d-mm\").write(suffix).write(\"\\\"><\/td>\");\t\r\n\t\t\twh.write(\"<td class=\\\"\").write(\"tabaccd-3d-mr\").write(suffix).write(\"\\\"><\/td>\");\r\n\t\twh.write(\"<\/tr>\");\t\r\n\t\twh.write(\"<tr>\");\r\n\t\t\twh.write(\"<td colspan=\\\"\").write(colspan2)\r\n\t\t\t\t.write(\"\\\" class=\\\"tabaccd-3d-b\\\"><\/td><\/tr><\/table>\");\r\n\r\n\t\t\twh.write(\"<div id=\\\"\").write(self.getUuid()).write(\"!real\\\"\")\r\n\t\t\t\t.write(self.getOuterAttrs()).write(self.getInnerAttrs())\r\n\t\t\t\t.write(\"><div id=\\\"\").write(self.getUuid()).write(\"!cave\\\">\")\r\n\t\t\t\t.writeChildren(self)\r\n\t\t\t\t.writeln(\"<\/div><\/div><\/td><\/tr>\");\r\n\r\n\t}","id":60856,"modified_method":"public void render(Component comp, Writer out) throws IOException {\t\r\n\t\tfinal SmartWriter wh = new SmartWriter(out);\r\n\t\tfinal Execution exec = Executions.getCurrent();\r\n\t\tfinal Tabpanel self = (Tabpanel) comp;\r\n\t\tfinal Tab tab = self.getLinkedTab();\r\n\t\tfinal Tabbox tabbox = self.getTabbox();\r\n\t\tfinal String tscls = tabbox.getTabSclass() + '-';\r\n\t\tfinal String suffix = self.isSelected() ? \"-sel\" : \"-uns\";\r\n\t\tfinal String height = Strings.isBlank(self.getHeight()) ? \"22\" : self.getHeight(); \t\t\r\n\t\t\r\n\t\twh.write(\"<tr id=\\\"\").write(self.getUuid()).write(\"\\\"><td>\");\r\n\t\twh.write(\"<table id=\\\"\").write(tab.getUuid()).write(\"\\\"\")\r\n\t\t\t.write(tab.getOuterAttrs()).write(tab.getInnerAttrs())\r\n\t\t\t.write(\" z.sel=\\\"\").write(tab.isSelected()).write(\"\\\" z.type=\\\"zul.tab.Tab\\\" z.box=\\\"\")\r\n\t\t\t.write(tabbox.getUuid()).write(\"\\\" z.panel=\\\"\").write(self.getUuid())\r\n\t\t\t.writeln(\"\\\" width=\\\"100%\\\" border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\">\");\t\t\r\n\r\n\t\tif(!Strings.isBlank(tabbox.getPanelSpacing()) && self.getIndex() != 0)\r\n\t\t\twh.write(\"<tr height=\\\"\").write(tabbox.getPanelSpacing()).writeln(\"\\\"><td><\/td><\/tr>\");\r\n\t\t\r\n\t\twh.write(\"<tr><td class=\\\"\").write(tscls).write(\"tl\").write(suffix).writeln(\"\\\"><\/td>\")\r\n\t\t\t.write(\"<td colspan=\\\"\").write(tab.isClosable() ? 4:3)\r\n\t\t\t.write(\"\\\" class=\\\"\").write(tscls).write(\"tm\").write(suffix).writeln(\"\\\"><\/td>\")\r\n\t\t\t.write(\"<td class=\\\"\").write(tscls).write(\"tr\").write(suffix).writeln(\"\\\"><\/td><\/tr>\");\t\r\n\r\n\t\twh.write(\"<tr height=\\\"\").write(height).write(\"\\\"><td class=\\\"\")\r\n\t\t\t.write(tscls).write(\"ml\").write(suffix).writeln(\"\\\"><\/td>\")\r\n\t\t\t.write(\"<td width=\\\"3\\\" class=\\\"\").write(tscls).write(\"mm\").write(suffix).writeln(\"\\\"><\/td>\")\r\n\t\t\t.write(\"<td align=\\\"left\\\" class=\\\"\").write(tscls).write(\"mm\").write(suffix)\r\n\t\t\t.write(\"\\\"><a href=\\\"javascript:;\\\" id=\\\"\").write(tab.getUuid()).write(\"!a\\\">\")\r\n\t\t\t.write(tab.getImgTag());\r\n\t\t\tnew Out(tab.getLabel()).render(out);\r\n\t\t\twh.writeln(\"<\/a><\/td>\");\t\t\t\r\n\r\n\t\tif(tab.isClosable()){\r\n\t\t\twh.write(\"<td width=\\\"11\\\" align=\\\"right\\\" class=\\\"\")\r\n\t\t\t.write(tscls).write(\"mm\").write(suffix).write(\"\\\"><img id=\\\"\")\r\n\t\t\t.write(self.getUuid()).write(\"!close\\\" src=\\\"\")\r\n\t\t\t.write(exec.encodeURL(\"~./zul/img/close-off.gif\"))\r\n\t\t\t.writeln(\"\\\"/><\/td>\");\r\n\t\t}\r\n\r\n\t\twh.write(\"<td width=\\\"3\\\" class=\\\"\").write(tscls).write(\"mm\").write(suffix).writeln(\"\\\"><\/td>\")\r\n\t\t\t.write(\"<td class=\\\"\").write(tscls).write(\"mr\").write(suffix).writeln(\"\\\"><\/td><\/tr>\");\r\n\r\n\t\twh.write(\"<tr><td colspan=\\\"\").write(tab.isClosable() ? 6:5)\r\n\t\t\t.write(\"\\\" class=\\\"\").write(tscls).write(\"b\\\"><\/td><\/tr>\\n<\/table>\");\r\n\r\n\t\twh.write(\"<div id=\\\"\").write(self.getUuid()).write(\"!real\\\"\")\r\n\t\t\t.write(self.getOuterAttrs()).write(self.getInnerAttrs())\r\n\t\t\t.write(\"><div id=\\\"\").write(self.getUuid()).write(\"!cave\\\">\")\r\n\t\t\t.writeChildren(self)\r\n\t\t\t.writeln(\"<\/div><\/div><\/td><\/tr>\");\r\n\t}","commit_id":"dee006ae4edeff29b38f201c76a0a489ed794ef6","url":"https://github.com/zkoss/zk"},{"original_method":"public void render(Component comp, Writer out) throws IOException {\r\n\t\tfinal SmartWriter wh = new SmartWriter(out);\r\n\t\tfinal Tabpanel self = (Tabpanel) comp;\r\n\r\n\t\tif(self.getTabbox().getOrient().equals(\"vertical\")){\r\n\t\t\twh.write(\"<div id=\\\"\").write(self.getUuid()).write('\"')\r\n\t\t\t\t.write(self.getOuterAttrs()).write(self.getInnerAttrs()).write('>')\r\n\t\t\t\t.writeChildren(self)\r\n\t\t\t\t.write(\"<\/div>\");\t\t\r\n\t\t}\r\n\t\telse{\r\n\t\t\twh.write(\"<tr id=\\\"\").write(self.getUuid()).write('\"')\r\n\t\t\t\t.write(self.getOuterAttrs()).writeln('>')\r\n\t\t\t\t.write(\"<td id=\\\"\").write(self.getUuid()).write(\"!real\\\" class=\\\"tabpanel-hr\\\"\")\r\n\t\t\t\t.write(self.getInnerAttrs()).write('>')\r\n\t\t\t\t.writeChildren(self)\r\n\t\t\t\t.writeln(\"<\/td><\/tr>\");\r\n\t\t}\r\n\t}","id":60857,"modified_method":"public void render(Component comp, Writer out) throws IOException {\r\n\t\tfinal Tabpanel self = (Tabpanel) comp;\r\n\t\tfinal Tabbox tabbox = self.getTabbox();\r\n\t\tif (\"accordion\".equals(tabbox.getMold())) {\r\n\t\t\t_acdpanel.render(comp, out);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (\"vertical\".equals(tabbox.getOrient())) {\r\n\t\t\t_vpanel.render(comp, out);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfinal SmartWriter wh = new SmartWriter(out);\r\n\r\n\t\twh.write(\"<tr id=\\\"\").write(self.getUuid()).write('\"')\r\n\t\t\t.write(self.getOuterAttrs()).write('>')\r\n\t\t\t.write(\"<td id=\\\"\").write(self.getUuid()).write(\"!real\\\" class=\\\"tabpanel-hr\\\"\")\r\n\t\t\t.write(self.getInnerAttrs()).write('>')\r\n\t\t\t.writeChildren(self)\r\n\t\t\t.writeln(\"<\/td><\/tr>\");\r\n\t}","commit_id":"dee006ae4edeff29b38f201c76a0a489ed794ef6","url":"https://github.com/zkoss/zk"},{"original_method":"public void render(Component comp, Writer out) throws IOException {\r\n\t\tfinal SmartWriter wh = new SmartWriter(out);\r\n\t\tfinal Tabpanels self = (Tabpanels) comp;\r\n\r\n\t\tif(((Tabbox)self.getParent()).getOrient().equals(\"vertical\")){\r\n\t\t\twh.write(\"<td id=\\\"\").write(self.getUuid()).write(\"\\\"\")\r\n\t\t\t\t.write(self.getOuterAttrs()).write(self.getInnerAttrs()).writeln(\">\")\r\n\t\t\t\t.writeChildren(self)\r\n\t\t\t\t.writeln(\"<\/td>\");\r\n\t\t} else {\r\n\t\t\twh.write(\"<tbody id=\\\"\").write(self.getUuid()).write(\"\\\"\")\r\n\t\t\t\t.write(self.getOuterAttrs()).write(self.getInnerAttrs()).writeln(\">\")\r\n\t\t\t\t.writeChildren(self)\r\n\t\t\t\t.writeln(\"<\/tbody>\");\r\n\t\t}\r\n\t}","id":60858,"modified_method":"public void render(Component comp, Writer out) throws IOException {\r\n\t\tfinal Tabpanels self = (Tabpanels) comp;\r\n\t\tif (\"vertical\".equals(self.getTabbox().getOrient())) {\r\n\t\t\t_vpanels.render(comp, out);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfinal SmartWriter wh = new SmartWriter(out);\r\n\r\n\t\twh.write(\"<tbody id=\\\"\").write(self.getUuid()).write(\"\\\"\")\r\n\t\t\t.write(self.getOuterAttrs()).write(self.getInnerAttrs()).writeln(\">\")\r\n\t\t\t.writeChildren(self)\r\n\t\t\t.writeln(\"<\/tbody>\");\r\n\t}","commit_id":"dee006ae4edeff29b38f201c76a0a489ed794ef6","url":"https://github.com/zkoss/zk"},{"original_method":"public void render(Component comp, Writer out) throws IOException {\r\n\t\tfinal Tabs self = (Tabs)comp;\r\n\t\tfinal Tabbox tabbox = self.getTabbox();\r\n\r\n\t\tif(tabbox.getOrient().equals(\"vertical\")) {\r\n\t\t\t_vtabs.render(comp, out);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfinal SmartWriter wh = new SmartWriter(out);\t\t\r\n\t\tfinal String tscls = tabbox.getTabSclass() + '-';\r\n\r\n\t\twh.write(\"<thead id=\\\"\").write(self.getUuid()).write(\"\\\" z.type=\\\"zul.tab.Tabs\\\"\")\r\n\t\t\t.write(self.getOuterAttrs()).write(self.getInnerAttrs()).writeln('>')\r\n\t\t\t.writeln(\"<tr><td><table border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\">\")\r\n\t\t\t.write(\"<tr valign=\\\"bottom\\\">\");\r\n\t\t\r\n\t\t/* prefix column */\r\n\t\twh.writeln(\"<td><table border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\">\");\r\n\t\twh.write(\"<tr><td class=\\\"\").write(tscls).writeln(\"first\\\"><\/td><\/tr><\/table><\/td>\");\t\t\t\t\r\n\r\n\t\twh.writeChildren(self);\r\n\t\t\r\n\t\twh.write(\"<td style=\\\"display:none\\\" id=\\\"\")\r\n\t\t\t.write(self.getUuid()).writeln(\"!child\\\"><\/td>\"); //bookmark for adding children\r\n\t\t\r\n\t\t/* postfix column */\t\t\r\n\t\twh.writeln(\"<td><table border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\">\")\r\n\t\t\t.write(\"<tr><td class=\\\"\").write(tscls).write(\"last1\\\" id=\\\"\")\r\n\t\t\t.write(self.getUuid()).writeln(\"!last\\\"><\/td>\")\r\n\t\t\t.write(\"<td class=\\\"\").write(tscls).writeln(\"last2\\\"><\/td>\")\r\n\t\t\t.writeln(\"<\/tr><\/table><\/td><\/tr><\/table><\/td><\/tr><\/thead>\");\r\n\t}","id":60859,"modified_method":"public void render(Component comp, Writer out) throws IOException {\r\n\t\tfinal Tabs self = (Tabs)comp;\r\n\t\tfinal Tabbox tabbox = self.getTabbox();\r\n\r\n\t\tif(\"vertical\".equals(tabbox.getOrient())) {\r\n\t\t\t_vtabs.render(comp, out);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfinal SmartWriter wh = new SmartWriter(out);\t\t\r\n\t\tfinal String tscls = tabbox.getTabSclass() + '-';\r\n\r\n\t\twh.write(\"<thead id=\\\"\").write(self.getUuid()).write(\"\\\" z.type=\\\"zul.tab.Tabs\\\"\")\r\n\t\t\t.write(self.getOuterAttrs()).write(self.getInnerAttrs()).writeln('>')\r\n\t\t\t.writeln(\"<tr><td><table border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\">\")\r\n\t\t\t.write(\"<tr valign=\\\"bottom\\\">\");\r\n\t\t\r\n\t\t/* prefix column */\r\n\t\twh.writeln(\"<td><table border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\">\");\r\n\t\twh.write(\"<tr><td class=\\\"\").write(tscls).writeln(\"first\\\"><\/td><\/tr><\/table><\/td>\");\t\t\t\t\r\n\r\n\t\twh.writeChildren(self);\r\n\t\t\r\n\t\twh.write(\"<td style=\\\"display:none\\\" id=\\\"\")\r\n\t\t\t.write(self.getUuid()).writeln(\"!child\\\"><\/td>\"); //bookmark for adding children\r\n\t\t\r\n\t\t/* postfix column */\t\t\r\n\t\twh.writeln(\"<td><table border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\">\")\r\n\t\t\t.write(\"<tr><td class=\\\"\").write(tscls).write(\"last1\\\" id=\\\"\")\r\n\t\t\t.write(self.getUuid()).writeln(\"!last\\\"><\/td>\")\r\n\t\t\t.write(\"<td class=\\\"\").write(tscls).writeln(\"last2\\\"><\/td>\")\r\n\t\t\t.writeln(\"<\/tr><\/table><\/td><\/tr><\/table><\/td><\/tr><\/thead>\");\r\n\t}","commit_id":"dee006ae4edeff29b38f201c76a0a489ed794ef6","url":"https://github.com/zkoss/zk"},{"original_method":"/**\r\n<c:set var=\"self\" value=\"${requestScope.arg.self}\"/>\r\n<a id=\"${self.uuid}\" z.type=\"zul.widget.Tbtn\" ${self.outerAttrs}${self.innerAttrs}>\r\n<c:choose>\r\n<c:when test=\"${self.dir == 'reverse'}\">\r\n\t<c:out value=\"${self.label}\"/>\r\n\t<c:if test=\"${self.imageAssigned and self.orient == 'vertical'}\">\r\n\t  <br/>\r\n\t<\/c:if>\r\n\t${self.imgTag}\r\n<\/c:when>\r\n<c:otherwise>\r\n\t${self.imgTag}\r\n\t<c:if test=\"${self.imageAssigned and self.orient == 'vertical'}\">\r\n\t  <br/>\r\n\t<\/c:if>\r\n\t<c:out value=\"${self.label}\"/>\r\n<\/c:otherwise>\r\n<\/c:choose><\/a>\r\n\t */\r\n\tpublic void render(Component comp, Writer out) throws IOException {\r\n\t\tfinal SmartWriter wh = new SmartWriter(out);\r\n\t\tfinal Toolbarbutton self = (Toolbarbutton) comp;\r\n\t\t\r\n\t\twh.write(\"<a id=\\\"\" + self.getUuid() + \"\\\" z.type=\\\"zul.widget.Tbtn\\\"\" + self.getOuterAttrs() + self.getInnerAttrs() + \">\");\r\n\t\tif (self.getDir().equals(\"reverse\")){\r\n\t\t\tnew Out(self.getLabel()).render(out);\r\n\t\t\tif (self.isImageAssigned() && self.getOrient().equals(\"vertical\")){\r\n\t\t\t\twh.write(\"<br/>\");\r\n\t\t\t}\r\n\t\t\twh.write(self.getImgTag());\r\n\t\t}\r\n\t\telse{\r\n\t\t\twh.write(self.getImgTag());\r\n\t\t\tif (self.isImageAssigned() && self.getOrient().equals(\"vertical\")){\r\n\t\t\t\twh.write(\"<br/>\");\t\t\t\t\r\n\t\t\t}\r\n\t\t\tnew Out(self.getLabel()).render(out);\r\n\t\t}\t\t\r\n\t\twh.write(\"<\/a>\");\r\n\r\n\t}","id":60860,"modified_method":"public void render(Component comp, Writer out) throws IOException {\r\n\t\tfinal SmartWriter wh = new SmartWriter(out);\r\n\t\tfinal Toolbarbutton self = (Toolbarbutton) comp;\r\n\t\t\r\n\t\twh.write(\"<a id=\\\"\").write(self.getUuid()).write(\"\\\" z.type=\\\"zul.widget.Tbtn\\\"\")\r\n\t\t\t.write(self.getOuterAttrs()).write(self.getInnerAttrs()).write(\">\");\r\n\r\n\t\tif (self.getDir().equals(\"reverse\")){\r\n\t\t\tnew Out(self.getLabel()).render(out);\r\n\t\t\tif (self.isImageAssigned() && self.getOrient().equals(\"vertical\"))\r\n\t\t\t\twh.writeln(\"<br/>\");\r\n\t\t\twh.write(self.getImgTag());\r\n\t\t} else{\r\n\t\t\twh.write(self.getImgTag());\r\n\t\t\tif (self.isImageAssigned() && self.getOrient().equals(\"vertical\"))\r\n\t\t\t\twh.writeln(\"<br/>\");\t\t\t\t\r\n\t\t\tnew Out(self.getLabel()).render(out);\r\n\t\t}\t\t\r\n\r\n\t\twh.write(\"<\/a>\");\r\n\t}","commit_id":"dee006ae4edeff29b38f201c76a0a489ed794ef6","url":"https://github.com/zkoss/zk"},{"original_method":"private boolean hasError(Node that) {\n        if (allowWarnings) {\n            // skip warnings\n            for(Message message : that.getErrors())\n                if(!(message instanceof AnalysisWarning))\n                    return true;\n        } else {\n            // don't skip warnings\n            if(!that.getErrors().isEmpty())\n                return true;\n        }\n        return false;\n    }","id":60861,"modified_method":"private boolean hasError(Node that) {\n        if (allowWarnings) {\n            // skip warnings\n            for(Message message : that.getErrors()){\n                if(!(message instanceof AnalysisWarning)\n                        && !(message instanceof UsageWarning))\n                    return true;\n            }\n        } else {\n            // skip only usage warnings\n            for(Message message : that.getErrors()){\n                if(!(message instanceof UsageWarning))\n                    return true;\n            }\n        }\n        return false;\n    }","commit_id":"3db495d0690868622676930ca869a3d62d7d8536","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private static void outputMetadata(ContentHandlerHelper helper, Metadata metadata, String elementName) throws MetadataException {\n        if (metadata.getDirectoryCount() > 0) {\n            for (Iterator j = metadata.getDirectoryIterator(); j.hasNext();) {\n                Directory directory = (Directory) j.next();\n\n                helper.startElement(elementName, new String[]{\"name\", directory.getName()});\n\n                for (Iterator k = directory.getTagIterator(); k.hasNext();) {\n                    Tag tag = (Tag) k.next();\n                    helper.startElement(TAG_ELEMENT);\n                    helper.element(\"id\", tag.getTagType());\n                    helper.element(\"name\", tag.getTagName());\n                    helper.element(\"value\", tag.getDescription());\n                    helper.endElement();\n                }\n                // TODO: Should do something with this?\n                if (directory.hasErrors()) {\n                    for (Iterator k = directory.getErrors(); k.hasNext();) {\n                        //System.out.println(\"ERROR: \" + k.next());\n                    }\n                }\n\n                helper.endElement();\n            }\n        }\n    }","id":60862,"modified_method":"private static void outputMetadata(ContentHandlerHelper helper, Metadata metadata, String elementName) throws MetadataException {\n        if (metadata.getDirectoryCount() > 0) {\n            for (Directory directory: metadata.getDirectories()) {\n\n                helper.startElement(elementName, new String[]{\"name\", directory.getName()});\n\n                for (Tag tag: directory.getTags()) {\n                    helper.startElement(TAG_ELEMENT);\n                    helper.element(\"id\", tag.getTagType());\n                    helper.element(\"name\", tag.getTagName());\n                    helper.element(\"value\", tag.getDescription());\n                    helper.endElement();\n                }\n                // TODO: Should do something with this?\n                if (directory.hasErrors()) {\n                    for (String error: directory.getErrors()) {\n                        //System.out.println(\"ERROR: \" + k.next());\n                    }\n                }\n\n                helper.endElement();\n            }\n        }\n    }","commit_id":"120138a596264dd9ed27ba4df0be50fa5de6e050","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private static void outputImageMetadata(ContentHandlerHelper helper, Config config, File file) throws Exception {\n        helper.startElement(\"image-metadata\");\n        InputStream is = new BufferedInputStream(new FileInputStream(file));\n        try {\n            String contentType = URLConnection.guessContentTypeFromStream(is);\n            if (contentType != null && contentType.startsWith(\"image/\")) {\n\n                if (contentType.equals(\"image/jpeg\")) {\n\n                    JpegSegmentReader segmentReader = new JpegSegmentReader(is);\n\n                    // Basic info: content-type, size and comment\n                    if (config.isBasicInfo()) {\n\n                        helper.startElement(\"basic-info\");\n                        helper.element(\"content-type\", contentType);\n\n                        byte[] startOfFrameSegment = segmentReader.readSegment(JpegSegmentReader.SEGMENT_SOF0);\n                        if (startOfFrameSegment != null) {\n                            // Big-endian, unsigned encoding\n                            int width = NumberUtils.readShortBigEndian(startOfFrameSegment, 3) & 0xffff;\n                            int height = NumberUtils.readShortBigEndian(startOfFrameSegment, 1) & 0xffff;\n                            helper.element(\"width\", width);\n                            helper.element(\"height\", height);\n                        }\n                        byte[] commentSegment = segmentReader.readSegment((byte) 0xfe);\n                        if (commentSegment != null)\n                            helper.element(\"comment\", new String(commentSegment), \"iso-8859-1\"); // probably just ASCII\n\n                        helper.endElement();\n                    }\n                    // Exif info\n                    if (config.isExifInfo()) {\n                        byte[] exifSegment = segmentReader.readSegment(JpegSegmentReader.SEGMENT_APP1);\n                        if (exifSegment != null) {\n                            Metadata metadata = new Metadata();\n                            new ExifReader(exifSegment).extract(metadata);\n                            outputMetadata(helper, metadata, EXIF_ELEMENT);\n                        }\n                    }\n                    // IPTC info\n                    if (config.isIptcInfo()) {\n                        byte[] iptcSegment = segmentReader.readSegment(JpegSegmentReader.SEGMENT_APPD);\n                        if (iptcSegment != null) {\n                            Metadata metadata = new Metadata();\n                            new IptcReader(iptcSegment).extract(metadata);\n                            outputMetadata(helper, metadata, IPTC_ELEMENT);\n                        }\n                    }\n\n                } else if (contentType.equals(\"image/gif\")) {\n\n                    // Basic info: content-type and size\n                    if (config.isBasicInfo()) {\n                        helper.startElement(\"basic-info\");\n                        helper.element(\"content-type\", contentType);\n\n                        byte[] bytes = new byte[10];\n                        int count = is.read(bytes);\n\n                        if (count == bytes.length) {\n                            // Little-endian, unsigned encoding\n                            int width = NumberUtils.readShortLittleEndian(bytes, 6) & 0xffff;\n                            int height = NumberUtils.readShortLittleEndian(bytes, 8) & 0xffff;\n                            helper.element(\"width\", width);\n                            helper.element(\"height\", height);\n                        }\n                        helper.endElement();\n                    }\n                } else if (contentType.equals(\"image/png\")) {\n                    // Basic info: content-type and size\n                    if (config.isBasicInfo()) {\n                        helper.startElement(\"basic-info\");\n                        helper.element(\"content-type\", contentType);\n\n                        // See http://www.libpng.org/pub/png/spec/1.2/\n\n                        byte[] bytes = new byte[8 + 4 + 4 + 13];// header + chunk length + chunk type + IHDR content\n                        int count = is.read(bytes);\n\n                        if (count == bytes.length) {\n                            if (bytes[12] == 'I' && bytes[13] == 'H' && bytes[14] == 'D' && bytes[15] == 'R') {\n//                                int chunkLength = NumberUtils.readIntBigEndian(bytes, 8);\n                                int width = NumberUtils.readIntBigEndian(bytes, 16);\n                                int height = NumberUtils.readIntBigEndian(bytes, 20);\n//                                int bitDepth = bytes[24];\n//                                int colorType = bytes[25];\n//                                int compressionMethod = bytes[26];\n//                                int filterMethod = bytes[27];\n//                                int interlaceMethod = bytes[28];\n\n                                helper.element(\"width\", width);\n                                helper.element(\"height\", height);\n                            }\n                        }\n\n                        helper.endElement();\n                    }\n                } else {\n                    // Basic info: just content-type\n                    if (config.isBasicInfo()) {\n                        helper.startElement(\"basic-info\");\n                        helper.element(\"content-type\", contentType);\n                        helper.endElement();\n                    }\n                }\n            }\n        } finally {\n            if (is != null)\n                is.close();\n        }\n        helper.endElement();\n    }","id":60863,"modified_method":"private static void outputImageMetadata(ContentHandlerHelper helper, Config config, File file) throws Exception {\n        helper.startElement(\"image-metadata\");\n        InputStream is = new BufferedInputStream(new FileInputStream(file));\n        try {\n            String contentType = URLConnection.guessContentTypeFromStream(is);\n            if (contentType != null && contentType.startsWith(\"image/\")) {\n\n                if (contentType.equals(\"image/jpeg\")) {\n\n                    JpegSegmentData segmentData = JpegSegmentReader.readSegments(new StreamReader(is), null);\n\n                    // Basic info: content-type, size and comment\n                    if (config.isBasicInfo()) {\n\n                        helper.startElement(\"basic-info\");\n                        helper.element(\"content-type\", contentType);\n\n                        byte[] startOfFrameSegment = segmentData.getSegment(JpegSegmentType.SOF0);\n                        if (startOfFrameSegment != null) {\n                            // Big-endian, unsigned encoding\n                            int width = NumberUtils.readShortBigEndian(startOfFrameSegment, 3) & 0xffff;\n                            int height = NumberUtils.readShortBigEndian(startOfFrameSegment, 1) & 0xffff;\n                            helper.element(\"width\", width);\n                            helper.element(\"height\", height);\n                        }\n                        byte[] commentSegment = segmentData.getSegment(JpegSegmentType.COM);\n                        if (commentSegment != null)\n                            helper.element(\"comment\", new String(commentSegment), \"iso-8859-1\"); // probably just ASCII\n\n                        helper.endElement();\n                    }\n                    // Exif info\n                    if (config.isExifInfo()) {\n                        byte[] exifSegment = segmentData.getSegment(JpegSegmentType.APP1);\n                        if (exifSegment != null) {\n                            Metadata metadata = new Metadata();\n                            new ExifReader().extract(exifSegment, metadata, JpegSegmentType.APP1);\n                            outputMetadata(helper, metadata, EXIF_ELEMENT);\n                        }\n                    }\n                    // IPTC info\n                    if (config.isIptcInfo()) {\n                        byte[] iptcSegment = segmentData.getSegment(JpegSegmentType.APPD);\n                        if (iptcSegment != null) {\n                            Metadata metadata = new Metadata();\n                            new IptcReader().extract(iptcSegment, metadata, JpegSegmentType.APPD);\n                            outputMetadata(helper, metadata, IPTC_ELEMENT);\n                        }\n                    }\n\n                } else if (contentType.equals(\"image/gif\")) {\n\n                    // Basic info: content-type and size\n                    if (config.isBasicInfo()) {\n                        helper.startElement(\"basic-info\");\n                        helper.element(\"content-type\", contentType);\n\n                        byte[] bytes = new byte[10];\n                        int count = is.read(bytes);\n\n                        if (count == bytes.length) {\n                            // Little-endian, unsigned encoding\n                            int width = NumberUtils.readShortLittleEndian(bytes, 6) & 0xffff;\n                            int height = NumberUtils.readShortLittleEndian(bytes, 8) & 0xffff;\n                            helper.element(\"width\", width);\n                            helper.element(\"height\", height);\n                        }\n                        helper.endElement();\n                    }\n                } else if (contentType.equals(\"image/png\")) {\n                    // Basic info: content-type and size\n                    if (config.isBasicInfo()) {\n                        helper.startElement(\"basic-info\");\n                        helper.element(\"content-type\", contentType);\n\n                        // See http://www.libpng.org/pub/png/spec/1.2/\n\n                        byte[] bytes = new byte[8 + 4 + 4 + 13];// header + chunk length + chunk type + IHDR content\n                        int count = is.read(bytes);\n\n                        if (count == bytes.length) {\n                            if (bytes[12] == 'I' && bytes[13] == 'H' && bytes[14] == 'D' && bytes[15] == 'R') {\n//                                int chunkLength = NumberUtils.readIntBigEndian(bytes, 8);\n                                int width = NumberUtils.readIntBigEndian(bytes, 16);\n                                int height = NumberUtils.readIntBigEndian(bytes, 20);\n//                                int bitDepth = bytes[24];\n//                                int colorType = bytes[25];\n//                                int compressionMethod = bytes[26];\n//                                int filterMethod = bytes[27];\n//                                int interlaceMethod = bytes[28];\n\n                                helper.element(\"width\", width);\n                                helper.element(\"height\", height);\n                            }\n                        }\n\n                        helper.endElement();\n                    }\n                } else {\n                    // Basic info: just content-type\n                    if (config.isBasicInfo()) {\n                        helper.startElement(\"basic-info\");\n                        helper.element(\"content-type\", contentType);\n                        helper.endElement();\n                    }\n                }\n            }\n        } finally {\n            if (is != null)\n                is.close();\n        }\n        helper.endElement();\n    }","commit_id":"120138a596264dd9ed27ba4df0be50fa5de6e050","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private static LocalQuickFix[] genCastFixes(GrSignature signature, PsiType[] argumentTypes, GroovyPsiElement context) {\n\n      final List<GrClosureSignature> signatures = GrClosureSignatureUtil.generateSimpleSignature(signature);\n\n      List<Pair<Integer, PsiType>> errors = new ArrayList<Pair<Integer, PsiType>>();\n      for (GrClosureSignature closureSignature : signatures) {\n        final GrClosureSignatureUtil.MapResultWithError<PsiType> map =\n          GrClosureSignatureUtil.mapSimpleSignatureWithErrors(closureSignature, argumentTypes, Function.ID, context, 1);\n        if (map != null) {\n          errors.addAll(map.getErrors());\n        }\n      }\n\n      final ArrayList<LocalQuickFix> fixes = new ArrayList<LocalQuickFix>();\n      for (Pair<Integer, PsiType> error : errors) {\n        fixes.add(new ParameterCastFix(error.first, error.second));\n      }\n\n      return fixes.toArray(new LocalQuickFix[fixes.size()]);\n    }","id":60864,"modified_method":"private static LocalQuickFix[] genCastFixes(GrSignature signature, PsiType[] argumentTypes, GrArgumentList argumentList) {\n\n      final List<GrClosureSignature> signatures = GrClosureSignatureUtil.generateSimpleSignature(signature);\n\n      List<Pair<Integer, PsiType>> allErrors = new ArrayList<Pair<Integer, PsiType>>();\n      for (GrClosureSignature closureSignature : signatures) {\n        final GrClosureSignatureUtil.MapResultWithError<PsiType> map =\n          GrClosureSignatureUtil.mapSimpleSignatureWithErrors(closureSignature, argumentTypes, Function.ID, argumentList, 1);\n        if (map != null) {\n          final List<Pair<Integer, PsiType>> errors = map.getErrors();\n          for (Pair<Integer, PsiType> error : errors) {\n            if (!(error.first == 0 && PsiImplUtil.hasNamedArguments(argumentList))) {\n              allErrors.add(error);\n            }\n          }\n        }\n      }\n\n      final ArrayList<LocalQuickFix> fixes = new ArrayList<LocalQuickFix>();\n      for (Pair<Integer, PsiType> error : allErrors) {\n        fixes.add(new ParameterCastFix(error.first, error.second));\n      }\n\n      return fixes.toArray(new LocalQuickFix[fixes.size()]);\n    }","commit_id":"a3804fa9881f9327c72387ac7f3f7afdd3a12977","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void highlightInapplicableMethodUsage(GroovyResolveResult methodResolveResult,\n                                                  GroovyPsiElement place,\n                                                  PsiMethod method,\n                                                  PsiType[] argumentTypes) {\n      final PsiClass containingClass =\n        method instanceof GrGdkMethod ? ((GrGdkMethod)method).getStaticMethod().getContainingClass() : method.getContainingClass();\n\n      if (containingClass == null) {\n        registerCannotApplyError(place, argumentTypes, method.getName());\n        return;\n      }\n      final String typesString = buildArgTypesList(argumentTypes);\n      final PsiElementFactory factory = JavaPsiFacade.getInstance(method.getProject()).getElementFactory();\n      final PsiClassType containingType = factory.createType(containingClass, methodResolveResult.getSubstitutor());\n      final String canonicalText = containingType.getInternalCanonicalText();\n      String message;\n      if (method.isConstructor()) {\n        message = GroovyBundle.message(\"cannot.apply.constructor\", method.getName(), canonicalText, typesString);\n      }\n      else {\n        message = GroovyBundle.message(\"cannot.apply.method1\", method.getName(), canonicalText, typesString);\n      }\n\n      registerError(getElementToHighlight(place, PsiUtil.getArgumentsList(place)), message,\n                    genCastFixes(GrClosureSignatureUtil.createSignature(methodResolveResult), argumentTypes, place),\n                    ProblemHighlightType.GENERIC_ERROR_OR_WARNING);\n    }","id":60865,"modified_method":"private void highlightInapplicableMethodUsage(GroovyResolveResult methodResolveResult,\n                                                  GroovyPsiElement place,\n                                                  PsiMethod method,\n                                                  PsiType[] argumentTypes) {\n      final PsiClass containingClass =\n        method instanceof GrGdkMethod ? ((GrGdkMethod)method).getStaticMethod().getContainingClass() : method.getContainingClass();\n\n      if (containingClass == null) {\n        registerCannotApplyError(place, argumentTypes, method.getName());\n        return;\n      }\n      final String typesString = buildArgTypesList(argumentTypes);\n      final PsiElementFactory factory = JavaPsiFacade.getInstance(method.getProject()).getElementFactory();\n      final PsiClassType containingType = factory.createType(containingClass, methodResolveResult.getSubstitutor());\n      final String canonicalText = containingType.getInternalCanonicalText();\n      String message;\n      if (method.isConstructor()) {\n        message = GroovyBundle.message(\"cannot.apply.constructor\", method.getName(), canonicalText, typesString);\n      }\n      else {\n        message = GroovyBundle.message(\"cannot.apply.method1\", method.getName(), canonicalText, typesString);\n      }\n\n      final GrArgumentList argumentsList = PsiUtil.getArgumentsList(place);\n      registerError(getElementToHighlight(place, argumentsList), message,\n                    genCastFixes(GrClosureSignatureUtil.createSignature(methodResolveResult), argumentTypes, argumentsList),\n                    ProblemHighlightType.GENERIC_ERROR_OR_WARNING);\n    }","commit_id":"a3804fa9881f9327c72387ac7f3f7afdd3a12977","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ParameterCastFix(int param, PsiType type) {\n    this.param = param;\n    myType = type;\n\n    StringBuilder builder = new StringBuilder();\n    builder.append(\"Cast \");\n\n    builder.append(param + 1);\n    switch (param + 1) {\n      case 1:\n        builder.append(\"st\");\n        break;\n      case 2:\n        builder.append(\"nd\");\n        break;\n      case 3:\n        builder.append(\"rd\");\n        break;\n      default:\n        builder.append(\"th\");\n        break;\n    }\n    builder.append(\" parameter to \").append(type.getCanonicalText());\n\n\n    myName = builder.toString();\n  }","id":60866,"modified_method":"public ParameterCastFix(int param, PsiType type) {\n    myParam = param;\n    myType = type;\n\n    StringBuilder builder = new StringBuilder();\n    builder.append(\"Cast \");\n\n    builder.append(param + 1);\n    switch (param + 1) {\n      case 1:\n        builder.append(\"st\");\n        break;\n      case 2:\n        builder.append(\"nd\");\n        break;\n      case 3:\n        builder.append(\"rd\");\n        break;\n      default:\n        builder.append(\"th\");\n        break;\n    }\n    builder.append(\" parameter to \").append(type.getCanonicalText());\n\n\n    myName = builder.toString();\n  }","commit_id":"a3804fa9881f9327c72387ac7f3f7afdd3a12977","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void doFix(Project project, ProblemDescriptor descriptor) throws IncorrectOperationException {\n    final PsiElement element = descriptor.getPsiElement();\n    final GrArgumentList list = element instanceof GrArgumentList ? (GrArgumentList)element :PsiUtil.getArgumentsList(element);\n    if (list == null) return;\n\n    final GrExpression[] arguments = list.getExpressionArguments();\n\n    final int p = list.getNamedArguments().length > 0 ? param - 1 : param;\n    if (arguments.length <= p) return;\n\n    GrCastFix.doCast(project, myType, arguments[p]);\n  }","id":60867,"modified_method":"@Override\n  protected void doFix(Project project, ProblemDescriptor descriptor) throws IncorrectOperationException {\n    final PsiElement element = descriptor.getPsiElement();\n    final GrArgumentList list = element instanceof GrArgumentList ? (GrArgumentList)element :PsiUtil.getArgumentsList(element);\n    if (list == null) return;\n\n    final GrExpression[] arguments = list.getExpressionArguments();\n\n    final int p = PsiImplUtil.hasNamedArguments(list) ? myParam - 1 : myParam;\n    if (arguments.length <= p) return;\n\n    GrCastFix.doCast(project, myType, arguments[p]);\n  }","commit_id":"a3804fa9881f9327c72387ac7f3f7afdd3a12977","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Run the validator on the given {@link Document}.\n     * \n     * @return results of the validation\n     * @throws\n     */\n    public List<ValidationError> validate()\n    {\n        validateRpd1s1();\n        validateRpd1s2();\n        validateRpd1s3();\n        validateRpd2s1();\n        validateRpd2s2();\n        validateRpd2s3();\n        validateRpd2s4();\n        validateRpd2s5();\n        validateRpd2s6();\n        validateRpd2s7();\n        validateRpd2s8();\n        validateRpd2s9();\n        validateRpd3s1();\n        validateRpd3s2();\n        validateRpd3s3();\n        validateRpd3s4();\n        validateRpd3s5();\n        validateRpd3s6();\n        validateRpd3s7();\n        validateRpd3s8();\n        validateRpd3s9();\n        validateRpd3s10();\n        validateRpd3s11();\n        validateRpd3s12();\n        validateRpd3s13();\n        validateRpd3s14();\n        validateRpd3s15();\n\n        return getErrors();\n    }","id":60868,"modified_method":"/**\n     * Run the validator on the given {@link Document}.\n     * \n     * @return results of the validation\n     * @throws\n     */\n    public List<ValidationError> validate()\n    {\n        // RPD 1\n        validateRpd1s1();\n        validateRpd1s2();\n        validateRpd1s3();\n\n        // RPD 2\n        validateRpd2s1();\n        validateRpd2s2();\n        validateRpd2s3();\n        validateRpd2s4();\n        validateRpd2s5();\n        validateRpd2s6();\n        validateRpd2s7();\n        validateRpd2s8();\n        validateRpd2s9();\n\n        // RPD 3\n        validateRpd3s1();\n        validateRpd3s2();\n        validateRpd3s3();\n        validateRpd3s4();\n        validateRpd3s5();\n        validateRpd3s6();\n        validateRpd3s7();\n        validateRpd3s8();\n        validateRpd3s9();\n        validateRpd3s10();\n        validateRpd3s11();\n        validateRpd3s12();\n        validateRpd3s13();\n        validateRpd3s14();\n        validateRpd3s15();\n\n        // RPD 4\n        validateRpd4s1();\n        validateRpd4s2();\n        validateRpd4s3();\n        validateRpd4s4();\n        validateRpd4s5();\n        validateRpd4s6();\n        validateRpd4s7();\n\n        // RPD 5\n        validateRpd5s1();\n\n        // RPD 6\n        validateRpd6s1();\n        validateRpd6s2();\n\n        // RPD 7\n        validateRpd7s1();\n        validateRpd7s2();\n        validateRpd7s3();\n        validateRpd7s4();\n        validateRpd7s5();\n        validateRpd7s6();\n        validateRpd7s7();\n\n        return getErrors();\n    }","commit_id":"4384cf6eccda10669e7031a706ac065919baaf1e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private String getErrors(DutchWebGuidelinesValidator validator)\n    {\n        return validator.getErrors().toString();\n    }","id":60869,"modified_method":"private String getErrors(DutchWebGuidelinesValidator validator)\n    {\n        StringBuffer buffer = new StringBuffer();\n        \n        for (ValidationError error : validator.getErrors()) {\n            buffer.append(error + \"\\n\");\n        }\n        \n        return buffer.toString();\n    }","commit_id":"4384cf6eccda10669e7031a706ac065919baaf1e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * When building a new website: only use the Strict version of HTML 4.01 or XHTML 1.0.\n     */\n    public void validateRpd2s4()\n    {\n        // Check doctype XHTML strict or HTML 4.01 strict\n    }","id":60870,"modified_method":"/**\n     * When building a new website: only use the Strict version of HTML 4.01 or XHTML 1.0.\n     */\n    public void validateRpd2s4()\n    {\n        // This guideline cannot be automatically tested, however we check that a DOCTYPE has been specified.\n        assertFalse(Type.ERROR, \"rpd2s4.noDoctype\", document.getDoctype() == null);\n    }","commit_id":"26caa39c018edd83bb789975912f5663ddbec9a7","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Write both grammatically correct and descriptive markup.\n     */\n    public void validateRpd3s1()\n    {\n        List<String> headings = Arrays.asList(\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\");\n\n        int previousLevel = 1;\n        for (Node element : getElements(headings)) {\n            int currentLevel = Integer.parseInt(element.getNodeName().substring(1));\n\n            // Verify that we haven't jumped from h1 to h3.\n            assertTrue(Type.ERROR, \"rpd3s1.headings\", currentLevel <= previousLevel + 1);\n            previousLevel = currentLevel;\n        }\n\n        // <b> and <i> are not allowed.\n        assertFalse(Type.ERROR, \"rpd3s1.boldMarkup\", containsElement(\"b\"));\n        assertFalse(Type.ERROR, \"rpd3s1.italicMarkup\", containsElement(\"i\"));\n    }","id":60871,"modified_method":"/**\n     * Write both grammatically correct and descriptive markup.\n     */\n    public void validateRpd3s1()\n    {\n        // <b> and <i> are not allowed.\n        assertFalse(Type.ERROR, \"rpd3s1.boldMarkup\", containsElement(\"b\"));\n        assertFalse(Type.ERROR, \"rpd3s1.italicMarkup\", containsElement(\"i\"));\n    }","commit_id":"26caa39c018edd83bb789975912f5663ddbec9a7","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * When modifying an existing website: only use the Transitional version of HTML 4.01 or XHTML 1.0 if it is not\n     * possible or desirable to use the Strict version.\n     */\n    public void validateRpd2s3()\n    {\n        // Check doctype XHTML strict or HTML 4.01 strict\n    }","id":60872,"modified_method":"/**\n     * When modifying an existing website: only use the Transitional version of HTML 4.01 or XHTML 1.0 if it is not\n     * possible or desirable to use the Strict version.\n     */\n    public void validateRpd2s3()\n    {\n        // This guideline cannot be automatically tested, however we check that a DOCTYPE has been specified.\n        assertFalse(Type.ERROR, \"rpd2s3.noDoctype\", document.getDoctype() == null);\n    }","commit_id":"26caa39c018edd83bb789975912f5663ddbec9a7","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Run the validator on the given {@link Document}.\n     * \n     * @return results of the validation\n     * @throws\n     */\n    public List<ValidationError> validate()\n    {\n        validateRpd1s1();\n        validateRpd1s2();\n        validateRpd1s3();\n        validateRpd2s1();\n        validateRpd2s2();\n        validateRpd2s3();\n        validateRpd2s4();\n        validateRpd2s5();\n        validateRpd2s6();\n        validateRpd2s7();\n        validateRpd2s8();\n        validateRpd2s9();\n        validateRpd3s1();\n\n        return getErrors();\n    }","id":60873,"modified_method":"/**\n     * Run the validator on the given {@link Document}.\n     * \n     * @return results of the validation\n     * @throws\n     */\n    public List<ValidationError> validate()\n    {\n        validateRpd1s1();\n        validateRpd1s2();\n        validateRpd1s3();\n        validateRpd2s1();\n        validateRpd2s2();\n        validateRpd2s3();\n        validateRpd2s4();\n        validateRpd2s5();\n        validateRpd2s6();\n        validateRpd2s7();\n        validateRpd2s8();\n        validateRpd2s9();\n        validateRpd3s1();\n        validateRpd3s2();\n        validateRpd3s3();\n        validateRpd3s4();\n        validateRpd3s5();\n        validateRpd3s6();\n        validateRpd3s7();\n        validateRpd3s8();\n        validateRpd3s9();\n        validateRpd3s10();\n        validateRpd3s11();\n        validateRpd3s12();\n        validateRpd3s13();\n        validateRpd3s14();\n        validateRpd3s15();\n\n        return getErrors();\n    }","commit_id":"26caa39c018edd83bb789975912f5663ddbec9a7","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void testRpd3s1HeadingsMissingLevel() throws Exception \n    {\n        setValidatorDocument(\"<body><h1><\/h1><h3><\/h3><\/body>\");\n        validator.validateRpd3s1();\n        assertFalse(getErrors(validator), isValid(validator));\n    }","id":60874,"modified_method":"public void testRpd3s3HeadingsMissingLevel() throws Exception\n    {\n        setValidatorDocument(\"<body><h1><\/h1><h3><\/h3><\/body>\");\n        validator.validateRpd3s3();\n        assertFalse(getErrors(validator), isValid(validator));\n    }","commit_id":"26caa39c018edd83bb789975912f5663ddbec9a7","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private boolean isValid(DutchWebGuidelinesValidator validator)\n    {\n        return validator.getErrors().isEmpty();\n    }","id":60875,"modified_method":"private boolean isValid(DutchWebGuidelinesValidator validator)\n    {\n        boolean isValid = true;\n        \n        for (ValidationError error : validator.getErrors()) {\n            if (error.getType() != Type.WARNING) {\n                isValid = false;\n            }\n        }\n        \n        return isValid;\n    }","commit_id":"26caa39c018edd83bb789975912f5663ddbec9a7","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void testValidate() throws Exception\n    {\n        setValidatorDocument(getClass().getResourceAsStream(\"/dwg-valid.html\"));\n        validator.validate();\n        assertTrue(getErrors(validator), isValid(validator));\n    }","id":60876,"modified_method":"public void testValidate() throws Exception\n    {\n        setValidatorDocument(getClass().getResourceAsStream(\"/dwg-valid.html\"));\n        validator.validate();\n        \n        for (ValidationError error : validator.getErrors()) {            \n            System.err.println(error);\n        }\n        \n        assertTrue(getErrors(validator), isValid(validator));\n    }","commit_id":"26caa39c018edd83bb789975912f5663ddbec9a7","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void testRpd2s5FramesetDoctype() throws Exception \n    {\n        setValidatorDocument(getClass().getResourceAsStream(\"/dwg-frame-framesetdoctype.html\"));\n        validator.validateRpd2s5();\n        assertFalse(getErrors(validator), isValid(validator));\n    }","id":60877,"modified_method":"public void testRpd2s5FramesetDoctype() throws Exception\n    {\n        setValidatorDocument(\"<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Frameset//EN' \"\n            + \"'http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd'><html><\/html>\");\n        validator.validateRpd2s5();\n        assertFalse(getErrors(validator), isValid(validator));\n    }","commit_id":"26caa39c018edd83bb789975912f5663ddbec9a7","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void testRpd3s1HeadingsValid() throws Exception \n    {\n        setValidatorDocument(\"<body><h1><\/h1><h2><\/h2><h2><\/h2><h3><\/h3><\/body>\");\n        validator.validateRpd3s1();\n        assertTrue(getErrors(validator), isValid(validator));\n    }","id":60878,"modified_method":"public void testRpd3s3HeadingsValid() throws Exception\n    {\n        setValidatorDocument(\"<body><h1><\/h1><h2><\/h2><h2><\/h2><h3><\/h3><\/body>\");\n        validator.validateRpd3s3();\n        assertTrue(getErrors(validator), isValid(validator));\n    }","commit_id":"26caa39c018edd83bb789975912f5663ddbec9a7","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private static SNode _quotation_createNode_puymhi_a0a0a0b0a0e0(Object parameter_1) {\n      PersistenceFacade facade = PersistenceFacade.getInstance();\n      SNode quotedNode_2 = null;\n      SNode quotedNode_3 = null;\n      SNode quotedNode_4 = null;\n      quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eb05cdc7L, \"jetbrains.mps.lang.editor.structure.CellModel_RefNode\"), null, null, false);\n      SNodeAccessUtil.setReferenceTarget(quotedNode_2, MetaAdapterFactory.getReferenceLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x10964446123L, 0x10973779681L, \"relationDeclaration\"), (SNode) parameter_1);\n      quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x120154df6f3L, \"jetbrains.mps.lang.editor.structure.IndentLayoutNewLineStyleClassItem\"), null, null, false);\n      SNodeAccessUtil.setProperty(quotedNode_3, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x1143bd1283bL, 0x1143bd161dbL, \"flag\"), \"true\");\n      quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x11beb039542L, 0x11beb040d06L, \"styleItem\"), quotedNode_3);\n      quotedNode_4 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x120154c4089L, \"jetbrains.mps.lang.editor.structure.IndentLayoutIndentStyleClassItem\"), null, null, false);\n      SNodeAccessUtil.setProperty(quotedNode_4, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x1143bd1283bL, 0x1143bd161dbL, \"flag\"), \"true\");\n      quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x11beb039542L, 0x11beb040d06L, \"styleItem\"), quotedNode_4);\n      return quotedNode_2;\n    }","id":60879,"modified_method":"private static SNode _quotation_createNode_puymhi_a0a0a0a0a0e0(Object parameter_1) {\n      PersistenceFacade facade = PersistenceFacade.getInstance();\n      SNode quotedNode_2 = null;\n      SNode quotedNode_3 = null;\n      quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eb01232eL, \"jetbrains.mps.lang.editor.structure.CellModel_Constant\"), null, null, false);\n      SNodeAccessUtil.setProperty(quotedNode_2, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eb01232eL, 0xf9eb01232fL, \"text\"), (String) parameter_1);\n      quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x120154df6f3L, \"jetbrains.mps.lang.editor.structure.IndentLayoutNewLineStyleClassItem\"), null, null, false);\n      SNodeAccessUtil.setProperty(quotedNode_3, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x1143bd1283bL, 0x1143bd161dbL, \"flag\"), \"true\");\n      quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x11beb039542L, 0x11beb040d06L, \"styleItem\"), quotedNode_3);\n      return quotedNode_2;\n    }","commit_id":"0e73e2b09afed8d88e97afa9c19c6771f64d6d65","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_puymhi_a0a0a0a1a0a4a(Object parameter_1) {\n      PersistenceFacade facade = PersistenceFacade.getInstance();\n      SNode quotedNode_2 = null;\n      SNode quotedNode_3 = null;\n      SNode quotedNode_4 = null;\n      SNode quotedNode_5 = null;\n      quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eb0ad38eL, \"jetbrains.mps.lang.editor.structure.CellModel_RefNodeList\"), null, null, false);\n      SNodeAccessUtil.setReferenceTarget(quotedNode_2, MetaAdapterFactory.getReferenceLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x10964446123L, 0x10973779681L, \"relationDeclaration\"), (SNode) parameter_1);\n      quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x120154df6f3L, \"jetbrains.mps.lang.editor.structure.IndentLayoutNewLineStyleClassItem\"), null, null, false);\n      SNodeAccessUtil.setProperty(quotedNode_3, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x1143bd1283bL, 0x1143bd161dbL, \"flag\"), \"true\");\n      quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x11beb039542L, 0x11beb040d06L, \"styleItem\"), quotedNode_3);\n      quotedNode_4 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x120154c4089L, \"jetbrains.mps.lang.editor.structure.IndentLayoutIndentStyleClassItem\"), null, null, false);\n      SNodeAccessUtil.setProperty(quotedNode_4, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x1143bd1283bL, 0x1143bd161dbL, \"flag\"), \"true\");\n      quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x11beb039542L, 0x11beb040d06L, \"styleItem\"), quotedNode_4);\n      quotedNode_5 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x120150bb441L, \"jetbrains.mps.lang.editor.structure.CellLayout_Indent\"), null, null, false);\n      quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x1098c8cf48aL, 0x1098c8e38e8L, \"cellLayout\"), quotedNode_5);\n      return quotedNode_2;\n    }","id":60880,"modified_method":"private static SNode _quotation_createNode_puymhi_a0a0a0a0a0a4a(Object parameter_1) {\n      PersistenceFacade facade = PersistenceFacade.getInstance();\n      SNode quotedNode_2 = null;\n      SNode quotedNode_3 = null;\n      quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eb01232eL, \"jetbrains.mps.lang.editor.structure.CellModel_Constant\"), null, null, false);\n      SNodeAccessUtil.setProperty(quotedNode_2, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eb01232eL, 0xf9eb01232fL, \"text\"), (String) parameter_1);\n      quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x120154df6f3L, \"jetbrains.mps.lang.editor.structure.IndentLayoutNewLineStyleClassItem\"), null, null, false);\n      SNodeAccessUtil.setProperty(quotedNode_3, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x1143bd1283bL, 0x1143bd161dbL, \"flag\"), \"true\");\n      quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x11beb039542L, 0x11beb040d06L, \"styleItem\"), quotedNode_3);\n      return quotedNode_2;\n    }","commit_id":"0e73e2b09afed8d88e97afa9c19c6771f64d6d65","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_puymhi_a0a0a1a0a4a(Object parameter_1) {\n      PersistenceFacade facade = PersistenceFacade.getInstance();\n      SNode quotedNode_2 = null;\n      SNode quotedNode_3 = null;\n      SNode quotedNode_4 = null;\n      quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xfd52a2c922L, \"jetbrains.mps.lang.editor.structure.CellModel_RefCell\"), null, null, false);\n      SNodeAccessUtil.setReferenceTarget(quotedNode_2, MetaAdapterFactory.getReferenceLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x10964446123L, 0x10973779681L, \"relationDeclaration\"), (SNode) parameter_1);\n      quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x120154df6f3L, \"jetbrains.mps.lang.editor.structure.IndentLayoutNewLineStyleClassItem\"), null, null, false);\n      SNodeAccessUtil.setProperty(quotedNode_3, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x1143bd1283bL, 0x1143bd161dbL, \"flag\"), \"true\");\n      quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x11beb039542L, 0x11beb040d06L, \"styleItem\"), quotedNode_3);\n      quotedNode_4 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x120154c4089L, \"jetbrains.mps.lang.editor.structure.IndentLayoutIndentStyleClassItem\"), null, null, false);\n      SNodeAccessUtil.setProperty(quotedNode_4, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x1143bd1283bL, 0x1143bd161dbL, \"flag\"), \"true\");\n      quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x11beb039542L, 0x11beb040d06L, \"styleItem\"), quotedNode_4);\n      return quotedNode_2;\n    }","id":60881,"modified_method":"private static SNode _quotation_createNode_puymhi_a0a0a0a0a4a(Object parameter_1) {\n      PersistenceFacade facade = PersistenceFacade.getInstance();\n      SNode quotedNode_2 = null;\n      SNode quotedNode_3 = null;\n      SNode quotedNode_4 = null;\n      quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xfd52a2c922L, \"jetbrains.mps.lang.editor.structure.CellModel_RefCell\"), null, null, false);\n      SNodeAccessUtil.setReferenceTarget(quotedNode_2, MetaAdapterFactory.getReferenceLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x10964446123L, 0x10973779681L, \"relationDeclaration\"), (SNode) parameter_1);\n      quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x120154df6f3L, \"jetbrains.mps.lang.editor.structure.IndentLayoutNewLineStyleClassItem\"), null, null, false);\n      SNodeAccessUtil.setProperty(quotedNode_3, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x1143bd1283bL, 0x1143bd161dbL, \"flag\"), \"true\");\n      quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x11beb039542L, 0x11beb040d06L, \"styleItem\"), quotedNode_3);\n      quotedNode_4 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x120154c4089L, \"jetbrains.mps.lang.editor.structure.IndentLayoutIndentStyleClassItem\"), null, null, false);\n      SNodeAccessUtil.setProperty(quotedNode_4, MetaAdapterFactory.getProperty(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x1143bd1283bL, 0x1143bd161dbL, \"flag\"), \"true\");\n      quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x11beb039542L, 0x11beb040d06L, \"styleItem\"), quotedNode_4);\n      return quotedNode_2;\n    }","commit_id":"0e73e2b09afed8d88e97afa9c19c6771f64d6d65","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n      public void execute(@NotNull String pattern) {\n        SNodeOperations.insertNextSiblingChild(_context.getNode(), _quotation_createNode_puymhi_a0a0a0f0());\n      }","id":60882,"modified_method":"@Override\n      public void execute(@NotNull String pattern) {\n        SNode topLevelCollection = ListSequence.fromList(SNodeOperations.getNodeAncestors(_context.getNode(), MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eaff2517L, \"jetbrains.mps.lang.editor.structure.CellModel_Collection\"), true)).last();\n        ListSequence.fromList(SLinkOperations.getChildren(topLevelCollection, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eaff2517L, 0xf9eaff2518L, \"childCellModel\"))).addElement(_quotation_createNode_puymhi_a0a1a0f0());\n      }","commit_id":"0e73e2b09afed8d88e97afa9c19c6771f64d6d65","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n      public void execute(@NotNull String pattern) {\n        SNode newCell;\n        if (SPropertyOperations.hasValue(myParameterObject, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf980556927L, \"metaClass\"), \"aggregation\", \"reference\")) {\n          if ((boolean) LinkDeclaration__BehaviorDescriptor.isSingular_idhEwIfAt.invoke(myParameterObject)) {\n            newCell = _quotation_createNode_puymhi_a0a0a0b0a0e0(myParameterObject);\n          } else {\n            newCell = _quotation_createNode_puymhi_a0a0a0a1a0a4a(myParameterObject);\n          }\n        } else {\n          SNode refCell = _quotation_createNode_puymhi_a0a0a1a0a4a(myParameterObject);\n          SLinkOperations.setTarget(SLinkOperations.getTarget(refCell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xfd52a2c922L, 0xfd5cf2df2aL, \"editorComponent\")), MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xfba0eb7c50L, 0xfba0ec5415L, \"cellModel\"), SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x8ace515f0191e6eL, \"jetbrains.mps.lang.editor.structure.CellModel_ReferencePresentation\")));\n          newCell = refCell;\n        }\n        SNodeOperations.replaceWithAnother(_context.getNode(), newCell);\n      }","id":60883,"modified_method":"@Override\n      public void execute(@NotNull String pattern) {\n        if (SPropertyOperations.hasValue(myParameterObject, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf980556927L, \"metaClass\"), \"aggregation\", \"reference\")) {\n          if ((boolean) LinkDeclaration__BehaviorDescriptor.isSingular_idhEwIfAt.invoke(myParameterObject)) {\n            SNode label = _quotation_createNode_puymhi_a0a0a0a0a0e0(SPropertyOperations.getString(myParameterObject, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98052f333L, \"role\")) + \":\");\n            SNodeOperations.replaceWithAnother(_context.getNode(), label);\n            SNodeOperations.insertNextSiblingChild(label, _quotation_createNode_puymhi_a0a2a0a0a0a4a(myParameterObject));\n          } else {\n            SNode label = _quotation_createNode_puymhi_a0a0a0a0a0a4a(SPropertyOperations.getString(myParameterObject, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98052f333L, \"role\")) + \":\");\n            SNodeOperations.replaceWithAnother(_context.getNode(), label);\n            SNodeOperations.insertNextSiblingChild(label, _quotation_createNode_puymhi_a0a2a0a0a0a0e0(myParameterObject));\n          }\n        } else {\n          SNode refCell = _quotation_createNode_puymhi_a0a0a0a0a4a(myParameterObject);\n          SNodeOperations.replaceWithAnother(_context.getNode(), refCell);\n          SNode inlineComponent = SNodeFactoryOperations.createNewNode(SNodeFactoryOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xfd5cee772bL, \"jetbrains.mps.lang.editor.structure.InlineEditorComponent\")), null);\n          SLinkOperations.setTarget(refCell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xfd52a2c922L, 0xfd5cf2df2aL, \"editorComponent\"), inlineComponent);\n          SLinkOperations.setTarget(SLinkOperations.getTarget(refCell, MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xfd52a2c922L, 0xfd5cf2df2aL, \"editorComponent\")), MetaAdapterFactory.getContainmentLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xfba0eb7c50L, 0xfba0ec5415L, \"cellModel\"), SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x8ace515f0191e6eL, \"jetbrains.mps.lang.editor.structure.CellModel_ReferencePresentation\")));\n        }\n      }","commit_id":"0e73e2b09afed8d88e97afa9c19c6771f64d6d65","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_puymhi_a0a0a0f0() {\n      PersistenceFacade facade = PersistenceFacade.getInstance();\n      SNode quotedNode_1 = null;\n      quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, \"jetbrains.mps.lang.editor.structure.EditorCellModel\"), null, null, false);\n      return quotedNode_1;\n    }","id":60884,"modified_method":"private static SNode _quotation_createNode_puymhi_a0a1a0f0() {\n      PersistenceFacade facade = PersistenceFacade.getInstance();\n      SNode quotedNode_1 = null;\n      quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9eafb9a39L, \"jetbrains.mps.lang.editor.structure.EditorCellModel\"), null, null, false);\n      return quotedNode_1;\n    }","commit_id":"0e73e2b09afed8d88e97afa9c19c6771f64d6d65","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doRefactor() {\n    this.collectInformation();\n    SNode innerClass = this.makeInnerClass();\n    SNodeOperations.replaceWithAnother(this.myClassToRefactor, this.makeInnerConstructorInvocation(ListSequence.fromList(SLinkOperations.getTargets(innerClass, \"constructor\", true)).getElement(0)));\n  }","id":60885,"modified_method":"public void doRefactor() {\n    collectInformation();\n    SNode creator = SNodeOperations.as(SNodeOperations.getParent(myClassToRefactor), \"jetbrains.mps.baseLanguage.structure.AnonymousClassCreator\");\n    if ((creator != null)) {\n      SNodeOperations.replaceWithAnother(creator, makeInnerConstructorInvocation(ListSequence.fromList(SLinkOperations.getTargets(makeInnerClass(), \"constructor\", true)).getElement(0)));\n    }\n  }","commit_id":"858cfb30e37865c36cc91c611af587641c583afe","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute(final SNode node, final EditorContext editorContext) {\n    SNode methodNode = new _Quotations.QuotationClass_14().createNode();\n    SLinkOperations.addChild(node, \"staticMethod\", methodNode);\n    editorContext.select(methodNode);\n  }","id":60886,"modified_method":"public void execute(final SNode node, final EditorContext editorContext) {\n    SNode methodNode = new _Quotations.QuotationClass_15().createNode();\n    SLinkOperations.addChild(node, \"staticMethod\", methodNode);\n    editorContext.select(methodNode);\n  }","commit_id":"d3a4d643f005e41bce10f968e609823209fc7168","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute(final SNode node, final EditorContext editorContext) {\n    SNode classifier = CreateMethodDeclarationUtil.getClassifier(node);\n    boolean isSameClassifier = SNodeOperations.getAncestor(node, \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false) == classifier;\n    final String name = CreateMethodDeclarationUtil.getMethodName(editorContext);\n    SNode method = new _Quotations.QuotationClass_15().createNode(name);\n    if (!(isSameClassifier)) {\n      SLinkOperations.setTarget(method, \"visibility\", new _Quotations.QuotationClass_17().createNode(), true);\n    }\n    SLinkOperations.addChild(classifier, \"method\", method);\n    SNodeOperations.replaceWithAnother(node, new _Quotations.QuotationClass_16().createNode(method));\n    if (isSameClassifier) {\n      editorContext.selectWRTFocusPolicy(method);\n    } else {\n      IOperationContext operationContext = editorContext.getOperationContext();\n      IEditor editor = operationContext.getComponent(MPSEditorOpener.class).editNode(classifier, operationContext);\n      editor.getEditorContext().selectWRTFocusPolicy(method);\n    }\n  }","id":60887,"modified_method":"public void execute(final SNode node, final EditorContext editorContext) {\n    SNode classifier = CreateMethodDeclarationUtil.getClassifier(node);\n    boolean isSameClassifier = SNodeOperations.getAncestor(node, \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false) == classifier;\n    final String name = CreateMethodDeclarationUtil.getMethodName(editorContext);\n    SNode type;\n    if (SNodeOperations.isInstanceOf(TypeChecker.getInstance().getTypeOf(node), \"jetbrains.mps.baseLanguage.structure.Type\")) {\n      type = SNodeOperations.cast(TypeChecker.getInstance().getTypeOf(node), \"jetbrains.mps.baseLanguage.structure.Type\");\n    } else {\n      type = new _Quotations.QuotationClass_12().createNode();\n    }\n    SNode method = new _Quotations.QuotationClass_16().createNode(type, name);\n    if (!(isSameClassifier)) {\n      SLinkOperations.setTarget(method, \"visibility\", new _Quotations.QuotationClass_18().createNode(), true);\n    }\n    SLinkOperations.addChild(classifier, \"method\", method);\n    SNodeOperations.replaceWithAnother(node, new _Quotations.QuotationClass_17().createNode(method));\n    if (isSameClassifier) {\n      editorContext.selectWRTFocusPolicy(method);\n    } else {\n      IOperationContext operationContext = editorContext.getOperationContext();\n      IEditor editor = operationContext.getComponent(MPSEditorOpener.class).editNode(classifier, operationContext);\n      editor.getEditorContext().selectWRTFocusPolicy(method);\n    }\n  }","commit_id":"d3a4d643f005e41bce10f968e609823209fc7168","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute(final SNode node, final EditorContext editorContext) {\n    final SNode classConcept = SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\");\n    final List<SNode> fields = SLinkOperations.getTargets(classConcept, \"field\", true);\n    final SNode thisExp = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.ThisExpression\", null);\n    final SNode equalsDeclaration = new _Quotations.QuotationClass_13().createNode(thisExp, thisExp, classConcept, classConcept);\n    SNode thatDeclaration = SLinkOperations.getTarget(SNodeOperations.cast(ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(equalsDeclaration, \"body\", true), \"statement\", true)).last(), \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclarationStatement\"), \"localVariableDeclaration\", true);\n\n    SNode thatRef = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.LocalVariableReference\", null);\n    SLinkOperations.setTarget(thatRef, \"variableDeclaration\", thatDeclaration, false);\n    SNode fieldRefOperation = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.FieldReferenceOperation\", null);\n    for (SNode field : fields) {\n      SLinkOperations.setTarget(fieldRefOperation, \"fieldDeclaration\", field, false);\n      SNode checkStmt;\n      if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(field, \"type\", true), \"jetbrains.mps.baseLanguage.structure.PrimitiveType\")) {\n        if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(field, \"type\", true), \"jetbrains.mps.baseLanguage.structure.FloatType\")) {\n          checkStmt = new _Quotations.QuotationClass_18().createNode(thatRef, SNodeOperations.copyNode(fieldRefOperation), thisExp, SNodeOperations.copyNode(fieldRefOperation));\n        } else if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(field, \"type\", true), \"jetbrains.mps.baseLanguage.structure.DoubleType\")) {\n          checkStmt = new _Quotations.QuotationClass_19().createNode(thatRef, SNodeOperations.copyNode(fieldRefOperation), thisExp, SNodeOperations.copyNode(fieldRefOperation));\n        } else {\n          checkStmt = new _Quotations.QuotationClass_12().createNode(thatRef, SNodeOperations.copyNode(fieldRefOperation), thisExp, SNodeOperations.copyNode(fieldRefOperation));\n        }\n      } else if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(field, \"type\", true), \"jetbrains.mps.baseLanguage.structure.ArrayType\")) {\n        checkStmt = new _Quotations.QuotationClass_10().createNode(thisExp, fieldRefOperation, thatRef, fieldRefOperation);\n      } else {\n        checkStmt = new _Quotations.QuotationClass_11().createNode(thatRef, SNodeOperations.copyNode(fieldRefOperation), thisExp, SNodeOperations.copyNode(fieldRefOperation), thisExp, SNodeOperations.copyNode(fieldRefOperation), thatRef, SNodeOperations.copyNode(fieldRefOperation));\n      }\n      SLinkOperations.addChild(SLinkOperations.getTarget(equalsDeclaration, \"body\", true), \"statement\", checkStmt);\n    }\n    SLinkOperations.addNewChild(SLinkOperations.getTarget(equalsDeclaration, \"body\", true), \"statement\", \"jetbrains.mps.baseLanguage.structure.Statement\");\n    SLinkOperations.addChild(SLinkOperations.getTarget(equalsDeclaration, \"body\", true), \"statement\", new _Quotations.QuotationClass_35().createNode());\n    SLinkOperations.addChild(classConcept, \"method\", equalsDeclaration);\n    // Method equals() is generated, now hashCode method body generation begins  \n    SNode hashCodeDeclaration = SLinkOperations.addChild(classConcept, \"method\", new _Quotations.QuotationClass_31().createNode());\n    SNode resultDeclaration = new _Quotations.QuotationClass_8().createNode();\n    SNode resultReference = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.LocalVariableReference\", null);\n    SLinkOperations.setTarget(resultReference, \"variableDeclaration\", SLinkOperations.getTarget(resultDeclaration, \"localVariableDeclaration\", true), false);\n    SNode tempDeclaration = new _Quotations.QuotationClass_20().createNode();\n    SNode tempReference = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.LocalVariableReference\", null);\n    SLinkOperations.setTarget(tempReference, \"variableDeclaration\", SLinkOperations.getTarget(tempDeclaration, \"localVariableDeclaration\", true), false);\n    if (ListSequence.fromList(SLinkOperations.getTargets(classConcept, \"field\", true)).any(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, \"type\", true), \"jetbrains.mps.baseLanguage.structure.DoubleType\");\n      }\n    })) {\n      SLinkOperations.addChild(SLinkOperations.getTarget(hashCodeDeclaration, \"body\", true), \"statement\", tempDeclaration);\n    }\n    SLinkOperations.addChild(SLinkOperations.getTarget(hashCodeDeclaration, \"body\", true), \"statement\", resultDeclaration);\n    int i = 239;\n    for (final SNode field : fields) {\n      SLinkOperations.setTarget(fieldRefOperation, \"fieldDeclaration\", field, false);\n      SNode calcStatement = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.Statement\", null);\n      SNode plusExpression = new _Quotations.QuotationClass_24().createNode(resultReference);\n      if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(field, \"type\", true), \"jetbrains.mps.baseLanguage.structure.IntegerType\")) {\n        calcStatement = new _Quotations.QuotationClass_30().createNode(resultReference, thisExp, field, plusExpression);\n      } else if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(field, \"type\", true), \"jetbrains.mps.baseLanguage.structure.ByteType\") || SNodeOperations.isInstanceOf(SLinkOperations.getTarget(field, \"type\", true), \"jetbrains.mps.baseLanguage.structure.CharType\")) {\n        calcStatement = new _Quotations.QuotationClass_23().createNode(thisExp, fieldRefOperation, plusExpression, resultReference);\n      } else if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(field, \"type\", true), \"jetbrains.mps.baseLanguage.structure.DoubleType\")) {\n        SLinkOperations.addChild(SLinkOperations.getTarget(hashCodeDeclaration, \"body\", true), \"statement\", new _Quotations.QuotationClass_22().createNode(tempReference, thisExp, fieldRefOperation, thisExp, fieldRefOperation));\n        calcStatement = new _Quotations.QuotationClass_21().createNode(resultReference, plusExpression, tempReference, tempReference);\n      } else if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(field, \"type\", true), \"jetbrains.mps.baseLanguage.structure.FloatType\")) {\n        calcStatement = new _Quotations.QuotationClass_36().createNode(resultReference, plusExpression, thisExp, field, thisExp, field);\n      } else if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(field, \"type\", true), \"jetbrains.mps.baseLanguage.structure.StringType\")) {\n        calcStatement = new _Quotations.QuotationClass_37().createNode(resultReference, plusExpression, fieldRefOperation, fieldRefOperation);\n      } else if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(field, \"type\", true), \"jetbrains.mps.baseLanguage.structure.ArrayType\")) {\n        calcStatement = new _Quotations.QuotationClass_38().createNode(plusExpression, thisExp, fieldRefOperation, thisExp, fieldRefOperation, resultReference);\n      } else {\n        calcStatement = new _Quotations.QuotationClass_39().createNode(thisExp, fieldRefOperation, thisExp, fieldRefOperation, plusExpression, resultReference);\n      }\n      SLinkOperations.addChild(SLinkOperations.getTarget(hashCodeDeclaration, \"body\", true), \"statement\", calcStatement);\n    }\n    SLinkOperations.addChild(SLinkOperations.getTarget(hashCodeDeclaration, \"body\", true), \"statement\", new _Quotations.QuotationClass_9().createNode(resultReference));\n  }","id":60888,"modified_method":"public void execute(final SNode node, final EditorContext editorContext) {\n    final SNode classConcept = SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\");\n    final List<SNode> fields = SLinkOperations.getTargets(classConcept, \"field\", true);\n    final SNode thisExp = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.ThisExpression\", null);\n    final SNode equalsDeclaration = new _Quotations.QuotationClass_14().createNode(thisExp, thisExp, classConcept, classConcept);\n    SNode thatDeclaration = SLinkOperations.getTarget(SNodeOperations.cast(ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(equalsDeclaration, \"body\", true), \"statement\", true)).last(), \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclarationStatement\"), \"localVariableDeclaration\", true);\n\n    SNode thatRef = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.LocalVariableReference\", null);\n    SLinkOperations.setTarget(thatRef, \"variableDeclaration\", thatDeclaration, false);\n    SNode fieldRefOperation = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.FieldReferenceOperation\", null);\n    for (SNode field : fields) {\n      SLinkOperations.setTarget(fieldRefOperation, \"fieldDeclaration\", field, false);\n      SNode checkStmt;\n      if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(field, \"type\", true), \"jetbrains.mps.baseLanguage.structure.PrimitiveType\")) {\n        if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(field, \"type\", true), \"jetbrains.mps.baseLanguage.structure.FloatType\")) {\n          checkStmt = new _Quotations.QuotationClass_19().createNode(thatRef, SNodeOperations.copyNode(fieldRefOperation), thisExp, SNodeOperations.copyNode(fieldRefOperation));\n        } else if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(field, \"type\", true), \"jetbrains.mps.baseLanguage.structure.DoubleType\")) {\n          checkStmt = new _Quotations.QuotationClass_20().createNode(thatRef, SNodeOperations.copyNode(fieldRefOperation), thisExp, SNodeOperations.copyNode(fieldRefOperation));\n        } else {\n          checkStmt = new _Quotations.QuotationClass_13().createNode(thatRef, SNodeOperations.copyNode(fieldRefOperation), thisExp, SNodeOperations.copyNode(fieldRefOperation));\n        }\n      } else if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(field, \"type\", true), \"jetbrains.mps.baseLanguage.structure.ArrayType\")) {\n        checkStmt = new _Quotations.QuotationClass_10().createNode(thisExp, fieldRefOperation, thatRef, fieldRefOperation);\n      } else {\n        checkStmt = new _Quotations.QuotationClass_11().createNode(thatRef, SNodeOperations.copyNode(fieldRefOperation), thisExp, SNodeOperations.copyNode(fieldRefOperation), thisExp, SNodeOperations.copyNode(fieldRefOperation), thatRef, SNodeOperations.copyNode(fieldRefOperation));\n      }\n      SLinkOperations.addChild(SLinkOperations.getTarget(equalsDeclaration, \"body\", true), \"statement\", checkStmt);\n    }\n    SLinkOperations.addNewChild(SLinkOperations.getTarget(equalsDeclaration, \"body\", true), \"statement\", \"jetbrains.mps.baseLanguage.structure.Statement\");\n    SLinkOperations.addChild(SLinkOperations.getTarget(equalsDeclaration, \"body\", true), \"statement\", new _Quotations.QuotationClass_36().createNode());\n    SLinkOperations.addChild(classConcept, \"method\", equalsDeclaration);\n    // Method equals() is generated, now hashCode method body generation begins  \n    SNode hashCodeDeclaration = SLinkOperations.addChild(classConcept, \"method\", new _Quotations.QuotationClass_32().createNode());\n    SNode resultDeclaration = new _Quotations.QuotationClass_8().createNode();\n    SNode resultReference = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.LocalVariableReference\", null);\n    SLinkOperations.setTarget(resultReference, \"variableDeclaration\", SLinkOperations.getTarget(resultDeclaration, \"localVariableDeclaration\", true), false);\n    SNode tempDeclaration = new _Quotations.QuotationClass_21().createNode();\n    SNode tempReference = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.LocalVariableReference\", null);\n    SLinkOperations.setTarget(tempReference, \"variableDeclaration\", SLinkOperations.getTarget(tempDeclaration, \"localVariableDeclaration\", true), false);\n    if (ListSequence.fromList(SLinkOperations.getTargets(classConcept, \"field\", true)).any(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, \"type\", true), \"jetbrains.mps.baseLanguage.structure.DoubleType\");\n      }\n    })) {\n      SLinkOperations.addChild(SLinkOperations.getTarget(hashCodeDeclaration, \"body\", true), \"statement\", tempDeclaration);\n    }\n    SLinkOperations.addChild(SLinkOperations.getTarget(hashCodeDeclaration, \"body\", true), \"statement\", resultDeclaration);\n    int i = 239;\n    for (final SNode field : fields) {\n      SLinkOperations.setTarget(fieldRefOperation, \"fieldDeclaration\", field, false);\n      SNode calcStatement = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.Statement\", null);\n      SNode plusExpression = new _Quotations.QuotationClass_25().createNode(resultReference);\n      if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(field, \"type\", true), \"jetbrains.mps.baseLanguage.structure.IntegerType\")) {\n        calcStatement = new _Quotations.QuotationClass_31().createNode(resultReference, thisExp, field, plusExpression);\n      } else if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(field, \"type\", true), \"jetbrains.mps.baseLanguage.structure.ByteType\") || SNodeOperations.isInstanceOf(SLinkOperations.getTarget(field, \"type\", true), \"jetbrains.mps.baseLanguage.structure.CharType\")) {\n        calcStatement = new _Quotations.QuotationClass_24().createNode(thisExp, fieldRefOperation, plusExpression, resultReference);\n      } else if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(field, \"type\", true), \"jetbrains.mps.baseLanguage.structure.DoubleType\")) {\n        SLinkOperations.addChild(SLinkOperations.getTarget(hashCodeDeclaration, \"body\", true), \"statement\", new _Quotations.QuotationClass_23().createNode(tempReference, thisExp, fieldRefOperation, thisExp, fieldRefOperation));\n        calcStatement = new _Quotations.QuotationClass_22().createNode(resultReference, plusExpression, tempReference, tempReference);\n      } else if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(field, \"type\", true), \"jetbrains.mps.baseLanguage.structure.FloatType\")) {\n        calcStatement = new _Quotations.QuotationClass_37().createNode(resultReference, plusExpression, thisExp, field, thisExp, field);\n      } else if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(field, \"type\", true), \"jetbrains.mps.baseLanguage.structure.StringType\")) {\n        calcStatement = new _Quotations.QuotationClass_38().createNode(resultReference, plusExpression, fieldRefOperation, fieldRefOperation);\n      } else if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(field, \"type\", true), \"jetbrains.mps.baseLanguage.structure.ArrayType\")) {\n        calcStatement = new _Quotations.QuotationClass_39().createNode(plusExpression, thisExp, fieldRefOperation, thisExp, fieldRefOperation, resultReference);\n      } else {\n        calcStatement = new _Quotations.QuotationClass_40().createNode(thisExp, fieldRefOperation, thisExp, fieldRefOperation, plusExpression, resultReference);\n      }\n      SLinkOperations.addChild(SLinkOperations.getTarget(hashCodeDeclaration, \"body\", true), \"statement\", calcStatement);\n    }\n    SLinkOperations.addChild(SLinkOperations.getTarget(hashCodeDeclaration, \"body\", true), \"statement\", new _Quotations.QuotationClass_9().createNode(resultReference));\n  }","commit_id":"d3a4d643f005e41bce10f968e609823209fc7168","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute(final SNode node, final EditorContext editorContext) {\n    SNode classConcept = SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\");\n    List<SNode> fields = SLinkOperations.getTargets(classConcept, \"field\", true);\n    for (final SNode field : fields) {\n      final String getterName = \"get\" + NameUtil.capitalize(SPropertyOperations.getString(field, \"name\"));\n      if (ListSequence.fromList(SLinkOperations.getTargets(classConcept, \"method\", true)).any(new IWhereFilter<SNode>() {\n        public boolean accept(SNode method) {\n          return getterName.equals(SPropertyOperations.getString(method, \"name\")) && ListSequence.fromList(SLinkOperations.getTargets(method, \"parameter\", true)).isEmpty();\n        }\n      })) {\n        continue;\n      }\n      // Method creation begins \n      Pair p;\n      final SNode thisExpression = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.ThisExpression\", null);\n      SLinkOperations.addChild(classConcept, \"method\", new _Quotations.QuotationClass_27().createNode(SLinkOperations.getTarget(field, \"type\", true), thisExpression, field, getterName));\n    }\n  }","id":60889,"modified_method":"public void execute(final SNode node, final EditorContext editorContext) {\n    SNode classConcept = SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\");\n    List<SNode> fields = SLinkOperations.getTargets(classConcept, \"field\", true);\n    for (final SNode field : fields) {\n      final String getterName = \"get\" + NameUtil.capitalize(SPropertyOperations.getString(field, \"name\"));\n      if (ListSequence.fromList(SLinkOperations.getTargets(classConcept, \"method\", true)).any(new IWhereFilter<SNode>() {\n        public boolean accept(SNode method) {\n          return getterName.equals(SPropertyOperations.getString(method, \"name\")) && ListSequence.fromList(SLinkOperations.getTargets(method, \"parameter\", true)).isEmpty();\n        }\n      })) {\n        continue;\n      }\n      // Method creation begins \n      Pair p;\n      final SNode thisExpression = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.ThisExpression\", null);\n      SLinkOperations.addChild(classConcept, \"method\", new _Quotations.QuotationClass_28().createNode(SLinkOperations.getTarget(field, \"type\", true), thisExpression, field, getterName));\n    }\n  }","commit_id":"d3a4d643f005e41bce10f968e609823209fc7168","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute(final SNode node, final EditorContext editorContext) {\n    SNode classConcept = SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\");\n    List<SNode> fields = SLinkOperations.getTargets(classConcept, \"field\", true);\n    Pair p;\n    final SNode thisExpression = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.ThisExpression\", null);\n    for (final SNode field : fields) {\n      final String getterName = \"get\" + NameUtil.capitalize(SPropertyOperations.getString(field, \"name\"));\n      final Wrappers._boolean getterIsAbsent = new Wrappers._boolean(true);\n      ListSequence.fromList(SLinkOperations.getTargets(classConcept, \"method\", true)).visitAll(new IVisitor<SNode>() {\n        public void visit(SNode it) {\n          if (getterName.equals(SPropertyOperations.getString(it, \"name\")) && ListSequence.fromList(SLinkOperations.getTargets(it, \"parameter\", true)).isEmpty()) {\n            getterIsAbsent.value = false;\n          }\n        }\n      });\n      if (getterIsAbsent.value) {\n        SLinkOperations.addChild(classConcept, \"method\", new _Quotations.QuotationClass_28().createNode(SLinkOperations.getTarget(field, \"type\", true), thisExpression, field, getterName));\n      }\n\n      final String setterName = \"set\" + NameUtil.capitalize(SPropertyOperations.getString(field, \"name\"));\n      final Wrappers._boolean setterIsAbsent = new Wrappers._boolean(true);\n      ListSequence.fromList(SLinkOperations.getTargets(classConcept, \"method\", true)).visitAll(new IVisitor<SNode>() {\n        public void visit(SNode method) {\n          if (setterName.equals(SPropertyOperations.getString(method, \"name\")) && ListSequence.fromList(SLinkOperations.getTargets(method, \"parameter\", true)).count() == 1) {\n            setterIsAbsent.value = false;\n          }\n        }\n      });\n      if (!(setterIsAbsent.value)) {\n        continue;\n      }\n      SLinkOperations.addChild(classConcept, \"method\", new _Quotations.QuotationClass_29().createNode(thisExpression, field, SLinkOperations.getTarget(field, \"type\", true), SPropertyOperations.getString(field, \"name\"), setterName));\n    }\n  }","id":60890,"modified_method":"public void execute(final SNode node, final EditorContext editorContext) {\n    SNode classConcept = SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\");\n    List<SNode> fields = SLinkOperations.getTargets(classConcept, \"field\", true);\n    Pair p;\n    final SNode thisExpression = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.ThisExpression\", null);\n    for (final SNode field : fields) {\n      final String getterName = \"get\" + NameUtil.capitalize(SPropertyOperations.getString(field, \"name\"));\n      final Wrappers._boolean getterIsAbsent = new Wrappers._boolean(true);\n      ListSequence.fromList(SLinkOperations.getTargets(classConcept, \"method\", true)).visitAll(new IVisitor<SNode>() {\n        public void visit(SNode it) {\n          if (getterName.equals(SPropertyOperations.getString(it, \"name\")) && ListSequence.fromList(SLinkOperations.getTargets(it, \"parameter\", true)).isEmpty()) {\n            getterIsAbsent.value = false;\n          }\n        }\n      });\n      if (getterIsAbsent.value) {\n        SLinkOperations.addChild(classConcept, \"method\", new _Quotations.QuotationClass_29().createNode(SLinkOperations.getTarget(field, \"type\", true), thisExpression, field, getterName));\n      }\n\n      final String setterName = \"set\" + NameUtil.capitalize(SPropertyOperations.getString(field, \"name\"));\n      final Wrappers._boolean setterIsAbsent = new Wrappers._boolean(true);\n      ListSequence.fromList(SLinkOperations.getTargets(classConcept, \"method\", true)).visitAll(new IVisitor<SNode>() {\n        public void visit(SNode method) {\n          if (setterName.equals(SPropertyOperations.getString(method, \"name\")) && ListSequence.fromList(SLinkOperations.getTargets(method, \"parameter\", true)).count() == 1) {\n            setterIsAbsent.value = false;\n          }\n        }\n      });\n      if (!(setterIsAbsent.value)) {\n        continue;\n      }\n      SLinkOperations.addChild(classConcept, \"method\", new _Quotations.QuotationClass_30().createNode(thisExpression, field, SLinkOperations.getTarget(field, \"type\", true), SPropertyOperations.getString(field, \"name\"), setterName));\n    }\n  }","commit_id":"d3a4d643f005e41bce10f968e609823209fc7168","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute(final SNode node, final EditorContext editorContext) {\n    SNode classConcept = SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\");\n    List<SNode> fields = SLinkOperations.getTargets(classConcept, \"field\", true);\n    if (ListSequence.fromList(fields).isEmpty()) {\n      return;\n    }\n    for (final SNode field : fields) {\n      final String setterName = \"set\" + NameUtil.capitalize(SPropertyOperations.getString(field, \"name\"));\n      boolean setterIsAbsent = true;\n      if (ListSequence.fromList(SLinkOperations.getTargets(classConcept, \"method\", true)).any(new IWhereFilter<SNode>() {\n        public boolean accept(SNode method) {\n          return setterName.equals(SPropertyOperations.getString(method, \"name\")) && ListSequence.fromList(SLinkOperations.getTargets(method, \"parameter\", true)).count() == 1;\n        }\n      })) {\n        setterIsAbsent = false;\n      }\n      if (!(setterIsAbsent)) {\n        continue;\n      }\n      Pair<String, String> p;\n      final SNode thisExpression = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.ThisExpression\", null);\n      // Method creation begins \n      SLinkOperations.addChild(classConcept, \"method\", new _Quotations.QuotationClass_26().createNode(thisExpression, field, SLinkOperations.getTarget(field, \"type\", true), SPropertyOperations.getString(field, \"name\"), setterName));\n    }\n  }","id":60891,"modified_method":"public void execute(final SNode node, final EditorContext editorContext) {\n    SNode classConcept = SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\");\n    List<SNode> fields = SLinkOperations.getTargets(classConcept, \"field\", true);\n    if (ListSequence.fromList(fields).isEmpty()) {\n      return;\n    }\n    for (final SNode field : fields) {\n      final String setterName = \"set\" + NameUtil.capitalize(SPropertyOperations.getString(field, \"name\"));\n      boolean setterIsAbsent = true;\n      if (ListSequence.fromList(SLinkOperations.getTargets(classConcept, \"method\", true)).any(new IWhereFilter<SNode>() {\n        public boolean accept(SNode method) {\n          return setterName.equals(SPropertyOperations.getString(method, \"name\")) && ListSequence.fromList(SLinkOperations.getTargets(method, \"parameter\", true)).count() == 1;\n        }\n      })) {\n        setterIsAbsent = false;\n      }\n      if (!(setterIsAbsent)) {\n        continue;\n      }\n      Pair<String, String> p;\n      final SNode thisExpression = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.ThisExpression\", null);\n      // Method creation begins \n      SLinkOperations.addChild(classConcept, \"method\", new _Quotations.QuotationClass_27().createNode(thisExpression, field, SLinkOperations.getTarget(field, \"type\", true), SPropertyOperations.getString(field, \"name\"), setterName));\n    }\n  }","commit_id":"d3a4d643f005e41bce10f968e609823209fc7168","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute(final SNode node, final EditorContext editorContext) {\n    final SNode classConcept = SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\");\n    List<SNode> fields = SLinkOperations.getTargets(classConcept, \"field\", true);\n    final SNode rightmostExpression;\n    SNode firstField = ListSequence.fromList(fields).first();\n    SNode currentExpression = null;\n    for (SNode field : fields) {\n      SNode fieldRef = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.FieldReferenceOperation\", null);\n      SLinkOperations.setTarget(fieldRef, \"fieldDeclaration\", field, false);\n      SNode item = new _Quotations.QuotationClass_5().createNode(((field == firstField ?\n        \"\" :\n        \", \"\n      )) + SPropertyOperations.getString(field, \"name\") + \"=\");\n      SNode dotExpression = new _Quotations.QuotationClass_32().createNode(SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.ThisExpression\", null), fieldRef);\n      if (field == firstField) {\n        currentExpression = new _Quotations.QuotationClass_25().createNode(SPropertyOperations.getString(classConcept, \"name\") + \"{\", item);\n        currentExpression = new _Quotations.QuotationClass_34().createNode(dotExpression, currentExpression);\n      } else {\n        currentExpression = new _Quotations.QuotationClass_6().createNode(item, currentExpression);\n        currentExpression = new _Quotations.QuotationClass_33().createNode(dotExpression, currentExpression);\n      }\n    }\n    rightmostExpression = new _Quotations.QuotationClass_7().createNode(currentExpression);\n    SLinkOperations.addChild(classConcept, \"method\", new _Quotations.QuotationClass_4().createNode(rightmostExpression));\n  }","id":60892,"modified_method":"public void execute(final SNode node, final EditorContext editorContext) {\n    final SNode classConcept = SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\");\n    List<SNode> fields = SLinkOperations.getTargets(classConcept, \"field\", true);\n    final SNode rightmostExpression;\n    SNode firstField = ListSequence.fromList(fields).first();\n    SNode currentExpression = null;\n    for (SNode field : fields) {\n      SNode fieldRef = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.FieldReferenceOperation\", null);\n      SLinkOperations.setTarget(fieldRef, \"fieldDeclaration\", field, false);\n      SNode item = new _Quotations.QuotationClass_5().createNode(((field == firstField ?\n        \"\" :\n        \", \"\n      )) + SPropertyOperations.getString(field, \"name\") + \"=\");\n      SNode dotExpression = new _Quotations.QuotationClass_33().createNode(SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.ThisExpression\", null), fieldRef);\n      if (field == firstField) {\n        currentExpression = new _Quotations.QuotationClass_26().createNode(SPropertyOperations.getString(classConcept, \"name\") + \"{\", item);\n        currentExpression = new _Quotations.QuotationClass_35().createNode(dotExpression, currentExpression);\n      } else {\n        currentExpression = new _Quotations.QuotationClass_6().createNode(item, currentExpression);\n        currentExpression = new _Quotations.QuotationClass_34().createNode(dotExpression, currentExpression);\n      }\n    }\n    rightmostExpression = new _Quotations.QuotationClass_7().createNode(currentExpression);\n    SLinkOperations.addChild(classConcept, \"method\", new _Quotations.QuotationClass_4().createNode(rightmostExpression));\n  }","commit_id":"d3a4d643f005e41bce10f968e609823209fc7168","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * Create a ParenthesisedExpression and hook it properly into the model\n   * \n   * @param leftTurn The node that should be put outside and to the left from the new parens\n   * @param rightTurn The node that should be put outside and to the right from the new parens\n   * @param firstCommon The common ancestor expression of both parentheses\n   */\n  private static SNode rebalance(SNode leftTurn, SNode firstCommon, SNode rightTurn) {\n\n    // Accumulate expressions between the leftTurn and firstCommon to include inside the parens. \n    // These would be the nodes into which we come from the left child. \n    SNode leftAccumulator = null;\n    // Accumulate expressions between the rightTurn and firstCommon to include inside the parens. \n    // These would be the nodes into which we come from the right child. \n    SNode rightAccumulator = null;\n\n    if (leftTurn != null && neq_a65dpo_a0a8a71(leftTurn, firstCommon)) {\n      // Accumulate nodes on the path from the left paren \n      leftAccumulator = SLinkOperations.getTarget(leftTurn, \"rightExpression\", true);\n      SNodeOperations.detachNode(leftAccumulator);\n      SNode current = SNodeOperations.cast(SNodeOperations.getParent(leftTurn), \"jetbrains.mps.baseLanguage.structure.Expression\");\n      SNode previous = leftTurn;\n      while (neq_a65dpo_a0f0i0r(current, firstCommon)) {\n        if (SNodeOperations.isInstanceOf(current, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\") && eq_a65dpo_a0a0a5a8a71(SLinkOperations.getTarget(SNodeOperations.cast(current, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\"), \"leftExpression\", true), previous)) {\n          SNodeOperations.replaceWithAnother(current, previous);\n          SLinkOperations.setTarget(SNodeOperations.cast(current, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\"), \"leftExpression\", leftAccumulator, true);\n          leftAccumulator = current;\n        } else {\n          previous = current;\n        }\n        current = SNodeOperations.cast(SNodeOperations.getParent(previous), \"jetbrains.mps.baseLanguage.structure.Expression\");\n      }\n    } else {\n      // Nothing to accumulate \n      if (SNodeOperations.isInstanceOf(firstCommon, \"jetbrains.mps.baseLanguage.structure.CastExpression\")) {\n        leftAccumulator = firstCommon;\n      }\n      if (SNodeOperations.isInstanceOf(firstCommon, \"jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression\")) {\n        leftAccumulator = SLinkOperations.getTarget(SNodeOperations.cast(firstCommon, \"jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression\"), \"condition\", true);\n        SNodeOperations.detachNode(leftAccumulator);\n      }\n      if (SNodeOperations.isInstanceOf(firstCommon, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\")) {\n        leftAccumulator = SLinkOperations.getTarget(SNodeOperations.cast(firstCommon, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\"), \"leftExpression\", true);\n        SNodeOperations.detachNode(leftAccumulator);\n      }\n    }\n\n    if (rightTurn != null && neq_a65dpo_a0a01a71(rightTurn, firstCommon)) {\n      // Accumulate nodes on the path from the right paren \n      rightAccumulator = SLinkOperations.getTarget(rightTurn, \"leftExpression\", true);\n      SNodeOperations.detachNode(rightAccumulator);\n      SNode current = SNodeOperations.cast(SNodeOperations.getParent(rightTurn), \"jetbrains.mps.baseLanguage.structure.Expression\");\n      SNode previous = rightTurn;\n      while (neq_a65dpo_a0a5a01a71(current, firstCommon) && !(SNodeOperations.isInstanceOf(current, \"jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression\") || SNodeOperations.isInstanceOf(current, \"jetbrains.mps.baseLanguage.structure.CastExpression\"))) {\n        if (SNodeOperations.isInstanceOf(current, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\") && eq_a65dpo_a0a0a5a01a71(SLinkOperations.getTarget(SNodeOperations.cast(current, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\"), \"rightExpression\", true), previous)) {\n          SNodeOperations.replaceWithAnother(current, previous);\n          SLinkOperations.setTarget(SNodeOperations.cast(current, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\"), \"rightExpression\", rightAccumulator, true);\n          rightAccumulator = current;\n        } else {\n          previous = current;\n        }\n        current = SNodeOperations.cast(SNodeOperations.getParent(previous), \"jetbrains.mps.baseLanguage.structure.Expression\");\n      }\n\n    } else {\n      // Nothing to accumulate \n      if (SNodeOperations.isInstanceOf(firstCommon, \"jetbrains.mps.baseLanguage.structure.CastExpression\")) {\n        // cannot set a right paren attached directly to a CastExpression \n        assert false;\n      }\n      if (SNodeOperations.isInstanceOf(firstCommon, \"jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression\")) {\n        rightAccumulator = SLinkOperations.getTarget(SNodeOperations.cast(firstCommon, \"jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression\"), \"ifFalse\", true);\n        SNodeOperations.detachNode(rightAccumulator);\n      }\n      if (SNodeOperations.isInstanceOf(firstCommon, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\")) {\n        rightAccumulator = SLinkOperations.getTarget(SNodeOperations.cast(firstCommon, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\"), \"rightExpression\", true);\n        SNodeOperations.detachNode(rightAccumulator);\n      }\n    }\n\n    assert leftAccumulator != null;\n    assert rightAccumulator != null;\n\n    SNode parens = SNodeFactoryOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.ParenthesizedExpression\", null);\n    if (SNodeOperations.isInstanceOf(firstCommon, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\")) {\n      ParenthesisUtil.hookInBinaryOperation(SNodeOperations.cast(firstCommon, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\"), rightTurn, leftTurn, parens, rightAccumulator, leftAccumulator);\n    } else if (SNodeOperations.isInstanceOf(firstCommon, \"jetbrains.mps.baseLanguage.structure.CastExpression\")) {\n      ParenthesisUtil.hookInCastExpression(SNodeOperations.cast(firstCommon, \"jetbrains.mps.baseLanguage.structure.CastExpression\"), rightTurn, parens, rightAccumulator);\n\n    } else {\n      ParenthesisUtil.hookInTernaryOperator(SNodeOperations.cast(firstCommon, \"jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression\"), rightTurn, leftTurn, parens, rightAccumulator, leftAccumulator);\n    }\n    SLinkOperations.setTarget(parens, \"expression\", firstCommon, true);\n    return parens;\n  }","id":60893,"modified_method":"/**\n   * Create a ParenthesisedExpression and hook it properly into the model\n   * \n   * @param leftTurn The node that should be put outside and to the left from the new parens\n   * @param rightTurn The node that should be put outside and to the right from the new parens\n   * @param firstCommon The common ancestor expression of both parentheses\n   */\n  private static SNode rebalance(SNode leftTurn, SNode firstCommon, SNode rightTurn) {\n\n    // Accumulate expressions between the leftTurn and firstCommon to include inside the parens. \n    // These would be the nodes into which we come from the left child. \n    SNode leftAccumulator = null;\n    // Accumulate expressions between the rightTurn and firstCommon to include inside the parens. \n    // These would be the nodes into which we come from the right child. \n    SNode rightAccumulator = null;\n    if (leftTurn != null && neq_a65dpo_a0a7a61(leftTurn, firstCommon)) {\n      // Accumulate nodes on the path from the left paren \n      leftAccumulator = SLinkOperations.getTarget(leftTurn, \"rightExpression\", true);\n      SNodeOperations.detachNode(leftAccumulator);\n      SNode current = SNodeOperations.cast(SNodeOperations.getParent(leftTurn), \"jetbrains.mps.baseLanguage.structure.Expression\");\n      SNode previous = leftTurn;\n      while (neq_a65dpo_a0f0h0q(current, firstCommon)) {\n        if (SNodeOperations.isInstanceOf(current, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\") && eq_a65dpo_a0a0a5a7a61(SLinkOperations.getTarget(SNodeOperations.cast(current, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\"), \"leftExpression\", true), previous)) {\n          SNodeOperations.replaceWithAnother(current, previous);\n          SLinkOperations.setTarget(SNodeOperations.cast(current, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\"), \"leftExpression\", leftAccumulator, true);\n          leftAccumulator = current;\n        } else {\n          previous = current;\n        }\n        current = SNodeOperations.cast(SNodeOperations.getParent(previous), \"jetbrains.mps.baseLanguage.structure.Expression\");\n      }\n    } else {\n      // Nothing to accumulate \n      if (SNodeOperations.isInstanceOf(firstCommon, \"jetbrains.mps.baseLanguage.structure.CastExpression\")) {\n        leftAccumulator = firstCommon;\n      }\n      if (SNodeOperations.isInstanceOf(firstCommon, \"jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression\")) {\n        leftAccumulator = SLinkOperations.getTarget(SNodeOperations.cast(firstCommon, \"jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression\"), \"condition\", true);\n        SNodeOperations.detachNode(leftAccumulator);\n      }\n      if (SNodeOperations.isInstanceOf(firstCommon, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\")) {\n        leftAccumulator = SLinkOperations.getTarget(SNodeOperations.cast(firstCommon, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\"), \"leftExpression\", true);\n        SNodeOperations.detachNode(leftAccumulator);\n      }\n    }\n\n    if (rightTurn != null && neq_a65dpo_a0a9a61(rightTurn, firstCommon)) {\n      // Accumulate nodes on the path from the right paren \n      rightAccumulator = SLinkOperations.getTarget(rightTurn, \"leftExpression\", true);\n      SNodeOperations.detachNode(rightAccumulator);\n      SNode current = SNodeOperations.cast(SNodeOperations.getParent(rightTurn), \"jetbrains.mps.baseLanguage.structure.Expression\");\n      SNode previous = rightTurn;\n      while (neq_a65dpo_a0a5a9a61(current, firstCommon) && !(SNodeOperations.isInstanceOf(current, \"jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression\") || SNodeOperations.isInstanceOf(current, \"jetbrains.mps.baseLanguage.structure.CastExpression\"))) {\n        if (SNodeOperations.isInstanceOf(current, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\") && eq_a65dpo_a0a0a5a9a61(SLinkOperations.getTarget(SNodeOperations.cast(current, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\"), \"rightExpression\", true), previous)) {\n          SNodeOperations.replaceWithAnother(current, previous);\n          SLinkOperations.setTarget(SNodeOperations.cast(current, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\"), \"rightExpression\", rightAccumulator, true);\n          rightAccumulator = current;\n        } else {\n          previous = current;\n        }\n        current = SNodeOperations.cast(SNodeOperations.getParent(previous), \"jetbrains.mps.baseLanguage.structure.Expression\");\n      }\n\n    } else {\n      // Nothing to accumulate \n      if (SNodeOperations.isInstanceOf(firstCommon, \"jetbrains.mps.baseLanguage.structure.CastExpression\")) {\n        rightAccumulator = SLinkOperations.getTarget(SNodeOperations.cast(firstCommon, \"jetbrains.mps.baseLanguage.structure.CastExpression\"), \"expression\", true);\n      }\n      if (SNodeOperations.isInstanceOf(firstCommon, \"jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression\")) {\n        rightAccumulator = SLinkOperations.getTarget(SNodeOperations.cast(firstCommon, \"jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression\"), \"ifFalse\", true);\n      }\n      if (SNodeOperations.isInstanceOf(firstCommon, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\")) {\n        rightAccumulator = SLinkOperations.getTarget(SNodeOperations.cast(firstCommon, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\"), \"rightExpression\", true);\n      }\n      SNodeOperations.detachNode(rightAccumulator);\n    }\n\n    assert leftAccumulator != null;\n    assert rightAccumulator != null;\n    SNode parens = SNodeFactoryOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.ParenthesizedExpression\", null);\n    if (SNodeOperations.isInstanceOf(firstCommon, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\")) {\n      ParenthesisUtil.hookInBinaryOperation(SNodeOperations.cast(firstCommon, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\"), rightTurn, leftTurn, parens, rightAccumulator, leftAccumulator);\n    } else if (SNodeOperations.isInstanceOf(firstCommon, \"jetbrains.mps.baseLanguage.structure.CastExpression\")) {\n      ParenthesisUtil.hookInCastExpression(SNodeOperations.cast(firstCommon, \"jetbrains.mps.baseLanguage.structure.CastExpression\"), rightTurn, parens, rightAccumulator);\n\n    } else if (SNodeOperations.isInstanceOf(firstCommon, \"jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression\")) {\n      ParenthesisUtil.hookInTernaryOperator(SNodeOperations.cast(firstCommon, \"jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression\"), rightTurn, leftTurn, parens, rightAccumulator, leftAccumulator);\n    } else {\n      assert false;\n    }\n    SLinkOperations.setTarget(parens, \"expression\", firstCommon, true);\n    return parens;\n  }","commit_id":"89a3a8efa51388b12a6ab221581e37275d1eaf95","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static void hookInBinaryOperation(SNode firstCommon, SNode rightTurn, SNode leftTurn, SNode parens, SNode rightAccumulator, SNode leftAccumulator) {\n\n    SNode leftSide = SLinkOperations.getTarget(firstCommon, \"leftExpression\", true);\n    SNode rightSide = SLinkOperations.getTarget(firstCommon, \"rightExpression\", true);\n    assert leftSide != null || rightSide != null;\n\n    SNode head = (rightSide != null ? rightSide : leftSide);\n    SNodeOperations.replaceWithAnother(firstCommon, head);\n    SLinkOperations.setTarget(parens, \"expression\", firstCommon, true);\n    SLinkOperations.setTarget(firstCommon, \"leftExpression\", leftAccumulator, true);\n    SLinkOperations.setTarget(firstCommon, \"rightExpression\", rightAccumulator, true);\n    SNode subtree;\n    if (leftSide != null) {\n      subtree = leftSide;\n      SLinkOperations.setTarget(leftTurn, \"rightExpression\", parens, true);\n    } else {\n      subtree = parens;\n    }\n    if (rightSide != null) {\n      SLinkOperations.setTarget(rightTurn, \"leftExpression\", subtree, true);\n    }\n  }","id":60894,"modified_method":"private static void hookInBinaryOperation(SNode firstCommon, SNode rightTurn, SNode leftTurn, SNode parens, SNode rightAccumulator, SNode leftAccumulator) {\n\n    if (leftTurn == rightTurn) {\n      SNodeOperations.replaceWithAnother(firstCommon, parens);\n      SLinkOperations.setTarget(firstCommon, \"leftExpression\", leftAccumulator, true);\n      SLinkOperations.setTarget(firstCommon, \"rightExpression\", rightAccumulator, true);\n      SLinkOperations.setTarget(parens, \"expression\", firstCommon, true);\n      return;\n    }\n\n    SNode leftSide = SLinkOperations.getTarget(firstCommon, \"leftExpression\", true);\n    SNode rightSide = SLinkOperations.getTarget(firstCommon, \"rightExpression\", true);\n    assert leftSide != null || rightSide != null;\n    SNode head = (rightSide != null ? rightSide : leftSide);\n    SNodeOperations.replaceWithAnother(firstCommon, head);\n    SLinkOperations.setTarget(parens, \"expression\", firstCommon, true);\n    SLinkOperations.setTarget(firstCommon, \"leftExpression\", leftAccumulator, true);\n    SLinkOperations.setTarget(firstCommon, \"rightExpression\", rightAccumulator, true);\n    SNode subtree;\n    if (leftSide != null) {\n      subtree = leftSide;\n      SLinkOperations.setTarget(leftTurn, \"rightExpression\", parens, true);\n    } else {\n      subtree = parens;\n    }\n    if (rightSide != null) {\n      SLinkOperations.setTarget(rightTurn, \"leftExpression\", subtree, true);\n    }\n  }","commit_id":"89a3a8efa51388b12a6ab221581e37275d1eaf95","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean neq_a65dpo_a0a5a01a71(Object a, Object b) {\n    return !((a != null ? a.equals(b) : a == b));\n  }","id":60895,"modified_method":"private static boolean neq_a65dpo_a0a5a9a61(Object a, Object b) {\n    return !((a != null ? a.equals(b) : a == b));\n  }","commit_id":"89a3a8efa51388b12a6ab221581e37275d1eaf95","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static void hookInTernaryOperator(SNode firstCommon, SNode rightTurn, SNode leftTurn, SNode parens, SNode rightAccumulator, SNode leftAccumulator) {\n\n    SNode bottomMostTernary = ParenthesisUtil.findBottomMostTernary(SNodeOperations.cast(firstCommon, \"jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression\"));\n\n    if ((SLinkOperations.getTarget(firstCommon, \"ifFalse\", true) != null)) {\n      SNodeOperations.replaceWithAnother(firstCommon, SLinkOperations.getTarget(bottomMostTernary, \"ifFalse\", true));\n      if ((SLinkOperations.getTarget(firstCommon, \"condition\", true) != null)) {\n        SLinkOperations.setTarget(rightTurn, \"leftExpression\", SLinkOperations.getTarget(firstCommon, \"condition\", true), true);\n        SLinkOperations.setTarget(leftTurn, \"rightExpression\", parens, true);\n      } else {\n        SLinkOperations.setTarget(rightTurn, \"leftExpression\", parens, true);\n      }\n    } else {\n      SNodeOperations.replaceWithAnother(firstCommon, SLinkOperations.getTarget(firstCommon, \"condition\", true));\n      SLinkOperations.setTarget(leftTurn, \"rightExpression\", parens, true);\n    }\n\n    SLinkOperations.setTarget(bottomMostTernary, \"ifFalse\", rightAccumulator, true);\n    SLinkOperations.setTarget(firstCommon, \"condition\", leftAccumulator, true);\n  }","id":60896,"modified_method":"private static void hookInTernaryOperator(SNode firstCommon, SNode rightTurn, SNode leftTurn, SNode parens, SNode rightAccumulator, SNode leftAccumulator) {\n\n    SNode bottomMostTernary = ParenthesisUtil.findBottomMostTernary(SNodeOperations.cast(firstCommon, \"jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression\"));\n    if (rightTurn != null) {\n      SNodeOperations.replaceWithAnother(firstCommon, SLinkOperations.getTarget(bottomMostTernary, \"ifFalse\", true));\n      if (leftTurn != null) {\n        SLinkOperations.setTarget(rightTurn, \"leftExpression\", SLinkOperations.getTarget(firstCommon, \"condition\", true), true);\n        SLinkOperations.setTarget(leftTurn, \"rightExpression\", parens, true);\n      } else {\n        SLinkOperations.setTarget(rightTurn, \"leftExpression\", parens, true);\n      }\n    } else {\n      if (leftTurn != null) {\n        SNodeOperations.replaceWithAnother(firstCommon, SLinkOperations.getTarget(firstCommon, \"condition\", true));\n        SLinkOperations.setTarget(leftTurn, \"rightExpression\", parens, true);\n      } else {\n        SNodeOperations.replaceWithAnother(firstCommon, parens);\n      }\n    }\n    SLinkOperations.setTarget(bottomMostTernary, \"ifFalse\", rightAccumulator, true);\n    SLinkOperations.setTarget(firstCommon, \"condition\", leftAccumulator, true);\n  }","commit_id":"89a3a8efa51388b12a6ab221581e37275d1eaf95","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode handleCastExpression(SNode firstCommon, SNode rightExpression) {\n    SNode castExpr = SNodeOperations.cast(firstCommon, \"jetbrains.mps.baseLanguage.structure.CastExpression\");\n    SNode leftTurn = null;\n    SNode rightTurn = findRightTurn(rightExpression, castExpr);\n\n    // Wrap the whole cast expression in parens \n    if (eq_a65dpo_a0f0k(leftTurn, rightTurn)) {\n      SNode parens = SNodeFactoryOperations.replaceWithNewChild(castExpr, \"jetbrains.mps.baseLanguage.structure.ParenthesizedExpression\");\n      SLinkOperations.setTarget(parens, \"expression\", castExpr, true);\n      return parens;\n    }\n\n    return ParenthesisUtil.rebalance(leftTurn, firstCommon, rightTurn);\n  }","id":60897,"modified_method":"private static SNode handleCastExpression(SNode firstCommon, SNode rightExpression) {\n    SNode castExpr = SNodeOperations.cast(firstCommon, \"jetbrains.mps.baseLanguage.structure.CastExpression\");\n    SNode leftTurn = null;\n    SNode rightTurn = findRightTurn(rightExpression, castExpr);\n    return ParenthesisUtil.rebalance(leftTurn, firstCommon, rightTurn);\n  }","commit_id":"89a3a8efa51388b12a6ab221581e37275d1eaf95","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static void hookInCastExpression(SNode firstCommon, SNode rightTurn, SNode parens, SNode rightAccumulator) {\n\n    assert rightTurn != null;\n    SNodeOperations.replaceWithAnother(firstCommon, rightTurn);\n    SLinkOperations.setTarget(rightTurn, \"leftExpression\", parens, true);\n    SLinkOperations.setTarget(parens, \"expression\", firstCommon, true);\n    SLinkOperations.setTarget(firstCommon, \"expression\", rightAccumulator, true);\n  }","id":60898,"modified_method":"private static void hookInCastExpression(SNode firstCommon, SNode rightTurn, SNode parens, SNode rightAccumulator) {\n    if (rightTurn != null) {\n      SNodeOperations.replaceWithAnother(firstCommon, rightTurn);\n      SLinkOperations.setTarget(rightTurn, \"leftExpression\", parens, true);\n    } else {\n      SNodeOperations.replaceWithAnother(firstCommon, parens);\n    }\n    SLinkOperations.setTarget(parens, \"expression\", firstCommon, true);\n    SLinkOperations.setTarget(firstCommon, \"expression\", rightAccumulator, true);\n  }","commit_id":"89a3a8efa51388b12a6ab221581e37275d1eaf95","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean eq_a65dpo_a0a0a5a01a71(Object a, Object b) {\n    return (a != null ? a.equals(b) : a == b);\n  }","id":60899,"modified_method":"private static boolean eq_a65dpo_a0a0a5a7a61(Object a, Object b) {\n    return (a != null ? a.equals(b) : a == b);\n  }","commit_id":"89a3a8efa51388b12a6ab221581e37275d1eaf95","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean neq_a65dpo_a0a8a71(Object a, Object b) {\n    return !((a != null ? a.equals(b) : a == b));\n  }","id":60900,"modified_method":"private static boolean neq_a65dpo_a0a7a61(Object a, Object b) {\n    return !((a != null ? a.equals(b) : a == b));\n  }","commit_id":"89a3a8efa51388b12a6ab221581e37275d1eaf95","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode handleBinaryOperation(SNode leftExpression, SNode firstCommon, SNode rightExpression) {\n    SNode leftTurn = findLeftTurn(leftExpression, firstCommon);\n    SNode rightTurn = findRightTurn(rightExpression, firstCommon);\n    if (eq_a65dpo_a0c0m(leftTurn, rightTurn)) {\n      assert eq_a65dpo_a0a0c0m(leftTurn, firstCommon);\n      SNode parens = SNodeFactoryOperations.replaceWithNewChild(leftTurn, \"jetbrains.mps.baseLanguage.structure.ParenthesizedExpression\");\n      SLinkOperations.setTarget(parens, \"expression\", leftTurn, true);\n      return parens;\n    }\n\n    return ParenthesisUtil.rebalance(leftTurn, firstCommon, rightTurn);\n  }","id":60901,"modified_method":"private static SNode handleBinaryOperation(SNode leftExpression, SNode firstCommon, SNode rightExpression) {\n    SNode leftTurn = findLeftTurn(leftExpression, firstCommon);\n    SNode rightTurn = findRightTurn(rightExpression, firstCommon);\n    return ParenthesisUtil.rebalance(leftTurn, firstCommon, rightTurn);\n  }","commit_id":"89a3a8efa51388b12a6ab221581e37275d1eaf95","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * Strictly following binary operations, is the leaf the right-most leaf under the root?\n   * Useful to detect right parens added behind an expression inside e.g. a CastExpression\n   */\n  private static boolean isTheRightMostExpression(final SNode root, final SNode leaf) {\n    if (!(SNodeOperations.isInstanceOf(root, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\"))) {\n      return eq_a65dpo_a0a0a0qb(root, leaf);\n    }\n    SNode binOp = SNodeOperations.cast(root, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\");\n    return isTheRightMostExpression(SLinkOperations.getTarget(binOp, \"rightExpression\", true), leaf);\n  }","id":60902,"modified_method":"/**\n   * Strictly following binary operations, is the leaf the right-most leaf under the root?\n   * Useful to detect right parens added behind an expression inside e.g. a CastExpression\n   */\n  private static boolean isTheRightMostExpression(final SNode root, final SNode leaf) {\n    if (!(SNodeOperations.isInstanceOf(root, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\"))) {\n      return eq_a65dpo_a0a0a0pb(root, leaf);\n    }\n    SNode binOp = SNodeOperations.cast(root, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\");\n    return isTheRightMostExpression(SLinkOperations.getTarget(binOp, \"rightExpression\", true), leaf);\n  }","commit_id":"89a3a8efa51388b12a6ab221581e37275d1eaf95","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode handleTernaryOperator(SNode firstCommon, SNode leftExpression, SNode rightExpression) {\n    assert SNodeOperations.isInstanceOf(firstCommon, \"jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression\");\n    SNode ternaryExpr = SNodeOperations.cast(firstCommon, \"jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression\");\n    SNode leftTurn = findLeftTurn(leftExpression, ternaryExpr);\n    SNode rightTurn = findRightTurn(rightExpression, ternaryExpr);\n\n    // Wrap the whole ternary operator expression in parens \n    if (eq_a65dpo_a0g0i(leftTurn, rightTurn)) {\n      SNode parens = SNodeFactoryOperations.replaceWithNewChild(ternaryExpr, \"jetbrains.mps.baseLanguage.structure.ParenthesizedExpression\");\n      SLinkOperations.setTarget(parens, \"expression\", ternaryExpr, true);\n      return parens;\n    }\n\n    return ParenthesisUtil.rebalance(leftTurn, firstCommon, rightTurn);\n  }","id":60903,"modified_method":"private static SNode handleTernaryOperator(SNode firstCommon, SNode leftExpression, SNode rightExpression) {\n    assert SNodeOperations.isInstanceOf(firstCommon, \"jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression\");\n    SNode ternaryExpr = SNodeOperations.cast(firstCommon, \"jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression\");\n    SNode leftTurn = findLeftTurn(leftExpression, ternaryExpr);\n    SNode rightTurn = findRightTurn(rightExpression, ternaryExpr);\n    return ParenthesisUtil.rebalance(leftTurn, firstCommon, rightTurn);\n  }","commit_id":"89a3a8efa51388b12a6ab221581e37275d1eaf95","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean eq_a65dpo_a0a0a0qb(Object a, Object b) {\n    return (a != null ? a.equals(b) : a == b);\n  }","id":60904,"modified_method":"private static boolean eq_a65dpo_a0a0a0pb(Object a, Object b) {\n    return (a != null ? a.equals(b) : a == b);\n  }","commit_id":"89a3a8efa51388b12a6ab221581e37275d1eaf95","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean eq_a65dpo_a0a0a5a8a71(Object a, Object b) {\n    return (a != null ? a.equals(b) : a == b);\n  }","id":60905,"modified_method":"private static boolean eq_a65dpo_a0a0a5a9a61(Object a, Object b) {\n    return (a != null ? a.equals(b) : a == b);\n  }","commit_id":"89a3a8efa51388b12a6ab221581e37275d1eaf95","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean neq_a65dpo_a0a01a71(Object a, Object b) {\n    return !((a != null ? a.equals(b) : a == b));\n  }","id":60906,"modified_method":"private static boolean neq_a65dpo_a0a9a61(Object a, Object b) {\n    return !((a != null ? a.equals(b) : a == b));\n  }","commit_id":"89a3a8efa51388b12a6ab221581e37275d1eaf95","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean eq_a65dpo_a0a2a0a2a63(Object a, Object b) {\n    return (a != null ? a.equals(b) : a == b);\n  }","id":60907,"modified_method":"private static boolean eq_a65dpo_a0a2a0a2a53(Object a, Object b) {\n    return (a != null ? a.equals(b) : a == b);\n  }","commit_id":"89a3a8efa51388b12a6ab221581e37275d1eaf95","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode findTurn(SNode leaf, SNode stopNode, boolean leftTurn) {\n    SNode currentNode = SNodeOperations.getParent(leaf);\n    SNode previous = leaf;\n    while (neq_a65dpo_a0c0kb(previous, stopNode)) {\n      if (SNodeOperations.isInstanceOf(currentNode, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\")) {\n        final SNode currentBinaryExpr = SNodeOperations.cast(currentNode, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\");\n        if (leftTurn && eq_a65dpo_a0a1a0a2a63(SLinkOperations.getTarget(currentBinaryExpr, \"rightExpression\", true), previous)) {\n          return currentBinaryExpr;\n        }\n        if (!(leftTurn) && eq_a65dpo_a0a2a0a2a63(SLinkOperations.getTarget(currentBinaryExpr, \"leftExpression\", true), previous)) {\n          return currentBinaryExpr;\n        }\n      }\n      previous = currentNode;\n      currentNode = SNodeOperations.getParent(currentNode);\n    }\n    return (SNodeOperations.isInstanceOf(stopNode, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\") ? SNodeOperations.cast(stopNode, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\") : null);\n  }","id":60908,"modified_method":"private static SNode findTurn(SNode leaf, SNode stopNode, boolean leftTurn) {\n    SNode currentNode = SNodeOperations.getParent(leaf);\n    SNode previous = leaf;\n    while (neq_a65dpo_a0c0jb(previous, stopNode)) {\n      if (SNodeOperations.isInstanceOf(currentNode, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\")) {\n        final SNode currentBinaryExpr = SNodeOperations.cast(currentNode, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\");\n        if (leftTurn && eq_a65dpo_a0a1a0a2a53(SLinkOperations.getTarget(currentBinaryExpr, \"rightExpression\", true), previous)) {\n          return currentBinaryExpr;\n        }\n        if (!(leftTurn) && eq_a65dpo_a0a2a0a2a53(SLinkOperations.getTarget(currentBinaryExpr, \"leftExpression\", true), previous)) {\n          return currentBinaryExpr;\n        }\n      }\n      previous = currentNode;\n      currentNode = SNodeOperations.getParent(currentNode);\n    }\n    return (SNodeOperations.isInstanceOf(stopNode, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\") ? SNodeOperations.cast(stopNode, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\") : null);\n  }","commit_id":"89a3a8efa51388b12a6ab221581e37275d1eaf95","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean eq_a65dpo_a0a1a0a2a63(Object a, Object b) {\n    return (a != null ? a.equals(b) : a == b);\n  }","id":60909,"modified_method":"private static boolean eq_a65dpo_a0a1a0a2a53(Object a, Object b) {\n    return (a != null ? a.equals(b) : a == b);\n  }","commit_id":"89a3a8efa51388b12a6ab221581e37275d1eaf95","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean eq_a65dpo_a0f0k(Object a, Object b) {\n    return (a != null ? a.equals(b) : a == b);\n  }","id":60910,"modified_method":"private static boolean neq_a65dpo_a0f0h0q(Object a, Object b) {\n    return !((a != null ? a.equals(b) : a == b));\n  }","commit_id":"89a3a8efa51388b12a6ab221581e37275d1eaf95","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean neq_a65dpo_a0c0kb(Object a, Object b) {\n    return !((a != null ? a.equals(b) : a == b));\n  }","id":60911,"modified_method":"private static boolean neq_a65dpo_a0c0jb(Object a, Object b) {\n    return !((a != null ? a.equals(b) : a == b));\n  }","commit_id":"89a3a8efa51388b12a6ab221581e37275d1eaf95","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * Generate java class code.\n     *\n     * @param pojo POJO descriptor.\n     * @param key {@code true} if key class should be generated.\n     * @param pkg Package name.\n     * @param pkgFolder Folder where to save generated class.\n     * @param constructor {@code true} if empty and full constructors should be generated.\n     * @param includeKeys {@code true} if key fields should be included into value class.\n     * @param askOverwrite Callback to ask user to confirm file overwrite.\n     * @throws IOException If failed to write generated code into file.\n     */\n    private static void generateCode(PojoDescriptor pojo, boolean key, String pkg, File pkgFolder,\n        boolean constructor, boolean includeKeys, ConfirmCallable askOverwrite) throws IOException {\n        String type = key ? pojo.keyClassName() : pojo.valueClassName();\n\n        checkValidJavaIdentifier(pkg, true, \"Package\", type);\n\n        checkValidJavaIdentifier(type, false, \"Type\", type);\n\n        if (!pkgFolder.exists() && !pkgFolder.mkdirs())\n            throw new IOException(\"Failed to create folders for package: \" + pkg);\n\n        File out = new File(pkgFolder, type + \".java\");\n\n        if (out.exists()) {\n            MessageBox.Result choice = askOverwrite.confirm(out.getName());\n\n            if (CANCEL == choice)\n                throw new IllegalStateException(\"POJO generation was canceled!\");\n\n            if (NO == choice || NO_TO_ALL == choice)\n                return;\n        }\n\n        Collection<String> src = new ArrayList<>(256);\n\n        header(src, pkg, \"java.io.*\", type, type + \" implements Serializable\");\n\n        add1(src, \"/** */\");\n        add1(src, \"private static final long serialVersionUID = 0L;\");\n        add0(src, \"\");\n\n        Collection<PojoField> fields = key ? pojo.keyFields() : pojo.valueFields(includeKeys);\n\n        // Generate fields declaration.\n        for (PojoField field : fields) {\n            String fldName = field.javaName();\n\n            checkValidJavaIdentifier(fldName, false, \"Field\", type);\n\n            add1(src, \"/** Value for \" + fldName + \". */\");\n\n            if (key && field.affinityKey())\n                add1(src, \"@AffinityKeyMapped\");\n\n            add1(src, \"private \" + javaTypeName(field) + \" \" + fldName + \";\");\n            add0(src, \"\");\n        }\n\n        // Generate constructors.\n        if (constructor) {\n            add1(src, \"/**\");\n            add1(src, \" * Empty constructor.\");\n            add1(src, \" */\");\n            add1(src, \"public \" + type + \"() {\");\n            add2(src, \"// No-op.\");\n            add1(src, \"}\");\n\n            add0(src, \"\");\n\n            add1(src, \"/**\");\n            add1(src, \" * Full constructor.\");\n            add1(src, \" */\");\n            add1(src, \"public \" + type + \"(\");\n\n            Iterator<PojoField> it = fields.iterator();\n\n            while (it.hasNext()) {\n                PojoField field = it.next();\n\n                add2(src, javaTypeName(field) + \" \" + field.javaName() + (it.hasNext() ? \",\" : \"\"));\n            }\n            add1(src, \") {\");\n\n            for (PojoField field : fields)\n                add2Fmt(src, \"this.%1$s = %1$s;\", field.javaName());\n\n            add1(src, \"}\");\n            add0(src, \"\");\n        }\n\n        // Generate getters and setters methods.\n        for (PojoField field : fields) {\n            String fldName = field.javaName();\n\n            String fldType = javaTypeName(field);\n\n            String mtdName = capitalizeFirst(fldName);\n\n            add1(src, \"/**\");\n            add1(src, \" * Gets \" + fldName + \".\");\n            add1(src, \" *\");\n            add1(src, \" * @return Value for \" + fldName + \".\");\n            add1(src, \" */\");\n            add1(src, \"public \" + fldType + \" get\" + mtdName + \"() {\");\n            add2(src, \"return \" + fldName + \";\");\n            add1(src, \"}\");\n            add0(src, \"\");\n\n            add1(src, \"/**\");\n            add1(src, \" * Sets \" + fldName + \".\");\n            add1(src, \" *\");\n            add1(src, \" * @param \" + fldName + \" New value for \" + fldName + \".\");\n            add1(src, \" */\");\n            add1(src, \"public void set\" + mtdName + \"(\" + fldType + \" \" + fldName + \") {\");\n            add2(src, \"this.\" + fldName + \" = \" + fldName + \";\");\n            add1(src, \"}\");\n            add0(src, \"\");\n        }\n\n        // Generate equals() method.\n        add1(src, \"/** {@inheritDoc} */\");\n        add1(src, \"@Override public boolean equals(Object o) {\");\n        add2(src, \"if (this == o)\");\n        add3(src, \"return true;\");\n        add0(src, \"\");\n\n        add2(src, \"if (!(o instanceof \" + type + \"))\");\n        add3(src, \"return false;\");\n        add0(src, \"\");\n\n        add2Fmt(src, \"%1$s that = (%1$s)o;\", type);\n\n        for (PojoField field : fields) {\n            add0(src, \"\");\n\n            String javaName = field.javaName();\n\n            if (field.primitive()) {\n                switch (field.javaTypeName()) {\n                    case \"float\":\n                        add2Fmt(src, \"if (Float.compare(%1$s, that.%1$s) != 0)\", javaName);\n                        break;\n\n                    case \"double\":\n                        add2Fmt(src, \"if (Double.compare(%1$s, that.%1$s) != 0)\", javaName);\n                        break;\n\n                    default:\n                        add2Fmt(src, \"if (%1$s != that.%1$s)\", javaName);\n                }\n            }\n            else\n                add2Fmt(src, \"if (%1$s != null ? !%1$s.equals(that.%1$s) : that.%1$s != null)\", javaName);\n\n            add3(src, \"return false;\");\n        }\n\n        add0(src, \"\");\n        add2(src, \"return true;\");\n        add1(src, \"}\");\n        add0(src, \"\");\n\n        // Generate hashCode() method.\n        add1(src, \"/** {@inheritDoc} */\");\n        add1(src, \"@Override public int hashCode() {\");\n\n        List<String> hash = new ArrayList<>(fields.size() * 2);\n\n        boolean first = true;\n        boolean tempVar = false;\n\n        for (PojoField field : fields) {\n            String javaName = field.javaName();\n\n            if (!first)\n                add0(hash, \"\");\n\n            if (field.primitive()) {\n                switch (field.javaTypeName()) {\n                    case \"boolean\":\n                        add2Fmt(hash, first ? \"int res = %s ? 1 : 0;\" : \"res = 31 * res + (%s ? 1 : 0);\", javaName);\n                        break;\n\n                    case \"byte\":\n                    case \"short\":\n                        add2Fmt(hash, first ? \"int res = (int)%s;\" : \"res = 31 * res + (int)%s;\", javaName);\n                        break;\n\n                    case \"int\":\n                        add2Fmt(hash, first ? \"int res = %s;\" : \"res = 31 * res + %s;\", javaName);\n                        break;\n\n                    case \"long\":\n                        add2Fmt(hash, first\n                            ? \"int res = (int)(%1$s ^ (%1$s >>> 32));\"\n                            : \"res = 31 * res + (int)(%1$s ^ (%1$s >>> 32));\", javaName);\n                        break;\n\n                    case \"float\":\n                        add2Fmt(hash, first\n                            ? \"int res = %1$s != +0.0f ? Float.floatToIntBits(%1$s) : 0;\"\n                            : \"res = 31 * res + (%1$s != +0.0f ? Float.floatToIntBits(%1$s) : 0);\", javaName);\n                        break;\n\n                    case \"double\":\n                        add2Fmt(hash, (tempVar ? \"ig_hash_temp\" : \"long ig_hash_temp\") +\n                            \" = Double.doubleToLongBits(%s);\", javaName);\n\n                        add0(hash, \"\");\n\n                        add2Fmt(hash, first\n                            ? \"int res = (int)(ig_hash_temp ^ (ig_hash_temp >>> 32));\"\n                            : \"res = 31 * res + (int)(ig_hash_temp ^ (ig_hash_temp >>> 32));\", javaName);\n\n                        tempVar = true;\n                        break;\n                }\n            }\n            else\n                add2Fmt(hash, first ? \"int res = %1$s != null ? %1$s.hashCode() : 0;\"\n                    : \"res = 31 * res + (%1$s != null ? %1$s.hashCode() : 0);\", javaName);\n\n            first = false;\n        }\n\n        for (String line : hash)\n            add0(src, line);\n\n        add0(src, \"\");\n        add2(src, \"return res;\");\n        add1(src, \"}\");\n        add0(src, \"\");\n\n        // Generate toString() method.\n        add1(src, \"/** {@inheritDoc} */\");\n        add1(src, \"@Override public String toString() {\");\n\n        Iterator<PojoField> it = fields.iterator();\n\n        add2Fmt(src, \"return \\\"%1$s [%2$s=\\\" + %2$s +\", type, it.next().javaName());\n\n        while (it.hasNext())\n            add3(src, String.format(\"\\\", %1$s=\\\" + %1$s +\", it.next().javaName()));\n\n        add3(src, \"\\\"]\\\";\");\n        add1(src, \"}\");\n\n        add0(src, \"}\");\n        add0(src, \"\");\n\n        // Write generated code to file.\n        write(src, out);\n    }","id":60912,"modified_method":"/**\n     * Generate java class code.\n     *\n     * @param pojo POJO descriptor.\n     * @param key {@code true} if key class should be generated.\n     * @param pkg Package name.\n     * @param pkgFolder Folder where to save generated class.\n     * @param constructor {@code true} if empty and full constructors should be generated.\n     * @param includeKeys {@code true} if key fields should be included into value class.\n     * @param askOverwrite Callback to ask user to confirm file overwrite.\n     * @throws IOException If failed to write generated code into file.\n     */\n    private static void generateCode(PojoDescriptor pojo, boolean key, String pkg, File pkgFolder,\n        boolean constructor, boolean includeKeys, ConfirmCallable askOverwrite) throws IOException {\n        String type = key ? pojo.keyClassName() : pojo.valueClassName();\n\n        checkValidJavaIdentifier(pkg, true, \"Package\", type);\n\n        checkValidJavaIdentifier(type, false, \"Type\", type);\n\n        if (!pkgFolder.exists() && !pkgFolder.mkdirs())\n            throw new IOException(\"Failed to create folders for package: \" + pkg);\n\n        File out = new File(pkgFolder, type + \".java\");\n\n        if (out.exists()) {\n            MessageBox.Result choice = askOverwrite.confirm(out.getName());\n\n            if (CANCEL == choice)\n                throw new IllegalStateException(\"POJO generation was canceled!\");\n\n            if (NO == choice || NO_TO_ALL == choice)\n                return;\n        }\n\n        Collection<String> src = new ArrayList<>(256);\n\n        header(src, pkg, type, type + \" implements Serializable\", \"java.io.*\");\n\n        add1(src, \"/** */\");\n        add1(src, \"private static final long serialVersionUID = 0L;\");\n        add0(src, \"\");\n\n        Collection<PojoField> fields = key ? pojo.keyFields() : pojo.valueFields(includeKeys);\n\n        // Generate fields declaration.\n        for (PojoField field : fields) {\n            String fldName = field.javaName();\n\n            checkValidJavaIdentifier(fldName, false, \"Field\", type);\n\n            add1(src, \"/** Value for \" + fldName + \". */\");\n\n            if (key && field.affinityKey())\n                add1(src, \"@AffinityKeyMapped\");\n\n            add1(src, \"private \" + javaTypeName(field) + \" \" + fldName + \";\");\n            add0(src, \"\");\n        }\n\n        // Generate constructors.\n        if (constructor) {\n            add1(src, \"/**\");\n            add1(src, \" * Empty constructor.\");\n            add1(src, \" */\");\n            add1(src, \"public \" + type + \"() {\");\n            add2(src, \"// No-op.\");\n            add1(src, \"}\");\n\n            add0(src, \"\");\n\n            add1(src, \"/**\");\n            add1(src, \" * Full constructor.\");\n            add1(src, \" */\");\n            add1(src, \"public \" + type + \"(\");\n\n            Iterator<PojoField> it = fields.iterator();\n\n            while (it.hasNext()) {\n                PojoField field = it.next();\n\n                add2(src, javaTypeName(field) + \" \" + field.javaName() + (it.hasNext() ? \",\" : \"\"));\n            }\n            add1(src, \") {\");\n\n            for (PojoField field : fields)\n                add2Fmt(src, \"this.%1$s = %1$s;\", field.javaName());\n\n            add1(src, \"}\");\n            add0(src, \"\");\n        }\n\n        // Generate getters and setters methods.\n        for (PojoField field : fields) {\n            String fldName = field.javaName();\n\n            String fldType = javaTypeName(field);\n\n            String mtdName = capitalizeFirst(fldName);\n\n            add1(src, \"/**\");\n            add1(src, \" * Gets \" + fldName + \".\");\n            add1(src, \" *\");\n            add1(src, \" * @return Value for \" + fldName + \".\");\n            add1(src, \" */\");\n            add1(src, \"public \" + fldType + \" get\" + mtdName + \"() {\");\n            add2(src, \"return \" + fldName + \";\");\n            add1(src, \"}\");\n            add0(src, \"\");\n\n            add1(src, \"/**\");\n            add1(src, \" * Sets \" + fldName + \".\");\n            add1(src, \" *\");\n            add1(src, \" * @param \" + fldName + \" New value for \" + fldName + \".\");\n            add1(src, \" */\");\n            add1(src, \"public void set\" + mtdName + \"(\" + fldType + \" \" + fldName + \") {\");\n            add2(src, \"this.\" + fldName + \" = \" + fldName + \";\");\n            add1(src, \"}\");\n            add0(src, \"\");\n        }\n\n        // Generate equals() method.\n        add1(src, \"/** {@inheritDoc} */\");\n        add1(src, \"@Override public boolean equals(Object o) {\");\n        add2(src, \"if (this == o)\");\n        add3(src, \"return true;\");\n        add0(src, \"\");\n\n        add2(src, \"if (!(o instanceof \" + type + \"))\");\n        add3(src, \"return false;\");\n        add0(src, \"\");\n\n        add2Fmt(src, \"%1$s that = (%1$s)o;\", type);\n\n        for (PojoField field : fields) {\n            add0(src, \"\");\n\n            String javaName = field.javaName();\n\n            if (field.primitive()) {\n                switch (field.javaTypeName()) {\n                    case \"float\":\n                        add2Fmt(src, \"if (Float.compare(%1$s, that.%1$s) != 0)\", javaName);\n                        break;\n\n                    case \"double\":\n                        add2Fmt(src, \"if (Double.compare(%1$s, that.%1$s) != 0)\", javaName);\n                        break;\n\n                    default:\n                        add2Fmt(src, \"if (%1$s != that.%1$s)\", javaName);\n                }\n            }\n            else\n                add2Fmt(src, \"if (%1$s != null ? !%1$s.equals(that.%1$s) : that.%1$s != null)\", javaName);\n\n            add3(src, \"return false;\");\n        }\n\n        add0(src, \"\");\n        add2(src, \"return true;\");\n        add1(src, \"}\");\n        add0(src, \"\");\n\n        // Generate hashCode() method.\n        add1(src, \"/** {@inheritDoc} */\");\n        add1(src, \"@Override public int hashCode() {\");\n\n        List<String> hash = new ArrayList<>(fields.size() * 2);\n\n        boolean first = true;\n        boolean tempVar = false;\n\n        for (PojoField field : fields) {\n            String javaName = field.javaName();\n\n            if (!first)\n                add0(hash, \"\");\n\n            if (field.primitive()) {\n                switch (field.javaTypeName()) {\n                    case \"boolean\":\n                        add2Fmt(hash, first ? \"int res = %s ? 1 : 0;\" : \"res = 31 * res + (%s ? 1 : 0);\", javaName);\n                        break;\n\n                    case \"byte\":\n                    case \"short\":\n                        add2Fmt(hash, first ? \"int res = (int)%s;\" : \"res = 31 * res + (int)%s;\", javaName);\n                        break;\n\n                    case \"int\":\n                        add2Fmt(hash, first ? \"int res = %s;\" : \"res = 31 * res + %s;\", javaName);\n                        break;\n\n                    case \"long\":\n                        add2Fmt(hash, first\n                            ? \"int res = (int)(%1$s ^ (%1$s >>> 32));\"\n                            : \"res = 31 * res + (int)(%1$s ^ (%1$s >>> 32));\", javaName);\n                        break;\n\n                    case \"float\":\n                        add2Fmt(hash, first\n                            ? \"int res = %1$s != +0.0f ? Float.floatToIntBits(%1$s) : 0;\"\n                            : \"res = 31 * res + (%1$s != +0.0f ? Float.floatToIntBits(%1$s) : 0);\", javaName);\n                        break;\n\n                    case \"double\":\n                        add2Fmt(hash, (tempVar ? \"ig_hash_temp\" : \"long ig_hash_temp\") +\n                            \" = Double.doubleToLongBits(%s);\", javaName);\n\n                        add0(hash, \"\");\n\n                        add2Fmt(hash, first\n                            ? \"int res = (int)(ig_hash_temp ^ (ig_hash_temp >>> 32));\"\n                            : \"res = 31 * res + (int)(ig_hash_temp ^ (ig_hash_temp >>> 32));\", javaName);\n\n                        tempVar = true;\n                        break;\n                }\n            }\n            else\n                add2Fmt(hash, first ? \"int res = %1$s != null ? %1$s.hashCode() : 0;\"\n                    : \"res = 31 * res + (%1$s != null ? %1$s.hashCode() : 0);\", javaName);\n\n            first = false;\n        }\n\n        for (String line : hash)\n            add0(src, line);\n\n        add0(src, \"\");\n        add2(src, \"return res;\");\n        add1(src, \"}\");\n        add0(src, \"\");\n\n        // Generate toString() method.\n        add1(src, \"/** {@inheritDoc} */\");\n        add1(src, \"@Override public String toString() {\");\n\n        Iterator<PojoField> it = fields.iterator();\n\n        add2Fmt(src, \"return \\\"%1$s [%2$s=\\\" + %2$s +\", type, it.next().javaName());\n\n        while (it.hasNext())\n            add3(src, String.format(\"\\\", %1$s=\\\" + %1$s +\", it.next().javaName()));\n\n        add3(src, \"\\\"]\\\";\");\n        add1(src, \"}\");\n\n        add0(src, \"}\");\n        add0(src, \"\");\n\n        // Write generated code to file.\n        write(src, out);\n    }","commit_id":"122b0f4d83620d296e36d0a7236fc3f60e73d7c1","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Generate java snippet for cache configuration with JDBC store and types metadata.\n     *\n     * @param pojos POJO descriptors.\n     * @param pkg Types package.\n     * @param includeKeys {@code true} if key fields should be included into value class.\n     * @param generateAliases {@code true} if aliases should be generated for query fields.\n     * @param outFolder Output folder.\n     * @param askOverwrite Callback to ask user to confirm file overwrite.\n     * @throws IOException If generation failed.\n     */\n    public static void snippet(Collection<PojoDescriptor> pojos, String pkg, boolean includeKeys,\n        boolean generateAliases, String outFolder, ConfirmCallable askOverwrite) throws IOException {\n        File pkgFolder = new File(outFolder, pkg.replace('.', File.separatorChar));\n\n        File cacheCfg = new File(pkgFolder, \"CacheConfig.java\");\n\n        if (cacheCfg.exists()) {\n            MessageBox.Result choice = askOverwrite.confirm(cacheCfg.getName());\n\n            if (CANCEL == choice)\n                throw new IllegalStateException(\"Java snippet generation was canceled!\");\n\n            if (NO == choice || NO_TO_ALL == choice)\n                return;\n        }\n\n        Collection<String> src = new ArrayList<>(256);\n\n        header(src, pkg, \"java.sql.*;java.util.*;\" +\n            \"org.apache.ignite.cache.*;org.apache.ignite.cache.store.jdbc.*;\" +\n            \"org.apache.ignite.configuration.*\",\n            \"CacheConfig\", \"CacheConfig\");\n\n        // Generate methods for each type in order to avoid compiler error \"java: code too large\".\n        for (PojoDescriptor pojo : pojos) {\n            String tbl = pojo.table();\n            String valClsName = pojo.valueClassName();\n\n            add1(src, \"/**\");\n            add1(src, \" * Create JDBC type for \" + tbl + \".\");\n            add1(src, \" *\");\n            add1(src, \" * @param cacheName Cache name.\");\n            add1(src, \" * @return Configured JDBC type.\");\n            add1(src, \" */\");\n            add1(src, \"private static JdbcType jdbcType\" + valClsName + \"(String cacheName) {\");\n\n            add2(src, \"JdbcType jdbcType = new JdbcType();\");\n            add0(src, \"\");\n\n            add2(src, \"jdbcType.setCacheName(cacheName);\");\n\n            // Database schema.\n            if (pojo.schema() != null)\n                add2(src, \"jdbcType.setDatabaseSchema(\\\"\" + pojo.schema() + \"\\\");\");\n\n            // Database table.\n            add2(src, \"jdbcType.setDatabaseTable(\\\"\" + tbl + \"\\\");\");\n\n            // Java info.\n            add2(src, \"jdbcType.setKeyType(\\\"\" + pkg + \".\" + pojo.keyClassName() + \"\\\");\");\n            add2(src, \"jdbcType.setValueType(\\\"\" + pkg + \".\" + valClsName + \"\\\");\");\n            add0(src, \"\");\n\n            // Key fields.\n            add2(src, \"// Key fields for \" + tbl + \".\");\n            add2(src, \"Collection<JdbcTypeField> keys = new ArrayList<>();\");\n            addFields(src, \"keys\", pojo.keyFields());\n            add2(src, \"jdbcType.setKeyFields(keys.toArray(new JdbcTypeField[keys.size()]));\");\n            add0(src, \"\");\n\n            // Value fields.\n            add2(src, \"// Value fields for \" + tbl + \".\");\n            add2(src, \"Collection<JdbcTypeField> vals = new ArrayList<>();\");\n            addFields(src, \"vals\", pojo.valueFields(includeKeys));\n            add2(src, \"jdbcType.setValueFields(vals.toArray(new JdbcTypeField[vals.size()]));\");\n            add0(src, \"\");\n            add2(src, \"return jdbcType;\");\n            add1(src, \"}\");\n            add0(src, \"\");\n\n            add1(src, \"/**\");\n            add1(src, \" * Create SQL Query descriptor for \" + tbl + \".\");\n            add1(src, \" *\");\n            add1(src, \" * @return Configured query entity.\");\n            add1(src, \" */\");\n            add1(src, \"private static QueryEntity queryEntity\" + valClsName + \"() {\");\n\n            // Query entity.\n            add2(src, \"QueryEntity qryEntity = new QueryEntity();\");\n            add0(src, \"\");\n            add2(src, \"qryEntity.setKeyType(\\\"\" + pkg + \".\" + pojo.keyClassName() + \"\\\");\");\n            add2(src, \"qryEntity.setValueType(\\\"\" + pkg + \".\" + valClsName + \"\\\");\");\n\n            add0(src, \"\");\n\n            // Query fields.\n            add2(src, \"// Query fields for \" + tbl + \".\");\n            add2(src, \"LinkedHashMap<String, String> fields = new LinkedHashMap<>();\");\n            add0(src, \"\");\n\n            for (PojoField field : pojo.fields())\n                add2(src, \"fields.put(\\\"\" + field.javaName() + \"\\\", \\\"\" +\n                    GeneratorUtils.boxPrimitiveType(field.javaTypeName()) + \"\\\");\");\n\n            add0(src, \"\");\n            add2(src, \"qryEntity.setFields(fields);\");\n            add0(src, \"\");\n\n            // Aliases.\n            if (generateAliases) {\n                Collection<PojoField> aliases = new ArrayList<>();\n\n                for (PojoField field : pojo.fields()) {\n                    if (!field.javaName().equalsIgnoreCase(field.dbName()))\n                        aliases.add(field);\n                }\n\n                if (!aliases.isEmpty()) {\n                    add2(src, \"// Aliases for fields.\");\n                    add2(src, \"LinkedHashMap<String, String> aliases = new LinkedHashMap<>();\");\n                    add0(src, \"\");\n\n                    for (PojoField alias : aliases)\n                        add2(src, \"aliases.put(\\\"\" + alias.javaName() + \"\\\", \\\"\" + alias.dbName() + \"\\\");\");\n\n                    add0(src, \"\");\n                    add2(src, \"qryEntity.setAliases(aliases);\");\n                    add0(src, \"\");\n                }\n            }\n\n            // Indexes.\n            Collection<QueryIndex> idxs = pojo.indexes();\n\n            if (!idxs.isEmpty()) {\n                boolean first = true;\n                boolean firstIdx = true;\n\n                for (QueryIndex idx : idxs) {\n                    Set<Map.Entry<String, Boolean>> dbIdxFlds = idx.getFields().entrySet();\n\n                    int sz = dbIdxFlds.size();\n\n                    List<T2<String, Boolean>> idxFlds = new ArrayList<>(sz);\n\n                    for (Map.Entry<String, Boolean> idxFld : dbIdxFlds) {\n                        PojoField field = GeneratorUtils.findFieldByName(pojo.valueFields(true), idxFld.getKey());\n\n                        if (field != null)\n                            idxFlds.add(new T2<>(field.javaName(), idxFld.getValue()));\n                        else\n                            break;\n                    }\n\n                    // Only if all fields present, add index description.\n                    if (idxFlds.size() == sz) {\n                        if (first) {\n                            add2(src, \"// Indexes for \" + tbl + \".\");\n                            add2(src, \"Collection<QueryIndex> idxs = new ArrayList<>();\");\n                            add0(src, \"\");\n                        }\n\n                        if (sz == 1) {\n                            T2<String, Boolean> idxFld = idxFlds.get(0);\n\n                            add2(src, \"idxs.add(new QueryIndex(\\\"\" + idxFld.getKey() + \"\\\", \" + idxFld.getValue() + \", \\\"\" +\n                                idx.getName() + \"\\\"));\");\n                            add0(src, \"\");\n                        }\n                        else {\n                            add2(src, (firstIdx ? \"QueryIndex \" : \"\") + \"idx = new QueryIndex();\");\n                            add0(src, \"\");\n\n                            add2(src, \"idx.setName(\\\"\" + idx.getName() + \"\\\");\");\n                            add0(src, \"\");\n\n                            add2(src, (firstIdx ? \"LinkedHashMap<String, Boolean> \" : \"\") +\n                                \"idxFlds = new LinkedHashMap<>();\");\n                            add0(src, \"\");\n\n                            for (T2<String, Boolean> idxFld : idxFlds)\n                                add2(src, \"idxFlds.put(\\\"\" + idxFld.getKey() + \"\\\", \" + idxFld.getValue() + \");\");\n\n                            add0(src, \"\");\n\n                            add2(src, \"idx.setFields(idxFlds);\");\n                            add0(src, \"\");\n\n                            add2(src, \"idxs.add(idx);\");\n                            add0(src, \"\");\n\n                            firstIdx = false;\n                        }\n\n                        first = false;\n                    }\n                }\n\n                if (!first) {\n                    add2(src, \"qryEntity.setIndexes(idxs);\");\n                    add0(src, \"\");\n                }\n            }\n\n            add2(src, \"return qryEntity;\");\n\n            add1(src, \"}\");\n            add0(src, \"\");\n        }\n\n        add1(src, \"/**\");\n        add1(src, \" * Configure cache.\");\n        add1(src, \" *\");\n        add1(src, \" * @param cacheName Cache name.\");\n        add1(src, \" * @param storeFactory Cache store factory.\");\n        add1(src, \" * @return Cache configuration.\");\n        add1(src, \" */\");\n        add1(src, \"public static <K, V> CacheConfiguration<K, V> cache(String cacheName,\" +\n            \" CacheJdbcPojoStoreFactory<K, V> storeFactory) {\");\n        add2(src, \"if (storeFactory == null)\");\n        add3(src, \" throw new IllegalArgumentException(\\\"Cache store factory cannot be null.\\\");\");\n        add0(src, \"\");\n        add2(src, \"CacheConfiguration<K, V> ccfg = new CacheConfiguration<>(cacheName);\");\n        add0(src, \"\");\n        add2(src, \"ccfg.setCacheStoreFactory(storeFactory);\");\n        add2(src, \"ccfg.setReadThrough(true);\");\n        add2(src, \"ccfg.setWriteThrough(true);\");\n        add0(src, \"\");\n\n        add2(src, \"// Configure JDBC types. \");\n        add2(src, \"Collection<JdbcType> jdbcTypes = new ArrayList<>();\");\n        add0(src, \"\");\n\n        for (PojoDescriptor pojo : pojos)\n            add2(src, \"jdbcTypes.add(jdbcType\" + pojo.valueClassName() + \"(cacheName));\");\n\n        add0(src, \"\");\n\n        add2(src, \"storeFactory.setTypes(jdbcTypes.toArray(new JdbcType[jdbcTypes.size()]));\");\n        add0(src, \"\");\n\n\n        add2(src, \"// Configure query entities. \");\n        add2(src, \"Collection<QueryEntity> qryEntities = new ArrayList<>();\");\n        add0(src, \"\");\n\n        for (PojoDescriptor pojo : pojos)\n            add2(src, \"qryEntities.add(queryEntity\" + pojo.valueClassName() + \"());\");\n\n        add0(src, \"\");\n\n        add2(src, \"ccfg.setQueryEntities(qryEntities);\");\n        add0(src, \"\");\n\n        add2(src, \"return ccfg;\");\n        add1(src, \"}\");\n\n        add0(src, \"}\");\n\n        write(src, cacheCfg);\n    }","id":60913,"modified_method":"/**\n     * Generate java snippet for cache configuration with JDBC store and types metadata.\n     *\n     * @param pojos POJO descriptors.\n     * @param pkg Types package.\n     * @param includeKeys {@code true} if key fields should be included into value class.\n     * @param generateAliases {@code true} if aliases should be generated for query fields.\n     * @param outFolder Output folder.\n     * @param askOverwrite Callback to ask user to confirm file overwrite.\n     * @throws IOException If generation failed.\n     */\n    public static void snippet(Collection<PojoDescriptor> pojos, String pkg, boolean includeKeys,\n        boolean generateAliases, String outFolder, ConfirmCallable askOverwrite) throws IOException {\n        File pkgFolder = new File(outFolder, pkg.replace('.', File.separatorChar));\n\n        File cacheCfg = new File(pkgFolder, \"CacheConfig.java\");\n\n        if (cacheCfg.exists()) {\n            MessageBox.Result choice = askOverwrite.confirm(cacheCfg.getName());\n\n            if (CANCEL == choice)\n                throw new IllegalStateException(\"Java snippet generation was canceled!\");\n\n            if (NO == choice || NO_TO_ALL == choice)\n                return;\n        }\n\n        Collection<String> src = new ArrayList<>(256);\n\n        header(src, pkg, \"CacheConfig\", \"CacheConfig\", \"java.sql.*\", \"java.util.*\", \"\", \"org.apache.ignite.cache.*\",\n            \"org.apache.ignite.cache.store.jdbc.*\", \"org.apache.ignite.configuration.*\");\n\n        // Generate methods for each type in order to avoid compiler error \"java: code too large\".\n        for (PojoDescriptor pojo : pojos) {\n            String tbl = pojo.table();\n            String valClsName = pojo.valueClassName();\n            Collection<PojoField> fields = pojo.valueFields(true);\n\n            add1(src, \"/**\");\n            add1(src, \" * Create JDBC type for \" + tbl + \".\");\n            add1(src, \" *\");\n            add1(src, \" * @param cacheName Cache name.\");\n            add1(src, \" * @return Configured JDBC type.\");\n            add1(src, \" */\");\n            add1(src, \"private static JdbcType jdbcType\" + valClsName + \"(String cacheName) {\");\n\n            add2(src, \"JdbcType jdbcType = new JdbcType();\");\n            add0(src, \"\");\n\n            add2(src, \"jdbcType.setCacheName(cacheName);\");\n\n            // Database schema.\n            if (pojo.schema() != null)\n                add2(src, \"jdbcType.setDatabaseSchema(\\\"\" + pojo.schema() + \"\\\");\");\n\n            // Database table.\n            add2(src, \"jdbcType.setDatabaseTable(\\\"\" + tbl + \"\\\");\");\n\n            // Java info.\n            add2(src, \"jdbcType.setKeyType(\\\"\" + pkg + \".\" + pojo.keyClassName() + \"\\\");\");\n            add2(src, \"jdbcType.setValueType(\\\"\" + pkg + \".\" + valClsName + \"\\\");\");\n            add0(src, \"\");\n\n            // Key fields.\n            add2(src, \"// Key fields for \" + tbl + \".\");\n            add2(src, \"Collection<JdbcTypeField> keys = new ArrayList<>();\");\n            addFields(src, \"keys\", pojo.keyFields());\n            add2(src, \"jdbcType.setKeyFields(keys.toArray(new JdbcTypeField[keys.size()]));\");\n            add0(src, \"\");\n\n            // Value fields.\n            add2(src, \"// Value fields for \" + tbl + \".\");\n            add2(src, \"Collection<JdbcTypeField> vals = new ArrayList<>();\");\n            addFields(src, \"vals\", pojo.valueFields(includeKeys));\n            add2(src, \"jdbcType.setValueFields(vals.toArray(new JdbcTypeField[vals.size()]));\");\n            add0(src, \"\");\n            add2(src, \"return jdbcType;\");\n            add1(src, \"}\");\n            add0(src, \"\");\n\n            add1(src, \"/**\");\n            add1(src, \" * Create SQL Query descriptor for \" + tbl + \".\");\n            add1(src, \" *\");\n            add1(src, \" * @return Configured query entity.\");\n            add1(src, \" */\");\n            add1(src, \"private static QueryEntity queryEntity\" + valClsName + \"() {\");\n\n            // Query entity.\n            add2(src, \"QueryEntity qryEntity = new QueryEntity();\");\n            add0(src, \"\");\n            add2(src, \"qryEntity.setKeyType(\\\"\" + pkg + \".\" + pojo.keyClassName() + \"\\\");\");\n            add2(src, \"qryEntity.setValueType(\\\"\" + pkg + \".\" + valClsName + \"\\\");\");\n\n            add0(src, \"\");\n\n            // Query fields.\n            add2(src, \"// Query fields for \" + tbl + \".\");\n            add2(src, \"LinkedHashMap<String, String> fields = new LinkedHashMap<>();\");\n            add0(src, \"\");\n\n            for (PojoField field : fields)\n                add2(src, \"fields.put(\\\"\" + field.javaName() + \"\\\", \\\"\" +\n                    GeneratorUtils.boxPrimitiveType(field.javaTypeName()) + \"\\\");\");\n\n            add0(src, \"\");\n            add2(src, \"qryEntity.setFields(fields);\");\n            add0(src, \"\");\n\n            // Aliases.\n            if (generateAliases) {\n                Collection<PojoField> aliases = new ArrayList<>();\n\n                for (PojoField field : fields) {\n                    if (!field.javaName().equalsIgnoreCase(field.dbName()))\n                        aliases.add(field);\n                }\n\n                if (!aliases.isEmpty()) {\n                    add2(src, \"// Aliases for fields.\");\n                    add2(src, \"Map<String, String> aliases = new HashMap<>();\");\n                    add0(src, \"\");\n\n                    for (PojoField alias : aliases)\n                        add2(src, \"aliases.put(\\\"\" + alias.javaName() + \"\\\", \\\"\" + alias.dbName() + \"\\\");\");\n\n                    add0(src, \"\");\n                    add2(src, \"qryEntity.setAliases(aliases);\");\n                    add0(src, \"\");\n                }\n            }\n\n            // Indexes.\n            Collection<QueryIndex> idxs = pojo.indexes();\n\n            if (!idxs.isEmpty()) {\n                boolean first = true;\n                boolean firstIdx = true;\n\n                for (QueryIndex idx : idxs) {\n                    Set<Map.Entry<String, Boolean>> dbIdxFlds = idx.getFields().entrySet();\n\n                    int sz = dbIdxFlds.size();\n\n                    List<T2<String, Boolean>> idxFlds = new ArrayList<>(sz);\n\n                    for (Map.Entry<String, Boolean> idxFld : dbIdxFlds) {\n                        PojoField field = GeneratorUtils.findFieldByName(fields, idxFld.getKey());\n\n                        if (field != null)\n                            idxFlds.add(new T2<>(field.javaName(), idxFld.getValue()));\n                        else\n                            break;\n                    }\n\n                    // Only if all fields present, add index description.\n                    if (idxFlds.size() == sz) {\n                        if (first) {\n                            add2(src, \"// Indexes for \" + tbl + \".\");\n                            add2(src, \"Collection<QueryIndex> idxs = new ArrayList<>();\");\n                            add0(src, \"\");\n                        }\n\n                        if (sz == 1) {\n                            T2<String, Boolean> idxFld = idxFlds.get(0);\n\n                            add2(src, \"idxs.add(new QueryIndex(\\\"\" + idxFld.getKey() + \"\\\", \" + idxFld.getValue() + \", \\\"\" +\n                                idx.getName() + \"\\\"));\");\n                            add0(src, \"\");\n                        }\n                        else {\n                            add2(src, (firstIdx ? \"QueryIndex \" : \"\") + \"idx = new QueryIndex();\");\n                            add0(src, \"\");\n\n                            add2(src, \"idx.setName(\\\"\" + idx.getName() + \"\\\");\");\n                            add0(src, \"\");\n\n                            add2(src, (firstIdx ? \"LinkedHashMap<String, Boolean> \" : \"\") +\n                                \"idxFlds = new LinkedHashMap<>();\");\n                            add0(src, \"\");\n\n                            for (T2<String, Boolean> idxFld : idxFlds)\n                                add2(src, \"idxFlds.put(\\\"\" + idxFld.getKey() + \"\\\", \" + idxFld.getValue() + \");\");\n\n                            add0(src, \"\");\n\n                            add2(src, \"idx.setFields(idxFlds);\");\n                            add0(src, \"\");\n\n                            add2(src, \"idxs.add(idx);\");\n                            add0(src, \"\");\n\n                            firstIdx = false;\n                        }\n\n                        first = false;\n                    }\n                }\n\n                if (!first) {\n                    add2(src, \"qryEntity.setIndexes(idxs);\");\n                    add0(src, \"\");\n                }\n            }\n\n            add2(src, \"return qryEntity;\");\n\n            add1(src, \"}\");\n            add0(src, \"\");\n        }\n\n        add1(src, \"/**\");\n        add1(src, \" * Configure cache.\");\n        add1(src, \" *\");\n        add1(src, \" * @param cacheName Cache name.\");\n        add1(src, \" * @param storeFactory Cache store factory.\");\n        add1(src, \" * @return Cache configuration.\");\n        add1(src, \" */\");\n        add1(src, \"public static <K, V> CacheConfiguration<K, V> cache(String cacheName,\" +\n            \" CacheJdbcPojoStoreFactory<K, V> storeFactory) {\");\n        add2(src, \"if (storeFactory == null)\");\n        add3(src, \" throw new IllegalArgumentException(\\\"Cache store factory cannot be null.\\\");\");\n        add0(src, \"\");\n        add2(src, \"CacheConfiguration<K, V> ccfg = new CacheConfiguration<>(cacheName);\");\n        add0(src, \"\");\n        add2(src, \"ccfg.setCacheStoreFactory(storeFactory);\");\n        add2(src, \"ccfg.setReadThrough(true);\");\n        add2(src, \"ccfg.setWriteThrough(true);\");\n        add0(src, \"\");\n\n        add2(src, \"// Configure JDBC types. \");\n        add2(src, \"Collection<JdbcType> jdbcTypes = new ArrayList<>();\");\n        add0(src, \"\");\n\n        for (PojoDescriptor pojo : pojos)\n            add2(src, \"jdbcTypes.add(jdbcType\" + pojo.valueClassName() + \"(cacheName));\");\n\n        add0(src, \"\");\n\n        add2(src, \"storeFactory.setTypes(jdbcTypes.toArray(new JdbcType[jdbcTypes.size()]));\");\n        add0(src, \"\");\n\n\n        add2(src, \"// Configure query entities. \");\n        add2(src, \"Collection<QueryEntity> qryEntities = new ArrayList<>();\");\n        add0(src, \"\");\n\n        for (PojoDescriptor pojo : pojos)\n            add2(src, \"qryEntities.add(queryEntity\" + pojo.valueClassName() + \"());\");\n\n        add0(src, \"\");\n\n        add2(src, \"ccfg.setQueryEntities(qryEntities);\");\n        add0(src, \"\");\n\n        add2(src, \"return ccfg;\");\n        add1(src, \"}\");\n\n        add0(src, \"}\");\n\n        write(src, cacheCfg);\n    }","commit_id":"122b0f4d83620d296e36d0a7236fc3f60e73d7c1","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Generate class header.\n     *\n     * @param src Source code.\n     * @param pkg Package name.\n     * @param imports Optional imports.\n     * @param desc Class description.\n     * @param cls Class declaration.\n     */\n    private static void header(Collection<String> src, String pkg, String imports, String desc, String cls) {\n        // License.\n        add0(src, \"/*\");\n        add0(src, \" * Licensed to the Apache Software Foundation (ASF) under one or more\");\n        add0(src, \" * contributor license agreements.  See the NOTICE file distributed with\");\n        add0(src, \" * this work for additional information regarding copyright ownership.\");\n        add0(src, \" * The ASF licenses this file to You under the Apache License, Version 2.0\");\n        add0(src, \" * (the \\\"License\\\"); you may not use this file except in compliance with\");\n        add0(src, \" * the License.  You may obtain a copy of the License at\");\n        add0(src, \" *\");\n        add0(src, \" *      http://www.apache.org/licenses/LICENSE-2.0\");\n        add0(src, \" *\");\n        add0(src, \" * Unless required by applicable law or agreed to in writing, software\");\n        add0(src, \" * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\");\n        add0(src, \" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\");\n        add0(src, \" * See the License for the specific language governing permissions and\");\n        add0(src, \" * limitations under the License.\");\n        add0(src, \" */\");\n        add0(src, \"\");\n\n        // Package.\n        add0(src, \"package \" + pkg + \";\");\n        add0(src, \"\");\n\n        // Imports.\n        if (!imports.isEmpty()) {\n            for (String imp : imports.split(\";\"))\n                if (imp.isEmpty())\n                    add0(src, \"\");\n                else\n                    add0(src, \"import \" + imp + \";\");\n\n            add0(src, \"\");\n        }\n\n        // Class.\n        add0(src, \"/**\");\n        add0(src, \" * \" + desc + \" definition.\");\n        add0(src, \" *\");\n        add0(src, \" * Code generated by Apache Ignite Schema Import utility: \"\n            + new SimpleDateFormat(\"MM/dd/yyyy\").format(new Date()) + \".\");\n        add0(src, \" */\");\n        add0(src, \"public class \" + cls + \" {\");\n    }","id":60914,"modified_method":"/**\n     * Generate class header.\n     *\n     * @param src Source code.\n     * @param pkg Package name.\n     * @param desc Class description.\n     * @param cls Class declaration.\n     * @param imports Optional imports.\n     */\n    private static void header(Collection<String> src, String pkg, String desc, String cls, String... imports) {\n        // License.\n        add0(src, \"/*\");\n        add0(src, \" * Licensed to the Apache Software Foundation (ASF) under one or more\");\n        add0(src, \" * contributor license agreements.  See the NOTICE file distributed with\");\n        add0(src, \" * this work for additional information regarding copyright ownership.\");\n        add0(src, \" * The ASF licenses this file to You under the Apache License, Version 2.0\");\n        add0(src, \" * (the \\\"License\\\"); you may not use this file except in compliance with\");\n        add0(src, \" * the License.  You may obtain a copy of the License at\");\n        add0(src, \" *\");\n        add0(src, \" *      http://www.apache.org/licenses/LICENSE-2.0\");\n        add0(src, \" *\");\n        add0(src, \" * Unless required by applicable law or agreed to in writing, software\");\n        add0(src, \" * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\");\n        add0(src, \" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\");\n        add0(src, \" * See the License for the specific language governing permissions and\");\n        add0(src, \" * limitations under the License.\");\n        add0(src, \" */\");\n        add0(src, \"\");\n\n        // Package.\n        add0(src, \"package \" + pkg + \";\");\n        add0(src, \"\");\n\n        // Imports.\n        if (imports != null && imports.length > 0) {\n            for (String imp : imports)\n                add0(src, imp.isEmpty() ? \"\" : \"import \" + imp + \";\");\n\n            add0(src, \"\");\n        }\n\n        // Class.\n        add0(src, \"/**\");\n        add0(src, \" * \" + desc + \" definition.\");\n        add0(src, \" *\");\n        add0(src, \" * Code generated by Apache Ignite Schema Import utility: \"\n            + new SimpleDateFormat(\"MM/dd/yyyy\").format(new Date()) + \".\");\n        add0(src, \" */\");\n        add0(src, \"public class \" + cls + \" {\");\n    }","commit_id":"122b0f4d83620d296e36d0a7236fc3f60e73d7c1","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Add query field aliases to xml document.\n     *\n     * @param doc XML document.\n     * @param parent Parent XML node.\n     * @param fields Map with fields.\n     */\n    private static void addQueryFieldAliases(Document doc, Node parent, Collection<PojoField> fields) {\n        Collection<PojoField> aliases = new ArrayList<>();\n\n        for (PojoField field : fields) {\n            if (!field.javaName().equalsIgnoreCase(field.dbName()))\n                aliases.add(field);\n        }\n\n        if (!aliases.isEmpty()) {\n            Element prop = addProperty(doc, parent, \"aliases\", null);\n\n            Element map = addElement(doc, prop, \"util:map\", \"map-class\", \"java.util.LinkedHashMap\");\n\n            for (PojoField alias : aliases)\n                addElement(doc, map, \"entry\", \"key\", alias.javaName(), \"value\", alias.dbName());\n        }\n    }","id":60915,"modified_method":"/**\n     * Add query field aliases to xml document.\n     *\n     * @param doc XML document.\n     * @param parent Parent XML node.\n     * @param fields Map with fields.\n     */\n    private static void addQueryFieldAliases(Document doc, Node parent, Collection<PojoField> fields) {\n        Collection<PojoField> aliases = new ArrayList<>();\n\n        for (PojoField field : fields) {\n            if (!field.javaName().equalsIgnoreCase(field.dbName()))\n                aliases.add(field);\n        }\n\n        if (!aliases.isEmpty()) {\n            Element prop = addProperty(doc, parent, \"aliases\", null);\n\n            Element map = addElement(doc, prop, \"map\");\n\n            for (PojoField alias : aliases)\n                addElement(doc, map, \"entry\", \"key\", alias.javaName(), \"value\", alias.dbName());\n        }\n    }","commit_id":"122b0f4d83620d296e36d0a7236fc3f60e73d7c1","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Generate java snippet for cache configuration with JDBC store and types metadata.\n     *\n     * @param pojos POJO descriptors.\n     * @param pkg Types package.\n     * @param includeKeys {@code true} if key fields should be included into value class.\n     * @param outFolder Output folder.\n     * @param askOverwrite Callback to ask user to confirm file overwrite.\n     * @throws IOException If generation failed.\n     */\n    public static void snippet(Collection<PojoDescriptor> pojos, String pkg, boolean includeKeys,\n        String outFolder, ConfirmCallable askOverwrite) throws IOException {\n        File pkgFolder = new File(outFolder, pkg.replace('.', File.separatorChar));\n\n        File cacheCfg = new File(pkgFolder, \"CacheConfig.java\");\n\n        if (cacheCfg.exists()) {\n            MessageBox.Result choice = askOverwrite.confirm(cacheCfg.getName());\n\n            if (CANCEL == choice)\n                throw new IllegalStateException(\"Java snippet generation was canceled!\");\n\n            if (NO == choice || NO_TO_ALL == choice)\n                return;\n        }\n\n        Collection<String> src = new ArrayList<>(256);\n\n        header(src, pkg, \"java.sql.*;java.util.*;\" +\n            \"org.apache.ignite.cache.*;org.apache.ignite.cache.store.jdbc.*;\" +\n            \"org.apache.ignite.configuration.*\",\n            \"CacheConfig\", \"CacheConfig\");\n\n        // Generate methods for each type in order to avoid compiler error \"java: code too large\".\n        for (PojoDescriptor pojo : pojos) {\n            String tbl = pojo.table();\n            String valClsName = pojo.valueClassName();\n\n            add1(src, \"/**\");\n            add1(src, \" * Create JDBC type for \" + tbl + \".\");\n            add1(src, \" *\");\n            add1(src, \" * @param cacheName Cache name.\");\n            add1(src, \" * @return Configured JDBC type.\");\n            add1(src, \" */\");\n            add1(src, \"private static JdbcType jdbcType\" + valClsName + \"(String cacheName) {\");\n\n            add2(src, \"JdbcType jdbcType = new JdbcType();\");\n            add0(src, \"\");\n\n            add2(src, \"jdbcType.setCacheName(cacheName);\");\n\n            // Database schema.\n            if (pojo.schema() != null)\n                add2(src, \"jdbcType.setDatabaseSchema(\\\"\" + pojo.schema() + \"\\\");\");\n\n            // Database table.\n            add2(src, \"jdbcType.setDatabaseTable(\\\"\" + tbl + \"\\\");\");\n\n            // Java info.\n            add2(src, \"jdbcType.setKeyType(\\\"\" + pkg + \".\" + pojo.keyClassName() + \"\\\");\");\n            add2(src, \"jdbcType.setValueType(\\\"\" + pkg + \".\" + valClsName + \"\\\");\");\n            add0(src, \"\");\n\n            // Key fields.\n            add2(src, \"// Key fields for \" + tbl + \".\");\n            add2(src, \"Collection<JdbcTypeField> keys = new ArrayList<>();\");\n            addFields(src, \"keys\", pojo.keyFields());\n            add2(src, \"jdbcType.setKeyFields(keys.toArray(new JdbcTypeField[keys.size()]));\");\n            add0(src, \"\");\n\n            // Value fields.\n            add2(src, \"// Value fields for \" + tbl + \".\");\n            add2(src, \"Collection<JdbcTypeField> vals = new ArrayList<>();\");\n            addFields(src, \"vals\", pojo.valueFields(includeKeys));\n            add2(src, \"jdbcType.setValueFields(vals.toArray(new JdbcTypeField[vals.size()]));\");\n            add0(src, \"\");\n            add2(src, \"return jdbcType;\");\n            add1(src, \"}\");\n            add0(src, \"\");\n\n            add1(src, \"/**\");\n            add1(src, \" * Create SQL Query descriptor for \" + tbl + \".\");\n            add1(src, \" *\");\n            add1(src, \" * @return Configured query entity.\");\n            add1(src, \" */\");\n            add1(src, \"private static QueryEntity queryEntity\" + valClsName + \"() {\");\n\n            // Query entity.\n            add2(src, \"QueryEntity qryEntity = new QueryEntity();\");\n            add0(src, \"\");\n            add2(src, \"qryEntity.setKeyType(\\\"\" + pkg + \".\" + pojo.keyClassName() + \"\\\");\");\n            add2(src, \"qryEntity.setValueType(\\\"\" + pkg + \".\" + valClsName + \"\\\");\");\n\n            add0(src, \"\");\n\n            // Query fields.\n            add2(src, \"// Query fields for \" + tbl + \".\");\n            add2(src, \"LinkedHashMap<String, String> fields = new LinkedHashMap<>();\");\n            add0(src, \"\");\n\n            for (PojoField field : pojo.fields())\n                add2(src, \"fields.put(\\\"\" + field.javaName() + \"\\\", \\\"\" + javaTypeName(field) + \"\\\");\");\n\n            add0(src, \"\");\n            add2(src, \"qryEntity.setFields(fields);\");\n            add0(src, \"\");\n\n            // Indexes.\n            Collection<QueryIndex> idxs = pojo.indexes();\n\n            if (!idxs.isEmpty()) {\n                add2(src, \"// Indexes for \" + tbl + \".\");\n                add2(src, \"Collection<QueryIndex> idxs = new ArrayList<>();\");\n                add0(src, \"\");\n\n                boolean firstIdx = true;\n\n                for (QueryIndex idx : idxs) {\n                    if (idx.getFields().size() == 1) {\n                        Map.Entry<String, Boolean> fld = F.first(idx.getFields().entrySet());\n\n                        add2(src, \"idxs.add(new QueryIndex(\\\"\" + fld.getKey() + \"\\\", \" + fld.getValue() + \", \\\"\" +\n                            idx.getName() + \"\\\"));\");\n                        add0(src, \"\");\n                    }\n                    else {\n                        add2(src, (firstIdx ? \"QueryIndex \" : \"\") + \"idx = new QueryIndex();\");\n                        add0(src, \"\");\n\n                        add2(src, \"idx.setName(\\\"\" + idx.getName() + \"\\\");\");\n                        add0(src, \"\");\n\n                        add2(src, (firstIdx ? \"LinkedHashMap<String, Boolean> \" : \"\") +\n                            \"idxFlds = new LinkedHashMap<>();\");\n                        add0(src, \"\");\n\n                        for (Map.Entry<String, Boolean> idxFld : idx.getFields().entrySet())\n                            add2(src, \"idxFlds.put(\\\"\" + idxFld.getKey() + \"\\\", \" + idxFld.getValue() + \");\");\n\n                        add0(src, \"\");\n\n                        add2(src, \"idx.setFields(idxFlds);\");\n                        add0(src, \"\");\n\n                        add2(src, \"idxs.add(idx);\");\n                        add0(src, \"\");\n\n                        firstIdx = false;\n                    }\n                }\n\n                add2(src, \"qryEntity.setIndexes(idxs);\");\n                add0(src, \"\");\n            }\n\n            add2(src, \"return qryEntity;\");\n\n            add1(src, \"}\");\n            add0(src, \"\");\n        }\n\n        add1(src, \"/**\");\n        add1(src, \" * Configure cache.\");\n        add1(src, \" *\");\n        add1(src, \" * @param cacheName Cache name.\");\n        add1(src, \" * @param storeFactory Cache store factory.\");\n        add1(src, \" * @return Cache configuration.\");\n        add1(src, \" */\");\n        add1(src, \"public static <K, V> CacheConfiguration<K, V> cache(String cacheName,\" +\n            \" CacheJdbcPojoStoreFactory<K, V> storeFactory) {\");\n        add2(src, \"if (storeFactory == null)\");\n        add3(src, \" throw new IllegalArgumentException(\\\"Cache store factory cannot be null.\\\");\");\n        add0(src, \"\");\n        add2(src, \"CacheConfiguration<K, V> ccfg = new CacheConfiguration<>(cacheName);\");\n        add0(src, \"\");\n        add2(src, \"ccfg.setCacheStoreFactory(storeFactory);\");\n        add2(src, \"ccfg.setReadThrough(true);\");\n        add2(src, \"ccfg.setWriteThrough(true);\");\n        add0(src, \"\");\n\n        add2(src, \"// Configure JDBC types. \");\n        add2(src, \"Collection<JdbcType> jdbcTypes = new ArrayList<>();\");\n        add0(src, \"\");\n\n        for (PojoDescriptor pojo : pojos)\n            add2(src, \"jdbcTypes.add(jdbcType\" + pojo.valueClassName() + \"(cacheName));\");\n\n        add0(src, \"\");\n\n        add2(src, \"storeFactory.setTypes(jdbcTypes.toArray(new JdbcType[jdbcTypes.size()]));\");\n        add0(src, \"\");\n\n\n        add2(src, \"// Configure query entities. \");\n        add2(src, \"Collection<QueryEntity> qryEntities = new ArrayList<>();\");\n        add0(src, \"\");\n\n        for (PojoDescriptor pojo : pojos)\n            add2(src, \"qryEntities.add(queryEntity\" + pojo.valueClassName() + \"());\");\n\n        add0(src, \"\");\n\n        add2(src, \"ccfg.setQueryEntities(qryEntities);\");\n        add0(src, \"\");\n\n        add2(src, \"return ccfg;\");\n        add1(src, \"}\");\n\n        add0(src, \"}\");\n\n        write(src, cacheCfg);\n    }","id":60916,"modified_method":"/**\n     * Generate java snippet for cache configuration with JDBC store and types metadata.\n     *\n     * @param pojos POJO descriptors.\n     * @param pkg Types package.\n     * @param includeKeys {@code true} if key fields should be included into value class.\n     * @param outFolder Output folder.\n     * @param askOverwrite Callback to ask user to confirm file overwrite.\n     * @throws IOException If generation failed.\n     */\n    public static void snippet(Collection<PojoDescriptor> pojos, String pkg, boolean includeKeys,\n        String outFolder, ConfirmCallable askOverwrite) throws IOException {\n        File pkgFolder = new File(outFolder, pkg.replace('.', File.separatorChar));\n\n        File cacheCfg = new File(pkgFolder, \"CacheConfig.java\");\n\n        if (cacheCfg.exists()) {\n            MessageBox.Result choice = askOverwrite.confirm(cacheCfg.getName());\n\n            if (CANCEL == choice)\n                throw new IllegalStateException(\"Java snippet generation was canceled!\");\n\n            if (NO == choice || NO_TO_ALL == choice)\n                return;\n        }\n\n        Collection<String> src = new ArrayList<>(256);\n\n        header(src, pkg, \"java.sql.*;java.util.*;\" +\n            \"org.apache.ignite.cache.*;org.apache.ignite.cache.store.jdbc.*;\" +\n            \"org.apache.ignite.configuration.*\",\n            \"CacheConfig\", \"CacheConfig\");\n\n        // Generate methods for each type in order to avoid compiler error \"java: code too large\".\n        for (PojoDescriptor pojo : pojos) {\n            String tbl = pojo.table();\n            String valClsName = pojo.valueClassName();\n\n            add1(src, \"/**\");\n            add1(src, \" * Create JDBC type for \" + tbl + \".\");\n            add1(src, \" *\");\n            add1(src, \" * @param cacheName Cache name.\");\n            add1(src, \" * @return Configured JDBC type.\");\n            add1(src, \" */\");\n            add1(src, \"private static JdbcType jdbcType\" + valClsName + \"(String cacheName) {\");\n\n            add2(src, \"JdbcType jdbcType = new JdbcType();\");\n            add0(src, \"\");\n\n            add2(src, \"jdbcType.setCacheName(cacheName);\");\n\n            // Database schema.\n            if (pojo.schema() != null)\n                add2(src, \"jdbcType.setDatabaseSchema(\\\"\" + pojo.schema() + \"\\\");\");\n\n            // Database table.\n            add2(src, \"jdbcType.setDatabaseTable(\\\"\" + tbl + \"\\\");\");\n\n            // Java info.\n            add2(src, \"jdbcType.setKeyType(\\\"\" + pkg + \".\" + pojo.keyClassName() + \"\\\");\");\n            add2(src, \"jdbcType.setValueType(\\\"\" + pkg + \".\" + valClsName + \"\\\");\");\n            add0(src, \"\");\n\n            // Key fields.\n            add2(src, \"// Key fields for \" + tbl + \".\");\n            add2(src, \"Collection<JdbcTypeField> keys = new ArrayList<>();\");\n            addFields(src, \"keys\", pojo.keyFields());\n            add2(src, \"jdbcType.setKeyFields(keys.toArray(new JdbcTypeField[keys.size()]));\");\n            add0(src, \"\");\n\n            // Value fields.\n            add2(src, \"// Value fields for \" + tbl + \".\");\n            add2(src, \"Collection<JdbcTypeField> vals = new ArrayList<>();\");\n            addFields(src, \"vals\", pojo.valueFields(includeKeys));\n            add2(src, \"jdbcType.setValueFields(vals.toArray(new JdbcTypeField[vals.size()]));\");\n            add0(src, \"\");\n            add2(src, \"return jdbcType;\");\n            add1(src, \"}\");\n            add0(src, \"\");\n\n            add1(src, \"/**\");\n            add1(src, \" * Create SQL Query descriptor for \" + tbl + \".\");\n            add1(src, \" *\");\n            add1(src, \" * @return Configured query entity.\");\n            add1(src, \" */\");\n            add1(src, \"private static QueryEntity queryEntity\" + valClsName + \"() {\");\n\n            // Query entity.\n            add2(src, \"QueryEntity qryEntity = new QueryEntity();\");\n            add0(src, \"\");\n            add2(src, \"qryEntity.setKeyType(\\\"\" + pkg + \".\" + pojo.keyClassName() + \"\\\");\");\n            add2(src, \"qryEntity.setValueType(\\\"\" + pkg + \".\" + valClsName + \"\\\");\");\n\n            add0(src, \"\");\n\n            // Query fields.\n            add2(src, \"// Query fields for \" + tbl + \".\");\n            add2(src, \"LinkedHashMap<String, String> fields = new LinkedHashMap<>();\");\n            add0(src, \"\");\n\n            for (PojoField field : pojo.fields())\n                add2(src, \"fields.put(\\\"\" + field.javaName() + \"\\\", \\\"\" + javaTypeName(field) + \"\\\");\");\n\n            add0(src, \"\");\n            add2(src, \"qryEntity.setFields(fields);\");\n            add0(src, \"\");\n\n            // Indexes.\n            Collection<QueryIndex> idxs = pojo.indexes();\n\n            if (!idxs.isEmpty()) {\n                boolean first = true;\n                boolean firstIdx = true;\n\n                for (QueryIndex idx : idxs) {\n                    Set<Map.Entry<String, Boolean>> dbIdxFlds = idx.getFields().entrySet();\n\n                    int sz = dbIdxFlds.size();\n\n                    List<T2<String, Boolean>> idxFlds = new ArrayList<>(sz);\n\n                    for (Map.Entry<String, Boolean> idxFld : dbIdxFlds) {\n                        PojoField field = findFieldByName(pojo, idxFld.getKey());\n\n                        if (field != null)\n                            idxFlds.add(new T2<>(field.javaName(), idxFld.getValue()));\n                        else\n                            break;\n                    }\n\n                    // Only if all fields present, add index description.\n                    if (idxFlds.size() == sz) {\n                        if (first) {\n                            add2(src, \"// Indexes for \" + tbl + \".\");\n                            add2(src, \"Collection<QueryIndex> idxs = new ArrayList<>();\");\n                            add0(src, \"\");\n                        }\n\n                        if (sz == 1) {\n                            T2<String, Boolean> idxFld = idxFlds.get(0);\n\n                            add2(src, \"idxs.add(new QueryIndex(\\\"\" + idxFld.getKey() + \"\\\", \" + idxFld.getValue() + \", \\\"\" +\n                                idx.getName() + \"\\\"));\");\n                            add0(src, \"\");\n                        }\n                        else {\n                            add2(src, (firstIdx ? \"QueryIndex \" : \"\") + \"idx = new QueryIndex();\");\n                            add0(src, \"\");\n\n                            add2(src, \"idx.setName(\\\"\" + idx.getName() + \"\\\");\");\n                            add0(src, \"\");\n\n                            add2(src, (firstIdx ? \"LinkedHashMap<String, Boolean> \" : \"\") +\n                                \"idxFlds = new LinkedHashMap<>();\");\n                            add0(src, \"\");\n\n                            for (T2<String, Boolean> idxFld : idxFlds)\n                                add2(src, \"idxFlds.put(\\\"\" + idxFld.getKey() + \"\\\", \" + idxFld.getValue() + \");\");\n\n                            add0(src, \"\");\n\n                            add2(src, \"idx.setFields(idxFlds);\");\n                            add0(src, \"\");\n\n                            add2(src, \"idxs.add(idx);\");\n                            add0(src, \"\");\n\n                            firstIdx = false;\n                        }\n\n                        first = false;\n                    }\n                }\n\n                if (!first) {\n                    add2(src, \"qryEntity.setIndexes(idxs);\");\n                    add0(src, \"\");\n                }\n            }\n\n            add2(src, \"return qryEntity;\");\n\n            add1(src, \"}\");\n            add0(src, \"\");\n        }\n\n        add1(src, \"/**\");\n        add1(src, \" * Configure cache.\");\n        add1(src, \" *\");\n        add1(src, \" * @param cacheName Cache name.\");\n        add1(src, \" * @param storeFactory Cache store factory.\");\n        add1(src, \" * @return Cache configuration.\");\n        add1(src, \" */\");\n        add1(src, \"public static <K, V> CacheConfiguration<K, V> cache(String cacheName,\" +\n            \" CacheJdbcPojoStoreFactory<K, V> storeFactory) {\");\n        add2(src, \"if (storeFactory == null)\");\n        add3(src, \" throw new IllegalArgumentException(\\\"Cache store factory cannot be null.\\\");\");\n        add0(src, \"\");\n        add2(src, \"CacheConfiguration<K, V> ccfg = new CacheConfiguration<>(cacheName);\");\n        add0(src, \"\");\n        add2(src, \"ccfg.setCacheStoreFactory(storeFactory);\");\n        add2(src, \"ccfg.setReadThrough(true);\");\n        add2(src, \"ccfg.setWriteThrough(true);\");\n        add0(src, \"\");\n\n        add2(src, \"// Configure JDBC types. \");\n        add2(src, \"Collection<JdbcType> jdbcTypes = new ArrayList<>();\");\n        add0(src, \"\");\n\n        for (PojoDescriptor pojo : pojos)\n            add2(src, \"jdbcTypes.add(jdbcType\" + pojo.valueClassName() + \"(cacheName));\");\n\n        add0(src, \"\");\n\n        add2(src, \"storeFactory.setTypes(jdbcTypes.toArray(new JdbcType[jdbcTypes.size()]));\");\n        add0(src, \"\");\n\n\n        add2(src, \"// Configure query entities. \");\n        add2(src, \"Collection<QueryEntity> qryEntities = new ArrayList<>();\");\n        add0(src, \"\");\n\n        for (PojoDescriptor pojo : pojos)\n            add2(src, \"qryEntities.add(queryEntity\" + pojo.valueClassName() + \"());\");\n\n        add0(src, \"\");\n\n        add2(src, \"ccfg.setQueryEntities(qryEntities);\");\n        add0(src, \"\");\n\n        add2(src, \"return ccfg;\");\n        add1(src, \"}\");\n\n        add0(src, \"}\");\n\n        write(src, cacheCfg);\n    }","commit_id":"87f78fb51777cb6cd04710d676487cd7599b49aa","url":"https://github.com/apache/ignite"},{"original_method":"public boolean isVisible(\n\t\t\tPermissionChecker permissionChecker, Portlet portlet)\n\t\tthrows Exception {\n\n\t\tlong companyId = permissionChecker.getCompanyId();\n\n\t\tif (!MarketplaceUtil.hasMarketplaceAdmin(companyId) &&\n\t\t\tpermissionChecker.isOmniadmin()) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\tUser user = UserLocalServiceUtil.getUserById(\n\t\t\tpermissionChecker.getUserId());\n\n\t\tif (MarketplaceUtil.isMarketplaceAdmin(user)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","id":60917,"modified_method":"public boolean isVisible(\n\t\t\tPermissionChecker permissionChecker, Portlet portlet)\n\t\tthrows Exception {\n\n\t\tif (permissionChecker.isOmniadmin()) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"2590516019b5a4846d5f8a806e7d84d62e53f36f","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic boolean contains(\n\t\tPermissionChecker permissionChecker, long userId,\n\t\tlong[] organizationIds, String actionId) {\n\n\t\tif ((actionId.equals(ActionKeys.DELETE) ||\n\t\t\t actionId.equals(ActionKeys.IMPERSONATE) ||\n\t\t\t actionId.equals(ActionKeys.PERMISSIONS) ||\n\t\t\t actionId.equals(ActionKeys.UPDATE)) &&\n\t\t\tPortalUtil.isOmniadmin(userId) &&\n\t\t\t!permissionChecker.isOmniadmin()) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\ttry {\n\t\t\tUser user = null;\n\n\t\t\tif (userId != ResourceConstants.PRIMKEY_DNE) {\n\t\t\t\tuser = UserLocalServiceUtil.getUserById(userId);\n\n\t\t\t\tif ((actionId.equals(ActionKeys.DELETE) ||\n\t\t\t\t\t actionId.equals(ActionKeys.IMPERSONATE) ||\n\t\t\t\t\t actionId.equals(ActionKeys.PERMISSIONS) ||\n\t\t\t\t\t actionId.equals(ActionKeys.UPDATE)) &&\n\t\t\t\t\tPortalUtil.isCompanyAdmin(user) &&\n\t\t\t\t\t!permissionChecker.isOmniadmin() &&\n\t\t\t\t\t!permissionChecker.isCompanyAdmin()) {\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tContact contact = user.getContact();\n\n\t\t\t\tif (permissionChecker.hasOwnerPermission(\n\t\t\t\t\t\tpermissionChecker.getCompanyId(), User.class.getName(),\n\t\t\t\t\t\tuserId, contact.getUserId(), actionId) ||\n\t\t\t\t\t(permissionChecker.getUserId() == userId)) {\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (permissionChecker.hasPermission(\n\t\t\t\t\t0, User.class.getName(), userId, actionId)) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (user == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (organizationIds == null) {\n\t\t\t\torganizationIds = user.getOrganizationIds();\n\t\t\t}\n\n\t\t\tfor (long organizationId : organizationIds) {\n\t\t\t\tOrganization organization =\n\t\t\t\t\tOrganizationLocalServiceUtil.getOrganization(\n\t\t\t\t\t\torganizationId);\n\n\t\t\t\tif (OrganizationPermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, organization,\n\t\t\t\t\t\tActionKeys.MANAGE_USERS)) {\n\n\t\t\t\t\tif (permissionChecker.getUserId() == user.getUserId()) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tGroup organizationGroup = organization.getGroup();\n\n\t\t\t\t\t// Organization administrators can only manage normal users.\n\t\t\t\t\t// Owners can only manage normal users and administrators.\n\n\t\t\t\t\tif (UserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t\t\tuser.getUserId(), organizationGroup.getGroupId(),\n\t\t\t\t\t\t\tRoleConstants.ORGANIZATION_OWNER, true)) {\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if (UserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t\t\t\tuser.getUserId(),\n\t\t\t\t\t\t\t\torganizationGroup.getGroupId(),\n\t\t\t\t\t\t\t\tRoleConstants.ORGANIZATION_ADMINISTRATOR,\n\t\t\t\t\t\t\t\ttrue) &&\n\t\t\t\t\t\t\t !UserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t\t\t\tpermissionChecker.getUserId(),\n\t\t\t\t\t\t\t\torganizationGroup.getGroupId(),\n\t\t\t\t\t\t\t\tRoleConstants.ORGANIZATION_OWNER, true)) {\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\treturn false;\n\t}","id":60918,"modified_method":"@Override\n\tpublic boolean contains(\n\t\tPermissionChecker permissionChecker, long userId,\n\t\tlong[] organizationIds, String actionId) {\n\n\t\ttry {\n\t\t\tUser user = null;\n\n\t\t\tif (userId != ResourceConstants.PRIMKEY_DNE) {\n\t\t\t\tuser = UserLocalServiceUtil.getUserById(userId);\n\n\t\t\t\tif ((actionId.equals(ActionKeys.DELETE) ||\n\t\t\t\t\t actionId.equals(ActionKeys.IMPERSONATE) ||\n\t\t\t\t\t actionId.equals(ActionKeys.PERMISSIONS) ||\n\t\t\t\t\t actionId.equals(ActionKeys.UPDATE)) &&\n\t\t\t\t\t!permissionChecker.isOmniadmin() &&\n\t\t\t\t\t(PortalUtil.isOmniadmin(userId) ||\n\t\t\t\t\t (!permissionChecker.isCompanyAdmin() &&\n\t\t\t\t\t  PortalUtil.isCompanyAdmin(user)))) {\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tContact contact = user.getContact();\n\n\t\t\t\tif (permissionChecker.hasOwnerPermission(\n\t\t\t\t\t\tpermissionChecker.getCompanyId(), User.class.getName(),\n\t\t\t\t\t\tuserId, contact.getUserId(), actionId) ||\n\t\t\t\t\t(permissionChecker.getUserId() == userId)) {\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (permissionChecker.hasPermission(\n\t\t\t\t\t0, User.class.getName(), userId, actionId)) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (user == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (organizationIds == null) {\n\t\t\t\torganizationIds = user.getOrganizationIds();\n\t\t\t}\n\n\t\t\tfor (long organizationId : organizationIds) {\n\t\t\t\tOrganization organization =\n\t\t\t\t\tOrganizationLocalServiceUtil.getOrganization(\n\t\t\t\t\t\torganizationId);\n\n\t\t\t\tif (OrganizationPermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, organization,\n\t\t\t\t\t\tActionKeys.MANAGE_USERS)) {\n\n\t\t\t\t\tif (permissionChecker.getUserId() == user.getUserId()) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tGroup organizationGroup = organization.getGroup();\n\n\t\t\t\t\t// Organization administrators can only manage normal users.\n\t\t\t\t\t// Owners can only manage normal users and administrators.\n\n\t\t\t\t\tif (UserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t\t\tuser.getUserId(), organizationGroup.getGroupId(),\n\t\t\t\t\t\t\tRoleConstants.ORGANIZATION_OWNER, true)) {\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if (UserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t\t\t\tuser.getUserId(),\n\t\t\t\t\t\t\t\torganizationGroup.getGroupId(),\n\t\t\t\t\t\t\t\tRoleConstants.ORGANIZATION_ADMINISTRATOR,\n\t\t\t\t\t\t\t\ttrue) &&\n\t\t\t\t\t\t\t !UserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t\t\t\tpermissionChecker.getUserId(),\n\t\t\t\t\t\t\t\torganizationGroup.getGroupId(),\n\t\t\t\t\t\t\t\tRoleConstants.ORGANIZATION_OWNER, true)) {\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"65a082ea8e1617dd3f51a5cbb1f0792d36837d2a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n  public boolean canExecute(EditorContext context) {\n    Selection selection = context.getSelectionManager().getSelection();\n    if (selection instanceof SingularSelection) {\n      EditorCell selectedCell = getCellToPasteTo(context.getSelectedCell());\n      if (selectedCell == null) {\n        return false;\n      }\n      SNode selectedNode = selectedCell.getSNode();\n      if (selectedNode == null || jetbrains.mps.util.SNodeOperations.isDisposed(selectedNode)) {\n        return false;\n      }\n      List<SNode> pasteNodes = CopyPasteUtil.getNodesFromClipboard(selectedNode.getModel());\n      if (pasteNodes == null || pasteNodes.isEmpty()) {\n        return CopyPasteUtil.isConversionAvailable(selectedNode.getModel(), selectedNode);\n      }\n\n      if (selection instanceof EditorCellLabelSelection) {\n        if (!new NodePaster(pasteNodes).canPaste(selectedCell)) {\n          LOG.debug(\"Couldn't paste node here\");\n          return false;\n        }\n        return true;\n      } else if (selection instanceof EditorCellSelection) {\n        return canPasteViaNodePaster(selection, pasteNodes);\n      }\n\n\n    } else if (selection instanceof MultipleSelection) {\n      SNode selectedNode = selection.getSelectedNodes().get(0);\n      List<SNode> pasteNodes = CopyPasteUtil.getNodesFromClipboard(selectedNode.getModel());\n      return canPasteViaNodePaster(selection, pasteNodes);\n    }\n    return false;\n  }","id":60919,"modified_method":"@Override\n  public boolean canExecute(EditorContext context) {\n    Selection selection = context.getSelectionManager().getSelection();\n    if (selection instanceof SingularSelection) {\n      EditorCell selectedCell = getCellToPasteTo(context.getSelectedCell());\n      if (selectedCell == null) {\n        return false;\n      }\n      SNode selectedNode = selectedCell.getSNode();\n      if (selectedNode == null || jetbrains.mps.util.SNodeOperations.isDisposed(selectedNode)) {\n        return false;\n      }\n      List<SNode> pasteNodes = CopyPasteUtil.getNodesFromClipboard(selectedNode.getModel());\n      if (pasteNodes == null || pasteNodes.isEmpty()) {\n        return CopyPasteUtil.isConversionAvailable(selectedNode.getModel(), selectedNode);\n      }\n\n      if (selection instanceof EditorCellLabelSelection) {\n        return canPasteViaNodePaster(selectedCell, pasteNodes);\n      } else if (selection instanceof EditorCellSelection) {\n        return canPasteViaNodePasterWithRemove(selection, pasteNodes) || canPasteViaNodePaster(selectedCell, pasteNodes);\n      }\n\n\n    } else if (selection instanceof MultipleSelection) {\n      SNode selectedNode = selection.getSelectedNodes().get(0);\n      List<SNode> pasteNodes = CopyPasteUtil.getNodesFromClipboard(selectedNode.getModel());\n      return canPasteViaNodePasterWithRemove(selection, pasteNodes);\n    }\n    return false;\n  }","commit_id":"02b280d3136d22914461f01de9c74d73260b2682","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void execute(final EditorContext context) {\n    LOG.assertInCommand();\n    final EditorComponent editorComponent = (EditorComponent) context.getEditorComponent();\n    final Selection selection = editorComponent.getSelectionManager().getSelection();\n    final SNode nodeSelected;\n    nodeSelected = selection.getSelectedNodes().get(0);\n    final SModel modeltoPaste = nodeSelected.getModel();\n\n    // sometimes model is not in repository (paste in merge dialog)\n    final boolean inRepository = SModelRepository.getInstance().getModelDescriptor(modeltoPaste.getModelId()) != null;\n\n    PasteNodeData data = CopyPasteUtil.getPasteNodeDataFromClipboard(modeltoPaste);\n    if (data == null || data.getNodes().isEmpty()) {\n      data = CopyPasteUtil.getConvertedFromClipboard(modeltoPaste, context.getOperationContext().getProject());\n      if (data == null || data.getNodes().isEmpty()) return;\n    }\n    final PasteNodeData pasteNodeData = data;\n\n    //this is used in case node is in repo to pass it into invokeLater\n    final SNodeReference selectedNodePointer = nodeSelected.getReference();\n    SwingUtilities.invokeLater(new Runnable() {\n      @Override\n      public void run() {\n        final Runnable addImportsRunnable = CopyPasteUtil.addImportsWithDialog(pasteNodeData, modeltoPaste, context.getOperationContext());\n        ModelAccess.instance().runCommandInEDT(new Runnable() {\n          @Override\n          public void run() {\n            if (addImportsRunnable != null) {\n              addImportsRunnable.run();\n            }\n\n            List<SNode> pasteNodes = pasteNodeData.getNodes();\n\n            if (selection instanceof EditorCellLabelSelection) {\n              EditorCell pasteTargetCell = getCellToPasteTo(editorComponent.getSelectedCell());\n              final CellInfo pasteTargetCellInfo = APICellAdapter.getCellInfo(pasteTargetCell);\n              EditorCell selectedCell = pasteTargetCellInfo.findCell(editorComponent);\n              assert selectedCell != null;\n\n\n              if (canPasteBefore(selectedCell, pasteNodes)) {\n                SNode selectedNode = inRepository ? selectedNodePointer.resolve(MPSModuleRepository.getInstance()) : nodeSelected;\n                if (jetbrains.mps.util.SNodeOperations.isDisposed(selectedNode)) {\n                  LOG.error(\"Selected node is disposed: node = \" + selectedNode.toString() + \" ; node pointer = (\" + selectedNodePointer.toString() + \")\");\n                  return;\n                }\n                new NodePaster(pasteNodes).pasteRelative(selectedNode, PastePlaceHint.BEFORE_ANCHOR);\n              } else {\n                new NodePaster(pasteNodes).paste(selectedCell);\n              }\n            } else if (selection instanceof MultipleSelection || selection instanceof EditorCellSelection) {\n              NodePaster nodePaster = new NodePaster(pasteNodes);\n              if (nodePaster.canPasteWithRemove(selection.getSelectedNodes())) {\n                nodePaster.pasteWithRemove(selection.getSelectedNodes());\n              }\n            }\n\n            Set<SReference> requireResolveReferences = new HashSet<SReference>();\n            for (SReference ref : pasteNodeData.getRequireResolveReferences()) {\n              //ref can be detached from modeltoPaste while using copy/paste handlers\n              if (ref.getSourceNode() == null || ref.getSourceNode().getModel() == null) continue;\n              requireResolveReferences.add(ref);\n            }\n\n            ResolverComponent.getInstance().resolveScopesOnly(requireResolveReferences, context.getOperationContext());\n\n            // set selection\n            editorComponent.flushEvents();\n            EditorCell nodeCell = editorComponent.findNodeCell(pasteNodes.get(0));\n            if (nodeCell == null) return; // after 'set reference'?\n\n            EditorCell_Label labelCell = CellFinderUtil.findChildByClass(nodeCell, EditorCell_Label.class, true);\n            if (labelCell != null) {\n              editorComponent.changeSelection(labelCell);\n            }\n\n            if (pasteNodes.size() == 1) {\n              editorComponent.pushSelection(nodeCell);\n            } else {\n              SNode firstNodeToSelect = pasteNodes.get(0);\n              SNode lastNodeToSelect = null;\n              for (int i = pasteNodes.size() - 1; i > 0 && lastNodeToSelect == null; i--) {\n                if (pasteNodes.get(i).getParent() == firstNodeToSelect.getParent()) {\n                  lastNodeToSelect = pasteNodes.get(i);\n                }\n              }\n              if (lastNodeToSelect != null) {\n                SelectionManager selectionManager = editorComponent.getSelectionManager();\n                selectionManager.pushSelection(selectionManager.createRangeSelection(firstNodeToSelect, lastNodeToSelect));\n              }\n            }\n          }\n        }, context.getOperationContext().getProject());\n\n      }\n    });\n  }","id":60920,"modified_method":"@Override\n  public void execute(final EditorContext context) {\n    LOG.assertInCommand();\n    final EditorComponent editorComponent = (EditorComponent) context.getEditorComponent();\n    final Selection selection = editorComponent.getSelectionManager().getSelection();\n    final List<SNode> selectedNodes = selection.getSelectedNodes();\n    //this is used in case node is in repo to pass it into invokeLater\n    final List<SNodeReference> selectedReferences = new ArrayList<SNodeReference>();\n    for (SNode node : selectedNodes) {\n      selectedReferences.add(node.getReference());\n    }\n    final SModel modelToPaste = selectedNodes.get(0).getModel();\n\n    // sometimes model is not in repository (paste in merge dialog)\n    final boolean inRepository = SModelRepository.getInstance().getModelDescriptor(modelToPaste.getModelId()) != null;\n\n    PasteNodeData data = CopyPasteUtil.getPasteNodeDataFromClipboard(modelToPaste);\n    if (data == null || data.getNodes().isEmpty()) {\n      data = CopyPasteUtil.getConvertedFromClipboard(modelToPaste, context.getOperationContext().getProject());\n      if (data == null || data.getNodes().isEmpty()) return;\n    }\n    final PasteNodeData pasteNodeData = data;\n\n    SwingUtilities.invokeLater(new Runnable() {\n      @Override\n      public void run() {\n        final Runnable addImportsRunnable = CopyPasteUtil.addImportsWithDialog(pasteNodeData, modelToPaste, context.getOperationContext());\n        ModelAccess.instance().runCommandInEDT(new Runnable() {\n          @Override\n          public void run() {\n            if (addImportsRunnable != null) {\n              addImportsRunnable.run();\n            }\n\n            List<SNode> pasteNodes = pasteNodeData.getNodes();\n\n            if (selection instanceof EditorCellLabelSelection ||\n                (selection instanceof EditorCellSelection && !canPasteViaNodePasterWithRemove(selection, pasteNodes))) {\n              EditorCell pasteTargetCell = getCellToPasteTo(editorComponent.getSelectedCell());\n              final CellInfo pasteTargetCellInfo = APICellAdapter.getCellInfo(pasteTargetCell);\n              EditorCell selectedCell = pasteTargetCellInfo.findCell(editorComponent);\n              assert selectedCell != null;\n\n\n              if (canPasteBefore(selectedCell, pasteNodes)) {\n                SNodeReference currentSelectedReference = selectedReferences.get(0);\n                SNode currentSelectedNode = inRepository ? currentSelectedReference.resolve(MPSModuleRepository.getInstance()) : selectedNodes.get(0);\n                if (checkDisposed(currentSelectedReference, currentSelectedNode)) return;\n                new NodePaster(pasteNodes).pasteRelative(currentSelectedNode, PastePlaceHint.BEFORE_ANCHOR);\n              } else {\n                new NodePaster(pasteNodes).paste(selectedCell);\n              }\n            } else if (selection instanceof MultipleSelection || selection instanceof EditorCellSelection) {\n              NodePaster nodePaster = new NodePaster(pasteNodes);\n              List<SNode> currentSelectedNodes;\n              if (!inRepository) {\n                currentSelectedNodes = selectedNodes;\n              } else {\n                currentSelectedNodes = new ArrayList<SNode>();\n                for (SNodeReference ref : selectedReferences) {\n                  currentSelectedNodes.add(ref.resolve(MPSModuleRepository.getInstance()));\n                }\n              }\n\n              Iterator<SNodeReference> referenceIterator = selectedReferences.iterator();\n              for (SNode node : currentSelectedNodes) {\n                SNodeReference reference = referenceIterator.next();\n                if (checkDisposed(reference, node)) return;\n              }\n\n              if (nodePaster.canPasteWithRemove(currentSelectedNodes)) {\n                nodePaster.pasteWithRemove(currentSelectedNodes);\n              }\n            }\n\n            Set<SReference> requireResolveReferences = new HashSet<SReference>();\n            for (SReference ref : pasteNodeData.getRequireResolveReferences()) {\n              //ref can be detached from modeltoPaste while using copy/paste handlers\n              if (ref.getSourceNode() == null || ref.getSourceNode().getModel() == null) continue;\n              requireResolveReferences.add(ref);\n            }\n\n            ResolverComponent.getInstance().resolveScopesOnly(requireResolveReferences, context.getOperationContext());\n\n            // set selection\n            editorComponent.flushEvents();\n            EditorCell nodeCell = editorComponent.findNodeCell(pasteNodes.get(0));\n            if (nodeCell == null) return; // after 'set reference'?\n\n            EditorCell_Label labelCell = CellFinderUtil.findChildByClass(nodeCell, EditorCell_Label.class, true);\n            if (labelCell != null) {\n              editorComponent.changeSelection(labelCell);\n            }\n\n            if (pasteNodes.size() == 1) {\n              editorComponent.pushSelection(nodeCell);\n            } else {\n              SNode firstNodeToSelect = pasteNodes.get(0);\n              SNode lastNodeToSelect = null;\n              for (int i = pasteNodes.size() - 1; i > 0 && lastNodeToSelect == null; i--) {\n                if (pasteNodes.get(i).getParent() == firstNodeToSelect.getParent()) {\n                  lastNodeToSelect = pasteNodes.get(i);\n                }\n              }\n              if (lastNodeToSelect != null) {\n                SelectionManager selectionManager = editorComponent.getSelectionManager();\n                selectionManager.pushSelection(selectionManager.createRangeSelection(firstNodeToSelect, lastNodeToSelect));\n              }\n            }\n          }\n        }, context.getOperationContext().getProject());\n\n      }\n    });\n  }","commit_id":"02b280d3136d22914461f01de9c74d73260b2682","url":"https://github.com/JetBrains/MPS"},{"original_method":"private boolean canPasteViaNodePaster(Selection selection, List<SNode> pasteNodes) {\n    if (!new NodePaster(pasteNodes).canPasteWithRemove(selection.getSelectedNodes()) ) {\n      LOG.debug(\"Couldn't paste node here\");\n      return false;\n    }\n    return true;\n  }","id":60921,"modified_method":"private boolean canPasteViaNodePasterWithRemove(Selection selection, List<SNode> pasteNodes) {\n    if (!new NodePaster(pasteNodes).canPasteWithRemove(selection.getSelectedNodes())) {\n      LOG.debug(\"Couldn't paste node here\");\n      return false;\n    }\n    return true;\n  }","commit_id":"02b280d3136d22914461f01de9c74d73260b2682","url":"https://github.com/JetBrains/MPS"},{"original_method":"private boolean canPasteBefore(EditorCell selectedCell, List<SNode> pasteNodes) {\n    if (!APICellAdapter.isFirstPositionInBigCell(selectedCell)) return false;\n    SNode anchor = selectedCell.getSNode();\n    if (anchor.getParent() == null) return false;\n\n    NodeAndRole nodeAndRole = new NodePaster(pasteNodes).getActualAnchorNode(anchor, anchor.getRoleInParent());\n    if (nodeAndRole == null) return false;\n\n    EditorCell targetCell = selectedCell.getEditorComponent().findNodeCell(nodeAndRole.myNode);\n    return targetCell != null && ((jetbrains.mps.nodeEditor.cells.EditorCell) targetCell).getFirstLeaf(CellConditions.SELECTABLE) == selectedCell &&\n        new NodePaster(pasteNodes).canPasteRelative(nodeAndRole.myNode);\n  }","id":60922,"modified_method":"private boolean canPasteBefore(EditorCell selectedCell, List<SNode> pasteNodes) {\n    if (!APICellAdapter.isFirstPositionInBigCell(selectedCell)) return false;\n    SNode anchor = selectedCell.getSNode();\n    if (anchor.getParent() == null) return false;\n\n    NodeAndRole nodeAndRole = new NodePaster(pasteNodes).getActualAnchorNode(anchor, anchor.getRoleInParent(), false);\n    if (nodeAndRole == null) return false;\n\n    EditorCell targetCell = selectedCell.getEditorComponent().findNodeCell(nodeAndRole.myNode);\n    return targetCell != null && ((jetbrains.mps.nodeEditor.cells.EditorCell) targetCell).getFirstLeaf(CellConditions.SELECTABLE) == selectedCell &&\n        new NodePaster(pasteNodes).canPasteRelative(nodeAndRole.myNode);\n  }","commit_id":"02b280d3136d22914461f01de9c74d73260b2682","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public void testMethodImpl() throws Exception {\n      final Editor editor = TestBody.this.initEditor(\"8777381699079285185\", \"8777381699079285195\");\n      EditorComponent editorComponent = (EditorComponent) editor.getCurrentEditorComponent();\n      BaseEditorTestBody.invokeAction(editorComponent, \"$Copy\");\n      BaseEditorTestBody.invokeAction(editorComponent, \"jetbrains.mps.ide.editor.actions.MoveUp_Action\");\n      BaseEditorTestBody.invokeAction(editorComponent, \"jetbrains.mps.ide.editor.actions.SelectUp_Action\");\n      BaseEditorTestBody.invokeAction(editorComponent, \"jetbrains.mps.ide.editor.actions.SelectUp_Action\");\n      BaseEditorTestBody.invokeAction(editorComponent, \"$Paste\");\n\n    }","id":60923,"modified_method":"@Override\n    public void testMethodImpl() throws Exception {\n      final Editor editor = TestBody.this.initEditor(\"8777381699079285185\", \"8777381699079285195\");\n      EditorComponent editorComponent = (EditorComponent) editor.getCurrentEditorComponent();\n      BaseEditorTestBody.invokeAction(editorComponent, \"jetbrains.mps.ide.editor.actions.SelectUp_Action\");\n      BaseEditorTestBody.invokeAction(editorComponent, \"jetbrains.mps.ide.editor.actions.SelectUp_Action\");\n      BaseEditorTestBody.invokeAction(editorComponent, \"jetbrains.mps.ide.editor.actions.SelectUp_Action\");\n      BaseEditorTestBody.invokeAction(editorComponent, \"jetbrains.mps.ide.editor.actions.SelectUp_Action\");\n      BaseEditorTestBody.invokeAction(editorComponent, \"$Copy\");\n      BaseEditorTestBody.invokeAction(editorComponent, \"jetbrains.mps.ide.editor.actions.MoveUp_Action\");\n      BaseEditorTestBody.invokeAction(editorComponent, \"jetbrains.mps.ide.editor.actions.SelectUp_Action\");\n      BaseEditorTestBody.invokeAction(editorComponent, \"jetbrains.mps.ide.editor.actions.SelectUp_Action\");\n      BaseEditorTestBody.invokeAction(editorComponent, \"$Paste\");\n\n    }","commit_id":"02b280d3136d22914461f01de9c74d73260b2682","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void paste(SNode pasteTarget, String role, PasteEnv pasteEnv) {\n    String role_ = role != null ? role : pasteTarget.getRoleInParent();\n    int status = canPaste(pasteTarget, role_, pasteEnv);\n\n    if (status == PASTE_TO_TARGET) {\n      pasteToTarget(pasteTarget, null, role_, PastePlaceHint.DEFAULT);\n    } else if (status == PASTE_TO_PARENT) {\n      pasteToParent(pasteTarget, role_, PastePlaceHint.DEFAULT);\n    } else if (status == PASTE_TO_ROOT) {\n      for (SNode pasteNode : myPasteNodes) {\n        pasteTarget.getModel().addRootNode(pasteNode);\n      }\n    }\n  }","id":60924,"modified_method":"private void paste(SNode pasteTarget, String role, PasteEnv pasteEnv) {\n    String role_ = role != null ? role : pasteTarget.getRoleInParent();\n    int status = canPaste(pasteTarget, role_, pasteEnv);\n\n    if (status == PASTE_TO_TARGET) {\n      pasteToTarget(pasteTarget, null, role_, PastePlaceHint.DEFAULT);\n    } else if (status == PASTE_TO_PARENT) {\n      pasteToParent(pasteTarget, role_, PastePlaceHint.DEFAULT, false);\n    } else if (status == PASTE_TO_ROOT) {\n      for (SNode pasteNode : myPasteNodes) {\n        pasteTarget.getModel().addRootNode(pasteNode);\n      }\n    }\n  }","commit_id":"02b280d3136d22914461f01de9c74d73260b2682","url":"https://github.com/JetBrains/MPS"},{"original_method":"private boolean canPasteToParent(SNode anchorNode, String role) {\n    NodeAndRole nodeAndRole = getActualAnchorNode(anchorNode, role);\n    return (nodeAndRole != null && nodeAndRole.myNode != null);\n  }","id":60925,"modified_method":"private boolean canPasteToParent(SNode anchorNode, String role, boolean exactly) {\n    NodeAndRole nodeAndRole = getActualAnchorNode(anchorNode, role, exactly);\n    return (nodeAndRole != null && nodeAndRole.myNode != null);\n  }","commit_id":"02b280d3136d22914461f01de9c74d73260b2682","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean canPasteWithRemove(List<SNode> pasteTargets) {\n    if (pasteTargets.isEmpty()) {\n      return false;\n    }\n    SNode firstNode = pasteTargets.get(0);\n    String role = firstNode.getRoleInParent();\n    for (SNode node : pasteTargets) {\n      if (!node.getRoleInParent().equals(role)) {\n        return false;\n      }\n    }\n    SNode lastNode = pasteTargets.get(pasteTargets.size() - 1);\n    return canPasteToTarget(lastNode.getParent(), lastNode.getRoleInParent(), pasteTargets.size() == 1);\n  }","id":60926,"modified_method":"public boolean canPasteWithRemove(List<SNode> pasteTargets) {\n    if (pasteTargets.isEmpty()) {\n      return false;\n    }\n    SNode firstNode = pasteTargets.get(0);\n    String role = firstNode.getRoleInParent();\n    for (SNode node : pasteTargets) {\n      if (!node.getRoleInParent().equals(role)) {\n        return false;\n      }\n    }\n    SNode lastNode = pasteTargets.get(pasteTargets.size() - 1);\n    return canPasteToParent(lastNode, lastNode.getRoleInParent(), true);\n  }","commit_id":"02b280d3136d22914461f01de9c74d73260b2682","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void pasteWithRemove(List<SNode> pasteTargets) {\n    if (pasteTargets.isEmpty()) {\n      return;\n    }\n    SNode lastNode = pasteTargets.get(pasteTargets.size() - 1);\n    pasteToParent(lastNode, lastNode.getRoleInParent(), PastePlaceHint.DEFAULT);\n    for (SNode node : pasteTargets) {\n      if (node.getModel() != null) {\n        node.delete();\n      }\n    }\n  }","id":60927,"modified_method":"public void pasteWithRemove(List<SNode> pasteTargets) {\n    if (pasteTargets.isEmpty()) {\n      return;\n    }\n    SNode lastNode = pasteTargets.get(pasteTargets.size() - 1);\n    pasteToParent(lastNode, lastNode.getRoleInParent(), PastePlaceHint.DEFAULT, true);\n    for (SNode node : pasteTargets) {\n      if (node.getModel() != null) {\n        node.delete();\n      }\n    }\n  }","commit_id":"02b280d3136d22914461f01de9c74d73260b2682","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void pasteToParent(SNode pasteTarget, String role, PastePlaceHint placeHint) {\n    SNode actualPasteTarget;\n    NodeAndRole nodeAndRole = getActualAnchorNode(pasteTarget, role);\n    SNode actualAnchorNode = nodeAndRole.myNode;\n    String actualRole = nodeAndRole.myRole;\n    actualPasteTarget = actualAnchorNode.getParent();\n    if (actualPasteTarget == null) {\n      return;\n    }\n    pasteToTarget(actualPasteTarget, actualAnchorNode, actualRole, placeHint);\n  }","id":60928,"modified_method":"private void pasteToParent(SNode pasteTarget, String role, PastePlaceHint placeHint, boolean exactly) {\n    SNode actualPasteTarget;\n    NodeAndRole nodeAndRole = getActualAnchorNode(pasteTarget, role, exactly);\n    SNode actualAnchorNode = nodeAndRole.myNode;\n    String actualRole = nodeAndRole.myRole;\n    actualPasteTarget = actualAnchorNode.getParent();\n    if (actualPasteTarget == null) {\n      return;\n    }\n    pasteToTarget(actualPasteTarget, actualAnchorNode, actualRole, placeHint);\n  }","commit_id":"02b280d3136d22914461f01de9c74d73260b2682","url":"https://github.com/JetBrains/MPS"},{"original_method":"private int canPaste(SNode pasteTarget, String role, PasteEnv pasteEnv) {\n    if (myPasteNodes == null || myPasteNodes.isEmpty()) {\n      return PASTE_N_A;\n    }\n\n    String role_ = role != null ? role : pasteTarget.getRoleInParent();\n\n    boolean canPasteAsRoot = (pasteTarget.getParent() == null) && canPasteAsRoots(); // root selected and ..\n    boolean canPasteToTarget = canPasteToTarget(pasteTarget, role_, true);\n\n    if (pasteEnv == PasteEnv.PROJECT_TREE) {\n      // project pane\n      if (canPasteAsRoot) {\n        return PASTE_TO_ROOT;\n      }\n\n      if (canPasteToTarget) {\n        return PASTE_TO_TARGET;\n      }\n    } else {\n      // editor pane\n      if (canPasteToTarget) {\n        return PASTE_TO_TARGET;\n      }\n    }\n\n    if (canPasteToParent(pasteTarget, role_)) {\n      return PASTE_TO_PARENT;\n    }\n\n    return PASTE_N_A;\n  }","id":60929,"modified_method":"private int canPaste(SNode pasteTarget, String role, PasteEnv pasteEnv) {\n    if (myPasteNodes == null || myPasteNodes.isEmpty()) {\n      return PASTE_N_A;\n    }\n\n    String role_ = role != null ? role : pasteTarget.getRoleInParent();\n\n    boolean canPasteAsRoot = (pasteTarget.getParent() == null) && canPasteAsRoots(); // root selected and ..\n    boolean canPasteToTarget = canPasteToTarget(pasteTarget, role_, true);\n\n    if (pasteEnv == PasteEnv.PROJECT_TREE) {\n      // project pane\n      if (canPasteAsRoot) {\n        return PASTE_TO_ROOT;\n      }\n\n      if (canPasteToTarget) {\n        return PASTE_TO_TARGET;\n      }\n    } else {\n      // editor pane\n      if (canPasteToTarget) {\n        return PASTE_TO_TARGET;\n      }\n    }\n\n    if (canPasteToParent(pasteTarget, role_, false)) {\n      return PASTE_TO_PARENT;\n    }\n\n    return PASTE_N_A;\n  }","commit_id":"02b280d3136d22914461f01de9c74d73260b2682","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean canPasteRelative(SNode anchorNode) {\n    return canPasteToParent(anchorNode, anchorNode.getRoleInParent());\n  }","id":60930,"modified_method":"public boolean canPasteRelative(SNode anchorNode) {\n    return canPasteToParent(anchorNode, anchorNode.getRoleInParent(), false);\n  }","commit_id":"02b280d3136d22914461f01de9c74d73260b2682","url":"https://github.com/JetBrains/MPS"},{"original_method":"public NodeAndRole getActualAnchorNode(SNode firstAnchorNode, String firstRole) {\n    String role = firstRole;\n    SNode anchorNode = firstAnchorNode;\n    while (anchorNode != null) {\n      SNode container = anchorNode.getParent();\n      if (container == null) {\n        break;\n      }\n      if (canPasteToTarget(container, role, firstAnchorNode == anchorNode)) {\n        return new NodeAndRole(anchorNode, role);\n      }\n      anchorNode = container;\n      role = anchorNode.getRoleInParent();\n    }\n    return null;\n  }","id":60931,"modified_method":"public NodeAndRole getActualAnchorNode(SNode firstAnchorNode, String firstRole, boolean exactly) {\n    String role = firstRole;\n    SNode anchorNode = firstAnchorNode;\n    while (anchorNode != null) {\n      SNode container = anchorNode.getParent();\n      if (container == null) {\n        return null;\n      }\n      if (canPasteToTarget(container, role, firstAnchorNode == anchorNode)) {\n        return new NodeAndRole(anchorNode, role);\n      }\n      if (exactly) {\n        break;\n      }\n      anchorNode = container;\n      role = anchorNode.getRoleInParent();\n    }\n    return null;\n  }","commit_id":"02b280d3136d22914461f01de9c74d73260b2682","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void pasteRelative(SNode anchorNode, PastePlaceHint placeHint) {\n    if (anchorNode.getParent() == null) {\n      pasteAsRoots(anchorNode.getModel());\n    } else {\n      pasteToParent(anchorNode, anchorNode.getRoleInParent(), placeHint);\n    }\n  }","id":60932,"modified_method":"public void pasteRelative(SNode anchorNode, PastePlaceHint placeHint) {\n    if (anchorNode.getParent() == null) {\n      pasteAsRoots(anchorNode.getModel());\n    } else {\n      pasteToParent(anchorNode, anchorNode.getRoleInParent(), placeHint, false);\n    }\n  }","commit_id":"02b280d3136d22914461f01de9c74d73260b2682","url":"https://github.com/JetBrains/MPS"},{"original_method":"private MultiProcessDebugger createMultiprocessDebugger(ServerSocket serverSocket, ProcessHandler processHandler) {\n    MultiProcessDebugger debugger = new MultiProcessDebugger(this, serverSocket, 10000);\n    debugger.setOtherDebuggerCloseListener(new MultiProcessDebugger.DebuggerProcessListener() {\n      @Override\n      public void threadsClosed(Set<String> threadIds) {\n        for (PyThreadInfo t : mySuspendedThreads) {\n          if (threadIds.contains(t.getId())) {\n            if (getSession().isSuspended()) {\n              getSession().resume();\n              break;\n            }\n          }\n        }\n      }\n    });\n    return debugger;\n  }","id":60933,"modified_method":"private MultiProcessDebugger createMultiprocessDebugger(ServerSocket serverSocket) {\n    MultiProcessDebugger debugger = new MultiProcessDebugger(this, serverSocket, 10000);\n    debugger.setOtherDebuggerCloseListener(new MultiProcessDebugger.DebuggerProcessListener() {\n      @Override\n      public void threadsClosed(Set<String> threadIds) {\n        for (PyThreadInfo t : mySuspendedThreads) {\n          if (threadIds.contains(t.getId())) {\n            if (getSession().isSuspended()) {\n              getSession().resume();\n              break;\n            }\n          }\n        }\n      }\n    });\n    return debugger;\n  }","commit_id":"5cefa517be5a95ca25a238c85dc5c71db82a4535","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PyDebugProcess(final @NotNull XDebugSession session,\n                        @NotNull final ServerSocket serverSocket,\n                        @NotNull final ExecutionConsole executionConsole,\n                        @Nullable final ProcessHandler processHandler, boolean multiProcess) {\n    super(session);\n    session.setPauseActionSupported(true);\n    if (multiProcess) {\n      myDebugger = createMultiprocessDebugger(serverSocket, processHandler);\n    }\n    else {\n      myDebugger = new RemoteDebugger(this, serverSocket, 10000);\n    }\n    myBreakpointHandlers = new XBreakpointHandler[]{new PyLineBreakpointHandler(this), new PyExceptionBreakpointHandler(this),\n      new DjangoLineBreakpointHandler(this), new DjangoExceptionBreakpointHandler(this)};\n    myEditorsProvider = new PyDebuggerEditorsProvider();\n    mySmartStepIntoHandler = new PySmartStepIntoHandler(this);\n    myProcessHandler = processHandler;\n    myExecutionConsole = executionConsole;\n    if (myProcessHandler != null) {\n      myProcessHandler.addProcessListener(this);\n    }\n    if (processHandler instanceof PyRemoteProcessHandlerBase) {\n      myPositionConverter = new PyRemotePositionConverter(this, ((PyRemoteProcessHandlerBase)processHandler).getMappingSettings());\n    }\n    else {\n      myPositionConverter = new PyLocalPositionConverter();\n    }\n    myDebugger.addCloseListener(new RemoteDebuggerCloseListener() {\n      @Override\n      public void closed() {\n        handleStop();\n      }\n\n      @Override\n      public void communicationError() {\n        handleCommunicationError();\n      }\n\n      @Override\n      public void exitEvent() {\n        handleCommunicationError();\n      }\n    });\n  }","id":60934,"modified_method":"public PyDebugProcess(final @NotNull XDebugSession session,\n                        @NotNull final ServerSocket serverSocket,\n                        @NotNull final ExecutionConsole executionConsole,\n                        @Nullable final ProcessHandler processHandler, boolean multiProcess) {\n    super(session);\n    session.setPauseActionSupported(true);\n    if (multiProcess) {\n      myDebugger = createMultiprocessDebugger(serverSocket);\n    }\n    else {\n      myDebugger = new RemoteDebugger(this, serverSocket, 10000);\n    }\n    myBreakpointHandlers = new XBreakpointHandler[]{new PyLineBreakpointHandler(this), new PyExceptionBreakpointHandler(this),\n      new DjangoLineBreakpointHandler(this), new DjangoExceptionBreakpointHandler(this)};\n    myEditorsProvider = new PyDebuggerEditorsProvider();\n    mySmartStepIntoHandler = new PySmartStepIntoHandler(this);\n    myProcessHandler = processHandler;\n    myExecutionConsole = executionConsole;\n    if (myProcessHandler != null) {\n      myProcessHandler.addProcessListener(this);\n    }\n    if (processHandler instanceof PyRemoteProcessHandlerBase) {\n      myPositionConverter = new PyRemotePositionConverter(this, ((PyRemoteProcessHandlerBase)processHandler).getMappingSettings());\n    }\n    else {\n      myPositionConverter = new PyLocalPositionConverter();\n    }\n    myDebugger.addCloseListener(new RemoteDebuggerCloseListener() {\n      @Override\n      public void closed() {\n        handleStop();\n      }\n\n      @Override\n      public void communicationError() {\n        handleCommunicationError();\n      }\n\n      @Override\n      public void exitEvent() {\n        handleCommunicationError();\n      }\n    });\n  }","commit_id":"5cefa517be5a95ca25a238c85dc5c71db82a4535","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static String normalize(@Nullable String file) {\n    if (file == null) {\n      return file;\n    }\n    String res =  FileUtil.toSystemIndependentName(file);\n\n    if (isWindowsPath(file)) {\n      res = res.toLowerCase();\n    }\n    return res;\n  }","id":60935,"modified_method":"@Nullable\n  protected String normalize(@Nullable String file) {\n    if (file == null) {\n      return file;\n    }\n\n    return FileUtil.toSystemIndependentName(file);\n  }","commit_id":"5cefa517be5a95ca25a238c85dc5c71db82a4535","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isWindowsPath(@NotNull String path) {\n    return path.contains(\"\\\\\");\n  }","id":60936,"modified_method":"public static boolean isWindowsPath(@NotNull String path) {\n    return path.contains(\"\\\\\") || (path.length() > 1 && path.charAt(1) == ':');\n  }","commit_id":"5cefa517be5a95ca25a238c85dc5c71db82a4535","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static String getScriptName(PythonCommandLineState pyState) {\n    ExecutionEnvironment environment = pyState.getEnvironment();\n    if (environment == null) {\n      return null;\n    }\n    RunProfile runProfile = environment.getRunProfile();\n    if (runProfile instanceof PythonRunConfiguration) {\n      return FileUtil.toSystemIndependentName(((PythonRunConfiguration)runProfile).getScriptName());\n    }\n    return null;\n  }","id":60937,"modified_method":"@Nullable\n  private static String getScriptName(PythonCommandLineState pyState) {\n    ExecutionEnvironment environment = pyState.getEnvironment();\n    if (environment == null) {\n      return null;\n    }\n    RunProfile runProfile = environment.getRunProfile();\n    if (runProfile instanceof PythonRunConfiguration) {\n      String name = FileUtil.toSystemIndependentName(((PythonRunConfiguration)runProfile).getScriptName());\n      return SystemInfo.isWindows ? name.toLowerCase() : name;\n    }\n    return null;\n  }","commit_id":"562425750ac0e9170f9fef98b162051de5ff87f8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DartConfigurable(final @NotNull Project project) {\n    myProject = project;\n\n    initEnableDartSupportCheckBox();\n\n    DartSdkUtil.initDartSdkPathTextFieldWithBrowseButton(myProject, mySdkPathTextWithBrowse, myVersionLabel);\n    mySdkPathTextWithBrowse.getTextField().getDocument().addDocumentListener(new DocumentAdapter() {\n      @Override\n      protected void textChanged(final DocumentEvent e) {\n        final String sdkPath = FileUtilRt.toSystemIndependentName(mySdkPathTextWithBrowse.getText().trim());\n        if (!myInReset && DartSdkUtil.isDartSdkHome(sdkPath)) {\n          final String dartiumPath = DartiumUtil.getDartiumPathForSdk(sdkPath);\n          if (dartiumPath != null) {\n            myDartiumPathTextWithBrowse.setText(FileUtilRt.toSystemDependentName(dartiumPath));\n          }\n        }\n\n        updateErrorLabel();\n      }\n    });\n\n    initDartiumRelatedControls();\n\n    initModulesPanel();\n\n    myErrorLabel.setIcon(AllIcons.Actions.Lightning);\n  }","id":60938,"modified_method":"public DartConfigurable(final @NotNull Project project) {\n    myProject = project;\n    initEnableDartSupportCheckBox();\n    initDartSdkAndDartiumControls();\n    initModulesPanel();\n    myErrorLabel.setIcon(AllIcons.Actions.Lightning);\n  }","commit_id":"2207a10800b2c63efecaf7a5dfcc3402239922af","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  private String getErrorMessage() {\n    if (!myEnableDartSupportCheckBox.isSelected()) {\n      return null;\n    }\n\n    String message = DartSdkUtil.getErrorMessageIfWrongSdkRootPath(mySdkPathTextWithBrowse.getText().trim());\n    if (message != null) return message;\n\n    message = DartiumUtil.getErrorMessageIfWrongDartiumPath(myDartiumPathTextWithBrowse.getText().trim());\n    if (message != null) return message;\n\n    if (DartSdkGlobalLibUtil.isIdeWithMultipleModuleSupport() && myModulesCheckboxTree.getCheckedNodes(Module.class, null).length == 0) {\n      return \"Warning: no modules selected. Dart support will be disabled for the project.\";\n    }\n\n    return null;\n  }","id":60939,"modified_method":"@Nullable\n  private String getErrorMessage() {\n    if (!myEnableDartSupportCheckBox.isSelected()) {\n      return null;\n    }\n\n    String message = DartSdkUtil.getErrorMessageIfWrongSdkRootPath(mySdkPathTextWithBrowse.getText().trim());\n    if (message != null) return message;\n\n    message = DartiumUtil.getErrorMessageIfWrongDartiumPath(myDartiumPathTextWithBrowse.getText().trim());\n    if (message != null) return message;\n\n    if (DartSdkGlobalLibUtil.isIdeWithMultipleModuleSupport() && myModulesCheckboxTree.getCheckedNodes(Module.class, null).length == 0) {\n      return DartBundle.message(\"warning.no.modules.selected.dart.support.will.be.disabled\");\n    }\n\n    return null;\n  }","commit_id":"2207a10800b2c63efecaf7a5dfcc3402239922af","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void initDartiumRelatedControls() {\n    myDartiumPathTextWithBrowse.addBrowseFolderListener(\"Select Dartium browser path\", null, myProject,\n                                                        FileChooserDescriptorFactory.createSingleFileOrExecutableAppDescriptor());\n    myDartiumPathTextWithBrowse.getTextField().getDocument().addDocumentListener(new DocumentAdapter() {\n      @Override\n      protected void textChanged(final DocumentEvent e) {\n        updateErrorLabel();\n      }\n    });\n\n    myDartiumSettingsButton.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(final ActionEvent e) {\n        ShowSettingsUtil.getInstance().editConfigurable(myProject, myDartiumSettingsCurrent.createConfigurable());\n      }\n    });\n  }","id":60940,"modified_method":"private void initDartSdkAndDartiumControls() {\n    final Computable<Boolean> isResettingControlsComputable = new Computable<Boolean>() {\n      public Boolean compute() {\n        return myInReset;\n      }\n    };\n\n    DartSdkUtil.initDartSdkAndDartiumControls(myProject, mySdkPathTextWithBrowse, myVersionLabel, myDartiumPathTextWithBrowse,\n                                              isResettingControlsComputable);\n\n    final DocumentAdapter documentListener = new DocumentAdapter() {\n      protected void textChanged(final DocumentEvent e) {\n        updateErrorLabel();\n      }\n    };\n\n    mySdkPathTextWithBrowse.getTextField().getDocument().addDocumentListener(documentListener);\n    myDartiumPathTextWithBrowse.getTextField().getDocument().addDocumentListener(documentListener);\n\n    myDartiumSettingsButton.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(final ActionEvent e) {\n        ShowSettingsUtil.getInstance().editConfigurable(myProject, myDartiumSettingsCurrent.createConfigurable());\n      }\n    });\n  }","commit_id":"2207a10800b2c63efecaf7a5dfcc3402239922af","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public void disposeUIResources() {\n    mySdkInitial = null;\n    myModulesWithDartSdkLibAttachedInitial.clear();\n  }","id":60941,"modified_method":"@Override\n  public void disposeUIResources() {\n    mySdkInitial = null;\n    myModulesWithDartSdkLibAttachedInitial.clear();\n    myDartiumInitial = null;\n    myDartiumSettingsCurrent = null;\n  }","commit_id":"2207a10800b2c63efecaf7a5dfcc3402239922af","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public void apply() throws ConfigurationException {\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      @Override\n      public void run() {\n        if (myEnableDartSupportCheckBox.isSelected()) {\n          final String sdkHomePath = FileUtilRt.toSystemIndependentName(mySdkPathTextWithBrowse.getText().trim());\n          final String initialSdkHomePath = mySdkInitial == null ? \"\" : mySdkInitial.getHomePath();\n\n          if (DartSdkUtil.isDartSdkHome(sdkHomePath)) {\n            final String dartSdkGlobalLibName;\n\n            if (mySdkInitial == null) {\n              dartSdkGlobalLibName = DartSdkGlobalLibUtil.createDartSdkGlobalLib(sdkHomePath);\n            }\n            else {\n              dartSdkGlobalLibName = mySdkInitial.getGlobalLibName();\n\n              if (!sdkHomePath.equals(initialSdkHomePath)) {\n                DartSdkGlobalLibUtil.updateDartSdkGlobalLib(dartSdkGlobalLibName, sdkHomePath);\n              }\n            }\n\n            final Module[] modules = DartSdkGlobalLibUtil.isIdeWithMultipleModuleSupport()\n                                     ? myModulesCheckboxTree.getCheckedNodes(Module.class, null)\n                                     : ModuleManager.getInstance(myProject).getModules();\n            DartSdkGlobalLibUtil.updateDependencyOnDartSdkGlobalLib(myProject, modules, dartSdkGlobalLibName);\n          }\n\n          final String dartiumPath = FileUtilRt.toSystemIndependentName(myDartiumPathTextWithBrowse.getText().trim());\n          final String dartiumPathInitial = myDartiumInitial == null ? null : myDartiumInitial.getPath();\n          if (!dartiumPath.isEmpty() && new File(dartiumPath).exists() && !dartiumPath.equals(dartiumPathInitial)) {\n            final WebBrowser browser = DartiumUtil.ensureDartiumBrowserConfigured(dartiumPath);\n            if (!myDartiumSettingsCurrent.equals(browser.getSpecificSettings())) {\n              WebBrowserManager.getInstance().setBrowserSpecificSettings(browser, myDartiumSettingsCurrent);\n            }\n          }\n\n          if (myDartiumInitial != null && !myDartiumSettingsCurrent.equals(myDartiumInitial.getSpecificSettings())) {\n            WebBrowserManager.getInstance().setBrowserSpecificSettings(myDartiumInitial, myDartiumSettingsCurrent);\n          }\n        }\n        else {\n          if (myModulesWithDartSdkLibAttachedInitial.size() > 0 && mySdkInitial != null) {\n            DartSdkGlobalLibUtil.detachDartSdkGlobalLib(myModulesWithDartSdkLibAttachedInitial, mySdkInitial.getGlobalLibName());\n          }\n        }\n      }\n    });\n\n    reset(); // because we rely on remembering initial state\n  }","id":60942,"modified_method":"@Override\n  public void apply() throws ConfigurationException {\n    // similar to DartWebApplicationGenerator.generateProject()\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      @Override\n      public void run() {\n        if (myEnableDartSupportCheckBox.isSelected()) {\n          final String sdkHomePath = FileUtilRt.toSystemIndependentName(mySdkPathTextWithBrowse.getText().trim());\n          final String initialSdkHomePath = mySdkInitial == null ? \"\" : mySdkInitial.getHomePath();\n\n          if (DartSdkUtil.isDartSdkHome(sdkHomePath)) {\n            final String dartSdkGlobalLibName;\n\n            if (mySdkInitial == null) {\n              dartSdkGlobalLibName = DartSdkGlobalLibUtil.createDartSdkGlobalLib(sdkHomePath);\n            }\n            else {\n              dartSdkGlobalLibName = mySdkInitial.getGlobalLibName();\n\n              if (!sdkHomePath.equals(initialSdkHomePath)) {\n                DartSdkGlobalLibUtil.updateDartSdkGlobalLib(dartSdkGlobalLibName, sdkHomePath);\n              }\n            }\n\n            final Module[] modules = DartSdkGlobalLibUtil.isIdeWithMultipleModuleSupport()\n                                     ? myModulesCheckboxTree.getCheckedNodes(Module.class, null)\n                                     : ModuleManager.getInstance(myProject).getModules();\n            DartSdkGlobalLibUtil.updateDependencyOnDartSdkGlobalLib(myProject, modules, dartSdkGlobalLibName);\n          }\n\n          final String dartiumPath = FileUtilRt.toSystemIndependentName(myDartiumPathTextWithBrowse.getText().trim());\n          DartiumUtil.applyDartiumSettings(dartiumPath, myDartiumSettingsCurrent);\n        }\n        else {\n          if (myModulesWithDartSdkLibAttachedInitial.size() > 0 && mySdkInitial != null) {\n            DartSdkGlobalLibUtil.detachDartSdkGlobalLib(myModulesWithDartSdkLibAttachedInitial, mySdkInitial.getGlobalLibName());\n          }\n        }\n      }\n    });\n\n    reset(); // because we rely on remembering initial state\n  }","commit_id":"2207a10800b2c63efecaf7a5dfcc3402239922af","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public void buildUI(final @NotNull SettingsStep settingsStep) {\n    settingsStep.addSettingsField(DartBundle.message(\"dart.sdk.path.label\"), mySdkPathTextWithBrowse);\n    settingsStep.addSettingsField(DartBundle.message(\"version.label\"), myVersionLabel);\n  }","id":60943,"modified_method":"@Override\n  public void buildUI(final @NotNull SettingsStep settingsStep) {\n    settingsStep.addSettingsField(DartBundle.message(\"dart.sdk.path.label\"), mySdkPathTextWithBrowse);\n    settingsStep.addSettingsField(DartBundle.message(\"version.label\"), myVersionLabel);\n    settingsStep.addSettingsField(DartBundle.message(\"dartium.path.label\"), myDartiumSettingsPanel);\n  }","commit_id":"2207a10800b2c63efecaf7a5dfcc3402239922af","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public DartGeneratorPeer() {\n    DartSdkUtil.initDartSdkPathTextFieldWithBrowseButton(null, mySdkPathTextWithBrowse, myVersionLabel);\n\n    final DartSdk sdk = DartSdk.getGlobalDartSdk();\n    mySdkPathTextWithBrowse.setText(sdk == null ? \"\" : FileUtil.toSystemDependentName(sdk.getHomePath()));\n  }","id":60944,"modified_method":"public DartGeneratorPeer() {\n    // set initial values before initDartSdkAndDartiumControls() because listeners should not be triggered on initialization\n    final DartSdk sdkInitial = DartSdk.getGlobalDartSdk();\n    mySdkPathTextWithBrowse.setText(sdkInitial == null ? \"\" : FileUtil.toSystemDependentName(sdkInitial.getHomePath()));\n\n    final WebBrowser dartiumInitial = DartiumUtil.getDartiumBrowser();\n    myDartiumSettingsCurrent = new ChromeSettings();\n    if (dartiumInitial != null) {\n      final BrowserSpecificSettings browserSpecificSettings = dartiumInitial.getSpecificSettings();\n      if (browserSpecificSettings instanceof ChromeSettings) {\n        myDartiumSettingsCurrent = (ChromeSettings)browserSpecificSettings.clone();\n      }\n    }\n\n    myDartiumPathTextWithBrowse.setText(dartiumInitial == null\n                                        ? \"\"\n                                        : FileUtilRt.toSystemDependentName(StringUtil.notNullize(dartiumInitial.getPath())));\n\n\n    // now setup controls\n    DartSdkUtil.initDartSdkAndDartiumControls(null, mySdkPathTextWithBrowse, myVersionLabel, myDartiumPathTextWithBrowse,\n                                              new Computable.PredefinedValueComputable<Boolean>(false));\n\n    myDartiumSettingsButton.addActionListener(new ActionListener() {\n      public void actionPerformed(final ActionEvent e) {\n        ShowSettingsUtil.getInstance().editConfigurable(myDartiumSettingsButton, myDartiumSettingsCurrent.createConfigurable());\n      }\n    });\n  }","commit_id":"2207a10800b2c63efecaf7a5dfcc3402239922af","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  @Override\n  public String getSettings() {\n    return FileUtil.toSystemIndependentName(mySdkPathTextWithBrowse.getText().trim());\n  }","id":60945,"modified_method":"@NotNull\n  @Override\n  public DartProjectWizardData getSettings() {\n    final String sdkPath = FileUtil.toSystemIndependentName(mySdkPathTextWithBrowse.getText().trim());\n    final String dartiumPath = FileUtil.toSystemIndependentName(myDartiumPathTextWithBrowse.getText().trim());\n    return new DartProjectWizardData(sdkPath, dartiumPath, myDartiumSettingsCurrent);\n  }","commit_id":"2207a10800b2c63efecaf7a5dfcc3402239922af","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public static void initDartSdkPathTextFieldWithBrowseButton(final @Nullable Project project,\n                                                              final @NotNull TextFieldWithBrowseButton dartSdkPathComponent,\n                                                              final @Nullable JBLabel versionLabel) {\n    final TextComponentAccessor<JTextField> textComponentAccessor = new TextComponentAccessor<JTextField>() {\n      @Override\n      public String getText(final JTextField component) {\n        return component.getText();\n      }\n\n      @Override\n      public void setText(final JTextField component, @NotNull String text) {\n        if (!text.isEmpty() && !isDartSdkHome(text)) {\n          final String probablySdkPath = text + \"/dart-sdk\";\n          if (isDartSdkHome(probablySdkPath)) {\n            component.setText(FileUtilRt.toSystemDependentName(probablySdkPath));\n            return;\n          }\n        }\n\n        component.setText(FileUtilRt.toSystemDependentName(text));\n      }\n    };\n\n    final ComponentWithBrowseButton.BrowseFolderActionListener<JTextField> browseFolderListener =\n      new ComponentWithBrowseButton.BrowseFolderActionListener<JTextField>(\"Select Dart SDK path\", null, dartSdkPathComponent, project,\n                                                                           FileChooserDescriptorFactory.createSingleFolderDescriptor(),\n                                                                           textComponentAccessor);\n    dartSdkPathComponent.addBrowseFolderListener(project, browseFolderListener);\n\n    if (versionLabel != null) {\n      dartSdkPathComponent.getTextField().getDocument().addDocumentListener(new DocumentAdapter() {\n        @Override\n        protected void textChanged(final DocumentEvent e) {\n          final String sdkHomePath = dartSdkPathComponent.getText().trim();\n          versionLabel.setText(sdkHomePath.isEmpty() ? \"\" : getSdkVersion(sdkHomePath));\n        }\n      });\n    }\n  }","id":60946,"modified_method":"public static void initDartSdkAndDartiumControls(final @Nullable Project project,\n                                                   final @NotNull TextFieldWithBrowseButton dartSdkPathComponent,\n                                                   final @NotNull JBLabel versionLabel,\n                                                   final @NotNull TextFieldWithBrowseButton dartiumPathComponent,\n                                                   final @NotNull Computable<Boolean> isResettingControlsComputable) {\n    final TextComponentAccessor<JTextField> textComponentAccessor = new TextComponentAccessor<JTextField>() {\n      @Override\n      public String getText(final JTextField component) {\n        return component.getText();\n      }\n\n      @Override\n      public void setText(final JTextField component, @NotNull String text) {\n        if (!text.isEmpty() && !isDartSdkHome(text)) {\n          final String probablySdkPath = text + \"/dart-sdk\";\n          if (isDartSdkHome(probablySdkPath)) {\n            component.setText(FileUtilRt.toSystemDependentName(probablySdkPath));\n            return;\n          }\n        }\n\n        component.setText(FileUtilRt.toSystemDependentName(text));\n      }\n    };\n\n    final ComponentWithBrowseButton.BrowseFolderActionListener<JTextField> browseFolderListener =\n      new ComponentWithBrowseButton.BrowseFolderActionListener<JTextField>(\"Select Dart SDK path\", null, dartSdkPathComponent, project,\n                                                                           FileChooserDescriptorFactory.createSingleFolderDescriptor(),\n                                                                           textComponentAccessor);\n    dartSdkPathComponent.addBrowseFolderListener(project, browseFolderListener);\n\n    dartiumPathComponent.addBrowseFolderListener(\"Select Dartium browser path\", null, project,\n                                                 FileChooserDescriptorFactory.createSingleFileOrExecutableAppDescriptor());\n\n    dartSdkPathComponent.getTextField().getDocument().addDocumentListener(new DocumentAdapter() {\n      @Override\n      protected void textChanged(final DocumentEvent e) {\n        final String sdkHomePath = dartSdkPathComponent.getText().trim();\n        versionLabel.setText(sdkHomePath.isEmpty() ? \"\" : getSdkVersion(sdkHomePath));\n\n        if (!isResettingControlsComputable.compute() && isDartSdkHome(sdkHomePath)) {\n          final String dartiumPath = DartiumUtil.getDartiumPathForSdk(sdkHomePath);\n          if (dartiumPath != null) {\n            dartiumPathComponent.setText(FileUtilRt.toSystemDependentName(dartiumPath));\n          }\n        }\n      }\n    });\n  }","commit_id":"2207a10800b2c63efecaf7a5dfcc3402239922af","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  public GeneratorPeer<String> createPeer() {\n    return new DartGeneratorPeer();\n  }","id":60947,"modified_method":"@NotNull\n  public GeneratorPeer<DartProjectWizardData> createPeer() {\n    return new DartGeneratorPeer();\n  }","commit_id":"2207a10800b2c63efecaf7a5dfcc3402239922af","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void generateProject(final @NotNull Project project,\n                              final @NotNull VirtualFile baseDir,\n                              final @NotNull String dartSdkPath,\n                              final @NotNull Module module) {\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      public void run() {\n        if (DartSdkUtil.isDartSdkHome(dartSdkPath)) {\n          final DartSdk sdk = DartSdk.getGlobalDartSdk();\n\n          final String dartSdkLibName;\n          if (sdk == null) {\n            dartSdkLibName = DartSdkGlobalLibUtil.createDartSdkGlobalLib(dartSdkPath);\n          }\n          else {\n            dartSdkLibName = sdk.getGlobalLibName();\n\n            if (!dartSdkPath.equals(sdk.getHomePath())) {\n              DartSdkGlobalLibUtil.updateDartSdkGlobalLib(dartSdkLibName, dartSdkPath);\n            }\n          }\n\n          DartSdkGlobalLibUtil.configureDependencyOnGlobalLib(module, dartSdkLibName);\n        }\n\n        try {\n          baseDir.createChildDirectory(this, \"web\");\n          baseDir.createChildDirectory(this, \"lib\");\n          final VirtualFile pubspecYamlFile = baseDir.createChildData(this, \"pubspec.yaml\");\n          pubspecYamlFile.setBinaryContent((\"name: \" + module.getName() + \"\\n\" +\n                                            \"dependencies:\\n\" +\n                                            \"  browser: any\").getBytes());\n        }\n        catch (IOException ignore) {/* unlucky */}\n      }\n    });\n  }","id":60948,"modified_method":"public void generateProject(final @NotNull Project project,\n                              final @NotNull VirtualFile baseDir,\n                              final @NotNull DartProjectWizardData data,\n                              final @NotNull Module module) {\n    // similar to DartConfigurable.apply()\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      public void run() {\n        if (DartSdkUtil.isDartSdkHome(data.dartSdkPath)) {\n          final DartSdk sdk = DartSdk.getGlobalDartSdk();\n\n          final String dartSdkLibName;\n          if (sdk == null) {\n            dartSdkLibName = DartSdkGlobalLibUtil.createDartSdkGlobalLib(data.dartSdkPath);\n          }\n          else {\n            dartSdkLibName = sdk.getGlobalLibName();\n\n            if (!data.dartSdkPath.equals(sdk.getHomePath())) {\n              DartSdkGlobalLibUtil.updateDartSdkGlobalLib(dartSdkLibName, data.dartSdkPath);\n            }\n          }\n\n          DartSdkGlobalLibUtil.configureDependencyOnGlobalLib(module, dartSdkLibName);\n        }\n\n        DartiumUtil.applyDartiumSettings(FileUtilRt.toSystemIndependentName(data.dartiumPath), data.dartiumSettings);\n\n        try {\n          baseDir.createChildDirectory(this, \"web\");\n          baseDir.createChildDirectory(this, \"lib\");\n          final VirtualFile pubspecYamlFile = baseDir.createChildData(this, \"pubspec.yaml\");\n          pubspecYamlFile.setBinaryContent((\"name: \" + module.getName() + \"\\n\" +\n                                            \"dependencies:\\n\" +\n                                            \"  browser: any\").getBytes());\n        }\n        catch (IOException ignore) {/* unlucky */}\n      }\n    });\n  }","commit_id":"2207a10800b2c63efecaf7a5dfcc3402239922af","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void diffToJsop(NodeState before, NodeState after, final String path,\n            final StringBuilder jsop) {\n\n        store.compare(before, after, new NodeStateDiff() {\n            @Override\n            public void propertyAdded(PropertyState after) {\n                jsop.append('^').append(buildPath(after.getName()))\n                        .append(':').append(toJson(after));\n            }\n\n            @Override\n            public void propertyChanged(PropertyState before, PropertyState after) {\n                jsop.append('^').append(buildPath(after.getName()))\n                        .append(':').append(toJson(after));\n            }\n\n            @Override\n            public void propertyDeleted(PropertyState before) {\n                jsop.append('^').append(buildPath(before.getName())).append(\":null\");\n            }\n\n            @Override\n            public void childNodeAdded(String name, NodeState after) {\n                jsop.append('+').append(buildPath(name)).append(':');\n                toJson(after);\n            }\n\n            @Override\n            public void childNodeDeleted(String name, NodeState before) {\n                jsop.append('-').append(buildPath(name));\n            }\n\n            @Override\n            public void childNodeChanged(String name, NodeState before, NodeState after) {\n                diffToJsop(before, after, PathUtils.concat(path, name), jsop);\n            }\n\n            private String buildPath(String name) {\n                return '\"' + PathUtils.concat(path, name) + '\"';\n            }\n\n            private String toJson(PropertyState propertyState) {\n                return propertyState.isArray()\n                    ? CoreValueMapper.toJsonArray(propertyState.getValues())\n                    : CoreValueMapper.toJsonValue(propertyState.getValue());\n            }\n\n            private void toJson(NodeState nodeState) {\n                jsop.append('{');\n                String comma = \"\";\n                for (PropertyState property : nodeState.getProperties()) {\n                    String value = property.isArray()\n                            ? CoreValueMapper.toJsonArray(property.getValues())\n                            : CoreValueMapper.toJsonValue(property.getValue());\n\n                    jsop.append(comma);\n                    comma = \",\";\n                    jsop.append('\"').append(property.getName()).append(\"\\\":\").append(value);\n                }\n\n                for (ChildNodeEntry child : nodeState.getChildNodeEntries()) {\n                    jsop.append(comma);\n                    comma = \",\";\n                    jsop.append('\"').append(child.getName()).append(\"\\\":\");\n                    toJson(child.getNodeState());\n                }\n                jsop.append('}');\n            }\n        });\n    }","id":60949,"modified_method":"private void diffToJsop(NodeState before, NodeState after, final String path,\n            final StringBuilder jsop) {\n\n        store.compare(before, after, new NodeStateDiff() {\n            @Override\n            public void propertyAdded(PropertyState after) {\n                jsop.append('^').append(buildPath(after.getName()))\n                        .append(':').append(toJson(after));\n            }\n\n            @Override\n            public void propertyChanged(PropertyState before, PropertyState after) {\n                jsop.append('^').append(buildPath(after.getName()))\n                        .append(':').append(toJson(after));\n            }\n\n            @Override\n            public void propertyDeleted(PropertyState before) {\n                jsop.append('^').append(buildPath(before.getName())).append(\":null\");\n            }\n\n            @Override\n            public void childNodeAdded(String name, NodeState after) {\n                jsop.append('+').append(buildPath(name)).append(':');\n                toJson(after);\n            }\n\n            @Override\n            public void childNodeDeleted(String name, NodeState before) {\n                jsop.append('-').append(buildPath(name));\n            }\n\n            @Override\n            public void childNodeChanged(String name, NodeState before, NodeState after) {\n                diffToJsop(before, after, PathUtils.concat(path, name), jsop);\n            }\n\n            private String buildPath(String name) {\n                return '\"' + PathUtils.concat(path, name) + '\"';\n            }\n\n            private String toJson(PropertyState propertyState) {\n                return propertyState.isArray()\n                    ? CoreValueMapper.toJsonArray(propertyState.getValues())\n                    : CoreValueMapper.toJsonValue(propertyState.getValue());\n            }\n\n            private void toJson(NodeState nodeState) {\n                jsop.append('{');\n                String comma = \"\";\n                for (PropertyState property : nodeState.getProperties()) {\n                    String value = toJson(property);\n                    jsop.append(comma);\n                    comma = \",\";\n                    jsop.append('\"').append(property.getName()).append(\"\\\":\").append(value);\n                }\n\n                for (ChildNodeEntry child : nodeState.getChildNodeEntries()) {\n                    jsop.append(comma);\n                    comma = \",\";\n                    jsop.append('\"').append(child.getName()).append(\"\\\":\");\n                    toJson(child.getNodeState());\n                }\n                jsop.append('}');\n            }\n        });\n    }","commit_id":"7b8344fff3f0460fe9711979ed0190f69671bc74","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Get the value of the property\n     * @return  value or {@code null} if single valued\n     */\n    public Iterable<CoreValue> getValues() {\n        return getPropertyState().getValues();\n    }","id":60950,"modified_method":"/**\n     * Get the value of the property\n     * @return  value or {@code null} if single valued\n     */\n    public Iterable<CoreValue> getValues() {\n        PropertyState state = getPropertyState();\n        return state == null ? null : state.getValues();\n    }","commit_id":"7b8344fff3f0460fe9711979ed0190f69671bc74","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Get the value of the property\n     * @return  value or {@code null} if multi values\n     */\n    public CoreValue getValue() {\n        return getPropertyState().getValue();\n    }","id":60951,"modified_method":"/**\n     * Get the value of the property\n     * @return  value or {@code null} if multi values\n     */\n    public CoreValue getValue() {\n        PropertyState state = getPropertyState();\n        return state.isArray() ? null : state.getValue();\n    }","commit_id":"7b8344fff3f0460fe9711979ed0190f69671bc74","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public CoreValue getValue() {\n        return value;\n    }","id":60952,"modified_method":"@Override\n    public CoreValue getValue() {\n        if (value == null) {\n            throw new IllegalStateException(\"Not a single valued property\");\n        }\n        return value;\n    }","commit_id":"7b8344fff3f0460fe9711979ed0190f69671bc74","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public Iterable<CoreValue> getValues() {\n        return values;\n    }","id":60953,"modified_method":"@Override\n    public Iterable<CoreValue> getValues() {\n        if (values == null) {\n            throw new IllegalStateException(\"Not a multi valued property\");\n        }\n        return values;\n    }","commit_id":"7b8344fff3f0460fe9711979ed0190f69671bc74","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Get the value of the property\n     *\n     * @return the value of the property\n     * @throws InvalidItemStateException\n     */\n    @Nonnull\n    public Value getValue() throws InvalidItemStateException {\n        return ValueFactoryImpl.createValue(getPropertyState(), sessionDelegate.getNamePathMapper());\n    }","id":60954,"modified_method":"/**\n     * Get the value of the property\n     *\n     * @return the value of the property\n     * @throws InvalidItemStateException\n     * @throws ValueFormatException if this property is multi-valued\n     */\n    @Nonnull\n    public Value getValue() throws InvalidItemStateException, ValueFormatException {\n        PropertyState property = getPropertyState();\n        if (property.isArray()) {\n            throw new ValueFormatException(this + \" is multi-valued.\");\n        }\n        return ValueFactoryImpl.createValue(property, sessionDelegate.getNamePathMapper());\n    }","commit_id":"feeb74212844c53685919146b8760355bb783cdd","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Get the values of the property\n     *\n     * @return the values of the property\n     * @throws InvalidItemStateException\n     */\n    @Nonnull\n    public List<Value> getValues() throws InvalidItemStateException {\n        return ValueFactoryImpl.createValues(getPropertyState(), sessionDelegate.getNamePathMapper());\n    }","id":60955,"modified_method":"/**\n     * Get the values of the property\n     *\n     * @return the values of the property\n     * @throws InvalidItemStateException\n     * @throws ValueFormatException if this property is single-valued\n     */\n    @Nonnull\n    public List<Value> getValues() throws InvalidItemStateException, ValueFormatException {\n        PropertyState property = getPropertyState();\n        if (!property.isArray()) {\n            throw new ValueFormatException(this + \" is single-valued.\");\n        }\n        return ValueFactoryImpl.createValues(property, sessionDelegate.getNamePathMapper());\n    }","commit_id":"feeb74212844c53685919146b8760355bb783cdd","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    @Nonnull\n    public Value getValue() throws RepositoryException {\n        checkStatus();\n\n        return perform(new SessionOperation<Value>() {\n            @Override\n            public Value perform() throws RepositoryException {\n                if (isMultiple()) {\n                    throw new ValueFormatException(this + \" is multi-valued.\");\n                }\n\n                return dlg.getValue();\n            }\n        });\n    }","id":60956,"modified_method":"@Override\n    @Nonnull\n    public Value getValue() throws RepositoryException {\n        checkStatus();\n\n        return perform(new SessionOperation<Value>() {\n            @Override\n            public Value perform() throws RepositoryException {\n                return dlg.getValue();\n            }\n        });\n    }","commit_id":"feeb74212844c53685919146b8760355bb783cdd","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    @Nonnull\n    public Value[] getValues() throws RepositoryException {\n        checkStatus();\n\n        return perform(new SessionOperation<Value[]>() {\n            @Override\n            public Value[] perform() throws RepositoryException {\n                if (!isMultiple()) {\n                    throw new ValueFormatException(this + \" is not multi-valued.\");\n                }\n\n                return Iterables.toArray(dlg.getValues(), Value.class);\n            }\n        });\n    }","id":60957,"modified_method":"@Override\n    @Nonnull\n    public Value[] getValues() throws RepositoryException {\n        checkStatus();\n\n        return perform(new SessionOperation<List<Value>>() {\n            @Override\n            public List<Value> perform() throws RepositoryException {\n                return dlg.getValues();\n            }\n        }).toArray(NO_VALUES);\n    }","commit_id":"feeb74212844c53685919146b8760355bb783cdd","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"protected int readInternal(byte [] buf, int offset, int len) throws IOException {\n\t\t\n\t\tif (_atEOF) {\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tLibrary.logger().finer(baseName() + \": reading \" + len + \" bytes into buffer of length \" + \n\t\t\t\t((null != buf) ? buf.length : \"null\") + \" at offset \" + offset);\n\t\t// is this the first block?\n\t\tif (null == _currentBlock) {\n\t\t\tif (_atEOF)\n\t\t\t\treturn -1;\n\t\t\t_currentBlock = getFirstBlock();\n\t\t\t_blockOffset = 0;\n\t\t\tif (null == _currentBlock) {\n\t\t\t\t_atEOF = true;\n\t\t\t\treturn -1; // nothing to read\n\t\t\t}\n\t\t} \n\t\tLibrary.logger().finer(\"reading from block: \" + _currentBlock.name() + \" length: \" + \n\t\t\t\t_currentBlock.contentLength() +\n\t\t\t\t\" at offset \" + _blockOffset);\n\t\t\n\t\t// Now we have a block in place. Read from it. If we run out of block before\n\t\t// we've read len bytes, pull next block.\n\t\tint lenToRead = len;\n\t\tint lenRead = 0;\n\t\twhile (lenToRead > 0) {\n\t\t\tif (_blockOffset >= _currentBlock.contentLength()) {\n\t\t\t\t// DKS make sure we don't miss a byte...\n\t\t\t\t_currentBlock = getNextBlock();\n\t\t\t\t_blockOffset = 0;\n\t\t\t\tif (null == _currentBlock) {\n\t\t\t\t\tLibrary.logger().info(\"next block was null, setting _atEOF, returning \" + ((lenRead > 0) ? lenRead : -1));\n\t\t\t\t\t_atEOF = true;\n\t\t\t\t\tif (lenRead > 0) {\n\t\t\t\t\t\treturn lenRead;\n\t\t\t\t\t}\n\t\t\t\t\treturn -1; // no bytes read, at eof\n\t\t\t\t}\n\t\t\t\tLibrary.logger().info(\"now reading from block: \" + _currentBlock.name() + \" length: \" + \n\t\t\t\t\t\t_currentBlock.contentLength() +\n\t\t\t\t\t\t\" at offset \" + _blockOffset);\n\t\t\t}\n\t\t\tint readCount = ((_currentBlock.contentLength() - _blockOffset) > lenToRead) ? lenToRead : (_currentBlock.contentLength() - _blockOffset);\n\t\t\tif (null != buf) {} // use for skip\n\t\t\t\tLibrary.logger().finest(\"before arraycopy: content length \"+_currentBlock.contentLength()+\" _blockOffset \"+_blockOffset+\" dst length \"+buf.length+\" dst index \"+offset+\" len to copy \"+readCount);\n\t\t\t\tSystem.arraycopy(_currentBlock.content(), _blockOffset, buf, offset, readCount);\n\t\t\t\n\t\t\t_blockOffset += readCount;\n\t\t\toffset += readCount;\n\t\t\tlenToRead -= readCount;\n\t\t\tlenRead += readCount;\n\t\t\tLibrary.logger().finest(\"     read \" + readCount + \" bytes for \" + lenRead + \" total, \" + lenToRead + \" remaining.\");\n\t\t\t\n\t\t}\n\t\treturn lenRead;\n\t}","id":60958,"modified_method":"protected int readInternal(byte [] buf, int offset, int len) throws IOException {\n\t\t\n\t\tif (_atEOF) {\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tLibrary.logger().finer(baseName() + \": reading \" + len + \" bytes into buffer of length \" + \n\t\t\t\t((null != buf) ? buf.length : \"null\") + \" at offset \" + offset);\n\t\t// is this the first block?\n\t\tif (null == _currentBlock) {\n\t\t\tif (_atEOF)\n\t\t\t\treturn -1;\n\t\t\tContentObject firstBlock = getFirstBlock();\n\t\t\tif (null == firstBlock) {\n\t\t\t\t_atEOF = true;\n\t\t\t\treturn -1; // nothing to read\n\t\t\t}\n\t\t\tsetCurrentBlock(firstBlock);\n\t\t} \n\t\tLibrary.logger().finer(\"reading from block: \" + _currentBlock.name() + \" length: \" + \n\t\t\t\t_currentBlock.contentLength());\n\t\t\n\t\t// Now we have a block in place. Read from it. If we run out of block before\n\t\t// we've read len bytes, pull next block.\n\t\tint lenToRead = len;\n\t\tint lenRead = 0;\n\t\tlong readCount = 0;\n\t\twhile (lenToRead > 0) {\n\t\t\tif (0 == _blockReadStream.available()) {\n\t\t\t\t// DKS make sure we don't miss a byte...\n\t\t\t\tsetCurrentBlock(getNextBlock());\n\t\t\t\tif (null == _currentBlock) {\n\t\t\t\t\tLibrary.logger().info(\"next block was null, setting _atEOF, returning \" + ((lenRead > 0) ? lenRead : -1));\n\t\t\t\t\t_atEOF = true;\n\t\t\t\t\tif (lenRead > 0) {\n\t\t\t\t\t\treturn lenRead;\n\t\t\t\t\t}\n\t\t\t\t\treturn -1; // no bytes read, at eof\n\t\t\t\t}\n\t\t\t\tLibrary.logger().info(\"now reading from block: \" + _currentBlock.name() + \" length: \" + \n\t\t\t\t\t\t_currentBlock.contentLength());\n\t\t\t}\n\t\t\tif (null != buf) {  // use for skip\n\t\t\t\tLibrary.logger().finest(\"before block read: content length \"+_currentBlock.contentLength()+\" position \"+ tell() +\" available: \" + _blockReadStream.available() + \" dst length \"+buf.length+\" dst index \"+offset+\" len to read \"+lenToRead);\n\t\t\t\t// Read as many bytes as we can\n\t\t\t\treadCount = _blockReadStream.read(buf, offset, lenToRead);\n\t\t\t} else {\n\t\t\t\treadCount = _blockReadStream.skip(lenToRead);\n\t\t\t}\n\t\t\t\n\t\t\tif (readCount < 0) {\n\t\t\t\tLibrary.logger().info(\"Tried to read at end of block, go get next block.\");\n\t\t\t} else {\n\t\t\t\toffset += readCount;\n\t\t\t\tlenToRead -= readCount;\n\t\t\t\tlenRead += readCount;\n\t\t\t\tLibrary.logger().finest(\"     read \" + readCount + \" bytes for \" + lenRead + \" total, \" + lenToRead + \" remaining.\");\n\t\t\t}\n\t\t}\n\t\treturn lenRead;\n\t}","commit_id":"83cecd1e0bc9a402359698eabb40843cacc9f8bf","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"@Override\n\tpublic synchronized void mark(int readlimit) {\n\t\t_readlimit = readlimit;\n\t\t_markBlock = blockIndex();\n\t\tif (null == _currentBlockStream) {\n\t\t\t_markOffset = 0;\n\t\t} else {\n\t\t\t_markOffset = _currentBlock.contentLength() - _currentBlockStream.available();\n\t\t}\n\t\tLibrary.logger().finer(\"mark: block: \" + blockIndex() + \" offset: \" + _blockOffset);\n\t}","id":60959,"modified_method":"@Override\n\tpublic synchronized void mark(int readlimit) {\n\t\t_readlimit = readlimit;\n\t\t_markBlock = blockIndex();\n\t\tif (null == _currentBlockStream) {\n\t\t\t_markOffset = 0;\n\t\t} else {\n\t\t\t_markOffset = _currentBlock.contentLength() - _currentBlockStream.available();\n\t\t}\n\t\tLibrary.logger().finer(\"mark: block: \" + blockIndex() + \" offset: \" + _markOffset);\n\t}","commit_id":"83cecd1e0bc9a402359698eabb40843cacc9f8bf","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public boolean isGone() throws IOException {\n\t\tif (null == _currentBlock && null == _goneBlock)\n\t\t\tgetFirstBlock();\n\t\treturn (null != _goneBlock);\n\t}","id":60960,"modified_method":"public boolean isGone() throws IOException {\n\t\tContentObject newBlock = null;\n\n\t\tif (null == _currentBlock && null == _goneBlock) {\n\t\t\tnewBlock = getFirstBlock(); // sets _goneBlock, but not _currentBlock\n\t\t}\n\t\tif (null == _goneBlock) {\n\t\t\tif (null != newBlock) {\n\t\t\t\tsetCurrentBlock(newBlock); // save it for reuse\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}","commit_id":"2f3372e57c3970d830ccc141226e2067c1387c24","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"protected ContentObject getFirstBlock() throws IOException {\n\t\tif (VersioningProfile.isVersioned(_baseName)) {\n\t\t\treturn super.getFirstBlock();\n\t\t}\n\t\tLibrary.logger().info(\"getFirstBlock: getting latest version of \" + _baseName);\n\t\tContentObject result =  _library.getLatestVersion(_baseName, null, _timeout);\n\t\tif (null != result){\n\t\t\tLibrary.logger().info(\"getFirstBlock: retrieved latest version object \" + result.name() + \" type: \" + result.signedInfo().getTypeName());\n\t\t\t// Now need to verify the block we got\n\t\t\tif (!verifyBlock(result)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// Now we know the version\n\t\t\t_baseName = SegmentationProfile.segmentRoot(result.name());\n\t\t\tLibrary.logger().info(\"getFirstBlock: Have version information, now querying first segment.\");\n\t\t\treturn super.getFirstBlock(); // now that we have the latest version, go back for the first block.\n\t\t} else {\n\t\t\tLibrary.logger().info(\"getFirstBlock: no block available for latest version of \" + _baseName);\n\t\t}\n\t\treturn result;\n\t}","id":60961,"modified_method":"protected ContentObject getFirstBlock() throws IOException {\n\t\tif (VersioningProfile.isVersioned(_baseName)) {\n\t\t\treturn super.getFirstBlock();\n\t\t}\n\t\tLibrary.logger().info(\"getFirstBlock: getting latest version of \" + _baseName);\n\t\tContentObject result =  _library.getLatestVersion(_baseName, null, _timeout);\n\t\tif (null != result){\n\t\t\tLibrary.logger().info(\"getFirstBlock: retrieved latest version object \" + result.name() + \" type: \" + result.signedInfo().getTypeName());\n\t\t\t// Now need to verify the block we got\n\t\t\tif (!verifyBlock(result)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t_baseName = SegmentationProfile.segmentRoot(result.name());\n\t\t\t// Now we know the version. Did we luck out and get first block?\n\t\t\tif (isFirstBlock(result)) {\n\t\t\t\tLibrary.logger().info(\"getFirstBlock: got first block on first try: \" + result.name());\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tLibrary.logger().info(\"getFirstBlock: Have version information, now querying first segment.\");\n\t\t\treturn super.getFirstBlock(); // now that we have the latest version, go back for the first block.\n\t\t} else {\n\t\t\tLibrary.logger().info(\"getFirstBlock: no block available for latest version of \" + _baseName);\n\t\t}\n\t\treturn result;\n\t}","commit_id":"2f3372e57c3970d830ccc141226e2067c1387c24","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"protected int readInternal(byte [] buf, int offset, int len) throws IOException {\n\t\t\n\t\tLibrary.logger().info(\"CCNBlockInputStream: reading \" + len + \" bytes into buffer of length \" + \n\t\t\t\t((null != buf) ? buf.length : \"null\") + \" at offset \" + offset);\n\t\t// is this the first block?\n\t\tif (null == _currentBlock) {\n\t\t\tsetCurrentBlock(getFirstBlock());\n\t\t\tif (null == _currentBlock)\n\t\t\t\treturn 0; // nothing to read\n\t\t} \n\t\t\n\t\t// Now we have a block in place. Read from it. If we run out of block before\n\t\t// we've read len bytes, return what we read. On next read, pull next block.\n\t\tint remainingBytes = _blockReadStream.available();\n\t\t\n\t\tif (remainingBytes <= 0) {\n\t\t\tsetCurrentBlock(getNextBlock());\n\t\t\tif (null == _currentBlock) {\n\t\t\t\t// in socket implementation, this would be EAGAIN\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tremainingBytes = _blockReadStream.available();\n\t\t}\n\t\t// Read minimum of remainder of this block and available buffer.\n\t\tlong readCount = (remainingBytes > len) ? len : remainingBytes;\n\t\tif (null != buf) { // use for skip\n\t\t\treadCount = _blockReadStream.read(buf, offset, len);\n\t\t} else {\n\t\t\treadCount = _blockReadStream.skip(len);\n\t\t}\n\t\tLibrary.logger().info(\"CCNBlockInputStream: read \" + readCount + \" bytes from block \" + _currentBlock.name());\n\t\treturn (int)readCount;\n\t}","id":60962,"modified_method":"protected int readInternal(byte [] buf, int offset, int len) throws IOException {\n\t\t\n\t\tLibrary.logger().info(\"CCNBlockInputStream: reading \" + len + \" bytes into buffer of length \" + \n\t\t\t\t((null != buf) ? buf.length : \"null\") + \" at offset \" + offset);\n\t\t// is this the first block?\n\t\tif (null == _currentBlock) {\n\t\t\tContentObject firstBlock = getFirstBlock();\n\t\t\tif (null == firstBlock) {\n\t\t\t\treturn -1; // nothing to read\n\t\t\t}\n\t\t\tsetCurrentBlock(firstBlock);\n\t\t} \n\t\t\n\t\t// Now we have a block in place. Read from it. If we run out of block before\n\t\t// we've read len bytes, return what we read. On next read, pull next block.\n\t\tint remainingBytes = _blockReadStream.available();\n\t\t\n\t\tif (remainingBytes <= 0) {\n\t\t\tsetCurrentBlock(getNextBlock());\n\t\t\tif (null == _currentBlock) {\n\t\t\t\t// in socket implementation, this would be EAGAIN\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tremainingBytes = _blockReadStream.available();\n\t\t}\n\t\t// Read minimum of remainder of this block and available buffer.\n\t\tlong readCount = (remainingBytes > len) ? len : remainingBytes;\n\t\tif (null != buf) { // use for skip\n\t\t\treadCount = _blockReadStream.read(buf, offset, len);\n\t\t} else {\n\t\t\treadCount = _blockReadStream.skip(len);\n\t\t}\n\t\tLibrary.logger().info(\"CCNBlockInputStream: read \" + readCount + \" bytes from block \" + _currentBlock.name());\n\t\treturn (int)readCount;\n\t}","commit_id":"24460640b0f06d56e021af13e8597f44c1c5c12f","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public static boolean isLanguageAspect(ModelRoot root, IModule module, SModelFqName modelFqName) {\n    if (!isUnderLanguageModels(module, root)) return false;\n    //prefixed with language namespace\n    if (!NameUtil.namespaceFromLongName(modelFqName.getLongName()).equals(module.getModuleFqName())) return false;\n    //is aspect model name\n    if (LanguageAspect.valueOf(NameUtil.shortNameFromLongName(modelFqName.getLongName())) == null) return false;\n    //is non-stereotyped (? test models)\n    //if (modelFqName.getStereotype() != null && !modelFqName.getStereotype().equals(\"\")) return false;\n\n    return true;\n  }","id":60963,"modified_method":"public static boolean isLanguageAspect(ModelRoot root, IModule module, SModelFqName modelFqName) {\n    if (!isUnderLanguageModels(module, root)) return false;\n    //prefixed with language namespace\n    if (!NameUtil.namespaceFromLongName(modelFqName.getLongName()).equals(module.getModuleFqName())) return false;\n    //is aspect model name\n    String name = NameUtil.shortNameFromLongName(modelFqName.getLongName());\n    for (LanguageAspect la:LanguageAspect.values()){\n      if (la.getName().equals(name)) return true;\n    }\n    return false;\n    //is non-stereotyped (? test models)\n    //if (modelFqName.getStereotype() != null && !modelFqName.getStereotype().equals(\"\")) return false;\n  }","commit_id":"7afc6b1c686932266a1856dbcba1f910b410aee7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SNode getBreakingNodeAndClearContext() {\n    SNode node = breakingNodePointer.getNode();\n    breakingNodePointer = null;\n    return node;\n  }","id":60964,"modified_method":"public SNode getBreakingNodeAndClearContext() {\n    if (breakingNodePointer == null) {\n      return null;\n    }\n\n    SNode node = breakingNodePointer.getNode();\n    breakingNodePointer = null;\n    return node;\n  }","commit_id":"9bbd99a2847f7e5bb4d62e183857384b5db4a4a3","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public boolean canBeAnAncestor(IOperationContext operationContext, CanBeAnAncestorContext _context, @Nullable CheckingNodeContext checkingNodeContext) {\n      boolean result = invokeCanBeASomethingMethod(canBeAnAncestorMethod, operationContext, _context);\n\n      if (checkingNodeContext != null && !result) {\n        SNode constraints = getConceptConstraints(canBeAnAncestorMethod);\n        if (constraints == null) {\n          throw new RuntimeException(\"Empty concept constraints\");\n        }\n        checkingNodeContext.breakingNodePointer = new SNodePointer(SConstraintsUtil.getConceptConstraints_CanBeAncestor(constraints));\n      }\n\n      return result;\n    }","id":60965,"modified_method":"@Override\n    public boolean canBeAnAncestor(IOperationContext operationContext, CanBeAnAncestorContext _context, @Nullable CheckingNodeContext checkingNodeContext) {\n      boolean result = invokeCanBeASomethingMethod(canBeAnAncestorMethod, operationContext, _context);\n\n      if (checkingNodeContext != null && !result) {\n        checkingNodeContext.breakingNodePointer = getConceptConstraint(canBeAnAncestorMethod, operationContext, \"canBeAncestor\");\n      }\n\n      return result;\n    }","commit_id":"9bbd99a2847f7e5bb4d62e183857384b5db4a4a3","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode getConceptConstraints(Method method) {\n      String fqName = method.getDeclaringClass().getName();\n\n      Language language = getLanguageForConceptFqName(fqName);\n      if (language == null) {\n        return null;\n      }\n\n      SModelDescriptor sm = language.getConstraintsModelDescriptor();\n      if (sm == null) {\n        return null;\n      }\n\n      SNode root = SModelOperations.getRootByName(sm.getSModel(), NameUtil.shortNameFromLongName(fqName));\n      if (root == null) {\n        return null;\n      }\n\n      if (jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations.isInstanceOf(root, SConstraintsUtil.concept_ConceptConstraints)) {\n        return root;\n      }\n\n      return null;\n    }","id":60966,"modified_method":"private static SNode getConceptConstraints(IOperationContext context, Method method) {\n      Class cls = method.getDeclaringClass();\n      String fqName = cls.getName();\n      String modelName = NameUtil.namespaceFromLongName(fqName);\n      String rootName = NameUtil.shortNameFromLongName(fqName);\n      Language language = context.getScope().getLanguage(NameUtil.namespaceFromLongName(modelName));\n      if (language == null) {\n        return null;\n      }\n      SModelDescriptor sm = language.getConstraintsModelDescriptor();\n      if (sm == null) return null;\n      SNode root = SModelOperations.getRootByName(sm.getSModel(), rootName);\n      if (root == null) return null;\n      if (SNodeOperations.isInstanceOf(root, SConstraintsUtil.concept_ConceptConstraints)) {\n        return root;\n      }\n      return null;\n    }","commit_id":"9bbd99a2847f7e5bb4d62e183857384b5db4a4a3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public InterpretedConstraints(String fqName) {\n      this.fqName = fqName;\n\n      canBeAChildMethod = getCanBeSomethingMethodWithInheritance(fqName, BehaviorConstants.CAN_BE_A_CHILD_METHOD_NAME, IOperationContext.class, CanBeAChildContext.class);\n      canBeAnAncestorMethod = getCanBeSomethingMethodWithInheritance(fqName, BehaviorConstants.CAN_BE_AN_ANCESTOR_METHOD_NAME, IOperationContext.class, CanBeAnAncestorContext.class);\n      canBeAParentMethod = getCanBeSomethingMethodWithInheritance(fqName, BehaviorConstants.CAN_BE_A_PARENT_METHOD_NAME, IOperationContext.class, CanBeAParentContext.class);\n      canBeARootMethod = getCanBeSomethingMethodWithInheritance(fqName, BehaviorConstants.CAN_BE_A_ROOT_METHOD_NAME, IOperationContext.class, CanBeARootContext.class);\n    }","id":60967,"modified_method":"public InterpretedConstraints(String fqName) {\n      this.fqName = fqName;\n\n      canBeAChildMethod = getCanBeSomethingMethodWithInheritanceWithModelAccess(fqName, BehaviorConstants.CAN_BE_A_CHILD_METHOD_NAME, IOperationContext.class, CanBeAChildContext.class);\n      canBeAnAncestorMethod = getCanBeSomethingMethodWithInheritanceWithModelAccess(fqName, BehaviorConstants.CAN_BE_AN_ANCESTOR_METHOD_NAME, IOperationContext.class, CanBeAnAncestorContext.class);\n      canBeAParentMethod = getCanBeSomethingMethodWithInheritanceWithModelAccess(fqName, BehaviorConstants.CAN_BE_A_PARENT_METHOD_NAME, IOperationContext.class, CanBeAParentContext.class);\n      canBeARootMethod = getCanBeSomethingMethodWithInheritanceWithModelAccess(fqName, BehaviorConstants.CAN_BE_A_ROOT_METHOD_NAME, IOperationContext.class, CanBeARootContext.class);\n    }","commit_id":"9bbd99a2847f7e5bb4d62e183857384b5db4a4a3","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public boolean canBeAChild(IOperationContext operationContext, CanBeAChildContext _context, @Nullable CheckingNodeContext checkingNodeContext) {\n      boolean result = invokeCanBeASomethingMethod(canBeAChildMethod, operationContext, _context);\n\n      if (checkingNodeContext != null && !result) {\n        SNode constraints = getConceptConstraints(canBeAChildMethod);\n        if (constraints == null) {\n          throw new RuntimeException(\"Empty concept constraints\");\n        }\n        checkingNodeContext.breakingNodePointer = new SNodePointer(SConstraintsUtil.getConceptConstraints_CanBeChild(constraints));\n      }\n\n      return result;\n    }","id":60968,"modified_method":"@Override\n    public boolean canBeAChild(IOperationContext operationContext, CanBeAChildContext _context, @Nullable CheckingNodeContext checkingNodeContext) {\n      boolean result = invokeCanBeASomethingMethod(canBeAChildMethod, operationContext, _context);\n\n      if (checkingNodeContext != null && !result) {\n        checkingNodeContext.breakingNodePointer = getConceptConstraint(canBeAChildMethod, operationContext, \"canBeChild\");\n      }\n\n      return result;\n    }","commit_id":"9bbd99a2847f7e5bb4d62e183857384b5db4a4a3","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public boolean canBeARoot(IOperationContext operationContext, CanBeARootContext _context, @Nullable CheckingNodeContext checkingNodeContext) {\n      SNode concept = SModelUtil.findConceptDeclaration(fqName, operationContext.getScope());\n\n      if (!(SNodeUtil.isInstanceOfConceptDeclaration(concept) && SNodeUtil.getConceptDeclaration_IsRootable(concept))) {\n        if (checkingNodeContext != null) {\n          checkingNodeContext.breakingNodePointer = new SNodePointer(concept);\n        }\n\n        return false;\n      }\n\n      boolean result = invokeCanBeASomethingMethod(canBeARootMethod, operationContext, _context);\n      if (checkingNodeContext != null && !result) {\n        SNode constraints = getConceptConstraints(canBeARootMethod);\n        if (constraints == null) {\n          throw new RuntimeException(\"Empty concept constraints\");\n        }\n        checkingNodeContext.breakingNodePointer = new SNodePointer(SConstraintsUtil.getConceptConstraints_CanBeRoot(constraints));\n      }\n\n      return result;\n    }","id":60969,"modified_method":"@Override\n    public boolean canBeARoot(final IOperationContext operationContext, CanBeARootContext _context, @Nullable final CheckingNodeContext checkingNodeContext) {\n      if (!ModelAccess.instance().runReadAction(new Computable<Boolean>() {\n        @Override\n        public Boolean compute() {\n          SNode concept = SModelUtil.findConceptDeclaration(fqName, operationContext.getScope());\n          if (!(SNodeUtil.isInstanceOfConceptDeclaration(concept) && SNodeUtil.getConceptDeclaration_IsRootable(concept))) {\n            if (checkingNodeContext != null) {\n              checkingNodeContext.breakingNodePointer = new SNodePointer(concept);\n            }\n\n            return false;\n          } else {\n            return true;\n          }\n        }\n      })) {\n        return false;\n      }\n\n      boolean result = invokeCanBeASomethingMethod(canBeARootMethod, operationContext, _context);\n      if (checkingNodeContext != null && !result) {\n        checkingNodeContext.breakingNodePointer = getConceptConstraint(canBeARootMethod, operationContext, \"canBeRoot\");\n      }\n\n      return result;\n    }","commit_id":"9bbd99a2847f7e5bb4d62e183857384b5db4a4a3","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public boolean canBeAParent(IOperationContext operationContext, CanBeAParentContext _context, @Nullable CheckingNodeContext checkingNodeContext) {\n      boolean result = invokeCanBeASomethingMethod(canBeAParentMethod, operationContext, _context);\n\n      if (checkingNodeContext != null && !result) {\n        SNode constraints = getConceptConstraints(canBeAParentMethod);\n        if (constraints == null) {\n          throw new RuntimeException(\"Empty concept constraints\");\n        }\n        checkingNodeContext.breakingNodePointer = new SNodePointer(SConstraintsUtil.getConceptConstraints_CanBeParent(constraints));\n      }\n\n      return result;\n    }","id":60970,"modified_method":"@Override\n    public boolean canBeAParent(final IOperationContext operationContext, CanBeAParentContext _context, @Nullable final CheckingNodeContext checkingNodeContext) {\n      boolean result = invokeCanBeASomethingMethod(canBeAParentMethod, operationContext, _context);\n\n      if (checkingNodeContext != null && !result) {\n        checkingNodeContext.breakingNodePointer = getConceptConstraint(canBeAParentMethod, operationContext, \"canBeParent\");\n      }\n\n      return result;\n    }","commit_id":"9bbd99a2847f7e5bb4d62e183857384b5db4a4a3","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    protected Object resolveObject(Object obj) throws IOException {\n        if (obj instanceof TopLevelExceptionPlaceholder) {\n            return ((ExceptionPlaceholder) obj).read(getClassLoader());\n        }\n        return obj;\n    }","id":60971,"modified_method":"@Override\n    protected final Object resolveObject(Object obj) throws IOException {\n        return getObjectTransformer().transform(obj);\n    }","commit_id":"788199795387a29ba3de9dbf91dfa69a6bfda12d","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected Object replaceObject(Object obj) throws IOException {\n        if (obj instanceof Throwable) {\n            return new TopLevelExceptionPlaceholder((Throwable) obj);\n        }\n        return obj;\n    }","id":60972,"modified_method":"@Override\n    protected final Object replaceObject(Object obj) throws IOException {\n        return getObjectTransformer().transform(obj);\n    }","commit_id":"788199795387a29ba3de9dbf91dfa69a6bfda12d","url":"https://github.com/gradle/gradle"},{"original_method":"public SerializedPayload serialize(Object payload) {\n        final SerializeMap map = classLoaderRegistry.newSerializeSession();\n        try {\n            StreamByteBuffer buffer = new StreamByteBuffer();\n            final ObjectOutputStream objectStream = new ExceptionReplacingObjectOutputStream(buffer.getOutputStream()) {\n                @Override\n                protected void writeClassDescriptor(ObjectStreamClass desc) throws IOException {\n                    Class<?> targetClass = desc.forClass();\n                    writeClass(targetClass);\n                }\n\n                @Override\n                protected void annotateProxyClass(Class<?> cl) throws IOException {\n                    writeInt(cl.getInterfaces().length);\n                    for (Class<?> type : cl.getInterfaces()) {\n                        writeClass(type);\n                    }\n                }\n\n                private void writeClass(Class<?> targetClass) throws IOException {\n                    writeClassLoader(targetClass);\n                    writeUTF(targetClass.getName());\n                }\n\n                private void writeClassLoader(Class<?> targetClass) throws IOException {\n                    writeShort(map.visitClass(targetClass));\n                }\n            };\n\n            objectStream.writeObject(payload);\n            objectStream.close();\n\n            Map<Short, ClassLoaderDetails> classLoaders = new HashMap<Short, ClassLoaderDetails>();\n            map.collectClassLoaderDefinitions(classLoaders);\n            return new SerializedPayload(classLoaders, buffer.readAsListOfByteArrays());\n        } catch (IOException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n    }","id":60973,"modified_method":"public SerializedPayload serialize(Object payload) {\n        final SerializeMap map = classLoaderRegistry.newSerializeSession();\n        try {\n            StreamByteBuffer buffer = new StreamByteBuffer();\n            final ObjectOutputStream objectStream = new PayloadSerializerObjectOutputStream(buffer.getOutputStream(), map);\n\n            objectStream.writeObject(payload);\n            objectStream.close();\n\n            Map<Short, ClassLoaderDetails> classLoaders = new HashMap<Short, ClassLoaderDetails>();\n            map.collectClassLoaderDefinitions(classLoaders);\n            return new SerializedPayload(classLoaders, buffer.readAsListOfByteArrays());\n        } catch (IOException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n    }","commit_id":"788199795387a29ba3de9dbf91dfa69a6bfda12d","url":"https://github.com/gradle/gradle"},{"original_method":"public Object deserialize(SerializedPayload payload) {\n        final DeserializeMap map = classLoaderRegistry.newDeserializeSession();\n        try {\n            final Map<Short, ClassLoaderDetails> classLoaderDetails = (Map<Short, ClassLoaderDetails>) payload.getHeader();\n            StreamByteBuffer buffer = StreamByteBuffer.of(payload.getSerializedModel());\n            final ObjectInputStream objectStream = new ExceptionReplacingObjectInputStream(buffer.getInputStream(), getClass().getClassLoader()) {\n                @Override\n                protected ObjectStreamClass readClassDescriptor() throws IOException, ClassNotFoundException {\n                    Class<?> aClass = readClass();\n                    ObjectStreamClass descriptor = ObjectStreamClass.lookupAny(aClass);\n                    if (descriptor == null) {\n                        throw new ClassNotFoundException(aClass.getName());\n                    }\n                    return descriptor;\n                }\n\n                @Override\n                protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n                    return desc.forClass();\n                }\n\n                private Class<?> readClass() throws IOException, ClassNotFoundException {\n                    short id = readShort();\n                    String className = readUTF();\n                    ClassLoaderDetails classLoader = classLoaderDetails.get(id);\n                    return map.resolveClass(classLoader, className);\n                }\n\n                @Override\n                protected Class<?> resolveProxyClass(String[] interfaces) throws IOException, ClassNotFoundException {\n                    int count = readInt();\n                    Class<?>[] actualInterfaces = new Class<?>[count];\n                    for (int i = 0; i < count; i++) {\n                        actualInterfaces[i] = readClass();\n                    }\n                    return Proxy.getProxyClass(actualInterfaces[0].getClassLoader(), actualInterfaces);\n                }\n            };\n            return objectStream.readObject();\n        } catch (Exception e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n    }","id":60974,"modified_method":"public Object deserialize(SerializedPayload payload) {\n        final DeserializeMap map = classLoaderRegistry.newDeserializeSession();\n        try {\n            final Map<Short, ClassLoaderDetails> classLoaderDetails = (Map<Short, ClassLoaderDetails>) payload.getHeader();\n            StreamByteBuffer buffer = StreamByteBuffer.of(payload.getSerializedModel());\n            final ObjectInputStream objectStream = new PayloadSerializerObjectInputStream(buffer.getInputStream(), getClass().getClassLoader(), classLoaderDetails, map);\n            return objectStream.readObject();\n        } catch (Exception e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n    }","commit_id":"788199795387a29ba3de9dbf91dfa69a6bfda12d","url":"https://github.com/gradle/gradle"},{"original_method":"TopLevelExceptionPlaceholder(Throwable throwable) throws IOException {\n        super(throwable);\n    }","id":60975,"modified_method":"public TopLevelExceptionPlaceholder(Throwable throwable, Transformer<ExceptionReplacingObjectOutputStream, OutputStream> objectOutputStreamCreator) throws IOException {\n        super(throwable, objectOutputStreamCreator);\n    }","commit_id":"788199795387a29ba3de9dbf91dfa69a6bfda12d","url":"https://github.com/gradle/gradle"},{"original_method":"protected void setupWrappedStream() throws IOException {\n            // If we need to cache for retransmission, store data in a\n            // CacheAndWriteOutputStream. Otherwise write directly to the output stream.\n            if (cachingForRetransmission) {\n                cachedStream =\n                    new CacheAndWriteOutputStream(connection.getOutputStream());\n                wrappedStream = cachedStream;\n            } else {\n                wrappedStream = connection.getOutputStream();\n            }\n        }","id":60976,"modified_method":"protected void setupWrappedStream() throws IOException {\n            // If we need to cache for retransmission, store data in a\n            // CacheAndWriteOutputStream. Otherwise write directly to the output stream.\n            OutputStream cout = null;\n            try {\n                cout = connection.getOutputStream();\n            } catch (SocketException e) {\n                if (\"Socket Closed\".equals(e.getMessage())) {\n                    connection.connect();\n                    cout = connection.getOutputStream();\n                } else {\n                    throw e;\n                }\n            }\n            if (cachingForRetransmission) {\n                cachedStream =\n                    new CacheAndWriteOutputStream(cout);\n                wrappedStream = cachedStream;\n            } else {\n                wrappedStream = cout;\n            }\n        }","commit_id":"7967bd909343f31e8b4abf166d57108d74311d8a","url":"https://github.com/apache/cxf"},{"original_method":"public void write(int b) throws IOException {\n            delegate.write(b);\n            bytesWrittenCounter += 1;\n        }","id":60977,"modified_method":"public void write(int b) throws IOException {\n            super.write(b);\n            bytesWrittenCounter += 1;\n        }","commit_id":"c2f24f944d33e79cff65a342e62e695c45d9b2bb","url":"https://github.com/belaban/JGroups"},{"original_method":"public StreamingOutputStreamWrapper(Socket outputStreamOwner) throws IOException {\n            super();\n            this.outputStreamOwner = outputStreamOwner;\n            this.delegate = new BufferedOutputStream(outputStreamOwner.getOutputStream());\n        }","id":60978,"modified_method":"public StreamingOutputStreamWrapper(Socket outputStreamOwner) throws IOException {\n            super(outputStreamOwner.getOutputStream());\n            this.outputStreamOwner = outputStreamOwner;\n        }","commit_id":"c2f24f944d33e79cff65a342e62e695c45d9b2bb","url":"https://github.com/belaban/JGroups"},{"original_method":"public void process(Socket socket) {\n            StreamingOutputStreamWrapper wrapper = null;\n            ObjectInputStream ois = null;\n            try {\n                int bufferSize = socket.getSendBufferSize();\n                socket.setSendBufferSize(socket_buffer_size);\n                if (log.isDebugEnabled())\n                    log.debug(\"Running on \" + Thread.currentThread()\n                            + \". Accepted request for state transfer from \"\n                            + socket.getInetAddress() + \":\" + socket.getPort()\n                            + \", original buffer size was \" + bufferSize + \" and was reset to \"\n                            + socket.getSendBufferSize() + \", passing outputstream up... \");\n\n                ois = new ObjectInputStream(socket.getInputStream());\n                String state_id = (String) ois.readObject();\n                Address stateRequester = (Address) ois.readObject();\n                wrapper = new StreamingOutputStreamWrapper(socket);\n                StateTransferInfo sti = new StateTransferInfo(stateRequester, wrapper, state_id);\n                up_prot.up(new Event(Event.STATE_TRANSFER_OUTPUTSTREAM, sti));\n            } catch (IOException e) {\n                if (log.isWarnEnabled()) {\n                    log.warn(\"State writer socket thread spawned abnormaly\", e);\n                }\n            } catch (ClassNotFoundException e) {\n                // thrown by ois.readObject()\n                // should never happen since String/Address are core classes\n            } finally {\n                if (!socket.isConnected()) {\n                    if (log.isWarnEnabled())\n                        log.warn(\"Could not receive connection from state receiver. Closing socket...\");\n                }\n                Util.close(wrapper);\n                Util.close(socket);\n            }\n        }","id":60979,"modified_method":"public void process(Socket socket) {\n            OutputStream bos = null;\n            ObjectInputStream ois = null;\n            try {\n                int bufferSize = socket.getSendBufferSize();\n                socket.setSendBufferSize(socket_buffer_size);\n                if (log.isDebugEnabled())\n                    log.debug(\"Running on \" + Thread.currentThread()\n                            + \". Accepted request for state transfer from \"\n                            + socket.getInetAddress() + \":\" + socket.getPort()\n                            + \", original buffer size was \" + bufferSize + \" and was reset to \"\n                            + socket.getSendBufferSize() + \", passing outputstream up... \");\n\n                ois = new ObjectInputStream(socket.getInputStream());\n                String state_id = (String) ois.readObject();\n                Address stateRequester = (Address) ois.readObject();\n                bos = new BufferedOutputStream(new StreamingOutputStreamWrapper(socket),socket_buffer_size);\n                up_prot.up(new Event(Event.STATE_TRANSFER_OUTPUTSTREAM, new StateTransferInfo(stateRequester, bos, state_id)));\n            } catch (IOException e) {\n                if (log.isWarnEnabled()) {\n                    log.warn(\"State writer socket thread spawned abnormaly\", e);\n                }\n            } catch (ClassNotFoundException e) {\n                // thrown by ois.readObject()\n                // should never happen since String/Address are core classes\n            } finally {\n                if (!socket.isConnected()) {\n                    if (log.isWarnEnabled())\n                        log.warn(\"Could not receive connection from state receiver. Closing socket...\");\n                }\n                Util.close(bos);\n                Util.close(socket);\n            }\n        }","commit_id":"c2f24f944d33e79cff65a342e62e695c45d9b2bb","url":"https://github.com/belaban/JGroups"},{"original_method":"public void close() throws IOException {\n            if (closed.compareAndSet(false, true)) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"State reader is closing the socket \");\n                }\n                Util.close(delegate);\n                Util.close(inputStreamOwner);\n                up_prot.up(new Event(Event.STATE_TRANSFER_INPUTSTREAM_CLOSED));\n                down(new Event(Event.STATE_TRANSFER_INPUTSTREAM_CLOSED));\n            }\n        }","id":60980,"modified_method":"public void close() throws IOException {\n            if (closed.compareAndSet(false, true)) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"State reader is closing the socket \");\n                }\n                Util.close(inputStreamOwner);\n                up(new Event(Event.STATE_TRANSFER_INPUTSTREAM_CLOSED));\n                down(new Event(Event.STATE_TRANSFER_INPUTSTREAM_CLOSED));\n            }\n            super.close();\n        }","commit_id":"c2f24f944d33e79cff65a342e62e695c45d9b2bb","url":"https://github.com/belaban/JGroups"},{"original_method":"private void connectToStateProvider(StateHeader hdr) {\n        IpAddress address = hdr.bind_addr;\n        String tmp_state_id = hdr.getStateId();\n        StreamingInputStreamWrapper wrapper = null;\n        StateTransferInfo sti = null;\n        Socket socket = new Socket();\n        try {\n            socket.bind(new InetSocketAddress(bind_addr, 0));\n            int bufferSize = socket.getReceiveBufferSize();\n            socket.setReceiveBufferSize(socket_buffer_size);\n            if (log.isDebugEnabled())\n                log.debug(\"Connecting to state provider \" + address.getIpAddress() + \":\"\n                        + address.getPort() + \", original buffer size was \" + bufferSize\n                        + \" and was reset to \" + socket.getReceiveBufferSize());\n            socket.connect(new InetSocketAddress(address.getIpAddress(), address.getPort()));\n            if (log.isDebugEnabled())\n                log.debug(\"Connected to state provider, my end of the socket is \"\n                        + socket.getLocalAddress() + \":\" + socket.getLocalPort()\n                        + \" passing inputstream up...\");\n\n            // write out our state_id and address\n            ObjectOutputStream out = new ObjectOutputStream(socket.getOutputStream());\n            out.writeObject(tmp_state_id);\n            out.writeObject(local_addr);\n\n            wrapper = new StreamingInputStreamWrapper(socket);\n            sti = new StateTransferInfo(hdr.sender, wrapper, tmp_state_id);\n            up_prot.up(new Event(Event.STATE_TRANSFER_INPUTSTREAM, sti));\n        } catch (IOException e) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"State reader socket thread spawned abnormaly\", e);\n            }\n\n            // pass null stream up so that JChannel.getState() returns false\n            InputStream is = null;\n            sti = new StateTransferInfo(hdr.sender, is, tmp_state_id);\n            up_prot.up(new Event(Event.STATE_TRANSFER_INPUTSTREAM, sti));\n        } finally {\n            if (!socket.isConnected()) {\n                if (log.isWarnEnabled())\n                    log.warn(\"Could not connect to state provider. Closing socket...\");\n            }\n            Util.close(wrapper);\n            Util.close(socket);\n        }\n    }","id":60981,"modified_method":"private void connectToStateProvider(StateHeader hdr) {\n        IpAddress address = hdr.bind_addr;\n        String tmp_state_id = hdr.getStateId();\n        InputStream bis = null;\n        StateTransferInfo sti = null;\n        Socket socket = new Socket();\n        try {\n            socket.bind(new InetSocketAddress(bind_addr, 0));\n            int bufferSize = socket.getReceiveBufferSize();\n            socket.setReceiveBufferSize(socket_buffer_size);\n            if (log.isDebugEnabled())\n                log.debug(\"Connecting to state provider \" + address.getIpAddress() + \":\"\n                        + address.getPort() + \", original buffer size was \" + bufferSize\n                        + \" and was reset to \" + socket.getReceiveBufferSize());\n            socket.connect(new InetSocketAddress(address.getIpAddress(), address.getPort()));\n            if (log.isDebugEnabled())\n                log.debug(\"Connected to state provider, my end of the socket is \"\n                        + socket.getLocalAddress() + \":\" + socket.getLocalPort()\n                        + \" passing inputstream up...\");\n\n            // write out our state_id and address\n            ObjectOutputStream out = new ObjectOutputStream(socket.getOutputStream());\n            out.writeObject(tmp_state_id);\n            out.writeObject(local_addr);\n\n            bis = new BufferedInputStream(new StreamingInputStreamWrapper(socket));\n            sti = new StateTransferInfo(hdr.sender, bis, tmp_state_id);\n            up_prot.up(new Event(Event.STATE_TRANSFER_INPUTSTREAM, sti));\n        } catch (IOException e) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"State reader socket thread spawned abnormaly\", e);\n            }\n\n            // pass null stream up so that JChannel.getState() returns false\n            InputStream is = null;\n            sti = new StateTransferInfo(hdr.sender, is, tmp_state_id);\n            up_prot.up(new Event(Event.STATE_TRANSFER_INPUTSTREAM, sti));\n        } finally {\n            if (!socket.isConnected()) {\n                if (log.isWarnEnabled())\n                    log.warn(\"Could not connect to state provider. Closing socket...\");\n            }\n            Util.close(bis);\n            Util.close(socket);\n        }\n    }","commit_id":"c2f24f944d33e79cff65a342e62e695c45d9b2bb","url":"https://github.com/belaban/JGroups"},{"original_method":"public void write(byte[] b, int off, int len) throws IOException {\n            delegate.write(b, off, len);\n            bytesWrittenCounter += len;\n        }","id":60982,"modified_method":"public void write(byte[] b, int off, int len) throws IOException {\n            super.write(b, off, len);\n            bytesWrittenCounter += len;\n        }","commit_id":"c2f24f944d33e79cff65a342e62e695c45d9b2bb","url":"https://github.com/belaban/JGroups"},{"original_method":"public StreamingInputStreamWrapper(Socket inputStreamOwner) throws IOException {\n            super();\n            this.inputStreamOwner = inputStreamOwner;\n            this.delegate = new BufferedInputStream(inputStreamOwner.getInputStream());\n        }","id":60983,"modified_method":"public StreamingInputStreamWrapper(Socket inputStreamOwner) throws IOException {\n            super(inputStreamOwner.getInputStream());\n            this.inputStreamOwner = inputStreamOwner;\n        }","commit_id":"c2f24f944d33e79cff65a342e62e695c45d9b2bb","url":"https://github.com/belaban/JGroups"},{"original_method":"public void close() throws IOException {\n            if (closed.compareAndSet(false, true)) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"State writer is closing the socket \");\n                }\n\n                Util.close(delegate);\n                Util.close(outputStreamOwner);\n                up_prot.up(new Event(Event.STATE_TRANSFER_OUTPUTSTREAM_CLOSED));\n                down(new Event(Event.STATE_TRANSFER_OUTPUTSTREAM_CLOSED));\n\n                if (stats) {\n                    avg_state_size = num_bytes_sent.addAndGet(bytesWrittenCounter)\n                            / num_state_reqs.doubleValue();\n                }\n            }\n        }","id":60984,"modified_method":"public void close() throws IOException {\n            if (closed.compareAndSet(false, true)) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"State writer is closing the socket \");\n                }\n                Util.close(outputStreamOwner);\n                up(new Event(Event.STATE_TRANSFER_OUTPUTSTREAM_CLOSED));\n                down(new Event(Event.STATE_TRANSFER_OUTPUTSTREAM_CLOSED));\n\n                if (stats) {\n                    avg_state_size = num_bytes_sent.addAndGet(bytesWrittenCounter)\n                            / num_state_reqs.doubleValue();\n                }\n                super.close();\n            }\n        }","commit_id":"c2f24f944d33e79cff65a342e62e695c45d9b2bb","url":"https://github.com/belaban/JGroups"},{"original_method":"public void write(byte[] b) throws IOException {\n            delegate.write(b);\n            if (b != null) {\n                bytesWrittenCounter += b.length;\n            }\n        }","id":60985,"modified_method":"public void write(byte[] b) throws IOException {\n            super.write(b);\n            bytesWrittenCounter += b.length;            \n        }","commit_id":"c2f24f944d33e79cff65a342e62e695c45d9b2bb","url":"https://github.com/belaban/JGroups"},{"original_method":"public void write(int b) throws IOException {\n            delegate.write(b);\n            bytesWrittenCounter += 1;\n        }","id":60986,"modified_method":"public void write(int b) throws IOException {\n            super.write(b);\n            bytesWrittenCounter += 1;\n        }","commit_id":"daf77e52d4729e220530e4a5f316a687adef711a","url":"https://github.com/belaban/JGroups"},{"original_method":"public StreamingInputStreamWrapper(Socket inputStreamOwner) throws IOException {\n            super();\n            this.inputStreamOwner = inputStreamOwner;\n            this.delegate = new BufferedInputStream(inputStreamOwner.getInputStream());\n        }","id":60987,"modified_method":"public StreamingInputStreamWrapper(Socket inputStreamOwner) throws IOException {\n            super(inputStreamOwner.getInputStream());\n            this.inputStreamOwner = inputStreamOwner;\n        }","commit_id":"daf77e52d4729e220530e4a5f316a687adef711a","url":"https://github.com/belaban/JGroups"},{"original_method":"public void close() throws IOException {\n            if (closed.compareAndSet(false, true)) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"State writer is closing the socket \");\n                }\n\n                Util.close(delegate);\n                Util.close(outputStreamOwner);\n                up_prot.up(new Event(Event.STATE_TRANSFER_OUTPUTSTREAM_CLOSED));\n                down(new Event(Event.STATE_TRANSFER_OUTPUTSTREAM_CLOSED));\n\n                if (stats) {\n                    avg_state_size = num_bytes_sent.addAndGet(bytesWrittenCounter)\n                            / num_state_reqs.doubleValue();\n                }\n            }\n        }","id":60988,"modified_method":"public void close() throws IOException {\n            if (closed.compareAndSet(false, true)) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"State writer is closing the socket \");\n                }\n                Util.close(outputStreamOwner);\n                up(new Event(Event.STATE_TRANSFER_OUTPUTSTREAM_CLOSED));\n                down(new Event(Event.STATE_TRANSFER_OUTPUTSTREAM_CLOSED));\n\n                if (stats) {\n                    avg_state_size = num_bytes_sent.addAndGet(bytesWrittenCounter)\n                            / num_state_reqs.doubleValue();\n                }\n                super.close();\n            }\n        }","commit_id":"daf77e52d4729e220530e4a5f316a687adef711a","url":"https://github.com/belaban/JGroups"},{"original_method":"public void close() throws IOException {\n            if (closed.compareAndSet(false, true)) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"State reader is closing the socket \");\n                }\n                Util.close(delegate);\n                Util.close(inputStreamOwner);\n                up_prot.up(new Event(Event.STATE_TRANSFER_INPUTSTREAM_CLOSED));\n                down(new Event(Event.STATE_TRANSFER_INPUTSTREAM_CLOSED));\n            }\n        }","id":60989,"modified_method":"public void close() throws IOException {\n            if (closed.compareAndSet(false, true)) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"State reader is closing the socket \");\n                }\n                Util.close(inputStreamOwner);\n                up(new Event(Event.STATE_TRANSFER_INPUTSTREAM_CLOSED));\n                down(new Event(Event.STATE_TRANSFER_INPUTSTREAM_CLOSED));\n            }\n            super.close();\n        }","commit_id":"daf77e52d4729e220530e4a5f316a687adef711a","url":"https://github.com/belaban/JGroups"},{"original_method":"public void process(Socket socket) {\n            StreamingOutputStreamWrapper wrapper = null;\n            ObjectInputStream ois = null;\n            try {\n                int bufferSize = socket.getSendBufferSize();\n                socket.setSendBufferSize(socket_buffer_size);\n                if (log.isDebugEnabled())\n                    log.debug(\"Running on \" + Thread.currentThread()\n                            + \". Accepted request for state transfer from \"\n                            + socket.getInetAddress() + \":\" + socket.getPort()\n                            + \", original buffer size was \" + bufferSize + \" and was reset to \"\n                            + socket.getSendBufferSize() + \", passing outputstream up... \");\n\n                ois = new ObjectInputStream(socket.getInputStream());\n                String state_id = (String) ois.readObject();\n                Address stateRequester = (Address) ois.readObject();\n                wrapper = new StreamingOutputStreamWrapper(socket);\n                StateTransferInfo sti = new StateTransferInfo(stateRequester, wrapper, state_id);\n                up_prot.up(new Event(Event.STATE_TRANSFER_OUTPUTSTREAM, sti));\n            } catch (IOException e) {\n                if (log.isWarnEnabled()) {\n                    log.warn(\"State writer socket thread spawned abnormaly\", e);\n                }\n            } catch (ClassNotFoundException e) {\n                // thrown by ois.readObject()\n                // should never happen since String/Address are core classes\n            } finally {\n                if (!socket.isConnected()) {\n                    if (log.isWarnEnabled())\n                        log.warn(\"Could not receive connection from state receiver. Closing socket...\");\n                }\n                Util.close(wrapper);\n                Util.close(socket);\n            }\n        }","id":60990,"modified_method":"public void process(Socket socket) {\n            OutputStream bos = null;\n            ObjectInputStream ois = null;\n            try {\n                int bufferSize = socket.getSendBufferSize();\n                socket.setSendBufferSize(socket_buffer_size);\n                if (log.isDebugEnabled())\n                    log.debug(\"Running on \" + Thread.currentThread()\n                            + \". Accepted request for state transfer from \"\n                            + socket.getInetAddress() + \":\" + socket.getPort()\n                            + \", original buffer size was \" + bufferSize + \" and was reset to \"\n                            + socket.getSendBufferSize() + \", passing outputstream up... \");\n\n                ois = new ObjectInputStream(socket.getInputStream());\n                String state_id = (String) ois.readObject();\n                Address stateRequester = (Address) ois.readObject();\n                bos = new BufferedOutputStream(new StreamingOutputStreamWrapper(socket),socket_buffer_size);\n                up_prot.up(new Event(Event.STATE_TRANSFER_OUTPUTSTREAM, new StateTransferInfo(stateRequester, bos, state_id)));\n            } catch (IOException e) {\n                if (log.isWarnEnabled()) {\n                    log.warn(\"State writer socket thread spawned abnormaly\", e);\n                }\n            } catch (ClassNotFoundException e) {\n                // thrown by ois.readObject()\n                // should never happen since String/Address are core classes\n            } finally {\n                if (!socket.isConnected()) {\n                    if (log.isWarnEnabled())\n                        log.warn(\"Could not receive connection from state receiver. Closing socket...\");\n                }\n                Util.close(bos);\n                Util.close(socket);\n            }\n        }","commit_id":"daf77e52d4729e220530e4a5f316a687adef711a","url":"https://github.com/belaban/JGroups"},{"original_method":"public void write(byte[] b) throws IOException {\n            delegate.write(b);\n            if (b != null) {\n                bytesWrittenCounter += b.length;\n            }\n        }","id":60991,"modified_method":"public void write(byte[] b) throws IOException {\n            super.write(b);\n            bytesWrittenCounter += b.length;            \n        }","commit_id":"daf77e52d4729e220530e4a5f316a687adef711a","url":"https://github.com/belaban/JGroups"},{"original_method":"public void write(byte[] b, int off, int len) throws IOException {\n            delegate.write(b, off, len);\n            bytesWrittenCounter += len;\n        }","id":60992,"modified_method":"public void write(byte[] b, int off, int len) throws IOException {\n            super.write(b, off, len);\n            bytesWrittenCounter += len;\n        }","commit_id":"daf77e52d4729e220530e4a5f316a687adef711a","url":"https://github.com/belaban/JGroups"},{"original_method":"private void connectToStateProvider(StateHeader hdr) {\n        IpAddress address = hdr.bind_addr;\n        String tmp_state_id = hdr.getStateId();\n        StreamingInputStreamWrapper wrapper = null;\n        StateTransferInfo sti = null;\n        Socket socket = new Socket();\n        try {\n            socket.bind(new InetSocketAddress(bind_addr, 0));\n            int bufferSize = socket.getReceiveBufferSize();\n            socket.setReceiveBufferSize(socket_buffer_size);\n            if (log.isDebugEnabled())\n                log.debug(\"Connecting to state provider \" + address.getIpAddress() + \":\"\n                        + address.getPort() + \", original buffer size was \" + bufferSize\n                        + \" and was reset to \" + socket.getReceiveBufferSize());\n            socket.connect(new InetSocketAddress(address.getIpAddress(), address.getPort()));\n            if (log.isDebugEnabled())\n                log.debug(\"Connected to state provider, my end of the socket is \"\n                        + socket.getLocalAddress() + \":\" + socket.getLocalPort()\n                        + \" passing inputstream up...\");\n\n            // write out our state_id and address\n            ObjectOutputStream out = new ObjectOutputStream(socket.getOutputStream());\n            out.writeObject(tmp_state_id);\n            out.writeObject(local_addr);\n\n            wrapper = new StreamingInputStreamWrapper(socket);\n            sti = new StateTransferInfo(hdr.sender, wrapper, tmp_state_id);\n            up_prot.up(new Event(Event.STATE_TRANSFER_INPUTSTREAM, sti));\n        } catch (IOException e) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"State reader socket thread spawned abnormaly\", e);\n            }\n\n            // pass null stream up so that JChannel.getState() returns false\n            InputStream is = null;\n            sti = new StateTransferInfo(hdr.sender, is, tmp_state_id);\n            up_prot.up(new Event(Event.STATE_TRANSFER_INPUTSTREAM, sti));\n        } finally {\n            if (!socket.isConnected()) {\n                if (log.isWarnEnabled())\n                    log.warn(\"Could not connect to state provider. Closing socket...\");\n            }\n            Util.close(wrapper);\n            Util.close(socket);\n        }\n    }","id":60993,"modified_method":"private void connectToStateProvider(StateHeader hdr) {\n        IpAddress address = hdr.bind_addr;\n        String tmp_state_id = hdr.getStateId();\n        InputStream bis = null;\n        StateTransferInfo sti = null;\n        Socket socket = new Socket();\n        try {\n            socket.bind(new InetSocketAddress(bind_addr, 0));\n            int bufferSize = socket.getReceiveBufferSize();\n            socket.setReceiveBufferSize(socket_buffer_size);\n            if (log.isDebugEnabled())\n                log.debug(\"Connecting to state provider \" + address.getIpAddress() + \":\"\n                        + address.getPort() + \", original buffer size was \" + bufferSize\n                        + \" and was reset to \" + socket.getReceiveBufferSize());\n            socket.connect(new InetSocketAddress(address.getIpAddress(), address.getPort()));\n            if (log.isDebugEnabled())\n                log.debug(\"Connected to state provider, my end of the socket is \"\n                        + socket.getLocalAddress() + \":\" + socket.getLocalPort()\n                        + \" passing inputstream up...\");\n\n            // write out our state_id and address\n            ObjectOutputStream out = new ObjectOutputStream(socket.getOutputStream());\n            out.writeObject(tmp_state_id);\n            out.writeObject(local_addr);\n\n            bis = new BufferedInputStream(new StreamingInputStreamWrapper(socket));\n            sti = new StateTransferInfo(hdr.sender, bis, tmp_state_id);\n            up_prot.up(new Event(Event.STATE_TRANSFER_INPUTSTREAM, sti));\n        } catch (IOException e) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"State reader socket thread spawned abnormaly\", e);\n            }\n\n            // pass null stream up so that JChannel.getState() returns false\n            InputStream is = null;\n            sti = new StateTransferInfo(hdr.sender, is, tmp_state_id);\n            up_prot.up(new Event(Event.STATE_TRANSFER_INPUTSTREAM, sti));\n        } finally {\n            if (!socket.isConnected()) {\n                if (log.isWarnEnabled())\n                    log.warn(\"Could not connect to state provider. Closing socket...\");\n            }\n            Util.close(bis);\n            Util.close(socket);\n        }\n    }","commit_id":"daf77e52d4729e220530e4a5f316a687adef711a","url":"https://github.com/belaban/JGroups"},{"original_method":"public StreamingOutputStreamWrapper(Socket outputStreamOwner) throws IOException {\n            super();\n            this.outputStreamOwner = outputStreamOwner;\n            this.delegate = new BufferedOutputStream(outputStreamOwner.getOutputStream());\n        }","id":60994,"modified_method":"public StreamingOutputStreamWrapper(Socket outputStreamOwner) throws IOException {\n            super(outputStreamOwner.getOutputStream());\n            this.outputStreamOwner = outputStreamOwner;\n        }","commit_id":"daf77e52d4729e220530e4a5f316a687adef711a","url":"https://github.com/belaban/JGroups"},{"original_method":"@Override\n    public void visit(MethodDefinition that) {\n        super.visit(that);\n        // FIXME: we need to set those in the model loader as well\n        Method method = that.getDeclarationModel();\n        Method refinedMethod = (Method) Util.getTopmostRefinedDeclaration(method);\n        if(isPrimitive(method, refinedMethod))\n            Util.markUnBoxed(method);\n        Iterator<Parameter> parameters = method.getParameterLists().get(0).getParameters().iterator();\n        for(Parameter refinedParam : refinedMethod.getParameterLists().get(0).getParameters()){\n            Parameter param = parameters.next();\n            if(isPrimitive(param, refinedParam))\n                Util.markUnBoxed(param);\n        }\n    }","id":60995,"modified_method":"@Override\n    public void visit(MethodDefinition that) {\n        super.visit(that);\n        // FIXME: we need to set those in the model loader as well\n        Method method = that.getDeclarationModel();\n        Method refinedMethod = (Method) Util.getTopmostRefinedDeclaration(method);\n        if(isPrimitive(method, refinedMethod))\n            Util.markUnBoxed(method);\n        Iterator<Parameter> parameters = method.getParameterLists().get(0).getParameters().iterator();\n        for(Parameter refinedParam : refinedMethod.getParameterLists().get(0).getParameters()){\n            Parameter param = parameters.next();\n            if(isPrimitive(param, refinedParam)) {\n                Util.markUnBoxed(param);\n                Util.markUnBoxed(refinedParam);\n            }\n        }\n    }","commit_id":"47d69aad6cecb79019e41caf414f66e72b6a0318","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public void visit(AnyAttribute that) {\n        super.visit(that);\n        TypedDeclaration declaration = that.getDeclarationModel();\n        TypedDeclaration refinedDeclaration = Util.getTopmostRefinedDeclaration(declaration);\n        if(isPrimitive(declaration, refinedDeclaration))\n            Util.markUnBoxed(declaration);\n    }","id":60996,"modified_method":"@Override\n    public void visit(AnyAttribute that) {\n        super.visit(that);\n        TypedDeclaration declaration = that.getDeclarationModel();\n        TypedDeclaration refinedDeclaration = Util.getTopmostRefinedDeclaration(declaration);\n        if(isPrimitive(declaration, refinedDeclaration)) {\n            Util.markUnBoxed(declaration);\n            Util.markUnBoxed(refinedDeclaration);\n        }\n    }","commit_id":"47d69aad6cecb79019e41caf414f66e72b6a0318","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public void visit(MethodDefinition that) {\n        super.visit(that);\n        // FIXME: we need to set those in the model loader as well\n        Method method = that.getDeclarationModel();\n        Method refinedMethod = (Method) Util.getTopmostRefinedDeclaration(method);\n        if(isPrimitive(method, refinedMethod))\n            Util.markUnBoxed(method);\n        Iterator<Parameter> parameters = method.getParameterLists().get(0).getParameters().iterator();\n        for(Parameter refinedParam : refinedMethod.getParameterLists().get(0).getParameters()){\n            Parameter param = parameters.next();\n            if(isPrimitive(param, refinedParam)) {\n                Util.markUnBoxed(param);\n                Util.markUnBoxed(refinedParam);\n            }\n        }\n    }","id":60997,"modified_method":"@Override\n    public void visit(MethodDefinition that) {\n        super.visit(that);\n        // FIXME: we need to set those in the model loader as well\n        Method method = that.getDeclarationModel();\n        Method refinedMethod = (Method) Util.getTopmostRefinedDeclaration(method);\n        if(isPrimitive(method, refinedMethod)) {\n            Util.markUnBoxed(method);\n            Util.markUnBoxed(refinedMethod);\n        }\n        Iterator<Parameter> parameters = method.getParameterLists().get(0).getParameters().iterator();\n        for(Parameter refinedParam : refinedMethod.getParameterLists().get(0).getParameters()){\n            Parameter param = parameters.next();\n            if(isPrimitive(param, refinedParam)) {\n                Util.markUnBoxed(param);\n                Util.markUnBoxed(refinedParam);\n            }\n        }\n    }","commit_id":"1649dc77eb128d9477739e28b7997ac5666fc16c","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public String getLineMarked(Set queryHashes) {\n            if (line == null) return \"\";\n            if ((queryHashes == null) || (queryHashes.size() == 0)) return line.trim();\n            if (line.endsWith(\".\")) line = line.substring(0, line.length() - 1);\n            Iterator i = queryHashes.iterator();\n            String h;\n            String[] w = line.split(\" \");\n            String mark = \"\";\n            while (i.hasNext()) {\n                h = (String) i.next();\n                for (int j = 0; j < w.length; j++) {\n                    //ignore punctuation marks (contrib [MN])\n                    if ((w[j].endsWith(\".\"))||\n                        (w[j].endsWith(\",\"))||\n                        (w[j].endsWith(\"!\"))||\n                        (w[j].endsWith(\"?\"))) {\n                        mark = w[j].substring(w[j].length()-1);\n                        w[j] = w[j].substring(0,w[j].length()-1);\n                    }\n                    else {\n                        mark = \"\";\n                    }\n                    //end contrib [MN]\n                    if (indexEntryAttribute.word2hash(w[j]).equals(h)) w[j] = \"<b>\" + w[j] + \"<\/b>\";\n                    w[j] = w[j] + mark;\n                }\n            }\n            StringBuffer l = new StringBuffer(line.length() + queryHashes.size() * 8);\n            for (int j = 0; j < w.length; j++) {\n                l.append(w[j]);\n                l.append(' ');\n            }\n            return l.toString().trim();\n        }","id":60998,"modified_method":"public String getLineMarked(Set queryHashes) {\n            if (line == null) return \"\";\n            if ((queryHashes == null) || (queryHashes.size() == 0)) return line.trim();\n            if (line.endsWith(\".\")) line = line.substring(0, line.length() - 1);\n            Iterator i = queryHashes.iterator();\n            String h;\n            String[] w = line.split(\" \");\n            String prefix = \"\";\n            String postfix = \"\";\n            int len = 0;\n            while (i.hasNext()) {\n                h = (String) i.next();\n                for (int j = 0; j < w.length; j++) {\n                    //ignore punctuation marks (contrib [MN])\n                    //note to myself:\n                    //For details on regex see \"Mastering regular expressions\" by J.E.F. Friedl\n                    //especially p. 123 and p. 390/391 (in the German version of the 2nd edition)\n\n                    prefix = \"\";\n                    postfix = \"\";\n\n                    while((w[j].matches(\"\\\\A\\\\PL.+\"))) {\n                        prefix = w[j].substring(0,1) + prefix;\n                        w[j] = w[j].substring(1);\n                    }\n\n                    while((w[j].matches(\".+\\\\PL\\\\Z\"))) {\n                        len = w[j].length();\n                        postfix = w[j].substring(len-1,len) + postfix;\n                        w[j] = w[j].substring(0,len-1);\n                    }\n\n                    //end contrib [MN]\n                    if (indexEntryAttribute.word2hash(w[j]).equals(h)) w[j] = \"<b>\" + w[j] + \"<\/b>\";\n                    w[j] = prefix + w[j] + postfix;\n                }\n            }\n            StringBuffer l = new StringBuffer(line.length() + queryHashes.size() * 8);\n            for (int j = 0; j < w.length; j++) {\n                l.append(w[j]);\n                l.append(' ');\n            }\n            return l.toString().trim();\n        }","commit_id":"2d3b7251a462681432872913d4afb0b00b711b9f","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n   * Performs the doc-available function.\n   * @param ctx query context\n   * @return result\n   * @throws QueryException query exception\n   */\n  private Bln docAvailable(final QueryContext ctx) throws QueryException {\n    try {\n      return Bln.get(doc(ctx) != null);\n    } catch(final QueryException ex) {\n      final Err err = ex.err();\n      if(err != null) {\n        if(err.is(ErrType.FODC) && (err.code.endsWith(\"0002\") || err.code.endsWith(\"0004\")) ||\n           err.is(ErrType.BXDB) && err.code.endsWith(\"0006\")) return Bln.FALSE;\n      }\n      throw ex;\n    }\n  }","id":60999,"modified_method":"/**\n   * Performs the doc-available function.\n   * @param ctx query context\n   * @return result\n   * @throws QueryException query exception\n   */\n  private Bln docAvailable(final QueryContext ctx) throws QueryException {\n    try {\n      return Bln.get(doc(ctx) != null);\n    } catch(final QueryException ex) {\n      final Err err = ex.err();\n      if(err != null) {\n        final String num = err.code.length() == 8 ? err.code.substring(4) : \"\";\n        if(err.is(ErrType.FODC) && (num.equals(\"0002\") || num.equals(\"0004\")) ||\n           err.is(ErrType.BXDB) && num.equals(\"0006\")) return Bln.FALSE;\n      }\n      throw ex;\n    }\n  }","commit_id":"06f25f83f60da4d2a2dce93c7352f6e2dfa2c5f2","url":"https://github.com/BaseXdb/basex"}]