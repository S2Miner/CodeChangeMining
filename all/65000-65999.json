[{"original_method":"protected void doClassTest(String path) {\n        myFixture.configureByFile(path);\n        assertGotoSymbol(new GotoClassModel2(getProject()), getProject(), myFixture.getEditor());\n    }","id":65000,"modified_method":"protected void doClassTest(String path) {\n        myFixture.configureByFile(path);\n        assertGotoSymbol(new GotoClassModel2(getProject()), myFixture.getEditor());\n    }","commit_id":"1168cf62bfa4798b6c20d13b251922c8ab1f9147","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static void assertGotoSymbol(FilteringGotoByModel<Language> model, @NotNull Project project, @NotNull Editor editor) {\n        List<String> searchTextList = InTextDirectivesUtils.findListWithPrefixes(editor.getDocument().getText(), \"// SEARCH_TEXT:\");\n        Assert.assertFalse(\"There's no search text in test data file given. Use '// SEARCH_TEXT:' directive\",\n                           searchTextList.isEmpty());\n\n        List<String> expectedReferences = InTextDirectivesUtils.findListWithPrefixes(editor.getDocument().getText(), \"// REF:\");\n        boolean enableCheckbox = InTextDirectivesUtils.isDirectiveDefined(editor.getDocument().getText(), \"// CHECK_BOX\");\n\n        String searchText = searchTextList.get(0);\n\n        List<Object> elementsByName = new ArrayList<Object>();\n\n        String[] names = model.getNames(enableCheckbox);\n        for (String name : names) {\n            if (name != null && name.startsWith(searchText)) {\n                elementsByName.addAll(Arrays.asList(model.getElementsByName(name, enableCheckbox, name + \"*\")));\n            }\n        }\n\n        List<String> renderedElements = Lists.transform(elementsByName, new Function<Object, String>() {\n            @Override\n            public String apply(@Nullable Object element) {\n                Assert.assertNotNull(element);\n                Assert.assertTrue(element instanceof PsiElement);\n                return ReferenceUtils.renderAsGotoImplementation((PsiElement) element);\n            }\n        });\n\n        UsefulTestCase.assertOrderedEquals(Ordering.natural().sortedCopy(renderedElements), expectedReferences);\n    }","id":65001,"modified_method":"private static void assertGotoSymbol(@NotNull FilteringGotoByModel<Language> model, @NotNull Editor editor) {\n        String documentText = editor.getDocument().getText();\n        List<String> searchTextList = InTextDirectivesUtils.findListWithPrefixes(documentText, \"// SEARCH_TEXT:\");\n        Assert.assertFalse(\"There's no search text in test data file given. Use '// SEARCH_TEXT:' directive\",\n                           searchTextList.isEmpty());\n\n        List<String> expectedReferences = KotlinPackage.map(\n                InTextDirectivesUtils.findLinesWithPrefixesRemoved(documentText, \"// REF:\"),\n                new Function1<String, String>() {\n                    @Override\n                    public String invoke(String input) {\n                        return input.trim();\n                    }\n                }\n        );\n        boolean enableCheckbox = InTextDirectivesUtils.isDirectiveDefined(documentText, \"// CHECK_BOX\");\n\n        String searchText = searchTextList.get(0);\n\n        List<Object> elementsByName = new ArrayList<Object>();\n\n        String[] names = model.getNames(enableCheckbox);\n        for (String name : names) {\n            if (name != null && name.startsWith(searchText)) {\n                elementsByName.addAll(Arrays.asList(model.getElementsByName(name, enableCheckbox, name + \"*\")));\n            }\n        }\n\n        List<String> renderedElements = Lists.transform(elementsByName, new Function<Object, String>() {\n            @Override\n            public String apply(@Nullable Object element) {\n                Assert.assertNotNull(element);\n                Assert.assertTrue(element instanceof PsiElement);\n                return ReferenceUtils.renderAsGotoImplementation((PsiElement) element);\n            }\n        });\n\n        UsefulTestCase.assertOrderedEquals(Ordering.natural().sortedCopy(renderedElements), expectedReferences);\n    }","commit_id":"1168cf62bfa4798b6c20d13b251922c8ab1f9147","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public NavigationItem[] getItemsByName(String name, String pattern, Project project, boolean includeNonProjectItems) {\n        GlobalSearchScope scope = includeNonProjectItems ? GlobalSearchScope.allScope(project) : GlobalSearchScope.projectScope(project);\n\n        Collection<? extends NavigationItem> functions = StubIndex.getInstance().get(\n                JetFunctionShortNameIndex.getInstance().getKey(), name, project, scope);\n\n        Collection<? extends NavigationItem> properties = StubIndex.getInstance().get(\n                JetPropertyShortNameIndex.getInstance().getKey(), name, project, scope);\n\n        List<NavigationItem> items = new ArrayList<NavigationItem>(Collections2.filter(functions, Predicates.notNull()));\n        items.addAll(properties);\n\n        return ArrayUtil.toObjectArray(items, NavigationItem.class);\n    }","id":65002,"modified_method":"@NotNull\n    @Override\n    public NavigationItem[] getItemsByName(String name, String pattern, Project project, boolean includeNonProjectItems) {\n        GlobalSearchScope scope = includeNonProjectItems ? GlobalSearchScope.allScope(project) : GlobalSearchScope.projectScope(project);\n\n        Collection<? extends NavigationItem> functions = JetFunctionShortNameIndex.getInstance().get(name, project, scope);\n        Collection<? extends NavigationItem> properties = JetPropertyShortNameIndex.getInstance().get(name, project, scope);\n\n        List<NavigationItem> items = new ArrayList<NavigationItem>(Collections2.filter(functions, Predicates.notNull()));\n        items.addAll(properties);\n\n        return ArrayUtil.toObjectArray(items, NavigationItem.class);\n    }","commit_id":"1168cf62bfa4798b6c20d13b251922c8ab1f9147","url":"https://github.com/JetBrains/kotlin"},{"original_method":"protected LightProjectDescriptor getProjectDescriptorFromFileDirective() {\n        if (!isAllFilesPresentInTest()) {\n            try {\n                String fileText = FileUtil.loadFile(new File(getTestDataPath(), fileName()), true);\n\n                List<String> withLibraryDirective = InTextDirectivesUtils.findLinesWithPrefixesRemoved(fileText, \"WITH_LIBRARY:\");\n                if (!withLibraryDirective.isEmpty()) {\n                    return new JdkAndMockLibraryProjectDescriptor(PluginTestCaseBase.getTestDataPathBase() + \"/\" + withLibraryDirective.get(0), true);\n                }\n                else if (InTextDirectivesUtils.isDirectiveDefined(fileText, \"RUNTIME\")) {\n                    return JetWithJdkAndRuntimeLightProjectDescriptor.INSTANCE;\n                }\n                else if (InTextDirectivesUtils.isDirectiveDefined(fileText, \"JS\")) {\n                    return JetStdJSProjectDescriptor.INSTANCE;\n                }\n            }\n            catch (IOException e) {\n                throw UtilsPackage.rethrow(e);\n            }\n        }\n\n        return JetLightProjectDescriptor.INSTANCE;\n    }","id":65003,"modified_method":"protected LightProjectDescriptor getProjectDescriptorFromFileDirective() {\n        if (!isAllFilesPresentInTest()) {\n            try {\n                String fileText = FileUtil.loadFile(new File(getTestDataPath(), fileName()), true);\n\n                List<String> withLibraryDirective = InTextDirectivesUtils.findLinesWithPrefixesRemoved(fileText, \"WITH_LIBRARY:\");\n                if (!withLibraryDirective.isEmpty()) {\n                    return new JdkAndMockLibraryProjectDescriptor(PluginTestCaseBase.getTestDataPathBase() + \"/\" + withLibraryDirective.get(0), true);\n                }\n                else if (InTextDirectivesUtils.isDirectiveDefined(fileText, \"RUNTIME\")) {\n                    return JetWithJdkAndRuntimeLightProjectDescriptor.INSTANCE;\n                }\n                else if (InTextDirectivesUtils.isDirectiveDefined(fileText, \"RUNTIME_WITH_SOURCES\")) {\n                    return ProjectDescriptorWithStdlibSources.INSTANCE;\n                }\n                else if (InTextDirectivesUtils.isDirectiveDefined(fileText, \"JS\")) {\n                    return JetStdJSProjectDescriptor.INSTANCE;\n                }\n            }\n            catch (IOException e) {\n                throw UtilsPackage.rethrow(e);\n            }\n        }\n\n        return JetLightProjectDescriptor.INSTANCE;\n    }","commit_id":"1168cf62bfa4798b6c20d13b251922c8ab1f9147","url":"https://github.com/JetBrains/kotlin"},{"original_method":"protected <T extends PsiElement> void doTest(@NotNull String path) throws Exception {\n        File mainFile = new File(path);\n        final String mainFileName = mainFile.getName();\n        String mainFileText = FileUtil.loadFile(mainFile, true);\n        final String prefix = mainFileName.substring(0, mainFileName.indexOf('.') + 1);\n\n        List<String> caretElementClassNames = InTextDirectivesUtils.findLinesWithPrefixesRemoved(mainFileText, \"// PSI_ELEMENT: \");\n        assert caretElementClassNames.size() == 1;\n        //noinspection unchecked\n\n        Class<T> caretElementClass = (Class<T>)Class.forName(caretElementClassNames.get(0));\n\n        OptionsParser parser = OptionsParser.getParserByPsiElementClass(caretElementClass);\n\n        String rootPath = path.substring(0, path.lastIndexOf(\"/\") + 1);\n\n        File rootDir = new File(rootPath);\n        File[] extraFiles = rootDir.listFiles(\n                new FilenameFilter() {\n                    @Override\n                    public boolean accept(@NotNull File dir, @NotNull String name) {\n                        if (!name.startsWith(prefix) || name.equals(mainFileName)) return false;\n\n                        String ext = FileUtilRt.getExtension(name);\n                        return ext.equals(\"kt\")\n                               || ext.equals(\"java\")\n                               || ext.equals(\"xml\")\n                               || (ext.equals(\"txt\") && !name.endsWith(\".results.txt\"));\n                    }\n                }\n        );\n\n        assert extraFiles != null;\n        for (File file : extraFiles) {\n            myFixture.configureByFile(rootPath + file.getName());\n        }\n        myFixture.configureByFile(path);\n\n        PsiElement originalElement =\n                InTextDirectivesUtils.isDirectiveDefined(mainFileText, \"// FIND_BY_REF\")\n                ? TargetElementUtilBase.findTargetElement(myFixture.getEditor(),\n                                                          TargetElementUtilBase.REFERENCED_ELEMENT_ACCEPTED | TargetElementUtil.NEW_AS_CONSTRUCTOR)\n                : myFixture.getElementAtCaret();\n        if (InTextDirectivesUtils.isDirectiveDefined(mainFileText, \"// FIND_BY_MIRROR_ELEMENT\")) {\n            assert originalElement instanceof PsiCompiledElement : \"PsiCompiledElement is expected: \" + originalElement;\n            originalElement = ((PsiCompiledElement)originalElement).getMirror();\n        }\n        T caretElement = PsiTreeUtil.getParentOfType(originalElement, caretElementClass, false);\n        assertNotNull(String.format(\"Element with type '%s' wasn't found at caret position\", caretElementClass), caretElement);\n\n        FindUsagesOptions options = parser != null ? parser.parse(mainFileText, getProject()) : null;\n        Collection<UsageInfo> usageInfos = findUsages(caretElement, options);\n\n        Collection<UsageFilteringRule> filteringRules = instantiateClasses(mainFileText, \"// FILTERING_RULES: \");\n        final Collection<UsageGroupingRule> groupingRules = instantiateClasses(mainFileText, \"// GROUPING_RULES: \");\n\n        Collection<UsageInfo2UsageAdapter> filteredUsages = getUsageAdapters(filteringRules, usageInfos);\n\n        Function<UsageInfo2UsageAdapter, String> convertToString = new Function<UsageInfo2UsageAdapter, String>() {\n            @Override\n            public String apply(@Nullable final UsageInfo2UsageAdapter usageAdapter) {\n                assert usageAdapter != null;\n\n                String groupAsString = Joiner.on(\", \").join(\n                        KotlinPackage.map(\n                                groupingRules,\n                                new Function1<UsageGroupingRule, String>() {\n                                    @Override\n                                    public String invoke(UsageGroupingRule rule) {\n                                        UsageGroup group = rule.groupUsage(usageAdapter);\n                                        return group != null ? group.getText(null) : \"\";\n                                    }\n                                }\n                        )\n                );\n                if (!groupAsString.isEmpty()) {\n                    groupAsString = \"(\" + groupAsString + \") \";\n                }\n\n                UsageType usageType = getUsageType(usageAdapter.getElement());\n                String usageTypeAsString = usageType == null ? \"null\" : usageType.toString(USAGE_VIEW_PRESENTATION);\n\n                return usageTypeAsString + \" \" +\n                       groupAsString +\n                       Joiner.on(\"\").join(Arrays.asList(usageAdapter.getPresentation().getText()));\n            }\n        };\n\n        Collection<String> finalUsages = Ordering.natural().sortedCopy(Collections2.transform(filteredUsages, convertToString));\n        JetTestUtils.assertEqualsToFile(new File(rootPath, prefix + \"results.txt\"), StringUtil.join(finalUsages, \"\\n\"));\n    }","id":65004,"modified_method":"protected <T extends PsiElement> void doTest(@NotNull String path) throws Exception {\n        File mainFile = new File(path);\n        final String mainFileName = mainFile.getName();\n        String mainFileText = FileUtil.loadFile(mainFile, true);\n        final String prefix = mainFileName.substring(0, mainFileName.indexOf('.') + 1);\n\n        List<String> caretElementClassNames = InTextDirectivesUtils.findLinesWithPrefixesRemoved(mainFileText, \"// PSI_ELEMENT: \");\n        assert caretElementClassNames.size() == 1;\n        //noinspection unchecked\n\n        Class<T> caretElementClass = (Class<T>)Class.forName(caretElementClassNames.get(0));\n\n        OptionsParser parser = OptionsParser.getParserByPsiElementClass(caretElementClass);\n\n        String rootPath = path.substring(0, path.lastIndexOf(\"/\") + 1);\n\n        File rootDir = new File(rootPath);\n        File[] extraFiles = rootDir.listFiles(\n                new FilenameFilter() {\n                    @Override\n                    public boolean accept(@NotNull File dir, @NotNull String name) {\n                        if (!name.startsWith(prefix) || name.equals(mainFileName)) return false;\n\n                        String ext = FileUtilRt.getExtension(name);\n                        return ext.equals(\"kt\")\n                               || ext.equals(\"java\")\n                               || ext.equals(\"xml\")\n                               || (ext.equals(\"txt\") && !name.endsWith(\".results.txt\"));\n                    }\n                }\n        );\n\n        assert extraFiles != null;\n        for (File file : extraFiles) {\n            myFixture.configureByFile(rootPath + file.getName());\n        }\n        myFixture.configureByFile(path);\n\n        PsiElement originalElement =\n                InTextDirectivesUtils.isDirectiveDefined(mainFileText, \"// FIND_BY_REF\")\n                ? TargetElementUtilBase.findTargetElement(myFixture.getEditor(),\n                                                          TargetElementUtilBase.REFERENCED_ELEMENT_ACCEPTED | TargetElementUtil.NEW_AS_CONSTRUCTOR)\n                : myFixture.getElementAtCaret();\n        boolean findByMirrorElement = InTextDirectivesUtils.isDirectiveDefined(mainFileText, \"// FIND_BY_MIRROR_ELEMENT\");\n        boolean findByNavigationElement = InTextDirectivesUtils.isDirectiveDefined(mainFileText, \"// FIND_BY_NAVIGATION_ELEMENT\");\n        if (findByMirrorElement && findByNavigationElement) {\n            fail(\"Incompatible directives\");\n        }\n\n        if (findByMirrorElement) {\n            assert originalElement instanceof PsiCompiledElement : \"PsiCompiledElement is expected: \" + originalElement;\n            originalElement = ((PsiCompiledElement)originalElement).getMirror();\n        }\n\n        if (findByNavigationElement) {\n            assert originalElement != null : \"Original element is not found\";\n            originalElement = originalElement.getNavigationElement();\n        }\n\n        T caretElement = PsiTreeUtil.getParentOfType(originalElement, caretElementClass, false);\n        assertNotNull(String.format(\"Element with type '%s' wasn't found at caret position\", caretElementClass), caretElement);\n\n        FindUsagesOptions options = parser != null ? parser.parse(mainFileText, getProject()) : null;\n        Collection<UsageInfo> usageInfos = findUsages(caretElement, options);\n\n        Collection<UsageFilteringRule> filteringRules = instantiateClasses(mainFileText, \"// FILTERING_RULES: \");\n        final Collection<UsageGroupingRule> groupingRules = instantiateClasses(mainFileText, \"// GROUPING_RULES: \");\n\n        Collection<UsageInfo2UsageAdapter> filteredUsages = getUsageAdapters(filteringRules, usageInfos);\n\n        Function<UsageInfo2UsageAdapter, String> convertToString = new Function<UsageInfo2UsageAdapter, String>() {\n            @Override\n            public String apply(@Nullable final UsageInfo2UsageAdapter usageAdapter) {\n                assert usageAdapter != null;\n\n                String groupAsString = Joiner.on(\", \").join(\n                        KotlinPackage.map(\n                                groupingRules,\n                                new Function1<UsageGroupingRule, String>() {\n                                    @Override\n                                    public String invoke(UsageGroupingRule rule) {\n                                        UsageGroup group = rule.groupUsage(usageAdapter);\n                                        return group != null ? group.getText(null) : \"\";\n                                    }\n                                }\n                        )\n                );\n                if (!groupAsString.isEmpty()) {\n                    groupAsString = \"(\" + groupAsString + \") \";\n                }\n\n                UsageType usageType = getUsageType(usageAdapter.getElement());\n                String usageTypeAsString = usageType == null ? \"null\" : usageType.toString(USAGE_VIEW_PRESENTATION);\n\n                return usageTypeAsString + \" \" +\n                       groupAsString +\n                       Joiner.on(\"\").join(Arrays.asList(usageAdapter.getPresentation().getText()));\n            }\n        };\n\n        Collection<String> finalUsages = Ordering.natural().sortedCopy(Collections2.transform(filteredUsages, convertToString));\n        JetTestUtils.assertEqualsToFile(new File(rootPath, prefix + \"results.txt\"), StringUtil.join(finalUsages, \"\\n\"));\n    }","commit_id":"b2201026d1cb386de8977f825c646a883f3a05f4","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n     * Get the path of the site descriptor for a given locale.\n     *\n     * @param locale the locale\n     * @return the site descriptor path\n     */\n    protected File getSiteDescriptorFile( Locale locale )\n    {\n        File siteDescriptor = new File( siteDirectory, \"site_\" + locale.getLanguage() + \".xml\" );\n\n        if ( !siteDescriptor.exists() )\n        {\n            siteDescriptor = new File( siteDirectory, \"site.xml\" );\n        }\n        return siteDescriptor;\n    }","id":65005,"modified_method":"/**\n     * Get the path of the site descriptor for a given locale.\n     *\n     * @param locale the locale\n     * @return the site descriptor path\n     */\n    protected File getSiteDescriptorFile( File basedir, Locale locale )\n    {\n        // TODO: get proper siteDirectory\n\n        File siteDescriptor = new File( basedir, \"src/site/site_\" + locale.getLanguage() + \".xml\" );\n\n        if ( !siteDescriptor.exists() )\n        {\n            siteDescriptor = new File( basedir, \"src/site/site.xml\" );\n        }\n        return siteDescriptor;\n    }","commit_id":"6a7c2fdf0760f12471b377792ce18e554d21b46e","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void execute()\n        throws MojoExecutionException\n    {\n        List localesList = initLocalesList();\n\n        for ( Iterator iterator = localesList.iterator(); iterator.hasNext(); )\n        {\n            Locale locale = (Locale) iterator.next();\n\n            File descriptorFile = getSiteDescriptorFile( locale );\n\n            if ( descriptorFile.exists() )\n            {\n                artifact.addMetadata( new SiteDescriptorArtifactMetadata( artifact, descriptorFile ) );\n            }\n        }\n    }","id":65006,"modified_method":"public void execute()\n        throws MojoExecutionException\n    {\n        List localesList = initLocalesList();\n\n        for ( Iterator iterator = localesList.iterator(); iterator.hasNext(); )\n        {\n            Locale locale = (Locale) iterator.next();\n\n            File descriptorFile = getSiteDescriptorFile( basedir, locale );\n\n            if ( descriptorFile.exists() )\n            {\n                artifact.addMetadata( new SiteDescriptorArtifactMetadata( artifact, descriptorFile ) );\n            }\n        }\n    }","commit_id":"6a7c2fdf0760f12471b377792ce18e554d21b46e","url":"https://github.com/apache/maven-plugins"},{"original_method":"private File getOutputDirectory( Locale locale, Locale defaultLocale )\n    {\n        if ( locale.getLanguage().equals( defaultLocale.getLanguage() ) )\n        {\n            return outputDirectory;\n        }\n\n        return new File( outputDirectory, locale.getLanguage() );\n    }","id":65007,"modified_method":"private File getOutputDirectory( Locale locale, Locale defaultLocale )\n    {\n        File file;\n        if ( locale.getLanguage().equals( defaultLocale.getLanguage() ) )\n        {\n            file = outputDirectory;\n        }\n        else\n        {\n            file = new File( outputDirectory, locale.getLanguage() );\n        }\n        return file;\n    }","commit_id":"6a7c2fdf0760f12471b377792ce18e554d21b46e","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Generates Project Info Page\n     *\n     * @param siteDescriptor  site.xml\n     * @param locale          the locale used\n     * @param projectInfos    list of projectInfos\n     * @param outputDirectory directory that will contain the generated project info page\n     */\n    private void generateProjectInfoPage( String siteDescriptor, Locale locale, List projectInfos,\n                                          File outputDirectory )\n        throws RendererException, IOException\n    {\n        String outputFileName = \"project-info.html\";\n\n        SiteRendererSink sink = siteRenderer.createSink( siteDirectory, outputFileName, siteDescriptor );\n\n        String title = i18n.getString( \"site-plugin\", locale, \"report.information.title\" );\n\n        sink.head();\n        sink.title();\n        sink.text( title );\n        sink.title_();\n        sink.head_();\n        sink.body();\n\n        sink.section1();\n        sink.sectionTitle1();\n        sink.text( title );\n        sink.sectionTitle1_();\n\n        sink.paragraph();\n        sink.text( i18n.getString( \"site-plugin\", locale, \"report.information.description1\" ) + \" \" );\n        sink.link( \"http://maven.apache.org\" );\n        sink.text( \"Maven\" );\n        sink.link_();\n        sink.text( \" \" + i18n.getString( \"site-plugin\", locale, \"report.information.description2\" ) );\n        sink.paragraph_();\n\n        sink.section2();\n\n        sink.sectionTitle2();\n        sink.text( i18n.getString( \"site-plugin\", locale, \"report.information.sectionTitle\" ) );\n        sink.sectionTitle2_();\n\n        sink.table();\n\n        sink.tableRow();\n        sink.tableHeaderCell();\n        sink.text( i18n.getString( \"site-plugin\", locale, \"report.information.column.document\" ) );\n        sink.tableHeaderCell_();\n        sink.tableHeaderCell();\n        sink.text( i18n.getString( \"site-plugin\", locale, \"report.information.column.description\" ) );\n        sink.tableHeaderCell_();\n        sink.tableRow_();\n\n        for ( Iterator i = projectInfos.iterator(); i.hasNext(); )\n        {\n            MavenReport report = (MavenReport) i.next();\n\n            sink.tableRow();\n            sink.tableCell();\n            sink.link( report.getOutputName() + \".html\" );\n            sink.text( report.getName( locale ) );\n            sink.link_();\n            sink.tableCell_();\n            sink.tableCell();\n            sink.text( report.getDescription( locale ) );\n            sink.tableCell_();\n            sink.tableRow_();\n        }\n\n        sink.table_();\n\n        sink.section2_();\n\n        sink.section1_();\n\n        sink.body_();\n\n        sink.flush();\n\n        sink.close();\n\n        File outputFile = new File( outputDirectory, outputFileName );\n\n        siteRenderer.generateDocument( new OutputStreamWriter( new FileOutputStream( outputFile ), outputEncoding ),\n                                       template, attributes, sink, locale );\n    }","id":65008,"modified_method":"/**\n     * Generates Project Info Page\n     *\n     * @param projectInfos    list of projectInfos\n     * @param outputDirectory directory that will contain the generated project info page\n     */\n    private void generateProjectInfoPage( List projectInfos, File outputDirectory, SiteRenderingContext context )\n        throws RendererException, IOException\n    {\n        String outputFileName = \"project-info.html\";\n\n        SiteRendererSink sink = siteRenderer.createSink( siteDirectory, outputFileName );\n\n        Locale locale = context.getLocale();\n        String title = i18n.getString( \"site-plugin\", locale, \"report.information.title\" );\n\n        sink.head();\n        sink.title();\n        sink.text( title );\n        sink.title_();\n        sink.head_();\n        sink.body();\n\n        sink.section1();\n        sink.sectionTitle1();\n        sink.text( title );\n        sink.sectionTitle1_();\n\n        sink.paragraph();\n        sink.text( i18n.getString( \"site-plugin\", locale, \"report.information.description1\" ) + \" \" );\n        sink.link( \"http://maven.apache.org\" );\n        sink.text( \"Maven\" );\n        sink.link_();\n        sink.text( \" \" + i18n.getString( \"site-plugin\", locale, \"report.information.description2\" ) );\n        sink.paragraph_();\n\n        sink.section2();\n\n        sink.sectionTitle2();\n        sink.text( i18n.getString( \"site-plugin\", locale, \"report.information.sectionTitle\" ) );\n        sink.sectionTitle2_();\n\n        sink.table();\n\n        sink.tableRow();\n        sink.tableHeaderCell();\n        sink.text( i18n.getString( \"site-plugin\", locale, \"report.information.column.document\" ) );\n        sink.tableHeaderCell_();\n        sink.tableHeaderCell();\n        sink.text( i18n.getString( \"site-plugin\", locale, \"report.information.column.description\" ) );\n        sink.tableHeaderCell_();\n        sink.tableRow_();\n\n        for ( Iterator i = projectInfos.iterator(); i.hasNext(); )\n        {\n            MavenReport report = (MavenReport) i.next();\n\n            sink.tableRow();\n            sink.tableCell();\n            sink.link( report.getOutputName() + \".html\" );\n            sink.text( report.getName( locale ) );\n            sink.link_();\n            sink.tableCell_();\n            sink.tableCell();\n            sink.text( report.getDescription( locale ) );\n            sink.tableCell_();\n            sink.tableRow_();\n        }\n\n        sink.table_();\n\n        sink.section2_();\n\n        sink.section1_();\n\n        sink.body_();\n\n        sink.flush();\n\n        sink.close();\n\n        File outputFile = new File( outputDirectory, outputFileName );\n\n        siteRenderer.generateDocument( new OutputStreamWriter( new FileOutputStream( outputFile ), outputEncoding ),\n                                       sink, context );\n    }","commit_id":"6a7c2fdf0760f12471b377792ce18e554d21b46e","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Generate the project site\n     * <p/>\n     * throws MojoExecutionException if any\n     *\n     * @see org.apache.maven.plugin.Mojo#execute()\n     */\n    public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n\n        if ( templateDirectory == null )\n        {\n            siteRenderer.setTemplateClassLoader( SiteMojo.class.getClassLoader() );\n        }\n        else\n        {\n            try\n            {\n                if ( !templateDirectory.exists() )\n                {\n                    throw new MojoExecutionException(\n                        \"This templateDirectory=[\" + templateDirectory + \"] doesn't exist.\" );\n                }\n\n                URL templateDirectoryUrl = templateDirectory.toURL();\n\n                URL[] urls = {templateDirectoryUrl};\n\n                URLClassLoader urlClassloader = new URLClassLoader( urls );\n\n                siteRenderer.setTemplateClassLoader( urlClassloader );\n            }\n            catch ( MalformedURLException e )\n            {\n                throw new MojoExecutionException( templateDirectory + \" isn't a valid URL.\", e );\n            }\n        }\n\n        if ( attributes == null )\n        {\n            attributes = new HashMap();\n        }\n\n        if ( attributes.get( \"project\" ) == null )\n        {\n            attributes.put( \"project\", project );\n        }\n\n        if ( attributes.get( \"outputEncoding\" ) == null )\n        {\n            attributes.put( \"outputEncoding\", outputEncoding );\n        }\n\n        List reports = filterReports( this.reports );\n\n        Map categories = categorizeReports( reports );\n        List projectInfos = (List) categories.get( MavenReport.CATEGORY_PROJECT_INFORMATION );\n        List projectReports = (List) categories.get( MavenReport.CATEGORY_PROJECT_REPORTS );\n\n        if ( projectInfos == null )\n        {\n            projectInfos = Collections.EMPTY_LIST;\n        }\n\n        if ( projectReports == null )\n        {\n            projectReports = Collections.EMPTY_LIST;\n        }\n\n        try\n        {\n            List localesList = initLocalesList();\n\n            // Default is first in the list\n            Locale defaultLocale = (Locale) localesList.get( 0 );\n            Locale.setDefault( defaultLocale );\n\n            // Sort projectInfos and projectReports with the default locale setted\n            // TODO Beautify the output by sorting with each current locale\n            Comparator reportComparator = new ReportComparator();\n            Collections.sort( projectInfos, reportComparator );\n            Collections.sort( projectReports, reportComparator );\n\n            for ( Iterator iterator = localesList.iterator(); iterator.hasNext(); )\n            {\n                Locale locale = (Locale) iterator.next();\n\n                File outputDirectory = getOutputDirectory( locale, defaultLocale );\n\n                // Safety\n                if ( !outputDirectory.exists() )\n                {\n                    outputDirectory.mkdirs();\n                }\n\n                // Generate static site\n                File siteDirectoryFile = siteDirectory;\n                File xdocDirectoryFile = xdocDirectory;\n                if ( !locale.getLanguage().equals( defaultLocale.getLanguage() ) )\n                {\n                    siteDirectoryFile = new File( siteDirectory, locale.getLanguage() );\n\n                    xdocDirectoryFile = new File( xdocDirectory, locale.getLanguage() );\n                }\n\n                // Try to find duplicate files\n                Map duplicate = new LinkedHashMap();\n                String defaultExcludes = StringUtils.join( FileUtils.getDefaultExcludes(), \",\" );\n                if ( locale.getLanguage().equals( defaultLocale.getLanguage() ) )\n                {\n                    for ( Iterator it = localesList.iterator(); it.hasNext(); )\n                    {\n                        Locale l = (Locale) it.next();\n                        defaultExcludes += \",\" + l.getLanguage() + \"/**\";\n                    }\n                }\n\n                if ( siteDirectoryFile.exists() )\n                {\n                    // TODO: avoid this hardcoding - the resources dir might be elsewhere. We should really test for duplicate targets, not guess at what source files will be html.\n                    // add the site's 'resources' directory to the default exclude list\n                    String actualExcludes = defaultExcludes + \",\" + \"resources/**\";\n\n                    tryToFindDuplicates( siteDirectoryFile, actualExcludes, duplicate );\n                }\n\n                // Handle the GeneratedSite Directory\n                if ( generatedSiteDirectory.exists() )\n                {\n                    tryToFindDuplicates( generatedSiteDirectory, defaultExcludes, duplicate );\n                }\n\n                // Exception if a file is duplicate\n                checkDuplicates( duplicate, locale );\n\n                String siteDescriptor = getSiteDescriptor( reports, locale, projectInfos, projectReports );\n\n                //Generate reports\n                List generatedReportsFileName = Collections.EMPTY_LIST;\n                if ( reports != null )\n                {\n                    generatedReportsFileName =\n                        generateReportsPages( reports, locale, outputDirectory, defaultLocale, siteDescriptor );\n                }\n\n                //Generate overview pages\n                if ( projectInfos.size() > 0 )\n                {\n                    generateProjectInfoPage( siteDescriptor, locale, projectInfos, outputDirectory );\n                }\n\n                if ( projectReports.size() > 0 )\n                {\n                    generateProjectReportsPage( siteDescriptor, locale, projectReports, outputDirectory );\n                }\n\n                // Try to generate the index.html\n                String displayLanguage = locale.getDisplayLanguage( Locale.ENGLISH );\n                if ( duplicate.get( \"index\" ) != null )\n                {\n                    getLog().info( \"Ignoring the index file generation for the \" + displayLanguage + \" version.\" );\n                }\n                else\n                {\n                    getLog().info( \"Generate an index file for the \" + displayLanguage + \" version.\" );\n                    generateIndexPage( siteDescriptor, locale, outputDirectory );\n                }\n\n                // TODO: Be good to generate a module's summary page thats referenced off the\n                // Modules menu item.\n\n                // Log if a user override a report file\n                for ( Iterator it = generatedReportsFileName.iterator(); it.hasNext(); )\n                {\n                    String reportFileName = (String) it.next();\n\n                    if ( duplicate.get( reportFileName ) != null )\n                    {\n                        getLog().info( \"Override the generated file \\\"\" + reportFileName + \"\\\" for the \" +\n                            displayLanguage + \" version.\" );\n                    }\n                }\n\n                siteRenderer.render( siteDirectoryFile, outputDirectory, siteDescriptor, template, attributes, locale );\n\n                // Check if ${basedir}/xdocs is existing\n                if ( xdocDirectory.exists() )\n                {\n                    File[] fileNames = xdocDirectoryFile.listFiles();\n\n                    if ( fileNames.length > 0 )\n                    {\n                        XdocSiteModule xdoc = new XdocSiteModule();\n\n                        siteRenderer.render( xdocDirectoryFile, outputDirectory, xdoc.getSourceDirectory(), xdoc\n                            .getExtension(), xdoc.getParserId(), siteDescriptor, template, attributes, locale,\n                                             outputEncoding );\n                    }\n                }\n\n                copyResources( outputDirectory );\n\n                // Copy site resources\n                if ( resourcesDirectory != null && resourcesDirectory.exists() )\n                {\n                    copyDirectory( resourcesDirectory, outputDirectory );\n                }\n\n                if ( generatedSiteDirectory.exists() )\n                {\n                    siteRenderer.render( generatedSiteDirectory, outputDirectory, siteDescriptor, template, attributes,\n                                         locale );\n                }\n            }\n        }\n        catch ( MavenReportException e )\n        {\n            throw new MojoExecutionException( \"Error during report generation\", e );\n        }\n        catch ( RendererException e )\n        {\n            throw new MojoExecutionException( \"Error during page generation\", e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error during site generation\", e );\n        }\n    }","id":65009,"modified_method":"/**\n     * Generate the project site\n     * <p/>\n     * throws MojoExecutionException if any\n     *\n     * @see org.apache.maven.plugin.Mojo#execute()\n     */\n    public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n        ClassLoader templateClassLoader;\n\n        if ( templateDirectory == null )\n        {\n            templateClassLoader = SiteMojo.class.getClassLoader();\n        }\n        else\n        {\n            try\n            {\n                if ( !templateDirectory.exists() )\n                {\n                    throw new MojoExecutionException(\n                        \"This templateDirectory=[\" + templateDirectory + \"] doesn't exist.\" );\n                }\n\n                templateClassLoader = new URLClassLoader( new URL[]{templateDirectory.toURL()} );\n            }\n            catch ( MalformedURLException e )\n            {\n                throw new MojoExecutionException( templateDirectory + \" isn't a valid URL.\", e );\n            }\n        }\n\n        if ( attributes == null )\n        {\n            attributes = new HashMap();\n        }\n\n        if ( attributes.get( \"project\" ) == null )\n        {\n            attributes.put( \"project\", project );\n        }\n\n        if ( attributes.get( \"outputEncoding\" ) == null )\n        {\n            attributes.put( \"outputEncoding\", outputEncoding );\n        }\n\n        List reports = filterReports( this.reports );\n\n        Map categories = categorizeReports( reports );\n        List projectInfos = (List) categories.get( MavenReport.CATEGORY_PROJECT_INFORMATION );\n        List projectReports = (List) categories.get( MavenReport.CATEGORY_PROJECT_REPORTS );\n\n        if ( projectInfos == null )\n        {\n            projectInfos = Collections.EMPTY_LIST;\n        }\n\n        if ( projectReports == null )\n        {\n            projectReports = Collections.EMPTY_LIST;\n        }\n\n        try\n        {\n            List localesList = initLocalesList();\n\n            // Default is first in the list\n            Locale defaultLocale = (Locale) localesList.get( 0 );\n            Locale.setDefault( defaultLocale );\n\n            // Sort projectInfos and projectReports with the default locale setted\n            // TODO Beautify the output by sorting with each current locale\n            Comparator reportComparator = new ReportComparator();\n            Collections.sort( projectInfos, reportComparator );\n            Collections.sort( projectReports, reportComparator );\n\n            for ( Iterator iterator = localesList.iterator(); iterator.hasNext(); )\n            {\n                Locale locale = (Locale) iterator.next();\n\n                File outputDirectory = getOutputDirectory( locale, defaultLocale );\n\n                // Safety\n                if ( !outputDirectory.exists() )\n                {\n                    outputDirectory.mkdirs();\n                }\n\n                // Generate static site\n                File siteDirectoryFile = siteDirectory;\n                File xdocDirectoryFile = xdocDirectory;\n                if ( !locale.getLanguage().equals( defaultLocale.getLanguage() ) )\n                {\n                    siteDirectoryFile = new File( siteDirectory, locale.getLanguage() );\n\n                    xdocDirectoryFile = new File( xdocDirectory, locale.getLanguage() );\n                }\n\n                // Try to find duplicate files\n                Map duplicate = new LinkedHashMap();\n                String defaultExcludes = StringUtils.join( FileUtils.getDefaultExcludes(), \",\" );\n                if ( locale.getLanguage().equals( defaultLocale.getLanguage() ) )\n                {\n                    for ( Iterator it = localesList.iterator(); it.hasNext(); )\n                    {\n                        Locale l = (Locale) it.next();\n                        defaultExcludes += \",\" + l.getLanguage() + \"/**\";\n                    }\n                }\n\n                if ( siteDirectoryFile.exists() )\n                {\n                    // TODO: avoid this hardcoding - the resources dir might be elsewhere. We should really test for duplicate targets, not guess at what source files will be html.\n                    // add the site's 'resources' directory to the default exclude list\n                    String actualExcludes = defaultExcludes + \",\" + \"resources/**\";\n\n                    tryToFindDuplicates( siteDirectoryFile, actualExcludes, duplicate );\n                }\n\n                // Handle the GeneratedSite Directory\n                if ( generatedSiteDirectory.exists() )\n                {\n                    tryToFindDuplicates( generatedSiteDirectory, defaultExcludes, duplicate );\n                }\n\n                // Exception if a file is duplicate\n                checkDuplicates( duplicate, locale );\n\n                DecorationModel decoration = getDecorationModel( reports, locale, projectInfos, projectReports );\n\n                SiteRenderingContext context = new SiteRenderingContext();\n                context.setTemplate( template );\n                context.setTemplateProperties( attributes );\n                context.setLocale( locale );\n                context.setTemplateClassLoader( templateClassLoader );\n                context.setDecoration( decoration );\n\n                //Generate reports\n                List generatedReportsFileName = Collections.EMPTY_LIST;\n                if ( reports != null )\n                {\n                    generatedReportsFileName = generateReportsPages( reports, outputDirectory, defaultLocale, context );\n                }\n\n                //Generate overview pages\n                if ( projectInfos.size() > 0 )\n                {\n                    generateProjectInfoPage( projectInfos, outputDirectory, context );\n                }\n\n                if ( projectReports.size() > 0 )\n                {\n                    generateProjectReportsPage( projectReports, outputDirectory, context );\n                }\n\n                // Try to generate the index.html\n                String displayLanguage = locale.getDisplayLanguage( Locale.ENGLISH );\n                if ( duplicate.get( \"index\" ) != null )\n                {\n                    getLog().info( \"Ignoring the index file generation for the \" + displayLanguage + \" version.\" );\n                }\n                else\n                {\n                    getLog().info( \"Generate an index file for the \" + displayLanguage + \" version.\" );\n                    generateIndexPage( outputDirectory, context );\n                }\n\n                // TODO: Be good to generate a module's summary page thats referenced off the\n                // Modules menu item.\n\n                // Log if a user override a report file\n                for ( Iterator it = generatedReportsFileName.iterator(); it.hasNext(); )\n                {\n                    String reportFileName = (String) it.next();\n\n                    if ( duplicate.get( reportFileName ) != null )\n                    {\n                        getLog().info( \"Override the generated file \\\"\" + reportFileName + \"\\\" for the \" +\n                            displayLanguage + \" version.\" );\n                    }\n                }\n\n                siteRenderer.render( siteDirectoryFile, outputDirectory, context );\n\n                // Check if ${basedir}/xdocs is existing\n                if ( xdocDirectory.exists() )\n                {\n                    File[] fileNames = xdocDirectoryFile.listFiles();\n\n                    if ( fileNames.length > 0 )\n                    {\n                        XdocSiteModule xdoc = new XdocSiteModule();\n\n                        siteRenderer.render( xdocDirectoryFile, outputDirectory, xdoc.getSourceDirectory(),\n                                             xdoc.getExtension(), xdoc.getParserId(), context, outputEncoding );\n                    }\n                }\n\n                copyResources( outputDirectory );\n\n                // Copy site resources\n                if ( resourcesDirectory != null && resourcesDirectory.exists() )\n                {\n                    copyDirectory( resourcesDirectory, outputDirectory );\n                }\n\n                if ( generatedSiteDirectory.exists() )\n                {\n                    siteRenderer.render( generatedSiteDirectory, outputDirectory, context );\n                }\n            }\n        }\n        catch ( MavenReportException e )\n        {\n            throw new MojoExecutionException( \"Error during report generation\", e );\n        }\n        catch ( RendererException e )\n        {\n            throw new MojoExecutionException( \"Error during page generation\", e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error during site generation\", e );\n        }\n    }","commit_id":"6a7c2fdf0760f12471b377792ce18e554d21b46e","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Convenience method that try to find duplicate files in sub-directories of a given directory.\n     * <p>The scan is case sensitive.<\/p>\n     *\n     * @param directory       the directory to scan\n     * @param defaultExcludes files patterns to be exclude from the search\n     * @param duplicate       the map to update\n     * @throws IOException if any\n     */\n    private static void tryToFindDuplicates( File directory, String defaultExcludes, Map duplicate )\n        throws IOException\n    {\n        List siteFiles = FileUtils.getFileNames( directory, null, defaultExcludes, false );\n        for ( Iterator it = siteFiles.iterator(); it.hasNext(); )\n        {\n            String currentFile = (String) it.next();\n\n            if ( currentFile.lastIndexOf( File.separator ) == -1 )\n            {\n                // ignore files directly in the directory\n                continue;\n            }\n\n            if ( currentFile.lastIndexOf( \".\" ) == -1 || currentFile.startsWith( \".\" ) )\n            {\n                // ignore files without extension\n                continue;\n            }\n\n            String key = currentFile.substring( currentFile.indexOf( File.separator ) + 1, currentFile\n                .lastIndexOf( \".\" ) );\n\n            List tmp = (List) duplicate.get( key.toLowerCase() );\n            if ( tmp == null )\n            {\n                tmp = new ArrayList();\n                duplicate.put( key.toLowerCase(), tmp );\n            }\n            tmp.add( currentFile );\n        }\n    }","id":65010,"modified_method":"/**\n     * Convenience method that try to find duplicate files in sub-directories of a given directory.\n     * <p>The scan is case sensitive.<\/p>\n     *\n     * @param directory       the directory to scan\n     * @param defaultExcludes files patterns to be exclude from the search\n     * @param duplicate       the map to update\n     * @throws IOException if any\n     */\n    private static void tryToFindDuplicates( File directory, String defaultExcludes, Map duplicate )\n        throws IOException\n    {\n        List siteFiles = FileUtils.getFileNames( directory, null, defaultExcludes, false );\n        for ( Iterator it = siteFiles.iterator(); it.hasNext(); )\n        {\n            String currentFile = (String) it.next();\n\n            int endIndex = currentFile.lastIndexOf( \".\" );\n            if ( currentFile.lastIndexOf( File.separator ) == -1 )\n            {\n                // ignore files directly in the directory\n            }\n            else if ( endIndex == -1 || currentFile.startsWith( \".\" ) )\n            {\n                // ignore files without extension\n            }\n            else\n            {\n\n                int beginIndex = currentFile.indexOf( File.separator ) + 1;\n                String key = currentFile.substring( beginIndex, endIndex ).toLowerCase( Locale.getDefault() );\n\n                List tmp = (List) duplicate.get( key );\n                if ( tmp == null )\n                {\n                    tmp = new ArrayList();\n                    duplicate.put( key, tmp );\n                }\n                tmp.add( currentFile );\n            }\n        }\n    }","commit_id":"6a7c2fdf0760f12471b377792ce18e554d21b46e","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Generates the Project Report Pages\n     *\n     * @param siteDescriptor  site.xml\n     * @param locale          the locale used\n     * @param projectReports  list of project reports\n     * @param outputDirectory directory that will contain the generated project report pages\n     */\n    private void generateProjectReportsPage( String siteDescriptor, Locale locale, List projectReports,\n                                             File outputDirectory )\n        throws RendererException, IOException\n    {\n        String outputFileName = \"maven-reports.html\";\n\n        SiteRendererSink sink = siteRenderer.createSink( siteDirectory, outputFileName, siteDescriptor );\n\n        String title = i18n.getString( \"site-plugin\", locale, \"report.project.title\" );\n\n        sink.head();\n        sink.title();\n        sink.text( title );\n        sink.title_();\n        sink.head_();\n        sink.body();\n\n        sink.section1();\n        sink.sectionTitle1();\n        sink.text( title );\n        sink.sectionTitle1_();\n\n        sink.paragraph();\n        sink.text( i18n.getString( \"site-plugin\", locale, \"report.project.description1\" ) + \" \" );\n        sink.link( \"http://maven.apache.org\" );\n        sink.text( \"Maven\" );\n        sink.link_();\n        sink.text( \". \" + i18n.getString( \"site-plugin\", locale, \"report.project.description2\" ) );\n        sink.paragraph_();\n\n        sink.section2();\n\n        sink.sectionTitle2();\n        sink.text( i18n.getString( \"site-plugin\", locale, \"report.project.sectionTitle\" ) );\n        sink.sectionTitle2_();\n\n        sink.table();\n\n        sink.tableRow();\n        sink.tableHeaderCell();\n        sink.text( i18n.getString( \"site-plugin\", locale, \"report.project.column.document\" ) );\n        sink.tableHeaderCell_();\n        sink.tableHeaderCell();\n        sink.text( i18n.getString( \"site-plugin\", locale, \"report.project.column.description\" ) );\n        sink.tableHeaderCell_();\n        sink.tableRow_();\n\n        for ( Iterator i = projectReports.iterator(); i.hasNext(); )\n        {\n            MavenReport report = (MavenReport) i.next();\n\n            sink.tableRow();\n            sink.tableCell();\n            sink.link( report.getOutputName() + \".html\" );\n            sink.text( report.getName( locale ) );\n            sink.link_();\n            sink.tableCell_();\n            sink.tableCell();\n            sink.text( report.getDescription( locale ) );\n            sink.tableCell_();\n            sink.tableRow_();\n        }\n\n        sink.table_();\n\n        sink.section2_();\n\n        sink.section1_();\n\n        sink.body_();\n\n        File outputFile = new File( outputDirectory, outputFileName );\n\n        siteRenderer.generateDocument( new OutputStreamWriter( new FileOutputStream( outputFile ), outputEncoding ),\n                                       template, attributes, sink, locale );\n    }","id":65011,"modified_method":"/**\n     * Generates the Project Report Pages\n     *\n     * @param projectReports  list of project reports\n     * @param outputDirectory directory that will contain the generated project report pages\n     */\n    private void generateProjectReportsPage( List projectReports, File outputDirectory, SiteRenderingContext context )\n        throws RendererException, IOException\n    {\n        String outputFileName = \"maven-reports.html\";\n\n        SiteRendererSink sink = siteRenderer.createSink( siteDirectory, outputFileName );\n\n        Locale locale = context.getLocale();\n        String title = i18n.getString( \"site-plugin\", locale, \"report.project.title\" );\n\n        sink.head();\n        sink.title();\n        sink.text( title );\n        sink.title_();\n        sink.head_();\n        sink.body();\n\n        sink.section1();\n        sink.sectionTitle1();\n        sink.text( title );\n        sink.sectionTitle1_();\n\n        sink.paragraph();\n        sink.text( i18n.getString( \"site-plugin\", locale, \"report.project.description1\" ) + \" \" );\n        sink.link( \"http://maven.apache.org\" );\n        sink.text( \"Maven\" );\n        sink.link_();\n        sink.text( \". \" + i18n.getString( \"site-plugin\", locale, \"report.project.description2\" ) );\n        sink.paragraph_();\n\n        sink.section2();\n\n        sink.sectionTitle2();\n        sink.text( i18n.getString( \"site-plugin\", locale, \"report.project.sectionTitle\" ) );\n        sink.sectionTitle2_();\n\n        sink.table();\n\n        sink.tableRow();\n        sink.tableHeaderCell();\n        sink.text( i18n.getString( \"site-plugin\", locale, \"report.project.column.document\" ) );\n        sink.tableHeaderCell_();\n        sink.tableHeaderCell();\n        sink.text( i18n.getString( \"site-plugin\", locale, \"report.project.column.description\" ) );\n        sink.tableHeaderCell_();\n        sink.tableRow_();\n\n        for ( Iterator i = projectReports.iterator(); i.hasNext(); )\n        {\n            MavenReport report = (MavenReport) i.next();\n\n            sink.tableRow();\n            sink.tableCell();\n            sink.link( report.getOutputName() + \".html\" );\n            sink.text( report.getName( locale ) );\n            sink.link_();\n            sink.tableCell_();\n            sink.tableCell();\n            sink.text( report.getDescription( locale ) );\n            sink.tableCell_();\n            sink.tableRow_();\n        }\n\n        sink.table_();\n\n        sink.section2_();\n\n        sink.section1_();\n\n        sink.body_();\n\n        File outputFile = new File( outputDirectory, outputFileName );\n\n        siteRenderer.generateDocument( new OutputStreamWriter( new FileOutputStream( outputFile ), outputEncoding ),\n                                       sink, context );\n    }","commit_id":"6a7c2fdf0760f12471b377792ce18e554d21b46e","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Generate reports pages\n     *\n     * @param reports\n     * @param locale\n     * @param localeOutputDirectory\n     */\n    private List generateReportsPages( List reports, Locale locale, File localeOutputDirectory, Locale defaultLocale,\n                                       String siteDescriptor )\n        throws RendererException, IOException, MavenReportException\n    {\n        List generatedReportsFileName = new ArrayList();\n\n        for ( Iterator j = reports.iterator(); j.hasNext(); )\n        {\n            MavenReport report = (MavenReport) j.next();\n\n            getLog().info( \"Generate \\\"\" + report.getName( locale ) + \"\\\" report.\" );\n\n            report.setReportOutputDirectory( localeOutputDirectory );\n\n            String reportFileName = report.getOutputName();\n\n            if ( locale.equals( defaultLocale ) )\n            {\n                generatedReportsFileName.add( reportFileName );\n            }\n            else\n            {\n                generatedReportsFileName.add( locale.getLanguage() + File.separator + reportFileName );\n            }\n\n            String outputFileName = reportFileName + \".html\";\n\n            SiteRendererSink sink = siteRenderer.createSink( siteDirectory, outputFileName, siteDescriptor );\n\n            report.generate( sink, locale );\n\n            if ( !report.isExternalReport() )\n            {\n                File outputFile = new File( localeOutputDirectory, outputFileName );\n\n                if ( !outputFile.getParentFile().exists() )\n                {\n                    outputFile.getParentFile().mkdirs();\n                }\n\n                siteRenderer.generateDocument(\n                    new OutputStreamWriter( new FileOutputStream( outputFile ), outputEncoding ), template, attributes,\n                    sink, locale );\n            }\n        }\n        return generatedReportsFileName;\n    }","id":65012,"modified_method":"/**\n     * Generate reports pages\n     *\n     * @param reports\n     * @param localeOutputDirectory\n     */\n    private List generateReportsPages( List reports, File localeOutputDirectory, Locale defaultLocale,\n                                       SiteRenderingContext context )\n        throws RendererException, IOException, MavenReportException\n    {\n        List generatedReportsFileName = new ArrayList();\n\n        for ( Iterator j = reports.iterator(); j.hasNext(); )\n        {\n            MavenReport report = (MavenReport) j.next();\n\n            Locale locale = context.getLocale();\n            getLog().info( \"Generate \\\"\" + report.getName( locale ) + \"\\\" report.\" );\n\n            report.setReportOutputDirectory( localeOutputDirectory );\n\n            String reportFileName = report.getOutputName();\n\n            if ( locale.equals( defaultLocale ) )\n            {\n                generatedReportsFileName.add( reportFileName );\n            }\n            else\n            {\n                generatedReportsFileName.add( locale.getLanguage() + File.separator + reportFileName );\n            }\n\n            String outputFileName = reportFileName + \".html\";\n\n            SiteRendererSink sink = siteRenderer.createSink( siteDirectory, outputFileName );\n\n            report.generate( sink, locale );\n\n            if ( !report.isExternalReport() )\n            {\n                File outputFile = new File( localeOutputDirectory, outputFileName );\n\n                if ( !outputFile.getParentFile().exists() )\n                {\n                    outputFile.getParentFile().mkdirs();\n                }\n\n                siteRenderer.generateDocument(\n                    new OutputStreamWriter( new FileOutputStream( outputFile ), outputEncoding ), sink, context );\n            }\n        }\n        return generatedReportsFileName;\n    }","commit_id":"6a7c2fdf0760f12471b377792ce18e554d21b46e","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Generate an index page.\n     *\n     * @param siteDescriptor\n     * @param locale\n     * @param outputDirectory\n     */\n    private void generateIndexPage( String siteDescriptor, Locale locale, File outputDirectory )\n        throws RendererException, IOException\n    {\n        String outputFileName = \"index.html\";\n\n        SiteRendererSink sink = siteRenderer.createSink( siteDirectory, outputFileName, siteDescriptor );\n\n        String title = i18n.getString( \"site-plugin\", locale, \"report.index.title\" ).trim() + \" \" + project.getName();\n\n        sink.head();\n        sink.title();\n        sink.text( title );\n        sink.title_();\n        sink.head_();\n        sink.body();\n\n        sink.section1();\n        sink.sectionTitle1();\n        sink.text( title );\n        sink.sectionTitle1_();\n\n        sink.paragraph();\n        if ( project.getDescription() != null )\n        {\n            // TODO How to handle i18n?\n            sink.text( project.getDescription() );\n        }\n        else\n        {\n            sink.text( i18n.getString( \"site-plugin\", locale, \"report.index.nodescription\" ) );\n        }\n        sink.paragraph_();\n\n        sink.body_();\n\n        sink.flush();\n\n        sink.close();\n\n        File outputFile = new File( outputDirectory, outputFileName );\n\n        siteRenderer.generateDocument( new OutputStreamWriter( new FileOutputStream( outputFile ), outputEncoding ),\n                                       template, attributes, sink, locale );\n    }","id":65013,"modified_method":"/**\n     * Generate an index page.\n     *\n     * @param outputDirectory\n     */\n    private void generateIndexPage( File outputDirectory, SiteRenderingContext context )\n        throws RendererException, IOException\n    {\n        String outputFileName = \"index.html\";\n\n        SiteRendererSink sink = siteRenderer.createSink( siteDirectory, outputFileName );\n\n        Locale locale = context.getLocale();\n        String title = i18n.getString( \"site-plugin\", locale, \"report.index.title\" ).trim() + \" \" + project.getName();\n\n        sink.head();\n        sink.title();\n        sink.text( title );\n        sink.title_();\n        sink.head_();\n        sink.body();\n\n        sink.section1();\n        sink.sectionTitle1();\n        sink.text( title );\n        sink.sectionTitle1_();\n\n        sink.paragraph();\n        if ( project.getDescription() != null )\n        {\n            // TODO How to handle i18n?\n            sink.text( project.getDescription() );\n        }\n        else\n        {\n            sink.text( i18n.getString( \"site-plugin\", locale, \"report.index.nodescription\" ) );\n        }\n        sink.paragraph_();\n\n        sink.body_();\n\n        sink.flush();\n\n        sink.close();\n\n        File outputFile = new File( outputDirectory, outputFileName );\n\n        siteRenderer.generateDocument( new OutputStreamWriter( new FileOutputStream( outputFile ), outputEncoding ),\n                                       sink, context );\n    }","commit_id":"6a7c2fdf0760f12471b377792ce18e554d21b46e","url":"https://github.com/apache/maven-plugins"},{"original_method":"private List filterReports( List reports )\n    {\n        List filteredReports = new ArrayList( reports.size() );\n        for ( Iterator i = reports.iterator(); i.hasNext(); )\n        {\n            MavenReport report = (MavenReport) i.next();\n            try\n            {\n                if ( report.canGenerateReport() )\n                {\n                    filteredReports.add( report );\n                }\n            }\n            // the canGenerateReport() has been added just before the 2.0 release and will cause all the reporting\n            // plugins with an earlier version to fail (most of the codehaus mojo now fails)\n            // be nice with them, output a warning and don't let them break anything\n            catch ( AbstractMethodError e )\n            {\n                getLog().warn( \"Error loading report \" + report.getClass().getName() +\n                    \" - AbstractMethodError: canGenerateReport()\" );\n                filteredReports.add( report );\n            }\n        }\n        return filteredReports;\n    }","id":65014,"modified_method":"private List filterReports( List reports )\n    {\n        List filteredReports = new ArrayList( reports.size() );\n        if ( generateReports )\n        {\n            for ( Iterator i = reports.iterator(); i.hasNext(); )\n            {\n                MavenReport report = (MavenReport) i.next();\n                //noinspection ErrorNotRethrown,UnusedCatchParameter\n                try\n                {\n                    if ( report.canGenerateReport() )\n                    {\n                        filteredReports.add( report );\n                    }\n                }\n                catch ( AbstractMethodError e )\n                {\n\n                    // the canGenerateReport() has been added just before the 2.0 release and will cause all the reporting\n                    // plugins with an earlier version to fail (most of the codehaus mojo now fails)\n                    // be nice with them, output a warning and don't let them break anything\n\n                    getLog().warn( \"Error loading report \" + report.getClass().getName() +\n                        \" - AbstractMethodError: canGenerateReport()\" );\n                    filteredReports.add( report );\n                }\n            }\n        }\n        return filteredReports;\n    }","commit_id":"6a7c2fdf0760f12471b377792ce18e554d21b46e","url":"https://github.com/apache/maven-plugins"},{"original_method":"private TestSuite doBuildSuite() {\n        try {\n            CompileSession session = new CompileSession(myEnvironment);\n\n            myEnvironment.addToClasspath(ForTestCompileStdlib.stdlibJarForTests());\n\n            File junitJar = new File(\"testlib/lib/junit-4.9.jar\");\n\n            if (!junitJar.exists()) {\n                throw new AssertionError();\n            }\n\n            myEnvironment.addToClasspath(junitJar);\n\n            CoreLocalFileSystem localFileSystem = myEnvironment.getLocalFileSystem();\n            VirtualFile path = localFileSystem.findFileByPath(JetParsingTest.getTestDataDir() + \"/../../testlib/test\");\n            session.addSources(path);\n\n            if (!session.analyze(System.out)) {\n                throw new RuntimeException();\n            }\n\n            ClassFileFactory classFileFactory = session.generate();\n\n            URLClassLoader dependenciesClassLoader = new URLClassLoader(new URL[] { junitJar.toURI().toURL() });\n            GeneratedClassLoader loader;\n            URLClassLoader parentClassLoader = new URLClassLoader(new URL[]{\n                    ForTestCompileStdlib.stdlibJarForTests().toURI().toURL()}, dependenciesClassLoader);\n            loader = new GeneratedClassLoader(classFileFactory, parentClassLoader);\n\n            JetTypeMapper typeMapper = new JetTypeMapper(classFileFactory.state.getStandardLibrary(), session.getMyBindingContext());\n            TestSuite suite = new TestSuite(\"StandardLibrary\");\n            try {\n                for(JetFile jetFile : session.getSourceFileNamespaces()) {\n                    for(JetDeclaration decl : jetFile.getDeclarations()) {\n                        if(decl instanceof JetClass) {\n                            JetClass jetClass = (JetClass) decl;\n\n                            ClassDescriptor descriptor = (ClassDescriptor) session.getMyBindingContext().get(BindingContext.DECLARATION_TO_DESCRIPTOR, jetClass);\n                            Set<JetType> allSuperTypes = new THashSet<JetType>();\n                            CodegenUtil.addSuperTypes(descriptor.getDefaultType(), allSuperTypes);\n\n                            for(JetType type : allSuperTypes) {\n                                String internalName = typeMapper.mapType(type).getInternalName();\n                                if(internalName.equals(\"junit/framework/Test\")) {\n                                    String name = typeMapper.mapType(descriptor.getDefaultType()).getInternalName();\n                                    System.out.println(name);\n                                    Class<TestCase> aClass = (Class<TestCase>) loader.loadClass(name.replace('/', '.'));\n                                    if((aClass.getModifiers() & Modifier.ABSTRACT) == 0\n                                     && (aClass.getModifiers() & Modifier.PUBLIC) != 0) {\n                                        try {\n                                            Constructor<TestCase> constructor = aClass.getConstructor();\n                                            if(constructor != null && (constructor.getModifiers() & Modifier.PUBLIC) != 0) {\n                                                suite.addTestSuite(aClass);\n                                            }\n                                        }\n                                        catch (NoSuchMethodException e) {\n                                        }\n                                    }\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            finally {\n                typeMapper = null;\n            }\n\n            return suite;\n\n        } catch (RuntimeException e) {\n            throw e;\n        } catch (Throwable e) {\n            throw new RuntimeException(e);\n        }\n    }","id":65015,"modified_method":"private TestSuite doBuildSuite() {\n        try {\n            CompileSession session = new CompileSession(myEnvironment);\n\n            myEnvironment.addToClasspath(ForTestCompileStdlib.stdlibJarForTests());\n\n            File junitJar = new File(\"testlib/lib/junit-4.9.jar\");\n\n            if (!junitJar.exists()) {\n                throw new AssertionError();\n            }\n\n            myEnvironment.addToClasspath(junitJar);\n\n            CoreLocalFileSystem localFileSystem = myEnvironment.getLocalFileSystem();\n            VirtualFile path = localFileSystem.findFileByPath(JetParsingTest.getTestDataDir() + \"/../../testlib/test\");\n            session.addSources(path);\n\n            if (!session.analyze(System.out)) {\n                throw new RuntimeException();\n            }\n\n            ClassFileFactory classFileFactory = session.generate();\n\n            GeneratedClassLoader loader = new GeneratedClassLoader(\n                    classFileFactory,\n                    new URLClassLoader(new URL[]{ForTestCompileStdlib.stdlibJarForTests().toURI().toURL(), junitJar.toURI().toURL()},\n                                       TestCase.class.getClassLoader()));\n\n            JetTypeMapper typeMapper = new JetTypeMapper(classFileFactory.state.getStandardLibrary(), session.getMyBindingContext());\n            TestSuite suite = new TestSuite(\"StandardLibrary\");\n            try {\n                for(JetFile jetFile : session.getSourceFileNamespaces()) {\n                    for(JetDeclaration decl : jetFile.getDeclarations()) {\n                        if(decl instanceof JetClass) {\n                            JetClass jetClass = (JetClass) decl;\n\n                            ClassDescriptor descriptor = (ClassDescriptor) session.getMyBindingContext().get(BindingContext.DECLARATION_TO_DESCRIPTOR, jetClass);\n                            Set<JetType> allSuperTypes = new THashSet<JetType>();\n                            CodegenUtil.addSuperTypes(descriptor.getDefaultType(), allSuperTypes);\n\n                            for(JetType type : allSuperTypes) {\n                                String internalName = typeMapper.mapType(type).getInternalName();\n                                if(internalName.equals(\"junit/framework/Test\")) {\n                                    String name = typeMapper.mapType(descriptor.getDefaultType()).getInternalName();\n                                    System.out.println(name);\n                                    Class<TestCase> aClass = (Class<TestCase>) loader.loadClass(name.replace('/', '.'));\n                                    if((aClass.getModifiers() & Modifier.ABSTRACT) == 0\n                                     && (aClass.getModifiers() & Modifier.PUBLIC) != 0) {\n                                        try {\n                                            Constructor<TestCase> constructor = aClass.getConstructor();\n                                            if(constructor != null && (constructor.getModifiers() & Modifier.PUBLIC) != 0) {\n                                                suite.addTestSuite(aClass);\n                                            }\n                                        }\n                                        catch (NoSuchMethodException e) {\n                                        }\n                                    }\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            finally {\n                typeMapper = null;\n            }\n\n            return suite;\n\n        } catch (RuntimeException e) {\n            throw e;\n        } catch (Throwable e) {\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"25b71cd6c900d51e38866dc4bb3cfd8e77ebad7c","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void checkInfo(ClassReader kotlinReader, ClassReader javaReader) {\n        OuterClassInfo kotlinInfo = getOuterClassInfo(kotlinReader);\n        OuterClassInfo javaInfo = getOuterClassInfo(javaReader);\n        assertEquals(\"Error in enclosingMethodInfo info for: \" + kotlinReader.getClassName() + \" class\", javaInfo, kotlinInfo);\n    }","id":65016,"modified_method":"private static void checkInfo(@NotNull ClassReader kotlinReader, @NotNull ClassReader javaReader) {\n        OuterClassInfo kotlinInfo = getOuterClassInfo(kotlinReader);\n        OuterClassInfo javaInfo = getOuterClassInfo(javaReader);\n        compareInfo(kotlinReader.getClassName(), kotlinInfo, javaInfo);\n    }","commit_id":"449e26ce6d876b2106951ca9a756aa7f69accf6d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void doCustomTest(@NotNull String kotlinClassName, @NotNull OuterClassInfo expectedInfo, String testDataFile) {\n        ClassReader kotlinReader = getKotlinClassReader(kotlinClassName, testDataFile);\n        OuterClassInfo kotlinInfo = getOuterClassInfo(kotlinReader);\n        String message = \"Error in enclosingMethodInfo info for: \" + kotlinReader.getClassName() + \" class\";\n        if ((kotlinInfo.owner == null) || !kotlinInfo.owner.startsWith(expectedInfo.owner)) {\n            fail(message + \" expectedOwner=\" + expectedInfo.owner + \", actualOwner=\" + kotlinInfo.owner);\n        }\n        assertEquals(message, expectedInfo.method, kotlinInfo.method);\n        assertEquals(message, expectedInfo.descriptor, kotlinInfo.descriptor);\n    }","id":65017,"modified_method":"private void doCustomTest(@NotNull String kotlinClassName, @NotNull OuterClassInfo expectedInfo, String testDataFile) {\n        ClassReader kotlinReader = getKotlinClassReader(kotlinClassName, testDataFile);\n        OuterClassInfo kotlinInfo = getOuterClassInfo(kotlinReader);\n        String message = \"Error in enclosingMethodInfo info for: \" + kotlinReader.getClassName() + \" class\";\n        if ((kotlinInfo.owner == null) || !kotlinInfo.owner.startsWith(expectedInfo.owner)) {\n            assertEquals(message, expectedInfo.owner, kotlinInfo.owner);\n        }\n        assertEquals(message, expectedInfo.method, kotlinInfo.method);\n        assertEquals(message, expectedInfo.descriptor, kotlinInfo.descriptor);\n    }","commit_id":"449e26ce6d876b2106951ca9a756aa7f69accf6d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private ClassReader getKotlinClassReader(@NotNull String kotlinClassName, String testDataFile) {\n        loadFile(TEST_FOLDER + \"/ \" + testDataFile + \".kt\");\n        OutputFileCollection outputFiles = generateClassesInFile();\n        OutputFile outputFile = outputFiles.get(kotlinClassName.replace('.', '/') + \".class\");\n        assertNotNull(outputFile);\n        return new ClassReader(outputFile.asByteArray());\n    }","id":65018,"modified_method":"private ClassReader getKotlinClassReader(@NotNull String kotlinClassName, @NotNull String testDataFile) {\n        loadFile(TEST_FOLDER + \"/\" + testDataFile + \".kt\");\n        OutputFileCollection outputFiles = generateClassesInFile();\n        OutputFile outputFile = outputFiles.get(kotlinClassName.replace('.', '/') + \".class\");\n        assertNotNull(\"Couldn't find kotlin class: \" + kotlinClassName ,outputFile);\n        return new ClassReader(outputFile.asByteArray());\n    }","commit_id":"449e26ce6d876b2106951ca9a756aa7f69accf6d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void doTest(@NotNull String kotlinClassName, @NotNull String javaClassName, String testDataFile) throws Exception {\n        File javaClassesTempDirectory = compileJava(TEST_FOLDER + \"/\" + testDataFile + \".java\");\n\n        UrlClassLoader javaClassLoader = new UrlClassLoader(new URL[] {javaClassesTempDirectory.toURI().toURL()}, getClass().getClassLoader());\n\n        String javaClassPath = javaClassName.replace('.', File.separatorChar) + \".class\";\n        InputStream javaClassStream = javaClassLoader.getResourceAsStream(javaClassPath);\n        ClassReader javaReader =  new ClassReader(javaClassStream);\n\n        ClassReader kotlinReader = getKotlinClassReader(kotlinClassName, testDataFile);\n\n        checkInfo(kotlinReader, javaReader);\n    }","id":65019,"modified_method":"private void doTest(@NotNull String kotlinClassName, @NotNull String javaClassName, String testDataFile) throws Exception {\n        File javaClassesTempDirectory = compileJava(TEST_FOLDER + \"/\" + testDataFile + \".java\");\n\n        UrlClassLoader javaClassLoader = UrlClassLoader.build().urls(javaClassesTempDirectory.toURI().toURL()).get();\n\n        String javaClassPath = javaClassName.replace('.', File.separatorChar) + \".class\";\n        InputStream javaClassStream = javaClassLoader.getResourceAsStream(javaClassPath);\n        assert javaClassStream != null : \"Couldn't find class bytecode \" + javaClassPath;\n\n        ClassReader javaReader =  new ClassReader(javaClassStream);\n        ClassReader kotlinReader = getKotlinClassReader(kotlinClassName, testDataFile);\n\n        checkInfo(kotlinReader, javaReader);\n    }","commit_id":"449e26ce6d876b2106951ca9a756aa7f69accf6d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void execute() throws MojoExecutionException, MojoFailureException {\n        URLClassLoader projectClassLoader = null;\n        try {\n            projectClassLoader = new URLClassLoader(new URL[]{outputDirectory.toURI().toURL()});\n        } catch (MalformedURLException e) {\n            throw new RuntimeException(e);\n        }\n\n        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();\n        Thread.currentThread().setContextClassLoader(projectClassLoader);\n\n        KieServices ks = KieServices.Factory.get();\n\n        try {\n            KieRepository kr = ks.getRepository();\n            KieModule kModule = kr.addKieModule(ks.getResources().newFileSystemResource(sourceFolder));\n            KieContainerImpl kContainer = (KieContainerImpl) ks.newKieContainer(kModule.getReleaseId());\n\n            KieProject kieProject = kContainer.getKieProject();\n            ResultsImpl messages = kieProject.verify();\n\n            List<Message> errors = messages.filterMessages(Message.Level.ERROR);\n            if (!errors.isEmpty()) {\n                for (Message error : errors) {\n                    getLog().error(error.toString());\n                }\n                throw new MojoFailureException(\"Build failed!\");\n            }\n        } finally {\n            Thread.currentThread().setContextClassLoader(contextClassLoader);\n        }\n        getLog().info(\"KieModule successfully built!\");\n    }","id":65020,"modified_method":"public void execute() throws MojoExecutionException, MojoFailureException {\n        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();\n\n        try {\n            Set<URL> urls = new HashSet<URL>();\n            List<String> elements = project.getCompileClasspathElements();\n            for (String element : elements) {\n                urls.add(new File(element).toURI().toURL());\n            }\n            urls.add(outputDirectory.toURI().toURL());\n\n            ClassLoader projectClassLoader = URLClassLoader.newInstance(urls.toArray(new URL[0]),\n                                                                        Thread.currentThread().getContextClassLoader());\n\n            Thread.currentThread().setContextClassLoader(projectClassLoader);\n\n        } catch (DependencyResolutionRequiredException e) {\n            throw new RuntimeException(e);\n        } catch (MalformedURLException e) {\n            throw new RuntimeException(e);\n        }\n\n        KieServices ks = KieServices.Factory.get();\n\n        try {\n            KieRepository kr = ks.getRepository();\n            KieModule kModule = kr.addKieModule(ks.getResources().newFileSystemResource(sourceFolder));\n            KieContainerImpl kContainer = (KieContainerImpl) ks.newKieContainer(kModule.getReleaseId());\n\n            KieProject kieProject = kContainer.getKieProject();\n            ResultsImpl messages = kieProject.verify();\n\n            List<Message> errors = messages.filterMessages(Message.Level.ERROR);\n            if (!errors.isEmpty()) {\n                for (Message error : errors) {\n                    getLog().error(error.toString());\n                }\n                throw new MojoFailureException(\"Build failed!\");\n            }\n        } finally {\n            Thread.currentThread().setContextClassLoader(contextClassLoader);\n        }\n        getLog().info(\"KieModule successfully built!\");\n    }","commit_id":"b8a952e885a7f54e322eb0c13fbc734a3fd95db5","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private File getTargetIdeaInstallDir(final Map<String, Object> _params) {\n    boolean isMac = SystemInfo.isMac;\n    String userHome = System.getProperty(\"user.home\");\n    String ideaConfigRootPath = (isMac ?\n      userHome + File.separator + \"Library\" + File.separator + \"Application Support\" :\n      userHome\n    );\n    final VirtualFile ideaConfigRoot = VirtualFileUtils.getVirtualFile(ideaConfigRootPath);\n    final String ideaConfigFolderPrefix = (isMac ?\n      \"IntelliJIdea\" :\n      \".IntelliJIdea\"\n    );\n    List<VirtualFile> existingIdeaConfigs = ListSequence.fromList(new ArrayList<VirtualFile>());\n    for (VirtualFile child : ideaConfigRoot.getChildren()) {\n      if (child.isDirectory() && child.getName().startsWith(ideaConfigFolderPrefix)) {\n        ListSequence.fromList(existingIdeaConfigs).addElement(child);\n      }\n    }\n    if ((int) ListSequence.fromList(existingIdeaConfigs).count() == 0) {\n      JOptionPane.showMessageDialog(((Frame) MapSequence.fromMap(_params).get(\"frame\")), \"IntelliJ IDEA installation was not found\", \"Cannot install plugin\", JOptionPane.ERROR_MESSAGE);\n      return null;\n    } else if ((int) ListSequence.fromList(existingIdeaConfigs).count() == 1) {\n      return VirtualFileUtils.toFile(ListSequence.fromList(existingIdeaConfigs).first());\n    }\n\n    FileChooserDescriptor descriptor = new FileChooserDescriptor(false, true, false, false, false, false) {\n      @Override\n      public boolean isFileVisible(VirtualFile file, boolean b) {\n        if (!(super.isFileVisible(file, b))) {\n          return false;\n        }\n        return ideaConfigRoot.equals(file.getParent()) && file.getName().startsWith(ideaConfigFolderPrefix);\n      }\n    };\n    descriptor.setTitle(\"Select IntelliJ IDEA configuration folder\");\n    descriptor.setRoot(ideaConfigRoot);\n\n    String oldShowHiddenValue = PropertiesComponent.getInstance().getValue(\"FileChooser.showHiddens\");\n    PropertiesComponent.getInstance().setValue(\"FileChooser.showHiddens\", Boolean.TRUE.toString());\n    FileChooserDialog dialog = FileChooserFactory.getInstance().createFileChooser(descriptor, ((Frame) MapSequence.fromMap(_params).get(\"frame\")));\n    VirtualFile[] files = dialog.choose(ideaConfigRoot, null);\n    PropertiesComponent.getInstance().setValue(\"FileChooser.showHiddens\", oldShowHiddenValue);\n    assert files.length <= 1;\n    return (files.length == 0 ?\n      null :\n      VirtualFileUtils.toFile(files[0])\n    );\n  }","id":65021,"modified_method":"private File getTargetIdeaInstallDir(final Map<String, Object> _params) {\n    boolean isMac = SystemInfo.isMac;\n    String userHome = System.getProperty(\"user.home\");\n    String ideaConfigRootPath = (isMac ?\n      userHome + File.separator + \"Library\" + File.separator + \"Application Support\" :\n      userHome\n    );\n    final VirtualFile ideaConfigRoot = VirtualFileUtils.getVirtualFile(ideaConfigRootPath);\n    final Pattern namePattern = (isMac ?\n      REGEXP_gyxeh4_a0a4a4 :\n      REGEXP_gyxeh4_a0a4a4_0\n    );\n    List<VirtualFile> existingIdeaConfigs = ListSequence.fromList(new ArrayList<VirtualFile>());\n    for (VirtualFile child : ideaConfigRoot.getChildren()) {\n      if (child.isDirectory()) {\n        if (namePattern.matcher(child.getName()).matches()) {\n          ListSequence.fromList(existingIdeaConfigs).addElement(child);\n        }\n      }\n    }\n    if ((int) ListSequence.fromList(existingIdeaConfigs).count() == 0) {\n      JOptionPane.showMessageDialog(((Frame) MapSequence.fromMap(_params).get(\"frame\")), \"IntelliJ IDEA installation was not found\", \"Cannot install plugin\", JOptionPane.ERROR_MESSAGE);\n      return null;\n    } else if ((int) ListSequence.fromList(existingIdeaConfigs).count() == 1) {\n      return VirtualFileUtils.toFile(ListSequence.fromList(existingIdeaConfigs).first());\n    }\n\n    FileChooserDescriptor descriptor = new FileChooserDescriptor(false, true, false, false, false, false) {\n      @Override\n      public boolean isFileVisible(VirtualFile file, boolean b) {\n        if (!(super.isFileVisible(file, b))) {\n          return false;\n        }\n        return ideaConfigRoot.equals(file.getParent()) && namePattern.matcher(file.getName()).matches();\n      }\n    };\n    descriptor.setTitle(\"Select IntelliJ IDEA configuration folder\");\n    descriptor.setRoot(ideaConfigRoot);\n\n    String oldShowHiddenValue = PropertiesComponent.getInstance().getValue(\"FileChooser.showHiddens\");\n    PropertiesComponent.getInstance().setValue(\"FileChooser.showHiddens\", Boolean.TRUE.toString());\n    FileChooserDialog dialog = FileChooserFactory.getInstance().createFileChooser(descriptor, ((Frame) MapSequence.fromMap(_params).get(\"frame\")));\n    VirtualFile[] files = dialog.choose(ideaConfigRoot, null);\n    PropertiesComponent.getInstance().setValue(\"FileChooser.showHiddens\", oldShowHiddenValue);\n    assert files.length <= 1;\n    return (files.length == 0 ?\n      null :\n      VirtualFileUtils.toFile(files[0])\n    );\n  }","commit_id":"d7e6b5036ab016a4c4e9f888ab699ac2171058f6","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public Iterator<Resource> listChildren(final Resource parent) {\n        final String prefixPath = parent.getPath() + \"/\";\n        final Map<String, Map<String, Object>> candidates = new LinkedHashMap<String, Map<String,Object>>();\n        synchronized ( this.resources ) {\n            for(final Map.Entry<String, Map<String, Object>> e : this.resources.entrySet()) {\n                if (e.getKey().startsWith(prefixPath) && e.getKey().lastIndexOf('/') < prefixPath.length() ) {\n                    if ( !this.deletedResources.contains(e.getKey()) ) {\n                        candidates.put(e.getKey(), e.getValue());\n                    }\n                }\n            }\n            for(final Map.Entry<String, Map<String, Object>> e : this.temporaryResources.entrySet()) {\n                if (e.getKey().startsWith(prefixPath) && e.getKey().lastIndexOf('/') < prefixPath.length() ) {\n                    if ( !this.deletedResources.contains(e.getKey()) ) {\n                        candidates.put(e.getKey(), e.getValue());\n                    }\n                }\n            }\n        }\n        final List<Resource> children = new ArrayList<Resource>();\n        for(final Map.Entry<String, Map<String, Object>> e : candidates.entrySet()) {\n            children.add(new MockResource(e.getKey(), e.getValue(), this));\n        }\n        return children.iterator();\n    }","id":65022,"modified_method":"@Override\n    public Iterator<Resource> listChildren(final Resource parent) {\n        final String pathPrefix = \"/\".equals(parent.getPath()) ? \"\" : parent.getPath();\n        final Pattern childPathMatcher = Pattern.compile(\"^\" + Pattern.quote(pathPrefix) + \"/[^/]+$\");\n        final Map<String, Map<String, Object>> candidates = new LinkedHashMap<String, Map<String,Object>>();\n        synchronized ( this.resources ) {\n            for(final Map.Entry<String, Map<String, Object>> e : this.resources.entrySet()) {\n                if (childPathMatcher.matcher(e.getKey()).matches()) {\n                    if ( !this.deletedResources.contains(e.getKey()) ) {\n                        candidates.put(e.getKey(), e.getValue());\n                    }\n                }\n            }\n            for(final Map.Entry<String, Map<String, Object>> e : this.temporaryResources.entrySet()) {\n                if (childPathMatcher.matcher(e.getKey()).matches()) {\n                    if ( !this.deletedResources.contains(e.getKey()) ) {\n                        candidates.put(e.getKey(), e.getValue());\n                    }\n                }\n            }\n        }\n        final List<Resource> children = new ArrayList<Resource>();\n        for(final Map.Entry<String, Map<String, Object>> e : candidates.entrySet()) {\n            children.add(new MockResource(e.getKey(), e.getValue(), this));\n        }\n        return children.iterator();\n    }","commit_id":"23f05ecfa765fb7532b75c196ac1455fcd1bff1c","url":"https://github.com/apache/sling"},{"original_method":"public ClsReferenceParameterListImpl(PsiElement parent, String[] classParameters) {\n    myParent = parent;\n\n    int length = classParameters.length;\n    myTypeParameters = new ClsTypeElementImpl[length];\n\n    for (int i = 0; i < length; i++) {\n      String s = classParameters[length - i - 1];\n      char variance = ClsTypeElementImpl.VARIANCE_NONE;\n      if (s.startsWith(EXTENDS_PREFIX)) {\n        variance = ClsTypeElementImpl.VARIANCE_EXTENDS;\n        s = s.substring(EXTENDS_PREFIX.length());\n      }\n      else if (s.startsWith(SUPER_PREFIX)) {\n        variance = ClsTypeElementImpl.VARIANCE_SUPER;\n        s = s.substring(SUPER_PREFIX.length());\n      }\n      else if (StringUtil.startsWithChar(s, '?')) {\n        variance = ClsTypeElementImpl.VARIANCE_INVARIANT;\n        s = s.substring(1);\n      }\n\n      myTypeParameters[i] = new ClsTypeElementImpl(this, s, variance);\n    }\n  }","id":65023,"modified_method":"public ClsReferenceParameterListImpl(PsiElement parent, String[] classParameters) {\n    myParent = parent;\n\n    int length = classParameters.length;\n    myTypeParameters = new ClsTypeElementImpl[length];\n\n    for (int i = 0; i < length; i++) {\n      String s = classParameters[length - i - 1];\n      char variance = ClsTypeElementImpl.VARIANCE_NONE;\n      final Matcher extendsMatcher = EXTENDS_PREFIX.matcher(s);\n      if (extendsMatcher.find()) {\n        variance = ClsTypeElementImpl.VARIANCE_EXTENDS;\n        s = extendsMatcher.group(2);\n      }\n      else {\n        final Matcher superMatcher = SUPER_PREFIX.matcher(s);\n        if (superMatcher.find()) {\n          variance = ClsTypeElementImpl.VARIANCE_SUPER;\n          s = superMatcher.group(2);\n        }\n        else if (StringUtil.startsWithChar(s, '?')) {\n          variance = ClsTypeElementImpl.VARIANCE_INVARIANT;\n          s = s.substring(1);\n        }\n      }\n\n      myTypeParameters[i] = new ClsTypeElementImpl(this, s, variance);\n    }\n  }","commit_id":"ffa42cda83c04b475d83837118cead4e595d0e56","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Obtains text of all type parameter values in a reference.\n   * They go in left-to-right order: <code>A&lt;List&lt;String&gt, B&lt;Integer&gt;&gt;<\/code> yields\n   * <code>[\"List&lt;String&gt\", \"B&lt;Integer&gt;\"]<\/code>. Parameters of the outer reference are ignored:\n   * <code>A&lt;List&lt;String&gt&gt;.B&lt;Integer&gt;<\/code> yields <code>[\"Integer\"]<\/code>\n   *\n   * @param referenceText the text of the reference to calculate type parameters for.\n   * @return the calculated array of type parameters.\n   */\n  @NotNull\n  public static String[] getClassParametersText(@NotNull String referenceText) {\n    if (referenceText.indexOf('<') < 0) return ArrayUtil.EMPTY_STRING_ARRAY;\n    referenceText = removeWhitespace(referenceText);\n    final char[] chars = referenceText.toCharArray();\n    int afterLastDotIndex = 0;\n\n    int level = 0;\n    for (int i = 0; i < chars.length; i++) {\n      char aChar = chars[i];\n      switch (aChar) {\n        case '<':\n          level++;\n          break;\n        case '.':\n          if (level == 0) afterLastDotIndex = i + 1;\n          break;\n        case '>':\n          level--;\n          break;\n      }\n    }\n\n    if (level != 0) return ArrayUtil.EMPTY_STRING_ARRAY;\n\n    int dim = 0;\n    for (int i = afterLastDotIndex; i < chars.length; i++) {\n      char aChar = chars[i];\n      switch (aChar) {\n        case '<':\n          level++;\n          if (level == 1) dim++;\n          break;\n        case ',':\n          if (level == 1) dim++;\n          break;\n        case '>':\n          level--;\n          break;\n      }\n    }\n    if (level != 0 || dim == 0) return ArrayUtil.EMPTY_STRING_ARRAY;\n\n    final String[] result = new String[dim];\n    dim = 0;\n    int ltPos = 0;\n    for (int i = afterLastDotIndex; i < chars.length; i++) {\n      final char aChar = chars[i];\n      switch (aChar) {\n        case '<':\n          level++;\n          if (level == 1) ltPos = i;\n          break;\n        case ',':\n          if (level == 1) {\n            result[dim++] = new String(chars, ltPos + 1, i - ltPos - 1);\n            ltPos = i;\n          }\n          break;\n        case '>':\n          level--;\n          if (level == 0) result[dim++] = new String(chars, ltPos + 1, i - ltPos - 1);\n          break;\n      }\n    }\n\n    return result;\n  }","id":65024,"modified_method":"/**\n   * Obtains text of all type parameter values in a reference.\n   * They go in left-to-right order: <code>A&lt;List&lt;String&gt, B&lt;Integer&gt;&gt;<\/code> yields\n   * <code>[\"List&lt;String&gt\", \"B&lt;Integer&gt;\"]<\/code>. Parameters of the outer reference are ignored:\n   * <code>A&lt;List&lt;String&gt&gt;.B&lt;Integer&gt;<\/code> yields <code>[\"Integer\"]<\/code>\n   *\n   * @param referenceText the text of the reference to calculate type parameters for.\n   * @return the calculated array of type parameters.\n   */\n  @NotNull\n  public static String[] getClassParametersText(@NotNull String referenceText) {\n    if (referenceText.indexOf('<') < 0) return ArrayUtil.EMPTY_STRING_ARRAY;\n    final char[] chars = referenceText.toCharArray();\n    int afterLastDotIndex = 0;\n\n    int level = 0;\n    for (int i = 0; i < chars.length; i++) {\n      char aChar = chars[i];\n      switch (aChar) {\n        case '<':\n          level++;\n          break;\n        case '.':\n          if (level == 0) afterLastDotIndex = i + 1;\n          break;\n        case '>':\n          level--;\n          break;\n      }\n    }\n\n    if (level != 0) return ArrayUtil.EMPTY_STRING_ARRAY;\n\n    int dim = 0;\n    for (int i = afterLastDotIndex; i < chars.length; i++) {\n      char aChar = chars[i];\n      switch (aChar) {\n        case '<':\n          level++;\n          if (level == 1) dim++;\n          break;\n        case ',':\n          if (level == 1) dim++;\n          break;\n        case '>':\n          level--;\n          break;\n      }\n    }\n    if (level != 0 || dim == 0) return ArrayUtil.EMPTY_STRING_ARRAY;\n\n    final String[] result = new String[dim];\n    dim = 0;\n    int ltPos = 0;\n    for (int i = afterLastDotIndex; i < chars.length; i++) {\n      final char aChar = chars[i];\n      switch (aChar) {\n        case '<':\n          level++;\n          if (level == 1) ltPos = i;\n          break;\n        case ',':\n          if (level == 1) {\n            result[dim++] = new String(chars, ltPos + 1, i - ltPos - 1);\n            ltPos = i;\n          }\n          break;\n        case '>':\n          level--;\n          if (level == 0) result[dim++] = new String(chars, ltPos + 1, i - ltPos - 1);\n          break;\n      }\n    }\n\n    return result;\n  }","commit_id":"ffa42cda83c04b475d83837118cead4e595d0e56","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Constructor.\n     */\n    public ImplicitTagLibraryInfo(JspCompilationContext ctxt,\n            ParserController pc,\n            PageInfo pi,\n            String prefix,\n            String tagdir,\n            ErrorDispatcher err) throws JasperException {\n        super(prefix, null);\n        this.pc = pc;\n        this.pi = pi;\n        this.tagFileMap = new Hashtable<>();\n        this.vec = new Vector<>();\n\n        // Implicit tag libraries have no functions:\n        this.functions = new FunctionInfo[0];\n\n        tlibversion = TLIB_VERSION;\n        jspversion = JSP_VERSION;\n\n        if (!tagdir.startsWith(WEB_INF_TAGS)) {\n            err.jspError(\"jsp.error.invalid.tagdir\", tagdir);\n        }\n\n        // Determine the value of the <short-name> subelement of the\n        // \"imaginary\" <taglib> element\n        if (tagdir.equals(WEB_INF_TAGS)\n                || tagdir.equals( WEB_INF_TAGS + \"/\")) {\n            shortname = TAGS_SHORTNAME;\n        } else {\n            shortname = tagdir.substring(WEB_INF_TAGS.length());\n            shortname = shortname.replace('/', '-');\n        }\n\n        // Populate mapping of tag names to tag file paths\n        Set<String> dirList = ctxt.getResourcePaths(tagdir);\n        if (dirList != null) {\n            Iterator<String> it = dirList.iterator();\n            while (it.hasNext()) {\n                String path = it.next();\n                if (path.endsWith(TAG_FILE_SUFFIX)\n                        || path.endsWith(TAGX_FILE_SUFFIX)) {\n                    /*\n                     * Use the filename of the tag file, without the .tag or\n                     * .tagx extension, respectively, as the <name> subelement\n                     * of the \"imaginary\" <tag-file> element\n                     */\n                    String suffix = path.endsWith(TAG_FILE_SUFFIX) ?\n                            TAG_FILE_SUFFIX : TAGX_FILE_SUFFIX;\n                    String tagName = path.substring(path.lastIndexOf(\"/\") + 1);\n                    tagName = tagName.substring(0,\n                            tagName.lastIndexOf(suffix));\n                    tagFileMap.put(tagName, path);\n                } else if (path.endsWith(IMPLICIT_TLD)) {\n                    InputStream in = null;\n                    try {\n                        in = ctxt.getResourceAsStream(path);\n                        if (in != null) {\n\n                            // Add implicit TLD to dependency list\n                            if (pi != null) {\n                                pi.addDependant(path, ctxt.getLastModified(path));\n                            }\n\n                            ParserUtils pu = new ParserUtils();\n                            TreeNode tld = pu.parseXMLDocument(uri, in);\n\n                            if (tld.findAttribute(\"version\") != null) {\n                                this.jspversion = tld.findAttribute(\"version\");\n                            }\n\n                            // Process each child element of our <taglib> element\n                            Iterator<TreeNode> list = tld.findChildren();\n\n                            while (list.hasNext()) {\n                                TreeNode element = list.next();\n                                String tname = element.getName();\n\n                                if (\"tlibversion\".equals(tname) // JSP 1.1\n                                        || \"tlib-version\".equals(tname)) { // JSP 1.2\n                                    this.tlibversion = element.getBody();\n                                } else if (\"jspversion\".equals(tname)\n                                        || \"jsp-version\".equals(tname)) {\n                                    this.jspversion = element.getBody();\n                                } else if (\"shortname\".equals(tname) || \"short-name\".equals(tname)) {\n                                    // Ignore\n                                } else {\n                                    // All other elements are invalid\n                                    err.jspError(\"jsp.error.invalid.implicit\", path);\n                                }\n                            }\n                            try {\n                                double version = Double.parseDouble(this.jspversion);\n                                if (version < 2.0) {\n                                    err.jspError(\"jsp.error.invalid.implicit.version\", path);\n                                }\n                            } catch (NumberFormatException e) {\n                                err.jspError(\"jsp.error.invalid.implicit.version\", path);\n                            }\n                        }\n                    } finally {\n                        if (in != null) {\n                            try {\n                                in.close();\n                            } catch (Throwable t) {\n                                ExceptionUtils.handleThrowable(t);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n    }","id":65025,"modified_method":"/**\n     * Constructor.\n     */\n    public ImplicitTagLibraryInfo(JspCompilationContext ctxt,\n            ParserController pc,\n            PageInfo pi,\n            String prefix,\n            String tagdir,\n            ErrorDispatcher err) throws JasperException {\n        super(prefix, null);\n        this.pc = pc;\n        this.pi = pi;\n        this.tagFileMap = new Hashtable<>();\n        this.vec = new Vector<>();\n\n        // Implicit tag libraries have no functions:\n        this.functions = new FunctionInfo[0];\n\n        tlibversion = TLIB_VERSION;\n        jspversion = JSP_VERSION;\n\n        if (!tagdir.startsWith(WEB_INF_TAGS)) {\n            err.jspError(\"jsp.error.invalid.tagdir\", tagdir);\n        }\n\n        // Determine the value of the <short-name> subelement of the\n        // \"imaginary\" <taglib> element\n        if (tagdir.equals(WEB_INF_TAGS)\n                || tagdir.equals( WEB_INF_TAGS + \"/\")) {\n            shortname = TAGS_SHORTNAME;\n        } else {\n            shortname = tagdir.substring(WEB_INF_TAGS.length());\n            shortname = shortname.replace('/', '-');\n        }\n\n        // Populate mapping of tag names to tag file paths\n        Set<String> dirList = ctxt.getResourcePaths(tagdir);\n        if (dirList != null) {\n            for (String path : dirList) {\n                if (path.endsWith(TAG_FILE_SUFFIX)\n                        || path.endsWith(TAGX_FILE_SUFFIX)) {\n                    /*\n                     * Use the filename of the tag file, without the .tag or\n                     * .tagx extension, respectively, as the <name> subelement\n                     * of the \"imaginary\" <tag-file> element\n                     */\n                    String suffix = path.endsWith(TAG_FILE_SUFFIX) ?\n                            TAG_FILE_SUFFIX : TAGX_FILE_SUFFIX;\n                    String tagName = path.substring(path.lastIndexOf(\"/\") + 1);\n                    tagName = tagName.substring(0,\n                            tagName.lastIndexOf(suffix));\n                    tagFileMap.put(tagName, path);\n                } else if (path.endsWith(IMPLICIT_TLD)) {\n                    TaglibXml taglibXml;\n                    try {\n                        URL url = ctxt.getResource(path);\n                        TldResourcePath resourcePath = new TldResourcePath(url, path);\n                        // TODO enable validation\n                        TldParser parser = new TldParser(true, false, new ImplicitTldRuleSet());\n                        taglibXml = parser.parse(resourcePath);\n                    } catch (IOException | SAXException e) {\n                        err.jspError(e);\n                        // unreached\n                        throw new JasperException(e);\n                    }\n                    this.tlibversion = taglibXml.getTlibVersion();\n                    this.jspversion = taglibXml.getJspVersion();\n                    try {\n                        double version = Double.parseDouble(this.jspversion);\n                        if (version < 2.0) {\n                            err.jspError(\"jsp.error.invalid.implicit.version\", path);\n                        }\n                    } catch (NumberFormatException e) {\n                        err.jspError(\"jsp.error.invalid.implicit.version\", path);\n                    }\n\n                    // Add implicit TLD to dependency list\n                    if (pi != null) {\n                        pi.addDependant(path, ctxt.getLastModified(path));\n                    }\n                }\n            }\n        }\n\n    }","commit_id":"2677272f3bd59e0b10e56a0bf6700782b9d97d65","url":"https://github.com/apache/tomcat"},{"original_method":"public TldParser(boolean namespaceAware, boolean validation) {\n        TldRuleSet ruleSet = new TldRuleSet();\n        digester = DigesterFactory.newDigester(validation, namespaceAware, ruleSet);\n    }","id":65026,"modified_method":"public TldParser(boolean namespaceAware, boolean validation) {\n        this(namespaceAware, validation, new TldRuleSet());\n    }","commit_id":"2677272f3bd59e0b10e56a0bf6700782b9d97d65","url":"https://github.com/apache/tomcat"},{"original_method":"/** \n     * Initializes securitymanager for the environment\n     * Can only happen once!\n     */\n    static void configure(Environment environment) throws IOException {\n        ESLogger log = Loggers.getLogger(Security.class);\n        // init lucene random seed. it will use /dev/urandom where available.\n        StringHelper.randomId();\n        InputStream config = Security.class.getResourceAsStream(POLICY_RESOURCE);\n        if (config == null) {\n            throw new NoSuchFileException(POLICY_RESOURCE);\n        }\n        Path newConfig = processTemplate(config, environment);\n        System.setProperty(\"java.security.policy\", newConfig.toString());\n        System.setSecurityManager(new SecurityManager());\n        try {\n            // don't hide securityexception here, it means java.io.tmpdir is not accessible!\n            Files.delete(newConfig);\n        } catch (SecurityException broken) {\n            log.error(\"unable to properly access temporary files, run with -Djava.security.debug=policy for more information\");\n            throw broken;\n        } catch (IOException ignore) {\n            // e.g. virus scanner on windows\n        }\n    }","id":65027,"modified_method":"/** \n     * Initializes securitymanager for the environment\n     * Can only happen once!\n     */\n    static void configure(Environment environment) throws Exception {\n        // init lucene random seed. it will use /dev/urandom where available:\n        StringHelper.randomId();\n\n        // enable security policy: union of template and environment-based paths.\n        URI template = Security.class.getResource(POLICY_RESOURCE).toURI();\n        Policy.setPolicy(new ESPolicy(template, createPermissions(environment)));\n\n        // enable security manager\n        System.setSecurityManager(new SecurityManager());\n\n        // do some basic tests\n        selfTest();\n    }","commit_id":"86fc8ceac71fbcfe95d6675eeb6b2ffc2cb71d41","url":"https://github.com/elastic/elasticsearch"},{"original_method":"static void addPath(Writer writer, Path path, String permissions) throws IOException {\n        // paths may not exist yet\n        Files.createDirectories(path);\n        // add each path twice: once for itself, again for files underneath it\n        writer.write(\"permission java.io.FilePermission \\\"\" + encode(path) + \"\\\", \\\"\" + permissions + \"\\\";\");\n        writer.write(System.lineSeparator());\n        writer.write(\"permission java.io.FilePermission \\\"\" + encode(path) + \"${/}-\\\", \\\"\" + permissions + \"\\\";\");\n        writer.write(System.lineSeparator());\n    }","id":65028,"modified_method":"/** Add access to path (and all files underneath it */\n    static void addPath(Permissions policy, Path path, String permissions) throws IOException {\n        // paths may not exist yet\n        Files.createDirectories(path);\n        // add each path twice: once for itself, again for files underneath it\n        policy.add(new FilePermission(path.toString(), permissions));\n        policy.add(new FilePermission(path.toString() + path.getFileSystem().getSeparator() + \"-\", permissions));\n    }","commit_id":"86fc8ceac71fbcfe95d6675eeb6b2ffc2cb71d41","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/** test generated permissions for all configured paths */\n    public void testEnvironmentPaths() throws Exception {\n        Path path = createTempDir();\n\n        ImmutableSettings.Builder settingsBuilder = ImmutableSettings.builder();\n        settingsBuilder.put(\"path.home\", path.resolve(\"home\").toString());\n        settingsBuilder.put(\"path.conf\", path.resolve(\"conf\").toString());\n        settingsBuilder.put(\"path.plugins\", path.resolve(\"plugins\").toString());\n        settingsBuilder.putArray(\"path.data\", path.resolve(\"data1\").toString(), path.resolve(\"data2\").toString());\n        settingsBuilder.put(\"path.logs\", path.resolve(\"logs\").toString());\n        Settings settings = settingsBuilder.build();\n\n        Environment environment = new Environment(settings);        \n        Path policyFile = Security.processTemplate(new ByteArrayInputStream(new byte[0]), environment);\n     \n        ProtectionDomain domain = getClass().getProtectionDomain();\n        Policy policy = Policy.getInstance(\"JavaPolicy\", new URIParameter(policyFile.toUri()));\n\n        // check that all directories got permissions:\n        // homefile: this is needed unless we break out rules for \"lib\" dir.\n        // TODO: make read-only\n        assertTrue(policy.implies(domain, new FilePermission(environment.homeFile().toString(), \"read,readlink,write,delete\")));\n        // config file\n        // TODO: make read-only\n        assertTrue(policy.implies(domain, new FilePermission(environment.configFile().toString(), \"read,readlink,write,delete\")));\n        // plugins: r/w, TODO: can this be minimized?\n        assertTrue(policy.implies(domain, new FilePermission(environment.pluginsFile().toString(), \"read,readlink,write,delete\")));\n        // data paths: r/w\n        for (Path dataPath : environment.dataFiles()) {\n            assertTrue(policy.implies(domain, new FilePermission(dataPath.toString(), \"read,readlink,write,delete\")));\n        }\n        for (Path dataPath : environment.dataWithClusterFiles()) {\n            assertTrue(policy.implies(domain, new FilePermission(dataPath.toString(), \"read,readlink,write,delete\")));\n        }\n        // logs: r/w\n        assertTrue(policy.implies(domain, new FilePermission(environment.logsFile().toString(), \"read,readlink,write,delete\")));\n    }","id":65029,"modified_method":"/** test generated permissions for all configured paths */\n    public void testEnvironmentPaths() throws Exception {\n        Path path = createTempDir();\n\n        ImmutableSettings.Builder settingsBuilder = ImmutableSettings.builder();\n        settingsBuilder.put(\"path.home\", path.resolve(\"home\").toString());\n        settingsBuilder.put(\"path.conf\", path.resolve(\"conf\").toString());\n        settingsBuilder.put(\"path.plugins\", path.resolve(\"plugins\").toString());\n        settingsBuilder.putArray(\"path.data\", path.resolve(\"data1\").toString(), path.resolve(\"data2\").toString());\n        settingsBuilder.put(\"path.logs\", path.resolve(\"logs\").toString());\n        Settings settings = settingsBuilder.build();\n\n        Environment environment = new Environment(settings);\n        Permissions permissions = Security.createPermissions(environment);\n\n        // check that all directories got permissions:\n        // homefile: this is needed unless we break out rules for \"lib\" dir.\n        // TODO: make read-only\n        assertTrue(permissions.implies(new FilePermission(environment.homeFile().toString(), \"read,readlink,write,delete\")));\n        // config file\n        // TODO: make read-only\n        assertTrue(permissions.implies(new FilePermission(environment.configFile().toString(), \"read,readlink,write,delete\")));\n        // plugins: r/w, TODO: can this be minimized?\n        assertTrue(permissions.implies(new FilePermission(environment.pluginsFile().toString(), \"read,readlink,write,delete\")));\n        // data paths: r/w\n        for (Path dataPath : environment.dataFiles()) {\n            assertTrue(permissions.implies(new FilePermission(dataPath.toString(), \"read,readlink,write,delete\")));\n        }\n        for (Path dataPath : environment.dataWithClusterFiles()) {\n            assertTrue(permissions.implies(new FilePermission(dataPath.toString(), \"read,readlink,write,delete\")));\n        }\n        // logs: r/w\n        assertTrue(permissions.implies(new FilePermission(environment.logsFile().toString(), \"read,readlink,write,delete\")));\n    }","commit_id":"86fc8ceac71fbcfe95d6675eeb6b2ffc2cb71d41","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/** test generated permissions */\n    public void testGeneratedPermissions() throws Exception {\n        Path path = createTempDir();\n        // make a fake ES home and ensure we only grant permissions to that.\n        Path esHome = path.resolve(\"esHome\");\n        ImmutableSettings.Builder settingsBuilder = ImmutableSettings.builder();\n        settingsBuilder.put(\"path.home\", esHome.toString());\n        Settings settings = settingsBuilder.build();\n\n        Environment environment = new Environment(settings);        \n        Path policyFile = Security.processTemplate(new ByteArrayInputStream(new byte[0]), environment);\n      \n        ProtectionDomain domain = getClass().getProtectionDomain();\n        Policy policy = Policy.getInstance(\"JavaPolicy\", new URIParameter(policyFile.toUri()));\n        // the fake es home\n        assertTrue(policy.implies(domain, new FilePermission(esHome.toString(), \"read\")));\n        // its parent\n        assertFalse(policy.implies(domain, new FilePermission(path.toString(), \"read\")));\n        // some other sibling\n        assertFalse(policy.implies(domain, new FilePermission(path.resolve(\"other\").toString(), \"read\")));\n    }","id":65030,"modified_method":"/** test generated permissions */\n    public void testGeneratedPermissions() throws Exception {\n        Path path = createTempDir();\n        // make a fake ES home and ensure we only grant permissions to that.\n        Path esHome = path.resolve(\"esHome\");\n        ImmutableSettings.Builder settingsBuilder = ImmutableSettings.builder();\n        settingsBuilder.put(\"path.home\", esHome.toString());\n        Settings settings = settingsBuilder.build();\n\n        Environment environment = new Environment(settings);\n        Permissions permissions = Security.createPermissions(environment);\n      \n        // the fake es home\n        assertTrue(permissions.implies(new FilePermission(esHome.toString(), \"read\")));\n        // its parent\n        assertFalse(permissions.implies(new FilePermission(path.toString(), \"read\")));\n        // some other sibling\n        assertFalse(permissions.implies(new FilePermission(path.resolve(\"other\").toString(), \"read\")));\n    }","commit_id":"86fc8ceac71fbcfe95d6675eeb6b2ffc2cb71d41","url":"https://github.com/elastic/elasticsearch"},{"original_method":"protected void test(String file) throws Exception {\n        InputStream in = AbstractQueryTest.class.getResourceAsStream(file);\n        ContinueLineReader r = new ContinueLineReader(new LineNumberReader(new InputStreamReader(in)));\n        String className = getClass().getName();\n        String shortClassName = className.replaceAll(\"org.apache.jackrabbit.oak.plugins.index.\", \"oajopi.\");\n        PrintWriter w = new PrintWriter(new OutputStreamWriter(\n                new FileOutputStream(\"target/\" + shortClassName + \"_\"\n                        + file)));\n        HashSet<String> knownQueries = new HashSet<String>();\n        boolean errors = false;\n        try {\n            while (true) {\n                String line = r.readLine();\n                if (line == null) {\n                    break;\n                }\n                line = line.trim();\n                if (line.startsWith(\"#\") || line.length() == 0) {\n                    w.println(line);\n                } else if (line.startsWith(\"xpath2sql\")) {\n                    line = line.substring(\"xpath2sql\".length()).trim();\n                    w.println(\"xpath2sql \" + line);\n                    XPathToSQL2Converter c = new XPathToSQL2Converter();\n                    String got;\n                    try {\n                        got = c.convert(line);\n                    } catch (ParseException e) {\n                        got = \"invalid: \" + e.getMessage().replace('\\n', ' ');\n                    } catch (Exception e) {\n                        // e.printStackTrace();\n                        got = \"error: \" + e.toString().replace('\\n', ' ');\n                    }\n                    String formatted = formatSQL(got);\n                    if (!knownQueries.add(line)) {\n                        got = \"duplicate xpath2sql query\";\n                    }\n                    line = r.readLine().trim();\n                    w.println(formatted);\n                    if (!line.equals(got) && !line.equals(formatted)) {\n                        errors = true;\n                    }\n                } else if (line.startsWith(\"select\")\n                        || line.startsWith(\"explain\")\n                        || line.startsWith(\"measure\")\n                        || line.startsWith(\"sql1\") || line.startsWith(\"xpath\")) {\n                    w.println(line);\n                    String language = QueryEngineImpl.SQL2;\n                    if (line.startsWith(\"sql1 \")) {\n                        language = QueryEngineImpl.SQL;\n                        line = line.substring(\"sql1 \".length());\n                    } else if (line.startsWith(\"xpath \")) {\n                        language = QueryEngineImpl.XPATH;\n                        line = line.substring(\"xpath \".length());\n                    }\n                    boolean readEnd = true;\n                    for (String resultLine : executeQuery(line, language)) {\n                        w.println(resultLine);\n                        if (readEnd) {\n                            line = r.readLine();\n                            if (line == null) {\n                                errors = true;\n                                readEnd = false;\n                            } else {\n                                line = line.trim();\n                                if (line.length() == 0) {\n                                    errors = true;\n                                    readEnd = false;\n                                } else {\n                                    if (!line.equals(resultLine)) {\n                                        errors = true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    w.println(\"\");\n                    if (readEnd) {\n                        while (true) {\n                            line = r.readLine();\n                            if (line == null) {\n                                break;\n                            }\n                            line = line.trim();\n                            if (line.length() == 0) {\n                                break;\n                            }\n                            errors = true;\n                        }\n                    }\n                } else if (line.startsWith(\"commit\")) {\n                    w.println(line);\n                    line = line.substring(\"commit\".length()).trim();\n                    apply(root, line);\n                    root.commit();\n                }\n                w.flush();\n            }\n        } finally {\n            w.close();\n            r.close();\n        }\n        if (errors) {\n            throw new Exception(\"Results in target/\" + file\n                    + \" don't match expected \"\n                    + \"results in src/test/resources/\" + file\n                    + \"; compare the files for details\");\n        }\n    }","id":65031,"modified_method":"protected void test(String file) throws Exception {\n        String className = getClass().getName();\n        String shortClassName = className.replaceAll(\"org.apache.jackrabbit.oak.plugins.index.\", \"oajopi.\");\n\n        File input = new File(AbstractQueryTest.class.getResource(file).getPath());\n        File output = new File(\"target/\" + shortClassName + \"_\" + file);\n        \n        InputStream in = new FileInputStream(input);\n        ContinueLineReader r = new ContinueLineReader(new LineNumberReader(new InputStreamReader(in)));\n        PrintWriter w = new PrintWriter(new OutputStreamWriter(\n                new FileOutputStream(output)));\n        HashSet<String> knownQueries = new HashSet<String>();\n        boolean errors = false;\n        try {\n            while (true) {\n                String line = r.readLine();\n                if (line == null) {\n                    break;\n                }\n                line = line.trim();\n                if (line.startsWith(\"#\") || line.length() == 0) {\n                    w.println(line);\n                } else if (line.startsWith(\"xpath2sql\")) {\n                    line = line.substring(\"xpath2sql\".length()).trim();\n                    w.println(\"xpath2sql \" + line);\n                    XPathToSQL2Converter c = new XPathToSQL2Converter();\n                    String got;\n                    try {\n                        got = c.convert(line);\n                    } catch (ParseException e) {\n                        got = \"invalid: \" + e.getMessage().replace('\\n', ' ');\n                    } catch (Exception e) {\n                        // e.printStackTrace();\n                        got = \"error: \" + e.toString().replace('\\n', ' ');\n                    }\n                    String formatted = formatSQL(got);\n                    if (!knownQueries.add(line)) {\n                        got = \"duplicate xpath2sql query\";\n                    }\n                    line = r.readLine().trim();\n                    w.println(formatted);\n                    if (!line.equals(got) && !line.equals(formatted)) {\n                        errors = true;\n                    }\n                } else if (line.startsWith(\"select\")\n                        || line.startsWith(\"explain\")\n                        || line.startsWith(\"measure\")\n                        || line.startsWith(\"sql1\") || line.startsWith(\"xpath\")) {\n                    w.println(line);\n                    String language = QueryEngineImpl.SQL2;\n                    if (line.startsWith(\"sql1 \")) {\n                        language = QueryEngineImpl.SQL;\n                        line = line.substring(\"sql1 \".length());\n                    } else if (line.startsWith(\"xpath \")) {\n                        language = QueryEngineImpl.XPATH;\n                        line = line.substring(\"xpath \".length());\n                    }\n                    boolean readEnd = true;\n                    for (String resultLine : executeQuery(line, language)) {\n                        w.println(resultLine);\n                        if (readEnd) {\n                            line = r.readLine();\n                            if (line == null) {\n                                errors = true;\n                                readEnd = false;\n                            } else {\n                                line = line.trim();\n                                if (line.length() == 0) {\n                                    errors = true;\n                                    readEnd = false;\n                                } else {\n                                    if (!line.equals(resultLine)) {\n                                        errors = true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    w.println(\"\");\n                    if (readEnd) {\n                        while (true) {\n                            line = r.readLine();\n                            if (line == null) {\n                                break;\n                            }\n                            line = line.trim();\n                            if (line.length() == 0) {\n                                break;\n                            }\n                            errors = true;\n                        }\n                    }\n                } else if (line.startsWith(\"commit\")) {\n                    w.println(line);\n                    line = line.substring(\"commit\".length()).trim();\n                    apply(root, line);\n                    root.commit();\n                }\n                w.flush();\n            }\n        } finally {\n            w.close();\n            r.close();\n        }\n        if (errors) {\n            throw new Exception(\"Results in \" + output.getPath()\n                    + \" don't match expected \"\n                    + \"results in \" + input.getPath()\n                    + \"; compare the files for details\");\n        }\n    }","commit_id":"9faa368b263c0f146a0dbb740804ee0df41ffdc9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n  public void getMetrics(MetricsCollector metricsCollector, boolean all) {\n    MetricsRecordBuilder mrb = metricsCollector.addRecord(metricsName)\n        .setContext(metricsContext);\n\n    if (wrapper != null) {\n      mrb.addGauge(Interns.info(QUEUE_SIZE_NAME, QUEUE_SIZE_DESC), wrapper.getTotalQueueSize())\n          .addGauge(Interns.info(GENERAL_QUEUE_NAME, GENERAL_QUEUE_DESC),\n              wrapper.getGeneralQueueLength())\n          .addGauge(Interns.info(REPLICATION_QUEUE_NAME,\n              REPLICATION_QUEUE_DESC), wrapper.getReplicationQueueLength())\n          .addGauge(Interns.info(PRIORITY_QUEUE_NAME, PRIORITY_QUEUE_DESC),\n              wrapper.getPriorityQueueLength())\n          .addGauge(Interns.info(NUM_OPEN_CONNECTIONS_NAME,\n              NUM_OPEN_CONNECTIONS_DESC), wrapper.getNumOpenConnections())\n          .addGauge(Interns.info(NUM_ACTIVE_HANDLER_NAME,\n              NUM_ACTIVE_HANDLER_DESC), wrapper.getActiveRpcHandlerCount());\n    }\n\n    metricsRegistry.snapshot(mrb, all);\n  }","id":65032,"modified_method":"@Override\n  public void getMetrics(MetricsCollector metricsCollector, boolean all) {\n    MetricsRecordBuilder mrb = metricsCollector.addRecord(metricsName);\n\n    if (wrapper != null) {\n      mrb.addGauge(Interns.info(QUEUE_SIZE_NAME, QUEUE_SIZE_DESC), wrapper.getTotalQueueSize())\n          .addGauge(Interns.info(GENERAL_QUEUE_NAME, GENERAL_QUEUE_DESC),\n              wrapper.getGeneralQueueLength())\n          .addGauge(Interns.info(REPLICATION_QUEUE_NAME,\n              REPLICATION_QUEUE_DESC), wrapper.getReplicationQueueLength())\n          .addGauge(Interns.info(PRIORITY_QUEUE_NAME, PRIORITY_QUEUE_DESC),\n              wrapper.getPriorityQueueLength())\n          .addGauge(Interns.info(NUM_OPEN_CONNECTIONS_NAME,\n              NUM_OPEN_CONNECTIONS_DESC), wrapper.getNumOpenConnections())\n          .addGauge(Interns.info(NUM_ACTIVE_HANDLER_NAME,\n              NUM_ACTIVE_HANDLER_DESC), wrapper.getActiveRpcHandlerCount());\n    }\n\n    metricsRegistry.snapshot(mrb, all);\n  }","commit_id":"cecc475d2f194eed67edf16cd84fbf9716b8d5c5","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n  public void getMetrics(MetricsCollector metricsCollector, boolean all) {\n\n    MetricsRecordBuilder metricsRecordBuilder = metricsCollector.addRecord(metricsName)\n        .setContext(metricsContext);\n\n    // masterWrapper can be null because this function is called inside of init.\n    if (masterWrapper != null) {\n      metricsRecordBuilder\n          .addGauge(Interns.info(MASTER_ACTIVE_TIME_NAME,\n              MASTER_ACTIVE_TIME_DESC), masterWrapper.getActiveTime())\n          .addGauge(Interns.info(MASTER_START_TIME_NAME,\n              MASTER_START_TIME_DESC), masterWrapper.getStartTime())\n          .addGauge(Interns.info(AVERAGE_LOAD_NAME, AVERAGE_LOAD_DESC),\n              masterWrapper.getAverageLoad())\n          .tag(Interns.info(LIVE_REGION_SERVERS_NAME, LIVE_REGION_SERVERS_DESC),\n                masterWrapper.getRegionServers())\n          .addGauge(Interns.info(NUM_REGION_SERVERS_NAME,\n              NUMBER_OF_REGION_SERVERS_DESC), masterWrapper.getNumRegionServers())\n          .tag(Interns.info(DEAD_REGION_SERVERS_NAME, DEAD_REGION_SERVERS_DESC),\n                masterWrapper.getDeadRegionServers())\n          .addGauge(Interns.info(NUM_DEAD_REGION_SERVERS_NAME,\n              NUMBER_OF_DEAD_REGION_SERVERS_DESC),\n              masterWrapper.getNumDeadRegionServers())\n          .tag(Interns.info(ZOOKEEPER_QUORUM_NAME, ZOOKEEPER_QUORUM_DESC),\n              masterWrapper.getZookeeperQuorum())\n          .tag(Interns.info(SERVER_NAME_NAME, SERVER_NAME_DESC), masterWrapper.getServerName())\n          .tag(Interns.info(CLUSTER_ID_NAME, CLUSTER_ID_DESC), masterWrapper.getClusterId())\n          .tag(Interns.info(IS_ACTIVE_MASTER_NAME,\n              IS_ACTIVE_MASTER_DESC),\n              String.valueOf(masterWrapper.getIsActiveMaster()));\n    }\n\n    metricsRegistry.snapshot(metricsRecordBuilder, all);\n  }","id":65033,"modified_method":"@Override\n  public void getMetrics(MetricsCollector metricsCollector, boolean all) {\n\n    MetricsRecordBuilder metricsRecordBuilder = metricsCollector.addRecord(metricsName);\n\n    // masterWrapper can be null because this function is called inside of init.\n    if (masterWrapper != null) {\n      metricsRecordBuilder\n          .addGauge(Interns.info(MASTER_ACTIVE_TIME_NAME,\n              MASTER_ACTIVE_TIME_DESC), masterWrapper.getActiveTime())\n          .addGauge(Interns.info(MASTER_START_TIME_NAME,\n              MASTER_START_TIME_DESC), masterWrapper.getStartTime())\n          .addGauge(Interns.info(AVERAGE_LOAD_NAME, AVERAGE_LOAD_DESC),\n              masterWrapper.getAverageLoad())\n          .tag(Interns.info(LIVE_REGION_SERVERS_NAME, LIVE_REGION_SERVERS_DESC),\n                masterWrapper.getRegionServers())\n          .addGauge(Interns.info(NUM_REGION_SERVERS_NAME,\n              NUMBER_OF_REGION_SERVERS_DESC), masterWrapper.getNumRegionServers())\n          .tag(Interns.info(DEAD_REGION_SERVERS_NAME, DEAD_REGION_SERVERS_DESC),\n                masterWrapper.getDeadRegionServers())\n          .addGauge(Interns.info(NUM_DEAD_REGION_SERVERS_NAME,\n              NUMBER_OF_DEAD_REGION_SERVERS_DESC),\n              masterWrapper.getNumDeadRegionServers())\n          .tag(Interns.info(ZOOKEEPER_QUORUM_NAME, ZOOKEEPER_QUORUM_DESC),\n              masterWrapper.getZookeeperQuorum())\n          .tag(Interns.info(SERVER_NAME_NAME, SERVER_NAME_DESC), masterWrapper.getServerName())\n          .tag(Interns.info(CLUSTER_ID_NAME, CLUSTER_ID_DESC), masterWrapper.getClusterId())\n          .tag(Interns.info(IS_ACTIVE_MASTER_NAME,\n              IS_ACTIVE_MASTER_DESC),\n              String.valueOf(masterWrapper.getIsActiveMaster()));\n    }\n\n    metricsRegistry.snapshot(metricsRecordBuilder, all);\n  }","commit_id":"cecc475d2f194eed67edf16cd84fbf9716b8d5c5","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Yes this is a get function that doesn't return anything.  Thanks Hadoop for breaking all\n   * expectations of java programmers.  Instead of returning anything Hadoop metrics expects\n   * getMetrics to push the metrics into the collector.\n   *\n   * @param collector the collector\n   * @param all       get all the metrics regardless of when they last changed.\n   */\n  @Override\n  public void getMetrics(MetricsCollector collector, boolean all) {\n\n\n    MetricsRecordBuilder mrb = collector.addRecord(metricsName)\n        .setContext(metricsContext);\n\n    if (regionSources != null) {\n      lock.readLock().lock();\n      try {\n        for (MetricsRegionSourceImpl regionMetricSource : regionSources) {\n          regionMetricSource.snapshot(mrb, all);\n        }\n      } finally {\n        lock.readLock().unlock();\n      }\n    }\n\n    metricsRegistry.snapshot(mrb, all);\n  }","id":65034,"modified_method":"/**\n   * Yes this is a get function that doesn't return anything.  Thanks Hadoop for breaking all\n   * expectations of java programmers.  Instead of returning anything Hadoop metrics expects\n   * getMetrics to push the metrics into the collector.\n   *\n   * @param collector the collector\n   * @param all       get all the metrics regardless of when they last changed.\n   */\n  @Override\n  public void getMetrics(MetricsCollector collector, boolean all) {\n\n\n    MetricsRecordBuilder mrb = collector.addRecord(metricsName);\n\n    if (regionSources != null) {\n      lock.readLock().lock();\n      try {\n        for (MetricsRegionSourceImpl regionMetricSource : regionSources) {\n          regionMetricSource.snapshot(mrb, all);\n        }\n      } finally {\n        lock.readLock().unlock();\n      }\n    }\n\n    metricsRegistry.snapshot(mrb, all);\n  }","commit_id":"cecc475d2f194eed67edf16cd84fbf9716b8d5c5","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Yes this is a get function that doesn't return anything.  Thanks Hadoop for breaking all\n   * expectations of java programmers.  Instead of returning anything Hadoop metrics expects\n   * getMetrics to push the metrics into the collector.\n   *\n   * @param metricsCollector Collector to accept metrics\n   * @param all              push all or only changed?\n   */\n  @Override\n  public void getMetrics(MetricsCollector metricsCollector, boolean all) {\n\n    MetricsRecordBuilder mrb = metricsCollector.addRecord(metricsName)\n        .setContext(metricsContext);\n\n    // rsWrap can be null because this function is called inside of init.\n    if (rsWrap != null) {\n      mrb.addGauge(Interns.info(REGION_COUNT, REGION_COUNT_DESC), rsWrap.getNumOnlineRegions())\n          .addGauge(Interns.info(STORE_COUNT, STORE_COUNT_DESC), rsWrap.getNumStores())\n          .addGauge(Interns.info(WALFILE_COUNT, WALFILE_COUNT_DESC), rsWrap.getNumWALFiles())\n          .addGauge(Interns.info(WALFILE_SIZE, WALFILE_SIZE_DESC), rsWrap.getWALFileSize())\n          .addGauge(Interns.info(STOREFILE_COUNT, STOREFILE_COUNT_DESC), rsWrap.getNumStoreFiles())\n          .addGauge(Interns.info(MEMSTORE_SIZE, MEMSTORE_SIZE_DESC), rsWrap.getMemstoreSize())\n          .addGauge(Interns.info(STOREFILE_SIZE, STOREFILE_SIZE_DESC), rsWrap.getStoreFileSize())\n          .addGauge(Interns.info(RS_START_TIME_NAME, RS_START_TIME_DESC),\n              rsWrap.getStartCode())\n          .addCounter(Interns.info(TOTAL_REQUEST_COUNT, TOTAL_REQUEST_COUNT_DESC),\n              rsWrap.getTotalRequestCount())\n          .addCounter(Interns.info(READ_REQUEST_COUNT, READ_REQUEST_COUNT_DESC),\n              rsWrap.getReadRequestsCount())\n          .addCounter(Interns.info(WRITE_REQUEST_COUNT, WRITE_REQUEST_COUNT_DESC),\n              rsWrap.getWriteRequestsCount())\n          .addCounter(Interns.info(CHECK_MUTATE_FAILED_COUNT, CHECK_MUTATE_FAILED_COUNT_DESC),\n              rsWrap.getCheckAndMutateChecksFailed())\n          .addCounter(Interns.info(CHECK_MUTATE_PASSED_COUNT, CHECK_MUTATE_PASSED_COUNT_DESC),\n              rsWrap.getCheckAndMutateChecksPassed())\n          .addGauge(Interns.info(STOREFILE_INDEX_SIZE, STOREFILE_INDEX_SIZE_DESC),\n              rsWrap.getStoreFileIndexSize())\n          .addGauge(Interns.info(STATIC_INDEX_SIZE, STATIC_INDEX_SIZE_DESC),\n              rsWrap.getTotalStaticIndexSize())\n          .addGauge(Interns.info(STATIC_BLOOM_SIZE, STATIC_BLOOM_SIZE_DESC),\n            rsWrap.getTotalStaticBloomSize())\n          .addGauge(\n            Interns.info(NUMBER_OF_MUTATIONS_WITHOUT_WAL, NUMBER_OF_MUTATIONS_WITHOUT_WAL_DESC),\n              rsWrap.getNumMutationsWithoutWAL())\n          .addGauge(Interns.info(DATA_SIZE_WITHOUT_WAL, DATA_SIZE_WITHOUT_WAL_DESC),\n              rsWrap.getDataInMemoryWithoutWAL())\n          .addGauge(Interns.info(PERCENT_FILES_LOCAL, PERCENT_FILES_LOCAL_DESC),\n              rsWrap.getPercentFileLocal())\n          .addGauge(Interns.info(SPLIT_QUEUE_LENGTH, SPLIT_QUEUE_LENGTH_DESC),\n              rsWrap.getSplitQueueSize())\n          .addGauge(Interns.info(COMPACTION_QUEUE_LENGTH, COMPACTION_QUEUE_LENGTH_DESC),\n              rsWrap.getCompactionQueueSize())\n          .addGauge(Interns.info(FLUSH_QUEUE_LENGTH, FLUSH_QUEUE_LENGTH_DESC),\n              rsWrap.getFlushQueueSize())\n          .addGauge(Interns.info(BLOCK_CACHE_FREE_SIZE, BLOCK_CACHE_FREE_DESC),\n              rsWrap.getBlockCacheFreeSize())\n          .addGauge(Interns.info(BLOCK_CACHE_COUNT, BLOCK_CACHE_COUNT_DESC),\n              rsWrap.getBlockCacheCount())\n          .addGauge(Interns.info(BLOCK_CACHE_SIZE, BLOCK_CACHE_SIZE_DESC),\n              rsWrap.getBlockCacheSize())\n          .addCounter(Interns.info(BLOCK_CACHE_HIT_COUNT, BLOCK_CACHE_HIT_COUNT_DESC),\n              rsWrap.getBlockCacheHitCount())\n          .addCounter(Interns.info(BLOCK_CACHE_MISS_COUNT, BLOCK_COUNT_MISS_COUNT_DESC),\n              rsWrap.getBlockCacheMissCount())\n          .addCounter(Interns.info(BLOCK_CACHE_EVICTION_COUNT, BLOCK_CACHE_EVICTION_COUNT_DESC),\n              rsWrap.getBlockCacheEvictedCount())\n          .addGauge(Interns.info(BLOCK_CACHE_HIT_PERCENT, BLOCK_CACHE_HIT_PERCENT_DESC),\n              rsWrap.getBlockCacheHitPercent())\n          .addGauge(Interns.info(BLOCK_CACHE_EXPRESS_HIT_PERCENT,\n              BLOCK_CACHE_EXPRESS_HIT_PERCENT_DESC), rsWrap.getBlockCacheHitCachingPercent())\n          .addCounter(Interns.info(UPDATES_BLOCKED_TIME, UPDATES_BLOCKED_DESC),\n              rsWrap.getUpdatesBlockedTime())\n          .addCounter(Interns.info(FLUSHED_CELLS, FLUSHED_CELLS_DESC),\n              rsWrap.getFlushedCellsCount())\n          .addCounter(Interns.info(COMPACTED_CELLS, COMPACTED_CELLS_DESC),\n              rsWrap.getCompactedCellsCount())\n          .addCounter(Interns.info(MAJOR_COMPACTED_CELLS, MAJOR_COMPACTED_CELLS_DESC),\n              rsWrap.getMajorCompactedCellsCount())\n          .addCounter(Interns.info(FLUSHED_CELLS_SIZE, FLUSHED_CELLS_SIZE_DESC),\n              rsWrap.getFlushedCellsSize())\n          .addCounter(Interns.info(COMPACTED_CELLS_SIZE, COMPACTED_CELLS_SIZE_DESC),\n              rsWrap.getCompactedCellsSize())\n          .addCounter(Interns.info(MAJOR_COMPACTED_CELLS_SIZE, MAJOR_COMPACTED_CELLS_SIZE_DESC),\n              rsWrap.getMajorCompactedCellsSize())\n\n          .addCounter(Interns.info(HEDGED_READS, HEDGED_READS_DESC), rsWrap.getHedgedReadOps())\n          .addCounter(Interns.info(HEDGED_READ_WINS, HEDGED_READ_WINS_DESC),\n              rsWrap.getHedgedReadWins())\n\n          .addCounter(Interns.info(BLOCKED_REQUESTS_COUNT, BLOCKED_REQUESTS_COUNT_DESC),\n            rsWrap.getBlockedRequestsCount())\n\n          .tag(Interns.info(ZOOKEEPER_QUORUM_NAME, ZOOKEEPER_QUORUM_DESC),\n              rsWrap.getZookeeperQuorum())\n          .tag(Interns.info(SERVER_NAME_NAME, SERVER_NAME_DESC), rsWrap.getServerName())\n          .tag(Interns.info(CLUSTER_ID_NAME, CLUSTER_ID_DESC), rsWrap.getClusterId());\n    }\n\n    metricsRegistry.snapshot(mrb, all);\n  }","id":65035,"modified_method":"/**\n   * Yes this is a get function that doesn't return anything.  Thanks Hadoop for breaking all\n   * expectations of java programmers.  Instead of returning anything Hadoop metrics expects\n   * getMetrics to push the metrics into the collector.\n   *\n   * @param metricsCollector Collector to accept metrics\n   * @param all              push all or only changed?\n   */\n  @Override\n  public void getMetrics(MetricsCollector metricsCollector, boolean all) {\n\n    MetricsRecordBuilder mrb = metricsCollector.addRecord(metricsName);\n\n    // rsWrap can be null because this function is called inside of init.\n    if (rsWrap != null) {\n      mrb.addGauge(Interns.info(REGION_COUNT, REGION_COUNT_DESC), rsWrap.getNumOnlineRegions())\n          .addGauge(Interns.info(STORE_COUNT, STORE_COUNT_DESC), rsWrap.getNumStores())\n          .addGauge(Interns.info(WALFILE_COUNT, WALFILE_COUNT_DESC), rsWrap.getNumWALFiles())\n          .addGauge(Interns.info(WALFILE_SIZE, WALFILE_SIZE_DESC), rsWrap.getWALFileSize())\n          .addGauge(Interns.info(STOREFILE_COUNT, STOREFILE_COUNT_DESC), rsWrap.getNumStoreFiles())\n          .addGauge(Interns.info(MEMSTORE_SIZE, MEMSTORE_SIZE_DESC), rsWrap.getMemstoreSize())\n          .addGauge(Interns.info(STOREFILE_SIZE, STOREFILE_SIZE_DESC), rsWrap.getStoreFileSize())\n          .addGauge(Interns.info(RS_START_TIME_NAME, RS_START_TIME_DESC),\n              rsWrap.getStartCode())\n          .addCounter(Interns.info(TOTAL_REQUEST_COUNT, TOTAL_REQUEST_COUNT_DESC),\n              rsWrap.getTotalRequestCount())\n          .addCounter(Interns.info(READ_REQUEST_COUNT, READ_REQUEST_COUNT_DESC),\n              rsWrap.getReadRequestsCount())\n          .addCounter(Interns.info(WRITE_REQUEST_COUNT, WRITE_REQUEST_COUNT_DESC),\n              rsWrap.getWriteRequestsCount())\n          .addCounter(Interns.info(CHECK_MUTATE_FAILED_COUNT, CHECK_MUTATE_FAILED_COUNT_DESC),\n              rsWrap.getCheckAndMutateChecksFailed())\n          .addCounter(Interns.info(CHECK_MUTATE_PASSED_COUNT, CHECK_MUTATE_PASSED_COUNT_DESC),\n              rsWrap.getCheckAndMutateChecksPassed())\n          .addGauge(Interns.info(STOREFILE_INDEX_SIZE, STOREFILE_INDEX_SIZE_DESC),\n              rsWrap.getStoreFileIndexSize())\n          .addGauge(Interns.info(STATIC_INDEX_SIZE, STATIC_INDEX_SIZE_DESC),\n              rsWrap.getTotalStaticIndexSize())\n          .addGauge(Interns.info(STATIC_BLOOM_SIZE, STATIC_BLOOM_SIZE_DESC),\n            rsWrap.getTotalStaticBloomSize())\n          .addGauge(\n            Interns.info(NUMBER_OF_MUTATIONS_WITHOUT_WAL, NUMBER_OF_MUTATIONS_WITHOUT_WAL_DESC),\n              rsWrap.getNumMutationsWithoutWAL())\n          .addGauge(Interns.info(DATA_SIZE_WITHOUT_WAL, DATA_SIZE_WITHOUT_WAL_DESC),\n              rsWrap.getDataInMemoryWithoutWAL())\n          .addGauge(Interns.info(PERCENT_FILES_LOCAL, PERCENT_FILES_LOCAL_DESC),\n              rsWrap.getPercentFileLocal())\n          .addGauge(Interns.info(SPLIT_QUEUE_LENGTH, SPLIT_QUEUE_LENGTH_DESC),\n              rsWrap.getSplitQueueSize())\n          .addGauge(Interns.info(COMPACTION_QUEUE_LENGTH, COMPACTION_QUEUE_LENGTH_DESC),\n              rsWrap.getCompactionQueueSize())\n          .addGauge(Interns.info(FLUSH_QUEUE_LENGTH, FLUSH_QUEUE_LENGTH_DESC),\n              rsWrap.getFlushQueueSize())\n          .addGauge(Interns.info(BLOCK_CACHE_FREE_SIZE, BLOCK_CACHE_FREE_DESC),\n              rsWrap.getBlockCacheFreeSize())\n          .addGauge(Interns.info(BLOCK_CACHE_COUNT, BLOCK_CACHE_COUNT_DESC),\n              rsWrap.getBlockCacheCount())\n          .addGauge(Interns.info(BLOCK_CACHE_SIZE, BLOCK_CACHE_SIZE_DESC),\n              rsWrap.getBlockCacheSize())\n          .addCounter(Interns.info(BLOCK_CACHE_HIT_COUNT, BLOCK_CACHE_HIT_COUNT_DESC),\n              rsWrap.getBlockCacheHitCount())\n          .addCounter(Interns.info(BLOCK_CACHE_MISS_COUNT, BLOCK_COUNT_MISS_COUNT_DESC),\n              rsWrap.getBlockCacheMissCount())\n          .addCounter(Interns.info(BLOCK_CACHE_EVICTION_COUNT, BLOCK_CACHE_EVICTION_COUNT_DESC),\n              rsWrap.getBlockCacheEvictedCount())\n          .addGauge(Interns.info(BLOCK_CACHE_HIT_PERCENT, BLOCK_CACHE_HIT_PERCENT_DESC),\n              rsWrap.getBlockCacheHitPercent())\n          .addGauge(Interns.info(BLOCK_CACHE_EXPRESS_HIT_PERCENT,\n              BLOCK_CACHE_EXPRESS_HIT_PERCENT_DESC), rsWrap.getBlockCacheHitCachingPercent())\n          .addCounter(Interns.info(UPDATES_BLOCKED_TIME, UPDATES_BLOCKED_DESC),\n              rsWrap.getUpdatesBlockedTime())\n          .addCounter(Interns.info(FLUSHED_CELLS, FLUSHED_CELLS_DESC),\n              rsWrap.getFlushedCellsCount())\n          .addCounter(Interns.info(COMPACTED_CELLS, COMPACTED_CELLS_DESC),\n              rsWrap.getCompactedCellsCount())\n          .addCounter(Interns.info(MAJOR_COMPACTED_CELLS, MAJOR_COMPACTED_CELLS_DESC),\n              rsWrap.getMajorCompactedCellsCount())\n          .addCounter(Interns.info(FLUSHED_CELLS_SIZE, FLUSHED_CELLS_SIZE_DESC),\n              rsWrap.getFlushedCellsSize())\n          .addCounter(Interns.info(COMPACTED_CELLS_SIZE, COMPACTED_CELLS_SIZE_DESC),\n              rsWrap.getCompactedCellsSize())\n          .addCounter(Interns.info(MAJOR_COMPACTED_CELLS_SIZE, MAJOR_COMPACTED_CELLS_SIZE_DESC),\n              rsWrap.getMajorCompactedCellsSize())\n\n          .addCounter(Interns.info(HEDGED_READS, HEDGED_READS_DESC), rsWrap.getHedgedReadOps())\n          .addCounter(Interns.info(HEDGED_READ_WINS, HEDGED_READ_WINS_DESC),\n              rsWrap.getHedgedReadWins())\n\n          .addCounter(Interns.info(BLOCKED_REQUESTS_COUNT, BLOCKED_REQUESTS_COUNT_DESC),\n            rsWrap.getBlockedRequestsCount())\n\n          .tag(Interns.info(ZOOKEEPER_QUORUM_NAME, ZOOKEEPER_QUORUM_DESC),\n              rsWrap.getZookeeperQuorum())\n          .tag(Interns.info(SERVER_NAME_NAME, SERVER_NAME_DESC), rsWrap.getServerName())\n          .tag(Interns.info(CLUSTER_ID_NAME, CLUSTER_ID_DESC), rsWrap.getClusterId());\n    }\n\n    metricsRegistry.snapshot(mrb, all);\n  }","commit_id":"cecc475d2f194eed67edf16cd84fbf9716b8d5c5","url":"https://github.com/apache/hbase"},{"original_method":"public DLFileEntry moveFileEntry(\n\t\t\tlong userId, long groupId, long folderId, long newFolderId,\n\t\t\tString name, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tDate now = new Date();\n\n\t\tDLFileEntry fileEntry = dlFileEntryPersistence.findByG_F_N(\n\t\t\tgroupId, folderId, name);\n\n\t\tlong oldFileEntryId = fileEntry.getFileEntryId();\n\n\t\tif (dlLocalService.hasFile(\n\t\t\t\tuser.getCompanyId(),\n\t\t\t\tDLFileEntryImpl.getRepositoryId(groupId, newFolderId), name,\n\t\t\t\tStringPool.BLANK)) {\n\n\t\t\tthrow new DuplicateFileException(name);\n\t\t}\n\n\t\tlong newFileEntryId = counterLocalService.increment();\n\n\t\tDLFileEntry newFileEntry = dlFileEntryPersistence.create(\n\t\t\tnewFileEntryId);\n\n\t\tnewFileEntry.setGroupId(fileEntry.getGroupId());\n\t\tnewFileEntry.setCompanyId(fileEntry.getCompanyId());\n\t\tnewFileEntry.setUserId(fileEntry.getUserId());\n\t\tnewFileEntry.setUserName(fileEntry.getUserName());\n\t\tnewFileEntry.setVersionUserId(fileEntry.getVersionUserId());\n\t\tnewFileEntry.setVersionUserName(fileEntry.getVersionUserName());\n\t\tnewFileEntry.setCreateDate(fileEntry.getCreateDate());\n\t\tnewFileEntry.setModifiedDate(fileEntry.getModifiedDate());\n\t\tnewFileEntry.setFolderId(newFolderId);\n\t\tnewFileEntry.setName(name);\n\t\tnewFileEntry.setExtension(fileEntry.getExtension());\n\t\tnewFileEntry.setTitle(fileEntry.getTitle());\n\t\tnewFileEntry.setDescription(fileEntry.getDescription());\n\t\tnewFileEntry.setExtraSettings(fileEntry.getExtraSettings());\n\t\tnewFileEntry.setVersion(fileEntry.getVersion());\n\t\tnewFileEntry.setSize(fileEntry.getSize());\n\t\tnewFileEntry.setReadCount(fileEntry.getReadCount());\n\n\t\tdlFileEntryPersistence.update(newFileEntry, false);\n\n\t\tdlFileEntryPersistence.remove(fileEntry);\n\n\t\tworkflowInstanceLinkLocalService.updateClassPK(\n\t\t\tfileEntry.getCompanyId(), fileEntry.getGroupId(),\n\t\t\tDLFileEntry.class.getName(), oldFileEntryId, newFileEntryId);\n\n\t\tList<DLFileVersion> fileVersions =\n\t\t\tdlFileVersionPersistence.findByFileEntryId(\n\t\t\t\t\toldFileEntryId);\n\n\t\tfor (DLFileVersion fileVersion : fileVersions) {\n\t\t\tlong newFileVersionId = counterLocalService.increment();\n\n\t\t\tDLFileVersion newFileVersion = dlFileVersionPersistence.create(\n\t\t\t\tnewFileVersionId);\n\n\t\t\tnewFileVersion.setCompanyId(fileVersion.getCompanyId());\n\t\t\tnewFileVersion.setUserId(fileVersion.getUserId());\n\t\t\tnewFileVersion.setUserName(fileVersion.getUserName());\n\t\t\tnewFileVersion.setCreateDate(fileVersion.getCreateDate());\n\t\t\tnewFileVersion.setFileEntryId(newFileEntryId);\n\t\t\tnewFileVersion.setExtension(fileVersion.getExtension());\n\t\t\tnewFileVersion.setTitle(fileVersion.getTitle());\n\t\t\tnewFileVersion.setDescription(fileVersion.getDescription());\n\t\t\tnewFileVersion.setChangeLog(fileVersion.getChangeLog());\n\t\t\tnewFileVersion.setExtraSettings(fileVersion.getExtraSettings());\n\t\t\tnewFileVersion.setVersion(fileVersion.getVersion());\n\t\t\tnewFileVersion.setSize(fileVersion.getSize());\n\t\t\tnewFileVersion.setStatus(fileVersion.getStatus());\n\t\t\tnewFileVersion.setStatusByUserId(userId);\n\t\t\tnewFileVersion.setStatusByUserName(user.getFullName());\n\t\t\tnewFileVersion.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\t\tdlFileVersionPersistence.update(newFileVersion, false);\n\n\t\t\tdlFileVersionPersistence.remove(fileVersion);\n\t\t}\n\n\t\t// Resources\n\n\t\tresourceLocalService.updateResources(\n\t\t\tfileEntry.getCompanyId(), DLFileEntry.class.getName(),\n\t\t\tResourceConstants.SCOPE_INDIVIDUAL,\n\t\t\tString.valueOf(fileEntry.getFileEntryId()),\n\t\t\tString.valueOf(newFileEntryId));\n\n\t\t// Expando\n\n\t\texpandoValueLocalService.deleteValues(\n\t\t\tDLFileEntry.class.getName(), fileEntry.getFileEntryId());\n\n\t\t// DLApp\n\n\t\tdlAppHelperLocalService.moveFileEntry(\n\t\t\tuserId, groupId, folderId, newFolderId, oldFileEntryId,\n\t\t\tnewFileEntryId, name);\n\n\t\t// File\n\n\t\tdlLocalService.updateFile(\n\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\tnewFileEntry.getGroupId(), fileEntry.getRepositoryId(),\n\t\t\tnewFileEntry.getRepositoryId(), name, newFileEntryId);\n\n\t\treturn newFileEntry;\n\t}","id":65036,"modified_method":"public DLFileEntry moveFileEntry(\n\t\t\tlong userId, long groupId, long folderId, long newFolderId,\n\t\t\tString name, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tDate now = new Date();\n\n\t\tDLFileEntry fileEntry = dlFileEntryPersistence.findByG_F_N(\n\t\t\tgroupId, folderId, name);\n\n\t\tlong oldFileEntryId = fileEntry.getFileEntryId();\n\n\t\tif (dlLocalService.hasFile(\n\t\t\t\tuser.getCompanyId(),\n\t\t\t\tDLFileEntryImpl.getRepositoryId(groupId, newFolderId), name,\n\t\t\t\tStringPool.BLANK)) {\n\n\t\t\tthrow new DuplicateFileException(name);\n\t\t}\n\n\t\tlong newFileEntryId = counterLocalService.increment();\n\n\t\tDLFileEntry newFileEntry = dlFileEntryPersistence.create(\n\t\t\tnewFileEntryId);\n\n\t\tnewFileEntry.setGroupId(fileEntry.getGroupId());\n\t\tnewFileEntry.setCompanyId(fileEntry.getCompanyId());\n\t\tnewFileEntry.setUserId(fileEntry.getUserId());\n\t\tnewFileEntry.setUserName(fileEntry.getUserName());\n\t\tnewFileEntry.setVersionUserId(fileEntry.getVersionUserId());\n\t\tnewFileEntry.setVersionUserName(fileEntry.getVersionUserName());\n\t\tnewFileEntry.setCreateDate(fileEntry.getCreateDate());\n\t\tnewFileEntry.setModifiedDate(fileEntry.getModifiedDate());\n\t\tnewFileEntry.setFolderId(newFolderId);\n\t\tnewFileEntry.setName(name);\n\t\tnewFileEntry.setExtension(fileEntry.getExtension());\n\t\tnewFileEntry.setTitle(fileEntry.getTitle());\n\t\tnewFileEntry.setDescription(fileEntry.getDescription());\n\t\tnewFileEntry.setExtraSettings(fileEntry.getExtraSettings());\n\t\tnewFileEntry.setVersion(fileEntry.getVersion());\n\t\tnewFileEntry.setSize(fileEntry.getSize());\n\t\tnewFileEntry.setReadCount(fileEntry.getReadCount());\n\n\t\tdlFileEntryPersistence.update(newFileEntry, false);\n\n\t\tdlFileEntryPersistence.remove(fileEntry);\n\n\t\tworkflowInstanceLinkLocalService.updateClassPK(\n\t\t\tfileEntry.getCompanyId(), fileEntry.getGroupId(),\n\t\t\tDLFileEntry.class.getName(), oldFileEntryId, newFileEntryId);\n\n\t\tList<DLFileVersion> fileVersions =\n\t\t\tdlFileVersionPersistence.findByFileEntryId(oldFileEntryId);\n\n\t\tfor (DLFileVersion fileVersion : fileVersions) {\n\t\t\tlong newFileVersionId = counterLocalService.increment();\n\n\t\t\tDLFileVersion newFileVersion = dlFileVersionPersistence.create(\n\t\t\t\tnewFileVersionId);\n\n\t\t\tnewFileVersion.setGroupId(fileVersion.getGroupId());\n\t\t\tnewFileVersion.setCompanyId(fileVersion.getCompanyId());\n\t\t\tnewFileVersion.setUserId(fileVersion.getUserId());\n\t\t\tnewFileVersion.setUserName(fileVersion.getUserName());\n\t\t\tnewFileVersion.setCreateDate(fileVersion.getCreateDate());\n\t\t\tnewFileVersion.setFileEntryId(newFileEntryId);\n\t\t\tnewFileVersion.setExtension(fileVersion.getExtension());\n\t\t\tnewFileVersion.setTitle(fileVersion.getTitle());\n\t\t\tnewFileVersion.setDescription(fileVersion.getDescription());\n\t\t\tnewFileVersion.setChangeLog(fileVersion.getChangeLog());\n\t\t\tnewFileVersion.setExtraSettings(fileVersion.getExtraSettings());\n\t\t\tnewFileVersion.setVersion(fileVersion.getVersion());\n\t\t\tnewFileVersion.setSize(fileVersion.getSize());\n\t\t\tnewFileVersion.setStatus(fileVersion.getStatus());\n\t\t\tnewFileVersion.setStatusByUserId(userId);\n\t\t\tnewFileVersion.setStatusByUserName(user.getFullName());\n\t\t\tnewFileVersion.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\t\tdlFileVersionPersistence.update(newFileVersion, false);\n\n\t\t\tdlFileVersionPersistence.remove(fileVersion);\n\t\t}\n\n\t\t// Resources\n\n\t\tresourceLocalService.updateResources(\n\t\t\tfileEntry.getCompanyId(), DLFileEntry.class.getName(),\n\t\t\tResourceConstants.SCOPE_INDIVIDUAL,\n\t\t\tString.valueOf(fileEntry.getFileEntryId()),\n\t\t\tString.valueOf(newFileEntryId));\n\n\t\t// Expando\n\n\t\texpandoValueLocalService.deleteValues(\n\t\t\tDLFileEntry.class.getName(), fileEntry.getFileEntryId());\n\n\t\t// DLApp\n\n\t\tdlAppHelperLocalService.moveFileEntry(\n\t\t\tuserId, groupId, folderId, newFolderId, oldFileEntryId,\n\t\t\tnewFileEntryId, name);\n\n\t\t// File\n\n\t\tdlLocalService.updateFile(\n\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\tnewFileEntry.getGroupId(), fileEntry.getRepositoryId(),\n\t\t\tnewFileEntry.getRepositoryId(), name, newFileEntryId);\n\n\t\treturn newFileEntry;\n\t}","commit_id":"1ed71e2f2b1ad41cc09a41ed3f3dec577d680b53","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteFileEntry(\n\t\t\tlong groupId, long folderId, String name, String version)\n\t\tthrows PortalException, SystemException {\n\n\t\tDLFileEntry fileEntry = dlFileEntryPersistence.findByG_F_N(\n\t\t\tgroupId, folderId, name);\n\n\t\tlong fileEntryId = fileEntry.getFileEntryId();\n\n\t\tif (Validator.isNotNull(version)) {\n\t\t\ttry {\n\t\t\t\tdlLocalService.deleteFile(\n\t\t\t\t\tfileEntry.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\t\t\tfileEntry.getRepositoryId(), fileEntry.getName(), version);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(e, e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong fileVersionsCount =\n\t\t\t\tdlFileVersionPersistence.countByFileEntryId(fileEntryId);\n\n\t\t\tdlFileVersionPersistence.removeByF_V(fileEntryId, version);\n\n\t\t\tif (fileVersionsCount == 1) {\n\t\t\t\tdlFileEntryPersistence.remove(fileEntry);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (version.equals(fileEntry.getVersion())) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tDLFileVersion fileVersion = getLatestFileVersion(\n\t\t\t\t\t\t\tfileEntryId);\n\n\t\t\t\t\t\tfileEntry.setVersion(fileVersion.getVersion());\n\t\t\t\t\t\tfileEntry.setSize(fileVersion.getSize());\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchFileVersionException nsfve) {\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdlFileEntryPersistence.update(fileEntry, false);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdeleteFileEntry(fileEntry);\n\t\t}\n\t}","id":65037,"modified_method":"public void deleteFileEntry(\n\t\t\tlong groupId, long folderId, String name, String version)\n\t\tthrows PortalException, SystemException {\n\n\t\tDLFileEntry fileEntry = dlFileEntryPersistence.findByG_F_N(\n\t\t\tgroupId, folderId, name);\n\n\t\tif (Validator.isNotNull(version)) {\n\t\t\ttry {\n\t\t\t\tdlLocalService.deleteFile(\n\t\t\t\t\tfileEntry.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\t\t\tfileEntry.getRepositoryId(), fileEntry.getName(), version);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(e, e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong fileVersionsCount =\n\t\t\t\tdlFileVersionPersistence.countByFileEntryId(\n\t\t\t\t\tfileEntry.getFileEntryId());\n\n\t\t\tdlFileVersionPersistence.removeByF_V(\n\t\t\t\tfileEntry.getFileEntryId(), version);\n\n\t\t\tif (fileVersionsCount == 1) {\n\t\t\t\tdlFileEntryPersistence.remove(fileEntry);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (version.equals(fileEntry.getVersion())) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tDLFileVersion fileVersion = getLatestFileVersion(\n\t\t\t\t\t\t\tfileEntry.getFileEntryId());\n\n\t\t\t\t\t\tfileEntry.setVersion(fileVersion.getVersion());\n\t\t\t\t\t\tfileEntry.setSize(fileVersion.getSize());\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchFileVersionException nsfve) {\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdlFileEntryPersistence.update(fileEntry, false);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdeleteFileEntry(fileEntry);\n\t\t}\n\t}","commit_id":"1ed71e2f2b1ad41cc09a41ed3f3dec577d680b53","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected DLFileVersion addFileVersion(\n\t\t\tUser user, DLFileEntry fileEntry, Date modifiedDate,\n\t\t\tString extension, String title, String description,\n\t\t\tString changeLog, String extraSettings, String version, long size,\n\t\t\tint status, ServiceContext serviceContext)\n\t\tthrows SystemException {\n\n\t\tlong fileVersionId = counterLocalService.increment();\n\n\t\tDLFileVersion fileVersion = dlFileVersionPersistence.create(\n\t\t\tfileVersionId);\n\n\t\tlong versionUserId = fileEntry.getVersionUserId();\n\n\t\tif (versionUserId <= 0) {\n\t\t\tversionUserId = fileEntry.getUserId();\n\t\t}\n\n\t\tString versionUserName = GetterUtil.getString(\n\t\t\tfileEntry.getVersionUserName(), fileEntry.getUserName());\n\n\t\tfileVersion.setCompanyId(fileEntry.getCompanyId());\n\t\tfileVersion.setUserId(versionUserId);\n\t\tfileVersion.setUserName(versionUserName);\n\t\tfileVersion.setCreateDate(modifiedDate);\n\t\tfileVersion.setFileEntryId(fileEntry.getFileEntryId());\n\t\tfileVersion.setExtension(extension);\n\t\tfileVersion.setTitle(title);\n\t\tfileVersion.setDescription(description);\n\t\tfileVersion.setChangeLog(changeLog);\n\t\tfileVersion.setExtraSettings(extraSettings);\n\t\tfileVersion.setVersion(version);\n\t\tfileVersion.setSize(size);\n\t\tfileVersion.setStatus(status);\n\t\tfileVersion.setStatusByUserId(user.getUserId());\n\t\tfileVersion.setStatusByUserName(user.getFullName());\n\t\tfileVersion.setStatusDate(fileEntry.getModifiedDate());\n\t\tfileVersion.setExpandoBridgeAttributes(serviceContext);\n\n\t\tdlFileVersionPersistence.update(fileVersion, false);\n\n\t\treturn fileVersion;\n\t}","id":65038,"modified_method":"protected DLFileVersion addFileVersion(\n\t\t\tUser user, DLFileEntry fileEntry, Date modifiedDate,\n\t\t\tString extension, String title, String description,\n\t\t\tString changeLog, String extraSettings, String version, long size,\n\t\t\tint status, ServiceContext serviceContext)\n\t\tthrows SystemException {\n\n\t\tlong fileVersionId = counterLocalService.increment();\n\n\t\tDLFileVersion fileVersion = dlFileVersionPersistence.create(\n\t\t\tfileVersionId);\n\n\t\tlong versionUserId = fileEntry.getVersionUserId();\n\n\t\tif (versionUserId <= 0) {\n\t\t\tversionUserId = fileEntry.getUserId();\n\t\t}\n\n\t\tString versionUserName = GetterUtil.getString(\n\t\t\tfileEntry.getVersionUserName(), fileEntry.getUserName());\n\n\t\tfileVersion.setGroupId(fileEntry.getGroupId());\n\t\tfileVersion.setCompanyId(fileEntry.getCompanyId());\n\t\tfileVersion.setUserId(versionUserId);\n\t\tfileVersion.setUserName(versionUserName);\n\t\tfileVersion.setCreateDate(modifiedDate);\n\t\tfileVersion.setFileEntryId(fileEntry.getFileEntryId());\n\t\tfileVersion.setExtension(extension);\n\t\tfileVersion.setTitle(title);\n\t\tfileVersion.setDescription(description);\n\t\tfileVersion.setChangeLog(changeLog);\n\t\tfileVersion.setExtraSettings(extraSettings);\n\t\tfileVersion.setVersion(version);\n\t\tfileVersion.setSize(size);\n\t\tfileVersion.setStatus(status);\n\t\tfileVersion.setStatusByUserId(user.getUserId());\n\t\tfileVersion.setStatusByUserName(user.getFullName());\n\t\tfileVersion.setStatusDate(fileEntry.getModifiedDate());\n\t\tfileVersion.setExpandoBridgeAttributes(serviceContext);\n\n\t\tdlFileVersionPersistence.update(fileVersion, false);\n\n\t\treturn fileVersion;\n\t}","commit_id":"1ed71e2f2b1ad41cc09a41ed3f3dec577d680b53","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void updateFileVersions() throws Exception {\n\t\ttry {\n\t\t\trunSQL(\"alter_column_type DLFileVersion title VARCHAR(255)\");\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tUpgradeTable upgradeTable = UpgradeTableFactoryUtil.getUpgradeTable(\n\t\t\t\tDLFileVersionTable.TABLE_NAME,\n\t\t\t\tDLFileVersionTable.TABLE_COLUMNS);\n\n\t\t\tupgradeTable.setCreateSQL(DLFileVersionTable.TABLE_SQL_CREATE);\n\n\t\t\tupgradeTable.updateTable();\n\t\t}\n\n\t\tConnection con = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs = null;\n\n\t\ttry {\n\t\t\tcon = DataAccess.getConnection();\n\n\t\t\tps = con.prepareStatement(\n\t\t\t\t\"select fileVersionId, folderId, name from DLFileVersion\");\n\n\t\t\trs = ps.executeQuery();\n\n\t\t\twhile (rs.next()) {\n\t\t\t\tlong fileVersionId = rs.getLong(\"fileVersionId\");\n\t\t\t\tlong folderId = rs.getLong(\"folderId\");\n\t\t\t\tString name = rs.getString(\"name\");\n\n\t\t\t\tlong fileEntryId = getFileEntryId(folderId, name);\n\n\t\t\t\trunSQL(\n\t\t\t\t\t\"update DLFileVersion set fileEntryId = '\" + fileEntryId +\n\t\t\t\t\t\t\"' where fileVersionId = \" + fileVersionId);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tDataAccess.cleanUp(con, ps, rs);\n\t\t}\n\n\t\trunSQL(\"alter table DLFileVersion drop column folderId\");\n\t\trunSQL(\"alter table DLFileVersion drop column name\");\n\t}","id":65039,"modified_method":"protected void updateFileVersions() throws Exception {\n\t\ttry {\n\t\t\trunSQL(\"alter_column_type DLFileVersion title VARCHAR(255)\");\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tUpgradeTable upgradeTable = UpgradeTableFactoryUtil.getUpgradeTable(\n\t\t\t\tDLFileVersionTable.TABLE_NAME,\n\t\t\t\tDLFileVersionTable.TABLE_COLUMNS);\n\n\t\t\tupgradeTable.setCreateSQL(DLFileVersionTable.TABLE_SQL_CREATE);\n\n\t\t\tupgradeTable.updateTable();\n\t\t}\n\n\t\tConnection con = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs = null;\n\n\t\ttry {\n\t\t\tcon = DataAccess.getConnection();\n\n\t\t\tps = con.prepareStatement(\n\t\t\t\t\"select fileVersionId, folderId, name from DLFileVersion\");\n\n\t\t\trs = ps.executeQuery();\n\n\t\t\twhile (rs.next()) {\n\t\t\t\tlong fileVersionId = rs.getLong(\"fileVersionId\");\n\t\t\t\tlong folderId = rs.getLong(\"folderId\");\n\t\t\t\tString name = rs.getString(\"name\");\n\n\t\t\t\tlong fileEntryId = getFileEntryId(folderId, name);\n\n\t\t\t\trunSQL(\n\t\t\t\t\t\"update DLFileVersion set fileEntryId = \" + fileEntryId +\n\t\t\t\t\t\t\" where fileVersionId = \" + fileVersionId);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tDataAccess.cleanUp(con, ps, rs);\n\t\t}\n\n\t\trunSQL(\"alter table DLFileVersion drop column folderId\");\n\t\trunSQL(\"alter table DLFileVersion drop column name\");\n\t}","commit_id":"1ed71e2f2b1ad41cc09a41ed3f3dec577d680b53","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, FileEntry fileEntry)\n\t\tthrows Exception {\n\n\t\tlong userId = portletDataContext.getUserId(fileEntry.getUserUuid());\n\n\t\tif (!fileEntry.isDefaultRepository()) {\n\n\t\t\t// References has been automatically imported, nothing to do here\n\n\t\t\treturn;\n\t\t}\n\n\t\tMap<Long, Long> folderIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tFolder.class);\n\n\t\tlong folderId = MapUtil.getLong(\n\t\t\tfolderIds, fileEntry.getFolderId(), fileEntry.getFolderId());\n\n\t\tlong[] assetCategoryIds = portletDataContext.getAssetCategoryIds(\n\t\t\tDLFileEntry.class, fileEntry.getFileEntryId());\n\t\tString[] assetTagNames = portletDataContext.getAssetTagNames(\n\t\t\tDLFileEntry.class, fileEntry.getFileEntryId());\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\tfileEntry, DLFileEntry.class);\n\n\t\tserviceContext.setAttribute(\n\t\t\t\"sourceFileName\", \"A.\" + fileEntry.getExtension());\n\t\tserviceContext.setUserId(userId);\n\n\t\tElement fileEntryElement = portletDataContext.getImportDataElement(\n\t\t\tfileEntry);\n\n\t\tString binPath = fileEntryElement.attributeValue(\"bin-path\");\n\n\t\tInputStream is = null;\n\n\t\tif (Validator.isNull(binPath) &&\n\t\t\tportletDataContext.isPerformDirectBinaryImport()) {\n\n\t\t\ttry {\n\t\t\t\tis = FileEntryUtil.getContentStream(fileEntry);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Unable to retrieve content for file entry \" +\n\t\t\t\t\t\t\tfileEntry.getFileEntryId(),\n\t\t\t\t\t\te);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tis = portletDataContext.getZipEntryAsInputStream(binPath);\n\t\t}\n\n\t\tif (is == null) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"No file found for file entry \" +\n\t\t\t\t\t\tfileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\timportMetaData(\n\t\t\tportletDataContext, fileEntryElement, fileEntry, serviceContext);\n\n\t\tFileEntry importedFileEntry = null;\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\tFileEntry existingFileEntry = fetchStagedModelByUuidAndGroupId(\n\t\t\t\tfileEntry.getUuid(), portletDataContext.getScopeGroupId());\n\n\t\t\tFileVersion fileVersion = fileEntry.getFileVersion();\n\n\t\t\tif (existingFileEntry == null) {\n\t\t\t\tif (portletDataContext.isDataStrategyMirrorWithOverwriting()) {\n\t\t\t\t\tFileEntry existingTitleFileEntry =\n\t\t\t\t\t\tFileEntryUtil.fetchByR_F_T(\n\t\t\t\t\t\t\tportletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\t\t\tfileEntry.getTitle());\n\n\t\t\t\t\tif (existingTitleFileEntry == null) {\n\t\t\t\t\t\texistingTitleFileEntry = FileEntryUtil.fetchByR_F_FN(\n\t\t\t\t\t\t\tportletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\t\t\tfileEntry.getFileName());\n\t\t\t\t\t}\n\n\t\t\t\t\tif (existingTitleFileEntry != null) {\n\t\t\t\t\t\tDLAppLocalServiceUtil.deleteFileEntry(\n\t\t\t\t\t\t\texistingTitleFileEntry.getFileEntryId());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tserviceContext.setAttribute(\n\t\t\t\t\t\"fileVersionUuid\", fileVersion.getUuid());\n\t\t\t\tserviceContext.setUuid(fileEntry.getUuid());\n\n\t\t\t\tString fileEntryTitle =\n\t\t\t\t\tDLFileEntryLocalServiceUtil.getUniqueTitle(\n\t\t\t\t\t\tportletDataContext.getScopeGroupId(), folderId, 0,\n\t\t\t\t\t\tfileEntry.getTitle(), fileEntry.getExtension());\n\n\t\t\t\timportedFileEntry = DLAppLocalServiceUtil.addFileEntry(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\tfileEntry.getFileName(), fileEntry.getMimeType(),\n\t\t\t\t\tfileEntryTitle, fileEntry.getDescription(), null, is,\n\t\t\t\t\tfileEntry.getSize(), serviceContext);\n\n\t\t\t\tif (fileEntry.isInTrash()) {\n\t\t\t\t\timportedFileEntry = DLAppServiceUtil.moveFileEntryToTrash(\n\t\t\t\t\t\timportedFileEntry.getFileEntryId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tFileVersion latestExistingFileVersion =\n\t\t\t\t\texistingFileEntry.getLatestFileVersion(true);\n\n\t\t\t\tboolean indexEnabled = serviceContext.isIndexingEnabled();\n\n\t\t\t\tboolean deleteFileEntry = false;\n\t\t\t\tboolean updateFileEntry = false;\n\n\t\t\t\tif (!Validator.equals(\n\t\t\t\t\t\tfileVersion.getUuid(),\n\t\t\t\t\t\tlatestExistingFileVersion.getUuid())) {\n\n\t\t\t\t\tdeleteFileEntry = true;\n\t\t\t\t\tupdateFileEntry = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tInputStream existingFileVersionInputStream = null;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\texistingFileVersionInputStream =\n\t\t\t\t\t\t\tlatestExistingFileVersion.getContentStream(false);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t\t\t_log.debug(e, e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tif (existingFileVersionInputStream != null) {\n\t\t\t\t\t\t\texistingFileVersionInputStream.close();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (existingFileVersionInputStream == null) {\n\t\t\t\t\t\tupdateFileEntry = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tserviceContext.setIndexingEnabled(false);\n\n\t\t\t\t\tif (updateFileEntry) {\n\t\t\t\t\t\tDLFileVersion alreadyExistingFileVersion =\n\t\t\t\t\t\t\tDLFileVersionLocalServiceUtil.\n\t\t\t\t\t\t\t\tgetFileVersionByUuidAndGroupId(\n\t\t\t\t\t\t\t\t\tfileVersion.getUuid(),\n\t\t\t\t\t\t\t\t\texistingFileEntry.getGroupId());\n\n\t\t\t\t\t\tif (alreadyExistingFileVersion != null) {\n\t\t\t\t\t\t\tserviceContext.setAttribute(\n\t\t\t\t\t\t\t\t\"existingDLFileVersionId\",\n\t\t\t\t\t\t\t\talreadyExistingFileVersion.getFileVersionId());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tserviceContext.setUuid(fileVersion.getUuid());\n\n\t\t\t\t\t\timportedFileEntry =\n\t\t\t\t\t\t\tDLAppLocalServiceUtil.updateFileEntry(\n\t\t\t\t\t\t\t\tuserId, existingFileEntry.getFileEntryId(),\n\t\t\t\t\t\t\t\tfileEntry.getFileName(),\n\t\t\t\t\t\t\t\tfileEntry.getMimeType(), fileEntry.getTitle(),\n\t\t\t\t\t\t\t\tfileEntry.getDescription(), null, false, is,\n\t\t\t\t\t\t\t\tfileEntry.getSize(), serviceContext);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tDLAppLocalServiceUtil.updateAsset(\n\t\t\t\t\t\t\tuserId, existingFileEntry,\n\t\t\t\t\t\t\tlatestExistingFileVersion, assetCategoryIds,\n\t\t\t\t\t\t\tassetTagNames, null);\n\n\t\t\t\t\t\timportedFileEntry = existingFileEntry;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (importedFileEntry.getFolderId() != folderId) {\n\t\t\t\t\t\timportedFileEntry = DLAppLocalServiceUtil.moveFileEntry(\n\t\t\t\t\t\t\tuserId, importedFileEntry.getFileEntryId(),\n\t\t\t\t\t\t\tfolderId, serviceContext);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (importedFileEntry instanceof LiferayFileEntry) {\n\t\t\t\t\t\tLiferayFileEntry liferayFileEntry =\n\t\t\t\t\t\t\t(LiferayFileEntry)importedFileEntry;\n\n\t\t\t\t\t\tIndexer<DLFileEntry> indexer =\n\t\t\t\t\t\t\tIndexerRegistryUtil.nullSafeGetIndexer(\n\t\t\t\t\t\t\t\tDLFileEntry.class);\n\n\t\t\t\t\t\tindexer.reindex(\n\t\t\t\t\t\t\t(DLFileEntry)liferayFileEntry.getModel());\n\t\t\t\t\t}\n\n\t\t\t\t\tif (deleteFileEntry &&\n\t\t\t\t\t\tExportImportThreadLocal.isStagingInProcess()) {\n\n\t\t\t\t\t\tDLAppServiceUtil.deleteFileVersion(\n\t\t\t\t\t\t\tlatestExistingFileVersion.getFileEntryId(),\n\t\t\t\t\t\t\tlatestExistingFileVersion.getVersion());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tserviceContext.setIndexingEnabled(indexEnabled);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tString fileEntryTitle = DLFileEntryLocalServiceUtil.getUniqueTitle(\n\t\t\t\tportletDataContext.getScopeGroupId(), folderId, 0,\n\t\t\t\tfileEntry.getTitle(), fileEntry.getExtension());\n\n\t\t\timportedFileEntry = DLAppLocalServiceUtil.addFileEntry(\n\t\t\t\tuserId, portletDataContext.getScopeGroupId(), folderId,\n\t\t\t\tfileEntry.getFileName(), fileEntry.getMimeType(),\n\t\t\t\tfileEntryTitle, fileEntry.getDescription(), null, is,\n\t\t\t\tfileEntry.getSize(), serviceContext);\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(\n\t\t\t\t\"document_library\", \"previews-and-thumbnails\")) {\n\n\t\t\tDLProcessorRegistryUtil.importGeneratedFiles(\n\t\t\t\tportletDataContext, fileEntry, importedFileEntry,\n\t\t\t\tfileEntryElement);\n\t\t}\n\n\t\tportletDataContext.importClassedModel(\n\t\t\tfileEntry, importedFileEntry, DLFileEntry.class);\n\n\t\tMap<Long, Long> fileEntryIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tFileEntry.class);\n\n\t\tfileEntryIds.put(\n\t\t\tfileEntry.getFileEntryId(), importedFileEntry.getFileEntryId());\n\t}","id":65040,"modified_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, FileEntry fileEntry)\n\t\tthrows Exception {\n\n\t\tlong userId = portletDataContext.getUserId(fileEntry.getUserUuid());\n\n\t\tif (!fileEntry.isDefaultRepository()) {\n\n\t\t\t// References has been automatically imported, nothing to do here\n\n\t\t\treturn;\n\t\t}\n\n\t\tMap<Long, Long> folderIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tFolder.class);\n\n\t\tlong folderId = MapUtil.getLong(\n\t\t\tfolderIds, fileEntry.getFolderId(), fileEntry.getFolderId());\n\n\t\tlong[] assetCategoryIds = portletDataContext.getAssetCategoryIds(\n\t\t\tDLFileEntry.class, fileEntry.getFileEntryId());\n\t\tString[] assetTagNames = portletDataContext.getAssetTagNames(\n\t\t\tDLFileEntry.class, fileEntry.getFileEntryId());\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\tfileEntry, DLFileEntry.class);\n\n\t\tserviceContext.setAttribute(\n\t\t\t\"sourceFileName\", \"A.\" + fileEntry.getExtension());\n\t\tserviceContext.setUserId(userId);\n\n\t\tElement fileEntryElement = portletDataContext.getImportDataElement(\n\t\t\tfileEntry);\n\n\t\tString binPath = fileEntryElement.attributeValue(\"bin-path\");\n\n\t\tInputStream is = null;\n\n\t\tif (Validator.isNull(binPath) &&\n\t\t\tportletDataContext.isPerformDirectBinaryImport()) {\n\n\t\t\ttry {\n\t\t\t\tis = FileEntryUtil.getContentStream(fileEntry);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Unable to retrieve content for file entry \" +\n\t\t\t\t\t\t\tfileEntry.getFileEntryId(),\n\t\t\t\t\t\te);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tis = portletDataContext.getZipEntryAsInputStream(binPath);\n\t\t}\n\n\t\tif (is == null) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"No file found for file entry \" +\n\t\t\t\t\t\tfileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\timportMetaData(\n\t\t\tportletDataContext, fileEntryElement, fileEntry, serviceContext);\n\n\t\tFileEntry importedFileEntry = null;\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\tFileEntry existingFileEntry = fetchStagedModelByUuidAndGroupId(\n\t\t\t\tfileEntry.getUuid(), portletDataContext.getScopeGroupId());\n\n\t\t\tFileVersion fileVersion = fileEntry.getFileVersion();\n\n\t\t\tif (existingFileEntry == null) {\n\t\t\t\tif (portletDataContext.isDataStrategyMirrorWithOverwriting()) {\n\t\t\t\t\tFileEntry existingTitleFileEntry =\n\t\t\t\t\t\tFileEntryUtil.fetchByR_F_T(\n\t\t\t\t\t\t\tportletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\t\t\tfileEntry.getTitle());\n\n\t\t\t\t\tif (existingTitleFileEntry == null) {\n\t\t\t\t\t\texistingTitleFileEntry = FileEntryUtil.fetchByR_F_FN(\n\t\t\t\t\t\t\tportletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\t\t\tfileEntry.getFileName());\n\t\t\t\t\t}\n\n\t\t\t\t\tif (existingTitleFileEntry != null) {\n\t\t\t\t\t\tDLAppLocalServiceUtil.deleteFileEntry(\n\t\t\t\t\t\t\texistingTitleFileEntry.getFileEntryId());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tserviceContext.setAttribute(\n\t\t\t\t\t\"fileVersionUuid\", fileVersion.getUuid());\n\t\t\t\tserviceContext.setUuid(fileEntry.getUuid());\n\n\t\t\t\tString fileEntryTitle =\n\t\t\t\t\tDLFileEntryLocalServiceUtil.getUniqueTitle(\n\t\t\t\t\t\tportletDataContext.getScopeGroupId(), folderId, 0,\n\t\t\t\t\t\tfileEntry.getTitle(), fileEntry.getExtension());\n\n\t\t\t\timportedFileEntry = DLAppLocalServiceUtil.addFileEntry(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\tfileEntry.getFileName(), fileEntry.getMimeType(),\n\t\t\t\t\tfileEntryTitle, fileEntry.getDescription(), null, is,\n\t\t\t\t\tfileEntry.getSize(), serviceContext);\n\n\t\t\t\tif (fileEntry.isInTrash()) {\n\t\t\t\t\timportedFileEntry = DLAppServiceUtil.moveFileEntryToTrash(\n\t\t\t\t\t\timportedFileEntry.getFileEntryId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tFileVersion latestExistingFileVersion =\n\t\t\t\t\texistingFileEntry.getLatestFileVersion(true);\n\n\t\t\t\tboolean indexEnabled = serviceContext.isIndexingEnabled();\n\n\t\t\t\tboolean deleteFileEntry = false;\n\t\t\t\tboolean updateFileEntry = false;\n\n\t\t\t\tif (!Validator.equals(\n\t\t\t\t\t\tfileVersion.getUuid(),\n\t\t\t\t\t\tlatestExistingFileVersion.getUuid())) {\n\n\t\t\t\t\tdeleteFileEntry = true;\n\t\t\t\t\tupdateFileEntry = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tInputStream existingFileVersionInputStream = null;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\texistingFileVersionInputStream =\n\t\t\t\t\t\t\tlatestExistingFileVersion.getContentStream(false);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t\t\t_log.debug(e, e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tif (existingFileVersionInputStream != null) {\n\t\t\t\t\t\t\texistingFileVersionInputStream.close();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (existingFileVersionInputStream == null) {\n\t\t\t\t\t\tupdateFileEntry = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tserviceContext.setIndexingEnabled(false);\n\n\t\t\t\t\tif (updateFileEntry) {\n\t\t\t\t\t\tDLFileVersion alreadyExistingFileVersion =\n\t\t\t\t\t\t\tDLFileVersionLocalServiceUtil.\n\t\t\t\t\t\t\t\tgetFileVersionByUuidAndGroupId(\n\t\t\t\t\t\t\t\t\tfileVersion.getUuid(),\n\t\t\t\t\t\t\t\t\texistingFileEntry.getGroupId());\n\n\t\t\t\t\t\tif (alreadyExistingFileVersion != null) {\n\t\t\t\t\t\t\tserviceContext.setAttribute(\n\t\t\t\t\t\t\t\t\"existingDLFileVersionId\",\n\t\t\t\t\t\t\t\talreadyExistingFileVersion.getFileVersionId());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tserviceContext.setUuid(fileVersion.getUuid());\n\n\t\t\t\t\t\tString fileEntryTitle =\n\t\t\t\t\t\t\tDLFileEntryLocalServiceUtil.getUniqueTitle(\n\t\t\t\t\t\t\t\tportletDataContext.getScopeGroupId(),\n\t\t\t\t\t\t\t\texistingFileEntry.getFolderId(),\n\t\t\t\t\t\t\t\texistingFileEntry.getFileEntryId(),\n\t\t\t\t\t\t\t\tfileEntry.getTitle(), fileEntry.getExtension());\n\n\t\t\t\t\t\timportedFileEntry =\n\t\t\t\t\t\t\tDLAppLocalServiceUtil.updateFileEntry(\n\t\t\t\t\t\t\t\tuserId, existingFileEntry.getFileEntryId(),\n\t\t\t\t\t\t\t\tfileEntry.getFileName(),\n\t\t\t\t\t\t\t\tfileEntry.getMimeType(), fileEntryTitle,\n\t\t\t\t\t\t\t\tfileEntry.getDescription(), null, false, is,\n\t\t\t\t\t\t\t\tfileEntry.getSize(), serviceContext);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tDLAppLocalServiceUtil.updateAsset(\n\t\t\t\t\t\t\tuserId, existingFileEntry,\n\t\t\t\t\t\t\tlatestExistingFileVersion, assetCategoryIds,\n\t\t\t\t\t\t\tassetTagNames, null);\n\n\t\t\t\t\t\timportedFileEntry = existingFileEntry;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (importedFileEntry.getFolderId() != folderId) {\n\t\t\t\t\t\timportedFileEntry = DLAppLocalServiceUtil.moveFileEntry(\n\t\t\t\t\t\t\tuserId, importedFileEntry.getFileEntryId(),\n\t\t\t\t\t\t\tfolderId, serviceContext);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (importedFileEntry instanceof LiferayFileEntry) {\n\t\t\t\t\t\tLiferayFileEntry liferayFileEntry =\n\t\t\t\t\t\t\t(LiferayFileEntry)importedFileEntry;\n\n\t\t\t\t\t\tIndexer<DLFileEntry> indexer =\n\t\t\t\t\t\t\tIndexerRegistryUtil.nullSafeGetIndexer(\n\t\t\t\t\t\t\t\tDLFileEntry.class);\n\n\t\t\t\t\t\tindexer.reindex(\n\t\t\t\t\t\t\t(DLFileEntry)liferayFileEntry.getModel());\n\t\t\t\t\t}\n\n\t\t\t\t\tif (deleteFileEntry &&\n\t\t\t\t\t\tExportImportThreadLocal.isStagingInProcess()) {\n\n\t\t\t\t\t\tDLAppServiceUtil.deleteFileVersion(\n\t\t\t\t\t\t\tlatestExistingFileVersion.getFileEntryId(),\n\t\t\t\t\t\t\tlatestExistingFileVersion.getVersion());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tserviceContext.setIndexingEnabled(indexEnabled);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tString fileEntryTitle = DLFileEntryLocalServiceUtil.getUniqueTitle(\n\t\t\t\tportletDataContext.getScopeGroupId(), folderId, 0,\n\t\t\t\tfileEntry.getTitle(), fileEntry.getExtension());\n\n\t\t\timportedFileEntry = DLAppLocalServiceUtil.addFileEntry(\n\t\t\t\tuserId, portletDataContext.getScopeGroupId(), folderId,\n\t\t\t\tfileEntry.getFileName(), fileEntry.getMimeType(),\n\t\t\t\tfileEntryTitle, fileEntry.getDescription(), null, is,\n\t\t\t\tfileEntry.getSize(), serviceContext);\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(\n\t\t\t\t\"document_library\", \"previews-and-thumbnails\")) {\n\n\t\t\tDLProcessorRegistryUtil.importGeneratedFiles(\n\t\t\t\tportletDataContext, fileEntry, importedFileEntry,\n\t\t\t\tfileEntryElement);\n\t\t}\n\n\t\tportletDataContext.importClassedModel(\n\t\t\tfileEntry, importedFileEntry, DLFileEntry.class);\n\n\t\tMap<Long, Long> fileEntryIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tFileEntry.class);\n\n\t\tfileEntryIds.put(\n\t\t\tfileEntry.getFileEntryId(), importedFileEntry.getFileEntryId());\n\t}","commit_id":"0704f14d28bcbd062525e1c5c07b72ead72a879c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Document doGetDocument(Object obj) throws Exception {\n\t\tDLFileEntry fileEntry = (DLFileEntry)obj;\n\n\t\tlong companyId = fileEntry.getCompanyId();\n\t\tlong groupId = fileEntry.getGroupId();\n\t\tlong userId = fileEntry.getUserId();\n\t\tlong repositoryId = fileEntry.getDataRepositoryId();\n\t\tString fileName = fileEntry.getName();\n\t\tlong fileEntryId = fileEntry.getFileEntryId();\n\t\tString properties = fileEntry.getLuceneProperties();\n\t\tDate modifiedDate = fileEntry.getModifiedDate();\n\n\t\tlong[] assetCategoryIds = AssetCategoryLocalServiceUtil.getCategoryIds(\n\t\t\tDLFileEntry.class.getName(), fileEntryId);\n\t\tString[] assetCategoryNames =\n\t\t\tAssetCategoryLocalServiceUtil.getCategoryNames(\n\t\t\t\tDLFileEntry.class.getName(), fileEntryId);\n\t\tString[] assetTagNames = AssetTagLocalServiceUtil.getTagNames(\n\t\t\tDLFileEntry.class.getName(), fileEntryId);\n\n\t\tFileModel fileModel = new FileModel();\n\n\t\tfileModel.setAssetCategoryIds(assetCategoryIds);\n\t\tfileModel.setAssetCategoryNames(assetCategoryNames);\n\t\tfileModel.setAssetTagNames(assetTagNames);\n\t\tfileModel.setCompanyId(companyId);\n\t\tfileModel.setFileEntryId(fileEntryId);\n\t\tfileModel.setFileName(fileName);\n\t\tfileModel.setGroupId(groupId);\n\t\tfileModel.setUserId(userId);\n\t\tfileModel.setModifiedDate(modifiedDate);\n\t\tfileModel.setPortletId(PORTLET_ID);\n\t\tfileModel.setProperties(properties);\n\t\tfileModel.setRepositoryId(repositoryId);\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(FileModel.class);\n\n\t\treturn indexer.getDocument(fileModel);\n\t}","id":65041,"modified_method":"protected Document doGetDocument(Object obj) throws Exception {\n\t\tDLFileEntry fileEntry = (DLFileEntry)obj;\n\n\t\tFileModel fileModel = new FileModel();\n\n\t\tlong[] assetCategoryIds = AssetCategoryLocalServiceUtil.getCategoryIds(\n\t\t\tDLFileEntry.class.getName(), fileEntry.getFileEntryId());\n\n\t\tfileModel.setAssetCategoryIds(assetCategoryIds);\n\n\t\tString[] assetCategoryNames =\n\t\t\tAssetCategoryLocalServiceUtil.getCategoryNames(\n\t\t\t\tDLFileEntry.class.getName(), fileEntry.getFileEntryId());\n\n\t\tfileModel.setAssetCategoryNames(assetCategoryNames);\n\n\t\tString[] assetTagNames = AssetTagLocalServiceUtil.getTagNames(\n\t\t\tDLFileEntry.class.getName(), fileEntry.getFileEntryId());\n\n\t\tfileModel.setAssetTagNames(assetTagNames);\n\n\t\tfileModel.setCompanyId(fileEntry.getCompanyId());\n\t\tfileModel.setFileEntryId(fileEntry.getFileEntryId());\n\t\tfileModel.setFileName(fileEntry.getName());\n\t\tfileModel.setGroupId(fileEntry.getGroupId());\n\t\tfileModel.setUserId(fileEntry.getUserId());\n\t\tfileModel.setModifiedDate(fileEntry.getModifiedDate());\n\t\tfileModel.setPortletId(PORTLET_ID);\n\t\tfileModel.setProperties(fileEntry.getLuceneProperties());\n\t\tfileModel.setRepositoryId(fileEntry.getDataRepositoryId());\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(FileModel.class);\n\n\t\treturn indexer.getDocument(fileModel);\n\t}","commit_id":"b3161b6806827b57488c329ad29456632f7b6e38","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public FileEntry moveFileEntryFromTrash(\n\t\t\tlong userId, FileEntry fileEntry, long newFolderId,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong fileEntryId = fileEntry.getFileEntryId();\n\n\t\t// File entry\n\n\t\tList<DLFileVersion> dlFileVersions =\n\t\t\tdlFileVersionLocalService.getFileVersions(\n\t\t\t\tfileEntry.getFileEntryId(), WorkflowConstants.STATUS_ANY);\n\n\t\tdlFileVersions = ListUtil.sort(\n\t\t\tdlFileVersions, new FileVersionVersionComparator());\n\n\t\tFileVersion fileVersion = new LiferayFileVersion(dlFileVersions.get(0));\n\n\t\tdlFileEntryLocalService.updateStatus(\n\t\t\tuserId, fileVersion.getFileVersionId(), fileVersion.getStatus(),\n\t\t\tnew HashMap<String, Serializable>(), serviceContext);\n\n\t\t// File rank\n\n\t\tdlFileRankLocalService.enableFileRanks(fileEntryId);\n\n\t\t// Move from trash\n\n\t\treturn dlAppService.moveFileEntry(\n\t\t\tfileEntryId, newFolderId, serviceContext);\n\t}","id":65042,"modified_method":"public FileEntry moveFileEntryFromTrash(\n\t\t\tlong userId, FileEntry fileEntry, long newFolderId,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// File entry\n\n\t\tList<DLFileVersion> dlFileVersions =\n\t\t\tdlFileVersionLocalService.getFileVersions(\n\t\t\t\tfileEntry.getFileEntryId(), WorkflowConstants.STATUS_ANY);\n\n\t\tdlFileVersions = ListUtil.sort(\n\t\t\tdlFileVersions, new FileVersionVersionComparator());\n\n\t\tFileVersion fileVersion = new LiferayFileVersion(dlFileVersions.get(0));\n\n\t\tdlFileEntryLocalService.updateStatus(\n\t\t\tuserId, fileVersion.getFileVersionId(), fileVersion.getStatus(),\n\t\t\tnew HashMap<String, Serializable>(), serviceContext);\n\n\t\t// File rank\n\n\t\tdlFileRankLocalService.enableFileRanks(fileEntry.getFileEntryId());\n\n\t\t// App helper\n\n\t\treturn dlAppService.moveFileEntry(\n\t\t\tfileEntry.getFileEntryId(), newFolderId, serviceContext);\n\t}","commit_id":"7f684bdb3893a50838818a4ece95eeab4139f785","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void serveAddFileEntry(\n\t\t\tResourceRequest resourceRequest, ResourceResponse resourceResponse)\n\t\tthrows Exception {\n\n\t\tlong folderId = ParamUtil.getLong(resourceRequest, \"folderId\");\n\n\t\tFolder folder = DLAppServiceUtil.getFolder(folderId);\n\n\t\tString fileEntryTitle = ParamUtil.getString(\n\t\t\tresourceRequest, \"fileEntryTitle\");\n\n\t\tString content = ParamUtil.getString(resourceRequest, \"content\");\n\n\t\tbyte[] bytes = content.getBytes(StringPool.UTF8);\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\tString extension = FileUtil.getExtension(fileEntryTitle);\n\n\t\tserviceContext.setAttribute(\"extension\", extension);\n\n\t\tserviceContext.setAttribute(\"sourceFileName\", fileEntryTitle);\n\n\t\tserviceContext.setScopeGroupId(folder.getGroupId());\n\n\t\tFileEntry fileEntry = DLAppServiceUtil.addFileEntry(\n\t\t\tfolder.getRepositoryId(), folderId, fileEntryTitle,\n\t\t\tStringPool.BLANK, StringPool.BLANK, bytes, serviceContext);\n\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\tlong fileEntryId = fileEntry.getFileEntryId();\n\n\t\tjsonObject.put(\"fileEntryId\", String.valueOf(fileEntryId));\n\n\t\tString fileEntryURL = ShindigUtil.getFileEntryURL(\n\t\t\tStringPool.BLANK, fileEntryId);\n\n\t\tjsonObject.put(\"fileEntryURL\", fileEntryURL);\n\n\t\twriteJSON(resourceRequest, resourceResponse, jsonObject.toString());\n\t}","id":65043,"modified_method":"protected void serveAddFileEntry(\n\t\t\tResourceRequest resourceRequest, ResourceResponse resourceResponse)\n\t\tthrows Exception {\n\n\t\tlong folderId = ParamUtil.getLong(resourceRequest, \"folderId\");\n\n\t\tFolder folder = DLAppServiceUtil.getFolder(folderId);\n\n\t\tString fileEntryTitle = ParamUtil.getString(\n\t\t\tresourceRequest, \"fileEntryTitle\");\n\n\t\tString content = ParamUtil.getString(resourceRequest, \"content\");\n\n\t\tbyte[] bytes = content.getBytes(StringPool.UTF8);\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\tString extension = FileUtil.getExtension(fileEntryTitle);\n\n\t\tserviceContext.setAttribute(\"extension\", extension);\n\n\t\tserviceContext.setAttribute(\"sourceFileName\", fileEntryTitle);\n\n\t\tserviceContext.setScopeGroupId(folder.getGroupId());\n\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\tFileEntry fileEntry = DLAppServiceUtil.addFileEntry(\n\t\t\tfolder.getRepositoryId(), folderId, fileEntryTitle,\n\t\t\tStringPool.BLANK, StringPool.BLANK, bytes, serviceContext);\n\n\t\tjsonObject.put(\"fileEntryId\", fileEntry.getFileEntryId());\n\n\t\tString fileEntryURL = ShindigUtil.getFileEntryURL(\n\t\t\tStringPool.BLANK, fileEntry.getFileEntryId());\n\n\t\tjsonObject.put(\"fileEntryURL\", fileEntryURL);\n\n\t\twriteJSON(resourceRequest, resourceResponse, jsonObject.toString());\n\t}","commit_id":"f63a68d0a16e90275fcdf0e6dcb48827aa8ec0da","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void serveGetFolderChildren(\n\t\t\tResourceRequest resourceRequest, ResourceResponse resourceResponse)\n\t\tthrows Exception {\n\n\t\tlong repositoryId = ParamUtil.getLong(resourceRequest, \"repositoryId\");\n\t\tlong folderId = ParamUtil.getLong(resourceRequest, \"folderId\");\n\n\t\tList<Folder> folders = DLAppServiceUtil.getFolders(\n\t\t\trepositoryId, folderId);\n\n\t\tfolders = ListUtil.sort(\n\t\t\tfolders, new RepositoryModelNameComparator(true));\n\n\t\tJSONArray jsonArray = JSONFactoryUtil.createJSONArray();\n\n\t\tfor (Folder folder : folders) {\n\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\tjsonObject.put(\"entryId\", String.valueOf(folder.getFolderId()));\n\t\t\tjsonObject.put(\"label\", folder.getName());\n\t\t\tjsonObject.put(\"leaf\", false);\n\t\t\tjsonObject.put(\"type\", \"editor\");\n\n\t\t\tjsonArray.put(jsonObject);\n\t\t}\n\n\t\tboolean getFileEntries = ParamUtil.getBoolean(\n\t\t\tresourceRequest, \"getFileEntries\");\n\n\t\tif (getFileEntries) {\n\t\t\tList<FileEntry> fileEntries = DLAppServiceUtil.getFileEntries(\n\t\t\t\trepositoryId, folderId);\n\n\t\t\tfileEntries = ListUtil.sort(\n\t\t\t\tfileEntries, new RepositoryModelNameComparator(true));\n\n\t\t\tfor (FileEntry fileEntry : fileEntries) {\n\t\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\t\tlong fileEntryId = fileEntry.getFileEntryId();\n\n\t\t\t\tjsonObject.put(\"entryId\", String.valueOf(fileEntryId));\n\n\t\t\t\tString fileEntryURL = ShindigUtil.getFileEntryURL(\n\t\t\t\t\t\tStringPool.BLANK, fileEntryId);\n\n\t\t\t\tjsonObject.put(\"fileEntryURL\", fileEntryURL);\n\t\t\t\tjsonObject.put(\"label\", fileEntry.getTitle());\n\t\t\t\tjsonObject.put(\"leaf\", true);\n\t\t\t\tjsonObject.put(\"type\", \"editor\");\n\n\t\t\t\tjsonArray.put(jsonObject);\n\t\t\t}\n\t\t}\n\n\t\twriteJSON(resourceRequest, resourceResponse, jsonArray.toString());\n\t}","id":65044,"modified_method":"protected void serveGetFolderChildren(\n\t\t\tResourceRequest resourceRequest, ResourceResponse resourceResponse)\n\t\tthrows Exception {\n\n\t\tlong repositoryId = ParamUtil.getLong(resourceRequest, \"repositoryId\");\n\t\tlong folderId = ParamUtil.getLong(resourceRequest, \"folderId\");\n\n\t\tList<Folder> folders = DLAppServiceUtil.getFolders(\n\t\t\trepositoryId, folderId);\n\n\t\tfolders = ListUtil.sort(\n\t\t\tfolders, new RepositoryModelNameComparator(true));\n\n\t\tJSONArray jsonArray = JSONFactoryUtil.createJSONArray();\n\n\t\tfor (Folder folder : folders) {\n\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\tjsonObject.put(\"entryId\", folder.getFolderId());\n\t\t\tjsonObject.put(\"label\", folder.getName());\n\t\t\tjsonObject.put(\"leaf\", false);\n\t\t\tjsonObject.put(\"type\", \"editor\");\n\n\t\t\tjsonArray.put(jsonObject);\n\t\t}\n\n\t\tboolean getFileEntries = ParamUtil.getBoolean(\n\t\t\tresourceRequest, \"getFileEntries\");\n\n\t\tif (getFileEntries) {\n\t\t\tList<FileEntry> fileEntries = DLAppServiceUtil.getFileEntries(\n\t\t\t\trepositoryId, folderId);\n\n\t\t\tfileEntries = ListUtil.sort(\n\t\t\t\tfileEntries, new RepositoryModelNameComparator(true));\n\n\t\t\tfor (FileEntry fileEntry : fileEntries) {\n\t\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\t\tjsonObject.put(\"entryId\", fileEntry.getFileEntryId());\n\n\t\t\t\tString fileEntryURL = ShindigUtil.getFileEntryURL(\n\t\t\t\t\tStringPool.BLANK, fileEntry.getFileEntryId());\n\n\t\t\t\tjsonObject.put(\"fileEntryURL\", fileEntryURL);\n\n\t\t\t\tjsonObject.put(\"label\", fileEntry.getTitle());\n\t\t\t\tjsonObject.put(\"leaf\", true);\n\t\t\t\tjsonObject.put(\"type\", \"editor\");\n\n\t\t\t\tjsonArray.put(jsonObject);\n\t\t\t}\n\t\t}\n\n\t\twriteJSON(resourceRequest, resourceResponse, jsonArray.toString());\n\t}","commit_id":"f63a68d0a16e90275fcdf0e6dcb48827aa8ec0da","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void serveAddFolder(\n\t\t\tResourceRequest resourceRequest, ResourceResponse resourceResponse)\n\t\tthrows Exception {\n\n\t\tlong parentFolderId = ParamUtil.getLong(\n\t\t\tresourceRequest, \"parentFolderId\");\n\n\t\tFolder parentFolder = DLAppServiceUtil.getFolder(parentFolderId);\n\n\t\tString folderName = ParamUtil.getString(resourceRequest, \"folderName\");\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setScopeGroupId(parentFolder.getGroupId());\n\n\t\tFolder folder = DLAppServiceUtil.addFolder(\n\t\t\tparentFolder.getRepositoryId(), parentFolderId, folderName,\n\t\t\tStringPool.BLANK, serviceContext);\n\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\tjsonObject.put(\"folderId\", String.valueOf(folder.getFolderId()));\n\n\t\twriteJSON(resourceRequest, resourceResponse, jsonObject.toString());\n\t}","id":65045,"modified_method":"protected void serveAddFolder(\n\t\t\tResourceRequest resourceRequest, ResourceResponse resourceResponse)\n\t\tthrows Exception {\n\n\t\tlong parentFolderId = ParamUtil.getLong(\n\t\t\tresourceRequest, \"parentFolderId\");\n\n\t\tFolder parentFolder = DLAppServiceUtil.getFolder(parentFolderId);\n\n\t\tString folderName = ParamUtil.getString(resourceRequest, \"folderName\");\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setScopeGroupId(parentFolder.getGroupId());\n\n\t\tFolder folder = DLAppServiceUtil.addFolder(\n\t\t\tparentFolder.getRepositoryId(), parentFolderId, folderName,\n\t\t\tStringPool.BLANK, serviceContext);\n\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\tjsonObject.put(\"folderId\", folder.getFolderId());\n\n\t\twriteJSON(resourceRequest, resourceResponse, jsonObject.toString());\n\t}","commit_id":"f63a68d0a16e90275fcdf0e6dcb48827aa8ec0da","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@NotNull\n  public List<TargetTypeBuildScope> getBuildTargetScopes(@NotNull final CompileScope baseScope,\n                                                         @NotNull final CompilerFilter filter,\n                                                         @NotNull final Project project) {\n    final FlexCompiler flexCompiler = FlexCompiler.getInstance(project);\n    if (!filter.acceptCompiler(flexCompiler)) return Collections.emptyList();\n\n    final TargetTypeBuildScope.Builder builder = TargetTypeBuildScope.newBuilder().setTypeId(FlexBuildTargetType.INSTANCE.getTypeId());\n\n    final RunConfiguration runConfiguration = CompileStepBeforeRun.getRunConfiguration(baseScope);\n    final Collection<Pair<Module, FlexBuildConfiguration>> bcsToCompileForPackaging =\n      FlexCompiler.getBCsToCompileForPackaging(baseScope);\n\n    try {\n      for (Pair<Module, FlexBuildConfiguration> moduleAndBC : FlexCompiler.getModulesAndBCsToCompile(baseScope)) {\n        final Module module = moduleAndBC.first;\n        final FlexBuildConfiguration bc = moduleAndBC.second;\n\n        if (bcsToCompileForPackaging != null && contains(bcsToCompileForPackaging, module, bc)) {\n          final boolean forcedDebugStatus = FlexCompiler.getForcedDebugStatus(project, bc);\n          builder.addTargetId(FlexCommonUtils.getBuildTargetId(module.getName(), bc.getName(), forcedDebugStatus));\n        }\n        else if (bc.isTempBCForCompilation()) {\n          LOG.assertTrue(runConfiguration instanceof FlashRunConfiguration || runConfiguration instanceof FlexUnitRunConfiguration,\n                         bc.getName());\n          final BCBasedRunnerParameters params = runConfiguration instanceof FlashRunConfiguration\n                                                 ? ((FlashRunConfiguration)runConfiguration).getRunnerParameters()\n                                                 : ((FlexUnitRunConfiguration)runConfiguration).getRunnerParameters();\n          LOG.assertTrue(params.getModuleName().equals(module.getName()),\n                         \"Module name in run config: \" + params.getModuleName() + \", expected: \" + module.getName());\n          LOG.assertTrue(params.getBCName().equals(bc.getName()),\n                         \"BC name in run config: \" + params.getBCName() + \", expected: \" + bc.getName());\n          builder.addTargetId(FlexCommonUtils.getBuildTargetIdForRunConfig(runConfiguration.getType().getId(), runConfiguration.getName()));\n        }\n        else {\n          builder.addTargetId(FlexCommonUtils.getBuildTargetId(module.getName(), bc.getName(), null));\n        }\n      }\n    }\n    catch (ConfigurationException e) {\n      // can't happen because checked in ValidateFlashConfigurationsPrecompileTask\n      LOG.error(e);\n    }\n\n    return Collections.singletonList(builder.build());\n  }","id":65046,"modified_method":"@NotNull\n  public List<TargetTypeBuildScope> getBuildTargetScopes(@NotNull final CompileScope baseScope,\n                                                         @NotNull final CompilerFilter filter,\n                                                         @NotNull final Project project,\n                                                         boolean forceBuild) {\n    final FlexCompiler flexCompiler = FlexCompiler.getInstance(project);\n    if (!filter.acceptCompiler(flexCompiler)) return Collections.emptyList();\n\n    final TargetTypeBuildScope.Builder builder = TargetTypeBuildScope.newBuilder().setTypeId(FlexBuildTargetType.INSTANCE.getTypeId()).setForceBuild(forceBuild);\n\n    final RunConfiguration runConfiguration = CompileStepBeforeRun.getRunConfiguration(baseScope);\n    final Collection<Pair<Module, FlexBuildConfiguration>> bcsToCompileForPackaging =\n      FlexCompiler.getBCsToCompileForPackaging(baseScope);\n\n    try {\n      for (Pair<Module, FlexBuildConfiguration> moduleAndBC : FlexCompiler.getModulesAndBCsToCompile(baseScope)) {\n        final Module module = moduleAndBC.first;\n        final FlexBuildConfiguration bc = moduleAndBC.second;\n\n        if (bcsToCompileForPackaging != null && contains(bcsToCompileForPackaging, module, bc)) {\n          final boolean forcedDebugStatus = FlexCompiler.getForcedDebugStatus(project, bc);\n          builder.addTargetId(FlexCommonUtils.getBuildTargetId(module.getName(), bc.getName(), forcedDebugStatus));\n        }\n        else if (bc.isTempBCForCompilation()) {\n          LOG.assertTrue(runConfiguration instanceof FlashRunConfiguration || runConfiguration instanceof FlexUnitRunConfiguration,\n                         bc.getName());\n          final BCBasedRunnerParameters params = runConfiguration instanceof FlashRunConfiguration\n                                                 ? ((FlashRunConfiguration)runConfiguration).getRunnerParameters()\n                                                 : ((FlexUnitRunConfiguration)runConfiguration).getRunnerParameters();\n          LOG.assertTrue(params.getModuleName().equals(module.getName()),\n                         \"Module name in run config: \" + params.getModuleName() + \", expected: \" + module.getName());\n          LOG.assertTrue(params.getBCName().equals(bc.getName()),\n                         \"BC name in run config: \" + params.getBCName() + \", expected: \" + bc.getName());\n          builder.addTargetId(FlexCommonUtils.getBuildTargetIdForRunConfig(runConfiguration.getType().getId(), runConfiguration.getName()));\n        }\n        else {\n          builder.addTargetId(FlexCommonUtils.getBuildTargetId(module.getName(), bc.getName(), null));\n        }\n      }\n    }\n    catch (ConfigurationException e) {\n      // can't happen because checked in ValidateFlashConfigurationsPrecompileTask\n      LOG.error(e);\n    }\n\n    return Collections.singletonList(builder.build());\n  }","commit_id":"14c6596913d950cfac5b2e2735c6e8bd6b83b5ee","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  public List<TargetTypeBuildScope> getBuildTargetScopes(@NotNull final CompileScope baseScope,\n                                                         @NotNull final CompilerFilter filter,\n                                                         @NotNull final Project project) {\n    final FlexCompiler flexCompiler = FlexCompiler.getInstance(project);\n    if (!filter.acceptCompiler(flexCompiler)) return Collections.emptyList();\n\n    final TargetTypeBuildScope.Builder productionBuilder = TargetTypeBuildScope.newBuilder().setTypeId(\n      FlexResourceBuildTargetType.PRODUCTION.getTypeId());\n    final TargetTypeBuildScope.Builder testBuilder = TargetTypeBuildScope.newBuilder().setTypeId(\n      FlexResourceBuildTargetType.TEST.getTypeId());\n\n    try {\n      for (Pair<Module, FlexBuildConfiguration> moduleAndBC : FlexCompiler.getModulesAndBCsToCompile(baseScope)) {\n        final Module module = moduleAndBC.first;\n        productionBuilder.addTargetId(module.getName());\n        testBuilder.addTargetId(module.getName());\n      }\n    }\n    catch (ConfigurationException e) {\n      // can't happen because checked in ValidateFlashConfigurationsPrecompileTask\n    }\n\n    return Arrays.asList(productionBuilder.build(), testBuilder.build());\n  }","id":65047,"modified_method":"@NotNull\n  public List<TargetTypeBuildScope> getBuildTargetScopes(@NotNull final CompileScope baseScope,\n                                                         @NotNull final CompilerFilter filter,\n                                                         @NotNull final Project project,\n                                                         boolean forceBuild) {\n    final FlexCompiler flexCompiler = FlexCompiler.getInstance(project);\n    if (!filter.acceptCompiler(flexCompiler)) return Collections.emptyList();\n\n    final TargetTypeBuildScope.Builder productionBuilder = TargetTypeBuildScope.newBuilder().setTypeId(\n      FlexResourceBuildTargetType.PRODUCTION.getTypeId()).setForceBuild(forceBuild);\n    final TargetTypeBuildScope.Builder testBuilder = TargetTypeBuildScope.newBuilder().setTypeId(\n      FlexResourceBuildTargetType.TEST.getTypeId()).setForceBuild(forceBuild);\n\n    try {\n      for (Pair<Module, FlexBuildConfiguration> moduleAndBC : FlexCompiler.getModulesAndBCsToCompile(baseScope)) {\n        final Module module = moduleAndBC.first;\n        productionBuilder.addTargetId(module.getName());\n        testBuilder.addTargetId(module.getName());\n      }\n    }\n    catch (ConfigurationException e) {\n      // can't happen because checked in ValidateFlashConfigurationsPrecompileTask\n    }\n\n    return Arrays.asList(productionBuilder.build(), testBuilder.build());\n  }","commit_id":"14c6596913d950cfac5b2e2735c6e8bd6b83b5ee","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private BasicResolver createIBiblioResolver(String name, String root) {\n        IBiblioWharfResolver iBiblioResolver = new IBiblioWharfResolver();\n        iBiblioResolver.setUsepoms(true);\n        iBiblioResolver.setName(name);\n        iBiblioResolver.setRoot(root);\n        iBiblioResolver.setPattern(ResolverContainer.MAVEN_REPO_PATTERN);\n        iBiblioResolver.setM2compatible(true);\n        iBiblioResolver.setUseMavenMetadata(true);\n        iBiblioResolver.setChecksums(\"\");\n        return iBiblioResolver;\n    }","id":65048,"modified_method":"private BasicResolver createIBiblioResolver(String name, String root) {\n        IBiblioResolver resolver;\n\n        URI rootUri;\n        try {\n            rootUri = new URI(root);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n        if (rootUri.getScheme().equalsIgnoreCase(\"file\")) {\n            resolver = new IBiblioResolver();\n            resolver.setRepository(new FileRepository());\n            resolver.setRoot(rootUri.getPath());\n            resolver.setRepositoryCacheManager(new LocalFileRepositoryCacheManager(name));\n        } else {\n            IBiblioWharfResolver wharfResolver = new IBiblioWharfResolver();\n            wharfResolver.setSnapshotTimeout(IBiblioWharfResolver.DAILY);\n            resolver = wharfResolver;\n            resolver.setRoot(root);\n        }\n\n        resolver.setUsepoms(true);\n        resolver.setName(name);\n        resolver.setPattern(ResolverContainer.MAVEN_REPO_PATTERN);\n        resolver.setM2compatible(true);\n        resolver.setUseMavenMetadata(true);\n        resolver.setChecksums(\"\");\n\n        return resolver;\n    }","commit_id":"a0cd1d6584e5e58a39a67e83fa8e19715a9d3bbb","url":"https://github.com/gradle/gradle"},{"original_method":"public void createResolvers(Collection<DependencyResolver> resolvers) {\n        URI rootUri = getUrl();\n        if (rootUri == null) {\n            throw new InvalidUserDataException(\"You must specify a URL for a Maven repository.\");\n        }\n\n        MavenResolver resolver;\n        if (rootUri.getScheme().equalsIgnoreCase(\"file\")) {\n            resolver = new MavenResolver();\n            resolver.setRepository(new FileRepository());\n            resolver.setRoot(new File(rootUri).getAbsolutePath());\n            resolver.setRepositoryCacheManager(new LocalFileRepositoryCacheManager(name));\n        } else {\n            resolver = new MavenResolver();\n            resolver.setRoot(rootUri.toString());\n        }\n\n        resolver.setUsepoms(true);\n        resolver.setName(name);\n        resolver.setPattern(ArtifactRepositoryContainer.MAVEN_REPO_PATTERN);\n        resolver.setM2compatible(true);\n        resolver.setUseMavenMetadata(true);\n        resolver.setChecksums(\"\");\n\n        Collection<URI> artifactUrls = getArtifactUrls();\n        if (artifactUrls.isEmpty()) {\n            resolver.setDescriptor(IBiblioResolver.DESCRIPTOR_OPTIONAL);\n            resolvers.add(resolver);\n            return;\n        }\n\n        resolver.setName(name + \"_poms\");\n\n        URLResolver artifactResolver = new UrlWharfResolver();\n        artifactResolver.setName(name + \"_jars\");\n        artifactResolver.setM2compatible(true);\n        artifactResolver.setChecksums(\"\");\n        artifactResolver.addArtifactPattern(rootUri.toString() + '/' + ArtifactRepositoryContainer.MAVEN_REPO_PATTERN);\n        for (URI repoUrl : artifactUrls) {\n            artifactResolver.addArtifactPattern(repoUrl.toString() + '/' + ArtifactRepositoryContainer.MAVEN_REPO_PATTERN);\n        }\n\n        DualResolver dualResolver = new DualResolver();\n        dualResolver.setName(name);\n        dualResolver.setIvyResolver(resolver);\n        dualResolver.setArtifactResolver(artifactResolver);\n        dualResolver.setDescriptor(DualResolver.DESCRIPTOR_OPTIONAL);\n\n        resolvers.add(dualResolver);\n    }","id":65049,"modified_method":"public void createResolvers(Collection<DependencyResolver> resolvers) {\n        URI rootUri = getUrl();\n        if (rootUri == null) {\n            throw new InvalidUserDataException(\"You must specify a URL for a Maven repository.\");\n        }\n\n        MavenResolver resolver = new MavenResolver();\n        resolver.setName(name);\n        resolver.setM2compatible(true);\n        resolver.setDescriptor(IBiblioResolver.DESCRIPTOR_OPTIONAL);\n\n        if (rootUri.getScheme().equalsIgnoreCase(\"file\")) {\n            resolver.setRepository(new FileRepository());\n            resolver.setRepositoryCacheManager(new LocalFileRepositoryCacheManager(name));\n\n            resolver.setRoot(getFilePath(rootUri));\n            \n            Collection<URI> artifactUrls = getArtifactUrls();\n            for (URI repoUrl : artifactUrls) {\n                resolver.addArtifactUrl(getFilePath(repoUrl));\n            }\n        } else {\n            resolver.setRepository(new CommonsHttpClientBackedRepository(null, null));\n            resolver.setRoot(getUriPath(rootUri));\n\n            Collection<URI> artifactUrls = getArtifactUrls();\n            for (URI repoUrl : artifactUrls) {\n                resolver.addArtifactUrl(getUriPath(repoUrl));\n            }\n        }\n        resolvers.add(resolver);\n    }","commit_id":"b3e05cd6f0b06c3308c5704ef667a18d8f980e5a","url":"https://github.com/gradle/gradle"},{"original_method":"public void createResolvers(Collection<DependencyResolver> resolvers) {\n        URI rootUri = getUrl();\n        if (rootUri == null) {\n            throw new InvalidUserDataException(\"You must specify a URL for a Maven repository.\");\n        }\n\n        IBiblioResolver resolver;\n\n        if (rootUri.getScheme().equalsIgnoreCase(\"file\")) {\n            resolver = new IBiblioResolver();\n            resolver.setRepository(new FileRepository());\n            resolver.setRoot(new File(rootUri).getAbsolutePath());\n            resolver.setRepositoryCacheManager(new LocalFileRepositoryCacheManager(name));\n        } else {\n            IBiblioWharfResolver wharfResolver = new IBiblioWharfResolver();\n            wharfResolver.setSnapshotTimeout(IBiblioWharfResolver.DAILY);\n            resolver = wharfResolver;\n            resolver.setRoot(rootUri.toString());\n        }\n\n        resolver.setUsepoms(true);\n        resolver.setName(name);\n        resolver.setPattern(ArtifactRepositoryContainer.MAVEN_REPO_PATTERN);\n        resolver.setM2compatible(true);\n        resolver.setUseMavenMetadata(true);\n        resolver.setChecksums(\"\");\n\n        Collection<URI> artifactUrls = getArtifactUrls();\n        if (artifactUrls.isEmpty()) {\n            resolver.setDescriptor(IBiblioResolver.DESCRIPTOR_OPTIONAL);\n            resolvers.add(resolver);\n            return;\n        }\n\n        resolver.setName(name + \"_poms\");\n\n        URLResolver artifactResolver = new UrlWharfResolver();\n        artifactResolver.setName(name + \"_jars\");\n        artifactResolver.setM2compatible(true);\n        artifactResolver.setChecksums(\"\");\n        artifactResolver.addArtifactPattern(rootUri.toString() + '/' + ArtifactRepositoryContainer.MAVEN_REPO_PATTERN);\n        for (URI repoUrl : artifactUrls) {\n            artifactResolver.addArtifactPattern(repoUrl.toString() + '/' + ArtifactRepositoryContainer.MAVEN_REPO_PATTERN);\n        }\n\n        DualResolver dualResolver = new DualResolver();\n        dualResolver.setName(name);\n        dualResolver.setIvyResolver(resolver);\n        dualResolver.setArtifactResolver(artifactResolver);\n        dualResolver.setDescriptor(DualResolver.DESCRIPTOR_OPTIONAL);\n\n        resolvers.add(dualResolver);\n    }","id":65050,"modified_method":"public void createResolvers(Collection<DependencyResolver> resolvers) {\n        URI rootUri = getUrl();\n        if (rootUri == null) {\n            throw new InvalidUserDataException(\"You must specify a URL for a Maven repository.\");\n        }\n\n        MavenResolver resolver;\n        if (rootUri.getScheme().equalsIgnoreCase(\"file\")) {\n            resolver = new MavenResolver();\n            resolver.setRepository(new FileRepository());\n            resolver.setRoot(new File(rootUri).getAbsolutePath());\n            resolver.setRepositoryCacheManager(new LocalFileRepositoryCacheManager(name));\n        } else {\n            resolver = new MavenResolver();\n            resolver.setRoot(rootUri.toString());\n        }\n\n        resolver.setUsepoms(true);\n        resolver.setName(name);\n        resolver.setPattern(ArtifactRepositoryContainer.MAVEN_REPO_PATTERN);\n        resolver.setM2compatible(true);\n        resolver.setUseMavenMetadata(true);\n        resolver.setChecksums(\"\");\n\n        Collection<URI> artifactUrls = getArtifactUrls();\n        if (artifactUrls.isEmpty()) {\n            resolver.setDescriptor(IBiblioResolver.DESCRIPTOR_OPTIONAL);\n            resolvers.add(resolver);\n            return;\n        }\n\n        resolver.setName(name + \"_poms\");\n\n        URLResolver artifactResolver = new UrlWharfResolver();\n        artifactResolver.setName(name + \"_jars\");\n        artifactResolver.setM2compatible(true);\n        artifactResolver.setChecksums(\"\");\n        artifactResolver.addArtifactPattern(rootUri.toString() + '/' + ArtifactRepositoryContainer.MAVEN_REPO_PATTERN);\n        for (URI repoUrl : artifactUrls) {\n            artifactResolver.addArtifactPattern(repoUrl.toString() + '/' + ArtifactRepositoryContainer.MAVEN_REPO_PATTERN);\n        }\n\n        DualResolver dualResolver = new DualResolver();\n        dualResolver.setName(name);\n        dualResolver.setIvyResolver(resolver);\n        dualResolver.setArtifactResolver(artifactResolver);\n        dualResolver.setDescriptor(DualResolver.DESCRIPTOR_OPTIONAL);\n\n        resolvers.add(dualResolver);\n    }","commit_id":"6ad9dc6fc7a7dafc5caed2efcde6479988db8ead","url":"https://github.com/gradle/gradle"},{"original_method":"public void maybeSaveDynamicRevision(DependencyDescriptor original, ResolvedModuleRevision downloadedModule) {\n            if (downloadedModule == null) {\n                return;\n            }\n\n            ModuleRevisionId originalId = original.getDependencyRevisionId();\n            ModuleRevisionId resolvedId = downloadedModule.getId();\n            if (originalId.equals(resolvedId) && !original.isChanging()) {\n                return;\n            }\n\n            LOGGER.debug(\"Caching resolved revision in dynamic revision cache: Will use '{}' for '{}'\", resolvedId, originalId);\n            dynamicVersionCache.saveResolvedDynamicVersion(downloadedModule.getResolver(), originalId, resolvedId);\n        }","id":65051,"modified_method":"public void maybeSaveDynamicRevision(DependencyDescriptor original, ResolvedModuleRevision downloadedModule) {\n            if (downloadedModule == null) {\n                return;\n            }\n\n            ModuleRevisionId originalId = original.getDependencyRevisionId();\n            ModuleRevisionId resolvedId = downloadedModule.getId();\n            if (originalId.equals(resolvedId) && !isChanging(original)) {\n                return;\n            }\n\n            LOGGER.debug(\"Caching resolved revision in dynamic revision cache: Will use '{}' for '{}'\", resolvedId, originalId);\n            dynamicVersionCache.saveResolvedDynamicVersion(downloadedModule.getResolver(), originalId, resolvedId);\n        }","commit_id":"6ad9dc6fc7a7dafc5caed2efcde6479988db8ead","url":"https://github.com/gradle/gradle"},{"original_method":"public DependencyDescriptor maybeResolveDynamicRevision(DependencyResolver resolver, DependencyDescriptor original) {\n            assert dynamicVersionCachePolicy != null : \"dynamicRevisionExpiryPolicy was not configured\";\n\n            ModuleRevisionId originalId = original.getDependencyRevisionId();\n            DynamicVersionCache.ResolvedDynamicVersion resolvedRevision = dynamicVersionCache.getResolvedDynamicVersion(resolver, originalId);\n            if (resolvedRevision == null) {\n                return original;\n            }\n            if (dynamicVersionCachePolicy.mustCheckForUpdates(resolvedRevision.getModule(), resolvedRevision.getAgeMillis())) {\n                LOGGER.debug(\"Resolved revision in dynamic revision cache is expired: will perform fresh resolve of '{}'\", originalId);\n                return original;\n            }\n            \n            if (originalId.equals(resolvedRevision.getRevision())) {\n                LOGGER.debug(\"Found cached version of changing module: Using cached metadata for '{}'\", originalId);\n                return ForceChangeDependencyDescriptor.forceChangingFlag(original, false);\n            }\n\n            LOGGER.debug(\"Found resolved revision in dynamic revision cache: Using '{}' for '{}'\", resolvedRevision.getRevision(), originalId);\n            return original.clone(resolvedRevision.getRevision());\n        }","id":65052,"modified_method":"public DependencyDescriptor maybeResolveDynamicRevision(DependencyResolver resolver, DependencyDescriptor original) {\n            assert dynamicVersionCachePolicy != null : \"dynamicRevisionExpiryPolicy was not configured\";\n\n            ModuleRevisionId originalId = original.getDependencyRevisionId();\n            DynamicVersionCache.ResolvedDynamicVersion resolvedRevision = dynamicVersionCache.getResolvedDynamicVersion(resolver, originalId);\n            if (resolvedRevision == null) {\n                return tweakSnapshot(original);\n            }\n            if (dynamicVersionCachePolicy.mustCheckForUpdates(resolvedRevision.getModule(), resolvedRevision.getAgeMillis())) {\n                LOGGER.debug(\"Resolved revision in dynamic revision cache is expired: will perform fresh resolve of '{}'\", originalId);\n                return tweakSnapshot(original);\n            }\n            \n            if (originalId.equals(resolvedRevision.getRevision())) {\n                LOGGER.debug(\"Found cached version of changing module: Using cached metadata for '{}'\", originalId);\n                return ForceChangeDependencyDescriptor.forceChangingFlag(original, false);\n            }\n\n            LOGGER.debug(\"Found resolved revision in dynamic revision cache: Using '{}' for '{}'\", resolvedRevision.getRevision(), originalId);\n            return original.clone(resolvedRevision.getRevision());\n        }","commit_id":"6ad9dc6fc7a7dafc5caed2efcde6479988db8ead","url":"https://github.com/gradle/gradle"},{"original_method":"public void resolveModule() {\n            try {\n                resolvedModule = resolver.getDependency(descriptor, resolveData);\n                dynamicRevisions.maybeSaveDynamicRevision(descriptor, resolvedModule);\n            } catch (ParseException e) {\n                throw new RuntimeException(e);\n            }\n        }","id":65053,"modified_method":"public void resolveModule() {\n            try {\n                resolvedModule = resolver.getDependency(resolvedDescriptor, resolveData);\n                dynamicRevisions.maybeSaveDynamicRevision(descriptor, resolvedModule);\n            } catch (ParseException e) {\n                throw new RuntimeException(e);\n            }\n        }","commit_id":"6ad9dc6fc7a7dafc5caed2efcde6479988db8ead","url":"https://github.com/gradle/gradle"},{"original_method":"public void lookupModuleInCache() {\n            DependencyDescriptor resolvedDynamicDependency = dynamicRevisions.maybeResolveDynamicRevision(resolver, descriptor);\n\n            resolvedModule = findModuleInCache(resolver, resolvedDynamicDependency, resolveData);\n        }","id":65054,"modified_method":"public void lookupModuleInCache() {\n            resolvedDescriptor = dynamicRevisions.maybeResolveDynamicRevision(resolver, descriptor);\n            resolvedModule = findModuleInCache(resolver, resolvedDescriptor, resolveData);\n        }","commit_id":"6ad9dc6fc7a7dafc5caed2efcde6479988db8ead","url":"https://github.com/gradle/gradle"},{"original_method":"public int countByC_N_D(\n\t\t\tlong companyId, String name, String description,\n\t\t\tLinkedHashMap<String, Object> params)\n\t\tthrows SystemException {\n\n\t\tname = StringUtil.lowerCase(name);\n\t\tdescription = StringUtil.lowerCase(description);\n\n\t\tif (params == null) {\n\t\t\tparams = new LinkedHashMap<String, Object>();\n\t\t}\n\n\t\tLong userId = (Long)params.get(\"usersGroups\");\n\n\t\tLinkedHashMap<String, Object> params1 = params;\n\n\t\tLinkedHashMap<String, Object> params2 =\n\t\t\tnew LinkedHashMap<String, Object>();\n\n\t\tparams2.putAll(params1);\n\n\t\tif (userId != null) {\n\t\t\tparams2.remove(\"usersGroups\");\n\t\t\tparams2.put(\"groupsOrgs\", userId);\n\t\t}\n\n\t\tLinkedHashMap<String, Object> params3 =\n\t\t\tnew LinkedHashMap<String, Object>();\n\n\t\tparams3.putAll(params1);\n\n\t\tif (userId != null) {\n\t\t\tparams3.remove(\"usersGroups\");\n\t\t\tparams3.put(\"groupsUserGroups\", userId);\n\t\t}\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = openSession();\n\n\t\t\tint count = countByC_N_D(\n\t\t\t\tsession, companyId, name, description, params1);\n\n\t\t\tif (Validator.isNotNull(userId)) {\n\t\t\t\tcount += countByC_N_D(\n\t\t\t\t\tsession, companyId, name, description, params2);\n\n\t\t\t\tcount += countByC_N_D(\n\t\t\t\t\tsession, companyId, name, description, params3);\n\t\t\t}\n\n\t\t\treturn count;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t\tfinally {\n\t\t\tcloseSession(session);\n\t\t}\n\t}","id":65055,"modified_method":"public int countByC_N_D(\n\t\t\tlong companyId, String name, String description,\n\t\t\tLinkedHashMap<String, Object> params)\n\t\tthrows SystemException {\n\n\t\tname = StringUtil.lowerCase(name);\n\t\tdescription = StringUtil.lowerCase(description);\n\n\t\tif (params == null) {\n\t\t\tparams = new LinkedHashMap<String, Object>();\n\t\t}\n\n\t\tLong userId = (Long)params.get(\"usersGroups\");\n\n\t\tLinkedHashMap<String, Object> params1 = params;\n\n\t\tLinkedHashMap<String, Object> params2 =\n\t\t\tnew LinkedHashMap<String, Object>();\n\n\t\tparams2.putAll(params1);\n\n\t\tif (userId != null) {\n\t\t\tparams2.remove(\"usersGroups\");\n\t\t\tparams2.put(\"groupsOrgs\", userId);\n\t\t}\n\n\t\tLinkedHashMap<String, Object> params3 =\n\t\t\tnew LinkedHashMap<String, Object>();\n\n\t\tparams3.putAll(params1);\n\n\t\tif (userId != null) {\n\t\t\tparams3.remove(\"usersGroups\");\n\t\t\tparams3.put(\"groupsUserGroups\", userId);\n\t\t}\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = openSession();\n\n\t\t\tSet<Long> count = new HashSet<Long>();\n\n\t\t\tcount.addAll(\n\t\t\t\tcountByC_N_D(session, companyId, name, description, params1));\n\n\t\t\tif (Validator.isNotNull(userId)) {\n\t\t\t\tcount.addAll(\n\t\t\t\t\tcountByC_N_D(\n\t\t\t\t\t\tsession, companyId, name, description, params2));\n\n\t\t\t\tcount.addAll(\n\t\t\t\t\tcountByC_N_D(\n\t\t\t\t\t\tsession, companyId, name, description, params3));\n\t\t\t}\n\n\t\t\treturn count.size();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t\tfinally {\n\t\t\tcloseSession(session);\n\t\t}\n\t}","commit_id":"e065a965093bd0157eb709a043544c4c8a47c03f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected int countByC_N_D(\n\t\tSession session, long companyId, String name, String description,\n\t\tLinkedHashMap<String, Object> params) {\n\n\t\tString sql = CustomSQLUtil.get(COUNT_BY_C_N_D);\n\n\t\tsql = StringUtil.replace(sql, \"[$JOIN$]\", getJoin(params));\n\t\tsql = StringUtil.replace(sql, \"[$WHERE$]\", getWhere(params));\n\n\t\tSQLQuery q = session.createSQLQuery(sql);\n\n\t\tq.addScalar(COUNT_COLUMN_NAME, Type.LONG);\n\n\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\tsetJoin(qPos, params);\n\t\tqPos.add(companyId);\n\t\tqPos.add(name);\n\t\tqPos.add(name);\n\t\tqPos.add(description);\n\t\tqPos.add(description);\n\n\t\tIterator<Long> itr = q.list().iterator();\n\n\t\tif (itr.hasNext()) {\n\t\t\tLong count = itr.next();\n\n\t\t\tif (count != null) {\n\t\t\t\treturn count.intValue();\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}","id":65056,"modified_method":"protected List<Long> countByC_N_D(\n\t\tSession session, long companyId, String name, String description,\n\t\tLinkedHashMap<String, Object> params) {\n\n\t\tString sql = CustomSQLUtil.get(COUNT_BY_C_N_D);\n\n\t\tsql = StringUtil.replace(sql, \"[$JOIN$]\", getJoin(params));\n\t\tsql = StringUtil.replace(sql, \"[$WHERE$]\", getWhere(params));\n\n\t\tSQLQuery q = session.createSQLQuery(sql);\n\n\t\tq.addScalar(\"groupId\", Type.LONG);\n\n\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\tsetJoin(qPos, params);\n\t\tqPos.add(companyId);\n\t\tqPos.add(name);\n\t\tqPos.add(name);\n\t\tqPos.add(description);\n\t\tqPos.add(description);\n\n\t\treturn q.list();\n\t}","commit_id":"e065a965093bd0157eb709a043544c4c8a47c03f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/** @since 0.9.11 */\n    public boolean getUseOutproxyPlugin(int tunnel) {\n        return getBooleanProperty(tunnel, I2PTunnelHTTPClient.PROP_USE_OUTPROXY_PLUGIN);\n    }","id":65057,"modified_method":"/**\n     *  Default true\n     *  @since 0.9.11\n     */\n    public boolean getUseOutproxyPlugin(int tunnel) {\n        return Boolean.parseBoolean(getProperty(tunnel, I2PTunnelHTTPClient.PROP_USE_OUTPROXY_PLUGIN, \"true\"));\n    }","commit_id":"9ca625a64e8d5a5355c8d4b4b96a8b7f0da82b92","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"protected void clientConnectionRun(Socket s) {\n        OutputStream out = null;\n\n        /**\n         * The URL after fixup, always starting with http://\n         */\n        String targetRequest = null;\n\n        boolean usingWWWProxy = false;\n        boolean usingOutproxy = false;\n        Outproxy outproxy = null;\n        boolean usingInternalServer = false;\n        String internalPath = null;\n        String internalRawQuery = null;\n        String currentProxy = null;\n        long requestId = __requestId.incrementAndGet();\n        boolean shout = false;\n\n        try {\n            out = s.getOutputStream();\n            InputReader reader = new InputReader(s.getInputStream());\n            String line, method = null, protocol = null, host = null, destination = null;\n            StringBuilder newRequest = new StringBuilder();\n            boolean ahelperPresent = false;\n            boolean ahelperNew = false;\n            String ahelperKey = null;\n            String userAgent = null;\n            String authorization = null;\n            int remotePort = 0;\n            String referer = null;\n            while((line = reader.readLine(method)) != null) {\n                line = line.trim();\n                if(_log.shouldLog(Log.DEBUG)) {\n                    _log.debug(getPrefix(requestId) + \"Line=[\" + line + \"]\");\n                }\n\n                String lowercaseLine = line.toLowerCase(Locale.US);\n                if(lowercaseLine.startsWith(\"connection: \") ||\n                        lowercaseLine.startsWith(\"keep-alive: \") ||\n                        lowercaseLine.startsWith(\"proxy-connection: \")) {\n                    continue;\n                }\n\n                if(method == null) { // first line (GET /base64/realaddr)\n                    if(_log.shouldLog(Log.DEBUG)) {\n                        _log.debug(getPrefix(requestId) + \"First line [\" + line + \"]\");\n                    }\n\n                    String[] params = line.split(\" \", 3);\n                    if(params.length != 3) {\n                        break;\n                    }\n                    String request = params[1];\n\n                    // various obscure fixups\n                    if(request.startsWith(\"/\") && getTunnel().getClientOptions().getProperty(\"i2ptunnel.noproxy\") != null) {\n                        // what is this for ???\n                        request = \"http://i2p\" + request;\n                    } else if(request.startsWith(\"/eepproxy/\")) {\n                        // Deprecated\n                        // /eepproxy/foo.i2p/bar/baz.html\n                        String subRequest = request.substring(\"/eepproxy/\".length());\n                        if(subRequest.indexOf(\"/\") == -1) {\n                            subRequest += \"/\";\n                        }\n                        request = \"http://\" + subRequest;\n                    /****\n                    } else if (request.toLowerCase(Locale.US).startsWith(\"http://i2p/\")) {\n                    // http://i2p/b64key/bar/baz.html\n                    // we can't do this now by setting the URI host to the b64key, as\n                    // it probably contains '=' and '~' which are illegal,\n                    // and a host may not include escaped octets\n                    // This will get undone below.\n                    String subRequest = request.substring(\"http://i2p/\".length());\n                    if (subRequest.indexOf(\"/\") == -1)\n                    subRequest += \"/\";\n                    \"http://\" + \"b64key/bar/baz.html\"\n                    request = \"http://\" + subRequest;\n                    } else if (request.toLowerCase(Locale.US).startsWith(\"http://\")) {\n                    // Unsupported\n                    // http://$b64key/...\n                    // This probably used to work, rewrite it so that\n                    // we can create a URI without illegal characters\n                    // This will get undone below.\n                    String  oldPath = request.substring(7);\n                    int slash = oldPath.indexOf(\"/\");\n                    if (slash < 0)\n                    slash = oldPath.length();\n                    if (slash >= 516 && !oldPath.substring(0, slash).contains(\".\"))\n                    request = \"http://i2p/\" + oldPath;\n                     ****/\n                    }\n\n                    method = params[0];\n                    if (method.toUpperCase(Locale.US).equals(\"CONNECT\")) {\n                        // this makes things easier later, by spoofing a\n                        // protocol so the URI parser find the host and port\n                        // FIXME breaks in-net outproxy\n                        request = \"https://\" + request + '/';\n                    }\n\n                    // Now use the Java URI parser\n                    // This will be the incoming URI but will then get modified\n                    // to be the outgoing URI (with http:// if going to outproxy, otherwise without)\n                    URI requestURI;\n                    try {\n                        requestURI = new URI(request);\n                        if(requestURI.getRawUserInfo() != null || requestURI.getRawFragment() != null) {\n                            // these should never be sent to the proxy in the request line\n                            if(_log.shouldLog(Log.WARN)) {\n                                _log.warn(getPrefix(requestId) + \"Removing userinfo or fragment [\" + request + \"]\");\n                            }\n                            requestURI = changeURI(requestURI, null, 0, null);\n                        }\n                        if(requestURI.getPath() == null || requestURI.getPath().length() <= 0) {\n                            // Add a path\n                            if(_log.shouldLog(Log.WARN)) {\n                                _log.warn(getPrefix(requestId) + \"Adding / path to [\" + request + \"]\");\n                            }\n                            requestURI = changeURI(requestURI, null, 0, \"/\");\n                        }\n                    } catch(URISyntaxException use) {\n                        if(_log.shouldLog(Log.WARN)) {\n                            _log.warn(getPrefix(requestId) + \"Bad request [\" + request + \"]\", use);\n                        }\n                        if(out != null) {\n                            out.write(getErrorPage(\"baduri\", ERR_BAD_URI));\n                            writeFooter(out);\n                        }\n                        s.close();\n                        return;\n                    }\n\n                    String protocolVersion = params[2];\n\n                    protocol = requestURI.getScheme();\n                    host = requestURI.getHost();\n                    if(protocol == null || host == null) {\n                        _log.warn(\"Null protocol or host: \" + request + ' ' + protocol + ' ' + host);\n                        method = null;\n                        break;\n                    }\n\n                    int port = requestURI.getPort();\n\n                    // Go through the various types of host names, set\n                    // the host and destination variables accordingly,\n                    // and transform the first line.\n                    // For all i2p network hosts, ensure that the host is a\n                    // Base 32 hostname so that we do not reveal our name for it\n                    // in our addressbook (all naming is local),\n                    // and it is removed from the request line.\n\n                    String hostLowerCase = host.toLowerCase(Locale.US);\n                    if(hostLowerCase.equals(LOCAL_SERVER)) {\n                        // so we don't do any naming service lookups\n                        destination = host;\n                        usingInternalServer = true;\n                        internalPath = requestURI.getPath();\n                        internalRawQuery = requestURI.getRawQuery();\n                    } else if(hostLowerCase.equals(\"i2p\")) {\n                        // pull the b64 _dest out of the first path element\n                        String oldPath = requestURI.getPath().substring(1);\n                        int slash = oldPath.indexOf(\"/\");\n                        if(slash < 0) {\n                            slash = oldPath.length();\n                            oldPath += \"/\";\n                        }\n                        String _dest = oldPath.substring(0, slash);\n                        if(slash >= 516 && !_dest.contains(\".\")) {\n                            // possible alternative:\n                            // redirect to b32\n                            destination = _dest;\n                            host = getHostName(destination);\n                            targetRequest = requestURI.toASCIIString();\n                            String newURI = oldPath.substring(slash);\n                            String query = requestURI.getRawQuery();\n                            if(query != null) {\n                                newURI += '?' + query;\n                            }\n                            try {\n                                requestURI = new URI(newURI);\n                            } catch(URISyntaxException use) {\n                                // shouldnt happen\n                                _log.warn(request, use);\n                                method = null;\n                                break;\n                            }\n                        } else {\n                            _log.warn(\"Bad http://i2p/b64dest \" + request);\n                            host = null;\n                            break;\n                        }\n                    } else if(hostLowerCase.endsWith(\".i2p\")) {\n                        // Destination gets the host name\n                        destination = host;\n                        // Host becomes the destination's \"{b32}.b32.i2p\" string, or \"i2p\" on lookup failure\n                        host = getHostName(destination);\n\n                        int rPort = requestURI.getPort();\n                        if (rPort > 0) {\n                            // Save it to put in the I2PSocketOptions,\n                            remotePort = rPort;\n                         /********\n                            // but strip it from the URL\n                            if(_log.shouldLog(Log.WARN)) {\n                                _log.warn(getPrefix(requestId) + \"Removing port from [\" + request + \"]\");\n                            }\n                            try {\n                                requestURI = changeURI(requestURI, null, -1, null);\n                            } catch(URISyntaxException use) {\n                                _log.warn(request, use);\n                                method = null;\n                                break;\n                            }\n                          ******/\n                        } else if (\"https\".equals(protocol) ||\n                                   method.toUpperCase(Locale.US).equals(\"CONNECT\")) {\n                            remotePort = 443;\n                        } else {\n                            remotePort = 80;\n                        }\n\n                        String query = requestURI.getRawQuery();\n                        if(query != null) {\n                            boolean ahelperConflict = false;\n\n                            // Try to find an address helper in the query\n                            String[] helperStrings = removeHelper(query);\n                            if(helperStrings != null &&\n                                    !Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_DISABLE_HELPER))) {\n                                query = helperStrings[0];\n                                if(query.equals(\"\")) {\n                                    query = null;\n                                }\n                                try {\n                                    requestURI = replaceQuery(requestURI, query);\n                                } catch(URISyntaxException use) {\n                                    // shouldn't happen\n                                    _log.warn(request, use);\n                                    method = null;\n                                    break;\n                                }\n                                ahelperKey = helperStrings[1];\n                                // Key contains data, lets not ignore it\n                                if(ahelperKey.length() > 0) {\n                                    if(ahelperKey.endsWith(\".i2p\")) {\n                                        // allow i2paddresshelper=<b32>.b32.i2p syntax.\n                                        /*\n                                        also i2paddresshelper=name.i2p for aliases\n                                        i.e. on your eepsite put\n                                        <a href=\"?i2paddresshelper=name.i2p\">This is the name I want to be called.<\/a>\n                                         */\n                                        Destination _dest = _context.namingService().lookup(ahelperKey);\n                                        if(_dest == null) {\n                                            if(_log.shouldLog(Log.WARN)) {\n                                                _log.warn(getPrefix(requestId) + \"Could not find destination for \" + ahelperKey);\n                                            }\n                                            byte[] header = getErrorPage(\"ahelper-notfound\", ERR_AHELPER_NOTFOUND);\n                                            out.write(header);\n                                            out.write((\"<p>\" + _(\"This seems to be a bad destination:\") + \" \" + ahelperKey + \" \" + _(\"i2paddresshelper cannot help you with a destination like that!\") + \"<\/p>\").getBytes(\"UTF-8\"));\n                                            writeFooter(out);\n                                            // XXX: should closeSocket(s) be in a finally block?\n                                            closeSocket(s);\n                                            return;\n                                        }\n                                        ahelperKey = _dest.toBase64();\n                                    }\n\n                                    ahelperPresent = true;\n                                    // ahelperKey will be validated later\n                                    if(host == null || \"i2p\".equals(host)) {\n                                        // Host lookup failed - resolvable only with addresshelper\n                                        // Store in local HashMap unless there is conflict\n                                        String old = addressHelpers.putIfAbsent(destination.toLowerCase(Locale.US), ahelperKey);\n                                        ahelperNew = old == null;\n                                        if((!ahelperNew) && !old.equals(ahelperKey)) {\n                                            // Conflict: handle when URL reconstruction done\n                                            ahelperConflict = true;\n                                            if(_log.shouldLog(Log.WARN)) {\n                                                _log.warn(getPrefix(requestId) + \"Addresshelper key conflict for site [\" + destination +\n                                                        \"], trusted key [\" + old + \"], specified key [\" + ahelperKey + \"].\");\n                                            }\n                                        }\n                                    } else {\n                                        // If the host is resolvable from database, verify addresshelper key\n                                        // Silently bypass correct keys, otherwise alert\n                                        Destination hostDest = _context.namingService().lookup(destination);\n                                        if(hostDest != null) {\n                                            String destB64 = hostDest.toBase64();\n                                            if(destB64 != null && !destB64.equals(ahelperKey)) {\n                                                // Conflict: handle when URL reconstruction done\n                                                ahelperConflict = true;\n                                                if(_log.shouldLog(Log.WARN)) {\n                                                    _log.warn(getPrefix(requestId) + \"Addresshelper key conflict for site [\" + destination +\n                                                            \"], trusted key [\" + destB64 + \"], specified key [\" + ahelperKey + \"].\");\n                                                }\n\n                                            }\n                                        }\n                                    }\n                                } // ahelperKey\n                            } // helperstrings\n\n                            // Did addresshelper key conflict?\n                            if(ahelperConflict) {\n                                if(out != null) {\n                                    // convert ahelperKey to b32\n                                    String alias = getHostName(ahelperKey);\n                                    if(alias.equals(\"i2p\")) {\n                                        // bad ahelperKey\n                                        byte[] header = getErrorPage(\"dnfb\", ERR_DESTINATION_UNKNOWN);\n                                        writeErrorMessage(header, out, targetRequest, false, destination, null);\n                                    } else {\n                                        String trustedURL = requestURI.toASCIIString();\n                                        URI conflictURI;\n                                        try {\n                                            conflictURI = changeURI(requestURI, alias, 0, null);\n                                        } catch(URISyntaxException use) {\n                                            // shouldn't happen\n                                            _log.warn(request, use);\n                                            method = null;\n                                            break;\n                                        }\n                                        String conflictURL = conflictURI.toASCIIString();\n                                        byte[] header = getErrorPage(\"ahelper-conflict\", ERR_AHELPER_CONFLICT);\n                                        out.write(header);\n                                        out.write(_(\"To visit the destination in your host database, click <a href=\\\"{0}\\\">here<\/a>. To visit the conflicting addresshelper destination, click <a href=\\\"{1}\\\">here<\/a>.\", trustedURL, conflictURL).getBytes(\"UTF-8\"));\n                                        out.write((\"<\/p><\/div>\").getBytes());\n                                        writeFooter(out);\n                                    }\n                                }\n                                s.close();\n                                return;\n                            }\n                        }  // end query processing\n\n                        String addressHelper = addressHelpers.get(destination);\n                        if(addressHelper != null) {\n                            host = getHostName(addressHelper);\n                        }\n\n                        // now strip everything but path and query from URI\n                        targetRequest = requestURI.toASCIIString();\n                        String newURI = requestURI.getRawPath();\n                        if(query != null) {\n                            newURI += '?' + query;\n                        }\n                        try {\n                            requestURI = new URI(newURI);\n                        } catch(URISyntaxException use) {\n                            // shouldnt happen\n                            _log.warn(request, use);\n                            method = null;\n                            break;\n                        }\n\n                    // end of (host endsWith(\".i2p\"))\n\n                    } else if(hostLowerCase.equals(\"localhost\") || host.equals(\"127.0.0.1\") ||\n                            host.startsWith(\"192.168.\") || host.equals(\"[::1]\")) {\n                        // if somebody is trying to get to 192.168.example.com, oh well\n                        if(out != null) {\n                            out.write(getErrorPage(\"localhost\", ERR_LOCALHOST));\n                            writeFooter(out);\n                        }\n                        s.close();\n                        return;\n                    } else if(host.contains(\".\") || host.startsWith(\"[\")) {\n                        if (Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_USE_OUTPROXY_PLUGIN))) {\n                            ClientAppManager mgr = _context.clientAppManager();\n                            if (mgr != null) {\n                                ClientApp op = mgr.getRegisteredApp(Outproxy.NAME);\n                                if (op != null) {\n                                    outproxy = (Outproxy) op;\n                                    int rPort = requestURI.getPort();\n                                    if (rPort > 0)\n                                        remotePort = rPort;\n                                    else if (\"https\".equals(protocol) ||\n                                             method.toUpperCase(Locale.US).equals(\"CONNECT\"))\n                                        remotePort = 443;\n                                    else\n                                        remotePort = 80;\n                                    usingOutproxy = true;\n                                    targetRequest = requestURI.toASCIIString();\n                                    if(_log.shouldLog(Log.DEBUG))\n                                        _log.debug(getPrefix(requestId) + \" [\" + host + \"]: outproxy!\");\n                                }\n                            }\n                        }\n                        if (!usingOutproxy) {\n                            if(port >= 0) {\n                                host = host + ':' + port;\n                            }\n                            // The request must be forwarded to a WWW proxy\n                            if(_log.shouldLog(Log.DEBUG)) {\n                                _log.debug(\"Before selecting outproxy for \" + host);\n                            }\n                            if (\"https\".equals(protocol) ||\n                                method.toUpperCase(Locale.US).equals(\"CONNECT\"))\n                                currentProxy = selectSSLProxy();\n                            else\n                                currentProxy = selectProxy();\n                            if(_log.shouldLog(Log.DEBUG)) {\n                                _log.debug(\"After selecting outproxy for \" + host + \": \" + currentProxy);\n                            }\n                            if(currentProxy == null) {\n                                if(_log.shouldLog(Log.WARN)) {\n                                    _log.warn(getPrefix(requestId) + \"Host wants to be outproxied, but we dont have any!\");\n                                }\n                                l.log(\"No HTTP outproxy found for the request.\");\n                                if(out != null) {\n                                    out.write(getErrorPage(\"noproxy\", _ERR_NO_OUTPROXY));\n                                    writeFooter(out);\n                                }\n                                s.close();\n                                return;\n                            }\n                            destination = currentProxy;\n                            usingWWWProxy = true;\n                            targetRequest = requestURI.toASCIIString();\n                            if(_log.shouldLog(Log.DEBUG)) {\n                                _log.debug(getPrefix(requestId) + \" [\" + host + \"]: wwwProxy!\");\n                            }\n                        }\n                    } else {\n                        // what is left for here? a hostname with no dots, and != \"i2p\"\n                        // and not a destination ???\n                        // Perhaps something in privatehosts.txt ...\n                        // Rather than look it up, just bail out.\n                        if(_log.shouldLog(Log.WARN)) {\n                            _log.warn(\"NODOTS, NOI2P: \" + request);\n                        }\n                        if(out != null) {\n                            out.write(getErrorPage(\"denied\", ERR_REQUEST_DENIED));\n                            writeFooter(out);\n                        }\n                        s.close();\n                        return;\n                    }   // end host name processing\n\n                    boolean isValid = usingOutproxy || usingWWWProxy ||\n                                      usingInternalServer || isSupportedAddress(host, protocol);\n                    if(!isValid) {\n                        if(_log.shouldLog(Log.INFO)) {\n                            _log.info(getPrefix(requestId) + \"notValid(\" + host + \")\");\n                        }\n                        method = null;\n                        destination = null;\n                        break;\n                    }\n\n                    line = method + ' ' + requestURI.toASCIIString() + ' ' + protocolVersion;\n\n                    if(_log.shouldLog(Log.DEBUG)) {\n                        _log.debug(getPrefix(requestId) + \"NEWREQ: \\\"\" + line + \"\\\"\");\n                        _log.debug(getPrefix(requestId) + \"HOST  : \\\"\" + host + \"\\\"\");\n                        _log.debug(getPrefix(requestId) + \"DEST  : \\\"\" + destination + \"\\\"\");\n                    }\n\n                // end first line processing\n\n                } else {\n                    if(lowercaseLine.startsWith(\"host: \") && !usingWWWProxy && !usingOutproxy) {\n                        // Note that we only pass the original Host: line through to the outproxy\n                        // But we don't create a Host: line if it wasn't sent to us\n                        line = \"Host: \" + host;\n                        if(_log.shouldLog(Log.INFO)) {\n                            _log.info(getPrefix(requestId) + \"Setting host = \" + host);\n                        }\n                    } else if(lowercaseLine.startsWith(\"user-agent: \")) {\n                        // save for deciding whether to offer address book form\n                        userAgent = lowercaseLine.substring(12);\n                        if(!Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_USER_AGENT))) {\n                            line = null;\n                            continue;\n                        }\n                    } else if(lowercaseLine.startsWith(\"accept\")) {\n                        // strip the accept-blah headers, as they vary dramatically from\n                        // browser to browser\n                        line = null;\n                        continue;\n                    } else if (lowercaseLine.startsWith(\"referer: \")) {\n                        // save for address helper form below\n                        referer = line.substring(9);\n                        if (!Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_REFERER))) {\n                            // Shouldn't we be more specific, like accepting in-site referers ?\n                            //line = \"Referer: i2p\";\n                            line = null;\n                            continue; // completely strip the line\n                        }\n                    } else if(lowercaseLine.startsWith(\"via: \") &&\n                            !Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_VIA))) {\n                        //line = \"Via: i2p\";\n                        line = null;\n                        continue; // completely strip the line\n                    } else if(lowercaseLine.startsWith(\"from: \")) {\n                        //line = \"From: i2p\";\n                        line = null;\n                        continue; // completely strip the line\n                    } else if(lowercaseLine.startsWith(\"authorization: ntlm \")) {\n                        // Block Windows NTLM after 401\n                        line = null;\n                        continue;\n                    } else if(lowercaseLine.startsWith(\"proxy-authorization: \")) {\n                        // This should be for us. It is a\n                        // hop-by-hop header, and we definitely want to block Windows NTLM after a far-end 407.\n                        // Response to far-end shouldn't happen, as we\n                        // strip Proxy-Authenticate from the response in HTTPResponseOutputStream\n                        authorization = line.substring(21);  // \"proxy-authorization: \".length()\n                        line = null;\n                        continue;\n                    } else if(lowercaseLine.startsWith(\"icy\")) {\n                        // icecast/shoutcast, We need to leave the user-agent alone.\n                        shout = true;\n                    }\n                }\n\n                if(line.length() == 0) {\n                    // No more headers, add our own and break out of the loop\n                    String ok = getTunnel().getClientOptions().getProperty(\"i2ptunnel.gzip\");\n                    boolean gzip = DEFAULT_GZIP;\n                    if(ok != null) {\n                        gzip = Boolean.parseBoolean(ok);\n                    }\n                    if(gzip && !usingInternalServer) {\n                        // according to rfc2616 s14.3, this *should* force identity, even if\n                        // an explicit q=0 for gzip doesn't.  tested against orion.i2p, and it\n                        // seems to work.\n                        newRequest.append(\"Accept-Encoding: \\r\\n\");\n                        newRequest.append(\"X-Accept-Encoding: x-i2p-gzip;q=1.0, identity;q=0.5, deflate;q=0, gzip;q=0, *;q=0\\r\\n\");\n                    }\n                    if(!shout) {\n                        if(!Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_USER_AGENT))) {\n                            // let's not advertise to external sites that we are from I2P\n                            if(usingWWWProxy || usingOutproxy) {\n                                newRequest.append(\"User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.9.2.6) Gecko/20100625 Firefox/3.6.6\\r\\n\");\n                            } else {\n                                newRequest.append(\"User-Agent: MYOB/6.66 (AN/ON)\\r\\n\");\n                            }\n                        }\n                    }\n                    // Add Proxy-Authentication header for next hop (outproxy)\n                    if(usingWWWProxy && Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_OUTPROXY_AUTH))) {\n                        // specific for this proxy\n                        String user = getTunnel().getClientOptions().getProperty(PROP_OUTPROXY_USER_PREFIX + currentProxy);\n                        String pw = getTunnel().getClientOptions().getProperty(PROP_OUTPROXY_PW_PREFIX + currentProxy);\n                        if(user == null || pw == null) {\n                            // if not, look at default user and pw\n                            user = getTunnel().getClientOptions().getProperty(PROP_OUTPROXY_USER);\n                            pw = getTunnel().getClientOptions().getProperty(PROP_OUTPROXY_PW);\n                        }\n                        if(user != null && pw != null) {\n                            newRequest.append(\"Proxy-Authorization: Basic \").append(Base64.encode((user + ':' + pw).getBytes(), true)) // true = use standard alphabet\n                                    .append(\"\\r\\n\");\n                        }\n                    }\n                    newRequest.append(\"Connection: close\\r\\n\\r\\n\");\n                    break;\n                } else {\n                    newRequest.append(line).append(\"\\r\\n\"); // HTTP spec\n                }\n            } // end header processing\n\n            if(_log.shouldLog(Log.DEBUG)) {\n                _log.debug(getPrefix(requestId) + \"NewRequest header: [\" + newRequest.toString() + \"]\");\n            }\n\n            if(method == null || (destination == null && !usingOutproxy)) {\n                //l.log(\"No HTTP method found in the request.\");\n                if(out != null) {\n                    if(protocol != null && \"http\".equals(protocol.toLowerCase(Locale.US))) {\n                        out.write(getErrorPage(\"denied\", ERR_REQUEST_DENIED));\n                    } else {\n                        out.write(getErrorPage(\"protocol\", ERR_BAD_PROTOCOL));\n                    }\n                    writeFooter(out);\n                }\n                s.close();\n                return;\n            }\n\n            if(_log.shouldLog(Log.DEBUG)) {\n                _log.debug(getPrefix(requestId) + \"Destination: \" + destination);\n            }\n\n            // Authorization\n            AuthResult result = authorize(s, requestId, method, authorization);\n            if (result != AuthResult.AUTH_GOOD) {\n                if(_log.shouldLog(Log.WARN)) {\n                    if(authorization != null) {\n                        _log.warn(getPrefix(requestId) + \"Auth failed, sending 407 again\");\n                    } else {\n                        _log.warn(getPrefix(requestId) + \"Auth required, sending 407\");\n                    }\n                }\n                out.write(getAuthError(result == AuthResult.AUTH_STALE).getBytes());\n                writeFooter(out);\n                s.close();\n                return;\n            }\n\n            // Serve local proxy files (images, css linked from error pages)\n            // Ignore all the headers\n            if(usingInternalServer) {\n                // disable the add form if address helper is disabled\n                if(internalPath.equals(\"/add\") &&\n                        Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_DISABLE_HELPER))) {\n                    out.write(ERR_HELPER_DISABLED);\n                } else {\n                    LocalHTTPServer.serveLocalFile(out, method, internalPath, internalRawQuery, _proxyNonce);\n                }\n                s.close();\n                return;\n            }\n\n            // no destination, going to outproxy plugin\n            if (usingOutproxy) {\n                Socket outSocket = outproxy.connect(host, remotePort);\n                Runnable onTimeout = new OnTimeout(s, s.getOutputStream(), targetRequest, usingWWWProxy, currentProxy, requestId);\n                byte[] data;\n                byte[] response;\n                if (method.toUpperCase(Locale.US).equals(\"CONNECT\")) {\n                    data = null;\n                    response = I2PTunnelConnectClient.SUCCESS_RESPONSE;\n                } else {\n                    data = newRequest.toString().getBytes(\"ISO-8859-1\");\n                    response = null;\n                }\n                new I2PTunnelOutproxyRunner(s, outSocket, sockLock, data, response, onTimeout);\n                return;\n            }\n\n            // LOOKUP\n            // If the host is \"i2p\", the getHostName() lookup failed, don't try to\n            // look it up again as the naming service does not do negative caching\n            // so it will be slow.\n            Destination clientDest = null;\n            String addressHelper = addressHelpers.get(destination.toLowerCase(Locale.US));\n            if(addressHelper != null) {\n                clientDest = _context.namingService().lookup(addressHelper);\n                if(clientDest == null) {\n                    // remove bad entries\n                    addressHelpers.remove(destination.toLowerCase(Locale.US));\n                    if(_log.shouldLog(Log.WARN)) {\n                        _log.warn(getPrefix(requestId) + \"Could not find destination for \" + addressHelper);\n                    }\n                    byte[] header = getErrorPage(\"ahelper-notfound\", ERR_AHELPER_NOTFOUND);\n                    writeErrorMessage(header, out, targetRequest, false, destination, null);\n                    s.close();\n                    return;\n                }\n            } else if(\"i2p\".equals(host)) {\n                clientDest = null;\n            } else if(destination.length() == 60 && destination.toLowerCase(Locale.US).endsWith(\".b32.i2p\")) {\n                // use existing session to look up for efficiency\n                verifySocketManager();\n                I2PSession sess = sockMgr.getSession();\n                if(!sess.isClosed()) {\n                    byte[] hData = Base32.decode(destination.substring(0, 52));\n                    if(hData != null) {\n                        if(_log.shouldLog(Log.INFO)) {\n                            _log.info(\"lookup in-session \" + destination);\n                        }\n                        Hash hash = Hash.create(hData);\n                        clientDest = sess.lookupDest(hash, 20 * 1000);\n                    }\n                } else {\n                    clientDest = _context.namingService().lookup(destination);\n                }\n            } else {\n                clientDest = _context.namingService().lookup(destination);\n            }\n\n            if(clientDest == null) {\n                //l.log(\"Could not resolve \" + destination + \".\");\n                if(_log.shouldLog(Log.WARN)) {\n                    _log.warn(\"Unable to resolve \" + destination + \" (proxy? \" + usingWWWProxy + \", request: \" + targetRequest);\n                }\n                byte[] header;\n                String jumpServers = null;\n                if(usingWWWProxy) {\n                    header = getErrorPage(\"dnfp\", ERR_DESTINATION_UNKNOWN);\n                } else if(ahelperPresent) {\n                    header = getErrorPage(\"dnfb\", ERR_DESTINATION_UNKNOWN);\n                } else if(destination.length() == 60 && destination.toLowerCase(Locale.US).endsWith(\".b32.i2p\")) {\n                    header = getErrorPage(\"dnf\", ERR_DESTINATION_UNKNOWN);\n                } else {\n                    header = getErrorPage(\"dnfh\", ERR_DESTINATION_UNKNOWN);\n                    jumpServers = getTunnel().getClientOptions().getProperty(PROP_JUMP_SERVERS);\n                    if(jumpServers == null) {\n                        jumpServers = DEFAULT_JUMP_SERVERS;\n                    }\n                }\n                writeErrorMessage(header, out, targetRequest, usingWWWProxy, destination, jumpServers);\n                s.close();\n                return;\n            }\n\n            // Address helper response form\n            // This will only load once - the second time it won't be \"new\"\n            // Don't do this for eepget, which uses a user-agent of \"Wget\"\n            if(ahelperNew && \"GET\".equals(method) &&\n                    (userAgent == null || !userAgent.startsWith(\"Wget\")) &&\n                    !Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_DISABLE_HELPER))) {\n                writeHelperSaveForm(out, destination, ahelperKey, targetRequest, referer);\n                s.close();\n                return;\n            }\n\n            // Redirect to non-addresshelper URL to not clog the browser address bar\n            // and not pass the parameter to the eepsite.\n            // This also prevents the not-found error page from looking bad\n            // Syndie can't handle a redirect of a POST\n            if(ahelperPresent && !\"POST\".equals(method)) {\n                String uri = targetRequest;\n                if(_log.shouldLog(Log.DEBUG)) {\n                    _log.debug(\"Auto redirecting to \" + uri);\n                }\n                out.write((\"HTTP/1.1 301 Address Helper Accepted\\r\\n\" +\n                        \"Location: \" + uri + \"\\r\\n\" +\n                        \"\\r\\n\").getBytes(\"UTF-8\"));\n                s.close();\n                return;\n            }\n\n            Properties opts = new Properties();\n            //opts.setProperty(\"i2p.streaming.inactivityTimeout\", \"\"+120*1000);\n            // 1 == disconnect.  see ConnectionOptions in the new streaming lib, which i\n            // dont want to hard link to here\n            //opts.setProperty(\"i2p.streaming.inactivityTimeoutAction\", \"\"+1);\n            I2PSocketOptions sktOpts = getDefaultOptions(opts);\n            if (remotePort > 0)\n                sktOpts.setPort(remotePort);\n            I2PSocket i2ps = createI2PSocket(clientDest, sktOpts);\n            Runnable onTimeout = new OnTimeout(s, s.getOutputStream(), targetRequest, usingWWWProxy, currentProxy, requestId);\n            if (method.toUpperCase(Locale.US).equals(\"CONNECT\")) {\n                byte[] data;\n                byte[] response;\n                if (usingWWWProxy) {\n                    data = newRequest.toString().getBytes(\"ISO-8859-1\");\n                    response = null;\n                } else {\n                    data = null;\n                    response = I2PTunnelConnectClient.SUCCESS_RESPONSE;\n                }\n                new I2PTunnelRunner(s, i2ps, sockLock, data, response, mySockets, onTimeout);\n            } else {\n                byte[] data = newRequest.toString().getBytes(\"ISO-8859-1\");\n                new I2PTunnelHTTPClientRunner(s, i2ps, sockLock, data, mySockets, onTimeout);\n            }\n        } catch (SocketException ex) {\n            if (_log.shouldLog(Log.INFO)) {\n                _log.info(getPrefix(requestId) + \"Error trying to connect\", ex);\n            }\n            //l.log(\"Error connecting: \" + ex.getMessage());\n            handleHTTPClientException(ex, out, targetRequest, usingWWWProxy, currentProxy, requestId);\n            closeSocket(s);\n        } catch(IOException ex) {\n            if(_log.shouldLog(Log.INFO)) {\n                _log.info(getPrefix(requestId) + \"Error trying to connect\", ex);\n            }\n            //l.log(\"Error connecting: \" + ex.getMessage());\n            handleHTTPClientException(ex, out, targetRequest, usingWWWProxy, currentProxy, requestId);\n            closeSocket(s);\n        } catch(I2PException ex) {\n            if(_log.shouldLog(Log.INFO)) {\n                _log.info(\"getPrefix(requestId) + Error trying to connect\", ex);\n            }\n            //l.log(\"Error connecting: \" + ex.getMessage());\n            handleHTTPClientException(ex, out, targetRequest, usingWWWProxy, currentProxy, requestId);\n            closeSocket(s);\n        } catch(OutOfMemoryError oom) {\n            IOException ex = new IOException(\"OOM\");\n            _log.error(\"getPrefix(requestId) + Error trying to connect\", oom);\n            //l.log(\"Error connecting: \" + ex.getMessage());\n            handleHTTPClientException(ex, out, targetRequest, usingWWWProxy, currentProxy, requestId);\n            closeSocket(s);\n        }\n    }","id":65058,"modified_method":"protected void clientConnectionRun(Socket s) {\n        OutputStream out = null;\n\n        /**\n         * The URL after fixup, always starting with http:// or https://\n         */\n        String targetRequest = null;\n\n        // in-net outproxy\n        boolean usingWWWProxy = false;\n        // local outproxy plugin\n        boolean usingInternalOutproxy = false;\n        Outproxy outproxy = null;\n        boolean usingInternalServer = false;\n        String internalPath = null;\n        String internalRawQuery = null;\n        String currentProxy = null;\n        long requestId = __requestId.incrementAndGet();\n        boolean shout = false;\n\n        try {\n            out = s.getOutputStream();\n            InputReader reader = new InputReader(s.getInputStream());\n            String line, method = null, protocol = null, host = null, destination = null;\n            StringBuilder newRequest = new StringBuilder();\n            boolean ahelperPresent = false;\n            boolean ahelperNew = false;\n            String ahelperKey = null;\n            String userAgent = null;\n            String authorization = null;\n            int remotePort = 0;\n            String referer = null;\n            while((line = reader.readLine(method)) != null) {\n                line = line.trim();\n                if(_log.shouldLog(Log.DEBUG)) {\n                    _log.debug(getPrefix(requestId) + \"Line=[\" + line + \"]\");\n                }\n\n                String lowercaseLine = line.toLowerCase(Locale.US);\n                if(lowercaseLine.startsWith(\"connection: \") ||\n                        lowercaseLine.startsWith(\"keep-alive: \") ||\n                        lowercaseLine.startsWith(\"proxy-connection: \")) {\n                    continue;\n                }\n\n                if(method == null) { // first line (GET /base64/realaddr)\n                    if(_log.shouldLog(Log.DEBUG)) {\n                        _log.debug(getPrefix(requestId) + \"First line [\" + line + \"]\");\n                    }\n\n                    String[] params = line.split(\" \", 3);\n                    if(params.length != 3) {\n                        break;\n                    }\n                    String request = params[1];\n\n                    // various obscure fixups\n                    if(request.startsWith(\"/\") && getTunnel().getClientOptions().getProperty(\"i2ptunnel.noproxy\") != null) {\n                        // what is this for ???\n                        request = \"http://i2p\" + request;\n                    } else if(request.startsWith(\"/eepproxy/\")) {\n                        // Deprecated\n                        // /eepproxy/foo.i2p/bar/baz.html\n                        String subRequest = request.substring(\"/eepproxy/\".length());\n                        if(subRequest.indexOf(\"/\") == -1) {\n                            subRequest += \"/\";\n                        }\n                        request = \"http://\" + subRequest;\n                    /****\n                    } else if (request.toLowerCase(Locale.US).startsWith(\"http://i2p/\")) {\n                    // http://i2p/b64key/bar/baz.html\n                    // we can't do this now by setting the URI host to the b64key, as\n                    // it probably contains '=' and '~' which are illegal,\n                    // and a host may not include escaped octets\n                    // This will get undone below.\n                    String subRequest = request.substring(\"http://i2p/\".length());\n                    if (subRequest.indexOf(\"/\") == -1)\n                    subRequest += \"/\";\n                    \"http://\" + \"b64key/bar/baz.html\"\n                    request = \"http://\" + subRequest;\n                    } else if (request.toLowerCase(Locale.US).startsWith(\"http://\")) {\n                    // Unsupported\n                    // http://$b64key/...\n                    // This probably used to work, rewrite it so that\n                    // we can create a URI without illegal characters\n                    // This will get undone below.\n                    String  oldPath = request.substring(7);\n                    int slash = oldPath.indexOf(\"/\");\n                    if (slash < 0)\n                    slash = oldPath.length();\n                    if (slash >= 516 && !oldPath.substring(0, slash).contains(\".\"))\n                    request = \"http://i2p/\" + oldPath;\n                     ****/\n                    }\n\n                    method = params[0];\n                    if (method.toUpperCase(Locale.US).equals(\"CONNECT\")) {\n                        // this makes things easier later, by spoofing a\n                        // protocol so the URI parser find the host and port\n                        // For in-net outproxy, will be fixed up below\n                        request = \"https://\" + request + '/';\n                    }\n\n                    // Now use the Java URI parser\n                    // This will be the incoming URI but will then get modified\n                    // to be the outgoing URI (with http:// if going to outproxy, otherwise without)\n                    URI requestURI;\n                    try {\n                        requestURI = new URI(request);\n                        if(requestURI.getRawUserInfo() != null || requestURI.getRawFragment() != null) {\n                            // these should never be sent to the proxy in the request line\n                            if(_log.shouldLog(Log.WARN)) {\n                                _log.warn(getPrefix(requestId) + \"Removing userinfo or fragment [\" + request + \"]\");\n                            }\n                            requestURI = changeURI(requestURI, null, 0, null);\n                        }\n                        if(requestURI.getPath() == null || requestURI.getPath().length() <= 0) {\n                            // Add a path\n                            if(_log.shouldLog(Log.WARN)) {\n                                _log.warn(getPrefix(requestId) + \"Adding / path to [\" + request + \"]\");\n                            }\n                            requestURI = changeURI(requestURI, null, 0, \"/\");\n                        }\n                    } catch(URISyntaxException use) {\n                        if(_log.shouldLog(Log.WARN)) {\n                            _log.warn(getPrefix(requestId) + \"Bad request [\" + request + \"]\", use);\n                        }\n                        if(out != null) {\n                            out.write(getErrorPage(\"baduri\", ERR_BAD_URI));\n                            writeFooter(out);\n                        }\n                        s.close();\n                        return;\n                    }\n\n                    String protocolVersion = params[2];\n\n                    protocol = requestURI.getScheme();\n                    host = requestURI.getHost();\n                    if(protocol == null || host == null) {\n                        _log.warn(\"Null protocol or host: \" + request + ' ' + protocol + ' ' + host);\n                        method = null;\n                        break;\n                    }\n\n                    int port = requestURI.getPort();\n\n                    // Go through the various types of host names, set\n                    // the host and destination variables accordingly,\n                    // and transform the first line.\n                    // For all i2p network hosts, ensure that the host is a\n                    // Base 32 hostname so that we do not reveal our name for it\n                    // in our addressbook (all naming is local),\n                    // and it is removed from the request line.\n\n                    String hostLowerCase = host.toLowerCase(Locale.US);\n                    if(hostLowerCase.equals(LOCAL_SERVER)) {\n                        // so we don't do any naming service lookups\n                        destination = host;\n                        usingInternalServer = true;\n                        internalPath = requestURI.getPath();\n                        internalRawQuery = requestURI.getRawQuery();\n                    } else if(hostLowerCase.equals(\"i2p\")) {\n                        // pull the b64 _dest out of the first path element\n                        String oldPath = requestURI.getPath().substring(1);\n                        int slash = oldPath.indexOf(\"/\");\n                        if(slash < 0) {\n                            slash = oldPath.length();\n                            oldPath += \"/\";\n                        }\n                        String _dest = oldPath.substring(0, slash);\n                        if(slash >= 516 && !_dest.contains(\".\")) {\n                            // possible alternative:\n                            // redirect to b32\n                            destination = _dest;\n                            host = getHostName(destination);\n                            targetRequest = requestURI.toASCIIString();\n                            String newURI = oldPath.substring(slash);\n                            String query = requestURI.getRawQuery();\n                            if(query != null) {\n                                newURI += '?' + query;\n                            }\n                            try {\n                                requestURI = new URI(newURI);\n                            } catch(URISyntaxException use) {\n                                // shouldnt happen\n                                _log.warn(request, use);\n                                method = null;\n                                break;\n                            }\n                        } else {\n                            _log.warn(\"Bad http://i2p/b64dest \" + request);\n                            host = null;\n                            break;\n                        }\n                    } else if(hostLowerCase.endsWith(\".i2p\")) {\n                        // Destination gets the host name\n                        destination = host;\n                        // Host becomes the destination's \"{b32}.b32.i2p\" string, or \"i2p\" on lookup failure\n                        host = getHostName(destination);\n\n                        int rPort = requestURI.getPort();\n                        if (rPort > 0) {\n                            // Save it to put in the I2PSocketOptions,\n                            remotePort = rPort;\n                         /********\n                            // but strip it from the URL\n                            if(_log.shouldLog(Log.WARN)) {\n                                _log.warn(getPrefix(requestId) + \"Removing port from [\" + request + \"]\");\n                            }\n                            try {\n                                requestURI = changeURI(requestURI, null, -1, null);\n                            } catch(URISyntaxException use) {\n                                _log.warn(request, use);\n                                method = null;\n                                break;\n                            }\n                          ******/\n                        } else if (\"https\".equals(protocol) ||\n                                   method.toUpperCase(Locale.US).equals(\"CONNECT\")) {\n                            remotePort = 443;\n                        } else {\n                            remotePort = 80;\n                        }\n\n                        String query = requestURI.getRawQuery();\n                        if(query != null) {\n                            boolean ahelperConflict = false;\n\n                            // Try to find an address helper in the query\n                            String[] helperStrings = removeHelper(query);\n                            if(helperStrings != null &&\n                                    !Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_DISABLE_HELPER))) {\n                                query = helperStrings[0];\n                                if(query.equals(\"\")) {\n                                    query = null;\n                                }\n                                try {\n                                    requestURI = replaceQuery(requestURI, query);\n                                } catch(URISyntaxException use) {\n                                    // shouldn't happen\n                                    _log.warn(request, use);\n                                    method = null;\n                                    break;\n                                }\n                                ahelperKey = helperStrings[1];\n                                // Key contains data, lets not ignore it\n                                if(ahelperKey.length() > 0) {\n                                    if(ahelperKey.endsWith(\".i2p\")) {\n                                        // allow i2paddresshelper=<b32>.b32.i2p syntax.\n                                        /*\n                                        also i2paddresshelper=name.i2p for aliases\n                                        i.e. on your eepsite put\n                                        <a href=\"?i2paddresshelper=name.i2p\">This is the name I want to be called.<\/a>\n                                         */\n                                        Destination _dest = _context.namingService().lookup(ahelperKey);\n                                        if(_dest == null) {\n                                            if(_log.shouldLog(Log.WARN)) {\n                                                _log.warn(getPrefix(requestId) + \"Could not find destination for \" + ahelperKey);\n                                            }\n                                            byte[] header = getErrorPage(\"ahelper-notfound\", ERR_AHELPER_NOTFOUND);\n                                            out.write(header);\n                                            out.write((\"<p>\" + _(\"This seems to be a bad destination:\") + \" \" + ahelperKey + \" \" + _(\"i2paddresshelper cannot help you with a destination like that!\") + \"<\/p>\").getBytes(\"UTF-8\"));\n                                            writeFooter(out);\n                                            // XXX: should closeSocket(s) be in a finally block?\n                                            closeSocket(s);\n                                            return;\n                                        }\n                                        ahelperKey = _dest.toBase64();\n                                    }\n\n                                    ahelperPresent = true;\n                                    // ahelperKey will be validated later\n                                    if(host == null || \"i2p\".equals(host)) {\n                                        // Host lookup failed - resolvable only with addresshelper\n                                        // Store in local HashMap unless there is conflict\n                                        String old = addressHelpers.putIfAbsent(destination.toLowerCase(Locale.US), ahelperKey);\n                                        ahelperNew = old == null;\n                                        if((!ahelperNew) && !old.equals(ahelperKey)) {\n                                            // Conflict: handle when URL reconstruction done\n                                            ahelperConflict = true;\n                                            if(_log.shouldLog(Log.WARN)) {\n                                                _log.warn(getPrefix(requestId) + \"Addresshelper key conflict for site [\" + destination +\n                                                        \"], trusted key [\" + old + \"], specified key [\" + ahelperKey + \"].\");\n                                            }\n                                        }\n                                    } else {\n                                        // If the host is resolvable from database, verify addresshelper key\n                                        // Silently bypass correct keys, otherwise alert\n                                        Destination hostDest = _context.namingService().lookup(destination);\n                                        if(hostDest != null) {\n                                            String destB64 = hostDest.toBase64();\n                                            if(destB64 != null && !destB64.equals(ahelperKey)) {\n                                                // Conflict: handle when URL reconstruction done\n                                                ahelperConflict = true;\n                                                if(_log.shouldLog(Log.WARN)) {\n                                                    _log.warn(getPrefix(requestId) + \"Addresshelper key conflict for site [\" + destination +\n                                                            \"], trusted key [\" + destB64 + \"], specified key [\" + ahelperKey + \"].\");\n                                                }\n\n                                            }\n                                        }\n                                    }\n                                } // ahelperKey\n                            } // helperstrings\n\n                            // Did addresshelper key conflict?\n                            if(ahelperConflict) {\n                                if(out != null) {\n                                    // convert ahelperKey to b32\n                                    String alias = getHostName(ahelperKey);\n                                    if(alias.equals(\"i2p\")) {\n                                        // bad ahelperKey\n                                        byte[] header = getErrorPage(\"dnfb\", ERR_DESTINATION_UNKNOWN);\n                                        writeErrorMessage(header, out, targetRequest, false, destination, null);\n                                    } else {\n                                        String trustedURL = requestURI.toASCIIString();\n                                        URI conflictURI;\n                                        try {\n                                            conflictURI = changeURI(requestURI, alias, 0, null);\n                                        } catch(URISyntaxException use) {\n                                            // shouldn't happen\n                                            _log.warn(request, use);\n                                            method = null;\n                                            break;\n                                        }\n                                        String conflictURL = conflictURI.toASCIIString();\n                                        byte[] header = getErrorPage(\"ahelper-conflict\", ERR_AHELPER_CONFLICT);\n                                        out.write(header);\n                                        out.write(_(\"To visit the destination in your host database, click <a href=\\\"{0}\\\">here<\/a>. To visit the conflicting addresshelper destination, click <a href=\\\"{1}\\\">here<\/a>.\", trustedURL, conflictURL).getBytes(\"UTF-8\"));\n                                        out.write((\"<\/p><\/div>\").getBytes());\n                                        writeFooter(out);\n                                    }\n                                }\n                                s.close();\n                                return;\n                            }\n                        }  // end query processing\n\n                        String addressHelper = addressHelpers.get(destination);\n                        if(addressHelper != null) {\n                            host = getHostName(addressHelper);\n                        }\n\n                        // now strip everything but path and query from URI\n                        targetRequest = requestURI.toASCIIString();\n                        String newURI = requestURI.getRawPath();\n                        if(query != null) {\n                            newURI += '?' + query;\n                        }\n                        try {\n                            requestURI = new URI(newURI);\n                        } catch(URISyntaxException use) {\n                            // shouldnt happen\n                            _log.warn(request, use);\n                            method = null;\n                            break;\n                        }\n\n                    // end of (host endsWith(\".i2p\"))\n\n                    } else if(hostLowerCase.equals(\"localhost\") || host.equals(\"127.0.0.1\") ||\n                            host.startsWith(\"192.168.\") || host.equals(\"[::1]\")) {\n                        // if somebody is trying to get to 192.168.example.com, oh well\n                        if(out != null) {\n                            out.write(getErrorPage(\"localhost\", ERR_LOCALHOST));\n                            writeFooter(out);\n                        }\n                        s.close();\n                        return;\n                    } else if(host.contains(\".\") || host.startsWith(\"[\")) {\n                        if (Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_USE_OUTPROXY_PLUGIN))) {\n                            ClientAppManager mgr = _context.clientAppManager();\n                            if (mgr != null) {\n                                ClientApp op = mgr.getRegisteredApp(Outproxy.NAME);\n                                if (op != null) {\n                                    outproxy = (Outproxy) op;\n                                    int rPort = requestURI.getPort();\n                                    if (rPort > 0)\n                                        remotePort = rPort;\n                                    else if (\"https\".equals(protocol) ||\n                                             method.toUpperCase(Locale.US).equals(\"CONNECT\"))\n                                        remotePort = 443;\n                                    else\n                                        remotePort = 80;\n                                    usingInternalOutproxy = true;\n                                    targetRequest = requestURI.toASCIIString();\n                                    if(_log.shouldLog(Log.DEBUG))\n                                        _log.debug(getPrefix(requestId) + \" [\" + host + \"]: outproxy!\");\n                                }\n                            }\n                        }\n                        if (!usingInternalOutproxy) {\n                            if(port >= 0) {\n                                host = host + ':' + port;\n                            }\n                            // The request must be forwarded to a WWW proxy\n                            if(_log.shouldLog(Log.DEBUG)) {\n                                _log.debug(\"Before selecting outproxy for \" + host);\n                            }\n                            if (\"https\".equals(protocol) ||\n                                method.toUpperCase(Locale.US).equals(\"CONNECT\"))\n                                currentProxy = selectSSLProxy();\n                            else\n                                currentProxy = selectProxy();\n                            if(_log.shouldLog(Log.DEBUG)) {\n                                _log.debug(\"After selecting outproxy for \" + host + \": \" + currentProxy);\n                            }\n                            if(currentProxy == null) {\n                                if(_log.shouldLog(Log.WARN)) {\n                                    _log.warn(getPrefix(requestId) + \"Host wants to be outproxied, but we dont have any!\");\n                                }\n                                l.log(\"No outproxy found for the request.\");\n                                if(out != null) {\n                                    out.write(getErrorPage(\"noproxy\", _ERR_NO_OUTPROXY));\n                                    writeFooter(out);\n                                }\n                                s.close();\n                                return;\n                            }\n                            destination = currentProxy;\n                            usingWWWProxy = true;\n                            targetRequest = requestURI.toASCIIString();\n                            if(_log.shouldLog(Log.DEBUG)) {\n                                _log.debug(getPrefix(requestId) + \" [\" + host + \"]: wwwProxy!\");\n                            }\n                        }\n                    } else {\n                        // what is left for here? a hostname with no dots, and != \"i2p\"\n                        // and not a destination ???\n                        // Perhaps something in privatehosts.txt ...\n                        // Rather than look it up, just bail out.\n                        if(_log.shouldLog(Log.WARN)) {\n                            _log.warn(\"NODOTS, NOI2P: \" + request);\n                        }\n                        if(out != null) {\n                            out.write(getErrorPage(\"denied\", ERR_REQUEST_DENIED));\n                            writeFooter(out);\n                        }\n                        s.close();\n                        return;\n                    }   // end host name processing\n\n                    boolean isValid = usingInternalOutproxy || usingWWWProxy ||\n                                      usingInternalServer || isSupportedAddress(host, protocol);\n                    if(!isValid) {\n                        if(_log.shouldLog(Log.INFO)) {\n                            _log.info(getPrefix(requestId) + \"notValid(\" + host + \")\");\n                        }\n                        method = null;\n                        destination = null;\n                        break;\n                    }\n\n                    if (method.toUpperCase(Locale.US).equals(\"CONNECT\")) {\n                        // fix up the change to requestURI above to get back to the original host:port\n                        line = method + ' ' + requestURI.getHost() + ':' + requestURI.getPort() + ' ' + protocolVersion;\n                    } else {\n                        line = method + ' ' + requestURI.toASCIIString() + ' ' + protocolVersion;\n                    }\n\n                    if(_log.shouldLog(Log.DEBUG)) {\n                        _log.debug(getPrefix(requestId) + \"NEWREQ: \\\"\" + line + \"\\\"\");\n                        _log.debug(getPrefix(requestId) + \"HOST  : \\\"\" + host + \"\\\"\");\n                        _log.debug(getPrefix(requestId) + \"DEST  : \\\"\" + destination + \"\\\"\");\n                    }\n\n                // end first line processing\n\n                } else {\n                    if(lowercaseLine.startsWith(\"host: \") && !usingWWWProxy && !usingInternalOutproxy) {\n                        // Note that we only pass the original Host: line through to the outproxy\n                        // But we don't create a Host: line if it wasn't sent to us\n                        line = \"Host: \" + host;\n                        if(_log.shouldLog(Log.INFO)) {\n                            _log.info(getPrefix(requestId) + \"Setting host = \" + host);\n                        }\n                    } else if(lowercaseLine.startsWith(\"user-agent: \")) {\n                        // save for deciding whether to offer address book form\n                        userAgent = lowercaseLine.substring(12);\n                        if(!Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_USER_AGENT))) {\n                            line = null;\n                            continue;\n                        }\n                    } else if(lowercaseLine.startsWith(\"accept\")) {\n                        // strip the accept-blah headers, as they vary dramatically from\n                        // browser to browser\n                        line = null;\n                        continue;\n                    } else if (lowercaseLine.startsWith(\"referer: \")) {\n                        // save for address helper form below\n                        referer = line.substring(9);\n                        if (!Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_REFERER))) {\n                            // Shouldn't we be more specific, like accepting in-site referers ?\n                            //line = \"Referer: i2p\";\n                            line = null;\n                            continue; // completely strip the line\n                        }\n                    } else if(lowercaseLine.startsWith(\"via: \") &&\n                            !Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_VIA))) {\n                        //line = \"Via: i2p\";\n                        line = null;\n                        continue; // completely strip the line\n                    } else if(lowercaseLine.startsWith(\"from: \")) {\n                        //line = \"From: i2p\";\n                        line = null;\n                        continue; // completely strip the line\n                    } else if(lowercaseLine.startsWith(\"authorization: ntlm \")) {\n                        // Block Windows NTLM after 401\n                        line = null;\n                        continue;\n                    } else if(lowercaseLine.startsWith(\"proxy-authorization: \")) {\n                        // This should be for us. It is a\n                        // hop-by-hop header, and we definitely want to block Windows NTLM after a far-end 407.\n                        // Response to far-end shouldn't happen, as we\n                        // strip Proxy-Authenticate from the response in HTTPResponseOutputStream\n                        authorization = line.substring(21);  // \"proxy-authorization: \".length()\n                        line = null;\n                        continue;\n                    } else if(lowercaseLine.startsWith(\"icy\")) {\n                        // icecast/shoutcast, We need to leave the user-agent alone.\n                        shout = true;\n                    }\n                }\n\n                if(line.length() == 0) {\n                    // No more headers, add our own and break out of the loop\n                    String ok = getTunnel().getClientOptions().getProperty(\"i2ptunnel.gzip\");\n                    boolean gzip = DEFAULT_GZIP;\n                    if(ok != null) {\n                        gzip = Boolean.parseBoolean(ok);\n                    }\n                    if(gzip && !usingInternalServer &&\n                       !method.toUpperCase(Locale.US).equals(\"CONNECT\")) {\n                        // according to rfc2616 s14.3, this *should* force identity, even if\n                        // an explicit q=0 for gzip doesn't.  tested against orion.i2p, and it\n                        // seems to work.\n                        newRequest.append(\"Accept-Encoding: \\r\\n\");\n                        if (!usingInternalOutproxy)\n                            newRequest.append(\"X-Accept-Encoding: x-i2p-gzip;q=1.0, identity;q=0.5, deflate;q=0, gzip;q=0, *;q=0\\r\\n\");\n                    }\n                    if(!shout && !method.toUpperCase(Locale.US).equals(\"CONNECT\")) {\n                        if(!Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_USER_AGENT))) {\n                            // let's not advertise to external sites that we are from I2P\n                            if(usingWWWProxy || usingInternalOutproxy) {\n                                newRequest.append(\"User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.9.2.6) Gecko/20100625 Firefox/3.6.6\\r\\n\");\n                            } else {\n                                newRequest.append(\"User-Agent: MYOB/6.66 (AN/ON)\\r\\n\");\n                            }\n                        }\n                    }\n                    // Add Proxy-Authentication header for next hop (outproxy)\n                    if(usingWWWProxy && Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_OUTPROXY_AUTH))) {\n                        // specific for this proxy\n                        String user = getTunnel().getClientOptions().getProperty(PROP_OUTPROXY_USER_PREFIX + currentProxy);\n                        String pw = getTunnel().getClientOptions().getProperty(PROP_OUTPROXY_PW_PREFIX + currentProxy);\n                        if(user == null || pw == null) {\n                            // if not, look at default user and pw\n                            user = getTunnel().getClientOptions().getProperty(PROP_OUTPROXY_USER);\n                            pw = getTunnel().getClientOptions().getProperty(PROP_OUTPROXY_PW);\n                        }\n                        if(user != null && pw != null) {\n                            newRequest.append(\"Proxy-Authorization: Basic \").append(Base64.encode((user + ':' + pw).getBytes(), true)) // true = use standard alphabet\n                                    .append(\"\\r\\n\");\n                        }\n                    }\n                    newRequest.append(\"Connection: close\\r\\n\\r\\n\");\n                    break;\n                } else {\n                    newRequest.append(line).append(\"\\r\\n\"); // HTTP spec\n                }\n            } // end header processing\n\n            if(_log.shouldLog(Log.DEBUG)) {\n                _log.debug(getPrefix(requestId) + \"NewRequest header: [\" + newRequest.toString() + \"]\");\n            }\n\n            if(method == null || (destination == null && !usingInternalOutproxy)) {\n                //l.log(\"No HTTP method found in the request.\");\n                if(out != null) {\n                    if(protocol != null && \"http\".equals(protocol.toLowerCase(Locale.US))) {\n                        out.write(getErrorPage(\"denied\", ERR_REQUEST_DENIED));\n                    } else {\n                        out.write(getErrorPage(\"protocol\", ERR_BAD_PROTOCOL));\n                    }\n                    writeFooter(out);\n                }\n                s.close();\n                return;\n            }\n\n            if(_log.shouldLog(Log.DEBUG)) {\n                _log.debug(getPrefix(requestId) + \"Destination: \" + destination);\n            }\n\n            // Authorization\n            AuthResult result = authorize(s, requestId, method, authorization);\n            if (result != AuthResult.AUTH_GOOD) {\n                if(_log.shouldLog(Log.WARN)) {\n                    if(authorization != null) {\n                        _log.warn(getPrefix(requestId) + \"Auth failed, sending 407 again\");\n                    } else {\n                        _log.warn(getPrefix(requestId) + \"Auth required, sending 407\");\n                    }\n                }\n                out.write(getAuthError(result == AuthResult.AUTH_STALE).getBytes());\n                writeFooter(out);\n                s.close();\n                return;\n            }\n\n            // Serve local proxy files (images, css linked from error pages)\n            // Ignore all the headers\n            if(usingInternalServer) {\n                // disable the add form if address helper is disabled\n                if(internalPath.equals(\"/add\") &&\n                        Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_DISABLE_HELPER))) {\n                    out.write(ERR_HELPER_DISABLED);\n                } else {\n                    LocalHTTPServer.serveLocalFile(out, method, internalPath, internalRawQuery, _proxyNonce);\n                }\n                s.close();\n                return;\n            }\n\n            // no destination, going to outproxy plugin\n            if (usingInternalOutproxy) {\n                Socket outSocket = outproxy.connect(host, remotePort);\n                Runnable onTimeout = new OnTimeout(s, s.getOutputStream(), targetRequest, usingWWWProxy, currentProxy, requestId);\n                byte[] data;\n                byte[] response;\n                if (method.toUpperCase(Locale.US).equals(\"CONNECT\")) {\n                    data = null;\n                    response = I2PTunnelConnectClient.SUCCESS_RESPONSE;\n                } else {\n                    data = newRequest.toString().getBytes(\"ISO-8859-1\");\n                    response = null;\n                }\n                new I2PTunnelOutproxyRunner(s, outSocket, sockLock, data, response, onTimeout);\n                return;\n            }\n\n            // LOOKUP\n            // If the host is \"i2p\", the getHostName() lookup failed, don't try to\n            // look it up again as the naming service does not do negative caching\n            // so it will be slow.\n            Destination clientDest = null;\n            String addressHelper = addressHelpers.get(destination.toLowerCase(Locale.US));\n            if(addressHelper != null) {\n                clientDest = _context.namingService().lookup(addressHelper);\n                if(clientDest == null) {\n                    // remove bad entries\n                    addressHelpers.remove(destination.toLowerCase(Locale.US));\n                    if(_log.shouldLog(Log.WARN)) {\n                        _log.warn(getPrefix(requestId) + \"Could not find destination for \" + addressHelper);\n                    }\n                    byte[] header = getErrorPage(\"ahelper-notfound\", ERR_AHELPER_NOTFOUND);\n                    writeErrorMessage(header, out, targetRequest, false, destination, null);\n                    s.close();\n                    return;\n                }\n            } else if(\"i2p\".equals(host)) {\n                clientDest = null;\n            } else if(destination.length() == 60 && destination.toLowerCase(Locale.US).endsWith(\".b32.i2p\")) {\n                // use existing session to look up for efficiency\n                verifySocketManager();\n                I2PSession sess = sockMgr.getSession();\n                if(!sess.isClosed()) {\n                    byte[] hData = Base32.decode(destination.substring(0, 52));\n                    if(hData != null) {\n                        if(_log.shouldLog(Log.INFO)) {\n                            _log.info(\"lookup in-session \" + destination);\n                        }\n                        Hash hash = Hash.create(hData);\n                        clientDest = sess.lookupDest(hash, 20 * 1000);\n                    }\n                } else {\n                    clientDest = _context.namingService().lookup(destination);\n                }\n            } else {\n                clientDest = _context.namingService().lookup(destination);\n            }\n\n            if(clientDest == null) {\n                //l.log(\"Could not resolve \" + destination + \".\");\n                if(_log.shouldLog(Log.WARN)) {\n                    _log.warn(\"Unable to resolve \" + destination + \" (proxy? \" + usingWWWProxy + \", request: \" + targetRequest);\n                }\n                byte[] header;\n                String jumpServers = null;\n                if(usingWWWProxy) {\n                    header = getErrorPage(\"dnfp\", ERR_DESTINATION_UNKNOWN);\n                } else if(ahelperPresent) {\n                    header = getErrorPage(\"dnfb\", ERR_DESTINATION_UNKNOWN);\n                } else if(destination.length() == 60 && destination.toLowerCase(Locale.US).endsWith(\".b32.i2p\")) {\n                    header = getErrorPage(\"dnf\", ERR_DESTINATION_UNKNOWN);\n                } else {\n                    header = getErrorPage(\"dnfh\", ERR_DESTINATION_UNKNOWN);\n                    jumpServers = getTunnel().getClientOptions().getProperty(PROP_JUMP_SERVERS);\n                    if(jumpServers == null) {\n                        jumpServers = DEFAULT_JUMP_SERVERS;\n                    }\n                }\n                writeErrorMessage(header, out, targetRequest, usingWWWProxy, destination, jumpServers);\n                s.close();\n                return;\n            }\n\n            // Address helper response form\n            // This will only load once - the second time it won't be \"new\"\n            // Don't do this for eepget, which uses a user-agent of \"Wget\"\n            if(ahelperNew && \"GET\".equals(method) &&\n                    (userAgent == null || !userAgent.startsWith(\"Wget\")) &&\n                    !Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_DISABLE_HELPER))) {\n                writeHelperSaveForm(out, destination, ahelperKey, targetRequest, referer);\n                s.close();\n                return;\n            }\n\n            // Redirect to non-addresshelper URL to not clog the browser address bar\n            // and not pass the parameter to the eepsite.\n            // This also prevents the not-found error page from looking bad\n            // Syndie can't handle a redirect of a POST\n            if(ahelperPresent && !\"POST\".equals(method)) {\n                String uri = targetRequest;\n                if(_log.shouldLog(Log.DEBUG)) {\n                    _log.debug(\"Auto redirecting to \" + uri);\n                }\n                out.write((\"HTTP/1.1 301 Address Helper Accepted\\r\\n\" +\n                        \"Location: \" + uri + \"\\r\\n\" +\n                        \"\\r\\n\").getBytes(\"UTF-8\"));\n                s.close();\n                return;\n            }\n\n            Properties opts = new Properties();\n            //opts.setProperty(\"i2p.streaming.inactivityTimeout\", \"\"+120*1000);\n            // 1 == disconnect.  see ConnectionOptions in the new streaming lib, which i\n            // dont want to hard link to here\n            //opts.setProperty(\"i2p.streaming.inactivityTimeoutAction\", \"\"+1);\n            I2PSocketOptions sktOpts = getDefaultOptions(opts);\n            if (remotePort > 0)\n                sktOpts.setPort(remotePort);\n            I2PSocket i2ps = createI2PSocket(clientDest, sktOpts);\n            Runnable onTimeout = new OnTimeout(s, s.getOutputStream(), targetRequest, usingWWWProxy, currentProxy, requestId);\n            if (method.toUpperCase(Locale.US).equals(\"CONNECT\")) {\n                byte[] data;\n                byte[] response;\n                if (usingWWWProxy) {\n                    data = newRequest.toString().getBytes(\"ISO-8859-1\");\n                    response = null;\n                } else {\n                    data = null;\n                    response = I2PTunnelConnectClient.SUCCESS_RESPONSE;\n                }\n                new I2PTunnelRunner(s, i2ps, sockLock, data, response, mySockets, onTimeout);\n            } else {\n                byte[] data = newRequest.toString().getBytes(\"ISO-8859-1\");\n                new I2PTunnelHTTPClientRunner(s, i2ps, sockLock, data, mySockets, onTimeout);\n            }\n        } catch (SocketException ex) {\n            if (_log.shouldLog(Log.INFO)) {\n                _log.info(getPrefix(requestId) + \"Error trying to connect\", ex);\n            }\n            //l.log(\"Error connecting: \" + ex.getMessage());\n            handleHTTPClientException(ex, out, targetRequest, usingWWWProxy, currentProxy, requestId);\n            closeSocket(s);\n        } catch(IOException ex) {\n            if(_log.shouldLog(Log.INFO)) {\n                _log.info(getPrefix(requestId) + \"Error trying to connect\", ex);\n            }\n            //l.log(\"Error connecting: \" + ex.getMessage());\n            handleHTTPClientException(ex, out, targetRequest, usingWWWProxy, currentProxy, requestId);\n            closeSocket(s);\n        } catch(I2PException ex) {\n            if(_log.shouldLog(Log.INFO)) {\n                _log.info(\"getPrefix(requestId) + Error trying to connect\", ex);\n            }\n            //l.log(\"Error connecting: \" + ex.getMessage());\n            handleHTTPClientException(ex, out, targetRequest, usingWWWProxy, currentProxy, requestId);\n            closeSocket(s);\n        } catch(OutOfMemoryError oom) {\n            IOException ex = new IOException(\"OOM\");\n            _log.error(\"getPrefix(requestId) + Error trying to connect\", oom);\n            //l.log(\"Error connecting: \" + ex.getMessage());\n            handleHTTPClientException(ex, out, targetRequest, usingWWWProxy, currentProxy, requestId);\n            closeSocket(s);\n        }\n    }","commit_id":"9ca625a64e8d5a5355c8d4b4b96a8b7f0da82b92","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private StreamForwarder(InputStream in, OutputStream out, boolean toI2P) {\n            this.in = in;\n            this.out = out;\n            _toI2P = toI2P;\n            direction = (toI2P ? \"toI2P\" : \"fromI2P\");\n            _cache = ByteCache.getInstance(32, NETWORK_BUFFER_SIZE);\n            setName(\"StreamForwarder \" + _runnerId + '.' + __forwarderId.incrementAndGet());\n            start();\n        }","id":65059,"modified_method":"private StreamForwarder(InputStream in, OutputStream out, boolean toI2P) {\n            this.in = in;\n            this.out = out;\n            _toI2P = toI2P;\n            direction = (toI2P ? \"toOutproxy\" : \"fromOutproxy\");\n            _cache = ByteCache.getInstance(32, NETWORK_BUFFER_SIZE);\n            setName(\"OutproxyForwarder \" + _runnerId + '.' + __forwarderId.incrementAndGet());\n            start();\n        }","commit_id":"9ca625a64e8d5a5355c8d4b4b96a8b7f0da82b92","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  Starts itself\n     *\n     *  @param slock the socket lock, non-null\n     *  @param initialI2PData may be null\n     *  @param onTimeout May be null. If non-null and no data (except initial data) was sent or received,\n                         it will be run before closing s.\n     */\n    public I2PTunnelOutproxyRunner(Socket s, Socket i2ps, Object slock, byte[] initialI2PData,\n                                   byte[] initialSocketData, Runnable onTimeout) {\n        this.s = s;\n        this.i2ps = i2ps;\n        this.slock = slock;\n        this.initialI2PData = initialI2PData;\n        this.initialSocketData = initialSocketData;\n        this.onTimeout = onTimeout;\n        lastActivityOn = -1;\n        startedOn = Clock.getInstance().now();\n        _log = I2PAppContext.getGlobalContext().logManager().getLog(getClass());\n        if (_log.shouldLog(Log.INFO))\n            _log.info(\"I2PTunnelRunner started\");\n        _runnerId = __runnerId.incrementAndGet();\n        setName(\"I2PTunnelOutproxyRunner \" + _runnerId);\n        start();\n    }","id":65060,"modified_method":"/**\n     *  Starts itself (fixme)\n     *\n     *  @param slock the socket lock, non-null\n     *  @param initialI2PData may be null\n     *  @param onTimeout May be null. If non-null and no data (except initial data) was sent or received,\n                         it will be run before closing s.\n     */\n    public I2PTunnelOutproxyRunner(Socket s, Socket i2ps, Object slock, byte[] initialI2PData,\n                                   byte[] initialSocketData, Runnable onTimeout) {\n        this.s = s;\n        this.i2ps = i2ps;\n        this.slock = slock;\n        this.initialI2PData = initialI2PData;\n        this.initialSocketData = initialSocketData;\n        this.onTimeout = onTimeout;\n        lastActivityOn = -1;\n        startedOn = Clock.getInstance().now();\n        _log = I2PAppContext.getGlobalContext().logManager().getLog(getClass());\n        if (_log.shouldLog(Log.INFO))\n            _log.info(\"OutproxyRunner started\");\n        _runnerId = __runnerId.incrementAndGet();\n        setName(\"OutproxyRunner \" + _runnerId);\n        start();\n    }","commit_id":"9ca625a64e8d5a5355c8d4b4b96a8b7f0da82b92","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  Is the systray enabled?\n     *\n     *  @since 0.9.26\n     */\n    public boolean isSystrayEnabled() {\n        return _context.getBooleanProperty(RouterConsoleRunner.PROP_DTG_ENABLED);\n    }","id":65061,"modified_method":"/**\n     *  Is the systray enabled?\n     *\n     *  @since 0.9.26\n     */\n    public boolean isSystrayEnabled() {\n        // default false for now, except on non-service windows\n        String sdtg = _context.getProperty(RouterConsoleRunner.PROP_DTG_ENABLED);\n        return Boolean.parseBoolean(sdtg) ||\n               (sdtg == null && SystemVersion.isWindows());\n    }","commit_id":"b123720fa3ab52cecc8b513acf107bdac37f8700","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private void startTrayApp() {\n        // if no permissions, don't even try\n        // isLaunchedAsService() always returns true on Linux\n        if (DAEMON_USER.equals(System.getProperty(\"user.name\")) ||\n            (SystemVersion.isWindows() && _context.hasWrapper() && WrapperManager.isLaunchedAsService())) {\n            // required true for jrobin to work\n            System.setProperty(\"java.awt.headless\", \"true\");\n            return;\n        }\n        try {\n            // default false for now\n            boolean desktopguiEnabled = _context.getBooleanProperty(PROP_DTG_ENABLED);\n            if (desktopguiEnabled) {\n                //Check if we are in a headless environment, set properties accordingly\n          \tSystem.setProperty(\"java.awt.headless\", Boolean.toString(GraphicsEnvironment.isHeadless()));\n                net.i2p.desktopgui.Main dtg = new net.i2p.desktopgui.Main(_context, _mgr, null);    \n                dtg.startup();\n            } else {\n                // required true for jrobin to work\n          \tSystem.setProperty(\"java.awt.headless\", \"true\");\n                // this check is in SysTray but do it here too\n                if (SystemVersion.isWindows() && (!Boolean.getBoolean(\"systray.disable\")) && (!SystemVersion.is64Bit()))\n                    SysTray.getInstance();\n            }\n        } catch (Throwable t) {\n            t.printStackTrace();\n        }\n    }","id":65062,"modified_method":"private void startTrayApp() {\n        // if no permissions, don't even try\n        // isLaunchedAsService() always returns true on Linux\n        if (DAEMON_USER.equals(System.getProperty(\"user.name\")) ||\n            (SystemVersion.isWindows() && _context.hasWrapper() && WrapperManager.isLaunchedAsService())) {\n            // required true for jrobin to work\n            System.setProperty(\"java.awt.headless\", \"true\");\n            return;\n        }\n        try {\n            // default false for now, except on non-service windows\n            String sdtg = _context.getProperty(PROP_DTG_ENABLED);\n            boolean desktopguiEnabled = Boolean.parseBoolean(sdtg) ||\n                                        (sdtg == null && SystemVersion.isWindows());\n            if (desktopguiEnabled) {\n                //Check if we are in a headless environment, set properties accordingly\n          \tSystem.setProperty(\"java.awt.headless\", Boolean.toString(GraphicsEnvironment.isHeadless()));\n                net.i2p.desktopgui.Main dtg = new net.i2p.desktopgui.Main(_context, _mgr, null);    \n                dtg.startup();\n            } else {\n                // required true for jrobin to work\n          \tSystem.setProperty(\"java.awt.headless\", \"true\");\n                // this check is in SysTray but do it here too\n                if (SystemVersion.isWindows() && (!Boolean.getBoolean(\"systray.disable\")) && (!SystemVersion.is64Bit()))\n                    SysTray.getInstance();\n            }\n        } catch (Throwable t) {\n            t.printStackTrace();\n        }\n    }","commit_id":"b123720fa3ab52cecc8b513acf107bdac37f8700","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Create (if necessary) and return a Digester configured to process the\n     * tld.\n     */\n    private static Digester createTldDigester(boolean namespaceAware,\n            boolean validation) {\n        \n        Digester digester = null;\n        if (!namespaceAware && !validation) {\n            if (tldDigesters[0] == null) {\n                tldDigesters[0] = DigesterFactory.newDigester(validation,\n                        namespaceAware, tldRuleSet);\n            }\n            digester = tldDigesters[0];\n        } else if (!namespaceAware && validation) {\n            if (tldDigesters[1] == null) {\n                tldDigesters[1] = DigesterFactory.newDigester(validation,\n                        namespaceAware, tldRuleSet);\n            }\n            digester = tldDigesters[1];\n        } else if (namespaceAware && !validation) {\n            if (tldDigesters[2] == null) {\n                tldDigesters[2] = DigesterFactory.newDigester(validation,\n                        namespaceAware, tldRuleSet);\n            }\n            digester = tldDigesters[2];\n        } else {\n            if (tldDigesters[3] == null) {\n                tldDigesters[3] = DigesterFactory.newDigester(validation,\n                        namespaceAware, tldRuleSet);\n            }\n            digester = tldDigesters[3];\n        }\n        return digester;\n    }","id":65063,"modified_method":"/**\n     * Create (if necessary) and return a Digester configured to process the\n     * tld.\n     */\n    private static Digester createTldDigester(boolean namespaceAware,\n            boolean validation) {\n        \n        Digester digester = null;\n        if (!namespaceAware && !validation) {\n            if (tldDigesters[0] == null) {\n                tldDigesters[0] = DigesterFactory.newDigester(validation,\n                        namespaceAware, new TldRuleSet());\n            }\n            digester = tldDigesters[0];\n        } else if (!namespaceAware && validation) {\n            if (tldDigesters[1] == null) {\n                tldDigesters[1] = DigesterFactory.newDigester(validation,\n                        namespaceAware, new TldRuleSet());\n            }\n            digester = tldDigesters[1];\n        } else if (namespaceAware && !validation) {\n            if (tldDigesters[2] == null) {\n                tldDigesters[2] = DigesterFactory.newDigester(validation,\n                        namespaceAware, new TldRuleSet());\n            }\n            digester = tldDigesters[2];\n        } else {\n            if (tldDigesters[3] == null) {\n                tldDigesters[3] = DigesterFactory.newDigester(validation,\n                        namespaceAware, new TldRuleSet());\n            }\n            digester = tldDigesters[3];\n        }\n        return digester;\n    }","commit_id":"c28b33c648f77586266ef00b4f11de0daa73fa26","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * <p>Add the set of Rule instances defined in this RuleSet to the\n     * specified <code>Digester<\/code> instance, associating them with\n     * our namespace URI (if any).  This method should only be called\n     * by a Digester instance.<\/p>\n     *\n     * @param digester Digester instance to which the new Rule instances\n     *  should be added.\n     */\n    public void addRuleInstances(Digester digester) {\n\n        digester.addCallMethod(prefix + \"taglib/listener/listener-class\",\n                               \"addApplicationListener\", 0);\n\n    }","id":65064,"modified_method":"/**\n     * <p>Add the set of Rule instances defined in this RuleSet to the\n     * specified <code>Digester<\/code> instance, associating them with\n     * our namespace URI (if any).  This method should only be called\n     * by a Digester instance.<\/p>\n     *\n     * @param digester Digester instance to which the new Rule instances\n     *  should be added.\n     */\n    public void addRuleInstances(Digester digester) {\n\n        TaglibUriRule taglibUriRule = new TaglibUriRule(); \n        \n        digester.addRule(prefix + \"taglib/uri\", taglibUriRule);\n\n        digester.addRule(prefix + \"taglib/listener/listener-class\",\n                new TaglibListenerRule(taglibUriRule));\n\n    }","commit_id":"c28b33c648f77586266ef00b4f11de0daa73fa26","url":"https://github.com/apache/tomcat"},{"original_method":"public static String getInputPageRowSize(Configuration conf)\n    {\n        return conf.get(INPUT_CQL_PAGE_ROW_SIZE_CONFIG);\n    }","id":65065,"modified_method":"public static Optional<Integer> getInputPageRowSize(Configuration conf)\n    {\n        return getIntSetting(INPUT_CQL_PAGE_ROW_SIZE_CONFIG, conf);\n    }","commit_id":"3b708f9989274cbe9e0e2a5fda6f1d0a3d96ebee","url":"https://github.com/apache/cassandra"},{"original_method":"public void initialize(InputSplit split, TaskAttemptContext context) throws IOException\n    {\n        this.split = (ColumnFamilySplit) split;\n        Configuration conf = HadoopCompat.getConfiguration(context);\n        totalRowCount = (this.split.getLength() < Long.MAX_VALUE)\n                      ? (int) this.split.getLength()\n                      : ConfigHelper.getInputSplitSize(conf);\n        cfName = ConfigHelper.getInputColumnFamily(conf);\n        consistencyLevel = ConsistencyLevel.valueOf(ConfigHelper.getReadConsistencyLevel(conf));\n        keyspace = ConfigHelper.getInputKeyspace(conf);\n        columns = CqlConfigHelper.getInputcolumns(conf);\n        userDefinedWhereClauses = CqlConfigHelper.getInputWhereClauses(conf);\n\n        try\n        {\n            pageRowSize = Integer.parseInt(CqlConfigHelper.getInputPageRowSize(conf));\n        }\n        catch (NumberFormatException e)\n        {\n            pageRowSize = DEFAULT_CQL_PAGE_LIMIT;\n        }\n\n        partitioner = ConfigHelper.getInputPartitioner(HadoopCompat.getConfiguration(context));\n\n        try\n        {\n            if (client != null)\n                return;\n\n            // create connection using thrift\n            String[] locations = split.getLocations();\n            Exception lastException = null;\n            for (String location : locations)\n            {\n                int port = ConfigHelper.getInputRpcPort(conf);\n                try\n                {\n                    client = CqlPagingInputFormat.createAuthenticatedClient(location, port, conf);\n                    break;\n                }\n                catch (Exception e)\n                {\n                    lastException = e;\n                    logger.warn(\"Failed to create authenticated client to {}:{}\", location , port);\n                }\n            }\n            if (client == null && lastException != null)\n                throw lastException;\n\n            // retrieve partition keys and cluster keys from system.schema_columnfamilies table\n            retrieveKeys();\n\n            client.set_keyspace(keyspace);\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n\n        rowIterator = new RowIterator();\n\n        logger.debug(\"created {}\", rowIterator);\n    }","id":65066,"modified_method":"public void initialize(InputSplit split, TaskAttemptContext context) throws IOException\n    {\n        this.split = (ColumnFamilySplit) split;\n        Configuration conf = HadoopCompat.getConfiguration(context);\n        totalRowCount = (this.split.getLength() < Long.MAX_VALUE)\n                      ? (int) this.split.getLength()\n                      : ConfigHelper.getInputSplitSize(conf);\n        cfName = ConfigHelper.getInputColumnFamily(conf);\n        consistencyLevel = ConsistencyLevel.valueOf(ConfigHelper.getReadConsistencyLevel(conf));\n        keyspace = ConfigHelper.getInputKeyspace(conf);\n        columns = CqlConfigHelper.getInputcolumns(conf);\n        userDefinedWhereClauses = CqlConfigHelper.getInputWhereClauses(conf);\n\n        try\n        {\n            pageRowSize = CqlConfigHelper.getInputPageRowSize(conf).get();\n        }\n        catch (NumberFormatException e)\n        {\n            pageRowSize = DEFAULT_CQL_PAGE_LIMIT;\n        }\n\n        partitioner = ConfigHelper.getInputPartitioner(HadoopCompat.getConfiguration(context));\n\n        try\n        {\n            if (client != null)\n                return;\n\n            // create connection using thrift\n            String[] locations = split.getLocations();\n            Exception lastException = null;\n            for (String location : locations)\n            {\n                int port = ConfigHelper.getInputRpcPort(conf);\n                try\n                {\n                    client = CqlPagingInputFormat.createAuthenticatedClient(location, port, conf);\n                    break;\n                }\n                catch (Exception e)\n                {\n                    lastException = e;\n                    logger.warn(\"Failed to create authenticated client to {}:{}\", location , port);\n                }\n            }\n            if (client == null && lastException != null)\n                throw lastException;\n\n            // retrieve partition keys and cluster keys from system.schema_columnfamilies table\n            retrieveKeys();\n\n            client.set_keyspace(keyspace);\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n\n        rowIterator = new RowIterator();\n\n        logger.debug(\"created {}\", rowIterator);\n    }","commit_id":"3b708f9989274cbe9e0e2a5fda6f1d0a3d96ebee","url":"https://github.com/apache/cassandra"},{"original_method":"public int run(String[] args) throws Exception\n    {\n        String outputReducerType = \"filesystem\";\n        if (args != null && args[0].startsWith(OUTPUT_REDUCER_VAR))\n        {\n            String[] s = args[0].split(\"=\");\n            if (s != null && s.length == 2)\n                outputReducerType = s[1];\n        }\n        logger.info(\"output reducer type: \" + outputReducerType);\n\n        Job job = new Job(getConf(), \"wordcount\");\n        job.setJarByClass(WordCount.class);\n        job.setMapperClass(TokenizerMapper.class);\n\n        if (outputReducerType.equalsIgnoreCase(\"filesystem\"))\n        {\n            job.setCombinerClass(ReducerToFilesystem.class);\n            job.setReducerClass(ReducerToFilesystem.class);\n            job.setOutputKeyClass(Text.class);\n            job.setOutputValueClass(IntWritable.class);\n            FileOutputFormat.setOutputPath(job, new Path(OUTPUT_PATH_PREFIX));\n        }\n        else\n        {\n            job.setReducerClass(ReducerToCassandra.class);\n\n            job.setMapOutputKeyClass(Text.class);\n            job.setMapOutputValueClass(IntWritable.class);\n            job.setOutputKeyClass(Map.class);\n            job.setOutputValueClass(List.class);\n\n            job.setOutputFormatClass(CqlOutputFormat.class);\n\n            ConfigHelper.setOutputColumnFamily(job.getConfiguration(), KEYSPACE, OUTPUT_COLUMN_FAMILY);\n            job.getConfiguration().set(PRIMARY_KEY, \"word,sum\");\n            String query = \"UPDATE \" + KEYSPACE + \".\" + OUTPUT_COLUMN_FAMILY +\n                           \" SET count_num = ? \";\n            CqlConfigHelper.setOutputCql(job.getConfiguration(), query);\n            ConfigHelper.setOutputInitialAddress(job.getConfiguration(), \"localhost\");\n            ConfigHelper.setOutputPartitioner(job.getConfiguration(), \"Murmur3Partitioner\");\n        }\n\n        job.setInputFormatClass(CqlPagingInputFormat.class);\n\n        ConfigHelper.setInputRpcPort(job.getConfiguration(), \"9160\");\n        ConfigHelper.setInputInitialAddress(job.getConfiguration(), \"localhost\");\n        ConfigHelper.setInputColumnFamily(job.getConfiguration(), KEYSPACE, COLUMN_FAMILY);\n        ConfigHelper.setInputPartitioner(job.getConfiguration(), \"Murmur3Partitioner\");\n\n        CqlConfigHelper.setInputCQLPageRowSize(job.getConfiguration(), \"3\");\n        job.waitForCompletion(true);\n        return 0;\n    }","id":65067,"modified_method":"public int run(String[] args) throws Exception\n    {\n        String outputReducerType = \"filesystem\";\n        String inputMapperType = \"native\";\n        String outputReducer = null;\n        String inputMapper = null;\n\n        if (args != null)\n        {\n            if(args[0].startsWith(OUTPUT_REDUCER_VAR))\n                outputReducer = args[0];\n            if(args[0].startsWith(INPUT_MAPPER_VAR))\n                inputMapper = args[0];\n            \n            if (args.length == 2)\n            {\n                if(args[1].startsWith(OUTPUT_REDUCER_VAR))\n                    outputReducer = args[1];\n                if(args[1].startsWith(INPUT_MAPPER_VAR))\n                    inputMapper = args[1]; \n            }\n        }\n\n        if (outputReducer != null)\n        {\n            String[] s = outputReducer.split(\"=\");\n            if (s != null && s.length == 2)\n                outputReducerType = s[1];\n        }\n        logger.info(\"output reducer type: \" + outputReducerType);\n        if (inputMapper != null)\n        {\n            String[] s = inputMapper.split(\"=\");\n            if (s != null && s.length == 2)\n                inputMapperType = s[1];\n        }\n        Job job = new Job(getConf(), \"wordcount\");\n        job.setJarByClass(WordCount.class);\n\n        if (outputReducerType.equalsIgnoreCase(\"filesystem\"))\n        {\n            job.setCombinerClass(ReducerToFilesystem.class);\n            job.setReducerClass(ReducerToFilesystem.class);\n            job.setOutputKeyClass(Text.class);\n            job.setOutputValueClass(IntWritable.class);\n            FileOutputFormat.setOutputPath(job, new Path(OUTPUT_PATH_PREFIX));\n        }\n        else\n        {\n            job.setReducerClass(ReducerToCassandra.class);\n\n            job.setMapOutputKeyClass(Text.class);\n            job.setMapOutputValueClass(IntWritable.class);\n            job.setOutputKeyClass(Map.class);\n            job.setOutputValueClass(List.class);\n\n            job.setOutputFormatClass(CqlOutputFormat.class);\n\n            ConfigHelper.setOutputColumnFamily(job.getConfiguration(), KEYSPACE, OUTPUT_COLUMN_FAMILY);\n            job.getConfiguration().set(PRIMARY_KEY, \"word,sum\");\n            String query = \"UPDATE \" + KEYSPACE + \".\" + OUTPUT_COLUMN_FAMILY +\n                           \" SET count_num = ? \";\n            CqlConfigHelper.setOutputCql(job.getConfiguration(), query);\n            ConfigHelper.setOutputInitialAddress(job.getConfiguration(), \"localhost\");\n            ConfigHelper.setOutputPartitioner(job.getConfiguration(), \"Murmur3Partitioner\");\n        }\n\n        if (inputMapperType.equalsIgnoreCase(\"native\"))\n        {\n            job.setMapperClass(NativeTokenizerMapper.class);\n            job.setInputFormatClass(CqlInputFormat.class);\n            CqlConfigHelper.setInputCql(job.getConfiguration(), \"select * from \" + COLUMN_FAMILY + \" where token(id) > ? and token(id) <= ? allow filtering\");\n        }\n        else\n        {\n            job.setMapperClass(TokenizerMapper.class);\n            job.setInputFormatClass(CqlPagingInputFormat.class);\n            ConfigHelper.setInputRpcPort(job.getConfiguration(), \"9160\");\n        }\n\n        ConfigHelper.setInputInitialAddress(job.getConfiguration(), \"localhost\");\n        ConfigHelper.setInputColumnFamily(job.getConfiguration(), KEYSPACE, COLUMN_FAMILY);\n        ConfigHelper.setInputPartitioner(job.getConfiguration(), \"Murmur3Partitioner\");\n\n        CqlConfigHelper.setInputCQLPageRowSize(job.getConfiguration(), \"3\");\n        job.waitForCompletion(true);\n        return 0;\n    }","commit_id":"3b708f9989274cbe9e0e2a5fda6f1d0a3d96ebee","url":"https://github.com/apache/cassandra"},{"original_method":"public int run(String[] args) throws Exception\n    {\n        Job job = new Job(getConf(), \"wordcountcounters\");\n        job.setJarByClass(WordCountCounters.class);\n        job.setMapperClass(SumMapper.class);\n\n        job.setCombinerClass(ReducerToFilesystem.class);\n        job.setReducerClass(ReducerToFilesystem.class);\n        job.setOutputKeyClass(Text.class);\n        job.setOutputValueClass(LongWritable.class);\n        FileOutputFormat.setOutputPath(job, new Path(OUTPUT_PATH_PREFIX));\n\n        job.setInputFormatClass(CqlPagingInputFormat.class);\n\n        ConfigHelper.setInputRpcPort(job.getConfiguration(), \"9160\");\n        ConfigHelper.setInputInitialAddress(job.getConfiguration(), \"localhost\");\n        ConfigHelper.setInputPartitioner(job.getConfiguration(), \"Murmur3Partitioner\");\n        ConfigHelper.setInputColumnFamily(job.getConfiguration(), WordCount.KEYSPACE, WordCount.OUTPUT_COLUMN_FAMILY);\n\n        CqlConfigHelper.setInputCQLPageRowSize(job.getConfiguration(), \"3\");\n\n        job.waitForCompletion(true);\n        return 0;\n    }","id":65068,"modified_method":"public int run(String[] args) throws Exception\n    {\n        String inputMapperType = \"native\";\n        if (args != null && args[0].startsWith(INPUT_MAPPER_VAR))\n        {\n            String[] arg0 = args[0].split(\"=\");\n            if (arg0 != null && arg0.length == 2)\n                inputMapperType = arg0[1];\n        }\n        Job job = new Job(getConf(), \"wordcountcounters\");\n\n        job.setCombinerClass(ReducerToFilesystem.class);\n        job.setReducerClass(ReducerToFilesystem.class);\n        job.setJarByClass(WordCountCounters.class); \n\n        ConfigHelper.setInputInitialAddress(job.getConfiguration(), \"localhost\");\n        ConfigHelper.setInputPartitioner(job.getConfiguration(), \"Murmur3Partitioner\");\n        ConfigHelper.setInputColumnFamily(job.getConfiguration(), WordCount.KEYSPACE, WordCount.OUTPUT_COLUMN_FAMILY);\n\n        CqlConfigHelper.setInputCQLPageRowSize(job.getConfiguration(), \"3\");\n        if (\"native\".equals(inputMapperType))\n        {\n            job.setMapperClass(SumNativeMapper.class);\n            job.setInputFormatClass(CqlInputFormat.class);\n            CqlConfigHelper.setInputCql(job.getConfiguration(), \"select * from \" + WordCount.OUTPUT_COLUMN_FAMILY + \" where token(word) > ? and token(word) <= ? allow filtering\");\n        }\n        else\n        {\n            job.setMapperClass(SumMapper.class);\n            job.setInputFormatClass(CqlPagingInputFormat.class);\n            ConfigHelper.setInputRpcPort(job.getConfiguration(), \"9160\");\n        }\n\n        job.setOutputKeyClass(Text.class);\n        job.setOutputValueClass(LongWritable.class);\n        FileOutputFormat.setOutputPath(job, new Path(OUTPUT_PATH_PREFIX));\n        job.waitForCompletion(true);\n        return 0;\n    }","commit_id":"3b708f9989274cbe9e0e2a5fda6f1d0a3d96ebee","url":"https://github.com/apache/cassandra"},{"original_method":"public static String getInputPageRowSize(Configuration conf)\n    {\n        return conf.get(INPUT_CQL_PAGE_ROW_SIZE_CONFIG);\n    }","id":65069,"modified_method":"public static Optional<Integer> getInputPageRowSize(Configuration conf)\n    {\n        return getIntSetting(INPUT_CQL_PAGE_ROW_SIZE_CONFIG, conf);\n    }","commit_id":"d7cb9700538c6ad9921902f81c081eef77a037b7","url":"https://github.com/apache/cassandra"},{"original_method":"public void initialize(InputSplit split, TaskAttemptContext context) throws IOException\n    {\n        this.split = (ColumnFamilySplit) split;\n        Configuration conf = HadoopCompat.getConfiguration(context);\n        totalRowCount = (this.split.getLength() < Long.MAX_VALUE)\n                      ? (int) this.split.getLength()\n                      : ConfigHelper.getInputSplitSize(conf);\n        cfName = ConfigHelper.getInputColumnFamily(conf);\n        consistencyLevel = ConsistencyLevel.valueOf(ConfigHelper.getReadConsistencyLevel(conf));\n        keyspace = ConfigHelper.getInputKeyspace(conf);\n        columns = CqlConfigHelper.getInputcolumns(conf);\n        userDefinedWhereClauses = CqlConfigHelper.getInputWhereClauses(conf);\n\n        try\n        {\n            pageRowSize = Integer.parseInt(CqlConfigHelper.getInputPageRowSize(conf));\n        }\n        catch (NumberFormatException e)\n        {\n            pageRowSize = DEFAULT_CQL_PAGE_LIMIT;\n        }\n\n        partitioner = ConfigHelper.getInputPartitioner(HadoopCompat.getConfiguration(context));\n\n        try\n        {\n            if (client != null)\n                return;\n\n            // create connection using thrift\n            String[] locations = split.getLocations();\n            Exception lastException = null;\n            for (String location : locations)\n            {\n                int port = ConfigHelper.getInputRpcPort(conf);\n                try\n                {\n                    client = CqlPagingInputFormat.createAuthenticatedClient(location, port, conf);\n                    break;\n                }\n                catch (Exception e)\n                {\n                    lastException = e;\n                    logger.warn(\"Failed to create authenticated client to {}:{}\", location , port);\n                }\n            }\n            if (client == null && lastException != null)\n                throw lastException;\n\n            // retrieve partition keys and cluster keys from system.schema_columnfamilies table\n            retrieveKeys();\n\n            client.set_keyspace(keyspace);\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n\n        rowIterator = new RowIterator();\n\n        logger.debug(\"created {}\", rowIterator);\n    }","id":65070,"modified_method":"public void initialize(InputSplit split, TaskAttemptContext context) throws IOException\n    {\n        this.split = (ColumnFamilySplit) split;\n        Configuration conf = HadoopCompat.getConfiguration(context);\n        totalRowCount = (this.split.getLength() < Long.MAX_VALUE)\n                      ? (int) this.split.getLength()\n                      : ConfigHelper.getInputSplitSize(conf);\n        cfName = ConfigHelper.getInputColumnFamily(conf);\n        consistencyLevel = ConsistencyLevel.valueOf(ConfigHelper.getReadConsistencyLevel(conf));\n        keyspace = ConfigHelper.getInputKeyspace(conf);\n        columns = CqlConfigHelper.getInputcolumns(conf);\n        userDefinedWhereClauses = CqlConfigHelper.getInputWhereClauses(conf);\n\n        try\n        {\n            pageRowSize = CqlConfigHelper.getInputPageRowSize(conf).get();\n        }\n        catch (NumberFormatException e)\n        {\n            pageRowSize = DEFAULT_CQL_PAGE_LIMIT;\n        }\n\n        partitioner = ConfigHelper.getInputPartitioner(HadoopCompat.getConfiguration(context));\n\n        try\n        {\n            if (client != null)\n                return;\n\n            // create connection using thrift\n            String[] locations = split.getLocations();\n            Exception lastException = null;\n            for (String location : locations)\n            {\n                int port = ConfigHelper.getInputRpcPort(conf);\n                try\n                {\n                    client = CqlPagingInputFormat.createAuthenticatedClient(location, port, conf);\n                    break;\n                }\n                catch (Exception e)\n                {\n                    lastException = e;\n                    logger.warn(\"Failed to create authenticated client to {}:{}\", location , port);\n                }\n            }\n            if (client == null && lastException != null)\n                throw lastException;\n\n            // retrieve partition keys and cluster keys from system.schema_columnfamilies table\n            retrieveKeys();\n\n            client.set_keyspace(keyspace);\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n\n        rowIterator = new RowIterator();\n\n        logger.debug(\"created {}\", rowIterator);\n    }","commit_id":"d7cb9700538c6ad9921902f81c081eef77a037b7","url":"https://github.com/apache/cassandra"},{"original_method":"public int run(String[] args) throws Exception\n    {\n        String outputReducerType = \"filesystem\";\n        if (args != null && args[0].startsWith(OUTPUT_REDUCER_VAR))\n        {\n            String[] s = args[0].split(\"=\");\n            if (s != null && s.length == 2)\n                outputReducerType = s[1];\n        }\n        logger.info(\"output reducer type: \" + outputReducerType);\n\n        Job job = new Job(getConf(), \"wordcount\");\n        job.setJarByClass(WordCount.class);\n        job.setMapperClass(TokenizerMapper.class);\n\n        if (outputReducerType.equalsIgnoreCase(\"filesystem\"))\n        {\n            job.setCombinerClass(ReducerToFilesystem.class);\n            job.setReducerClass(ReducerToFilesystem.class);\n            job.setOutputKeyClass(Text.class);\n            job.setOutputValueClass(IntWritable.class);\n            FileOutputFormat.setOutputPath(job, new Path(OUTPUT_PATH_PREFIX));\n        }\n        else\n        {\n            job.setReducerClass(ReducerToCassandra.class);\n\n            job.setMapOutputKeyClass(Text.class);\n            job.setMapOutputValueClass(IntWritable.class);\n            job.setOutputKeyClass(Map.class);\n            job.setOutputValueClass(List.class);\n\n            job.setOutputFormatClass(CqlOutputFormat.class);\n\n            ConfigHelper.setOutputColumnFamily(job.getConfiguration(), KEYSPACE, OUTPUT_COLUMN_FAMILY);\n            job.getConfiguration().set(PRIMARY_KEY, \"word,sum\");\n            String query = \"UPDATE \" + KEYSPACE + \".\" + OUTPUT_COLUMN_FAMILY +\n                           \" SET count_num = ? \";\n            CqlConfigHelper.setOutputCql(job.getConfiguration(), query);\n            ConfigHelper.setOutputInitialAddress(job.getConfiguration(), \"localhost\");\n            ConfigHelper.setOutputPartitioner(job.getConfiguration(), \"Murmur3Partitioner\");\n        }\n\n        job.setInputFormatClass(CqlPagingInputFormat.class);\n\n        ConfigHelper.setInputRpcPort(job.getConfiguration(), \"9160\");\n        ConfigHelper.setInputInitialAddress(job.getConfiguration(), \"localhost\");\n        ConfigHelper.setInputColumnFamily(job.getConfiguration(), KEYSPACE, COLUMN_FAMILY);\n        ConfigHelper.setInputPartitioner(job.getConfiguration(), \"Murmur3Partitioner\");\n\n        CqlConfigHelper.setInputCQLPageRowSize(job.getConfiguration(), \"3\");\n        job.waitForCompletion(true);\n        return 0;\n    }","id":65071,"modified_method":"public int run(String[] args) throws Exception\n    {\n        String outputReducerType = \"filesystem\";\n        String inputMapperType = \"native\";\n        String outputReducer = null;\n        String inputMapper = null;\n\n        if (args != null)\n        {\n            if(args[0].startsWith(OUTPUT_REDUCER_VAR))\n                outputReducer = args[0];\n            if(args[0].startsWith(INPUT_MAPPER_VAR))\n                inputMapper = args[0];\n            \n            if (args.length == 2)\n            {\n                if(args[1].startsWith(OUTPUT_REDUCER_VAR))\n                    outputReducer = args[1];\n                if(args[1].startsWith(INPUT_MAPPER_VAR))\n                    inputMapper = args[1]; \n            }\n        }\n\n        if (outputReducer != null)\n        {\n            String[] s = outputReducer.split(\"=\");\n            if (s != null && s.length == 2)\n                outputReducerType = s[1];\n        }\n        logger.info(\"output reducer type: \" + outputReducerType);\n        if (inputMapper != null)\n        {\n            String[] s = inputMapper.split(\"=\");\n            if (s != null && s.length == 2)\n                inputMapperType = s[1];\n        }\n        Job job = new Job(getConf(), \"wordcount\");\n        job.setJarByClass(WordCount.class);\n\n        if (outputReducerType.equalsIgnoreCase(\"filesystem\"))\n        {\n            job.setCombinerClass(ReducerToFilesystem.class);\n            job.setReducerClass(ReducerToFilesystem.class);\n            job.setOutputKeyClass(Text.class);\n            job.setOutputValueClass(IntWritable.class);\n            FileOutputFormat.setOutputPath(job, new Path(OUTPUT_PATH_PREFIX));\n        }\n        else\n        {\n            job.setReducerClass(ReducerToCassandra.class);\n\n            job.setMapOutputKeyClass(Text.class);\n            job.setMapOutputValueClass(IntWritable.class);\n            job.setOutputKeyClass(Map.class);\n            job.setOutputValueClass(List.class);\n\n            job.setOutputFormatClass(CqlOutputFormat.class);\n\n            ConfigHelper.setOutputColumnFamily(job.getConfiguration(), KEYSPACE, OUTPUT_COLUMN_FAMILY);\n            job.getConfiguration().set(PRIMARY_KEY, \"word,sum\");\n            String query = \"UPDATE \" + KEYSPACE + \".\" + OUTPUT_COLUMN_FAMILY +\n                           \" SET count_num = ? \";\n            CqlConfigHelper.setOutputCql(job.getConfiguration(), query);\n            ConfigHelper.setOutputInitialAddress(job.getConfiguration(), \"localhost\");\n            ConfigHelper.setOutputPartitioner(job.getConfiguration(), \"Murmur3Partitioner\");\n        }\n\n        if (inputMapperType.equalsIgnoreCase(\"native\"))\n        {\n            job.setMapperClass(NativeTokenizerMapper.class);\n            job.setInputFormatClass(CqlInputFormat.class);\n            CqlConfigHelper.setInputCql(job.getConfiguration(), \"select * from \" + COLUMN_FAMILY + \" where token(id) > ? and token(id) <= ? allow filtering\");\n        }\n        else\n        {\n            job.setMapperClass(TokenizerMapper.class);\n            job.setInputFormatClass(CqlPagingInputFormat.class);\n            ConfigHelper.setInputRpcPort(job.getConfiguration(), \"9160\");\n        }\n\n        ConfigHelper.setInputInitialAddress(job.getConfiguration(), \"localhost\");\n        ConfigHelper.setInputColumnFamily(job.getConfiguration(), KEYSPACE, COLUMN_FAMILY);\n        ConfigHelper.setInputPartitioner(job.getConfiguration(), \"Murmur3Partitioner\");\n\n        CqlConfigHelper.setInputCQLPageRowSize(job.getConfiguration(), \"3\");\n        job.waitForCompletion(true);\n        return 0;\n    }","commit_id":"d7cb9700538c6ad9921902f81c081eef77a037b7","url":"https://github.com/apache/cassandra"},{"original_method":"public int run(String[] args) throws Exception\n    {\n        Job job = new Job(getConf(), \"wordcountcounters\");\n        job.setJarByClass(WordCountCounters.class);\n        job.setMapperClass(SumMapper.class);\n\n        job.setCombinerClass(ReducerToFilesystem.class);\n        job.setReducerClass(ReducerToFilesystem.class);\n        job.setOutputKeyClass(Text.class);\n        job.setOutputValueClass(LongWritable.class);\n        FileOutputFormat.setOutputPath(job, new Path(OUTPUT_PATH_PREFIX));\n\n        job.setInputFormatClass(CqlPagingInputFormat.class);\n\n        ConfigHelper.setInputRpcPort(job.getConfiguration(), \"9160\");\n        ConfigHelper.setInputInitialAddress(job.getConfiguration(), \"localhost\");\n        ConfigHelper.setInputPartitioner(job.getConfiguration(), \"Murmur3Partitioner\");\n        ConfigHelper.setInputColumnFamily(job.getConfiguration(), WordCount.KEYSPACE, WordCount.OUTPUT_COLUMN_FAMILY);\n\n        CqlConfigHelper.setInputCQLPageRowSize(job.getConfiguration(), \"3\");\n\n        job.waitForCompletion(true);\n        return 0;\n    }","id":65072,"modified_method":"public int run(String[] args) throws Exception\n    {\n        String inputMapperType = \"native\";\n        if (args != null && args[0].startsWith(INPUT_MAPPER_VAR))\n        {\n            String[] arg0 = args[0].split(\"=\");\n            if (arg0 != null && arg0.length == 2)\n                inputMapperType = arg0[1];\n        }\n        Job job = new Job(getConf(), \"wordcountcounters\");\n\n        job.setCombinerClass(ReducerToFilesystem.class);\n        job.setReducerClass(ReducerToFilesystem.class);\n        job.setJarByClass(WordCountCounters.class); \n\n        ConfigHelper.setInputInitialAddress(job.getConfiguration(), \"localhost\");\n        ConfigHelper.setInputPartitioner(job.getConfiguration(), \"Murmur3Partitioner\");\n        ConfigHelper.setInputColumnFamily(job.getConfiguration(), WordCount.KEYSPACE, WordCount.OUTPUT_COLUMN_FAMILY);\n\n        CqlConfigHelper.setInputCQLPageRowSize(job.getConfiguration(), \"3\");\n        if (\"native\".equals(inputMapperType))\n        {\n            job.setMapperClass(SumNativeMapper.class);\n            job.setInputFormatClass(CqlInputFormat.class);\n            CqlConfigHelper.setInputCql(job.getConfiguration(), \"select * from \" + WordCount.OUTPUT_COLUMN_FAMILY + \" where token(word) > ? and token(word) <= ? allow filtering\");\n        }\n        else\n        {\n            job.setMapperClass(SumMapper.class);\n            job.setInputFormatClass(CqlPagingInputFormat.class);\n            ConfigHelper.setInputRpcPort(job.getConfiguration(), \"9160\");\n        }\n\n        job.setOutputKeyClass(Text.class);\n        job.setOutputValueClass(LongWritable.class);\n        FileOutputFormat.setOutputPath(job, new Path(OUTPUT_PATH_PREFIX));\n        job.waitForCompletion(true);\n        return 0;\n    }","commit_id":"d7cb9700538c6ad9921902f81c081eef77a037b7","url":"https://github.com/apache/cassandra"},{"original_method":"protected void doGet(HttpServletRequest request, HttpServletResponse response)\n    \tthrows ServletException, IOException\n    {\n        String servletPath=null;\n        String pathInfo=null;\n        Enumeration reqRanges = null;\n        Boolean included =request.getAttribute(Dispatcher.INCLUDE_REQUEST_URI)!=null;\n        if (included!=null && included.booleanValue())\n        {\n            servletPath=(String)request.getAttribute(Dispatcher.INCLUDE_SERVLET_PATH);\n            pathInfo=(String)request.getAttribute(Dispatcher.INCLUDE_PATH_INFO);\n            if (servletPath==null)\n            {\n                servletPath=request.getServletPath();\n                pathInfo=request.getPathInfo();\n            }\n        }\n        else\n        {\n            included=Boolean.FALSE;\n            servletPath=request.getServletPath();\n            pathInfo=request.getPathInfo();\n            \n            // Is this a range request?\n            reqRanges = request.getHeaders(HttpHeaders.RANGE);\n            if (reqRanges!=null && !reqRanges.hasMoreElements())\n                reqRanges=null;\n        }\n        \n        String pathInContext=URIUtil.addPaths(servletPath,pathInfo);\n        boolean endsWithSlash=pathInContext.endsWith(URIUtil.SLASH);\n        \n        // Can we gzip this request?\n        String pathInContextGz=null;\n        boolean gzip=false;\n        if (!included.booleanValue() && _gzip && reqRanges==null && !endsWithSlash )\n        {\n            String accept=request.getHeader(HttpHeaders.ACCEPT_ENCODING);\n            if (accept!=null && accept.indexOf(\"gzip\")>=0)\n                gzip=true;\n        }\n        \n        // Find the resource and content\n        Resource resource=null;\n        HttpContent content=null;\n        \n        Connector connector = HttpConnection.getCurrentConnection().getConnector();\n        ResourceCache cache=(connector instanceof NIOConnector) ?_nioCache:_bioCache;\n        try\n        {   \n            // Try gzipped content first\n            if (gzip)\n            {\n                pathInContextGz=pathInContext+\".gz\";  \n\n                if (cache==null)\n                {\n                    resource=getResource(pathInContextGz);\n                }\n                else\n                {\n                    content=cache.lookup(pathInContextGz,this);\n\n                    if (content!=null)\n                        resource=content.getResource();\n                    else\n                        resource=getResource(pathInContextGz);\n                }\n\n                if (resource==null || !resource.exists()|| resource.isDirectory())\n                {\n                    if (cache!=null && content==null)\n                    {\n                        String real_path=_servletContext.getRealPath(pathInContextGz);\n                        if (real_path!=null)\n                            cache.miss(pathInContextGz,_contextHandler.newResource(real_path));\n                    }\n                    gzip=false;\n                    pathInContextGz=null;\n                }\n            }\n        \n            // find resource\n            if (!gzip)\n            {\n                if (cache==null)\n                    resource=getResource(pathInContext);\n                else\n                {\n                    content=cache.lookup(pathInContext,this);\n\n                    if (content!=null)\n                        resource=content.getResource();\n                    else\n                        resource=getResource(pathInContext);\n                }\n            }\n            \n            if (Log.isDebugEnabled())\n                Log.debug(\"resource=\"+resource+(content!=null?\" content\":\"\"));\n                        \n            // Handle resource\n            if (resource==null || !resource.exists())\n                response.sendError(HttpServletResponse.SC_NOT_FOUND);\n            else if (!resource.isDirectory())\n            {   \n                // ensure we have content\n                if (content==null)\n                    content=new UnCachedContent(resource);\n                \n                if (included.booleanValue() || passConditionalHeaders(request,response, resource,content))  \n                {\n                    if (gzip)\n                    {\n                       response.setHeader(HttpHeaders.CONTENT_ENCODING,\"gzip\");\n                       String mt=_servletContext.getMimeType(pathInContext);\n                       if (mt!=null)\n                           response.setContentType(mt);\n                    }\n                    sendData(request,response,included.booleanValue(),resource,content,reqRanges);  \n                }\n            }\n            else\n            {\n                String welcome=null;\n                \n                if (!endsWithSlash || (pathInContext.length()==1 && request.getAttribute(\"org.eclipse.jetty.server.nullPathInfo\")!=null))\n                {\n                    StringBuffer buf=request.getRequestURL();\n                    synchronized(buf)\n                    {\n                        int param=buf.lastIndexOf(\";\");\n                        if (param<0)\n                            buf.append('/');\n                        else\n                            buf.insert(param,'/');\n                        String q=request.getQueryString();\n                        if (q!=null&&q.length()!=0)\n                        {\n                            buf.append('?');\n                            buf.append(q);\n                        }\n                        response.setContentLength(0);\n                        response.sendRedirect(response.encodeRedirectURL(buf.toString()));\n                    }\n                }\n                // else look for a welcome file\n                else if (null!=(welcome=getWelcomeFile(resource)))\n                {\n                    String ipath=URIUtil.addPaths(pathInContext,welcome);\n                    if (_redirectWelcome)\n                    {\n                        // Redirect to the index\n                        response.setContentLength(0);\n                        String q=request.getQueryString();\n                        if (q!=null&&q.length()!=0)\n                            response.sendRedirect(URIUtil.addPaths( _servletContext.getContextPath(),ipath)+\"?\"+q);\n                        else\n                            response.sendRedirect(URIUtil.addPaths( _servletContext.getContextPath(),ipath));\n                    }\n                    else\n                    {\n                        // Forward to the index\n                        RequestDispatcher dispatcher=request.getRequestDispatcher(ipath);\n                        if (dispatcher!=null)\n                        {\n                            if (included.booleanValue())\n                                dispatcher.include(request,response);\n                            else\n                            {\n                                request.setAttribute(\"org.eclipse.jetty.server.welcome\",ipath);\n                                dispatcher.forward(request,response);\n                            }\n                        }\n                    }\n                }\n                else \n                {\n                    content=new UnCachedContent(resource);\n                    if (included.booleanValue() || passConditionalHeaders(request,response, resource,content))\n                        sendDirectory(request,response,resource,pathInContext.length()>1);\n                }\n            }\n        }\n        catch(IllegalArgumentException e)\n        {\n            Log.warn(Log.EXCEPTION,e);\n            if(!response.isCommitted())\n                response.sendError(500, e.getMessage());\n        }\n        finally\n        {\n            if (content!=null)\n                content.release();\n            else if (resource!=null)\n                resource.release();\n        }\n        \n    }","id":65073,"modified_method":"protected void doGet(HttpServletRequest request, HttpServletResponse response)\n    \tthrows ServletException, IOException\n    {\n        String servletPath=null;\n        String pathInfo=null;\n        Enumeration reqRanges = null;\n        Boolean included =request.getAttribute(Dispatcher.INCLUDE_REQUEST_URI)!=null;\n        if (included!=null && included.booleanValue())\n        {\n            servletPath=(String)request.getAttribute(Dispatcher.INCLUDE_SERVLET_PATH);\n            pathInfo=(String)request.getAttribute(Dispatcher.INCLUDE_PATH_INFO);\n            if (servletPath==null)\n            {\n                servletPath=request.getServletPath();\n                pathInfo=request.getPathInfo();\n            }\n        }\n        else\n        {\n            included=Boolean.FALSE;\n            servletPath=request.getServletPath();\n            pathInfo=request.getPathInfo();\n            \n            // Is this a range request?\n            reqRanges = request.getHeaders(HttpHeaders.RANGE);\n            if (reqRanges!=null && !reqRanges.hasMoreElements())\n                reqRanges=null;\n        }\n        \n        String pathInContext=URIUtil.addPaths(servletPath,pathInfo);\n        boolean endsWithSlash=pathInContext.endsWith(URIUtil.SLASH);\n        \n        // Can we gzip this request?\n        String pathInContextGz=null;\n        boolean gzip=false;\n        if (!included.booleanValue() && _gzip && reqRanges==null && !endsWithSlash )\n        {\n            String accept=request.getHeader(HttpHeaders.ACCEPT_ENCODING);\n            if (accept!=null && accept.indexOf(\"gzip\")>=0)\n                gzip=true;\n        }\n        \n        // Find the resource and content\n        Resource resource=null;\n        HttpContent content=null;\n        \n        Connector connector = HttpConnection.getCurrentConnection().getConnector();\n        ResourceCache cache=(connector instanceof NIOConnector) ?_nioCache:_bioCache;\n        try\n        {   \n            // Try gzipped content first\n            if (gzip)\n            {\n                pathInContextGz=pathInContext+\".gz\";  \n\n                if (cache==null)\n                {\n                    resource=getResource(pathInContextGz);\n                }\n                else\n                {\n                    content=cache.lookup(pathInContextGz,this);\n\n                    if (content!=null)\n                        resource=content.getResource();\n                    else\n                        resource=getResource(pathInContextGz);\n                }\n\n                if (resource==null || !resource.exists()|| resource.isDirectory())\n                {\n                    if (cache!=null && content==null)\n                    {\n                        String real_path=_servletContext.getRealPath(pathInContextGz);\n                        if (real_path!=null)\n                            cache.miss(pathInContextGz,_contextHandler.newResource(real_path));\n                    }\n                    gzip=false;\n                    pathInContextGz=null;\n                }\n            }\n        \n            // find resource\n            if (!gzip)\n            {\n                if (cache==null)\n                    resource=getResource(pathInContext);\n                else\n                {\n                    content=cache.lookup(pathInContext,this);\n\n                    if (content!=null)\n                        resource=content.getResource();\n                    else\n                        resource=getResource(pathInContext);\n                }\n            }\n            \n            if (Log.isDebugEnabled())\n                Log.debug(\"resource=\"+resource+(content!=null?\" content\":\"\"));\n                        \n            // Handle resource\n            if (resource==null || !resource.exists())\n                response.sendError(HttpServletResponse.SC_NOT_FOUND);\n            else if (!resource.isDirectory())\n            {   \n                if (endsWithSlash && _contextHandler.isAliases() && pathInContext.length()>1)\n                {\n                    String q=request.getQueryString();\n                    pathInContext=pathInContext.substring(0,pathInContext.length()-1);\n                    if (q!=null&&q.length()!=0)\n                        pathInContext+=\"?\"+q;\n                    response.sendRedirect(response.encodeRedirectURL(URIUtil.addPaths(_servletContext.getContextPath(),pathInContext)));\n                }\n\t\telse\n\t\t{\n\t\t    // ensure we have content\n\t\t    if (content==null)\n\t\t\tcontent=new UnCachedContent(resource);\n\t\t    \n\t\t    if (included.booleanValue() || passConditionalHeaders(request,response, resource,content))  \n\t\t    {\n\t\t\tif (gzip)\n\t\t\t{\n\t\t\t   response.setHeader(HttpHeaders.CONTENT_ENCODING,\"gzip\");\n\t\t\t   String mt=_servletContext.getMimeType(pathInContext);\n\t\t\t   if (mt!=null)\n\t\t\t       response.setContentType(mt);\n\t\t\t}\n\t\t\tsendData(request,response,included.booleanValue(),resource,content,reqRanges);  \n\t\t    }\n\t\t}\n            }\n            else\n            {\n                String welcome=null;\n                \n                if (!endsWithSlash || (pathInContext.length()==1 && request.getAttribute(\"org.eclipse.jetty.server.nullPathInfo\")!=null))\n                {\n                    StringBuffer buf=request.getRequestURL();\n                    synchronized(buf)\n                    {\n                        int param=buf.lastIndexOf(\";\");\n                        if (param<0)\n                            buf.append('/');\n                        else\n                            buf.insert(param,'/');\n                        String q=request.getQueryString();\n                        if (q!=null&&q.length()!=0)\n                        {\n                            buf.append('?');\n                            buf.append(q);\n                        }\n                        response.setContentLength(0);\n                        response.sendRedirect(response.encodeRedirectURL(buf.toString()));\n                    }\n                }\n                // else look for a welcome file\n                else if (null!=(welcome=getWelcomeFile(resource)))\n                {\n                    String ipath=URIUtil.addPaths(pathInContext,welcome);\n                    if (_redirectWelcome)\n                    {\n                        // Redirect to the index\n                        response.setContentLength(0);\n                        String q=request.getQueryString();\n                        if (q!=null&&q.length()!=0)\n                            response.sendRedirect(response.encodeRedirectURL(URIUtil.addPaths( _servletContext.getContextPath(),ipath)+\"?\"+q));\n                        else\n                            response.sendRedirect(response.encodeRedirectURL(URIUtil.addPaths( _servletContext.getContextPath(),ipath)));\n                    }\n                    else\n                    {\n                        // Forward to the index\n                        RequestDispatcher dispatcher=request.getRequestDispatcher(ipath);\n                        if (dispatcher!=null)\n                        {\n                            if (included.booleanValue())\n                                dispatcher.include(request,response);\n                            else\n                            {\n                                request.setAttribute(\"org.eclipse.jetty.server.welcome\",ipath);\n                                dispatcher.forward(request,response);\n                            }\n                        }\n                    }\n                }\n                else \n                {\n                    content=new UnCachedContent(resource);\n                    if (included.booleanValue() || passConditionalHeaders(request,response, resource,content))\n                        sendDirectory(request,response,resource,pathInContext.length()>1);\n                }\n            }\n        }\n        catch(IllegalArgumentException e)\n        {\n            Log.warn(Log.EXCEPTION,e);\n            if(!response.isCommitted())\n                response.sendError(500, e.getMessage());\n        }\n        finally\n        {\n            if (content!=null)\n                content.release();\n            else if (resource!=null)\n                resource.release();\n        }\n        \n    }","commit_id":"abf43385f3ea9faf5aa35c9ab1dae0c17a41d443","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void exec(File command, String pathInfo, HttpServletRequest req, HttpServletResponse res) throws IOException\n    {\n        String path=command.getAbsolutePath();\n        File dir=command.getParentFile();\n        String scriptName=req.getRequestURI().substring(0,req.getRequestURI().length()-pathInfo.length());\n        String scriptPath=getServletContext().getRealPath(scriptName);\n        String pathTranslated=req.getPathTranslated();\n\n        int len=req.getContentLength();\n        if (len<0)\n            len=0;\n        if ((pathTranslated==null)||(pathTranslated.length()==0))\n            pathTranslated=path;\n\n        EnvList env=new EnvList(_env);\n        // these ones are from \"The WWW Common Gateway Interface Version 1.1\"\n        // look at :\n        // http://Web.Golux.Com/coar/cgi/draft-coar-cgi-v11-03-clean.html#6.1.1\n        env.set(\"AUTH_TYPE\",req.getAuthType());\n        env.set(\"CONTENT_LENGTH\",Integer.toString(len));\n        env.set(\"CONTENT_TYPE\",req.getContentType());\n        env.set(\"GATEWAY_INTERFACE\",\"CGI/1.1\");\n        if ((pathInfo!=null)&&(pathInfo.length()>0))\n        {\n            env.set(\"PATH_INFO\",pathInfo);\n        }\n        env.set(\"PATH_TRANSLATED\",pathTranslated);\n        env.set(\"QUERY_STRING\",req.getQueryString());\n        env.set(\"REMOTE_ADDR\",req.getRemoteAddr());\n        env.set(\"REMOTE_HOST\",req.getRemoteHost());\n        // The identity information reported about the connection by a\n        // RFC 1413 [11] request to the remote agent, if\n        // available. Servers MAY choose not to support this feature, or\n        // not to request the data for efficiency reasons.\n        // \"REMOTE_IDENT\" => \"NYI\"\n        env.set(\"REMOTE_USER\",req.getRemoteUser());\n        env.set(\"REQUEST_METHOD\",req.getMethod());\n        env.set(\"SCRIPT_NAME\",scriptName);\n        env.set(\"SCRIPT_FILENAME\",scriptPath);\n        env.set(\"SERVER_NAME\",req.getServerName());\n        env.set(\"SERVER_PORT\",Integer.toString(req.getServerPort()));\n        env.set(\"SERVER_PROTOCOL\",req.getProtocol());\n        env.set(\"SERVER_SOFTWARE\",getServletContext().getServerInfo());\n\n        Enumeration enm=req.getHeaderNames();\n        while (enm.hasMoreElements())\n        {\n            String name=(String)enm.nextElement();\n            String value=req.getHeader(name);\n            env.set(\"HTTP_\"+name.toUpperCase().replace('-','_'),value);\n        }\n\n        // these extra ones were from printenv on www.dev.nomura.co.uk\n        env.set(\"HTTPS\",(req.isSecure()?\"ON\":\"OFF\"));\n        // \"DOCUMENT_ROOT\" => root + \"/docs\",\n        // \"SERVER_URL\" => \"NYI - http://us0245\",\n        // \"TZ\" => System.getProperty(\"user.timezone\"),\n\n        // are we meant to decode args here ? or does the script get them\n        // via PATH_INFO ? if we are, they should be decoded and passed\n        // into exec here...\n        String execCmd=path;\n        if ((execCmd.charAt(0)!='\"')&&(execCmd.indexOf(\" \")>=0))\n            execCmd=\"\\\"\"+execCmd+\"\\\"\";\n        if (_cmdPrefix!=null)\n            execCmd=_cmdPrefix+\" \"+execCmd;\n\n        Process p=(dir==null)?Runtime.getRuntime().exec(execCmd,env.getEnvArray()):Runtime.getRuntime().exec(execCmd,env.getEnvArray(),dir);\n\n        // hook processes input to browser's output (async)\n        final InputStream inFromReq=req.getInputStream();\n        final OutputStream outToCgi=p.getOutputStream();\n        final int inLength=len;\n\n        IO.copyThread(p.getErrorStream(),System.err);\n        \n        new Thread(new Runnable()\n        {\n            public void run()\n            {\n                try\n                {\n                    if (inLength>0)\n                        IO.copy(inFromReq,outToCgi,inLength);\n                    outToCgi.close();\n                }\n                catch (IOException e)\n                {\n                    Log.ignore(e);\n                }\n            }\n        }).start();\n\n        // hook processes output to browser's input (sync)\n        // if browser closes stream, we should detect it and kill process...\n        OutputStream os = null;\n        try\n        {\n            // read any headers off the top of our input stream\n            // NOTE: Multiline header items not supported!\n            String line=null;\n            InputStream inFromCgi=p.getInputStream();\n\n            //br=new BufferedReader(new InputStreamReader(inFromCgi));\n            //while ((line=br.readLine())!=null)\n            while( (line = getTextLineFromStream( inFromCgi )).length() > 0 )\n            {\n                if (!line.startsWith(\"HTTP\"))\n                {\n                    int k=line.indexOf(':');\n                    if (k>0)\n                    {\n                        String key=line.substring(0,k).trim();\n                        String value = line.substring(k+1).trim();\n                        if (\"Location\".equals(key))\n                        {\n                            res.sendRedirect(value);\n                        }\n                        else if (\"Status\".equals(key))\n                        {\n                        \tString[] token = value.split( \" \" );\n                            int status=Integer.parseInt(token[0]);\n                            res.setStatus(status);\n                        }\n                        else\n                        {\n                            // add remaining header items to our response header\n                            res.addHeader(key,value);\n                        }\n                    }\n                }\n            }\n            // copy cgi content to response stream...\n            os = res.getOutputStream();\n            IO.copy(inFromCgi, os);\n            p.waitFor();\n\n            if (!_ignoreExitState)\n            {\n                int exitValue=p.exitValue();\n                if (0!=exitValue)\n                {\n                    Log.warn(\"Non-zero exit status (\"+exitValue+\") from CGI program: \"+path);\n                    if (!res.isCommitted())\n                        res.sendError(500,\"Failed to exec CGI\");\n                }\n            }\n        }\n        catch (IOException e)\n        {\n            // browser has probably closed its input stream - we\n            // terminate and clean up...\n            Log.debug(\"CGI: Client closed connection!\");\n        }\n        catch (InterruptedException ie)\n        {\n            Log.debug(\"CGI: interrupted!\");\n        }\n        finally\n        {\n            if( os != null )\n            {\n                try\n                {\n                    os.close();\n                }\n                catch(Exception e)\n                {\n                    Log.ignore(e);\n                }\n            }\n            os = null;\n            p.destroy();\n            // Log.debug(\"CGI: terminated!\");\n        }\n    }","id":65074,"modified_method":"private void exec(File command, String pathInfo, HttpServletRequest req, HttpServletResponse res) throws IOException\n    {\n        String path=command.getAbsolutePath();\n        File dir=command.getParentFile();\n        String scriptName=req.getRequestURI().substring(0,req.getRequestURI().length()-pathInfo.length());\n        String scriptPath=getServletContext().getRealPath(scriptName);\n        String pathTranslated=req.getPathTranslated();\n\n        int len=req.getContentLength();\n        if (len<0)\n            len=0;\n        if ((pathTranslated==null)||(pathTranslated.length()==0))\n            pathTranslated=path;\n\n        EnvList env=new EnvList(_env);\n        // these ones are from \"The WWW Common Gateway Interface Version 1.1\"\n        // look at :\n        // http://Web.Golux.Com/coar/cgi/draft-coar-cgi-v11-03-clean.html#6.1.1\n        env.set(\"AUTH_TYPE\",req.getAuthType());\n        env.set(\"CONTENT_LENGTH\",Integer.toString(len));\n        env.set(\"CONTENT_TYPE\",req.getContentType());\n        env.set(\"GATEWAY_INTERFACE\",\"CGI/1.1\");\n        if ((pathInfo!=null)&&(pathInfo.length()>0))\n        {\n            env.set(\"PATH_INFO\",pathInfo);\n        }\n        env.set(\"PATH_TRANSLATED\",pathTranslated);\n        env.set(\"QUERY_STRING\",req.getQueryString());\n        env.set(\"REMOTE_ADDR\",req.getRemoteAddr());\n        env.set(\"REMOTE_HOST\",req.getRemoteHost());\n        // The identity information reported about the connection by a\n        // RFC 1413 [11] request to the remote agent, if\n        // available. Servers MAY choose not to support this feature, or\n        // not to request the data for efficiency reasons.\n        // \"REMOTE_IDENT\" => \"NYI\"\n        env.set(\"REMOTE_USER\",req.getRemoteUser());\n        env.set(\"REQUEST_METHOD\",req.getMethod());\n        env.set(\"SCRIPT_NAME\",scriptName);\n        env.set(\"SCRIPT_FILENAME\",scriptPath);\n        env.set(\"SERVER_NAME\",req.getServerName());\n        env.set(\"SERVER_PORT\",Integer.toString(req.getServerPort()));\n        env.set(\"SERVER_PROTOCOL\",req.getProtocol());\n        env.set(\"SERVER_SOFTWARE\",getServletContext().getServerInfo());\n\n        Enumeration enm=req.getHeaderNames();\n        while (enm.hasMoreElements())\n        {\n            String name=(String)enm.nextElement();\n            String value=req.getHeader(name);\n            env.set(\"HTTP_\"+name.toUpperCase().replace('-','_'),value);\n        }\n\n        // these extra ones were from printenv on www.dev.nomura.co.uk\n        env.set(\"HTTPS\",(req.isSecure()?\"ON\":\"OFF\"));\n        // \"DOCUMENT_ROOT\" => root + \"/docs\",\n        // \"SERVER_URL\" => \"NYI - http://us0245\",\n        // \"TZ\" => System.getProperty(\"user.timezone\"),\n\n        // are we meant to decode args here ? or does the script get them\n        // via PATH_INFO ? if we are, they should be decoded and passed\n        // into exec here...\n        String execCmd=path;\n        if ((execCmd.charAt(0)!='\"')&&(execCmd.indexOf(\" \")>=0))\n            execCmd=\"\\\"\"+execCmd+\"\\\"\";\n        if (_cmdPrefix!=null)\n            execCmd=_cmdPrefix+\" \"+execCmd;\n\n        Process p=(dir==null)?Runtime.getRuntime().exec(execCmd,env.getEnvArray()):Runtime.getRuntime().exec(execCmd,env.getEnvArray(),dir);\n\n        // hook processes input to browser's output (async)\n        final InputStream inFromReq=req.getInputStream();\n        final OutputStream outToCgi=p.getOutputStream();\n        final int inLength=len;\n\n        IO.copyThread(p.getErrorStream(),System.err);\n        \n        new Thread(new Runnable()\n        {\n            public void run()\n            {\n                try\n                {\n                    if (inLength>0)\n                        IO.copy(inFromReq,outToCgi,inLength);\n                    outToCgi.close();\n                }\n                catch (IOException e)\n                {\n                    Log.ignore(e);\n                }\n            }\n        }).start();\n\n        // hook processes output to browser's input (sync)\n        // if browser closes stream, we should detect it and kill process...\n        OutputStream os = null;\n        try\n        {\n            // read any headers off the top of our input stream\n            // NOTE: Multiline header items not supported!\n            String line=null;\n            InputStream inFromCgi=p.getInputStream();\n\n            //br=new BufferedReader(new InputStreamReader(inFromCgi));\n            //while ((line=br.readLine())!=null)\n            while( (line = getTextLineFromStream( inFromCgi )).length() > 0 )\n            {\n                if (!line.startsWith(\"HTTP\"))\n                {\n                    int k=line.indexOf(':');\n                    if (k>0)\n                    {\n                        String key=line.substring(0,k).trim();\n                        String value = line.substring(k+1).trim();\n                        if (\"Location\".equals(key))\n                        {\n                            res.sendRedirect(res.encodeRedirectURL(value));\n                        }\n                        else if (\"Status\".equals(key))\n                        {\n                        \tString[] token = value.split( \" \" );\n                            int status=Integer.parseInt(token[0]);\n                            res.setStatus(status);\n                        }\n                        else\n                        {\n                            // add remaining header items to our response header\n                            res.addHeader(key,value);\n                        }\n                    }\n                }\n            }\n            // copy cgi content to response stream...\n            os = res.getOutputStream();\n            IO.copy(inFromCgi, os);\n            p.waitFor();\n\n            if (!_ignoreExitState)\n            {\n                int exitValue=p.exitValue();\n                if (0!=exitValue)\n                {\n                    Log.warn(\"Non-zero exit status (\"+exitValue+\") from CGI program: \"+path);\n                    if (!res.isCommitted())\n                        res.sendError(500,\"Failed to exec CGI\");\n                }\n            }\n        }\n        catch (IOException e)\n        {\n            // browser has probably closed its input stream - we\n            // terminate and clean up...\n            Log.debug(\"CGI: Client closed connection!\");\n        }\n        catch (InterruptedException ie)\n        {\n            Log.debug(\"CGI: interrupted!\");\n        }\n        finally\n        {\n            if( os != null )\n            {\n                try\n                {\n                    os.close();\n                }\n                catch(Exception e)\n                {\n                    Log.ignore(e);\n                }\n            }\n            os = null;\n            p.destroy();\n            // Log.debug(\"CGI: terminated!\");\n        }\n    }","commit_id":"aea99b14aaff9a41337fab4427170814a53d85dd","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void testFormRedirect()\n            throws Exception\n    {\n        _security.setAuthenticator(new FormAuthenticator(\"/testLoginPage\",\"/testErrorPage\",false));\n        _security.setStrict(false);\n        _server.start();\n\n        String response;\n\n        response = _connector.getResponses(\"GET /ctx/noauth/info HTTP/1.0\\r\\n\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 200 OK\"));\n\n        response = _connector.getResponses(\"GET /ctx/forbid/info HTTP/1.0\\r\\n\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 403 Forbidden\"));\n\n        response = _connector.getResponses(\"GET /ctx/auth/info HTTP/1.0\\r\\n\\r\\n\");\n        assertTrue(response.indexOf(\" 302 Found\") > 0);\n        assertTrue(response.indexOf(\"/ctx/testLoginPage\") > 0);\n        String session = response.substring(response.indexOf(\"JSESSIONID=\") + 11, response.indexOf(\";Path=/ctx\"));\n\n        response = _connector.getResponses(\"GET /ctx/testLoginPage HTTP/1.0\\r\\n\"+\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"\\r\\n\");\n        System.err.println(response);\n        assertTrue(response.indexOf(\" 200 OK\") > 0);\n        assertTrue(response.indexOf(\"URI=/ctx/testLoginPage\") > 0);\n        \n        response = _connector.getResponses(\"POST /ctx/j_security_check HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"Content-Type: application/x-www-form-urlencoded\\r\\n\" +\n                \"Content-Length: 31\\r\\n\" +\n                \"\\r\\n\" +\n        \"j_username=user&j_password=wrong\\r\\n\");\n        assertTrue(response.indexOf(\"Location\") > 0);\n\n        response = _connector.getResponses(\"POST /ctx/j_security_check HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"Content-Type: application/x-www-form-urlencoded\\r\\n\" +\n                \"Content-Length: 35\\r\\n\" +\n                \"\\r\\n\" +\n                \"j_username=user&j_password=password\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 302 \"));\n        assertTrue(response.indexOf(\"Location\") > 0);\n        assertTrue(response.indexOf(\"/ctx/auth/info\") > 0);\n\n        response = _connector.getResponses(\"GET /ctx/auth/info HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 200 OK\"));\n\n        response = _connector.getResponses(\"GET /ctx/admin/info HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 403\"));\n        assertTrue(response.indexOf(\"!role\") > 0);\n    }","id":65075,"modified_method":"public void testFormRedirect()\n            throws Exception\n    {\n        _security.setAuthenticator(new FormAuthenticator(\"/testLoginPage\",\"/testErrorPage\",false));\n        _security.setStrict(false);\n        _server.start();\n\n        String response;\n\n        response = _connector.getResponses(\"GET /ctx/noauth/info HTTP/1.0\\r\\n\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 200 OK\"));\n\n        response = _connector.getResponses(\"GET /ctx/forbid/info HTTP/1.0\\r\\n\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 403 Forbidden\"));\n\n        response = _connector.getResponses(\"GET /ctx/auth/info HTTP/1.0\\r\\n\\r\\n\");\n        assertTrue(response.indexOf(\" 302 Found\") > 0);\n        assertTrue(response.indexOf(\"/ctx/testLoginPage\") > 0);\n        String session = response.substring(response.indexOf(\"JSESSIONID=\") + 11, response.indexOf(\";Path=/ctx\"));\n\n        response = _connector.getResponses(\"GET /ctx/testLoginPage HTTP/1.0\\r\\n\"+\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"\\r\\n\");\n        assertTrue(response.indexOf(\" 200 OK\") > 0);\n        assertTrue(response.indexOf(\"URI=/ctx/testLoginPage\") > 0);\n        \n        response = _connector.getResponses(\"POST /ctx/j_security_check HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"Content-Type: application/x-www-form-urlencoded\\r\\n\" +\n                \"Content-Length: 31\\r\\n\" +\n                \"\\r\\n\" +\n        \"j_username=user&j_password=wrong\\r\\n\");\n        assertTrue(response.indexOf(\"Location\") > 0);\n\n        response = _connector.getResponses(\"POST /ctx/j_security_check HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"Content-Type: application/x-www-form-urlencoded\\r\\n\" +\n                \"Content-Length: 35\\r\\n\" +\n                \"\\r\\n\" +\n                \"j_username=user&j_password=password\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 302 \"));\n        assertTrue(response.indexOf(\"Location\") > 0);\n        assertTrue(response.indexOf(\"/ctx/auth/info\") > 0);\n\n        response = _connector.getResponses(\"GET /ctx/auth/info HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 200 OK\"));\n\n        response = _connector.getResponses(\"GET /ctx/admin/info HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 403\"));\n        assertTrue(response.indexOf(\"!role\") > 0);\n    }","commit_id":"aea99b14aaff9a41337fab4427170814a53d85dd","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void doGet(final HttpServletRequest request, final HttpServletResponse response) throws ServletException, IOException\n    {\n        if(request.getPathInfo()!=null && request.getPathInfo().toLowerCase().indexOf(\"script\")!=-1)\n        {\n            response.sendRedirect(getServletContext().getContextPath() + \"/dump/info\");\n            return;\n        }\n            \n        request.setCharacterEncoding(\"UTF-8\");\n        \n        if (request.getParameter(\"empty\")!=null)\n        {\n            response.setStatus(200);\n            response.flushBuffer();\n            return;\n        }\n        \n        if (request.getParameter(\"sleep\")!=null)\n        {\n            try\n            {\n                long s = Long.parseLong(request.getParameter(\"sleep\"));\n                if (request.getHeader(HttpHeaders.EXPECT)!=null &&request.getHeader(HttpHeaders.EXPECT).indexOf(\"102\")>=0)\n                {\n                    Thread.sleep(s/2);\n                    response.sendError(102);\n                    Thread.sleep(s/2);\n                }\n                else\n                    Thread.sleep(s);\n            }\n            catch (InterruptedException e)\n            {\n                return;\n            }\n            catch (Exception e)\n            {\n                throw new ServletException(e);\n            }\n        }\n\n        if (request.getAttribute(\"RESUME\")==null && request.getParameter(\"resume\")!=null)\n        {\n            request.setAttribute(\"RESUME\",Boolean.TRUE);\n\n            final long resume=Long.parseLong(request.getParameter(\"resume\"));\n            new Thread(new Runnable()\n            {\n                public void run()\n                {\n                    try\n                    {\n                        Thread.sleep(resume);\n                    }\n                    catch (InterruptedException e)\n                    {\n                        e.printStackTrace();\n                    }\n                    Continuation continuation = ContinuationSupport.getContinuation(request);\n                    continuation.resume();\n                }\n                \n            }).start();\n        }\n\n        if (request.getParameter(\"complete\")!=null)\n        {\n            final long complete=Long.parseLong(request.getParameter(\"complete\"));\n            new Thread(new Runnable()\n            {\n                public void run()\n                {\n                    try\n                    {\n                        Thread.sleep(complete);\n                    }\n                    catch (InterruptedException e)\n                    {\n                        e.printStackTrace();\n                    }\n                    try\n                    {\n                        response.setContentType(\"text/html\");\n                        response.getOutputStream().println(\"<h1>COMPLETED<\/h1>\"); \n                        Continuation continuation = ContinuationSupport.getContinuation(request,response);\n                        continuation.complete();\n                    }\n                    catch (IOException e)\n                    {\n                        e.printStackTrace();\n                    }\n                }\n\n            }).start();\n        }\n        \n        if (request.getParameter(\"suspend\")!=null && request.getAttribute(\"SUSPEND\")!=Boolean.TRUE)\n        {\n            request.setAttribute(\"SUSPEND\",Boolean.TRUE);\n            try\n            {\n                Continuation continuation = ContinuationSupport.getContinuation(request);\n                continuation.setTimeout(Long.parseLong(request.getParameter(\"suspend\")));\n                continuation.suspend();\n                continuation.undispatch();\n            }\n            catch(Exception e)\n            {\n                throw new ServletException(e);\n            }\n        }        \n            \n        request.setAttribute(\"Dump\", this);\n        getServletContext().setAttribute(\"Dump\",this);\n        // getServletContext().log(\"dump \"+request.getRequestURI());\n\n        // Force a content length response\n        String length= request.getParameter(\"length\");\n        if (length != null && length.length() > 0)\n        {\n            response.setContentLength(Integer.parseInt(length));\n        }\n\n        // Handle a dump of data\n        String data= request.getParameter(\"data\");\n        String block= request.getParameter(\"block\");\n        String dribble= request.getParameter(\"dribble\");\n        boolean flush= request.getParameter(\"flush\")!=null?Boolean.parseBoolean(request.getParameter(\"flush\")):false;\n        if (data != null && data.length() > 0)\n        {\n            long d=Long.parseLong(data);\n            int b=(block!=null&&block.length()>0)?Integer.parseInt(block):50;\n            byte[] buf=new byte[b];\n            for (int i=0;i<b;i++)\n            {\n                \n                buf[i]=(byte)('0'+(i%10));\n                if (i%10==9)\n                    buf[i]=(byte)'\\n';\n            }\n            buf[0]='o';\n            OutputStream out=response.getOutputStream();\n            response.setContentType(\"text/plain\");\n            while (d > 0)\n            {\n                if (b==1)\n                {\n                    out.write(d%80==0?'\\n':'.');\n                    d--;\n                }\n                else if (d>=b)\n                {\n                    out.write(buf);\n                    d=d-b;\n                }\n                else\n                {\n                    out.write(buf,0,(int)d);\n                    d=0;\n                }\n                \n                if (dribble!=null)\n                {\n                    out.flush();\n                    try\n                    {\n                        Thread.sleep(Long.parseLong(dribble));\n                    }\n                    catch (Exception e)\n                    {\n                        e.printStackTrace();\n                        break;\n                    }\n                }\n                \n            }\n            \n            if (flush)\n                out.flush();\n            \n            return;\n        }\n\n        // Handle a dump of data\n        String chars= request.getParameter(\"chars\");\n        if (chars != null && chars.length() > 0)\n        {\n            long d=Long.parseLong(chars);\n            int b=(block!=null&&block.length()>0)?Integer.parseInt(block):50;\n            char[] buf=new char[b];\n            for (int i=0;i<b;i++)\n            {\n                buf[i]=(char)('0'+(i%10));\n                if (i%10==9)\n                    buf[i]='\\n';\n            }\n            buf[0]='o';\n            response.setContentType(\"text/plain\");\n            PrintWriter out=response.getWriter();\n            while (d > 0 && !out.checkError())\n            {\n                if (b==1)\n                {\n                    out.write(d%80==0?'\\n':'.');\n                    d--;\n                }\n                else if (d>=b)\n                {\n                    out.write(buf);\n                    d=d-b;\n                }\n                else\n                {\n                    out.write(buf,0,(int)d);\n                    d=0;\n                }\n            }\n            return;\n        }\n\n        \n        \n        // handle an exception\n        String info= request.getPathInfo();\n        if (info != null && info.endsWith(\"Exception\"))\n        {\n            try\n            {\n                throw (Throwable) Thread.currentThread().getContextClassLoader().loadClass(info.substring(1)).newInstance();\n            }\n            catch (Throwable th)\n            {\n                throw new ServletException(th);\n            }\n        }\n\n        // test a reset\n        String reset= request.getParameter(\"reset\");\n        if (reset != null && reset.length() > 0)\n        {\n            response.getOutputStream().println(\"THIS SHOULD NOT BE SEEN!\");\n            response.setHeader(\"SHOULD_NOT\",\"BE SEEN\");\n            response.reset();\n        }\n        \n        \n        // handle an redirect\n        String redirect= request.getParameter(\"redirect\");\n        if (redirect != null && redirect.length() > 0)\n        {\n            response.getOutputStream().println(\"THIS SHOULD NOT BE SEEN!\");\n            response.sendRedirect(redirect);\n            try\n            {\n                response.getOutputStream().println(\"THIS SHOULD NOT BE SEEN!\");\n            }\n            catch(IOException e)\n            {\n                // ignored as stream is closed.\n            }\n            return;\n        }\n\n        // handle an error\n        String error= request.getParameter(\"error\");\n        if (error != null && error.length() > 0 && request.getAttribute(\"javax.servlet.error.status_code\")==null)\n        {\n            response.getOutputStream().println(\"THIS SHOULD NOT BE SEEN!\");\n            response.sendError(Integer.parseInt(error));\n            try\n            {\n                response.getOutputStream().println(\"THIS SHOULD NOT BE SEEN!\");\n            }\n            catch(IllegalStateException e)\n            {\n                try\n                {\n                    response.getWriter().println(\"NOR THIS!!\"); \n                }\n                catch(IOException e2){}\n            }\n            catch(IOException e){}\n            return;\n        }\n\n        // Handle a extra headers \n        String headers= request.getParameter(\"headers\");\n        if (headers != null && headers.length() > 0)\n        {\n            long h=Long.parseLong(headers);\n            for (int i=0;i<h;i++)\n                response.addHeader(\"Header\"+i,\"Value\"+i);\n        }\n\n        String buffer= request.getParameter(\"buffer\");\n        if (buffer != null && buffer.length() > 0)\n            response.setBufferSize(Integer.parseInt(buffer));\n\n        String charset= request.getParameter(\"charset\");\n        if (charset==null)\n            charset=\"UTF-8\";\n        response.setCharacterEncoding(charset);\n        response.setContentType(\"text/html\");\n\n        if (info != null && info.indexOf(\"Locale/\") >= 0)\n        {\n            try\n            {\n                String locale_name= info.substring(info.indexOf(\"Locale/\") + 7);\n                Field f= java.util.Locale.class.getField(locale_name);\n                response.setLocale((Locale)f.get(null));\n            }\n            catch (Exception e)\n            {\n                e.printStackTrace();\n                response.setLocale(Locale.getDefault());\n            }\n        }\n\n        String cn= request.getParameter(\"cookie\");\n        String cv=request.getParameter(\"cookiev\");\n        if (cn!=null && cv!=null)\n        {\n            Cookie cookie= new Cookie(cn, cv);\n            if (request.getParameter(\"version\")!=null)\n                cookie.setVersion(Integer.parseInt(request.getParameter(\"version\")));\n            cookie.setComment(\"Cookie from dump servlet\");\n            response.addCookie(cookie);\n        }\n\n        String pi= request.getPathInfo();\n        if (pi != null && pi.startsWith(\"/ex\"))\n        {\n            OutputStream out= response.getOutputStream();\n            out.write(\"<\/H1>This text should be reset<\/H1>\".getBytes());\n            if (\"/ex0\".equals(pi))\n                throw new ServletException(\"test ex0\", new Throwable());\n            else if (\"/ex1\".equals(pi))\n                throw new IOException(\"test ex1\");\n            else if (\"/ex2\".equals(pi))\n                throw new UnavailableException(\"test ex2\");\n            else if (pi.startsWith(\"/ex3/\"))\n                throw new UnavailableException(\"test ex3\",Integer.parseInt(pi.substring(5)));\n            throw new RuntimeException(\"test\");\n        }\n\n        if (\"true\".equals(request.getParameter(\"close\")))\n            response.setHeader(\"Connection\",\"close\");\n\n        String buffered= request.getParameter(\"buffered\");\n        \n        PrintWriter pout=null;\n        \n        try\n        {\n            pout =response.getWriter();\n        }\n        catch(IllegalStateException e)\n        {\n            pout=new PrintWriter(new OutputStreamWriter(response.getOutputStream(),charset));\n        }\n        if (buffered!=null)\n            pout = new PrintWriter(new BufferedWriter(pout,Integer.parseInt(buffered)));\n        \n        try\n        {\n            pout.write(\"<html>\\n<body>\\n\");\n            pout.write(\"<h1>Dump Servlet<\/h1>\\n\");\n            pout.write(\"<table width=\\\"95%\\\">\");\n            pout.write(\"<tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getMethod:&nbsp;<\/th>\");\n            pout.write(\"<td>\" + notag(request.getMethod())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getContentLength:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+Integer.toString(request.getContentLength())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getContentType:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+notag(request.getContentType())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getRequestURI:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+notag(request.getRequestURI())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getRequestURL:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+notag(request.getRequestURL().toString())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getContextPath:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getContextPath()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getServletPath:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+notag(request.getServletPath())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getPathInfo:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+notag(request.getPathInfo())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getPathTranslated:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+notag(request.getPathTranslated())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getQueryString:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+notag(request.getQueryString())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            \n            pout.write(\"<th align=\\\"right\\\">getProtocol:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getProtocol()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getScheme:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getScheme()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getServerName:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+notag(request.getServerName())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getServerPort:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+Integer.toString(request.getServerPort())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getLocalName:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getLocalName()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getLocalAddr:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getLocalAddr()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getLocalPort:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+Integer.toString(request.getLocalPort())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getRemoteUser:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getRemoteUser()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getRemoteAddr:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getRemoteAddr()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getRemoteHost:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getRemoteHost()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getRemotePort:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getRemotePort()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getRequestedSessionId:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getRequestedSessionId()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">isSecure():&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.isSecure()+\"<\/td>\");\n\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">isUserInRole(admin):&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.isUserInRole(\"admin\")+\"<\/td>\");\n\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getLocale:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getLocale()+\"<\/td>\");\n            \n            Enumeration locales= request.getLocales();\n            while (locales.hasMoreElements())\n            {\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">getLocales:&nbsp;<\/th>\");\n                pout.write(\"<td>\"+locales.nextElement()+\"<\/td>\");\n            }\n            pout.write(\"<\/tr><tr>\\n\");\n            \n            pout.write(\"<th align=\\\"left\\\" colspan=\\\"2\\\"><big><br/>Other HTTP Headers:<\/big><\/th>\");\n            Enumeration h= request.getHeaderNames();\n            String name;\n            while (h.hasMoreElements())\n            {\n                name= (String)h.nextElement();\n\n                Enumeration h2= request.getHeaders(name);\n                while (h2.hasMoreElements())\n                {\n                    String hv= (String)h2.nextElement();\n                    pout.write(\"<\/tr><tr>\\n\");\n                    pout.write(\"<th align=\\\"right\\\">\"+notag(name)+\":&nbsp;<\/th>\");\n                    pout.write(\"<td>\"+notag(hv)+\"<\/td>\");\n                }\n            }\n\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"left\\\" colspan=\\\"2\\\"><big><br/>Request Parameters:<\/big><\/th>\");\n            h= request.getParameterNames();\n            while (h.hasMoreElements())\n            {\n                name= (String)h.nextElement();\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">\"+notag(name)+\":&nbsp;<\/th>\");\n                pout.write(\"<td>\"+notag(request.getParameter(name))+\"<\/td>\");\n                String[] values= request.getParameterValues(name);\n                if (values == null)\n                {\n                    pout.write(\"<\/tr><tr>\\n\");\n                    pout.write(\"<th align=\\\"right\\\">\"+notag(name)+\" Values:&nbsp;<\/th>\");\n                    pout.write(\"<td>\"+\"NULL!\"+\"<\/td>\");\n                }\n                else if (values.length > 1)\n                {\n                    for (int i= 0; i < values.length; i++)\n                    {\n                        pout.write(\"<\/tr><tr>\\n\");\n                        pout.write(\"<th align=\\\"right\\\">\"+notag(name)+\"[\"+i+\"]:&nbsp;<\/th>\");\n                        pout.write(\"<td>\"+notag(values[i])+\"<\/td>\");\n                    }\n                }\n            }\n\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"left\\\" colspan=\\\"2\\\"><big><br/>Cookies:<\/big><\/th>\");\n            Cookie[] cookies = request.getCookies();\n            for (int i=0; cookies!=null && i<cookies.length;i++)\n            {\n                Cookie cookie = cookies[i];\n\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">\"+notag(cookie.getName())+\":&nbsp;<\/th>\");\n                pout.write(\"<td>\"+notag(cookie.getValue())+\"<\/td>\");\n            }\n            \n            String content_type=request.getContentType();\n            if (content_type!=null &&\n                !content_type.startsWith(\"application/x-www-form-urlencoded\") &&\n                !content_type.startsWith(\"multipart/form-data\"))\n            {\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"left\\\" valign=\\\"top\\\" colspan=\\\"2\\\"><big><br/>Content:<\/big><\/th>\");\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<td><pre>\");\n                char[] content= new char[4096];\n                int len;\n                try{\n                    Reader in=request.getReader();\n                    \n                    while((len=in.read(content))>=0)\n                        pout.write(notag(new String(content,0,len)));\n                }\n                catch(IOException e)\n                {\n                    pout.write(e.toString());\n                }\n                \n                pout.write(\"<\/pre><\/td>\");\n            }\n            \n            \n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"left\\\" colspan=\\\"2\\\"><big><br/>Request Attributes:<\/big><\/th>\");\n            Enumeration a= request.getAttributeNames();\n            while (a.hasMoreElements())\n            {\n                name= (String)a.nextElement();\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\" valign=\\\"top\\\">\"+name.replace(\".\",\" .\")+\":&nbsp;<\/th>\");\n                pout.write(\"<td>\"+\"<pre>\" + toString(request.getAttribute(name)) + \"<\/pre>\"+\"<\/td>\");\n            }            \n\n            \n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"left\\\" colspan=\\\"2\\\"><big><br/>Servlet InitParameters:<\/big><\/th>\");\n            a= getInitParameterNames();\n            while (a.hasMoreElements())\n            {\n                name= (String)a.nextElement();\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">\"+name+\":&nbsp;<\/th>\");\n                pout.write(\"<td>\"+ toString(getInitParameter(name)) +\"<\/td>\");\n            }\n\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"left\\\" colspan=\\\"2\\\"><big><br/>Context InitParameters:<\/big><\/th>\");\n            a= getServletContext().getInitParameterNames();\n            while (a.hasMoreElements())\n            {\n                name= (String)a.nextElement();\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\" valign=\\\"top\\\">\"+name.replace(\".\",\" .\")+\":&nbsp;<\/th>\");\n                pout.write(\"<td>\"+ toString(getServletContext().getInitParameter(name)) + \"<\/td>\");\n            }\n\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"left\\\" colspan=\\\"2\\\"><big><br/>Context Attributes:<\/big><\/th>\");\n            a= getServletContext().getAttributeNames();\n            while (a.hasMoreElements())\n            {\n                name= (String)a.nextElement();\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\" valign=\\\"top\\\">\"+name.replace(\".\",\" .\")+\":&nbsp;<\/th>\");\n                pout.write(\"<td>\"+\"<pre>\" + toString(getServletContext().getAttribute(name)) + \"<\/pre>\"+\"<\/td>\");\n            }\n\n\n            String res= request.getParameter(\"resource\");\n            if (res != null && res.length() > 0)\n            {\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"left\\\" colspan=\\\"2\\\"><big><br/>Get Resource: \\\"\"+res+\"\\\"<\/big><\/th>\");\n                \n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">this.getClass().getResource(...):&nbsp;<\/th>\");\n                pout.write(\"<td>\"+this.getClass().getResource(res)+\"<\/td>\");\n\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">this.getClass().getClassLoader().getResource(...):&nbsp;<\/th>\");\n                pout.write(\"<td>\"+this.getClass().getClassLoader().getResource(res)+\"<\/td>\");\n\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">Thread.currentThread().getContextClassLoader().getResource(...):&nbsp;<\/th>\");\n                pout.write(\"<td>\"+Thread.currentThread().getContextClassLoader().getResource(res)+\"<\/td>\");\n\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">getServletContext().getResource(...):&nbsp;<\/th>\");\n                try{pout.write(\"<td>\"+getServletContext().getResource(res)+\"<\/td>\");}\n                catch(Exception e) {pout.write(\"<td>\"+\"\" +e+\"<\/td>\");}\n            }\n            \n            pout.write(\"<\/tr><\/table>\\n\");\n\n            /* ------------------------------------------------------------ */\n            pout.write(\"<h2>Request Wrappers<\/h2>\\n\");\n            ServletRequest rw=request;\n            int w=0;\n            while (rw !=null)\n            {\n                pout.write((w++)+\": \"+rw.getClass().getName()+\"<br/>\");\n                if (rw instanceof HttpServletRequestWrapper)\n                    rw=((HttpServletRequestWrapper)rw).getRequest();\n                else if (rw instanceof ServletRequestWrapper)\n                    rw=((ServletRequestWrapper)rw).getRequest();\n                else\n                    rw=null;\n            }\n\n            /* ------------------------------------------------------------ */\n            pout.write(\"<h2>Response Wrappers<\/h2>\\n\");\n            ServletResponse rsw=response;\n            w=0;\n            while (rsw !=null)\n            {\n                pout.write((w++)+\": \"+rsw.getClass().getName()+\"<br/>\");\n                if (rsw instanceof HttpServletResponseWrapper)\n                    rsw=((HttpServletResponseWrapper)rsw).getResponse();\n                else if (rsw instanceof ServletResponseWrapper)\n                    rsw=((ServletResponseWrapper)rsw).getResponse();\n                else\n                    rsw=null;\n            }\n            \n            pout.write(\"<br/>\");\n            pout.write(\"<h2>International Characters (UTF-8)<\/h2>\");\n            pout.write(\"LATIN LETTER SMALL CAPITAL AE<br/>\\n\");\n            pout.write(\"Directly uni encoded(\\\\u1d01): \\u1d01<br/>\");\n            pout.write(\"HTML reference (&amp;AElig;): &AElig;<br/>\");\n            pout.write(\"Decimal (&amp;#7425;): &#7425;<br/>\");\n            pout.write(\"Javascript unicode (\\\\u1d01) : <script language='javascript'>document.write(\\\"\\u1d01\\\");<\/script><br/>\");\n            pout.write(\"<br/>\");\n            pout.write(\"<h2>Form to generate GET content<\/h2>\");\n            pout.write(\"<form method=\\\"GET\\\" action=\\\"\"+response.encodeURL(getURI(request))+\"\\\">\");\n            pout.write(\"TextField: <input type=\\\"text\\\" name=\\\"TextField\\\" value=\\\"value\\\"/><br/>\\n\");\n            pout.write(\"<input type=\\\"submit\\\" name=\\\"Action\\\" value=\\\"Submit\\\">\");\n            pout.write(\"<\/form>\");\n\n            pout.write(\"<br/>\");\n            \n            pout.write(\"<h2>Form to generate POST content<\/h2>\");\n            pout.write(\"<form method=\\\"POST\\\" accept-charset=\\\"utf-8\\\" action=\\\"\"+response.encodeURL(getURI(request))+\"\\\">\");\n            pout.write(\"TextField: <input type=\\\"text\\\" name=\\\"TextField\\\" value=\\\"value\\\"/><br/>\\n\");\n            pout.write(\"Select: <select multiple name=\\\"Select\\\">\\n\");\n            pout.write(\"<option>ValueA<\/option>\");\n            pout.write(\"<option>ValueB1,ValueB2<\/option>\");\n            pout.write(\"<option>ValueC<\/option>\");\n            pout.write(\"<\/select><br/>\");\n            pout.write(\"<input type=\\\"submit\\\" name=\\\"Action\\\" value=\\\"Submit\\\"><br/>\");\n            pout.write(\"<\/form>\");\n            pout.write(\"<br/>\");\n            \n            pout.write(\"<h2>Form to generate UPLOAD content<\/h2>\");\n            pout.write(\"<form method=\\\"POST\\\" enctype=\\\"multipart/form-data\\\" accept-charset=\\\"utf-8\\\" action=\\\"\"+\n                    response.encodeURL(getURI(request))+(request.getQueryString()==null?\"\":(\"?\"+request.getQueryString()))+\n                    \"\\\">\");\n            pout.write(\"TextField: <input type=\\\"text\\\" name=\\\"TextField\\\" value=\\\"comment\\\"/><br/>\\n\");\n            pout.write(\"File 1: <input type=\\\"file\\\" name=\\\"file1\\\" /><br/>\\n\");\n            pout.write(\"File 2: <input type=\\\"file\\\" name=\\\"file2\\\" /><br/>\\n\");\n            pout.write(\"<input type=\\\"submit\\\" name=\\\"Action\\\" value=\\\"Submit\\\"><br/>\");\n            pout.write(\"<\/form>\");\n\n            pout.write(\"<h2>Form to set Cookie<\/h2>\");\n            pout.write(\"<form method=\\\"POST\\\" action=\\\"\"+response.encodeURL(getURI(request))+\"\\\">\");\n            pout.write(\"cookie: <input type=\\\"text\\\" name=\\\"cookie\\\" /><br/>\\n\");\n            pout.write(\"value: <input type=\\\"text\\\" name=\\\"cookiev\\\" /><br/>\\n\");\n            pout.write(\"<input type=\\\"submit\\\" name=\\\"Action\\\" value=\\\"setCookie\\\">\");\n            pout.write(\"<\/form>\\n\");\n            \n            pout.write(\"<h2>Form to get Resource<\/h2>\");\n            pout.write(\"<form method=\\\"POST\\\" action=\\\"\"+response.encodeURL(getURI(request))+\"\\\">\");\n            pout.write(\"resource: <input type=\\\"text\\\" name=\\\"resource\\\" /><br/>\\n\");\n            pout.write(\"<input type=\\\"submit\\\" name=\\\"Action\\\" value=\\\"getResource\\\">\");\n            pout.write(\"<\/form>\\n\");\n        }\n        catch (Exception e)\n        {\n            getServletContext().log(\"dump\", e);\n        }\n        \n        String lines= request.getParameter(\"lines\");\n        if (lines!=null)\n        {\n            char[] line = \"<span>A line of characters. Blah blah blah blah.  blooble blooble<\/span><\/br>\\n\".toCharArray();\n            for (int l=Integer.parseInt(lines);l-->0;)\n            {\n                pout.write(\"<span>\"+l+\" <\/span>\");\n                pout.write(line);\n            }\n        }\n        \n        pout.write(\"<\/body>\\n<\/html>\\n\");\n        \n        pout.close();\n\n        if (pi != null)\n        {\n            if (\"/ex4\".equals(pi))\n                throw new ServletException(\"test ex4\", new Throwable());\n            if (\"/ex5\".equals(pi))\n                throw new IOException(\"test ex5\");\n            if (\"/ex6\".equals(pi))\n                throw new UnavailableException(\"test ex6\");\n        }\n\n\n    }","id":65076,"modified_method":"@Override\n    public void doGet(final HttpServletRequest request, final HttpServletResponse response) throws ServletException, IOException\n    {\n        if(request.getPathInfo()!=null && request.getPathInfo().toLowerCase().indexOf(\"script\")!=-1)\n        {\n            response.sendRedirect(response.encodeRedirectURL(getServletContext().getContextPath() + \"/dump/info\"));\n            return;\n        }\n            \n        request.setCharacterEncoding(\"UTF-8\");\n        \n        if (request.getParameter(\"empty\")!=null)\n        {\n            response.setStatus(200);\n            response.flushBuffer();\n            return;\n        }\n        \n        if (request.getParameter(\"sleep\")!=null)\n        {\n            try\n            {\n                long s = Long.parseLong(request.getParameter(\"sleep\"));\n                if (request.getHeader(HttpHeaders.EXPECT)!=null &&request.getHeader(HttpHeaders.EXPECT).indexOf(\"102\")>=0)\n                {\n                    Thread.sleep(s/2);\n                    response.sendError(102);\n                    Thread.sleep(s/2);\n                }\n                else\n                    Thread.sleep(s);\n            }\n            catch (InterruptedException e)\n            {\n                return;\n            }\n            catch (Exception e)\n            {\n                throw new ServletException(e);\n            }\n        }\n\n        if (request.getAttribute(\"RESUME\")==null && request.getParameter(\"resume\")!=null)\n        {\n            request.setAttribute(\"RESUME\",Boolean.TRUE);\n\n            final long resume=Long.parseLong(request.getParameter(\"resume\"));\n            new Thread(new Runnable()\n            {\n                public void run()\n                {\n                    try\n                    {\n                        Thread.sleep(resume);\n                    }\n                    catch (InterruptedException e)\n                    {\n                        e.printStackTrace();\n                    }\n                    Continuation continuation = ContinuationSupport.getContinuation(request);\n                    continuation.resume();\n                }\n                \n            }).start();\n        }\n\n        if (request.getParameter(\"complete\")!=null)\n        {\n            final long complete=Long.parseLong(request.getParameter(\"complete\"));\n            new Thread(new Runnable()\n            {\n                public void run()\n                {\n                    try\n                    {\n                        Thread.sleep(complete);\n                    }\n                    catch (InterruptedException e)\n                    {\n                        e.printStackTrace();\n                    }\n                    try\n                    {\n                        response.setContentType(\"text/html\");\n                        response.getOutputStream().println(\"<h1>COMPLETED<\/h1>\"); \n                        Continuation continuation = ContinuationSupport.getContinuation(request,response);\n                        continuation.complete();\n                    }\n                    catch (IOException e)\n                    {\n                        e.printStackTrace();\n                    }\n                }\n\n            }).start();\n        }\n        \n        if (request.getParameter(\"suspend\")!=null && request.getAttribute(\"SUSPEND\")!=Boolean.TRUE)\n        {\n            request.setAttribute(\"SUSPEND\",Boolean.TRUE);\n            try\n            {\n                Continuation continuation = ContinuationSupport.getContinuation(request);\n                continuation.setTimeout(Long.parseLong(request.getParameter(\"suspend\")));\n                continuation.suspend();\n                continuation.undispatch();\n            }\n            catch(Exception e)\n            {\n                throw new ServletException(e);\n            }\n        }        \n            \n        request.setAttribute(\"Dump\", this);\n        getServletContext().setAttribute(\"Dump\",this);\n        // getServletContext().log(\"dump \"+request.getRequestURI());\n\n        // Force a content length response\n        String length= request.getParameter(\"length\");\n        if (length != null && length.length() > 0)\n        {\n            response.setContentLength(Integer.parseInt(length));\n        }\n\n        // Handle a dump of data\n        String data= request.getParameter(\"data\");\n        String block= request.getParameter(\"block\");\n        String dribble= request.getParameter(\"dribble\");\n        boolean flush= request.getParameter(\"flush\")!=null?Boolean.parseBoolean(request.getParameter(\"flush\")):false;\n        if (data != null && data.length() > 0)\n        {\n            long d=Long.parseLong(data);\n            int b=(block!=null&&block.length()>0)?Integer.parseInt(block):50;\n            byte[] buf=new byte[b];\n            for (int i=0;i<b;i++)\n            {\n                \n                buf[i]=(byte)('0'+(i%10));\n                if (i%10==9)\n                    buf[i]=(byte)'\\n';\n            }\n            buf[0]='o';\n            OutputStream out=response.getOutputStream();\n            response.setContentType(\"text/plain\");\n            while (d > 0)\n            {\n                if (b==1)\n                {\n                    out.write(d%80==0?'\\n':'.');\n                    d--;\n                }\n                else if (d>=b)\n                {\n                    out.write(buf);\n                    d=d-b;\n                }\n                else\n                {\n                    out.write(buf,0,(int)d);\n                    d=0;\n                }\n                \n                if (dribble!=null)\n                {\n                    out.flush();\n                    try\n                    {\n                        Thread.sleep(Long.parseLong(dribble));\n                    }\n                    catch (Exception e)\n                    {\n                        e.printStackTrace();\n                        break;\n                    }\n                }\n                \n            }\n            \n            if (flush)\n                out.flush();\n            \n            return;\n        }\n\n        // Handle a dump of data\n        String chars= request.getParameter(\"chars\");\n        if (chars != null && chars.length() > 0)\n        {\n            long d=Long.parseLong(chars);\n            int b=(block!=null&&block.length()>0)?Integer.parseInt(block):50;\n            char[] buf=new char[b];\n            for (int i=0;i<b;i++)\n            {\n                buf[i]=(char)('0'+(i%10));\n                if (i%10==9)\n                    buf[i]='\\n';\n            }\n            buf[0]='o';\n            response.setContentType(\"text/plain\");\n            PrintWriter out=response.getWriter();\n            while (d > 0 && !out.checkError())\n            {\n                if (b==1)\n                {\n                    out.write(d%80==0?'\\n':'.');\n                    d--;\n                }\n                else if (d>=b)\n                {\n                    out.write(buf);\n                    d=d-b;\n                }\n                else\n                {\n                    out.write(buf,0,(int)d);\n                    d=0;\n                }\n            }\n            return;\n        }\n\n        \n        \n        // handle an exception\n        String info= request.getPathInfo();\n        if (info != null && info.endsWith(\"Exception\"))\n        {\n            try\n            {\n                throw (Throwable) Thread.currentThread().getContextClassLoader().loadClass(info.substring(1)).newInstance();\n            }\n            catch (Throwable th)\n            {\n                throw new ServletException(th);\n            }\n        }\n\n        // test a reset\n        String reset= request.getParameter(\"reset\");\n        if (reset != null && reset.length() > 0)\n        {\n            response.getOutputStream().println(\"THIS SHOULD NOT BE SEEN!\");\n            response.setHeader(\"SHOULD_NOT\",\"BE SEEN\");\n            response.reset();\n        }\n        \n        \n        // handle an redirect\n        String redirect= request.getParameter(\"redirect\");\n        if (redirect != null && redirect.length() > 0)\n        {\n            response.getOutputStream().println(\"THIS SHOULD NOT BE SEEN!\");\n            response.sendRedirect(response.encodeRedirectURL(redirect));\n            try\n            {\n                response.getOutputStream().println(\"THIS SHOULD NOT BE SEEN!\");\n            }\n            catch(IOException e)\n            {\n                // ignored as stream is closed.\n            }\n            return;\n        }\n\n        // handle an error\n        String error= request.getParameter(\"error\");\n        if (error != null && error.length() > 0 && request.getAttribute(\"javax.servlet.error.status_code\")==null)\n        {\n            response.getOutputStream().println(\"THIS SHOULD NOT BE SEEN!\");\n            response.sendError(Integer.parseInt(error));\n            try\n            {\n                response.getOutputStream().println(\"THIS SHOULD NOT BE SEEN!\");\n            }\n            catch(IllegalStateException e)\n            {\n                try\n                {\n                    response.getWriter().println(\"NOR THIS!!\"); \n                }\n                catch(IOException e2){}\n            }\n            catch(IOException e){}\n            return;\n        }\n\n        // Handle a extra headers \n        String headers= request.getParameter(\"headers\");\n        if (headers != null && headers.length() > 0)\n        {\n            long h=Long.parseLong(headers);\n            for (int i=0;i<h;i++)\n                response.addHeader(\"Header\"+i,\"Value\"+i);\n        }\n\n        String buffer= request.getParameter(\"buffer\");\n        if (buffer != null && buffer.length() > 0)\n            response.setBufferSize(Integer.parseInt(buffer));\n\n        String charset= request.getParameter(\"charset\");\n        if (charset==null)\n            charset=\"UTF-8\";\n        response.setCharacterEncoding(charset);\n        response.setContentType(\"text/html\");\n\n        if (info != null && info.indexOf(\"Locale/\") >= 0)\n        {\n            try\n            {\n                String locale_name= info.substring(info.indexOf(\"Locale/\") + 7);\n                Field f= java.util.Locale.class.getField(locale_name);\n                response.setLocale((Locale)f.get(null));\n            }\n            catch (Exception e)\n            {\n                e.printStackTrace();\n                response.setLocale(Locale.getDefault());\n            }\n        }\n\n        String cn= request.getParameter(\"cookie\");\n        String cv=request.getParameter(\"cookiev\");\n        if (cn!=null && cv!=null)\n        {\n            Cookie cookie= new Cookie(cn, cv);\n            if (request.getParameter(\"version\")!=null)\n                cookie.setVersion(Integer.parseInt(request.getParameter(\"version\")));\n            cookie.setComment(\"Cookie from dump servlet\");\n            response.addCookie(cookie);\n        }\n\n        String pi= request.getPathInfo();\n        if (pi != null && pi.startsWith(\"/ex\"))\n        {\n            OutputStream out= response.getOutputStream();\n            out.write(\"<\/H1>This text should be reset<\/H1>\".getBytes());\n            if (\"/ex0\".equals(pi))\n                throw new ServletException(\"test ex0\", new Throwable());\n            else if (\"/ex1\".equals(pi))\n                throw new IOException(\"test ex1\");\n            else if (\"/ex2\".equals(pi))\n                throw new UnavailableException(\"test ex2\");\n            else if (pi.startsWith(\"/ex3/\"))\n                throw new UnavailableException(\"test ex3\",Integer.parseInt(pi.substring(5)));\n            throw new RuntimeException(\"test\");\n        }\n\n        if (\"true\".equals(request.getParameter(\"close\")))\n            response.setHeader(\"Connection\",\"close\");\n\n        String buffered= request.getParameter(\"buffered\");\n        \n        PrintWriter pout=null;\n        \n        try\n        {\n            pout =response.getWriter();\n        }\n        catch(IllegalStateException e)\n        {\n            pout=new PrintWriter(new OutputStreamWriter(response.getOutputStream(),charset));\n        }\n        if (buffered!=null)\n            pout = new PrintWriter(new BufferedWriter(pout,Integer.parseInt(buffered)));\n        \n        try\n        {\n            pout.write(\"<html>\\n<body>\\n\");\n            pout.write(\"<h1>Dump Servlet<\/h1>\\n\");\n            pout.write(\"<table width=\\\"95%\\\">\");\n            pout.write(\"<tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getMethod:&nbsp;<\/th>\");\n            pout.write(\"<td>\" + notag(request.getMethod())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getContentLength:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+Integer.toString(request.getContentLength())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getContentType:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+notag(request.getContentType())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getRequestURI:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+notag(request.getRequestURI())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getRequestURL:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+notag(request.getRequestURL().toString())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getContextPath:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getContextPath()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getServletPath:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+notag(request.getServletPath())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getPathInfo:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+notag(request.getPathInfo())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getPathTranslated:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+notag(request.getPathTranslated())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getQueryString:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+notag(request.getQueryString())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            \n            pout.write(\"<th align=\\\"right\\\">getProtocol:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getProtocol()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getScheme:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getScheme()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getServerName:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+notag(request.getServerName())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getServerPort:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+Integer.toString(request.getServerPort())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getLocalName:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getLocalName()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getLocalAddr:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getLocalAddr()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getLocalPort:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+Integer.toString(request.getLocalPort())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getRemoteUser:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getRemoteUser()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getRemoteAddr:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getRemoteAddr()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getRemoteHost:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getRemoteHost()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getRemotePort:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getRemotePort()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getRequestedSessionId:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getRequestedSessionId()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">isSecure():&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.isSecure()+\"<\/td>\");\n\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">isUserInRole(admin):&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.isUserInRole(\"admin\")+\"<\/td>\");\n\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getLocale:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getLocale()+\"<\/td>\");\n            \n            Enumeration locales= request.getLocales();\n            while (locales.hasMoreElements())\n            {\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">getLocales:&nbsp;<\/th>\");\n                pout.write(\"<td>\"+locales.nextElement()+\"<\/td>\");\n            }\n            pout.write(\"<\/tr><tr>\\n\");\n            \n            pout.write(\"<th align=\\\"left\\\" colspan=\\\"2\\\"><big><br/>Other HTTP Headers:<\/big><\/th>\");\n            Enumeration h= request.getHeaderNames();\n            String name;\n            while (h.hasMoreElements())\n            {\n                name= (String)h.nextElement();\n\n                Enumeration h2= request.getHeaders(name);\n                while (h2.hasMoreElements())\n                {\n                    String hv= (String)h2.nextElement();\n                    pout.write(\"<\/tr><tr>\\n\");\n                    pout.write(\"<th align=\\\"right\\\">\"+notag(name)+\":&nbsp;<\/th>\");\n                    pout.write(\"<td>\"+notag(hv)+\"<\/td>\");\n                }\n            }\n\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"left\\\" colspan=\\\"2\\\"><big><br/>Request Parameters:<\/big><\/th>\");\n            h= request.getParameterNames();\n            while (h.hasMoreElements())\n            {\n                name= (String)h.nextElement();\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">\"+notag(name)+\":&nbsp;<\/th>\");\n                pout.write(\"<td>\"+notag(request.getParameter(name))+\"<\/td>\");\n                String[] values= request.getParameterValues(name);\n                if (values == null)\n                {\n                    pout.write(\"<\/tr><tr>\\n\");\n                    pout.write(\"<th align=\\\"right\\\">\"+notag(name)+\" Values:&nbsp;<\/th>\");\n                    pout.write(\"<td>\"+\"NULL!\"+\"<\/td>\");\n                }\n                else if (values.length > 1)\n                {\n                    for (int i= 0; i < values.length; i++)\n                    {\n                        pout.write(\"<\/tr><tr>\\n\");\n                        pout.write(\"<th align=\\\"right\\\">\"+notag(name)+\"[\"+i+\"]:&nbsp;<\/th>\");\n                        pout.write(\"<td>\"+notag(values[i])+\"<\/td>\");\n                    }\n                }\n            }\n\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"left\\\" colspan=\\\"2\\\"><big><br/>Cookies:<\/big><\/th>\");\n            Cookie[] cookies = request.getCookies();\n            for (int i=0; cookies!=null && i<cookies.length;i++)\n            {\n                Cookie cookie = cookies[i];\n\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">\"+notag(cookie.getName())+\":&nbsp;<\/th>\");\n                pout.write(\"<td>\"+notag(cookie.getValue())+\"<\/td>\");\n            }\n            \n            String content_type=request.getContentType();\n            if (content_type!=null &&\n                !content_type.startsWith(\"application/x-www-form-urlencoded\") &&\n                !content_type.startsWith(\"multipart/form-data\"))\n            {\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"left\\\" valign=\\\"top\\\" colspan=\\\"2\\\"><big><br/>Content:<\/big><\/th>\");\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<td><pre>\");\n                char[] content= new char[4096];\n                int len;\n                try{\n                    Reader in=request.getReader();\n                    \n                    while((len=in.read(content))>=0)\n                        pout.write(notag(new String(content,0,len)));\n                }\n                catch(IOException e)\n                {\n                    pout.write(e.toString());\n                }\n                \n                pout.write(\"<\/pre><\/td>\");\n            }\n            \n            \n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"left\\\" colspan=\\\"2\\\"><big><br/>Request Attributes:<\/big><\/th>\");\n            Enumeration a= request.getAttributeNames();\n            while (a.hasMoreElements())\n            {\n                name= (String)a.nextElement();\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\" valign=\\\"top\\\">\"+name.replace(\".\",\" .\")+\":&nbsp;<\/th>\");\n                pout.write(\"<td>\"+\"<pre>\" + toString(request.getAttribute(name)) + \"<\/pre>\"+\"<\/td>\");\n            }            \n\n            \n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"left\\\" colspan=\\\"2\\\"><big><br/>Servlet InitParameters:<\/big><\/th>\");\n            a= getInitParameterNames();\n            while (a.hasMoreElements())\n            {\n                name= (String)a.nextElement();\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">\"+name+\":&nbsp;<\/th>\");\n                pout.write(\"<td>\"+ toString(getInitParameter(name)) +\"<\/td>\");\n            }\n\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"left\\\" colspan=\\\"2\\\"><big><br/>Context InitParameters:<\/big><\/th>\");\n            a= getServletContext().getInitParameterNames();\n            while (a.hasMoreElements())\n            {\n                name= (String)a.nextElement();\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\" valign=\\\"top\\\">\"+name.replace(\".\",\" .\")+\":&nbsp;<\/th>\");\n                pout.write(\"<td>\"+ toString(getServletContext().getInitParameter(name)) + \"<\/td>\");\n            }\n\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"left\\\" colspan=\\\"2\\\"><big><br/>Context Attributes:<\/big><\/th>\");\n            a= getServletContext().getAttributeNames();\n            while (a.hasMoreElements())\n            {\n                name= (String)a.nextElement();\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\" valign=\\\"top\\\">\"+name.replace(\".\",\" .\")+\":&nbsp;<\/th>\");\n                pout.write(\"<td>\"+\"<pre>\" + toString(getServletContext().getAttribute(name)) + \"<\/pre>\"+\"<\/td>\");\n            }\n\n\n            String res= request.getParameter(\"resource\");\n            if (res != null && res.length() > 0)\n            {\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"left\\\" colspan=\\\"2\\\"><big><br/>Get Resource: \\\"\"+res+\"\\\"<\/big><\/th>\");\n                \n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">this.getClass().getResource(...):&nbsp;<\/th>\");\n                pout.write(\"<td>\"+this.getClass().getResource(res)+\"<\/td>\");\n\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">this.getClass().getClassLoader().getResource(...):&nbsp;<\/th>\");\n                pout.write(\"<td>\"+this.getClass().getClassLoader().getResource(res)+\"<\/td>\");\n\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">Thread.currentThread().getContextClassLoader().getResource(...):&nbsp;<\/th>\");\n                pout.write(\"<td>\"+Thread.currentThread().getContextClassLoader().getResource(res)+\"<\/td>\");\n\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">getServletContext().getResource(...):&nbsp;<\/th>\");\n                try{pout.write(\"<td>\"+getServletContext().getResource(res)+\"<\/td>\");}\n                catch(Exception e) {pout.write(\"<td>\"+\"\" +e+\"<\/td>\");}\n            }\n            \n            pout.write(\"<\/tr><\/table>\\n\");\n\n            /* ------------------------------------------------------------ */\n            pout.write(\"<h2>Request Wrappers<\/h2>\\n\");\n            ServletRequest rw=request;\n            int w=0;\n            while (rw !=null)\n            {\n                pout.write((w++)+\": \"+rw.getClass().getName()+\"<br/>\");\n                if (rw instanceof HttpServletRequestWrapper)\n                    rw=((HttpServletRequestWrapper)rw).getRequest();\n                else if (rw instanceof ServletRequestWrapper)\n                    rw=((ServletRequestWrapper)rw).getRequest();\n                else\n                    rw=null;\n            }\n\n            /* ------------------------------------------------------------ */\n            pout.write(\"<h2>Response Wrappers<\/h2>\\n\");\n            ServletResponse rsw=response;\n            w=0;\n            while (rsw !=null)\n            {\n                pout.write((w++)+\": \"+rsw.getClass().getName()+\"<br/>\");\n                if (rsw instanceof HttpServletResponseWrapper)\n                    rsw=((HttpServletResponseWrapper)rsw).getResponse();\n                else if (rsw instanceof ServletResponseWrapper)\n                    rsw=((ServletResponseWrapper)rsw).getResponse();\n                else\n                    rsw=null;\n            }\n            \n            pout.write(\"<br/>\");\n            pout.write(\"<h2>International Characters (UTF-8)<\/h2>\");\n            pout.write(\"LATIN LETTER SMALL CAPITAL AE<br/>\\n\");\n            pout.write(\"Directly uni encoded(\\\\u1d01): \\u1d01<br/>\");\n            pout.write(\"HTML reference (&amp;AElig;): &AElig;<br/>\");\n            pout.write(\"Decimal (&amp;#7425;): &#7425;<br/>\");\n            pout.write(\"Javascript unicode (\\\\u1d01) : <script language='javascript'>document.write(\\\"\\u1d01\\\");<\/script><br/>\");\n            pout.write(\"<br/>\");\n            pout.write(\"<h2>Form to generate GET content<\/h2>\");\n            pout.write(\"<form method=\\\"GET\\\" action=\\\"\"+response.encodeURL(getURI(request))+\"\\\">\");\n            pout.write(\"TextField: <input type=\\\"text\\\" name=\\\"TextField\\\" value=\\\"value\\\"/><br/>\\n\");\n            pout.write(\"<input type=\\\"submit\\\" name=\\\"Action\\\" value=\\\"Submit\\\">\");\n            pout.write(\"<\/form>\");\n\n            pout.write(\"<br/>\");\n            \n            pout.write(\"<h2>Form to generate POST content<\/h2>\");\n            pout.write(\"<form method=\\\"POST\\\" accept-charset=\\\"utf-8\\\" action=\\\"\"+response.encodeURL(getURI(request))+\"\\\">\");\n            pout.write(\"TextField: <input type=\\\"text\\\" name=\\\"TextField\\\" value=\\\"value\\\"/><br/>\\n\");\n            pout.write(\"Select: <select multiple name=\\\"Select\\\">\\n\");\n            pout.write(\"<option>ValueA<\/option>\");\n            pout.write(\"<option>ValueB1,ValueB2<\/option>\");\n            pout.write(\"<option>ValueC<\/option>\");\n            pout.write(\"<\/select><br/>\");\n            pout.write(\"<input type=\\\"submit\\\" name=\\\"Action\\\" value=\\\"Submit\\\"><br/>\");\n            pout.write(\"<\/form>\");\n            pout.write(\"<br/>\");\n            \n            pout.write(\"<h2>Form to generate UPLOAD content<\/h2>\");\n            pout.write(\"<form method=\\\"POST\\\" enctype=\\\"multipart/form-data\\\" accept-charset=\\\"utf-8\\\" action=\\\"\"+\n                    response.encodeURL(getURI(request))+(request.getQueryString()==null?\"\":(\"?\"+request.getQueryString()))+\n                    \"\\\">\");\n            pout.write(\"TextField: <input type=\\\"text\\\" name=\\\"TextField\\\" value=\\\"comment\\\"/><br/>\\n\");\n            pout.write(\"File 1: <input type=\\\"file\\\" name=\\\"file1\\\" /><br/>\\n\");\n            pout.write(\"File 2: <input type=\\\"file\\\" name=\\\"file2\\\" /><br/>\\n\");\n            pout.write(\"<input type=\\\"submit\\\" name=\\\"Action\\\" value=\\\"Submit\\\"><br/>\");\n            pout.write(\"<\/form>\");\n\n            pout.write(\"<h2>Form to set Cookie<\/h2>\");\n            pout.write(\"<form method=\\\"POST\\\" action=\\\"\"+response.encodeURL(getURI(request))+\"\\\">\");\n            pout.write(\"cookie: <input type=\\\"text\\\" name=\\\"cookie\\\" /><br/>\\n\");\n            pout.write(\"value: <input type=\\\"text\\\" name=\\\"cookiev\\\" /><br/>\\n\");\n            pout.write(\"<input type=\\\"submit\\\" name=\\\"Action\\\" value=\\\"setCookie\\\">\");\n            pout.write(\"<\/form>\\n\");\n            \n            pout.write(\"<h2>Form to get Resource<\/h2>\");\n            pout.write(\"<form method=\\\"POST\\\" action=\\\"\"+response.encodeURL(getURI(request))+\"\\\">\");\n            pout.write(\"resource: <input type=\\\"text\\\" name=\\\"resource\\\" /><br/>\\n\");\n            pout.write(\"<input type=\\\"submit\\\" name=\\\"Action\\\" value=\\\"getResource\\\">\");\n            pout.write(\"<\/form>\\n\");\n        }\n        catch (Exception e)\n        {\n            getServletContext().log(\"dump\", e);\n        }\n        \n        String lines= request.getParameter(\"lines\");\n        if (lines!=null)\n        {\n            char[] line = \"<span>A line of characters. Blah blah blah blah.  blooble blooble<\/span><\/br>\\n\".toCharArray();\n            for (int l=Integer.parseInt(lines);l-->0;)\n            {\n                pout.write(\"<span>\"+l+\" <\/span>\");\n                pout.write(line);\n            }\n        }\n        \n        pout.write(\"<\/body>\\n<\/html>\\n\");\n        \n        pout.close();\n\n        if (pi != null)\n        {\n            if (\"/ex4\".equals(pi))\n                throw new ServletException(\"test ex4\", new Throwable());\n            if (\"/ex5\".equals(pi))\n                throw new IOException(\"test ex5\");\n            if (\"/ex6\".equals(pi))\n                throw new UnavailableException(\"test ex6\");\n        }\n\n\n    }","commit_id":"aea99b14aaff9a41337fab4427170814a53d85dd","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public Authentication validateRequest(ServletRequest req, ServletResponse res, boolean mandatory) throws ServerAuthException\n    {   \n        HttpServletRequest request = (HttpServletRequest)req;\n        HttpServletResponse response = (HttpServletResponse)res;\n        String uri = request.getRequestURI();\n        if (uri==null)\n            uri=URIUtil.SLASH;\n\n        mandatory|=uri.endsWith(__J_SECURITY_CHECK);\n        if (!mandatory)\n            return _deferred;\n        \n        if (isLoginOrErrorPage(URIUtil.addPaths(request.getServletPath(),request.getPathInfo())))\n            return Authentication.NOT_CHECKED;\n            \n        HttpSession session = request.getSession(true);\n            \n        try\n        {\n            // Handle a request for authentication.\n            if (uri.endsWith(__J_SECURITY_CHECK))\n            {\n                final String username = request.getParameter(__J_USERNAME);\n                final String password = request.getParameter(__J_PASSWORD);\n                \n                UserIdentity user = _loginService.login(username,password);\n                if (user!=null)\n                {\n                    // Redirect to original request\n                    String nuri;\n                    synchronized(session)\n                    {\n                        nuri = (String) session.getAttribute(__J_URI);\n                        session.removeAttribute(__J_URI);\n                    }\n                    \n                    if (nuri == null || nuri.length() == 0)\n                    {\n                        nuri = request.getContextPath();\n                        if (nuri.length() == 0) \n                            nuri = URIUtil.SLASH;\n                    }\n                    response.setContentLength(0);   \n                    response.sendRedirect(response.encodeRedirectURL(nuri));\n\n                    Authentication cached=new SessionAuthentication(session,this,user);\n                    session.setAttribute(SessionAuthentication.__J_AUTHENTICATED, cached);\n                    return new FormAuthentication(this,user);\n                }\n                \n                // not authenticated\n                if (Log.isDebugEnabled()) \n                    Log.debug(\"Form authentication FAILED for \" + StringUtil.printable(username));\n                if (_formErrorPage == null)\n                {\n                    if (response != null) \n                        response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                }\n                else if (_dispatch)\n                {\n                    RequestDispatcher dispatcher = request.getRequestDispatcher(_formErrorPage);\n                    response.setHeader(HttpHeaders.CACHE_CONTROL,\"No-cache\");\n                    response.setDateHeader(HttpHeaders.EXPIRES,1);\n                    dispatcher.forward(new FormRequest(request), new FormResponse(response));\n                }\n                else\n                {\n                    response.sendRedirect(URIUtil.addPaths(request.getContextPath(),_formErrorPage));\n                }\n                \n                return Authentication.SEND_FAILURE;\n            }\n            \n            // Look for cached authentication\n            Authentication authentication = (Authentication) session.getAttribute(SessionAuthentication.__J_AUTHENTICATED);\n            if (authentication != null) \n            {\n                // Has authentication been revoked?\n                if (authentication instanceof Authentication.User && \n                    _loginService!=null &&\n                    !_loginService.validate(((Authentication.User)authentication).getUserIdentity()))\n                \n                    session.removeAttribute(SessionAuthentication.__J_AUTHENTICATED);\n                else\n                    return authentication;\n            }\n\n            // if we can't send challenge\n            if (_deferred.isDeferred(response))\n                return Authentication.UNAUTHENTICATED; \n            \n            // remember the current URI\n            synchronized (session)\n            {\n                // TODO is this right?\n                if (session.getAttribute(__J_URI)==null)\n                {\n                    StringBuffer buf = request.getRequestURL();\n                    if (request.getQueryString() != null)\n                        buf.append(\"?\").append(request.getQueryString());\n                    session.setAttribute(__J_URI, buf.toString());\n                }\n            }\n            \n            // send the the challenge\n            if (_dispatch)\n            {\n                RequestDispatcher dispatcher = request.getRequestDispatcher(_formLoginPage);\n                response.setHeader(HttpHeaders.CACHE_CONTROL,\"No-cache\");\n                response.setDateHeader(HttpHeaders.EXPIRES,1);\n                dispatcher.forward(new FormRequest(request), new FormResponse(response));\n            }\n            else\n            {\n                response.sendRedirect(URIUtil.addPaths(request.getContextPath(),_formLoginPage));\n            }\n            return Authentication.SEND_CONTINUE;\n            \n         \n        }\n        catch (IOException e)\n        {\n            throw new ServerAuthException(e);\n        }\n        catch (ServletException e)\n        {\n            throw new ServerAuthException(e);\n        }\n    }","id":65077,"modified_method":"public Authentication validateRequest(ServletRequest req, ServletResponse res, boolean mandatory) throws ServerAuthException\n    {   \n        HttpServletRequest request = (HttpServletRequest)req;\n        HttpServletResponse response = (HttpServletResponse)res;\n        String uri = request.getRequestURI();\n        if (uri==null)\n            uri=URIUtil.SLASH;\n\n        mandatory|=isJSecurityCheck(uri);\n        if (!mandatory)\n            return _deferred;\n        \n        if (isLoginOrErrorPage(URIUtil.addPaths(request.getServletPath(),request.getPathInfo())))\n            return Authentication.NOT_CHECKED;\n            \n        HttpSession session = request.getSession(true);\n            \n        try\n        {\n            // Handle a request for authentication.\n            if (isJSecurityCheck(uri))\n            {\n                final String username = request.getParameter(__J_USERNAME);\n                final String password = request.getParameter(__J_PASSWORD);\n                \n                UserIdentity user = _loginService.login(username,password);\n                if (user!=null)\n                {\n                    // Redirect to original request\n                    String nuri;\n                    synchronized(session)\n                    {\n                        nuri = (String) session.getAttribute(__J_URI);\n                        session.removeAttribute(__J_URI);\n                    }\n                    \n                    if (nuri == null || nuri.length() == 0)\n                    {\n                        nuri = request.getContextPath();\n                        if (nuri.length() == 0) \n                            nuri = URIUtil.SLASH;\n                    }\n                    response.setContentLength(0);   \n                    response.sendRedirect(response.encodeRedirectURL(nuri));\n\n                    Authentication cached=new SessionAuthentication(session,this,user);\n                    session.setAttribute(SessionAuthentication.__J_AUTHENTICATED, cached);\n                    return new FormAuthentication(this,user);\n                }\n                \n                // not authenticated\n                if (Log.isDebugEnabled()) \n                    Log.debug(\"Form authentication FAILED for \" + StringUtil.printable(username));\n                if (_formErrorPage == null)\n                {\n                    if (response != null) \n                        response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                }\n                else if (_dispatch)\n                {\n                    RequestDispatcher dispatcher = request.getRequestDispatcher(_formErrorPage);\n                    response.setHeader(HttpHeaders.CACHE_CONTROL,\"No-cache\");\n                    response.setDateHeader(HttpHeaders.EXPIRES,1);\n                    dispatcher.forward(new FormRequest(request), new FormResponse(response));\n                }\n                else\n                {\n                    response.sendRedirect(response.encodeRedirectURL(URIUtil.addPaths(request.getContextPath(),_formErrorPage)));\n                }\n                \n                return Authentication.SEND_FAILURE;\n            }\n            \n            // Look for cached authentication\n            Authentication authentication = (Authentication) session.getAttribute(SessionAuthentication.__J_AUTHENTICATED);\n            if (authentication != null) \n            {\n                // Has authentication been revoked?\n                if (authentication instanceof Authentication.User && \n                    _loginService!=null &&\n                    !_loginService.validate(((Authentication.User)authentication).getUserIdentity()))\n                \n                    session.removeAttribute(SessionAuthentication.__J_AUTHENTICATED);\n                else\n                    return authentication;\n            }\n\n            // if we can't send challenge\n            if (_deferred.isDeferred(response))\n                return Authentication.UNAUTHENTICATED; \n            \n            // remember the current URI\n            synchronized (session)\n            {\n                // TODO is this right?\n                if (session.getAttribute(__J_URI)==null)\n                {\n                    StringBuffer buf = request.getRequestURL();\n                    if (request.getQueryString() != null)\n                        buf.append(\"?\").append(request.getQueryString());\n                    session.setAttribute(__J_URI, buf.toString());\n                }\n            }\n            \n            // send the the challenge\n            if (_dispatch)\n            {\n                RequestDispatcher dispatcher = request.getRequestDispatcher(_formLoginPage);\n                response.setHeader(HttpHeaders.CACHE_CONTROL,\"No-cache\");\n                response.setDateHeader(HttpHeaders.EXPIRES,1);\n                dispatcher.forward(new FormRequest(request), new FormResponse(response));\n            }\n            else\n            {\n                response.sendRedirect(response.encodeRedirectURL(URIUtil.addPaths(request.getContextPath(),_formLoginPage)));\n            }\n            return Authentication.SEND_CONTINUE;\n            \n         \n        }\n        catch (IOException e)\n        {\n            throw new ServerAuthException(e);\n        }\n        catch (ServletException e)\n        {\n            throw new ServerAuthException(e);\n        }\n    }","commit_id":"aea99b14aaff9a41337fab4427170814a53d85dd","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException\n        {\n            if (_newContextURL==null)\n                return;\n                        \n            String url = _newContextURL;\n            if (!_discardPathInfo && request.getPathInfo()!=null)\n                url=URIUtil.addPaths(url, request.getPathInfo());\n            if (!_discardQuery && request.getQueryString()!=null)\n                url+=\"?\"+request.getQueryString();\n            \n            response.sendRedirect(url);\n\n            String path=_newContextURL;\n            if (!_discardPathInfo && request.getPathInfo()!=null)\n                path=URIUtil.addPaths(path, request.getPathInfo());\n            \n            StringBuilder location = URIUtil.hasScheme(path)?new StringBuilder():baseRequest.getRootURL();\n\n            location.append(path);\n            if (!_discardQuery && request.getQueryString()!=null)\n            {\n                location.append('?');\n                location.append(request.getQueryString());\n            }\n            \n            response.setHeader(HttpHeaders.LOCATION,location.toString());\n\n            if (_expires!=null)\n                response.setHeader(HttpHeaders.EXPIRES,_expires);\n            \n            response.setStatus(_permanent?HttpServletResponse.SC_MOVED_PERMANENTLY:HttpServletResponse.SC_FOUND);\n            response.setContentLength(0);\n            baseRequest.setHandled(true);\n        }","id":65078,"modified_method":"public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException\n        {\n            if (_newContextURL==null)\n                return;\n                        \n            String url = _newContextURL;\n            if (!_discardPathInfo && request.getPathInfo()!=null)\n                url=URIUtil.addPaths(url, request.getPathInfo());\n            if (!_discardQuery && request.getQueryString()!=null)\n                url+=\"?\"+request.getQueryString();\n            \n            response.sendRedirect(response.encodeRedirectURL(url));\n\n            String path=_newContextURL;\n            if (!_discardPathInfo && request.getPathInfo()!=null)\n                path=URIUtil.addPaths(path, request.getPathInfo());\n            \n            StringBuilder location = URIUtil.hasScheme(path)?new StringBuilder():baseRequest.getRootURL();\n\n            location.append(path);\n            if (!_discardQuery && request.getQueryString()!=null)\n            {\n                location.append('?');\n                location.append(request.getQueryString());\n            }\n            \n            response.setHeader(HttpHeaders.LOCATION,location.toString());\n\n            if (_expires!=null)\n                response.setHeader(HttpHeaders.EXPIRES,_expires);\n            \n            response.setStatus(_permanent?HttpServletResponse.SC_MOVED_PERMANENTLY:HttpServletResponse.SC_FOUND);\n            response.setContentLength(0);\n            baseRequest.setHandled(true);\n        }","commit_id":"aea99b14aaff9a41337fab4427170814a53d85dd","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public String apply(String target, HttpServletRequest request, HttpServletResponse response) throws IOException\n    {\n        response.sendRedirect(_location);\n        return target;\n    }","id":65079,"modified_method":"public String apply(String target, HttpServletRequest request, HttpServletResponse response) throws IOException\n    {\n        response.sendRedirect(response.encodeRedirectURL(_location));\n        return target;\n    }","commit_id":"aea99b14aaff9a41337fab4427170814a53d85dd","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    protected String apply(String target, HttpServletRequest request, HttpServletResponse response, Matcher matcher)\n            throws IOException\n    {\n        target=_replacement;\n        for (int g=1;g<=matcher.groupCount();g++)\n        {\n            String group = matcher.group(g);\n            target=target.replaceAll(\"\\\\$\"+g,group);\n        }\n\n        response.sendRedirect(target);\n        return target;\n    }","id":65080,"modified_method":"@Override\n    protected String apply(String target, HttpServletRequest request, HttpServletResponse response, Matcher matcher)\n            throws IOException\n    {\n        target=_replacement;\n        for (int g=1;g<=matcher.groupCount();g++)\n        {\n            String group = matcher.group(g);\n            target=target.replaceAll(\"\\\\$\"+g,group);\n        }\n\n        response.sendRedirect(response.encodeRedirectURL(target));\n        return target;\n    }","commit_id":"aea99b14aaff9a41337fab4427170814a53d85dd","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException\n    {\n        if (baseRequest.isHandled())\n            return;\n        \n        boolean skipContentBody = false;\n        if(!HttpMethods.GET.equals(request.getMethod()))\n        {\n            if(!HttpMethods.HEAD.equals(request.getMethod()))\n                return;\n            skipContentBody = true;\n        }\n     \n        Resource resource=getResource(request);\n        \n        if (resource==null || !resource.exists())\n            return;\n        if (!_aliases && resource.getAlias()!=null)\n        {\n            Log.info(resource+\" aliased to \"+resource.getAlias());\n            return;\n        }\n\n        // We are going to server something\n        baseRequest.setHandled(true);\n        \n        if (resource.isDirectory())\n        {\n            if (!request.getPathInfo().endsWith(URIUtil.SLASH))\n            {\n                response.sendRedirect(URIUtil.addPaths(request.getRequestURI(),URIUtil.SLASH));\n                return;\n            }\n            \n            Resource welcome=getWelcome(resource);\n            if (welcome!=null && welcome.exists())\n                resource=welcome;\n            else\n            {\n                doDirectory(request,response,resource);\n                baseRequest.setHandled(true);\n                return;\n            }\n        }\n        \n        // set some headers\n        long last_modified=resource.lastModified();\n        if (last_modified>0)\n        {\n            long if_modified=request.getDateHeader(HttpHeaders.IF_MODIFIED_SINCE);\n            if (if_modified>0 && last_modified/1000<=if_modified/1000)\n            {\n                response.setStatus(HttpStatus.NOT_MODIFIED_304);\n                return;\n            }\n        }\n        \n        Buffer mime=_mimeTypes.getMimeByExtension(resource.toString());\n        if (mime==null)\n            mime=_mimeTypes.getMimeByExtension(request.getPathInfo());\n        \n        // set the headers\n        doResponseHeaders(response,resource,mime!=null?mime.toString():null);\n        response.setDateHeader(HttpHeaders.LAST_MODIFIED,last_modified);\n        if(skipContentBody)\n            return;\n        // Send the content\n        OutputStream out =null;\n        try {out = response.getOutputStream();}\n        catch(IllegalStateException e) {out = new WriterOutputStream(response.getWriter());}\n        \n        // See if a short direct method can be used?\n        if (out instanceof HttpConnection.Output)\n        {\n            // TODO file mapped buffers\n            ((HttpConnection.Output)out).sendContent(resource.getInputStream());\n        }\n        else\n        {\n            // Write content normally\n            resource.writeTo(out,0,resource.length());\n        }\n    }","id":65081,"modified_method":"public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException\n    {\n        if (baseRequest.isHandled())\n            return;\n        \n        boolean skipContentBody = false;\n        if(!HttpMethods.GET.equals(request.getMethod()))\n        {\n            if(!HttpMethods.HEAD.equals(request.getMethod()))\n                return;\n            skipContentBody = true;\n        }\n     \n        Resource resource=getResource(request);\n        \n        if (resource==null || !resource.exists())\n            return;\n        if (!_aliases && resource.getAlias()!=null)\n        {\n            Log.info(resource+\" aliased to \"+resource.getAlias());\n            return;\n        }\n\n        // We are going to server something\n        baseRequest.setHandled(true);\n        \n        if (resource.isDirectory())\n        {\n            if (!request.getPathInfo().endsWith(URIUtil.SLASH))\n            {\n                response.sendRedirect(response.encodeRedirectURL(URIUtil.addPaths(request.getRequestURI(),URIUtil.SLASH)));\n                return;\n            }\n            \n            Resource welcome=getWelcome(resource);\n            if (welcome!=null && welcome.exists())\n                resource=welcome;\n            else\n            {\n                doDirectory(request,response,resource);\n                baseRequest.setHandled(true);\n                return;\n            }\n        }\n        \n        // set some headers\n        long last_modified=resource.lastModified();\n        if (last_modified>0)\n        {\n            long if_modified=request.getDateHeader(HttpHeaders.IF_MODIFIED_SINCE);\n            if (if_modified>0 && last_modified/1000<=if_modified/1000)\n            {\n                response.setStatus(HttpStatus.NOT_MODIFIED_304);\n                return;\n            }\n        }\n        \n        Buffer mime=_mimeTypes.getMimeByExtension(resource.toString());\n        if (mime==null)\n            mime=_mimeTypes.getMimeByExtension(request.getPathInfo());\n        \n        // set the headers\n        doResponseHeaders(response,resource,mime!=null?mime.toString():null);\n        response.setDateHeader(HttpHeaders.LAST_MODIFIED,last_modified);\n        if(skipContentBody)\n            return;\n        // Send the content\n        OutputStream out =null;\n        try {out = response.getOutputStream();}\n        catch(IllegalStateException e) {out = new WriterOutputStream(response.getWriter());}\n        \n        // See if a short direct method can be used?\n        if (out instanceof HttpConnection.Output)\n        {\n            // TODO file mapped buffers\n            ((HttpConnection.Output)out).sendContent(resource.getInputStream());\n        }\n        else\n        {\n            // Write content normally\n            resource.writeTo(out,0,resource.length());\n        }\n    }","commit_id":"aea99b14aaff9a41337fab4427170814a53d85dd","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Sets the candidate foundation as defined in ICE-CORE.\n     *\n     * @param foundation the candidate foundation as defined in ICE-CORE.\n     */\n    public void setFoundation(int foundation)\n    {\n        super.setAttribute(FOUNDATION_ATTR_NAME, foundation);\n    }","id":65082,"modified_method":"/**\r\n     * Sets the candidate foundation as defined in ICE-CORE.\r\n     *\r\n     * @param foundation the candidate foundation as defined in ICE-CORE.\r\n     */\r\n    public void setFoundation(String foundation)\r\n    {\r\n        super.setAttribute(FOUNDATION_ATTR_NAME, foundation);\r\n    }","commit_id":"af7a2680fdfcec270cbfe704dea9406560340872","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the candidate foundation as defined in ICE-CORE.\n     *\n     * @return the candidate foundation as defined in ICE-CORE.\n     */\n    public int getFoundation()\n    {\n        return super.getAttributeAsInt(FOUNDATION_ATTR_NAME);\n    }","id":65083,"modified_method":"/**\r\n     * Returns the candidate foundation as defined in ICE-CORE.\r\n     *\r\n     * @return the candidate foundation as defined in ICE-CORE.\r\n     */\r\n    public String getFoundation()\r\n    {\r\n        return super.getAttributeAsString(FOUNDATION_ATTR_NAME);\r\n    }","commit_id":"af7a2680fdfcec270cbfe704dea9406560340872","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates a {@link GTalkCandidatePacketExtension} and initializes it so\n     * that it would describe the state of <tt>candidate<\/tt>\n     *\n     * @param candidate the ICE4J {@link Candidate} that we'd like to convert\n     * into an Google Talk packet extension.\n     * @param name name of the candidate extension\n     *\n     * @return a new {@link GTalkCandidatePacketExtension} corresponding to the\n     * state of the <tt>candidate<\/tt> candidate.\n     */\n    public static GTalkCandidatePacketExtension createCandidate(\n            Candidate<?> candidate, String name)\n    {\n        GTalkCandidatePacketExtension packet =\n            new GTalkCandidatePacketExtension();\n\n        Component component = candidate.getParentComponent();\n\n        packet.setName(name);\n        packet.setGeneration(\n                component.getParentStream().getParentAgent().getGeneration());\n\n        TransportAddress transportAddress = candidate.getTransportAddress();\n\n        // different username/password for each candidate ?\n        packet.setUsername(((LocalCandidate)candidate).getUfrag());\n        if(candidate instanceof GoogleRelayedCandidate)\n        {\n            packet.setPassword(\n                    ((GoogleRelayedCandidate)\n                     candidate).getPassword());\n        }\n        else\n        {\n            packet.setPassword(\"\");\n        }\n        packet.setAddress(transportAddress.getHostAddress());\n        packet.setPort(transportAddress.getPort());\n        if(transportAddress.getPort() != 443)\n        {\n            packet.setProtocol(candidate.getTransport().toString());\n        }\n        else\n        {\n            packet.setProtocol(\"ssltcp\");\n        }\n        packet.setNetwork(0);\n        packet.setFoundation(0);\n        packet.setComponent(component.getComponentID());\n\n        CandidateType candType = CandidateType.valueOf(\n                candidate.getType().toString());\n\n        if(candType == CandidateType.srflx)\n        {\n            candType = CandidateType.stun;\n        }\n        else if(candType == CandidateType.host)\n        {\n            candType = CandidateType.local;\n        }\n\n        packet.setType(candType);\n        double priority = candidate.getPriority();\n        packet.setPreference((priority / 1000));\n\n        return packet;\n    }","id":65084,"modified_method":"/**\r\n     * Creates a {@link GTalkCandidatePacketExtension} and initializes it so\r\n     * that it would describe the state of <tt>candidate<\/tt>\r\n     *\r\n     * @param candidate the ICE4J {@link Candidate} that we'd like to convert\r\n     * into an Google Talk packet extension.\r\n     * @param name name of the candidate extension\r\n     *\r\n     * @return a new {@link GTalkCandidatePacketExtension} corresponding to the\r\n     * state of the <tt>candidate<\/tt> candidate.\r\n     */\r\n    public static GTalkCandidatePacketExtension createCandidate(\r\n            Candidate<?> candidate, String name)\r\n    {\r\n        GTalkCandidatePacketExtension packet =\r\n            new GTalkCandidatePacketExtension();\r\n\r\n        Component component = candidate.getParentComponent();\r\n\r\n        packet.setName(name);\r\n        packet.setGeneration(\r\n                component.getParentStream().getParentAgent().getGeneration());\r\n\r\n        TransportAddress transportAddress = candidate.getTransportAddress();\r\n\r\n        // different username/password for each candidate ?\r\n        packet.setUsername(((LocalCandidate)candidate).getUfrag());\r\n        if(candidate instanceof GoogleRelayedCandidate)\r\n        {\r\n            packet.setPassword(\r\n                    ((GoogleRelayedCandidate)\r\n                     candidate).getPassword());\r\n        }\r\n        else\r\n        {\r\n            packet.setPassword(\"\");\r\n        }\r\n        packet.setAddress(transportAddress.getHostAddress());\r\n        packet.setPort(transportAddress.getPort());\r\n        if(transportAddress.getPort() != 443)\r\n        {\r\n            packet.setProtocol(candidate.getTransport().toString());\r\n        }\r\n        else\r\n        {\r\n            packet.setProtocol(\"ssltcp\");\r\n        }\r\n        packet.setNetwork(0);\r\n        packet.setFoundation(\"0\");\r\n        packet.setComponent(component.getComponentID());\r\n\r\n        CandidateType candType = CandidateType.valueOf(\r\n                candidate.getType().toString());\r\n\r\n        if(candType == CandidateType.srflx)\r\n        {\r\n            candType = CandidateType.stun;\r\n        }\r\n        else if(candType == CandidateType.host)\r\n        {\r\n            candType = CandidateType.local;\r\n        }\r\n\r\n        packet.setType(candType);\r\n        double priority = candidate.getPriority();\r\n        packet.setPreference((priority / 1000));\r\n\r\n        return packet;\r\n    }","commit_id":"af7a2680fdfcec270cbfe704dea9406560340872","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\r\n     * Starts the connectivity establishment of the associated ICE\r\n     * <tt>Agent<\/tt>.\r\n     *\r\n     * @param remote the collection of <tt>ContentPacketExtension<\/tt>s which\r\n     * represents the remote counterpart of the negotiation between the local\r\n     * and the remote peers\r\n     * @return <tt>true<\/tt> if connectivity establishment has been started in\r\n     * response to the call; otherwise, <tt>false<\/tt>\r\n     * @see TransportManagerJabberImpl#startConnectivityEstablishment(Iterable)\r\n     */\r\n    @Override\r\n    public synchronized boolean startConnectivityEstablishment(\r\n            Iterable<ContentPacketExtension> remote)\r\n    {\r\n        /* If ICE is already running, we try to update the checklists with\r\n         * the candidates. Note that this is a best effort.\r\n         */\r\n        if (IceProcessingState.RUNNING.equals(iceAgent.getState()))\r\n        {\r\n            if(logger.isInfoEnabled())\r\n            {\r\n                logger.info(\"Update ICE remote candidates\");\r\n            }\r\n\r\n            for (ContentPacketExtension content : remote)\r\n            {\r\n                IceUdpTransportPacketExtension transport\r\n                    = content.getFirstChildOfType(\r\n                            IceUdpTransportPacketExtension.class);\r\n\r\n                List<CandidatePacketExtension> candidates\r\n                    = transport.getChildExtensionsOfType(\r\n                        CandidatePacketExtension.class);\r\n                // Sorts the remote candidates (host < reflexive < relayed) in\r\n                // order to create first host, then reflexive, the relayed\r\n                // candidates, to be able to set the relative-candidate matching\r\n                // the rel-addr/rel-port attribute.\r\n                Collections.sort(candidates);\r\n\r\n                if(candidates == null || candidates.size() == 0)\r\n                {\r\n                    return false;\r\n                }\r\n\r\n                RtpDescriptionPacketExtension description\r\n                    = content.getFirstChildOfType(\r\n                        RtpDescriptionPacketExtension.class);\r\n\r\n                if (description == null)\r\n                {\r\n                    ContentPacketExtension localContent\r\n                        = findContentByName(cpeList, content.getName());\r\n\r\n                    if (localContent != null)\r\n                    {\r\n                        description\r\n                            = localContent.getFirstChildOfType(\r\n                                    RtpDescriptionPacketExtension.class);\r\n                    }\r\n                }\r\n\r\n                if (description == null)\r\n                    continue;\r\n\r\n                IceMediaStream stream = iceAgent.getStream(\r\n                        description.getMedia());\r\n\r\n                /* Different stream may have different ufrag/password */\r\n                String ufrag = transport.getUfrag();\r\n\r\n                if (ufrag != null)\r\n                    stream.setRemoteUfrag(ufrag);\r\n\r\n                String password = transport.getPassword();\r\n\r\n                if (password != null)\r\n                    stream.setRemotePassword(password);\r\n\r\n                for (CandidatePacketExtension candidate : candidates)\r\n                {\r\n                    /*\r\n                     * Is the remote candidate from the current generation of\r\n                     * the iceAgent?\r\n                     */\r\n                    if (candidate.getGeneration() != iceAgent.getGeneration())\r\n                        continue;\r\n\r\n                    Component component\r\n                        = stream.getComponent(candidate.getComponent());\r\n\r\n                    TransportAddress relatedAddr = null;\r\n                    if(candidate.getRelAddr() != null\r\n                            && candidate.getRelPort() != -1)\r\n                    {\r\n                        relatedAddr = new TransportAddress(\r\n                                candidate.getRelAddr(),\r\n                                candidate.getRelPort(),\r\n                                Transport.parse(candidate.getProtocol()));\r\n                    }\r\n                    RemoteCandidate relatedCandidate\r\n                        = component.findRemoteCandidate(relatedAddr);\r\n                    component.addUpdateRemoteCandidates(\r\n                            new RemoteCandidate(\r\n                                    new TransportAddress(\r\n                                            candidate.getIP(),\r\n                                            candidate.getPort(),\r\n                                            Transport.parse(\r\n                                                    candidate.getProtocol())),\r\n                                    component,\r\n                                    org.ice4j.ice.CandidateType.parse(\r\n                                            candidate.getType().toString()),\r\n                                    Integer.toString(candidate.getFoundation()),\r\n                                    candidate.getPriority(),\r\n                                    relatedCandidate));\r\n                }\r\n            }\r\n\r\n            /* update all components of all streams */\r\n            for(IceMediaStream stream : iceAgent.getStreams())\r\n            {\r\n                for(Component component : stream.getComponents())\r\n                {\r\n                    component.updateRemoteCandidates();\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        int generation = iceAgent.getGeneration();\r\n        boolean startConnectivityEstablishment = false;\r\n\r\n        for (ContentPacketExtension content : remote)\r\n        {\r\n            IceUdpTransportPacketExtension transport\r\n                = content.getFirstChildOfType(\r\n                        IceUdpTransportPacketExtension.class);\r\n\r\n            List<CandidatePacketExtension> candidates\r\n                = transport.getChildExtensionsOfType(\r\n                        CandidatePacketExtension.class);\r\n            // Sorts the remote candidates (host < reflexive < relayed) in order\r\n            // to create first host, then reflexive, the relayed candidates, to\r\n            // be able to set the relative-candidate matching the\r\n            // rel-addr/rel-port attribute.\r\n            Collections.sort(candidates);\r\n\r\n            /*\r\n             * If we cannot associate an IceMediaStream with the remote content,\r\n             * we will not have anything to add the remote candidates to.\r\n             */\r\n            RtpDescriptionPacketExtension description\r\n                = content.getFirstChildOfType(\r\n                    RtpDescriptionPacketExtension.class);\r\n\r\n            if ((description == null) && (cpeList != null))\r\n            {\r\n                ContentPacketExtension localContent\r\n                    = findContentByName(cpeList, content.getName());\r\n\r\n                if (localContent != null)\r\n                {\r\n                    description\r\n                        = localContent.getFirstChildOfType(\r\n                                RtpDescriptionPacketExtension.class);\r\n                }\r\n            }\r\n            if (description == null)\r\n                continue;\r\n\r\n            IceMediaStream stream = iceAgent.getStream(description.getMedia());\r\n\r\n            /* Different stream may have different ufrag/password */\r\n            String ufrag = transport.getUfrag();\r\n\r\n            if (ufrag != null)\r\n                stream.setRemoteUfrag(ufrag);\r\n\r\n            String password = transport.getPassword();\r\n\r\n            if (password != null)\r\n                stream.setRemotePassword(password);\r\n\r\n            for (CandidatePacketExtension candidate : candidates)\r\n            {\r\n                /*\r\n                 * Is the remote candidate from the current generation of the\r\n                 * iceAgent?\r\n                 */\r\n                if (candidate.getGeneration() != generation)\r\n                    continue;\r\n\r\n                Component component\r\n                    = stream.getComponent(candidate.getComponent());\r\n\r\n                TransportAddress relatedAddr = null;\r\n                if(candidate.getRelAddr() != null\r\n                        && candidate.getRelPort() != -1)\r\n                {\r\n                    relatedAddr = new TransportAddress(\r\n                            candidate.getRelAddr(),\r\n                            candidate.getRelPort(),\r\n                            Transport.parse(candidate.getProtocol()));\r\n                }\r\n                RemoteCandidate relatedCandidate\r\n                    = component.findRemoteCandidate(relatedAddr);\r\n                component.addRemoteCandidate(\r\n                        new RemoteCandidate(\r\n                                new TransportAddress(\r\n                                        candidate.getIP(),\r\n                                        candidate.getPort(),\r\n                                        Transport.parse(\r\n                                                candidate.getProtocol())),\r\n                                component,\r\n                                org.ice4j.ice.CandidateType.parse(\r\n                                        candidate.getType().toString()),\r\n                                Integer.toString(candidate.getFoundation()),\r\n                                candidate.getPriority(),\r\n                                relatedCandidate));\r\n                startConnectivityEstablishment = true;\r\n            }\r\n        }\r\n        if (startConnectivityEstablishment)\r\n        {\r\n            /*\r\n             * Once again because the ICE Agent does not support adding\r\n             * candidates after the connectivity establishment has been started\r\n             * and because multiple transport-info JingleIQs may be used to send\r\n             * the whole set of transport candidates from the remote peer to the\r\n             * local peer, do not really start the connectivity establishment\r\n             * until we have at least one remote candidate per ICE Component.\r\n             */\r\n            for (IceMediaStream stream : iceAgent.getStreams())\r\n            {\r\n                for (Component component : stream.getComponents())\r\n                {\r\n                    if (component.getRemoteCandidateCount() < 1)\r\n                    {\r\n                        startConnectivityEstablishment = false;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!startConnectivityEstablishment)\r\n                    break;\r\n            }\r\n\r\n            if (startConnectivityEstablishment)\r\n            {\r\n                iceAgent.startConnectivityEstablishment();\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","id":65085,"modified_method":"/**\r\n     * Starts the connectivity establishment of the associated ICE\r\n     * <tt>Agent<\/tt>.\r\n     *\r\n     * @param remote the collection of <tt>ContentPacketExtension<\/tt>s which\r\n     * represents the remote counterpart of the negotiation between the local\r\n     * and the remote peers\r\n     * @return <tt>true<\/tt> if connectivity establishment has been started in\r\n     * response to the call; otherwise, <tt>false<\/tt>\r\n     * @see TransportManagerJabberImpl#startConnectivityEstablishment(Iterable)\r\n     */\r\n    @Override\r\n    public synchronized boolean startConnectivityEstablishment(\r\n            Iterable<ContentPacketExtension> remote)\r\n    {\r\n        /* If ICE is already running, we try to update the checklists with\r\n         * the candidates. Note that this is a best effort.\r\n         */\r\n        if (IceProcessingState.RUNNING.equals(iceAgent.getState()))\r\n        {\r\n            if(logger.isInfoEnabled())\r\n            {\r\n                logger.info(\"Update ICE remote candidates\");\r\n            }\r\n\r\n            for (ContentPacketExtension content : remote)\r\n            {\r\n                IceUdpTransportPacketExtension transport\r\n                    = content.getFirstChildOfType(\r\n                            IceUdpTransportPacketExtension.class);\r\n\r\n                List<CandidatePacketExtension> candidates\r\n                    = transport.getChildExtensionsOfType(\r\n                        CandidatePacketExtension.class);\r\n                // Sorts the remote candidates (host < reflexive < relayed) in\r\n                // order to create first host, then reflexive, the relayed\r\n                // candidates, to be able to set the relative-candidate matching\r\n                // the rel-addr/rel-port attribute.\r\n                Collections.sort(candidates);\r\n\r\n                if(candidates == null || candidates.size() == 0)\r\n                {\r\n                    return false;\r\n                }\r\n\r\n                RtpDescriptionPacketExtension description\r\n                    = content.getFirstChildOfType(\r\n                        RtpDescriptionPacketExtension.class);\r\n\r\n                if (description == null)\r\n                {\r\n                    ContentPacketExtension localContent\r\n                        = findContentByName(cpeList, content.getName());\r\n\r\n                    if (localContent != null)\r\n                    {\r\n                        description\r\n                            = localContent.getFirstChildOfType(\r\n                                    RtpDescriptionPacketExtension.class);\r\n                    }\r\n                }\r\n\r\n                if (description == null)\r\n                    continue;\r\n\r\n                IceMediaStream stream = iceAgent.getStream(\r\n                        description.getMedia());\r\n\r\n                /* Different stream may have different ufrag/password */\r\n                String ufrag = transport.getUfrag();\r\n\r\n                if (ufrag != null)\r\n                    stream.setRemoteUfrag(ufrag);\r\n\r\n                String password = transport.getPassword();\r\n\r\n                if (password != null)\r\n                    stream.setRemotePassword(password);\r\n\r\n                for (CandidatePacketExtension candidate : candidates)\r\n                {\r\n                    /*\r\n                     * Is the remote candidate from the current generation of\r\n                     * the iceAgent?\r\n                     */\r\n                    if (candidate.getGeneration() != iceAgent.getGeneration())\r\n                        continue;\r\n\r\n                    Component component\r\n                        = stream.getComponent(candidate.getComponent());\r\n\r\n                    TransportAddress relatedAddr = null;\r\n                    if(candidate.getRelAddr() != null\r\n                            && candidate.getRelPort() != -1)\r\n                    {\r\n                        relatedAddr = new TransportAddress(\r\n                                candidate.getRelAddr(),\r\n                                candidate.getRelPort(),\r\n                                Transport.parse(candidate.getProtocol()));\r\n                    }\r\n                    RemoteCandidate relatedCandidate\r\n                        = component.findRemoteCandidate(relatedAddr);\r\n                    component.addUpdateRemoteCandidates(\r\n                            new RemoteCandidate(\r\n                                    new TransportAddress(\r\n                                            candidate.getIP(),\r\n                                            candidate.getPort(),\r\n                                            Transport.parse(\r\n                                                    candidate.getProtocol())),\r\n                                    component,\r\n                                    org.ice4j.ice.CandidateType.parse(\r\n                                            candidate.getType().toString()),\r\n                                    candidate.getFoundation(),\r\n                                    candidate.getPriority(),\r\n                                    relatedCandidate));\r\n                }\r\n            }\r\n\r\n            /* update all components of all streams */\r\n            for(IceMediaStream stream : iceAgent.getStreams())\r\n            {\r\n                for(Component component : stream.getComponents())\r\n                {\r\n                    component.updateRemoteCandidates();\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        int generation = iceAgent.getGeneration();\r\n        boolean startConnectivityEstablishment = false;\r\n\r\n        for (ContentPacketExtension content : remote)\r\n        {\r\n            IceUdpTransportPacketExtension transport\r\n                = content.getFirstChildOfType(\r\n                        IceUdpTransportPacketExtension.class);\r\n\r\n            List<CandidatePacketExtension> candidates\r\n                = transport.getChildExtensionsOfType(\r\n                        CandidatePacketExtension.class);\r\n            // Sorts the remote candidates (host < reflexive < relayed) in order\r\n            // to create first host, then reflexive, the relayed candidates, to\r\n            // be able to set the relative-candidate matching the\r\n            // rel-addr/rel-port attribute.\r\n            Collections.sort(candidates);\r\n\r\n            /*\r\n             * If we cannot associate an IceMediaStream with the remote content,\r\n             * we will not have anything to add the remote candidates to.\r\n             */\r\n            RtpDescriptionPacketExtension description\r\n                = content.getFirstChildOfType(\r\n                    RtpDescriptionPacketExtension.class);\r\n\r\n            if ((description == null) && (cpeList != null))\r\n            {\r\n                ContentPacketExtension localContent\r\n                    = findContentByName(cpeList, content.getName());\r\n\r\n                if (localContent != null)\r\n                {\r\n                    description\r\n                        = localContent.getFirstChildOfType(\r\n                                RtpDescriptionPacketExtension.class);\r\n                }\r\n            }\r\n            if (description == null)\r\n                continue;\r\n\r\n            IceMediaStream stream = iceAgent.getStream(description.getMedia());\r\n\r\n            /* Different stream may have different ufrag/password */\r\n            String ufrag = transport.getUfrag();\r\n\r\n            if (ufrag != null)\r\n                stream.setRemoteUfrag(ufrag);\r\n\r\n            String password = transport.getPassword();\r\n\r\n            if (password != null)\r\n                stream.setRemotePassword(password);\r\n\r\n            for (CandidatePacketExtension candidate : candidates)\r\n            {\r\n                /*\r\n                 * Is the remote candidate from the current generation of the\r\n                 * iceAgent?\r\n                 */\r\n                if (candidate.getGeneration() != generation)\r\n                    continue;\r\n\r\n                Component component\r\n                    = stream.getComponent(candidate.getComponent());\r\n\r\n                TransportAddress relatedAddr = null;\r\n                if(candidate.getRelAddr() != null\r\n                        && candidate.getRelPort() != -1)\r\n                {\r\n                    relatedAddr = new TransportAddress(\r\n                            candidate.getRelAddr(),\r\n                            candidate.getRelPort(),\r\n                            Transport.parse(candidate.getProtocol()));\r\n                }\r\n                RemoteCandidate relatedCandidate\r\n                    = component.findRemoteCandidate(relatedAddr);\r\n                component.addRemoteCandidate(\r\n                        new RemoteCandidate(\r\n                                new TransportAddress(\r\n                                        candidate.getIP(),\r\n                                        candidate.getPort(),\r\n                                        Transport.parse(\r\n                                                candidate.getProtocol())),\r\n                                component,\r\n                                org.ice4j.ice.CandidateType.parse(\r\n                                        candidate.getType().toString()),\r\n                                candidate.getFoundation(),\r\n                                candidate.getPriority(),\r\n                                relatedCandidate));\r\n                startConnectivityEstablishment = true;\r\n            }\r\n        }\r\n        if (startConnectivityEstablishment)\r\n        {\r\n            /*\r\n             * Once again because the ICE Agent does not support adding\r\n             * candidates after the connectivity establishment has been started\r\n             * and because multiple transport-info JingleIQs may be used to send\r\n             * the whole set of transport candidates from the remote peer to the\r\n             * local peer, do not really start the connectivity establishment\r\n             * until we have at least one remote candidate per ICE Component.\r\n             */\r\n            for (IceMediaStream stream : iceAgent.getStreams())\r\n            {\r\n                for (Component component : stream.getComponents())\r\n                {\r\n                    if (component.getRemoteCandidateCount() < 1)\r\n                    {\r\n                        startConnectivityEstablishment = false;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!startConnectivityEstablishment)\r\n                    break;\r\n            }\r\n\r\n            if (startConnectivityEstablishment)\r\n            {\r\n                iceAgent.startConnectivityEstablishment();\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"af7a2680fdfcec270cbfe704dea9406560340872","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\r\n     * Creates a {@link CandidatePacketExtension} and initializes it so that it\r\n     * would describe the state of <tt>candidate<\/tt>\r\n     *\r\n     * @param candidate the ICE4J {@link Candidate} that we'd like to convert\r\n     * into an XMPP packet extension.\r\n     *\r\n     * @return a new {@link CandidatePacketExtension} corresponding to the state\r\n     * of the <tt>candidate<\/tt> candidate.\r\n     */\r\n    private CandidatePacketExtension createCandidate(Candidate<?> candidate)\r\n    {\r\n        CandidatePacketExtension packet = new CandidatePacketExtension();\r\n\r\n        //TODO: XMPP expects int values as foundations. Luckily that's exactly\r\n        //what ice4j is using under the hood at this time. still, we'd need to\r\n        //make sure that doesn't change ... possibly by setting a property there\r\n        packet.setFoundation(Integer.parseInt( candidate.getFoundation()));\r\n\r\n        Component component = candidate.getParentComponent();\r\n\r\n        packet.setComponent(component.getComponentID());\r\n        packet.setProtocol(candidate.getTransport().toString());\r\n        packet.setPriority(candidate.getPriority());\r\n        packet.setGeneration(\r\n                component.getParentStream().getParentAgent().getGeneration());\r\n\r\n        TransportAddress transportAddress = candidate.getTransportAddress();\r\n        packet.setID(getNextID());\r\n        packet.setIP(transportAddress.getHostAddress());\r\n        packet.setPort(transportAddress.getPort());\r\n\r\n        packet.setType(CandidateType.valueOf(candidate.getType().toString()));\r\n\r\n        TransportAddress relAddr = candidate.getRelatedAddress();\r\n\r\n        if(relAddr != null)\r\n        {\r\n            packet.setRelAddr(relAddr.getHostAddress());\r\n            packet.setRelPort(relAddr.getPort());\r\n        }\r\n\r\n        /*\r\n         * FIXME The XML schema of XEP-0176: Jingle ICE-UDP Transport Method\r\n         * specifies the network attribute as required.\r\n         */\r\n        packet.setNetwork(0);\r\n\r\n        return packet;\r\n    }","id":65086,"modified_method":"/**\r\n     * Creates a {@link CandidatePacketExtension} and initializes it so that it\r\n     * would describe the state of <tt>candidate<\/tt>\r\n     *\r\n     * @param candidate the ICE4J {@link Candidate} that we'd like to convert\r\n     * into an XMPP packet extension.\r\n     *\r\n     * @return a new {@link CandidatePacketExtension} corresponding to the state\r\n     * of the <tt>candidate<\/tt> candidate.\r\n     */\r\n    private CandidatePacketExtension createCandidate(Candidate<?> candidate)\r\n    {\r\n        CandidatePacketExtension packet = new CandidatePacketExtension();\r\n\r\n        packet.setFoundation(candidate.getFoundation());\r\n\r\n        Component component = candidate.getParentComponent();\r\n\r\n        packet.setComponent(component.getComponentID());\r\n        packet.setProtocol(candidate.getTransport().toString());\r\n        packet.setPriority(candidate.getPriority());\r\n        packet.setGeneration(\r\n                component.getParentStream().getParentAgent().getGeneration());\r\n\r\n        TransportAddress transportAddress = candidate.getTransportAddress();\r\n        packet.setID(getNextID());\r\n        packet.setIP(transportAddress.getHostAddress());\r\n        packet.setPort(transportAddress.getPort());\r\n\r\n        packet.setType(CandidateType.valueOf(candidate.getType().toString()));\r\n\r\n        TransportAddress relAddr = candidate.getRelatedAddress();\r\n\r\n        if(relAddr != null)\r\n        {\r\n            packet.setRelAddr(relAddr.getHostAddress());\r\n            packet.setRelPort(relAddr.getPort());\r\n        }\r\n\r\n        /*\r\n         * FIXME The XML schema of XEP-0176: Jingle ICE-UDP Transport Method\r\n         * specifies the network attribute as required.\r\n         */\r\n        packet.setNetwork(0);\r\n\r\n        return packet;\r\n    }","commit_id":"af7a2680fdfcec270cbfe704dea9406560340872","url":"https://github.com/jitsi/jitsi"},{"original_method":"@Override\n    public String[] getValueConstraints() {\n        // TODO: namespace mapping?\n        return node.getStrings(\"jcr:valueConstraints\");\n    }","id":65087,"modified_method":"@Override\n    public String[] getValueConstraints() {\n        // TODO: namespace mapping?\n        String[] constraints = node.getStrings(\"jcr:valueConstraints\");\n        if (constraints == null) {\n            constraints = new String[0];\n        }\n        return constraints;\n    }","commit_id":"c850bfeff34aa1d5c71f6d383bc67f75b87809b0","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean isMandatory() {\n        return getBoolean(\"jcr:mandatory\", false);\n    }","id":65088,"modified_method":"@Override\n    public boolean isMandatory() {\n        return node.getBoolean(\"jcr:mandatory\");\n    }","commit_id":"8dc6b5f5bcf2fac89c326b86bb13e47c4c230cd7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean isProtected() {\n        return getBoolean(\"jcr:protected\", false);\n    }","id":65089,"modified_method":"@Override\n    public boolean isProtected() {\n        return node.getBoolean(\"jcr:protected\");\n    }","commit_id":"8dc6b5f5bcf2fac89c326b86bb13e47c4c230cd7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"protected ItemDefinitionImpl(\n            NodeType type, NameMapper mapper, Tree tree) {\n        this.type = type;\n        this.mapper = mapper;\n        this.tree = tree;\n    }","id":65090,"modified_method":"protected ItemDefinitionImpl(NodeType type, NodeUtil node) {\n        this.type = type;\n        this.node = node;\n    }","commit_id":"8dc6b5f5bcf2fac89c326b86bb13e47c4c230cd7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean isAutoCreated() {\n        return getBoolean(\"jcr:autoCreated\", false);\n    }","id":65091,"modified_method":"@Override\n    public boolean isAutoCreated() {\n        return node.getBoolean(\"jcr:autoCreated\");\n    }","commit_id":"8dc6b5f5bcf2fac89c326b86bb13e47c4c230cd7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public String getName() {\n        return getName(\"jcr:name\", \"*\");\n    }","id":65092,"modified_method":"@Override\n    public String getName() {\n        return node.getName(\"jcr:name\", \"*\");\n    }","commit_id":"8dc6b5f5bcf2fac89c326b86bb13e47c4c230cd7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public int getOnParentVersion() {\n        String opv = getString(\"jcr:onParentVersion\", ACTIONNAME_COPY);\n        if (ACTIONNAME_ABORT.equalsIgnoreCase(opv)) {\n            return OnParentVersionAction.ABORT;\n        } else if (ACTIONNAME_COMPUTE.equalsIgnoreCase(opv)) {\n            return OnParentVersionAction.COMPUTE;\n        } else if (ACTIONNAME_IGNORE.equalsIgnoreCase(opv)) {\n            return OnParentVersionAction.IGNORE;\n        } else if (ACTIONNAME_INITIALIZE.equalsIgnoreCase(opv)) {\n            return OnParentVersionAction.INITIALIZE;\n        } else if (ACTIONNAME_VERSION.equalsIgnoreCase(opv)) {\n            return OnParentVersionAction.VERSION;\n        } else {\n            return OnParentVersionAction.COPY;\n        }\n    }","id":65093,"modified_method":"@Override\n    public int getOnParentVersion() {\n        String opv = node.getString(\"jcr:onParentVersion\", ACTIONNAME_COPY);\n        if (ACTIONNAME_ABORT.equalsIgnoreCase(opv)) {\n            return OnParentVersionAction.ABORT;\n        } else if (ACTIONNAME_COMPUTE.equalsIgnoreCase(opv)) {\n            return OnParentVersionAction.COMPUTE;\n        } else if (ACTIONNAME_IGNORE.equalsIgnoreCase(opv)) {\n            return OnParentVersionAction.IGNORE;\n        } else if (ACTIONNAME_INITIALIZE.equalsIgnoreCase(opv)) {\n            return OnParentVersionAction.INITIALIZE;\n        } else if (ACTIONNAME_VERSION.equalsIgnoreCase(opv)) {\n            return OnParentVersionAction.VERSION;\n        } else {\n            return OnParentVersionAction.COPY;\n        }\n    }","commit_id":"8dc6b5f5bcf2fac89c326b86bb13e47c4c230cd7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"protected NodeDefinitionImpl(\n            NodeTypeManager manager,\n            NodeType type, NameMapper mapper, Tree tree) {\n        super(type, mapper, tree);\n        this.manager = manager;\n    }","id":65094,"modified_method":"protected NodeDefinitionImpl(\n            NodeTypeManager manager, NodeType type, NodeUtil node) {\n        super(type, node);\n        this.manager = manager;\n    }","commit_id":"8dc6b5f5bcf2fac89c326b86bb13e47c4c230cd7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public String[] getRequiredPrimaryTypeNames() {\n        return getNames(\"requiredPrimaryTypes\", \"nt:base\");\n    }","id":65095,"modified_method":"@Override\n    public String[] getRequiredPrimaryTypeNames() {\n        return node.getNames(\"requiredPrimaryTypes\", \"nt:base\");\n    }","commit_id":"8dc6b5f5bcf2fac89c326b86bb13e47c4c230cd7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean allowsSameNameSiblings() {\n        return getBoolean(\"jcr:sameNameSiblings\", false);\n    }","id":65096,"modified_method":"@Override\n    public boolean allowsSameNameSiblings() {\n        return node.getBoolean(\"jcr:sameNameSiblings\");\n    }","commit_id":"8dc6b5f5bcf2fac89c326b86bb13e47c4c230cd7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public String getDefaultPrimaryTypeName() {\n        return getName(\"jcr:defaultPrimaryTypeName\", null);\n    }","id":65097,"modified_method":"@Override\n    public String getDefaultPrimaryTypeName() {\n        return node.getName(\"jcr:defaultPrimaryTypeName\", null);\n    }","commit_id":"8dc6b5f5bcf2fac89c326b86bb13e47c4c230cd7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean isMultiple() {\n        return getBoolean(\"jcr:multiple\", false);\n    }","id":65098,"modified_method":"@Override\n    public boolean isMultiple() {\n        return node.getBoolean(\"jcr:multiple\");\n    }","commit_id":"8dc6b5f5bcf2fac89c326b86bb13e47c4c230cd7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public int getRequiredType() {\n        String type = getString(\"jcr:requiredType\", TYPENAME_UNDEFINED);\n        if (PropertyType.TYPENAME_BINARY.equalsIgnoreCase(type)) {\n            return PropertyType.BINARY;\n        } else if (PropertyType.TYPENAME_BOOLEAN.equalsIgnoreCase(type)) {\n            return PropertyType.BOOLEAN;\n        } else if (PropertyType.TYPENAME_DATE.equalsIgnoreCase(type)) {\n            return PropertyType.DATE;\n        } else if (PropertyType.TYPENAME_DECIMAL.equalsIgnoreCase(type)) {\n            return PropertyType.DECIMAL;\n        } else if (PropertyType.TYPENAME_DOUBLE.equalsIgnoreCase(type)) {\n            return PropertyType.DOUBLE;\n        } else if (PropertyType.TYPENAME_LONG.equalsIgnoreCase(type)) {\n            return PropertyType.LONG;\n        } else if (PropertyType.TYPENAME_NAME.equalsIgnoreCase(type)) {\n            return PropertyType.NAME;\n        } else if (PropertyType.TYPENAME_PATH.equalsIgnoreCase(type)) {\n            return PropertyType.PATH;\n        } else if (PropertyType.TYPENAME_REFERENCE.equalsIgnoreCase(type)) {\n            return PropertyType.REFERENCE;\n        } else if (PropertyType.TYPENAME_STRING.equalsIgnoreCase(type)) {\n            return PropertyType.STRING;\n        } else if (PropertyType.TYPENAME_URI.equalsIgnoreCase(type)) {\n            return PropertyType.URI;\n        } else if (PropertyType.TYPENAME_WEAKREFERENCE.equalsIgnoreCase(type)) {\n            return PropertyType.WEAKREFERENCE;\n        } else {\n            return PropertyType.UNDEFINED;\n        }\n    }","id":65099,"modified_method":"@Override\n    public int getRequiredType() {\n        String type = node.getString(\"jcr:requiredType\", TYPENAME_UNDEFINED);\n        if (PropertyType.TYPENAME_BINARY.equalsIgnoreCase(type)) {\n            return PropertyType.BINARY;\n        } else if (PropertyType.TYPENAME_BOOLEAN.equalsIgnoreCase(type)) {\n            return PropertyType.BOOLEAN;\n        } else if (PropertyType.TYPENAME_DATE.equalsIgnoreCase(type)) {\n            return PropertyType.DATE;\n        } else if (PropertyType.TYPENAME_DECIMAL.equalsIgnoreCase(type)) {\n            return PropertyType.DECIMAL;\n        } else if (PropertyType.TYPENAME_DOUBLE.equalsIgnoreCase(type)) {\n            return PropertyType.DOUBLE;\n        } else if (PropertyType.TYPENAME_LONG.equalsIgnoreCase(type)) {\n            return PropertyType.LONG;\n        } else if (PropertyType.TYPENAME_NAME.equalsIgnoreCase(type)) {\n            return PropertyType.NAME;\n        } else if (PropertyType.TYPENAME_PATH.equalsIgnoreCase(type)) {\n            return PropertyType.PATH;\n        } else if (PropertyType.TYPENAME_REFERENCE.equalsIgnoreCase(type)) {\n            return PropertyType.REFERENCE;\n        } else if (PropertyType.TYPENAME_STRING.equalsIgnoreCase(type)) {\n            return PropertyType.STRING;\n        } else if (PropertyType.TYPENAME_URI.equalsIgnoreCase(type)) {\n            return PropertyType.URI;\n        } else if (PropertyType.TYPENAME_WEAKREFERENCE.equalsIgnoreCase(type)) {\n            return PropertyType.WEAKREFERENCE;\n        } else {\n            return PropertyType.UNDEFINED;\n        }\n    }","commit_id":"8dc6b5f5bcf2fac89c326b86bb13e47c4c230cd7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean isQueryOrderable() {\n        return getBoolean(\"jcr:isQueryOrderable\", true);\n    }","id":65100,"modified_method":"@Override\n    public boolean isQueryOrderable() {\n        return node.getBoolean(\"jcr:isQueryOrderable\");\n    }","commit_id":"8dc6b5f5bcf2fac89c326b86bb13e47c4c230cd7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public String[] getValueConstraints() {\n        String[] constraints = getStrings(\"jcr:valueConstraints\", null);\n        if (constraints != null) {\n            int type = getRequiredType();\n            if (type == PropertyType.NAME || type == PropertyType.PATH) {\n                for (int i = 0; i < constraints.length; i++) {\n                    // TODO: namespace mapping\n                }\n            }\n        }\n        return constraints;\n    }","id":65101,"modified_method":"@Override\n    public String[] getValueConstraints() {\n        // TODO: namespace mapping?\n        return node.getStrings(\"jcr:valueConstraints\");\n    }","commit_id":"8dc6b5f5bcf2fac89c326b86bb13e47c4c230cd7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean isFullTextSearchable() {\n        return getBoolean(\"jcr:isFullTextSearchable\", true);\n    }","id":65102,"modified_method":"@Override\n    public boolean isFullTextSearchable() {\n        return node.getBoolean(\"jcr:isFullTextSearchable\");\n    }","commit_id":"8dc6b5f5bcf2fac89c326b86bb13e47c4c230cd7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public PropertyDefinitionImpl(NodeType type, NameMapper mapper, Tree tree) {\n        super(type, mapper, tree);\n    }","id":65103,"modified_method":"public PropertyDefinitionImpl(NodeType type, NodeUtil node) {\n        super(type, node);\n    }","commit_id":"8dc6b5f5bcf2fac89c326b86bb13e47c4c230cd7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public String[] getAvailableQueryOperators() {\n        return getStrings(\"jcr:availableQueryOperators\", DEFAULT_QOPS.clone());\n    }","id":65104,"modified_method":"@Override\n    public String[] getAvailableQueryOperators() {\n        String[] ops = node.getStrings(\"jcr:availableQueryOperators\");\n        if (ops == null) {\n            ops = new String[] {\n                    QueryObjectModelConstants.JCR_OPERATOR_EQUAL_TO,\n                    QueryObjectModelConstants.JCR_OPERATOR_NOT_EQUAL_TO,\n                    QueryObjectModelConstants.JCR_OPERATOR_GREATER_THAN,\n                    QueryObjectModelConstants.JCR_OPERATOR_GREATER_THAN_OR_EQUAL_TO,\n                    QueryObjectModelConstants.JCR_OPERATOR_LESS_THAN,\n                    QueryObjectModelConstants.JCR_OPERATOR_LESS_THAN_OR_EQUAL_TO,\n                    QueryObjectModelConstants.JCR_OPERATOR_LIKE };\n        }\n        return ops;\n    }","commit_id":"8dc6b5f5bcf2fac89c326b86bb13e47c4c230cd7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n\tpublic void onSuccess(ClientKeyBlock block, boolean fromStore, Object reqTokenIgnored, ObjectContainer container, ClientContext context) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(parent, 1);\n\t\t}\n\t\tif(parent instanceof ClientGetter)\n\t\t\t((ClientGetter)parent).addKeyToBinaryBlob(block, container, context);\n\t\tBucket data = extract(block, container, context);\n\t\tif(data == null) return; // failed\n\t\tif(!block.isMetadata()) {\n\t\t\tif(key instanceof ClientSSK) {\n\t\t\t\ttry {\n\t\t\t\t\tFreenetURI uri = this.key.getURI();\n\t\t\t\t\tif(uri.isSSK() && uri.isSSKForUSK()) {\n\t\t\t\t\t\turi = uri.uskForSSK();\n\t\t\t\t\t\tUSK u = USK.create(uri);\n\t\t\t\t\t\tcontext.uskManager.updateKnownGood(u, uri.getSuggestedEdition(), context);\n\t\t\t\t\t}\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\tLogger.error(this, \"Caught \"+e, e);\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\t// Don't let the USK hint cause us to not succeed on the block.\n\t\t\t\t\tLogger.error(this, \"Caught \"+t, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tonSuccess(new FetchResult((ClientMetadata)null, data), container, context);\n\t\t} else {\n\t\t\tonFailure(new FetchException(FetchException.INVALID_METADATA, \"Metadata where expected data\"), false, container, context);\n\t\t}\n\t}","id":65105,"modified_method":"@Override\n\tpublic void onSuccess(ClientKeyBlock block, boolean fromStore, Object reqTokenIgnored, ObjectContainer container, ClientContext context) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(parent, 1);\n\t\t}\n\t\tif(parent instanceof ClientGetter)\n\t\t\t((ClientGetter)parent).addKeyToBinaryBlob(block, container, context);\n\t\tBucket data = extract(block, container, context);\n\t\tif(data == null) return; // failed\n\t\tcontext.uskManager.checkUSK(key.getURI(), fromStore, container, block.isMetadata());\n\t\tif(!block.isMetadata()) {\n\t\t\tonSuccess(new FetchResult((ClientMetadata)null, data), container, context);\n\t\t} else {\n\t\t\tonFailure(new FetchException(FetchException.INVALID_METADATA, \"Metadata where expected data\"), false, container, context);\n\t\t}\n\t}","commit_id":"b8f4ca5b6cc322332ed3ead606a3c1b99997642e","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\tprotected void onSuccess(FetchResult result, ObjectContainer container, ClientContext context) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(decompressors, 1);\n\t\t\tcontainer.activate(parent, 1);\n\t\t\tcontainer.activate(ctx, 1);\n\t\t\tcontainer.activate(rcb, 1);\n\t\t}\n\t\tremoveMetadata(container);\n\t\tremoveArchiveMetadata(container);\n\t\tsynchronized(this) {\n\t\t\t// So a SingleKeyListener isn't created.\n\t\t\tfinished = true;\n\t\t}\n\t\tif(parent.isCancelled()) {\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Parent is cancelled\");\n\t\t\tresult.asBucket().free();\n\t\t\tif(persistent) result.asBucket().removeFrom(container);\n\t\t\tonFailure(new FetchException(FetchException.CANCELLED), false, container, context);\n\t\t\treturn;\n\t\t}\n\t\tif((!ctx.ignoreTooManyPathComponents) && (!metaStrings.isEmpty()) && isFinal) {\n\t\t\t// Some meta-strings left\n\t\t\tif(addedMetaStrings > 0) {\n\t\t\t\t// Should this be an error?\n\t\t\t\t// It would be useful to be able to fetch the data ...\n\t\t\t\t// On the other hand such inserts could cause unpredictable results?\n\t\t\t\t// Would be useful to make a redirect to the key we actually fetched.\n\t\t\t\trcb.onFailure(new FetchException(FetchException.INVALID_METADATA, \"Invalid metadata: too many path components in redirects\", thisKey), this, container, context);\n\t\t\t} else {\n\t\t\t\t// TOO_MANY_PATH_COMPONENTS\n\t\t\t\t// report to user\n\t\t\t\tif(logMINOR) {\n\t\t\t\t\tLogger.minor(this, \"Too many path components: for \"+uri+\" meta=\"+metaStrings.toString());\n\t\t\t\t}\n\t\t\t\tFreenetURI tryURI = uri;\n\t\t\t\ttryURI = tryURI.dropLastMetaStrings(metaStrings.size());\n\t\t\t\trcb.onFailure(new FetchException(FetchException.TOO_MANY_PATH_COMPONENTS, result.size(), (rcb == parent), result.getMimeType(), tryURI), this, container, context);\n\t\t\t}\n\t\t\tresult.asBucket().free();\n\t\t\tif(persistent) result.asBucket().removeFrom(container);\n\t\t\treturn;\n\t\t} else if(result.size() > ctx.maxOutputLength) {\n\t\t\trcb.onFailure(new FetchException(FetchException.TOO_BIG, result.size(), (rcb == parent), result.getMimeType()), this, container, context);\n\t\t\tresult.asBucket().free();\n\t\t\tif(persistent) result.asBucket().removeFrom(container);\n\t\t} else {\n\t\t\tInputStream input = null;\n\t\t\ttry {\n\t\t\t\tinput = result.asBucket().getInputStream();\n\t\t\t} catch (IOException e) {\n\t\t\t\trcb.onFailure(new FetchException(FetchException.BUCKET_ERROR), this, container, context);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trcb.onSuccess(input, result.getMetadata(), decompressors, this, container, context);\n\t\t}\n\t}","id":65106,"modified_method":"@Override\n\tprotected void onSuccess(FetchResult result, ObjectContainer container, ClientContext context) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(decompressors, 1);\n\t\t\tcontainer.activate(parent, 1);\n\t\t\tcontainer.activate(ctx, 1);\n\t\t\tcontainer.activate(rcb, 1);\n\t\t}\n\t\tremoveMetadata(container);\n\t\tremoveArchiveMetadata(container);\n\t\tsynchronized(this) {\n\t\t\t// So a SingleKeyListener isn't created.\n\t\t\tfinished = true;\n\t\t}\n\t\tif(parent.isCancelled()) {\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Parent is cancelled\");\n\t\t\tresult.asBucket().free();\n\t\t\tif(persistent) result.asBucket().removeFrom(container);\n\t\t\tonFailure(new FetchException(FetchException.CANCELLED), false, container, context);\n\t\t\treturn;\n\t\t}\n\t\tif((!ctx.ignoreTooManyPathComponents) && (!metaStrings.isEmpty()) && isFinal) {\n\t\t\t// Some meta-strings left\n\t\t\tif(addedMetaStrings > 0) {\n\t\t\t\t// Should this be an error?\n\t\t\t\t// It would be useful to be able to fetch the data ...\n\t\t\t\t// On the other hand such inserts could cause unpredictable results?\n\t\t\t\t// Would be useful to make a redirect to the key we actually fetched.\n\t\t\t\trcb.onFailure(new FetchException(FetchException.INVALID_METADATA, \"Invalid metadata: too many path components in redirects\", thisKey), this, container, context);\n\t\t\t} else {\n\t\t\t\t// TOO_MANY_PATH_COMPONENTS\n\t\t\t\t// report to user\n\t\t\t\tif(logMINOR) {\n\t\t\t\t\tLogger.minor(this, \"Too many path components: for \"+uri+\" meta=\"+metaStrings.toString());\n\t\t\t\t}\n\t\t\t\tFreenetURI tryURI = uri;\n\t\t\t\ttryURI = tryURI.dropLastMetaStrings(metaStrings.size());\n\t\t\t\trcb.onFailure(new FetchException(FetchException.TOO_MANY_PATH_COMPONENTS, result.size(), (rcb == parent), result.getMimeType(), tryURI), this, container, context);\n\t\t\t}\n\t\t\tresult.asBucket().free();\n\t\t\tif(persistent) result.asBucket().removeFrom(container);\n\t\t\treturn;\n\t\t} else if(result.size() > ctx.maxOutputLength) {\n\t\t\trcb.onFailure(new FetchException(FetchException.TOO_BIG, result.size(), (rcb == parent), result.getMimeType()), this, container, context);\n\t\t\tresult.asBucket().free();\n\t\t\tif(persistent) result.asBucket().removeFrom(container);\n\t\t} else {\n\t\t\ttry {\n\t\t\tPipedInputStream data = new PipedInputStream();\n\t\t\tfinal Bucket resultBucket = result.asBucket();\n\t\t\tfinal InputStream input = result.asBucket().getInputStream();\n\t\t\tfinal PipedOutputStream output = new PipedOutputStream(data);\n\t\t\tnew Thread() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tFileUtil.copy(input, output , -1);\n\t\t\t\t\t\toutput.close();\n\t\t\t\t\t\tinput.close();\n\t\t\t\t\t} catch(IOException e) {\n\t\t\t\t\t\tCloser.close(output);\n\t\t\t\t\t\tCloser.close(input);\n\t\t\t\t\t\tresultBucket.free();\n\t\t\t\t\t\tLogger.error(this, \"Failed to extract the data bucket form \"+this, e);\n\t\t\t\t\t\t/* Handle exceptions by dying as violently as possible. As the main thread of\n\t\t\t\t\t\texecution will be in the process of reading data from this thread, we need to generally\n\t\t\t\t\t\tcause mayhem over there to make it stop. */\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}.start();\n\t\t\trcb.onSuccess(data, result.getMetadata(), decompressors, this, container, context);\n\t\t\t} catch(IOException e) {\n\t\t\t\tLogger.error(this, \"Failed to extract data bucket\");\n\t\t\t\trcb.onFailure(new FetchException(FetchException.BUCKET_ERROR), this, container, context);\n\t\t\t}\n\t\t}\n\t}","commit_id":"6fcbbdad4cfdb787d98d2370cd84d59ff8401c49","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\tpublic void onSuccess(ClientKeyBlock block, boolean fromStore, Object reqTokenIgnored, ObjectContainer container, ClientContext context) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(parent, 1);\n\t\t}\n\t\tif(parent instanceof ClientGetter)\n\t\t\t((ClientGetter)parent).addKeyToBinaryBlob(block, container, context);\n\t\tBucket data = extract(block, container, context);\n\t\tif(data == null) return; // failed\n\t\tif(!block.isMetadata()) {\n\t\t\tif(key instanceof ClientSSK) {\n\t\t\t\ttry {\n\t\t\t\t\tFreenetURI uri = this.key.getURI();\n\t\t\t\t\tif(uri.isSSK() && uri.isSSKForUSK()) {\n\t\t\t\t\t\turi = uri.uskForSSK();\n\t\t\t\t\t\tUSK u = USK.create(uri);\n\t\t\t\t\t\tcontext.uskManager.updateKnownGood(u, uri.getSuggestedEdition(), context);\n\t\t\t\t\t}\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\tLogger.error(this, \"Caught \"+e, e);\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\t// Don't let the USK hint cause us to not succeed on the block.\n\t\t\t\t\tLogger.error(this, \"Caught \"+t, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tonSuccess(new FetchResult((ClientMetadata)null, data), container, context);\n\t\t} else {\n\t\t\tonFailure(new FetchException(FetchException.INVALID_METADATA, \"Metadata where expected data\"), false, container, context);\n\t\t}\n\t}","id":65107,"modified_method":"@Override\n\tpublic void onSuccess(ClientKeyBlock block, boolean fromStore, Object reqTokenIgnored, ObjectContainer container, ClientContext context) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(parent, 1);\n\t\t}\n\t\tif(parent instanceof ClientGetter)\n\t\t\t((ClientGetter)parent).addKeyToBinaryBlob(block, container, context);\n\t\tBucket data = extract(block, container, context);\n\t\tif(data == null) return; // failed\n\t\tcontext.uskManager.checkUSK(key.getURI(), fromStore, container, block.isMetadata());\n\t\tif(!block.isMetadata()) {\n\t\t\tonSuccess(new FetchResult((ClientMetadata)null, data), container, context);\n\t\t} else {\n\t\t\tonFailure(new FetchException(FetchException.INVALID_METADATA, \"Metadata where expected data\"), false, container, context);\n\t\t}\n\t}","commit_id":"a4ec81d4c7c3db74a757aff9e013ba601badd32d","url":"https://github.com/freenet/fred"},{"original_method":"private static int addImportForItem(PsiFile file, int startOffset, LookupItem item) throws IncorrectOperationException {\n    PsiDocumentManager.getInstance(file.getProject()).commitAllDocuments();\n\n    Object o = item.getObject();\n    if (o instanceof PsiClass){\n      PsiClass aClass = (PsiClass)o;\n      int length = aClass.getName().length();\n      return addImportForClass(file, startOffset, startOffset + length, aClass);\n    }\n    else if (o instanceof PsiType){\n      PsiType type = ((PsiType)o).getDeepComponentType();\n      if (type instanceof PsiClassType) {\n        PsiClass refClass = ((PsiClassType) type).resolve();\n        if (refClass != null){\n          int length = refClass.getName().length();\n          return addImportForClass(file, startOffset, startOffset + length, refClass);\n        }\n      }\n    }\n    else if (o instanceof PsiMethod){\n      PsiMethod method = (PsiMethod)o;\n      if (method.isConstructor()){\n        PsiClass aClass = (PsiClass)item.getAttribute(LookupItem.CONTAINING_CLASS_ATTR);\n        if (aClass == null){\n          aClass = method.getContainingClass();\n        }\n        if (aClass != null){\n          int length = method.getName().length();\n          return addImportForClass(file, startOffset, startOffset + length, aClass);\n        }\n      }\n    }\n\n    return startOffset;\n  }","id":65108,"modified_method":"private static int addImportForItem(PsiFile file, int startOffset, LookupItem item) throws IncorrectOperationException {\n    PsiDocumentManager.getInstance(file.getProject()).commitAllDocuments();\n\n    Object o = item.getObject();\n    if (o instanceof PsiClass){\n      PsiClass aClass = (PsiClass)o;\n      int length = aClass.getName().length();\n      final int newOffset = addImportForClass(file, startOffset, startOffset + length, aClass);\n      shortenReference(file, newOffset);\n      return newOffset;\n    }\n    else if (o instanceof PsiType){\n      PsiType type = ((PsiType)o).getDeepComponentType();\n      if (type instanceof PsiClassType) {\n        PsiClass refClass = ((PsiClassType) type).resolve();\n        if (refClass != null){\n          int length = refClass.getName().length();\n          return addImportForClass(file, startOffset, startOffset + length, refClass);\n        }\n      }\n    }\n    else if (o instanceof PsiMethod){\n      PsiMethod method = (PsiMethod)o;\n      if (method.isConstructor()){\n        PsiClass aClass = (PsiClass)item.getAttribute(LookupItem.CONTAINING_CLASS_ATTR);\n        if (aClass == null){\n          aClass = method.getContainingClass();\n        }\n        if (aClass != null){\n          int length = method.getName().length();\n          return addImportForClass(file, startOffset, startOffset + length, aClass);\n        }\n      }\n    }\n\n    return startOffset;\n  }","commit_id":"bdb6da6b3623b2dfdc8e0d8f8401edf13ea466ac","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void addImportForItem(PsiFile file, int startOffset, LookupItem item) throws IncorrectOperationException {\n    PsiDocumentManager.getInstance(file.getProject()).commitAllDocuments();\n\n    Object o = item.getObject();\n    if (o instanceof PsiClass){\n      PsiClass aClass = (PsiClass)o;\n      int length = aClass.getName().length();\n      addImportForClass(file, startOffset, startOffset + length, aClass);\n    }\n    else if (o instanceof PsiType){\n      PsiType type = ((PsiType)o).getDeepComponentType();\n      if (type instanceof PsiClassType) {\n        PsiClass refClass = ((PsiClassType) type).resolve();\n        if (refClass != null){\n          int length = refClass.getName().length();\n          addImportForClass(file, startOffset, startOffset + length, refClass);\n        }\n      }\n    }\n    else if (o instanceof PsiMethod){\n      PsiMethod method = (PsiMethod)o;\n      if (method.isConstructor()){\n        PsiClass aClass = (PsiClass)item.getAttribute(LookupItem.CONTAINING_CLASS_ATTR);\n        if (aClass == null){\n          aClass = method.getContainingClass();\n        }\n        if (aClass != null){\n          int length = method.getName().length();\n          addImportForClass(file, startOffset, startOffset + length, aClass);\n        }\n      }\n    }\n  }","id":65109,"modified_method":"private static int addImportForItem(PsiFile file, int startOffset, LookupItem item) throws IncorrectOperationException {\n    PsiDocumentManager.getInstance(file.getProject()).commitAllDocuments();\n\n    Object o = item.getObject();\n    if (o instanceof PsiClass){\n      PsiClass aClass = (PsiClass)o;\n      int length = aClass.getName().length();\n      return addImportForClass(file, startOffset, startOffset + length, aClass);\n    }\n    else if (o instanceof PsiType){\n      PsiType type = ((PsiType)o).getDeepComponentType();\n      if (type instanceof PsiClassType) {\n        PsiClass refClass = ((PsiClassType) type).resolve();\n        if (refClass != null){\n          int length = refClass.getName().length();\n          return addImportForClass(file, startOffset, startOffset + length, refClass);\n        }\n      }\n    }\n    else if (o instanceof PsiMethod){\n      PsiMethod method = (PsiMethod)o;\n      if (method.isConstructor()){\n        PsiClass aClass = (PsiClass)item.getAttribute(LookupItem.CONTAINING_CLASS_ATTR);\n        if (aClass == null){\n          aClass = method.getContainingClass();\n        }\n        if (aClass != null){\n          int length = method.getName().length();\n          return addImportForClass(file, startOffset, startOffset + length, aClass);\n        }\n      }\n    }\n\n    return startOffset;\n  }","commit_id":"b0196ecf353f1e7cfa421e5ec5426c8fe7f26266","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean handleInsertInner(final CompletionContext context,\n                           int startOffset, LookupData data, LookupItem item,\n                           final boolean signatureSelected, final char completionChar) {\n\n    LOG.assertTrue(CommandProcessor.getInstance().getCurrentCommand() != null);\n    PsiDocumentManager.getInstance(context.project).commitDocument(context.editor.getDocument());\n    myContext = context;\n    myStartOffset = startOffset;\n    myLookupData = data;\n    myLookupItem = item;\n\n    myProject = myContext.project;\n    myFile = myContext.file;\n    myEditor = myContext.editor;\n    myDocument = myEditor.getDocument();\n\n    if (isTemplateToBeCompleted(myLookupItem)){\n        handleTemplate(context, signatureSelected, completionChar);\n      // we could not clear in this case since handleTemplate has templateFinished lisntener that works\n      // with e.g. myLookupItem\n        return false;\n    }\n\n    int tailType = getTailType(completionChar);\n\n    adjustContextAfterLookupStringInsertion();\n    myState = new InsertHandlerState(myContext.selectionEndOffset, myContext.selectionEndOffset);\n\n    final boolean overwrite = completionChar != 0\n      ? completionChar == Lookup.REPLACE_SELECT_CHAR\n      : myLookupItem.getAttribute(LookupItem.OVERWRITE_ON_AUTOCOMPLETE_ATTR) != null;\n\n\n    final boolean needLeftParenth = isToInsertParenth(tailType);\n    final boolean hasParams = needLeftParenth && hasParams(signatureSelected);\n    tailType = modifyTailTypeBasedOnMethodReturnType(signatureSelected, needLeftParenth, hasParams, tailType);\n\n    if (overwrite)\n      removeEndOfIdentifier(needLeftParenth && hasParams);\n    else if(myContext.identifierEndOffset != myContext.selectionEndOffset)\n      context.resetParensInfo();\n\n    handleParenses(hasParams, needLeftParenth, tailType);\n    handleBrackets();\n\n    RangeMarker saveMaker = null;\n    final boolean generateAnonymousBody = myLookupItem.getAttribute(LookupItem.GENERATE_ANONYMOUS_BODY_ATTR) != null;\n    if (generateAnonymousBody){\n      saveMaker = myDocument.createRangeMarker(myState.caretOffset, myState.caretOffset);\n      myDocument.insertString(myState.tailOffset, \"{}\");\n      myState.caretOffset = myState.tailOffset + 1;\n      myState.tailOffset += 2;\n    }\n\n    myState.caretOffset = processTail(tailType, myState.caretOffset, myState.tailOffset);\n\n    myEditor.getCaretModel().moveToOffset(myState.caretOffset);\n    myEditor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n    myEditor.getSelectionModel().removeSelection();\n\n    try{\n      addImportForItem(myFile, myStartOffset, myLookupItem);\n    }\n    catch(IncorrectOperationException e){\n      LOG.error(e);\n    }\n\n    if (needLeftParenth && hasParams){\n      // Invoke parameters popup\n      final PsiMethod method = myLookupItem.getObject() instanceof PsiMethod ? (PsiMethod)myLookupItem.getObject() : null;\n      AutoPopupController.getInstance(myProject).autoPopupParameterInfo(myEditor, signatureSelected ? method : null);\n    }\n\n    if (tailType == TailType.DOT){\n      AutoPopupController.getInstance(myProject).autoPopupMemberLookup(myEditor);\n    }\n\n    if (generateAnonymousBody){\n      generateAnonymousBody();\n      if (hasParams){\n        int offset = saveMaker.getStartOffset();\n        myEditor.getCaretModel().moveToOffset(offset);\n        myEditor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n        myEditor.getSelectionModel().removeSelection();\n      }\n      return false;\n    }\n    \n    if (insertingAnnotation()) {\n      final Document document = context.editor.getDocument();\n      PsiDocumentManager.getInstance(context.project).commitDocument(document);\n      final PsiElement elementAt = myFile.findElementAt(myStartOffset);\n      final PsiElement prevSibling = elementAt != null? elementAt.getParent().getPrevSibling():null;\n      \n      if(prevSibling == null || !\"@\".equals(prevSibling.getText())) {\n        document.insertString(myStartOffset, \"@\");\n      }\n    }\n    return true;\n  }","id":65110,"modified_method":"public boolean handleInsertInner(CompletionContext context,\n                           int startOffset, LookupData data, LookupItem item,\n                           final boolean signatureSelected, final char completionChar) {\n\n    LOG.assertTrue(CommandProcessor.getInstance().getCurrentCommand() != null);\n    PsiDocumentManager.getInstance(context.project).commitDocument(context.editor.getDocument());\n    myContext = context;\n    myStartOffset = startOffset;\n    myLookupData = data;\n    myLookupItem = item;\n\n    myProject = myContext.project;\n    myFile = myContext.file;\n    myEditor = myContext.editor;\n    myDocument = myEditor.getDocument();\n\n    if (isTemplateToBeCompleted(myLookupItem)){\n        handleTemplate(context, signatureSelected, completionChar);\n      // we could not clear in this case since handleTemplate has templateFinished lisntener that works\n      // with e.g. myLookupItem\n        return false;\n    }\n\n    int tailType = getTailType(completionChar);\n\n    adjustContextAfterLookupStringInsertion();\n    myState = new InsertHandlerState(myContext.selectionEndOffset, myContext.selectionEndOffset);\n\n    final boolean overwrite = completionChar != 0\n      ? completionChar == Lookup.REPLACE_SELECT_CHAR\n      : myLookupItem.getAttribute(LookupItem.OVERWRITE_ON_AUTOCOMPLETE_ATTR) != null;\n\n\n    final boolean needLeftParenth = isToInsertParenth(tailType);\n    final boolean hasParams = needLeftParenth && hasParams(signatureSelected);\n    tailType = modifyTailTypeBasedOnMethodReturnType(signatureSelected, needLeftParenth, hasParams, tailType);\n\n    if (overwrite)\n      removeEndOfIdentifier(needLeftParenth && hasParams);\n    else if(myContext.identifierEndOffset != myContext.selectionEndOffset)\n      context.resetParensInfo();\n\n    handleParenses(hasParams, needLeftParenth, tailType);\n    handleBrackets();\n\n    RangeMarker saveMaker = null;\n    final boolean generateAnonymousBody = myLookupItem.getAttribute(LookupItem.GENERATE_ANONYMOUS_BODY_ATTR) != null;\n    if (generateAnonymousBody){\n      saveMaker = myDocument.createRangeMarker(myState.caretOffset, myState.caretOffset);\n      myDocument.insertString(myState.tailOffset, \"{}\");\n      myState.caretOffset = myState.tailOffset + 1;\n      myState.tailOffset += 2;\n    }\n\n    myState.caretOffset = processTail(tailType, myState.caretOffset, myState.tailOffset);\n\n    myEditor.getCaretModel().moveToOffset(myState.caretOffset);\n    myEditor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n    myEditor.getSelectionModel().removeSelection();\n\n    try{\n      myStartOffset = addImportForItem(myFile, myStartOffset, myLookupItem);\n    }\n    catch(IncorrectOperationException e){\n      LOG.error(e);\n    }\n\n    if (needLeftParenth && hasParams){\n      // Invoke parameters popup\n      final PsiMethod method = myLookupItem.getObject() instanceof PsiMethod ? (PsiMethod)myLookupItem.getObject() : null;\n      AutoPopupController.getInstance(myProject).autoPopupParameterInfo(myEditor, signatureSelected ? method : null);\n    }\n\n    if (tailType == TailType.DOT){\n      AutoPopupController.getInstance(myProject).autoPopupMemberLookup(myEditor);\n    }\n\n    if (generateAnonymousBody){\n      generateAnonymousBody();\n      if (hasParams){\n        int offset = saveMaker.getStartOffset();\n        myEditor.getCaretModel().moveToOffset(offset);\n        myEditor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n        myEditor.getSelectionModel().removeSelection();\n      }\n      return false;\n    }\n\n    if (insertingAnnotation()) {\n      final Document document = context.editor.getDocument();\n      PsiDocumentManager.getInstance(context.project).commitDocument(document);\n      final PsiElement elementAt = myFile.findElementAt(myStartOffset - 1 );\n\n      if(!\"@\".equals(elementAt.getText())) {\n        document.insertString(myStartOffset, \"@\");\n      }\n    }\n    return true;\n  }","commit_id":"b0196ecf353f1e7cfa421e5ec5426c8fe7f26266","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void addImportForClass(PsiFile file, int startOffset, int endOffset, PsiClass aClass) throws IncorrectOperationException {\n    SmartPsiElementPointer pointer = SmartPointerManager.getInstance(file.getProject()).createSmartPsiElementPointer(aClass);\n    LOG.assertTrue(CommandProcessor.getInstance().getCurrentCommand() != null);\n    LOG.assertTrue(ApplicationManager.getApplication().getCurrentWriteAction(null) != null);\n\n    final PsiManager manager = file.getManager();\n    final PsiResolveHelper helper = manager.getResolveHelper();\n\n    final Document document = PsiDocumentManager.getInstance(manager.getProject()).getDocument(file);\n\n    CharSequence chars = document.getCharsSequence();\n    int length = document.getTextLength();\n    PsiElement element = file.findElementAt(startOffset);\n    String refText = chars.subSequence(startOffset, endOffset).toString();\n    PsiClass refClass = helper.resolveReferencedClass(refText, element);\n    if (refClass != null && (refClass.getQualifiedName() == null/* local classes and parameters*/\n                             || manager.areElementsEquivalent(aClass, refClass))) return;\n    boolean insertSpace = endOffset < length && Character.isJavaIdentifierPart(chars.charAt(endOffset));\n\n    if (insertSpace){\n      document.insertString(endOffset, \" \");\n    }\n    String name = aClass.getName();\n    document.replaceString(startOffset, endOffset, name);\n    endOffset = startOffset + name.length();\n\n    PsiDocumentManager.getInstance(manager.getProject()).commitAllDocuments();\n\n    element = file.findElementAt(startOffset);\n    if (element instanceof PsiIdentifier){\n      PsiElement parent = element.getParent();\n      if (parent instanceof PsiJavaCodeReferenceElement && !((PsiJavaCodeReferenceElement)parent).isQualified()){\n        PsiJavaCodeReferenceElement ref = (PsiJavaCodeReferenceElement)parent;\n        final PsiElement pointerElement = pointer.getElement();\n        if(pointerElement instanceof PsiClass){\n          if (!(ref instanceof PsiImportStaticReferenceElement)) {\n            PsiJavaCodeReferenceElement newRef = (PsiJavaCodeReferenceElement)ref.bindToElement(pointerElement);\n            endOffset = newRef.getTextRange().getEndOffset();\n          }\n          else {\n            final PsiImportStaticStatement statement = ((PsiImportStaticReferenceElement)ref).bindToTargetClass((PsiClass) pointerElement);\n            endOffset = statement.getTextRange().getEndOffset();\n          }\n        }\n      }\n    }\n\n    if (insertSpace){\n      document.deleteString(endOffset, endOffset + 1);\n    }\n  }","id":65111,"modified_method":"private static int addImportForClass(PsiFile file, int startOffset, int endOffset, PsiClass aClass) throws IncorrectOperationException {\n    SmartPsiElementPointer pointer = SmartPointerManager.getInstance(file.getProject()).createSmartPsiElementPointer(aClass);\n    LOG.assertTrue(CommandProcessor.getInstance().getCurrentCommand() != null);\n    LOG.assertTrue(ApplicationManager.getApplication().getCurrentWriteAction(null) != null);\n\n    final PsiManager manager = file.getManager();\n    final PsiResolveHelper helper = manager.getResolveHelper();\n\n    final Document document = PsiDocumentManager.getInstance(manager.getProject()).getDocument(file);\n\n    CharSequence chars = document.getCharsSequence();\n    int length = document.getTextLength();\n    int newStartOffset = startOffset;\n\n    PsiElement element = file.findElementAt(startOffset);\n    String refText = chars.subSequence(startOffset, endOffset).toString();\n    PsiClass refClass = helper.resolveReferencedClass(refText, element);\n    if (refClass != null && (refClass.getQualifiedName() == null/* local classes and parameters*/\n                             || manager.areElementsEquivalent(aClass, refClass))) return newStartOffset;\n    boolean insertSpace = endOffset < length && Character.isJavaIdentifierPart(chars.charAt(endOffset));\n\n    if (insertSpace){\n      document.insertString(endOffset, \" \");\n    }\n    String name = aClass.getName();\n    document.replaceString(startOffset, endOffset, name);\n    endOffset = startOffset + name.length();\n\n    PsiDocumentManager.getInstance(manager.getProject()).commitAllDocuments();\n\n    element = file.findElementAt(startOffset);\n    if (element instanceof PsiIdentifier){\n      PsiElement parent = element.getParent();\n      if (parent instanceof PsiJavaCodeReferenceElement && !((PsiJavaCodeReferenceElement)parent).isQualified()){\n        PsiJavaCodeReferenceElement ref = (PsiJavaCodeReferenceElement)parent;\n        final PsiElement pointerElement = pointer.getElement();\n        if(pointerElement instanceof PsiClass){\n          if (!(ref instanceof PsiImportStaticReferenceElement)) {\n            PsiJavaCodeReferenceElement newRef = (PsiJavaCodeReferenceElement)ref.bindToElement(pointerElement);\n            final TextRange textRange = newRef.getTextRange();\n            endOffset = textRange.getEndOffset();\n            newStartOffset = textRange.getStartOffset();\n          }\n          else {\n            final PsiImportStaticStatement statement = ((PsiImportStaticReferenceElement)ref).bindToTargetClass((PsiClass) pointerElement);\n            final TextRange textRange = statement.getTextRange();\n            endOffset = textRange.getEndOffset();\n            newStartOffset = textRange.getStartOffset();\n          }\n        }\n      }\n    }\n\n    if (insertSpace){\n      document.deleteString(endOffset, endOffset + 1);\n    }\n\n    return newStartOffset;\n  }","commit_id":"b0196ecf353f1e7cfa421e5ec5426c8fe7f26266","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected SchemaFactory createSchemaFactory() {\n        SchemaFactory factory = SchemaFactory.newInstance(schemaLanguage);\n        if (getResourceResolver() != null) {\n            factory.setResourceResolver(getResourceResolver());\n        }\n        return factory;\n    }","id":65112,"modified_method":"protected SchemaFactory createSchemaFactory() {\n        return schemaReader.createSchemaFactory();\n    }","commit_id":"115cb3affbe2b0a866f7b686035b5b73626b0dca","url":"https://github.com/apache/camel"},{"original_method":"public void setSchemaAsByteArray(byte[] schemaAsByteArray) {\n        this.schemaAsByteArray = schemaAsByteArray;\n    }","id":65113,"modified_method":"public void setSchemaAsByteArray(byte[] schemaAsByteArray) {\n        schemaReader.setSchemaAsByteArray(schemaAsByteArray);\n    }","commit_id":"115cb3affbe2b0a866f7b686035b5b73626b0dca","url":"https://github.com/apache/camel"},{"original_method":"public byte[] getSchemaAsByteArray() {\n        return schemaAsByteArray;\n    }","id":65114,"modified_method":"public byte[] getSchemaAsByteArray() {\n        return schemaReader.getSchemaAsByteArray();\n    }","commit_id":"115cb3affbe2b0a866f7b686035b5b73626b0dca","url":"https://github.com/apache/camel"},{"original_method":"public void setResourceResolver(LSResourceResolver resourceResolver) {\n        this.resourceResolver = resourceResolver;\n    }","id":65115,"modified_method":"public void setResourceResolver(LSResourceResolver resourceResolver) {\n        schemaReader.setResourceResolver(resourceResolver);\n    }","commit_id":"115cb3affbe2b0a866f7b686035b5b73626b0dca","url":"https://github.com/apache/camel"},{"original_method":"public void setSchemaLanguage(String schemaLanguage) {\n        this.schemaLanguage = schemaLanguage;\n    }","id":65116,"modified_method":"public void setSchemaLanguage(String schemaLanguage) {\n        schemaReader.setSchemaLanguage(schemaLanguage);\n    }","commit_id":"115cb3affbe2b0a866f7b686035b5b73626b0dca","url":"https://github.com/apache/camel"},{"original_method":"public void setSchemaUrl(URL schemaUrl) {\n        this.schemaUrl = schemaUrl;\n    }","id":65117,"modified_method":"public void setSchemaUrl(URL schemaUrl) {\n        schemaReader.setSchemaUrl(schemaUrl);\n    }","commit_id":"115cb3affbe2b0a866f7b686035b5b73626b0dca","url":"https://github.com/apache/camel"},{"original_method":"protected Source createSchemaSource() throws IOException {\n        throw new IllegalArgumentException(\"You must specify either a schema, schemaFile, schemaSource or schemaUrl property\");\n    }","id":65118,"modified_method":"protected Source createSchemaSource() throws IOException {\n        return schemaReader.createSchemaSource();\n    }","commit_id":"115cb3affbe2b0a866f7b686035b5b73626b0dca","url":"https://github.com/apache/camel"},{"original_method":"public URL getSchemaUrl() {\n        return schemaUrl;\n    }","id":65119,"modified_method":"public URL getSchemaUrl() {\n        return schemaReader.getSchemaUrl();\n    }","commit_id":"115cb3affbe2b0a866f7b686035b5b73626b0dca","url":"https://github.com/apache/camel"},{"original_method":"public void setSchema(Schema schema) {\n        this.schema = schema;\n    }","id":65120,"modified_method":"public void setSchema(Schema schema) {\n        schemaReader.setSchema(schema);\n    }","commit_id":"115cb3affbe2b0a866f7b686035b5b73626b0dca","url":"https://github.com/apache/camel"},{"original_method":"public Schema getSchema() throws IOException, SAXException {\n        if (schema == null) {\n            synchronized (this) {\n                if (schema == null) {\n                    schema = createSchema();\n                }\n            }\n        }\n        return schema;\n    }","id":65121,"modified_method":"public Schema getSchema() throws IOException, SAXException {\n        return schemaReader.getSchema();\n    }","commit_id":"115cb3affbe2b0a866f7b686035b5b73626b0dca","url":"https://github.com/apache/camel"},{"original_method":"public void setSchemaFactory(SchemaFactory schemaFactory) {\n        this.schemaFactory = schemaFactory;\n    }","id":65122,"modified_method":"public void setSchemaFactory(SchemaFactory schemaFactory) {\n        schemaReader.setSchemaFactory(schemaFactory);\n    }","commit_id":"115cb3affbe2b0a866f7b686035b5b73626b0dca","url":"https://github.com/apache/camel"},{"original_method":"public String getSchemaLanguage() {\n        return schemaLanguage;\n    }","id":65123,"modified_method":"public String getSchemaLanguage() {\n        return schemaReader.getSchemaLanguage();\n    }","commit_id":"115cb3affbe2b0a866f7b686035b5b73626b0dca","url":"https://github.com/apache/camel"},{"original_method":"public void setSchemaSource(Source schemaSource) {\n        this.schemaSource = schemaSource;\n    }","id":65124,"modified_method":"public void setSchemaSource(Source schemaSource) {\n        schemaReader.setSchemaSource(schemaSource);\n    }","commit_id":"115cb3affbe2b0a866f7b686035b5b73626b0dca","url":"https://github.com/apache/camel"},{"original_method":"public SchemaFactory getSchemaFactory() {\n        if (schemaFactory == null) {\n            synchronized (this) {\n                if (schemaFactory == null) {\n                    schemaFactory = createSchemaFactory();\n                }\n            }\n        }\n        return schemaFactory;\n    }","id":65125,"modified_method":"public SchemaFactory getSchemaFactory() {\n        return schemaReader.getSchemaFactory();\n    }","commit_id":"115cb3affbe2b0a866f7b686035b5b73626b0dca","url":"https://github.com/apache/camel"},{"original_method":"public Source getSchemaSource() throws IOException {\n        if (schemaSource == null) {\n            schemaSource = createSchemaSource();\n        }\n        return schemaSource;\n    }","id":65126,"modified_method":"public Source getSchemaSource() throws IOException {\n        return schemaReader.getSchemaSource();\n    }","commit_id":"115cb3affbe2b0a866f7b686035b5b73626b0dca","url":"https://github.com/apache/camel"},{"original_method":"protected Schema createSchema() throws SAXException, IOException {\n        SchemaFactory factory = getSchemaFactory();\n\n        URL url = getSchemaUrl();\n        if (url != null) {\n            synchronized (this) {\n                return factory.newSchema(url);\n            }\n        }\n\n        File file = getSchemaFile();\n        if (file != null) {\n            synchronized (this) {\n                return factory.newSchema(file);\n            }\n        }\n\n        byte[] bytes = getSchemaAsByteArray();\n        if (bytes != null) {\n            synchronized (this) {\n                return factory.newSchema(new StreamSource(new ByteArrayInputStream(schemaAsByteArray)));\n            }\n        }\n\n        Source source = getSchemaSource();\n        synchronized (this) {\n            return factory.newSchema(source);\n        }\n    }","id":65127,"modified_method":"protected Schema createSchema() throws SAXException, IOException {\n        return schemaReader.createSchema();\n    }","commit_id":"115cb3affbe2b0a866f7b686035b5b73626b0dca","url":"https://github.com/apache/camel"},{"original_method":"public File getSchemaFile() {\n        return schemaFile;\n    }","id":65128,"modified_method":"public File getSchemaFile() {\n        return schemaReader.getSchemaFile();\n    }","commit_id":"115cb3affbe2b0a866f7b686035b5b73626b0dca","url":"https://github.com/apache/camel"},{"original_method":"public void loadSchema() throws Exception {\n        // force loading of schema\n        schema = createSchema();\n    }","id":65129,"modified_method":"public void loadSchema() throws Exception {\n        schemaReader.loadSchema();\n    }","commit_id":"115cb3affbe2b0a866f7b686035b5b73626b0dca","url":"https://github.com/apache/camel"},{"original_method":"public LSResourceResolver getResourceResolver() {\n        return resourceResolver;\n    }","id":65130,"modified_method":"public LSResourceResolver getResourceResolver() {\n        return schemaReader.getResourceResolver();\n    }","commit_id":"115cb3affbe2b0a866f7b686035b5b73626b0dca","url":"https://github.com/apache/camel"},{"original_method":"public void setSchemaFile(File schemaFile) {\n        this.schemaFile = schemaFile;\n    }","id":65131,"modified_method":"public void setSchemaFile(File schemaFile) {\n        schemaReader.setSchemaFile(schemaFile);\n    }","commit_id":"115cb3affbe2b0a866f7b686035b5b73626b0dca","url":"https://github.com/apache/camel"},{"original_method":"protected void configureValidator(ValidatingProcessor validator) throws Exception {\n        if (resourceResolver != null) {\n            validator.setResourceResolver(resourceResolver);\n        } else {\n            validator.setResourceResolver(new DefaultLSResourceResolver(getCamelContext(), resourceUri));\n        }\n        validator.setSchemaLanguage(getSchemaLanguage());\n        validator.setSchemaFactory(getSchemaFactory());\n        validator.setErrorHandler(getErrorHandler());\n        validator.setUseDom(isUseDom());\n        validator.setUseSharedSchema(isUseSharedSchema());\n        validator.setFailOnNullBody(isFailOnNullBody());\n        validator.setFailOnNullHeader(isFailOnNullHeader());\n        validator.setHeaderName(getHeaderName());\n    }","id":65132,"modified_method":"protected void configureValidator(ValidatingProcessor validator) throws Exception {\n        validator.setErrorHandler(getErrorHandler());\n        validator.setUseDom(isUseDom());\n        validator.setUseSharedSchema(isUseSharedSchema());\n        validator.setFailOnNullBody(isFailOnNullBody());\n        validator.setFailOnNullHeader(isFailOnNullHeader());\n        validator.setHeaderName(getHeaderName());\n    }","commit_id":"115cb3affbe2b0a866f7b686035b5b73626b0dca","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public Producer createProducer() throws Exception {\n        ValidatingProcessor validator = new ValidatingProcessor();\n\n        InputStream is = ResourceHelper.resolveMandatoryResourceAsInputStream(getCamelContext(), resourceUri);\n        byte[] bytes = null;\n        try {\n            bytes = IOConverter.toBytes(is);\n        } finally {\n            // and make sure to close the input stream after the schema has been loaded\n            IOHelper.close(is);\n        }\n\n        validator.setSchemaAsByteArray(bytes);\n        LOG.debug(\"{} using schema resource: {}\", this, resourceUri);\n        configureValidator(validator);\n\n        // force loading of schema at create time otherwise concurrent\n        // processing could cause thread safe issues for the javax.xml.validation.SchemaFactory\n        validator.loadSchema();\n\n        return new ValidatorProducer(this, validator);\n    }","id":65133,"modified_method":"@Override\n    public Producer createProducer() throws Exception {\n\n        if (!schemaReaderConfigured) {\n            if (resourceResolver != null) {\n                schemaReader.setResourceResolver(resourceResolver);\n            } else {\n                schemaReader.setResourceResolver(new DefaultLSResourceResolver(getCamelContext(), resourceUri));\n            }\n            schemaReader.setSchemaLanguage(getSchemaLanguage());\n            schemaReader.setSchemaFactory(getSchemaFactory());\n            \n            byte[] bytes = readSchemaResource();\n            schemaReader.setSchemaAsByteArray(bytes);\n            LOG.debug(\"{} using schema resource: {}\", this, resourceUri);\n\n            // force loading of schema at create time otherwise concurrent\n            // processing could cause thread safe issues for the\n            // javax.xml.validation.SchemaFactory\n            schemaReader.loadSchema();\n\n            // configure only once\n            schemaReaderConfigured = true;\n        }\n\n        ValidatingProcessor validator = new ValidatingProcessor(schemaReader);\n        configureValidator(validator);\n\n        return new ValidatorProducer(this, validator);\n    }","commit_id":"115cb3affbe2b0a866f7b686035b5b73626b0dca","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void doStart() throws Exception {\n        ObjectHelper.notNull(consumer, \"Consumer\", this);\n        ObjectHelper.notNull(camelContext, \"CamelContext\", this);\n        ObjectHelper.notNull(task, \"Task\", this);\n\n        // if no existing executor provided, then create a new thread pool ourselves\n        if (scheduledExecutorService == null) {\n            // we only need one thread in the pool to schedule this task\n            this.scheduledExecutorService = getCamelContext().getExecutorServiceManager()\n                    .newScheduledThreadPool(this, consumer.getEndpoint().getEndpointUri(), 1);\n            // and we should shutdown the thread pool when no longer needed\n            this.shutdownExecutor = true;\n        }\n    }","id":65134,"modified_method":"@Override\n    protected void doStart() throws Exception {\n        ObjectHelper.notNull(consumer, \"Consumer\", this);\n        ObjectHelper.notNull(camelContext, \"CamelContext\", this);\n        ObjectHelper.notNull(task, \"Task\", this);\n\n        // if no existing executor provided, then create a new thread pool ourselves\n        if (scheduledExecutorService == null) {\n            // we only need one thread in the pool to schedule this task\n            this.scheduledExecutorService = getCamelContext().getExecutorServiceManager()\n                    .newSingleThreadScheduledExecutor(consumer, consumer.getEndpoint().getEndpointUri());\n            // and we should shutdown the thread pool when no longer needed\n            this.shutdownExecutor = true;\n        }\n    }","commit_id":"2f75b2f1bd2f23a864c2dc3c31b1badfd40cc743","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void doStart() throws Exception {\n        ObjectHelper.notEmpty(cron, \"cron\", this);\n\n        trigger = new CronTrigger(getCron(), getTimeZone());\n\n        if (taskScheduler == null) {\n            taskScheduler = new ThreadPoolTaskScheduler();\n            CamelThreadFactory tf = new CamelThreadFactory(getCamelContext().getExecutorServiceManager().getThreadNamePattern(), \"SpringScheduledPollConsumerSchedulerTask\", true);\n            taskScheduler.setThreadFactory(tf);\n            taskScheduler.afterPropertiesSet();\n            destroyTaskScheduler = true;\n        }\n\n        LOG.debug(\"Scheduling cron trigger {}\", getCron());\n        future = taskScheduler.schedule(runnable, trigger);\n    }","id":65135,"modified_method":"@Override\n    protected void doStart() throws Exception {\n        ObjectHelper.notEmpty(cron, \"cron\", this);\n\n        trigger = new CronTrigger(getCron(), getTimeZone());\n\n        if (taskScheduler == null) {\n            taskScheduler = new CamelThreadPoolTaskScheduler(getCamelContext(), consumer, consumer.getEndpoint().getEndpointUri());\n            taskScheduler.afterPropertiesSet();\n            destroyTaskScheduler = true;\n        }\n\n        LOG.debug(\"Scheduling cron trigger {}\", getCron());\n        future = taskScheduler.schedule(runnable, trigger);\n    }","commit_id":"2f75b2f1bd2f23a864c2dc3c31b1badfd40cc743","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected Exchange getFallback() {\n        if (fallbackProducer == null) {\n            return exchange;\n        }\n        try {\n            if (exchange.getException() != null) {\n                Exception exception = exchange.getException();\n                exchange.setException(null);\n                if (exception instanceof InterruptedException) {\n                    exchange.removeProperty(Exchange.ROUTE_STOP);\n                }\n            }\n            fallbackProducer.process(exchange);\n        } catch (Exception e) {\n            exchange.setException(e);\n        }\n        return exchange;\n    }","id":65136,"modified_method":"@Override\n    protected Exchange getFallback() {\n        if (fallbackEndpoint == null) {\n            return exchange;\n        }\n        try {\n            if (exchange.getException() != null) {\n                Exception exception = exchange.getException();\n                exchange.setException(null);\n                if (exception instanceof InterruptedException) {\n                    exchange.removeProperty(Exchange.ROUTE_STOP);\n                }\n            }\n            cache.doInProducer(fallbackEndpoint, exchange, exchange.getPattern(), new ProducerCallback<Exchange>() {\n                @Override\n                public Exchange doInProducer(Producer producer, Exchange exchange, ExchangePattern exchangePattern) throws Exception {\n                    try {\n                        producer.process(exchange);\n                    } catch (Exception e) {\n                        exchange.setException(e);\n                    }\n                    return exchange;\n                }\n            });\n        } catch (Exception e) {\n            exchange.setException(e);\n        }\n        return exchange;\n    }","commit_id":"09f6c50fe6898ec24927548907558debe1794eb1","url":"https://github.com/apache/camel"},{"original_method":"protected CamelHystrixCommand(Setter setter, Exchange exchange, String cacheKey, Producer runProducer, Producer fallbackProducer) {\n        super(setter);\n        this.exchange = exchange;\n        this.cacheKey = cacheKey;\n        this.runProducer = runProducer;\n        this.fallbackProducer = fallbackProducer;\n    }","id":65137,"modified_method":"protected CamelHystrixCommand(Setter setter, Exchange exchange, String cacheKey, ProducerCache cache, Endpoint runEndpoint, Endpoint fallbackEndpoint) {\n        super(setter);\n        this.exchange = exchange;\n        this.cacheKey = cacheKey;\n        this.cache = cache;\n        this.runEndpoint = runEndpoint;\n        this.fallbackEndpoint = fallbackEndpoint;\n    }","commit_id":"09f6c50fe6898ec24927548907558debe1794eb1","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected Exchange run() {\n        try {\n            runProducer.process(exchange);\n        } catch (Exception e) {\n            exchange.setException(e);\n        }\n\n        if (exchange.getException() != null) {\n            Exception exception = exchange.getException();\n            exchange.setException(null);\n            if (exception instanceof InterruptedException) {\n                exchange.removeProperty(Exchange.ROUTE_STOP);\n            }\n            throw new RuntimeException(exception.getMessage());\n        }\n        return exchange;\n    }","id":65138,"modified_method":"@Override\n    protected Exchange run() {\n        try {\n            cache.doInProducer(runEndpoint, exchange, exchange.getPattern(), new ProducerCallback<Exchange>() {\n                @Override\n                public Exchange doInProducer(Producer producer, Exchange exchange, ExchangePattern exchangePattern) throws Exception {\n                    try {\n                        producer.process(exchange);\n                    } catch (Exception e) {\n                        exchange.setException(e);\n                    }\n                    return exchange;\n                }\n            });\n        } catch (Exception e) {\n            exchange.setException(e);\n        }\n\n        if (exchange.getException() != null) {\n            Exception exception = exchange.getException();\n            exchange.setException(null);\n            if (exception instanceof InterruptedException) {\n                exchange.removeProperty(Exchange.ROUTE_STOP);\n            }\n            throw new RuntimeException(exception.getMessage());\n        }\n        return exchange;\n    }","commit_id":"09f6c50fe6898ec24927548907558debe1794eb1","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void doStop() throws Exception {\n        if (requestContext != null) {\n            requestContext.shutdown();\n        }\n        ServiceHelper.stopServices(runProducer, fallbackProducer);\n        super.doStop();\n    }","id":65139,"modified_method":"@Override\n    protected void doStop() throws Exception {\n        if (requestContext != null) {\n            requestContext.shutdown();\n        }\n        ServiceHelper.stopService(producerCache);\n        super.doStop();\n    }","commit_id":"09f6c50fe6898ec24927548907558debe1794eb1","url":"https://github.com/apache/camel"},{"original_method":"public void process(final Exchange exchange) throws Exception {\n        HystrixCommand.Setter setter = HystrixCommand.Setter.withGroupKey(\n                HystrixCommandGroupKey.Factory.asKey(exchange.getIn().getHeader(HystrixConstants.CAMEL_HYSTRIX_GROUP_KEY, configuration.getGroupKey(), String.class)));\n\n        setCommandPropertiesDefaults(setter, exchange);\n        setThreadPoolPropertiesDefaults(setter, exchange);\n\n        CamelHystrixCommand camelHystrixCommand = new CamelHystrixCommand(setter, exchange, getCacheKey(exchange), runProducer, fallbackProducer);\n\n        checkRequestContextPresent(exchange);\n        clearCache(camelHystrixCommand.getCommandKey(), exchange);\n        camelHystrixCommand.execute();\n\n        if (configuration.isMetrics()) {\n            populateWithMetrics(exchange, camelHystrixCommand);\n        }\n    }","id":65140,"modified_method":"public void process(final Exchange exchange) throws Exception {\n        HystrixCommand.Setter setter = HystrixCommand.Setter.withGroupKey(\n                HystrixCommandGroupKey.Factory.asKey(exchange.getIn().getHeader(HystrixConstants.CAMEL_HYSTRIX_GROUP_KEY, configuration.getGroupKey(), String.class)));\n\n        setCommandPropertiesDefaults(setter, exchange);\n        setThreadPoolPropertiesDefaults(setter, exchange);\n\n        // lookup the endpoints to use, which can be overridden from headers\n        String run = exchange.getIn().getHeader(HystrixConstants.CAMEL_HYSTRIX_RUN_ENDPOINT, configuration.getRunEndpoint(), String.class);\n        String fallback = exchange.getIn().getHeader(HystrixConstants.CAMEL_HYSTRIX_FALLBACK_ENDPOINT, configuration.getFallbackEndpoint(), String.class);\n        Endpoint runEndpoint = exchange.getContext().getEndpoint(run);\n        Endpoint fallbackEndpoint = fallback != null ? exchange.getContext().getEndpoint(fallback) : null;\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Run endpoint: {}\", runEndpoint);\n            log.debug(\"Fallback endpoint: {}\", fallbackEndpoint);\n        }\n\n        CamelHystrixCommand camelHystrixCommand = new CamelHystrixCommand(setter, exchange, getCacheKey(exchange), producerCache, runEndpoint, fallbackEndpoint);\n\n        checkRequestContextPresent(exchange);\n        clearCache(camelHystrixCommand.getCommandKey(), exchange);\n        camelHystrixCommand.execute();\n\n        if (configuration.isMetrics()) {\n            populateWithMetrics(exchange, camelHystrixCommand);\n        }\n    }","commit_id":"09f6c50fe6898ec24927548907558debe1794eb1","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void doStart() throws Exception {\n        // setup the run and fallback producers\n        Endpoint runEndpoint = getEndpoint().getCamelContext().getEndpoint(configuration.getRunEndpoint());\n        Endpoint fallbackEndpoint = null;\n        if (ObjectHelper.isNotEmpty(configuration.getFallbackEndpoint())) {\n            fallbackEndpoint = getEndpoint().getCamelContext().getEndpoint(configuration.getFallbackEndpoint());\n        }\n\n        if (fallbackEndpoint != null) {\n            log.debug(\"Endpoint run: {}, fallback: {}\", runEndpoint, fallbackEndpoint);\n        } else {\n            log.debug(\"Endpoint run: {}\", runEndpoint);\n        }\n\n        // start endpoints before creating producer\n        ServiceHelper.startServices(runEndpoint, fallbackEndpoint);\n        runProducer = runEndpoint.createProducer();\n        fallbackProducer = fallbackEndpoint != null ? fallbackEndpoint.createProducer() : null;\n\n        // start producers\n        ServiceHelper.startServices(runProducer, fallbackProducer);\n\n        if (configuration.getInitializeRequestContext() != null && configuration.getInitializeRequestContext()) {\n            requestContext = HystrixRequestContext.initializeContext();\n        }\n        super.doStart();\n    }","id":65141,"modified_method":"@Override\n    protected void doStart() throws Exception {\n        // setup the producer cache\n        producerCache = new ProducerCache(this, getEndpoint().getCamelContext());\n        ServiceHelper.startService(producerCache);\n\n        if (configuration.getInitializeRequestContext() != null && configuration.getInitializeRequestContext()) {\n            requestContext = HystrixRequestContext.initializeContext();\n        }\n        super.doStart();\n    }","commit_id":"09f6c50fe6898ec24927548907558debe1794eb1","url":"https://github.com/apache/camel"},{"original_method":"public Exchange createExchange(Exchange exchange) {\n        Class<Exchange> exchangeType = getExchangeType();\n        if (exchangeType != null) {\n            if (exchangeType.isInstance(exchange)) {\n                return exchangeType.cast(exchange);\n            }\n        }\n        Exchange answer = createExchange();\n        answer.copyFrom(exchange);\n        return answer;\n    }","id":65142,"modified_method":"public Exchange createExchange(Exchange exchange) {\n        Class<Exchange> exchangeType = getExchangeType();\n        if (exchangeType != null) {\n            if (exchangeType.isInstance(exchange)) {\n                return exchangeType.cast(exchange);\n            }\n        }\n        return exchange.copy();\n    }","commit_id":"e35e7878a7bf9e71c3a9243ab3ee58bca4e4ad17","url":"https://github.com/apache/camel"},{"original_method":"public DefaultExchange(Exchange parent) {\n        this(parent.getContext(), parent.getPattern());\n        this.unitOfWork = parent.getUnitOfWork();\n        this.fromEndpoint = parent.getFromEndpoint();\n    }","id":65143,"modified_method":"public DefaultExchange(Exchange parent) {\n        this(parent.getContext(), parent.getPattern());\n        this.fromEndpoint = parent.getFromEndpoint();\n        this.unitOfWork = parent.getUnitOfWork();\n    }","commit_id":"e35e7878a7bf9e71c3a9243ab3ee58bca4e4ad17","url":"https://github.com/apache/camel"},{"original_method":"public DefaultExchange(Endpoint fromEndpoint, ExchangePattern pattern) {\n        this.context = fromEndpoint.getCamelContext();\n        this.fromEndpoint = fromEndpoint;\n        this.pattern = pattern;\n    }","id":65144,"modified_method":"public DefaultExchange(Endpoint fromEndpoint, ExchangePattern pattern) {\n        this(fromEndpoint.getCamelContext(), pattern);\n        this.fromEndpoint = fromEndpoint;\n    }","commit_id":"e35e7878a7bf9e71c3a9243ab3ee58bca4e4ad17","url":"https://github.com/apache/camel"},{"original_method":"public Exchange copy() {\n        Exchange exchange = new DefaultExchange(this);\n        exchange.copyFrom(this);\n        return exchange;\n    }","id":65145,"modified_method":"public Exchange copy() {\n        DefaultExchange exchange = new DefaultExchange(this);\n\n        exchange.setProperties(safeCopy(getProperties()));\n        safeCopy(exchange.getIn(), getIn());\n        if (hasOut()) {\n            safeCopy(exchange.getOut(), getOut());\n        }\n        exchange.setException(getException());\n        return exchange;\n    }","commit_id":"e35e7878a7bf9e71c3a9243ab3ee58bca4e4ad17","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Prepare the execution of the transformation.\n     * @param arguments the arguments to use for this transformation\n     * @return true if the execution preparation went well, false if an error occurred.\n     */\n    public boolean prepareExecution(String[] arguments)\n    {\n\t\tRowSet    rs;\n\t\tint    nroutput;\n\t\tint    nrcopies;\n\t\tint    prevcopies;\n\t\tint    nextcopies;\n\n\t\tstartDate = null;\n\n\t\t/*\n\t\t * Set the arguments on the transformation...\n\t\t */\n\t\ttransMeta.setArguments(arguments);\n\n\t\t/* OK, see if we need to capture the logging into a String and\n\t\t * then put it in a database field later on.\n\t\t * From here until the execution is finished, the log will be captured.\n\t\t *\n\t\t */\n\t\tif (transMeta.isLogfieldUsed())\n\t\t{\n\t\t\tlog.startStringCapture();\n\t\t\tlog.setString(Messages.getString(\"Trans.Log.Start\")+Const.CR); //$NON-NLS-1$\n\t\t}\n\n\t\tif (transMeta.getName()==null)\n\t\t{\n\t\t\tif (transMeta.getFilename()!=null)\n\t\t\t{\n\t\t\t\tlog.logMinimal(toString(), Messages.getString(\"Trans.Log.DispacthingStartedForFilename\",transMeta.getFilename())); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog.logMinimal(toString(), Messages.getString(\"Trans.Log.DispacthingStartedForTransformation\",transMeta.getName())); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t}\n\n\t\tif (transMeta.getArguments()!=null)\n\t\t{\n\t\t\tlog.logMinimal(toString(), Messages.getString(\"Trans.Log.NumberOfArgumentsDetected\", String.valueOf(transMeta.getArguments().length) )); //$NON-NLS-1$\n\t\t}\n\n\t\tif (isSafeModeEnabled())\n\t\t{\n\t\t\tlog.logBasic(toString(), Messages.getString(\"Trans.Log.SafeModeIsEnabled\",transMeta.getName())); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t}\n\n\t\tif (getReplayDate() != null) {\n\t\t\tSimpleDateFormat df = new SimpleDateFormat(REPLAY_DATE_FORMAT);\n\t\t\tlog.logBasic(toString(), Messages.getString(\"Trans.Log.ThisIsAReplayTransformation\") //$NON-NLS-1$\n\t\t\t\t\t+ df.format(getReplayDate()));\n\t\t} else {\n\t\t\tlog.logBasic(toString(), Messages.getString(\"Trans.Log.ThisIsNotAReplayTransformation\")); //$NON-NLS-1$\n\t\t}\n\n\t\tsteps\t = new ArrayList();\n\t\trowsets\t = new ArrayList();\n\n\t\t//\n\t\t// Sort the steps & hops for visual pleasure...\n\t\t//\n\t\tif (isMonitored() && transMeta.nrSteps()<10)\n\t\t{\n\t\t\ttransMeta.sortStepsNatural();\n\t\t\ttransMeta.sortHopsNatural();\n\t\t}\n\n\t\tArrayList hopsteps=transMeta.getTransHopSteps(false);\n\n\t\tlog.logDetailed(toString(), Messages.getString(\"Trans.Log.FoundDefferentSteps\",String.valueOf(hopsteps.size())));\t //$NON-NLS-1$ //$NON-NLS-2$\n\t\tlog.logDetailed(toString(), Messages.getString(\"Trans.Log.AllocatingRowsets\")); //$NON-NLS-1$\n\n\t\t// First allocate all the rowsets required!\n\t\tfor (int i=0;i<hopsteps.size();i++)\n\t\t{\n\t\t\tStepMeta stepMeta=(StepMeta)hopsteps.get(i);\n\t\t\tlog.logDetailed(toString(), Messages.getString(\"Trans.Log.AllocateingRowsetsForStep\",String.valueOf(i),stepMeta.getName())); //$NON-NLS-1$ //$NON-NLS-2$\n\n\t\t\tnroutput = transMeta.findNrNextSteps(stepMeta);\n\n\t\t\tfor (int n=0;n<nroutput;n++)\n\t\t\t{\n\t\t\t\t// What's the next step?\n\t\t\t\tStepMeta nsi = transMeta.findNextStep(stepMeta, n);\n\n\t\t\t\t// How many times do we start the target step?\n\t\t\t\tnextcopies=nsi.getCopies();\n\t\t\t\tprevcopies=stepMeta.getCopies();\n\t\t\t\tlog.logDetailed(toString(), Messages.getString(\"Trans.Log.copiesInfo\",String.valueOf(prevcopies),String.valueOf(nextcopies))); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\tint disptype;\n\t\t\t\t     if (prevcopies==1 && nextcopies==1) { disptype=TYPE_DISP_1_1; nrcopies = 1; }\n\t\t\t\telse if (prevcopies==1 && nextcopies >1) { disptype=TYPE_DISP_1_N; nrcopies = nextcopies; }\n\t\t\t\telse if (prevcopies >1 && nextcopies==1) { disptype=TYPE_DISP_N_1; nrcopies = prevcopies; }\n\t\t\t\telse if (prevcopies==nextcopies)         { disptype=TYPE_DISP_N_N; nrcopies = nextcopies; } // > 1!\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlog.logError(toString(), Messages.getString(\"Trans.Log.AllowedRelationships\")); //$NON-NLS-1$\n\t\t\t\t\tlog.logError(toString(), Messages.getString(\"Trans.Log.CannotHaveXYRelationships\")); //$NON-NLS-1$\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// At least run once...\n\t\t\t\t//\n\t\t\t\tfor (int c=0;c<nrcopies;c++)\n\t\t\t\t{\n\t\t\t\t\trs=new RowSet(transMeta.getSizeRowset());\n\t\t\t\t\tswitch(disptype)\n\t\t\t\t\t{\n\t\t\t\t\tcase TYPE_DISP_1_1: rs.setThreadNameFromToCopy(stepMeta.getName(), 0, nsi.getName(), 0); break;\n\t\t\t\t\tcase TYPE_DISP_1_N: rs.setThreadNameFromToCopy(stepMeta.getName(), 0, nsi.getName(), c); break;\n\t\t\t\t\tcase TYPE_DISP_N_1: rs.setThreadNameFromToCopy(stepMeta.getName(), c, nsi.getName(), 0); break;\n\t\t\t\t\tcase TYPE_DISP_N_N: rs.setThreadNameFromToCopy(stepMeta.getName(), c, nsi.getName(), c); break;\n\t\t\t\t\t}\n\t\t\t\t\trowsets.add(rs);\n\t\t\t\t\tlog.logDetailed(toString(), Messages.getString(\"Trans.TransformationAllocatedNewRowset\",rs.toString())); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t}\n\t\t\t}\n\t\t\tlog.logDetailed(toString(), Messages.getString(\"Trans.Log.AllocatedRowsets\",String.valueOf(rowsets.size()),String.valueOf(i),stepMeta.getName())+\" \"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$\n\t\t}\n\n\t\tlog.logDetailed(toString(), Messages.getString(\"Trans.Log.AllocatingStepsAndStepData\")); //$NON-NLS-1$\n        \n\t\t// Allocate the steps & the data...\n\t\tfor (int i=0;i<hopsteps.size();i++)\n\t\t{\n\t\t\tStepMeta stepMeta=(StepMeta)hopsteps.get(i);\n\t\t\tString stepid = stepMeta.getStepID();\n\n\t\t\tlog.logDetailed(toString(), Messages.getString(\"Trans.Log.TransformationIsToAllocateStep\",stepMeta.getName(),stepid)); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$\n\n\t\t\t// How many copies are launched of this step?\n\t\t\tnrcopies=stepMeta.getCopies();\n\n            if (log.isDebug()) log.logDebug(toString(), Messages.getString(\"Trans.Log.StepHasNumberRowCopies\",String.valueOf(nrcopies))); //$NON-NLS-1$\n\n\t\t\t// At least run once...\n\t\t\tfor (int c=0;c<nrcopies;c++)\n\t\t\t{\n\t\t\t\t// Make sure we haven't started it yet!\n\t\t\t\tif (!hasStepStarted(stepMeta.getName(), c))\n\t\t\t\t{\n\t\t\t\t\tStepMetaDataCombi combi = new StepMetaDataCombi();\n\n\t\t\t\t\tcombi.stepname = stepMeta.getName();\n\t\t\t\t\tcombi.copy     = c;\n\n\t\t\t\t\t// The meta-data\n\t\t\t\t\tcombi.meta = stepMeta.getStepMetaInterface();\n\n\t\t\t\t\t// Allocate the step data\n\t\t\t\t\tStepDataInterface data = combi.meta.getStepData();\n\t\t\t\t\tcombi.data = data;\n\n\t\t\t\t\t// Allocate the step\n\t\t\t\t\tStepInterface step=combi.meta.getStep(stepMeta, data, c, transMeta, this);\n\n\t\t\t\t\t// Possibly, enable safe mode in the steps...\n\t\t\t\t\t((BaseStep)step).setSafeModeEnabled(safeModeEnabled);\n\n                    // Create the kettle variables...\n                    LocalVariables.getInstance().createKettleVariables(((BaseStep)step).getName(), Thread.currentThread().getName(), true);\n\n\t\t\t\t\t// Save the step too\n\t\t\t\t\tcombi.step = step;\n\n\t\t\t\t\t// Add to the bunch...\n\t\t\t\t\tsteps.add(combi);\n\n\t\t\t\t\tlog.logDetailed(toString(), Messages.getString(\"Trans.Log.TransformationHasAllocatedANewStep\",stepMeta.getName(),String.valueOf(c))); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Link the threads to the rowsets\n\t\tsetThreadsOnRowSets();\n\n\t\t// Now (optionally) write start log record!\n\t\ttry\n\t\t{\n\t\t\tbeginProcessing();\n\t\t}\n\t\tcatch(KettleTransException kte)\n\t\t{\n\t\t\tlog.logError(toString(), kte.getMessage());\n\t\t\treturn false;\n\t\t}\n\n\t\t// Set preview sizes\n\t\tif (preview && preview_steps!=null)\n\t\t{\n\t\t\tfor (int i=0;i<steps.size();i++)\n\t\t\t{\n\t\t\t\tStepMetaDataCombi sid = (StepMetaDataCombi)steps.get(i);\n\n\t\t\t\tBaseStep rt=(BaseStep)sid.step;\n\t\t\t\tfor (int x=0;x<preview_steps.length;x++)\n\t\t\t\t{\n\t\t\t\t\tif (preview_steps[x].equalsIgnoreCase(rt.getStepname()) && rt.getCopy()==0)\n\t\t\t\t\t{\n\t\t\t\t\t\trt.previewSize=preview_sizes[x];\n\t\t\t\t\t\trt.previewBuffer=new ArrayList();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        log.logBasic(toString(), Messages.getString(\"Trans.Log.InitialisingSteps\", String.valueOf(steps.size()))); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$\n\n        StepInitThread initThreads[] = new StepInitThread[steps.size()];\n        Thread[] threads = new Thread[steps.size()];\n\n        // Initialize all the threads...\n\t\tfor (int i=0;i<steps.size();i++)\n\t\t{\n\t\t\tfinal StepMetaDataCombi sid=(StepMetaDataCombi)steps.get(i);\n            \n            // Do the init code in the background!\n            // Init all steps at once, but ALL steps need to finish before we can continue properly!\n\t\t\tinitThreads[i] = new StepInitThread(sid, log);\n            \n            // Put it in a separate thread!\n\t\t\tthreads[i] = new Thread(initThreads[i]);\n            threads[i].setName(\"init of \"+sid.stepname+\".\"+sid.copy+\" (\"+threads[i].getName()+\")\");\n            threads[i].start();\n\t\t}\n        \n        for (int i=0; i < threads.length;i++)\n        {\n            try {\n                threads[i].join();\n            } catch(Exception ex) {\n                ex.printStackTrace();\n                log.logError(\"Error with init thread: \" + ex.getMessage(), ex.getMessage());\n            }\n        }\n        \n        boolean ok = true;\n        \n        // All step are initialized now: see if there was one that didn't do it correctly!\n        for (int i=0;i<initThreads.length && ok;i++)\n        {\n            StepMetaDataCombi combi = initThreads[i].getCombi();\n            if (!initThreads[i].isOk()) \n            {\n                log.logError(toString(), Messages.getString(\"Trans.Log.StepFailedToInit\", combi.stepname+\".\"+combi.copy));\n                ok=false;\n            }\n            else\n            {\n                log.logDetailed(toString(), Messages.getString(\"Trans.Log.StepInitialized\", combi.stepname+\".\"+combi.copy));\n            }\n        }\n        \n\t\tif (!ok)\n\t\t{\n\t\t\tlog.logError(toString(), Messages.getString(\"Trans.Log.FailToInitializeAtLeastOneStep\")); //$NON-NLS-1$\n\t\t\treturn false;\n\t\t}\n\n        return true;\n\t}","id":65146,"modified_method":"/**\n     * Prepare the execution of the transformation.\n     * @param arguments the arguments to use for this transformation\n     * @return true if the execution preparation went well, false if an error occurred.\n     */\n    public boolean prepareExecution(String[] arguments)\n    {\n\t\tRowSet    rs;\n\t\tint    nroutput;\n\t\tint    nrcopies;\n\t\tint    prevcopies;\n\t\tint    nextcopies;\n\n\t\tstartDate = null;\n\n\t\t/*\n\t\t * Set the arguments on the transformation...\n\t\t */\n\t\tif (arguments!=null) transMeta.setArguments(arguments);\n\n\t\t/* OK, see if we need to capture the logging into a String and\n\t\t * then put it in a database field later on.\n\t\t * From here until the execution is finished, the log will be captured.\n\t\t *\n\t\t */\n\t\tif (transMeta.isLogfieldUsed())\n\t\t{\n\t\t\tlog.startStringCapture();\n\t\t\tlog.setString(Messages.getString(\"Trans.Log.Start\")+Const.CR); //$NON-NLS-1$\n\t\t}\n\n\t\tif (transMeta.getName()==null)\n\t\t{\n\t\t\tif (transMeta.getFilename()!=null)\n\t\t\t{\n\t\t\t\tlog.logMinimal(toString(), Messages.getString(\"Trans.Log.DispacthingStartedForFilename\",transMeta.getFilename())); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog.logMinimal(toString(), Messages.getString(\"Trans.Log.DispacthingStartedForTransformation\",transMeta.getName())); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t}\n\n\t\tif (transMeta.getArguments()!=null)\n\t\t{\n\t\t\tlog.logMinimal(toString(), Messages.getString(\"Trans.Log.NumberOfArgumentsDetected\", String.valueOf(transMeta.getArguments().length) )); //$NON-NLS-1$\n\t\t}\n\n\t\tif (isSafeModeEnabled())\n\t\t{\n\t\t\tlog.logBasic(toString(), Messages.getString(\"Trans.Log.SafeModeIsEnabled\",transMeta.getName())); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t}\n\n\t\tif (getReplayDate() != null) {\n\t\t\tSimpleDateFormat df = new SimpleDateFormat(REPLAY_DATE_FORMAT);\n\t\t\tlog.logBasic(toString(), Messages.getString(\"Trans.Log.ThisIsAReplayTransformation\") //$NON-NLS-1$\n\t\t\t\t\t+ df.format(getReplayDate()));\n\t\t} else {\n\t\t\tlog.logBasic(toString(), Messages.getString(\"Trans.Log.ThisIsNotAReplayTransformation\")); //$NON-NLS-1$\n\t\t}\n\n\t\tsteps\t = new ArrayList();\n\t\trowsets\t = new ArrayList();\n\n\t\t//\n\t\t// Sort the steps & hops for visual pleasure...\n\t\t//\n\t\tif (isMonitored() && transMeta.nrSteps()<10)\n\t\t{\n\t\t\ttransMeta.sortStepsNatural();\n\t\t\ttransMeta.sortHopsNatural();\n\t\t}\n\n\t\tArrayList hopsteps=transMeta.getTransHopSteps(false);\n\n\t\tlog.logDetailed(toString(), Messages.getString(\"Trans.Log.FoundDefferentSteps\",String.valueOf(hopsteps.size())));\t //$NON-NLS-1$ //$NON-NLS-2$\n\t\tlog.logDetailed(toString(), Messages.getString(\"Trans.Log.AllocatingRowsets\")); //$NON-NLS-1$\n\n\t\t// First allocate all the rowsets required!\n\t\tfor (int i=0;i<hopsteps.size();i++)\n\t\t{\n\t\t\tStepMeta stepMeta=(StepMeta)hopsteps.get(i);\n\t\t\tlog.logDetailed(toString(), Messages.getString(\"Trans.Log.AllocateingRowsetsForStep\",String.valueOf(i),stepMeta.getName())); //$NON-NLS-1$ //$NON-NLS-2$\n\n\t\t\tnroutput = transMeta.findNrNextSteps(stepMeta);\n\n\t\t\tfor (int n=0;n<nroutput;n++)\n\t\t\t{\n\t\t\t\t// What's the next step?\n\t\t\t\tStepMeta nsi = transMeta.findNextStep(stepMeta, n);\n\n\t\t\t\t// How many times do we start the target step?\n\t\t\t\tnextcopies=nsi.getCopies();\n\t\t\t\tprevcopies=stepMeta.getCopies();\n\t\t\t\tlog.logDetailed(toString(), Messages.getString(\"Trans.Log.copiesInfo\",String.valueOf(prevcopies),String.valueOf(nextcopies))); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\tint disptype;\n\t\t\t\t     if (prevcopies==1 && nextcopies==1) { disptype=TYPE_DISP_1_1; nrcopies = 1; }\n\t\t\t\telse if (prevcopies==1 && nextcopies >1) { disptype=TYPE_DISP_1_N; nrcopies = nextcopies; }\n\t\t\t\telse if (prevcopies >1 && nextcopies==1) { disptype=TYPE_DISP_N_1; nrcopies = prevcopies; }\n\t\t\t\telse if (prevcopies==nextcopies)         { disptype=TYPE_DISP_N_N; nrcopies = nextcopies; } // > 1!\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlog.logError(toString(), Messages.getString(\"Trans.Log.AllowedRelationships\")); //$NON-NLS-1$\n\t\t\t\t\tlog.logError(toString(), Messages.getString(\"Trans.Log.CannotHaveXYRelationships\")); //$NON-NLS-1$\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// At least run once...\n\t\t\t\t//\n\t\t\t\tfor (int c=0;c<nrcopies;c++)\n\t\t\t\t{\n\t\t\t\t\trs=new RowSet(transMeta.getSizeRowset());\n\t\t\t\t\tswitch(disptype)\n\t\t\t\t\t{\n\t\t\t\t\tcase TYPE_DISP_1_1: rs.setThreadNameFromToCopy(stepMeta.getName(), 0, nsi.getName(), 0); break;\n\t\t\t\t\tcase TYPE_DISP_1_N: rs.setThreadNameFromToCopy(stepMeta.getName(), 0, nsi.getName(), c); break;\n\t\t\t\t\tcase TYPE_DISP_N_1: rs.setThreadNameFromToCopy(stepMeta.getName(), c, nsi.getName(), 0); break;\n\t\t\t\t\tcase TYPE_DISP_N_N: rs.setThreadNameFromToCopy(stepMeta.getName(), c, nsi.getName(), c); break;\n\t\t\t\t\t}\n\t\t\t\t\trowsets.add(rs);\n\t\t\t\t\tlog.logDetailed(toString(), Messages.getString(\"Trans.TransformationAllocatedNewRowset\",rs.toString())); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t}\n\t\t\t}\n\t\t\tlog.logDetailed(toString(), Messages.getString(\"Trans.Log.AllocatedRowsets\",String.valueOf(rowsets.size()),String.valueOf(i),stepMeta.getName())+\" \"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$\n\t\t}\n\n\t\tlog.logDetailed(toString(), Messages.getString(\"Trans.Log.AllocatingStepsAndStepData\")); //$NON-NLS-1$\n        \n\t\t// Allocate the steps & the data...\n\t\tfor (int i=0;i<hopsteps.size();i++)\n\t\t{\n\t\t\tStepMeta stepMeta=(StepMeta)hopsteps.get(i);\n\t\t\tString stepid = stepMeta.getStepID();\n\n\t\t\tlog.logDetailed(toString(), Messages.getString(\"Trans.Log.TransformationIsToAllocateStep\",stepMeta.getName(),stepid)); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$\n\n\t\t\t// How many copies are launched of this step?\n\t\t\tnrcopies=stepMeta.getCopies();\n\n            if (log.isDebug()) log.logDebug(toString(), Messages.getString(\"Trans.Log.StepHasNumberRowCopies\",String.valueOf(nrcopies))); //$NON-NLS-1$\n\n\t\t\t// At least run once...\n\t\t\tfor (int c=0;c<nrcopies;c++)\n\t\t\t{\n\t\t\t\t// Make sure we haven't started it yet!\n\t\t\t\tif (!hasStepStarted(stepMeta.getName(), c))\n\t\t\t\t{\n\t\t\t\t\tStepMetaDataCombi combi = new StepMetaDataCombi();\n\n\t\t\t\t\tcombi.stepname = stepMeta.getName();\n\t\t\t\t\tcombi.copy     = c;\n\n\t\t\t\t\t// The meta-data\n\t\t\t\t\tcombi.meta = stepMeta.getStepMetaInterface();\n\n\t\t\t\t\t// Allocate the step data\n\t\t\t\t\tStepDataInterface data = combi.meta.getStepData();\n\t\t\t\t\tcombi.data = data;\n\n\t\t\t\t\t// Allocate the step\n\t\t\t\t\tStepInterface step=combi.meta.getStep(stepMeta, data, c, transMeta, this);\n\n\t\t\t\t\t// Possibly, enable safe mode in the steps...\n\t\t\t\t\t((BaseStep)step).setSafeModeEnabled(safeModeEnabled);\n\n                    // Create the kettle variables...\n                    LocalVariables.getInstance().createKettleVariables(((BaseStep)step).getName(), Thread.currentThread().getName(), true);\n\n\t\t\t\t\t// Save the step too\n\t\t\t\t\tcombi.step = step;\n\n\t\t\t\t\t// Add to the bunch...\n\t\t\t\t\tsteps.add(combi);\n\n\t\t\t\t\tlog.logDetailed(toString(), Messages.getString(\"Trans.Log.TransformationHasAllocatedANewStep\",stepMeta.getName(),String.valueOf(c))); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Link the threads to the rowsets\n\t\tsetThreadsOnRowSets();\n\n\t\t// Now (optionally) write start log record!\n\t\ttry\n\t\t{\n\t\t\tbeginProcessing();\n\t\t}\n\t\tcatch(KettleTransException kte)\n\t\t{\n\t\t\tlog.logError(toString(), kte.getMessage());\n\t\t\treturn false;\n\t\t}\n\n\t\t// Set preview sizes\n\t\tif (preview && preview_steps!=null)\n\t\t{\n\t\t\tfor (int i=0;i<steps.size();i++)\n\t\t\t{\n\t\t\t\tStepMetaDataCombi sid = (StepMetaDataCombi)steps.get(i);\n\n\t\t\t\tBaseStep rt=(BaseStep)sid.step;\n\t\t\t\tfor (int x=0;x<preview_steps.length;x++)\n\t\t\t\t{\n\t\t\t\t\tif (preview_steps[x].equalsIgnoreCase(rt.getStepname()) && rt.getCopy()==0)\n\t\t\t\t\t{\n\t\t\t\t\t\trt.previewSize=preview_sizes[x];\n\t\t\t\t\t\trt.previewBuffer=new ArrayList();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        log.logBasic(toString(), Messages.getString(\"Trans.Log.InitialisingSteps\", String.valueOf(steps.size()))); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$\n\n        StepInitThread initThreads[] = new StepInitThread[steps.size()];\n        Thread[] threads = new Thread[steps.size()];\n\n        // Initialize all the threads...\n\t\tfor (int i=0;i<steps.size();i++)\n\t\t{\n\t\t\tfinal StepMetaDataCombi sid=(StepMetaDataCombi)steps.get(i);\n            \n            // Do the init code in the background!\n            // Init all steps at once, but ALL steps need to finish before we can continue properly!\n\t\t\tinitThreads[i] = new StepInitThread(sid, log);\n            \n            // Put it in a separate thread!\n\t\t\tthreads[i] = new Thread(initThreads[i]);\n            threads[i].setName(\"init of \"+sid.stepname+\".\"+sid.copy+\" (\"+threads[i].getName()+\")\");\n            threads[i].start();\n\t\t}\n        \n        for (int i=0; i < threads.length;i++)\n        {\n            try {\n                threads[i].join();\n            } catch(Exception ex) {\n                ex.printStackTrace();\n                log.logError(\"Error with init thread: \" + ex.getMessage(), ex.getMessage());\n            }\n        }\n        \n        boolean ok = true;\n        \n        // All step are initialized now: see if there was one that didn't do it correctly!\n        for (int i=0;i<initThreads.length && ok;i++)\n        {\n            StepMetaDataCombi combi = initThreads[i].getCombi();\n            if (!initThreads[i].isOk()) \n            {\n                log.logError(toString(), Messages.getString(\"Trans.Log.StepFailedToInit\", combi.stepname+\".\"+combi.copy));\n                ok=false;\n            }\n            else\n            {\n                log.logDetailed(toString(), Messages.getString(\"Trans.Log.StepInitialized\", combi.stepname+\".\"+combi.copy));\n            }\n        }\n        \n\t\tif (!ok)\n\t\t{\n\t\t\tlog.logError(toString(), Messages.getString(\"Trans.Log.FailToInitializeAtLeastOneStep\")); //$NON-NLS-1$\n\t\t\treturn false;\n\t\t}\n\n        return true;\n\t}","commit_id":"5d5f2f54ebb892a1b867d9db0ccafa5c9658ca6a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public static void main(String[] a) throws KettleException\n\t{\n\t\tEnvUtil.environmentInit();\n        Thread parentThread = Thread.currentThread();\n        LocalVariables.getInstance().createKettleVariables(parentThread.getName(), null, false);\n\t\t\n\t    ArrayList args = new ArrayList();\n\t    for (int i=0;i<a.length;i++)\n\t    {\n\t        if (a[i].length()>0) args.add(a[i]);\n\t    }\n\n\t\tRepositoryMeta repinfo  = null;\n\t\tUserInfo       userinfo = null;\n\t\tJob            job      = null;\n\t\t\n\t\tStringBuffer optionRepname, optionUsername, optionPassword, optionJobname, optionDirname, optionFilename, optionLoglevel;\n        StringBuffer optionLogfile, optionListdir, optionListjobs, optionListrep, optionNorep, optionVersion;\n\n\t\tCommandLineOption options[] = new CommandLineOption[] \n            {\n\t\t\t    new CommandLineOption(\"rep\", \"Repository name\", optionRepname=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"user\", \"Repository username\", optionUsername=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"pass\", \"Repository password\", optionPassword=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"job\", \"The name of the transformation to launch\", optionJobname=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"dir\", \"The directory (don't forget the leading /)\", optionDirname=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"file\", \"The filename (Job XML) to launch\", optionFilename=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"level\", \"The logging level (Basic, Detailed, Debug, Rowlevel, Error, Nothing)\", optionLoglevel=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"logfile\", \"The logging file to write to\", optionLogfile=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"log\", \"The logging file to write to (deprecated)\", optionLogfile=new StringBuffer(), false, true),\n\t\t\t    new CommandLineOption(\"listdir\", \"List the directories in the repository\", optionListdir=new StringBuffer(), true, false),\n\t\t\t    new CommandLineOption(\"listjobs\", \"List the jobs in the specified directory\", optionListjobs=new StringBuffer(), true, false),\n\t\t\t    new CommandLineOption(\"listrep\", \"List the available repositories\", optionListrep=new StringBuffer(), true, false),\n\t\t        new CommandLineOption(\"norep\", \"Do not log into the repository\", optionNorep=new StringBuffer(), true, false),\n                new CommandLineOption(\"version\", \"show the version, revision and build date\", optionVersion=new StringBuffer(), true, false),\n            };\n\n\t\tif (args.size()==0 ) \n\t\t{\n\t\t    CommandLineOption.printUsage(options);\n\t\t    System.exit(9);\n\t\t}\n        \n        CommandLineOption.parseArguments(args, options);\n\n        String kettleRepname  = Const.getEnvironmentVariable(\"KETTLE_REPOSITORY\", null);\n        String kettleUsername = Const.getEnvironmentVariable(\"KETTLE_USER\", null);\n        String kettlePassword = Const.getEnvironmentVariable(\"KETTLE_PASSWORD\", null);\n        \n        if (!Const.isEmpty(kettleRepname )) optionRepname  = new StringBuffer(kettleRepname );\n        if (!Const.isEmpty(kettleUsername)) optionUsername = new StringBuffer(kettleUsername);\n        if (!Const.isEmpty(kettlePassword)) optionPassword = new StringBuffer(kettlePassword);\n        \n\t\t// System.out.println(\"Level=\"+loglevel);\n        LogWriter log;\n        LogWriter.setConsoleAppenderDebug();\n        if (Const.isEmpty(optionLogfile))\n        {\n            log=LogWriter.getInstance( LogWriter.LOG_LEVEL_BASIC );\n        }\n        else\n        {\n            log=LogWriter.getInstance( optionLogfile.toString(), true, LogWriter.LOG_LEVEL_BASIC );\n        }\n        \n        if (!Const.isEmpty(optionLoglevel)) \n        {\n            log.setLogLevel(optionLoglevel.toString());\n            log.logMinimal(STRING_KITCHEN, \"Logging is at level : \"+log.getLogLevelDesc());\n        } \n\t\t\n        if (!Const.isEmpty(optionVersion))\n        {\n            BuildVersion buildVersion = BuildVersion.getInstance();\n            log.logBasic(\"Pan\", \"Kettle version \"+Const.VERSION+\", build \"+buildVersion.getVersion()+\", build date : \"+buildVersion.getBuildDate());\n            if (a.length==1) System.exit(6);\n        }\n        \n        // Start the action...\n        //\n        if (!Const.isEmpty(optionRepname) && !Const.isEmpty(optionUsername)) log.logDetailed(STRING_KITCHEN, \"Repository and username supplied\");\n\n\t\tlog.logMinimal(STRING_KITCHEN, \"Start of run.\");\n\t\t\n\t\t/* Load the plugins etc.*/\n\t\tStepLoader steploader = StepLoader.getInstance();\n\t\tif (!steploader.read())\n\t\t{\n\t\t\tlog.logError(STRING_KITCHEN, \"Error loading steps... halting Kitchen!\");\n\t\t\tSystem.exit(8);\n\t\t}\n        \n        /* Load the plugins etc.*/\n        JobEntryLoader jeloader = JobEntryLoader.getInstance();\n        if (!jeloader.read())\n        {\n            log.logError(STRING_KITCHEN, \"Error loading job entries & plugins... halting Kitchen!\");\n            return;\n        }\n\n\t\tDate start, stop;\n\t\tCalendar cal;\n\t\tSimpleDateFormat df = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss.SSS\");\n\t\tcal=Calendar.getInstance();\n\t\tstart=cal.getTime();\n\t\t\t\t\n\t\tlog.logDebug(STRING_KITCHEN, \"Allocate new job.\");\n\t\tJobMeta jobMeta = new JobMeta(log);\n        \n        // In case we use a repository...\n        Repository repository = null;\n\n\t\ttry\n\t\t{\n\t\t\t// Read kettle job specified on command-line?\n\t\t\tif (!Const.isEmpty(optionRepname) || !Const.isEmpty(optionFilename))\n\t\t\t{\n\t\t\t\tlog.logDebug(STRING_KITCHEN, \"Parsing command line options.\");\n\t\t\t\tif (optionRepname!=null && !\"Y\".equalsIgnoreCase(optionNorep.toString()))\n\t\t\t\t{\n\t\t\t\t\tlog.logDebug(STRING_KITCHEN, \"Loading available repositories.\");\n\t\t\t\t\tRepositoriesMeta repsinfo = new RepositoriesMeta(log);\n\t\t\t\t\tif (repsinfo.readData())\n\t\t\t\t\t{\n\t\t\t\t\t\tlog.logDebug(STRING_KITCHEN, \"Finding repository [\"+optionRepname+\"]\");\n\t\t\t\t\t\trepinfo = repsinfo.findRepository(optionRepname.toString());\n\t\t\t\t\t\tif (repinfo!=null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Define and connect to the repository...\n\t\t\t\t\t\t\tlog.logDebug(STRING_KITCHEN, \"Allocate & connect to repository.\");\n\t\t\t\t\t\t\trepository = new Repository(log, repinfo, userinfo);\n\t\t\t\t\t\t\tif (repository.connect(\"Kitchen commandline\"))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tRepositoryDirectory directory = repository.getDirectoryTree(); // Default = root\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Find the directory name if one is specified...\n\t\t\t\t\t\t\t\tif (!Const.isEmpty(optionDirname))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tdirectory = repository.getDirectoryTree().findDirectory(optionDirname.toString());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (directory!=null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Check username, password\n\t\t\t\t\t\t\t\t\tlog.logDebug(STRING_KITCHEN, \"Check supplied username and password.\");\n\t\t\t\t\t\t\t\t\tuserinfo = new UserInfo(repository, optionUsername.toString(), optionPassword.toString());\n\t\t\t\t\t\t\t\t\tif (userinfo.getID()>0)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t    // Load a job\n\t\t\t\t\t\t\t\t\t\tif (!Const.isEmpty(optionJobname))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tlog.logDebug(STRING_KITCHEN, \"Load the job info...\");\n\t\t\t\t\t\t\t\t\t\t\tjobMeta =  new JobMeta(log, repository, optionJobname.toString(), directory);\n\t\t\t\t\t\t\t\t\t\t\tlog.logDebug(STRING_KITCHEN, \"Allocate job...\");\n\t\t\t\t\t\t\t\t\t\t\tjob = new Job(log, steploader, repository, jobMeta);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t// List the jobs in the repository\n\t\t\t\t\t\t\t\t\t\tif (\"Y\".equalsIgnoreCase(optionListjobs.toString()))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t    log.logDebug(STRING_KITCHEN, \"Getting list of jobs in directory: \"+directory);\n\t\t\t\t\t\t\t\t\t\t\tString jobnames[] = repository.getJobNames(directory.getID());\n\t\t\t\t\t\t\t\t\t\t\tfor (int i=0;i<jobnames.length;i++)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(jobnames[i]);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t// List the directories in the repository\n\t\t\t\t\t\t\t\t\t\tif (\"Y\".equalsIgnoreCase(optionListdir.toString()))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tString dirnames[] = repository.getDirectoryNames(directory.getID());\n\t\t\t\t\t\t\t\t\t\t\tfor (int i=0;i<dirnames.length;i++)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(dirnames[i]);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"ERROR: Can't verify username and password.\");\n\t\t\t\t\t\t\t\t\t\tuserinfo=null;\n\t\t\t\t\t\t\t\t\t\trepinfo=null;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tSystem.out.println(\"ERROR: Can't find the supplied directory [\"+optionDirname+\"]\");\n\t\t\t\t\t\t\t\t\tuserinfo=null;\n\t\t\t\t\t\t\t\t\trepinfo=null;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tSystem.out.println(\"ERROR: Can't connect to the repository.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSystem.out.println(\"ERROR: No repository provided, can't load job.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.println(\"ERROR: No repositories defined on this system.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n                // Try to load if from file anyway.\n\t\t\t\tif (!Const.isEmpty(optionFilename) && job==null)\n\t\t\t\t{\n\t\t\t\t\tjobMeta = new JobMeta(log, optionFilename.toString(), null);\n\t\t\t\t\tjob = new Job(log, steploader, null, jobMeta);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\tif (\"Y\".equalsIgnoreCase(optionListrep.toString()))\n\t\t\t{\n\t\t\t\tRepositoriesMeta ri = new RepositoriesMeta(log);\n\t\t\t\tif (ri.readData())\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"List of repositories:\");\n\t\t\t\t\tfor (int i=0;i<ri.nrRepositories();i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tRepositoryMeta rinfo = ri.getRepository(i);\n\t\t\t\t\t\tSystem.out.println(\"#\"+(i+1)+\" : \"+rinfo.getName()+\" [\"+rinfo.getDescription()+\"] \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"ERROR: Unable to read/parse the repositories XML file.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch(KettleException e)\n\t\t{\n\t\t\tjob=null;\n\t\t\tjobMeta=null;\n\t\t\tSystem.out.println(\"Processing stopped because of an error: \"+e.getMessage());\n\t\t}\n\n\t\tif (job==null)\n\t\t{\n\t\t\tif (!\"Y\".equalsIgnoreCase(optionListjobs.toString()) &&  \n\t\t\t\t!\"Y\".equalsIgnoreCase(optionListdir.toString()) && \n\t\t\t\t!\"Y\".equalsIgnoreCase(optionListrep.toString()) \n\t\t\t    )\n\t\t\t{\n\t\t\t\tSystem.out.println(\"ERROR: Kitchen can't continue because the job couldn't be loaded.\");\t\t\t    \n\t\t\t}\n\n            System.exit(7);\n\t\t}\n\t\t\n\t\tResult result = null;\n\n        int returnCode=0;\n        \n\t\ttry\n\t\t{\n            // Add Kettle variables for the job thread...\n            LocalVariables.getInstance().createKettleVariables(job.getName(), parentThread.getName(), true);\n            \n            // Set the arguments on the job metadata as well...\n            job.getJobMeta().setArguments((String[]) args.toArray(new String[args.size()]));\n            \n\t\t\tresult = job.execute(); // Execute the selected job.\n\t\t\tjob.endProcessing(\"end\", result);  // The bookkeeping...\n\t\t}\n\t\tcatch(KettleJobException je)\n\t\t{\n            if (result==null)\n            {\n                result = new Result();\n            }\n            result.setNrErrors(1L);\n            \n\t\t\ttry\n\t\t\t{\n\t\t\t\tjob.endProcessing(\"error\", result);\n\t\t\t}\n\t\t\tcatch(KettleJobException je2)\n\t\t\t{\n\t\t\t\tlog.logError(job.getName(), \"A serious error occured : \"+je2.getMessage());\n                returnCode = 2;\n\t\t\t}\n\t\t}\n        finally\n        {\n            if (repository!=null) repository.disconnect();\n        }\n        \n\t\tlog.logMinimal(STRING_KITCHEN, \"Finished!\");\n\t\t\n\t\tif (result!=null && result.getNrErrors()!=0)\n\t\t{\n\t\t\tlog.logError(STRING_KITCHEN, \"Finished with errors\");\n            returnCode = 1;\n\t\t}\n\t\tcal=Calendar.getInstance();\n\t\tstop=cal.getTime();\n\t\tString begin=df.format(start).toString();\n\t\tString end  =df.format(stop).toString();\n\n\t\tlog.logMinimal(STRING_KITCHEN, \"Start=\"+begin+\", Stop=\"+end);\n\t\tlong millis=stop.getTime()-start.getTime();\n\t\tlog.logMinimal(STRING_KITCHEN, \"Processing ended after \"+(millis/1000)+\" seconds.\");\n        \n        System.exit(returnCode);\n\n\t}","id":65147,"modified_method":"public static void main(String[] a) throws KettleException\n\t{\n\t\tEnvUtil.environmentInit();\n        Thread parentThread = Thread.currentThread();\n        LocalVariables.getInstance().createKettleVariables(parentThread.getName(), null, false);\n\t\t\n\t    ArrayList args = new ArrayList();\n\t    for (int i=0;i<a.length;i++)\n\t    {\n\t        if (a[i].length()>0) args.add(a[i]);\n\t    }\n\n\t\tRepositoryMeta repinfo  = null;\n\t\tUserInfo       userinfo = null;\n\t\tJob            job      = null;\n\t\t\n\t\tStringBuffer optionRepname, optionUsername, optionPassword, optionJobname, optionDirname, optionFilename, optionLoglevel;\n        StringBuffer optionLogfile, optionListdir, optionListjobs, optionListrep, optionNorep, optionVersion;\n\n\t\tCommandLineOption options[] = new CommandLineOption[] \n            {\n\t\t\t    new CommandLineOption(\"rep\", \"Repository name\", optionRepname=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"user\", \"Repository username\", optionUsername=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"pass\", \"Repository password\", optionPassword=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"job\", \"The name of the transformation to launch\", optionJobname=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"dir\", \"The directory (don't forget the leading /)\", optionDirname=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"file\", \"The filename (Job XML) to launch\", optionFilename=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"level\", \"The logging level (Basic, Detailed, Debug, Rowlevel, Error, Nothing)\", optionLoglevel=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"logfile\", \"The logging file to write to\", optionLogfile=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"log\", \"The logging file to write to (deprecated)\", optionLogfile=new StringBuffer(), false, true),\n\t\t\t    new CommandLineOption(\"listdir\", \"List the directories in the repository\", optionListdir=new StringBuffer(), true, false),\n\t\t\t    new CommandLineOption(\"listjobs\", \"List the jobs in the specified directory\", optionListjobs=new StringBuffer(), true, false),\n\t\t\t    new CommandLineOption(\"listrep\", \"List the available repositories\", optionListrep=new StringBuffer(), true, false),\n\t\t        new CommandLineOption(\"norep\", \"Do not log into the repository\", optionNorep=new StringBuffer(), true, false),\n                new CommandLineOption(\"version\", \"show the version, revision and build date\", optionVersion=new StringBuffer(), true, false),\n            };\n\n\t\tif (args.size()==0 ) \n\t\t{\n\t\t    CommandLineOption.printUsage(options);\n\t\t    System.exit(9);\n\t\t}\n        \n        CommandLineOption.parseArguments(args, options);\n\n        String kettleRepname  = Const.getEnvironmentVariable(\"KETTLE_REPOSITORY\", null);\n        String kettleUsername = Const.getEnvironmentVariable(\"KETTLE_USER\", null);\n        String kettlePassword = Const.getEnvironmentVariable(\"KETTLE_PASSWORD\", null);\n        \n        if (!Const.isEmpty(kettleRepname )) optionRepname  = new StringBuffer(kettleRepname );\n        if (!Const.isEmpty(kettleUsername)) optionUsername = new StringBuffer(kettleUsername);\n        if (!Const.isEmpty(kettlePassword)) optionPassword = new StringBuffer(kettlePassword);\n        \n\t\t// System.out.println(\"Level=\"+loglevel);\n        LogWriter log;\n        LogWriter.setConsoleAppenderDebug();\n        if (Const.isEmpty(optionLogfile))\n        {\n            log=LogWriter.getInstance( LogWriter.LOG_LEVEL_BASIC );\n        }\n        else\n        {\n            log=LogWriter.getInstance( optionLogfile.toString(), true, LogWriter.LOG_LEVEL_BASIC );\n        }\n        \n        if (!Const.isEmpty(optionLoglevel)) \n        {\n            log.setLogLevel(optionLoglevel.toString());\n            log.logMinimal(STRING_KITCHEN, \"Logging is at level : \"+log.getLogLevelDesc());\n        } \n\t\t\n        if (!Const.isEmpty(optionVersion))\n        {\n            BuildVersion buildVersion = BuildVersion.getInstance();\n            log.logBasic(\"Pan\", \"Kettle version \"+Const.VERSION+\", build \"+buildVersion.getVersion()+\", build date : \"+buildVersion.getBuildDate());\n            if (a.length==1) System.exit(6);\n        }\n        \n        // Start the action...\n        //\n        if (!Const.isEmpty(optionRepname) && !Const.isEmpty(optionUsername)) log.logDetailed(STRING_KITCHEN, \"Repository and username supplied\");\n\n\t\tlog.logMinimal(STRING_KITCHEN, \"Start of run.\");\n\t\t\n\t\t/* Load the plugins etc.*/\n\t\tStepLoader steploader = StepLoader.getInstance();\n\t\tif (!steploader.read())\n\t\t{\n\t\t\tlog.logError(STRING_KITCHEN, \"Error loading steps... halting Kitchen!\");\n\t\t\tSystem.exit(8);\n\t\t}\n        \n        /* Load the plugins etc.*/\n        JobEntryLoader jeloader = JobEntryLoader.getInstance();\n        if (!jeloader.read())\n        {\n            log.logError(STRING_KITCHEN, \"Error loading job entries & plugins... halting Kitchen!\");\n            return;\n        }\n\n\t\tDate start, stop;\n\t\tCalendar cal;\n\t\tSimpleDateFormat df = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss.SSS\");\n\t\tcal=Calendar.getInstance();\n\t\tstart=cal.getTime();\n\t\t\t\t\n\t\tlog.logDebug(STRING_KITCHEN, \"Allocate new job.\");\n\t\tJobMeta jobMeta = new JobMeta(log);\n        \n        // In case we use a repository...\n        Repository repository = null;\n\n\t\ttry\n\t\t{\n\t\t\t// Read kettle job specified on command-line?\n\t\t\tif (!Const.isEmpty(optionRepname) || !Const.isEmpty(optionFilename))\n\t\t\t{\n\t\t\t\tlog.logDebug(STRING_KITCHEN, \"Parsing command line options.\");\n\t\t\t\tif (optionRepname!=null && !\"Y\".equalsIgnoreCase(optionNorep.toString()))\n\t\t\t\t{\n\t\t\t\t\tlog.logDebug(STRING_KITCHEN, \"Loading available repositories.\");\n\t\t\t\t\tRepositoriesMeta repsinfo = new RepositoriesMeta(log);\n\t\t\t\t\tif (repsinfo.readData())\n\t\t\t\t\t{\n\t\t\t\t\t\tlog.logDebug(STRING_KITCHEN, \"Finding repository [\"+optionRepname+\"]\");\n\t\t\t\t\t\trepinfo = repsinfo.findRepository(optionRepname.toString());\n\t\t\t\t\t\tif (repinfo!=null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Define and connect to the repository...\n\t\t\t\t\t\t\tlog.logDebug(STRING_KITCHEN, \"Allocate & connect to repository.\");\n\t\t\t\t\t\t\trepository = new Repository(log, repinfo, userinfo);\n\t\t\t\t\t\t\tif (repository.connect(\"Kitchen commandline\"))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tRepositoryDirectory directory = repository.getDirectoryTree(); // Default = root\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Find the directory name if one is specified...\n\t\t\t\t\t\t\t\tif (!Const.isEmpty(optionDirname))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tdirectory = repository.getDirectoryTree().findDirectory(optionDirname.toString());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (directory!=null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Check username, password\n\t\t\t\t\t\t\t\t\tlog.logDebug(STRING_KITCHEN, \"Check supplied username and password.\");\n\t\t\t\t\t\t\t\t\tuserinfo = new UserInfo(repository, optionUsername.toString(), optionPassword.toString());\n\t\t\t\t\t\t\t\t\tif (userinfo.getID()>0)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t    // Load a job\n\t\t\t\t\t\t\t\t\t\tif (!Const.isEmpty(optionJobname))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tlog.logDebug(STRING_KITCHEN, \"Load the job info...\");\n\t\t\t\t\t\t\t\t\t\t\tjobMeta =  new JobMeta(log, repository, optionJobname.toString(), directory);\n\t\t\t\t\t\t\t\t\t\t\tlog.logDebug(STRING_KITCHEN, \"Allocate job...\");\n\t\t\t\t\t\t\t\t\t\t\tjob = new Job(log, steploader, repository, jobMeta);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t// List the jobs in the repository\n\t\t\t\t\t\t\t\t\t\tif (\"Y\".equalsIgnoreCase(optionListjobs.toString()))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t    log.logDebug(STRING_KITCHEN, \"Getting list of jobs in directory: \"+directory);\n\t\t\t\t\t\t\t\t\t\t\tString jobnames[] = repository.getJobNames(directory.getID());\n\t\t\t\t\t\t\t\t\t\t\tfor (int i=0;i<jobnames.length;i++)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(jobnames[i]);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t// List the directories in the repository\n\t\t\t\t\t\t\t\t\t\tif (\"Y\".equalsIgnoreCase(optionListdir.toString()))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tString dirnames[] = repository.getDirectoryNames(directory.getID());\n\t\t\t\t\t\t\t\t\t\t\tfor (int i=0;i<dirnames.length;i++)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(dirnames[i]);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"ERROR: Can't verify username and password.\");\n\t\t\t\t\t\t\t\t\t\tuserinfo=null;\n\t\t\t\t\t\t\t\t\t\trepinfo=null;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tSystem.out.println(\"ERROR: Can't find the supplied directory [\"+optionDirname+\"]\");\n\t\t\t\t\t\t\t\t\tuserinfo=null;\n\t\t\t\t\t\t\t\t\trepinfo=null;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tSystem.out.println(\"ERROR: Can't connect to the repository.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSystem.out.println(\"ERROR: No repository provided, can't load job.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.println(\"ERROR: No repositories defined on this system.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n                // Try to load if from file anyway.\n\t\t\t\tif (!Const.isEmpty(optionFilename) && job==null)\n\t\t\t\t{\n\t\t\t\t\tjobMeta = new JobMeta(log, optionFilename.toString(), null);\n\t\t\t\t\tjob = new Job(log, steploader, null, jobMeta);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\tif (\"Y\".equalsIgnoreCase(optionListrep.toString()))\n\t\t\t{\n\t\t\t\tRepositoriesMeta ri = new RepositoriesMeta(log);\n\t\t\t\tif (ri.readData())\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"List of repositories:\");\n\t\t\t\t\tfor (int i=0;i<ri.nrRepositories();i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tRepositoryMeta rinfo = ri.getRepository(i);\n\t\t\t\t\t\tSystem.out.println(\"#\"+(i+1)+\" : \"+rinfo.getName()+\" [\"+rinfo.getDescription()+\"] \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"ERROR: Unable to read/parse the repositories XML file.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch(KettleException e)\n\t\t{\n\t\t\tjob=null;\n\t\t\tjobMeta=null;\n\t\t\tSystem.out.println(\"Processing stopped because of an error: \"+e.getMessage());\n\t\t}\n\n\t\tif (job==null)\n\t\t{\n\t\t\tif (!\"Y\".equalsIgnoreCase(optionListjobs.toString()) &&  \n\t\t\t\t!\"Y\".equalsIgnoreCase(optionListdir.toString()) && \n\t\t\t\t!\"Y\".equalsIgnoreCase(optionListrep.toString()) \n\t\t\t    )\n\t\t\t{\n\t\t\t\tSystem.out.println(\"ERROR: Kitchen can't continue because the job couldn't be loaded.\");\t\t\t    \n\t\t\t}\n\n            System.exit(7);\n\t\t}\n\t\t\n\t\tResult result = null;\n\n        int returnCode=0;\n        \n\t\ttry\n\t\t{\n            // Add Kettle variables for the job thread...\n            LocalVariables.getInstance().createKettleVariables(job.getName(), parentThread.getName(), true);\n            \n            // Set the arguments on the job metadata as well...\n            if ( args.size() == 0 )\n            {\n                job.getJobMeta().setArguments(null);\n            }\n            else\n            {\n                job.getJobMeta().setArguments((String[]) args.toArray(new String[args.size()]));\n            }\n            \n\t\t\tresult = job.execute(); // Execute the selected job.\n\t\t\tjob.endProcessing(\"end\", result);  // The bookkeeping...\n\t\t}\n\t\tcatch(KettleJobException je)\n\t\t{\n            if (result==null)\n            {\n                result = new Result();\n            }\n            result.setNrErrors(1L);\n            \n\t\t\ttry\n\t\t\t{\n\t\t\t\tjob.endProcessing(\"error\", result);\n\t\t\t}\n\t\t\tcatch(KettleJobException je2)\n\t\t\t{\n\t\t\t\tlog.logError(job.getName(), \"A serious error occured : \"+je2.getMessage());\n                returnCode = 2;\n\t\t\t}\n\t\t}\n        finally\n        {\n            if (repository!=null) repository.disconnect();\n        }\n        \n\t\tlog.logMinimal(STRING_KITCHEN, \"Finished!\");\n\t\t\n\t\tif (result!=null && result.getNrErrors()!=0)\n\t\t{\n\t\t\tlog.logError(STRING_KITCHEN, \"Finished with errors\");\n            returnCode = 1;\n\t\t}\n\t\tcal=Calendar.getInstance();\n\t\tstop=cal.getTime();\n\t\tString begin=df.format(start).toString();\n\t\tString end  =df.format(stop).toString();\n\n\t\tlog.logMinimal(STRING_KITCHEN, \"Start=\"+begin+\", Stop=\"+end);\n\t\tlong millis=stop.getTime()-start.getTime();\n\t\tlog.logMinimal(STRING_KITCHEN, \"Processing ended after \"+(millis/1000)+\" seconds.\");\n        \n        System.exit(returnCode);\n\n\t}","commit_id":"d5792c48b10455eb2ac9b2665473da11ac4053a9","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n     * Take in the set of required information to\n     * determine what kickstartable tree to use for this Kickstart\n     * profile.\n     *\n     * @param channelId id of ChannelFamily selected.\n     * @param orgId org id\n     * @param treeId kickstart tree id\n     * @param url the url of the channel.\n     * @return ValidatorError if we couldn't find a KickstartableTree to update to\n     */\n    public ValidatorError updateKickstartableTree(Long channelId,\n                                                    Long orgId,\n                                                    Long treeId,\n                                                    String url) {\n\n\n\n        if (!KickstartFactory.verifyTreeAssignment(channelId, orgId, treeId)) {\n            ValidatorError ve = new ValidatorError(\"kickstart.software.notree\");\n            return ve;\n        }\n\n        KickstartableTree tree = KickstartFactory.findTreeById(treeId, orgId);\n        KickstartWizardHelper helper = new KickstartWizardHelper(getUser());\n\n\n        for (Token token : ksdata.getDefaultRegTokens()) {\n            ActivationKey key = ActivationKeyFactory.lookupByToken(token);\n            if (key != null && key.getKickstartSession() != null) {\n                token.setBaseChannel(tree.getChannel());\n            }\n        }\n\n        if (tree == null) {\n            ValidatorError ve = new ValidatorError(\"kickstart.software.notree\");\n            logger.debug(\"updateKickstartableTree(Long, String, \" +\n                    \"String, Long) - end - return value=\" + ve);\n            return ve;\n        }\n        else if (!tree.equals(ksdata.getTree())) {\n\n            this.ksdata.getKickstartDefaults().setKstree(tree);\n            if (!ksdata.isRawData() && !StringUtils.isBlank(url)) {\n                KickstartCommand kcmd = this.ksdata.getCommand(\"url\");\n                kcmd.setArguments(\"--url \" + url);\n\n                // Any time we update the kickstartable tree we need to remove any existing\n                // yum repo commands and re-add them for the new tree if necessary:\n                this.ksdata.removeCommand(\"repo\", false);\n                this.ksdata.removeCommand(\"key\", true);\n                logger.debug(\"updateKickstartableTree(Long, String, String, Long)\" +\n                        \" - end - return value=\" + null);\n            }\n            return null;\n        }\n        return null;\n\n    }","id":65148,"modified_method":"/**\n     * Take in the set of required information to\n     * determine what kickstartable tree to use for this Kickstart\n     * profile.\n     *\n     * @param channelId id of ChannelFamily selected.\n     * @param orgId org id\n     * @param treeId kickstart tree id\n     * @param url the url of the channel.\n     * @return ValidatorError if we couldn't find a KickstartableTree to update to\n     */\n    public ValidatorError updateKickstartableTree(Long channelId,\n                                                    Long orgId,\n                                                    Long treeId,\n                                                    String url) {\n\n\n\n        if (!KickstartFactory.verifyTreeAssignment(channelId, orgId, treeId)) {\n            ValidatorError ve = new ValidatorError(\"kickstart.software.notree\");\n            return ve;\n        }\n\n        KickstartableTree tree = KickstartFactory.findTreeById(treeId, orgId);\n        KickstartWizardHelper helper = new KickstartWizardHelper(getUser());\n\n\n        for (Token token : ksdata.getDefaultRegTokens()) {\n            ActivationKey key = ActivationKeyFactory.lookupByToken(token);\n            if (key != null && key.getKickstartSession() != null) {\n                token.setBaseChannel(tree.getChannel());\n            }\n        }\n\n        if (tree == null) {\n            ValidatorError ve = new ValidatorError(\"kickstart.software.notree\");\n            logger.debug(\"updateKickstartableTree(Long, String, \" +\n                    \"String, Long) - end - return value=\" + ve);\n            return ve;\n        }\n        else if (!tree.equals(ksdata.getTree())) {\n\n            this.ksdata.getKickstartDefaults().setKstree(tree);\n            if (!ksdata.isRawData() && !StringUtils.isBlank(url)) {\n                KickstartCommand kcmd = this.ksdata.getCommand(\"url\");\n                if (kcmd != null) {\n                    kcmd.setArguments(\"--url \" + url);\n                }\n\n                // Any time we update the kickstartable tree we need to remove any existing\n                // yum repo commands and re-add them for the new tree if necessary:\n                this.ksdata.removeCommand(\"repo\", false);\n                this.ksdata.removeCommand(\"key\", true);\n                logger.debug(\"updateKickstartableTree(Long, String, String, Long)\" +\n                        \" - end - return value=\" + null);\n            }\n            return null;\n        }\n        return null;\n\n    }","commit_id":"d3786084abc0cc23d3fabd5107380137ccc46ab7","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"private boolean handleBackspace(Editor editor, DataContext dataContext){\n    Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n    if (project == null) return false;\n\n    PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n\n    if (file == null) return false;\n\n    if (editor.getSelectionModel().hasSelection()) return false;\n\n    int offset = editor.getCaretModel().getOffset() - 1;\n    if (offset < 0) return false;\n    CharSequence chars = editor.getDocument().getCharsSequence();\n    char c = chars.charAt(offset);\n\n    final Editor injectedEditor = TypedHandler.injectedEditorIfCharTypedIsSignificant(c, editor, file);\n    if (injectedEditor != editor) {\n      file = PsiDocumentManager.getInstance(project).getPsiFile(injectedEditor.getDocument());\n      editor = injectedEditor;\n      offset = editor.getCaretModel().getOffset() - 1;\n      chars = editor.getDocument().getCharsSequence();\n    }\n\n    final BackspaceHandlerDelegate[] delegates = Extensions.getExtensions(BackspaceHandlerDelegate.EP_NAME);\n    for(BackspaceHandlerDelegate delegate: delegates) {\n      delegate.beforeCharDeleted(c, file, editor);\n    }\n\n    FileType fileType = file.getFileType();\n    final QuoteHandler quoteHandler = TypedHandler.getQuoteHandler(file);\n\n    HighlighterIterator hiterator = ((EditorEx)editor).getHighlighter().createIterator(offset);\n    boolean wasClosingQuote = quoteHandler != null && quoteHandler.isClosingQuote(hiterator, offset);\n\n    myOriginalHandler.execute(editor, dataContext);\n\n    if (offset >= editor.getDocument().getTextLength()) return true;\n\n    for(BackspaceHandlerDelegate delegate: delegates) {\n      if (delegate.charDeleted(c, file, editor)) {\n        return true;\n      }\n    }\n\n\n    chars = editor.getDocument().getCharsSequence();\n    if (c == '(' || c == '[' || c == '{'){\n      char c1 = chars.charAt(offset);\n      if (c == '(' && c1 != ')') return true;\n      if (c == '[' && c1 != ']') return true;\n      if (c == '{' && c1 != '}') return true;\n\n      HighlighterIterator iterator = ((EditorEx)editor).getHighlighter().createIterator(offset);\n      BraceMatcher braceMatcher = BraceMatchingUtil.getBraceMatcher(fileType);\n      if (!braceMatcher.isLBraceToken(iterator, chars, fileType) &&\n          !braceMatcher.isRBraceToken(iterator, chars, fileType)\n          ) {\n        return true;\n      }\n\n      final char closingBrace = c == '(' ? ')' : ']';\n      int rparenOffset = BraceMatchingUtil.findRightmostRParen(iterator, braceMatcher.getTokenType(closingBrace, iterator),chars,fileType);\n      if (rparenOffset >= 0){\n        iterator = ((EditorEx)editor).getHighlighter().createIterator(rparenOffset);\n        boolean matched = BraceMatchingUtil.matchBrace(chars, fileType, iterator, false);\n        if (matched) return true;\n      }\n\n      editor.getDocument().deleteString(offset, offset + 1);\n    }\n    else if (c == '\"' || c == '\\''){\n      char c1 = chars.charAt(offset);\n      if (c1 != c) return true;\n      if (wasClosingQuote) return true;\n\n      HighlighterIterator iterator = ((EditorEx)editor).getHighlighter().createIterator(offset);\n      if (quoteHandler == null || !quoteHandler.isOpeningQuote(iterator,offset)) return true;\n\n      editor.getDocument().deleteString(offset, offset + 1);\n    }\n\n    return true;\n  }","id":65149,"modified_method":"private boolean handleBackspace(Editor editor, DataContext dataContext){\n    Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n    if (project == null) return false;\n\n    PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n\n    if (file == null) return false;\n\n    if (editor.getSelectionModel().hasSelection()) return false;\n\n    int offset = editor.getCaretModel().getOffset() - 1;\n    if (offset < 0) return false;\n    CharSequence chars = editor.getDocument().getCharsSequence();\n    char c = chars.charAt(offset);\n\n    final Editor injectedEditor = TypedHandler.injectedEditorIfCharTypedIsSignificant(c, editor, file);\n    if (injectedEditor != editor) {\n      file = PsiDocumentManager.getInstance(project).getPsiFile(injectedEditor.getDocument());\n      editor = injectedEditor;\n      offset = editor.getCaretModel().getOffset() - 1;\n      chars = editor.getDocument().getCharsSequence();\n    }\n\n    final BackspaceHandlerDelegate[] delegates = Extensions.getExtensions(BackspaceHandlerDelegate.EP_NAME);\n    for(BackspaceHandlerDelegate delegate: delegates) {\n      delegate.beforeCharDeleted(c, file, editor);\n    }\n\n    FileType fileType = file.getFileType();\n    final QuoteHandler quoteHandler = TypedHandler.getQuoteHandler(file);\n\n    HighlighterIterator hiterator = ((EditorEx)editor).getHighlighter().createIterator(offset);\n    boolean wasClosingQuote = quoteHandler != null && quoteHandler.isClosingQuote(hiterator, offset);\n\n    myOriginalHandler.execute(editor, dataContext);\n\n    if (offset >= editor.getDocument().getTextLength()) return true;\n\n    for(BackspaceHandlerDelegate delegate: delegates) {\n      if (delegate.charDeleted(c, file, editor)) {\n        return true;\n      }\n    }\n\n\n    chars = editor.getDocument().getCharsSequence();\n    if (c == '(' || c == '[' || c == '{'){\n      char c1 = chars.charAt(offset);\n      if (c == '(' && c1 != ')') return true;\n      if (c == '[' && c1 != ']') return true;\n      if (c == '{' && c1 != '}') return true;\n\n      HighlighterIterator iterator = ((EditorEx)editor).getHighlighter().createIterator(offset);\n      BraceMatcher braceMatcher = BraceMatchingUtil.getBraceMatcher(fileType);\n      if (!braceMatcher.isLBraceToken(iterator, chars, fileType) &&\n          !braceMatcher.isRBraceToken(iterator, chars, fileType)\n          ) {\n        return true;\n      }\n\n      int rparenOffset = BraceMatchingUtil.findRightmostRParen(iterator, iterator.getTokenType() ,chars,fileType);\n      if (rparenOffset >= 0){\n        iterator = ((EditorEx)editor).getHighlighter().createIterator(rparenOffset);\n        boolean matched = BraceMatchingUtil.matchBrace(chars, fileType, iterator, false);\n        if (matched) return true;\n      }\n\n      editor.getDocument().deleteString(offset, offset + 1);\n    }\n    else if (c == '\"' || c == '\\''){\n      char c1 = chars.charAt(offset);\n      if (c1 != c) return true;\n      if (wasClosingQuote) return true;\n\n      HighlighterIterator iterator = ((EditorEx)editor).getHighlighter().createIterator(offset);\n      if (quoteHandler == null || !quoteHandler.isOpeningQuote(iterator,offset)) return true;\n\n      editor.getDocument().deleteString(offset, offset + 1);\n    }\n\n    return true;\n  }","commit_id":"0c88c74ba59fc2b0575d3157dc273e3b625f00fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static BraceMatcher getBraceMatcher(FileType fileType) {\n    BraceMatcher braceMatcher = BRACE_MATCHERS.get(fileType);\n    if (braceMatcher==null) {\n      if (fileType instanceof LanguageFileType) {\n        final Language language = ((LanguageFileType)fileType).getLanguage();\n        final PairedBraceMatcher matcher = LanguageBraceMatching.INSTANCE.forLanguage(language);\n        if (matcher != null) {\n          braceMatcher = new PairedBraceMatcherAdapter(matcher,language);\n        }\n      }\n      if (braceMatcher == null) braceMatcher = ourDefaultBraceMatcher;\n      BRACE_MATCHERS.put(fileType, braceMatcher);\n    }\n    return braceMatcher;\n  }","id":65150,"modified_method":"public static BraceMatcher getBraceMatcher(FileType fileType) {\n    BraceMatcher braceMatcher = BRACE_MATCHERS.get(fileType);\n    if (braceMatcher==null) {\n      for(FileTypeExtensionPoint<BraceMatcher> ext:Extensions.getExtensions(BraceMatcher.EP_NAME)) {\n        if (fileType.getName().equals(ext.filetype)) {\n          braceMatcher = ext.getInstance();\n          break;\n        }\n      }\n      if (braceMatcher == null) {\n        if (fileType instanceof LanguageFileType) {\n          final Language language = ((LanguageFileType)fileType).getLanguage();\n          final PairedBraceMatcher matcher = LanguageBraceMatching.INSTANCE.forLanguage(language);\n          if (matcher != null) {\n            braceMatcher = new PairedBraceMatcherAdapter(matcher,language);\n          }\n        }\n      }\n      if (braceMatcher == null) {\n        if (ourDefaultBraceMatcher == null) {\n          ourDefaultBraceMatcher = new DefaultBraceMatcher();\n        }\n        braceMatcher = ourDefaultBraceMatcher;\n      }\n      BRACE_MATCHERS.put(fileType, braceMatcher);\n    }\n    return braceMatcher;\n  }","commit_id":"0c88c74ba59fc2b0575d3157dc273e3b625f00fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean findStructuralLeftBrace(FileType fileType, HighlighterIterator iterator, CharSequence fileText) {\n    ourBraceStack.clear();\n    ourTagNameStack.clear();\n\n    BraceMatcher matcher = getBraceMatcher(fileType);\n    if (matcher == null) return false;\n\n    while (!iterator.atEnd()) {\n      if (isStructuralBraceToken(fileType, iterator,fileText)) {\n        if (isRBraceToken(iterator, fileText, fileType)) {\n          ourBraceStack.push(iterator.getTokenType());\n          ourTagNameStack.push(matcher.getTagName(fileText, iterator));\n        }\n        if (isLBraceToken(iterator, fileText, fileType)) {\n          if (ourBraceStack.size() == 0) return true;\n\n          final int group = matcher.getTokenGroup(iterator.getTokenType());\n\n          final IElementType topTokenType = ourBraceStack.pop();\n          final IElementType tokenType = iterator.getTokenType();\n\n          boolean isStrict = matcher.isStrictTagMatching(fileType, group);\n          boolean isCaseSensitive = matcher.areTagsCaseSensitive(fileType, group);\n\n          String topTagName = null;\n          String tagName = null;\n          if (isStrict){\n            topTagName = ourTagNameStack.pop();\n            tagName = matcher.getTagName(fileText, iterator);\n          }\n\n          if (!isPairBraces(topTokenType, tokenType, fileType)\n            || isStrict && !Comparing.equal(topTagName, tagName, isCaseSensitive)) {\n            return false;\n          }\n        }\n      }\n\n      iterator.retreat();\n    }\n\n    return false;\n  }","id":65151,"modified_method":"public static boolean findStructuralLeftBrace(FileType fileType, HighlighterIterator iterator, CharSequence fileText) {\n    ourBraceStack.clear();\n    ourTagNameStack.clear();\n\n    BraceMatcher matcher = getBraceMatcher(fileType);\n    if (matcher == null) return false;\n\n    while (!iterator.atEnd()) {\n      if (isStructuralBraceToken(fileType, iterator,fileText)) {\n        if (isRBraceToken(iterator, fileText, fileType)) {\n          ourBraceStack.push(iterator.getTokenType());\n          ourTagNameStack.push(getTagName(matcher,fileText, iterator));\n        }\n        if (isLBraceToken(iterator, fileText, fileType)) {\n          if (ourBraceStack.size() == 0) return true;\n\n          final int group = matcher.getBraceTokenGroupId(iterator.getTokenType());\n\n          final IElementType topTokenType = ourBraceStack.pop();\n          final IElementType tokenType = iterator.getTokenType();\n\n          boolean isStrict = isStrictTagMatching(matcher,fileType, group);\n          boolean isCaseSensitive = areTagsCaseSensitive(matcher,fileType, group);\n\n          String topTagName = null;\n          String tagName = null;\n          if (isStrict){\n            topTagName = ourTagNameStack.pop();\n            tagName = getTagName(matcher,fileText, iterator);\n          }\n\n          if (!isPairBraces(topTokenType, tokenType, fileType)\n            || isStrict && !Comparing.equal(topTagName, tagName, isCaseSensitive)) {\n            return false;\n          }\n        }\n      }\n\n      iterator.retreat();\n    }\n\n    return false;\n  }","commit_id":"0c88c74ba59fc2b0575d3157dc273e3b625f00fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"boolean doBraceMatch() {\n      ourBraceStack.clear();\n      ourTagNameStack.clear();\n      ourBraceStack.push(brace1Token);\n      if (isStrict){\n        ourTagNameStack.push(brace1TagName);\n      }\n      boolean matched = false;\n      while(true){\n        if (!forward){\n          iterator.retreat();\n        }\n        else{\n          iterator.advance();\n        }\n        if (iterator.atEnd()) {\n          break;\n        }\n\n        IElementType tokenType = iterator.getTokenType();\n\n        if (getTokenGroup(tokenType, fileType) == group) {\n          String tagName = myMatcher == null ? null : myMatcher.getTagName(fileText, iterator);\n          if (!isStrict && !Comparing.equal(brace1TagName, tagName, isCaseSensitive)) continue;\n          if (forward ? isLBraceToken(iterator, fileText, fileType) : isRBraceToken(iterator, fileText, fileType)){\n            ourBraceStack.push(tokenType);\n            if (isStrict){\n              ourTagNameStack.push(tagName);\n            }\n          }\n          else if (forward ? isRBraceToken(iterator, fileText,fileType) : isLBraceToken(iterator, fileText, fileType)){\n            IElementType topTokenType = ourBraceStack.pop();\n            String topTagName = null;\n            if (isStrict){\n              topTagName = ourTagNameStack.pop();\n            }\n\n            if (!isPairBraces(topTokenType, tokenType, fileType)\n              || isStrict && !Comparing.equal(topTagName, tagName, isCaseSensitive)\n            ){\n              matched = false;\n              break;\n            }\n\n            if (ourBraceStack.size() == 0){\n              matched = true;\n              break;\n            }\n          }\n        }\n      }\n      return matched;\n    }","id":65152,"modified_method":"boolean doBraceMatch() {\n      ourBraceStack.clear();\n      ourTagNameStack.clear();\n      ourBraceStack.push(brace1Token);\n      if (isStrict){\n        ourTagNameStack.push(brace1TagName);\n      }\n      boolean matched = false;\n      while(true){\n        if (!forward){\n          iterator.retreat();\n        }\n        else{\n          iterator.advance();\n        }\n        if (iterator.atEnd()) {\n          break;\n        }\n\n        IElementType tokenType = iterator.getTokenType();\n\n        if (getTokenGroup(tokenType, fileType) == group) {\n          String tagName = myMatcher == null ? null : getTagName(myMatcher,fileText, iterator);\n          if (!isStrict && !Comparing.equal(brace1TagName, tagName, isCaseSensitive)) continue;\n          if (forward ? isLBraceToken(iterator, fileText, fileType) : isRBraceToken(iterator, fileText, fileType)){\n            ourBraceStack.push(tokenType);\n            if (isStrict){\n              ourTagNameStack.push(tagName);\n            }\n          }\n          else if (forward ? isRBraceToken(iterator, fileText,fileType) : isLBraceToken(iterator, fileText, fileType)){\n            IElementType topTokenType = ourBraceStack.pop();\n            String topTagName = null;\n            if (isStrict){\n              topTagName = ourTagNameStack.pop();\n            }\n\n            if (!isPairBraces(topTokenType, tokenType, fileType)\n              || isStrict && !Comparing.equal(topTagName, tagName, isCaseSensitive)\n            ){\n              matched = false;\n              break;\n            }\n\n            if (ourBraceStack.size() == 0){\n              matched = true;\n              break;\n            }\n          }\n        }\n      }\n      return matched;\n    }","commit_id":"0c88c74ba59fc2b0575d3157dc273e3b625f00fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"MatchBraceContext(CharSequence _fileText, FileType _fileType, HighlighterIterator _iterator, boolean _forward) {\n      fileText = _fileText;\n      fileType = _fileType;\n      iterator = _iterator;\n      forward = _forward;\n\n      myMatcher = getBraceMatcher(_fileType);\n      brace1Token = iterator.getTokenType();\n      group = getTokenGroup(brace1Token, fileType);\n      brace1TagName = myMatcher == null ? null : myMatcher.getTagName(fileText, iterator);\n\n      isStrict = myMatcher != null && myMatcher.isStrictTagMatching(fileType, group);\n      isCaseSensitive = myMatcher != null && myMatcher.areTagsCaseSensitive(fileType, group);\n    }","id":65153,"modified_method":"MatchBraceContext(CharSequence _fileText, FileType _fileType, HighlighterIterator _iterator, boolean _forward) {\n      fileText = _fileText;\n      fileType = _fileType;\n      iterator = _iterator;\n      forward = _forward;\n\n      myMatcher = getBraceMatcher(_fileType);\n      brace1Token = iterator.getTokenType();\n      group = getTokenGroup(brace1Token, fileType);\n      brace1TagName = myMatcher == null ? null : getTagName(myMatcher,fileText, iterator);\n\n      isStrict = myMatcher != null && isStrictTagMatching(myMatcher,fileType, group);\n      isCaseSensitive = myMatcher != null && areTagsCaseSensitive(myMatcher,fileType, group);\n    }","commit_id":"0c88c74ba59fc2b0575d3157dc273e3b625f00fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static int getTokenGroup(IElementType tokenType, FileType fileType){\n    BraceMatcher matcher = getBraceMatcher(fileType);\n    if (matcher!=null) return matcher.getTokenGroup(tokenType);\n    return UNDEFINED_TOKEN_GROUP;\n  }","id":65154,"modified_method":"private static int getTokenGroup(IElementType tokenType, FileType fileType){\n    BraceMatcher matcher = getBraceMatcher(fileType);\n    if (matcher!=null) return matcher.getBraceTokenGroupId(tokenType);\n    return UNDEFINED_TOKEN_GROUP;\n  }","commit_id":"0c88c74ba59fc2b0575d3157dc273e3b625f00fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Creates a new brace pair instance.\n   *\n   * @param leftBraceChar  the character for the left brace in the pair.\n   * @param leftBrace      the lexer token type for the left brace in the pair.\n   * @param rightBraceChar the character for the right brace in the pair.\n   * @param rightBrace     the lexer token type for the right brace in the pair.\n   * @param structural     if true, the brace is considered structural (see {@link #isStructural()} for details)\n   */\n  public BracePair(char leftBraceChar,\n                   final IElementType leftBrace,\n                   char rightBraceChar,\n                   final IElementType rightBrace,\n                   final boolean structural) {\n    myLeftBraceChar = leftBraceChar;\n    myLeftBrace = leftBrace;\n    myRightBraceChar = rightBraceChar;\n    myRightBrace = rightBrace;\n    myStructural = structural;\n  }","id":65155,"modified_method":"/**\n   * Creates a new brace pair instance.\n   *\n   * @param leftBrace      the lexer token type for the left brace in the pair.\n   * @param rightBrace     the lexer token type for the right brace in the pair.\n   * @param structural     if true, the brace is considered structural (see {@link #isStructural()} for details)\n   */\n  public BracePair(final IElementType leftBrace, final IElementType rightBrace, final boolean structural) {\n    myLeftBrace = leftBrace;\n    myRightBrace = rightBrace;\n    myStructural = structural;\n  }","commit_id":"0c88c74ba59fc2b0575d3157dc273e3b625f00fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getTokenGroup(IElementType tokenType) {\n    return 777;\n  }","id":65156,"modified_method":"public int getBraceTokenGroupId(IElementType tokenType) {\n    return 777;\n  }","commit_id":"0c88c74ba59fc2b0575d3157dc273e3b625f00fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getTokenGroup(IElementType tokenType) {\n    final BracePair[] pairs = myMatcher.getPairs();\n    for (BracePair pair : pairs) {\n      if (tokenType == pair.getLeftBraceType() || tokenType == pair.getRightBraceType()) return myLanguage.hashCode();\n    }\n    return -1;\n  }","id":65157,"modified_method":"public int getBraceTokenGroupId(IElementType tokenType) {\n    final BracePair[] pairs = myMatcher.getPairs();\n    for (BracePair pair : pairs) {\n      if (tokenType == pair.getLeftBraceType() || tokenType == pair.getRightBraceType()) return myLanguage.hashCode();\n    }\n    return -1;\n  }","commit_id":"0c88c74ba59fc2b0575d3157dc273e3b625f00fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean handleRParen(Editor editor, FileType fileType, char rightParen, char leftParen){\n    if (!CodeInsightSettings.getInstance().AUTOINSERT_PAIR_BRACKET) return false;\n\n    int offset = editor.getCaretModel().getOffset();\n\n    if (offset == editor.getDocument().getTextLength()) return false;\n\n    HighlighterIterator iterator = ((EditorEx) editor).getHighlighter().createIterator(offset);\n    BraceMatcher braceMatcher = BraceMatchingUtil.getBraceMatcher(fileType);\n    if (iterator.atEnd() || braceMatcher.getTokenType(rightParen,iterator) != iterator.getTokenType()) {\n      return false;\n    }\n\n    iterator.retreat();\n\n    int lparenthOffset = BraceMatchingUtil.findLeftmostLParen(iterator, braceMatcher.getTokenType(leftParen, iterator),  editor.getDocument().getCharsSequence(),fileType);\n    if (lparenthOffset < 0) return false;\n\n    iterator = ((EditorEx) editor).getHighlighter().createIterator(lparenthOffset);\n    boolean matched = BraceMatchingUtil.matchBrace(editor.getDocument().getCharsSequence(), fileType, iterator, true);\n\n    if (!matched) return false;\n\n    editor.getCaretModel().moveToOffset(offset + 1);\n    editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n    return true;\n  }","id":65158,"modified_method":"private static boolean handleRParen(Editor editor, FileType fileType){\n    if (!CodeInsightSettings.getInstance().AUTOINSERT_PAIR_BRACKET) return false;\n\n    int offset = editor.getCaretModel().getOffset();\n\n    if (offset == editor.getDocument().getTextLength()) return false;\n\n    HighlighterIterator iterator = ((EditorEx) editor).getHighlighter().createIterator(offset);\n    BraceMatcher braceMatcher = BraceMatchingUtil.getBraceMatcher(fileType);\n    if (iterator.atEnd()) return false;\n\n    if (!braceMatcher.isRBraceToken(iterator, editor.getDocument().getCharsSequence(), fileType)) {\n      return false;\n    }\n\n    IElementType tokenType = iterator.getTokenType();\n    \n    iterator.retreat();\n\n    int lparenthOffset = BraceMatchingUtil.findLeftmostLParen(iterator, braceMatcher.getOppositeBraceTokenType(tokenType),  editor.getDocument().getCharsSequence(),fileType);\n    if (lparenthOffset < 0) return false;\n\n    iterator = ((EditorEx) editor).getHighlighter().createIterator(lparenthOffset);\n    boolean matched = BraceMatchingUtil.matchBrace(editor.getDocument().getCharsSequence(), fileType, iterator, true);\n\n    if (!matched) return false;\n\n    editor.getCaretModel().moveToOffset(offset + 1);\n    editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n    return true;\n  }","commit_id":"0c88c74ba59fc2b0575d3157dc273e3b625f00fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void handleAfterLParen(Editor editor, FileType fileType, char lparenChar){\n    int offset = editor.getCaretModel().getOffset();\n    HighlighterIterator iterator = ((EditorEx) editor).getHighlighter().createIterator(offset);\n    boolean atEndOfDocument = offset == editor.getDocument().getTextLength();\n\n    if (!atEndOfDocument) iterator.retreat();\n    BraceMatcher braceMatcher = BraceMatchingUtil.getBraceMatcher(fileType);\n    IElementType braceTokenType = braceMatcher.getTokenType(lparenChar, iterator);\n    if (iterator.atEnd() || iterator.getTokenType() != braceTokenType) return;\n\n    if (!iterator.atEnd()) {\n      iterator.advance();\n\n      IElementType tokenType = iterator.atEnd() ? null : iterator.getTokenType();\n      if (!BraceMatchingUtil.isPairedBracesAllowedBeforeTypeInFileType(braceTokenType, tokenType, fileType)) {\n        return;\n      }\n\n      iterator.retreat();\n    }\n\n    int lparenOffset = BraceMatchingUtil.findLeftmostLParen(iterator, braceTokenType, editor.getDocument().getCharsSequence(),fileType);\n    if (lparenOffset < 0) lparenOffset = 0;\n\n    iterator = ((EditorEx)editor).getHighlighter().createIterator(lparenOffset);\n    boolean matched = BraceMatchingUtil.matchBrace(editor.getDocument().getCharsSequence(), fileType, iterator, true);\n\n    if (!matched){\n      String text;\n      if (lparenChar == '(') {\n        text = \")\";\n      }\n      else if (lparenChar == '[') {\n        text = \"]\";\n      }\n      else if (lparenChar == '<') {\n        text = \">\";\n      }\n      else {\n        LOG.assertTrue(false);\n\n        return;\n      }\n      editor.getDocument().insertString(offset, text);\n    }\n  }","id":65159,"modified_method":"private static void handleAfterLParen(Editor editor, FileType fileType, char lparenChar){\n    int offset = editor.getCaretModel().getOffset();\n    HighlighterIterator iterator = ((EditorEx) editor).getHighlighter().createIterator(offset);\n    boolean atEndOfDocument = offset == editor.getDocument().getTextLength();\n\n    if (!atEndOfDocument) iterator.retreat();\n    BraceMatcher braceMatcher = BraceMatchingUtil.getBraceMatcher(fileType);\n    if (iterator.atEnd()) return;\n    IElementType braceTokenType = iterator.getTokenType();\n    if (!braceMatcher.isLBraceToken(iterator, editor.getDocument().getCharsSequence(), fileType)) return;\n\n    if (!iterator.atEnd()) {\n      iterator.advance();\n\n      IElementType tokenType = iterator.atEnd() ? null : iterator.getTokenType();\n      if (!BraceMatchingUtil.isPairedBracesAllowedBeforeTypeInFileType(braceTokenType, tokenType, fileType)) {\n        return;\n      }\n\n      iterator.retreat();\n    }\n\n    int lparenOffset = BraceMatchingUtil.findLeftmostLParen(iterator, braceTokenType, editor.getDocument().getCharsSequence(),fileType);\n    if (lparenOffset < 0) lparenOffset = 0;\n\n    iterator = ((EditorEx)editor).getHighlighter().createIterator(lparenOffset);\n    boolean matched = BraceMatchingUtil.matchBrace(editor.getDocument().getCharsSequence(), fileType, iterator, true);\n\n    if (!matched){\n      String text;\n      if (lparenChar == '(') {\n        text = \")\";\n      }\n      else if (lparenChar == '[') {\n        text = \"]\";\n      }\n      else if (lparenChar == '<') {\n        text = \">\";\n      }\n      else {\n        LOG.assertTrue(false);\n\n        return;\n      }\n      editor.getDocument().insertString(offset, text);\n    }\n  }","commit_id":"0c88c74ba59fc2b0575d3157dc273e3b625f00fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void execute(Editor editor, char charTyped, DataContext dataContext) {\n    Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n    if (project == null || editor.isColumnMode()){\n      if (myOriginalHandler != null){\n        myOriginalHandler.execute(editor, charTyped, dataContext);\n      }\n      return;\n    }\n\n    PsiFile file = PsiUtilBase.getPsiFileInEditor(editor, project);\n\n    if (file == null){\n      if (myOriginalHandler != null){\n        myOriginalHandler.execute(editor, charTyped, dataContext);\n      }\n      return;\n    }\n\n    if (editor.isViewer()) return;\n\n    if (!editor.getDocument().isWritable()) {\n      if (!FileDocumentManager.fileForDocumentCheckedOutSuccessfully(editor.getDocument(), project)) {\n        return;\n      }\n    }\n\n    Editor injectedEditor = injectedEditorIfCharTypedIsSignificant(charTyped, editor, file);\n    if (injectedEditor != editor) {\n      file = PsiDocumentManager.getInstance(project).getPsiFile(injectedEditor.getDocument());\n      editor = injectedEditor;\n    }\n\n    final TypedHandlerDelegate[] delegates = Extensions.getExtensions(TypedHandlerDelegate.EP_NAME);\n    AutoPopupController autoPopupController = AutoPopupController.getInstance(project);\n\n    boolean handled = false;\n    for(TypedHandlerDelegate delegate: delegates) {\n      final TypedHandlerDelegate.Result result = delegate.checkAutoPopup(charTyped, project, editor, file);\n      handled = result == TypedHandlerDelegate.Result.STOP;\n      if (result != TypedHandlerDelegate.Result.CONTINUE) break;\n    }\n\n    if (!handled) {\n      if (charTyped == '.') {\n        autoPopupController.autoPopupMemberLookup(editor, null);\n      }\n\n      if (charTyped == '('){\n        autoPopupController.autoPopupParameterInfo(editor, null);\n      }\n    }\n\n    if (!editor.isInsertMode()){\n      myOriginalHandler.execute(editor, charTyped, dataContext);\n      return;\n    }\n\n    if (editor.getSelectionModel().hasSelection()){\n      EditorModificationUtil.deleteSelectedText(editor);\n    }\n\n    final VirtualFile virtualFile = file.getVirtualFile();\n    FileType fileType;\n\n    if (virtualFile != null){\n      fileType = virtualFile.getFileType();\n    }\n    else {\n      fileType = file.getFileType();\n    }\n\n    for(TypedHandlerDelegate delegate: delegates) {\n      final TypedHandlerDelegate.Result result = delegate.beforeCharTyped(charTyped, project, editor, file, fileType);\n      if (result == TypedHandlerDelegate.Result.STOP) return;\n      if (result == TypedHandlerDelegate.Result.DEFAULT) break;\n    }\n\n    if (')' == charTyped){\n      if (handleRParen(editor, fileType, ')', '(')) return;\n    }\n    else if (']' == charTyped){\n      if (handleRParen(editor, fileType, ']', '[')) return;\n    }\n    else if ('\"' == charTyped || '\\'' == charTyped){\n      if (handleQuote(editor, fileType, charTyped, dataContext)) return;\n    }\n\n    myOriginalHandler.execute(editor, charTyped, dataContext);\n\n    if ('(' == charTyped && CodeInsightSettings.getInstance().AUTOINSERT_PAIR_BRACKET){\n      handleAfterLParen(editor, fileType, '(');\n    }\n    else if ('[' == charTyped && CodeInsightSettings.getInstance().AUTOINSERT_PAIR_BRACKET){\n      handleAfterLParen(editor, fileType, '[');\n    }\n    else if ('}' == charTyped){\n      indentClosingBrace(project, editor);\n    }\n\n    for(TypedHandlerDelegate delegate: delegates) {\n      final TypedHandlerDelegate.Result result = delegate.charTyped(charTyped, project, editor, file);\n      if (result == TypedHandlerDelegate.Result.STOP) return;\n      if (result == TypedHandlerDelegate.Result.DEFAULT) break;\n    }\n    if ('{' == charTyped) {\n      indentOpenedBrace(project, editor);\n    }\n  }","id":65160,"modified_method":"public void execute(Editor editor, char charTyped, DataContext dataContext) {\n    Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n    if (project == null || editor.isColumnMode()){\n      if (myOriginalHandler != null){\n        myOriginalHandler.execute(editor, charTyped, dataContext);\n      }\n      return;\n    }\n\n    PsiFile file = PsiUtilBase.getPsiFileInEditor(editor, project);\n\n    if (file == null){\n      if (myOriginalHandler != null){\n        myOriginalHandler.execute(editor, charTyped, dataContext);\n      }\n      return;\n    }\n\n    if (editor.isViewer()) return;\n\n    if (!editor.getDocument().isWritable()) {\n      if (!FileDocumentManager.fileForDocumentCheckedOutSuccessfully(editor.getDocument(), project)) {\n        return;\n      }\n    }\n\n    Editor injectedEditor = injectedEditorIfCharTypedIsSignificant(charTyped, editor, file);\n    if (injectedEditor != editor) {\n      file = PsiDocumentManager.getInstance(project).getPsiFile(injectedEditor.getDocument());\n      editor = injectedEditor;\n    }\n\n    final TypedHandlerDelegate[] delegates = Extensions.getExtensions(TypedHandlerDelegate.EP_NAME);\n    AutoPopupController autoPopupController = AutoPopupController.getInstance(project);\n\n    boolean handled = false;\n    for(TypedHandlerDelegate delegate: delegates) {\n      final TypedHandlerDelegate.Result result = delegate.checkAutoPopup(charTyped, project, editor, file);\n      handled = result == TypedHandlerDelegate.Result.STOP;\n      if (result != TypedHandlerDelegate.Result.CONTINUE) break;\n    }\n\n    if (!handled) {\n      if (charTyped == '.') {\n        autoPopupController.autoPopupMemberLookup(editor, null);\n      }\n\n      if (charTyped == '('){\n        autoPopupController.autoPopupParameterInfo(editor, null);\n      }\n    }\n\n    if (!editor.isInsertMode()){\n      myOriginalHandler.execute(editor, charTyped, dataContext);\n      return;\n    }\n\n    if (editor.getSelectionModel().hasSelection()){\n      EditorModificationUtil.deleteSelectedText(editor);\n    }\n\n    final VirtualFile virtualFile = file.getVirtualFile();\n    FileType fileType;\n\n    if (virtualFile != null){\n      fileType = virtualFile.getFileType();\n    }\n    else {\n      fileType = file.getFileType();\n    }\n\n    for(TypedHandlerDelegate delegate: delegates) {\n      final TypedHandlerDelegate.Result result = delegate.beforeCharTyped(charTyped, project, editor, file, fileType);\n      if (result == TypedHandlerDelegate.Result.STOP) return;\n      if (result == TypedHandlerDelegate.Result.DEFAULT) break;\n    }\n\n    if (')' == charTyped){\n      if (handleRParen(editor, fileType)) return;\n    }\n    else if (']' == charTyped){\n      if (handleRParen(editor, fileType)) return;\n    }\n    else if ('\"' == charTyped || '\\'' == charTyped){\n      if (handleQuote(editor, fileType, charTyped, dataContext)) return;\n    }\n\n    myOriginalHandler.execute(editor, charTyped, dataContext);\n\n    if ('(' == charTyped && CodeInsightSettings.getInstance().AUTOINSERT_PAIR_BRACKET){\n      handleAfterLParen(editor, fileType, '(');\n    }\n    else if ('[' == charTyped && CodeInsightSettings.getInstance().AUTOINSERT_PAIR_BRACKET){\n      handleAfterLParen(editor, fileType, '[');\n    }\n    else if ('}' == charTyped){\n      indentClosingBrace(project, editor);\n    }\n\n    for(TypedHandlerDelegate delegate: delegates) {\n      final TypedHandlerDelegate.Result result = delegate.charTyped(charTyped, project, editor, file);\n      if (result == TypedHandlerDelegate.Result.STOP) return;\n      if (result == TypedHandlerDelegate.Result.DEFAULT) break;\n    }\n    if ('{' == charTyped) {\n      indentOpenedBrace(project, editor);\n    }\n  }","commit_id":"0c88c74ba59fc2b0575d3157dc273e3b625f00fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void translate(HighlighterIterator iterator, List<TextRange> ranges) {\n    if (iterator.atEnd()) return;\n    int offset = 0;\n    for (TextRange range : ranges) {\n      while (range.getStartOffset() > iterator.getStart()) {\n        iterator.advance();\n        if (iterator.atEnd()) return;\n      }\n      while (range.getEndOffset() >= iterator.getEnd()) {\n        int relativeStart = iterator.getStart() - range.getStartOffset();\n        boolean merged = false;\n        if (myMergeByTextAttributes && !myPieces.isEmpty()) {\n          Map.Entry<Integer, Element> entry = myPieces.lastEntry();\n          final Integer key = entry.getKey();\n          final Element element = entry.getValue();\n          if (element.getEnd() >= offset + relativeStart &&\n              element.getAttributes().equals(iterator.getTextAttributes()) &&\n              element.getElementType().equals(iterator.getTokenType())) {\n            merged = true;\n            myPieces.put(key, new Element(key,\n                                          offset + (iterator.getEnd() - range.getStartOffset()), iterator.getTokenType(),\n                                          iterator.getTextAttributes()));\n          }\n        }\n        if (!merged) {\n          myPieces.put(offset + relativeStart, new Element(offset + relativeStart,\n                                                           offset + (iterator.getEnd() - range.getStartOffset()), iterator.getTokenType(),\n                                                           iterator.getTextAttributes()));\n        }\n        iterator.advance();\n        if (iterator.atEnd()) return;\n      }\n      offset += range.getLength() + 1 + myAdditionalOffset;  // myAdditionalOffset because of extra line - for shoene separators\n    }\n  }","id":65161,"modified_method":"private void translate(HighlighterIterator iterator, List<TextRange> ranges) {\n    int offset = 0;\n    int index = 0;\n\n    while (!iterator.atEnd() && index < ranges.size()) {\n      TextRange range = ranges.get(index);\n\n      if (range.getStartOffset() >= iterator.getEnd()) {\n        iterator.advance();\n        continue;\n      }\n\n      if (range.getEndOffset() >= iterator.getStart()) {\n        int relativeStart = Math.max(iterator.getStart() - range.getStartOffset(), 0);\n        int relativeEnd = Math.min(iterator.getEnd() - range.getStartOffset(), range.getLength());\n        boolean merged = false;\n        if (myMergeByTextAttributes && !myPieces.isEmpty()) {\n          Map.Entry<Integer, Element> entry = myPieces.lastEntry();\n          final Integer key = entry.getKey();\n          final Element element = entry.getValue();\n          if (element.getEnd() >= offset + relativeStart &&\n              element.getAttributes().equals(iterator.getTextAttributes()) &&\n              element.getElementType().equals(iterator.getTokenType())) {\n            merged = true;\n            myPieces.put(key, new Element(key,\n                                          offset + relativeEnd,\n                                          iterator.getTokenType(),\n                                          iterator.getTextAttributes()));\n          }\n        }\n        if (!merged) {\n          myPieces.put(offset + relativeStart, new Element(offset + relativeStart,\n                                                           offset + relativeEnd,\n                                                           iterator.getTokenType(),\n                                                           iterator.getTextAttributes()));\n        }\n      }\n\n      if (range.getEndOffset() < iterator.getEnd()) {\n        offset += range.getLength() + 1 + myAdditionalOffset;  // myAdditionalOffset because of extra line - for shoene separators\n        index++;\n        continue;\n      }\n\n      iterator.advance();\n    }\n  }","commit_id":"34898d56b81a2c4396c51e78900172720ff8c4cb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public FileContent(@NotNull final VirtualFile file, @NotNull final CharSequence contentAsText, final Charset charset) {\n    this(file);\n    myContentAsText = contentAsText;\n    myCharset = charset;\n  }","id":65162,"modified_method":"public FileContent(@NotNull final VirtualFile file, @NotNull final CharSequence contentAsText, final Charset charset) {\n    this(file, contentAsText, null, charset);\n  }","commit_id":"800aa979087270e1bc6dce70bf346925fb5b1161","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public FileContent(@NotNull final VirtualFile file, @NotNull final byte[] content) {\n    this(file);\n    myContent = content;\n    myCharset = LoadTextUtil.detectCharsetAndSetBOM(file, content);\n  }","id":65163,"modified_method":"public FileContent(@NotNull final VirtualFile file, @NotNull final byte[] content) {\n    this(file, null, content, LoadTextUtil.detectCharsetAndSetBOM(file, content));\n  }","commit_id":"800aa979087270e1bc6dce70bf346925fb5b1161","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public FileContent(@NotNull final VirtualFile file) {\n    myFile = file;\n    myFileType = FileTypeManager.getInstance().getFileTypeByFile(file);\n    // remember name explicitly because the file could be renamed afterwards\n    fileName = file.getName();\n  }","id":65164,"modified_method":"public FileContent(@NotNull final VirtualFile file) {\n    this(file, null, null, null);\n  }","commit_id":"800aa979087270e1bc6dce70bf346925fb5b1161","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void readExternal(Element element) {\n    final PluginBean pluginBean = XmlSerializer.deserialize(element, PluginBean.class);\n\n    url = pluginBean.url;\n    myName = pluginBean.name;\n    String idString = pluginBean.id;\n    if (idString == null || idString.length() == 0) {\n      idString = myName;\n    }\n    myId = PluginId.getId(idString);\n\n    String internalVersionString = pluginBean.formatVersion;\n    if (internalVersionString != null) {\n      try {\n        final int formatVersion = Integer.parseInt(internalVersionString);\n      }\n      catch (NumberFormatException e) {\n        LOG.error(new PluginException(\"Invalid value in plugin.xml format version: \" + internalVersionString, e, myId));\n      }\n    }\n    myUseIdeaClassLoader = pluginBean.useIdeaClassLoader;\n    if (pluginBean.ideaVersion != null) {\n      mySinceBuild = pluginBean.ideaVersion.sinceBuild;\n      myUntilBuild = pluginBean.ideaVersion.untilBuild;\n    }\n\n    myResourceBundleBaseName = pluginBean.resourceBundle;\n\n    myDescriptionChildText = pluginBean.description;\n    myChangeNotes = pluginBean.changeNotes;\n    myVersion = pluginBean.pluginVersion;\n    myCategory = pluginBean.category;\n\n\n    if (pluginBean.vendor != null) {\n      myVendor = pluginBean.vendor.name;\n      myVendorEmail = pluginBean.vendor.email;\n      myVendorUrl = pluginBean.vendor.url;\n      myVendorLogoPath = pluginBean.vendor.logo;\n    }\n\n    Set<PluginId> dependentPlugins = new HashSet<PluginId>();\n    Set<PluginId> optionalDependentPlugins = new HashSet<PluginId>();\n    myOptionalConfigs = new HashMap<PluginId, String>();\n    if (pluginBean.dependencies != null) {\n      for (PluginDependency dependency : pluginBean.dependencies) {\n        String text = dependency.pluginId;\n        if (text != null && text.length() > 0) {\n          final PluginId id = PluginId.getId(text);\n          dependentPlugins.add(id);\n          if (dependency.optional) {\n            optionalDependentPlugins.add(id);\n            if (dependency.configFile != null && dependency.configFile.length() > 0) {\n              myOptionalConfigs.put(id, dependency.configFile);  \n            }\n          }\n        }\n      }\n    }\n    myDependencies = dependentPlugins.isEmpty() ? PluginId.EMPTY_ARRAY : dependentPlugins.toArray(new PluginId[dependentPlugins.size()]);\n    myOptionalDependencies = optionalDependentPlugins.isEmpty() ? PluginId.EMPTY_ARRAY : optionalDependentPlugins.toArray(new PluginId[optionalDependentPlugins.size()]);\n\n    List<HelpSetPath> hsPathes = new ArrayList<HelpSetPath>();\n    if (pluginBean.helpSets != null) {\n      for (PluginHelpSet pluginHelpSet : pluginBean.helpSets) {\n        HelpSetPath hsPath = new HelpSetPath(pluginHelpSet.file, pluginHelpSet.path);\n        hsPathes.add(hsPath);\n      }\n    }\n    myHelpSets = hsPathes.size()>0 ? hsPathes.toArray(new HelpSetPath[hsPathes.size()]) : HelpSetPath.EMPTY;\n\n    myAppComponents = pluginBean.applicationComponents;\n    myProjectComponents = pluginBean.projectComponents;\n    myModuleComponents = pluginBean.moduleComponents;\n\n    if (myAppComponents == null) myAppComponents = ComponentConfig.EMPTY_ARRAY;\n    if (myProjectComponents == null) myProjectComponents = ComponentConfig.EMPTY_ARRAY;\n    if (myModuleComponents == null) myModuleComponents = ComponentConfig.EMPTY_ARRAY;\n\n    myExtensions = copyElements(pluginBean.extensions);\n    myExtensionsPoints = copyElements(pluginBean.extensionPoints);\n    myActionsElements = copyElements(pluginBean.actions);\n\n    if (pluginBean.extensionPoints != null) {\n      myExtensionsPoints = new ArrayList<Element>();\n      for (Element root : pluginBean.extensionPoints) {\n        for (Object o : root.getChildren()) {\n          myExtensionsPoints.add((Element)o);\n        }\n      }\n    }\n\n    if (pluginBean.modules != null && !pluginBean.modules.isEmpty()) {\n      myModules = pluginBean.modules;\n    }\n  }","id":65165,"modified_method":"private void readExternal(Element element) {\n    final PluginBean pluginBean = XmlSerializer.deserialize(element, PluginBean.class);\n\n    url = pluginBean.url;\n    myName = pluginBean.name;\n    String idString = pluginBean.id;\n    if (idString == null || idString.length() == 0) {\n      idString = myName;\n    }\n    myId = PluginId.getId(idString);\n\n    String internalVersionString = pluginBean.formatVersion;\n    if (internalVersionString != null) {\n      try {\n        Integer.parseInt(internalVersionString);\n      }\n      catch (NumberFormatException e) {\n        LOG.error(new PluginException(\"Invalid value in plugin.xml format version: '\" + internalVersionString+\"'\", e, myId));\n      }\n    }\n    myUseIdeaClassLoader = pluginBean.useIdeaClassLoader;\n    if (pluginBean.ideaVersion != null) {\n      mySinceBuild = pluginBean.ideaVersion.sinceBuild;\n      myUntilBuild = pluginBean.ideaVersion.untilBuild;\n    }\n\n    myResourceBundleBaseName = pluginBean.resourceBundle;\n\n    myDescriptionChildText = pluginBean.description;\n    myChangeNotes = pluginBean.changeNotes;\n    myVersion = pluginBean.pluginVersion;\n    myCategory = pluginBean.category;\n\n\n    if (pluginBean.vendor != null) {\n      myVendor = pluginBean.vendor.name;\n      myVendorEmail = pluginBean.vendor.email;\n      myVendorUrl = pluginBean.vendor.url;\n      myVendorLogoPath = pluginBean.vendor.logo;\n    }\n\n    Set<PluginId> dependentPlugins = new HashSet<PluginId>();\n    Set<PluginId> optionalDependentPlugins = new HashSet<PluginId>();\n    myOptionalConfigs = new HashMap<PluginId, String>();\n    if (pluginBean.dependencies != null) {\n      for (PluginDependency dependency : pluginBean.dependencies) {\n        String text = dependency.pluginId;\n        if (text != null && text.length() > 0) {\n          final PluginId id = PluginId.getId(text);\n          dependentPlugins.add(id);\n          if (dependency.optional) {\n            optionalDependentPlugins.add(id);\n            if (dependency.configFile != null && dependency.configFile.length() > 0) {\n              myOptionalConfigs.put(id, dependency.configFile);  \n            }\n          }\n        }\n      }\n    }\n    myDependencies = dependentPlugins.isEmpty() ? PluginId.EMPTY_ARRAY : dependentPlugins.toArray(new PluginId[dependentPlugins.size()]);\n    myOptionalDependencies = optionalDependentPlugins.isEmpty() ? PluginId.EMPTY_ARRAY : optionalDependentPlugins.toArray(new PluginId[optionalDependentPlugins.size()]);\n\n    List<HelpSetPath> hsPathes = new ArrayList<HelpSetPath>();\n    if (pluginBean.helpSets != null) {\n      for (PluginHelpSet pluginHelpSet : pluginBean.helpSets) {\n        HelpSetPath hsPath = new HelpSetPath(pluginHelpSet.file, pluginHelpSet.path);\n        hsPathes.add(hsPath);\n      }\n    }\n    myHelpSets = !hsPathes.isEmpty() ? hsPathes.toArray(new HelpSetPath[hsPathes.size()]) : HelpSetPath.EMPTY;\n\n    myAppComponents = pluginBean.applicationComponents;\n    myProjectComponents = pluginBean.projectComponents;\n    myModuleComponents = pluginBean.moduleComponents;\n\n    if (myAppComponents == null) myAppComponents = ComponentConfig.EMPTY_ARRAY;\n    if (myProjectComponents == null) myProjectComponents = ComponentConfig.EMPTY_ARRAY;\n    if (myModuleComponents == null) myModuleComponents = ComponentConfig.EMPTY_ARRAY;\n\n    myExtensions = copyElements(pluginBean.extensions);\n    myExtensionsPoints = copyElements(pluginBean.extensionPoints);\n    myActionsElements = copyElements(pluginBean.actions);\n\n    if (pluginBean.modules != null && !pluginBean.modules.isEmpty()) {\n      myModules = pluginBean.modules;\n    }\n  }","commit_id":"800aa979087270e1bc6dce70bf346925fb5b1161","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean equals(Object o) {\n    if (this == o) return true;\n    if (!(o instanceof IdeaPluginDescriptorImpl)) return false;\n\n    final IdeaPluginDescriptorImpl pluginDescriptor = (IdeaPluginDescriptorImpl)o;\n\n    if (myName != null ? !myName.equals(pluginDescriptor.myName) : pluginDescriptor.myName != null) return false;\n\n    return true;\n  }","id":65166,"modified_method":"public boolean equals(Object o) {\n    if (this == o) return true;\n    if (!(o instanceof IdeaPluginDescriptorImpl)) return false;\n\n    final IdeaPluginDescriptorImpl pluginDescriptor = (IdeaPluginDescriptorImpl)o;\n\n    return myName == null ? pluginDescriptor.myName == null : myName.equals(pluginDescriptor.myName);\n  }","commit_id":"800aa979087270e1bc6dce70bf346925fb5b1161","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static IntentionAction wrap(@NotNull ProblemDescriptor descriptor, int fixNumber) {\n    LOG.assertTrue(fixNumber > -1);\n    LOG.assertTrue(descriptor.getFixes() != null && descriptor.getFixes().length > fixNumber);\n\n    final QuickFix fix = descriptor.getFixes()[fixNumber];\n    return fix instanceof IntentionAction ? (IntentionAction)fix : new QuickFixWrapper(descriptor, fixNumber);\n  }","id":65167,"modified_method":"public static IntentionAction wrap(@NotNull ProblemDescriptor descriptor, int fixNumber) {\n    LOG.assertTrue(fixNumber > -1);\n    QuickFix[] fixes = descriptor.getFixes();\n    LOG.assertTrue(fixes != null && fixes.length > fixNumber);\n\n    final QuickFix fix = fixes[fixNumber];\n    return fix instanceof IntentionAction ? (IntentionAction)fix : new QuickFixWrapper(descriptor, fixNumber);\n  }","commit_id":"800aa979087270e1bc6dce70bf346925fb5b1161","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Collection<HighlightInfo> getHighlights() {\n    ArrayList<HighlightInfo> highlights = new ArrayList<HighlightInfo>();\n    for (int i = 0; i < myDescriptors.size(); i++) {\n      ProblemDescriptor problemDescriptor = myDescriptors.get(i);\n      String message = renderDescriptionMessage(problemDescriptor);\n      PsiElement psiElement = problemDescriptor.getPsiElement();\n      HighlightInfo highlightInfo =\n        HighlightInfo.createHighlightInfo(HighlightInfoType.WARNING, psiElement, message, message);\n      highlights.add(highlightInfo);\n      LocalInspectionTool tool = myTools.get(i);\n      List<IntentionAction> options = new ArrayList<IntentionAction>();\n      options.add(new SwitchOffToolAction(tool));\n      options.add(new AddNoInspectionCommentAction(tool, psiElement));\n      options.add(new AddNoInspectionDocTagAction(tool, psiElement));\n      options.add(new AddNoInspectionForClassAction(tool, psiElement));\n      options.add(new AddSuppressWarningsAnnotationAction(tool, psiElement));\n      options.add(new AddSuppressWarningsAnnotationForClassAction(tool, psiElement));\n      options.add(new AddSuppressWarningsAnnotationForAllAction(psiElement));\n      if (problemDescriptor.getFixes() != null) {\n        for (int k = 0; k < problemDescriptor.getFixes().length; k++) {\n          QuickFixAction.registerQuickFixAction(highlightInfo, new QuickFixWrapper(problemDescriptor, k), options);\n        }\n      } else {\n        QuickFixAction.registerQuickFixAction(highlightInfo, new EmptyIntentionAction(tool.getDisplayName(), options), options);\n      }\n    }\n    return highlights;\n  }","id":65168,"modified_method":"public Collection<HighlightInfo> getHighlights() {\n    ArrayList<HighlightInfo> highlights = new ArrayList<HighlightInfo>();\n    for (int i = 0; i < myDescriptors.size(); i++) {\n      ProblemDescriptor problemDescriptor = myDescriptors.get(i);\n      String message = renderDescriptionMessage(problemDescriptor);\n      PsiElement psiElement = problemDescriptor.getPsiElement();\n      HighlightInfo highlightInfo =\n        HighlightInfo.createHighlightInfo(HighlightInfoType.WARNING, psiElement, message, message);\n      highlights.add(highlightInfo);\n      LocalInspectionTool tool = myTools.get(i);\n      List<IntentionAction> options = new ArrayList<IntentionAction>();\n      options.add(new SwitchOffToolAction(tool));\n      options.add(new AddNoInspectionCommentAction(tool, psiElement));\n      options.add(new AddNoInspectionDocTagAction(tool, psiElement));\n      options.add(new AddNoInspectionForClassAction(tool, psiElement));\n      options.add(new AddSuppressWarningsAnnotationAction(tool, psiElement));\n      options.add(new AddSuppressWarningsAnnotationForClassAction(tool, psiElement));\n      options.add(new AddSuppressWarningsAnnotationForAllAction(psiElement));\n      final LocalQuickFix[] fixes = problemDescriptor.getFixes();\n      if (fixes != null && fixes.length > 0) {\n        for (int k = 0; k < problemDescriptor.getFixes().length; k++) {\n          QuickFixAction.registerQuickFixAction(highlightInfo, new QuickFixWrapper(problemDescriptor, k), options);\n        }\n      } else {\n        QuickFixAction.registerQuickFixAction(highlightInfo, new EmptyIntentionAction(tool.getDisplayName(), options), options);\n      }\n    }\n    return highlights;\n  }","commit_id":"ff1f278d727dfe250015c466468dd3180c92b11c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void doApplyInformationToEditor() {\n    List<HighlightInfo> infos = new ArrayList<HighlightInfo>(myDescriptors.size());\n    for (int i = 0; i < myDescriptors.size(); i++) {\n      ProblemDescriptor descriptor = myDescriptors.get(i);\n      LocalInspectionTool tool = myTools.get(i);\n      //TODO\n      PsiElement psiElement = descriptor.getPsiElement();\n      if (psiElement == null) continue;\n      String message = renderDescriptionMessage(descriptor);\n      final HighlightInfoType level = myLevels.get(i);\n\n      HighlightDisplayKey key = HighlightDisplayKey.find(tool.getShortName());\n      InspectionProfileImpl inspectionProfile = DaemonCodeAnalyzerSettings.getInstance().getInspectionProfile();\n      if (!inspectionProfile.isToolEnabled(key)) continue;\n      final boolean isError = inspectionProfile.getErrorLevel(key) == HighlightDisplayLevel.ERROR;\n\n\n      HighlightInfoType type = new HighlightInfoType() {\n        public HighlightSeverity getSeverity() {\n          return isError ? HighlightSeverity.ERROR : HighlightSeverity.WARNING;\n        }\n\n        public TextAttributesKey getAttributesKey() {\n          return level.getAttributesKey();\n        }\n      };\n      String plainMessage = XmlUtil.unescape(message.replaceAll(\"<[^>]*>\", \"\"));\n      HighlightInfo highlightInfo = HighlightInfo.createHighlightInfo(type, psiElement, plainMessage, message);\n      infos.add(highlightInfo);\n      List<IntentionAction> options = new ArrayList<IntentionAction>();\n      options.add(new SwitchOffToolAction(tool));\n      options.add(new AddNoInspectionCommentAction(tool, psiElement));\n      options.add(new AddNoInspectionDocTagAction(tool, psiElement));\n      options.add(new AddNoInspectionForClassAction(tool, psiElement));\n      options.add(new AddNoInspectionAllForClassAction(psiElement));\n      options.add(new AddSuppressWarningsAnnotationAction(tool, psiElement));\n      options.add(new AddSuppressWarningsAnnotationForClassAction(tool, psiElement));\n      options.add(new AddSuppressWarningsAnnotationForAllAction(psiElement));\n      if (descriptor.getFixes() != null) {\n        for (int k = 0; k < descriptor.getFixes().length; k++) {\n          QuickFixAction.registerQuickFixAction(highlightInfo, new QuickFixWrapper(descriptor, k), options);\n        }\n      } else {\n        QuickFixAction.registerQuickFixAction(highlightInfo, new EmptyIntentionAction(tool.getDisplayName(), options), options);\n      }\n    }\n\n    UpdateHighlightersUtil.setHighlightersToEditor(myProject, myDocument, myStartOffset, myEndOffset, infos,\n                                                   UpdateHighlightersUtil.INSPECTION_HIGHLIGHTERS_GROUP);\n    myDescriptors = Collections.EMPTY_LIST;\n    myLevels = Collections.EMPTY_LIST;\n    myTools = Collections.EMPTY_LIST;\n\n    DaemonCodeAnalyzerImpl daemonCodeAnalyzer = (DaemonCodeAnalyzerImpl)DaemonCodeAnalyzer.getInstance(myProject);\n    daemonCodeAnalyzer.getFileStatusMap().markFileUpToDate(myDocument, FileStatusMap.LOCAL_INSPECTIONS);\n\n    ErrorStripeRenderer renderer = new RefreshStatusRenderer(myProject, daemonCodeAnalyzer, myDocument, myFile);\n    Editor[] editors = EditorFactory.getInstance().getEditors(myDocument, myProject);\n    for (Editor editor : editors) {\n      ((EditorMarkupModel)editor.getMarkupModel()).setErrorStripeRenderer(renderer);\n    }\n  }","id":65169,"modified_method":"public void doApplyInformationToEditor() {\n    List<HighlightInfo> infos = new ArrayList<HighlightInfo>(myDescriptors.size());\n    for (int i = 0; i < myDescriptors.size(); i++) {\n      ProblemDescriptor descriptor = myDescriptors.get(i);\n      LocalInspectionTool tool = myTools.get(i);\n      //TODO\n      PsiElement psiElement = descriptor.getPsiElement();\n      if (psiElement == null) continue;\n      String message = renderDescriptionMessage(descriptor);\n      final HighlightInfoType level = myLevels.get(i);\n\n      HighlightDisplayKey key = HighlightDisplayKey.find(tool.getShortName());\n      InspectionProfileImpl inspectionProfile = DaemonCodeAnalyzerSettings.getInstance().getInspectionProfile();\n      if (!inspectionProfile.isToolEnabled(key)) continue;\n      final boolean isError = inspectionProfile.getErrorLevel(key) == HighlightDisplayLevel.ERROR;\n\n\n      HighlightInfoType type = new HighlightInfoType() {\n        public HighlightSeverity getSeverity() {\n          return isError ? HighlightSeverity.ERROR : HighlightSeverity.WARNING;\n        }\n\n        public TextAttributesKey getAttributesKey() {\n          return level.getAttributesKey();\n        }\n      };\n      String plainMessage = XmlUtil.unescape(message.replaceAll(\"<[^>]*>\", \"\"));\n      HighlightInfo highlightInfo = HighlightInfo.createHighlightInfo(type, psiElement, plainMessage, message);\n      infos.add(highlightInfo);\n      List<IntentionAction> options = new ArrayList<IntentionAction>();\n      options.add(new SwitchOffToolAction(tool));\n      options.add(new AddNoInspectionCommentAction(tool, psiElement));\n      options.add(new AddNoInspectionDocTagAction(tool, psiElement));\n      options.add(new AddNoInspectionForClassAction(tool, psiElement));\n      options.add(new AddNoInspectionAllForClassAction(psiElement));\n      options.add(new AddSuppressWarningsAnnotationAction(tool, psiElement));\n      options.add(new AddSuppressWarningsAnnotationForClassAction(tool, psiElement));\n      options.add(new AddSuppressWarningsAnnotationForAllAction(psiElement));\n      final LocalQuickFix[] fixes = descriptor.getFixes();\n      if (fixes != null && fixes.length > 0) {\n        for (int k = 0; k < fixes.length; k++) {\n          QuickFixAction.registerQuickFixAction(highlightInfo, new QuickFixWrapper(descriptor, k), options);\n        }\n      } else {\n        QuickFixAction.registerQuickFixAction(highlightInfo, new EmptyIntentionAction(tool.getDisplayName(), options), options);\n      }\n    }\n\n    UpdateHighlightersUtil.setHighlightersToEditor(myProject, myDocument, myStartOffset, myEndOffset, infos,\n                                                   UpdateHighlightersUtil.INSPECTION_HIGHLIGHTERS_GROUP);\n    myDescriptors = Collections.EMPTY_LIST;\n    myLevels = Collections.EMPTY_LIST;\n    myTools = Collections.EMPTY_LIST;\n\n    DaemonCodeAnalyzerImpl daemonCodeAnalyzer = (DaemonCodeAnalyzerImpl)DaemonCodeAnalyzer.getInstance(myProject);\n    daemonCodeAnalyzer.getFileStatusMap().markFileUpToDate(myDocument, FileStatusMap.LOCAL_INSPECTIONS);\n\n    ErrorStripeRenderer renderer = new RefreshStatusRenderer(myProject, daemonCodeAnalyzer, myDocument, myFile);\n    Editor[] editors = EditorFactory.getInstance().getEditors(myDocument, myProject);\n    for (Editor editor : editors) {\n      ((EditorMarkupModel)editor.getMarkupModel()).setErrorStripeRenderer(renderer);\n    }\n  }","commit_id":"ff1f278d727dfe250015c466468dd3180c92b11c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    protected Object doExecute() throws Exception {\n        // validate input before creating containers\n        preCreateContainer(name);\n\n        CreateEnsembleOptions ensembleOptions = CreateEnsembleOptions.build().zookeeperPassword(zookeeperPassword).user(newUser, newUserPassword + \",\" + newUserRole);\n        CreateSshContainerOptions options = CreateContainerOptionsBuilder.ssh()\n        .name(name)\n        .resolver(resolver)\n        .ensembleServer(isEnsembleServer)\n        .number(1)\n        .host(host)\n        .username(user)\n        .password(password)\n        .privateKeyFile(privateKeyFile != null ? privateKeyFile : CreateSshContainerOptions.DEFAULT_PRIVATE_KEY_FILE)\n        .passPhrase(passPhrase)\n        .port(port)\n        .sshRetries(sshRetries)\n        .minimumPort(minimumPort)\n        .maximumPort(maximumPort)\n        .password(password)\n        .proxyUri(proxyUri != null ? proxyUri : fabricService.getMavenRepoURI())\n        .zookeeperUrl(fabricService.getZookeeperUrl())\n        .zookeeperPassword(isEnsembleServer && zookeeperPassword != null ? zookeeperPassword : fabricService.getZookeeperPassword())\n        .jvmOpts(jvmOpts)\n        .createEnsembleOptions(ensembleOptions);\n\n\n        if (path != null && !path.isEmpty()) {\n            options.setPath(path);\n        }\n\n        CreateContainerMetadata[] metadatas = fabricService.createContainers(options);\n\n        if (isEnsembleServer && metadatas != null && metadatas.length > 0 && metadatas[0].isSuccess()) {\n            ShellUtils.storeZookeeperPassword(session, metadatas[0].getCreateOptions().getZookeeperPassword());\n        }\n        // display containers\n        displayContainers(metadatas);\n        // and set its profiles and versions after creation\n        postCreateContainers(metadatas);\n        return null;\n    }","id":65170,"modified_method":"@Override\n    protected Object doExecute() throws Exception {\n        // validate input before creating containers\n        preCreateContainer(name);\n\n        CreateEnsembleOptions ensembleOptions = CreateEnsembleOptions.build().zookeeperPassword(zookeeperPassword).user(newUser, newUserPassword + \",\" + newUserRole);\n        CreateSshContainerOptions options = CreateContainerOptionsBuilder.ssh()\n        .name(name)\n        .resolver(resolver)\n        .ensembleServer(isEnsembleServer)\n        .number(number)\n        .host(host)\n        .username(user)\n        .password(password)\n        .privateKeyFile(privateKeyFile != null ? privateKeyFile : CreateSshContainerOptions.DEFAULT_PRIVATE_KEY_FILE)\n        .passPhrase(passPhrase)\n        .port(port)\n        .sshRetries(sshRetries)\n        .minimumPort(minimumPort)\n        .maximumPort(maximumPort)\n        .password(password)\n        .proxyUri(proxyUri != null ? proxyUri : fabricService.getMavenRepoURI())\n        .zookeeperUrl(fabricService.getZookeeperUrl())\n        .zookeeperPassword(isEnsembleServer && zookeeperPassword != null ? zookeeperPassword : fabricService.getZookeeperPassword())\n        .jvmOpts(jvmOpts)\n        .createEnsembleOptions(ensembleOptions);\n\n\n        if (path != null && !path.isEmpty()) {\n            options.setPath(path);\n        }\n\n        CreateContainerMetadata[] metadatas = fabricService.createContainers(options);\n\n        if (isEnsembleServer && metadatas != null && metadatas.length > 0 && metadatas[0].isSuccess()) {\n            ShellUtils.storeZookeeperPassword(session, metadatas[0].getCreateOptions().getZookeeperPassword());\n        }\n        // display containers\n        displayContainers(metadatas);\n        // and set its profiles and versions after creation\n        postCreateContainers(metadatas);\n        return null;\n    }","commit_id":"1e8e1e226c7d7a35dcd0f2da61fb97fc48a9b62d","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Creates a shell script for installing and starting up a container.\n     *\n     * @param options\n     * @return\n     * @throws MalformedURLException\n     */\n    public static String buildInstallAndStartScript(CreateRemoteContainerOptions options) throws MalformedURLException, URISyntaxException {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"#!/bin/bash\").append(\"\\n\");\n        sb.append(RUN_FUNCTION).append(\"\\n\");\n        sb.append(DOWNLOAD_FUNCTION).append(\"\\n\");\n        sb.append(MAVEN_DOWNLOAD_FUNCTION).append(\"\\n\");\n        sb.append(UPDATE_PKGS).append(\"\\n\");\n        sb.append(INSTALL_CURL).append(\"\\n\");\n        sb.append(INSTALL_JDK).append(\"\\n\");\n        sb.append(VALIDATE_REQUIREMENTS).append(\"\\n\");\n        sb.append(EXIT_IF_NOT_EXISTS).append(\"\\n\");\n        sb.append(COPY_NODE_METADATA).append(\"\\n\");\n        sb.append(KARAF_CHECK).append(\"\\n\");\n        sb.append(REPLACE_IN_FILE).append(\"\\n\");\n        sb.append(CONFIGURE_HOSTNAMES).append(\"\\n\");\n        sb.append(\"run mkdir -p \").append(options.getPath()).append(\"\\n\");\n        sb.append(\"run cd \").append(options.getPath()).append(\"\\n\");\n        sb.append(\"run mkdir -p \").append(options.getName()).append(\"\\n\");\n        sb.append(\"run cd \").append(options.getName()).append(\"\\n\");\n        //We need admin access to be able to install curl & java.\n        if (options.isAdminAccess()) {\n            //This is not really needed.\n            //Its just here as a silly workaround for some cases which fail to get the first thing installed.\n            sb.append(\"update_pkgs\").append(\"\\n\");\n            sb.append(\"install_openjdk\").append(\"\\n\");\n            sb.append(\"install_curl\").append(\"\\n\");\n        }\n        sb.append(\"validate_requirements\").append(\"\\n\");\n        extractZipIntoDirectory(sb, options.getProxyUri(), \"org.fusesource.fabric\", \"fuse-fabric\", FabricConstants.FABRIC_VERSION);\n        sb.append(\"run cd `\").append(FIRST_FABRIC_DIRECTORY).append(\"`\\n\");\n        List<String> lines = new ArrayList<String>();\n        String globalResolver = options.getResolver() != null ? options.getResolver() : ZkDefs.DEFAULT_RESOLVER;\n        lines.add(ZkDefs.GLOBAL_RESOLVER_PROPERTY + \"=\" + globalResolver);\n        appendFile(sb, \"etc/system.properties\", lines);\n        replaceLineInFile(sb, \"etc/system.properties\", \"karaf.name=root\", \"karaf.name=\" + options.getName());\n        //Apply port range\n        replaceLineInFile(sb, \"etc/org.apache.karaf.shell.cfg\", \"sshPort=\" + DEFAULT_SSH_PORT, \"sshPort=\" + Ports.mapPortToRange(DEFAULT_SSH_PORT, options.getMinimumPort(), options.getMaximumPort()));\n        replaceLineInFile(sb, \"etc/org.apache.karaf.management.cfg\", \"rmiRegistryPort = \" + DEFAULT_RMI_REGISTRY_PORT, \"rmiRegistryPort=\" + Ports.mapPortToRange(DEFAULT_RMI_REGISTRY_PORT, options.getMinimumPort(), options.getMaximumPort()));\n        replaceLineInFile(sb, \"etc/org.apache.karaf.management.cfg\", \"rmiServerPort = \" + DEFAULT_RMI_SERVER_PORT, \"rmiServerPort=\" + Ports.mapPortToRange(DEFAULT_RMI_SERVER_PORT, options.getMinimumPort(), options.getMaximumPort()));\n        appendFile(sb, \"etc/system.properties\", Arrays.asList(ZkDefs.MINIMUM_PORT + \"=\" + options.getMinimumPort()));\n        appendFile(sb, \"etc/system.properties\", Arrays.asList(ZkDefs.MAXIMUM_PORT + \"=\" + options.getMaximumPort()));\n\n        appendFile(sb, \"etc/system.properties\", Arrays.asList(\"\\n\"));\n\n        //Read all system properties\n        for (Map.Entry<String, Properties> entry : options.getSystemProperties().entrySet()) {\n            Properties sysprops = entry.getValue();\n            for (Map.Entry syspropEntry : sysprops.entrySet()) {\n                Object type = syspropEntry.getKey();\n                Object value = syspropEntry.getValue();\n                appendFile(sb, \"etc/system.properties\", Arrays.asList(type + \"=\" + value));\n            }\n        }\n\n        //TODO: Be simple & move all of the code below under system properties MAP.\n        if (options.getPreferredAddress() != null) {\n            appendFile(sb, \"etc/system.properties\", Arrays.asList(HostUtils.PREFERED_ADDRESS_PROPERTY_NAME + \"=\" + options.getPreferredAddress()));\n        }\n\n        if (options.isEnsembleServer()) {\n            appendFile(sb, \"etc/system.properties\", Arrays.asList(\"zookeeper.password = \" + options.getZookeeperPassword()));\n            appendFile(sb, \"etc/system.properties\", Arrays.asList(SystemProperties.ENSEMBLE_AUTOSTART + \"=true\"));\n            appendFile(sb, \"etc/system.properties\", Arrays.asList(SystemProperties.AGENT_AUTOSTART + \"=true\"));\n            appendFile(sb, \"etc/system.properties\", Arrays.asList(SystemProperties.PROFILES_AUTOIMPORT_PATH + \"=${karaf.home}/fabric/import/\"));\n            if (options.getCreateEnsembleOptions() != null && options.getCreateEnsembleOptions().getUsers() != null) {\n                for (Map.Entry<String, String> entry : options.getCreateEnsembleOptions().getUsers().entrySet()) {\n                    appendFile(sb, \"etc/users.properties\", Arrays.asList(entry.getKey() + \"=\" + entry.getValue()));\n                }\n            }\n        } else if (options.getZookeeperUrl() != null) {\n            appendFile(sb, \"etc/system.properties\", Arrays.asList(\"zookeeper.url = \" + options.getZookeeperUrl()));\n            appendFile(sb, \"etc/system.properties\", Arrays.asList(\"zookeeper.password = \" + options.getZookeeperPassword()));\n            appendFile(sb, \"etc/system.properties\", Arrays.asList(SystemProperties.AGENT_AUTOSTART + \"=true\"));\n            appendToLineInFile(sb, \"etc/org.apache.karaf.features.cfg\", \"featuresBoot=\", \"fabric-agent,\");\n        }\n\n        //Add the proxyURI to the list of repositories\n        if (options.getProxyUri() != null) {\n            appendToLineInFile(sb, \"etc/org.ops4j.pax.url.mvn.cfg\", \"repositories=\", options.getProxyUri().toString() + \",\");\n        }\n        //Just for ensemble servers we want to copy their creation metadata for import.\n        if (options.isEnsembleServer()) {\n            CreateContainerMetadata metadata = options.getMetadataMap().get(options.getName());\n            if (metadata != null) {\n                byte[] metadataPayload = ObjectUtils.toBytes(metadata);\n                if (metadataPayload != null && metadataPayload.length > 0) {\n                    sb.append(\"copy_node_metadata \").append(options.getName()).append(\" \").append(new String(Base64Encoder.encode(metadataPayload))).append(\"\\n\");\n                }\n            }\n        }\n        if (options instanceof CreateJCloudsContainerOptions) {\n\n            sb.append(\"configure_hostnames\").append(\" \").append(((CreateJCloudsContainerOptions) options).getProviderName()).append(\"\\n\");\n        }\n        if (options.getJvmOpts() != null && !options.getJvmOpts().isEmpty()) {\n            sb.append(\"export JAVA_OPTS=\" + options.getJvmOpts()).append(\"\\n\");\n        }\n        sb.append(\"nohup bin/start &\").append(\"\\n\");\n        sb.append(\"karaf_check `pwd`\").append(\"\\n\");\n        return sb.toString();\n    }","id":65171,"modified_method":"/**\n     * Creates a shell script for installing and starting up a container.\n     *\n     * @param options\n     * @return\n     * @throws MalformedURLException\n     */\n    public static String buildInstallAndStartScript(CreateRemoteContainerOptions options) throws MalformedURLException, URISyntaxException {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"#!/bin/bash\").append(\"\\n\");\n        sb.append(RUN_FUNCTION).append(\"\\n\");\n        sb.append(DOWNLOAD_FUNCTION).append(\"\\n\");\n        sb.append(MAVEN_DOWNLOAD_FUNCTION).append(\"\\n\");\n        sb.append(UPDATE_PKGS).append(\"\\n\");\n        sb.append(INSTALL_CURL).append(\"\\n\");\n        sb.append(INSTALL_JDK).append(\"\\n\");\n        sb.append(VALIDATE_REQUIREMENTS).append(\"\\n\");\n        sb.append(EXIT_IF_NOT_EXISTS).append(\"\\n\");\n        sb.append(COPY_NODE_METADATA).append(\"\\n\");\n        sb.append(KARAF_CHECK).append(\"\\n\");\n        sb.append(REPLACE_IN_FILE).append(\"\\n\");\n        sb.append(CONFIGURE_HOSTNAMES).append(\"\\n\");\n\t\tsb.append(FIND_FREE_PORT).append(\"\\n\");\n        sb.append(\"run mkdir -p \").append(options.getPath()).append(\"\\n\");\n        sb.append(\"run cd \").append(options.getPath()).append(\"\\n\");\n        sb.append(\"run mkdir -p \").append(options.getName()).append(\"\\n\");\n        sb.append(\"run cd \").append(options.getName()).append(\"\\n\");\n        //We need admin access to be able to install curl & java.\n        if (options.isAdminAccess()) {\n            //This is not really needed.\n            //Its just here as a silly workaround for some cases which fail to get the first thing installed.\n            sb.append(\"update_pkgs\").append(\"\\n\");\n            sb.append(\"install_openjdk\").append(\"\\n\");\n            sb.append(\"install_curl\").append(\"\\n\");\n        }\n        sb.append(\"validate_requirements\").append(\"\\n\");\n        extractZipIntoDirectory(sb, options.getProxyUri(), \"org.fusesource.fabric\", \"fuse-fabric\", FabricConstants.FABRIC_VERSION);\n        sb.append(\"run cd `\").append(FIRST_FABRIC_DIRECTORY).append(\"`\\n\");\n        List<String> lines = new ArrayList<String>();\n        String globalResolver = options.getResolver() != null ? options.getResolver() : ZkDefs.DEFAULT_RESOLVER;\n        lines.add(ZkDefs.GLOBAL_RESOLVER_PROPERTY + \"=\" + globalResolver);\n        appendFile(sb, \"etc/system.properties\", lines);\n        replaceLineInFile(sb, \"etc/system.properties\", \"karaf.name=root\", \"karaf.name=\" + options.getName());\n        //Apply port range\n\t\tsb.append(\"SSH_PORT=\").append(\"`find_free_port \").append(Ports.mapPortToRange(DEFAULT_SSH_PORT, options.getMinimumPort(), options.getMaximumPort())).append(\" \").append(options.getMaximumPort()).append(\"`\\n\");\n\t\tsb.append(\"RMI_REGISTRY_PORT=\").append(\"`find_free_port \").append(Ports.mapPortToRange(DEFAULT_RMI_REGISTRY_PORT, options.getMinimumPort(), options.getMaximumPort())).append(\" \").append(options.getMaximumPort()).append(\"`\\n\");\n\t\tsb.append(\"RMI_SERVER_PORT=\").append(\"`find_free_port \").append(Ports.mapPortToRange(DEFAULT_RMI_SERVER_PORT, options.getMinimumPort(), options.getMaximumPort())).append(\" \").append(options.getMaximumPort()).append(\"`\\n\");\n\t\tsb.append(\"HTTP_PORT=\").append(\"`find_free_port \").append(Ports.mapPortToRange(DEFAULT_HTTP_PORT, options.getMinimumPort(), options.getMaximumPort())).append(\" \").append(options.getMaximumPort()).append(\"`\\n\");\n\n        replaceLineInFile(sb, \"etc/org.apache.karaf.shell.cfg\", \"sshPort=\" + DEFAULT_SSH_PORT, \"sshPort=$SSH_PORT\" );\n        replaceLineInFile(sb, \"etc/org.apache.karaf.management.cfg\", \"rmiRegistryPort = \" + DEFAULT_RMI_REGISTRY_PORT, \"rmiRegistryPort=$RMI_REGISTRY_PORT\");\n        replaceLineInFile(sb, \"etc/org.apache.karaf.management.cfg\", \"rmiServerPort = \" + DEFAULT_RMI_SERVER_PORT, \"rmiServerPort=$RMI_SERVER_PORT\");\n\t\treplaceLineInFile(sb, \"etc/org.ops4j.pax.web.cfg\", String.valueOf(DEFAULT_HTTP_PORT), \"$HTTP_PORT\");\n\t\treplaceLineInFile(sb, \"etc/jetty.xml\", String.valueOf(DEFAULT_HTTP_PORT), \"$HTTP_PORT\");\n        appendFile(sb, \"etc/system.properties\", Arrays.asList(ZkDefs.MINIMUM_PORT + \"=\" + options.getMinimumPort()));\n        appendFile(sb, \"etc/system.properties\", Arrays.asList(ZkDefs.MAXIMUM_PORT + \"=\" + options.getMaximumPort()));\n\n        appendFile(sb, \"etc/system.properties\", Arrays.asList(\"\\n\"));\n\n        //Read all system properties\n        for (Map.Entry<String, Properties> entry : options.getSystemProperties().entrySet()) {\n            Properties sysprops = entry.getValue();\n            for (Map.Entry syspropEntry : sysprops.entrySet()) {\n                Object type = syspropEntry.getKey();\n                Object value = syspropEntry.getValue();\n                appendFile(sb, \"etc/system.properties\", Arrays.asList(type + \"=\" + value));\n            }\n        }\n\n        //TODO: Be simple & move all of the code below under system properties MAP.\n        if (options.getPreferredAddress() != null) {\n            appendFile(sb, \"etc/system.properties\", Arrays.asList(HostUtils.PREFERED_ADDRESS_PROPERTY_NAME + \"=\" + options.getPreferredAddress()));\n        }\n\n        if (options.isEnsembleServer()) {\n            appendFile(sb, \"etc/system.properties\", Arrays.asList(\"zookeeper.password = \" + options.getZookeeperPassword()));\n            appendFile(sb, \"etc/system.properties\", Arrays.asList(SystemProperties.ENSEMBLE_AUTOSTART + \"=true\"));\n            appendFile(sb, \"etc/system.properties\", Arrays.asList(SystemProperties.AGENT_AUTOSTART + \"=true\"));\n            appendFile(sb, \"etc/system.properties\", Arrays.asList(SystemProperties.PROFILES_AUTOIMPORT_PATH + \"=${karaf.home}/fabric/import/\"));\n            if (options.getCreateEnsembleOptions() != null && options.getCreateEnsembleOptions().getUsers() != null) {\n                for (Map.Entry<String, String> entry : options.getCreateEnsembleOptions().getUsers().entrySet()) {\n                    appendFile(sb, \"etc/users.properties\", Arrays.asList(entry.getKey() + \"=\" + entry.getValue()));\n                }\n            }\n        } else if (options.getZookeeperUrl() != null) {\n            appendFile(sb, \"etc/system.properties\", Arrays.asList(\"zookeeper.url = \" + options.getZookeeperUrl()));\n            appendFile(sb, \"etc/system.properties\", Arrays.asList(\"zookeeper.password = \" + options.getZookeeperPassword()));\n            appendFile(sb, \"etc/system.properties\", Arrays.asList(SystemProperties.AGENT_AUTOSTART + \"=true\"));\n            appendToLineInFile(sb, \"etc/org.apache.karaf.features.cfg\", \"featuresBoot=\", \"fabric-agent,\");\n        }\n\n        //Add the proxyURI to the list of repositories\n        if (options.getProxyUri() != null) {\n            appendToLineInFile(sb, \"etc/org.ops4j.pax.url.mvn.cfg\", \"repositories=\", options.getProxyUri().toString() + \",\");\n        }\n        //Just for ensemble servers we want to copy their creation metadata for import.\n        if (options.isEnsembleServer()) {\n            CreateContainerMetadata metadata = options.getMetadataMap().get(options.getName());\n            if (metadata != null) {\n                byte[] metadataPayload = ObjectUtils.toBytes(metadata);\n                if (metadataPayload != null && metadataPayload.length > 0) {\n                    sb.append(\"copy_node_metadata \").append(options.getName()).append(\" \").append(new String(Base64Encoder.encode(metadataPayload))).append(\"\\n\");\n                }\n            }\n        }\n        if (options instanceof CreateJCloudsContainerOptions) {\n\n            sb.append(\"configure_hostnames\").append(\" \").append(((CreateJCloudsContainerOptions) options).getProviderName()).append(\"\\n\");\n        }\n        if (options.getJvmOpts() != null && !options.getJvmOpts().isEmpty()) {\n            sb.append(\"export JAVA_OPTS=\" + options.getJvmOpts()).append(\"\\n\");\n        }\n        sb.append(\"nohup bin/start &\").append(\"\\n\");\n        sb.append(\"karaf_check `pwd`\").append(\"\\n\");\n        return sb.toString();\n    }","commit_id":"1e8e1e226c7d7a35dcd0f2da61fb97fc48a9b62d","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public static float maxValue(float[] from) {\n    float result = from[0];\n    for (int i = 1; i<from.length; ++i)\n      if (from[i]>result) result = from[i];\n    return result;\n  }","id":65172,"modified_method":"public static float maxValue(float[] ary) {\n    return maxValue(ary,0,ary.length);\n  }","commit_id":"7b7d5ef0274d93d86cd78b89183dbfb3dadb00b8","url":"https://github.com/h2oai/h2o-3"},{"original_method":"protected void processRow(long gid, double [] nums, int ncats, int [] cats, double [] response, NewChunk [] outputs){throw new RuntimeException(\"should have been overridden!\");}","id":65173,"modified_method":"protected void processRow(long gid, double [] nums, int ncats, int [] cats, double [] response, NewChunk [] outputs){throw new RuntimeException(\"should've been overriden!\");}","commit_id":"7b7d5ef0274d93d86cd78b89183dbfb3dadb00b8","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n     * Prepare a Frame (with a single response) to be processed by the FrameTask\n     * 1) Place response at the end\n     * 2) (Optionally) Remove columns with constant values or with greater than 20% NaNs\n     * 3) Possibly turn integer categoricals into enums\n     *\n     * @param source A frame to be expanded and sanity checked\n     * @param response (should be part of source)\n     * @param toEnum Whether or not to turn categoricals into enums\n     * @param dropConstantCols Whether or not to drop constant columns\n     * @return Frame to be used by FrameTask\n     */\n    public static Frame prepareFrame(Frame source, Vec response, int[] ignored_cols, boolean toEnum, boolean dropConstantCols, boolean dropNACols) {\n      Frame fr = new Frame(source._names.clone(), source.vecs().clone());\n      if (ignored_cols != null) fr.remove(ignored_cols);\n      final Vec[] vecs =  fr.vecs();\n\n      // put response to the end (if not already)\n      for(int i = 0; i < vecs.length-1; ++i) {\n        if(vecs[i] == response){\n          final String n = fr._names[i];\n          if (toEnum && !vecs[i].isEnum()) fr.add(n, fr.remove(i).toEnum()); //convert int classes to enums\n          else fr.add(n, fr.remove(i));\n          break;\n        }\n      }\n      // special case for when response was at the end already\n      if (toEnum && !response.isEnum() && vecs[vecs.length-1] == response) {\n        final String n = fr._names[vecs.length-1];\n        fr.add(n, fr.remove(vecs.length-1).toEnum());\n      }\n\n      ArrayList<Integer> constantOrNAs = new ArrayList<>();\n      {\n        ArrayList<Integer> constantCols = new ArrayList<>();\n        ArrayList<Integer> NACols = new ArrayList<>();\n        for(int i = 0; i < vecs.length-1; ++i) {\n          // remove constant cols and cols with too many NAs\n          final boolean dropconstant = dropConstantCols && vecs[i].min() == vecs[i].max();\n          final boolean droptoomanyNAs = dropNACols && vecs[i].naCnt() > vecs[i].length()*1;\n          if(dropconstant) {\n            constantCols.add(i);\n          } else if (droptoomanyNAs) {\n            NACols.add(i);\n          }\n        }\n        constantOrNAs.addAll(constantCols);\n        constantOrNAs.addAll(NACols);\n\n        // Report what is dropped\n        String msg = \"\";\n        if (constantCols.size() > 0) msg += \"Dropping constant column(s): \";\n        for (int i : constantCols) msg += fr._names[i] + \" \";\n        if (NACols.size() > 0) msg += \"Dropping column(s) with too many missing values: \";\n        for (int i : NACols) msg += fr._names[i] + \" (\" + String.format(\"%.2f\", vecs[i].naCnt() * 100. / vecs[i].length()) + \"%) \";\n        for (String s : msg.split(\"\\n\")) Log.info(s);\n      }\n      if(!constantOrNAs.isEmpty()){\n        int [] cols = new int[constantOrNAs.size()];\n        for(int i = 0; i < cols.length; ++i)\n          cols[i] = constantOrNAs.get(i);\n        fr.remove(cols);\n      }\n      return fr;\n    }","id":65174,"modified_method":"/**\n     * Prepare a Frame (with a single response) to be processed by the FrameTask\n     * 1) Place response at the end\n     * 2) (Optionally) Remove columns with constant values or with greater than 20% NaNs\n     * 3) Possibly turn integer categoricals into enums\n     *\n     * @param source A frame to be expanded and sanity checked\n     * @param response (should be part of source)\n     * @param toEnum Whether or not to turn categoricals into enums\n     * @param dropConstantCols Whether or not to drop constant columns\n     * @return Frame to be used by FrameTask\n     */\n    public static Frame prepareFrame(Frame source, Vec response, int[] ignored_cols, boolean toEnum, boolean dropConstantCols, boolean dropNACols) {\n      Frame fr = new Frame(null /* not putting this into KV */, source._names.clone(), source.vecs().clone());\n      if (ignored_cols != null) fr.remove(ignored_cols);\n      final Vec[] vecs =  fr.vecs();\n\n      // put response to the end (if not already)\n      if (response != null) {\n        for (int i = 0; i < vecs.length - 1; ++i) {\n          if (vecs[i] == response) {\n            final String n = fr._names[i];\n            if (toEnum && !vecs[i].isEnum()) fr.add(n, fr.remove(i).toEnum()); //convert int classes to enums\n            else fr.add(n, fr.remove(i));\n            break;\n          }\n        }\n        // special case for when response was at the end already\n        if (toEnum && !response.isEnum() && vecs[vecs.length - 1] == response) {\n          final String n = fr._names[vecs.length - 1];\n          fr.add(n, fr.remove(vecs.length - 1).toEnum());\n        }\n      }\n\n      ArrayList<Integer> constantOrNAs = new ArrayList<>();\n      {\n        ArrayList<Integer> constantCols = new ArrayList<>();\n        ArrayList<Integer> NACols = new ArrayList<>();\n        for(int i = 0; i < vecs.length-1; ++i) {\n          // remove constant cols and cols with too many NAs\n          final boolean dropconstant = dropConstantCols && vecs[i].min() == vecs[i].max();\n          final boolean droptoomanyNAs = dropNACols && vecs[i].naCnt() > vecs[i].length()*1;\n          if(dropconstant) {\n            constantCols.add(i);\n          } else if (droptoomanyNAs) {\n            NACols.add(i);\n          }\n        }\n        constantOrNAs.addAll(constantCols);\n        constantOrNAs.addAll(NACols);\n\n        // Report what is dropped\n        String msg = \"\";\n        if (constantCols.size() > 0) msg += \"Dropping constant column(s): \";\n        for (int i : constantCols) msg += fr._names[i] + \" \";\n        if (NACols.size() > 0) msg += \"Dropping column(s) with too many missing values: \";\n        for (int i : NACols) msg += fr._names[i] + \" (\" + String.format(\"%.2f\", vecs[i].naCnt() * 100. / vecs[i].length()) + \"%) \";\n        for (String s : msg.split(\"\\n\")) Log.info(s);\n      }\n      if(!constantOrNAs.isEmpty()){\n        int [] cols = new int[constantOrNAs.size()];\n        for(int i = 0; i < cols.length; ++i)\n          cols[i] = constantOrNAs.get(i);\n        fr.remove(cols);\n      }\n      return fr;\n    }","commit_id":"7b7d5ef0274d93d86cd78b89183dbfb3dadb00b8","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * Method to process one row of the data for GLM functions.\n   * Numeric and categorical values are passed separately, as is response.\n   * Categoricals are passed as absolute indexes into the expanded beta vector, 0-levels are skipped\n   * (so the number of passed categoricals will not be the same for every row).\n   *\n   * Categorical expansion/indexing:\n   *   Categoricals are placed in the beginning of the beta vector.\n   *   Each cat variable with n levels is expanded into n-1 independent binary variables.\n   *   Indexes in cats[] will point to the appropriate coefficient in the beta vector, so e.g.\n   *   assume we have 2 categorical columns both with values A,B,C, then the following rows will have following indexes:\n   *      A,A - ncats = 0, we do not pass any categorical here\n   *      A,B - ncats = 1, indexes = [2]\n   *      B,B - ncats = 2, indexes = [0,2]\n   *      and so on\n   *\n   * @param gid      - global id of this row, in [0,_adaptedFrame.numRows())\n   * @param nums     - numeric values of this row\n   * @param ncats    - number of passed (non-zero) categoricals\n   * @param cats     - indexes of categoricals into the expanded beta-vector.\n   * @param response - numeric value for the response\n   */\n  protected void processRow(long gid, double [] nums, int ncats, int [] cats, double [] response){throw new RuntimeException(\"should have been overridden!\");}","id":65175,"modified_method":"/**\n   * Method to process one row of the data for GLM functions.\n   * Numeric and categorical values are passed separately, as is response.\n   * Categoricals are passed as absolute indexes into the expanded beta vector, 0-levels are skipped\n   * (so the number of passed categoricals will not be the same for every row).\n   *\n   * Categorical expansion/indexing:\n   *   Categoricals are placed in the beginning of the beta vector.\n   *   Each cat variable with n levels is expanded into n-1 independent binary variables.\n   *   Indexes in cats[] will point to the appropriate coefficient in the beta vector, so e.g.\n   *   assume we have 2 categorical columns both with values A,B,C, then the following rows will have following indexes:\n   *      A,A - ncats = 0, we do not pass any categorical here\n   *      A,B - ncats = 1, indexes = [2]\n   *      B,B - ncats = 2, indexes = [0,2]\n   *      and so on\n   *\n   * @param gid      - global id of this row, in [0,_adaptedFrame.numRows())\n   * @param nums     - numeric values of this row\n   * @param ncats    - number of passed (non-zero) categoricals\n   * @param cats     - indexes of categoricals into the expanded beta-vector.\n   * @param response - numeric value for the response\n   */\n  protected void processRow(long gid, double [] nums, int ncats, int [] cats, double [] response){throw new RuntimeException(\"should've been overriden!\");}","commit_id":"7b7d5ef0274d93d86cd78b89183dbfb3dadb00b8","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * Extracts the values, applies regularization to numerics, adds appropriate offsets to categoricals,\n   * and adapts response according to the CaseMode/CaseValue if set.\n   */\n  @Override public final void map(Chunk [] chunks, NewChunk [] outputs){\n    if(_job != null && _job._key != null && !Job.isRunning(_job._key)) throw new RuntimeException(\"Job cancelled\");\n    final int nrows = chunks[0].len();\n    final long offset = chunks[0].start();\n    chunkInit();\n    double [] nums = MemoryManager.malloc8d(_dinfo._nums);\n    int    [] cats = MemoryManager.malloc4(_dinfo._cats);\n    double [] response = MemoryManager.malloc8d(_dinfo._responses);\n    int start = 0;\n    int end = nrows;\n\n    boolean contiguous = false;\n    Random skip_rng = null; //random generator for skipping rows\n\n    //Example:\n    // _useFraction = 0.8 -> 1 repeat with fraction = 0.8\n    // _useFraction = 1.0 -> 1 repeat with fraction = 1.0\n    // _useFraction = 1.1 -> 2 repeats with fraction = 0.55\n    // _useFraction = 2.1 -> 3 repeats with fraction = 0.7\n    // _useFraction = 3.0 -> 3 repeats with fraction = 1.0\n    final int repeats = (int)Math.ceil(_useFraction);\n    final float fraction = _useFraction / repeats;\n\n    if (fraction < 1.0) {\n      skip_rng = getDeterRNG(new Random().nextLong());\n      if (contiguous) {\n        final int howmany = (int)Math.ceil(fraction*nrows);\n        if (howmany > 0) {\n          start = skip_rng.nextInt(nrows - howmany);\n          end = start + howmany;\n        }\n        assert(start < nrows);\n        assert(end <= nrows);\n      }\n    }\n\n    long[] shuf_map = null;\n    if (_shuffle) {\n      shuf_map = new long[end-start];\n      for (int i=0;i<shuf_map.length;++i)\n        shuf_map[i] = start + i;\n      shuffleArray(shuf_map, new Random().nextLong());\n    }\n    for(int rrr = 0; rrr < repeats; ++rrr) {\n    OUTER:\n      for(int rr = start; rr < end; ++rr){\n        final int r = shuf_map != null ? (int)shuf_map[rr-start] : rr;\n        if ((_dinfo._nfolds > 0 && (r % _dinfo._nfolds) == _dinfo._foldId)\n                || (skip_rng != null && skip_rng.nextFloat() > _useFraction))continue;\n        for(Chunk c:chunks)if(c.isNA0(r))continue OUTER; // skip rows with NAs!\n        int i = 0, ncats = 0;\n        for(; i < _dinfo._cats; ++i){\n          int c = (int)chunks[i].at80(r);\n          if(_dinfo._catLvls != null){ // some levels are ignored?\n            c = Arrays.binarySearch(_dinfo._catLvls[i],c);\n            if(c >= 0)\n              cats[ncats++] = c + _dinfo._catOffsets[i];\n          } else if(_dinfo._useAllFactorLevels)\n            cats[ncats++] = c + _dinfo._catOffsets[i];\n          else if(c != 0)\n            cats[ncats++] = c + _dinfo._catOffsets[i]-1;\n        }\n        final int n = chunks.length-_dinfo._responses;\n        for(;i < n;++i){\n          double d = chunks[i].at0(r);\n          if(_dinfo._normMul != null) d = (d - _dinfo._normSub[i-_dinfo._cats])*_dinfo._normMul[i-_dinfo._cats];\n          nums[i-_dinfo._cats] = d;\n        }\n        for(i = 0; i < _dinfo._responses; ++i) {\n          response[i] = chunks[chunks.length-_dinfo._responses + i].at0(r);\n          if (_dinfo._normRespMul != null) response[i] = (response[i] - _dinfo._normRespSub[i])*_dinfo._normRespMul[i];\n        }\n        if (outputs != null && outputs.length > 0)\n          processRow(offset + r, nums, ncats, cats, response, outputs);\n        else\n          processRow(offset + r, nums, ncats, cats, response);\n      }\n    }\n    chunkDone();\n  }","id":65176,"modified_method":"/**\n   * Extracts the values, applies regularization to numerics, adds appropriate offsets to categoricals,\n   * and adapts response according to the CaseMode/CaseValue if set.\n   */\n  @Override public final void map(Chunk [] chunks, NewChunk [] outputs){\n    if(_jobKey != null && !Job.isRunning(_jobKey))throw new JobCancelledException();\n    final int nrows = chunks[0].len();\n    final long offset = chunks[0].start();\n    chunkInit();\n    double [] nums = MemoryManager.malloc8d(_dinfo._nums);\n    int    [] cats = MemoryManager.malloc4(_dinfo._cats);\n    double [] response = _dinfo._responses == 0 ? null : MemoryManager.malloc8d(_dinfo._responses);\n    int start = 0;\n    int end = nrows;\n\n    boolean contiguous = false;\n    Random skip_rng = null; //random generator for skipping rows\n\n    //Example:\n    // _useFraction = 0.8 -> 1 repeat with fraction = 0.8\n    // _useFraction = 1.0 -> 1 repeat with fraction = 1.0\n    // _useFraction = 1.1 -> 2 repeats with fraction = 0.55\n    // _useFraction = 2.1 -> 3 repeats with fraction = 0.7\n    // _useFraction = 3.0 -> 3 repeats with fraction = 1.0\n    final int repeats = (int)Math.ceil(_useFraction);\n    final float fraction = _useFraction / repeats;\n\n    if (fraction < 1.0) {\n      skip_rng = RandomUtils.getDeterRNG(new Random().nextLong());\n      if (contiguous) {\n        final int howmany = (int)Math.ceil(fraction*nrows);\n        if (howmany > 0) {\n          start = skip_rng.nextInt(nrows - howmany);\n          end = start + howmany;\n        }\n        assert(start < nrows);\n        assert(end <= nrows);\n      }\n    }\n\n    long[] shuf_map = null;\n    if (_shuffle) {\n      shuf_map = new long[end-start];\n      for (int i=0;i<shuf_map.length;++i)\n        shuf_map[i] = start + i;\n      ArrayUtils.shuffleArray(shuf_map, new Random().nextLong());\n    }\n    long num_processed_rows = 0;\n    for(int rrr = 0; rrr < repeats; ++rrr) {\n      OUTER:\n      for(int rr = start; rr < end; ++rr){\n        final int r = shuf_map != null ? (int)shuf_map[rr-start] : rr;\n        final long lr = r + chunks[0].start();\n        if ((_dinfo._nfolds > 0 && (lr % _dinfo._nfolds) == _dinfo._foldId)\n          || (skip_rng != null && skip_rng.nextFloat() > _useFraction))continue;\n        ++num_processed_rows; //count rows with missing values even if they are skipped\n        for(Chunk c:chunks)if(skipMissing() && c.isNA0(r))continue OUTER; // skip rows with NAs!\n        int i = 0, ncats = 0;\n        for(; i < _dinfo._cats; ++i){\n          int c;\n          if (chunks[i].isNA0(r)) {\n            cats[ncats++] = (_dinfo._catOffsets[i+1]-1); //missing value turns into extra (last) factor\n          } else {\n            c = (int) chunks[i].at80(r);\n            if (_dinfo._catLvls != null) { // some levels are ignored?\n              c = Arrays.binarySearch(_dinfo._catLvls[i], c);\n              if (c >= 0)\n                cats[ncats++] = c + _dinfo._catOffsets[i];\n            } else if (_dinfo._useAllFactorLevels)\n              cats[ncats++] = c + _dinfo._catOffsets[i];\n            else if (c != 0)\n              cats[ncats++] = c + _dinfo._catOffsets[i] - 1;\n          }\n        }\n        final int n = chunks.length-_dinfo._responses;\n        for(;i < n;++i){\n          double d = chunks[i].at0(r); //can be NA if skipMissing() == false\n          if(_dinfo._normMul != null) d = (d - _dinfo._normSub[i-_dinfo._cats])*_dinfo._normMul[i-_dinfo._cats];\n          nums[i-_dinfo._cats] = d;\n        }\n        for(i = 0; i < _dinfo._responses; ++i) {\n          response[i] = chunks[chunks.length-_dinfo._responses + i].at0(r);\n          if (_dinfo._normRespMul != null) response[i] = (response[i] - _dinfo._normRespSub[i])*_dinfo._normRespMul[i];\n          if(Double.isNaN(response[i]))continue OUTER; // skip rows without a valid response (no supervised training possible)\n        }\n        long seed = offset + rrr*(end-start) + r;\n        if (outputs != null && outputs.length > 0)\n          processRow(seed, nums, ncats, cats, response, outputs);\n        else\n          processRow(seed, nums, ncats, cats, response);\n      }\n    }\n    chunkDone(num_processed_rows);\n  }","commit_id":"7b7d5ef0274d93d86cd78b89183dbfb3dadb00b8","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public final String [] coefNames(){\n      int k = 0;\n      final int n = fullN();\n      String [] res = new String[n];\n      final Vec [] vecs = _adaptedFrame.vecs();\n      for(int i = 0; i < _cats; ++i)\n        for(int j = _useAllFactorLevels?0:1; j < vecs[i].factors().length; ++j)\n          res[k++] = _adaptedFrame._names[i] + \".\" + vecs[i].factors()[j];\n      final int nums = n-k;\n      System.arraycopy(_adaptedFrame._names, _cats, res, k, nums);\n      return res;\n    }","id":65177,"modified_method":"public final String [] coefNames(){\n      int k = 0;\n      final int n = fullN();\n      String [] res = new String[n];\n      final Vec [] vecs = _adaptedFrame.vecs();\n      for(int i = 0; i < _cats; ++i) {\n        for (int j = _useAllFactorLevels ? 0 : 1; j < vecs[i].domain().length; ++j)\n          res[k++] = _adaptedFrame._names[i] + \".\" + vecs[i].domain()[j];\n        if (vecs[i].naCnt() > 0) res[k++] = _adaptedFrame._names[i] + \".missing(NA)\";\n      }\n      final int nums = n-k;\n      System.arraycopy(_adaptedFrame._names, _cats, res, k, nums);\n      return res;\n    }","commit_id":"7b7d5ef0274d93d86cd78b89183dbfb3dadb00b8","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public DataInfo(Frame fr, int nResponses, boolean useAllFactorLevels, boolean standardize, boolean standardize_response){\n      _nfolds = _foldId = 0;\n      _standardize = standardize;\n      _standardize_response = standardize_response;\n      _responses = nResponses;\n      _useAllFactorLevels = useAllFactorLevels;\n      _catLvls = null;\n      final Vec [] vecs = fr.vecs();\n      final int n = vecs.length-_responses;\n      if (n < 1) throw new IllegalArgumentException(\"Training data must have at least one column.\");\n      int [] nums = MemoryManager.malloc4(n);\n      int [] cats = MemoryManager.malloc4(n);\n      int nnums = 0, ncats = 0;\n      for(int i = 0; i < n; ++i){\n        if(vecs[i].isEnum())\n          cats[ncats++] = i;\n        else\n          nums[nnums++] = i;\n      }\n      _nums = nnums;\n      _cats = ncats;\n      // sort the cats in the decreasing order according to their size\n      for(int i = 0; i < ncats; ++i)\n        for(int j = i+1; j < ncats; ++j)\n          if(vecs[cats[i]].domain().length < vecs[cats[j]].domain().length){\n            int x = cats[i];\n            cats[i] = cats[j];\n            cats[j] = x;\n          }\n      Vec [] vecs2 = vecs.clone();\n      String [] names = fr._names.clone();\n      _catOffsets = MemoryManager.malloc4(ncats+1);\n      int len = _catOffsets[0] = 0;\n\n      for(int i = 0; i < ncats; ++i){\n        Vec v = (vecs2[i] = vecs[cats[i]]);\n        names[i] = fr._names[cats[i]];\n        _catOffsets[i+1] = (len += v.domain().length - (useAllFactorLevels?0:1));\n      }\n      if(standardize){\n        _normSub = MemoryManager.malloc8d(nnums);\n        _normMul = MemoryManager.malloc8d(nnums); Arrays.fill(_normMul, 1);\n      } else _normSub = _normMul = null;\n      for(int i = 0; i < nnums; ++i){\n        Vec v = (vecs2[i+ncats] = vecs[nums[i]]);\n        names[i+ncats] = fr._names[nums[i]];\n        if(standardize){\n          _normSub[i] = v.mean();\n          _normMul[i] = v.sigma() != 0 ? 1.0/v.sigma() : 1.0;\n        }\n      }\n\n      if(standardize_response){\n        _normRespSub = MemoryManager.malloc8d(_responses);\n        _normRespMul = MemoryManager.malloc8d(_responses); Arrays.fill(_normRespMul, 1);\n      } else _normRespSub = _normRespMul = null;\n      for(int i = 0; i < _responses; ++i){\n        Vec v = (vecs2[nnums+ncats+i] = vecs[nnums+ncats+i]);\n        if(standardize_response){\n          _normRespSub[i] = v.mean();\n          _normRespMul[i] = v.sigma() != 0 ? 1.0/v.sigma() : 1.0;\n//          Log.info(\"normalization for response[\" + i + \": mul \" + _normRespMul[i] + \", sub \" + _normRespSub[i]);\n        }\n      }\n      _adaptedFrame = new Frame(names,vecs2);\n      _adaptedFrame.reloadVecs();\n    }","id":65178,"modified_method":"public DataInfo(Frame fr, int nResponses, boolean useAllFactors, TransformType predictor_transform) {\n      this(fr, nResponses, useAllFactors, predictor_transform, TransformType.NONE);\n    }","commit_id":"7b7d5ef0274d93d86cd78b89183dbfb3dadb00b8","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public FrameTask(Job job, DataInfo dinfo, H2OCountedCompleter cmp) {\n    super(cmp);\n    _job = job;\n    _dinfo = dinfo;\n  }","id":65179,"modified_method":"public FrameTask(Key jobKey, DataInfo dinfo, H2OCountedCompleter cmp) {\n    super(cmp);\n    _jobKey = jobKey;\n    _dinfo = dinfo;\n  }","commit_id":"7b7d5ef0274d93d86cd78b89183dbfb3dadb00b8","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * Override this to do post-chunk processing work.\n   */\n  protected void chunkDone(){}","id":65180,"modified_method":"/**\n   * Override this to do post-chunk processing work.\n   * @param n Number of processed rows\n   */\n  protected void chunkDone(long n){}","commit_id":"7b7d5ef0274d93d86cd78b89183dbfb3dadb00b8","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public DataInfo(Frame fr, int nResponses, boolean useAllFactors, boolean standardize) {\n      this(fr, nResponses, useAllFactors, standardize, false);\n    }","id":65181,"modified_method":"public DataInfo(Frame fr, int nResponses, boolean useAllFactorLevels, TransformType predictor_transform, TransformType response_transform) {\n      _nfolds = _foldId = 0;\n      _predictor_transform = predictor_transform;\n      _response_transform = response_transform;\n      _responses = nResponses;\n      _useAllFactorLevels = useAllFactorLevels;\n      _catLvls = null;\n      final Vec [] vecs = fr.vecs();\n      final int n = vecs.length-_responses;\n      if (n < 1) throw new IllegalArgumentException(\"Training data must have at least one column.\");\n      int [] nums = MemoryManager.malloc4(n);\n      int [] cats = MemoryManager.malloc4(n);\n      int nnums = 0, ncats = 0;\n      for(int i = 0; i < n; ++i){\n        if(vecs[i].isEnum())\n          cats[ncats++] = i;\n        else\n          nums[nnums++] = i;\n      }\n      _nums = nnums;\n      _cats = ncats;\n      // sort the cats in the decreasing order according to their size\n      for(int i = 0; i < ncats; ++i)\n        for(int j = i+1; j < ncats; ++j)\n          if(vecs[cats[i]].domain().length < vecs[cats[j]].domain().length){\n            int x = cats[i];\n            cats[i] = cats[j];\n            cats[j] = x;\n          }\n      Vec [] vecs2 = vecs.clone();\n      String [] names = fr._names.clone();\n      _catOffsets = MemoryManager.malloc4(ncats+1);\n      _catMissing = new int[ncats];\n      int len = _catOffsets[0] = 0;\n\n      for(int i = 0; i < ncats; ++i){\n        Vec v = (vecs2[i] = vecs[cats[i]]);\n        names[i] = fr._names[cats[i]];\n        _catMissing[i] = v.naCnt() > 0 ? 1 : 0; //needed for test time\n        _catOffsets[i+1] = (len += v.domain().length - (useAllFactorLevels?0:1) + (v.naCnt()>0?1:0)); //missing values turn into a new factor level\n      }\n      if(predictor_transform != TransformType.NONE) {\n        _normSub = MemoryManager.malloc8d(nnums);\n        _normMul = MemoryManager.malloc8d(nnums); Arrays.fill(_normMul, 1);\n      } else _normSub = _normMul = null;\n      for(int i = 0; i < nnums; ++i){\n        Vec v = (vecs2[i+ncats] = vecs[nums[i]]);\n        names[i+ncats] = fr._names[nums[i]];\n        if(predictor_transform == TransformType.STANDARDIZE){\n          _normSub[i] = v.mean();\n          _normMul[i] = v.sigma() != 0 ? 1.0/v.sigma() : 1.0;\n        } else if (predictor_transform == TransformType.NORMALIZE) {\n          _normSub[i] = v.mean();\n          _normMul[i] = (v.max() - v.min() > 0)?1.0/(v.max() - v.min()):1.0;\n        }\n      }\n\n      if(response_transform != TransformType.NONE && _responses > 0){\n        _normRespSub = MemoryManager.malloc8d(_responses);\n        _normRespMul = MemoryManager.malloc8d(_responses); Arrays.fill(_normRespMul, 1);\n      } else _normRespSub = _normRespMul = null;\n      for(int i = 0; i < _responses; ++i){\n        Vec v = (vecs2[nnums+ncats+i] = vecs[nnums+ncats+i]);\n        if(response_transform == TransformType.STANDARDIZE){\n          _normRespSub[i] = v.mean();\n          _normRespMul[i] = v.sigma() != 0 ? 1.0/v.sigma() : 1.0;\n        } else if(response_transform == TransformType.NORMALIZE){\n          _normRespSub[i] = v.mean();\n          _normRespMul[i] = (v.max() - v.min() > 0)?1.0/(v.max() - v.min()):1.0;\n        }\n      }\n      _adaptedFrame = new Frame(names,vecs2);\n      _adaptedFrame.reloadVecs();\n    }","commit_id":"7b7d5ef0274d93d86cd78b89183dbfb3dadb00b8","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Test public void test2BPV() {\n   // Simple case only compressing 2*3bits into 1byte including 1 NA\n   testImpl(new long[] {0,0,                  1},\n            new int [] {0,Integer.MIN_VALUE,0},\n            2, 2, 1, 1);\n   // Filling whole byte, one NA\n   testImpl(new long[] {1,0                ,0,1},\n            new int [] {0,Integer.MIN_VALUE,0,0},\n            2, 0, 1, 1);\n   // crossing the border of two bytes by 4bits, one NA\n   testImpl(new long[] {1,0,0,                1, 0,0},\n            new int [] {0,0,Integer.MIN_VALUE,0, 0,0},\n            2, 4, 2, 1);\n   // Two full bytes, 5 NAs\n   testImpl(new long[] {0,0,0,1, 0,0,1,0},\n            new int [] {Integer.MIN_VALUE,Integer.MIN_VALUE,Integer.MIN_VALUE,0, 0,Integer.MIN_VALUE,0,Integer.MIN_VALUE},\n            2, 0, 2, 5);\n  }","id":65182,"modified_method":"@Test public void test2BPV() {\n   // Simple case only compressing 2*3bits into 1byte including 1 NA\n   testImpl(new long[] {0,Long.MAX_VALUE,                  1},\n            new int [] {0,Integer.MIN_VALUE,0},\n            2, 2, 1, 1);\n   // Filling whole byte, one NA\n   testImpl(new long[] {1,Long.MAX_VALUE                ,0,1},\n            new int [] {0,Integer.MIN_VALUE,0,0},\n            2, 0, 1, 1);\n   // crossing the border of two bytes by 4bits, one NA\n   testImpl(new long[] {1,0,Long.MAX_VALUE,                1, 0,0},\n            new int [] {0,0,Integer.MIN_VALUE,0, 0,0},\n            2, 4, 2, 1);\n   // Two full bytes, 5 NAs\n   testImpl(new long[] {Long.MAX_VALUE,Long.MAX_VALUE,Long.MAX_VALUE,1, 0,Long.MAX_VALUE,1,Long.MAX_VALUE},\n            new int [] {Integer.MIN_VALUE,Integer.MIN_VALUE,Integer.MIN_VALUE,0, 0,Integer.MIN_VALUE,0,Integer.MIN_VALUE},\n            2, 0, 2, 5);\n  }","commit_id":"dbccc97f6416980beca5335e9e546f57d3bfeeca","url":"https://github.com/h2oai/h2o-2"},{"original_method":"protected void set_sparse(int nzeros){\n    if(_len == nzeros)return;\n    assert _len == _len2;\n    int j = 0;\n    int  [] id = MemoryManager.malloc4(nzeros);\n    if(_ds == null){\n      long [] ls = MemoryManager.malloc8(nzeros);\n      int  [] xs = MemoryManager.malloc4(nzeros);\n      for(int i = 0; i < _len; ++i){\n        if(_ls[i] != 0){\n          ls[j] = _ls[i];\n          xs[j] = _xs[i];\n          id[j] = i;\n          ++j;\n        }\n      }\n      _ls = ls; _xs = xs; _id = id;\n    } else {\n      double [] ds = MemoryManager.malloc8d(nzeros);\n      for(int i = 0; i < _len; ++i){\n        if(_ds[i] != 0){\n          ds[j] = _ds[i];\n          id[j] = i;\n          ++j;\n        }\n      }\n      _ds = ds;\n      _id = id;\n    }\n    assert j == nzeros;\n    _len = nzeros;\n  }","id":65183,"modified_method":"protected void set_sparse(int nzeros){\n    if(_len == nzeros)return;\n    assert _len == _len2;\n    int zs = 0;\n    if(_ds == null){\n      assert nzeros < _ls.length;\n      _id = MemoryManager.malloc4(_ls.length);\n      for(int i = 0; i < _len; ++i){\n        if(_ls[i] == 0)++zs;\n        else {\n          _ls[i-zs] = _ls[i];\n          _xs[i-zs] = _xs[i];\n          _id[i-zs] = i;\n        }\n      }\n    } else {\n      assert nzeros < _ds.length;\n      _id = MemoryManager.malloc4(_ds.length);\n      for(int i = 0; i < _len; ++i){\n        if(_ds[i] == 0)++zs;\n        else {\n          _ds[i-zs] = _ds[i];\n          _id[i-zs] = i;\n        }\n      }\n    }\n    assert zs == (_len - nzeros);\n    _len = nzeros;\n  }","commit_id":"dbccc97f6416980beca5335e9e546f57d3bfeeca","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public void addNA  (     ) {\n    append2(0,Integer.MIN_VALUE  ); }","id":65184,"modified_method":"public void addNA  (     ) {append2(Long.MAX_VALUE,Integer.MIN_VALUE  ); }","commit_id":"dbccc97f6416980beca5335e9e546f57d3bfeeca","url":"https://github.com/h2oai/h2o-2"},{"original_method":"protected final boolean isNA2(int idx) {\n    return (_ds == null) ? (_ls[idx] == 0 && _xs[idx] == Integer.MIN_VALUE) : Double.isNaN(_ds[idx]);\n  }","id":65185,"modified_method":"protected final boolean isNA2(int idx) {\n    return (_ds == null) ? (_ls[idx] == Long.MAX_VALUE && _xs[idx] == Integer.MIN_VALUE) : Double.isNaN(_ds[idx]);\n  }","commit_id":"dbccc97f6416980beca5335e9e546f57d3bfeeca","url":"https://github.com/h2oai/h2o-2"},{"original_method":"private void append2slow( ) {\n    if( _len > Vec.CHUNK_SZ )\n      throw new ArrayIndexOutOfBoundsException(_len);\n    assert _ds==null;\n    if(_ls == null){\n      _ls = MemoryManager.malloc8(4);\n      _xs = MemoryManager.malloc4(4);\n      _id = MemoryManager.malloc4(4);\n    } else {\n      _ls = MemoryManager.arrayCopyOf(_ls,_len<<1);\n      _xs = MemoryManager.arrayCopyOf(_xs,_len<<1);\n      if(_id != null)\n        _id = MemoryManager.arrayCopyOf(_id,_len<<1);\n    }\n  }","id":65186,"modified_method":"private void append2slow( ) {\n    if( _len > Vec.CHUNK_SZ )\n      throw new ArrayIndexOutOfBoundsException(_len);\n    assert _ds==null;\n    if(_ls != null && _ls.length > 0){\n      if(_id == null){ // check for sparseness\n        int nzs = 0;\n        for(long l:_ls) if(l != 0)++nzs;\n        if((nzs+1)*MIN_SPARSE_RATIO < _len2){\n          set_sparse(nzs);\n          assert _len == 0 || _len  <= _ls.length:\"_len = \" + _len + \", _ls.length = \" + _ls.length + \", nzs = \" + nzs +  \", len2 = \" + _len2;\n          assert _id.length == _ls.length;\n          return;\n        }\n      } else {\n        // verify we're still sufficiently sparse\n        if((MIN_SPARSE_RATIO*(_len) >> 1) > _len2)  cancel_sparse();\n        else _id = MemoryManager.arrayCopyOf(_id,_len<<1);\n      }\n      _ls = MemoryManager.arrayCopyOf(_ls,_len<<1);\n      _xs = MemoryManager.arrayCopyOf(_xs,_len<<1);\n    } else {\n      _ls = MemoryManager.malloc8(4);\n      _xs = MemoryManager.malloc4(4);\n      _id = _id == null?null:MemoryManager.malloc4(4);\n    }\n    assert _len == 0 || _len < _ls.length:\"_len = \" + _len + \", _ls.length = \" + _ls.length;\n    assert _id == null || _id.length == _ls.length;\n  }","commit_id":"dbccc97f6416980beca5335e9e546f57d3bfeeca","url":"https://github.com/h2oai/h2o-2"},{"original_method":"protected final boolean setNA_impl2(int i) {\n    if( isNA2(i) ) return true;\n    if( _ls != null ) { _ls[i] = 0; _xs[i] = Integer.MIN_VALUE; }\n    if( _ds != null ) { _ds[i] = Double.NaN; }\n    return true;\n  }","id":65187,"modified_method":"protected final boolean setNA_impl2(int i) {\n    if( isNA2(i) ) return true;\n    if( _ls != null ) { _ls[i] = Long.MAX_VALUE; _xs[i] = Integer.MIN_VALUE; }\n    if( _ds != null ) { _ds[i] = Double.NaN; }\n    return true;\n  }","commit_id":"dbccc97f6416980beca5335e9e546f57d3bfeeca","url":"https://github.com/h2oai/h2o-2"},{"original_method":"Chunk compress() {\n    // Check for basic mode info: all missing or all strings or mixed stuff\n    byte mode = type();\n    if( mode==AppendableVec.NA ) // ALL NAs, nothing to do\n      return new C0DChunk(Double.NaN,_len);\n    boolean rerun=false;\n    if(mode == AppendableVec.ENUM){\n      for( int i=0; i<_len; i++ )\n        if(isEnum2(i))\n          _xs[i] = 0;\n        else if(!isNA2(i)){\n          setNA_impl2(i);\n          ++_naCnt;\n        }\n        // Smack any mismatched string/numbers\n    } else if(mode == AppendableVec.NUMBER){\n      for( int i=0; i<_len; i++ )\n        if(isEnum2(i)) {\n          setNA_impl2(i);\n          rerun = true;\n        }\n    }\n    if( rerun ) { _naCnt = -1;  type(); } // Re-run rollups after dropping all numbers/enums\n    boolean sparse = false;\n    // sparse? treat as sparse iff we have at least MIN_SPARSE_RATIOx more zeros than nonzeros\n    if(MIN_SPARSE_RATIO*(_naCnt + _nzCnt) < _len2) {\n      set_sparse(_naCnt + _nzCnt);\n      sparse = true;\n    }\n    // If the data was set8 as doubles, we do a quick check to see if it's\n    // plain longs.  If not, we give up and use doubles.\n    if( _ds != null ) {\n      int i=0;\n      for( ; i<_len; i++ ) // Attempt to inject all doubles into longs\n        if( !Double.isNaN(_ds[i]) && (double)(long)_ds[i] != _ds[i] ) break;\n      if(i < _len)\n        return sparse?new CXDChunk(_len2,_len,8,bufD(8)):chunkD();\n      _ls = new long[_ds.length]; // Else flip to longs\n      _xs = new int [_ds.length];\n      for( i=0; i<_len; i++ )   // Inject all doubles into longs\n        if( Double.isNaN(_ds[i]) ){_xs[i] = Integer.MIN_VALUE;_ls[i] = 0;}\n        else                       _ls[i] = (long)_ds[i];\n      _ds = null;\n    }\n\n    // IF (_len2 > _len) THEN Sparse\n    // Check for compressed *during appends*.  Here we know:\n    // - No specials; _xs[]==0.\n    // - No floats; _ds==null\n    // - NZ length in _len, actual length in _len2.\n    // - Huge ratio between _len2 and _len, and we do NOT want to inflate to\n    //   the larger size; we need to keep it all small all the time.\n    // - Rows in _xs\n\n    // Data in some fixed-point format, not doubles\n    // See if we can sanely normalize all the data to the same fixed-point.\n    int  xmin = Integer.MAX_VALUE;   // min exponent found\n    long lemin= 0, lemax=lemin; // min/max at xmin fixed-point\n    boolean overflow=false;\n    boolean floatOverflow = false;\n    boolean first = true;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    int p10iLength = DParseTask.powers10i.length;\n\n    for( int i=0; i<_len; i++ ) {\n      if( isNA2(i) ) continue;\n      long l = _ls[i];\n      int  x = _xs[i];\n      assert x != Integer.MIN_VALUE:\"l = \" + l + \", x = \" + x;\n      if( x==Integer.MIN_VALUE+1) x=0; // Replace enum flag with no scaling\n      assert l!=0 || x==0:\"l == 0 while x = \" + x + \" ls = \" + Arrays.toString(_ls);      // Exponent of zero is always zero\n      // Compute per-chunk min/max\n      double d = l*DParseTask.pow10(x);\n      if( d < min ) min = d;\n      if( d > max ) max = d;\n      long t;                   // Remove extra scaling\n      while( l!=0 && (t=l/10)*10==l ) { l=t; x++; }\n      floatOverflow = Math.abs(l) > MAX_FLOAT_MANTISSA;\n      if( first ) {\n        first = false;\n        xmin = x;\n        lemin = lemax = l;\n        continue;\n      }\n      // Track largest/smallest values at xmin scale.  Note overflow.\n      if( x < xmin ) {\n        if( overflow || (overflow = ((xmin-x) >=p10iLength)) ) continue;\n        lemin *= DParseTask.pow10i(xmin-x);\n        lemax *= DParseTask.pow10i(xmin-x);\n        xmin = x;               // Smaller xmin\n      }\n      // *this* value, as a long scaled at the smallest scale\n      if( overflow || (overflow = ((x-xmin) >=p10iLength)) ) continue;\n      long le = l*DParseTask.pow10i(x-xmin);\n      if( le < lemin ) lemin=le;\n      if( le > lemax ) lemax=le;\n    }\n\n    if(_len2 != _len){ // sparse? compare xmin/lemin/lemax with 0\n      lemin = Math.min(0, lemin);\n      lemax = Math.max(0, lemax);\n      min = Math.min(min,0);\n      max = Math.max(max,0);\n    }\n\n    // Constant column?\n    if( _naCnt==0 && min==max ) {\n      return ((long)min  == min)\n          ? new C0LChunk((long)min,_len2)\n          : new C0DChunk(      min,_len2);\n    }\n\n    // Boolean column?\n    if (max == 1 && min == 0 && xmin == 0 && !overflow) {\n      if(sparse) { // Very sparse?\n        return  _naCnt==0\n          ?new CX0Chunk(_len2,_len,bufS(0))// No NAs, can store as sparse bitvector\n          :new CXIChunk(_len2,_len,1,bufS(1)); // have NAs, store as sparse 1byte values\n      }\n\n      int bpv = _strCnt+_naCnt > 0 ? 2 : 1;   // Bit-vector\n      byte[] cbuf = bufB(bpv);\n      return new CBSChunk(cbuf, cbuf[0], cbuf[1]);\n    }\n\n    final boolean fpoint = xmin < 0 || min < Long.MIN_VALUE || max > Long.MAX_VALUE;\n\n    if(sparse){\n      if(fpoint) return new CXDChunk(_len2,_len,8,bufD(8));\n      int sz = 8;\n      if(Short.MIN_VALUE <= min && max <= Short.MAX_VALUE)sz = 2;\n      else if(Integer.MIN_VALUE <= min && max <= Integer.MAX_VALUE)sz = 4;\n      return new CXIChunk(_len2,_len,sz,bufS(sz));\n    }\n    // Exponent scaling: replacing numbers like 1.3 with 13e-1.  '13' fits in a\n    // byte and we scale the column by 0.1.  A set of numbers like\n    // {1.2,23,0.34} then is normalized to always be represented with 2 digits\n    // to the right: {1.20,23.00,0.34} and we scale by 100: {120,2300,34}.\n    // This set fits in a 2-byte short.\n\n    // We use exponent-scaling for bytes & shorts only; it's uncommon (and not\n    // worth it) for larger numbers.  We need to get the exponents to be\n    // uniform, so we scale up the largest lmax by the largest scale we need\n    // and if that fits in a byte/short - then it's worth compressing.  Other\n    // wise we just flip to a float or double representation.\n    if( overflow || (fpoint && floatOverflow) || -35 > xmin || xmin > 35 )\n      return chunkD();\n    if( fpoint ) {\n      if((int)lemin == lemin && (int)lemax == lemax){\n        if(lemax-lemin < 255 && (int)lemin == lemin ) // Fits in scaled biased byte?\n          return new C1SChunk( bufX(lemin,xmin,C1SChunk.OFF,0),(int)lemin,DParseTask.pow10(xmin));\n        if(lemax-lemin < 65535 ) { // we use signed 2B short, add -32k to the bias!\n          long bias = 32767 + lemin;\n          return new C2SChunk( bufX(bias,xmin,C2SChunk.OFF,1),(int)bias,DParseTask.pow10(xmin));\n        }\n        if(lemax - lemin < Integer.MAX_VALUE)\n          return new C4SChunk(bufX(lemin, xmin,C4SChunk.OFF,2),(int)lemin,DParseTask.pow10(xmin));\n      }\n      return chunkD();\n    } // else an integer column\n    // Compress column into a byte\n    if(xmin == 0 &&  0<=lemin && lemax <= 255 && ((_naCnt + _strCnt)==0) )\n      return new C1NChunk( bufX(0,0,C1NChunk.OFF,0));\n    if(lemin < Integer.MIN_VALUE)return new C8Chunk( bufX(0,0,0,3));\n    if( lemax-lemin < 255 ) {         // Span fits in a byte?\n      if(0 <= min && max < 255 )      // Span fits in an unbiased byte?\n        return new C1Chunk( bufX(0,0,C1Chunk.OFF,0));\n      return new C1SChunk( bufX(lemin,xmin,C1SChunk.OFF,0),(int)lemin,DParseTask.pow10i(xmin));\n    }\n\n    // Compress column into a short\n    if( lemax-lemin < 65535 ) {               // Span fits in a biased short?\n      if( xmin == 0 && Short.MIN_VALUE < lemin && lemax <= Short.MAX_VALUE ) // Span fits in an unbiased short?\n        return new C2Chunk( bufX(0,0,C2Chunk.OFF,1));\n      int bias = (int)(lemin-(Short.MIN_VALUE+1));\n      return new C2SChunk( bufX(bias,xmin,C2SChunk.OFF,1),bias,DParseTask.pow10i(xmin));\n    }\n    // Compress column into ints\n    if( Integer.MIN_VALUE < min && max <= Integer.MAX_VALUE )\n      return new C4Chunk( bufX(0,0,0,2));\n    return new C8Chunk( bufX(0,0,0,3));\n  }","id":65188,"modified_method":"Chunk compress() {\n    // Check for basic mode info: all missing or all strings or mixed stuff\n    byte mode = type();\n    if( mode==AppendableVec.NA ) // ALL NAs, nothing to do\n      return new C0DChunk(Double.NaN,_len);\n    boolean rerun=false;\n    if(mode == AppendableVec.ENUM){\n      for( int i=0; i<_len; i++ )\n        if(isEnum2(i))\n          _xs[i] = 0;\n        else if(!isNA2(i)){\n          setNA_impl2(i);\n          ++_naCnt;\n        }\n        // Smack any mismatched string/numbers\n    } else if(mode == AppendableVec.NUMBER){\n      for( int i=0; i<_len; i++ )\n        if(isEnum2(i)) {\n          setNA_impl2(i);\n          rerun = true;\n        }\n    }\n    if( rerun ) { _naCnt = -1;  type(); } // Re-run rollups after dropping all numbers/enums\n    boolean sparse = false;\n    // sparse? treat as sparse iff we have at least MIN_SPARSE_RATIOx more zeros than nonzeros\n    if(MIN_SPARSE_RATIO*(_naCnt + _nzCnt) < _len2) {\n      set_sparse(_naCnt + _nzCnt);\n      sparse = true;\n    }\n    // If the data was set8 as doubles, we do a quick check to see if it's\n    // plain longs.  If not, we give up and use doubles.\n    if( _ds != null ) {\n      int i=0;\n      for( ; i<_len; i++ ) // Attempt to inject all doubles into longs\n        if( !Double.isNaN(_ds[i]) && (double)(long)_ds[i] != _ds[i] ) break;\n      if(i < _len)\n        return sparse?new CXDChunk(_len2,_len,8,bufD(8)):chunkD();\n      _ls = new long[_ds.length]; // Else flip to longs\n      _xs = new int [_ds.length];\n      double [] ds = _ds;\n      _ds = null;\n      for( i=0; i<_len; i++ )   // Inject all doubles into longs\n        if( Double.isNaN(ds[i]) )setNA_impl2(i);\n        else                     _ls[i] = (long)ds[i];\n    }\n\n    // IF (_len2 > _len) THEN Sparse\n    // Check for compressed *during appends*.  Here we know:\n    // - No specials; _xs[]==0.\n    // - No floats; _ds==null\n    // - NZ length in _len, actual length in _len2.\n    // - Huge ratio between _len2 and _len, and we do NOT want to inflate to\n    //   the larger size; we need to keep it all small all the time.\n    // - Rows in _xs\n\n    // Data in some fixed-point format, not doubles\n    // See if we can sanely normalize all the data to the same fixed-point.\n    int  xmin = Integer.MAX_VALUE;   // min exponent found\n    long lemin= 0, lemax=lemin; // min/max at xmin fixed-point\n    boolean overflow=false;\n    boolean floatOverflow = false;\n    boolean first = true;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    int p10iLength = DParseTask.powers10i.length;\n\n    for( int i=0; i<_len; i++ ) {\n      if( isNA2(i) ) continue;\n      long l = _ls[i];\n      int  x = _xs[i];\n      assert x != Integer.MIN_VALUE:\"l = \" + l + \", x = \" + x;\n      if( x==Integer.MIN_VALUE+1) x=0; // Replace enum flag with no scaling\n      assert l!=0 || x==0:\"l == 0 while x = \" + x + \" ls = \" + Arrays.toString(_ls);      // Exponent of zero is always zero\n      // Compute per-chunk min/max\n      double d = l*DParseTask.pow10(x);\n      if( d < min ) min = d;\n      if( d > max ) max = d;\n      long t;                   // Remove extra scaling\n      while( l!=0 && (t=l/10)*10==l ) { l=t; x++; }\n      floatOverflow = Math.abs(l) > MAX_FLOAT_MANTISSA;\n      if( first ) {\n        first = false;\n        xmin = x;\n        lemin = lemax = l;\n        continue;\n      }\n      // Track largest/smallest values at xmin scale.  Note overflow.\n      if( x < xmin ) {\n        if( overflow || (overflow = ((xmin-x) >=p10iLength)) ) continue;\n        lemin *= DParseTask.pow10i(xmin-x);\n        lemax *= DParseTask.pow10i(xmin-x);\n        xmin = x;               // Smaller xmin\n      }\n      // *this* value, as a long scaled at the smallest scale\n      if( overflow || (overflow = ((x-xmin) >=p10iLength)) ) continue;\n      long le = l*DParseTask.pow10i(x-xmin);\n      if( le < lemin ) lemin=le;\n      if( le > lemax ) lemax=le;\n    }\n\n    if(_len2 != _len){ // sparse? compare xmin/lemin/lemax with 0\n      lemin = Math.min(0, lemin);\n      lemax = Math.max(0, lemax);\n      min = Math.min(min,0);\n      max = Math.max(max,0);\n    }\n\n    // Constant column?\n    if( _naCnt==0 && min==max ) {\n      return ((long)min  == min)\n          ? new C0LChunk((long)min,_len2)\n          : new C0DChunk(      min,_len2);\n    }\n\n    // Boolean column?\n    if (max == 1 && min == 0 && xmin == 0 && !overflow) {\n      if(sparse) { // Very sparse?\n        return  _naCnt==0\n          ?new CX0Chunk(_len2,_len,bufS(0))// No NAs, can store as sparse bitvector\n          :new CXIChunk(_len2,_len,1,bufS(1)); // have NAs, store as sparse 1byte values\n      }\n\n      int bpv = _strCnt+_naCnt > 0 ? 2 : 1;   // Bit-vector\n      byte[] cbuf = bufB(bpv);\n      return new CBSChunk(cbuf, cbuf[0], cbuf[1]);\n    }\n\n    final boolean fpoint = xmin < 0 || min < Long.MIN_VALUE || max > Long.MAX_VALUE;\n\n    if(sparse){\n      if(fpoint) return new CXDChunk(_len2,_len,8,bufD(8));\n      int sz = 8;\n      if(Short.MIN_VALUE <= min && max <= Short.MAX_VALUE)sz = 2;\n      else if(Integer.MIN_VALUE <= min && max <= Integer.MAX_VALUE)sz = 4;\n      return new CXIChunk(_len2,_len,sz,bufS(sz));\n    }\n    // Exponent scaling: replacing numbers like 1.3 with 13e-1.  '13' fits in a\n    // byte and we scale the column by 0.1.  A set of numbers like\n    // {1.2,23,0.34} then is normalized to always be represented with 2 digits\n    // to the right: {1.20,23.00,0.34} and we scale by 100: {120,2300,34}.\n    // This set fits in a 2-byte short.\n\n    // We use exponent-scaling for bytes & shorts only; it's uncommon (and not\n    // worth it) for larger numbers.  We need to get the exponents to be\n    // uniform, so we scale up the largest lmax by the largest scale we need\n    // and if that fits in a byte/short - then it's worth compressing.  Other\n    // wise we just flip to a float or double representation.\n    if( overflow || (fpoint && floatOverflow) || -35 > xmin || xmin > 35 )\n      return chunkD();\n    if( fpoint ) {\n      if((int)lemin == lemin && (int)lemax == lemax){\n        if(lemax-lemin < 255 && (int)lemin == lemin ) // Fits in scaled biased byte?\n          return new C1SChunk( bufX(lemin,xmin,C1SChunk.OFF,0),(int)lemin,DParseTask.pow10(xmin));\n        if(lemax-lemin < 65535 ) { // we use signed 2B short, add -32k to the bias!\n          long bias = 32767 + lemin;\n          return new C2SChunk( bufX(bias,xmin,C2SChunk.OFF,1),(int)bias,DParseTask.pow10(xmin));\n        }\n        if(lemax - lemin < Integer.MAX_VALUE)\n          return new C4SChunk(bufX(lemin, xmin,C4SChunk.OFF,2),(int)lemin,DParseTask.pow10(xmin));\n      }\n      return chunkD();\n    } // else an integer column\n    // Compress column into a byte\n    if(xmin == 0 &&  0<=lemin && lemax <= 255 && ((_naCnt + _strCnt)==0) )\n      return new C1NChunk( bufX(0,0,C1NChunk.OFF,0));\n    if(lemin < Integer.MIN_VALUE)return new C8Chunk( bufX(0,0,0,3));\n    if( lemax-lemin < 255 ) {         // Span fits in a byte?\n      if(0 <= min && max < 255 )      // Span fits in an unbiased byte?\n        return new C1Chunk( bufX(0,0,C1Chunk.OFF,0));\n      return new C1SChunk( bufX(lemin,xmin,C1SChunk.OFF,0),(int)lemin,DParseTask.pow10i(xmin));\n    }\n\n    // Compress column into a short\n    if( lemax-lemin < 65535 ) {               // Span fits in a biased short?\n      if( xmin == 0 && Short.MIN_VALUE < lemin && lemax <= Short.MAX_VALUE ) // Span fits in an unbiased short?\n        return new C2Chunk( bufX(0,0,C2Chunk.OFF,1));\n      int bias = (int)(lemin-(Short.MIN_VALUE+1));\n      return new C2SChunk( bufX(bias,xmin,C2SChunk.OFF,1),bias,DParseTask.pow10i(xmin));\n    }\n    // Compress column into ints\n    if( Integer.MIN_VALUE < min && max <= Integer.MAX_VALUE )\n      return new C4Chunk( bufX(0,0,0,2));\n    return new C8Chunk( bufX(0,0,0,3));\n  }","commit_id":"dbccc97f6416980beca5335e9e546f57d3bfeeca","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public void addNum(double d) {\n    if( _ds==null||_len >= _ds.length ) append2slowd();\n    _ds[_len] = d;\n    if(_id != null && d != 0) {\n      _id[_len] = _len2;\n      ++_len;\n    }\n    ++_len2;\n  }","id":65189,"modified_method":"public void addNum(double d) {\n    if(_id == null || d != 0) {\n      if( _ds == null || _len >= _ds.length ) {\n        append2slowd();\n        // call addNum again since append2slow might have flipped to sparse\n        addNum(d);\n        return;\n      }\n      if(_id != null)_id[_len] = _len2;\n      _ds[_len++] = d;\n    }\n    _len2++;\n  }","commit_id":"dbccc97f6416980beca5335e9e546f57d3bfeeca","url":"https://github.com/h2oai/h2o-2"},{"original_method":"void append2( long l, int x ) {\n    if( _ls==null||_len >= _ls.length ) append2slow();\n    if(_id == null){\n      _ls[_len] = l;\n      _xs[_len] = x;\n      _len++;\n    } else if(l != 0 || x != 0){\n      _ls[_len] = l;\n      _id[_len] = _len2;\n      _xs[_len] = x;\n      _len++;\n    }\n    _len2++;\n  }","id":65190,"modified_method":"void append2( long l, int x ) {\n    if(_id == null || l != 0){\n      if(_ls == null || _len == _ls.length) {\n        append2slow();\n        // again call append2 since calling append2slow might have changed things (eg might have switched to sparse and l could be 0)\n        append2(l,x);\n        return;\n      }\n      _ls[_len] = l;\n      _xs[_len] = x;\n      if(_id  != null)_id[_len] = _len2;\n      _len++;\n    }\n    _len2++;\n  }","commit_id":"dbccc97f6416980beca5335e9e546f57d3bfeeca","url":"https://github.com/h2oai/h2o-2"},{"original_method":"private void append2slowd( ) {\n    if( _len > Vec.CHUNK_SZ )\n      throw new ArrayIndexOutOfBoundsException(_len);\n    assert _ls==null;\n    boolean sparse = _id != null ||_ds == null;\n    _ds = _ds==null ? MemoryManager.malloc8d(4) : MemoryManager.arrayCopyOf(_ds,_len<<1);\n    if(sparse)\n      _id = _id==null ? MemoryManager.malloc4(4) : MemoryManager.arrayCopyOf(_id,_len<<1);\n  }","id":65191,"modified_method":"private void append2slowd() {\n    if( _len > Vec.CHUNK_SZ )\n      throw new ArrayIndexOutOfBoundsException(_len);\n    assert _ls==null;\n    if(_ds != null && _ds.length > 0){\n      if(_id == null){ // check for sparseness\n        int nzs = 0; // assume one non-zero for the element currently being stored\n        for(double d:_ds)if(d != 0)++nzs;\n        if((nzs+1)*MIN_SPARSE_RATIO < _len2)\n          set_sparse(nzs);\n      } else _id = MemoryManager.arrayCopyOf(_id, _len << 1);\n      _ds = MemoryManager.arrayCopyOf(_ds,_len<<1);\n    } else _ds = MemoryManager.malloc8d(4);\n    assert _len == 0 || _ds.length > _len:\"_ds.length = \" + _ds.length + \", _len = \" + _len;\n  }","commit_id":"dbccc97f6416980beca5335e9e546f57d3bfeeca","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Test public void testWrites() {\n    Key key = Vec.newKey();\n    AppendableVec av = new AppendableVec(key);\n    NewChunk nv = new NewChunk(av,0);\n    nv._ls = new long[]{0,0,0,0}; // A 4-row chunk\n    nv._xs = new int []{0,0,0,0};\n    nv._len= nv._len2 = nv._ls.length;\n    nv.close(0,null);\n    Vec vec = av.close(new Futures());\n    assertEquals( nv._ls.length, vec.length() );\n    // Compression returns the expected constant-compression-type:\n    Chunk c0 = vec.chunkForChunkIdx(0);\n    assertTrue( \"Found chunk class \"+c0.getClass()+\" but expected C0LChunk\", c0 instanceof C0LChunk );\n    assertEquals( false, c0.hasFloat() );\n    // Also, we can decompress correctly\n    for( int i=0; i<nv._ls.length; i++ )\n      assertEquals(0, c0.at0(i), c0.at0(i)*EPSILON);\n\n    // Now write a zero into slot 0\n    vec.set(0,0);\n    assertEquals(0,vec.at8(0));\n    Chunk c1 = vec.chunkForChunkIdx(0);\n    assertTrue( \"Found chunk class \"+c1.getClass()+\" but expected C0LChunk\", c1 instanceof C0LChunk );\n\n    // Now write a one into slot 1; chunk should inflate into boolean vector.\n    c1.set(1,1);\n    assertEquals(1,vec.at8(1)); // Immediate visibility in current thread\n    c1.close(0,null);           // Done writing into chunk\n    Chunk c2 = vec.chunkForChunkIdx(0);  // Look again at the installed chunk\n    assertTrue( \"Found chunk class \"+c2.getClass()+\" but expected CBSChunk\", c2 instanceof CBSChunk );\n\n    // Now write a two into slot 2; chunk should inflate into byte vector\n    c2.set(2,2);\n    assertEquals(2,vec.at8(2)); // Immediate visibility in current thread\n    c2.close(0,null);           // Done writing into chunk\n    Chunk c3 = vec.chunkForChunkIdx(0);  // Look again at the installed chunk\n    assertTrue( \"Found chunk class \"+c3.getClass()+\" but expected C1NChunk\", c3 instanceof C1NChunk );\n\n    c3.set(3,3);\n    assertEquals(3,vec.at8(3)); // Immediate visibility in current thread\n    c3.close(0,null);           // Done writing into chunk\n    Chunk c4 = vec.chunkForChunkIdx(0);  // Look again at the installed chunk\n    assertTrue( \"Found chunk class \"+c4.getClass()+\" but expected C1NChunk\", c4 instanceof C1NChunk );\n\n    UKV.remove(av._key);\n  }","id":65192,"modified_method":"@Test public void testWrites() {\n    Key key = Vec.newKey();\n    AppendableVec av = new AppendableVec(key);\n    NewChunk nv = new NewChunk(av,0);\n    nv._ls = new long[]{0,0,0,0}; // A 4-row chunk\n    nv._xs = new int []{0,0,0,0};\n    nv._len= nv._len2 = nv._ls.length;\n    nv.close(0,null);\n    Vec vec = av.close(new Futures());\n    assertEquals( nv._len2, vec.length() );\n    // Compression returns the expected constant-compression-type:\n    Chunk c0 = vec.chunkForChunkIdx(0);\n    assertTrue( \"Found chunk class \"+c0.getClass()+\" but expected C0LChunk\", c0 instanceof C0LChunk );\n    assertEquals( false, c0.hasFloat() );\n    // Also, we can decompress correctly\n    for( int i=0; i<nv._ls.length; i++ )\n      assertEquals(0, c0.at0(i), c0.at0(i)*EPSILON);\n\n    // Now write a zero into slot 0\n    vec.set(0,0);\n    assertEquals(0,vec.at8(0));\n    Chunk c1 = vec.chunkForChunkIdx(0);\n    assertTrue( \"Found chunk class \"+c1.getClass()+\" but expected C0LChunk\", c1 instanceof C0LChunk );\n\n    // Now write a one into slot 1; chunk should inflate into boolean vector.\n    c1.set(1,1);\n    assertEquals(1,vec.at8(1)); // Immediate visibility in current thread\n    c1.close(0,null);           // Done writing into chunk\n    Chunk c2 = vec.chunkForChunkIdx(0);  // Look again at the installed chunk\n    assertTrue( \"Found chunk class \"+c2.getClass()+\" but expected CBSChunk\", c2 instanceof CBSChunk );\n\n    // Now write a two into slot 2; chunk should inflate into byte vector\n    c2.set(2,2);\n    assertEquals(2,vec.at8(2)); // Immediate visibility in current thread\n    c2.close(0,null);           // Done writing into chunk\n    Chunk c3 = vec.chunkForChunkIdx(0);  // Look again at the installed chunk\n    assertTrue( \"Found chunk class \"+c3.getClass()+\" but expected C1NChunk\", c3 instanceof C1NChunk );\n\n    c3.set(3,3);\n    assertEquals(3,vec.at8(3)); // Immediate visibility in current thread\n    c3.close(0,null);           // Done writing into chunk\n    Chunk c4 = vec.chunkForChunkIdx(0);  // Look again at the installed chunk\n    assertTrue( \"Found chunk class \"+c4.getClass()+\" but expected C1NChunk\", c4 instanceof C1NChunk );\n\n    UKV.remove(av._key);\n  }","commit_id":"dbccc97f6416980beca5335e9e546f57d3bfeeca","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public void runTest(double [] vs, double v1, double v2, Class class0, Class class1, Class class2){\n    int nzeros = 3;\n    int length = 4*NewChunk.MIN_SPARSE_RATIO + 1;\n    double [] vals = new double[length];\n    int [] nzs = new int[]{length/4,length/2,(3*length)/4};\n    // test sparse double\n    vals[nzs[0]] = vs[0];\n    vals[nzs[1]] = vs[1];\n    vals[nzs[2]] = vs[2];\n    Chunk c0 = makeChunk(vals);\n    assertTrue(class0.isAssignableFrom(c0.getClass()));\n    try{\n      assertTrue(class0.isAssignableFrom(c0.getClass()));\n      assertEquals(3,c0.sparseLen());\n      for(int i = 0; i < vals.length; ++i){\n        assertEquals(Double.isNaN(vals[i]), c0.isNA0(i));\n        assertTrue(Double.isNaN(vals[i]) || vals[i] == c0.at0(i));\n      }\n      int j = c0.nextNZ(-1);\n      // test skip cnt iteration\n      for(int nz:nzs){\n        assertEquals(nz,j);\n        assertEquals(Double.isNaN(vals[nz]),c0.isNA0(j));\n        assertTrue(Double.isNaN(vals[nz]) || vals[nz] == c0.at0(j));\n        j = c0.nextNZ(j);\n      }\n      Iterator<CXIChunk.Value> it = ((CXIChunk)c0).values();\n      // test iterator\n      for(int nz:nzs){\n        CXIChunk.Value v = it.next();\n        assertEquals(nz,v.rowInChunk());\n        assertEquals(Double.isNaN(vals[nz]), v.isNA());\n        assertTrue(Double.isNaN(vals[nz]) || vals[nz] == v.asDouble());\n      }\n      Chunk c1 = setAndClose(vals[length-1] = v1,length-1,c0);\n      System.out.println(c1.getClass().getSimpleName());\n      assertTrue(class1.isAssignableFrom(c1.getClass()));\n      // test sparse set\n      assertEquals(4,c1.sparseLen());\n      assertEquals(Double.isNaN(v1),c1.isNA0(length-1));\n      assertTrue(Double.isNaN(v1) || v1 == c1.at0(length-1));\n      Chunk c2 = setAndClose(vals[0] = v2,0,c1);\n      System.out.println(c2.getClass().getSimpleName());\n      assertTrue(class2.isAssignableFrom(c2.getClass()));\n      assertTrue(c2.nextNZ(-1) == 0);\n      assertEquals(vals.length,c2.sparseLen());\n      for(int i = 0; i < vals.length; ++i){\n        assertEquals(Double.isNaN(vals[i]),c2.isNA0(i));\n        assertTrue(Double.isNaN(vals[i]) || vals[i] == c2.at0(i));\n        assertTrue(c2.nextNZ(i) == i+1);\n      }\n    }finally{\n      UKV.remove(c0._vec._key);\n    }\n  }","id":65193,"modified_method":"public void runTest(double [] vs, double v1, double v2, Class class0, Class class1, Class class2){\n    int nzeros = 3;\n    int length = 4*NewChunk.MIN_SPARSE_RATIO + 1;\n    double [] vals = new double[length];\n    int [] nzs = new int[]{length/4,length/2,(3*length)/4};\n    // test sparse double\n    vals[nzs[0]] = vs[0];\n    vals[nzs[1]] = vs[1];\n    vals[nzs[2]] = vs[2];\n    Chunk c0 = makeChunk(vals);\n    assertTrue(class0.isAssignableFrom(c0.getClass()));\n    try{\n      assertTrue(class0.isAssignableFrom(c0.getClass()));\n      assertEquals(3,c0.sparseLen());\n      for(int i = 0; i < vals.length; ++i){\n        assertEquals(Double.isNaN(vals[i]), c0.isNA0(i));\n        assertTrue(Double.isNaN(vals[i]) || vals[i] == c0.at0(i));\n      }\n      int j = c0.nextNZ(-1);\n      // test skip cnt iteration\n      for(int nz:nzs){\n        assertEquals(nz,j);\n        assertEquals(Double.isNaN(vals[nz]),c0.isNA0(j));\n        assertTrue(Double.isNaN(vals[nz]) || vals[nz] == c0.at0(j));\n        j = c0.nextNZ(j);\n      }\n      Iterator<CXIChunk.Value> it = ((CXIChunk)c0).values();\n      // test iterator\n      for(int nz:nzs){\n        CXIChunk.Value v = it.next();\n        assertEquals(nz,v.rowInChunk());\n        assertEquals(Double.isNaN(vals[nz]), v.isNA());\n        assertTrue(Double.isNaN(vals[nz]) || vals[nz] == v.asDouble());\n      }\n      Chunk c1 = setAndClose(vals[length-1] = v1,length-1,c0);\n      assertTrue(class1.isAssignableFrom(c1.getClass()));\n      // test sparse set\n      assertEquals(4,c1.sparseLen());\n      assertEquals(Double.isNaN(v1),c1.isNA0(length-1));\n      assertTrue(Double.isNaN(v1) || v1 == c1.at0(length-1));\n      Chunk c2 = setAndClose(vals[0] = v2,0,c1);\n      assertTrue(class2.isAssignableFrom(c2.getClass()));\n      assertTrue(c2.nextNZ(-1) == 0);\n      assertEquals(vals.length,c2.sparseLen());\n      for(int i = 0; i < vals.length; ++i){\n        assertEquals(Double.isNaN(vals[i]),c2.isNA0(i));\n        assertTrue(Double.isNaN(vals[i]) || vals[i] == c2.at0(i));\n        assertTrue(c2.nextNZ(i) == i+1);\n      }\n    }finally{\n      UKV.remove(c0._vec._key);\n    }\n  }","commit_id":"dbccc97f6416980beca5335e9e546f57d3bfeeca","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override\n    public GradientInfo[] getGradient(double[][] betas) {\n      GLMGradientTask gt = new GLMGradientTask(_dinfo,_glmp, _lambda, betas,1.0/_nobs).doAll(_dinfo._adaptedFrame);\n      GradientInfo [] ginfos = new GradientInfo[betas.length];\n      for(int i = 0; i < ginfos.length; ++i)\n        ginfos[i] = new GradientInfo(gt._objVals[i], gt._gradient[i]);\n      return ginfos;\n    }","id":65194,"modified_method":"@Override\n    public GradientInfo getGradient(double[] beta) {\n      GLMGradientTask gt = new GLMGradientTask(_dinfo,_glmp, _lambda, beta,1.0/_nobs).doAll(_dinfo._adaptedFrame);\n      return new GradientInfo(gt._objVal, gt._gradient);\n    }","commit_id":"7dc0adfbf823e923cab2318e2e8761addc823b66","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public void reduce(GLMGradientTask grt){\n      ArrayUtils.add(_objVals, grt._objVals);\n      for(int i = 0; i < _beta.length; ++i)\n        ArrayUtils.add(_gradient[i],grt._gradient[i]);\n    }","id":65195,"modified_method":"public void reduce(GLMGradientTask grt) {\n      _objVal += grt._objVal;\n      ArrayUtils.add(_gradient, grt._gradient);\n    }","commit_id":"7dc0adfbf823e923cab2318e2e8761addc823b66","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private final void goByRows(Chunk [] chks){\n      Row row = _dinfo.newDenseRow();\n      for(int rid = 0; rid < chks[0]._len; ++rid) {\n        row = _dinfo.extractDenseRow(chks, rid, row);\n        for(int i = 0; i < _beta.length; ++i) {\n          double [] g = _gradient[i];\n          double [] b = _beta[i];\n          double eta = row.innerProduct(b);\n          double mu = _params.linkInv(eta);\n          double var = _params.variance(mu);\n          if(var < 1e-6) var = 1e-6; // to avoid numerical problems with 0 variance\n          double gval = (mu-row.response(0)) / (var * _params.linkDeriv(mu));\n          // categoricals\n          for(int c: row.binIds)\n            g[c] += gval;\n          int off = _dinfo.numStart();\n          // numbers\n          for(int j = 0; j < _dinfo._nums; ++i)\n            g[j + off] += row.numVals[i] * gval;\n          // intercept\n          if(_dinfo._intercept)\n            g[g.length-1] += gval;\n        }\n      }\n    }","id":65196,"modified_method":"private final void goByRows(Chunk [] chks){\n      Row row = _dinfo.newDenseRow();\n      _skip = MemoryManager.mallocZ(chks[0]._len);\n      double [] g = _gradient;\n      double [] b = _beta;\n      for(int rid = 0; rid < chks[0]._len; ++rid) {\n        row = _dinfo.extractDenseRow(chks, rid, row);\n        if(_skip[rid] = !row.good) continue;\n        double eta = row.innerProduct(b);\n        double mu = _params.linkInv(eta);\n        _objVal += _params.deviance(row.response(0),mu);\n        double var = _params.variance(mu);\n        if(var < 1e-6) var = 1e-6; // to avoid numerical problems with 0 variance\n        double gval = (mu-row.response(0)) / (var * _params.linkDeriv(mu));\n        // categoricals\n        for(int c: row.binIds)\n          g[c] += gval;\n        int off = _dinfo.numStart();\n        // numbers\n        for(int j = 0; j < _dinfo._nums; ++j)\n          g[j + off] += row.numVals[j] * gval;\n        // intercept\n        if(_dinfo._intercept)\n          g[g.length-1] += gval;\n      }\n    }","commit_id":"7dc0adfbf823e923cab2318e2e8761addc823b66","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public  GLMIterationTask(Key jobKey, DataInfo dinfo, GLMModel.GLMParameters glm, boolean computeGram, boolean validate, boolean computeGradient, double [] beta, double ymu, double reg, float [] thresholds, H2OCountedCompleter cmp) {\n      _jobKey = jobKey;\n      _dinfo = dinfo;\n      _glm = glm;\n      _beta = beta;\n      _ymu = ymu;\n      _reg = reg;\n      _computeGram = computeGram;\n      _validate = validate;\n      assert glm._family != Family.binomial || thresholds != null;\n      _thresholds = _validate?thresholds:null;\n      _computeGradient = computeGradient;\n      assert !_computeGradient || validate;\n    }","id":65197,"modified_method":"public  GLMIterationTask(Key jobKey, DataInfo dinfo, GLMModel.GLMParameters glm, boolean computeGram, boolean validate, boolean computeGradient, double [] beta, double ymu, double reg, float [] thresholds, H2OCountedCompleter cmp) {\n      super(cmp);\n      _jobKey = jobKey;\n      _dinfo = dinfo;\n      _glm = glm;\n      _beta = beta;\n      _ymu = ymu;\n      _reg = reg;\n      _computeGram = computeGram;\n      _validate = validate;\n      assert glm._family != Family.binomial || thresholds != null;\n      _thresholds = _validate?thresholds:null;\n      _computeGradient = computeGradient;\n      assert !_computeGradient || validate;\n    }","commit_id":"7dc0adfbf823e923cab2318e2e8761addc823b66","url":"https://github.com/h2oai/h2o-3"},{"original_method":"protected final double [][] computeEtaByCols(Chunk [] chks, boolean [] skip) {\n      double  [][] eta = new double[_beta.length][];\n      for(int i = 0; i < eta.length; ++i)\n        eta[i] = MemoryManager.malloc8d(chks[0]._len);\n\n      // do categoricals first\n      for(int i = 0; i < _dinfo._cats; ++i) {\n        Chunk c = chks[i];\n        for(int r = 0; r < c._len; ++r) { // categoricals can not be sparse\n          if(skip[r] || c.isNA(r)) {\n            skip[r] = true;\n            continue;\n          }\n          int off = _dinfo.getCategoricalId(i,(int)c.at8(r));\n          if(off != -1)\n            for(int j = 0; j < eta.length; ++j)\n              eta[j][r] += _beta[j][off];\n        }\n      }\n      final int numStart = _dinfo.numStart();\n      // compute default eta offset for 0s\n      if(_dinfo._normMul != null && _dinfo._normSub != null) {\n        for (int j = 0; j < eta.length; ++j) {\n          double off = 0;\n          for (int i = 0; i < _dinfo._nums; ++i)\n            off -= _beta[j][numStart + i] * _dinfo._normSub[i] * _dinfo._normMul[i];\n          for(int r = 0; r < chks[0]._len; ++r)\n            eta[j][r] += off;\n        }\n      }\n      // now numerics\n      for (int i = 0; i < _dinfo._nums; ++i) {\n        Chunk c = chks[i + _dinfo._cats];\n        for (int r = c.nextNZ(-1); r < c._len; r = c.nextNZ(r)) {\n          if(skip[r] || c.isNA(r)) {\n            skip[r] = true;\n            continue;\n          }\n          double d = c.atd(r);\n          if (_dinfo._normMul != null)\n            d *= _dinfo._normMul[i];\n          for (int j = 0; j < eta.length; ++j)\n            eta[j][r] += _beta[j][numStart + i] * d;\n        }\n      }\n      return eta;\n    }","id":65198,"modified_method":"protected final double [] computeEtaByCols(Chunk [] chks, boolean [] skip) {\n      double [] eta = MemoryManager.malloc8d(chks[0]._len);\n      double [] b = _beta;\n      // do categoricals first\n      for(int i = 0; i < _dinfo._cats; ++i) {\n        Chunk c = chks[i];\n        for(int r = 0; r < c._len; ++r) { // categoricals can not be sparse\n          if(skip[r] || c.isNA(r)) {\n            skip[r] = true;\n            continue;\n          }\n          int off = _dinfo.getCategoricalId(i,(int)c.at8(r));\n          if(off != -1)\n            eta[r] += b[off];\n        }\n      }\n      final int numStart = _dinfo.numStart();\n      // compute default eta offset for 0s\n      if(_dinfo._normMul != null && _dinfo._normSub != null) {\n        double off = 0;\n        for (int i = 0; i < _dinfo._nums; ++i)\n          off -= b[numStart + i] * _dinfo._normSub[i] * _dinfo._normMul[i];\n        for(int r = 0; r < chks[0]._len; ++r)\n          eta[r] += off;\n      }\n      // now numerics\n      for (int i = 0; i < _dinfo._nums; ++i) {\n        Chunk c = chks[i + _dinfo._cats];\n        for (int r = c.nextNZ(-1); r < c._len; r = c.nextNZ(r)) {\n          if(skip[r] || c.isNA(r)) {\n            skip[r] = true;\n            continue;\n          }\n          double d = c.atd(r);\n          if (_dinfo._normMul != null)\n            d *= _dinfo._normMul[i];\n          eta[r] += b[numStart + i] * d;\n        }\n      }\n      return eta;\n    }","commit_id":"7dc0adfbf823e923cab2318e2e8761addc823b66","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public void map(Chunk [] chks){\n      if(chks.length >= 100 || mostlySparse(chks))\n        goByCols(chks);\n      else\n        goByRows(chks);\n    }","id":65199,"modified_method":"public void map(Chunk [] chks){\n      _gradient = MemoryManager.malloc8d(_beta.length);\n\n      if(chks.length >= 100 || mostlySparse(chks))\n        goByCols(chks);\n      else\n        goByRows(chks);\n      // apply reg\n      _objVal *= _reg;\n      double [] g = _gradient;\n      for (int j = 0; j < g.length; ++j)\n        g[j] *= _reg;\n    }","commit_id":"7dc0adfbf823e923cab2318e2e8761addc823b66","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private final void goByCols(Chunk [] chks){\n      int numStart = _dinfo.numStart();\n      boolean []   skp = MemoryManager.mallocZ(chks[0]._len);\n      double  [][] eta = computeEtaByCols(chks,skp);\n\n      Chunk offsetChunk = null;\n      int nxs = chks.length-1; // -1 for response\n      if(_dinfo._offset) {\n        nxs -= 1;\n        offsetChunk = chks[nxs];\n      }\n      Chunk responseChunk = chks[nxs];\n\n      double []      obj = MemoryManager.malloc8d(_beta.length);\n      double [] eta_sums = MemoryManager.malloc8d(eta.length);\n\n      // compute the predicted mean and variance and gradient for each row\n      for(int r = 0; r < chks[0]._len; ++r){\n        if(skp[r] || responseChunk.isNA(r))\n          continue;\n        double off = (_dinfo._offset?offsetChunk.atd(r):0);\n        double y = responseChunk.atd(r);\n        for(int j = 0; j < eta.length; ++j) {\n          double offset = off + (_dinfo._intercept?_beta[j][_beta[j].length-1]:0);\n          double mu = _params.linkInv(eta[j][r] + offset);\n          obj[j] += _params.deviance(y,mu);\n          double var = _params.variance(mu);\n          if(var < 1e-6) var = 1e-6; // to avoid numerical problems with 0 variance\n          eta[j][r] = (mu-y) / (var * _params.linkDeriv(mu));\n          eta_sums[j] += eta[j][r];\n        }\n      }\n      _gradient = new double[_beta.length][];\n      for(int i = 0; i < _gradient.length; ++i)\n        _gradient[i] = MemoryManager.malloc8d(_beta[i].length);\n\n      // finally go over the columns again and compute gradient for each column\n      // first handle eta offset and intercept\n      for(int j = 0; j < _gradient.length; ++j) {\n        if(_dinfo._intercept)\n          _gradient[j][_gradient[j].length-1] = eta_sums[j];\n        if(_dinfo._normMul != null && _dinfo._normSub != null)\n          for(int i = 0; i < _dinfo._nums; ++i)\n            _gradient[j][numStart + i] = -_dinfo._normSub[i]*_dinfo._normMul[i]*eta_sums[j];\n      }\n      // categoricals\n      for(int i = 0; i < _dinfo._cats; ++i) {\n        Chunk c = chks[i];\n        for(int r = 0; r < c._len; ++r) { // categoricals can not be sparse\n          if(skp[r]) continue;\n          int off = _dinfo.getCategoricalId(i,(int)chks[i].at8(r));\n          if(off != -1)\n            for(int j = 0; j < eta.length; ++j)\n              _gradient[j][off] += eta[j][r];\n        }\n      }\n      // numerics\n      for (int i = 0; i < _dinfo._nums; ++i) {\n        Chunk c = chks[i + _dinfo._cats];\n        for (int r = c.nextNZ(-1); r < c._len; r = c.nextNZ(r)) {\n          if(skp[r] || c.isNA(r))\n            continue;\n          double d = c.atd(r);\n          if (_dinfo._normMul != null)\n            d = d*_dinfo._normMul[i];\n          for (int j = 0; j < eta.length; ++j)\n            _gradient[j][numStart + i] += eta[j][r] * d;\n        }\n      }\n      // apply reg\n      for(int i = 0; i < _beta.length; ++i) {\n        obj[i] *= _reg;\n        for (int j = 0; j < _beta[i].length; ++j)\n          _gradient[i][j] *= _reg;\n      }\n      _objVals = obj;\n    }","id":65200,"modified_method":"private final void goByCols(Chunk [] chks){\n      int numStart = _dinfo.numStart();\n      boolean [] skp = MemoryManager.mallocZ(chks[0]._len);\n      double  [] eta = computeEtaByCols(chks,skp);\n      double  [] b = _beta;\n      double  [] g = _gradient;\n      Chunk offsetChunk = null;\n      int nxs = chks.length-1; // -1 for response\n      if(_dinfo._offset) {\n        nxs -= 1;\n        offsetChunk = chks[nxs];\n      }\n      Chunk responseChunk = chks[nxs];\n      double eta_sum = 0;\n      // compute the predicted mean and variance and gradient for each row\n      for(int r = 0; r < chks[0]._len; ++r){\n        if(skp[r] || responseChunk.isNA(r))\n          continue;\n        double off = (_dinfo._offset?offsetChunk.atd(r):0);\n        double y = responseChunk.atd(r);\n        double offset = off + (_dinfo._intercept?b[b.length-1]:0);\n        double mu = _params.linkInv(eta[r] + offset);\n        _objVal += _params.deviance(y,mu);\n        double var = _params.variance(mu);\n        if(var < 1e-6) var = 1e-6; // to avoid numerical problems with 0 variance\n        eta[r] = (mu-y) / (var * _params.linkDeriv(mu));\n        eta_sum += eta[r];\n      }\n      // finally go over the columns again and compute gradient for each column\n      // first handle eta offset and intercept\n      if(_dinfo._intercept)\n        g[g.length-1] = eta_sum;\n      if(_dinfo._normMul != null && _dinfo._normSub != null)\n        for(int i = 0; i < _dinfo._nums; ++i)\n          g[numStart + i] = -_dinfo._normSub[i]*_dinfo._normMul[i]*eta_sum;\n      // categoricals\n      for(int i = 0; i < _dinfo._cats; ++i) {\n        Chunk c = chks[i];\n        for(int r = 0; r < c._len; ++r) { // categoricals can not be sparse\n          if(skp[r]) continue;\n          int off = _dinfo.getCategoricalId(i,(int)chks[i].at8(r));\n          if(off != -1)\n            g[off] += eta[r];\n        }\n      }\n      // numerics\n      for (int i = 0; i < _dinfo._nums; ++i) {\n        Chunk c = chks[i + _dinfo._cats];\n        for (int r = c.nextNZ(-1); r < c._len; r = c.nextNZ(r)) {\n          if(skp[r] || c.isNA(r))\n            continue;\n          double d = c.atd(r);\n          if (_dinfo._normMul != null)\n            d = d*_dinfo._normMul[i];\n          g[numStart + i] += eta[r] * d;\n        }\n      }\n      _skip = skp;\n    }","commit_id":"7dc0adfbf823e923cab2318e2e8761addc823b66","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override\n    public void map(Chunk [] chks) {\n      if(!Job.isRunning(_jobKey))\n        throw new Job.JobCancelledException();\n      // initialize\n      if(_computeGram)_gram = new Gram(_dinfo.fullN(), _dinfo.largestCat(), _dinfo._nums, _dinfo._cats,true);\n      _xy = MemoryManager.malloc8d(_dinfo.fullN()+1); // + 1 is for intercept\n\n      if(_computeGradient)\n        _grad = MemoryManager.malloc8d(_dinfo.fullN()+1); // + 1 is for intercept\n      if(_glm._family == Family.binomial && _validate){\n        _ti = new int[2];\n        _newThresholds = new float[2][4*N_THRESHOLDS];\n      }\n\n      // compute\n      boolean sparse = FrameUtils.sparseRatio(chks) > .5;\n      if(sparse) {\n        for(Row r:_dinfo.extractSparseRows(chks, _beta))\n          processRow(r);\n      } else {\n        Row row = _dinfo.newDenseRow();\n        for(int r = 0 ; r < chks[0]._len; ++r)\n          processRow(_dinfo.extractDenseRow(chks,r, row));\n      }\n\n      // need to adjust gradient by centered zeros\n      int numStart = _dinfo.numStart();\n      if(_computeGradient && sparse && _dinfo._normSub != null) {\n        for(int i = 0; i < _dinfo._nums; ++i)\n          _grad[numStart+i] -= _gsum * _dinfo._normSub[i] * _dinfo._normMul[i];\n      }\n      // finalize\n      if(_computeGram)\n        _gram.mul(_reg);\n      for(int i = 0; i < _xy.length; ++i)\n        _xy[i] *= _reg;\n      if(_grad != null)\n        for(int i = 0; i < _grad.length; ++i)\n          _grad[i] *= _reg;\n      _yy *= _reg;\n      if(_validate && _glm._family == Family.binomial) {\n        assert _val != null;\n        _newThresholds[0] = Arrays.copyOf(_newThresholds[0],_ti[0]);\n        _newThresholds[1] = Arrays.copyOf(_newThresholds[1],_ti[1]);\n        Arrays.sort(_newThresholds[0]);\n        Arrays.sort(_newThresholds[1]);\n      }\n    }","id":65201,"modified_method":"@Override\n    public void map(Chunk [] chks) {\n      if(_jobKey != null && !Job.isRunning(_jobKey))\n        throw new Job.JobCancelledException();\n      // initialize\n      if(_computeGram)_gram = new Gram(_dinfo.fullN(), _dinfo.largestCat(), _dinfo._nums, _dinfo._cats,true);\n      // public GLMValidation(Key dataKey, double ymu, GLMParameters glm, int rank, float [] thresholds){\n      if(_validate) {\n        int rank = 0;\n        if(_beta != null)for(double d:_beta)if(d != 0)++rank;\n        _val = new GLMValidation(null, _ymu, _glm, rank, _thresholds);\n      }\n      _xy = MemoryManager.malloc8d(_dinfo.fullN()+1); // + 1 is for intercept\n\n      if(_computeGradient) {\n        _ginfo = new GradientInfo(0,MemoryManager.malloc8d(_dinfo.fullN() + (_dinfo._intercept?1:0))); // + 1 is for intercept\n      }\n      if(_glm._family == Family.binomial && _validate){\n        _ti = new int[2];\n        _newThresholds = new float[2][4*N_THRESHOLDS];\n      }\n\n      // compute\n      boolean sparse = FrameUtils.sparseRatio(chks) > .5;\n      if(sparse) {\n        for(Row r:_dinfo.extractSparseRows(chks, _beta))\n          processRow(r);\n        // need to adjust gradient by centered zeros\n        int numStart = _dinfo.numStart();\n        if(_computeGradient && sparse && _dinfo._normSub != null) {\n          double [] g = _ginfo._gradient;\n          for(int i = 0; i < _dinfo._nums; ++i)\n            g[numStart+i] -= _gsum * _dinfo._normSub[i] * _dinfo._normMul[i];\n        }\n      } else {\n        Row row = _dinfo.newDenseRow();\n        for(int r = 0 ; r < chks[0]._len; ++r)\n          processRow(_dinfo.extractDenseRow(chks,r, row));\n      }\n      // finalize\n      if(_computeGram)\n        _gram.mul(_reg);\n      for(int i = 0; i < _xy.length; ++i)\n        _xy[i] *= _reg;\n      if(_computeGradient) {\n        _ginfo._objVal *= _reg;\n        for (int i = 0; i < _ginfo._gradient.length; ++i)\n          _ginfo._gradient[i] *= _reg;\n      }\n      _yy *= _reg;\n      if(_validate && _glm._family == Family.binomial) {\n        assert _val != null;\n        _newThresholds[0] = Arrays.copyOf(_newThresholds[0],_ti[0]);\n        _newThresholds[1] = Arrays.copyOf(_newThresholds[1],_ti[1]);\n        Arrays.sort(_newThresholds[0]);\n        Arrays.sort(_newThresholds[1]);\n      }\n    }","commit_id":"7dc0adfbf823e923cab2318e2e8761addc823b66","url":"https://github.com/h2oai/h2o-3"},{"original_method":"protected final void processRow(Row r) {\n      if(!r.good) return;\n      ++_nobs;\n      final double y = r.response(0);\n      assert ((_glm._family != Family.gamma) || y > 0) : \"illegal response column, y must be > 0  for family=Gamma.\";\n      assert ((_glm._family != Family.binomial) || (0 <= y && y <= 1)) : \"illegal response column, y must be <0,1>  for family=Binomial. got \" + y;\n      final double w, eta, mu, var, z;\n      final int numStart = _dinfo.numStart();\n      double d = 1;\n      if( _glm._family == Family.gaussian){\n        w = 1;\n        z = y;\n        mu = (_validate || _computeGradient)?r.innerProduct(_beta):0;\n        var = 1;\n      } else {\n        eta = r.innerProduct(_beta);\n        mu = _glm.linkInv(eta);\n        var = Math.max(1e-6, _glm.variance(mu)); // avoid numerical problems with 0 variance\n        d = _glm.linkDeriv(mu);\n        z = eta + (y-mu)*d;\n        w = 1.0/(var*d*d);\n      }\n      if(_validate) {\n        _val.add(y, mu);\n        if(_glm._family == Family.binomial) {\n          int yi = (int) y;\n          if (_ti[yi] == _newThresholds[yi].length)\n            sampleThresholds(yi);\n          _newThresholds[yi][_ti[yi]++] = (float) mu;\n        }\n      }\n      assert w >= 0|| Double.isNaN(w) : \"invalid weight \" + w; // allow NaNs - can occur if line-search is needed!\n      double wz = w * z;\n      _yy += wz * z;\n      if(_computeGradient || _computeGram){\n        double grad = _computeGradient?((mu-y) / (var * d)):0;\n        _gsum += grad;\n        for(int i = 0; i < r.nBins; ++i){\n          int ii = r.binIds[i];\n          if(_computeGradient)_grad[ii] += grad;\n          _xy[ii] += wz;\n        }\n        for(int i = 0; i < r.nNums; ++i){\n          int id = r.numIds == null?(i+r.numStart):r.numIds[i];\n          double val = r.numVals[i];\n          _xy[id] += wz*val;\n          if(_computeGradient)\n            _grad[id] += grad*val;\n        }\n        if(_computeGradient)_grad[numStart + _dinfo._nums] += grad;\n        _xy[numStart + _dinfo._nums] += wz;\n        if(_computeGram)_gram.addRow(r, w);\n      }\n    }","id":65202,"modified_method":"protected final void processRow(Row r) {\n      if(!r.good) return;\n      ++_nobs;\n      final double y = r.response(0);\n      assert ((_glm._family != Family.gamma) || y > 0) : \"illegal response column, y must be > 0  for family=Gamma.\";\n      assert ((_glm._family != Family.binomial) || (0 <= y && y <= 1)) : \"illegal response column, y must be <0,1>  for family=Binomial. got \" + y;\n      final double w, eta, mu, var, z;\n      final int numStart = _dinfo.numStart();\n      double d = 1;\n      if( _glm._family == Family.gaussian){\n        w = 1;\n        z = y;\n        mu = (_validate || _computeGradient)?r.innerProduct(_beta):0;\n        var = 1;\n      } else {\n        eta = r.innerProduct(_beta);\n        mu = _glm.linkInv(eta);\n        var = Math.max(1e-6, _glm.variance(mu)); // avoid numerical problems with 0 variance\n        d = _glm.linkDeriv(mu);\n        z = eta + (y-mu)*d;\n        w = 1.0/(var*d*d);\n      }\n      if(_validate) {\n        _val.add(y, mu);\n        if(_glm._family == Family.binomial) {\n          int yi = (int) y;\n          if (_ti[yi] == _newThresholds[yi].length)\n            sampleThresholds(yi);\n          _newThresholds[yi][_ti[yi]++] = (float) mu;\n        }\n      }\n      assert w >= 0|| Double.isNaN(w) : \"invalid weight \" + w; // allow NaNs - can occur if line-search is needed!\n      double wz = w * z;\n      _yy += wz * z;\n      if(_computeGradient || _computeGram){\n        if(_computeGradient)\n          _ginfo._objVal += _glm.deviance(y,mu);\n        double grad = ((mu-y) / (var * d));\n        double [] g = _computeGradient?_ginfo._gradient:null;\n        _gsum += grad;\n        for(int i = 0; i < r.nBins; ++i){\n          int ii = r.binIds[i];\n          if(_computeGradient)g[ii] += grad;\n          _xy[ii] += wz;\n        }\n        for(int i = 0; i < r.nNums; ++i){\n          int id = r.numIds == null?(i + numStart):r.numIds[i];\n          double val = r.numVals[i];\n          _xy[id] += wz*val;\n          if(_computeGradient)\n            g[id] += grad*val;\n        }\n        if(_computeGradient)g[numStart + _dinfo._nums] += grad;\n        if(_dinfo._intercept)\n          _xy[_xy.length-1] += wz;\n        if(_computeGram)_gram.addRow(r, w);\n      }\n    }","commit_id":"7dc0adfbf823e923cab2318e2e8761addc823b66","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override public void map(Chunk [] chunks) {\n     Chunk filterChunk = chunks[chunks.length-1];\n     boolean [] skip = MemoryManager.mallocZ(chunks[0]._len);\n     for(int i = 0; i < chunks.length-1; ++i) {\n       for(int r = chunks[i].nextNZ(-1); r < chunks[i]._len; r = chunks[i].nextNZ(r)) {\n         skip[r] |= chunks[i].isNA(r);\n       }\n     }\n     Chunk response = chunks[chunks.length-2];\n     for(int r = 0; r < response._len; ++r) {\n       if(filterChunk.at8(r) == 0) continue;\n       if(!skip[r] && !response.isNA(r)) {\n         double d = response.atd(r);\n         _ymu += d;\n         if(d < _yMin)\n           _yMin = d;\n         if(d > _yMax)\n           _yMax = d;\n         ++_nobs;\n       }\n     }\n     _ymu /= _nobs;\n     for(int i = 0; i < skip.length; ++i)\n       filterChunk.set(i, skip[i]?0:1);\n   }","id":65203,"modified_method":"@Override public void map(Chunk [] chunks) {\n     boolean [] skip = MemoryManager.mallocZ(chunks[0]._len);\n     for(int i = 0; i < chunks.length-1; ++i) {\n       for(int r = chunks[i].nextNZ(-1); r < chunks[i]._len; r = chunks[i].nextNZ(r)) {\n         skip[r] |= chunks[i].isNA(r);\n       }\n     }\n     Chunk response = chunks[chunks.length-1];\n     for(int r = 0; r < response._len; ++r) {\n       if(skip[r]) continue;\n       if(!skip[r] && !response.isNA(r)) {\n         double d = response.atd(r);\n         _ymu += d;\n         if(d < _yMin)\n           _yMin = d;\n         if(d > _yMax)\n           _yMax = d;\n         ++_nobs;\n       }\n     }\n     _ymu /= _nobs;\n   }","commit_id":"7dc0adfbf823e923cab2318e2e8761addc823b66","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override\n    public void reduce(GLMIterationTask git){\n      if(_jobKey == null || Job.isRunning(_jobKey)) {\n        ArrayUtils.add(_xy, git._xy);\n        if (_computeGram) _gram.add(git._gram);\n        _yy += git._yy;\n        _nobs += git._nobs;\n        if (_validate) _val.add(git._val);\n        if (_computeGradient) ArrayUtils.add(_grad, git._grad);\n        if(_validate && _glm._family == Family.binomial) {\n          _newThresholds[0] = ArrayUtils.join(_newThresholds[0], git._newThresholds[0]);\n          _newThresholds[1] = ArrayUtils.join(_newThresholds[1], git._newThresholds[1]);\n          if (_newThresholds[0].length >= 2 * N_THRESHOLDS) {\n            for (int i = 0; i < 2 * N_THRESHOLDS; i += 2)\n              _newThresholds[0][i >> 1] = _newThresholds[0][i];\n          }\n          if (_newThresholds[0].length > N_THRESHOLDS)\n            _newThresholds[0] = Arrays.copyOf(_newThresholds[0], N_THRESHOLDS);\n          if (_newThresholds[1].length >= 2 * N_THRESHOLDS) {\n            for (int i = 0; i < 2 * N_THRESHOLDS; i += 2)\n              _newThresholds[1][i >> 1] = _newThresholds[1][i];\n          }\n          if (_newThresholds[1].length > N_THRESHOLDS)\n            _newThresholds[1] = Arrays.copyOf(_newThresholds[1], N_THRESHOLDS);\n        }\n        super.reduce(git);\n      }\n    }","id":65204,"modified_method":"@Override\n    public void reduce(GLMIterationTask git){\n      if(_jobKey == null || Job.isRunning(_jobKey)) {\n        ArrayUtils.add(_xy, git._xy);\n        if (_computeGram) _gram.add(git._gram);\n        _yy += git._yy;\n        _nobs += git._nobs;\n        if (_validate) _val.add(git._val);\n        if (_computeGradient) ArrayUtils.add(_ginfo._gradient, git._ginfo._gradient);\n        if(_validate && _glm._family == Family.binomial) {\n          _newThresholds[0] = ArrayUtils.join(_newThresholds[0], git._newThresholds[0]);\n          _newThresholds[1] = ArrayUtils.join(_newThresholds[1], git._newThresholds[1]);\n          if (_newThresholds[0].length >= 2 * N_THRESHOLDS) {\n            for (int i = 0; i < 2 * N_THRESHOLDS; i += 2)\n              _newThresholds[0][i >> 1] = _newThresholds[0][i];\n          }\n          if (_newThresholds[0].length > N_THRESHOLDS)\n            _newThresholds[0] = Arrays.copyOf(_newThresholds[0], N_THRESHOLDS);\n          if (_newThresholds[1].length >= 2 * N_THRESHOLDS) {\n            for (int i = 0; i < 2 * N_THRESHOLDS; i += 2)\n              _newThresholds[1][i >> 1] = _newThresholds[1][i];\n          }\n          if (_newThresholds[1].length > N_THRESHOLDS)\n            _newThresholds[1] = Arrays.copyOf(_newThresholds[1], N_THRESHOLDS);\n        }\n        super.reduce(git);\n      }\n    }","commit_id":"7dc0adfbf823e923cab2318e2e8761addc823b66","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override\n    public void postGlobal(){\n      for(int i = 0; i < _objVals.length; ++i) {\n        _objVals[i] += .5 * _currentLambda * ArrayUtils.l2norm2(_beta[i],_dinfo._intercept);\n        for(int j = 0; j < _beta[i].length - (_dinfo._intercept?1:0); ++j)\n          _gradient[i][j] += _currentLambda * _beta[i][j];\n      }\n    }","id":65205,"modified_method":"@Override\n    public void postGlobal(){\n      _objVal += .5 * _currentLambda * ArrayUtils.l2norm2(_beta,_dinfo._intercept);\n      for(int j = 0; j < _beta.length - (_dinfo._intercept?1:0); ++j)\n        _gradient[j] += _currentLambda * _beta[j];\n\n    }","commit_id":"7dc0adfbf823e923cab2318e2e8761addc823b66","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public final GradientInfo getGradient(double [] betas){\n      return getGradient(new double[][]{betas})[0];\n    }","id":65206,"modified_method":"public abstract GradientInfo  getGradient(double [] beta);","commit_id":"7dc0adfbf823e923cab2318e2e8761addc823b66","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * Solve the optimization problem defined by the user-supplied gradient function using L-BFGS algorithm.\n   *\n   * Will result into multiple (10s to 100s or even 1000s) calls of the user-provided gradient function.\n   * Outside of that it does only limited single threaded computation (order of number of coefficients).\n   * The gradient is likely to be the most expensive part and key for good perfomance.\n   *\n   * @param gslvr - user gradient function\n   * @param beta - starting solution\n   * @return Optimal solution (coefficients) + gradient info returned by the user gradient\n   * function evaluated at the found optmimum.\n   */\n  public final Result solve(GradientSolver gslvr, final double [] beta, GradientInfo gOld, ProgressMonitor pm) {\n    if(_hist == null)\n      _hist = new History(_historySz, beta.length);\n    double [][] lsBetas = new double[_nBetas][]; // do 32 line-search steps at once to minimize passes through the whole dataset\n    for(int i = 0; i < lsBetas.length; ++i)\n      lsBetas[i] = MemoryManager.malloc8d(beta.length);\n    double step = 1;\n    // just loop until good enough or line search can not progress\n    int iter = 0;\n_MAIN:\n    while(pm.progress(gOld) && MathUtils.l2norm2(gOld._gradient) > _gradEps && iter++ < _maxIter) {\n      double[] pk = _hist.getSearchDirection(gOld._gradient);\n      double t = step;\n      while (t > _minStep) {\n        for (int i = 0; i < _nBetas; ++i) {\n          wadd(lsBetas[i], beta, pk, t);\n          t *= _stepDec;\n        }\n        GradientInfo[] ginfos = gslvr.getGradient(lsBetas);\n\n        t = step;\n        // check the line search, we do several steps at once each time to limit number of passes over all data\n        for (int i = 0; i < ginfos.length; ++i) {\n          if(t < _minStep)\n            break _MAIN; // line search did not progress -> converged\n          if (ginfos[i].isValid() && !needLineSearch(t, gOld._objVal, ginfos[i]._objVal, pk, gOld._gradient)) {\n            // we got admissible solution\n            ArrayUtils.mult(pk, t);\n            _hist.update(pk, ginfos[i]._gradient, gOld._gradient);\n            gOld = ginfos[i];\n            ArrayUtils.add(beta, pk);\n            assert Arrays.equals(beta, lsBetas[i]);\n            step = 1; // reset line search to start from step = 1 again\n            continue _MAIN;\n          }\n          t *= _stepDec;\n        }\n        step = t;\n      }\n      // line search did not progress -> converged\n      --iter; // decrement iteration since we did not reallyupdate the result in the last one\n      break _MAIN;\n    }\n    Log.info(\"L_BFGS done after \" + iter + \" iterations, objval = \" + gOld._objVal + \", gradient norm2 = \" + MathUtils.l2norm2(gOld._gradient) + \",  converged = \" + (MathUtils.l2norm2(gOld._gradient) <= _gradEps) );\n    return new Result(iter,beta, gOld);\n  }","id":65207,"modified_method":"/**\n   * Solve the optimization problem defined by the user-supplied gradient function using L-BFGS algorithm.\n   *\n   * Will result into multiple (10s to 100s or even 1000s) calls of the user-provided gradient function.\n   * Outside of that it does only limited single threaded computation (order of number of coefficients).\n   * The gradient is likely to be the most expensive part and key for good perfomance.\n   *\n   * @param gslvr - user gradient function\n   * @param beta - starting solution\n   * @return Optimal solution (coefficients) + gradient info returned by the user gradient\n   * function evaluated at the found optmimum.\n   */\n  public final Result solve(GradientSolver gslvr, double [] beta, GradientInfo ginfo, ProgressMonitor pm) {\n    if(_hist == null)\n      _hist = new History(_historySz, beta.length);\n    beta = beta.clone();\n    // just loop until good enough or line search can not progress\n    int iter = 0;\n_MAIN:\n    while(pm.progress(ginfo) && MathUtils.l2norm2(ginfo._gradient) > _gradEps && iter++ < _maxIter) {\n      double [] pk = _hist.getSearchDirection(ginfo._gradient);\n      double [] objs = gslvr.lineSearch(beta,pk);\n      double step = gslvr.step();\n      double t = 1;\n      // check the line search, we do all the steps (up to min step) at once each time to limit number of passes over all data\n      for (int i = 0; i < objs.length; ++i) {\n        if (!needLineSearch(t, ginfo._objVal, objs[i], pk, ginfo._gradient)) {\n          // we got admissible solution\n          ArrayUtils.mult(pk, t);\n          ArrayUtils.add(beta,pk);\n          ginfo = gslvr.getGradient(beta);\n          _hist.update(pk, ginfo._gradient, ginfo._gradient);\n          ArrayUtils.add(beta, pk);\n          continue _MAIN;\n        }\n        t *= step;\n      }\n      // line search did not progress -> converged\n      --iter; // decrement iteration since we did not reallyupdate the result in the last one\n      break;\n    }\n    Log.info(\"L_BFGS done after \" + iter + \" iterations, objval = \" + ginfo._objVal + \", gradient norm2 = \" + MathUtils.l2norm2(ginfo._gradient) + \",  converged = \" + (MathUtils.l2norm2(ginfo._gradient) <= _gradEps) );\n    return new Result(iter,beta, ginfo);\n  }","commit_id":"7dc0adfbf823e923cab2318e2e8761addc823b66","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * Solve the optimization problem defined by the user-supplied gradient function using L-BFGS algorithm.\n   *\n   * Will result into multiple (10s to 100s or even 1000s) calls of the user-provided gradient function.\n   * Outside of that it does only limited single threaded computation (order of number of coefficients).\n   * The gradient is likely to be the most expensive part and key for good perfomance.\n   *\n   * @param gslvr  - user gradient function\n   * @param params - internal L-BFGS parameters.\n   * @params coefs - intial solution\n   * @return Optimal solution (coefficients) + gradient info returned by the user gradient\n   * function evaluated at the found optmimum.\n   */\n  public final Result solve(GradientSolver gslvr, double [] coefs){\n    return solve(gslvr, coefs, gslvr.getGradient(coefs), new ProgressMonitor());\n  }","id":65208,"modified_method":"/**\n   * Solve the optimization problem defined by the user-supplied gradient function using L-BFGS algorithm.\n   *\n   * Will result into multiple (10s to 100s or even 1000s) calls of the user-provided gradient function.\n   * Outside of that it does only limited single threaded computation (order of number of coefficients).\n   * The gradient is likely to be the most expensive part and key for good perfomance.\n   *\n   * @param gslvr  - user gradient function\n   * @params coefs - intial solution\n   * @return Optimal solution (coefficients) + gradient info returned by the user gradient\n   * function evaluated at the found optmimum.\n   */\n  public final Result solve(GradientSolver gslvr, double [] coefs){\n    return solve(gslvr, coefs, gslvr.getGradient(coefs), new ProgressMonitor());\n  }","commit_id":"7dc0adfbf823e923cab2318e2e8761addc823b66","url":"https://github.com/h2oai/h2o-3"},{"original_method":"protected void generateKubernetesJson(File kubernetesJson) throws MojoExecutionException {\n        // TODO populate properties, project etc.\n        MavenProject project = getProject();\n        Map<String, String> labelMap = getLabels();\n        String name = getKubernetesName();\n        if (labelMap.isEmpty() && Strings.isNotBlank(name)) {\n            // lets add a default label\n            labelMap.put(\"component\", name);\n        }\n        if (!labelMap.containsKey(\"provider\") && Strings.isNotBlank(provider)) {\n            labelMap.put(\"provider\", provider);\n        }\n\n        KubernetesListBuilder builder = new KubernetesListBuilder()\n                .addNewReplicationControllerItem()\n                .withNewMetadata()\n                .withName(KubernetesHelper.validateKubernetesId(replicationControllerName, \"fabric8.replicationController.name\"))\n                .withLabels(labelMap)\n                .endMetadata()\n                .withNewSpec()\n                .withReplicas(replicaCount)\n                .withSelector(labelMap)\n                .withNewTemplate()\n                .withNewMetadata()\n                .withLabels(labelMap)\n                .endMetadata()\n                .withNewSpec()\n                .withServiceAccountName(serviceAccount)\n                .addNewContainer()\n                .withName(getKubernetesContainerName())\n                .withImage(getDockerImage())\n                .withImagePullPolicy(getImagePullPolicy())\n                .withEnv(getEnvironmentVariables())\n                .withNewSecurityContext()\n                .withPrivileged(getContainerPrivileged())\n                .endSecurityContext()\n                .withPorts(getContainerPorts())\n                .withVolumeMounts(getVolumeMounts())\n                .withLivenessProbe(getLivenessProbe())\n                .withReadinessProbe(getReadinessProbe())\n                .endContainer()\n                .withVolumes(getVolumes())\n                .endSpec()\n                .endTemplate()\n                .endSpec()\n                .endReplicationControllerItem();\n\n        // Do we actually want to generate a service manifest?\n        if (serviceName != null) {\n            ServiceBuilder serviceBuilder = new ServiceBuilder()\n                    .withNewMetadata()\n                    .withName(serviceName)\n                    .withLabels(labelMap)\n                    .endMetadata();\n\n            ServiceFluent<ServiceBuilder>.SpecNested<ServiceBuilder> serviceSpecBuilder = serviceBuilder.withNewSpec().withSelector(labelMap);\n\n            List<ServicePort> servicePorts = getServicePorts();\n            System.out.println(\"Generated ports: \" + servicePorts);\n            boolean hasPorts = servicePorts != null & !servicePorts.isEmpty();\n            if (hasPorts) {\n                serviceSpecBuilder.withPorts(servicePorts);\n            } else {\n                serviceSpecBuilder.withClusterIP(\"None\");\n            }\n            serviceSpecBuilder.endSpec();\n\n            if (headlessServices || hasPorts) {\n                builder = builder.addToServiceItems(serviceBuilder.build());\n            }\n        }\n\n        Template template = getTemplate();\n        String iconUrl = getIconUrl();\n        if (!template.getParameters().isEmpty() || Strings.isNotBlank(iconUrl)) {\n            configureTemplateDescriptionAndIcon(template, iconUrl);\n            builder = builder.addToTemplateItems(template);\n        }\n\n        KubernetesList kubernetesList = builder.build();\n\n        Object result = Templates.combineTemplates(kubernetesList);\n        if (result instanceof Template) {\n            Template resultTemplate = (Template) result;\n            configureTemplateDescriptionAndIcon(resultTemplate, iconUrl);\n\n            if (pureKubernetes) {\n                try {\n                    result = applyTemplates(template);\n                } catch (IOException e) {\n                    throw new MojoExecutionException(\"Failed to process template locally \" + e, e);\n                }\n            }\n        }\n        try {\n            if (pureKubernetes) {\n                result = filterPureKubernetes(result);\n            }\n\n            ObjectMapper mapper = new ObjectMapper()\n                    .enable(SerializationFeature.INDENT_OUTPUT);\n            String generated = mapper.writeValueAsString(result);\n            Files.writeToFile(kubernetesJson, generated, Charset.defaultCharset());\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"Failed to generate Kubernetes JSON.\", e);\n        }\n    }","id":65209,"modified_method":"protected void generateKubernetesJson(File kubernetesJson) throws MojoExecutionException {\n        // TODO populate properties, project etc.\n        MavenProject project = getProject();\n        Map<String, String> labelMap = getLabels();\n        String name = getKubernetesName();\n        if (labelMap.isEmpty() && Strings.isNotBlank(name)) {\n            // lets add a default label\n            labelMap.put(\"component\", name);\n        }\n        if (!labelMap.containsKey(\"provider\") && Strings.isNotBlank(provider)) {\n            labelMap.put(\"provider\", provider);\n        }\n\n        KubernetesListBuilder builder = new KubernetesListBuilder()\n                .addNewReplicationControllerItem()\n                .withNewMetadata()\n                .withName(KubernetesHelper.validateKubernetesId(replicationControllerName, \"fabric8.replicationController.name\"))\n                .withLabels(labelMap)\n                .endMetadata()\n                .withNewSpec()\n                .withReplicas(replicaCount)\n                .withSelector(labelMap)\n                .withNewTemplate()\n                .withNewMetadata()\n                .withLabels(labelMap)\n                .endMetadata()\n                .withNewSpec()\n                .withServiceAccountName(serviceAccount)\n                .addNewContainer()\n                .withName(getKubernetesContainerName())\n                .withImage(getDockerImage())\n                .withImagePullPolicy(getImagePullPolicy())\n                .withEnv(getEnvironmentVariables())\n                .withNewSecurityContext()\n                .withPrivileged(getContainerPrivileged())\n                .endSecurityContext()\n                .withPorts(getContainerPorts())\n                .withVolumeMounts(getVolumeMounts())\n                .withLivenessProbe(getLivenessProbe())\n                .withReadinessProbe(getReadinessProbe())\n                .endContainer()\n                .withVolumes(getVolumes())\n                .endSpec()\n                .endTemplate()\n                .endSpec()\n                .endReplicationControllerItem();\n\n        // Do we actually want to generate a service manifest?\n        if (serviceName != null) {\n            Map<String, String> metricsAnnotations = new HashMap<>();\n\n            if (metricsScrape) {\n                metricsAnnotations.put(metricsScrapeAnnotation, Boolean.toString(metricsScrape));\n                if (metricsPort != null) {\n                    metricsAnnotations.put(metricsPortAnnotation, metricsPort.toString());\n                }\n            }\n\n            ServiceBuilder serviceBuilder = new ServiceBuilder()\n                    .withNewMetadata()\n                    .withName(serviceName)\n                    .withLabels(labelMap)\n                    .withAnnotations(metricsAnnotations)\n                    .endMetadata();\n\n            ServiceFluent<ServiceBuilder>.SpecNested<ServiceBuilder> serviceSpecBuilder = serviceBuilder.withNewSpec().withSelector(labelMap);\n\n            List<ServicePort> servicePorts = getServicePorts();\n            System.out.println(\"Generated ports: \" + servicePorts);\n            boolean hasPorts = servicePorts != null & !servicePorts.isEmpty();\n            if (hasPorts) {\n                serviceSpecBuilder.withPorts(servicePorts);\n            } else {\n                serviceSpecBuilder.withClusterIP(\"None\");\n            }\n            serviceSpecBuilder.endSpec();\n\n            if (headlessServices || hasPorts) {\n                builder = builder.addToServiceItems(serviceBuilder.build());\n            }\n        }\n\n        Template template = getTemplate();\n        String iconUrl = getIconUrl();\n        if (!template.getParameters().isEmpty() || Strings.isNotBlank(iconUrl)) {\n            configureTemplateDescriptionAndIcon(template, iconUrl);\n            builder = builder.addToTemplateItems(template);\n        }\n\n        KubernetesList kubernetesList = builder.build();\n\n        Object result = Templates.combineTemplates(kubernetesList);\n        if (result instanceof Template) {\n            Template resultTemplate = (Template) result;\n            configureTemplateDescriptionAndIcon(resultTemplate, iconUrl);\n\n            if (pureKubernetes) {\n                try {\n                    result = applyTemplates(template);\n                } catch (IOException e) {\n                    throw new MojoExecutionException(\"Failed to process template locally \" + e, e);\n                }\n            }\n        }\n        try {\n            if (pureKubernetes) {\n                result = filterPureKubernetes(result);\n            }\n\n            ObjectMapper mapper = new ObjectMapper()\n                    .enable(SerializationFeature.INDENT_OUTPUT);\n            String generated = mapper.writeValueAsString(result);\n            Files.writeToFile(kubernetesJson, generated, Charset.defaultCharset());\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"Failed to generate Kubernetes JSON.\", e);\n        }\n    }","commit_id":"21aa51193f5ae64806cad7119d0e2134e13073ba","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public Template getTemplate() throws MojoExecutionException {\n        List<io.fabric8.openshift.api.model.Parameter> parameters = new ArrayList<>();\n        MavenProject project = getProject();\n        Properties projectProperties = project.getProperties();\n        Set<String> paramNames = new HashSet<>();\n        if (templateParametersPropertiesFile != null && templateParametersPropertiesFile.isFile() && templateParametersPropertiesFile.exists()) {\n            final String valuePostfix = \".value\";\n            final String descriptionPostfix = \".description\";\n            try {\n                Properties properties = new Properties();\n                properties.load(new FileInputStream(templateParametersPropertiesFile));\n                // lets append the prefix\n                Set<Object> keys = properties.keySet();\n                Properties prefixedProperties = new Properties();\n                for (Object key : keys) {\n                    if (key != null) {\n                        String name = key.toString();\n                        String value = properties.getProperty(name);\n                        prefixedProperties.put(PARAMETER_PREFIX + \".\" + name, value);\n                    }\n                }\n                loadParametersFromProperties(prefixedProperties, parameters, paramNames);\n            } catch (IOException e) {\n                throw new MojoExecutionException(\"Failed to load templateParameters properties file \" + templateParametersPropertiesFile + \". \" + e, e);\n            }\n        }\n        loadParametersFromProperties(projectProperties, parameters, paramNames);\n        String templateName = projectProperties.containsKey(TEMPLATE_NAME) ?\n                String.valueOf(projectProperties.getProperty(TEMPLATE_NAME)) :\n                project.getArtifactId();\n        return new TemplateBuilder().withNewMetadata().withName(templateName).endMetadata().withParameters(parameters).build();\n    }","id":65210,"modified_method":"public Template getTemplate() throws MojoExecutionException {\n        List<io.fabric8.openshift.api.model.Parameter> parameters = new ArrayList<>();\n        MavenProject project = getProject();\n        Properties projectProperties = project.getProperties();\n        Set<String> paramNames = new HashSet<>();\n        if (templateParametersPropertiesFile != null && templateParametersPropertiesFile.isFile() && templateParametersPropertiesFile.exists()) {\n            final String valuePostfix = \".value\";\n            final String descriptionPostfix = \".description\";\n            try {\n                Properties properties = new Properties();\n                properties.load(new FileInputStream(templateParametersPropertiesFile));\n                // lets append the prefix\n                Set<Object> keys = properties.keySet();\n                Properties prefixedProperties = new Properties();\n                for (Object key : keys) {\n                    if (key != null) {\n                        String name = key.toString();\n                        String value = properties.getProperty(name);\n                        prefixedProperties.put(PARAMETER_PREFIX + \".\" + name, value);\n                    }\n                }\n                loadParametersFromProperties(prefixedProperties, parameters, paramNames);\n            } catch (IOException e) {\n                throw new MojoExecutionException(\"Failed to load templateParameters properties file \" + templateParametersPropertiesFile + \". \" + e, e);\n            }\n        }\n        loadParametersFromProperties(projectProperties, parameters, paramNames);\n        String templateName = projectProperties.containsKey(TEMPLATE_NAME) ?\n                String.valueOf(projectProperties.getProperty(TEMPLATE_NAME)) :\n                project.getArtifactId();\n        return new TemplateBuilder().withNewMetadata().withName(templateName).withAnnotations(getTemplateAnnotations()).endMetadata().withParameters(parameters).build();\n    }","commit_id":"7c57b91b826521b224f49e403a418a84583cd177","url":"https://github.com/fabric8io/fabric8"},{"original_method":"protected void generateKubernetesJson(File kubernetesJson) throws MojoExecutionException {\n        // TODO populate properties, project etc.\n        MavenProject project = getProject();\n        Map<String, String> labelMap = getLabels();\n        String name = getKubernetesName();\n        if (labelMap.isEmpty() && Strings.isNotBlank(name)) {\n            // lets add a default label\n            labelMap.put(\"component\", name);\n        }\n        if (!labelMap.containsKey(\"provider\") && Strings.isNotBlank(provider)) {\n            labelMap.put(\"provider\", provider);\n        }\n\n        KubernetesListBuilder builder = new KubernetesListBuilder()\n                .addNewReplicationControllerItem()\n                .withNewMetadata()\n                .withName(KubernetesHelper.validateKubernetesId(replicationControllerName, \"fabric8.replicationController.name\"))\n                .withLabels(labelMap)\n                .endMetadata()\n                .withNewSpec()\n                .withReplicas(replicaCount)\n                .withSelector(labelMap)\n                .withNewTemplate()\n                .withNewMetadata()\n                .withLabels(labelMap)\n                .endMetadata()\n                .withNewSpec()\n                .withServiceAccountName(serviceAccount)\n                .addNewContainer()\n                .withName(getKubernetesContainerName())\n                .withImage(getDockerImage())\n                .withImagePullPolicy(getImagePullPolicy())\n                .withEnv(getEnvironmentVariables())\n                .withNewSecurityContext()\n                .withPrivileged(getContainerPrivileged())\n                .endSecurityContext()\n                .withPorts(getContainerPorts())\n                .withVolumeMounts(getVolumeMounts())\n                .withLivenessProbe(getLivenessProbe())\n                .withReadinessProbe(getReadinessProbe())\n                .endContainer()\n                .withVolumes(getVolumes())\n                .endSpec()\n                .endTemplate()\n                .endSpec()\n                .endReplicationControllerItem();\n\n        // Do we actually want to generate a service manifest?\n        if (serviceName != null) {\n            Map<String, String> metricsAnnotations = new HashMap<>();\n\n            if (metricsScrape) {\n                metricsAnnotations.put(metricsScrapeAnnotation, Boolean.toString(metricsScrape));\n                if (metricsPort != null) {\n                    metricsAnnotations.put(metricsPortAnnotation, metricsPort.toString());\n                }\n            }\n\n            ServiceBuilder serviceBuilder = new ServiceBuilder()\n                    .withNewMetadata()\n                    .withName(serviceName)\n                    .withLabels(labelMap)\n                    .withAnnotations(metricsAnnotations)\n                    .endMetadata();\n\n            ServiceFluent<ServiceBuilder>.SpecNested<ServiceBuilder> serviceSpecBuilder = serviceBuilder.withNewSpec().withSelector(labelMap);\n\n            List<ServicePort> servicePorts = getServicePorts();\n            System.out.println(\"Generated ports: \" + servicePorts);\n            boolean hasPorts = servicePorts != null & !servicePorts.isEmpty();\n            if (hasPorts) {\n                serviceSpecBuilder.withPorts(servicePorts);\n            } else {\n                serviceSpecBuilder.withClusterIP(\"None\");\n                serviceSpecBuilder.withPorts(new ServicePort(null, null, 1, null, null));\n            }\n            if (Strings.isNotBlank(serviceType)) {\n                serviceSpecBuilder.withType(serviceType);\n            }\n            serviceSpecBuilder.endSpec();\n\n            if (headlessServices || hasPorts) {\n                builder = builder.addToServiceItems(serviceBuilder.build());\n            }\n        }\n\n        Template template = getTemplate();\n        String iconUrl = getIconUrl();\n        if (!template.getParameters().isEmpty() || Strings.isNotBlank(iconUrl)) {\n            configureTemplateDescriptionAndIcon(template, iconUrl);\n            builder = builder.addToTemplateItems(template);\n        }\n\n        KubernetesList kubernetesList = builder.build();\n\n        Object result = Templates.combineTemplates(kubernetesList);\n        if (result instanceof Template) {\n            Template resultTemplate = (Template) result;\n            configureTemplateDescriptionAndIcon(resultTemplate, iconUrl);\n\n            if (pureKubernetes) {\n                try {\n                    result = applyTemplates(template);\n                } catch (IOException e) {\n                    throw new MojoExecutionException(\"Failed to process template locally \" + e, e);\n                }\n            }\n        }\n        try {\n            if (pureKubernetes) {\n                result = filterPureKubernetes(result);\n            }\n\n            ObjectMapper mapper = new ObjectMapper()\n                    .enable(SerializationFeature.INDENT_OUTPUT);\n            String generated = mapper.writeValueAsString(result);\n            Files.writeToFile(kubernetesJson, generated, Charset.defaultCharset());\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"Failed to generate Kubernetes JSON.\", e);\n        }\n    }","id":65211,"modified_method":"protected void generateKubernetesJson(File kubernetesJson) throws MojoExecutionException {\n        // TODO populate properties, project etc.\n        MavenProject project = getProject();\n        Map<String, String> labelMap = getLabels();\n        String name = getKubernetesName();\n        if (labelMap.isEmpty() && Strings.isNotBlank(name)) {\n            // lets add a default label\n            labelMap.put(\"component\", name);\n        }\n        if (!labelMap.containsKey(\"provider\") && Strings.isNotBlank(provider)) {\n            labelMap.put(\"provider\", provider);\n        }\n\n        Map<String,String> podSpecAnnotations = getPodSpecAnnotations();\n        Map<String,String> rcAnnotations = getRCAnnotations();\n\n        KubernetesListBuilder builder = new KubernetesListBuilder()\n                .addNewReplicationControllerItem()\n                .withNewMetadata()\n                .withName(KubernetesHelper.validateKubernetesId(replicationControllerName, \"fabric8.replicationController.name\"))\n                .withLabels(labelMap)\n                .withAnnotations(rcAnnotations)\n                .endMetadata()\n                .withNewSpec()\n                .withReplicas(replicaCount)\n                .withSelector(labelMap)\n                .withNewTemplate()\n                .withNewMetadata()\n                .withLabels(labelMap)\n                .withAnnotations(podSpecAnnotations)\n                .endMetadata()\n                .withNewSpec()\n                .withServiceAccountName(serviceAccount)\n                .addNewContainer()\n                .withName(getKubernetesContainerName())\n                .withImage(getDockerImage())\n                .withImagePullPolicy(getImagePullPolicy())\n                .withEnv(getEnvironmentVariables())\n                .withNewSecurityContext()\n                .withPrivileged(getContainerPrivileged())\n                .endSecurityContext()\n                .withPorts(getContainerPorts())\n                .withVolumeMounts(getVolumeMounts())\n                .withLivenessProbe(getLivenessProbe())\n                .withReadinessProbe(getReadinessProbe())\n                .endContainer()\n                .withVolumes(getVolumes())\n                .endSpec()\n                .endTemplate()\n                .endSpec()\n                .endReplicationControllerItem();\n\n        // Do we actually want to generate a service manifest?\n        if (serviceName != null) {\n            Map<String, String> metricsAnnotations = new HashMap<>();\n\n            if (metricsScrape) {\n                metricsAnnotations.put(metricsScrapeAnnotation, Boolean.toString(metricsScrape));\n                if (metricsPort != null) {\n                    metricsAnnotations.put(metricsPortAnnotation, metricsPort.toString());\n                }\n            }\n\n            ServiceBuilder serviceBuilder = new ServiceBuilder()\n                    .withNewMetadata()\n                    .withName(serviceName)\n                    .withLabels(labelMap)\n                    .withAnnotations(metricsAnnotations)\n                    .endMetadata();\n\n            ServiceFluent<ServiceBuilder>.SpecNested<ServiceBuilder> serviceSpecBuilder = serviceBuilder.withNewSpec().withSelector(labelMap);\n\n            List<ServicePort> servicePorts = getServicePorts();\n            System.out.println(\"Generated ports: \" + servicePorts);\n            boolean hasPorts = servicePorts != null & !servicePorts.isEmpty();\n            if (hasPorts) {\n                serviceSpecBuilder.withPorts(servicePorts);\n            } else {\n                serviceSpecBuilder.withClusterIP(\"None\");\n                serviceSpecBuilder.withPorts(new ServicePort(null, null, 1, null, null));\n            }\n            if (Strings.isNotBlank(serviceType)) {\n                serviceSpecBuilder.withType(serviceType);\n            }\n            serviceSpecBuilder.endSpec();\n\n            if (headlessServices || hasPorts) {\n                builder = builder.addToServiceItems(serviceBuilder.build());\n            }\n        }\n\n        Template template = getTemplate();\n        String iconUrl = getIconUrl();\n        if (!template.getParameters().isEmpty() || Strings.isNotBlank(iconUrl)) {\n            configureTemplateDescriptionAndIcon(template, iconUrl);\n            builder = builder.addToTemplateItems(template);\n        }\n\n        KubernetesList kubernetesList = builder.build();\n\n        Object result = Templates.combineTemplates(kubernetesList);\n        if (result instanceof Template) {\n            Template resultTemplate = (Template) result;\n            configureTemplateDescriptionAndIcon(resultTemplate, iconUrl);\n\n            if (pureKubernetes) {\n                try {\n                    result = applyTemplates(template);\n                } catch (IOException e) {\n                    throw new MojoExecutionException(\"Failed to process template locally \" + e, e);\n                }\n            }\n        }\n        try {\n            if (pureKubernetes) {\n                result = filterPureKubernetes(result);\n            }\n\n            ObjectMapper mapper = new ObjectMapper()\n                    .enable(SerializationFeature.INDENT_OUTPUT);\n            String generated = mapper.writeValueAsString(result);\n            Files.writeToFile(kubernetesJson, generated, Charset.defaultCharset());\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"Failed to generate Kubernetes JSON.\", e);\n        }\n    }","commit_id":"7c57b91b826521b224f49e403a418a84583cd177","url":"https://github.com/fabric8io/fabric8"},{"original_method":"protected FileEntry doMoveFileEntryFromTrash(\n\t\t\tlong userId, FileEntry fileEntry, long newFolderId,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// File entry\n\n\t\tList<DLFileVersion> dlFileVersions =\n\t\t\tdlFileVersionLocalService.getFileVersions(\n\t\t\t\tfileEntry.getFileEntryId(), WorkflowConstants.STATUS_ANY);\n\n\t\tdlFileVersions = ListUtil.sort(\n\t\t\tdlFileVersions, new FileVersionVersionComparator());\n\n\t\tFileVersion fileVersion = new LiferayFileVersion(dlFileVersions.get(0));\n\n\t\tif (fileVersion.isInTrash()) {\n\t\t\trestoreFileEntryFromTrash(userId, fileEntry);\n\n\t\t\tDLFileEntry dlFileEntry = dlFileEntryLocalService.moveFileEntry(\n\t\t\t\tuserId, fileEntry.getFileEntryId(), newFolderId,\n\t\t\t\tserviceContext);\n\n\t\t\tif (DLAppHelperThreadLocal.isEnabled()) {\n\t\t\t\tdlFileRankLocalService.enableFileRanks(\n\t\t\t\t\tfileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\treturn new LiferayFileEntry(dlFileEntry);\n\t\t}\n\t\telse {\n\t\t\tdlFileEntryLocalService.updateStatus(\n\t\t\t\tuserId, fileVersion.getFileVersionId(), fileVersion.getStatus(),\n\t\t\t\tnew HashMap<String, Serializable>(), serviceContext);\n\n\t\t\tif (DLAppHelperThreadLocal.isEnabled()) {\n\n\t\t\t\t// File rank\n\n\t\t\t\tdlFileRankLocalService.enableFileRanks(\n\t\t\t\t\tfileEntry.getFileEntryId());\n\n\t\t\t\t// File shortcut\n\n\t\t\t\tdlFileShortcutLocalService.enableFileShortcuts(\n\t\t\t\t\tfileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\t// App helper\n\n\t\t\tfileEntry = dlAppService.moveFileEntry(\n\t\t\t\tfileEntry.getFileEntryId(), newFolderId, serviceContext);\n\n\t\t\t// Social\n\n\t\t\tsocialActivityCounterLocalService.enableActivityCounters(\n\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\tfileEntry.getFileEntryId());\n\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuserId, fileEntry.getGroupId(),\n\t\t\t\tDLFileEntryConstants.getClassName(), fileEntry.getFileEntryId(),\n\t\t\t\tSocialActivityConstants.TYPE_RESTORE_FROM_TRASH,\n\t\t\t\tStringPool.BLANK, 0);\n\n\t\t\treturn fileEntry;\n\t\t}\n\t}","id":65212,"modified_method":"protected FileEntry doMoveFileEntryFromTrash(\n\t\t\tlong userId, FileEntry fileEntry, long newFolderId,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// File entry\n\n\t\tList<DLFileVersion> dlFileVersions =\n\t\t\tdlFileVersionLocalService.getFileVersions(\n\t\t\t\tfileEntry.getFileEntryId(), WorkflowConstants.STATUS_ANY);\n\n\t\tdlFileVersions = ListUtil.sort(\n\t\t\tdlFileVersions, new FileVersionVersionComparator());\n\n\t\tFileVersion fileVersion = new LiferayFileVersion(dlFileVersions.get(0));\n\n\t\tif (fileVersion.isInTrash()) {\n\t\t\trestoreFileEntryFromTrash(userId, fileEntry);\n\n\t\t\tfileEntry = dlAppService.moveFileEntry(\n\t\t\t\tfileEntry.getFileEntryId(), newFolderId, serviceContext);\n\n\t\t\tif (DLAppHelperThreadLocal.isEnabled()) {\n\t\t\t\tdlFileRankLocalService.enableFileRanks(\n\t\t\t\t\tfileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\treturn fileEntry;\n\t\t}\n\t\telse {\n\t\t\tdlFileEntryLocalService.updateStatus(\n\t\t\t\tuserId, fileVersion.getFileVersionId(), fileVersion.getStatus(),\n\t\t\t\tnew HashMap<String, Serializable>(), serviceContext);\n\n\t\t\tif (DLAppHelperThreadLocal.isEnabled()) {\n\n\t\t\t\t// File rank\n\n\t\t\t\tdlFileRankLocalService.enableFileRanks(\n\t\t\t\t\tfileEntry.getFileEntryId());\n\n\t\t\t\t// File shortcut\n\n\t\t\t\tdlFileShortcutLocalService.enableFileShortcuts(\n\t\t\t\t\tfileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\t// App helper\n\n\t\t\tfileEntry = dlAppService.moveFileEntry(\n\t\t\t\tfileEntry.getFileEntryId(), newFolderId, serviceContext);\n\n\t\t\t// Social\n\n\t\t\tsocialActivityCounterLocalService.enableActivityCounters(\n\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\tfileEntry.getFileEntryId());\n\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuserId, fileEntry.getGroupId(),\n\t\t\t\tDLFileEntryConstants.getClassName(), fileEntry.getFileEntryId(),\n\t\t\t\tSocialActivityConstants.TYPE_RESTORE_FROM_TRASH,\n\t\t\t\tStringPool.BLANK, 0);\n\n\t\t\treturn fileEntry;\n\t\t}\n\t}","commit_id":"aed89b11ee6e7a736fd25acb8b639e8ebdd5a9fb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public FileEntry moveFileEntryFromTrash(\n\t\t\tlong userId, FileEntry fileEntry, long newFolderId,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// File entry\n\n\t\tList<DLFileVersion> dlFileVersions =\n\t\t\tdlFileVersionLocalService.getFileVersions(\n\t\t\t\tfileEntry.getFileEntryId(), WorkflowConstants.STATUS_ANY);\n\n\t\tdlFileVersions = ListUtil.sort(\n\t\t\tdlFileVersions, new FileVersionVersionComparator());\n\n\t\tFileVersion fileVersion = new LiferayFileVersion(dlFileVersions.get(0));\n\n\t\tif (fileVersion.isInTrash()) {\n\t\t\trestoreFileEntryFromTrash(userId, fileEntry);\n\n\t\t\tDLFileEntry dlFileEntry = dlFileEntryLocalService.moveFileEntry(\n\t\t\t\tuserId, fileEntry.getFileEntryId(), newFolderId,\n\t\t\t\tserviceContext);\n\n\t\t\tif (DLAppHelperThreadLocal.isEnabled()) {\n\t\t\t\tdlFileRankLocalService.enableFileRanks(\n\t\t\t\t\tfileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\treturn new LiferayFileEntry(dlFileEntry);\n\t\t}\n\t\telse {\n\t\t\tdlFileEntryLocalService.updateStatus(\n\t\t\t\tuserId, fileVersion.getFileVersionId(), fileVersion.getStatus(),\n\t\t\t\tnew HashMap<String, Serializable>(), serviceContext);\n\n\t\t\tif (DLAppHelperThreadLocal.isEnabled()) {\n\n\t\t\t\t// File rank\n\n\t\t\t\tdlFileRankLocalService.enableFileRanks(\n\t\t\t\t\tfileEntry.getFileEntryId());\n\n\t\t\t\t// File shortcut\n\n\t\t\t\tdlFileShortcutLocalService.enableFileShortcuts(\n\t\t\t\t\tfileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\t// App helper\n\n\t\t\treturn dlAppService.moveFileEntry(\n\t\t\t\tfileEntry.getFileEntryId(), newFolderId, serviceContext);\n\t\t}\n\t}","id":65213,"modified_method":"public FileEntry moveFileEntryFromTrash(\n\t\t\tlong userId, FileEntry fileEntry, long newFolderId,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// File entry\n\n\t\tList<DLFileVersion> dlFileVersions =\n\t\t\tdlFileVersionLocalService.getFileVersions(\n\t\t\t\tfileEntry.getFileEntryId(), WorkflowConstants.STATUS_ANY);\n\n\t\tdlFileVersions = ListUtil.sort(\n\t\t\tdlFileVersions, new FileVersionVersionComparator());\n\n\t\tFileVersion fileVersion = new LiferayFileVersion(dlFileVersions.get(0));\n\n\t\tif (fileVersion.isInTrash()) {\n\t\t\trestoreFileEntryFromTrash(userId, fileEntry);\n\n\t\t\tDLFileEntry dlFileEntry = dlFileEntryLocalService.moveFileEntry(\n\t\t\t\tuserId, fileEntry.getFileEntryId(), newFolderId,\n\t\t\t\tserviceContext);\n\n\t\t\tif (DLAppHelperThreadLocal.isEnabled()) {\n\t\t\t\tdlFileRankLocalService.enableFileRanks(\n\t\t\t\t\tfileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\treturn new LiferayFileEntry(dlFileEntry);\n\t\t}\n\t\telse {\n\t\t\tdlFileEntryLocalService.updateStatus(\n\t\t\t\tuserId, fileVersion.getFileVersionId(), fileVersion.getStatus(),\n\t\t\t\tnew HashMap<String, Serializable>(), serviceContext);\n\n\t\t\tif (DLAppHelperThreadLocal.isEnabled()) {\n\n\t\t\t\t// File rank\n\n\t\t\t\tdlFileRankLocalService.enableFileRanks(\n\t\t\t\t\tfileEntry.getFileEntryId());\n\n\t\t\t\t// File shortcut\n\n\t\t\t\tdlFileShortcutLocalService.enableFileShortcuts(\n\t\t\t\t\tfileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\t// App helper\n\n\t\t\tfileEntry = dlAppService.moveFileEntry(\n\t\t\t\tfileEntry.getFileEntryId(), newFolderId, serviceContext);\n\n\t\t\t// Social\n\n\t\t\tsocialActivityCounterLocalService.enableActivityCounters(\n\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\tfileEntry.getFileEntryId());\n\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuserId, fileEntry.getGroupId(),\n\t\t\t\tDLFileEntryConstants.getClassName(), fileEntry.getFileEntryId(),\n\t\t\t\tSocialActivityConstants.TYPE_RESTORE_FROM_TRASH,\n\t\t\t\tStringPool.BLANK, 0);\n\n\t\t\treturn fileEntry;\n\t\t}\n\t}","commit_id":"5f2c22affbde6c9131e52f85e48c172225e01d75","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected DLFileEntry updateFileEntry(\n\t\t\tlong userId, long fileEntryId, String sourceFileName, String title,\n\t\t\tString description, String changeLog, boolean majorVersion,\n\t\t\tString extraSettings, InputStream is, long size,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// File entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDLFileEntry dlFileEntry = dlFileEntryPersistence.findByPrimaryKey(\n\t\t\tfileEntryId);\n\n\t\tString extension = (String)serviceContext.getAttribute(\"extension\");\n\n\t\tif (Validator.isNull(extension)) {\n\t\t\textension = dlFileEntry.getExtension();\n\t\t}\n\n\t\tString mimeType = (String)serviceContext.getAttribute(\"contentType\");\n\n\t\tif (Validator.isNull(mimeType)) {\n\t\t\tmimeType = dlFileEntry.getMimeType();\n\t\t}\n\n\t\tif (Validator.isNull(title)) {\n\t\t\ttitle = sourceFileName;\n\n\t\t\tif (Validator.isNull(title)) {\n\t\t\t\ttitle = dlFileEntry.getTitle();\n\t\t\t}\n\t\t}\n\n\t\tLong documentTypeId = (Long)serviceContext.getAttribute(\n\t\t\t\"documentTypeId\");\n\n\t\tif (documentTypeId == null) {\n\t\t\tdocumentTypeId = 0L;\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidateFile(\n\t\t\tdlFileEntry.getGroupId(), dlFileEntry.getFolderId(),\n\t\t\tdlFileEntry.getFileEntryId(), dlFileEntry.getExtension(), title,\n\t\t\tsourceFileName, is);\n\n\t\t// File version\n\n\t\tString version = getNextVersion(\n\t\t\tdlFileEntry, majorVersion, serviceContext.getWorkflowAction());\n\n\t\tDLFileVersion dlFileVersion = null;\n\n\t\tboolean updatedFileVersion = false;\n\n\t\ttry {\n\t\t\tDLFileVersion latestDLFileVersion =\n\t\t\t\tdlFileEntry.getLatestFileVersion();\n\n\t\t\tif (size == 0) {\n\t\t\t\tsize = latestDLFileVersion.getSize();\n\t\t\t}\n\n\t\t\tif (!latestDLFileVersion.isApproved()) {\n\t\t\t\tif (!PropsValues.DL_FILE_ENTRY_DRAFTS_ENABLED) {\n\t\t\t\t\tversion = latestDLFileVersion.getVersion();\n\t\t\t\t}\n\n\t\t\t\tif (version.equals(latestDLFileVersion.getVersion())) {\n\t\t\t\t\tupdatedFileVersion = true;\n\t\t\t\t}\n\n\t\t\t\tif (latestDLFileVersion.isPending()) {\n\t\t\t\t\tserviceContext.setWorkflowAction(\n\t\t\t\t\t\tWorkflowConstants.ACTION_SAVE_DRAFT);\n\t\t\t\t}\n\n\t\t\t\tupdateFileVersion(\n\t\t\t\t\tuser, latestDLFileVersion, sourceFileName, extension,\n\t\t\t\t\tmimeType, title, description, changeLog, extraSettings,\n\t\t\t\t\tdocumentTypeId, version, size,\n\t\t\t\t\tlatestDLFileVersion.getStatus(),\n\t\t\t\t\tserviceContext.getModifiedDate(now), serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (latestDLFileVersion.getSize() == 0) {\n\t\t\t\t\tversion = latestDLFileVersion.getVersion();\n\n\t\t\t\t\tupdateFileVersion(\n\t\t\t\t\t\tuser, latestDLFileVersion, sourceFileName, extension,\n\t\t\t\t\t\tmimeType, title, description, changeLog, extraSettings,\n\t\t\t\t\t\tdocumentTypeId, version, size,\n\t\t\t\t\t\tlatestDLFileVersion.getStatus(),\n\t\t\t\t\t\tserviceContext.getModifiedDate(now), serviceContext);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdlFileVersion = addFileVersion(\n\t\t\t\t\t\tuser, dlFileEntry, serviceContext.getModifiedDate(now),\n\t\t\t\t\t\textension, mimeType, title, description, changeLog,\n\t\t\t\t\t\textraSettings, documentTypeId, version, size,\n\t\t\t\t\t\tWorkflowConstants.STATUS_DRAFT, serviceContext);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dlFileVersion == null) {\n\t\t\t\tdlFileVersion = latestDLFileVersion;\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchFileVersionException nsfve) {\n\t\t\tdlFileVersion = addFileVersion(\n\t\t\t\tuser, dlFileEntry, serviceContext.getModifiedDate(now),\n\t\t\t\textension, mimeType, title, description, changeLog,\n\t\t\t\textraSettings, documentTypeId, version, size,\n\t\t\t\tWorkflowConstants.STATUS_DRAFT, serviceContext);\n\t\t}\n\n\t\tFile file = null;\n\n\t\tif ((is == null) && !updatedFileVersion) {\n\t\t\tint fetchFailures = 0;\n\n\t\t\twhile (is == null) {\n\t\t\t\ttry {\n\t\t\t\t\tis = dlLocalService.getFileAsStream(\n\t\t\t\t\t\tuser.getCompanyId(), dlFileEntry.getDataRepositoryId(),\n\t\t\t\t\t\tdlFileEntry.getName());\n\n\t\t\t\t\tfile = FileUtil.createTempFile(\n\t\t\t\t\t\tFileUtil.getExtension(title));\n\n\t\t\t\t\tFileUtil.write(file, is);\n\t\t\t\t}\n\t\t\t\tcatch (IOException ioe) {\n\t\t\t\t\tthrow new SystemException(ioe);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchFileException nsfe) {\n\t\t\t\t\tfetchFailures++;\n\n\t\t\t\t\tif (PropsValues.DL_HOOK_IMPL.equals(\n\t\t\t\t\t\t\tJCRHook.class.getName()) &&\n\t\t\t\t\t\t(fetchFailures <\n\t\t\t\t\t\t\tPropsValues.DL_HOOK_JCR_FETCH_MAX_FAILURES)) {\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tThread.sleep(PropsValues.DL_HOOK_JCR_FETCH_DELAY);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (InterruptedException ie) {\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow nsfe;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, dlFileEntry, dlFileVersion,\n\t\t\tserviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Folder\n\n\t\tif (dlFileEntry.getFolderId() !=\n\t\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\tDLFolder dlFolder = dlFolderPersistence.findByPrimaryKey(\n\t\t\t\tdlFileEntry.getFolderId());\n\n\t\t\tdlFolder.setLastPostDate(dlFileEntry.getModifiedDate());\n\n\t\t\tdlFolderPersistence.update(dlFolder, false);\n\t\t}\n\n\t\t// File\n\n\t\tif ((is != null) || (file != null)) {\n\t\t\ttry {\n\t\t\t\tdlLocalService.deleteFile(\n\t\t\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\t\t\tdlFileEntry.getDataRepositoryId(), dlFileEntry.getName(),\n\t\t\t\t\tversion);\n\t\t\t}\n\t\t\tcatch (NoSuchFileException nsfe) {\n\t\t\t}\n\n\t\t\tif (file != null) {\n\t\t\t\ttry {\n\t\t\t\t\tis = new FileInputStream(file);\n\t\t\t\t}\n\t\t\t\tcatch (IOException ioe) {\n\t\t\t\t\tthrow new SystemException(ioe);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdlLocalService.updateFile(\n\t\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\t\tdlFileEntry.getGroupId(), dlFileEntry.getDataRepositoryId(),\n\t\t\t\tdlFileEntry.getName(), dlFileEntry.getExtension(), false,\n\t\t\t\tversion, sourceFileName, dlFileEntry.getFileEntryId(),\n\t\t\t\tdlFileEntry.getLuceneProperties(),\n\t\t\t\tdlFileEntry.getModifiedDate(), serviceContext, is);\n\t\t}\n\n\t\t// Workflow\n\n\t\tif (serviceContext.getWorkflowAction() ==\n\t\t\t\tWorkflowConstants.ACTION_PUBLISH) {\n\n\t\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\t\tuser.getCompanyId(), dlFileEntry.getGroupId(), userId,\n\t\t\t\tDLFileEntry.class.getName(), dlFileEntry.getFileEntryId(),\n\t\t\t\tdlFileEntry, serviceContext);\n\t\t}\n\n\t\treturn dlFileEntry;\n\t}","id":65214,"modified_method":"protected DLFileEntry updateFileEntry(\n\t\t\tlong userId, long fileEntryId, String sourceFileName, String title,\n\t\t\tString description, String changeLog, boolean majorVersion,\n\t\t\tString extraSettings, InputStream is, long size,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tDLFileEntry dlFileEntry = dlFileEntryPersistence.findByPrimaryKey(\n\t\t\tfileEntryId);\n\n\t\tboolean autoCheckIn = false;\n\n\t\tif (!dlFileEntry.isLocked()) {\n\t\t\tdlFileEntry = checkOutFileEntry(userId, fileEntryId);\n\t\t\tautoCheckIn = true;\n\t\t}\n\n\t\tString extension = (String)serviceContext.getAttribute(\"extension\");\n\n\t\tif (Validator.isNull(extension)) {\n\t\t\textension = dlFileEntry.getExtension();\n\t\t}\n\n\t\tString mimeType = (String)serviceContext.getAttribute(\"contentType\");\n\n\t\tif (Validator.isNull(mimeType)) {\n\t\t\tmimeType = dlFileEntry.getMimeType();\n\t\t}\n\n\t\tif (Validator.isNull(title)) {\n\t\t\ttitle = sourceFileName;\n\n\t\t\tif (Validator.isNull(title)) {\n\t\t\t\ttitle = dlFileEntry.getTitle();\n\t\t\t}\n\t\t}\n\n\t\tLong documentTypeId = (Long)serviceContext.getAttribute(\n\t\t\t\"documentTypeId\");\n\n\t\tif (documentTypeId == null) {\n\t\t\tdocumentTypeId = 0L;\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidateFile(\n\t\t\tdlFileEntry.getGroupId(), dlFileEntry.getFolderId(),\n\t\t\tdlFileEntry.getFileEntryId(), dlFileEntry.getExtension(), title,\n\t\t\tsourceFileName, is);\n\n\t\t// File version\n\n\t\tDLFileVersion dlFileVersion = dlFileEntry.getLatestFileVersion();\n\n\t\tString version = dlFileVersion.getVersion();\n\n\t\tif (size == 0) {\n\t\t\tsize = dlFileVersion.getSize();\n\t\t}\n\n\t\tupdateFileVersion(\n\t\t\tuser, dlFileVersion, sourceFileName, extension,mimeType, title,\n\t\t\tdescription, changeLog, extraSettings, documentTypeId, version,\n\t\t\tsize, dlFileVersion.getStatus(),\n\t\t\tserviceContext.getModifiedDate(now), serviceContext);\n\n\t\t// File\n\n\t\tif (is != null) {\n\t\t\ttry {\n\t\t\t\tdlLocalService.deleteFile(\n\t\t\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\t\t\tdlFileEntry.getDataRepositoryId(), dlFileEntry.getName(),\n\t\t\t\t\tversion);\n\t\t\t}\n\t\t\tcatch (NoSuchFileException nsfe) {\n\t\t\t}\n\n\t\t\tdlLocalService.updateFile(\n\t\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\t\tdlFileEntry.getGroupId(), dlFileEntry.getDataRepositoryId(),\n\t\t\t\tdlFileEntry.getName(), dlFileEntry.getExtension(), false,\n\t\t\t\tversion, sourceFileName, dlFileEntry.getFileEntryId(),\n\t\t\t\tdlFileEntry.getLuceneProperties(),\n\t\t\t\tdlFileEntry.getModifiedDate(), serviceContext, is);\n\t\t}\n\n\t\tif (autoCheckIn) {\n\t\t\tcheckInFileEntry(\n\t\t\t\tuserId, fileEntryId, majorVersion, changeLog, serviceContext);\n\t\t}\n\n\t\treturn dlFileEntry;\n\t}","commit_id":"7da885fb8ca7d617a3654acff6a3f981c6ac2540","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public DLFileEntry moveFileEntry(\n\t\t\tlong userId, long fileEntryId, long newFolderId,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDLFileEntry dlFileEntry = dlFileEntryPersistence.findByPrimaryKey(\n\t\t\tfileEntryId);\n\n\t\tlong oldFileEntryId = dlFileEntry.getFileEntryId();\n\n\t\tif (dlLocalService.hasFile(\n\t\t\t\tuser.getCompanyId(),\n\t\t\t\tDLFolderConstants.getDataRepositoryId(\n\t\t\t\t\tdlFileEntry.getGroupId(), newFolderId),\n\t\t\t\tdlFileEntry.getName(), StringPool.BLANK)) {\n\n\t\t\tthrow new DuplicateFileException(dlFileEntry.getName());\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tlong newFileEntryId = counterLocalService.increment();\n\n\t\tDLFileEntry newDLFileEntry = dlFileEntryPersistence.create(\n\t\t\tnewFileEntryId);\n\n\t\tnewDLFileEntry.setUuid(dlFileEntry.getUuid());\n\t\tnewDLFileEntry.setGroupId(dlFileEntry.getGroupId());\n\t\tnewDLFileEntry.setCompanyId(dlFileEntry.getCompanyId());\n\t\tnewDLFileEntry.setUserId(dlFileEntry.getUserId());\n\t\tnewDLFileEntry.setUserName(dlFileEntry.getUserName());\n\t\tnewDLFileEntry.setVersionUserId(dlFileEntry.getVersionUserId());\n\t\tnewDLFileEntry.setVersionUserName(dlFileEntry.getVersionUserName());\n\t\tnewDLFileEntry.setCreateDate(dlFileEntry.getCreateDate());\n\t\tnewDLFileEntry.setModifiedDate(dlFileEntry.getModifiedDate());\n\t\tnewDLFileEntry.setRepositoryId(dlFileEntry.getRepositoryId());\n\t\tnewDLFileEntry.setFolderId(newFolderId);\n\t\tnewDLFileEntry.setName(dlFileEntry.getName());\n\t\tnewDLFileEntry.setExtension(dlFileEntry.getExtension());\n\t\tnewDLFileEntry.setTitle(dlFileEntry.getTitle());\n\t\tnewDLFileEntry.setDescription(dlFileEntry.getDescription());\n\t\tnewDLFileEntry.setExtraSettings(dlFileEntry.getExtraSettings());\n\t\tnewDLFileEntry.setVersion(dlFileEntry.getVersion());\n\t\tnewDLFileEntry.setSize(dlFileEntry.getSize());\n\t\tnewDLFileEntry.setReadCount(dlFileEntry.getReadCount());\n\n\t\tdlFileEntryPersistence.remove(dlFileEntry);\n\n\t\tdlFileEntryPersistence.update(newDLFileEntry, false);\n\n\t\tworkflowInstanceLinkLocalService.updateClassPK(\n\t\t\tdlFileEntry.getCompanyId(), dlFileEntry.getGroupId(),\n\t\t\tDLFileEntry.class.getName(), oldFileEntryId, newFileEntryId);\n\n\t\tList<DLFileVersion> dlFileVersions =\n\t\t\tdlFileVersionPersistence.findByFileEntryId(oldFileEntryId);\n\n\t\tfor (DLFileVersion dlFileVersion : dlFileVersions) {\n\t\t\tlong newFileVersionId = counterLocalService.increment();\n\n\t\t\tDLFileVersion newDLFileVersion = dlFileVersionPersistence.create(\n\t\t\t\tnewFileVersionId);\n\n\t\t\tnewDLFileVersion.setGroupId(dlFileVersion.getGroupId());\n\t\t\tnewDLFileVersion.setCompanyId(dlFileVersion.getCompanyId());\n\t\t\tnewDLFileVersion.setUserId(dlFileVersion.getUserId());\n\t\t\tnewDLFileVersion.setUserName(dlFileVersion.getUserName());\n\t\t\tnewDLFileVersion.setCreateDate(dlFileVersion.getCreateDate());\n\t\t\tnewDLFileVersion.setFileEntryId(newFileEntryId);\n\t\t\tnewDLFileVersion.setExtension(dlFileVersion.getExtension());\n\t\t\tnewDLFileVersion.setTitle(dlFileVersion.getTitle());\n\t\t\tnewDLFileVersion.setDescription(dlFileVersion.getDescription());\n\t\t\tnewDLFileVersion.setChangeLog(dlFileVersion.getChangeLog());\n\t\t\tnewDLFileVersion.setExtraSettings(dlFileVersion.getExtraSettings());\n\t\t\tnewDLFileVersion.setVersion(dlFileVersion.getVersion());\n\t\t\tnewDLFileVersion.setSize(dlFileVersion.getSize());\n\t\t\tnewDLFileVersion.setStatus(dlFileVersion.getStatus());\n\t\t\tnewDLFileVersion.setStatusByUserId(userId);\n\t\t\tnewDLFileVersion.setStatusByUserName(user.getFullName());\n\t\t\tnewDLFileVersion.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\t\tExpandoBridge newDLFileVersionExpandoBridge =\n\t\t\t\tnewDLFileVersion.getExpandoBridge();\n\n\t\t\tExpandoBridge dlFileVersionExpandoBridge =\n\t\t\t\tdlFileVersion.getExpandoBridge();\n\n\t\t\tnewDLFileVersionExpandoBridge.setAttributes(\n\t\t\t\tdlFileVersionExpandoBridge.getAttributes());\n\n\t\t\tdlFileVersionPersistence.update(newDLFileVersion, false);\n\n\t\t\tdlFileVersionPersistence.remove(dlFileVersion);\n\t\t}\n\n\t\t// Resources\n\n\t\tresourceLocalService.updateResources(\n\t\t\tdlFileEntry.getCompanyId(), DLFileEntry.class.getName(),\n\t\t\tResourceConstants.SCOPE_INDIVIDUAL,\n\t\t\tString.valueOf(dlFileEntry.getFileEntryId()),\n\t\t\tString.valueOf(newFileEntryId));\n\n\t\t// Expando\n\n\t\texpandoValueLocalService.deleteValues(\n\t\t\tDLFileEntry.class.getName(), dlFileEntry.getFileEntryId());\n\n\t\t// DLApp\n\n\t\tdlAppHelperLocalService.moveFileEntry(oldFileEntryId, newFileEntryId);\n\n\t\t// File\n\n\t\tdlLocalService.updateFile(\n\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\tnewDLFileEntry.getGroupId(), dlFileEntry.getDataRepositoryId(),\n\t\t\tnewDLFileEntry.getDataRepositoryId(), dlFileEntry.getName(),\n\t\t\tnewFileEntryId);\n\n\t\treturn newDLFileEntry;\n\t}","id":65215,"modified_method":"public DLFileEntry moveFileEntry(\n\t\t\tlong userId, long fileEntryId, long newFolderId,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tboolean hasLock = hasFileEntryLock(userId, fileEntryId);\n\n\t\tif (!hasLock) {\n\t\t\tlockFileEntry(userId, fileEntryId);\n\t\t}\n\n\t\ttry {\n\t\t\treturn moveFileEntryImpl(\n\t\t\t\tuserId, fileEntryId, newFolderId, serviceContext);\n\t\t}\n\t\tfinally {\n\t\t\tunlockFileEntry(fileEntryId);\n\t\t}\n\t}","commit_id":"7da885fb8ca7d617a3654acff6a3f981c6ac2540","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteFileEntry(long fileEntryId)\n\t\tthrows PortalException, SystemException {\n\n\t\tDLFileEntryPermission.check(\n\t\t\tgetPermissionChecker(), fileEntryId, ActionKeys.DELETE);\n\n\t\tboolean hasLock = hasFileEntryLock(fileEntryId);\n\n\t\tif (!hasLock) {\n\n\t\t\t// Lock\n\n\t\t\tlockFileEntry(fileEntryId);\n\t\t}\n\n\t\ttry {\n\t\t\tdlFileEntryLocalService.deleteFileEntry(fileEntryId);\n\t\t}\n\t\tfinally {\n\n\t\t\t// Unlock\n\n\t\t\tunlockFileEntry(fileEntryId);\n\t\t}\n\t}","id":65216,"modified_method":"public void deleteFileEntry(long fileEntryId)\n\t\tthrows PortalException, SystemException {\n\n\t\tDLFileEntryPermission.check(\n\t\t\tgetPermissionChecker(), fileEntryId, ActionKeys.DELETE);\n\n\t\tdlFileEntryLocalService.deleteFileEntry(getUserId(), fileEntryId);\n\t}","commit_id":"7da885fb8ca7d617a3654acff6a3f981c6ac2540","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void revertFileEntry(\n\t\t\tlong fileEntryId, String version, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tDLFileEntryPermission.check(\n\t\t\tgetPermissionChecker(), fileEntryId, ActionKeys.UPDATE);\n\n\t\tboolean hasLock = hasFileEntryLock(fileEntryId);\n\n\t\tif (!hasLock) {\n\n\t\t\t// Lock\n\n\t\t\tlockFileEntry(fileEntryId);\n\t\t}\n\n\t\ttry {\n\t\t\tdlFileEntryLocalService.revertFileEntry(\n\t\t\t\tgetUserId(), fileEntryId, version, serviceContext);\n\t\t}\n\t\tfinally {\n\n\t\t\t// Unlock\n\n\t\t\tunlockFileEntry(fileEntryId);\n\t\t}\n\t}","id":65217,"modified_method":"public void revertFileEntry(\n\t\t\tlong fileEntryId, String version, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tDLFileEntryPermission.check(\n\t\t\tgetPermissionChecker(), fileEntryId, ActionKeys.UPDATE);\n\n\t\tdlFileEntryLocalService.revertFileEntry(\n\t\t\tgetUserId(), fileEntryId, version, serviceContext);\n\t}","commit_id":"7da885fb8ca7d617a3654acff6a3f981c6ac2540","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public DLFileEntry moveFileEntry(\n\t\t\tlong fileEntryId, long newFolderId, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tDLFileEntryPermission.check(\n\t\t\tgetPermissionChecker(), fileEntryId, ActionKeys.UPDATE);\n\n\t\tboolean hasLock = hasFileEntryLock(fileEntryId);\n\n\t\tif (!hasLock) {\n\n\t\t\t// Lock\n\n\t\t\tlockFileEntry(fileEntryId);\n\t\t}\n\n\t\tDLFileEntry dlFileEntry = null;\n\n\t\ttry {\n\t\t\tdlFileEntry = dlFileEntryLocalService.moveFileEntry(\n\t\t\t\tgetUserId(), fileEntryId, newFolderId, serviceContext);\n\t\t}\n\t\tfinally {\n\t\t\tif (!hasLock) {\n\n\t\t\t\t// Unlock\n\n\t\t\t\tunlockFileEntry(fileEntryId);\n\t\t\t}\n\t\t}\n\n\t\treturn dlFileEntry;\n\t}","id":65218,"modified_method":"public DLFileEntry moveFileEntry(\n\t\t\tlong fileEntryId, long newFolderId, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tDLFileEntryPermission.check(\n\t\t\tgetPermissionChecker(), fileEntryId, ActionKeys.UPDATE);\n\n\t\treturn dlFileEntryLocalService.moveFileEntry(\n\t\t\tgetUserId(), fileEntryId, newFolderId, serviceContext);\n\n\t}","commit_id":"7da885fb8ca7d617a3654acff6a3f981c6ac2540","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public DLFileEntry updateFileEntry(\n\t\t\tlong fileEntryId, String sourceFileName, String title,\n\t\t\tString description, String changeLog, boolean majorVersion,\n\t\t\tInputStream is, long size, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tDLFileEntryPermission.check(\n\t\t\tgetPermissionChecker(), fileEntryId, ActionKeys.UPDATE);\n\n\t\tboolean hasLock = hasFileEntryLock(fileEntryId);\n\n\t\tif (!hasLock) {\n\n\t\t\t// Lock\n\n\t\t\tlockFileEntry(fileEntryId);\n\t\t}\n\n\t\tDLFileEntry dlFileEntry = null;\n\n\t\ttry {\n\t\t\tdlFileEntry = dlFileEntryLocalService.updateFileEntry(\n\t\t\t\tgetUserId(), fileEntryId, sourceFileName, title, description,\n\t\t\t\tchangeLog, majorVersion, is, size, serviceContext);\n\t\t}\n\t\tfinally {\n\t\t\tif (!hasLock) {\n\n\t\t\t\t// Unlock\n\n\t\t\t\tunlockFileEntry(fileEntryId);\n\t\t\t}\n\t\t}\n\n\t\treturn dlFileEntry;\n\t}","id":65219,"modified_method":"public DLFileEntry updateFileEntry(\n\t\t\tlong fileEntryId, String sourceFileName, String title,\n\t\t\tString description, String changeLog, boolean majorVersion,\n\t\t\tInputStream is, long size, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tDLFileEntryPermission.check(\n\t\t\tgetPermissionChecker(), fileEntryId, ActionKeys.UPDATE);\n\n\t\tDLFileEntry dlFileEntry = null;\n\n\t\tdlFileEntry = dlFileEntryLocalService.updateFileEntry(\n\t\t\tgetUserId(), fileEntryId, sourceFileName, title, description,\n\t\t\tchangeLog, majorVersion, is, size, serviceContext);\n\n\t\treturn dlFileEntry;\n\t}","commit_id":"7da885fb8ca7d617a3654acff6a3f981c6ac2540","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int compare(\n\t\tDLFileVersion dlFileVersion1, DLFileVersion dlFileVersion2) {\n\n\t\tint value = 0;\n\n\t\tint[] versionParts1 = StringUtil.split(\n\t\t\tdlFileVersion1.getVersion(), StringPool.PERIOD, 0);\n\t\tint[] versionParts2 = StringUtil.split(\n\t\t\tdlFileVersion2.getVersion(), StringPool.PERIOD, 0);\n\n\t\tif ((versionParts1.length != 2) && (versionParts2.length != 2)) {\n\t\t\tvalue = 0;\n\t\t}\n\t\telse if ((versionParts1.length != 2)) {\n\t\t\tvalue = -1;\n\t\t}\n\t\telse if ((versionParts2.length != 2)) {\n\t\t\tvalue = 1;\n\t\t}\n\t\telse if (versionParts1[0] > versionParts2[0]) {\n\t\t\tvalue = 1;\n\t\t}\n\t\telse if (versionParts1[0] < versionParts2[0]) {\n\t\t\tvalue = -1;\n\t\t}\n\t\telse if (versionParts1[1] > versionParts2[1]) {\n\t\t\tvalue = 1;\n\t\t}\n\t\telse if (versionParts1[1] < versionParts2[1]) {\n\t\t\tvalue = -1;\n\t\t}\n\n\t\tif (_ascending) {\n\t\t\treturn value;\n\t\t}\n\t\telse {\n\t\t\treturn -value;\n\t\t}\n\t}","id":65220,"modified_method":"public int compare(\n\t\tDLFileVersion dlFileVersion1, DLFileVersion dlFileVersion2) {\n\n\t\tint value = 0;\n\n\t\tif (dlFileVersion1.getVersion().equals(\"PWC\")) {\n\t\t\treturn -1;\n\t\t}\n\t\telse if (dlFileVersion2.getVersion().equals(\"PWC\")) {\n\t\t\treturn 1;\n\t\t}\n\n\t\tint[] versionParts1 = StringUtil.split(\n\t\t\tdlFileVersion1.getVersion(), StringPool.PERIOD, 0);\n\t\tint[] versionParts2 = StringUtil.split(\n\t\t\tdlFileVersion2.getVersion(), StringPool.PERIOD, 0);\n\n\t\tif ((versionParts1.length != 2) && (versionParts2.length != 2)) {\n\t\t\tvalue = 0;\n\t\t}\n\t\telse if ((versionParts1.length != 2)) {\n\t\t\tvalue = -1;\n\t\t}\n\t\telse if ((versionParts2.length != 2)) {\n\t\t\tvalue = 1;\n\t\t}\n\t\telse if (versionParts1[0] > versionParts2[0]) {\n\t\t\tvalue = 1;\n\t\t}\n\t\telse if (versionParts1[0] < versionParts2[0]) {\n\t\t\tvalue = -1;\n\t\t}\n\t\telse if (versionParts1[1] > versionParts2[1]) {\n\t\t\tvalue = 1;\n\t\t}\n\t\telse if (versionParts1[1] < versionParts2[1]) {\n\t\t\tvalue = -1;\n\t\t}\n\n\t\tif (_ascending) {\n\t\t\treturn value;\n\t\t}\n\t\telse {\n\t\t\treturn -value;\n\t\t}\n\t}","commit_id":"7da885fb8ca7d617a3654acff6a3f981c6ac2540","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void initialize() throws IOException, InterruptedException {\n    new ProcessHelper(generateAdbCommand(\"logcat\", \"-c\")).execute();\n    logcat = Runtime.getRuntime().exec(generateAdbCommand(\"logcat\"));\n    new StreamPump(logcat.getInputStream()).addTarget(new LogLineProcessor())\n        .start();\n    new StreamPump(logcat.getErrorStream()).addTarget(System.err).start();\n  }","id":65221,"modified_method":"void initialize() throws IOException, InterruptedException {\n    adb(\"logcat\", \"-c\");\n    logcat = Runtime.getRuntime().exec(generateAdbCommand(\"logcat\"));\n    new StreamPump(logcat.getInputStream()).addTarget(new LogLineProcessor())\n        .start();\n    new StreamPump(logcat.getErrorStream()).addTarget(System.err).start();\n  }","commit_id":"cff2ad3064a991b71d919ffdefa813a24e1e3b7e","url":"https://github.com/processing/processing"},{"original_method":"public void shutdown() {\n    if (logcat != null) {\n      logcat.destroy();\n    }\n    env.deviceRemoved(this);\n  }","id":65222,"modified_method":"void shutdown() {\n    if (logcat != null) {\n      logcat.destroy();\n    }\n    env.deviceRemoved(this);\n  }","commit_id":"cff2ad3064a991b71d919ffdefa813a24e1e3b7e","url":"https://github.com/processing/processing"},{"original_method":"public void bringLauncherToFront() {\n    try {\n      new ProcessHelper(generateAdbCommand(\"shell\", \"am\", \"start\", \"-a\",\n        \"android.intent.action.MAIN\", \"-c\", \"android.intent.category.HOME\"))\n          .execute();\n    } catch (final Exception e) {\n      e.printStackTrace(System.err);\n    }\n  }","id":65223,"modified_method":"public void bringLauncherToFront() {\n    try {\n      adb(\"shell\", \"am\", \"start\", \"-a\", \"android.intent.action.MAIN\", \"-c\",\n        \"android.intent.category.HOME\");\n    } catch (final Exception e) {\n      e.printStackTrace(System.err);\n    }\n  }","commit_id":"cff2ad3064a991b71d919ffdefa813a24e1e3b7e","url":"https://github.com/processing/processing"},{"original_method":"public boolean installApp(final String apkPath, final RunnerListener status) {\n    bringLauncherToFront();\n    try {\n      final ProcessHelper p = new ProcessHelper(generateAdbCommand(\"install\",\n        \"-r\", // safe to always use -r switch\n        apkPath));\n\n      final ProcessResult installResult = p.execute();\n      if (!installResult.succeeded()) {\n        status.statusError(\"Could not install the sketch.\");\n        System.err.println(installResult);\n        return false;\n      }\n      String errorMsg = null;\n      for (final String line : installResult) {\n        if (line.startsWith(\"Failure\")) {\n          errorMsg = line.substring(8);\n          System.err.println(line);\n        }\n      }\n      if (errorMsg == null) {\n        status.statusNotice(\"Done installing.\");\n        return true;\n      }\n      status.statusError(\"Error while installing \" + errorMsg);\n    } catch (final IOException e) {\n      status.statusError(e);\n    } catch (final InterruptedException e) {\n    }\n    return false;\n  }","id":65224,"modified_method":"public boolean installApp(final String apkPath, final RunnerListener status) {\n    bringLauncherToFront();\n    try {\n      final ProcessResult installResult = adb(\"install\", \"-r\", apkPath);\n      if (!installResult.succeeded()) {\n        status.statusError(\"Could not install the sketch.\");\n        System.err.println(installResult);\n        return false;\n      }\n      String errorMsg = null;\n      for (final String line : installResult) {\n        if (line.startsWith(\"Failure\")) {\n          errorMsg = line.substring(8);\n          System.err.println(line);\n        }\n      }\n      if (errorMsg == null) {\n        status.statusNotice(\"Done installing.\");\n        return true;\n      }\n      status.statusError(\"Error while installing \" + errorMsg);\n    } catch (final IOException e) {\n      status.statusError(e);\n    } catch (final InterruptedException e) {\n    }\n    return false;\n  }","commit_id":"cff2ad3064a991b71d919ffdefa813a24e1e3b7e","url":"https://github.com/processing/processing"},{"original_method":"public boolean launchApp(final String packageName, final String className)\n      throws IOException, InterruptedException {\n    final ProcessHelper startSketch = new ProcessHelper(generateAdbCommand(\n      \"shell\", \"am\", \"start\", \"-e\", \"debug\", \"true\", \"-a\",\n      \"android.intent.action.MAIN\", \"-c\", \"android.intent.category.LAUNCHER\",\n      \"-n\", packageName + \"/.\" + className));\n    return startSketch.execute().succeeded();\n  }","id":65225,"modified_method":"public boolean launchApp(final String packageName, final String className)\n      throws IOException, InterruptedException {\n    return adb(\"shell\", \"am\", \"start\", \"-e\", \"debug\", \"true\", \"-a\",\n      \"android.intent.action.MAIN\", \"-c\", \"android.intent.category.LAUNCHER\",\n      \"-n\", packageName + \"/.\" + className).succeeded();\n  }","commit_id":"cff2ad3064a991b71d919ffdefa813a24e1e3b7e","url":"https://github.com/processing/processing"},{"original_method":"public void reset() {\n    myJdksTreeModel.reset(myProject);\n    myModulesConfigurator = new ModulesConfigurator(myProject, this);\n    myModulesConfigurator.resetModuleEditors();\n    myProjectConfigurable = myModulesConfigurator.getModulesConfigurable();\n    final LibraryTablesRegistrar tablesRegistrar = LibraryTablesRegistrar.getInstance();\n    myProjectLibrariesProvider = new LibrariesModifiableModel(tablesRegistrar.getLibraryTable(myProject).getModifiableModel());\n    myGlobalLibrariesProvider = new LibrariesModifiableModel(tablesRegistrar.getLibraryTable().getModifiableModel());\n    myApplicationServerLibrariesProvider =\n      new LibrariesModifiableModel(ApplicationServersManager.getInstance().getLibraryTable().getModifiableModel());\n    final Module[] modules = ModuleManager.getInstance(myProject).getModules();\n    for (Module module : modules) {\n      final ModifiableRootModel modelProxy = myModulesConfigurator.getModuleEditor(module).getModifiableRootModelProxy();\n      myModule2LibrariesMap.put(module, new LibrariesModifiableModel(modelProxy.getModuleLibraryTable().getModifiableModel()));\n    }\n    reloadTree();\n    super.reset();\n  }","id":65226,"modified_method":"public void reset() {\n    myJdksTreeModel.reset(myProject);\n    myModulesConfigurator = new ModulesConfigurator(myProject, this);\n    myModulesConfigurator.resetModuleEditors();\n    myProjectConfigurable = myModulesConfigurator.getModulesConfigurable();\n    final LibraryTablesRegistrar tablesRegistrar = LibraryTablesRegistrar.getInstance();\n    myProjectLibrariesProvider = new LibrariesModifiableModel(tablesRegistrar.getLibraryTable(myProject).getModifiableModel());\n    myGlobalLibrariesProvider = new LibrariesModifiableModel(tablesRegistrar.getLibraryTable().getModifiableModel());\n    myApplicationServerLibrariesProvider =\n      new LibrariesModifiableModel(ApplicationServersManager.getInstance().getLibraryTable().getModifiableModel());\n    final Module[] modules = myModulesConfigurator.getModules();\n    for (Module module : modules) {\n      final ModifiableRootModel modelProxy = myModulesConfigurator.getModuleEditor(module).getModifiableRootModelProxy();\n      myModule2LibrariesMap.put(module, new LibrariesModifiableModel(modelProxy.getModuleLibraryTable().getModifiableModel()));\n    }\n    reloadTree();\n    super.reset();\n  }","commit_id":"e5ef8abd06304ba33b7c8cfc4181a57e27f96110","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Set<String> getDependencies(Condition<OrderEntry> condition) {\n    final Set<String> result = new TreeSet<String>();\n    final Module[] modules = myModulesConfigurator.getModules();\n    for (Module module : modules) {\n      final ModifiableRootModel rootModel = myModulesConfigurator.getModuleEditor(module).getModifiableRootModel();\n      final OrderEntry[] entries = rootModel.getOrderEntries();\n      for (OrderEntry entry : entries) {\n        if (condition.value(entry)) {\n          result.add(module.getName());\n          break;\n        }\n      }\n    }\n    return result;\n  }","id":65227,"modified_method":"private Set<String> getDependencies(final Condition<OrderEntry> condition) {\n    final Set<String> result = new TreeSet<String>();\n    final Module[] modules = myModulesConfigurator.getModules();\n    for (final Module module : modules) {\n      final ModuleEditor moduleEditor = myModulesConfigurator.getModuleEditor(module);\n      if (moduleEditor != null) {\n        ApplicationManager.getApplication().runReadAction(new Runnable() {\n          public void run() {\n            final OrderEntry[] entries = moduleEditor.getModifiableRootModel().getOrderEntries();\n            for (OrderEntry entry : entries) {\n              if (condition.value(entry)) {\n                result.add(module.getName());\n                break;\n              }\n            }\n          }\n        });\n      }\n    }\n    return result;\n  }","commit_id":"e5ef8abd06304ba33b7c8cfc4181a57e27f96110","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private Set<String> getCachedDependencies(final Object selectedObject, final MyNode selectedNode, boolean force) {\n    if (selectedObject instanceof Library){\n      final Library library = (Library)selectedObject;\n      if (myLibraryDependencyCache.containsKey(library)){\n        return myLibraryDependencyCache.get(library);\n      }\n    } else if (selectedObject instanceof ProjectJdk){\n      final ProjectJdk projectJdk = (ProjectJdk)selectedObject;\n      if (myJdkDependencyCache.containsKey(projectJdk)){\n        return myJdkDependencyCache.get(projectJdk);\n      }\n    } else if (selectedObject instanceof Module) {\n      final Module module = (Module)selectedObject;\n      if (myModulesDependencyCache.containsKey(module)) {\n        return myModulesDependencyCache.get(module);\n      }\n    }\n    final Computable<Set<String>> dependencies = new Computable<Set<String>>(){\n      @Nullable\n      public Set<String> compute() {\n        final Set<String> dependencies = getDependencies(selectedObject, selectedNode);\n        if (selectedObject instanceof Library){\n          myLibraryDependencyCache.put((Library)selectedObject, dependencies);\n        } else if (selectedObject instanceof ProjectJdk){\n          final ProjectJdk projectJdk = (ProjectJdk)selectedObject;\n          myJdkDependencyCache.put(projectJdk, dependencies);\n        } else if (selectedObject instanceof Module){\n          myModulesDependencyCache.put((Module)selectedObject, dependencies);\n        }\n        return dependencies;\n      }\n    };\n    if (force){\n      return dependencies.compute();\n    } else {\n      myUpdateDependenciesAlarm.addRequest(new Runnable(){\n        public void run() {\n          ApplicationManager.getApplication().runReadAction(new Runnable() {\n            public void run() {\n              final Set<String> dep = dependencies.compute();\n              SwingUtilities.invokeLater(new Runnable(){\n                public void run() {\n                  if (dep != null && dep.size() == 0 && !myDisposed){\n                    myTree.repaint();\n                  }\n                }\n              });\n            }\n          });\n        }\n      }, 0);\n      return null;\n    }\n  }","id":65228,"modified_method":"@Nullable\n  private Set<String> getCachedDependencies(final Object selectedObject, final MyNode selectedNode, boolean force) {\n    if (selectedObject instanceof Library){\n      final Library library = (Library)selectedObject;\n      if (myLibraryDependencyCache.containsKey(library)){\n        return myLibraryDependencyCache.get(library);\n      }\n    } else if (selectedObject instanceof ProjectJdk){\n      final ProjectJdk projectJdk = (ProjectJdk)selectedObject;\n      if (myJdkDependencyCache.containsKey(projectJdk)){\n        return myJdkDependencyCache.get(projectJdk);\n      }\n    } else if (selectedObject instanceof Module) {\n      final Module module = (Module)selectedObject;\n      if (myModulesDependencyCache.containsKey(module)) {\n        return myModulesDependencyCache.get(module);\n      }\n    }\n    final Computable<Set<String>> dependencies = new Computable<Set<String>>(){\n      @Nullable\n      public Set<String> compute() {\n        final Set<String> dependencies = getDependencies(selectedObject, selectedNode);\n        if (selectedObject instanceof Library){\n          myLibraryDependencyCache.put((Library)selectedObject, dependencies);\n        } else if (selectedObject instanceof ProjectJdk){\n          final ProjectJdk projectJdk = (ProjectJdk)selectedObject;\n          myJdkDependencyCache.put(projectJdk, dependencies);\n        } else if (selectedObject instanceof Module){\n          myModulesDependencyCache.put((Module)selectedObject, dependencies);\n        }\n        return dependencies;\n      }\n    };\n    if (force){\n      return dependencies.compute();\n    } else {\n      myUpdateDependenciesAlarm.addRequest(new Runnable(){\n        public void run() {\n          final Set<String> dep = dependencies.compute();\n          SwingUtilities.invokeLater(new Runnable(){\n            public void run() {\n              if (dep != null && dep.size() == 0 && !myDisposed){\n                myTree.repaint();\n              }\n            }\n          });\n        }\n      }, 0);\n      return null;\n    }\n  }","commit_id":"e5ef8abd06304ba33b7c8cfc4181a57e27f96110","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public <C extends ServerConfiguration> RemoteServerConfigurable(RemoteServer<C> server, Runnable treeUpdater, boolean isNew) {\n    super(true, treeUpdater);\n    myServer = server;\n    myNew = isNew;\n    myServerName = myServer.getName();\n    C configuration = server.getConfiguration();\n    C innerConfiguration = XmlSerializerUtil.createCopy(configuration);\n    myInnerServer = new RemoteServerImpl<C>(\"<temp inner server>\", server.getType(), innerConfiguration);\n    myInnerApplied = false;\n    myUncheckedApply = false;\n\n    myConfigurable = server.getType().createConfigurable(innerConfiguration);\n\n    myAlarm = new Alarm(Alarm.ThreadToUse.SHARED_THREAD);\n    queueChangesCheck();\n  }","id":65229,"modified_method":"public <C extends ServerConfiguration> RemoteServerConfigurable(RemoteServer<C> server, Runnable treeUpdater, boolean isNew) {\n    super(true, treeUpdater);\n    myServer = server;\n    myNew = isNew;\n    myServerName = myServer.getName();\n    C configuration = server.getConfiguration();\n    C innerConfiguration = XmlSerializerUtil.createCopy(configuration);\n    myInnerServer = new RemoteServerImpl<C>(\"<temp inner server>\", server.getType(), innerConfiguration);\n    myInnerApplied = false;\n    myUncheckedApply = false;\n\n    myConfigurable = server.getType().createConfigurable(innerConfiguration);\n\n    myAlarm = new Alarm().setActivationComponent(myMainPanel);\n    queueChangesCheck();\n  }","commit_id":"544ab305df0bfc25316d5ed883fddc5ef0056292","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void queueChangesCheck() {\n    if (myAlarm.isDisposed()) {\n      return;\n    }\n    myAlarm.addRequest(new Runnable() {\n\n      @Override\n      public void run() {\n        UIUtil.invokeLaterIfNeeded(new Runnable() {\n\n          @Override\n          public void run() {\n            checkChanges();\n            queueChangesCheck();\n          }\n        });\n      }\n    }, CHANGES_CHECK_TIME);\n  }","id":65230,"modified_method":"private void queueChangesCheck() {\n    if (myAlarm.isDisposed()) {\n      return;\n    }\n    myAlarm.addRequest(new Runnable() {\n\n      @Override\n      public void run() {\n        checkChanges();\n        queueChangesCheck();\n      }\n    }, CHANGES_CHECK_TIME, ModalityState.any());\n  }","commit_id":"544ab305df0bfc25316d5ed883fddc5ef0056292","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static Reader getReaderByUrl(final String surl) {\n    try {\n      if (surl.startsWith(JAR_PROTOCOL)) {\n        VirtualFile file = VirtualFileManager.getInstance().findFileByUrl(BrowserUtil.getDocURL(surl));\n\n        if (file == null) {\n          return null;\n        }\n\n        return new StringReader(VfsUtil.loadText(file));\n      }\n\n      URL url = BrowserUtil.getURL(surl);\n      HttpConfigurable.getInstance().prepareURL(url.toString());\n      final URLConnection urlConnection = url.openConnection();\n      final String contentEncoding = urlConnection.getContentEncoding();\n      final ProgressIndicator pi = ProgressManager.getInstance().getProgressIndicator();\n      final InputStream inputStream = pi != null ? UrlConnectionUtil.getConnectionInputStreamWithException(urlConnection, pi) : urlConnection.getInputStream();\n      //noinspection IOResourceOpenedButNotSafelyClosed\n      return contentEncoding != null ? new InputStreamReader(inputStream, contentEncoding) : new InputStreamReader(inputStream);\n    }\n    catch (final IOException e) {\n      showErrorMessage(e);\n    }\n\n    return null;\n  }","id":65231,"modified_method":"@Nullable\n  private static Reader getReaderByUrl(final String surl, final ProgressIndicator pi) throws IOException {\n    if (surl.startsWith(JAR_PROTOCOL)) {\n      VirtualFile file = VirtualFileManager.getInstance().findFileByUrl(BrowserUtil.getDocURL(surl));\n\n      if (file == null) {\n        return null;\n      }\n\n      return new StringReader(VfsUtil.loadText(file));\n    }\n\n    URL url = BrowserUtil.getURL(surl);\n    HttpConfigurable.getInstance().prepareURL(url.toString());\n    final URLConnection urlConnection = url.openConnection();\n    final String contentEncoding = urlConnection.getContentEncoding();\n    final InputStream inputStream =\n      pi != null ? UrlConnectionUtil.getConnectionInputStreamWithException(urlConnection, pi) : urlConnection.getInputStream();\n    //noinspection IOResourceOpenedButNotSafelyClosed\n    return contentEncoding != null ? new InputStreamReader(inputStream, contentEncoding) : new InputStreamReader(inputStream);\n  }","commit_id":"1da5781833fea90964ea7ecb6ab1de990bc06a90","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isJavaDocURL(String url) {\n    final Reader stream = getReaderByUrl(url);\n\n    if (stream == null) {\n      return false;\n    }\n\n    final Waiter waiter = new Waiter(){\n      Boolean key = Boolean.FALSE;\n      final Object LOCK = new Object();\n\n      public void sayYes(){\n        key = Boolean.TRUE;\n        synchronized (LOCK) {\n          LOCK.notify();\n        }\n      }\n\n      public boolean runMe(){\n        try {\n          synchronized (LOCK) {\n            LOCK.wait(600);\n          }\n        }\n        catch (InterruptedException e) {\n          return false;\n        }\n\n        return key.booleanValue();\n      }\n    };\n\n    new Thread(new Runnable() {\n      public void run() {\n        try {\n          BufferedReader reader = null;\n          try {\n            reader = new BufferedReader(stream);\n            int lookUp = 6;\n\n            while (lookUp > 0) {\n              if (reader.readLine().indexOf(DOC_START_MARKER) != -1) {\n                waiter.sayYes();\n              }\n\n              lookUp--;\n            }\n          }\n          finally {\n            if (reader != null) {\n              reader.close();\n            }\n          }\n\n\n        }\n        catch (final Exception e) {\n          showErrorMessage(e);\n        }\n      }\n    }).start();\n\n    return waiter.runMe();\n  }","id":65232,"modified_method":"public static boolean isJavaDocURL(final String url) throws Exception {\n    final Waiter waiter = new Waiter(){\n      Boolean key = Boolean.FALSE;\n      final Object LOCK = new Object();\n\n      public void sayYes(){\n        key = Boolean.TRUE;\n        synchronized (LOCK) {\n          LOCK.notify();\n        }\n      }\n\n      public boolean runMe(){\n        try {\n          synchronized (LOCK) {\n            LOCK.wait(600);\n          }\n        }\n        catch (InterruptedException e) {\n          return false;\n        }\n\n        return key.booleanValue();\n      }\n    };\n\n    final boolean[] fail = new boolean[1];\n    final Exception [] ex = new Exception[1];\n    new Thread(new Runnable() {\n      public void run() {\n        Reader stream = null;\n        try {\n          stream = getReaderByUrl(url, ProgressManager.getInstance().getProgressIndicator());\n        }\n        catch (IOException e) {\n          ex[0] = e;\n        }\n        if (stream == null) {\n          fail[0] = true;\n          return;\n        }\n        try {\n          BufferedReader reader = null;\n          try {\n            reader = new BufferedReader(stream);\n            int lookUp = 6;\n\n            while (lookUp > 0) {\n              if (reader.readLine().indexOf(DOC_START_MARKER) != -1) {\n                waiter.sayYes();\n              }\n\n              lookUp--;\n            }\n          }\n          finally {\n            if (reader != null) {\n              reader.close();\n            }\n          }\n\n\n        }\n        catch (final Exception e) {\n          ex[0] = e;\n        }\n      }\n    }).start();\n\n    if (ex[0] != null) {\n      throw ex[0];\n    }\n    return !fail[0] && waiter.runMe();\n  }","commit_id":"1da5781833fea90964ea7ecb6ab1de990bc06a90","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  @SuppressWarnings({\"HardCodedStringLiteral\"})\n  public String getExternalDocInfo(final String surl) {\n    if (surl == null) {\n      return null;\n    }\n\n    final String root = ourAnchorsuffix.matcher(surl).replaceAll(\"\");\n\n    final StringBuffer data = new StringBuffer();\n\n    final Runnable process = new Runnable() {\n\n      public void run() {\n\n        final Reader stream = getReaderByUrl(surl);\n\n        if (stream == null) {\n            return;\n        }\n\n        Matcher anchorMatcher = ourAnchorsuffix.matcher(surl);\n        @NonNls String startSection = \"<!-- ======== START OF CLASS DATA ======== -->\";\n        @NonNls String endSection = \"SUMMARY ======== -->\";\n        boolean isClassDoc = true;\n\n        if (anchorMatcher.find()) {\n          isClassDoc = false;\n          startSection = \"<A NAME=\\\"\" + anchorMatcher.group(1).toUpperCase() + \"\\\"\";\n          endSection = \"<A NAME=\";\n        }\n\n        final BufferedReader buf = new BufferedReader(stream);\n\n        data.append(HTML + \"\\n\");\n        try {\n          String read;\n\n          do {\n            ProgressManager.getInstance().checkCanceled();\n            read = buf.readLine();\n          }\n          while (read != null && read.toUpperCase().indexOf(startSection) == -1);\n\n\n          if (read == null) {\n            data.delete(0, data.length());\n            return;\n          }\n\n          data.append(read);\n\n          if (isClassDoc) {\n            boolean skip = false;\n\n            while (((read = buf.readLine()) != null) && !read.toUpperCase().equals(DL)) {\n              ProgressManager.getInstance().checkCanceled();\n              if (read.toUpperCase().indexOf(H2) != -1) { // read=class name in <H2>\n                data.append(H2 + \"\\n\");\n                skip = true;\n              }\n              else if (!skip) data.append(read); //correctRefs(root, read));\n            }\n\n            data.append(DL + \"\\n\");\n\n            StringBuffer classDetails = new StringBuffer();\n\n            while (((read = buf.readLine()) != null) && !read.toUpperCase().equals(HR)) {\n              ProgressManager.getInstance().checkCanceled();\n              classDetails.append(read); //correctRefs(root, read));\n              classDetails.append(\"\\n\");\n            }\n\n            while (((read = buf.readLine()) != null) && !read.toUpperCase().equals(P)) {\n              ProgressManager.getInstance().checkCanceled();\n              data.append(read); //correctRefs(root, read));\n              data.append(\"\\n\");\n            }\n\n            data.append(classDetails);\n            data.append(P + \"\\n\");\n          }\n\n          while (((read = buf.readLine()) != null) && read.indexOf(endSection) == -1) {\n            ProgressManager.getInstance().checkCanceled();\n            if (read.toUpperCase().indexOf(HR) == -1) {\n              data.append(read); //correctRefs(root, read));\n              data.append(\"\\n\");\n            }\n          }\n\n          data.append(HTML_CLOSE + \"\\n\");\n\n        }\n        catch (final IOException e) {\n          showErrorMessage(e);\n        }\n        finally {\n          if (buf != null) {\n            try {\n              buf.close();\n            }\n            catch (IOException e) {\n              showErrorMessage(e);\n            }\n          }\n        }\n      }\n    };\n\n    final boolean ok = ProgressManager.getInstance().runProcessWithProgressSynchronously(process, \"Fetch external javadoc\", true, myProject);\n    if (ok) {\n      final String docText = correctRefs(root, data.toString());\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Filtered JavaDoc: \" + docText + \"\\n\");\n      }\n      return JavaDocUtil.fixupText(docText);\n    }\n    return null;\n  }","id":65233,"modified_method":"@Nullable\n  @SuppressWarnings({\"HardCodedStringLiteral\"})\n  public String getExternalDocInfo(final String surl) throws Exception {\n    if (surl == null) return null;    \n    if (MyJavadocFetcher.isFree()) {\n      final MyJavadocFetcher fetcher = new MyJavadocFetcher(surl);\n      fetcher.start();\n      try {\n        fetcher.join();\n      }\n      catch (InterruptedException e) {\n        return null;\n      }\n      final Exception exception = fetcher.getException();\n      if (exception != null) {\n        fetcher.cleanup();\n        throw exception;\n      }\n\n      final String docText = correctRefs(ourAnchorsuffix.matcher(surl).replaceAll(\"\"), fetcher.getData());\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Filtered JavaDoc: \" + docText + \"\\n\");\n      }\n      return JavaDocUtil.fixupText(docText);\n    }\n    return null;\n  }","commit_id":"1da5781833fea90964ea7ecb6ab1de990bc06a90","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public JavaDocProvider getDefaultProvider(final PsiElement _element) {\n    return new JavaDocProvider() {\n      private SmartPsiElementPointer element = SmartPointerManager.getInstance(_element.getProject()).createSmartPsiElementPointer(_element);\n\n      public String getJavaDoc() {\n        return getDocInfo(element.getElement());\n      }\n\n      public PsiElement getElement() {\n        return element.getElement();\n      }\n    };\n  }","id":65234,"modified_method":"public JavaDocProvider getDefaultProvider(final PsiElement _element) {\n    return new JavaDocProvider() {\n      private SmartPsiElementPointer element = SmartPointerManager.getInstance(_element.getProject()).createSmartPsiElementPointer(_element);\n\n      public String getJavaDoc() throws Exception {\n        return getDocInfo(element.getElement());\n      }\n\n      public PsiElement getElement() {\n        return element.getElement();\n      }\n    };\n  }","commit_id":"1da5781833fea90964ea7ecb6ab1de990bc06a90","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getDocInfo(PsiElement element) {\n    if (element instanceof PsiMethodCallExpression) {\n      return getMethodCandidateInfo(((PsiMethodCallExpression)element));\n    }\n    else {\n      final DocumentationProvider provider = getProviderFromElement(element);\n      final JavaDocInfoGenerator javaDocInfoGenerator =\n        new JavaDocInfoGenerator(myProject, element, provider);\n\n      if (myParameterInfoController != null) {\n        final Object[] objects = myParameterInfoController.getSelectedElements();\n\n        if (objects.length > 0) {\n          @NonNls StringBuffer sb = null;\n\n          for(Object o:objects) {\n            PsiElement parameter = getPsiElementFromParameterInfoObject(o, null);\n\n            if (parameter != null) {\n              if (sb == null) sb = new StringBuffer();\n              final String str2 = new JavaDocInfoGenerator(myProject, parameter, provider).generateDocInfo();\n              sb.append(str2);\n              sb.append(\"<br>\");\n            } else {\n              sb = null;\n              break;\n            }\n          }\n\n          if (sb != null) return sb.toString();\n        }\n      }\n\n      JavaDocExternalFilter docFilter = new JavaDocExternalFilter(myProject);\n      String docURL = getExternalJavaDocUrl(element);\n\n      if (element instanceof PsiCompiledElement) {\n        String externalDoc = docFilter.getExternalDocInfoForElement(docURL, element);\n        if (externalDoc != null) {\n          return externalDoc;\n        }\n      }\n\n      return docFilter.filterInternalDocInfo(\n        javaDocInfoGenerator.generateDocInfo(),\n        docURL);\n    }\n  }","id":65235,"modified_method":"private String getDocInfo(PsiElement element) throws Exception {\n    if (element instanceof PsiMethodCallExpression) {\n      return getMethodCandidateInfo(((PsiMethodCallExpression)element));\n    }\n    else {\n      final DocumentationProvider provider = getProviderFromElement(element);\n      final JavaDocInfoGenerator javaDocInfoGenerator =\n        new JavaDocInfoGenerator(myProject, element, provider);\n\n      if (myParameterInfoController != null) {\n        final Object[] objects = myParameterInfoController.getSelectedElements();\n\n        if (objects.length > 0) {\n          @NonNls StringBuffer sb = null;\n\n          for(Object o:objects) {\n            PsiElement parameter = getPsiElementFromParameterInfoObject(o, null);\n\n            if (parameter != null) {\n              if (sb == null) sb = new StringBuffer();\n              final String str2 = new JavaDocInfoGenerator(myProject, parameter, provider).generateDocInfo();\n              sb.append(str2);\n              sb.append(\"<br>\");\n            } else {\n              sb = null;\n              break;\n            }\n          }\n\n          if (sb != null) return sb.toString();\n        }\n      }\n\n      JavaDocExternalFilter docFilter = new JavaDocExternalFilter(myProject);\n      String docURL = getExternalJavaDocUrl(element);\n\n      if (element instanceof PsiCompiledElement) {\n        String externalDoc = docFilter.getExternalDocInfoForElement(docURL, element);\n        if (externalDoc != null) {\n          return externalDoc;\n        }\n      }\n\n      return docFilter.filterInternalDocInfo(\n        javaDocInfoGenerator.generateDocInfo(),\n        docURL);\n    }\n  }","commit_id":"1da5781833fea90964ea7ecb6ab1de990bc06a90","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void initComponent() { }","id":65236,"modified_method":"public void initComponent() {\n    myActionManagerEx.addAnActionListener(myActionListener);\n  }","commit_id":"1da5781833fea90964ea7ecb6ab1de990bc06a90","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public JavaDocManager(Project project) {\n    myProject = project;\n\n    registerDocumentationProvider(StdFileTypes.HTML, new HtmlDocumentationProvider(project));\n    registerDocumentationProvider(StdFileTypes.XHTML, new XHtmlDocumentationProvider(project));\n    final JspImplUtil.JspDocumentationProvider provider = new JspImplUtil.JspDocumentationProvider(project);\n    registerDocumentationProvider(StdFileTypes.JSP,provider);\n    registerDocumentationProvider(StdFileTypes.JSPX, provider);\n\n    registerDocumentationProvider(StdFileTypes.XML, new XmlDocumentationProvider());\n  }","id":65237,"modified_method":"public JavaDocManager(Project project, ActionManagerEx managerEx) {\n    myProject = project;\n    myActionManagerEx = managerEx;\n\n    registerDocumentationProvider(StdFileTypes.HTML, new HtmlDocumentationProvider(project));\n    registerDocumentationProvider(StdFileTypes.XHTML, new XHtmlDocumentationProvider(project));\n    final JspImplUtil.JspDocumentationProvider provider = new JspImplUtil.JspDocumentationProvider(project);\n    registerDocumentationProvider(StdFileTypes.JSP,provider);\n    registerDocumentationProvider(StdFileTypes.JSPX, provider);\n\n    registerDocumentationProvider(StdFileTypes.XML, new XmlDocumentationProvider());\n  }","commit_id":"1da5781833fea90964ea7ecb6ab1de990bc06a90","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void navigateByLink(final JavaDocInfoComponent component, String url) {\n    component.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n    final PsiManager manager = PsiManager.getInstance(myProject);\n    if (url.startsWith(PSI_ELEMENT_PROTOCOL)) {\n      final String refText = url.substring(PSI_ELEMENT_PROTOCOL.length());\n      final PsiElement targetElement = JavaDocUtil.findReferenceTarget(manager, refText, component.getElement());\n      if (targetElement != null) {\n        fetchDocInfo(getDefaultProvider(targetElement), component);\n      }\n    }\n    else {\n      final String docUrl = url;\n\n      fetchDocInfo\n        (new JavaDocProvider() {\n          String getElementLocator(String url) {\n            if (url.startsWith(DOC_ELEMENT_PROTOCOL)) {\n              return url.substring(DOC_ELEMENT_PROTOCOL.length());\n            }\n            return null;\n          }\n\n          public String getJavaDoc() {\n            String url = getElementLocator(docUrl);\n            if (url != null && JavaDocExternalFilter.isJavaDocURL(url)) {\n              String text = new JavaDocExternalFilter(myProject).getExternalDocInfo(url);\n\n              if (text != null) {\n                return text;\n              }\n            }\n\n            if (url == null) {\n              url = docUrl;\n            }\n\n            PsiElement element = component.getElement();\n            if (element != null) {\n              PsiElement parent = element;\n              while (true) {\n                if (parent == null || parent instanceof PsiDirectory) break;\n                parent = parent.getParent();\n              }\n              if (parent != null) {\n                PsiPackage aPackage = ((PsiDirectory)parent).getPackage();\n                if (aPackage != null) {\n                  String url1 = findUrlForLink(aPackage, url);\n                  if (url1 != null) {\n                    url = url1;\n                  }\n                }\n              }\n            }\n\n            BrowserUtil.launchBrowser(url);\n\n            return \"\";\n          }\n\n          public PsiElement getElement() {\n            //String loc = getElementLocator(docUrl);\n            //\n            //if (loc != null) {\n            //  PsiElement context = component.getElement();\n            //  return JavaDocUtil.findReferenceTarget(context.getManager(), loc, context);\n            //}\n\n            return component.getElement();\n          }\n        }, component);\n    }\n\n    component.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));\n  }","id":65238,"modified_method":"void navigateByLink(final JavaDocInfoComponent component, String url) {\n    component.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n    final PsiManager manager = PsiManager.getInstance(myProject);\n    if (url.startsWith(PSI_ELEMENT_PROTOCOL)) {\n      final String refText = url.substring(PSI_ELEMENT_PROTOCOL.length());\n      final PsiElement targetElement = JavaDocUtil.findReferenceTarget(manager, refText, component.getElement());\n      if (targetElement != null) {\n        fetchDocInfo(getDefaultProvider(targetElement), component);\n      }\n    }\n    else {\n      final String docUrl = url;\n\n      fetchDocInfo\n        (new JavaDocProvider() {\n          String getElementLocator(String url) {\n            if (url.startsWith(DOC_ELEMENT_PROTOCOL)) {\n              return url.substring(DOC_ELEMENT_PROTOCOL.length());\n            }\n            return null;\n          }\n\n          public String getJavaDoc() throws Exception {\n            String url = getElementLocator(docUrl);\n            if (url != null && JavaDocExternalFilter.isJavaDocURL(url)) {\n              String text = new JavaDocExternalFilter(myProject).getExternalDocInfo(url);\n\n              if (text != null) {\n                return text;\n              }\n            }\n\n            if (url == null) {\n              url = docUrl;\n            }\n\n            PsiElement element = component.getElement();\n            if (element != null) {\n              PsiElement parent = element;\n              while (true) {\n                if (parent == null || parent instanceof PsiDirectory) break;\n                parent = parent.getParent();\n              }\n              if (parent != null) {\n                PsiPackage aPackage = ((PsiDirectory)parent).getPackage();\n                if (aPackage != null) {\n                  String url1 = findUrlForLink(aPackage, url);\n                  if (url1 != null) {\n                    url = url1;\n                  }\n                }\n              }\n            }\n\n            BrowserUtil.launchBrowser(url);\n\n            return \"\";\n          }\n\n          public PsiElement getElement() {\n            //String loc = getElementLocator(docUrl);\n            //\n            //if (loc != null) {\n            //  PsiElement context = component.getElement();\n            //  return JavaDocUtil.findReferenceTarget(context.getManager(), loc, context);\n            //}\n\n            return component.getElement();\n          }\n        }, component);\n    }\n\n    component.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));\n  }","commit_id":"1da5781833fea90964ea7ecb6ab1de990bc06a90","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doFetchDocInfo(final JavaDocInfoComponent component, final JavaDocProvider provider, final boolean cancelRequests) {\n    component.startWait();\n    if (cancelRequests) {\n      myUpdateDocAlarm.cancelAllRequests();\n    }\n    myUpdateDocAlarm.addRequest(new Runnable() {\n      public void run() {\n        SwingUtilities.invokeLater(new Runnable() {\n          public void run() {\n            if (component.isEmpty()) {\n              component.setText(CodeInsightBundle.message(\"javadoc.fetching.progress\"));\n            }\n          }\n        });\n      }\n    }, 600);\n    myUpdateDocAlarm.addRequest(new Runnable() {\n      public void run() {\n        ApplicationManager.getApplication().runReadAction(new Runnable() {\n          public void run() {\n            final String text = provider.getJavaDoc();\n            if (text == null) {\n              component.setText(CodeInsightBundle.message(\"no.documentation.found\"), true);\n            }\n            else if (text.length() == 0) {\n              component.setText(component.getText(), true);\n            }\n            else {\n              component.setData(provider.getElement(), text);\n            }\n          }\n        });\n      }\n    }, 10);\n  }","id":65239,"modified_method":"private void doFetchDocInfo(final JavaDocInfoComponent component, final JavaDocProvider provider, final boolean cancelRequests) {\n    component.startWait();\n    if (cancelRequests) {\n      myUpdateDocAlarm.cancelAllRequests();\n    }\n    SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        if (component.isEmpty()) {\n          component.setText(CodeInsightBundle.message(\"javadoc.fetching.progress\"));\n        }\n      }\n    });\n    myUpdateDocAlarm.addRequest(new Runnable() {\n      public void run() {\n        ApplicationManager.getApplication().runReadAction(new Runnable() {\n          public void run() {\n            final String text;\n            try {\n              text = provider.getJavaDoc();\n            }\n            catch (final Exception e) {\n              SwingUtilities.invokeLater(new Runnable(){\n                public void run() {\n                  component.setText(CodeInsightBundle.message(\"javadoc.external.fetch.error.message\", e.getLocalizedMessage()), true);\n                }\n              });\n              return;\n            }\n            SwingUtilities.invokeLater(new Runnable() {\n              public void run() {\n                if (text == null) {\n                  component.setText(CodeInsightBundle.message(\"no.documentation.found\"), true);\n                }\n                else if (text.length() == 0) {\n                  component.setText(component.getText(), true);\n                }\n                else {\n                  component.setData(provider.getElement(), text);\n                }\n\n                final Dimension dimension = component.getPreferredSize();\n                final Window window = SwingUtilities.getWindowAncestor(component);\n                if (window != null) {\n                  window.setBounds(window.getX(),\n                                   window.getY(),\n                                   dimension.width,\n                                   dimension.height);\n                  window.validate();\n                  window.repaint();\n                }\n              }\n            });\n          }\n        });\n      }\n    }, 10);\n  }","commit_id":"1da5781833fea90964ea7ecb6ab1de990bc06a90","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void disposeComponent() {\n  }","id":65240,"modified_method":"public void disposeComponent() {\n    myActionManagerEx.removeAnActionListener(myActionListener);\n  }","commit_id":"1da5781833fea90964ea7ecb6ab1de990bc06a90","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doSave() throws WriteExternalException {\n    Collection<T> schemes = getAllSchemes();\n    myBaseDir.mkdirs();\n\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      public void run() {\n        ((NewVirtualFile)myVFSBaseDir).markDirtyRecursively();\n        myVFSBaseDir.refresh(false, true);\n      }\n    });\n\n\n    UniqueFileNamesProvider fileNameProvider = new UniqueFileNamesProvider();\n\n    reserveUsingFileNames(schemes, fileNameProvider);\n\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      public void run() {\n        deleteFilesFromDeletedSchemes();\n      }\n    });\n\n\n    saveSchemes(schemes, fileNameProvider);\n\n    if (myDeletedNames.size() > 0) {\n      for (StreamProvider provider : getEnabledProviders()) {\n        try {\n          provider.saveContent(getFileFullPath(DELETED_XML), createDeletedDocument(), myRoamingType);\n        }\n        catch (IOException e) {\n          LOG.debug(e);\n        }\n      }\n    }\n    else {\n      for (StreamProvider provider : getEnabledProviders()) {\n        provider.deleteFile(getFileFullPath(DELETED_XML), myRoamingType);\n      }\n\n    }\n  }","id":65241,"modified_method":"private void doSave() throws WriteExternalException {\n\n    myInsideSave = true;\n    try {\n      ApplicationManager.getApplication().runWriteAction(new Runnable() {\n        public void run() {\n          ((NewVirtualFile)myVFSBaseDir).markDirtyRecursively();\n          myVFSBaseDir.refresh(false, true);\n        }\n      });\n\n      Collection<T> schemes = getAllSchemes();\n      myBaseDir.mkdirs();\n\n      UniqueFileNamesProvider fileNameProvider = new UniqueFileNamesProvider();\n\n      reserveUsingFileNames(schemes, fileNameProvider);\n\n      ApplicationManager.getApplication().runWriteAction(new Runnable() {\n        public void run() {\n          deleteFilesFromDeletedSchemes();\n        }\n      });\n\n\n      saveSchemes(schemes, fileNameProvider);\n\n      if (myDeletedNames.size() > 0) {\n        for (StreamProvider provider : getEnabledProviders()) {\n          try {\n            provider.saveContent(getFileFullPath(DELETED_XML), createDeletedDocument(), myRoamingType);\n          }\n          catch (IOException e) {\n            LOG.debug(e);\n          }\n        }\n      }\n      else {\n        for (StreamProvider provider : getEnabledProviders()) {\n          provider.deleteFile(getFileFullPath(DELETED_XML), myRoamingType);\n        }\n\n      }\n    }\n    finally {\n      myInsideSave = false;\n    }\n  }","commit_id":"abd29cee03892ac0fd14b3e76686772ee7d2d642","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void onFileContentChanged(final VirtualFileEvent event, final VirtualFile baseDirFile) {\n    VirtualFile file = event.getFile();\n\n    if (event.getRequestor() == null && isFileUnder(file, baseDirFile)) {\n      File ioFile = new File(file.getPath());\n      E scheme = findSchemeFor(ioFile.getName());\n      ArrayList<E> read = new ArrayList<E>();\n      T oldCurrentScheme = null;\n      if (scheme != null) {\n        oldCurrentScheme = getCurrentScheme();\n        removeScheme((T)scheme);\n        myProcessor.onSchemeDeleted(scheme);\n      }\n\n      readSchemeFromFile(read, file, true);\n      if (!read.isEmpty()) {\n        E readScheme = read.get(0);\n        myProcessor.initScheme(readScheme);\n\n        myProcessor.onSchemeAdded(readScheme);\n\n        T newCurrentScheme = getCurrentScheme();\n\n        if (oldCurrentScheme != null && newCurrentScheme == null) {\n          setCurrentSchemeName(readScheme.getName());\n          newCurrentScheme = getCurrentScheme();\n        }\n\n        if (oldCurrentScheme != newCurrentScheme) {\n          myProcessor.onCurrentSchemeChanged(oldCurrentScheme);\n        }\n      }\n    }\n  }","id":65242,"modified_method":"private void onFileContentChanged(final VirtualFileEvent event, final VirtualFile baseDirFile) {\n    VirtualFile file = event.getFile();\n\n    if (event.getRequestor() == null && isFileUnder(file, baseDirFile) && !myInsideSave) {\n      File ioFile = new File(file.getPath());\n      E scheme = findSchemeFor(ioFile.getName());\n      ArrayList<E> read = new ArrayList<E>();\n      T oldCurrentScheme = null;\n      if (scheme != null) {\n        oldCurrentScheme = getCurrentScheme();\n        removeScheme((T)scheme);\n        myProcessor.onSchemeDeleted(scheme);\n      }\n\n      readSchemeFromFile(read, file, true);\n      if (!read.isEmpty()) {\n        E readScheme = read.get(0);\n        myProcessor.initScheme(readScheme);\n\n        myProcessor.onSchemeAdded(readScheme);\n\n        T newCurrentScheme = getCurrentScheme();\n\n        if (oldCurrentScheme != null && newCurrentScheme == null) {\n          setCurrentSchemeName(readScheme.getName());\n          newCurrentScheme = getCurrentScheme();\n        }\n\n        if (oldCurrentScheme != newCurrentScheme) {\n          myProcessor.onCurrentSchemeChanged(oldCurrentScheme);\n        }\n      }\n    }\n  }","commit_id":"abd29cee03892ac0fd14b3e76686772ee7d2d642","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addVFSListener() {\n    if (ApplicationManager.getApplication() == null || myListenerAdded) return;\n\n    LocalFileSystem system = LocalFileSystem.getInstance();\n    myVFSBaseDir = new WriteAction<VirtualFile>() {\n      protected void run(final Result<VirtualFile> result) {\n        VirtualFile dir = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(myBaseDir);\n        result.setResult(dir);\n        if (dir != null) {\n          ((NewVirtualFile)dir).markDirtyRecursively();\n          dir.refresh(false, false);\n        }\n      }\n    }.execute().getResultObject();\n\n\n    myVFSBaseDir.getChildren();\n\n    system.addVirtualFileListener(new VirtualFileAdapter() {\n      @Override\n      public void contentsChanged(final VirtualFileEvent event) {\n        onFileContentChanged(event, myVFSBaseDir);\n      }\n\n      @Override\n      public void fileCreated(final VirtualFileEvent event) {\n        VirtualFile file = event.getFile();\n\n        if (event.getRequestor() == null && isFileUnder(file, myVFSBaseDir)) {\n          ArrayList<E> read = new ArrayList<E>();\n          readSchemeFromFile(read, file, true);\n          if (!read.isEmpty()) {\n            E readScheme = read.get(0);\n            myProcessor.initScheme(readScheme);\n            myProcessor.onSchemeAdded(readScheme);\n          }\n        }\n\n      }\n\n      @Override\n      public void fileDeleted(final VirtualFileEvent event) {\n        VirtualFile parent = event.getParent();\n\n        if (event.getRequestor() == null && parent != null && parent.equals(myVFSBaseDir)) {\n          File ioFile = new File(event.getFileName());\n          E scheme = findSchemeFor(ioFile.getName());\n          T oldCurrentScheme = null;\n          if (scheme != null) {\n            oldCurrentScheme = getCurrentScheme();\n            //noinspection unchecked\n            removeScheme((T)scheme);\n            myProcessor.onSchemeDeleted(scheme);\n          }\n\n          T newCurrentScheme = getCurrentScheme();\n\n          if (oldCurrentScheme != null && newCurrentScheme == null) {\n            if (!mySchemes.isEmpty()) {\n              setCurrentSchemeName(mySchemes.get(0).getName());\n              newCurrentScheme = getCurrentScheme();\n            }\n          }\n\n          if (oldCurrentScheme != newCurrentScheme) {\n            myProcessor.onCurrentSchemeChanged(oldCurrentScheme);\n          }\n\n        }\n\n      }\n\n    });\n\n    myListenerAdded = true;\n  }","id":65243,"modified_method":"private void addVFSListener() {\n    if (ApplicationManager.getApplication() == null || myListenerAdded) return;\n\n    LocalFileSystem system = LocalFileSystem.getInstance();\n    myVFSBaseDir = new WriteAction<VirtualFile>() {\n      protected void run(final Result<VirtualFile> result) {\n        VirtualFile dir = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(myBaseDir);\n        result.setResult(dir);\n        if (dir != null) {\n          dir.getChildren();\n          ((NewVirtualFile)dir).markDirtyRecursively();\n          dir.refresh(false, true);\n        }\n      }\n    }.execute().getResultObject();\n\n\n\n\n    system.addVirtualFileListener(new VirtualFileAdapter() {\n      @Override\n      public void contentsChanged(final VirtualFileEvent event) {\n        onFileContentChanged(event, myVFSBaseDir);\n      }\n\n      @Override\n      public void fileCreated(final VirtualFileEvent event) {\n        VirtualFile file = event.getFile();\n\n        if (event.getRequestor() == null && isFileUnder(file, myVFSBaseDir) && !myInsideSave) {\n          ArrayList<E> read = new ArrayList<E>();\n          readSchemeFromFile(read, file, true);\n          if (!read.isEmpty()) {\n            E readScheme = read.get(0);\n            myProcessor.initScheme(readScheme);\n            myProcessor.onSchemeAdded(readScheme);\n          }\n        }\n\n      }\n\n      @Override\n      public void fileDeleted(final VirtualFileEvent event) {\n        VirtualFile parent = event.getParent();\n\n        if (event.getRequestor() == null && parent != null && parent.equals(myVFSBaseDir) && !myInsideSave) {\n          File ioFile = new File(event.getFileName());\n          E scheme = findSchemeFor(ioFile.getName());\n          T oldCurrentScheme = null;\n          if (scheme != null) {\n            oldCurrentScheme = getCurrentScheme();\n            //noinspection unchecked\n            removeScheme((T)scheme);\n            myProcessor.onSchemeDeleted(scheme);\n          }\n\n          T newCurrentScheme = getCurrentScheme();\n\n          if (oldCurrentScheme != null && newCurrentScheme == null) {\n            if (!mySchemes.isEmpty()) {\n              setCurrentSchemeName(mySchemes.get(0).getName());\n              newCurrentScheme = getCurrentScheme();\n            }\n          }\n\n          if (oldCurrentScheme != newCurrentScheme) {\n            myProcessor.onCurrentSchemeChanged(oldCurrentScheme);\n          }\n\n        }\n\n      }\n\n    });\n\n    myListenerAdded = true;\n  }","commit_id":"abd29cee03892ac0fd14b3e76686772ee7d2d642","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void reset() {\n    TemplateSettings templateSettings = TemplateSettings.getInstance();\n    List<TemplateGroup> groups = new ArrayList<TemplateGroup>(templateSettings.getTemplateGroups());\n\n    Collections.sort(groups, new Comparator<TemplateGroup>(){\n      public int compare(final TemplateGroup o1, final TemplateGroup o2) {\n        return o1.getName().compareTo(o2.getName());\n      }\n    });\n\n    initTemplates(groups, templateSettings.getLastSelectedTemplateKey());\n\n    if (templateSettings.getDefaultShortcutChar() == TemplateSettings.TAB_CHAR) {\n      myExpandByCombo.setSelectedItem(TAB);\n    }\n    else if (templateSettings.getDefaultShortcutChar() == TemplateSettings.ENTER_CHAR) {\n      myExpandByCombo.setSelectedItem(ENTER);\n    }\n    else {\n      myExpandByCombo.setSelectedItem(SPACE);\n    }\n    isModified = false;\n    myUpdateNeeded = true;\n  }","id":65244,"modified_method":"public void reset() {\n    TemplateSettings templateSettings = TemplateSettings.getInstance();\n    List<TemplateGroup> groups = new ArrayList<TemplateGroup>(templateSettings.getTemplateGroups());\n\n    Collections.sort(groups, new Comparator<TemplateGroup>(){\n      public int compare(final TemplateGroup o1, final TemplateGroup o2) {\n        return o1.getName().compareTo(o2.getName());\n      }\n    });\n\n    initTemplates(groups, templateSettings.getLastSelectedTemplateKey());\n\n\n\n    if (templateSettings.getDefaultShortcutChar() == TemplateSettings.TAB_CHAR) {\n      myExpandByCombo.setSelectedItem(TAB);\n    }\n    else if (templateSettings.getDefaultShortcutChar() == TemplateSettings.ENTER_CHAR) {\n      myExpandByCombo.setSelectedItem(ENTER);\n    }\n    else {\n      myExpandByCombo.setSelectedItem(SPACE);\n    }\n\n    updateTemplateText();\n\n    isModified = false;\n    myUpdateNeeded = true;\n\n\n  }","commit_id":"abd29cee03892ac0fd14b3e76686772ee7d2d642","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateTemplateTextArea() {\n    if (!myUpdateNeeded) return;\n\n    myAlarm.cancelAllRequests();\n    myAlarm.addRequest(new Runnable() {\n      public void run() {\n        ApplicationManager.getApplication().runWriteAction(new Runnable() {\n          public void run() {\n            int selected = getSelectedIndex();\n            if (selected < 0) {\n              myEditor.getDocument().replaceString(0, myEditor.getDocument().getTextLength(), \"\");\n            }\n            else {\n              TemplateImpl template = getTemplate(selected);\n              if (template != null) {\n                String text = template.getString();\n                myEditor.getDocument().replaceString(0, myEditor.getDocument().getTextLength(), text);\n                TemplateEditorUtil.setHighlighter(myEditor, template.getTemplateContext());\n              } else {\n                myEditor.getDocument().replaceString(0, myEditor.getDocument().getTextLength(), \"\");\n              }\n            }\n          }\n        });\n      }\n    }, 100);\n  }","id":65245,"modified_method":"private void updateTemplateTextArea() {\n    if (!myUpdateNeeded) return;\n\n    myAlarm.cancelAllRequests();\n    myAlarm.addRequest(new Runnable() {\n      public void run() {\n        updateTemplateText();\n      }\n    }, 100);\n  }","commit_id":"abd29cee03892ac0fd14b3e76686772ee7d2d642","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void updateCircularDependencyWarning() {\n    myUpdateWarningAlarm.cancelAllRequests();\n    myUpdateWarningAlarm.addRequest(new Runnable() {\n      public void run() {\n        final Graph<Chunk<ModifiableRootModel>> graph = ModuleCompilerUtil.toChunkGraph(myModulesConfigurator.createGraphGenerator());\n        final Collection<Chunk<ModifiableRootModel>> chunks = graph.getNodes();\n        String cycles = \"\";\n        int count = 0;\n        for (Chunk<ModifiableRootModel> chunk : chunks) {\n          final Set<ModifiableRootModel> modules = chunk.getNodes();\n          String cycle = \"\";\n          for (ModifiableRootModel model : modules) {\n            cycle += \", \" + model.getModule().getName();\n          }\n          if (modules.size() > 1) {\n            @NonNls final String br = \"<br>&nbsp;&nbsp;&nbsp;&nbsp;\";\n            cycles += br + (++count) + \". \" + cycle.substring(2);            \n          }\n        }\n        @NonNls final String leftBrace = \"<html>\";\n        @NonNls final String rightBrace = \"<\/html>\";\n        final String warningMessage =\n          leftBrace + (count > 0 ? ProjectBundle.message(\"module.circular.dependency.warning\", cycles, count) : \"\") + rightBrace;\n        final int count1=count;\n        SwingUtilities.invokeLater(new Runnable() {\n          public void run() {\n            myWarningLabel.setIcon(count1 > 0 ? Messages.getWarningIcon() : null);\n            myWarningLabel.setText(warningMessage);\n            myWarningLabel.repaint();}\n          }\n        );\n      }\n    }, 300);\n  }","id":65246,"modified_method":"void updateCircularDependencyWarning() {\n    myUpdateWarningAlarm.cancelAllRequests();\n    myUpdateWarningAlarm.addRequest(new Runnable() {\n      public void run() {\n        ApplicationManager.getApplication().runReadAction(new Runnable(){\n          public void run() {\n            final Graph<Chunk<ModifiableRootModel>> graph = ModuleCompilerUtil.toChunkGraph(myModulesConfigurator.createGraphGenerator());\n            final Collection<Chunk<ModifiableRootModel>> chunks = graph.getNodes();\n            String cycles = \"\";\n            int count = 0;\n            for (Chunk<ModifiableRootModel> chunk : chunks) {\n              final Set<ModifiableRootModel> modules = chunk.getNodes();\n              String cycle = \"\";\n              for (ModifiableRootModel model : modules) {\n                cycle += \", \" + model.getModule().getName();\n              }\n              if (modules.size() > 1) {\n                @NonNls final String br = \"<br>&nbsp;&nbsp;&nbsp;&nbsp;\";\n                cycles += br + (++count) + \". \" + cycle.substring(2);\n              }\n            }\n            @NonNls final String leftBrace = \"<html>\";\n            @NonNls final String rightBrace = \"<\/html>\";\n            final String warningMessage =\n              leftBrace + (count > 0 ? ProjectBundle.message(\"module.circular.dependency.warning\", cycles, count) : \"\") + rightBrace;\n            final int count1=count;\n            SwingUtilities.invokeLater(new Runnable() {\n              public void run() {\n                myWarningLabel.setIcon(count1 > 0 ? Messages.getWarningIcon() : null);\n                myWarningLabel.setText(warningMessage);\n                myWarningLabel.repaint();}\n              }\n            );\n          }\n        });\n      }\n    }, 300);\n  }","commit_id":"6fdb4b605af99fe031a55059da57e417401d0ca7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void disposeUIResources() {\n    if (myProjectJdkConfigurable != null) {\n      myProjectJdkConfigurable.disposeUIResources();\n    }\n  }","id":65247,"modified_method":"public void disposeUIResources() {\n    myUpdateWarningAlarm.cancelAllRequests();\n    if (myProjectJdkConfigurable != null) {\n      myProjectJdkConfigurable.disposeUIResources();\n    }\n  }","commit_id":"6fdb4b605af99fe031a55059da57e417401d0ca7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void init(final ProjectJdksModel model) {\n    myPanel = new ProjectConfigurable.MyJPanel();\n    myPanel.setPreferredSize(new Dimension(700, 500));\n\n    myRbRelativePaths.setText(ProjectBundle.message(\"module.paths.outside.module.dir.relative.radio\"));\n    myRbAbsolutePaths.setText(ProjectBundle.message(\"module.paths.outside.module.dir.absolute.radio\"));\n\n    if (((ProjectEx)myProject).isSavePathsRelative()) {\n      myRbRelativePaths.setSelected(true);\n    }\n    else {\n      myRbAbsolutePaths.setSelected(true);\n    }\n\n    myProjectJdkConfigurable = new ProjectJdkConfigurable(myProject, model);\n    myPanel.add(myProjectJdkConfigurable.createComponent(), new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 1, 0.0, 0.0,\n                                                                                   GridBagConstraints.WEST, GridBagConstraints.HORIZONTAL,\n                                                                                   new Insets(4, 4, 0, 0), 0, 0));\n\n    myPanel.add(myWholePanel, new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 1, 1.0, 1.0, GridBagConstraints.NORTHWEST,\n                                                     GridBagConstraints.NONE, new Insets(4, 0, 0, 0), 0, 0));\n\n    //myWarningLabel.setUI(new MultiLineLabelUI());\n    myPanel.add(myWarningLabel, new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 1, 0.0, 0.0, GridBagConstraints.NORTHWEST,\n                                                       GridBagConstraints.BOTH, new Insets(10, 6, 10, 0), 0, 0));\n  }","id":65248,"modified_method":"private void init(final ProjectJdksModel model) {\n    myPanel = new MyJPanel();\n    myPanel.setPreferredSize(new Dimension(700, 500));\n\n    myRbRelativePaths.setText(ProjectBundle.message(\"module.paths.outside.module.dir.relative.radio\"));\n    myRbAbsolutePaths.setText(ProjectBundle.message(\"module.paths.outside.module.dir.absolute.radio\"));\n\n    if (((ProjectEx)myProject).isSavePathsRelative()) {\n      myRbRelativePaths.setSelected(true);\n    }\n    else {\n      myRbAbsolutePaths.setSelected(true);\n    }\n\n    myProjectJdkConfigurable = new ProjectJdkConfigurable(myProject, model);\n    myPanel.add(myProjectJdkConfigurable.createComponent(), new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 1, 0.0, 0.0,\n                                                                                   GridBagConstraints.WEST, GridBagConstraints.HORIZONTAL,\n                                                                                   new Insets(4, 4, 0, 0), 0, 0));\n\n    myPanel.add(myWholePanel, new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 1, 1.0, 1.0, GridBagConstraints.NORTHWEST,\n                                                     GridBagConstraints.NONE, new Insets(4, 0, 0, 0), 0, 0));\n\n    //myWarningLabel.setUI(new MultiLineLabelUI());\n    myPanel.add(myWarningLabel, new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 1, 0.0, 0.0, GridBagConstraints.NORTHWEST,\n                                                       GridBagConstraints.BOTH, new Insets(10, 6, 10, 0), 0, 0));\n  }","commit_id":"6fdb4b605af99fe031a55059da57e417401d0ca7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void createUIComponents() {\n    myLanguageLevelCombo = new LanguageLevelCombo();\n    final JTextField textField = new JTextField();\n    final FileChooserDescriptor outputPathsChooserDescriptor = new FileChooserDescriptor(false, true, false, false, false, false);\n    InsertPathAction.addTo(textField, outputPathsChooserDescriptor);\n    outputPathsChooserDescriptor.setHideIgnored(false);\n    myProjectCompilerOutput = new FieldPanel(textField, null,\n                                             null,\n                                             new BrowseFilesListener(textField,\n                                                                     \"\",\n                                                                     ProjectBundle.message(\"project.compiler.output\"),\n                                                                     outputPathsChooserDescriptor),\n                                             new Runnable() {\n                                                public void run() {\n                                                  //do nothing\n                                                }\n                                              });\n  }","id":65249,"modified_method":"private void createUIComponents() {\n    myLanguageLevelCombo = new LanguageLevelCombo();\n    final JTextField textField = new JTextField();\n    final FileChooserDescriptor outputPathsChooserDescriptor = new FileChooserDescriptor(false, true, false, false, false, false);\n    InsertPathAction.addTo(textField, outputPathsChooserDescriptor);\n    outputPathsChooserDescriptor.setHideIgnored(false);\n    BrowseFilesListener listener = new BrowseFilesListener(textField, \"\", ProjectBundle.message(\"project.compiler.output\"), outputPathsChooserDescriptor);\n    myProjectCompilerOutput = new FieldPanel(textField, null, null, listener, EmptyRunnable.getInstance());\n  }","commit_id":"6fdb4b605af99fe031a55059da57e417401d0ca7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void reset() {\n    myProjectJdkConfigurable.reset();\n    final String compilerOutput = ProjectRootManagerEx.getInstance(myProject).getCompilerOutputUrl();\n    if (compilerOutput != null) {\n      myProjectCompilerOutput.setText(FileUtil.toSystemDependentName(VfsUtil.urlToPath(compilerOutput)));\n    }\n    myLanguageLevelCombo.reset(myProject);\n    updateCircularDependencyWarning();\n  }","id":65250,"modified_method":"public void reset() {\n    myProjectJdkConfigurable.reset();\n    final String compilerOutput = ProjectRootManager.getInstance(myProject).getCompilerOutputUrl();\n    if (compilerOutput != null) {\n      myProjectCompilerOutput.setText(FileUtil.toSystemDependentName(VfsUtil.urlToPath(compilerOutput)));\n    }\n    myLanguageLevelCombo.reset(myProject);\n    updateCircularDependencyWarning();\n  }","commit_id":"6fdb4b605af99fe031a55059da57e417401d0ca7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void onCurrentSchemeChanged() {\n    myLayout.show(mySettingsPanel, WAIT_CARD);\n\n    myAlarm.cancelAllRequests();\n    final Runnable request = new Runnable() {\n      public void run() {\n        SwingUtilities.invokeLater(new Runnable() {\n          public void run() {\n            ensureCurrentPanel().onSomethingChanged();\n            myLayout.show(mySettingsPanel, myModel.getSelectedScheme().getName());\n          }\n        });\n      }\n    };\n    myAlarm.addRequest(request, 200);\n  }","id":65251,"modified_method":"public void onCurrentSchemeChanged() {\n    myLayout.show(mySettingsPanel, WAIT_CARD);\n    final Runnable replaceLayout = new Runnable() {\n      public void run() {\n        ensureCurrentPanel().onSomethingChanged();\n        myLayout.show(mySettingsPanel, myModel.getSelectedScheme().getName());\n      }\n    };\n    if (ApplicationManager.getApplication().isHeadlessEnvironment()) {\n      replaceLayout.run();\n    } else {\n      myAlarm.cancelAllRequests();\n      final Runnable request = new Runnable() {\n        public void run() {\n          SwingUtilities.invokeLater(replaceLayout);\n        }\n      };\n      myAlarm.addRequest(request, 200);\n    }\n  }","commit_id":"08a7091a37e4b4c6a856432983ca36d5ba13226e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n    public void testNearCacheContainsKey_afterRemove() {\n        IMap<String, String> map = client.getMap(randomMapName(NEAR_CACHE_WITH_INVALIDATION));\n        String key = \"key\";\n\n        map.put(key, \"value\");\n        map.get(key);\n        map.remove(key);\n\n        assertFalse(format(\"map contains unexpected key %s (map size: %d)\", key, map.size()), map.containsKey(key));\n    }","id":65252,"modified_method":"@Test\n    public void testNearCacheContainsKey_afterRemove() {\n        IMap<String, String> map = getNearCachedMapFromClient(newInvalidationEnabledNearCacheConfig());\n        String key = \"key\";\n\n        map.put(key, \"value\");\n        map.get(key);\n        map.remove(key);\n\n        assertFalse(format(\"map contains unexpected key %s (map size: %d)\", key, map.size()), map.containsKey(key));\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCachePopulatedAndHitsGenerated_withInterleavedCacheHitGeneration() throws Exception {\n        IMap<Integer, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_NO_INVALIDATION));\n\n        int size = 1278;\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n            // populate near cache\n            map.get(i);\n            // generate near cache hits\n            map.get(i);\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        System.out.println(\"stats = \" + stats);\n        assertEquals(size, stats.getOwnedEntryCount());\n        assertEquals(size, stats.getHits());\n    }","id":65253,"modified_method":"@Test\n    public void testNearCachePopulatedAndHitsGenerated_withInterleavedCacheHitGeneration() throws Exception {\n        IMap<Integer, Integer> map = getNearCachedMapFromClient(newNoInvalidationNearCacheConfig());\n\n        int size = 1278;\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n            // populate near cache\n            map.get(i);\n            // generate near cache hits\n            map.get(i);\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        System.out.println(\"stats = \" + stats);\n        assertEquals(size, stats.getOwnedEntryCount());\n        assertEquals(size, stats.getHits());\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheTTLCleanup_triggeredViaGet() {\n        final IMap<Integer, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_TTL));\n\n        final int size = 100;\n        populateNearCache(map, size);\n\n        assertThatOwnedEntryCountEquals(map, size);\n\n        sleepSeconds(MAX_TTL_SECONDS + 1);\n\n        assertTrueEventually(new AssertTask() {\n            public void run() throws Exception {\n                // map.get() triggers near cache eviction/expiration process, but we need to call this on every assert,\n                // since the near cache has a cooldown for TTL cleanups, which may not be over after populateNearCache()\n                map.get(0);\n\n                assertThatOwnedEntryCountIsSmallerThan(map, size);\n            }\n        });\n    }","id":65254,"modified_method":"@Test\n    public void testNearCacheTTLCleanup_triggeredViaGet() {\n        final IMap<Integer, Integer> map = getNearCachedMapFromClient(newTTLNearCacheConfig());\n\n        final int size = 100;\n        populateNearCache(map, size);\n\n        assertThatOwnedEntryCountEquals(map, size);\n\n        sleepSeconds(MAX_TTL_SECONDS + 1);\n\n        assertTrueEventually(new AssertTask() {\n            public void run() throws Exception {\n                // map.get() triggers near cache eviction/expiration process, but we need to call this on every assert,\n                // since the near cache has a cooldown for TTL cleanups, which may not be over after populateNearCache()\n                map.get(0);\n\n                assertThatOwnedEntryCountIsSmallerThan(map, size);\n            }\n        });\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheInvalidation_WithRandom_whenMaxSizeExceeded() throws Exception {\n        String mapName = randomMapName(NEAR_CACHE_RANDOM_WITH_MAX_SIZE);\n        final IMap<Integer, Integer> map = client.getMap(mapName);\n\n        int mapSize = MAX_CACHE_SIZE * 2;\n        populateNearCache(map, mapSize);\n\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                triggerEviction(map);\n                assertThatOwnedEntryCountIsSmallerThan(map, MAX_CACHE_SIZE);\n            }\n        });\n    }","id":65255,"modified_method":"@Test\n    public void testNearCacheInvalidation_WithRandom_whenMaxSizeExceeded() throws Exception {\n        final IMap<Integer, Integer> map = getNearCachedMapFromClient(newRandomNearCacheConfig());\n\n        int mapSize = MAX_CACHE_SIZE * 2;\n        populateNearCache(map, mapSize);\n\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                triggerEviction(map);\n                assertThatOwnedEntryCountIsSmallerThan(map, MAX_CACHE_SIZE);\n            }\n        });\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheMaxSize() {\n        final IMap<Integer, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_MAX_SIZE));\n\n        populateNearCache(map, MAX_CACHE_SIZE + 1);\n\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                assertThatOwnedEntryCountIsSmallerThan(map, MAX_CACHE_SIZE);\n            }\n        });\n    }","id":65256,"modified_method":"@Test\n    public void testNearCacheMaxSize() {\n        final IMap<Integer, Integer> map = getNearCachedMapFromClient(newMaxSizeNearCacheConfig());\n\n        populateNearCache(map, MAX_CACHE_SIZE + 1);\n\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                assertThatOwnedEntryCountIsSmallerThan(map, MAX_CACHE_SIZE);\n            }\n        });\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test(expected = NullPointerException.class)\n    public void testNearCacheContainsNullKey() {\n        IMap<Integer, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_INVALIDATION));\n        map.containsKey(null);\n    }","id":65257,"modified_method":"@Test(expected = NullPointerException.class)\n    public void testNearCacheContainsNullKey() {\n        IMap<Integer, Integer> map = getNearCachedMapFromClient(newInvalidationEnabledNearCacheConfig());\n\n        map.containsKey(null);\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheInvalidation_WithLRU_whenMaxSizeExceeded() throws Exception {\n        String mapName = randomMapName(NEAR_CACHE_LRU_WITH_MAX_SIZE);\n        final IMap<Integer, Integer> map = client.getMap(mapName);\n\n        int mapSize = MAX_CACHE_SIZE * 2;\n        populateNearCache(map, mapSize);\n\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                triggerEviction(map);\n                assertThatOwnedEntryCountIsSmallerThan(map, MAX_CACHE_SIZE);\n            }\n        });\n    }","id":65258,"modified_method":"@Test\n    public void testNearCacheInvalidation_WithLRU_whenMaxSizeExceeded() throws Exception {\n        final IMap<Integer, Integer> map = getNearCachedMapFromClient(newLRUMaxSizeConfig());\n\n        int mapSize = MAX_CACHE_SIZE * 2;\n        populateNearCache(map, mapSize);\n\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                triggerEviction(map);\n                assertThatOwnedEntryCountIsSmallerThan(map, MAX_CACHE_SIZE);\n            }\n        });\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testGetAllChecksNearCacheFirst() throws Exception {\n        IMap<Integer, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_NO_INVALIDATION));\n        HashSet<Integer> keys = new HashSet<Integer>();\n\n        int size = 1003;\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n            keys.add(i);\n        }\n        // populate near cache\n        for (int i = 0; i < size; i++) {\n            map.get(i);\n        }\n        // getAll() generates the near cache hits\n        map.getAll(keys);\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertEquals(size, stats.getOwnedEntryCount());\n        assertEquals(size, stats.getHits());\n    }","id":65259,"modified_method":"@Test\n    public void testGetAllChecksNearCacheFirst() throws Exception {\n        IMap<Integer, Integer> map = getNearCachedMapFromClient(newNoInvalidationNearCacheConfig());\n\n        HashSet<Integer> keys = new HashSet<Integer>();\n\n        int size = 1003;\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n            keys.add(i);\n        }\n        // populate near cache\n        for (int i = 0; i < size; i++) {\n            map.get(i);\n        }\n        // getAll() generates the near cache hits\n        map.getAll(keys);\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertEquals(size, stats.getOwnedEntryCount());\n        assertEquals(size, stats.getHits());\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCachePopulatedAndHitsGenerated() throws Exception {\n        IMap<Integer, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_NO_INVALIDATION));\n\n        int size = 1278;\n        populateNearCache(map, size);\n\n        for (int i = 0; i < size; i++) {\n            // generate near cache hits\n            map.get(i);\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        System.out.println(\"stats = \" + stats);\n        assertEquals(size, stats.getOwnedEntryCount());\n        assertEquals(size, stats.getHits());\n    }","id":65260,"modified_method":"@Test\n    public void testNearCachePopulatedAndHitsGenerated() throws Exception {\n        IMap<Integer, Integer> map = getNearCachedMapFromClient(newNoInvalidationNearCacheConfig());\n\n\n        int size = 1278;\n        populateNearCache(map, size);\n\n        for (int i = 0; i < size; i++) {\n            // generate near cache hits\n            map.get(i);\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertEquals(size, stats.getOwnedEntryCount());\n        assertEquals(size, stats.getHits());\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheContainsKey_whenKeyAbsent() {\n        IMap<String, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_INVALIDATION));\n\n        assertFalse(format(\"map contains unexpected key NOT_THERE (map size: %d)\", map.size()), map.containsKey(\"NOT_THERE\"));\n    }","id":65261,"modified_method":"@Test\n    public void testNearCacheContainsKey_whenKeyAbsent() {\n        IMap<String, String> map = getNearCachedMapFromClient(newInvalidationEnabledNearCacheConfig());\n\n        assertFalse(format(\"map contains unexpected key NOT_THERE (map size: %d)\", map.size()), map.containsKey(\"NOT_THERE\"));\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheMisses() {\n        IMap<String, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_NO_INVALIDATION));\n\n        int expectedCacheMisses = 1321;\n        for (int i = 0; i < expectedCacheMisses; i++) {\n            map.get(\"NOT_THERE\" + i);\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertEquals(expectedCacheMisses, stats.getMisses());\n        assertEquals(expectedCacheMisses, stats.getOwnedEntryCount());\n    }","id":65262,"modified_method":"@Test\n    public void testNearCacheMisses() {\n        IMap<Integer, Integer> map = getNearCachedMapFromClient(newNoInvalidationNearCacheConfig());\n\n\n        int expectedCacheMisses = 1321;\n        for (int i = 0; i < expectedCacheMisses; i++) {\n            map.get(\"NOT_THERE\" + i);\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertEquals(expectedCacheMisses, stats.getMisses());\n        assertEquals(expectedCacheMisses, stats.getOwnedEntryCount());\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testGetAsyncPopulatesNearCache() throws Exception {\n        IMap<Integer, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_NO_INVALIDATION));\n\n        int size = 1239;\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n        }\n        // populate near cache\n        for (int i = 0; i < size; i++) {\n            Future async = map.getAsync(i);\n            async.get();\n        }\n        // generate near cache hits\n        for (int i = 0; i < size; i++) {\n            map.get(i);\n        }\n\n        assertThatOwnedEntryCountEquals(map, size);\n    }","id":65263,"modified_method":"@Test\n    public void testGetAsyncPopulatesNearCache() throws Exception {\n        IMap<Integer, Integer> map = getNearCachedMapFromClient(newInvalidationEnabledNearCacheConfig());\n\n        int size = 1239;\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n        }\n        // populate near cache\n        for (int i = 0; i < size; i++) {\n            Future async = map.getAsync(i);\n            async.get();\n        }\n        // generate near cache hits\n        for (int i = 0; i < size; i++) {\n            map.get(i);\n        }\n\n        assertThatOwnedEntryCountEquals(map, size);\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheInvalidateOnChange() {\n        String mapName = randomMapName(NEAR_CACHE_WITH_INVALIDATION);\n        IMap<Integer, Integer> serverMap = server.getMap(mapName);\n\n        int size = 118;\n        for (int i = 0; i < size; i++) {\n            serverMap.put(i, i);\n        }\n\n        final IMap<Integer, Integer> clientMap = hazelcastFactory.newHazelcastClient(clientConfig).getMap(mapName);\n        // populate near cache\n        for (int i = 0; i < size; i++) {\n            clientMap.get(i);\n        }\n\n        assertThatOwnedEntryCountEquals(clientMap, size);\n\n        // invalidate near cache from server side\n        for (int i = 0; i < size; i++) {\n            serverMap.put(i, i);\n        }\n\n        assertTrueEventually(new AssertTask() {\n            public void run() throws Exception {\n                assertThatOwnedEntryCountEquals(clientMap, 0);\n            }\n        }, 10);\n    }","id":65264,"modified_method":"@Test\n    public void testNearCacheInvalidateOnChange() {\n        String mapName = randomMapName();\n        HazelcastInstance server = hazelcastFactory.newHazelcastInstance(newConfig());\n        ClientConfig clientConfig = newClientConfig();\n        clientConfig.addNearCacheConfig(newInvalidationEnabledNearCacheConfig());\n        IMap<Integer, Integer> serverMap = server.getMap(mapName);\n\n        int size = 118;\n        for (int i = 0; i < size; i++) {\n            serverMap.put(i, i);\n        }\n\n        HazelcastInstance newHazelcastClient = hazelcastFactory.newHazelcastClient(clientConfig);\n        final IMap<Integer, Integer> clientMap = newHazelcastClient.getMap(mapName);\n        // populate near cache\n        for (int i = 0; i < size; i++) {\n            clientMap.get(i);\n        }\n\n        assertThatOwnedEntryCountEquals(clientMap, size);\n\n        // invalidate near cache from server side\n        for (int i = 0; i < size; i++) {\n            serverMap.put(i, i);\n        }\n\n        assertTrueEventually(new AssertTask() {\n            public void run() throws Exception {\n                assertThatOwnedEntryCountEquals(clientMap, 0);\n            }\n        });\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testGetNearCacheStatsBeforePopulation() {\n        IMap<Integer, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_NO_INVALIDATION));\n\n        int size = 101;\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertNotNull(stats);\n    }","id":65265,"modified_method":"@Test\n    public void testGetNearCacheStatsBeforePopulation() {\n        IMap<Integer, Integer> map = getNearCachedMapFromClient(newNoInvalidationNearCacheConfig());\n\n\n        int size = 101;\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertNotNull(stats);\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testIssue2009() throws Exception {\n        IMap<Integer, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_INVALIDATION));\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertNotNull(stats);\n    }","id":65266,"modified_method":"@Test\n    public void testIssue2009() throws Exception {\n        IMap<Integer, Integer> map = getNearCachedMapFromClient(newInvalidationEnabledNearCacheConfig());\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertNotNull(stats);\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testRemovedKeyValueNotInNearCache() throws Exception {\n        IMap<Integer, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_INVALIDATION));\n\n        int size = 1247;\n        populateNearCache(map, size);\n\n        for (int i = 0; i < size; i++) {\n            map.remove(i);\n            assertNull(map.get(i));\n        }\n    }","id":65267,"modified_method":"@Test\n    public void testRemovedKeyValueNotInNearCache() throws Exception {\n        IMap<Integer, Integer> map = getNearCachedMapFromClient(newInvalidationEnabledNearCacheConfig());\n\n        int size = 1247;\n        populateNearCache(map, size);\n\n        for (int i = 0; i < size; i++) {\n            map.remove(i);\n            assertNull(map.get(i));\n        }\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheMisses_whenRepeatedOnSameKey() {\n        IMap<String, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_INVALIDATION));\n\n        int expectedCacheMisses = 17;\n        for (int i = 0; i < expectedCacheMisses; i++) {\n            map.get(\"NOT_THERE\");\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertEquals(1, stats.getOwnedEntryCount());\n        assertEquals(expectedCacheMisses, stats.getMisses());\n    }","id":65268,"modified_method":"@Test\n    public void testNearCacheMisses_whenRepeatedOnSameKey() {\n        IMap<Integer, Integer> map = getNearCachedMapFromClient(newInvalidationEnabledNearCacheConfig());\n\n        int expectedCacheMisses = 17;\n        for (int i = 0; i < expectedCacheMisses; i++) {\n            map.get(\"NOT_THERE\");\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertEquals(1, stats.getOwnedEntryCount());\n        assertEquals(expectedCacheMisses, stats.getMisses());\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheInvalidation_WithLFU_whenMaxSizeExceeded() throws Exception {\n        String mapName = randomMapName(NEAR_CACHE_LFU_WITH_MAX_SIZE);\n        final IMap<Integer, Integer> map = client.getMap(mapName);\n\n        int mapSize = MAX_CACHE_SIZE * 2;\n        populateNearCache(map, mapSize);\n\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                triggerEviction(map);\n                assertThatOwnedEntryCountIsSmallerThan(map, MAX_CACHE_SIZE);\n            }\n        });\n    }","id":65269,"modified_method":"@Test\n    public void testNearCacheInvalidation_WithLFU_whenMaxSizeExceeded() throws Exception {\n        final IMap<Integer, Integer> map = getNearCachedMapFromClient(newLFUMaxSizeNearCacheConfig());\n\n        int mapSize = MAX_CACHE_SIZE * 2;\n        populateNearCache(map, mapSize);\n\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                triggerEviction(map);\n                assertThatOwnedEntryCountIsSmallerThan(map, MAX_CACHE_SIZE);\n            }\n        });\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheInvalidation_WithNone_whenMaxSizeExceeded() throws Exception {\n        String mapName = randomMapName(NEAR_CACHE_NONE_WITH_MAX_SIZE);\n        final IMap<Integer, Integer> map = client.getMap(mapName);\n\n        int mapSize = MAX_CACHE_SIZE * 2;\n        populateNearCache(map, mapSize);\n\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                assertThatOwnedEntryCountEquals(map, MAX_CACHE_SIZE);\n            }\n        });\n    }","id":65270,"modified_method":"@Test\n    public void testNearCacheInvalidation_WithNone_whenMaxSizeExceeded() throws Exception {\n        final IMap<Integer, Integer> map = getNearCachedMapFromClient(newNoneNearCacheConfig());\n\n        int mapSize = MAX_CACHE_SIZE * 2;\n        populateNearCache(map, mapSize);\n\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                assertThatOwnedEntryCountEquals(map, MAX_CACHE_SIZE);\n            }\n        });\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testMapRemove_WithNearCache() {\n        IMap<Integer, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_INVALIDATION));\n\n        int size = 1113;\n        populateNearCache(map, size);\n\n        for (int i = 0; i < size; i++) {\n            map.remove(i);\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertEquals(0, stats.getOwnedEntryCount());\n        assertEquals(size, stats.getMisses());\n    }","id":65271,"modified_method":"@Test\n    public void testMapRemove_WithNearCache() {\n        IMap<Integer, Integer> map = getNearCachedMapFromClient(newInvalidationEnabledNearCacheConfig());\n\n        int size = 1113;\n        populateNearCache(map, size);\n\n        for (int i = 0; i < size; i++) {\n            map.remove(i);\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertEquals(0, stats.getOwnedEntryCount());\n        assertEquals(size, stats.getMisses());\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheTTLCleanup_triggeredViaPut() {\n        final IMap<Integer, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_TTL));\n\n        final int size = 100;\n        populateNearCache(map, size);\n\n        assertThatOwnedEntryCountEquals(map, size);\n\n        sleepSeconds(MAX_TTL_SECONDS + 1);\n\n        assertTrueEventually(new AssertTask() {\n            public void run() throws Exception {\n                // map.put() triggers near cache eviction/expiration process, but we need to call this on every assert,\n                // since the near cache has a cooldown for TTL cleanups, which may not be over after populateNearCache()\n                map.put(0, 0);\n\n                assertThatOwnedEntryCountIsSmallerThan(map, size);\n            }\n        });\n    }","id":65272,"modified_method":"@Test\n    public void testNearCacheTTLCleanup_triggeredViaPut() {\n        final IMap<Integer, Integer> map = getNearCachedMapFromClient(newTTLNearCacheConfig());\n\n        final int size = 100;\n        populateNearCache(map, size);\n\n        assertThatOwnedEntryCountEquals(map, size);\n\n        sleepSeconds(MAX_TTL_SECONDS + 1);\n\n        assertTrueEventually(new AssertTask() {\n            public void run() throws Exception {\n                // map.put() triggers near cache eviction/expiration process, but we need to call this on every assert,\n                // since the near cache has a cooldown for TTL cleanups, which may not be over after populateNearCache()\n                map.put(0, 0);\n\n                assertThatOwnedEntryCountIsSmallerThan(map, size);\n            }\n        });\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCache_clearFromClient() {\n        String mapName = randomMapName(NEAR_CACHE_WITH_INVALIDATION);\n        IMap<Integer, Integer> map = client.getMap(mapName);\n\n        int size = 147;\n        populateNearCache(map, size);\n\n        map.clear();\n\n        // near cache should be empty\n        for (int i = 0; i < size; i++) {\n            assertNull(map.get(i));\n        }\n    }","id":65273,"modified_method":"@Test\n    public void testNearCache_clearFromClient() {\n        IMap<Integer, Integer> map = getNearCachedMapFromClient(newInvalidationEnabledNearCacheConfig());\n\n        int size = 147;\n        populateNearCache(map, size);\n\n        map.clear();\n\n        // near cache should be empty\n        for (int i = 0; i < size; i++) {\n            assertNull(map.get(i));\n        }\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testGetAllPopulatesNearCache() throws Exception {\n        IMap<Integer, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_NO_INVALIDATION));\n        HashSet<Integer> keys = new HashSet<Integer>();\n\n        int size = 1214;\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n            keys.add(i);\n        }\n        // getAll() populates near cache\n        map.getAll(keys);\n\n        assertThatOwnedEntryCountEquals(map, size);\n    }","id":65274,"modified_method":"@Test\n    public void testGetAllPopulatesNearCache() throws Exception {\n        IMap<Integer, Integer> map = getNearCachedMapFromClient(newNoInvalidationNearCacheConfig());\n\n        HashSet<Integer> keys = new HashSet<Integer>();\n\n        int size = 1214;\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n            keys.add(i);\n        }\n        // getAll() populates near cache\n        map.getAll(keys);\n\n        assertThatOwnedEntryCountEquals(map, size);\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheInvalidationWithLFU() throws Exception {\n        String mapName = randomMapName(NEAR_CACHE_LFU_WITH_MAX_SIZE);\n        final IMap<Integer, Integer> map = client.getMap(mapName);\n\n        int mapSize = MAX_CACHE_SIZE * 2;\n        populateNearCache(map, mapSize);\n\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                triggerEviction(map);\n                assertThatOwnedEntryCountIsSmallerThan(map, MAX_CACHE_SIZE);\n            }\n        });\n    }","id":65275,"modified_method":"@Test\n    public void testNearCacheInvalidationWithLFU() throws Exception {\n        final IMap<Integer, Integer> map = getNearCachedMapFromClient(newLFUMaxSizeNearCacheConfig());\n\n        int mapSize = MAX_CACHE_SIZE * 2;\n        populateNearCache(map, mapSize);\n\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                triggerEviction(map);\n                assertThatOwnedEntryCountIsSmallerThan(map, MAX_CACHE_SIZE);\n            }\n        });\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheIdleRecordsEvicted() {\n        IMap<Integer, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_IDLE));\n\n        int size = 147;\n        populateNearCache(map, size);\n\n        // generate near cache hits\n        for (int i = 0; i < size; i++) {\n            map.get(i);\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        long hitsBeforeIdleExpire = stats.getHits();\n\n        sleepSeconds(MAX_IDLE_SECONDS + 1);\n\n        for (int i = 0; i < size; i++) {\n            map.get(i);\n        }\n        stats = map.getLocalMapStats().getNearCacheStats();\n\n        assertEquals(\"as the hits are not equal, the entries were not cleared from near cash after MAX_IDLE_SECONDS\",\n                hitsBeforeIdleExpire, stats.getHits(), size);\n    }","id":65276,"modified_method":"@Test\n    public void testNearCacheIdleRecordsEvicted() {\n        IMap<Integer, Integer> map = getNearCachedMapFromClient(newMaxIdleSecondsNearCacheConfig());\n\n        int size = 147;\n        populateNearCache(map, size);\n\n        // generate near cache hits\n        for (int i = 0; i < size; i++) {\n            map.get(i);\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        long hitsBeforeIdleExpire = stats.getHits();\n\n        sleepSeconds(MAX_IDLE_SECONDS + 1);\n\n        for (int i = 0; i < size; i++) {\n            map.get(i);\n        }\n        stats = map.getLocalMapStats().getNearCacheStats();\n\n        assertEquals(\"as the hits are not equal, the entries were not cleared from near cash after MAX_IDLE_SECONDS\",\n                hitsBeforeIdleExpire, stats.getHits(), size);\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheContainsKey() {\n        IMap<String, String> map = client.getMap(randomMapName(NEAR_CACHE_WITH_INVALIDATION));\n        String key = \"key\";\n\n        map.put(key, \"value\");\n        map.get(key);\n\n        assertTrue(format(\"map doesn't contain expected key %s (map size: %d)\", key, map.size()), map.containsKey(key));\n    }","id":65277,"modified_method":"@Test\n    public void testNearCacheContainsKey() {\n        IMap<String, String> map = getNearCachedMapFromClient(newInvalidationEnabledNearCacheConfig());\n\n        String key = \"key\";\n\n        map.put(key, \"value\");\n        map.get(key);\n\n        assertTrue(format(\"map doesn't contain expected key %s (map size: %d)\", key, map.size()), map.containsKey(key));\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testGetAsync() throws Exception {\n        IMap<Integer, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_NO_INVALIDATION));\n\n        int size = 1009;\n        populateNearCache(map, size);\n\n        // generate near cache hits with async call\n        for (int i = 0; i < size; i++) {\n            Future async = map.getAsync(i);\n            async.get();\n        }\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertEquals(size, stats.getOwnedEntryCount());\n        assertEquals(size, stats.getHits());\n    }","id":65278,"modified_method":"@Test\n    public void testGetAsync() throws Exception {\n        IMap<Integer, Integer> map = getNearCachedMapFromClient(newNoInvalidationNearCacheConfig());\n\n\n        int size = 1009;\n        populateNearCache(map, size);\n\n        // generate near cache hits with async call\n        for (int i = 0; i < size; i++) {\n            Future async = map.getAsync(i);\n            async.get();\n        }\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertEquals(size, stats.getOwnedEntryCount());\n        assertEquals(size, stats.getHits());\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testServerMapExpiration_doesNotInvalidateClientNearCache() {\n        String mapName = randomMapName(NEAR_CACHE_WITH_LONG_MAX_IDLE_TIME);\n        IMap<Integer, Integer> serverMap = server.getMap(mapName);\n        IMap<Integer, Integer> clientMap = client.getMap(mapName);\n\n        // add EntryExpiredListener to catch expiration events\n        final CountDownLatch expiredEventLatch = new CountDownLatch(2);\n        EntryExpiredListener listener = new EntryExpiredListener() {\n            @Override\n            public void entryExpired(EntryEvent event) {\n                expiredEventLatch.countDown();\n            }\n        };\n        serverMap.addEntryListener(listener, false);\n        clientMap.addEntryListener(listener, false);\n\n        // add NearCacheEventListener to catch near cache invalidation event on client side\n        final CountDownLatch eventAddedLatch = new CountDownLatch(1);\n        addNearCacheInvalidateListener(clientMap, eventAddedLatch);\n\n        // put entry with TTL into server map\n        serverMap.put(1, 23, 6, TimeUnit.SECONDS);\n        assertNotNull(serverMap.get(1));\n\n        // wait until near cache invalidation is done after ADDED event\n        assertOpenEventually(eventAddedLatch);\n        assertThatOwnedEntryCountEquals(clientMap, 0);\n\n        // get() operation puts entry into client near cache\n        assertNotNull(clientMap.get(1));\n        assertThatOwnedEntryCountEquals(clientMap, 1);\n\n        // assert that the entry is not available on the server after expiration\n        assertOpenEventually(expiredEventLatch);\n        assertNull(serverMap.get(1));\n\n        // assert that the entry is still available on the client and in the client near cache\n        assertNotNull(clientMap.get(1));\n        assertThatOwnedEntryCountEquals(clientMap, 1);\n    }","id":65279,"modified_method":"@Test\n    public void testServerMapExpiration_doesNotInvalidateClientNearCache() {\n        String mapName = randomMapName();\n        HazelcastInstance server = hazelcastFactory.newHazelcastInstance(newConfig());\n        NearCacheConfig nearCacheConfig = newLongMaxIdleNearCacheConfig();\n        ClientConfig clientConfig = newClientConfig();\n        clientConfig.addNearCacheConfig(nearCacheConfig);\n        HazelcastInstance client = hazelcastFactory.newHazelcastClient(clientConfig);\n\n        IMap<Integer, Integer> serverMap = server.getMap(mapName);\n        IMap<Integer, Integer> clientMap = client.getMap(mapName);\n\n        // add EntryExpiredListener to catch expiration events\n        final CountDownLatch expiredEventLatch = new CountDownLatch(2);\n        EntryExpiredListener listener = new EntryExpiredListener() {\n            @Override\n            public void entryExpired(EntryEvent event) {\n                expiredEventLatch.countDown();\n            }\n        };\n        serverMap.addEntryListener(listener, false);\n        clientMap.addEntryListener(listener, false);\n\n        // add NearCacheEventListener to catch near cache invalidation event on client side\n        final CountDownLatch eventAddedLatch = new CountDownLatch(1);\n        addNearCacheInvalidateListener(clientMap, eventAddedLatch);\n\n        // put entry with TTL into server map\n        serverMap.put(1, 23, 6, TimeUnit.SECONDS);\n        assertNotNull(serverMap.get(1));\n\n        // wait until near cache invalidation is done after ADDED event\n        assertOpenEventually(eventAddedLatch);\n        assertThatOwnedEntryCountEquals(clientMap, 0);\n\n        // get() operation puts entry into client near cache\n        assertNotNull(clientMap.get(1));\n        assertThatOwnedEntryCountEquals(clientMap, 1);\n\n        // assert that the entry is not available on the server after expiration\n        assertOpenEventually(expiredEventLatch);\n        assertNull(serverMap.get(1));\n\n        // assert that the entry is still available on the client and in the client near cache\n        assertNotNull(clientMap.get(1));\n        assertThatOwnedEntryCountEquals(clientMap, 1);\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCache_clearFromRemote() {\n        String mapName = randomMapName(NEAR_CACHE_WITH_INVALIDATION);\n        final IMap<Integer, Integer> map = client.getMap(mapName);\n\n        final int size = 147;\n        populateNearCache(map, size);\n\n        server.getMap(mapName).clear();\n\n        // near cache should be empty\n        assertTrueEventually(new AssertTask() {\n            public void run() throws Exception {\n                for (int i = 0; i < size; i++) {\n                    assertNull(map.get(i));\n                }\n            }\n        });\n    }","id":65280,"modified_method":"@Test\n    public void testNearCache_clearFromRemote() {\n        String mapName = randomMapName();\n        HazelcastInstance server = hazelcastFactory.newHazelcastInstance(newConfig());\n        NearCacheConfig nearCacheConfig = newInvalidationEnabledNearCacheConfig();\n        ClientConfig clientConfig = newClientConfig();\n        clientConfig.addNearCacheConfig(nearCacheConfig);\n        HazelcastInstance client = hazelcastFactory.newHazelcastClient(clientConfig);\n        final IMap<Integer, Integer> map = client.getMap(mapName);\n\n        final int size = 147;\n        populateNearCache(map, size);\n\n        server.getMap(mapName).clear();\n\n        // near cache should be empty\n        assertTrueEventually(new AssertTask() {\n            public void run() throws Exception {\n                for (int i = 0; i < size; i++) {\n                    assertNull(map.get(i));\n                }\n            }\n        });\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheInvalidationWithLFU() throws Exception {\n        String mapName = randomMapName(NEAR_CACHE_LFU_WITH_MAX_SIZE);\n        final IMap<Integer, Integer> map = client.getMap(mapName);\n\n        int mapSize = MAX_CACHE_SIZE * 2;\n        populateNearCache(map, mapSize);\n\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                triggerEviction(map);\n                assertThatOwnedEntryCountIsSmallerThan(map, MAX_CACHE_SIZE);\n            }\n        });\n    }","id":65281,"modified_method":"@Test\n    public void testNearCacheInvalidationWithLFU() throws Exception {\n        final IMap<Integer, Integer> map = getNearCachedMapFromClient(newLFUMaxSizeNearCacheConfig());\n\n        int mapSize = MAX_CACHE_SIZE * 2;\n        populateNearCache(map, mapSize);\n\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                triggerEviction(map);\n                assertThatOwnedEntryCountIsSmallerThan(map, MAX_CACHE_SIZE);\n            }\n        });\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheTTLCleanup_triggeredViaGet() {\n        final IMap<Integer, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_TTL));\n\n        final int size = 100;\n        populateNearCache(map, size);\n\n        assertThatOwnedEntryCountEquals(map, size);\n\n        sleepSeconds(MAX_TTL_SECONDS + 1);\n\n        assertTrueEventually(new AssertTask() {\n            public void run() throws Exception {\n                // map.get() triggers near cache eviction/expiration process, but we need to call this on every assert,\n                // since the near cache has a cooldown for TTL cleanups, which may not be over after populateNearCache()\n                map.get(0);\n\n                assertThatOwnedEntryCountIsSmallerThan(map, size);\n            }\n        });\n    }","id":65282,"modified_method":"@Test\n    public void testNearCacheTTLCleanup_triggeredViaGet() {\n        final IMap<Integer, Integer> map = getNearCachedMapFromClient(newTTLNearCacheConfig());\n\n        final int size = 100;\n        populateNearCache(map, size);\n\n        assertThatOwnedEntryCountEquals(map, size);\n\n        sleepSeconds(MAX_TTL_SECONDS + 1);\n\n        assertTrueEventually(new AssertTask() {\n            public void run() throws Exception {\n                // map.get() triggers near cache eviction/expiration process, but we need to call this on every assert,\n                // since the near cache has a cooldown for TTL cleanups, which may not be over after populateNearCache()\n                map.get(0);\n\n                assertThatOwnedEntryCountIsSmallerThan(map, size);\n            }\n        });\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheInvalidation_WithRandom_whenMaxSizeExceeded() throws Exception {\n        String mapName = randomMapName(NEAR_CACHE_RANDOM_WITH_MAX_SIZE);\n        final IMap<Integer, Integer> map = client.getMap(mapName);\n\n        int mapSize = MAX_CACHE_SIZE * 2;\n        populateNearCache(map, mapSize);\n\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                triggerEviction(map);\n                assertThatOwnedEntryCountIsSmallerThan(map, MAX_CACHE_SIZE);\n            }\n        });\n    }","id":65283,"modified_method":"@Test\n    public void testNearCacheInvalidation_WithRandom_whenMaxSizeExceeded() throws Exception {\n        final IMap<Integer, Integer> map = getNearCachedMapFromClient(newRandomNearCacheConfig());\n\n        int mapSize = MAX_CACHE_SIZE * 2;\n        populateNearCache(map, mapSize);\n\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                triggerEviction(map);\n                assertThatOwnedEntryCountIsSmallerThan(map, MAX_CACHE_SIZE);\n            }\n        });\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheInvalidation_WithLFU_whenMaxSizeExceeded() throws Exception {\n        String mapName = randomMapName(NEAR_CACHE_LFU_WITH_MAX_SIZE);\n        final IMap<Integer, Integer> map = client.getMap(mapName);\n\n        int mapSize = MAX_CACHE_SIZE * 2;\n        populateNearCache(map, mapSize);\n\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                triggerEviction(map);\n                assertThatOwnedEntryCountIsSmallerThan(map, MAX_CACHE_SIZE);\n            }\n        });\n    }","id":65284,"modified_method":"@Test\n    public void testNearCacheInvalidation_WithLFU_whenMaxSizeExceeded() throws Exception {\n        final IMap<Integer, Integer> map = getNearCachedMapFromClient(newLFUMaxSizeNearCacheConfig());\n\n        int mapSize = MAX_CACHE_SIZE * 2;\n        populateNearCache(map, mapSize);\n\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                triggerEviction(map);\n                assertThatOwnedEntryCountIsSmallerThan(map, MAX_CACHE_SIZE);\n            }\n        });\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheMaxSize() {\n        final IMap<Integer, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_MAX_SIZE));\n\n        populateNearCache(map, MAX_CACHE_SIZE + 1);\n\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                assertThatOwnedEntryCountIsSmallerThan(map, MAX_CACHE_SIZE);\n            }\n        });\n    }","id":65285,"modified_method":"@Test\n    public void testNearCacheMaxSize() {\n        final IMap<Integer, Integer> map = getNearCachedMapFromClient(newMaxSizeNearCacheConfig());\n\n        populateNearCache(map, MAX_CACHE_SIZE + 1);\n\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                assertThatOwnedEntryCountIsSmallerThan(map, MAX_CACHE_SIZE);\n            }\n        });\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testServerMapExpiration_doesNotInvalidateClientNearCache() {\n        String mapName = randomMapName(NEAR_CACHE_WITH_LONG_MAX_IDLE_TIME);\n        IMap<Integer, Integer> serverMap = server.getMap(mapName);\n        IMap<Integer, Integer> clientMap = client.getMap(mapName);\n\n        // add EntryExpiredListener to catch expiration events\n        final CountDownLatch expiredEventLatch = new CountDownLatch(2);\n        EntryExpiredListener listener = new EntryExpiredListener() {\n            @Override\n            public void entryExpired(EntryEvent event) {\n                expiredEventLatch.countDown();\n            }\n        };\n        serverMap.addEntryListener(listener, false);\n        clientMap.addEntryListener(listener, false);\n\n        // add NearCacheEventListener to catch near cache invalidation event on client side\n        final CountDownLatch eventAddedLatch = new CountDownLatch(1);\n        addNearCacheInvalidateListener(clientMap, eventAddedLatch);\n\n        // put entry with TTL into server map\n        serverMap.put(1, 23, 6, TimeUnit.SECONDS);\n        assertNotNull(serverMap.get(1));\n\n        // wait until near cache invalidation is done after ADDED event\n        assertOpenEventually(eventAddedLatch);\n        assertThatOwnedEntryCountEquals(clientMap, 0);\n\n        // get() operation puts entry into client near cache\n        assertNotNull(clientMap.get(1));\n        assertThatOwnedEntryCountEquals(clientMap, 1);\n\n        // assert that the entry is not available on the server after expiration\n        assertOpenEventually(expiredEventLatch);\n        assertNull(serverMap.get(1));\n\n        // assert that the entry is still available on the client and in the client near cache\n        assertNotNull(clientMap.get(1));\n        assertThatOwnedEntryCountEquals(clientMap, 1);\n    }","id":65286,"modified_method":"@Test\n    public void testServerMapExpiration_doesNotInvalidateClientNearCache() {\n        String mapName = randomMapName();\n        HazelcastInstance server = hazelcastFactory.newHazelcastInstance(newConfig());\n        NearCacheConfig nearCacheConfig = newLongMaxIdleNearCacheConfig();\n        ClientConfig clientConfig = newClientConfig();\n        clientConfig.addNearCacheConfig(nearCacheConfig);\n        HazelcastInstance client = hazelcastFactory.newHazelcastClient(clientConfig);\n\n        IMap<Integer, Integer> serverMap = server.getMap(mapName);\n        IMap<Integer, Integer> clientMap = client.getMap(mapName);\n\n        // add EntryExpiredListener to catch expiration events\n        final CountDownLatch expiredEventLatch = new CountDownLatch(2);\n        EntryExpiredListener listener = new EntryExpiredListener() {\n            @Override\n            public void entryExpired(EntryEvent event) {\n                expiredEventLatch.countDown();\n            }\n        };\n        serverMap.addEntryListener(listener, false);\n        clientMap.addEntryListener(listener, false);\n\n        // add NearCacheEventListener to catch near cache invalidation event on client side\n        final CountDownLatch eventAddedLatch = new CountDownLatch(1);\n        addNearCacheInvalidateListener(clientMap, eventAddedLatch);\n\n        // put entry with TTL into server map\n        serverMap.put(1, 23, 6, TimeUnit.SECONDS);\n        assertNotNull(serverMap.get(1));\n\n        // wait until near cache invalidation is done after ADDED event\n        assertOpenEventually(eventAddedLatch);\n        assertThatOwnedEntryCountEquals(clientMap, 0);\n\n        // get() operation puts entry into client near cache\n        assertNotNull(clientMap.get(1));\n        assertThatOwnedEntryCountEquals(clientMap, 1);\n\n        // assert that the entry is not available on the server after expiration\n        assertOpenEventually(expiredEventLatch);\n        assertNull(serverMap.get(1));\n\n        // assert that the entry is still available on the client and in the client near cache\n        assertNotNull(clientMap.get(1));\n        assertThatOwnedEntryCountEquals(clientMap, 1);\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheContainsKey_afterRemove() {\n        IMap<String, String> map = client.getMap(randomMapName(NEAR_CACHE_WITH_INVALIDATION));\n        String key = \"key\";\n\n        map.put(key, \"value\");\n        map.get(key);\n        map.remove(key);\n\n        assertFalse(format(\"map contains unexpected key %s (map size: %d)\", key, map.size()), map.containsKey(key));\n    }","id":65287,"modified_method":"@Test\n    public void testNearCacheContainsKey_afterRemove() {\n        IMap<String, String> map = getNearCachedMapFromClient(newInvalidationEnabledNearCacheConfig());\n        String key = \"key\";\n\n        map.put(key, \"value\");\n        map.get(key);\n        map.remove(key);\n\n        assertFalse(format(\"map contains unexpected key %s (map size: %d)\", key, map.size()), map.containsKey(key));\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheMisses() {\n        IMap<String, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_NO_INVALIDATION));\n\n        int expectedCacheMisses = 1321;\n        for (int i = 0; i < expectedCacheMisses; i++) {\n            map.get(\"NOT_THERE\" + i);\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertEquals(expectedCacheMisses, stats.getMisses());\n        assertEquals(expectedCacheMisses, stats.getOwnedEntryCount());\n    }","id":65288,"modified_method":"@Test\n    public void testNearCacheMisses() {\n        IMap<Integer, Integer> map = getNearCachedMapFromClient(newNoInvalidationNearCacheConfig());\n\n\n        int expectedCacheMisses = 1321;\n        for (int i = 0; i < expectedCacheMisses; i++) {\n            map.get(\"NOT_THERE\" + i);\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertEquals(expectedCacheMisses, stats.getMisses());\n        assertEquals(expectedCacheMisses, stats.getOwnedEntryCount());\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCache_clearFromRemote() {\n        String mapName = randomMapName(NEAR_CACHE_WITH_INVALIDATION);\n        final IMap<Integer, Integer> map = client.getMap(mapName);\n\n        final int size = 147;\n        populateNearCache(map, size);\n\n        server.getMap(mapName).clear();\n\n        // near cache should be empty\n        assertTrueEventually(new AssertTask() {\n            public void run() throws Exception {\n                for (int i = 0; i < size; i++) {\n                    assertNull(map.get(i));\n                }\n            }\n        });\n    }","id":65289,"modified_method":"@Test\n    public void testNearCache_clearFromRemote() {\n        String mapName = randomMapName();\n        HazelcastInstance server = hazelcastFactory.newHazelcastInstance(newConfig());\n        NearCacheConfig nearCacheConfig = newInvalidationEnabledNearCacheConfig();\n        ClientConfig clientConfig = newClientConfig();\n        clientConfig.addNearCacheConfig(nearCacheConfig);\n        HazelcastInstance client = hazelcastFactory.newHazelcastClient(clientConfig);\n        final IMap<Integer, Integer> map = client.getMap(mapName);\n\n        final int size = 147;\n        populateNearCache(map, size);\n\n        server.getMap(mapName).clear();\n\n        // near cache should be empty\n        assertTrueEventually(new AssertTask() {\n            public void run() throws Exception {\n                for (int i = 0; i < size; i++) {\n                    assertNull(map.get(i));\n                }\n            }\n        });\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testIssue2009() throws Exception {\n        IMap<Integer, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_INVALIDATION));\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertNotNull(stats);\n    }","id":65290,"modified_method":"@Test\n    public void testIssue2009() throws Exception {\n        IMap<Integer, Integer> map = getNearCachedMapFromClient(newInvalidationEnabledNearCacheConfig());\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertNotNull(stats);\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheInvalidateOnChange() {\n        String mapName = randomMapName(NEAR_CACHE_WITH_INVALIDATION);\n        IMap<Integer, Integer> serverMap = server.getMap(mapName);\n\n        int size = 118;\n        for (int i = 0; i < size; i++) {\n            serverMap.put(i, i);\n        }\n\n        final IMap<Integer, Integer> clientMap = hazelcastFactory.newHazelcastClient(clientConfig).getMap(mapName);\n        // populate near cache\n        for (int i = 0; i < size; i++) {\n            clientMap.get(i);\n        }\n\n        assertThatOwnedEntryCountEquals(clientMap, size);\n\n        // invalidate near cache from server side\n        for (int i = 0; i < size; i++) {\n            serverMap.put(i, i);\n        }\n\n        assertTrueEventually(new AssertTask() {\n            public void run() throws Exception {\n                assertThatOwnedEntryCountEquals(clientMap, 0);\n            }\n        });\n    }","id":65291,"modified_method":"@Test\n    public void testNearCacheInvalidateOnChange() {\n        String mapName = randomMapName();\n        HazelcastInstance server = hazelcastFactory.newHazelcastInstance(newConfig());\n        ClientConfig clientConfig = newClientConfig();\n        clientConfig.addNearCacheConfig(newInvalidationEnabledNearCacheConfig());\n        IMap<Integer, Integer> serverMap = server.getMap(mapName);\n\n        int size = 118;\n        for (int i = 0; i < size; i++) {\n            serverMap.put(i, i);\n        }\n\n        HazelcastInstance newHazelcastClient = hazelcastFactory.newHazelcastClient(clientConfig);\n        final IMap<Integer, Integer> clientMap = newHazelcastClient.getMap(mapName);\n        // populate near cache\n        for (int i = 0; i < size; i++) {\n            clientMap.get(i);\n        }\n\n        assertThatOwnedEntryCountEquals(clientMap, size);\n\n        // invalidate near cache from server side\n        for (int i = 0; i < size; i++) {\n            serverMap.put(i, i);\n        }\n\n        assertTrueEventually(new AssertTask() {\n            public void run() throws Exception {\n                assertThatOwnedEntryCountEquals(clientMap, 0);\n            }\n        });\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheMisses_whenRepeatedOnSameKey() {\n        IMap<String, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_INVALIDATION));\n\n        int expectedCacheMisses = 17;\n        for (int i = 0; i < expectedCacheMisses; i++) {\n            map.get(\"NOT_THERE\");\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertEquals(1, stats.getOwnedEntryCount());\n        assertEquals(expectedCacheMisses, stats.getMisses());\n    }","id":65292,"modified_method":"@Test\n    public void testNearCacheMisses_whenRepeatedOnSameKey() {\n        IMap<Integer, Integer> map = getNearCachedMapFromClient(newInvalidationEnabledNearCacheConfig());\n\n        int expectedCacheMisses = 17;\n        for (int i = 0; i < expectedCacheMisses; i++) {\n            map.get(\"NOT_THERE\");\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertEquals(1, stats.getOwnedEntryCount());\n        assertEquals(expectedCacheMisses, stats.getMisses());\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testRemovedKeyValueNotInNearCache() throws Exception {\n        IMap<Integer, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_INVALIDATION));\n\n        int size = 1247;\n        populateNearCache(map, size);\n\n        for (int i = 0; i < size; i++) {\n            map.remove(i);\n            assertNull(map.get(i));\n        }\n    }","id":65293,"modified_method":"@Test\n    public void testRemovedKeyValueNotInNearCache() throws Exception {\n        IMap<Integer, Integer> map = getNearCachedMapFromClient(newInvalidationEnabledNearCacheConfig());\n\n        int size = 1247;\n        populateNearCache(map, size);\n\n        for (int i = 0; i < size; i++) {\n            map.remove(i);\n            assertNull(map.get(i));\n        }\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testGetAsync() throws Exception {\n        IMap<Integer, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_NO_INVALIDATION));\n\n        int size = 1009;\n        populateNearCache(map, size);\n\n        // generate near cache hits with async call\n        for (int i = 0; i < size; i++) {\n            Future async = map.getAsync(i);\n            async.get();\n        }\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertEquals(size, stats.getOwnedEntryCount());\n        assertEquals(size, stats.getHits());\n    }","id":65294,"modified_method":"@Test\n    public void testGetAsync() throws Exception {\n        IMap<Integer, Integer> map = getNearCachedMapFromClient(newNoInvalidationNearCacheConfig());\n\n\n        int size = 1009;\n        populateNearCache(map, size);\n\n        // generate near cache hits with async call\n        for (int i = 0; i < size; i++) {\n            Future async = map.getAsync(i);\n            async.get();\n        }\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertEquals(size, stats.getOwnedEntryCount());\n        assertEquals(size, stats.getHits());\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheTTLCleanup_triggeredViaPut() {\n        final IMap<Integer, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_TTL));\n\n        final int size = 100;\n        populateNearCache(map, size);\n\n        assertThatOwnedEntryCountEquals(map, size);\n\n        sleepSeconds(MAX_TTL_SECONDS + 1);\n\n        assertTrueEventually(new AssertTask() {\n            public void run() throws Exception {\n                // map.put() triggers near cache eviction/expiration process, but we need to call this on every assert,\n                // since the near cache has a cooldown for TTL cleanups, which may not be over after populateNearCache()\n                map.put(0, 0);\n\n                assertThatOwnedEntryCountIsSmallerThan(map, size);\n            }\n        });\n    }","id":65295,"modified_method":"@Test\n    public void testNearCacheTTLCleanup_triggeredViaPut() {\n        final IMap<Integer, Integer> map = getNearCachedMapFromClient(newTTLNearCacheConfig());\n\n        final int size = 100;\n        populateNearCache(map, size);\n\n        assertThatOwnedEntryCountEquals(map, size);\n\n        sleepSeconds(MAX_TTL_SECONDS + 1);\n\n        assertTrueEventually(new AssertTask() {\n            public void run() throws Exception {\n                // map.put() triggers near cache eviction/expiration process, but we need to call this on every assert,\n                // since the near cache has a cooldown for TTL cleanups, which may not be over after populateNearCache()\n                map.put(0, 0);\n\n                assertThatOwnedEntryCountIsSmallerThan(map, size);\n            }\n        });\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testGetAllPopulatesNearCache() throws Exception {\n        IMap<Integer, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_NO_INVALIDATION));\n        HashSet<Integer> keys = new HashSet<Integer>();\n\n        int size = 1214;\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n            keys.add(i);\n        }\n        // getAll() populates near cache\n        map.getAll(keys);\n\n        assertThatOwnedEntryCountEquals(map, size);\n    }","id":65296,"modified_method":"@Test\n    public void testGetAllPopulatesNearCache() throws Exception {\n        IMap<Integer, Integer> map = getNearCachedMapFromClient(newNoInvalidationNearCacheConfig());\n\n        HashSet<Integer> keys = new HashSet<Integer>();\n\n        int size = 1214;\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n            keys.add(i);\n        }\n        // getAll() populates near cache\n        map.getAll(keys);\n\n        assertThatOwnedEntryCountEquals(map, size);\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheIdleRecordsEvicted() {\n        IMap<Integer, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_IDLE));\n\n        int size = 147;\n        populateNearCache(map, size);\n\n        // generate near cache hits\n        for (int i = 0; i < size; i++) {\n            map.get(i);\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        long hitsBeforeIdleExpire = stats.getHits();\n\n        sleepSeconds(MAX_IDLE_SECONDS + 1);\n\n        for (int i = 0; i < size; i++) {\n            map.get(i);\n        }\n        stats = map.getLocalMapStats().getNearCacheStats();\n\n        assertEquals(\"as the hits are not equal, the entries were not cleared from near cash after MAX_IDLE_SECONDS\",\n                hitsBeforeIdleExpire, stats.getHits(), size);\n    }","id":65297,"modified_method":"@Test\n    public void testNearCacheIdleRecordsEvicted() {\n        IMap<Integer, Integer> map = getNearCachedMapFromClient(newMaxIdleSecondsNearCacheConfig());\n\n        int size = 147;\n        populateNearCache(map, size);\n\n        // generate near cache hits\n        for (int i = 0; i < size; i++) {\n            map.get(i);\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        long hitsBeforeIdleExpire = stats.getHits();\n\n        sleepSeconds(MAX_IDLE_SECONDS + 1);\n\n        for (int i = 0; i < size; i++) {\n            map.get(i);\n        }\n        stats = map.getLocalMapStats().getNearCacheStats();\n\n        assertEquals(\"as the hits are not equal, the entries were not cleared from near cash after MAX_IDLE_SECONDS\",\n                hitsBeforeIdleExpire, stats.getHits(), size);\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheInvalidation_WithNone_whenMaxSizeExceeded() throws Exception {\n        String mapName = randomMapName(NEAR_CACHE_NONE_WITH_MAX_SIZE);\n        final IMap<Integer, Integer> map = client.getMap(mapName);\n\n        int mapSize = MAX_CACHE_SIZE * 2;\n        populateNearCache(map, mapSize);\n\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                assertThatOwnedEntryCountEquals(map, MAX_CACHE_SIZE);\n            }\n        });\n    }","id":65298,"modified_method":"@Test\n    public void testNearCacheInvalidation_WithNone_whenMaxSizeExceeded() throws Exception {\n        final IMap<Integer, Integer> map = getNearCachedMapFromClient(newNoneNearCacheConfig());\n\n        int mapSize = MAX_CACHE_SIZE * 2;\n        populateNearCache(map, mapSize);\n\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                assertThatOwnedEntryCountEquals(map, MAX_CACHE_SIZE);\n            }\n        });\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCache_clearFromClient() {\n        String mapName = randomMapName(NEAR_CACHE_WITH_INVALIDATION);\n        IMap<Integer, Integer> map = client.getMap(mapName);\n\n        int size = 147;\n        populateNearCache(map, size);\n\n        map.clear();\n\n        // near cache should be empty\n        for (int i = 0; i < size; i++) {\n            assertNull(map.get(i));\n        }\n    }","id":65299,"modified_method":"@Test\n    public void testNearCache_clearFromClient() {\n        IMap<Integer, Integer> map = getNearCachedMapFromClient(newInvalidationEnabledNearCacheConfig());\n\n        int size = 147;\n        populateNearCache(map, size);\n\n        map.clear();\n\n        // near cache should be empty\n        for (int i = 0; i < size; i++) {\n            assertNull(map.get(i));\n        }\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCachePopulatedAndHitsGenerated() throws Exception {\n        IMap<Integer, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_NO_INVALIDATION));\n\n        int size = 1278;\n        populateNearCache(map, size);\n\n        for (int i = 0; i < size; i++) {\n            // generate near cache hits\n            map.get(i);\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        System.out.println(\"stats = \" + stats);\n        assertEquals(size, stats.getOwnedEntryCount());\n        assertEquals(size, stats.getHits());\n    }","id":65300,"modified_method":"@Test\n    public void testNearCachePopulatedAndHitsGenerated() throws Exception {\n        IMap<Integer, Integer> map = getNearCachedMapFromClient(newNoInvalidationNearCacheConfig());\n\n\n        int size = 1278;\n        populateNearCache(map, size);\n\n        for (int i = 0; i < size; i++) {\n            // generate near cache hits\n            map.get(i);\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertEquals(size, stats.getOwnedEntryCount());\n        assertEquals(size, stats.getHits());\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheContainsKey_whenKeyAbsent() {\n        IMap<String, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_INVALIDATION));\n\n        assertFalse(format(\"map contains unexpected key NOT_THERE (map size: %d)\", map.size()), map.containsKey(\"NOT_THERE\"));\n    }","id":65301,"modified_method":"@Test\n    public void testNearCacheContainsKey_whenKeyAbsent() {\n        IMap<String, String> map = getNearCachedMapFromClient(newInvalidationEnabledNearCacheConfig());\n\n        assertFalse(format(\"map contains unexpected key NOT_THERE (map size: %d)\", map.size()), map.containsKey(\"NOT_THERE\"));\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test(expected = NullPointerException.class)\n    public void testNearCacheContainsNullKey() {\n        IMap<Integer, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_INVALIDATION));\n        map.containsKey(null);\n    }","id":65302,"modified_method":"@Test(expected = NullPointerException.class)\n    public void testNearCacheContainsNullKey() {\n        IMap<Integer, Integer> map = getNearCachedMapFromClient(newInvalidationEnabledNearCacheConfig());\n\n        map.containsKey(null);\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testGetNearCacheStatsBeforePopulation() {\n        IMap<Integer, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_NO_INVALIDATION));\n\n        int size = 101;\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertNotNull(stats);\n    }","id":65303,"modified_method":"@Test\n    public void testGetNearCacheStatsBeforePopulation() {\n        IMap<Integer, Integer> map = getNearCachedMapFromClient(newNoInvalidationNearCacheConfig());\n\n\n        int size = 101;\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertNotNull(stats);\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testGetAsyncPopulatesNearCache() throws Exception {\n        IMap<Integer, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_NO_INVALIDATION));\n\n        int size = 1239;\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n        }\n        // populate near cache\n        for (int i = 0; i < size; i++) {\n            Future async = map.getAsync(i);\n            async.get();\n        }\n        // generate near cache hits\n        for (int i = 0; i < size; i++) {\n            map.get(i);\n        }\n\n        assertThatOwnedEntryCountEquals(map, size);\n    }","id":65304,"modified_method":"@Test\n    public void testGetAsyncPopulatesNearCache() throws Exception {\n        IMap<Integer, Integer> map = getNearCachedMapFromClient(newInvalidationEnabledNearCacheConfig());\n\n        int size = 1239;\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n        }\n        // populate near cache\n        for (int i = 0; i < size; i++) {\n            Future async = map.getAsync(i);\n            async.get();\n        }\n        // generate near cache hits\n        for (int i = 0; i < size; i++) {\n            map.get(i);\n        }\n\n        assertThatOwnedEntryCountEquals(map, size);\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testGetAllChecksNearCacheFirst() throws Exception {\n        IMap<Integer, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_NO_INVALIDATION));\n        HashSet<Integer> keys = new HashSet<Integer>();\n\n        int size = 1003;\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n            keys.add(i);\n        }\n        // populate near cache\n        for (int i = 0; i < size; i++) {\n            map.get(i);\n        }\n        // getAll() generates the near cache hits\n        map.getAll(keys);\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertEquals(size, stats.getOwnedEntryCount());\n        assertEquals(size, stats.getHits());\n    }","id":65305,"modified_method":"@Test\n    public void testGetAllChecksNearCacheFirst() throws Exception {\n        IMap<Integer, Integer> map = getNearCachedMapFromClient(newNoInvalidationNearCacheConfig());\n\n        HashSet<Integer> keys = new HashSet<Integer>();\n\n        int size = 1003;\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n            keys.add(i);\n        }\n        // populate near cache\n        for (int i = 0; i < size; i++) {\n            map.get(i);\n        }\n        // getAll() generates the near cache hits\n        map.getAll(keys);\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertEquals(size, stats.getOwnedEntryCount());\n        assertEquals(size, stats.getHits());\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testMapRemove_WithNearCache() {\n        IMap<Integer, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_INVALIDATION));\n\n        int size = 1113;\n        populateNearCache(map, size);\n\n        for (int i = 0; i < size; i++) {\n            map.remove(i);\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertEquals(0, stats.getOwnedEntryCount());\n        assertEquals(size, stats.getMisses());\n    }","id":65306,"modified_method":"@Test\n    public void testMapRemove_WithNearCache() {\n        IMap<Integer, Integer> map = getNearCachedMapFromClient(newInvalidationEnabledNearCacheConfig());\n\n        int size = 1113;\n        populateNearCache(map, size);\n\n        for (int i = 0; i < size; i++) {\n            map.remove(i);\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertEquals(0, stats.getOwnedEntryCount());\n        assertEquals(size, stats.getMisses());\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCachePopulatedAndHitsGenerated_withInterleavedCacheHitGeneration() throws Exception {\n        IMap<Integer, Integer> map = client.getMap(randomMapName(NEAR_CACHE_WITH_NO_INVALIDATION));\n\n        int size = 1278;\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n            // populate near cache\n            map.get(i);\n            // generate near cache hits\n            map.get(i);\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        System.out.println(\"stats = \" + stats);\n        assertEquals(size, stats.getOwnedEntryCount());\n        assertEquals(size, stats.getHits());\n    }","id":65307,"modified_method":"@Test\n    public void testNearCachePopulatedAndHitsGenerated_withInterleavedCacheHitGeneration() throws Exception {\n        IMap<Integer, Integer> map = getNearCachedMapFromClient(newNoInvalidationNearCacheConfig());\n\n        int size = 1278;\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n            // populate near cache\n            map.get(i);\n            // generate near cache hits\n            map.get(i);\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        System.out.println(\"stats = \" + stats);\n        assertEquals(size, stats.getOwnedEntryCount());\n        assertEquals(size, stats.getHits());\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheInvalidation_WithLRU_whenMaxSizeExceeded() throws Exception {\n        String mapName = randomMapName(NEAR_CACHE_LRU_WITH_MAX_SIZE);\n        final IMap<Integer, Integer> map = client.getMap(mapName);\n\n        int mapSize = MAX_CACHE_SIZE * 2;\n        populateNearCache(map, mapSize);\n\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                triggerEviction(map);\n                assertThatOwnedEntryCountIsSmallerThan(map, MAX_CACHE_SIZE);\n            }\n        });\n    }","id":65308,"modified_method":"@Test\n    public void testNearCacheInvalidation_WithLRU_whenMaxSizeExceeded() throws Exception {\n        final IMap<Integer, Integer> map = getNearCachedMapFromClient(newLRUMaxSizeConfig());\n\n        int mapSize = MAX_CACHE_SIZE * 2;\n        populateNearCache(map, mapSize);\n\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                triggerEviction(map);\n                assertThatOwnedEntryCountIsSmallerThan(map, MAX_CACHE_SIZE);\n            }\n        });\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheContainsKey() {\n        IMap<String, String> map = client.getMap(randomMapName(NEAR_CACHE_WITH_INVALIDATION));\n        String key = \"key\";\n\n        map.put(key, \"value\");\n        map.get(key);\n\n        assertTrue(format(\"map doesn't contain expected key %s (map size: %d)\", key, map.size()), map.containsKey(key));\n    }","id":65309,"modified_method":"@Test\n    public void testNearCacheContainsKey() {\n        IMap<String, String> map = getNearCachedMapFromClient(newInvalidationEnabledNearCacheConfig());\n\n        String key = \"key\";\n\n        map.put(key, \"value\");\n        map.get(key);\n\n        assertTrue(format(\"map doesn't contain expected key %s (map size: %d)\", key, map.size()), map.containsKey(key));\n    }","commit_id":"73644e240d6b75987c98ead4a9ea82a6a1c770f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public ProcessorOutput connectProcessorToBottomInput(Node node, Processor processor, String outputName, String referencedId) {\n        if (!idToInputMap.containsKey(referencedId)) {\n            LocationData locationData = node == null ? null : (LocationData) ((Element) node).getData();\n            throw new ValidationException(\"Reference to undeclared output parameter id \\\"\" + referencedId + \"\\\"\", locationData);\n        }\n        if (inputIdAlreadyConnected.contains(referencedId)) {\n            LocationData locationData = node == null ? null : (LocationData) ((Element) node).getData();\n            throw new ValidationException(\"Other processor output is already connected to output parameter id \\\"\" + referencedId + \"\\\"\", locationData);\n        }\n        ProcessorOutput processorOutput = processor.createOutput(outputName);\n        ProcessorInput bottomInput = (ProcessorInput) idToInputMap.get(referencedId);\n        bottomInput.setOutput(processorOutput);\n        processorOutput.setInput(bottomInput);\n        return processorOutput;\n    }","id":65310,"modified_method":"public ProcessorOutput connectProcessorToBottomInput(Node node, String outputName, String referencedId, ProcessorOutput processorOutput) {\n        if (!idToInputMap.containsKey(referencedId)) {\n            LocationData locationData = node == null ? null : (LocationData) ((Element) node).getData();\n            throw new ValidationException(\"Reference to undeclared output parameter id \\\"\" + referencedId + \"\\\"\", locationData);\n        }\n        if (inputIdAlreadyConnected.contains(referencedId)) {\n            LocationData locationData = node == null ? null : (LocationData) ((Element) node).getData();\n            throw new ValidationException(\"Other processor output is already connected to output parameter id \\\"\" + referencedId + \"\\\"\", locationData);\n        }\n        ProcessorInput bottomInput = (ProcessorInput) idToInputMap.get(referencedId);\n        bottomInput.setOutput(processorOutput);\n        processorOutput.setInput(bottomInput);\n        return processorOutput;\n    }","commit_id":"70ba272c66dc4db6c3f808e9a61f1d39721591a3","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static PipelineConfig createConfigFromAST(ASTPipeline astPipeline) {\n\n        // Perform sanity check on the connection in the pipeline\n        astPipeline.getIdInfo();\n\n        // Context used by pipeline factories (do not need to be the request context)\n        PipelineContext context = new PipelineContext();\n\n        // Create new configuration object\n        PipelineConfig config = new PipelineConfig();\n        PipelineBlock block = new PipelineBlock();\n\n        // Create socket info for each param\n        for (Iterator i = astPipeline.getParams().iterator(); i.hasNext();) {\n            ASTParam param = (ASTParam) i.next();\n\n            // Create internal top output/bottom input for this param\n            if (param.getType() == ASTParam.INPUT) {\n                InternalTopOutput internalTopOutput = new InternalTopOutput(param.getName(), param.getLocationData());\n                block.declareOutput(param.getNode(), param.getName(), internalTopOutput);\n                config.declareTopOutput(param.getName(), internalTopOutput);\n                setDebugAndSchema(internalTopOutput, param);\n            } else {\n                ProcessorInput internalBottomInput = new InternalBottomInput(param.getName());\n                block.declareBottomInput(param.getNode(), param.getName(), internalBottomInput);\n                config.declareBottomInput(param.getName(), internalBottomInput);\n                setDebugAndSchema(internalBottomInput, param);\n            }\n\n            // Create socket\n            // FIXME: when we implement the full delegation model, we'll have\n            // here to create of pass the input/output information.\n        }\n\n        // Internally connect all processors / choose / for-each\n        for (Iterator i = astPipeline.getStatements().iterator(); i.hasNext();) {\n            Object statement = i.next();\n            Processor processor = null;\n            boolean foundOutput = false;\n\n            if (statement instanceof ASTProcessorCall) {\n                ASTProcessorCall processorCall = (ASTProcessorCall) statement;\n\n                LocationData processorLocationData = processorCall.getLocationData();\n\n                if (processorCall.getEncapsulation() == null) {\n                    // Direct call\n                    if (processorCall.getProcessor() == null) {\n                        ProcessorFactory processorFactory = ProcessorFactoryRegistry.lookup(processorCall.getName());\n                        if (processorFactory == null)\n                            processorFactory = ProcessorFactoryRegistry.lookup(processorCall.getURI());\n                        if (processorFactory == null) {\n                            throw new ValidationException(\"Cannot find processor factory with name \\\"\"\n                                    + (processorCall.getName() != null ? XMLUtils.qNameToexplodedQName(processorCall.getName()) :  processorCall.getURI()) + \"\\\"\", processorLocationData);\n                        }\n                        processor = processorFactory.createInstance(context);\n                    } else {\n                        processor = processorCall.getProcessor();\n                    }\n                } else if (\"ejb\".equals(processorCall.getEncapsulation())) {\n                    // Call through EJB proxy\n                    ProxyProcessor proxyProcessor = new ProxyProcessor();\n                    proxyProcessor.setJNDIName(processorCall.getURI());\n                    proxyProcessor.setInputs(processorCall.getInputs());\n                    proxyProcessor.setOutputs(processorCall.getOutputs());\n                    processor = proxyProcessor.createInstance(context);\n                }\n\n                // Set info on processor\n                processor.setId(processorCall.getId());\n                processor.setLocationData(processorLocationData);\n\n                // Process outputs\n                for (Iterator j = processorCall.getOutputs().iterator(); j.hasNext();) {\n                    foundOutput = true;\n                    ASTOutput output = (ASTOutput) j.next();\n                    if (output.getName() == null)\n                        throw new OXFException(\"Name attribute is mandatory on output\");\n                    if (output.getId() == null && output.getRef() == null)\n                        throw new OXFException(\"Either one of id or ref must be specified on output \" + output.getName());\n\n                    if (output.getRef() != null) {\n                        ProcessorOutput pout = block.connectProcessorToBottomInput\n                                (output.getNode(), processor, output.getName(), output.getRef());\n                        setDebugAndSchema(pout, output);\n                        setBreakpointKey(pout, output);\n                    }\n\n                    if (output.getId() != null) {\n                        ProcessorOutput pout = processor.createOutput(output.getName());\n                        block.declareOutput(output.getNode(), output.getId(), pout);\n                        setDebugAndSchema(pout, output);\n                        setBreakpointKey(pout, output);\n                    }\n                }\n\n                // Make sure at least one of the outputs is connected\n                if (!foundOutput && processor.getOutputsInfo().size() > 0)\n                    throw new ValidationException(\"The processor output must be connected\", processorLocationData);\n\n                // Process inputs\n                for (Iterator j = processorCall.getInputs().iterator(); j.hasNext();) {\n                    ASTInput input = (ASTInput) j.next();\n\n                    ProcessorInput pin;\n                    LocationData locationData = input.getLocationData();\n                    if (input.getHref() != null) {\n                        // We reference a URI\n                        pin = block.connectProcessorToHref(input.getNode(), processor, input.getName(), input.getHref());\n                    } else {\n                        // We have some inline XML in the <input> tag\n                        Node inlineNode = input.getContent();\n\n                        Document document;\n                        if (inlineNode instanceof Element) {\n                            // Create new Document\n                            Element inlineElement = (Element) inlineNode;\n                            document = DocumentHelper.createDocument(inlineElement.createCopy());\n                            // Make sure the parent namespaces are copied over\n                            Map parentNamespaceContext = XMLUtils.getNamespaceContext(inlineElement.getParent());\n                            Element rootElement = document.getRootElement();\n                            for (Iterator k = parentNamespaceContext.keySet().iterator(); k.hasNext();) {\n                                String prefix = (String) k.next();\n                                String uri = (String) parentNamespaceContext.get(prefix);\n                                rootElement.addNamespace(prefix, uri);\n                            }\n                        } else if (inlineNode instanceof Document) {\n                            document = (Document) inlineNode;\n                        } else {\n                            throw new OXFException(\"Invalid type for inline document: \" + inlineNode.getClass().getName());\n                        }\n\n                        // Create generator for the static text\n                        Processor documentProcessor = PipelineUtils.createDOMGenerator(document, astPipeline.getValidity());\n\n                        ProcessorOutput pout = documentProcessor.createOutput(OUTPUT_DATA);\n                        pin = processor.createInput(input.getName());\n\n                        // NOTE: We should have a customizable mechanism to do this\n                        final String jndiName = \"oxf/processor/xslt-2.0\";\n                        // Experimental, doesn't work yet within XSLT configs!\n                        // To solve this, maybe a flag specifying that we are\n                        // using a template should be explicitly specified on\n                        // the input?\n                        if (false && XPathUtils.selectBooleanValue(document, \"/*/@*[local-name() = 'version' and namespace-uri() = 'http://www.w3.org/1999/XSL/Transform'] = '2.0'\").booleanValue()) {\n                            // It is embedded XSLT 2.0: connect through XSLT transformer\n\n                            ProcessorFactory processorFactory = ProcessorFactoryRegistry.lookup(jndiName);\n                            if (processorFactory == null) {\n                                throw new ValidationException(\"Cannot find processor factory with JNDI name \\\"\"\n                                        + processorCall.getURI() + \"\\\"\", locationData);\n                            }\n                            Processor templateProcessor = processorFactory.createInstance(context);\n\n                            // Set info on processor\n                            //processor.setId(processorCall.getId()); // what id, if any?\n                            templateProcessor.setLocationData(locationData);\n\n                            // Connect config input\n                            ProcessorInput configInput = templateProcessor.createInput(INPUT_CONFIG);\n                            pout.setInput(configInput);\n                            configInput.setOutput(pout);\n\n                            // Connect data input (for now, a null document)\n                            ProcessorInput dataInput = templateProcessor.createInput(INPUT_DATA);\n                            Processor nullGenerator = PipelineUtils.createDOMGenerator(XMLUtils.NULL_DOCUMENT, astPipeline.getValidity());\n                            ProcessorOutput nullGeneratorOutput = nullGenerator.createOutput(OUTPUT_DATA);\n                            nullGeneratorOutput.setInput(dataInput);\n                            dataInput.setOutput(nullGeneratorOutput);\n\n                            // Connect data output\n                            ProcessorOutput templateProcessorOutput = templateProcessor.createOutput(OUTPUT_DATA);\n                            templateProcessorOutput.setInput(pin);\n                            pin.setOutput(templateProcessorOutput);\n\n                        } else {\n                            // It is regular static text: connect directly\n                            pout.setInput(pin);\n                            pin.setOutput(pout);\n                        }\n                    }\n                    setDebugAndSchema(pin, input);\n                    setBreakpointKey(pin, input);\n                }\n\n            } else if (statement instanceof ASTChoose) {\n\n                // Instantiate processor\n                ASTChoose choose = (ASTChoose) statement;\n                AbstractProcessor chooseAbstractProcessor = new AbstractChooseProcessor(choose, astPipeline.getValidity());\n                ConcreteChooseProcessor chooseProcessor =\n                        (ConcreteChooseProcessor) chooseAbstractProcessor.createInstance(context);\n                processor = chooseProcessor;\n\n                // Connect special $data input (document on which the decision is made, or iterated on)\n                ProcessorInput pin = block.connectProcessorToHref(choose.getNode(), processor,\n                        AbstractChooseProcessor.CHOOSE_DATA_INPUT, choose.getHref());\n                setDebugAndSchema(pin, (ASTDebugSchema) statement);\n\n                // Go through inputs/outputs and connect to the rest of the pipeline\n                for (Iterator j = processor.getInputsInfo().iterator(); j.hasNext();) {\n                    // We reference a previously declared output\n                    String inputName = ((ProcessorInputOutputInfo) j.next()).getName();\n                    if (!inputName.equals(AbstractChooseProcessor.CHOOSE_DATA_INPUT)) {\n                        ASTHrefId hrefId = new ASTHrefId();\n                        hrefId.setId(inputName);\n                        block.connectProcessorToHref(choose.getNode(), processor, inputName, hrefId);\n                    }\n                }\n                for (Iterator j = processor.getOutputsInfo().iterator(); j.hasNext();) {\n                    String outputName = ((ProcessorInputOutputInfo) j.next()).getName();\n                    foundOutput = true;\n                    if (chooseProcessor.getOutputsByParamRef().contains(outputName))\n                        block.connectProcessorToBottomInput(choose.getNode(), processor, outputName, outputName);\n                    if (chooseProcessor.getOutputsById().contains(outputName))\n                        block.declareOutput(choose.getNode(), outputName, processor.createOutput(outputName));\n                }\n\n            } else if (statement instanceof ASTForEach) {\n\n                // Instantiate processor\n                ASTForEach forEach = (ASTForEach) statement;\n                LocationData forEachLocationData = forEach.getLocationData();\n                AbstractProcessor forEachAbstractProcessor = new ForEachProcessor(forEach, astPipeline.getValidity());\n                ForEachProcessor.ConcreteForEachProcessor forEachProcessor =\n                        (ForEachProcessor.ConcreteForEachProcessor) forEachAbstractProcessor.createInstance(context);\n                processor = forEachProcessor;\n\n                // Connect special $data input (document on which the decision is made, or iterated on)\n                ProcessorInput pin = block.connectProcessorToHref(forEach.getNode(), processor,\n                        ForEachProcessor.FOR_EACH_DATA_INPUT, forEach.getHref());\n                setDebugAndSchema(pin, forEachLocationData,\n                        forEach.getInputSchemaUri(), forEach.getInputSchemaHref(), forEach.getInputDebug());\n\n                // Go through inputs and connect to the rest of the pipeline\n                for (Iterator j = processor.getInputsInfo().iterator(); j.hasNext();) {\n                    // We reference a previously declared output\n                    String inputName = ((ProcessorInputOutputInfo) j.next()).getName();\n                    if (!inputName.equals(ForEachProcessor.FOR_EACH_DATA_INPUT)) {\n                        ASTHrefId hrefId = new ASTHrefId();\n                        hrefId.setId(inputName);\n                        block.connectProcessorToHref(forEach.getNode(), processor, inputName, hrefId);\n                    }\n                }\n\n                // Connect output\n                String outputName = null;\n                if (forEach.getId() != null) {\n                    outputName = forEach.getId();\n                    ProcessorOutput forEachOutput;\n                    if (forEach.getRef() != null) {\n                        block.connectProcessorToBottomInput(forEach.getNode(), processor, forEach.getId(), forEach.getRef());\n                        forEachOutput = processor.getOutputByName(forEach.getId());\n                    } else {\n                        forEachOutput = processor.createOutput(forEach.getId());\n                    }\n                    block.declareOutput(forEach.getNode(), forEach.getId(), forEachOutput);\n                } else if (forEach.getRef() != null) {\n                    outputName = forEach.getRef();\n                    block.connectProcessorToBottomInput(forEach.getNode(), processor, forEach.getRef(), forEach.getRef());\n                }\n                if (outputName != null) {\n                    foundOutput = true;\n                    setDebugAndSchema(processor.getOutputByName(outputName), forEachLocationData,\n                            forEach.getOutputSchemaUri(), forEach.getOutputSchemaHref(), forEach.getOutputDebug());\n                }\n            }\n\n            // Remember all processors and processor with no output (need to be started)\n            if (processor != null) {\n                config.addProcessor(processor);\n                if (!foundOutput) {\n                    config.addProcessorToStart(processor);\n                }\n            }\n        }\n\n        // Check that all bottom inputs are connected\n        for (Iterator i = astPipeline.getParams().iterator(); i.hasNext();) {\n            ASTParam param = (ASTParam) i.next();\n            if (param.getType() == ASTParam.OUTPUT) {\n                if (! block.isBottomInputConnected(param.getName()))\n                    throw new ValidationException(\"No processor in pipeline is connected to pipeline output '\"\n                            + param.getName() + \"'\", param.getLocationData());\n            }\n        }\n        \n        // Add processors created for connection reasons\n        for (Iterator i = block.getCreatedProcessors().iterator(); i.hasNext();)\n            config.addProcessor((Processor) i.next());\n\n        return config;\n    }","id":65311,"modified_method":"public static PipelineConfig createConfigFromAST(ASTPipeline astPipeline) {\n\n        // Perform sanity check on the connection in the pipeline\n        astPipeline.getIdInfo();\n\n        // Context used by pipeline factories (do not need to be the request context)\n        PipelineContext context = new PipelineContext();\n\n        // Create new configuration object\n        PipelineConfig config = new PipelineConfig();\n        PipelineBlock block = new PipelineBlock();\n\n        // Create socket info for each param\n        for (Iterator i = astPipeline.getParams().iterator(); i.hasNext();) {\n            ASTParam param = (ASTParam) i.next();\n\n            // Create internal top output/bottom input for this param\n            if (param.getType() == ASTParam.INPUT) {\n                InternalTopOutput internalTopOutput = new InternalTopOutput(param.getName(), param.getLocationData());\n                block.declareOutput(param.getNode(), param.getName(), internalTopOutput);\n                config.declareTopOutput(param.getName(), internalTopOutput);\n                setDebugAndSchema(internalTopOutput, param);\n            } else {\n                ProcessorInput internalBottomInput = new InternalBottomInput(param.getName());\n                block.declareBottomInput(param.getNode(), param.getName(), internalBottomInput);\n                config.declareBottomInput(param.getName(), internalBottomInput);\n                setDebugAndSchema(internalBottomInput, param);\n            }\n\n            // Create socket\n            // FIXME: when we implement the full delegation model, we'll have\n            // here to create of pass the input/output information.\n        }\n\n        // Internally connect all processors / choose / for-each\n        for (Iterator i = astPipeline.getStatements().iterator(); i.hasNext();) {\n            Object statement = i.next();\n            Processor processor = null;\n            boolean foundOutput = false;\n\n            if (statement instanceof ASTProcessorCall) {\n                ASTProcessorCall processorCall = (ASTProcessorCall) statement;\n\n                LocationData processorLocationData = processorCall.getLocationData();\n\n                if (processorCall.getEncapsulation() == null) {\n                    // Direct call\n                    if (processorCall.getProcessor() == null) {\n                        ProcessorFactory processorFactory = ProcessorFactoryRegistry.lookup(processorCall.getName());\n                        if (processorFactory == null)\n                            processorFactory = ProcessorFactoryRegistry.lookup(processorCall.getURI());\n                        if (processorFactory == null) {\n                            throw new ValidationException(\"Cannot find processor factory with name \\\"\"\n                                    + (processorCall.getName() != null ? XMLUtils.qNameToexplodedQName(processorCall.getName()) :  processorCall.getURI()) + \"\\\"\", processorLocationData);\n                        }\n                        processor = processorFactory.createInstance(context);\n                    } else {\n                        processor = processorCall.getProcessor();\n                    }\n                } else if (\"ejb\".equals(processorCall.getEncapsulation())) {\n                    // Call through EJB proxy\n                    ProxyProcessor proxyProcessor = new ProxyProcessor();\n                    proxyProcessor.setJNDIName(processorCall.getURI());\n                    proxyProcessor.setInputs(processorCall.getInputs());\n                    proxyProcessor.setOutputs(processorCall.getOutputs());\n                    processor = proxyProcessor.createInstance(context);\n                }\n\n                // Set info on processor\n                processor.setId(processorCall.getId());\n                processor.setLocationData(processorLocationData);\n\n                // Process outputs\n                for (Iterator j = processorCall.getOutputs().iterator(); j.hasNext();) {\n                    foundOutput = true;\n                    ASTOutput output = (ASTOutput) j.next();\n                    if (output.getName() == null)\n                        throw new OXFException(\"Name attribute is mandatory on output\");\n                    if (output.getId() == null && output.getRef() == null)\n                        throw new OXFException(\"Either one of id or ref must be specified on output \" + output.getName());\n\n                    ProcessorOutput pout = processor.createOutput(output.getName());\n                    if (output.getId() != null)\n                        block.declareOutput(output.getNode(), output.getId(), pout);\n                    if (output.getRef() != null)\n                        block.connectProcessorToBottomInput\n                                (output.getNode(), output.getName(), output.getRef(), pout);\n                    setDebugAndSchema(pout, output);\n                    setBreakpointKey(pout, output);\n                }\n\n                // Make sure at least one of the outputs is connected\n                if (!foundOutput && processor.getOutputsInfo().size() > 0)\n                    throw new ValidationException(\"The processor output must be connected\", processorLocationData);\n\n                // Process inputs\n                for (Iterator j = processorCall.getInputs().iterator(); j.hasNext();) {\n                    ASTInput input = (ASTInput) j.next();\n\n                    ProcessorInput pin;\n                    LocationData locationData = input.getLocationData();\n                    if (input.getHref() != null) {\n                        // We reference a URI\n                        pin = block.connectProcessorToHref(input.getNode(), processor, input.getName(), input.getHref());\n                    } else {\n                        // We have some inline XML in the <input> tag\n                        Node inlineNode = input.getContent();\n\n                        Document document;\n                        if (inlineNode instanceof Element) {\n                            // Create new Document\n                            Element inlineElement = (Element) inlineNode;\n                            document = DocumentHelper.createDocument(inlineElement.createCopy());\n                            // Make sure the parent namespaces are copied over\n                            Map parentNamespaceContext = XMLUtils.getNamespaceContext(inlineElement.getParent());\n                            Element rootElement = document.getRootElement();\n                            for (Iterator k = parentNamespaceContext.keySet().iterator(); k.hasNext();) {\n                                String prefix = (String) k.next();\n                                String uri = (String) parentNamespaceContext.get(prefix);\n                                rootElement.addNamespace(prefix, uri);\n                            }\n                        } else if (inlineNode instanceof Document) {\n                            document = (Document) inlineNode;\n                        } else {\n                            throw new OXFException(\"Invalid type for inline document: \" + inlineNode.getClass().getName());\n                        }\n\n                        // Create generator for the static text\n                        Processor documentProcessor = PipelineUtils.createDOMGenerator(document, astPipeline.getValidity());\n\n                        ProcessorOutput pout = documentProcessor.createOutput(OUTPUT_DATA);\n                        pin = processor.createInput(input.getName());\n\n                        // NOTE: We should have a customizable mechanism to do this\n                        final String jndiName = \"oxf/processor/xslt-2.0\";\n                        // Experimental, doesn't work yet within XSLT configs!\n                        // To solve this, maybe a flag specifying that we are\n                        // using a template should be explicitly specified on\n                        // the input?\n                        if (false && XPathUtils.selectBooleanValue(document, \"/*/@*[local-name() = 'version' and namespace-uri() = 'http://www.w3.org/1999/XSL/Transform'] = '2.0'\").booleanValue()) {\n                            // It is embedded XSLT 2.0: connect through XSLT transformer\n\n                            ProcessorFactory processorFactory = ProcessorFactoryRegistry.lookup(jndiName);\n                            if (processorFactory == null) {\n                                throw new ValidationException(\"Cannot find processor factory with JNDI name \\\"\"\n                                        + processorCall.getURI() + \"\\\"\", locationData);\n                            }\n                            Processor templateProcessor = processorFactory.createInstance(context);\n\n                            // Set info on processor\n                            //processor.setId(processorCall.getId()); // what id, if any?\n                            templateProcessor.setLocationData(locationData);\n\n                            // Connect config input\n                            ProcessorInput configInput = templateProcessor.createInput(INPUT_CONFIG);\n                            pout.setInput(configInput);\n                            configInput.setOutput(pout);\n\n                            // Connect data input (for now, a null document)\n                            ProcessorInput dataInput = templateProcessor.createInput(INPUT_DATA);\n                            Processor nullGenerator = PipelineUtils.createDOMGenerator(XMLUtils.NULL_DOCUMENT, astPipeline.getValidity());\n                            ProcessorOutput nullGeneratorOutput = nullGenerator.createOutput(OUTPUT_DATA);\n                            nullGeneratorOutput.setInput(dataInput);\n                            dataInput.setOutput(nullGeneratorOutput);\n\n                            // Connect data output\n                            ProcessorOutput templateProcessorOutput = templateProcessor.createOutput(OUTPUT_DATA);\n                            templateProcessorOutput.setInput(pin);\n                            pin.setOutput(templateProcessorOutput);\n\n                        } else {\n                            // It is regular static text: connect directly\n                            pout.setInput(pin);\n                            pin.setOutput(pout);\n                        }\n                    }\n                    setDebugAndSchema(pin, input);\n                    setBreakpointKey(pin, input);\n                }\n\n            } else if (statement instanceof ASTChoose) {\n\n                // Instantiate processor\n                ASTChoose choose = (ASTChoose) statement;\n                AbstractProcessor chooseAbstractProcessor = new AbstractChooseProcessor(choose, astPipeline.getValidity());\n                ConcreteChooseProcessor chooseProcessor =\n                        (ConcreteChooseProcessor) chooseAbstractProcessor.createInstance(context);\n                processor = chooseProcessor;\n\n                // Connect special $data input (document on which the decision is made, or iterated on)\n                ProcessorInput pin = block.connectProcessorToHref(choose.getNode(), processor,\n                        AbstractChooseProcessor.CHOOSE_DATA_INPUT, choose.getHref());\n                setDebugAndSchema(pin, (ASTDebugSchema) statement);\n\n                // Go through inputs/outputs and connect to the rest of the pipeline\n                for (Iterator j = processor.getInputsInfo().iterator(); j.hasNext();) {\n                    // We reference a previously declared output\n                    String inputName = ((ProcessorInputOutputInfo) j.next()).getName();\n                    if (!inputName.equals(AbstractChooseProcessor.CHOOSE_DATA_INPUT)) {\n                        ASTHrefId hrefId = new ASTHrefId();\n                        hrefId.setId(inputName);\n                        block.connectProcessorToHref(choose.getNode(), processor, inputName, hrefId);\n                    }\n                }\n                for (Iterator j = processor.getOutputsInfo().iterator(); j.hasNext();) {\n                    String outputName = ((ProcessorInputOutputInfo) j.next()).getName();\n                    foundOutput = true;\n                    ProcessorOutput pout = processor.createOutput(outputName);\n                    if (chooseProcessor.getOutputsById().contains(outputName))\n                        block.declareOutput(choose.getNode(), outputName, pout);\n                    if (chooseProcessor.getOutputsByParamRef().contains(outputName))\n                        block.connectProcessorToBottomInput(choose.getNode(), outputName, outputName, pout);\n                }\n\n            } else if (statement instanceof ASTForEach) {\n\n                // Instantiate processor\n                ASTForEach forEach = (ASTForEach) statement;\n                LocationData forEachLocationData = forEach.getLocationData();\n                AbstractProcessor forEachAbstractProcessor = new ForEachProcessor(forEach, astPipeline.getValidity());\n                ForEachProcessor.ConcreteForEachProcessor forEachProcessor =\n                        (ForEachProcessor.ConcreteForEachProcessor) forEachAbstractProcessor.createInstance(context);\n                processor = forEachProcessor;\n\n                // Connect special $data input (document on which the decision is made, or iterated on)\n                ProcessorInput pin = block.connectProcessorToHref(forEach.getNode(), processor,\n                        ForEachProcessor.FOR_EACH_DATA_INPUT, forEach.getHref());\n                setDebugAndSchema(pin, forEachLocationData,\n                        forEach.getInputSchemaUri(), forEach.getInputSchemaHref(), forEach.getInputDebug());\n\n                // Go through inputs and connect to the rest of the pipeline\n                for (Iterator j = processor.getInputsInfo().iterator(); j.hasNext();) {\n                    // We reference a previously declared output\n                    String inputName = ((ProcessorInputOutputInfo) j.next()).getName();\n                    if (!inputName.equals(ForEachProcessor.FOR_EACH_DATA_INPUT)) {\n                        ASTHrefId hrefId = new ASTHrefId();\n                        hrefId.setId(inputName);\n                        block.connectProcessorToHref(forEach.getNode(), processor, inputName, hrefId);\n                    }\n                }\n\n                // Connect output\n                String outputName = forEach.getId() != null ? forEach.getId() : forEach.getRef();\n                if (outputName != null) {\n                    foundOutput = true;\n                    ProcessorOutput forEachOutput = processor.createOutput(outputName);\n                    if (forEach.getId() != null)\n                        block.declareOutput(forEach.getNode(), forEach.getId(), forEachOutput);\n                    if (forEach.getRef() != null)\n                        block.connectProcessorToBottomInput(forEach.getNode(), forEach.getId(), forEach.getRef(), forEachOutput);\n                    setDebugAndSchema(processor.getOutputByName(outputName), forEachLocationData,\n                            forEach.getOutputSchemaUri(), forEach.getOutputSchemaHref(), forEach.getOutputDebug());\n                }\n            }\n\n            // Remember all processors and processor with no output (need to be started)\n            if (processor != null) {\n                config.addProcessor(processor);\n                if (!foundOutput) {\n                    config.addProcessorToStart(processor);\n                }\n            }\n        }\n\n        // Check that all bottom inputs are connected\n        for (Iterator i = astPipeline.getParams().iterator(); i.hasNext();) {\n            ASTParam param = (ASTParam) i.next();\n            if (param.getType() == ASTParam.OUTPUT) {\n                if (! block.isBottomInputConnected(param.getName()))\n                    throw new ValidationException(\"No processor in pipeline is connected to pipeline output '\"\n                            + param.getName() + \"'\", param.getLocationData());\n            }\n        }\n        \n        // Add processors created for connection reasons\n        for (Iterator i = block.getCreatedProcessors().iterator(); i.hasNext();)\n            config.addProcessor((Processor) i.next());\n\n        return config;\n    }","commit_id":"70ba272c66dc4db6c3f808e9a61f1d39721591a3","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public MyStatusPanel(String id, UserProfile userProfile) {\n\t\tsuper(id);\n\t\t\n\t\tlog.debug(\"MyStatusPanel()\");\n\t\n\t\t//get info\n\t\tfinal String displayName = userProfile.getDisplayName();\n\t\tfinal String userId = userProfile.getUserUuid();\n\t\t\n\t\t//if superUser and proxied, can't update\n\t\tboolean editable = true;\n\t\tif(sakaiProxy.isSuperUserAndProxiedToUser(userId)) {\n\t\t\teditable = false;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t//name\n\t\tLabel profileName = new Label(\"profileName\", displayName);\n\t\tadd(profileName);\n\t\t\n\t\t//status component\n\t\tstatus = new ProfileStatusRenderer(\"status\", userId, null, \"tiny\");\n\t\tstatus.setOutputMarkupId(true);\n\t\tadd(status);\n\t\t\n\t\tWebMarkupContainer statusFormContainer = new WebMarkupContainer(\"statusFormContainer\");\n\t\t\n\t\t\t\t\n\t\t//setup SimpleText object to back the single form field \n\t\tStringModel stringModel = new StringModel();\n\t\t\t\t\n\t\t//status form\n\t\tForm form = new Form(\"form\", new Model(stringModel));\n\t\tform.setOutputMarkupId(true);\n        \t\t\n\t\t//status field\n\t\tfinal TextField statusField = new TextField(\"message\", new PropertyModel(stringModel, \"string\"));\n        statusField.setOutputMarkupPlaceholderTag(true);\n        form.add(statusField);\n        \n        //link the status textfield field with the focus/blur function via this dynamic js \n        //also link with counter\n\t\tStringHeaderContributor statusJavascript = new StringHeaderContributor(\n\t\t\t\t\"<script type=\\\"text/javascript\\\">\" +\n\t\t\t\t\t\"$(document).ready( function(){\" +\n\t\t\t\t\t\"autoFill('#\" + statusField.getMarkupId() + \"', '\" + defaultStatus + \"');\" +\n\t\t\t\t\t\"countChars('#\" + statusField.getMarkupId() + \"');\" +\n\t\t\t\t\t\"});\" +\n\t\t\t\t\"<\/script>\");\n\t\tadd(statusJavascript);\n\n        \n        //clear link\n\t\tfinal AjaxFallbackLink clearLink = new AjaxFallbackLink(\"clearLink\") {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void onClick(AjaxRequestTarget target) {\n\t\t\t\t//clear status, hide and repaint\n\t\t\t\tif(statusLogic.clearUserStatus(userId)) {\n\t\t\t\t\tstatus.setVisible(false); //hide status\n\t\t\t\t\tthis.setVisible(false); //hide clear link\n\t\t\t\t\ttarget.addComponent(status);\n\t\t\t\t\ttarget.addComponent(this);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tclearLink.setOutputMarkupPlaceholderTag(true);\n\t\tclearLink.add(new Label(\"clearLabel\",new ResourceModel(\"link.status.clear\")));\n\t\n\t\t//set visibility of clear link based on status and if it's editable\n\t\tif(!status.isVisible() || !editable) {\n\t\t\tclearLink.setVisible(false);\n\t\t}\n\t\tadd(clearLink);\n        \n        \n        \n        \n        \n        //submit button\n\t\tIndicatingAjaxButton submitButton = new IndicatingAjaxButton(\"submit\", form) {\n\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tprotected void onSubmit(AjaxRequestTarget target, Form form) {\n\t\t\t\t\n\t\t\t\t//get the backing model\n        \t\tStringModel stringModel = (StringModel) form.getModelObject();\n\t\t\t\t\n\t\t\t\t//get userId from sakaiProxy\n\t\t\t\tString userId = sakaiProxy.getCurrentUserId();\n\t\t\t\t\n\t\t\t\t//get the status. if its the default text, do not update, although we should clear the model\n\t\t\t\tString statusMessage = StringUtils.trim(stringModel.getString());\n\t\t\t\tif(StringUtils.isBlank(statusMessage) || StringUtils.equals(statusMessage, defaultStatus)) {\n\t\t\t\t\tlog.warn(\"Status for userId: \" + userId + \" was not updated because they didn't enter anything.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t//save status from userProfile\n\t\t\t\tif(statusLogic.setUserStatus(userId, statusMessage)) {\n\t\t\t\t\tlog.info(\"Saved status for: \" + userId);\n\t\t\t\t\t\n\t\t\t\t\t//post update event\n\t\t\t\t\tsakaiProxy.postEvent(ProfileConstants.EVENT_STATUS_UPDATE, \"/profile/\"+userId, true);\n\n\t\t\t\t\t//update twitter\n\t\t\t\t\texternalIntegrationLogic.sendMessageToTwitter(userId, statusMessage);\n\t\t\t\t\t\n\t\t\t\t\t//repaint status component\n\t\t\t\t\tProfileStatusRenderer newStatus = new ProfileStatusRenderer(\"status\", userId, null, \"tiny\");\n\t\t\t\t\tnewStatus.setOutputMarkupId(true);\n\t\t\t\t\tstatus.replaceWith(newStatus);\n\t\t\t\t\tnewStatus.setVisible(true);\n\t\t\t\t\t\n\t\t\t\t\t//also show the clear link\n\t\t\t\t\tclearLink.setVisible(true);\n\t\t\t\t\t\n\t\t\t\t\tif(target != null) {\n\t\t\t\t\t\ttarget.addComponent(newStatus);\n\t\t\t\t\t\ttarget.addComponent(clearLink);\n\t\t\t\t\t\tstatus=newStatus; //update reference\n\t\t\t\t\t\t\n\t\t\t\t\t\t//reset the field\n\t\t\t\t\t\ttarget.appendJavascript(\"autoFill('#\" + statusField.getMarkupId() + \"', '\" + defaultStatus + \"');\");\n\t\t\t\t\t\t\n\t\t\t\t\t\t//reset the counter\n\t\t\t\t\t\ttarget.appendJavascript(\"countChars('#\" + statusField.getMarkupId() + \"');\");\n\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\tlog.error(\"Couldn't save status for: \" + userId);\n\t\t\t\t\tString js = \"alert('Failed to save status. If the problem persists, contact your system administrator.');\";\n\t\t\t\t\ttarget.prependJavascript(js);\t\n\t\t\t\t}\n\t\t\t\t\n            }\n\t\t};\n\t\tsubmitButton.setModel(new ResourceModel(\"button.sayit\"));\n\t\tform.add(submitButton);\n\t\t\n        //add form to container\n\t\tstatusFormContainer.add(form);\n\t\t\n\t\t//if not editable, hide the entire form\n\t\tif(!editable) {\n\t\t\tstatusFormContainer.setVisible(false);\n\t\t}\n\t\t\n\t\t\n\t\tadd(statusFormContainer);\n\t\t\n\t}","id":65312,"modified_method":"public MyStatusPanel(String id, UserProfile userProfile) {\n\t\tsuper(id);\n\t\t\n\t\tlog.debug(\"MyStatusPanel()\");\n\t\n\t\t//get info\n\t\tfinal String displayName = userProfile.getDisplayName();\n\t\tfinal String userId = userProfile.getUserUuid();\n\t\t\n\t\t//if superUser and proxied, can't update\n\t\tboolean editable = true;\n\t\tif(sakaiProxy.isSuperUserAndProxiedToUser(userId)) {\n\t\t\teditable = false;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t//name\n\t\tLabel profileName = new Label(\"profileName\", displayName);\n\t\tadd(profileName);\n\t\t\n\t\t//status component\n\t\tstatus = new ProfileStatusRenderer(\"status\", userId, null, \"tiny\");\n\t\tstatus.setOutputMarkupId(true);\n\t\tadd(status);\n\t\t\n\t\tWebMarkupContainer statusFormContainer = new WebMarkupContainer(\"statusFormContainer\");\n\t\t\n\t\t\t\t\n\t\t//setup SimpleText object to back the single form field \n\t\tStringModel stringModel = new StringModel();\n\t\t\t\t\n\t\t//status form\n\t\tForm form = new Form(\"form\", new Model(stringModel));\n\t\tform.setOutputMarkupId(true);\n        \t\t\n\t\t//status field\n\t\tfinal TextField statusField = new TextField(\"message\", new PropertyModel(stringModel, \"string\"));\n        statusField.setOutputMarkupPlaceholderTag(true);\n        form.add(statusField);\n        \n        //link the status textfield field with the focus/blur function via this dynamic js \n        //also link with counter\n\t\tStringHeaderContributor statusJavascript = new StringHeaderContributor(\n\t\t\t\t\"<script type=\\\"text/javascript\\\">\" +\n\t\t\t\t\t\"$(document).ready( function(){\" +\n\t\t\t\t\t\"autoFill('#\" + statusField.getMarkupId() + \"', '\" + defaultStatus + \"');\" +\n\t\t\t\t\t\"countChars('#\" + statusField.getMarkupId() + \"');\" +\n\t\t\t\t\t\"});\" +\n\t\t\t\t\"<\/script>\");\n\t\tadd(statusJavascript);\n\n        \n        //clear link\n\t\tfinal AjaxFallbackLink clearLink = new AjaxFallbackLink(\"clearLink\") {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void onClick(AjaxRequestTarget target) {\n\t\t\t\t//clear status, hide and repaint\n\t\t\t\tif(statusLogic.clearUserStatus(userId)) {\n\t\t\t\t\tstatus.setVisible(false); //hide status\n\t\t\t\t\tthis.setVisible(false); //hide clear link\n\t\t\t\t\ttarget.addComponent(status);\n\t\t\t\t\ttarget.addComponent(this);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tclearLink.setOutputMarkupPlaceholderTag(true);\n\t\tclearLink.add(new Label(\"clearLabel\",new ResourceModel(\"link.status.clear\")));\n\t\n\t\t//set visibility of clear link based on status and if it's editable\n\t\tif(!status.isVisible() || !editable) {\n\t\t\tclearLink.setVisible(false);\n\t\t}\n\t\tadd(clearLink);\n        \n        \n        \n        \n        \n        //submit button\n\t\tIndicatingAjaxButton submitButton = new IndicatingAjaxButton(\"submit\", form) {\n\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tprotected void onSubmit(AjaxRequestTarget target, Form form) {\n\t\t\t\t\n\t\t\t\t//get the backing model\n        \t\tStringModel stringModel = (StringModel) form.getModelObject();\n\t\t\t\t\n\t\t\t\t//get userId from sakaiProxy\n\t\t\t\tString userId = sakaiProxy.getCurrentUserId();\n\t\t\t\t\n\t\t\t\t//get the status. if its the default text, do not update, although we should clear the model\n\t\t\t\tString statusMessage = StringUtils.trim(stringModel.getString());\n\t\t\t\tif(StringUtils.isBlank(statusMessage) || StringUtils.equals(statusMessage, defaultStatus)) {\n\t\t\t\t\tlog.warn(\"Status for userId: \" + userId + \" was not updated because they didn't enter anything.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t//save status from userProfile\n\t\t\t\tif(statusLogic.setUserStatus(userId, statusMessage)) {\n\t\t\t\t\tlog.info(\"Saved status for: \" + userId);\n\t\t\t\t\t\n\t\t\t\t\t//post update event\n\t\t\t\t\tsakaiProxy.postEvent(ProfileConstants.EVENT_STATUS_UPDATE, \"/profile/\"+userId, true);\n\n\t\t\t\t\t//update twitter\n\t\t\t\t\texternalIntegrationLogic.sendMessageToTwitter(userId, statusMessage);\n\t\t\t\t\t\n\t\t\t\t\t// post to walls if wall enabled\n\t\t\t\t\tif (true == sakaiProxy.isWallEnabledGlobally()) {\n\t\t\t\t\t\twallLogic.addStatusToWalls(statusMessage, sakaiProxy.getCurrentUserId());\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//repaint status component\n\t\t\t\t\tProfileStatusRenderer newStatus = new ProfileStatusRenderer(\"status\", userId, null, \"tiny\");\n\t\t\t\t\tnewStatus.setOutputMarkupId(true);\n\t\t\t\t\tstatus.replaceWith(newStatus);\n\t\t\t\t\tnewStatus.setVisible(true);\n\t\t\t\t\t\n\t\t\t\t\t//also show the clear link\n\t\t\t\t\tclearLink.setVisible(true);\n\t\t\t\t\t\n\t\t\t\t\tif(target != null) {\n\t\t\t\t\t\ttarget.addComponent(newStatus);\n\t\t\t\t\t\ttarget.addComponent(clearLink);\n\t\t\t\t\t\tstatus=newStatus; //update reference\n\t\t\t\t\t\t\n\t\t\t\t\t\t//reset the field\n\t\t\t\t\t\ttarget.appendJavascript(\"autoFill('#\" + statusField.getMarkupId() + \"', '\" + defaultStatus + \"');\");\n\t\t\t\t\t\t\n\t\t\t\t\t\t//reset the counter\n\t\t\t\t\t\ttarget.appendJavascript(\"countChars('#\" + statusField.getMarkupId() + \"');\");\n\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\tlog.error(\"Couldn't save status for: \" + userId);\n\t\t\t\t\tString js = \"alert('Failed to save status. If the problem persists, contact your system administrator.');\";\n\t\t\t\t\ttarget.prependJavascript(js);\t\n\t\t\t\t}\n\t\t\t\t\n            }\n\t\t};\n\t\tsubmitButton.setModel(new ResourceModel(\"button.sayit\"));\n\t\tform.add(submitButton);\n\t\t\n        //add form to container\n\t\tstatusFormContainer.add(form);\n\t\t\n\t\t//if not editable, hide the entire form\n\t\tif(!editable) {\n\t\t\tstatusFormContainer.setVisible(false);\n\t\t}\n\t\t\n\t\t\n\t\tadd(statusFormContainer);\n\t\t\n\t}","commit_id":"4f8bea6fd5b17545feae3f4f4943ba87ccdb4b96","url":"https://github.com/sakaiproject/sakai"},{"original_method":"private void renderWallPanel(final String userUuid) {\n\t\t// container which wraps list\n\t\tfinal WebMarkupContainer wallItemsContainer = new WebMarkupContainer(\n\t\t\t\t\"wallItemsContainer\");\n\n\t\twallItemsContainer.setOutputMarkupId(true);\n\t\tadd(wallItemsContainer);\n\t\t\n\t\tWallItem wallItem = new WallItem();\n\t\t// always post to my wall as current user, to ensure super users cannot\n\t\t// make posts as other users\n\t\twallItem.setCreatorUuid(sakaiProxy.getCurrentUserId());\n\t\twallItem.setType(ProfileConstants.WALL_ITEM_TYPE_POST);\n\t\t\n\t\t// form for posting to my wall\n\t\tForm<WallItem> form = new Form<WallItem>(\"myWallPostForm\", new Model<WallItem>(wallItem));\n\t\tform.setOutputMarkupId(true);\n\t\tadd(form);\n\t\t\n\t\t// form submit feedback\n\t\tfinal Label formFeedback = new Label(\"formFeedback\");\n\t\tformFeedback.setOutputMarkupPlaceholderTag(true);\n\t\tform.add(formFeedback);\n\t\t\n        final FeedbackPanel feedback = new FeedbackPanel(\"feedback\");\n        feedback.setOutputMarkupId(true);\n        form.add(feedback);\n        \n        int[] filteredErrorLevels = new int[]{FeedbackMessage.ERROR};\n        feedback.setFilter(new ErrorLevelsFeedbackMessageFilter(filteredErrorLevels));\n\t\t\n\t\t// container for posting to my wall\n\t\tWebMarkupContainer myWallPostContainer = new WebMarkupContainer(\"myWallPostContainer\");\n\t\tTextArea<String> myWallPost = new TextArea<String>(\"myWallPost\", new PropertyModel<String>(wallItem, \"text\"));\n\t\tmyWallPost.add(new TinyMceBehavior(new TextareaTinyMceSettings(TinyMCESettings.Align.left)));\n\t\t\n\t\tmyWallPostContainer.add(myWallPost);\n\t\t\n\t\tform.add(myWallPostContainer);\n\t\t\n\t\tIndicatingAjaxButton submitButton = new IndicatingAjaxButton(\"myWallPostSubmit\", form) {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tprotected void onSubmit(AjaxRequestTarget target, Form form) {\n\t\t\t\t\n\t\t\t\tif (false == save(form, userUuid)) {\n\t\t\t\t\tformFeedback.setDefaultModel(new ResourceModel(\"error.wall.post.failed\"));\n\t\t\t\t\tformFeedback.add(new AttributeModifier(\"class\", true, new Model<String>(\"alertMessage\")));\n\t\t\t\t\ttarget.addComponent(formFeedback);\n\t\t\t\t} else {\n\t\t\t\t\tsetResponsePage(new MyProfile(userUuid));\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tsubmitButton.setModel(new ResourceModel(\"button.wall.post\"));\n\t\tsubmitButton.add(new TinyMceAjaxSubmitModifier());\n\t\tmyWallPostContainer.add(submitButton);\n\t\t\n\t\tWallItemDataProvider provider = new WallItemDataProvider(userUuid);\n\n\t\t// if no wall items, display a message\n\t\tif (0 == provider.size()) {\n\t\t\tadd(new Label(\"wallInformationMessage\",\n\t\t\t\t\tnew ResourceModel(\"text.wall.no.items\")));\n\t\t} else {\n\t\t\t// blank label when there are items to display\n\t\t\tadd(new Label(\"wallInformationMessage\"));\n\t\t}\n\n\t\t// TODO haven't decided whether to add a navigator yet\n\n\t\tDataView<WallItem> wallItemsDataView = new DataView<WallItem>(\n\t\t\t\t\"wallItems\", provider) {\n\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tprotected void populateItem(Item<WallItem> item) {\n\n\t\t\t\tWallItem wallItem = (WallItem) item.getDefaultModelObject();\n\n\t\t\t\titem.add(new WallItemPanel(\"wallItemPanel\", userUuid, wallItem));\n\t\t\t}\n\t\t};\n\n\t\twallItemsDataView.setOutputMarkupId(true);\n\t\t// wallItemsDataView.setItemsPerPage(10);\n\n\t\twallItemsContainer.add(wallItemsDataView);\n\t}","id":65313,"modified_method":"private void renderWallPanel(final String userUuid) {\n\t\t\n\t\tfinal String currentUserId = sakaiProxy.getCurrentUserId();\n\t\t\n\t\t// container which wraps list\n\t\tfinal WebMarkupContainer wallItemsContainer = new WebMarkupContainer(\n\t\t\t\t\"wallItemsContainer\");\n\n\t\twallItemsContainer.setOutputMarkupId(true);\n\t\tadd(wallItemsContainer);\n\t\t\n\t\tWallItem wallItem = new WallItem();\n\t\t// always post to my wall as current user, to ensure super users cannot\n\t\t// make posts as other users\n\t\twallItem.setCreatorUuid(sakaiProxy.getCurrentUserId());\n\t\twallItem.setType(ProfileConstants.WALL_ITEM_TYPE_POST);\n\t\t\n\t\t// form for posting to my wall\n\t\tForm<WallItem> form = new Form<WallItem>(\"myWallPostForm\", new Model<WallItem>(wallItem));\n\t\tform.setOutputMarkupId(true);\n\t\tadd(form);\n\t\t\n\t\t// form submit feedback\n\t\tfinal Label formFeedback = new Label(\"formFeedback\");\n\t\tformFeedback.setOutputMarkupPlaceholderTag(true);\n\t\tform.add(formFeedback);\n\t\t\n        final FeedbackPanel feedback = new FeedbackPanel(\"feedback\");\n        feedback.setOutputMarkupId(true);\n        form.add(feedback);\n        \n        int[] filteredErrorLevels = new int[]{FeedbackMessage.ERROR};\n        feedback.setFilter(new ErrorLevelsFeedbackMessageFilter(filteredErrorLevels));\n\t\t\n\t\t// container for posting to my wall\n\t\tWebMarkupContainer myWallPostContainer = new WebMarkupContainer(\"myWallPostContainer\");\n\t\tTextArea<String> myWallPost = new TextArea<String>(\"myWallPost\", new PropertyModel<String>(wallItem, \"text\"));\n\t\tmyWallPost.add(new TinyMceBehavior(new TextareaTinyMceSettings(TinyMCESettings.Align.left)));\n\t\t\n\t\tmyWallPostContainer.add(myWallPost);\n\t\t\n\t\tform.add(myWallPostContainer);\n\t\t\n\t\tIndicatingAjaxButton submitButton = new IndicatingAjaxButton(\"myWallPostSubmit\", form) {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tprotected void onSubmit(AjaxRequestTarget target, Form form) {\n\t\t\t\t\n\t\t\t\tif (false == save(form, userUuid)) {\n\t\t\t\t\tformFeedback.setDefaultModel(new ResourceModel(\"error.wall.post.failed\"));\n\t\t\t\t\tformFeedback.add(new AttributeModifier(\"class\", true, new Model<String>(\"alertMessage\")));\n\t\t\t\t\ttarget.addComponent(formFeedback);\n\t\t\t\t} else {\n\t\t\t\t\tsetResponsePage(new MyProfile(userUuid));\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tsubmitButton.setModel(new ResourceModel(\"button.wall.post\"));\n\t\tsubmitButton.add(new TinyMceAjaxSubmitModifier());\n\t\tmyWallPostContainer.add(submitButton);\n\t\t\n\t\tWallItemDataProvider provider = new WallItemDataProvider(userUuid);\n\n\t\t// if no wall items, display a message\n\t\tif (0 == provider.size()) {\n\t\t\tadd(new Label(\"wallInformationMessage\",\n\t\t\t\t\tnew ResourceModel(\"text.wall.no.items\")));\n\t\t} else {\n\t\t\t// blank label when there are items to display\n\t\t\tadd(new Label(\"wallInformationMessage\"));\n\t\t}\n\n\t\t// TODO haven't decided whether to add a navigator yet\n\n\t\tDataView<WallItem> wallItemsDataView = new DataView<WallItem>(\n\t\t\t\t\"wallItems\", provider) {\n\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tprotected void populateItem(Item<WallItem> item) {\n\n\t\t\t\tWallItem wallItem = (WallItem) item.getDefaultModelObject();\n\n\t\t\t\tif (ProfileConstants.WALL_ITEM_TYPE_STATUS == wallItem.getType()) {\n\t\t\t\t\t// if viewing own wall, or admin user\n\t\t\t\t\tif (wallItem.getCreatorUuid().equals(userUuid) || sakaiProxy.isSuperUser()) {\n\t\t\t\t\t\titem.add(new WallItemPanel(\"wallItemPanel\", userUuid, wallItem));\n\t\t\t\t\t}\n\t\t\t\t\t// else check connection status privacy\n\t\t\t\t\telse if (privacyLogic.isUserXStatusVisibleByUserY(\n\t\t\t\t\t\t\tuserUuid, currentUserId, connectionsLogic\n\t\t\t\t\t\t\t\t\t.isUserXFriendOfUserY(userUuid,\n\t\t\t\t\t\t\t\t\t\t\tcurrentUserId))) {\n\t\t\t\t\t\t\n\t\t\t\t\t\titem.add(new WallItemPanel(\"wallItemPanel\", userUuid, wallItem));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\titem.add(new WallItemPanel(\"wallItemPanel\", userUuid, wallItem));\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\twallItemsDataView.setOutputMarkupId(true);\n\t\t// wallItemsDataView.setItemsPerPage(10);\n\n\t\twallItemsContainer.add(wallItemsDataView);\n\t}","commit_id":"4f8bea6fd5b17545feae3f4f4943ba87ccdb4b96","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n \t * {@inheritDoc}\n \t */\n\tpublic boolean isEmailEnabledForThisMessageType(final String userId, final int messageType) {\n\t\t\n\t\t//get preferences record for this user\n    \tProfilePreferences profilePreferences = getPreferencesRecordForUser(userId);\n    \t\n    \t//if none, return whatever the flag is set as by default\n    \tif(profilePreferences == null) {\n    \t\treturn ProfileConstants.DEFAULT_EMAIL_NOTIFICATION_SETTING;\n    \t}\n    \t\n    \t//if its a request and requests enabled, true\n    \tif(messageType == ProfileConstants.EMAIL_NOTIFICATION_REQUEST && profilePreferences.isRequestEmailEnabled()) {\n    \t\treturn true;\n    \t}\n    \t\n    \t//if its a confirm and confirms enabled, true\n    \tif(messageType == ProfileConstants.EMAIL_NOTIFICATION_CONFIRM && profilePreferences.isConfirmEmailEnabled()) {\n    \t\treturn true;\n    \t}\n    \t\n    \t//if its a new message and new messages enabled, true\n    \tif(messageType == ProfileConstants.EMAIL_NOTIFICATION_MESSAGE_NEW && profilePreferences.isMessageNewEmailEnabled()) {\n    \t\treturn true;\n    \t}\n    \t\n    \t//if its a reply to a message message and replies enabled, true\n    \tif(messageType == ProfileConstants.EMAIL_NOTIFICATION_MESSAGE_REPLY && profilePreferences.isMessageReplyEmailEnabled()) {\n    \t\treturn true;\n    \t}\n    \t\n    \t// may split these later, but for now single preference controls wall emails\n    \tif((messageType == ProfileConstants.EMAIL_NOTIFICATION_WALL_EVENT_NEW || \n    \t\t\tmessageType == ProfileConstants.EMAIL_NOTIFICATION_WALL_POST_MY_NEW ||\n    \t\t\tmessageType == ProfileConstants.EMAIL_NOTIFICATION_WALL_POST_CONNECTION_NEW)\n    \t\t\t&& profilePreferences.isWallItemNewEmailEnabled()) {\n    \t\treturn true;\n    \t}\n    \t\n    \t//add more cases here as need progresses\n    \t\n    \t//no notification for this message type, return false \t\n    \tlog.debug(\"ProfileLogic.isEmailEnabledForThisMessageType. False for userId: \" + userId + \", messageType: \" + messageType);  \n\n    \treturn false;\n\t}","id":65314,"modified_method":"/**\n \t * {@inheritDoc}\n \t */\n\tpublic boolean isEmailEnabledForThisMessageType(final String userId, final int messageType) {\n\t\t\n\t\t//get preferences record for this user\n    \tProfilePreferences profilePreferences = getPreferencesRecordForUser(userId);\n    \t\n    \t//if none, return whatever the flag is set as by default\n    \tif(profilePreferences == null) {\n    \t\treturn ProfileConstants.DEFAULT_EMAIL_NOTIFICATION_SETTING;\n    \t}\n    \t\n    \t//if its a request and requests enabled, true\n    \tif(messageType == ProfileConstants.EMAIL_NOTIFICATION_REQUEST && profilePreferences.isRequestEmailEnabled()) {\n    \t\treturn true;\n    \t}\n    \t\n    \t//if its a confirm and confirms enabled, true\n    \tif(messageType == ProfileConstants.EMAIL_NOTIFICATION_CONFIRM && profilePreferences.isConfirmEmailEnabled()) {\n    \t\treturn true;\n    \t}\n    \t\n    \t//if its a new message and new messages enabled, true\n    \tif(messageType == ProfileConstants.EMAIL_NOTIFICATION_MESSAGE_NEW && profilePreferences.isMessageNewEmailEnabled()) {\n    \t\treturn true;\n    \t}\n    \t\n    \t//if its a reply to a message message and replies enabled, true\n    \tif(messageType == ProfileConstants.EMAIL_NOTIFICATION_MESSAGE_REPLY && profilePreferences.isMessageReplyEmailEnabled()) {\n    \t\treturn true;\n    \t}\n    \t\n    \t// may split these later, but for now single preference controls wall emails\n    \tif((messageType == ProfileConstants.EMAIL_NOTIFICATION_WALL_EVENT_NEW ||\n    \t\t\tmessageType == ProfileConstants.EMAIL_NOTIFICATION_WALL_STATUS_NEW ||\n    \t\t\tmessageType == ProfileConstants.EMAIL_NOTIFICATION_WALL_POST_MY_NEW ||\n    \t\t\tmessageType == ProfileConstants.EMAIL_NOTIFICATION_WALL_POST_CONNECTION_NEW)\n    \t\t\t&& profilePreferences.isWallItemNewEmailEnabled()) {\n    \t\treturn true;\n    \t}\n    \t\n    \t//add more cases here as need progresses\n    \t\n    \t//no notification for this message type, return false \t\n    \tlog.debug(\"ProfileLogic.isEmailEnabledForThisMessageType. False for userId: \" + userId + \", messageType: \" + messageType);  \n\n    \treturn false;\n\t}","commit_id":"4f8bea6fd5b17545feae3f4f4943ba87ccdb4b96","url":"https://github.com/sakaiproject/sakai"},{"original_method":"private void sendWallNotificationEmailToConnections(List<String> toUuids, final String fromUuid, final int messageType) {\n\t\t\n\t\t// create the map of replacement values for this email template\n\t\tMap<String, String> replacementValues = new HashMap<String, String>();\n\t\treplacementValues.put(\"senderDisplayName\", sakaiProxy.getUserDisplayName(fromUuid));\n\t\treplacementValues.put(\"localSakaiName\", sakaiProxy.getServiceName());\n\t\treplacementValues.put(\"localSakaiUrl\", sakaiProxy.getPortalUrl());\n\t\treplacementValues.put(\"toolName\", sakaiProxy.getCurrentToolTitle());\n\t\t\n\t\tString emailTemplateKey = null;\n\t\t\n\t\tif (ProfileConstants.EMAIL_NOTIFICATION_WALL_EVENT_NEW == messageType) {\n\t\t\temailTemplateKey = ProfileConstants.EMAIL_TEMPLATE_KEY_WALL_EVENT_NEW;\n\t\t\t\n\t\t\treplacementValues.put(\"profileLink\", linkLogic.getEntityLinkToProfileHome(fromUuid));\n\t\t\t\n\t\t} else if (ProfileConstants.EMAIL_NOTIFICATION_WALL_POST_CONNECTION_NEW == messageType) {\n\t\t\temailTemplateKey = ProfileConstants.EMAIL_TEMPLATE_KEY_WALL_POST_CONNECTION_NEW;\n\t\t\t\n\t\t\treplacementValues.put(\"profileLink\", linkLogic.getEntityLinkToProfileHome(fromUuid));\n\t\t}\n\t\t\n\t\tif (null != emailTemplateKey) {\n\t\t\tsakaiProxy.sendEmail(toUuids, emailTemplateKey, replacementValues);\n\t\t} else {\n\t\t\tlog.warn(\"not sending email, unknown message type for sendWallNotificationEmailToConnections: \" + messageType);\n\t\t}\n\t}","id":65315,"modified_method":"private void sendWallNotificationEmailToConnections(List<String> toUuids, final String fromUuid, final int messageType) {\n\t\t\n\t\t// create the map of replacement values for this email template\n\t\tMap<String, String> replacementValues = new HashMap<String, String>();\n\t\treplacementValues.put(\"senderDisplayName\", sakaiProxy.getUserDisplayName(fromUuid));\n\t\treplacementValues.put(\"senderProfileLink\", linkLogic.getEntityLinkToProfileHome(fromUuid));\n\t\treplacementValues.put(\"localSakaiName\", sakaiProxy.getServiceName());\n\t\treplacementValues.put(\"localSakaiUrl\", sakaiProxy.getPortalUrl());\n\t\treplacementValues.put(\"toolName\", sakaiProxy.getCurrentToolTitle());\n\t\t\n\t\tString emailTemplateKey = null;\n\t\t\n\t\tif (ProfileConstants.EMAIL_NOTIFICATION_WALL_EVENT_NEW == messageType) {\n\t\t\temailTemplateKey = ProfileConstants.EMAIL_TEMPLATE_KEY_WALL_EVENT_NEW;\t\t\t\n\t\t} else if (ProfileConstants.EMAIL_NOTIFICATION_WALL_POST_CONNECTION_NEW == messageType) {\n\t\t\temailTemplateKey = ProfileConstants.EMAIL_TEMPLATE_KEY_WALL_POST_CONNECTION_NEW;\n\t\t} else if (ProfileConstants.EMAIL_NOTIFICATION_WALL_STATUS_NEW == messageType) {\n\t\t\temailTemplateKey = ProfileConstants.EMAIL_TEMPLATE_KEY_WALL_STATUS_NEW;\n\t\t}\n\t\t\n\t\tif (null != emailTemplateKey) {\n\t\t\t// send individually to personalize email\n\t\t\tfor (String toUuid : toUuids) {\n\t\t\t\t// this just keeps overwriting profileLink with current toUuid\n\t\t\t\treplacementValues.put(\"displayName\", sakaiProxy.getUserDisplayName(toUuid));\n\t\t\t\treplacementValues.put(\"profileLink\", linkLogic.getEntityLinkToProfileHome(toUuid));\n\t\t\t\tsakaiProxy.sendEmail(toUuid, emailTemplateKey, replacementValues);\n\t\t\t}\n\t\t} else {\n\t\t\tlog.warn(\"not sending email, unknown message type for sendWallNotificationEmailToConnections: \" + messageType);\n\t\t}\n\t}","commit_id":"4f8bea6fd5b17545feae3f4f4943ba87ccdb4b96","url":"https://github.com/sakaiproject/sakai"},{"original_method":"private void sendWallNotificationEmailToUser(String toUuid,\n\t\t\tfinal String fromUuid, final int messageType) {\n\n\t\t// check if email preference enabled\n\t\tif (!preferencesLogic.isEmailEnabledForThisMessageType(toUuid,\n\t\t\t\tmessageType)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// create the map of replacement values for this email template\n\t\tMap<String, String> replacementValues = new HashMap<String, String>();\n\t\treplacementValues.put(\"senderDisplayName\", sakaiProxy.getUserDisplayName(fromUuid));\n\t\treplacementValues.put(\"localSakaiName\", sakaiProxy.getServiceName());\n\t\treplacementValues.put(\"localSakaiUrl\", sakaiProxy.getPortalUrl());\n\t\treplacementValues.put(\"toolName\", sakaiProxy.getCurrentToolTitle());\n\t\t\n\t\tString emailTemplateKey = null;\n\t\t\n\t\tif (ProfileConstants.EMAIL_NOTIFICATION_WALL_POST_MY_NEW == messageType) {\n\t\t\temailTemplateKey = ProfileConstants.EMAIL_TEMPLATE_KEY_WALL_POST_MY_NEW;\n\t\t\t\n\t\t\treplacementValues.put(\"profileLink\", linkLogic.getEntityLinkToProfileHome(toUuid));\n\t\t\t\n\t\t}\n\t\t\n\t\tif (null != emailTemplateKey) {\n\t\t\tsakaiProxy.sendEmail(toUuid, emailTemplateKey, replacementValues);\n\t\t} else {\n\t\t\tlog.warn(\"not sending email, unknown message type for sendWallNotificationEmailToUser: \" + messageType);\n\t\t}\n\n\t}","id":65316,"modified_method":"private void sendWallNotificationEmailToUser(String toUuid,\n\t\t\tfinal String fromUuid, final int messageType) {\n\n\t\t// check if email preference enabled\n\t\tif (!preferencesLogic.isEmailEnabledForThisMessageType(toUuid,\n\t\t\t\tmessageType)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// create the map of replacement values for this email template\n\t\tMap<String, String> replacementValues = new HashMap<String, String>();\n\t\treplacementValues.put(\"senderDisplayName\", sakaiProxy.getUserDisplayName(fromUuid));\n\t\treplacementValues.put(\"localSakaiName\", sakaiProxy.getServiceName());\n\t\treplacementValues.put(\"localSakaiUrl\", sakaiProxy.getPortalUrl());\n\t\treplacementValues.put(\"toolName\", sakaiProxy.getCurrentToolTitle());\n\t\t\n\t\tString emailTemplateKey = null;\n\t\t\n\t\tif (ProfileConstants.EMAIL_NOTIFICATION_WALL_POST_MY_NEW == messageType) {\n\t\t\temailTemplateKey = ProfileConstants.EMAIL_TEMPLATE_KEY_WALL_POST_MY_NEW;\n\t\t\t\n\t\t\treplacementValues.put(\"displayName\", sakaiProxy.getUserDisplayName(toUuid));\n\t\t\treplacementValues.put(\"profileLink\", linkLogic.getEntityLinkToProfileHome(toUuid));\n\t\t}\n\t\t\n\t\tif (null != emailTemplateKey) {\n\t\t\tsakaiProxy.sendEmail(toUuid, emailTemplateKey, replacementValues);\n\t\t} else {\n\t\t\tlog.warn(\"not sending email, unknown message type for sendWallNotificationEmailToUser: \" + messageType);\n\t\t}\n\n\t}","commit_id":"4f8bea6fd5b17545feae3f4f4943ba87ccdb4b96","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * {@inheritDoc}\n\t */\n\tpublic int getWallItemsCount(String userUuid, ProfilePrivacy privacy) {\n\n\t\tfinal String currentUserUuid = sakaiProxy.getCurrentUserId();\n\t\tif (null == sakaiProxy.getCurrentUserId()) {\n\t\t\tthrow new SecurityException(\n\t\t\t\t\t\"You must be logged in to make a request for a user's wall items.\");\n\t\t}\n\n\t\tif (null == privacy) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (false == StringUtils.equals(userUuid, currentUserUuid)) {\n\n\t\t\tif (false == privacyLogic.isUserXWallVisibleByUserY(userUuid,\n\t\t\t\t\tprivacy, currentUserUuid, connectionsLogic\n\t\t\t\t\t\t\t.isUserXFriendOfUserY(userUuid, currentUserUuid))) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tList<WallItem> wallItems = dao.getWallItemsForUser(userUuid).getWallItems();\n\t\t\n\t\t// filter wall items\n\t\tList<WallItem> filteredWallItems = new ArrayList<WallItem>();\n\t\tfor (WallItem wallItem : wallItems) {\n\t\t\t// current user is always allowed to see their wall items\n\t\t\tif (true == StringUtils.equals(userUuid, currentUserUuid)) {\n\t\t\t\tfilteredWallItems.add(wallItem);\n\t\t\t// don't allow friend-of-a-friend if not connected\n\t\t\t} else if (privacyLogic.isUserXWallVisibleByUserY(wallItem.getCreatorUuid(), currentUserUuid,\n\t\t\t\t\tconnectionsLogic.isUserXFriendOfUserY(wallItem.getCreatorUuid(), currentUserUuid))) {\n\t\t\t\tfilteredWallItems.add(wallItem);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint count = filteredWallItems.size();\n\t\t\n\t\t// connection statuses\n\t\tList<Person> connections = connectionsLogic\n\t\t\t\t.getConnectionsForUser(userUuid);\n\t\t\n\t\tif (null == connections || 0 == connections.size()) {\n\t\t\treturn count;\n\t\t}\n\t\t\n\t\tfor (Person connection : connections) {\n\t\t\t\n\t\t\tif (null != statusLogic.getUserStatus(connection.getUuid())) {\n\t\t\t\t\n\t\t\t\t// current user is always allowed to see status of connections\n\t\t\t\tif (true == StringUtils.equals(userUuid, currentUserUuid)) {\n\t\t\t\t\tcount++;\n\t\t\t\t// don't allow friend-of-a-friend if not connected\n\t\t\t\t} else if (true == privacyLogic.isUserXStatusVisibleByUserY(\n\t\t\t\t\t\tconnection.getUuid(), currentUserUuid,\n\t\t\t\t\t\tconnectionsLogic.isUserXFriendOfUserY(connection.getUuid(),\n\t\t\t\t\t\t\t\tcurrentUserUuid))) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tif (count > ProfileConstants.MAX_WALL_ITEMS_WITH_CONNECTION_STATUSES) {\n\t\t\treturn ProfileConstants.MAX_WALL_ITEMS_WITH_CONNECTION_STATUSES;\n\t\t} else {\n\t\t\treturn count;\n\t\t}\n\t}","id":65317,"modified_method":"/**\n\t * {@inheritDoc}\n\t */\n\tpublic int getWallItemsCount(String userUuid, ProfilePrivacy privacy) {\n\n\t\tfinal String currentUserUuid = sakaiProxy.getCurrentUserId();\n\t\tif (null == sakaiProxy.getCurrentUserId()) {\n\t\t\tthrow new SecurityException(\n\t\t\t\t\t\"You must be logged in to make a request for a user's wall items.\");\n\t\t}\n\n\t\tif (null == privacy) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (false == StringUtils.equals(userUuid, currentUserUuid)) {\n\n\t\t\tif (false == privacyLogic.isUserXWallVisibleByUserY(userUuid,\n\t\t\t\t\tprivacy, currentUserUuid, connectionsLogic\n\t\t\t\t\t\t\t.isUserXFriendOfUserY(userUuid, currentUserUuid))) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tList<WallItem> wallItems = dao.getWallItemsForUser(userUuid).getWallItems();\n\t\t\n\t\t// filter wall items\n\t\tList<WallItem> filteredWallItems = new ArrayList<WallItem>();\n\t\tfor (WallItem wallItem : wallItems) {\n\t\t\t// current user is always allowed to see their wall items\n\t\t\tif (true == StringUtils.equals(userUuid, currentUserUuid)) {\n\t\t\t\tfilteredWallItems.add(wallItem);\n\t\t\t// don't allow friend-of-a-friend if not connected\n\t\t\t} else if (privacyLogic.isUserXWallVisibleByUserY(wallItem.getCreatorUuid(), currentUserUuid,\n\t\t\t\t\tconnectionsLogic.isUserXFriendOfUserY(wallItem.getCreatorUuid(), currentUserUuid))) {\n\t\t\t\tfilteredWallItems.add(wallItem);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn filteredWallItems.size();\n\t}","commit_id":"4f8bea6fd5b17545feae3f4f4943ba87ccdb4b96","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * {@inheritDoc}\n\t */\n\tpublic void addEventToWalls(String event, final String userUuid) {\n\n\t\t// get the connections of the creator of this content\n\t\tfinal List<Person> connections = connectionsLogic.getConnectionsForUser(userUuid);\n\n\t\tif (null == connections || 0 == connections.size()) {\n\t\t\t// there are therefore no walls to post event to\n\t\t\treturn;\n\t\t}\n\n\t\tfinal WallItem wallItem = new WallItem();\n\n\t\twallItem.setCreatorUuid(userUuid);\n\t\twallItem.setType(ProfileConstants.WALL_ITEM_TYPE_EVENT);\n\t\twallItem.setDate(new Date());\n\t\t// this string is mapped to a localized resource string in GUI\n\t\twallItem.setText(event);\n\n\t\tThread thread = new Thread() {\n\t\t\tpublic void run() {\n\t\t\t\t\n\t\t\t\tList<String> uuidsToEmail = new ArrayList<String>();\n\t\t\t\t\n\t\t\t\tfor (Person connection : connections) {\n\t\t\n\t\t\t\t\t// only send email if successful\n\t\t\t\t\tif (dao.addNewWallItemForUser(connection.getUuid(), wallItem)) {\n\t\t\n\t\t\t\t\t\t// only send email if user has preference set\n\t\t\t\t\t\tif (true == preferencesLogic.isEmailEnabledForThisMessageType(connection.getUuid(),\n\t\t\t\t\t\t\t\tProfileConstants.EMAIL_NOTIFICATION_WALL_EVENT_NEW)) {\n\t\t\t\t\t\t\tuuidsToEmail.add(connection.getUuid());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// we don't guarantee delivery\n\t\t\t\t\t\tlog.warn(\"ProfileDao.addNewWallItemForUser failed for user: \" + connection.getUuid());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsendWallNotificationEmailToConnections(uuidsToEmail, userUuid,\n\t\t\t\t\t\tProfileConstants.EMAIL_NOTIFICATION_WALL_EVENT_NEW);\n\t\t\t}\n\t\t};\n\t\tthread.start();\n\t}","id":65318,"modified_method":"/**\n\t * {@inheritDoc}\n\t */\n\tpublic void addEventToWalls(String event, final String userUuid) {\n\t\taddItemToWalls(ProfileConstants.WALL_ITEM_TYPE_EVENT, event, userUuid);\n\t}","commit_id":"4f8bea6fd5b17545feae3f4f4943ba87ccdb4b96","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n \t * {@inheritDoc}\n \t */\n\tpublic List<WallItem> getWallItemsForUser(String userUuid, ProfilePrivacy privacy) {\n\n\t\tif (null == userUuid) {\n\t\t\tthrow new IllegalArgumentException(\"must provide user id\");\n\t\t}\n\n\t\tfinal String currentUserUuid = sakaiProxy.getCurrentUserId();\n\t\tif (null == currentUserUuid) {\n\t\t\tthrow new SecurityException(\n\t\t\t\t\t\"You must be logged in to make a request for a user's wall items.\");\n\t\t}\n\n\t\tif (null == privacy) {\n\t\t\treturn new ArrayList<WallItem>();\n\t\t}\n\n\t\tif (false == StringUtils.equals(userUuid, currentUserUuid)) {\n\t\t\tif (false == privacyLogic.isUserXWallVisibleByUserY(userUuid,\n\t\t\t\t\tprivacy, currentUserUuid, connectionsLogic\n\t\t\t\t\t\t\t.isUserXFriendOfUserY(userUuid, currentUserUuid))) {\n\t\t\t\treturn new ArrayList<WallItem>();\n\t\t\t}\n\t\t}\n\n\t\tList<WallItem> wallItems = dao.getWallItemsForUser(userUuid).getWallItems();\n\t\t\n\t\t// filter wall items\n\t\tList<WallItem> filteredWallItems = new ArrayList<WallItem>();\n\t\tfor (WallItem wallItem : wallItems) {\n\t\t\t// current user is always allowed to see their wall items\n\t\t\tif (true == StringUtils.equals(userUuid, currentUserUuid)) {\n\t\t\t\tfilteredWallItems.add(wallItem);\n\t\t\t// don't allow friend-of-a-friend if not connected\n\t\t\t} else if (privacyLogic.isUserXWallVisibleByUserY(wallItem.getCreatorUuid(), currentUserUuid,\n\t\t\t\t\tconnectionsLogic.isUserXFriendOfUserY(wallItem.getCreatorUuid(), currentUserUuid))) {\n\t\t\t\tfilteredWallItems.add(wallItem);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// add in any connection statuses\n\t\tList<Person> connections = connectionsLogic\n\t\t\t\t.getConnectionsForUser(userUuid);\n\n\t\tif (null == connections || 0 == connections.size()) {\n\t\t\tCollections.sort(filteredWallItems);\n\t\t\treturn filteredWallItems;\n\t\t}\n\n\t\tfor (Person connection : connections) {\n\n\t\t\tProfileStatus connectionStatus = statusLogic\n\t\t\t\t\t.getUserStatus(connection.getUuid());\n\n\t\t\tif (null == connectionStatus) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// status privacy check\n\t\t\tfinal boolean allowedStatus;\n\t\t\t// current user is always allowed to see status of connections\n\t\t\tif (true == StringUtils.equals(userUuid, currentUserUuid)) {\n\t\t\t\tallowedStatus = true;\n\t\t\t// don't allow friend-of-a-friend\t\n\t\t\t} else {\n\t\t\t\tallowedStatus =\t privacyLogic.isUserXStatusVisibleByUserY(\n\t\t\t\t\t\tconnection.getUuid(), currentUserUuid,\n\t\t\t\t\t\tconnectionsLogic.isUserXFriendOfUserY(connection.getUuid(),\n\t\t\t\t\t\t\t\tcurrentUserUuid));\n\t\t\t}\n\n\t\t\tif (true == allowedStatus) {\n\t\t\t\t\n\t\t\t\tWallItem wallItem = new WallItem();\n\t\t\t\twallItem.setType(ProfileConstants.WALL_ITEM_TYPE_STATUS);\n\t\t\t\twallItem.setCreatorUuid(connection.getUuid());\n\t\t\t\twallItem.setDate(connectionStatus.getDateAdded());\n\t\t\t\twallItem.setText(connectionStatus.getMessage());\n\n\t\t\t\tfilteredWallItems.add(wallItem);\n\t\t\t}\n\t\t}\n\n\t\t// wall items are comparable and need to be in order\n\t\tCollections.sort(filteredWallItems);\n\t\t\n\t\t// dao limits wall items but we also need to ensure any connection\n\t\t// status updates don't push the number of wall items over limit\n\t\tif (filteredWallItems.size() > ProfileConstants.MAX_WALL_ITEMS_WITH_CONNECTION_STATUSES) {\t\t\t\n\t\t\treturn filteredWallItems.subList(0, ProfileConstants.MAX_WALL_ITEMS_WITH_CONNECTION_STATUSES);\n\t\t} else {\n\t\t\treturn filteredWallItems;\n\t\t}\n\t}","id":65319,"modified_method":"/**\n \t * {@inheritDoc}\n \t */\n\tpublic List<WallItem> getWallItemsForUser(String userUuid, ProfilePrivacy privacy) {\n\n\t\tif (null == userUuid) {\n\t\t\tthrow new IllegalArgumentException(\"must provide user id\");\n\t\t}\n\n\t\tfinal String currentUserUuid = sakaiProxy.getCurrentUserId();\n\t\tif (null == currentUserUuid) {\n\t\t\tthrow new SecurityException(\n\t\t\t\t\t\"You must be logged in to make a request for a user's wall items.\");\n\t\t}\n\n\t\tif (null == privacy) {\n\t\t\treturn new ArrayList<WallItem>();\n\t\t}\n\n\t\tif (false == StringUtils.equals(userUuid, currentUserUuid)) {\n\t\t\tif (false == privacyLogic.isUserXWallVisibleByUserY(userUuid,\n\t\t\t\t\tprivacy, currentUserUuid, connectionsLogic\n\t\t\t\t\t\t\t.isUserXFriendOfUserY(userUuid, currentUserUuid))) {\n\t\t\t\treturn new ArrayList<WallItem>();\n\t\t\t}\n\t\t}\n\n\t\tList<WallItem> wallItems = dao.getWallItemsForUser(userUuid).getWallItems();\n\t\t\n\t\t// filter wall items\n\t\tList<WallItem> filteredWallItems = new ArrayList<WallItem>();\n\t\tfor (WallItem wallItem : wallItems) {\n\t\t\t// current user is always allowed to see their wall items\n\t\t\tif (true == StringUtils.equals(userUuid, currentUserUuid)) {\n\t\t\t\tfilteredWallItems.add(wallItem);\n\t\t\t// don't allow friend-of-a-friend if not connected\n\t\t\t} else if (privacyLogic.isUserXWallVisibleByUserY(wallItem.getCreatorUuid(), currentUserUuid,\n\t\t\t\t\tconnectionsLogic.isUserXFriendOfUserY(wallItem.getCreatorUuid(), currentUserUuid))) {\n\t\t\t\tfilteredWallItems.add(wallItem);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// wall items are comparable and need to be in order\n\t\tCollections.sort(filteredWallItems);\n\t\t\t\t\n\t\treturn filteredWallItems;\n\t}","commit_id":"4f8bea6fd5b17545feae3f4f4943ba87ccdb4b96","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Creates a new instance of <code>WallItemPanel<\/code>.\n\t * \n\t * @param id\n\t * @param userUuid the id of the user whose wall this item panel is on.\n\t * @param wallItem\n\t */\n\tpublic WallItemPanel(String id, final String userUuid, WallItem wallItem) {\n\t\tsuper(id);\n\n\t\t// image wrapper, links to profile\n\t\tLink<String> wallItemPhoto = new Link<String>(\"wallItemPhotoWrap\",\n\t\t\t\tnew Model<String>(wallItem.getCreatorUuid())) {\n\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void onClick() {\n\t\t\t\tsetResponsePage(new ViewProfile(getModelObject()));\n\t\t\t}\n\t\t};\n\n\t\t// image\n\t\twallItemPhoto.add(new ProfileImageRenderer(\"wallItemPhoto\", wallItem\n\t\t\t\t.getCreatorUuid()));\n\t\tadd(wallItemPhoto);\n\n\t\t// name and link to profile\n\t\tLink<String> wallItemProfileLink = new Link<String>(\n\t\t\t\t\"wallItemProfileLink\", new Model<String>(wallItem\n\t\t\t\t\t\t.getCreatorUuid())) {\n\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void onClick() {\n\t\t\t\tsetResponsePage(new ViewProfile(getModelObject()));\n\t\t\t}\n\n\t\t};\n\t\twallItemProfileLink.add(new Label(\"wallItemName\", sakaiProxy\n\t\t\t\t.getUserDisplayName(wallItem.getCreatorUuid())));\n\t\tadd(wallItemProfileLink);\n\n\t\t// TODO date has scope for internationalization?\n\t\tadd(new Label(\"wallItemDate\", ProfileUtils.convertDateToString(wallItem\n\t\t\t\t.getDate(), \"dd MMMMM, HH:mm\")));\n\n\t\t// wall item actions (TODO container?)\n\t\t\n\t\t// delete link\n\t\tfinal AjaxLink<WallItem> removeItemLink = new AjaxLink<WallItem>(\n\t\t\t\t\"removeWallItemLink\", new Model<WallItem>(wallItem)) {\n\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic void onClick(AjaxRequestTarget target) {\n\n\t\t\t\twallLogic.removeWallItemFromWall(userUuid, this\n\t\t\t\t\t\t.getModelObject());\n\n\t\t\t\t// delete link should only appear when viewing own profile\n\t\t\t\tsetResponsePage(new MyProfile());\n\t\t\t}\n\t\t};\n\n\t\t// special case for statuses which can't be deleted from walls\n\t\tif (ProfileConstants.WALL_ITEM_TYPE_STATUS == wallItem.getType()) {\n\t\t\tremoveItemLink.add(new Label(\"removeWallItemLabel\", new ResourceModel(\"link.wall.item.status\")));\t\t\t\n\t\t\tremoveItemLink.setEnabled(false);\n\t\t} else {\n\t\t\tremoveItemLink.add(new Label(\"removeWallItemLabel\", new ResourceModel(\"link.wall.item.remove\")));\n\t\t\tremoveItemLink.add(new AttributeModifier(\"title\", true, new ResourceModel(\"link.title.wall.remove\")));\n\t\t}\n\n\t\t// not visible when viewing another user's wall\n\t\tif (false == sakaiProxy.getCurrentUserId().equals(userUuid)) {\n\t\t\tremoveItemLink.setVisible(false);\n\t\t}\n\t\t\n\t\tadd(removeItemLink);\n\n\t\tif (ProfileConstants.WALL_ITEM_TYPE_EVENT == wallItem.getType()) {\n\t\t\tadd(new Label(\"wallItemText\", new ResourceModel(wallItem.getText())));\n\t\t\t\n\t\t} else if (ProfileConstants.WALL_ITEM_TYPE_POST == wallItem.getType()) {\n\t\t\tadd(new Label(\"wallItemText\", ProfileUtils.processHtml(wallItem\n\t\t\t\t\t.getText())).setEscapeModelStrings(false));\n\t\t\t\n\t\t} else if (ProfileConstants.WALL_ITEM_TYPE_STATUS == wallItem.getType()) {\n\t\t\tadd(new Label(\"wallItemText\", wallItem.getText()));\n\n\t\t}\n\t\t\n\t}","id":65320,"modified_method":"/**\n\t * Creates a new instance of <code>WallItemPanel<\/code>.\n\t * \n\t * @param id\n\t * @param userUuid the id of the user whose wall this item panel is on.\n\t * @param wallItem\n\t */\n\tpublic WallItemPanel(String id, final String userUuid, WallItem wallItem) {\n\t\tsuper(id);\n\n\t\t// image wrapper, links to profile\n\t\tLink<String> wallItemPhoto = new Link<String>(\"wallItemPhotoWrap\",\n\t\t\t\tnew Model<String>(wallItem.getCreatorUuid())) {\n\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void onClick() {\n\t\t\t\tsetResponsePage(new ViewProfile(getModelObject()));\n\t\t\t}\n\t\t};\n\n\t\t// image\n\t\twallItemPhoto.add(new ProfileImageRenderer(\"wallItemPhoto\", wallItem\n\t\t\t\t.getCreatorUuid()));\n\t\tadd(wallItemPhoto);\n\n\t\t// name and link to profile\n\t\tLink<String> wallItemProfileLink = new Link<String>(\n\t\t\t\t\"wallItemProfileLink\", new Model<String>(wallItem\n\t\t\t\t\t\t.getCreatorUuid())) {\n\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void onClick() {\n\t\t\t\tsetResponsePage(new ViewProfile(getModelObject()));\n\t\t\t}\n\n\t\t};\n\t\twallItemProfileLink.add(new Label(\"wallItemName\", sakaiProxy\n\t\t\t\t.getUserDisplayName(wallItem.getCreatorUuid())));\n\t\tadd(wallItemProfileLink);\n\n\t\t// TODO date has scope for internationalization?\n\t\tadd(new Label(\"wallItemDate\", ProfileUtils.convertDateToString(wallItem\n\t\t\t\t.getDate(), \"dd MMMMM, HH:mm\")));\n\n\t\t// wall item actions (TODO container?)\n\t\t\n\t\t// delete link\n\t\tfinal AjaxLink<WallItem> removeItemLink = new AjaxLink<WallItem>(\n\t\t\t\t\"removeWallItemLink\", new Model<WallItem>(wallItem)) {\n\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic void onClick(AjaxRequestTarget target) {\n\n\t\t\t\twallLogic.removeWallItemFromWall(userUuid, this\n\t\t\t\t\t\t.getModelObject());\n\n\t\t\t\t// delete link should only appear when viewing own profile\n\t\t\t\tsetResponsePage(new MyProfile());\n\t\t\t}\n\t\t};\n\n\t\tremoveItemLink.add(new Label(\"removeWallItemLabel\", new ResourceModel(\"link.wall.item.remove\")));\n\t\tremoveItemLink.add(new AttributeModifier(\"title\", true, new ResourceModel(\"link.title.wall.remove\")));\n\n\t\t// not visible when viewing another user's wall\n\t\tif (false == sakaiProxy.getCurrentUserId().equals(userUuid)) {\n\t\t\tremoveItemLink.setVisible(false);\n\t\t}\n\t\t\n\t\tadd(removeItemLink);\n\n\t\tif (ProfileConstants.WALL_ITEM_TYPE_EVENT == wallItem.getType()) {\n\t\t\tadd(new Label(\"wallItemText\", new ResourceModel(wallItem.getText())));\n\t\t\t\n\t\t} else if (ProfileConstants.WALL_ITEM_TYPE_POST == wallItem.getType()) {\n\t\t\tadd(new Label(\"wallItemText\", ProfileUtils.processHtml(wallItem\n\t\t\t\t\t.getText())).setEscapeModelStrings(false));\n\t\t\t\n\t\t} else if (ProfileConstants.WALL_ITEM_TYPE_STATUS == wallItem.getType()) {\n\t\t\tadd(new Label(\"wallItemText\", wallItem.getText()));\n\n\t\t}\n\t\t\n\t}","commit_id":"4f8bea6fd5b17545feae3f4f4943ba87ccdb4b96","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void processAction(\n\t\t\tPortletConfig config, ActionRequest req, ActionResponse res)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(req, Constants.CMD);\n\n\t\tif (!cmd.equals(Constants.UPDATE)) {\n\t\t\treturn;\n\t\t}\n\n\t\tString title = ParamUtil.getString(req, \"title\");\n\t\tString description = ParamUtil.getString(req, \"description\");\n\t\tboolean requireCaptcha = ParamUtil.getBoolean(req, \"requireCaptcha\");\n\t\tString subject = ParamUtil.getString(req, \"subject\");\n\t\tString emailAddress = ParamUtil.getString(req, \"emailAddress\");\n\n\t\tString portletResource = ParamUtil.getString(req, \"portletResource\");\n\n\t\tPortletPreferences prefs =\n\t\t\tPortletPreferencesFactoryUtil.getPortletSetup(\n\t\t\t\treq, portletResource, true, true);\n\n\t\tif (Validator.isNull(title)) {\n\t\t\tSessionErrors.add(req, \"titleRequired\");\n\t\t}\n\n\t\tif (Validator.isNull(subject)) {\n\t\t\tSessionErrors.add(req, \"subjectRequired\");\n\t\t}\n\n\t\tif (Validator.isNull(emailAddress)) {\n\t\t\tSessionErrors.add(req, \"emailAddressRequired\");\n\t\t}\n\t\telse if (!Validator.isEmailAddress(emailAddress)) {\n\t\t\tSessionErrors.add(req, \"emailAddressInvalid\");\n\t\t}\n\n\t\tif (!SessionErrors.isEmpty(req)) {\n\t\t\treturn;\n\t\t}\n\n\t\tprefs.setValue(\"title\", title);\n\t\tprefs.setValue(\"description\", description);\n\t\tprefs.setValue(\"require-captcha\", String.valueOf(requireCaptcha));\n\t\tprefs.setValue(\"subject\", subject);\n\t\tprefs.setValue(\"emailAddress\", emailAddress);\n\n\t\tint i = 1;\n\n\t\tString fieldLabel = ParamUtil.getString(req, \"fieldLabel\" + i);\n\t\tString fieldType = ParamUtil.getString(req, \"fieldType\" + i);\n\t\tboolean fieldOptional = ParamUtil.getBoolean(req, \"fieldOptional\" + i);\n\t\tString fieldOptions = ParamUtil.getString(req, \"fieldOptions\" + i);\n\n\t\twhile ((i == 1) || (fieldLabel.trim().length() > 0)) {\n\t\t\tprefs.setValue(\"fieldLabel\" + i, fieldLabel);\n\t\t\tprefs.setValue(\"fieldType\" + i, fieldType);\n\t\t\tprefs.setValue(\"fieldOptional\" + i, String.valueOf(fieldOptional));\n\t\t\tprefs.setValue(\"fieldOptions\" + i, fieldOptions);\n\n\t\t\ti++;\n\n\t\t\tfieldLabel = ParamUtil.getString(req, \"fieldLabel\" + i);\n\t\t\tfieldType = ParamUtil.getString(req, \"fieldType\" + i);\n\t\t\tfieldOptional = ParamUtil.getBoolean(req, \"fieldOptional\" + i);\n\t\t\tfieldOptions = ParamUtil.getString(req, \"fieldOptions\" + i);\n\t\t}\n\n\t\tif (SessionErrors.isEmpty(req)) {\n\t\t\tprefs.store();\n\n\t\t\tSessionMessages.add(req, config.getPortletName() + \".doConfigure\");\n\t\t}\n\t}","id":65321,"modified_method":"public void processAction(\n\t\t\tPortletConfig config, ActionRequest req, ActionResponse res)\n\t\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(req, Constants.CMD);\n\n\t\tif (!cmd.equals(Constants.UPDATE)) {\n\t\t\treturn;\n\t\t}\n\n\t\tString title = ParamUtil.getString(req, \"title\");\n\t\tString description = ParamUtil.getString(req, \"description\");\n\t\tboolean requireCaptcha = ParamUtil.getBoolean(req, \"requireCaptcha\");\n\t\tString subject = ParamUtil.getString(req, \"subject\");\n\t\tString emailAddress = ParamUtil.getString(req, \"emailAddress\");\n\n\t\tString fileName = ParamUtil.getString(req, \"fileName\");\n\t\tboolean saveToFile = ParamUtil.getBoolean(req, \"saveToFile\");\n\t\tboolean sendAsEmail = ParamUtil.getBoolean(req, \"sendAsEmail\");\n\t\tString thanksURL = ParamUtil.getString(req, \"thanksURL\");\n\n\t\tString portletResource = ParamUtil.getString(req, \"portletResource\");\n\n\t\tPortletPreferences prefs =\n\t\t\tPortletPreferencesFactoryUtil.getPortletSetup(\n\t\t\t\treq, portletResource, true, true);\n\n\n\t\tif (Validator.isNull(title)) {\n\t\t\tSessionErrors.add(req, \"titleRequired\");\n\t\t}\n\n\t\tif (Validator.isNull(subject)) {\n\t\t\tSessionErrors.add(req, \"subjectRequired\");\n\t\t}\n\n\t\tif (!sendAsEmail && !saveToFile){\n\t\t\tSessionErrors.add(req, \"emailOrFileRequired\");\n\t\t}\n\n\t\tif (sendAsEmail) {\n\t\t\tif (Validator.isNull(emailAddress)) {\n\t\t\t\tSessionErrors.add(req, \"emailAddressRequired\");\n\t\t\t}\n\t\t\telse if (!Validator.isEmailAddress(emailAddress)) {\n\t\t\t\tSessionErrors.add(req, \"emailAddressInvalid\");\n\t\t\t}\n\t\t}\n\n\t\tif (saveToFile) {\n\t\t\t// check if webserver can create a file as specified\n\t\t\ttry {\n\t\t\t\tFileOutputStream fos = new FileOutputStream(fileName, true);\n\t\t\t\tfos.close();\n\t\t\t} catch (SecurityException e) {\n\t\t\t\tSessionErrors.add(req, \"fileNameInvalid\");\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tSessionErrors.add(req, \"fileNameInvalid\");\n\t\t\t}\n\t\t}\n\n\t\tif (!SessionErrors.isEmpty(req)) {\n\t\t\treturn;\n\t\t}\n\n\t\tprefs.setValue(\"title\", title);\n\t\tprefs.setValue(\"description\", description);\n\t\tprefs.setValue(\"require-captcha\", String.valueOf(requireCaptcha));\n\t\tprefs.setValue(\"subject\", subject);\n\t\tprefs.setValue(\"emailAddress\", emailAddress);\n\t\tprefs.setValue(\"sendAsEmail\", String.valueOf(sendAsEmail));\n\t\tprefs.setValue(\"saveToFile\", String.valueOf(saveToFile));\n\t\tprefs.setValue(\"fileName\", fileName);\n\t\tprefs.setValue(\"thanksURL\", thanksURL);\n\n\t\tint i = 1;\n\n\t\tString fieldLabel = ParamUtil.getString(req, \"fieldLabel\" + i);\n\t\tString fieldType = ParamUtil.getString(req, \"fieldType\" + i);\n\t\tboolean fieldOptional = ParamUtil.getBoolean(req, \"fieldOptional\" + i);\n\t\tString fieldOptions = ParamUtil.getString(req, \"fieldOptions\" + i);\n\n\t\twhile ((i == 1) || (fieldLabel.trim().length() > 0)) {\n\t\t\tprefs.setValue(\"fieldLabel\" + i, fieldLabel);\n\t\t\tprefs.setValue(\"fieldType\" + i, fieldType);\n\t\t\tprefs.setValue(\"fieldOptional\" + i, String.valueOf(fieldOptional));\n\t\t\tprefs.setValue(\"fieldOptions\" + i, fieldOptions);\n\n\t\t\ti++;\n\n\t\t\tfieldLabel = ParamUtil.getString(req, \"fieldLabel\" + i);\n\t\t\tfieldType = ParamUtil.getString(req, \"fieldType\" + i);\n\t\t\tfieldOptional = ParamUtil.getBoolean(req, \"fieldOptional\" + i);\n\t\t\tfieldOptions = ParamUtil.getString(req, \"fieldOptions\" + i);\n\t\t}\n\n\t\tif (SessionErrors.isEmpty(req)) {\n\t\t\tprefs.store();\n\n\t\t\tSessionMessages.add(req, config.getPortletName() + \".doConfigure\");\n\t\t}\n\t}","commit_id":"b163ff0f4d6d83510e3939a678bf6e2be08e2e8c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig config,\n\t\t\tActionRequest req, ActionResponse res)\n\t\tthrows Exception {\n\n\t\tPortletConfigImpl configImpl = (PortletConfigImpl)config;\n\n\t\tString portletId = configImpl.getPortletId();\n\n\t\tPortletPreferences prefs =\n\t\t\tPortletPreferencesFactoryUtil.getPortletSetup(\n\t\t\t\treq, portletId, true, true);\n\n\t\tboolean requireCaptcha = GetterUtil.getBoolean(\n\t\t\tprefs.getValue(\"require-captcha\", StringPool.BLANK));\n\n\t\tif (requireCaptcha) {\n\t\t\ttry {\n\t\t\t\tCaptchaUtil.check(req);\n\t\t\t}\n\t\t\tcatch (CaptchaTextException cte) {\n\t\t\t\tSessionErrors.add(req, CaptchaTextException.class.getName());\n\t\t\t}\n\t\t}\n\n\t\tList fieldValues = new ArrayList();\n\n\t\tfor (int i = 1; i <= 10; i++) {\n\t\t\tfieldValues.add(req.getParameter(\"field\" + i));\n\t\t}\n\n\t\tif (validate(fieldValues, prefs)) {\n\t\t\tif (!sendEmail(fieldValues, prefs)) {\n\t\t\t\tSessionErrors.add(req, \"emailNotSent\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSessionMessages.add(req, \"emailSent\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tSessionErrors.add(req, \"allFieldsRequired\");\n\t\t}\n\t}","id":65322,"modified_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig config,\n\t\t\tActionRequest req, ActionResponse res)\n\t\tthrows Exception {\n\n\t\tPortletConfigImpl configImpl = (PortletConfigImpl)config;\n\n\t\tString portletId = configImpl.getPortletId();\n\n\t\tPortletPreferences prefs =\n\t\t\tPortletPreferencesFactoryUtil.getPortletSetup(\n\t\t\t\treq, portletId, true, true);\n\n\t\tboolean requireCaptcha = GetterUtil.getBoolean(\n\t\t\t\tprefs.getValue(\"require-captcha\", StringPool.BLANK));\n\n\t\tboolean sendAsEmail = GetterUtil.getBoolean(\n\t\t\t\tprefs.getValue(\"sendAsEmail\", StringPool.BLANK));\n\n\t\tboolean saveToFile = GetterUtil.getBoolean(\n\t\t\t\tprefs.getValue(\"saveToFile\", StringPool.BLANK));\n\n\t\tString fileName = GetterUtil.getString(\n\t\t\t\tprefs.getValue(\"fileName\", StringPool.BLANK));\n\n\t\tString thanksURL = GetterUtil.getString(\n\t\t\t\tprefs.getValue(\"thanksURL\", StringPool.BLANK));\n\n\t\tif (requireCaptcha) {\n\t\t\ttry {\n\t\t\t\tCaptchaUtil.check(req);\n\t\t\t}\n\t\t\tcatch (CaptchaTextException cte) {\n\t\t\t\tSessionErrors.add(req, CaptchaTextException.class.getName());\n\t\t\t}\n\t\t}\n\n\t\tList fieldValues = new ArrayList();\n\n\t\tfor (int i = 1; i <= 10; i++) {\n\t\t\tfieldValues.add(req.getParameter(\"field\" + i));\n\t\t}\n\n\t\tif (validate(fieldValues, prefs)) {\n\n\t\t\tboolean emailSent = false;\n\t\t\tboolean fileSaved = false;\n\n\t\t\tif (sendAsEmail) {\n\t\t\t\temailSent = sendEmail(fieldValues, prefs);\n\t\t\t}\n\n\t\t\tif (saveToFile) {\n\t\t\t\tfileSaved = saveFile(fieldValues, prefs, fileName);\n\t\t\t}\n\n\t\t\tif ((sendAsEmail == emailSent) && (saveToFile == fileSaved)) {\n\t\t\t\tSessionMessages.add(req, \"emailSent\");\n\t\t\t} else {\n\t\t\t\tSessionErrors.add(req, \"emailNotSent\");\n\t\t\t}\n\n\t\t}\n\t\telse {\n\t\t\tSessionErrors.add(req, \"allFieldsRequired\");\n\t\t}\n\n\t\tif (SessionErrors.isEmpty(req) && Validator.isNotNull(thanksURL)) {\n\t        res.sendRedirect(res.encodeURL(thanksURL));\n\t\t}\n\n\t}","commit_id":"b163ff0f4d6d83510e3939a678bf6e2be08e2e8c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void renderWallPanel(String userUuid) {\n\t\t// container which wraps list\n\t\tfinal WebMarkupContainer wallItemsContainer = new WebMarkupContainer(\n\t\t\t\t\"wallItemsContainer\");\n\n\t\twallItemsContainer.setOutputMarkupId(true);\n\t\tadd(wallItemsContainer);\n\t\t\n\t\t// form for posting to my wall\n\t\tForm<String> form = new Form<String>(\"myWallPostForm\", new Model<String>(new String()));\n\t\tform.setOutputMarkupId(true);\n\t\tadd(form);\n\t\t\n\t\t// form submit feedback\n\t\tfinal Label formFeedback = new Label(\"formFeedback\");\n\t\tformFeedback.setOutputMarkupPlaceholderTag(true);\n\t\tform.add(formFeedback);\n\t\t\n        final FeedbackPanel feedback = new FeedbackPanel(\"feedback\");\n        feedback.setOutputMarkupId(true);\n        form.add(feedback);\n        \n        int[] filteredErrorLevels = new int[]{FeedbackMessage.ERROR};\n        feedback.setFilter(new ErrorLevelsFeedbackMessageFilter(filteredErrorLevels));\n\t\t\n\t\t// container for posting to my wall\n\t\tWebMarkupContainer myWallPostContainer = new WebMarkupContainer(\"myWallPostContainer\");\n\t\tTextArea<String> myWallPost = new TextArea<String>(\"myWallPost\");\n\t\tmyWallPost.add(new TinyMceBehavior(new TextareaTinyMceSettings(TinyMCESettings.Align.left)));\n\t\t\n\t\tmyWallPostContainer.add(myWallPost);\n\t\t\n\t\tform.add(myWallPostContainer);\n\t\t\n\t\tAjaxFallbackButton submitButton = new AjaxFallbackButton(\"myWallPostSubmit\", form) {\n\t\t\tprotected void onSubmit(AjaxRequestTarget target, Form form) {\n\t\t\t\t\n\t\t\t}\n\t\t};\n\t\tsubmitButton.setModel(new ResourceModel(\"button.wall.post\"));\n\t\tsubmitButton.add(new TinyMceAjaxSubmitModifier());\n\t\tmyWallPostContainer.add(submitButton);\n\t\t\n\t\tWallItemDataProvider provider = new WallItemDataProvider(userUuid);\n\n\t\t// if no wall items, display a message\n\t\tif (0 == provider.size()) {\n\t\t\tadd(new Label(\"wallInformationMessage\",\n\t\t\t\t\tnew ResourceModel(\"text.wall.no.items\")));\n\t\t} else {\n\t\t\t// blank label when there are items to display\n\t\t\tadd(new Label(\"wallInformationMessage\"));\n\t\t}\n\n\t\t// TODO haven't decided whether to add a navigator yet\n\n\t\tDataView<WallItem> wallItemsDataView = new DataView<WallItem>(\n\t\t\t\t\"wallItems\", provider) {\n\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tprotected void populateItem(Item<WallItem> item) {\n\n\t\t\t\tWallItem wallItem = (WallItem) item.getDefaultModelObject();\n\n\t\t\t\titem.add(new WallItemPanel(\"wallItemPanel\", wallItem));\n\t\t\t}\n\t\t};\n\n\t\twallItemsDataView.setOutputMarkupId(true);\n\t\t// wallItemsDataView.setItemsPerPage(10);\n\n\t\twallItemsContainer.add(wallItemsDataView);\n\t}","id":65323,"modified_method":"private void renderWallPanel(final String userUuid) {\n\t\t// container which wraps list\n\t\tfinal WebMarkupContainer wallItemsContainer = new WebMarkupContainer(\n\t\t\t\t\"wallItemsContainer\");\n\n\t\twallItemsContainer.setOutputMarkupId(true);\n\t\tadd(wallItemsContainer);\n\t\t\n\t\tWallItem wallItem = new WallItem();\n\t\t// always post to my wall as current user, to ensure super users cannot\n\t\t// make posts as other users\n\t\twallItem.setCreatorUuid(sakaiProxy.getCurrentUserId());\n\t\twallItem.setType(ProfileConstants.WALL_ITEM_TYPE_POST);\n\t\t\n\t\t// form for posting to my wall\n\t\tForm<WallItem> form = new Form<WallItem>(\"myWallPostForm\", new Model<WallItem>(wallItem));\n\t\tform.setOutputMarkupId(true);\n\t\tadd(form);\n\t\t\n\t\t// form submit feedback\n\t\tfinal Label formFeedback = new Label(\"formFeedback\");\n\t\tformFeedback.setOutputMarkupPlaceholderTag(true);\n\t\tform.add(formFeedback);\n\t\t\n        final FeedbackPanel feedback = new FeedbackPanel(\"feedback\");\n        feedback.setOutputMarkupId(true);\n        form.add(feedback);\n        \n        int[] filteredErrorLevels = new int[]{FeedbackMessage.ERROR};\n        feedback.setFilter(new ErrorLevelsFeedbackMessageFilter(filteredErrorLevels));\n\t\t\n\t\t// container for posting to my wall\n\t\tWebMarkupContainer myWallPostContainer = new WebMarkupContainer(\"myWallPostContainer\");\n\t\tTextArea<String> myWallPost = new TextArea<String>(\"myWallPost\", new PropertyModel(wallItem, \"text\"));\n\t\tmyWallPost.add(new TinyMceBehavior(new TextareaTinyMceSettings(TinyMCESettings.Align.left)));\n\t\t\n\t\tmyWallPostContainer.add(myWallPost);\n\t\t\n\t\tform.add(myWallPostContainer);\n\t\t\n\t\tAjaxFallbackButton submitButton = new AjaxFallbackButton(\"myWallPostSubmit\", form) {\n\t\t\tprotected void onSubmit(AjaxRequestTarget target, Form form) {\n\t\t\t\t\n\t\t\t\t/*if (save(form)) {\n\t\t\t\t\t\n\t\t\t\t}*/\n\t\t\t\t\n\t\t\t\tsave(form, userUuid);\n\t\t\t\t\n\t\t\t\tsetResponsePage(new MyProfile(userUuid));\n\t\t\t}\n\t\t};\n\t\tsubmitButton.setModel(new ResourceModel(\"button.wall.post\"));\n\t\tsubmitButton.add(new TinyMceAjaxSubmitModifier());\n\t\tmyWallPostContainer.add(submitButton);\n\t\t\n\t\tWallItemDataProvider provider = new WallItemDataProvider(userUuid);\n\n\t\t// if no wall items, display a message\n\t\tif (0 == provider.size()) {\n\t\t\tadd(new Label(\"wallInformationMessage\",\n\t\t\t\t\tnew ResourceModel(\"text.wall.no.items\")));\n\t\t} else {\n\t\t\t// blank label when there are items to display\n\t\t\tadd(new Label(\"wallInformationMessage\"));\n\t\t}\n\n\t\t// TODO haven't decided whether to add a navigator yet\n\n\t\tDataView<WallItem> wallItemsDataView = new DataView<WallItem>(\n\t\t\t\t\"wallItems\", provider) {\n\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tprotected void populateItem(Item<WallItem> item) {\n\n\t\t\t\tWallItem wallItem = (WallItem) item.getDefaultModelObject();\n\n\t\t\t\titem.add(new WallItemPanel(\"wallItemPanel\", wallItem));\n\t\t\t}\n\t\t};\n\n\t\twallItemsDataView.setOutputMarkupId(true);\n\t\t// wallItemsDataView.setItemsPerPage(10);\n\n\t\twallItemsContainer.add(wallItemsDataView);\n\t}","commit_id":"2049fbde0bd78fd7116b7b5c0ed52a1bb6b7aab0","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public MyWallPanel(String panelId, String userUuid) {\n\n\t\tsuper(panelId);\n\t\t\n\t\t// double check for super user\n\t\tif (false == sakaiProxy.isSuperUser()) {\n\t\t\tlog.error(\"MyWallPanel: user \" + sakaiProxy.getCurrentUserId()\n\t\t\t\t\t+ \" attempted to access MyWallPanel for \" + userUuid\n\t\t\t\t\t+ \". Redirecting...\");\n\n\t\t\tthrow new RestartResponseException(new MyProfile());\n\t\t}\n\t\t\n\t\trenderWallPanel(userUuid);\n\t}","id":65324,"modified_method":"/**\n\t * Creates a new instance of <code>MyWallPanel<\/code>.\n\t * \n\t * This method is used when a super user is viewing the profile of another\n\t * user.\n\t */\n\tpublic MyWallPanel(String panelId, String userUuid) {\n\n\t\tsuper(panelId);\n\t\t\n\t\t// double check for super user\n\t\tif (false == sakaiProxy.isSuperUser()) {\n\t\t\tlog.error(\"MyWallPanel: user \" + sakaiProxy.getCurrentUserId()\n\t\t\t\t\t+ \" attempted to access MyWallPanel for \" + userUuid\n\t\t\t\t\t+ \". Redirecting...\");\n\n\t\t\tthrow new RestartResponseException(new MyProfile());\n\t\t}\n\t\t\n\t\trenderWallPanel(userUuid);\n\t}","commit_id":"2049fbde0bd78fd7116b7b5c0ed52a1bb6b7aab0","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n \t * {@inheritDoc}\n \t */\n\tpublic boolean isEmailEnabledForThisMessageType(final String userId, final int messageType) {\n\t\t\n\t\t//get preferences record for this user\n    \tProfilePreferences profilePreferences = getPreferencesRecordForUser(userId);\n    \t\n    \t//if none, return whatever the flag is set as by default\n    \tif(profilePreferences == null) {\n    \t\treturn ProfileConstants.DEFAULT_EMAIL_NOTIFICATION_SETTING;\n    \t}\n    \t\n    \t//if its a request and requests enabled, true\n    \tif(messageType == ProfileConstants.EMAIL_NOTIFICATION_REQUEST && profilePreferences.isRequestEmailEnabled()) {\n    \t\treturn true;\n    \t}\n    \t\n    \t//if its a confirm and confirms enabled, true\n    \tif(messageType == ProfileConstants.EMAIL_NOTIFICATION_CONFIRM && profilePreferences.isConfirmEmailEnabled()) {\n    \t\treturn true;\n    \t}\n    \t\n    \t//if its a new message and new messages enabled, true\n    \tif(messageType == ProfileConstants.EMAIL_NOTIFICATION_MESSAGE_NEW && profilePreferences.isMessageNewEmailEnabled()) {\n    \t\treturn true;\n    \t}\n    \t\n    \t//if its a reply to a message message and replies enabled, true\n    \tif(messageType == ProfileConstants.EMAIL_NOTIFICATION_MESSAGE_REPLY && profilePreferences.isMessageReplyEmailEnabled()) {\n    \t\treturn true;\n    \t}\n    \t\n    \tif(messageType == ProfileConstants.EMAIL_NOTIFICATION_WALL_EVENT_NEW && profilePreferences.isWallItemNewEmailEnabled()) {\n    \t\treturn true;\n    \t}\n    \t\n    \t//add more cases here as need progresses\n    \t\n    \t//no notification for this message type, return false \t\n    \tlog.debug(\"ProfileLogic.isEmailEnabledForThisMessageType. False for userId: \" + userId + \", messageType: \" + messageType);  \n\n    \treturn false;\n\t}","id":65325,"modified_method":"/**\n \t * {@inheritDoc}\n \t */\n\tpublic boolean isEmailEnabledForThisMessageType(final String userId, final int messageType) {\n\t\t\n\t\t//get preferences record for this user\n    \tProfilePreferences profilePreferences = getPreferencesRecordForUser(userId);\n    \t\n    \t//if none, return whatever the flag is set as by default\n    \tif(profilePreferences == null) {\n    \t\treturn ProfileConstants.DEFAULT_EMAIL_NOTIFICATION_SETTING;\n    \t}\n    \t\n    \t//if its a request and requests enabled, true\n    \tif(messageType == ProfileConstants.EMAIL_NOTIFICATION_REQUEST && profilePreferences.isRequestEmailEnabled()) {\n    \t\treturn true;\n    \t}\n    \t\n    \t//if its a confirm and confirms enabled, true\n    \tif(messageType == ProfileConstants.EMAIL_NOTIFICATION_CONFIRM && profilePreferences.isConfirmEmailEnabled()) {\n    \t\treturn true;\n    \t}\n    \t\n    \t//if its a new message and new messages enabled, true\n    \tif(messageType == ProfileConstants.EMAIL_NOTIFICATION_MESSAGE_NEW && profilePreferences.isMessageNewEmailEnabled()) {\n    \t\treturn true;\n    \t}\n    \t\n    \t//if its a reply to a message message and replies enabled, true\n    \tif(messageType == ProfileConstants.EMAIL_NOTIFICATION_MESSAGE_REPLY && profilePreferences.isMessageReplyEmailEnabled()) {\n    \t\treturn true;\n    \t}\n    \t\n    \t// may split these later, but for now single preference controls wall emails\n    \tif((messageType == ProfileConstants.EMAIL_NOTIFICATION_WALL_EVENT_NEW || \n    \t\t\tmessageType == ProfileConstants.EMAIL_NOTIFICATION_WALL_POST_MY_NEW ||\n    \t\t\tmessageType == ProfileConstants.EMAIL_NOTIFICATION_WALL_POST_CONNECTION_NEW)\n    \t\t\t&& profilePreferences.isWallItemNewEmailEnabled()) {\n    \t\treturn true;\n    \t}\n    \t\n    \t//add more cases here as need progresses\n    \t\n    \t//no notification for this message type, return false \t\n    \tlog.debug(\"ProfileLogic.isEmailEnabledForThisMessageType. False for userId: \" + userId + \", messageType: \" + messageType);  \n\n    \treturn false;\n\t}","commit_id":"2049fbde0bd78fd7116b7b5c0ed52a1bb6b7aab0","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * {@inheritDoc}\n\t */\n\tpublic void addEventToWalls(String event, String userUuid) {\n\n\t\t// get the connections of the creator of this content\n\t\tList<Person> connections = null;\n\t\tconnections = connectionsLogic.getConnectionsForUser(userUuid);\n\n\t\tif (null == connections || 0 == connections.size()) {\n\t\t\t// there are therefore no walls to post event to\n\t\t\treturn;\n\t\t}\n\n\t\tWallItem item = new WallItem();\n\n\t\titem.setCreatorUuid(userUuid);\n\t\titem.setType(ProfileConstants.WALL_ITEM_TYPE_EVENT);\n\t\titem.setDate(new Date());\n\t\t// this string is mapped to a localized resource string in GUI\n\t\titem.setText(event);\n\n\t\tfor (Person connection : connections) {\n\t\t\tdao.addNewWallItemForUser(connection.getUuid(), item);\n\n\t\t\tsendWallNotificationEmail(connection.getUuid(), userUuid,\n\t\t\t\t\tProfileConstants.EMAIL_NOTIFICATION_WALL_EVENT_NEW);\n\t\t}\n\t}","id":65326,"modified_method":"/**\n\t * {@inheritDoc}\n\t */\n\tpublic void addEventToWalls(String event, String userUuid) {\n\n\t\t// get the connections of the creator of this content\n\t\tList<Person> connections = null;\n\t\tconnections = connectionsLogic.getConnectionsForUser(userUuid);\n\n\t\tif (null == connections || 0 == connections.size()) {\n\t\t\t// there are therefore no walls to post event to\n\t\t\treturn;\n\t\t}\n\n\t\tWallItem wallItem = new WallItem();\n\n\t\twallItem.setCreatorUuid(userUuid);\n\t\twallItem.setType(ProfileConstants.WALL_ITEM_TYPE_EVENT);\n\t\twallItem.setDate(new Date());\n\t\t// this string is mapped to a localized resource string in GUI\n\t\twallItem.setText(event);\n\n\t\tfor (Person connection : connections) {\n\t\t\tdao.addNewWallItemForUser(connection.getUuid(), wallItem);\n\n\t\t\tsendWallNotificationEmail(connection.getUuid(), userUuid,\n\t\t\t\t\tProfileConstants.EMAIL_NOTIFICATION_WALL_EVENT_NEW);\n\t\t}\n\t}","commit_id":"2049fbde0bd78fd7116b7b5c0ed52a1bb6b7aab0","url":"https://github.com/sakaiproject/sakai"},{"original_method":"private void sendWallNotificationEmail(String toUuid,\n\t\t\tfinal String fromUuid, final int messageType) {\n\t\t\n\t\t// check if email preference enabled\n\t\tif(!preferencesLogic.isEmailEnabledForThisMessageType(toUuid, messageType)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (ProfileConstants.EMAIL_NOTIFICATION_WALL_EVENT_NEW == messageType) {\n\t\t\tString emailTemplateKey = ProfileConstants.EMAIL_TEMPLATE_KEY_WALL_EVENT_NEW;\n\t\t\t\n\t\t\t// create the map of replacement values for this email template\n\t\t\tMap<String,String> replacementValues = new HashMap<String,String>();\n\t\t\treplacementValues.put(\"senderDisplayName\", sakaiProxy.getUserDisplayName(fromUuid));\n\t\t\treplacementValues.put(\"localSakaiName\", sakaiProxy.getServiceName());\n\t\t\treplacementValues.put(\"profileLink\", linkLogic.getEntityLinkToProfileHome(toUuid));\n\t\t\treplacementValues.put(\"localSakaiUrl\", sakaiProxy.getPortalUrl());\n\t\t\treplacementValues.put(\"toolName\", sakaiProxy.getCurrentToolTitle());\n\t\n\t\t\tsakaiProxy.sendEmail(toUuid, emailTemplateKey, replacementValues);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// TODO wall posts\n\t}","id":65327,"modified_method":"private void sendWallNotificationEmail(String toUuid,\n\t\t\tfinal String fromUuid, final int messageType) {\n\n\t\t// check if email preference enabled\n\t\tif (!preferencesLogic.isEmailEnabledForThisMessageType(toUuid,\n\t\t\t\tmessageType)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// create the map of replacement values for this email template\n\t\tMap<String, String> replacementValues = new HashMap<String, String>();\n\t\treplacementValues.put(\"senderDisplayName\", sakaiProxy.getUserDisplayName(fromUuid));\n\t\treplacementValues.put(\"localSakaiName\", sakaiProxy.getServiceName());\n\t\treplacementValues.put(\"localSakaiUrl\", sakaiProxy.getPortalUrl());\n\t\treplacementValues.put(\"toolName\", sakaiProxy.getCurrentToolTitle());\n\t\t\n\t\tString emailTemplateKey = null;\n\t\t\n\t\tif (ProfileConstants.EMAIL_NOTIFICATION_WALL_EVENT_NEW == messageType) {\n\t\t\temailTemplateKey = ProfileConstants.EMAIL_TEMPLATE_KEY_WALL_EVENT_NEW;\t\t\t\n\t\t} else if (ProfileConstants.EMAIL_NOTIFICATION_WALL_POST_MY_NEW == messageType) {\n\t\t\temailTemplateKey = ProfileConstants.EMAIL_TEMPLATE_KEY_WALL_POST_MY_NEW;\n\t\t\t\n\t\t\treplacementValues.put(\"profileLink\", linkLogic.getEntityLinkToProfileHome(toUuid));\n\t\t\t\n\t\t} else if (ProfileConstants.EMAIL_NOTIFICATION_WALL_POST_CONNECTION_NEW == messageType) {\n\t\t\temailTemplateKey = ProfileConstants.EMAIL_TEMPLATE_KEY_WALL_POST_CONNECTION_NEW;\n\t\t\t\n\t\t\treplacementValues.put(\"profileLink\", linkLogic.getEntityLinkToProfileHome(fromUuid));\n\t\t}\n\t\t\n\t\tif (null != emailTemplateKey) {\n\t\t\tsakaiProxy.sendEmail(toUuid, emailTemplateKey, replacementValues);\n\t\t} else {\n\t\t\tlog.warn(\"not sending email, unknown message type: \" + messageType);\n\t\t}\n\n\t}","commit_id":"2049fbde0bd78fd7116b7b5c0ed52a1bb6b7aab0","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public WallItemPanel(String id, WallItem wallItem) {\n\t\tsuper(id);\n\n\t\t// image wrapper, links to profile\n\t\tLink<String> wallItemPhoto = new Link<String>(\"wallItemPhotoWrap\",\n\t\t\t\tnew Model<String>(wallItem.getCreatorUuid())) {\n\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void onClick() {\n\t\t\t\tsetResponsePage(new ViewProfile(getModelObject()));\n\t\t\t}\n\t\t};\n\n\t\t// image\n\t\twallItemPhoto.add(new ProfileImageRenderer(\"wallItemPhoto\", wallItem\n\t\t\t\t.getCreatorUuid()));\n\t\tadd(wallItemPhoto);\n\n\t\t// name and link to profile\n\t\tLink<String> wallItemProfileLink = new Link<String>(\n\t\t\t\t\"wallItemProfileLink\", new Model<String>(wallItem\n\t\t\t\t\t\t.getCreatorUuid())) {\n\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void onClick() {\n\t\t\t\tsetResponsePage(new ViewProfile(getModelObject()));\n\t\t\t}\n\n\t\t};\n\t\twallItemProfileLink.add(new Label(\"wallItemName\", sakaiProxy\n\t\t\t\t.getUserDisplayName(wallItem.getCreatorUuid())));\n\t\tadd(wallItemProfileLink);\n\n\t\tif (ProfileConstants.WALL_ITEM_TYPE_EVENT == wallItem.getType()) {\n\t\t\tadd(new Label(\"wallItemText\", new ResourceModel(wallItem.getText())));\n\t\t} else {\n\t\t\tadd(new Label(\"wallItemText\", wallItem.getText()));\n\t\t}\n\t\t\n\t\t// TODO date has scope for internationalization?\n\t\tadd(new Label(\"wallItemDate\", ProfileUtils.convertDateToString(wallItem\n\t\t\t\t.getDate(), \"dd MMMMM, kk:mm\")));\n\t}","id":65328,"modified_method":"public WallItemPanel(String id, WallItem wallItem) {\n\t\tsuper(id);\n\n\t\t// image wrapper, links to profile\n\t\tLink<String> wallItemPhoto = new Link<String>(\"wallItemPhotoWrap\",\n\t\t\t\tnew Model<String>(wallItem.getCreatorUuid())) {\n\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void onClick() {\n\t\t\t\tsetResponsePage(new ViewProfile(getModelObject()));\n\t\t\t}\n\t\t};\n\n\t\t// image\n\t\twallItemPhoto.add(new ProfileImageRenderer(\"wallItemPhoto\", wallItem\n\t\t\t\t.getCreatorUuid()));\n\t\tadd(wallItemPhoto);\n\n\t\t// name and link to profile\n\t\tLink<String> wallItemProfileLink = new Link<String>(\n\t\t\t\t\"wallItemProfileLink\", new Model<String>(wallItem\n\t\t\t\t\t\t.getCreatorUuid())) {\n\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void onClick() {\n\t\t\t\tsetResponsePage(new ViewProfile(getModelObject()));\n\t\t\t}\n\n\t\t};\n\t\twallItemProfileLink.add(new Label(\"wallItemName\", sakaiProxy\n\t\t\t\t.getUserDisplayName(wallItem.getCreatorUuid())));\n\t\tadd(wallItemProfileLink);\n\n\t\tif (ProfileConstants.WALL_ITEM_TYPE_EVENT == wallItem.getType()) {\n\t\t\tadd(new Label(\"wallItemText\", new ResourceModel(wallItem.getText())));\n\t\t} else if (ProfileConstants.WALL_ITEM_TYPE_POST == wallItem.getType()) {\n\t\t\tadd(new Label(\"wallItemText\", ProfileUtils.processHtml(wallItem.getText())).setEscapeModelStrings(false));\n\t\t} else {\n\t\t\tadd(new Label(\"wallItemText\", wallItem.getText()));\n\t\t}\n\t\t\n\t\t// TODO date has scope for internationalization?\n\t\tadd(new Label(\"wallItemDate\", ProfileUtils.convertDateToString(wallItem\n\t\t\t\t.getDate(), \"dd MMMMM, kk:mm\")));\n\t}","commit_id":"2049fbde0bd78fd7116b7b5c0ed52a1bb6b7aab0","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public FetchResults fetch(long start, long end, long step, int maxrows,\n            List<Source> sources) throws Exception {\n\n        final Map<String, Object> constants = Maps.newHashMap();\n\n        final Map<Source, String> rrdsBySource = Maps.newHashMap();\n        \n        for (final Source source : sources) {\n            // Grab the resource\n            final OnmsResource resource = m_resourceDao.getResourceById(source\n                    .getResourceId());\n            if (resource == null) {\n                LOG.error(\"No resource with id: {}\", source.getResourceId());\n                return null;\n            }\n\n            // Grab the attribute\n            RrdGraphAttribute rrdGraphAttribute = resource.getRrdGraphAttributes().get(source.getAttribute());\n\n            if (rrdGraphAttribute == null && !Strings.isNullOrEmpty(source.getFallbackAttribute())) {\n                LOG.error(\"No attribute with name '{}', using fallback-attribute with name '{}'\", source.getAttribute(), source.getFallbackAttribute());\n                source.setAttribute(source.getFallbackAttribute());\n                source.setFallbackAttribute(null);\n                rrdGraphAttribute = resource.getRrdGraphAttributes().get(source.getAttribute());\n            }\n\n            if (rrdGraphAttribute == null) {\n                LOG.error(\"No attribute with name: {}\", source.getAttribute());\n                return null;\n            }\n\n            // Gather the values from strings.properties\n            Utils.convertStringAttributesToConstants(source.getLabel(), resource.getStringPropertyAttributes(), constants);\n\n            // Build the path to the archive\n            final String rrdFile = System.getProperty(\"rrd.base.dir\")\n                    + File.separator + rrdGraphAttribute.getRrdRelativePath();\n\n            rrdsBySource.put(source, rrdFile);\n        }\n\n        // Fetch\n        return fetchMeasurements(start, end, step, maxrows, rrdsBySource, constants);\n    }","id":65329,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public FetchResults fetch(long start, long end, long step, int maxrows,\n            Long interval, Long heartbeat, List<Source> sources) throws Exception {\n\n        final Map<String, Object> constants = Maps.newHashMap();\n\n        final Map<Source, String> rrdsBySource = Maps.newHashMap();\n        \n        for (final Source source : sources) {\n            // Grab the resource\n            final OnmsResource resource = m_resourceDao.getResourceById(source\n                    .getResourceId());\n            if (resource == null) {\n                LOG.error(\"No resource with id: {}\", source.getResourceId());\n                return null;\n            }\n\n            // Grab the attribute\n            RrdGraphAttribute rrdGraphAttribute = resource.getRrdGraphAttributes().get(source.getAttribute());\n\n            if (rrdGraphAttribute == null && !Strings.isNullOrEmpty(source.getFallbackAttribute())) {\n                LOG.error(\"No attribute with name '{}', using fallback-attribute with name '{}'\", source.getAttribute(), source.getFallbackAttribute());\n                source.setAttribute(source.getFallbackAttribute());\n                source.setFallbackAttribute(null);\n                rrdGraphAttribute = resource.getRrdGraphAttributes().get(source.getAttribute());\n            }\n\n            if (rrdGraphAttribute == null) {\n                LOG.error(\"No attribute with name: {}\", source.getAttribute());\n                return null;\n            }\n\n            // Gather the values from strings.properties\n            Utils.convertStringAttributesToConstants(source.getLabel(), resource.getStringPropertyAttributes(), constants);\n\n            // Build the path to the archive\n            final String rrdFile = System.getProperty(\"rrd.base.dir\")\n                    + File.separator + rrdGraphAttribute.getRrdRelativePath();\n\n            rrdsBySource.put(source, rrdFile);\n        }\n\n        // Fetch\n        return fetchMeasurements(start, end, step, maxrows, rrdsBySource, constants);\n    }","commit_id":"e83918a01bb811b4b5cf3cd25c07eeaffb69e7c7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test(expected = javax.ws.rs.WebApplicationException.class)\n    public void cannotRetrieveUnknownAttributeAndUnknownFallbackAttribute() {\n        QueryRequest request = new QueryRequest();\n        request.setStart(1414602000000L);\n        request.setEnd(1417046400000L);\n        request.setStep(1000L);\n        request.setMaxRows(700);\n\n        // Average\n        Source ifInOctetsAvg = new Source();\n        ifInOctetsAvg.setResourceId(\"node[1].interfaceSnmp[eth0-04013f75f101]\");\n        ifInOctetsAvg.setAttribute(\"willNotBeFound\");\n        ifInOctetsAvg.setFallbackAttribute(\"willNotBeFoundToo\");\n        ifInOctetsAvg.setAggregation(\"AVERAGE\");\n        ifInOctetsAvg.setLabel(\"ifInOctetsAvg\");\n\n        request.setSources(Lists.newArrayList(\n                ifInOctetsAvg\n        ));\n\n        // Perform the query - this must fail\n        QueryResponse response = m_svc.query(request);\n    }","id":65330,"modified_method":"@Test(expected = javax.ws.rs.WebApplicationException.class)\n    public void cannotRetrieveUnknownAttributeAndUnknownFallbackAttribute() {\n        QueryRequest request = new QueryRequest();\n        request.setStart(1414602000000L);\n        request.setEnd(1417046400000L);\n        request.setStep(1000L);\n        request.setMaxRows(700);\n\n        // Average\n        Source ifInOctetsAvg = new Source();\n        ifInOctetsAvg.setResourceId(\"node[1].interfaceSnmp[eth0-04013f75f101]\");\n        ifInOctetsAvg.setAttribute(\"willNotBeFound\");\n        ifInOctetsAvg.setFallbackAttribute(\"willNotBeFoundToo\");\n        ifInOctetsAvg.setAggregation(\"AVERAGE\");\n        ifInOctetsAvg.setLabel(\"ifInOctetsAvg\");\n\n        request.setSources(Lists.newArrayList(\n                ifInOctetsAvg\n        ));\n\n        // Perform the query - this must fail\n        m_svc.query(request);\n    }","commit_id":"e83918a01bb811b4b5cf3cd25c07eeaffb69e7c7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public QueryResponse query(QueryRequest request) throws MeasurementException {\n        validate(request);\n\n        // Fetch the measurements\n        FetchResults results;\n        try {\n            results = fetchStrategy.fetch(\n                    request.getStart(),\n                    request.getEnd(),\n                    request.getStep(),\n                    request.getMaxRows(),\n                    request.getSources());\n        } catch (Exception e) {\n            throw new FetchException(e, \"Fetch failed: {}\", e.getMessage());\n        }\n        if (results == null) {\n            throw new ResourceNotFoundException(request);\n        }\n\n        // Apply the expression to the fetch results\n        expressionEngine.applyExpressions(request, results);\n\n        // Apply the filters\n        if (!request.getFilters().isEmpty()) {\n            RowSortedTable<Long, String, Double> table = results.asRowSortedTable();\n            filterEngine.filter(request.getFilters(), table);\n            results = new FetchResults(table, results.getStep(), results.getConstants());\n        }\n\n        // Remove any transient values belonging to sources\n        final Map<String, double[]> columns = results.getColumns();\n        for (final Source source : request.getSources()) {\n            if (source.getTransient()) {\n                columns.remove(source.getLabel());\n            }\n        }\n\n        // Build the response\n        final QueryResponse response = new QueryResponse();\n        response.setStart(request.getStart());\n        response.setEnd(request.getEnd());\n        response.setStep(results.getStep());\n        response.setTimestamps(results.getTimestamps());\n        response.setColumns(results.getColumns());\n        return response;\n    }","id":65331,"modified_method":"public QueryResponse query(QueryRequest request) throws MeasurementException {\n        validate(request);\n\n        // Fetch the measurements\n        FetchResults results;\n        try {\n            results = fetchStrategy.fetch(\n                    request.getStart(),\n                    request.getEnd(),\n                    request.getStep(),\n                    request.getMaxRows(),\n                    request.getHeartbeat(),\n                    request.getInterval(),\n                    request.getSources());\n        } catch (Exception e) {\n            throw new FetchException(e, \"Fetch failed: {}\", e.getMessage());\n        }\n        if (results == null) {\n            throw new ResourceNotFoundException(request);\n        }\n\n        // Apply the expression to the fetch results\n        expressionEngine.applyExpressions(request, results);\n\n        // Apply the filters\n        if (!request.getFilters().isEmpty()) {\n            RowSortedTable<Long, String, Double> table = results.asRowSortedTable();\n            filterEngine.filter(request.getFilters(), table);\n            results = new FetchResults(table, results.getStep(), results.getConstants());\n        }\n\n        // Remove any transient values belonging to sources\n        final Map<String, double[]> columns = results.getColumns();\n        for (final Source source : request.getSources()) {\n            if (source.getTransient()) {\n                columns.remove(source.getLabel());\n            }\n        }\n\n        // Build the response\n        final QueryResponse response = new QueryResponse();\n        response.setStart(request.getStart());\n        response.setEnd(request.getEnd());\n        response.setStep(results.getStep());\n        response.setTimestamps(results.getTimestamps());\n        response.setColumns(results.getColumns());\n        return response;\n    }","commit_id":"e83918a01bb811b4b5cf3cd25c07eeaffb69e7c7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public FetchResults fetch(long start, long end, long step, int maxrows, List<Source> sources) {\n        // Limit the step with a lower bound in order to prevent extremely large queries\n        long boundedStep = Math.max(STEP_LOWER_BOUND_IN_MS, step);\n        if (boundedStep != step) {\n            LOG.warn(\"Requested step size {} is too small. Using {}.\", step, boundedStep);\n        }\n\n        // Make sure the fetchStep is evenly divisible by the INTERVAL_DIVIDER\n        if (boundedStep % INTERVAL_DIVIDER != 0) {\n            boundedStep += boundedStep % INTERVAL_DIVIDER;\n        }\n        final long stepInMs = boundedStep;\n        long intervalInMs = stepInMs / INTERVAL_DIVIDER;\n\n        final Optional<Timestamp> startTs = Optional.of(Timestamp.fromEpochMillis(start));\n        final Optional<Timestamp> endTs = Optional.of(Timestamp.fromEpochMillis(end));\n        final Map<String, Object> constants = Maps.newHashMap();\n\n        // Group the sources by resource id to avoid calling the ResourceDao\n        // multiple times for the same resource\n        Map<String, List<Source>> sourcesByResourceId = sources.stream()\n                .collect(Collectors.groupingBy(Source::getResourceId));\n\n        // Lookup the resources in parallel\n        Map<OnmsResource, List<Source>> sourcesByResource = sourcesByResourceId.entrySet()\n                .parallelStream()\n                .collect(Collectors.toMap(\n                    e -> {\n                        final OnmsResource resource = m_resourceDao.getResourceById(e.getKey());\n                        if (resource == null) {\n                            LOG.error(\"No resource with id: {}\", e.getKey());\n                            throw new IllegalArgumentException(\"No resource with id: \" + e.getKey());\n                        }\n                        // The attributes are typically lazy loaded, so we trigger the load here\n                        // while we're in a parallel context\n                        resource.getAttributes();\n                        return resource;\n                    },\n                    e -> e.getValue()\n                    ));\n\n        // Now group the sources by Newts Resource ID, which differs from the OpenNMS Resource ID.\n        Map<String, List<Source>> sourcesByNewtsResourceId = Maps.newHashMap();\n        for (Entry<OnmsResource, List<Source>> entry : sourcesByResource.entrySet()) {\n            final OnmsResource resource = entry.getKey();\n            for (Source source : entry.getValue()) {\n                // Gather the values from strings.properties\n                Utils.convertStringAttributesToConstants(source.getLabel(), resource.getStringPropertyAttributes(), constants);\n\n                // Grab the attribute that matches the source\n                RrdGraphAttribute rrdGraphAttribute = resource.getRrdGraphAttributes().get(source.getAttribute());\n\n                if (rrdGraphAttribute == null && !Strings.isNullOrEmpty(source.getFallbackAttribute())) {\n                    LOG.error(\"No attribute with name '{}', using fallback-attribute with name '{}'\", source.getAttribute(), source.getFallbackAttribute());\n                    source.setAttribute(source.getFallbackAttribute());\n                    source.setFallbackAttribute(null);\n                    rrdGraphAttribute = resource.getRrdGraphAttributes().get(source.getAttribute());\n                }\n\n                if (rrdGraphAttribute == null) {\n                    LOG.error(\"No attribute with name: {}\", source.getAttribute());\n                    return null;\n                }\n\n                // The Newts Resource ID is stored in the rrdFile attribute\n                String newtsResourceId = rrdGraphAttribute.getRrdRelativePath();\n                // Remove the file separator prefix, added by the RrdGraphAttribute class\n                if (newtsResourceId.startsWith(File.separator)) {\n                    newtsResourceId = newtsResourceId.substring(File.separator.length(), newtsResourceId.length());\n                }\n\n                List<Source> listOfSources = sourcesByNewtsResourceId.get(newtsResourceId);\n                // Create the list if it doesn't exist\n                if (listOfSources == null) {\n                    listOfSources = Lists.newLinkedList();\n                    sourcesByNewtsResourceId.put(newtsResourceId, listOfSources);\n                }\n                listOfSources.add(source);\n            }\n        }\n\n        // The Newts API only allows us to perform a query using a single (Newts) Resource ID,\n        // so we perform multiple queries in parallel, and aggregate the results.\n        final AtomicReference<long[]> timestamps = new AtomicReference<>();\n        final Map<String, double[]> columns = Maps.newConcurrentMap();\n\n        sourcesByNewtsResourceId.entrySet().parallelStream().forEach(entry -> {\n            final String newtsResourceId = entry.getKey();\n            final List<Source> listOfSources = entry.getValue();\n\n            ResultDescriptor resultDescriptor = new ResultDescriptor(intervalInMs);\n            for (Source source : listOfSources) {\n                final String metricName = source.getAttribute();\n                final String name = source.getLabel();\n                final AggregationFunction fn = toAggregationFunction(source.getAggregation());\n\n                resultDescriptor.datasource(name, metricName, HEARTBEAT_MULTIPLIER*intervalInMs, fn);\n                resultDescriptor.export(name);\n            }\n\n            LOG.debug(\"Querying Newts for resource id {} with result descriptor: {}\", newtsResourceId, resultDescriptor);\n            Results<Measurement> results = m_sampleRepository.select(m_context, new Resource(newtsResourceId), startTs, endTs,\n                    resultDescriptor, Optional.of(Duration.millis(stepInMs)));\n            Collection<Row<Measurement>> rows = results.getRows();\n            LOG.debug(\"Found {} rows.\", rows.size());\n\n            final int N = rows.size();\n            final Map<String, double[]> myColumns = Maps.newHashMap();\n\n            timestamps.updateAndGet(existing -> {\n                if (existing == null) {\n                    // this is the first thread that has returned, build the array of timestamps\n                    // the timestamps should bet the same against all result sets\n                    final long[] tses = new long[rows.size()];\n                    int k=0;\n                    for (final Row<Measurement> row : results.getRows()) {\n                        tses[k] = row.getTimestamp().asMillis();\n                        k++;\n                    }\n                    return tses;\n                }\n                return existing;\n            });\n\n            int k = 0;\n            for (Row<Measurement> row : results.getRows()) {\n                for (Measurement measurement : row.getElements()) {\n                    double[] column = myColumns.get(measurement.getName());\n                    if (column == null) {\n                        column = new double[N];\n                        myColumns.put(measurement.getName(), column);\n                    }\n                    column[k] = measurement.getValue();\n                }\n                k += 1;\n            }\n\n            columns.putAll(myColumns);\n        });\n\n        FetchResults fetchResults = new FetchResults(timestamps.get(), columns, stepInMs, constants);\n        LOG.trace(\"Fetch results: {}\", fetchResults);\n        return fetchResults;\n    }","id":65332,"modified_method":"@Override\n    public FetchResults fetch(long start, long end, long step, int maxrows, Long interval, Long heartbeat, List<Source> sources) {\n        // Limit the step with a lower bound in order to prevent extremely large queries\n        long effectiveStep = Math.max(STEP_LOWER_BOUND_IN_MS, step);\n        if (effectiveStep != step) {\n            LOG.warn(\"Requested step size {} is too small. Using {}.\", step, effectiveStep);\n        }\n\n        long effectiveInterval;\n        if (interval == null) {\n            // Make sure the fetchStep is evenly divisible by the INTERVAL_DIVIDER\n            if (effectiveStep % INTERVAL_DIVIDER != 0) {\n                effectiveStep += effectiveStep % INTERVAL_DIVIDER;\n            }\n            effectiveInterval = effectiveStep / INTERVAL_DIVIDER;\n        } else {\n            effectiveInterval = interval;\n        }\n\n        long effectiveHeartbeat;\n        if (heartbeat == null) {\n            effectiveHeartbeat = effectiveInterval * HEARTBEAT_MULTIPLIER;\n        } else {\n            effectiveHeartbeat = heartbeat;\n        }\n\n        // We need effectiveStep to be final, so we redefine it here\n        final long effectiveStepInMs = effectiveStep;\n        final Optional<Timestamp> startTs = Optional.of(Timestamp.fromEpochMillis(start));\n        final Optional<Timestamp> endTs = Optional.of(Timestamp.fromEpochMillis(end));\n        final Map<String, Object> constants = Maps.newHashMap();\n\n        // Group the sources by resource id to avoid calling the ResourceDao\n        // multiple times for the same resource\n        Map<String, List<Source>> sourcesByResourceId = sources.stream()\n                .collect(Collectors.groupingBy(Source::getResourceId));\n\n        // Lookup the resources in parallel\n        Map<OnmsResource, List<Source>> sourcesByResource = sourcesByResourceId.entrySet()\n                .parallelStream()\n                .collect(Collectors.toMap(\n                    e -> {\n                        final OnmsResource resource = m_resourceDao.getResourceById(e.getKey());\n                        if (resource == null) {\n                            LOG.error(\"No resource with id: {}\", e.getKey());\n                            throw new IllegalArgumentException(\"No resource with id: \" + e.getKey());\n                        }\n                        // The attributes are typically lazy loaded, so we trigger the load here\n                        // while we're in a parallel context\n                        resource.getAttributes();\n                        return resource;\n                    },\n                    e -> e.getValue()\n                    ));\n\n        // Now group the sources by Newts Resource ID, which differs from the OpenNMS Resource ID.\n        Map<String, List<Source>> sourcesByNewtsResourceId = Maps.newHashMap();\n        for (Entry<OnmsResource, List<Source>> entry : sourcesByResource.entrySet()) {\n            final OnmsResource resource = entry.getKey();\n            for (Source source : entry.getValue()) {\n                // Gather the values from strings.properties\n                Utils.convertStringAttributesToConstants(source.getLabel(), resource.getStringPropertyAttributes(), constants);\n\n                // Grab the attribute that matches the source\n                RrdGraphAttribute rrdGraphAttribute = resource.getRrdGraphAttributes().get(source.getAttribute());\n\n                if (rrdGraphAttribute == null && !Strings.isNullOrEmpty(source.getFallbackAttribute())) {\n                    LOG.error(\"No attribute with name '{}', using fallback-attribute with name '{}'\", source.getAttribute(), source.getFallbackAttribute());\n                    source.setAttribute(source.getFallbackAttribute());\n                    source.setFallbackAttribute(null);\n                    rrdGraphAttribute = resource.getRrdGraphAttributes().get(source.getAttribute());\n                }\n\n                if (rrdGraphAttribute == null) {\n                    LOG.error(\"No attribute with name: {}\", source.getAttribute());\n                    return null;\n                }\n\n                // The Newts Resource ID is stored in the rrdFile attribute\n                String newtsResourceId = rrdGraphAttribute.getRrdRelativePath();\n                // Remove the file separator prefix, added by the RrdGraphAttribute class\n                if (newtsResourceId.startsWith(File.separator)) {\n                    newtsResourceId = newtsResourceId.substring(File.separator.length(), newtsResourceId.length());\n                }\n\n                List<Source> listOfSources = sourcesByNewtsResourceId.get(newtsResourceId);\n                // Create the list if it doesn't exist\n                if (listOfSources == null) {\n                    listOfSources = Lists.newLinkedList();\n                    sourcesByNewtsResourceId.put(newtsResourceId, listOfSources);\n                }\n                listOfSources.add(source);\n            }\n        }\n\n        // The Newts API only allows us to perform a query using a single (Newts) Resource ID,\n        // so we perform multiple queries in parallel, and aggregate the results.\n        final AtomicReference<long[]> timestamps = new AtomicReference<>();\n        final Map<String, double[]> columns = Maps.newConcurrentMap();\n\n        sourcesByNewtsResourceId.entrySet().parallelStream().forEach(entry -> {\n            final String newtsResourceId = entry.getKey();\n            final List<Source> listOfSources = entry.getValue();\n\n            ResultDescriptor resultDescriptor = new ResultDescriptor(effectiveInterval);\n            for (Source source : listOfSources) {\n                final String metricName = source.getAttribute();\n                final String name = source.getLabel();\n                final AggregationFunction fn = toAggregationFunction(source.getAggregation());\n\n                resultDescriptor.datasource(name, metricName, effectiveHeartbeat, fn);\n                resultDescriptor.export(name);\n            }\n\n            LOG.debug(\"Querying Newts for resource id {} with result descriptor: {}\", newtsResourceId, resultDescriptor);\n            Results<Measurement> results = m_sampleRepository.select(m_context, new Resource(newtsResourceId), startTs, endTs,\n                    resultDescriptor, Optional.of(Duration.millis(effectiveStepInMs)));\n            Collection<Row<Measurement>> rows = results.getRows();\n            LOG.debug(\"Found {} rows.\", rows.size());\n\n            final int N = rows.size();\n            final Map<String, double[]> myColumns = Maps.newHashMap();\n\n            timestamps.updateAndGet(existing -> {\n                if (existing == null) {\n                    // this is the first thread that has returned, build the array of timestamps\n                    // the timestamps should bet the same against all result sets\n                    final long[] tses = new long[rows.size()];\n                    int k=0;\n                    for (final Row<Measurement> row : results.getRows()) {\n                        tses[k] = row.getTimestamp().asMillis();\n                        k++;\n                    }\n                    return tses;\n                }\n                return existing;\n            });\n\n            int k = 0;\n            for (Row<Measurement> row : results.getRows()) {\n                for (Measurement measurement : row.getElements()) {\n                    double[] column = myColumns.get(measurement.getName());\n                    if (column == null) {\n                        column = new double[N];\n                        myColumns.put(measurement.getName(), column);\n                    }\n                    column[k] = measurement.getValue();\n                }\n                k += 1;\n            }\n\n            columns.putAll(myColumns);\n        });\n\n        FetchResults fetchResults = new FetchResults(timestamps.get(), columns, effectiveStep, constants);\n        LOG.trace(\"Fetch results: {}\", fetchResults);\n        return fetchResults;\n    }","commit_id":"e83918a01bb811b4b5cf3cd25c07eeaffb69e7c7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void cannotRetrieveUnknownAttributeAndUnknownFallbackAttribute() {\n        List<Source> sources = Lists.newArrayList(\n                createMockResource(\"icmplocalhost\", \"shouldNotBeFound\", \"127.0.0.1\", false)\n        );\n        replay();\n\n        Source sourceToBeFetched = new Source();\n        sourceToBeFetched.setResourceId(\"nodeSource[NODES:1505998205].responseTime[127.0.0.1]\");\n        sourceToBeFetched.setAttribute(\"willNotBeFound\");\n        sourceToBeFetched.setFallbackAttribute(\"willNotBeFoundToo\");\n        sourceToBeFetched.setAggregation(\"AVERAGE\");\n        sourceToBeFetched.setLabel(\"icmp\");\n\n        FetchResults fetchResults = m_newtsFetchStrategy.fetch(1431047069000L - (60 * 60 * 1000), 1431047069000L, 300 * 1000, 0, Lists.newArrayList(sourceToBeFetched));\n        assertNull(fetchResults);\n    }","id":65333,"modified_method":"@Test\n    public void cannotRetrieveUnknownAttributeAndUnknownFallbackAttribute() {\n        createMockResource(\"icmplocalhost\", \"shouldNotBeFound\", \"127.0.0.1\", false);\n        replay();\n\n        Source sourceToBeFetched = new Source();\n        sourceToBeFetched.setResourceId(\"nodeSource[NODES:1505998205].responseTime[127.0.0.1]\");\n        sourceToBeFetched.setAttribute(\"willNotBeFound\");\n        sourceToBeFetched.setFallbackAttribute(\"willNotBeFoundToo\");\n        sourceToBeFetched.setAggregation(\"AVERAGE\");\n        sourceToBeFetched.setLabel(\"icmp\");\n\n        FetchResults fetchResults = m_newtsFetchStrategy.fetch(1431047069000L - (60 * 60 * 1000), 1431047069000L, 300 * 1000, 0, null, null, Lists.newArrayList(sourceToBeFetched));\n        assertNull(fetchResults);\n    }","commit_id":"e83918a01bb811b4b5cf3cd25c07eeaffb69e7c7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void canRetrieveAttributeWhenFallbackAttributeIsSet() throws Exception {\n        List<Source> sources = Lists.newArrayList(\n                createMockResource(\"icmplocalhost\", \"icmp\", \"127.0.0.1\")\n        );\n        replay();\n\n        Source sourceToBeFetched = new Source();\n        sourceToBeFetched.setResourceId(\"nodeSource[NODES:1505998205].responseTime[127.0.0.1]\");\n        sourceToBeFetched.setAttribute(\"icmp\");\n        sourceToBeFetched.setFallbackAttribute(\"willNotBeFound\");\n        sourceToBeFetched.setAggregation(\"AVERAGE\");\n        sourceToBeFetched.setLabel(\"icmp\");\n\n        FetchResults fetchResults = m_newtsFetchStrategy.fetch(1431047069000L - (60 * 60 * 1000), 1431047069000L, 300 * 1000, 0, Lists.newArrayList(sourceToBeFetched));\n        assertEquals(1, fetchResults.getColumns().keySet().size());\n        assertTrue(fetchResults.getColumns().containsKey(\"icmplocalhost\"));\n        assertEquals(1, fetchResults.getTimestamps().length);\n    }","id":65334,"modified_method":"@Test\n    public void canRetrieveAttributeWhenFallbackAttributeIsSet() throws Exception {\n        createMockResource(\"icmplocalhost\", \"icmp\", \"127.0.0.1\");\n        replay();\n\n        Source sourceToBeFetched = new Source();\n        sourceToBeFetched.setResourceId(\"nodeSource[NODES:1505998205].responseTime[127.0.0.1]\");\n        sourceToBeFetched.setAttribute(\"icmp\");\n        sourceToBeFetched.setFallbackAttribute(\"willNotBeFound\");\n        sourceToBeFetched.setAggregation(\"AVERAGE\");\n        sourceToBeFetched.setLabel(\"icmp\");\n\n        FetchResults fetchResults = m_newtsFetchStrategy.fetch(1431047069000L - (60 * 60 * 1000), 1431047069000L, 300 * 1000, 0, null, null, Lists.newArrayList(sourceToBeFetched));\n        assertEquals(1, fetchResults.getColumns().keySet().size());\n        assertTrue(fetchResults.getColumns().containsKey(\"icmplocalhost\"));\n        assertEquals(1, fetchResults.getTimestamps().length);\n    }","commit_id":"e83918a01bb811b4b5cf3cd25c07eeaffb69e7c7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testFetchWithDuplicateResources() throws Exception {\n        List<Source> sources = Lists.newArrayList(\n            createMockResource(\"icmp\", \"icmp\", \"127.0.0.1\"),\n            createMockResource(\"icmp\", \"icmp\", \"192.168.0.1\")\n        );\n        replay();\n\n        FetchResults fetchResults = m_newtsFetchStrategy.fetch(1431047069000L - (60 * 60 * 1000), 1431047069000L, 300 * 1000, 0, sources);\n        // It's not possible to fetch multiple resources with the same label, we should only get 1 ICMP result\n        assertEquals(1, fetchResults.getColumns().keySet().size());\n    }","id":65335,"modified_method":"@Test\n    public void testFetchWithDuplicateResources() throws Exception {\n        List<Source> sources = Lists.newArrayList(\n            createMockResource(\"icmp\", \"icmp\", \"127.0.0.1\"),\n            createMockResource(\"icmp\", \"icmp\", \"192.168.0.1\")\n        );\n        replay();\n\n        FetchResults fetchResults = m_newtsFetchStrategy.fetch(1431047069000L - (60 * 60 * 1000), 1431047069000L, 300 * 1000, 0, null, null, sources);\n        // It's not possible to fetch multiple resources with the same label, we should only get 1 ICMP result\n        assertEquals(1, fetchResults.getColumns().keySet().size());\n    }","commit_id":"e83918a01bb811b4b5cf3cd25c07eeaffb69e7c7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void canRetrieveFallbackAttributeWhenAttributeNotFound() throws Exception {\n        List<Source> sources = Lists.newArrayList(\n                createMockResource(\"icmplocalhost\", \"icmp\", \"127.0.0.1\")\n        );\n        replay();\n\n        Source sourceToBeFetched = new Source();\n        sourceToBeFetched.setResourceId(\"nodeSource[NODES:1505998205].responseTime[127.0.0.1]\");\n        sourceToBeFetched.setAttribute(\"willNotBeFound\");\n        sourceToBeFetched.setFallbackAttribute(\"icmp\");\n        sourceToBeFetched.setAggregation(\"AVERAGE\");\n        sourceToBeFetched.setLabel(\"icmp\");\n\n        FetchResults fetchResults = m_newtsFetchStrategy.fetch(1431047069000L - (60 * 60 * 1000), 1431047069000L, 300 * 1000, 0, Lists.newArrayList(sourceToBeFetched));\n        assertEquals(1, fetchResults.getColumns().keySet().size());\n        assertTrue(fetchResults.getColumns().containsKey(\"icmplocalhost\"));\n        assertEquals(1, fetchResults.getTimestamps().length);\n    }","id":65336,"modified_method":"@Test\n    public void canRetrieveFallbackAttributeWhenAttributeNotFound() throws Exception {\n        createMockResource(\"icmplocalhost\", \"icmp\", \"127.0.0.1\");\n        replay();\n\n        Source sourceToBeFetched = new Source();\n        sourceToBeFetched.setResourceId(\"nodeSource[NODES:1505998205].responseTime[127.0.0.1]\");\n        sourceToBeFetched.setAttribute(\"willNotBeFound\");\n        sourceToBeFetched.setFallbackAttribute(\"icmp\");\n        sourceToBeFetched.setAggregation(\"AVERAGE\");\n        sourceToBeFetched.setLabel(\"icmp\");\n\n        FetchResults fetchResults = m_newtsFetchStrategy.fetch(1431047069000L - (60 * 60 * 1000), 1431047069000L, 300 * 1000, 0, null, null, Lists.newArrayList(sourceToBeFetched));\n        assertEquals(1, fetchResults.getColumns().keySet().size());\n        assertTrue(fetchResults.getColumns().containsKey(\"icmplocalhost\"));\n        assertEquals(1, fetchResults.getTimestamps().length);\n    }","commit_id":"e83918a01bb811b4b5cf3cd25c07eeaffb69e7c7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testFetch() throws Exception {\n        List<Source> sources = Lists.newArrayList(\n            createMockResource(\"icmplocalhost\", \"icmp\", \"127.0.0.1\"),\n            createMockResource(\"snmplocalhost\", \"snmp\", \"127.0.0.1\"),\n            createMockResource(\"snmp192\", \"snmp\", \"192.168.0.1\")\n        );\n        replay();\n\n        FetchResults fetchResults = m_newtsFetchStrategy.fetch(1431047069000L - (60 * 60 * 1000), 1431047069000L, 300 * 1000, 0, sources);\n        assertEquals(3, fetchResults.getColumns().keySet().size());\n        assertTrue(fetchResults.getColumns().containsKey(\"icmplocalhost\"));\n        assertTrue(fetchResults.getColumns().containsKey(\"snmplocalhost\"));\n        assertTrue(fetchResults.getColumns().containsKey(\"snmp192\"));\n        assertEquals(1, fetchResults.getTimestamps().length);\n    }","id":65337,"modified_method":"@Test\n    public void testFetch() throws Exception {\n        List<Source> sources = Lists.newArrayList(\n            createMockResource(\"icmplocalhost\", \"icmp\", \"127.0.0.1\"),\n            createMockResource(\"snmplocalhost\", \"snmp\", \"127.0.0.1\"),\n            createMockResource(\"snmp192\", \"snmp\", \"192.168.0.1\")\n        );\n        replay();\n\n        FetchResults fetchResults = m_newtsFetchStrategy.fetch(1431047069000L - (60 * 60 * 1000), 1431047069000L, 300 * 1000, 0, null, null, sources);\n        assertEquals(3, fetchResults.getColumns().keySet().size());\n        assertTrue(fetchResults.getColumns().containsKey(\"icmplocalhost\"));\n        assertTrue(fetchResults.getColumns().containsKey(\"snmplocalhost\"));\n        assertTrue(fetchResults.getColumns().containsKey(\"snmp192\"));\n        assertEquals(1, fetchResults.getTimestamps().length);\n    }","commit_id":"e83918a01bb811b4b5cf3cd25c07eeaffb69e7c7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public FetchResults fetch(long start, long end, long step, int maxrows,\n            List<Source> sources) throws Exception {\n        return null;\n    }","id":65338,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public FetchResults fetch(long start, long end, long step, int maxrows,\n            Long interval, Long heartbeat,\n            List<Source> sources) throws Exception {\n        return null;\n    }","commit_id":"e83918a01bb811b4b5cf3cd25c07eeaffb69e7c7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public String toString() {\n       return com.google.common.base.Objects.toStringHelper(this)\n                 .add(\"Step\", this.step)\n                 .add(\"Start\", this.start)\n                 .add(\"End\", this.end)\n                 .add(\"Sources\", this.sources)\n                 .add(\"Expressions\", this.expressions)\n                 .add(\"Filters\", this.filters)\n                 .toString();\n    }","id":65339,"modified_method":"@Override\n    public String toString() {\n       return com.google.common.base.Objects.toStringHelper(this)\n                 .add(\"Step\", this.step)\n                 .add(\"Start\", this.start)\n                 .add(\"End\", this.end)\n                 .add(\"Max Rows\", this.maxrows)\n                 .add(\"Interval\", this.interval)\n                 .add(\"Heartbeat\", this.heartbeat)\n                 .add(\"Sources\", this.sources)\n                 .add(\"Expressions\", this.expressions)\n                 .add(\"Filters\", this.filters)\n                 .toString();\n    }","commit_id":"e83918a01bb811b4b5cf3cd25c07eeaffb69e7c7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public int hashCode() {\n       return com.google.common.base.Objects.hashCode(\n                 this.step, this.start, this.end, this.sources, this.expressions, this.filters);\n    }","id":65340,"modified_method":"@Override\n    public int hashCode() {\n       return com.google.common.base.Objects.hashCode(\n                 this.step, this.start, this.end, this.maxrows, this.interval,\n                 this.heartbeat ,this.sources, this.expressions, this.filters);\n    }","commit_id":"e83918a01bb811b4b5cf3cd25c07eeaffb69e7c7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public boolean equals(Object obj) {\n       if (obj == null) {\n          return false;\n       }\n       if (getClass() != obj.getClass()) {\n          return false;\n       }\n       final QueryRequest other = (QueryRequest) obj;\n\n       return   com.google.common.base.Objects.equal(this.step, other.step)\n             && com.google.common.base.Objects.equal(this.start, other.start)\n             && com.google.common.base.Objects.equal(this.end, other.end)\n             && com.google.common.base.Objects.equal(this.sources, other.sources)\n             && com.google.common.base.Objects.equal(this.expressions, other.expressions)\n             && com.google.common.base.Objects.equal(this.filters, other.filters);\n    }","id":65341,"modified_method":"@Override\n    public boolean equals(Object obj) {\n       if (obj == null) {\n          return false;\n       }\n       if (getClass() != obj.getClass()) {\n          return false;\n       }\n       final QueryRequest other = (QueryRequest) obj;\n\n       return   com.google.common.base.Objects.equal(this.step, other.step)\n             && com.google.common.base.Objects.equal(this.start, other.start)\n             && com.google.common.base.Objects.equal(this.end, other.end)\n             && com.google.common.base.Objects.equal(this.maxrows, other.maxrows)\n             && com.google.common.base.Objects.equal(this.interval, other.interval)\n             && com.google.common.base.Objects.equal(this.heartbeat, other.heartbeat)\n             && com.google.common.base.Objects.equal(this.sources, other.sources)\n             && com.google.common.base.Objects.equal(this.expressions, other.expressions)\n             && com.google.common.base.Objects.equal(this.filters, other.filters);\n    }","commit_id":"e83918a01bb811b4b5cf3cd25c07eeaffb69e7c7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void validate(QueryRequest request) throws ValidationException {\n        if (request.getEnd() < 0) {\n            throw new ValidationException(\"Query end must be >= 0: {}\", request.getEnd());\n        }\n        if (request.getStep() <= 0) {\n            throw new ValidationException(\"Query step must be > 0: {}\", request.getStep());\n        }\n\n        final Map<String,String> labels = new HashMap<>();\n        for (final Source source : request.getSources()) {\n            if (source.getResourceId() == null\n                    || source.getAttribute() == null\n                    || source.getLabel() == null\n                    || source.getAggregation() == null) {\n                throw new ValidationException(\"Query source fields must be set: {}\", source);\n            }\n            if (labels.containsKey(source.getLabel())) {\n                throw new ValidationException(\"Query source label '{}' conflict: source with that label is already defined.\", source.getLabel());\n            } else {\n                labels.put(source.getLabel(), \"source\");\n            }\n        }\n        for (final Expression expression : request.getExpressions()) {\n            if (expression.getExpression() == null\n                    || expression.getLabel() == null) {\n                throw new ValidationException(\"Query expression fields must be set: {}\", expression);\n            }\n            if (labels.containsKey(expression.getLabel())) {\n                final String type = labels.get(expression.getLabel());\n                throw new ValidationException(\"Query expression label '{}' conflict: {} with that label is already defined.\", expression.getLabel(), type);\n            } else {\n                labels.put(expression.getLabel(), \"expression\");\n            }\n        }\n        List<FilterDef> filters = request.getFilters();\n        if (filters.size() > 0) {\n            for (FilterDef filter : filters) {\n                if (filter.getName() == null) {\n                    throw new ValidationException(\"Filter name must be set: {}\", filter);\n                }\n            }\n        }\n    }","id":65342,"modified_method":"public void validate(QueryRequest request) throws ValidationException {\n        if (request.getEnd() < 0) {\n            throw new ValidationException(\"Query end must be >= 0: {}\", request.getEnd());\n        }\n        if (request.getStep() <= 0) {\n            throw new ValidationException(\"Query step must be > 0: {}\", request.getStep());\n        }\n        if ((request.getHeartbeat() == null && request.getInterval() != null)\n                || (request.getHeartbeat() != null && request.getInterval() == null)) {\n            throw new ValidationException(\"If either the heartbeat or the interval are set, then both must be set.\");\n        }\n        if (request.getHeartbeat() != null && request.getInterval() != null) {\n            if (request.getHeartbeat() <= 0) {\n                throw new ValidationException(\"Heartbeat must be positive: {}\", request.getHeartbeat());\n            }\n            if (request.getInterval() <= 0) {\n                throw new ValidationException(\"Interval must be positive: {}\", request.getInterval());\n            }\n\n            if (request.getStep() % request.getInterval() != 0) {\n                throw new ValidationException(\"Step must be a multiple of the interval. Step: {}, Interval: {}\",\n                        request.getStep(), request.getInterval());\n            }\n\n            if (request.getHeartbeat() % request.getInterval() != 0) {\n                throw new ValidationException(\"Hearbeat must be a multiple of the interval. Interval: {} Hearbeat: {}\",\n                        request.getInterval(), request.getHeartbeat());\n            }\n        }\n\n        final Map<String,String> labels = new HashMap<>();\n        for (final Source source : request.getSources()) {\n            if (source.getResourceId() == null\n                    || source.getAttribute() == null\n                    || source.getLabel() == null\n                    || source.getAggregation() == null) {\n                throw new ValidationException(\"Query source fields must be set: {}\", source);\n            }\n            if (labels.containsKey(source.getLabel())) {\n                throw new ValidationException(\"Query source label '{}' conflict: source with that label is already defined.\", source.getLabel());\n            } else {\n                labels.put(source.getLabel(), \"source\");\n            }\n        }\n        for (final Expression expression : request.getExpressions()) {\n            if (expression.getExpression() == null\n                    || expression.getLabel() == null) {\n                throw new ValidationException(\"Query expression fields must be set: {}\", expression);\n            }\n            if (labels.containsKey(expression.getLabel())) {\n                final String type = labels.get(expression.getLabel());\n                throw new ValidationException(\"Query expression label '{}' conflict: {} with that label is already defined.\", expression.getLabel(), type);\n            } else {\n                labels.put(expression.getLabel(), \"expression\");\n            }\n        }\n        List<FilterDef> filters = request.getFilters();\n        if (filters.size() > 0) {\n            for (FilterDef filter : filters) {\n                if (filter.getName() == null) {\n                    throw new ValidationException(\"Filter name must be set: {}\", filter);\n                }\n            }\n        }\n    }","commit_id":"e83918a01bb811b4b5cf3cd25c07eeaffb69e7c7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public static String findJavaIdentifierPrefix(final PsiElement insertedElement, final int offset) {\n    if(insertedElement == null) return \"\";\n    final String text = insertedElement.getText();\n    final int offsetInElement = offset - insertedElement.getTextRange().getStartOffset();\n    int start = offsetInElement - 1;\n    while(start >=0 ) {\n      if(!Character.isJavaIdentifierPart(text.charAt(start))) break;\n      --start;\n    }\n\n    return text.substring(start + 1, offsetInElement).trim();\n  }","id":65343,"modified_method":"public static String findJavaIdentifierPrefix(final PsiElement insertedElement, final int offset) {\n    return findIdentifierPrefix(insertedElement, offset, character().javaIdentifierPart(), character().javaIdentifierStart());\n  }","commit_id":"a1ab6f972dc599910adc4e0a663c3b7f4f497914","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean fillCompletionVariants(final CompletionParameters parameters, final CompletionResultSet result) {\n    if (parameters.getCompletionType() != CompletionType.BASIC) return true;\n\n    final PsiFile file = parameters.getOriginalFile();\n    final int startOffset = parameters.getOffset();\n    final PsiElement element = ApplicationManager.getApplication().runReadAction(new Computable<PsiElement>() {\n      public PsiElement compute() {\n        return file.findElementAt(startOffset - 1);\n      }\n    });\n    final PsiElement insertedElement = parameters.getPosition();\n\n    final CompletionData data = CompletionUtil.getCompletionDataByElement(file);\n    if (!(data instanceof SyntaxTableCompletionData)) {\n      Set<CompletionVariant> toAdd = new HashSet<CompletionVariant>();\n      data.addKeywordVariants(toAdd, insertedElement, file);\n      for (CompletionVariant completionVariant : toAdd) {\n        if (completionVariant.hasKeywordCompletions()) {\n          return true;\n        }\n      }\n    }\n\n    final PsiReference reference = ApplicationManager.getApplication().runReadAction(new Computable<PsiReference>() {\n      public PsiReference compute() {\n        return file.findReferenceAt(startOffset);\n      }\n    });\n    if (reference == null) {\n      ASTNode textContainer = element != null ? element.getNode() : null;\n      while (textContainer != null) {\n        final IElementType elementType = textContainer.getElementType();\n        if (LanguageWordCompletion.INSTANCE.isEnabledIn(elementType) || elementType == PlainTextTokenTypes.PLAIN_TEXT) {\n          final String prefix = CompletionUtil.findJavaIdentifierPrefix(insertedElement, startOffset);\n          final CompletionResultSet resultSet = result.withPrefixMatcher(prefix);\n          for (final String word : AllWordsGetter.getAllWords(insertedElement, startOffset)) {\n            resultSet.addElement(new LookupItem<String>(word, word).setTailType(TailType.SPACE));\n          }\n        }\n        textContainer = textContainer.getTreeParent();\n      }\n    }\n\n    return true;\n  }","id":65344,"modified_method":"@Override\n  public boolean fillCompletionVariants(final CompletionParameters parameters, final CompletionResultSet result) {\n    if (parameters.getCompletionType() != CompletionType.BASIC) return true;\n\n    final PsiFile file = parameters.getOriginalFile();\n    final int startOffset = parameters.getOffset();\n    final PsiElement element = ApplicationManager.getApplication().runReadAction(new Computable<PsiElement>() {\n      public PsiElement compute() {\n        return file.findElementAt(startOffset - 1);\n      }\n    });\n    final PsiElement insertedElement = parameters.getPosition();\n\n    final CompletionData data = CompletionUtil.getCompletionDataByElement(file);\n    if (!(data instanceof SyntaxTableCompletionData)) {\n      Set<CompletionVariant> toAdd = new HashSet<CompletionVariant>();\n      data.addKeywordVariants(toAdd, insertedElement, file);\n      for (CompletionVariant completionVariant : toAdd) {\n        if (completionVariant.hasKeywordCompletions()) {\n          return true;\n        }\n      }\n    }\n\n    final PsiReference reference = ApplicationManager.getApplication().runReadAction(new Computable<PsiReference>() {\n      public PsiReference compute() {\n        return file.findReferenceAt(startOffset);\n      }\n    });\n    if (reference == null) {\n      ASTNode textContainer = element != null ? element.getNode() : null;\n      while (textContainer != null) {\n        final IElementType elementType = textContainer.getElementType();\n        if (LanguageWordCompletion.INSTANCE.isEnabledIn(elementType) || elementType == PlainTextTokenTypes.PLAIN_TEXT) {\n          final CompletionResultSet javaResultSet = result.withPrefixMatcher(CompletionUtil.findJavaIdentifierPrefix(insertedElement, startOffset));\n          final CompletionResultSet plainResultSet = result.withPrefixMatcher(CompletionUtil.findIdentifierPrefix(insertedElement,\n                                                                                                                  startOffset,\n                                                                                                                  character().javaIdentifierPart().andNot(character().equalTo('$')),\n                                                                                                                  character().javaIdentifierStart()));\n          for (final String word : AllWordsGetter.getAllWords(insertedElement, startOffset)) {\n            final LookupItem<String> item = new LookupItem<String>(word, word).setTailType(TailType.SPACE);\n            javaResultSet.addElement(item);\n            plainResultSet.addElement(item);\n          }\n        }\n        textContainer = textContainer.getTreeParent();\n      }\n    }\n\n    return true;\n  }","commit_id":"a1ab6f972dc599910adc4e0a663c3b7f4f497914","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public XmlCompletionData() {\n    declareFinalScope(XmlTag.class);\n    declareFinalScope(XmlAttribute.class);\n    declareFinalScope(XmlAttributeValue.class);\n\n    {\n      final CompletionVariant variant = new CompletionVariant(createTagCompletionFilter());\n      variant.includeScopeClass(XmlTag.class);\n      variant.addCompletionFilter(TrueFilter.INSTANCE);\n      variant.setInsertHandler(createTagInsertHandler());\n      registerVariant(variant);\n    }\n\n    {\n      final CompletionVariant variant = new CompletionVariant(createAttributeCompletionFilter());\n      variant.includeScopeClass(XmlAttribute.class);\n      variant.addCompletionFilter(TrueFilter.INSTANCE);\n      variant.setInsertHandler(new XmlAttributeInsertHandler());\n      registerVariant(variant);\n    }\n\n    {\n      final CompletionVariant variant = new CompletionVariant(createAttributeValueCompletionFilter());\n      variant.includeScopeClass(XmlAttributeValue.class);\n      variant.addCompletion(getAttributeValueGetter());\n      variant.addCompletionFilter(TrueFilter.INSTANCE, TailType.NONE);\n      variant.setInsertHandler(new XmlAttributeValueInsertHandler());\n      registerVariant(variant);\n    }\n\n    final ElementFilter entityCompletionFilter = createXmlEntityCompletionFilter();\n\n    {\n      final CompletionVariant variant = new CompletionVariant(\n          new AndFilter(new XmlTokenTypeFilter(XmlTokenType.XML_DATA_CHARACTERS), new NotFilter(entityCompletionFilter)));\n      variant.includeScopeClass(XmlToken.class, true);\n      variant.addCompletion(new SimpleTagContentEnumerationValuesGetter(), TailType.NONE);\n\n      registerVariant(variant);\n    }\n\n    {\n      final CompletionVariant variant = new CompletionVariant(entityCompletionFilter);\n      variant.includeScopeClass(XmlToken.class, true);\n      variant.addCompletion(new EntityRefGetter());\n      variant.setInsertHandler(new EntityRefInsertHandler());\n      registerVariant(variant);\n    }\n  }","id":65345,"modified_method":"public XmlCompletionData() {\n    declareFinalScope(XmlTag.class);\n    declareFinalScope(XmlAttribute.class);\n    declareFinalScope(XmlAttributeValue.class);\n\n    {\n      final CompletionVariant variant = new CompletionVariant(createTagCompletionFilter());\n      variant.includeScopeClass(XmlTag.class);\n      variant.addCompletionFilter(TrueFilter.INSTANCE);\n      variant.setInsertHandler(createTagInsertHandler());\n      registerVariant(variant);\n    }\n\n    {\n      final CompletionVariant variant = new CompletionVariant(createAttributeCompletionFilter());\n      variant.includeScopeClass(XmlAttribute.class);\n      variant.addCompletionFilter(TrueFilter.INSTANCE);\n      variant.setInsertHandler(new XmlAttributeInsertHandler());\n      registerVariant(variant);\n    }\n\n    {\n      final CompletionVariant variant = new CompletionVariant(createAttributeValueCompletionFilter());\n      variant.includeScopeClass(XmlAttributeValue.class);\n      variant.addCompletion(getAttributeValueGetter());\n      variant.addCompletionFilter(TrueFilter.INSTANCE, TailType.NONE);\n      variant.setInsertHandler(new XmlAttributeValueInsertHandler());\n      registerVariant(variant);\n    }\n\n    final ElementFilter entityCompletionFilter = createXmlEntityCompletionFilter();\n\n    {\n      final CompletionVariant variant = new CompletionVariant(\n        new AndFilter(new XmlTokenTypeFilter(XmlTokenType.XML_DATA_CHARACTERS), new NotFilter(entityCompletionFilter), new ElementFilter() {\n          public boolean isAcceptable(Object element, PsiElement context) {\n            XmlTag tag = PsiTreeUtil.getParentOfType(context, XmlTag.class, false);\n            if (tag != null) {\n              return XmlUtil.getSchemaSimpleContent(tag) != null;\n            }\n            return false;\n          }\n\n          public boolean isClassAcceptable(Class hintClass) {\n            return true;\n          }\n        }));\n      variant.includeScopeClass(XmlToken.class, true);\n      variant.addCompletion(new SimpleTagContentEnumerationValuesGetter(), TailType.NONE);\n\n      registerVariant(variant);\n    }\n    \n    {\n      final CompletionVariant variant = new CompletionVariant(\n        new AndFilter(new XmlTokenTypeFilter(XmlTokenType.XML_DATA_CHARACTERS), new NotFilter(entityCompletionFilter)));\n      variant.includeScopeClass(XmlToken.class, true);\n      registerVariant(variant);\n    }\n\n    {\n      final CompletionVariant variant = new CompletionVariant(entityCompletionFilter);\n      variant.includeScopeClass(XmlToken.class, true);\n      variant.addCompletion(new EntityRefGetter());\n      variant.setInsertHandler(new EntityRefInsertHandler());\n      registerVariant(variant);\n    }\n  }","commit_id":"a1ab6f972dc599910adc4e0a663c3b7f4f497914","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object[] get(final PsiElement context, CompletionContext completionContext) {\n      XmlTag tag = PsiTreeUtil.getParentOfType(context, XmlTag.class, false);\n      if (tag != null) {\n        final XmlTag simpleContent = XmlUtil.getSchemaSimpleContent(tag);\n        if (simpleContent != null) {\n          final HashSet<String> variants = new HashSet<String>();\n          XmlUtil.collectEnumerationValues(simpleContent, variants);\n          if (variants.size() > 0) return variants.toArray(new Object[variants.size()]);\n        }\n\n        for (final PsiReference reference : tag.getReferences()) {\n          if (!(reference instanceof TagNameReference)) {\n            return ArrayUtil.EMPTY_OBJECT_ARRAY;\n          }\n        }\n      }\n\n      return new AllWordsGetter().get(context, completionContext);\n    }","id":65346,"modified_method":"public Object[] get(final PsiElement context, CompletionContext completionContext) {\n      XmlTag tag = PsiTreeUtil.getParentOfType(context, XmlTag.class, false);\n      if (tag != null) {\n        final XmlTag simpleContent = XmlUtil.getSchemaSimpleContent(tag);\n        if (simpleContent != null) {\n          final HashSet<String> variants = new HashSet<String>();\n          XmlUtil.collectEnumerationValues(simpleContent, variants);\n          return variants.toArray(new Object[variants.size()]);\n        }\n      }\n\n      return ArrayUtil.EMPTY_OBJECT_ARRAY;\n    }","commit_id":"a1ab6f972dc599910adc4e0a663c3b7f4f497914","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void initVariantsInMethodScope() {\n    {\n// parameters list completion\n      final CompletionVariant variant = new CompletionVariant(\n        new LeftNeighbour(new OrFilter(new TextFilter(\"(\", \",\", PsiKeyword.FINAL),\n                                       new SuperParentFilter(new ClassFilter(PsiAnnotation.class)))));\n      variant.includeScopeClass(PsiParameterList.class, true);\n      addPrimitiveTypes(variant);\n      variant.addCompletionFilter(new ElementExtractorFilter(new ClassFilter(PsiClass.class)));\n      registerVariant(variant);\n    }\n\n// Completion for classes in method throws section\n// position\n    {\n      final ElementFilter position = new LeftNeighbour(new AndFilter(\n        new TextFilter(\")\"),\n        new ParentElementFilter(new ClassFilter(PsiParameterList.class))));\n\n// completion\n      CompletionVariant variant = new CompletionVariant(PsiMethod.class, position);\n      variant.includeScopeClass(PsiClass.class); // for throws on separate line\n      variant.addCompletion(PsiKeyword.THROWS);\n\n      registerVariant(variant);\n\n//in annotation methods\n      variant = new CompletionVariant(PsiAnnotationMethod.class, position);\n      variant.addCompletion(PsiKeyword.DEFAULT);\n      registerVariant(variant);\n    }\n\n    {\n// Completion for classes in method throws section\n// position\n      final ElementFilter position = new AndFilter(\n        new LeftNeighbour(new TextFilter(PsiKeyword.THROWS, \",\")),\n        new InsideElementFilter(new ClassFilter(PsiReferenceList.class))\n      );\n\n// completion\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiMethod.class, true);\n      variant.addCompletionFilter(new ElementExtractorFilter(new ThisOrAnyInnerFilter(new AssignableFromFilter(\"java.lang.Throwable\"))));\n      variant.addCompletionFilter(new ElementExtractorFilter(new ClassFilter(PsiPackage.class)));\n\n      registerVariant(variant);\n    }\n\n    {\n// completion for declarations\n      final CompletionVariant variant = new CompletionVariant(new OrFilter(END_OF_BLOCK, new LeftNeighbour(new TextFilter(PsiKeyword.FINAL))));\n      variant.includeScopeClass(PsiCodeBlock.class, false);\n      addPrimitiveTypes(variant);\n      variant.addCompletion(PsiKeyword.CLASS);\n      registerVariant(variant);\n    }\n\n// Completion in cast expressions\n    {\n      final CompletionVariant variant = new CompletionVariant(PsiMethod.class, new LeftNeighbour(new AndFilter(\n        new TextFilter(\"(\"),\n        new ParentElementFilter(new OrFilter(\n          new ClassFilter(PsiParenthesizedExpression.class),\n          new ClassFilter(PsiTypeCastExpression.class))))));\n      addPrimitiveTypes(variant);\n      registerVariant(variant);\n    }\n\n    {\n// instanceof keyword\n      final ElementFilter position = new LeftNeighbour(new OrFilter(\n          new ReferenceOnFilter(new ClassFilter(PsiVariable.class)),\n          new TextFilter(PsiKeyword.THIS),\n          new AndFilter(new TextFilter(\")\"), new ParentElementFilter(new AndFilter(\n            new ClassFilter(PsiTypeCastExpression.class, false),\n            new OrFilter(\n              new ParentElementFilter(new ClassFilter(PsiExpression.class)),\n              new ClassFilter(PsiExpression.class))))),\n          new AndFilter(new TextFilter(\"]\"), new ParentElementFilter(new ClassFilter(PsiArrayAccessExpression.class)))));\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiExpression.class, true);\n      variant.includeScopeClass(PsiMethod.class);\n      variant.addCompletionFilter(new FalseFilter());\n      variant.addCompletion(PsiKeyword.INSTANCEOF);\n\n      registerVariant(variant);\n    }\n\n    {\n// after instanceof keyword\n      final ElementFilter position = new PreviousElementFilter(new TextFilter(PsiKeyword.INSTANCEOF));\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiExpression.class, true);\n      variant.addCompletionFilter(new ElementExtractorFilter(new ClassFilter(PsiClass.class)));\n\n      registerVariant(variant);\n    }\n\n    {\n// after final keyword\n      final ElementFilter position = new AndFilter(new SuperParentFilter(new ClassFilter(PsiCodeBlock.class)),\n                                                   new LeftNeighbour(new TextFilter(PsiKeyword.FINAL)));\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiDeclarationStatement.class, true);\n      variant.addCompletionFilter(new ElementExtractorFilter(new ClassFilter(PsiClass.class)));\n      addPrimitiveTypes(variant);\n\n      registerVariant(variant);\n    }\n\n    {\n// Keyword completion in start of declaration\n      final CompletionVariant variant = new CompletionVariant(PsiMethod.class, END_OF_BLOCK);\n      variant.addCompletion(PsiKeyword.THIS, TailType.NONE);\n      variant.addCompletion(PsiKeyword.SUPER, TailType.NONE);\n      addKeywords(variant);\n      registerVariant(variant);\n    }\n\n    {\n// Keyword completion in returns\n      final CompletionVariant variant = new CompletionVariant(PsiMethod.class, new LeftNeighbour(new TextFilter(PsiKeyword.RETURN)));\n      variant.addCompletion(PsiKeyword.THIS, TailType.NONE);\n      variant.addCompletion(PsiKeyword.SUPER, TailType.NONE);\n      variant.addCompletion(PsiKeyword.TRUE, TailType.NONE);\n      variant.addCompletion(PsiKeyword.FALSE, TailType.NONE);\n      registerVariant(variant);\n    }\n\n\n// Catch/Finally completion\n    {\n      final ElementFilter position = new LeftNeighbour(new AndFilter(\n        new TextFilter(\"}\"),\n        new ParentElementFilter(new AndFilter(\n          new LeftNeighbour(new TextFilter(PsiKeyword.TRY)),\n          new ParentElementFilter(new ClassFilter(PsiTryStatement.class))))));\n\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiCodeBlock.class, true);\n      variant.addCompletion(PsiKeyword.CATCH, TailTypes.CATCH_LPARENTH);\n      variant.addCompletion(PsiKeyword.FINALLY, TailTypes.FINALLY_LBRACE);\n      variant.addCompletionFilter(new FalseFilter());\n      registerVariant(variant);\n    }\n\n// Catch/Finnaly completion\n    {\n      final ElementFilter position = new LeftNeighbour(new AndFilter(\n        new TextFilter(\"}\"),\n        new ParentElementFilter(new AndFilter(\n          new LeftNeighbour(new NotFilter(new TextFilter(PsiKeyword.TRY))),\n          new OrFilter(\n            new ParentElementFilter(new ClassFilter(PsiTryStatement.class)),\n            new ParentElementFilter(new ClassFilter(PsiCatchSection.class)))\n          ))));\n\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiCodeBlock.class, false);\n      variant.addCompletion(PsiKeyword.CATCH, TailTypes.CATCH_LPARENTH);\n      variant.addCompletion(PsiKeyword.FINALLY, TailTypes.FINALLY_LBRACE);\n      //variant.addCompletionFilter(new FalseFilter());\n      registerVariant(variant);\n    }\n\n    {\n// Completion for catches\n      final CompletionVariant variant = new CompletionVariant(PsiTryStatement.class, new PreviousElementFilter(new AndFilter(\n        new ParentElementFilter(new ClassFilter(PsiTryStatement.class)),\n        new TextFilter(\"(\")\n      )));\n      variant.includeScopeClass(PsiParameter.class);\n\n      variant.addCompletionFilter(new ElementExtractorFilter(new ThisOrAnyInnerFilter(new AssignableFromFilter(CommonClassNames.JAVA_LANG_THROWABLE))));\n      variant.addCompletionFilter(new ElementExtractorFilter(new ClassFilter(PsiPackage.class)));\n\n      registerVariant(variant);\n    }\n\n// Completion for else expression\n// completion\n    {\n      final ElementFilter position = new LeftNeighbour(\n        new OrFilter(\n          new AndFilter(new TextFilter(\"}\"),new ParentElementFilter(new ClassFilter(PsiIfStatement.class), 3)),\n          new AndFilter(new TextFilter(\";\"),new ParentElementFilter(new ClassFilter(PsiIfStatement.class), 2))\n        ));\n      final CompletionVariant variant = new CompletionVariant(PsiMethod.class, position);\n      variant.addCompletion(PsiKeyword.ELSE);\n\n      registerVariant(variant);\n    }\n\n    {\n// Super/This keyword completion\n      final ElementFilter position =\n        new LeftNeighbour(\n          new AndFilter(\n            new TextFilter(\".\"),\n            new LeftNeighbour(\n              new ReferenceOnFilter(new GeneratorFilter(EqualsFilter.class, new UpWalkGetter(new ClassFilter(PsiClass.class))))\n            )));\n      final CompletionVariant variant = new CompletionVariant(PsiMethod.class, position);\n      variant.includeScopeClass(PsiVariable.class);\n      variant.addCompletion(PsiKeyword.SUPER, TailType.NONE);\n      variant.addCompletion(PsiKeyword.THIS, TailType.NONE);\n      registerVariant(variant);\n    }\n    {\n// Class field completion\n\n      final CompletionVariant variant = new CompletionVariant(PsiMethod.class, new LeftNeighbour(\n        new AndFilter(\n            new TextFilter(\".\"),\n            new LeftNeighbour(\n                new OrFilter(\n                    new ReferenceOnFilter(new ClassFilter(PsiClass.class)),\n                    new TextFilter(PRIMITIVE_TYPES),\n                    new TextFilter(\"]\"))))));\n      variant.includeScopeClass(PsiAnnotationParameterList.class);\n      variant.includeScopeClass(PsiVariable.class);\n      variant.excludeScopeClass(PsiJavaCodeReferenceCodeFragment.class);\n      variant.addCompletion(PsiKeyword.CLASS, TailType.NONE);\n      registerVariant(variant);\n    }\n\n    {\n// break completion\n      final CompletionVariant variant = new CompletionVariant(new AndFilter(END_OF_BLOCK, new OrFilter(\n        new ScopeFilter(new ClassFilter(PsiSwitchStatement.class)),\n        new InsideElementFilter(new ClassFilter(PsiBlockStatement.class)))));\n\n      variant.includeScopeClass(PsiForStatement.class, false);\n      variant.includeScopeClass(PsiForeachStatement.class, false);\n      variant.includeScopeClass(PsiWhileStatement.class, false);\n      variant.includeScopeClass(PsiDoWhileStatement.class, false);\n      variant.includeScopeClass(PsiSwitchStatement.class, false);\n      variant.addCompletion(PsiKeyword.BREAK);\n      registerVariant(variant);\n    }\n    {\n// continue completion\n      final CompletionVariant variant = new CompletionVariant(new AndFilter(END_OF_BLOCK, new InsideElementFilter(new ClassFilter(PsiBlockStatement.class))));\n      variant.includeScopeClass(PsiForeachStatement.class, false);\n      variant.includeScopeClass(PsiForStatement.class, false);\n      variant.includeScopeClass(PsiWhileStatement.class, false);\n      variant.includeScopeClass(PsiDoWhileStatement.class, false);\n\n      variant.addCompletion(PsiKeyword.CONTINUE);\n      registerVariant(variant);\n    }\n\n    final AndFilter startSwitch = new AndFilter(END_OF_BLOCK, new LeftNeighbour(\n          new AndFilter(new TextFilter(\"{\"), new ParentElementFilter(new ClassFilter(PsiSwitchStatement.class), 2))));\n    {\n      final CompletionVariant variant = new CompletionVariant(\n        new AndFilter(\n          END_OF_BLOCK,\n          new NotFilter(startSwitch),\n          new OrFilter(\n            new ParentElementFilter(new ClassFilter(PsiSwitchLabelStatement.class)),\n            new LeftNeighbour(new OrFilter(\n              new ParentElementFilter(new ClassFilter(PsiSwitchStatement.class), 2),\n              new AndFilter(new TextFilter(\";\", \"}\", \":\"),new ParentElementFilter(new ClassFilter(PsiSwitchStatement.class), 3)\n              ))))));\n      variant.includeScopeClass(PsiElement.class, false);\n      variant.addCompletion(PsiKeyword.CASE, TailType.SPACE);\n      variant.addCompletion(PsiKeyword.DEFAULT, TailType.CASE_COLON);\n      variant.addCompletionFilter(TrueFilter.INSTANCE);\n      registerVariant(variant);\n    }\n\n    {\n      final CompletionVariant variant = new CompletionVariant(startSwitch);\n      variant.includeScopeClass(PsiElement.class, true);\n      variant.addCompletion(PsiKeyword.CASE, TailType.SPACE);\n      variant.addCompletion(PsiKeyword.DEFAULT, TailType.CASE_COLON);\n      variant.addCompletionFilter(new FalseFilter());\n      registerVariant(variant);\n    }\n\n    {\n// primitive arrays after new\n      final CompletionVariant variant = new CompletionVariant(PsiExpression.class, new LeftNeighbour(\n        new AndFilter(new TextFilter(PsiKeyword.NEW), new LeftNeighbour(new NotFilter(new TextFilter(\".\", PsiKeyword.THROW)))))\n      );\n      variant.includeScopeClass(PsiNewExpression.class, true);\n      addPrimitiveTypes(variant);\n      variant.setItemProperty(LookupItem.BRACKETS_COUNT_ATTR, 1);\n      registerVariant(variant);\n    }\n\n    {\n// after new\n      final CompletionVariant variant = new CompletionVariant(new LeftNeighbour(new TextFilter(PsiKeyword.NEW)));\n      variant.includeScopeClass(PsiNewExpression.class, true);\n      variant.addCompletionFilter(new ElementExtractorFilter(new ClassFilter(PsiClass.class)));\n\n      registerVariant(variant);\n    }\n\n\n    {\n      final CompletionVariant variant = new CompletionVariant(new AndFilter(\n        new ScopeFilter(new ParentElementFilter(new ClassFilter(PsiThrowStatement.class))),\n        new ParentElementFilter(new ClassFilter(PsiNewExpression.class)))\n      );\n      variant.includeScopeClass(PsiNewExpression.class, false);\n      variant.addCompletionFilter(new ElementExtractorFilter(new ThisOrAnyInnerFilter(new AssignableFromFilter(\"java.lang.Throwable\"))));\n\n      registerVariant(variant);\n    }\n\n    {\n// completion in reference parameters\n      final CompletionVariant variant = new CompletionVariant(TrueFilter.INSTANCE);\n      variant.includeScopeClass(PsiReferenceParameterList.class, true);\n      variant.addCompletionFilter(new ElementExtractorFilter(new ClassFilter(PsiClass.class)));\n\n      registerVariant(variant);\n    }\n\n    {\n// completion in annotation parameter list\n      final CompletionVariant variant = new CompletionVariant(TrueFilter.INSTANCE);\n      variant.includeScopeClass(PsiAnnotationParameterList.class, true);\n      variant.addCompletionFilter(new ElementExtractorFilter(new OrFilter(new ClassFilter(PsiAnnotationMethod.class),\n                       new ClassFilter(PsiClass.class),\n                       new ClassFilter(PsiPackage.class),\n                       new AndFilter(\n                         new ClassFilter(PsiField.class),\n                         new ModifierFilter(PsiModifier.STATIC, PsiModifier.FINAL)))));\n\n      registerVariant(variant);\n    }\n\n    {\n      // null completion\n      final CompletionVariant variant = new CompletionVariant(and(\n          psiElement().inside(or(\n              psiElement(PsiExpressionList.class),\n              psiElement(PsiExpression.class).withParent(or(psiElement(PsiIfStatement.class), psiElement(PsiLocalVariable.class))),\n              psiElement(PsiAssignmentExpression.class))\n          ),\n          not(psiElement().afterLeaf(\".\"))));\n      variant.addCompletion(PsiKeyword.NULL, TailType.NONE);\n      variant.addCompletion(PsiKeyword.TRUE, TailType.NONE);\n      variant.addCompletion(PsiKeyword.FALSE, TailType.NONE);\n      variant.includeScopeClass(PsiExpressionList.class);\n      variant.includeScopeClass(PsiStatement.class);\n      registerVariant(variant);\n    }\n  }","id":65347,"modified_method":"private void initVariantsInMethodScope() {\n    {\n// parameters list completion\n      final CompletionVariant variant = new CompletionVariant(\n        new LeftNeighbour(new OrFilter(new TextFilter(\"(\", \",\", PsiKeyword.FINAL),\n                                       new SuperParentFilter(new ClassFilter(PsiAnnotation.class)))));\n      variant.includeScopeClass(PsiParameterList.class, true);\n      addPrimitiveTypes(variant);\n      variant.addCompletionFilter(new ElementExtractorFilter(new ClassFilter(PsiClass.class)));\n      registerVariant(variant);\n    }\n\n// Completion for classes in method throws section\n// position\n    {\n      final ElementFilter position = new LeftNeighbour(new AndFilter(\n        new TextFilter(\")\"),\n        new ParentElementFilter(new ClassFilter(PsiParameterList.class))));\n\n// completion\n      CompletionVariant variant = new CompletionVariant(PsiMethod.class, position);\n      variant.includeScopeClass(PsiClass.class); // for throws on separate line\n      variant.addCompletion(PsiKeyword.THROWS);\n\n      registerVariant(variant);\n\n//in annotation methods\n      variant = new CompletionVariant(PsiAnnotationMethod.class, position);\n      variant.addCompletion(PsiKeyword.DEFAULT);\n      registerVariant(variant);\n    }\n\n    {\n// Completion for classes in method throws section\n// position\n      final ElementFilter position = new AndFilter(\n        new LeftNeighbour(new TextFilter(PsiKeyword.THROWS, \",\")),\n        new InsideElementFilter(new ClassFilter(PsiReferenceList.class))\n      );\n\n// completion\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiMethod.class, true);\n      variant.addCompletionFilter(new ElementExtractorFilter(new ThisOrAnyInnerFilter(new AssignableFromFilter(\"java.lang.Throwable\"))));\n      variant.addCompletionFilter(new ElementExtractorFilter(new ClassFilter(PsiPackage.class)));\n\n      registerVariant(variant);\n    }\n\n    {\n// completion for declarations\n      final CompletionVariant variant = new CompletionVariant(new OrFilter(END_OF_BLOCK, new LeftNeighbour(new TextFilter(PsiKeyword.FINAL))));\n      variant.includeScopeClass(PsiCodeBlock.class, false);\n      addPrimitiveTypes(variant);\n      variant.addCompletion(PsiKeyword.CLASS);\n      registerVariant(variant);\n    }\n\n// Completion in cast expressions\n    {\n      final CompletionVariant variant = new CompletionVariant(PsiMethod.class, new LeftNeighbour(new AndFilter(\n        new TextFilter(\"(\"),\n        new ParentElementFilter(new OrFilter(\n          new ClassFilter(PsiParenthesizedExpression.class),\n          new ClassFilter(PsiTypeCastExpression.class))))));\n      addPrimitiveTypes(variant);\n      registerVariant(variant);\n    }\n\n    {\n// instanceof keyword\n      final ElementFilter position = new LeftNeighbour(new OrFilter(\n          new ReferenceOnFilter(new ClassFilter(PsiVariable.class)),\n          new TextFilter(PsiKeyword.THIS),\n          new AndFilter(new TextFilter(\")\"), new ParentElementFilter(new AndFilter(\n            new ClassFilter(PsiTypeCastExpression.class, false),\n            new OrFilter(\n              new ParentElementFilter(new ClassFilter(PsiExpression.class)),\n              new ClassFilter(PsiExpression.class))))),\n          new AndFilter(new TextFilter(\"]\"), new ParentElementFilter(new ClassFilter(PsiArrayAccessExpression.class)))));\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiExpression.class, true);\n      variant.includeScopeClass(PsiMethod.class);\n      variant.addCompletionFilter(new FalseFilter());\n      variant.addCompletion(PsiKeyword.INSTANCEOF);\n\n      registerVariant(variant);\n    }\n\n    {\n// after instanceof keyword\n      final ElementFilter position = new PreviousElementFilter(new TextFilter(PsiKeyword.INSTANCEOF));\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiExpression.class, true);\n      variant.addCompletionFilter(new ElementExtractorFilter(new ClassFilter(PsiClass.class)));\n\n      registerVariant(variant);\n    }\n\n    {\n// after final keyword\n      final ElementFilter position = new AndFilter(new SuperParentFilter(new ClassFilter(PsiCodeBlock.class)),\n                                                   new LeftNeighbour(new TextFilter(PsiKeyword.FINAL)));\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiDeclarationStatement.class, true);\n      variant.addCompletionFilter(new ElementExtractorFilter(new ClassFilter(PsiClass.class)));\n      addPrimitiveTypes(variant);\n\n      registerVariant(variant);\n    }\n\n    {\n// Keyword completion in start of declaration\n      final CompletionVariant variant = new CompletionVariant(PsiMethod.class,\n                                                              or(new FilterPattern(END_OF_BLOCK),\n                                                                 psiElement().withParent(\n                                                                     psiElement(PsiReferenceExpression.class).withParent(PsiTypeCastExpression.class))));\n      variant.addCompletion(PsiKeyword.THIS, TailType.NONE);\n      variant.addCompletion(PsiKeyword.SUPER, TailType.NONE);\n      registerVariant(variant);\n    }\n\n    {\n// Keyword completion in start of declaration\n      final CompletionVariant variant = new CompletionVariant(PsiMethod.class, END_OF_BLOCK);\n      addKeywords(variant);\n      registerVariant(variant);\n    }\n\n    {\n// Keyword completion in returns\n      final CompletionVariant variant = new CompletionVariant(PsiMethod.class, new LeftNeighbour(new TextFilter(PsiKeyword.RETURN)));\n      variant.addCompletion(PsiKeyword.THIS, TailType.NONE);\n      variant.addCompletion(PsiKeyword.SUPER, TailType.NONE);\n      variant.addCompletion(PsiKeyword.TRUE, TailType.NONE);\n      variant.addCompletion(PsiKeyword.FALSE, TailType.NONE);\n      registerVariant(variant);\n    }\n\n\n// Catch/Finally completion\n    {\n      final ElementFilter position = new LeftNeighbour(new AndFilter(\n        new TextFilter(\"}\"),\n        new ParentElementFilter(new AndFilter(\n          new LeftNeighbour(new TextFilter(PsiKeyword.TRY)),\n          new ParentElementFilter(new ClassFilter(PsiTryStatement.class))))));\n\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiCodeBlock.class, true);\n      variant.addCompletion(PsiKeyword.CATCH, TailTypes.CATCH_LPARENTH);\n      variant.addCompletion(PsiKeyword.FINALLY, TailTypes.FINALLY_LBRACE);\n      variant.addCompletionFilter(new FalseFilter());\n      registerVariant(variant);\n    }\n\n// Catch/Finnaly completion\n    {\n      final ElementFilter position = new LeftNeighbour(new AndFilter(\n        new TextFilter(\"}\"),\n        new ParentElementFilter(new AndFilter(\n          new LeftNeighbour(new NotFilter(new TextFilter(PsiKeyword.TRY))),\n          new OrFilter(\n            new ParentElementFilter(new ClassFilter(PsiTryStatement.class)),\n            new ParentElementFilter(new ClassFilter(PsiCatchSection.class)))\n          ))));\n\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiCodeBlock.class, false);\n      variant.addCompletion(PsiKeyword.CATCH, TailTypes.CATCH_LPARENTH);\n      variant.addCompletion(PsiKeyword.FINALLY, TailTypes.FINALLY_LBRACE);\n      //variant.addCompletionFilter(new FalseFilter());\n      registerVariant(variant);\n    }\n\n    {\n// Completion for catches\n      final CompletionVariant variant = new CompletionVariant(PsiTryStatement.class, new PreviousElementFilter(new AndFilter(\n        new ParentElementFilter(new ClassFilter(PsiTryStatement.class)),\n        new TextFilter(\"(\")\n      )));\n      variant.includeScopeClass(PsiParameter.class);\n\n      variant.addCompletionFilter(new ElementExtractorFilter(new ThisOrAnyInnerFilter(new AssignableFromFilter(CommonClassNames.JAVA_LANG_THROWABLE))));\n      variant.addCompletionFilter(new ElementExtractorFilter(new ClassFilter(PsiPackage.class)));\n\n      registerVariant(variant);\n    }\n\n// Completion for else expression\n// completion\n    {\n      final ElementFilter position = new LeftNeighbour(\n        new OrFilter(\n          new AndFilter(new TextFilter(\"}\"),new ParentElementFilter(new ClassFilter(PsiIfStatement.class), 3)),\n          new AndFilter(new TextFilter(\";\"),new ParentElementFilter(new ClassFilter(PsiIfStatement.class), 2))\n        ));\n      final CompletionVariant variant = new CompletionVariant(PsiMethod.class, position);\n      variant.addCompletion(PsiKeyword.ELSE);\n\n      registerVariant(variant);\n    }\n\n    {\n// Super/This keyword completion\n      final ElementFilter position =\n        new LeftNeighbour(\n          new AndFilter(\n            new TextFilter(\".\"),\n            new LeftNeighbour(\n              new ReferenceOnFilter(new GeneratorFilter(EqualsFilter.class, new UpWalkGetter(new ClassFilter(PsiClass.class))))\n            )));\n      final CompletionVariant variant = new CompletionVariant(PsiMethod.class, position);\n      variant.includeScopeClass(PsiVariable.class);\n      variant.addCompletion(PsiKeyword.SUPER, TailType.NONE);\n      variant.addCompletion(PsiKeyword.THIS, TailType.NONE);\n      registerVariant(variant);\n    }\n    {\n// Class field completion\n\n      final CompletionVariant variant = new CompletionVariant(PsiMethod.class, new LeftNeighbour(\n        new AndFilter(\n            new TextFilter(\".\"),\n            new LeftNeighbour(\n                new OrFilter(\n                    new ReferenceOnFilter(new ClassFilter(PsiClass.class)),\n                    new TextFilter(PRIMITIVE_TYPES),\n                    new TextFilter(\"]\"))))));\n      variant.includeScopeClass(PsiAnnotationParameterList.class);\n      variant.includeScopeClass(PsiVariable.class);\n      variant.excludeScopeClass(PsiJavaCodeReferenceCodeFragment.class);\n      variant.addCompletion(PsiKeyword.CLASS, TailType.NONE);\n      registerVariant(variant);\n    }\n\n    {\n// break completion\n      final CompletionVariant variant = new CompletionVariant(new AndFilter(END_OF_BLOCK, new OrFilter(\n        new ScopeFilter(new ClassFilter(PsiSwitchStatement.class)),\n        new InsideElementFilter(new ClassFilter(PsiBlockStatement.class)))));\n\n      variant.includeScopeClass(PsiForStatement.class, false);\n      variant.includeScopeClass(PsiForeachStatement.class, false);\n      variant.includeScopeClass(PsiWhileStatement.class, false);\n      variant.includeScopeClass(PsiDoWhileStatement.class, false);\n      variant.includeScopeClass(PsiSwitchStatement.class, false);\n      variant.addCompletion(PsiKeyword.BREAK);\n      registerVariant(variant);\n    }\n    {\n// continue completion\n      final CompletionVariant variant = new CompletionVariant(new AndFilter(END_OF_BLOCK, new InsideElementFilter(new ClassFilter(PsiBlockStatement.class))));\n      variant.includeScopeClass(PsiForeachStatement.class, false);\n      variant.includeScopeClass(PsiForStatement.class, false);\n      variant.includeScopeClass(PsiWhileStatement.class, false);\n      variant.includeScopeClass(PsiDoWhileStatement.class, false);\n\n      variant.addCompletion(PsiKeyword.CONTINUE);\n      registerVariant(variant);\n    }\n\n    final AndFilter startSwitch = new AndFilter(END_OF_BLOCK, new LeftNeighbour(\n          new AndFilter(new TextFilter(\"{\"), new ParentElementFilter(new ClassFilter(PsiSwitchStatement.class), 2))));\n    {\n      final CompletionVariant variant = new CompletionVariant(\n        new AndFilter(\n          END_OF_BLOCK,\n          new NotFilter(startSwitch),\n          new OrFilter(\n            new ParentElementFilter(new ClassFilter(PsiSwitchLabelStatement.class)),\n            new LeftNeighbour(new OrFilter(\n              new ParentElementFilter(new ClassFilter(PsiSwitchStatement.class), 2),\n              new AndFilter(new TextFilter(\";\", \"}\", \":\"),new ParentElementFilter(new ClassFilter(PsiSwitchStatement.class), 3)\n              ))))));\n      variant.includeScopeClass(PsiElement.class, false);\n      variant.addCompletion(PsiKeyword.CASE, TailType.SPACE);\n      variant.addCompletion(PsiKeyword.DEFAULT, TailType.CASE_COLON);\n      variant.addCompletionFilter(TrueFilter.INSTANCE);\n      registerVariant(variant);\n    }\n\n    {\n      final CompletionVariant variant = new CompletionVariant(startSwitch);\n      variant.includeScopeClass(PsiElement.class, true);\n      variant.addCompletion(PsiKeyword.CASE, TailType.SPACE);\n      variant.addCompletion(PsiKeyword.DEFAULT, TailType.CASE_COLON);\n      variant.addCompletionFilter(new FalseFilter());\n      registerVariant(variant);\n    }\n\n    {\n// primitive arrays after new\n      final CompletionVariant variant = new CompletionVariant(PsiExpression.class, new LeftNeighbour(\n        new AndFilter(new TextFilter(PsiKeyword.NEW), new LeftNeighbour(new NotFilter(new TextFilter(\".\", PsiKeyword.THROW)))))\n      );\n      variant.includeScopeClass(PsiNewExpression.class, true);\n      addPrimitiveTypes(variant);\n      variant.setItemProperty(LookupItem.BRACKETS_COUNT_ATTR, 1);\n      registerVariant(variant);\n    }\n\n    {\n// after new\n      final CompletionVariant variant = new CompletionVariant(new LeftNeighbour(new TextFilter(PsiKeyword.NEW)));\n      variant.includeScopeClass(PsiNewExpression.class, true);\n      variant.addCompletionFilter(new ElementExtractorFilter(new ClassFilter(PsiClass.class)));\n\n      registerVariant(variant);\n    }\n\n\n    {\n      final CompletionVariant variant = new CompletionVariant(new AndFilter(\n        new ScopeFilter(new ParentElementFilter(new ClassFilter(PsiThrowStatement.class))),\n        new ParentElementFilter(new ClassFilter(PsiNewExpression.class)))\n      );\n      variant.includeScopeClass(PsiNewExpression.class, false);\n      variant.addCompletionFilter(new ElementExtractorFilter(new ThisOrAnyInnerFilter(new AssignableFromFilter(\"java.lang.Throwable\"))));\n\n      registerVariant(variant);\n    }\n\n    {\n// completion in reference parameters\n      final CompletionVariant variant = new CompletionVariant(TrueFilter.INSTANCE);\n      variant.includeScopeClass(PsiReferenceParameterList.class, true);\n      variant.addCompletionFilter(new ElementExtractorFilter(new ClassFilter(PsiClass.class)));\n\n      registerVariant(variant);\n    }\n\n    {\n// completion in annotation parameter list\n      final CompletionVariant variant = new CompletionVariant(TrueFilter.INSTANCE);\n      variant.includeScopeClass(PsiAnnotationParameterList.class, true);\n      variant.addCompletionFilter(new ElementExtractorFilter(new OrFilter(new ClassFilter(PsiAnnotationMethod.class),\n                       new ClassFilter(PsiClass.class),\n                       new ClassFilter(PsiPackage.class),\n                       new AndFilter(\n                         new ClassFilter(PsiField.class),\n                         new ModifierFilter(PsiModifier.STATIC, PsiModifier.FINAL)))));\n\n      registerVariant(variant);\n    }\n\n    {\n      // null completion\n      final CompletionVariant variant = new CompletionVariant(and(\n          psiElement().inside(or(\n              psiElement(PsiExpressionList.class),\n              psiElement(PsiExpression.class).withParent(or(psiElement(PsiIfStatement.class), psiElement(PsiLocalVariable.class))),\n              psiElement(PsiAssignmentExpression.class))\n          ),\n          not(psiElement().afterLeaf(\".\")),\n          not(psiElement().withParent(psiElement(PsiReferenceExpression.class).withParent(PsiTypeCastExpression.class)))\n      ));\n      variant.addCompletion(PsiKeyword.NULL, TailType.NONE);\n      variant.addCompletion(PsiKeyword.TRUE, TailType.NONE);\n      variant.addCompletion(PsiKeyword.FALSE, TailType.NONE);\n      variant.includeScopeClass(PsiExpressionList.class);\n      variant.includeScopeClass(PsiStatement.class);\n      registerVariant(variant);\n    }\n  }","commit_id":"34d2db9a538c6440c5fa72d9162fb3a4a4004597","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n\t\t public void sawOpcode(int seen) {\n\t\tif (!isFinal && seen == INVOKEVIRTUAL && getNameConstantOperand().equals(\"start\")\n\t\t\t\t&& getSigConstantOperand().equals(\"()V\")) {\n\t\t\ttry {\n\t\t\t\tif (Hierarchy.isSubtype(getDottedClassConstantOperand(), \"java.lang.Thread\")) {\n\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"SC_START_IN_CTOR\", NORMAL_PRIORITY)\n\t\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t\t\t.addSourceLine(this));\n\t\t\t\t}\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tbugReporter.reportMissingClass(e);\n\t\t\t}\n\t\t}\n\t}","id":65348,"modified_method":"@Override\n\t\t public void sawOpcode(int seen) {\n\t\tif (!isFinal && seen == INVOKEVIRTUAL && getNameConstantOperand().equals(\"start\")\n\t\t\t\t&& getSigConstantOperand().equals(\"()V\")) {\n\t\t\ttry {\n\t\t\t\tif (Hierarchy.isSubtype(getDottedClassConstantOperand(), \"java.lang.Thread\")) {\n\t\t\t\t\tBugInstance bug = new BugInstance(this, \"SC_START_IN_CTOR\", Priorities.NORMAL_PRIORITY)\n\t\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t\t.addCalledMethod(this);\n\t\t\t\t\t Subtypes2 subtypes2 = AnalysisContext.currentAnalysisContext().getSubtypes2();\n\t\t             Set<ClassDescriptor> directSubtypes = subtypes2.getDirectSubtypes(getClassDescriptor());\n\t\t             if (!directSubtypes.isEmpty()) {\n\t\t\t\t\t\t\tfor(ClassDescriptor sub : directSubtypes) \n\t\t                \t\tbug.addClass(sub).describe(ClassAnnotation.SUBCLASS_ROLE);\n\t\t                \tbug.setPriority(Priorities.HIGH_PRIORITY);\n\t\t                }\n\t\t\t\t\tbugReporter.reportBug(bug.addSourceLine(this));\n\t\t\t\t}\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tbugReporter.reportMissingClass(e);\n\t\t\t}\n\t\t}\n\t}","commit_id":"b2a9238544dbf374dae1993af3c8f10a75e73c37","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void sawOpcode(int seen) {\n\tif (!isFinal && seen == INVOKEVIRTUAL && nameConstant.equals(\"start\")\n\t\t\t\t&& sigConstant.equals(\"()V\"))\n\t\tbugReporter.reportBug(new BugInstance(\"SC_START_IN_CTOR\", NORMAL_PRIORITY)\n\t\t\t.addClassAndMethod(this)\n\t\t\t.addCalledMethod(this));\n\t}","id":65349,"modified_method":"public void sawOpcode(int seen) {\n\tif (!isFinal && seen == INVOKEVIRTUAL && nameConstant.equals(\"start\")\n\t\t\t\t&& sigConstant.equals(\"()V\"))\n\t\tbugReporter.reportBug(new BugInstance(\"SC_START_IN_CTOR\", NORMAL_PRIORITY)\n\t\t\t.addClassAndMethod(this)\n\t\t\t.addCalledMethod(this)\n\t\t\t.addSourceLine(this));\n\t}","commit_id":"5d7ead8a169aedaee213337044dce41d07185ad5","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void sawOpcode(int seen) {\n\n\tif ((seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE)\n\t\t&& nameConstant.equals(\"available\")\n\t\t&& sigConstant.equals(\"()I\")\n\t    || (seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE)\n\t\t&& nameConstant.startsWith(\"get\")\n\t\t&& nameConstant.endsWith(\"Length\")\n\t\t&& sigConstant.equals(\"()I\")\n\t    || (seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE)\n\t\t&& classConstant.equals(\"java/io/File\")\n\t\t&& nameConstant.equals(\"length\")\n\t\t&& sigConstant.equals(\"()J\"))   {\n\t\tsawAvailable = 70;\n\t\treturn;\n\t\t}\n\tsawAvailable--;\n\tif ((seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE)\n\t\t&& !classConstant.equals(\"ByteArrayInputStream\")\n\t\t&& nameConstant.equals(\"read\")\n\t\t&& (sigConstant.startsWith(\"([B\")\n\t\t   || sigConstant.startsWith(\"([C\"))\n\t\t&& sawAvailable <= 0)   {\n\t\t/*\n\t\tSystem.out.println(\"Saw invocation of \"\n\t\t\t+ nameConstant + \"(\"\n\t\t\t+sigConstant\n\t\t\t+\")\");\n\t\t*/\n\n\t\tsawRead = true;\n\t\treturn;\n\t\t}\n\tif (seen == POP && sawRead)  {\n\t\tbugReporter.reportBug(new BugInstance(\"RR_NOT_CHECKED\", NORMAL_PRIORITY)\n\t\t\t.addClassAndMethod(this)\n\t\t\t.addCalledMethod(this));\n\t\t}\n\tsawRead = false;\n\t}","id":65350,"modified_method":"public void sawOpcode(int seen) {\n\n\tif ((seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE)\n\t\t&& nameConstant.equals(\"available\")\n\t\t&& sigConstant.equals(\"()I\")\n\t    || (seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE)\n\t\t&& nameConstant.startsWith(\"get\")\n\t\t&& nameConstant.endsWith(\"Length\")\n\t\t&& sigConstant.equals(\"()I\")\n\t    || (seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE)\n\t\t&& classConstant.equals(\"java/io/File\")\n\t\t&& nameConstant.equals(\"length\")\n\t\t&& sigConstant.equals(\"()J\"))   {\n\t\tsawAvailable = 70;\n\t\treturn;\n\t\t}\n\tsawAvailable--;\n\tif ((seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE)\n\t\t&& !classConstant.equals(\"ByteArrayInputStream\")\n\t\t&& nameConstant.equals(\"read\")\n\t\t&& (sigConstant.startsWith(\"([B\")\n\t\t   || sigConstant.startsWith(\"([C\"))\n\t\t&& sawAvailable <= 0)   {\n\t\t/*\n\t\tSystem.out.println(\"Saw invocation of \"\n\t\t\t+ nameConstant + \"(\"\n\t\t\t+sigConstant\n\t\t\t+\")\");\n\t\t*/\n\n\t\tsawRead = true;\n\t\treadPC = PC;\n\t\treturn;\n\t\t}\n\tif (seen == POP && sawRead)  {\n\t\tbugReporter.reportBug(new BugInstance(\"RR_NOT_CHECKED\", NORMAL_PRIORITY)\n\t\t\t.addClassAndMethod(this)\n\t\t\t.addCalledMethod(this)\n\t\t\t.addSourceLine(this, readPC));\n\t\t}\n\tsawRead = false;\n\t}","commit_id":"1034fc6d4140d646ac22a5c230a60671516be99f","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void sawRegExPattern(int stackDepth, int flags) {\n\t\tif (stack.getStackDepth() < stackDepth) return;\n\t\tOpcodeStack.Item it = stack.getStackItem(stackDepth);\n\t\tif (it.getSpecialKind() == OpcodeStack.Item.FILE_SEPARATOR_STRING && (flags & Pattern.LITERAL) == 0) {\n\t\t\t  bugReporter.reportBug(new BugInstance(this, \"RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION\", \n\t\t\t\t\t  HIGH_PRIORITY)\n\t\t\t\t\t\t\t\t\t  .addClassAndMethod(this)\n\t\t\t\t\t\t\t\t\t  .addCalledMethod(this)\n\t\t\t\t\t\t\t\t\t  .addSourceLine(this)\n\t\t\t\t\t  );\n\t\t\t  return;\n\t\t}\n\t\tObject value = it.getConstant();\n\t\tif (value == null || !(value instanceof String)) return;\n\t\tString regex = (String) value;\n\t\ttry {\n\t\t\tPattern.compile(regex, flags);\n\t\t} catch (PatternSyntaxException e) {\n\t\t  bugReporter.reportBug(new BugInstance(this, \"RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION\", \n\t\t\t\tHIGH_PRIORITY)\n\t\t\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t\t\t\t.addString(regex)\n\t\t\t\t\t\t\t\t.addInt(flags)\n\t\t\t\t\t\t\t\t.addSourceLine(this)\n\t\t\t\t);\n\t\t}\n\t}","id":65351,"modified_method":"private void sawRegExPattern(int stackDepth, int flags) {\n\t\tif (stack.getStackDepth() < stackDepth) return;\n\t\tOpcodeStack.Item it = stack.getStackItem(stackDepth);\n\t\tif (it.getSpecialKind() == OpcodeStack.Item.FILE_SEPARATOR_STRING && (flags & Pattern.LITERAL) == 0) {\n\t\t\t  bugReporter.reportBug(new BugInstance(this, \"RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION\", \n\t\t\t\t\t  HIGH_PRIORITY)\n\t\t\t\t\t\t\t\t\t  .addClassAndMethod(this)\n\t\t\t\t\t\t\t\t\t  .addCalledMethod(this)\n\t\t\t\t\t\t\t\t\t  .addSourceLine(this)\n\t\t\t\t\t  );\n\t\t\t  return;\n\t\t}\n\t\tObject value = it.getConstant();\n\t\tif (value == null || !(value instanceof String)) return;\n\t\tString regex = (String) value;\n\t\ttry {\n\t\t\tPattern.compile(regex, flags);\n\t\t} catch (PatternSyntaxException e) {\n\t\t\tString message = e.getMessage();\n\t\t\tint eol = message.indexOf('\\n');\n\t\t\tif (eol > 0)\n\t\t\t\tmessage = message.substring(0, eol);\n\t\t\tBugInstance bug = new BugInstance(this, \"RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION\", \n\t\t\t\t\tHIGH_PRIORITY)\n\t\t\t.addClassAndMethod(this)\n\t\t\t.addCalledMethod(this)\n\t\t\t.addString(message).describe(StringAnnotation.ERROR_MSG_ROLE)\n\t\t\t.addString(regex).describe(StringAnnotation.REGEX_ROLE);\n\t\t\tString options = getOptions(flags);\n\t\t\tif (options.length() > 0)\n\t\t\t\tbug.addString(\"Regex flags: \" + options).describe(StringAnnotation.STRING_MESSAGE);\n\t\t\tbug.addSourceLine(this);\n\t\t\tbugReporter.reportBug(bug);\n\t\t}\n\t}","commit_id":"6b10ea51844fbae0dcdc595bdf0a3e8ae1ffccbf","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void sawOpcode(int seen) {\n\tif (seen == INVOKEVIRTUAL && nameConstant.equals(\"finalize\"))\n\t\tbugReporter.reportBug(new BugInstance(\"FI_EXPLICIT_INVOCATION\", NORMAL_PRIORITY)\n\t\t\t.addClassAndMethod(this)\n\t\t\t.addCalledMethod(this));\n\tif (seen == INVOKESPECIAL && nameConstant.equals(\"finalize\")) \n\t\tsawSuperFinalize = true;\n\t}","id":65352,"modified_method":"public void sawOpcode(int seen) {\n\tif (seen == INVOKEVIRTUAL && nameConstant.equals(\"finalize\"))\n\t\tbugReporter.reportBug(new BugInstance(\"FI_EXPLICIT_INVOCATION\", NORMAL_PRIORITY)\n\t\t\t.addClassAndMethod(this)\n\t\t\t.addCalledMethod(this).describe(\"METHOD_CALLED\")\n\t\t\t.addSourceLine(this, PC));\n\tif (seen == INVOKESPECIAL && nameConstant.equals(\"finalize\")) \n\t\tsawSuperFinalize = true;\n\t}","commit_id":"caa92600958b432543d3a2b08aea40aa786c98a5","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        if (deploymentUnit.getParent() != null) {\n            return; // only run for top-level deployments\n        }\n\n        final CompositeIndex index = deploymentUnit.getAttachment(Attachments.COMPOSITE_ANNOTATION_INDEX);\n\n        // CDI built-in normal scopes plus @Dependent\n        addAnnotations(deploymentUnit, CdiAnnotations.BEAN_DEFINING_ANNOTATIONS);\n        // CDI @Model stereotype\n        addAnnotation(deploymentUnit, new AnnotationType(CdiAnnotations.MODEL.getDotName(), false));\n        // EE7 built-in normal scopes and stereotypes\n        addAnnotation(deploymentUnit, new AnnotationType(TransactionScoped.class));\n        addAnnotation(deploymentUnit, new AnnotationType(VIEW_SCOPED_NAME, true));\n        addAnnotation(deploymentUnit, new AnnotationType(FLOW_SCOPED_NAME, true));\n\n        for (AnnotationType annotationType : CdiAnnotations.BEAN_DEFINING_META_ANNOTATIONS) {\n            addAnnotations(deploymentUnit, getAnnotationsAnnotatedWith(index, annotationType.getName()));\n        }\n    }","id":65353,"modified_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        if (deploymentUnit.getParent() != null) {\n            return; // only run for top-level deployments\n        }\n\n        final CompositeIndex index = deploymentUnit.getAttachment(Attachments.COMPOSITE_ANNOTATION_INDEX);\n\n        addAnnotations(deploymentUnit, CdiAnnotations.BUILT_IN_SCOPES);\n        // EE7 built-in scopes\n        addAnnotation(deploymentUnit, new AnnotationType(TransactionScoped.class));\n        addAnnotation(deploymentUnit, new AnnotationType(VIEW_SCOPED_NAME, true));\n        addAnnotation(deploymentUnit, new AnnotationType(FLOW_SCOPED_NAME, true));\n\n        addAnnotations(deploymentUnit, getAnnotationsAnnotatedWith(index, CdiAnnotations.NORM_SCOPE.getDotName()));\n        addAnnotations(deploymentUnit, getAnnotationsAnnotatedWith(index, CdiAnnotations.SCOPE));\n    }","commit_id":"78cb35b344abad9835b93285597b6377f4a36e87","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testAlphaModule(AlphaLookup alpha) {\n        Assert.assertNotNull(alpha);\n        Set<String> accessibleImplementations = getAccessibleImplementations(alpha.getInstance());\n        Assert.assertTrue(accessibleImplementations.contains(AlphaBean.class.getSimpleName()));\n        Assert.assertTrue(accessibleImplementations.contains(BravoBean.class.getSimpleName()));\n        Assert.assertFalse(accessibleImplementations.contains(CharlieBean.class.getSimpleName()));\n        Assert.assertFalse(accessibleImplementations.contains(DeltaBean.class.getSimpleName()));\n    }","id":65354,"modified_method":"@Test\n    public void testAlphaModule(AlphaLookup alpha) {\n        Assert.assertNotNull(alpha);\n        Set<String> accessibleImplementations = getAccessibleImplementations(alpha.getInstance());\n        Assert.assertTrue(accessibleImplementations.contains(AlphaBean.class.getSimpleName()));\n        Assert.assertTrue(accessibleImplementations.contains(BravoBean.class.getSimpleName()));\n        /*\n         * Alpha does not have a dependency on Charlie and thus Charlie would ideally not be accessible.\n         * Unfortunately, Weld resolves dependencies transitively and therefore does not follow classloader\n         * accessibility in this case. This should change once WELD-1536 is resolved.\n         */\n        Assert.assertTrue(accessibleImplementations.contains(CharlieBean.class.getSimpleName()));\n        Assert.assertFalse(accessibleImplementations.contains(DeltaBean.class.getSimpleName()));\n    }","commit_id":"78cb35b344abad9835b93285597b6377f4a36e87","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n    * Creates a new InjectionTarget for a given class. If the interceptionSupport flag is set to true the resulting instance will support\n    * interception (support provided by Weld). If an InjectionTarget is created for a component where interception support is implemented\n    * through component's view (EJBs, managed beans) the flag must be set to false.\n    *\n    * @param componentClass\n    * @param bean\n    * @param beanManager\n    * @param interceptionSupport\n    * @return\n    */\n    public static <T> WeldInjectionTarget<T> createInjectionTarget(Class<?> componentClass, Bean<T> bean, BeanManagerImpl beanManager,\n            boolean interceptionSupport) {\n        final ClassTransformer transformer = beanManager.getServices().get(ClassTransformer.class);\n        @SuppressWarnings(\"unchecked\")\n        final Class<T> clazz = (Class<T>) componentClass;\n        EnhancedAnnotatedType<T> type = transformer.getEnhancedAnnotatedType(clazz, beanManager.getId());\n\n        if (!type.getJavaClass().equals(componentClass)) {\n            /*\n             * Jasper loads a class with multiple classloaders which is not supported by Weld.\n             * If this happens, use a combination of a bean archive identifier and class' classloader hashCode as the BDA ID.\n             * This breaks AnnotatedType serialization but that does not matter as these are non-contextual components.\n             */\n            final String bdaId = beanManager.getId() + componentClass.getClassLoader().hashCode();\n            type = transformer.getEnhancedAnnotatedType(clazz, bdaId);\n        }\n\n        if (Beans.getBeanConstructor(type) == null) {\n            /*\n             * For example, AsyncListeners may be CDI-incompatible as long as the application never calls javax.servletAsyncContext#createListener(Class)\n             * and only instantiates the listener itself.\n             */\n            return beanManager.getInjectionTargetFactory(type).createNonProducibleInjectionTarget();\n        }\n        WeldInjectionTargetBuilder<T> builder = beanManager.createInjectionTargetBuilder(type);\n        builder.setResourceInjectionEnabled(false); // because these are all EE components where resource injection is not handled by Weld\n        if (interceptionSupport) {\n            return builder.build();\n        } else {\n            // suppress interception/decoration because this is a component for which WF provides interception support\n            return builder.setInterceptionEnabled(false).setTargetClassLifecycleCallbacksEnabled(false).setDecorationEnabled(false).build();\n        }\n    }","id":65355,"modified_method":"/**\n    * Creates a new InjectionTarget for a given class. If the interceptionSupport flag is set to true the resulting instance will support\n    * interception (support provided by Weld). If an InjectionTarget is created for a component where interception support is implemented\n    * through component's view (EJBs, managed beans) the flag must be set to false.\n    *\n    * @param componentClass\n    * @param bean\n    * @param beanManager\n    * @param interceptionSupport\n    * @return\n    */\n    public static <T> BasicInjectionTarget<T> createInjectionTarget(Class<?> componentClass, Bean<T> bean, BeanManagerImpl beanManager,\n            boolean interceptionSupport) {\n        final ClassTransformer transformer = beanManager.getServices().get(ClassTransformer.class);\n        @SuppressWarnings(\"unchecked\")\n        final Class<T> clazz = (Class<T>) componentClass;\n        EnhancedAnnotatedType<T> type = transformer.getEnhancedAnnotatedType(clazz, beanManager.getId());\n\n        if (!type.getJavaClass().equals(componentClass)) {\n            /*\n             * Jasper loads a class with multiple classloaders which is not supported by Weld.\n             * If this happens, use a combination of a bean archive identifier and class' classloader hashCode as the BDA ID.\n             * This breaks AnnotatedType serialization but that does not matter as these are non-contextual components.\n             */\n            final String bdaId = beanManager.getId() + componentClass.getClassLoader().hashCode();\n            type = transformer.getEnhancedAnnotatedType(clazz, bdaId);\n        }\n\n        if (Beans.getBeanConstructor(type) == null) {\n            /*\n             * For example, AsyncListeners may be CDI-incompatible as long as the application never calls javax.servletAsyncContext#createListener(Class)\n             * and only instantiates the listener itself.\n             */\n            return new NonProducibleInjectionTarget<>(type, bean, beanManager);\n        }\n        if (interceptionSupport) {\n            return new InterceptedNonContextualComponentInjectionTarget<>(type, bean, beanManager);\n        } else {\n            return new NonContextualComponentInjectionTarget<>(type, bean, beanManager);\n        }\n    }","commit_id":"78cb35b344abad9835b93285597b6377f4a36e87","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public synchronized void start(final StartContext context) throws StartException {\n        final ClassLoader cl = WildFlySecurityManager.getCurrentContextClassLoaderPrivileged();\n        try {\n            WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(classLoader);\n            beanManager = weldContainer.getValue().getBeanManager(beanDeploymentArchiveId);\n\n            for (final Class<?> interceptor : interceptorClasses) {\n                AnnotatedType<?> type = beanManager.createAnnotatedType(interceptor);\n                interceptorInjections.put(interceptor, beanManager.getInjectionTargetFactory(type).createInterceptorInjectionTarget());\n            }\n\n            if (ejbName != null) {\n                EjbDescriptor<Object> descriptor = beanManager.getEjbDescriptor(ejbName);\n                //may happen if the EJB was vetoed\n                if (descriptor != null) {\n                    bean = beanManager.getBean(descriptor);\n                }\n            }\n\n            if (bean instanceof SessionBean<?>) {\n                SessionBean<?> sessionBean = (SessionBean<?>) bean;\n                this.injectionTarget = sessionBean.getInjectionTarget();\n                return;\n            }\n\n            WeldInjectionTarget injectionTarget = InjectionTargets.createInjectionTarget(componentClass, bean, beanManager, !Utils.isComponentWithView(componentDescription));\n            if (componentDescription instanceof MessageDrivenComponentDescription || componentDescription instanceof WebComponentDescription) {\n                // fire ProcessInjectionTarget for non-contextual components\n                this.injectionTarget = beanManager.fireProcessInjectionTarget(injectionTarget.getAnnotatedType(), injectionTarget);\n            } else {\n                this.injectionTarget = injectionTarget;\n            }\n            beanManager.getServices().get(InjectionTargetService.class).validateProducer(injectionTarget);\n\n        } finally {\n            WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(cl);\n        }\n    }","id":65356,"modified_method":"@Override\n    public synchronized void start(final StartContext context) throws StartException {\n        final ClassLoader cl = WildFlySecurityManager.getCurrentContextClassLoaderPrivileged();\n        try {\n            WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(classLoader);\n            beanManager = weldContainer.getValue().getBeanManager(beanDeploymentArchiveId);\n\n            for (final Class<?> interceptor : interceptorClasses) {\n                AnnotatedType<?> type = beanManager.createAnnotatedType(interceptor);\n                interceptorInjections.put(interceptor, beanManager.getInjectionTargetFactory(type).createInterceptorInjectionTarget());\n            }\n\n            if (ejbName != null) {\n                EjbDescriptor<Object> descriptor = beanManager.getEjbDescriptor(ejbName);\n                //may happen if the EJB was vetoed\n                if (descriptor != null) {\n                    bean = beanManager.getBean(descriptor);\n                }\n            }\n\n            if (bean instanceof SessionBean<?>) {\n                SessionBean<?> sessionBean = (SessionBean<?>) bean;\n                this.injectionTarget = sessionBean.getInjectionTarget();\n                return;\n            }\n\n            BasicInjectionTarget injectionTarget = InjectionTargets.createInjectionTarget(componentClass, bean, beanManager, !Utils.isComponentWithView(componentDescription));\n            if (componentDescription instanceof MessageDrivenComponentDescription || componentDescription instanceof WebComponentDescription) {\n                // fire ProcessInjectionTarget for non-contextual components\n                this.injectionTarget = beanManager.fireProcessInjectionTarget(injectionTarget.getAnnotated(), injectionTarget);\n            } else {\n                this.injectionTarget = injectionTarget;\n            }\n            beanManager.getServices().get(InjectionTargetService.class).validateProducer(injectionTarget);\n\n        } finally {\n            WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(cl);\n        }\n    }","commit_id":"78cb35b344abad9835b93285597b6377f4a36e87","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final DeploymentUnit parent = Utils.getRootDeploymentUnit(deploymentUnit);\n        final ServiceTarget serviceTarget = phaseContext.getServiceTarget();\n        final ResourceRoot deploymentRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT);\n        if (!WeldDeploymentMarker.isPartOfWeldDeployment(deploymentUnit)) {\n\n            //if there are CDI annotation present and this is the top level deployment we log a warning\n            if (deploymentUnit.getParent() == null && CdiAnnotationMarker.cdiAnnotationsPresent(deploymentUnit)) {\n                WeldLogger.DEPLOYMENT_LOGGER.cdiAnnotationsButNotBeanArchive(deploymentUnit);\n            }\n\n            return;\n        }\n\n        //add a dependency on the weld service to web deployments\n        final ServiceName weldBootstrapServiceName = parent.getServiceName().append(WeldBootstrapService.SERVICE_NAME);\n        deploymentUnit.addToAttachmentList(Attachments.WEB_DEPENDENCIES, weldBootstrapServiceName);\n\n        final Set<ServiceName> jpaServices = new HashSet<ServiceName>();\n\n\n        // we only start weld on top level deployments\n        if (deploymentUnit.getParent() != null) {\n            return;\n        }\n\n        WeldLogger.DEPLOYMENT_LOGGER.startingServicesForCDIDeployment(phaseContext.getDeploymentUnit().getName());\n\n        final Module module = deploymentUnit.getAttachment(Attachments.MODULE);\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n        final CompositeIndex rootIndex = deploymentUnit.getAttachment(Attachments.COMPOSITE_ANNOTATION_INDEX);\n\n        final Set<BeanDeploymentArchiveImpl> beanDeploymentArchives = new HashSet<BeanDeploymentArchiveImpl>();\n        final Map<ModuleIdentifier, BeanDeploymentModule> bdmsByIdentifier = new HashMap<ModuleIdentifier, BeanDeploymentModule>();\n        final Map<ModuleIdentifier, ModuleSpecification> moduleSpecByIdentifier = new HashMap<ModuleIdentifier, ModuleSpecification>();\n\n        // the root module only has access to itself. For most deployments this will be the only module\n        // for ear deployments this represents the ear/lib directory.\n        // war and jar deployment visibility will depend on the dependencies that\n        // exist in the application, and mirror inter module dependencies\n        final BeanDeploymentModule rootBeanDeploymentModule = deploymentUnit.getAttachment(WeldAttachments.BEAN_DEPLOYMENT_MODULE);\n\n        final EEModuleDescription eeModuleDescription = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.EE_MODULE_DESCRIPTION);\n        final EEApplicationDescription eeApplicationDescription = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.EE_APPLICATION_DESCRIPTION);\n\n        bdmsByIdentifier.put(module.getIdentifier(), rootBeanDeploymentModule);\n\n        moduleSpecByIdentifier.put(module.getIdentifier(), moduleSpecification);\n\n        beanDeploymentArchives.addAll(rootBeanDeploymentModule.getBeanDeploymentArchives());\n        final List<DeploymentUnit> subDeployments = deploymentUnit.getAttachmentList(Attachments.SUB_DEPLOYMENTS);\n\n        final Set<ClassLoader> subDeploymentLoaders = new HashSet<ClassLoader>();\n\n        getJpaDependencies(deploymentUnit, jpaServices);\n\n        for (DeploymentUnit subDeployment : subDeployments) {\n            getJpaDependencies(deploymentUnit, jpaServices);\n            final Module subDeploymentModule = subDeployment.getAttachment(Attachments.MODULE);\n            if (subDeploymentModule == null) {\n                continue;\n            }\n            subDeploymentLoaders.add(subDeploymentModule.getClassLoader());\n\n            final ModuleSpecification subDeploymentModuleSpec = subDeployment.getAttachment(Attachments.MODULE_SPECIFICATION);\n            final BeanDeploymentModule bdm = subDeployment.getAttachment(WeldAttachments.BEAN_DEPLOYMENT_MODULE);\n            if (bdm == null) {\n                continue;\n            }\n            // add the modules bdas to the global set of bdas\n            beanDeploymentArchives.addAll(bdm.getBeanDeploymentArchives());\n            bdmsByIdentifier.put(subDeploymentModule.getIdentifier(), bdm);\n            moduleSpecByIdentifier.put(subDeploymentModule.getIdentifier(), subDeploymentModuleSpec);\n\n            //we have to do this here as the aggregate components are not available in earlier phases\n            final ResourceRoot subDeploymentRoot = subDeployment.getAttachment(Attachments.DEPLOYMENT_ROOT);\n            final EjbInjectionServices ejbInjectionServices = new WeldEjbInjectionServices(deploymentUnit.getServiceRegistry(), eeModuleDescription, eeApplicationDescription, subDeploymentRoot.getRoot());\n            bdm.addService(EjbInjectionServices.class, ejbInjectionServices);\n\n            final ResourceInjectionServices resourceInjectionServices = new WeldResourceInjectionServices(deploymentUnit.getServiceRegistry(), eeModuleDescription);\n            bdm.addService(ResourceInjectionServices.class, resourceInjectionServices);\n\n            final CompositeIndex index = subDeployment.getAttachment(Attachments.COMPOSITE_ANNOTATION_INDEX);\n            if (index != null) {\n                bdm.addService(ClassFileServices.class, new WeldClassFileServices(index, subDeploymentModule.getClassLoader()));\n            }\n        }\n\n        for (Map.Entry<ModuleIdentifier, BeanDeploymentModule> entry : bdmsByIdentifier.entrySet()) {\n            final ModuleSpecification bdmSpec = moduleSpecByIdentifier.get(entry.getKey());\n            final BeanDeploymentModule bdm = entry.getValue();\n            if (bdm == rootBeanDeploymentModule) {\n                continue; // the root module only has access to itself\n            }\n            for (ModuleDependency dependency : bdmSpec.getSystemDependencies()) {\n                BeanDeploymentModule other = bdmsByIdentifier.get(dependency.getIdentifier());\n                if (other != null && other != bdm) {\n                    bdm.addBeanDeploymentModule(other);\n                }\n            }\n        }\n\n        final EjbInjectionServices ejbInjectionServices = new WeldEjbInjectionServices(deploymentUnit.getServiceRegistry(),\n                eeModuleDescription, eeApplicationDescription, deploymentRoot.getRoot());\n        final ResourceInjectionServices resourceInjectionServices = new WeldResourceInjectionServices(deploymentUnit.getServiceRegistry(), eeModuleDescription);\n        final WeldClassFileServices classFileServices = (rootIndex != null ? new WeldClassFileServices(rootIndex, module.getClassLoader()) : null);\n\n\n        rootBeanDeploymentModule.addService(EjbInjectionServices.class, ejbInjectionServices);\n        rootBeanDeploymentModule.addService(ResourceInjectionServices.class, resourceInjectionServices);\n        if (classFileServices != null) {\n            rootBeanDeploymentModule.addService(ClassFileServices.class, classFileServices);\n        }\n\n        for (final BeanDeploymentArchiveImpl additional : deploymentUnit.getAttachmentList(WeldAttachments.ADDITIONAL_BEAN_DEPLOYMENT_MODULES)) {\n            beanDeploymentArchives.add(additional);\n            additional.getServices().add(EjbInjectionServices.class, ejbInjectionServices);\n            additional.getServices().add(ResourceInjectionServices.class, resourceInjectionServices);\n            if (classFileServices != null) {\n                additional.getServices().add(ClassFileServices.class, classFileServices);\n            }\n        }\n\n        final Collection<Metadata<Extension>> extensions = WeldPortableExtensions.getPortableExtensions(deploymentUnit).getExtensions();\n\n        final WeldDeployment deployment = new WeldDeployment(beanDeploymentArchives, extensions, module, subDeploymentLoaders, deploymentUnit, rootBeanDeploymentModule);\n\n        final WeldBootstrapService weldBootstrapService = new WeldBootstrapService(deployment, Environments.EE_INJECT, deploymentUnit.getName());\n\n        installBootstrapConfigurationService(deployment, parent);\n\n        weldBootstrapService.addWeldService(EjbInjectionServices.class, ejbInjectionServices);\n        weldBootstrapService.addWeldService(ResourceInjectionServices.class, resourceInjectionServices);\n        weldBootstrapService.addWeldService(EjbServices.class, new WeldEjbServices(deploymentUnit.getServiceRegistry()));\n        if (classFileServices != null) {\n            weldBootstrapService.addWeldService(ClassFileServices.class, classFileServices);\n        }\n\n        final JpaInjectionServices rootJpaInjectionServices = new WeldJpaInjectionServices(deploymentUnit);\n        final JaxwsInjectionServices rootJaxWsInjectionServices = new WeldJaxwsInjectionServices(deploymentUnit);\n        weldBootstrapService.addWeldService(JpaInjectionServices.class, rootJpaInjectionServices);\n        weldBootstrapService.addWeldService(JaxwsInjectionServices.class, rootJaxWsInjectionServices);\n\n        // add the weld service\n        final ServiceBuilder<WeldBootstrapService> weldBootstrapServiceBuilder = serviceTarget.addService(weldBootstrapServiceName, weldBootstrapService);\n\n        weldBootstrapServiceBuilder.addDependencies(TCCLSingletonService.SERVICE_NAME);\n\n        installSecurityService(serviceTarget, deploymentUnit, weldBootstrapService, weldBootstrapServiceBuilder);\n        installTransactionService(serviceTarget, deploymentUnit, weldBootstrapService, weldBootstrapServiceBuilder);\n\n        weldBootstrapServiceBuilder.install();\n\n        final List<SetupAction> setupActions = new ArrayList<SetupAction>();\n        JavaNamespaceSetup naming = deploymentUnit.getAttachment(org.jboss.as.ee.naming.Attachments.JAVA_NAMESPACE_SETUP_ACTION);\n        if (naming != null) {\n            setupActions.add(naming);\n        }\n\n        final WeldStartService weldStartService = new WeldStartService(setupActions, module.getClassLoader(), Utils.getRootDeploymentUnit(deploymentUnit).getServiceName());\n\n        ServiceBuilder<WeldStartService> startService = serviceTarget.addService(deploymentUnit.getServiceName().append(WeldStartService.SERVICE_NAME), weldStartService)\n                .addDependency(weldBootstrapServiceName, WeldBootstrapService.class, weldStartService.getBootstrap())\n                .addDependencies(jpaServices);\n\n        // make sure JNDI bindings are up\n        startService.addDependency(JndiNamingDependencyProcessor.serviceName(deploymentUnit));\n        final EarMetaData earConfig = deploymentUnit.getAttachment(org.jboss.as.ee.structure.Attachments.EAR_METADATA);\n        if (earConfig == null || !earConfig.getInitializeInOrder())  {\n            // in-order install of sub-deployments may result in service dependencies deadlocks if the jndi dependency services of subdeployments are added as dependencies\n            for (DeploymentUnit sub : subDeployments) {\n                startService.addDependency(JndiNamingDependencyProcessor.serviceName(sub));\n            }\n        }\n\n        startService.install();\n\n    }","id":65357,"modified_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final DeploymentUnit parent = Utils.getRootDeploymentUnit(deploymentUnit);\n        final ServiceTarget serviceTarget = phaseContext.getServiceTarget();\n        final ResourceRoot deploymentRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT);\n        if (!WeldDeploymentMarker.isPartOfWeldDeployment(deploymentUnit)) {\n\n            //if there are CDI annotation present and this is the top level deployment we log a warning\n            if (deploymentUnit.getParent() == null && CdiAnnotationMarker.cdiAnnotationsPresent(deploymentUnit)) {\n                WeldLogger.DEPLOYMENT_LOGGER.cdiAnnotationsButNotBeanArchive(deploymentUnit);\n            }\n\n            return;\n        }\n\n        //add a dependency on the weld service to web deployments\n        final ServiceName weldBootstrapServiceName = parent.getServiceName().append(WeldBootstrapService.SERVICE_NAME);\n        deploymentUnit.addToAttachmentList(Attachments.WEB_DEPENDENCIES, weldBootstrapServiceName);\n\n        final Set<ServiceName> jpaServices = new HashSet<ServiceName>();\n\n\n        // we only start weld on top level deployments\n        if (deploymentUnit.getParent() != null) {\n            return;\n        }\n\n        WeldLogger.DEPLOYMENT_LOGGER.startingServicesForCDIDeployment(phaseContext.getDeploymentUnit().getName());\n\n        final Module module = deploymentUnit.getAttachment(Attachments.MODULE);\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n\n        final Set<BeanDeploymentArchiveImpl> beanDeploymentArchives = new HashSet<BeanDeploymentArchiveImpl>();\n        final Map<ModuleIdentifier, BeanDeploymentModule> bdmsByIdentifier = new HashMap<ModuleIdentifier, BeanDeploymentModule>();\n        final Map<ModuleIdentifier, ModuleSpecification> moduleSpecByIdentifier = new HashMap<ModuleIdentifier, ModuleSpecification>();\n\n        // the root module only has access to itself. For most deployments this will be the only module\n        // for ear deployments this represents the ear/lib directory.\n        // war and jar deployment visibility will depend on the dependencies that\n        // exist in the application, and mirror inter module dependencies\n        final BeanDeploymentModule rootBeanDeploymentModule = deploymentUnit.getAttachment(WeldAttachments.BEAN_DEPLOYMENT_MODULE);\n\n        final EEModuleDescription eeModuleDescription = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.EE_MODULE_DESCRIPTION);\n        final EEApplicationDescription eeApplicationDescription = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.EE_APPLICATION_DESCRIPTION);\n\n        bdmsByIdentifier.put(module.getIdentifier(), rootBeanDeploymentModule);\n\n        moduleSpecByIdentifier.put(module.getIdentifier(), moduleSpecification);\n\n        beanDeploymentArchives.addAll(rootBeanDeploymentModule.getBeanDeploymentArchives());\n        final List<DeploymentUnit> subDeployments = deploymentUnit.getAttachmentList(Attachments.SUB_DEPLOYMENTS);\n\n        final Set<ClassLoader> subDeploymentLoaders = new HashSet<ClassLoader>();\n\n        getJpaDependencies(deploymentUnit, jpaServices);\n\n        for (DeploymentUnit subDeployment : subDeployments) {\n            getJpaDependencies(deploymentUnit, jpaServices);\n            final Module subDeploymentModule = subDeployment.getAttachment(Attachments.MODULE);\n            if (subDeploymentModule == null) {\n                continue;\n            }\n            subDeploymentLoaders.add(subDeploymentModule.getClassLoader());\n\n            final ModuleSpecification subDeploymentModuleSpec = subDeployment.getAttachment(Attachments.MODULE_SPECIFICATION);\n            final BeanDeploymentModule bdm = subDeployment.getAttachment(WeldAttachments.BEAN_DEPLOYMENT_MODULE);\n            if (bdm == null) {\n                continue;\n            }\n            // add the modules bdas to the global set of bdas\n            beanDeploymentArchives.addAll(bdm.getBeanDeploymentArchives());\n            bdmsByIdentifier.put(subDeploymentModule.getIdentifier(), bdm);\n            moduleSpecByIdentifier.put(subDeploymentModule.getIdentifier(), subDeploymentModuleSpec);\n\n            //we have to do this here as the aggregate components are not available in earlier phases\n            final ResourceRoot subDeploymentRoot = subDeployment.getAttachment(Attachments.DEPLOYMENT_ROOT);\n            final EjbInjectionServices ejbInjectionServices = new WeldEjbInjectionServices(deploymentUnit.getServiceRegistry(), eeModuleDescription, eeApplicationDescription, subDeploymentRoot.getRoot());\n            bdm.addService(EjbInjectionServices.class, ejbInjectionServices);\n\n            final ResourceInjectionServices resourceInjectionServices = new WeldResourceInjectionServices(deploymentUnit.getServiceRegistry(), eeModuleDescription);\n            bdm.addService(ResourceInjectionServices.class, resourceInjectionServices);\n        }\n\n        for (Map.Entry<ModuleIdentifier, BeanDeploymentModule> entry : bdmsByIdentifier.entrySet()) {\n            final ModuleSpecification bdmSpec = moduleSpecByIdentifier.get(entry.getKey());\n            final BeanDeploymentModule bdm = entry.getValue();\n            if (bdm == rootBeanDeploymentModule) {\n                continue; // the root module only has access to itself\n            }\n            for (ModuleDependency dependency : bdmSpec.getSystemDependencies()) {\n                BeanDeploymentModule other = bdmsByIdentifier.get(dependency.getIdentifier());\n                if (other != null && other != bdm) {\n                    bdm.addBeanDeploymentModule(other);\n                }\n            }\n        }\n\n        final EjbInjectionServices ejbInjectionServices = new WeldEjbInjectionServices(deploymentUnit.getServiceRegistry(),\n                eeModuleDescription, eeApplicationDescription, deploymentRoot.getRoot());\n        final ResourceInjectionServices resourceInjectionServices = new WeldResourceInjectionServices(deploymentUnit.getServiceRegistry(), eeModuleDescription);\n\n        rootBeanDeploymentModule.addService(EjbInjectionServices.class, ejbInjectionServices);\n        rootBeanDeploymentModule.addService(ResourceInjectionServices.class, resourceInjectionServices);\n\n        for (final BeanDeploymentArchiveImpl additional : deploymentUnit.getAttachmentList(WeldAttachments.ADDITIONAL_BEAN_DEPLOYMENT_MODULES)) {\n            beanDeploymentArchives.add(additional);\n            additional.getServices().add(EjbInjectionServices.class, ejbInjectionServices);\n            additional.getServices().add(ResourceInjectionServices.class, resourceInjectionServices);\n        }\n\n        final Collection<Metadata<Extension>> extensions = WeldPortableExtensions.getPortableExtensions(deploymentUnit).getExtensions();\n\n        final WeldDeployment deployment = new WeldDeployment(beanDeploymentArchives, extensions, module, subDeploymentLoaders, deploymentUnit, rootBeanDeploymentModule);\n\n        final WeldBootstrapService weldBootstrapService = new WeldBootstrapService(deployment, Environments.EE_INJECT, deploymentUnit.getName());\n\n        installBootstrapConfigurationService(deployment, parent);\n\n        weldBootstrapService.addWeldService(EjbInjectionServices.class, ejbInjectionServices);\n        weldBootstrapService.addWeldService(ResourceInjectionServices.class, resourceInjectionServices);\n        weldBootstrapService.addWeldService(EjbServices.class, new WeldEjbServices(deploymentUnit.getServiceRegistry()));\n\n\n        final JpaInjectionServices rootJpaInjectionServices = new WeldJpaInjectionServices(deploymentUnit);\n        final JaxwsInjectionServices rootJaxWsInjectionServices = new WeldJaxwsInjectionServices(deploymentUnit);\n        weldBootstrapService.addWeldService(JpaInjectionServices.class, rootJpaInjectionServices);\n        weldBootstrapService.addWeldService(JaxwsInjectionServices.class, rootJaxWsInjectionServices);\n\n        // add the weld service\n        final ServiceBuilder<WeldBootstrapService> weldBootstrapServiceBuilder = serviceTarget.addService(weldBootstrapServiceName, weldBootstrapService);\n\n        weldBootstrapServiceBuilder.addDependencies(TCCLSingletonService.SERVICE_NAME);\n\n        installSecurityService(serviceTarget, deploymentUnit, weldBootstrapService, weldBootstrapServiceBuilder);\n        installTransactionService(serviceTarget, deploymentUnit, weldBootstrapService, weldBootstrapServiceBuilder);\n\n        weldBootstrapServiceBuilder.install();\n\n        final List<SetupAction> setupActions = new ArrayList<SetupAction>();\n        JavaNamespaceSetup naming = deploymentUnit.getAttachment(org.jboss.as.ee.naming.Attachments.JAVA_NAMESPACE_SETUP_ACTION);\n        if (naming != null) {\n            setupActions.add(naming);\n        }\n\n        final WeldStartService weldStartService = new WeldStartService(setupActions, module.getClassLoader(), Utils.getRootDeploymentUnit(deploymentUnit).getServiceName());\n\n        ServiceBuilder<WeldStartService> startService = serviceTarget.addService(deploymentUnit.getServiceName().append(WeldStartService.SERVICE_NAME), weldStartService)\n                .addDependency(weldBootstrapServiceName, WeldBootstrapService.class, weldStartService.getBootstrap())\n                .addDependencies(jpaServices);\n\n        // make sure JNDI bindings are up\n        startService.addDependency(JndiNamingDependencyProcessor.serviceName(deploymentUnit));\n        final EarMetaData earConfig = deploymentUnit.getAttachment(org.jboss.as.ee.structure.Attachments.EAR_METADATA);\n        if (earConfig == null || !earConfig.getInitializeInOrder())  {\n            // in-order install of sub-deployments may result in service dependencies deadlocks if the jndi dependency services of subdeployments are added as dependencies\n            for (DeploymentUnit sub : subDeployments) {\n                startService.addDependency(JndiNamingDependencyProcessor.serviceName(sub));\n            }\n        }\n\n        startService.install();\n\n    }","commit_id":"78cb35b344abad9835b93285597b6377f4a36e87","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected InterceptorBindings getInterceptorBindings(String ejbName, final BeanManagerImpl manager) {\n        if (ejbName != null) {\n            EjbServices ejbServices = manager.getServices().get(EjbServices.class);\n            if (ejbServices instanceof ForwardingEjbServices) {\n                ejbServices = ((ForwardingEjbServices) ejbServices).delegate();\n            }\n            if (ejbServices instanceof WeldEjbServices) {\n                return ((WeldEjbServices) ejbServices).getBindings(ejbName);\n            }\n        } else {\n            // This is a managed bean\n            SlimAnnotatedType<?> type = (SlimAnnotatedType<?>) manager.createAnnotatedType(componentClass);\n            if (!manager.getInterceptorModelRegistry().containsKey(type)) {\n                EnhancedAnnotatedType<?> enhancedType = manager.getServices().get(ClassTransformer.class).getEnhancedAnnotatedType(type);\n                InterceptionModelInitializer.of(manager, enhancedType, null).init();\n            }\n            InterceptionModel model = manager.getInterceptorModelRegistry().get(type);\n            if (model != null) {\n                return new InterceptorBindingsAdapter(manager.getInterceptorModelRegistry().get(type));\n            }\n        }\n        return null;\n    }","id":65358,"modified_method":"protected InterceptorBindings getInterceptorBindings(String ejbName, final BeanManagerImpl manager) {\n        if (ejbName != null) {\n            EjbServices ejbServices = manager.getServices().get(EjbServices.class);\n            if (ejbServices instanceof ForwardingEjbServices) {\n                ejbServices = ((ForwardingEjbServices) ejbServices).delegate();\n            }\n            if (ejbServices instanceof WeldEjbServices) {\n                return ((WeldEjbServices) ejbServices).getBindings(ejbName);\n            }\n        } else {\n            // This is a managed bean\n            SlimAnnotatedType<?> type = (SlimAnnotatedType<?>) manager.createAnnotatedType(componentClass);\n            if (!manager.getInterceptorModelRegistry().containsKey(type)) {\n                EnhancedAnnotatedType<?> enhancedType = manager.getServices().get(ClassTransformer.class).getEnhancedAnnotatedType(type);\n                InterceptionModelInitializer.of(manager, enhancedType, null).init();\n            }\n            InterceptionModel<ClassMetadata<?>> model = manager.getInterceptorModelRegistry().get(type);\n            if (model != null) {\n                return new InterceptorBindingsAdapter(manager.getInterceptorModelRegistry().get(type));\n            }\n        }\n        return null;\n    }","commit_id":"78cb35b344abad9835b93285597b6377f4a36e87","url":"https://github.com/wildfly/wildfly"},{"original_method":"private ResourceRootHandler(DeploymentUnit deploymentUnit, Components components, Map<ResourceRoot, Index> indexes) {\n            this.deploymentUnit = deploymentUnit;\n            this.explicitBeanArchives = deploymentUnit.getAttachment(ExplicitBeanArchiveMetadataContainer.ATTACHMENT_KEY);\n            this.module = deploymentUnit.getAttachment(Attachments.MODULE);\n            this.indexes = indexes;\n            this.components = components;\n            this.reflectionIndex = deploymentUnit.getAttachment(Attachments.REFLECTION_INDEX);\n            this.deploymentResourceRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT);\n            this.classesResourceRoot = deploymentUnit.getAttachment(WeldAttachments.CLASSES_RESOURCE_ROOT);\n            HashSet<AnnotationType> annotationTypes = new HashSet<>(getRootDeploymentUnit(deploymentUnit).getAttachment(WeldAttachments.BEAN_DEFINING_ANNOTATIONS));\n            annotationTypes.addAll(getRootDeploymentUnit(deploymentUnit).getAttachmentList(WeldAttachments.INJECTION_TARGET_DEFINING_ANNOTATIONS));\n            this.beanDefiningAnnotations = annotationTypes;\n            this.requireBeanDescriptor = getRootDeploymentUnit(deploymentUnit).getAttachment(WeldConfiguration.ATTACHMENT_KEY).isRequireBeanDescriptor();\n        }","id":65359,"modified_method":"private ResourceRootHandler(DeploymentUnit deploymentUnit, Components components, Map<ResourceRoot, Index> indexes) {\n            this.deploymentUnit = deploymentUnit;\n            this.explicitBeanArchives = deploymentUnit.getAttachment(ExplicitBeanArchiveMetadataContainer.ATTACHMENT_KEY);\n            this.module = deploymentUnit.getAttachment(Attachments.MODULE);\n            this.indexes = indexes;\n            this.components = components;\n            this.reflectionIndex = deploymentUnit.getAttachment(Attachments.REFLECTION_INDEX);\n            this.deploymentResourceRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT);\n            this.classesResourceRoot = deploymentUnit.getAttachment(WeldAttachments.CLASSES_RESOURCE_ROOT);\n            HashSet<AnnotationType> annotationTypes = new HashSet<>(getRootDeploymentUnit(deploymentUnit).getAttachment(WeldAttachments.BEAN_DEFINING_ANNOTATIONS));\n            List<DotName> definingAnnotations = getRootDeploymentUnit(deploymentUnit).getAttachmentList(InjectionTargetDefiningAnnotations.INJECTION_TARGET_DEFINING_ANNOTATIONS);\n            for(DotName annotation : definingAnnotations) {\n                annotationTypes.add(new AnnotationType(annotation, false));\n            }\n            this.beanDefiningAnnotations = annotationTypes;\n            this.requireBeanDescriptor = getRootDeploymentUnit(deploymentUnit).getAttachment(WeldConfiguration.ATTACHMENT_KEY).isRequireBeanDescriptor();\n        }","commit_id":"592267be4397bcacb15790d7ef4e50999fec4f91","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n\n        if (deploymentUnit.getParent() == null) {\n            //register resource, provider and application as CDI annotation defining types\n            deploymentUnit.addToAttachmentList(WeldAttachments.INJECTION_TARGET_DEFINING_ANNOTATIONS, new AnnotationType(JaxrsAnnotations.PROVIDER.getDotName(), false));\n            deploymentUnit.addToAttachmentList(WeldAttachments.INJECTION_TARGET_DEFINING_ANNOTATIONS, new AnnotationType(JaxrsAnnotations.PATH.getDotName(), false));\n        }\n\n        final CompositeIndex index = deploymentUnit.getAttachment(Attachments.COMPOSITE_ANNOTATION_INDEX);\n        for (final JaxrsAnnotations annotation : JaxrsAnnotations.values()) {\n            if (!index.getAnnotations(annotation.getDotName()).isEmpty()) {\n                JaxrsDeploymentMarker.mark(deploymentUnit);\n                phaseContext.addToAttachmentList(Attachments.NEXT_PHASE_DEPS, Services.JBOSS_MODULE_INDEX_SERVICE);\n                return;\n            }\n        }\n\n    }","id":65360,"modified_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n\n        if (deploymentUnit.getParent() == null) {\n            //register resource, provider and application as CDI annotation defining types\n            deploymentUnit.addToAttachmentList(INJECTION_TARGET_DEFINING_ANNOTATIONS, JaxrsAnnotations.PROVIDER.getDotName());\n            deploymentUnit.addToAttachmentList(INJECTION_TARGET_DEFINING_ANNOTATIONS, JaxrsAnnotations.PATH.getDotName());\n        }\n\n        final CompositeIndex index = deploymentUnit.getAttachment(Attachments.COMPOSITE_ANNOTATION_INDEX);\n        for (final JaxrsAnnotations annotation : JaxrsAnnotations.values()) {\n            if (!index.getAnnotations(annotation.getDotName()).isEmpty()) {\n                JaxrsDeploymentMarker.mark(deploymentUnit);\n                phaseContext.addToAttachmentList(Attachments.NEXT_PHASE_DEPS, Services.JBOSS_MODULE_INDEX_SERVICE);\n                return;\n            }\n        }\n\n    }","commit_id":"592267be4397bcacb15790d7ef4e50999fec4f91","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n\n        final Module module = deploymentUnit.getAttachment(org.jboss.as.server.deployment.Attachments.MODULE);\n        if (module == null) {\n            return;\n        }\n\n\n        final ResteasyDeploymentData resteasy = deploymentUnit.getAttachment(JaxrsAttachments.RESTEASY_DEPLOYMENT_DATA);\n        if (resteasy == null) {\n            return;\n        }\n        // right now I only support resources\n        if (!resteasy.isScanResources()) return;\n\n        final EEModuleDescription moduleDescription = deploymentUnit.getAttachment(Attachments.EE_MODULE_DESCRIPTION);\n        if (moduleDescription == null) {\n            return;\n        }\n\n        final ClassLoader loader = module.getClassLoader();\n\n        for (final ComponentDescription component : moduleDescription.getComponentDescriptions()) {\n            Class<?> componentClass = null;\n            try {\n                componentClass = loader.loadClass(component.getComponentClassName());\n            } catch (ClassNotFoundException e) {\n                throw new DeploymentUnitProcessingException(e);\n            }\n            if (!GetRestful.isRootResource(componentClass)) continue;\n\n            if (component instanceof SessionBeanComponentDescription) {\n                if (component instanceof StatefulComponentDescription) {\n                    //using SFSB's as JAX-RS endpoints is not recommended, but if people really want to do it they can\n\n                    JAXRS_LOGGER.debugf(\"Stateful session bean %s is being used as a JAX-RS endpoint, this is not recommended\", component.getComponentName());\n                    if (WeldDeploymentMarker.isPartOfWeldDeployment(deploymentUnit)) {\n                        //if possible just let CDI handle the integration\n                        continue;\n                    }\n                }\n\n                Class[] jaxrsType = GetRestful.getSubResourceClasses(componentClass);\n                final String jndiName;\n                if (component.getViews().size() == 1) {\n                    //only 1 view, just use the simple JNDI name\n                    jndiName = \"java:app/\" + moduleDescription.getModuleName() + \"/\" + component.getComponentName();\n                } else {\n                    boolean found = false;\n                    String foundType = null;\n                    for (final ViewDescription view : component.getViews()) {\n                        for (Class subResource : jaxrsType) {\n                            if (view.getViewClassName().equals(subResource.getName())) {\n                                foundType = subResource.getName();\n                                found = true;\n                                break;\n                            }\n                        }\n                        if (found) {\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        throw JaxrsLogger.JAXRS_LOGGER.typeNameNotAnEjbView(Arrays.asList(jaxrsType), component.getComponentName());\n                    }\n                    jndiName = \"java:app/\" + moduleDescription.getModuleName() + \"/\" + component.getComponentName() + \"!\" + foundType;\n                }\n\n                JAXRS_LOGGER.debugf(\"Found JAX-RS Managed Bean: %s local jndi jaxRsTypeName: %s\", component.getComponentClassName(), jndiName);\n                StringBuilder buf = new StringBuilder();\n                buf.append(jndiName).append(\";\").append(component.getComponentClassName()).append(\";\").append(\"true\");\n\n                resteasy.getScannedJndiComponentResources().add(buf.toString());\n                // make sure its removed from list\n                resteasy.getScannedResourceClasses().remove(component.getComponentClassName());\n            } else if (component instanceof ManagedBeanComponentDescription) {\n                String jndiName = \"java:app/\" + moduleDescription.getModuleName() + \"/\" + component.getComponentName();\n\n                JAXRS_LOGGER.debugf(\"Found JAX-RS Managed Bean: %s local jndi name: %s\", component.getComponentClassName(), jndiName);\n                StringBuilder buf = new StringBuilder();\n                buf.append(jndiName).append(\";\").append(component.getComponentClassName()).append(\";\").append(\"true\");\n\n                resteasy.getScannedJndiComponentResources().add(buf.toString());\n                // make sure its removed from list\n                resteasy.getScannedResourceClasses().remove(component.getComponentClassName());\n            }\n        }\n    }","id":65361,"modified_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n\n        final Module module = deploymentUnit.getAttachment(org.jboss.as.server.deployment.Attachments.MODULE);\n        if (module == null) {\n            return;\n        }\n\n\n        final ResteasyDeploymentData resteasy = deploymentUnit.getAttachment(JaxrsAttachments.RESTEASY_DEPLOYMENT_DATA);\n        if (resteasy == null) {\n            return;\n        }\n        // right now I only support resources\n        if (!resteasy.isScanResources()) return;\n\n        final EEModuleDescription moduleDescription = deploymentUnit.getAttachment(Attachments.EE_MODULE_DESCRIPTION);\n        if (moduleDescription == null) {\n            return;\n        }\n\n        final ClassLoader loader = module.getClassLoader();\n\n        for (final ComponentDescription component : moduleDescription.getComponentDescriptions()) {\n            Class<?> componentClass = null;\n            try {\n                componentClass = loader.loadClass(component.getComponentClassName());\n            } catch (ClassNotFoundException e) {\n                throw new DeploymentUnitProcessingException(e);\n            }\n            if (!GetRestful.isRootResource(componentClass)) continue;\n\n            if (isInstanceOf(component, SESSION_BEAN_DESCRIPTION_CLASS_NAME)) {\n                if (isInstanceOf(component, STATEFUL_SESSION_BEAN_DESCRIPTION_CLASS_NAME)) {\n                    //using SFSB's as JAX-RS endpoints is not recommended, but if people really want to do it they can\n\n                    JAXRS_LOGGER.debugf(\"Stateful session bean %s is being used as a JAX-RS endpoint, this is not recommended\", component.getComponentName());\n                    if (WeldDeploymentMarker.isPartOfWeldDeployment(deploymentUnit)) {\n                        //if possible just let CDI handle the integration\n                        continue;\n                    }\n                }\n\n                Class[] jaxrsType = GetRestful.getSubResourceClasses(componentClass);\n                final String jndiName;\n                if (component.getViews().size() == 1) {\n                    //only 1 view, just use the simple JNDI name\n                    jndiName = \"java:app/\" + moduleDescription.getModuleName() + \"/\" + component.getComponentName();\n                } else {\n                    boolean found = false;\n                    String foundType = null;\n                    for (final ViewDescription view : component.getViews()) {\n                        for (Class subResource : jaxrsType) {\n                            if (view.getViewClassName().equals(subResource.getName())) {\n                                foundType = subResource.getName();\n                                found = true;\n                                break;\n                            }\n                        }\n                        if (found) {\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        throw JaxrsLogger.JAXRS_LOGGER.typeNameNotAnEjbView(Arrays.asList(jaxrsType), component.getComponentName());\n                    }\n                    jndiName = \"java:app/\" + moduleDescription.getModuleName() + \"/\" + component.getComponentName() + \"!\" + foundType;\n                }\n\n                JAXRS_LOGGER.debugf(\"Found JAX-RS Managed Bean: %s local jndi jaxRsTypeName: %s\", component.getComponentClassName(), jndiName);\n                StringBuilder buf = new StringBuilder();\n                buf.append(jndiName).append(\";\").append(component.getComponentClassName()).append(\";\").append(\"true\");\n\n                resteasy.getScannedJndiComponentResources().add(buf.toString());\n                // make sure its removed from list\n                resteasy.getScannedResourceClasses().remove(component.getComponentClassName());\n            } else if (component instanceof ManagedBeanComponentDescription) {\n                String jndiName = \"java:app/\" + moduleDescription.getModuleName() + \"/\" + component.getComponentName();\n\n                JAXRS_LOGGER.debugf(\"Found JAX-RS Managed Bean: %s local jndi name: %s\", component.getComponentClassName(), jndiName);\n                StringBuilder buf = new StringBuilder();\n                buf.append(jndiName).append(\";\").append(component.getComponentClassName()).append(\";\").append(\"true\");\n\n                resteasy.getScannedJndiComponentResources().add(buf.toString());\n                // make sure its removed from list\n                resteasy.getScannedResourceClasses().remove(component.getComponentClassName());\n            }\n        }\n    }","commit_id":"592267be4397bcacb15790d7ef4e50999fec4f91","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void addDependency(ModuleSpecification moduleSpecification, ModuleLoader moduleLoader,\n                               ModuleIdentifier moduleIdentifier) {\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, moduleIdentifier, false, false, true, false));\n    }","id":65362,"modified_method":"private void addDependency(ModuleSpecification moduleSpecification, ModuleLoader moduleLoader,\n                               ModuleIdentifier moduleIdentifier, boolean optional) {\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, moduleIdentifier, optional, false, true, false));\n    }","commit_id":"592267be4397bcacb15790d7ef4e50999fec4f91","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n\n        final ModuleLoader moduleLoader = Module.getBootModuleLoader();\n        addDependency(moduleSpecification, moduleLoader, JAXRS_API);\n        addDependency(moduleSpecification, moduleLoader, JAXB_API);\n        addDependency(moduleSpecification, moduleLoader, JSON_API);\n\n        //we need to add these from all deployments, as they could be using the JAX-RS client\n\n        addDependency(moduleSpecification, moduleLoader, RESTEASY_ATOM);\n        addDependency(moduleSpecification, moduleLoader, RESTEASY_VALIDATOR_11);\n        addDependency(moduleSpecification, moduleLoader, RESTEASY_JAXRS);\n        addDependency(moduleSpecification, moduleLoader, RESTEASY_JAXB);\n        addDependency(moduleSpecification, moduleLoader, RESTEASY_JACKSON2);\n        addDependency(moduleSpecification, moduleLoader, RESTEASY_JSON_P_PROVIDER);\n        //addDependency(moduleSpecification, moduleLoader, RESTEASY_JETTISON);\n        addDependency(moduleSpecification, moduleLoader, RESTEASY_JSAPI);\n        addDependency(moduleSpecification, moduleLoader, RESTEASY_MULTIPART);\n        addDependency(moduleSpecification, moduleLoader, RESTEASY_YAML);\n        addDependency(moduleSpecification, moduleLoader, JACKSON_CORE_ASL);\n        addDependency(moduleSpecification, moduleLoader, RESTEASY_CRYPTO);\n\n        if (WeldDeploymentMarker.isPartOfWeldDeployment(deploymentUnit)) {\n            addDependency(moduleSpecification, moduleLoader, RESTEASY_CDI);\n        }\n\n    }","id":65363,"modified_method":"public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n\n        final ModuleLoader moduleLoader = Module.getBootModuleLoader();\n        addDependency(moduleSpecification, moduleLoader, JAXRS_API, false);\n        addDependency(moduleSpecification, moduleLoader, JAXB_API, false);\n        addDependency(moduleSpecification, moduleLoader, JSON_API, false);\n\n        //we need to add these from all deployments, as they could be using the JAX-RS client\n\n        addDependency(moduleSpecification, moduleLoader, RESTEASY_ATOM, true);\n        addDependency(moduleSpecification, moduleLoader, RESTEASY_VALIDATOR_11, true);\n        addDependency(moduleSpecification, moduleLoader, RESTEASY_JAXRS, true);\n        addDependency(moduleSpecification, moduleLoader, RESTEASY_JAXB, true);\n        addDependency(moduleSpecification, moduleLoader, RESTEASY_JACKSON2, true);\n        addDependency(moduleSpecification, moduleLoader, RESTEASY_JSON_P_PROVIDER, true);\n        //addDependency(moduleSpecification, moduleLoader, RESTEASY_JETTISON);\n        addDependency(moduleSpecification, moduleLoader, RESTEASY_JSAPI, true);\n        addDependency(moduleSpecification, moduleLoader, RESTEASY_MULTIPART, true);\n        addDependency(moduleSpecification, moduleLoader, RESTEASY_YAML, true);\n        addDependency(moduleSpecification, moduleLoader, JACKSON_CORE_ASL, true);\n        addDependency(moduleSpecification, moduleLoader, RESTEASY_CRYPTO, true);\n\n        if (WeldDeploymentMarker.isPartOfWeldDeployment(deploymentUnit)) {\n            addDependency(moduleSpecification, moduleLoader, RESTEASY_CDI, true);\n        }\n\n    }","commit_id":"592267be4397bcacb15790d7ef4e50999fec4f91","url":"https://github.com/wildfly/wildfly"},{"original_method":"public SetMultimap<String, TaskSelectionResult> select(String name, Project project) {\n        return select(name, (ProjectInternal) project, Collections.<Project>emptySet());\n    }","id":65364,"modified_method":"/**\n     * Finds tasks that will have exactly the given name, without necessarily creating or configuring the tasks. Returns null if no such match found.\n     */\n    @Nullable\n    public TaskSelectionResult select(String name, Project project, boolean includeSubProjects) {\n        if (!includeSubProjects) {\n            TaskInternal task = (TaskInternal) project.getTasks().findByName(name);\n            if (task != null) {\n                return new FixedTaskSelectionResult(Collections.<Task>singleton(task));\n            }\n        } else {\n            LinkedHashSet<Task> tasks = new LinkedHashSet<Task>();\n            new MultiProjectTaskSelectionResult(name, project).collectTasks(tasks);\n            if (!tasks.isEmpty()) {\n                return new FixedTaskSelectionResult(tasks);\n            }\n        }\n\n        return null;\n    }","commit_id":"70858799511bb079ad6f6bfa6d260f1c8a110a73","url":"https://github.com/gradle/gradle"},{"original_method":"private TaskSelection getSelection(String path, ProjectInternal project) {\n        SetMultimap<String, TaskSelectionResult> tasksByName;\n        ResolvedTaskPath taskPath = taskPathResolver.resolvePath(path, project);\n\n        if (taskPath.isQualified()) {\n            tasksByName = taskNameResolver.select(taskPath.getTaskName(), taskPath.getProject());\n        } else {\n            tasksByName = taskNameResolver.selectAll(taskPath.getTaskName(), taskPath.getProject());\n        }\n\n        Set<TaskSelectionResult> tasks = tasksByName.get(taskPath.getTaskName());\n        if (!tasks.isEmpty()) {\n            // An exact match\n            return new TaskSelection(path, tasks);\n        }\n\n        NameMatcher matcher = new NameMatcher();\n        String actualName = matcher.find(taskPath.getTaskName(), tasksByName.keySet());\n        if (actualName != null) {\n            return new TaskSelection(taskPath.getPrefix() + actualName, tasksByName.get(actualName));\n        }\n\n        throw new TaskSelectionException(matcher.formatErrorMessage(\"task\", taskPath.getProject()));\n    }","id":65365,"modified_method":"private TaskSelection getSelection(String path, ProjectInternal project) {\n        ResolvedTaskPath taskPath = taskPathResolver.resolvePath(path, project);\n\n        TaskSelectionResult tasks = taskNameResolver.select(taskPath.getTaskName(), taskPath.getProject(), !taskPath.isQualified());\n        if (tasks != null) {\n            // An exact match\n            return new TaskSelection(path, tasks);\n        }\n\n        Map<String, TaskSelectionResult> tasksByName = taskNameResolver.selectAll(taskPath.getProject(), !taskPath.isQualified());\n        NameMatcher matcher = new NameMatcher();\n        String actualName = matcher.find(taskPath.getTaskName(), tasksByName.keySet());\n        if (actualName != null) {\n            return new TaskSelection(taskPath.getPrefix() + actualName, tasksByName.get(actualName));\n        }\n\n        throw new TaskSelectionException(matcher.formatErrorMessage(\"task\", taskPath.getProject()));\n    }","commit_id":"70858799511bb079ad6f6bfa6d260f1c8a110a73","url":"https://github.com/gradle/gradle"},{"original_method":"public Set<Task> getTasks() {\n            return CollectionUtils.collect(taskSelectionResult, new LinkedHashSet<Task>(), new Transformer<Task, TaskSelectionResult>() {\n                public Task transform(TaskSelectionResult original) {\n                    return original.getTask();\n                }\n            });\n        }","id":65366,"modified_method":"public Set<Task> getTasks() {\n            LinkedHashSet<Task> result = new LinkedHashSet<Task>();\n            taskSelectionResult.collectTasks(result);\n            return result;\n        }","commit_id":"70858799511bb079ad6f6bfa6d260f1c8a110a73","url":"https://github.com/gradle/gradle"},{"original_method":"public TaskSelection(String taskName, Set<TaskSelectionResult> tasks) {\n            this.taskName = taskName;\n            taskSelectionResult = tasks;\n        }","id":65367,"modified_method":"public TaskSelection(String taskName, TaskSelectionResult tasks) {\n            this.taskName = taskName;\n            taskSelectionResult = tasks;\n        }","commit_id":"70858799511bb079ad6f6bfa6d260f1c8a110a73","url":"https://github.com/gradle/gradle"},{"original_method":"private void updateSingleUsage(@NotNull PsiElement usage, @NotNull PsiNamedElement newElement) {\n    // TODO: Respect the qualified import style\n    if (usage instanceof PyQualifiedExpression) {\n      PyQualifiedExpression expr = (PyQualifiedExpression)usage;\n      if (myMovedElement instanceof PyClass && PyNames.INIT.equals(expr.getName())) {\n        return;\n      }\n      if (expr.isQualified()) {\n        final PyElementGenerator generator = PyElementGenerator.getInstance(expr.getProject());\n        final PyExpression generated = generator.createExpressionFromText(LanguageLevel.forElement(expr), expr.getName());\n        final PsiElement newExpr = expr.replace(generated);\n        PyClassRefactoringUtil.insertImport(newExpr, newElement, null, true);\n      }\n    }\n    if (usage instanceof PyStringLiteralExpression) {\n      for (PsiReference ref : usage.getReferences()) {\n        if (ref instanceof PyDunderAllReference) {\n          usage.delete();\n        }\n        else {\n          if (ref.isReferenceTo(myMovedElement)) {\n            ref.bindToElement(newElement);\n          }\n        }\n      }\n    }\n    else {\n      final PyImportStatementBase importStmt = getImportStatementByElement(usage);\n      if (importStmt != null) {\n        PyClassRefactoringUtil.updateImportOfElement(importStmt, newElement);\n      }\n      final PsiFile usageFile = usage.getContainingFile();\n      final PsiElement oldElementBody = PyMoveModuleMembersHelper.expandNamedElementBody(myMovedElement);\n      if (usageFile == myMovedElement.getContainingFile() && !PsiTreeUtil.isAncestor(oldElementBody, usage, false)) {\n        PyClassRefactoringUtil.insertImport(myMovedElement, newElement);\n      }\n      if (resolvesToLocalStarImport(usage)) {\n        PyClassRefactoringUtil.insertImport(usage, newElement);\n        myOptimizeImportTargets.add(usageFile);\n      }\n    }\n  }","id":65368,"modified_method":"private void updateSingleUsage(@NotNull PsiElement usage, @NotNull PsiNamedElement newElement) {\n    // TODO: Respect the qualified import style\n    if (usage instanceof PyQualifiedExpression) {\n      PyQualifiedExpression expr = (PyQualifiedExpression)usage;\n      if (myMovedElement instanceof PyClass && PyNames.INIT.equals(expr.getName())) {\n        return;\n      }\n      if (expr.isQualified()) {\n        insertImportFromAndReplaceReference(newElement, expr);\n      }\n    }\n    if (usage instanceof PyStringLiteralExpression) {\n      for (PsiReference ref : usage.getReferences()) {\n        if (ref instanceof PyDunderAllReference) {\n          usage.delete();\n        }\n        else {\n          if (ref.isReferenceTo(myMovedElement)) {\n            ref.bindToElement(newElement);\n          }\n        }\n      }\n    }\n    else {\n      // Update import of unqualified reference\n      final PyImportStatementBase importStmt = getImportStatementByElement(usage);\n      if (importStmt != null) {\n        PyClassRefactoringUtil.updateImportOfElement(importStmt, newElement);\n      }\n      // Do nothing if usage itself was moved too\n      if (belongsToSomeMovedElement(usage)) {\n        return;\n      }\n      final PsiFile usageFile = usage.getContainingFile();\n      if (usageFile == myMovedElement.getContainingFile() && usage instanceof PyQualifiedExpression) {\n        if (usage.getParent() instanceof PyGlobalStatement) {\n          myScopeOwnersWithGlobal.add(ScopeUtil.getScopeOwner(usage));\n          usage.delete();\n        }\n        else if (myScopeOwnersWithGlobal.contains(ScopeUtil.getScopeOwner(usage))) {\n          insertQualifiedImportAndReplaceReference(newElement, (PyQualifiedExpression)usage);\n        }\n        else {\n          insertImportFromAndReplaceReference(newElement, (PyQualifiedExpression)usage);\n        }\n      }\n      if (resolvesToLocalStarImport(usage)) {\n        PyClassRefactoringUtil.insertImport(usage, newElement);\n        myOptimizeImportTargets.add(usageFile);\n      }\n    }\n  }","commit_id":"9569af6e819c527be9914dd5c28b6219d97dd338","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doMoveSymbolsTest(@NotNull String toFileName, String... symbolNames) {\n    String root = \"/refactoring/move/\" + getTestName(true);\n    String rootBefore = root + \"/before/src\";\n    String rootAfter = root + \"/after/src\";\n    VirtualFile dir1 = myFixture.copyDirectoryToProject(rootBefore, \"\");\n    PsiDocumentManager.getInstance(myFixture.getProject()).commitAllDocuments();\n\n    final PsiNamedElement[] symbols = ContainerUtil.map2Array(symbolNames, PsiNamedElement.class, new Function<String, PsiNamedElement>() {\n      @Override\n      public PsiNamedElement fun(String name) {\n        final PsiNamedElement found = findFirstNamedElement(name);\n        assertNotNull(found);\n        return found;\n      }\n    });\n\n    VirtualFile toVirtualFile = dir1.findFileByRelativePath(toFileName);\n    String path = toVirtualFile != null ? toVirtualFile.getPath() : (dir1.getPath() + \"/\" + toFileName);\n    new PyMoveModuleMembersProcessor(myFixture.getProject(),\n                                     symbols,\n                                     path,\n                                     false).run();\n\n    VirtualFile dir2 = getVirtualFileByName(PythonTestUtil.getTestDataPath() + rootAfter);\n    try {\n      PlatformTestUtil.assertDirectoriesEqual(dir2, dir1);\n    }\n    catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }","id":65369,"modified_method":"private void doMoveSymbolsTest(@NotNull String toFileName, String... symbolNames) {\n    String root = \"/refactoring/move/\" + getTestName(true);\n    String rootBefore = root + \"/before/src\";\n    String rootAfter = root + \"/after/src\";\n    VirtualFile dir1 = myFixture.copyDirectoryToProject(rootBefore, \"\");\n    PsiDocumentManager.getInstance(myFixture.getProject()).commitAllDocuments();\n\n    final PsiNamedElement[] symbols = ContainerUtil.map2Array(symbolNames, PsiNamedElement.class, new Function<String, PsiNamedElement>() {\n      @Override\n      public PsiNamedElement fun(String name) {\n        final PsiNamedElement found = findFirstNamedElement(name);\n        assertNotNull(\"Symbol '\" + name + \"' does not exist\", found);\n        return found;\n      }\n    });\n\n    VirtualFile toVirtualFile = dir1.findFileByRelativePath(toFileName);\n    String path = toVirtualFile != null ? toVirtualFile.getPath() : (dir1.getPath() + \"/\" + toFileName);\n    new PyMoveModuleMembersProcessor(myFixture.getProject(),\n                                     symbols,\n                                     path,\n                                     false).run();\n\n    VirtualFile dir2 = getVirtualFileByName(PythonTestUtil.getTestDataPath() + rootAfter);\n    try {\n      PlatformTestUtil.assertDirectoriesEqual(dir2, dir1);\n    }\n    catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }","commit_id":"9569af6e819c527be9914dd5c28b6219d97dd338","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override public void visitField(@NotNull PsiField field) {\n            if (!field.hasModifierProperty(PsiModifier.STATIC)) {\n                return;\n            }\n            if (field.getInitializer() != null) {\n                return;\n            }\n            final PsiClass containingClass = field.getContainingClass();\n\n            if (containingClass == null) {\n                return;\n            }\n            if (containingClass.isEnum()) {\n                return;\n            }\n            if (m_ignorePrimitives) {\n                final PsiType type = field.getType();\n                if (ClassUtils.isPrimitive(type)) {\n                    return;\n                }\n            }\n            final PsiClassInitializer[] initializers =\n                    containingClass.getInitializers();\n            // Do the static initializers come in actual order in file?\n            // (They need to.)\n            final UninitializedReadCollector uninitializedReadCollector =\n                    new UninitializedReadCollector();\n            for(final PsiClassInitializer initializer : initializers) {\n                if(initializer.hasModifierProperty(PsiModifier.STATIC)) {\n                    final PsiCodeBlock body = initializer.getBody();\n                    if(uninitializedReadCollector.blockAssignsVariable(\n                            body, field)) {\n                        break;\n                    }\n                }\n            }\n\n            final PsiExpression[] badReads =\n                    uninitializedReadCollector.getUninitializedReads();\n            for(PsiExpression badRead : badReads) {\n                registerError(badRead);\n            }\n        }","id":65370,"modified_method":"@Override public void visitField(@NotNull PsiField field) {\n            if (!field.hasModifierProperty(PsiModifier.STATIC)) {\n                return;\n            }\n            if (field.getInitializer() != null) {\n                return;\n            }\n            final PsiClass containingClass = field.getContainingClass();\n            if (containingClass == null) {\n                return;\n            }\n            if (containingClass.isEnum()) {\n                return;\n            }\n            if (m_ignorePrimitives) {\n                final PsiType type = field.getType();\n                if (ClassUtils.isPrimitive(type)) {\n                    return;\n                }\n            }\n            final PsiClassInitializer[] initializers =\n                    containingClass.getInitializers();\n            // Do the static initializers come in actual order in file?\n            // (They need to.)\n            final UninitializedReadCollector uninitializedReadCollector =\n                    new UninitializedReadCollector();\n            boolean assigned = false;\n            for(final PsiClassInitializer initializer : initializers) {\n                if (!initializer.hasModifierProperty(PsiModifier.STATIC)) {\n                    continue;\n                }\n                final PsiCodeBlock body = initializer.getBody();\n                if(uninitializedReadCollector.blockAssignsVariable(\n                            body, field)) {\n                    assigned = true;\n                    break;\n                }\n            }\n            if (assigned) {\n                final PsiExpression[] badReads =\n                        uninitializedReadCollector.getUninitializedReads();\n                for(PsiExpression badRead : badReads) {\n                    registerError(badRead);\n                }\n                return;\n            }\n            final PsiMethod[] methods = containingClass.getMethods();\n            for (PsiMethod method : methods) {\n                if (!method.hasModifierProperty(PsiModifier.STATIC)) {\n                    continue;\n                }\n                final PsiCodeBlock body = method.getBody();\n                uninitializedReadCollector.blockAssignsVariable(body, field);\n            }\n            final PsiExpression[] moreBadReads =\n                    uninitializedReadCollector.getUninitializedReads();\n            for (PsiExpression badRead : moreBadReads) {\n                registerError(badRead);\n            }\n        }","commit_id":"705266743e2516133555c09b5c6458a9940a86f0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean blockAssignsVariable(@Nullable PsiCodeBlock block,\n                                        @NotNull PsiVariable variable){\n        return blockAssignsVariable(block, variable,\n                                    new HashSet<MethodSignature>());\n    }","id":65371,"modified_method":"public boolean blockAssignsVariable(@Nullable PsiCodeBlock block,\n                                        @NotNull PsiVariable variable){\n        return blockAssignsVariable(block, variable,\n                counter, new HashSet<MethodSignature>());\n    }","commit_id":"705266743e2516133555c09b5c6458a9940a86f0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean doWhileAssignsVariable(\n            @NotNull PsiDoWhileStatement doWhileStatement,\n            @NotNull PsiVariable variable,\n            @NotNull Set<MethodSignature> checkedMethods){\n        final PsiExpression condition = doWhileStatement.getCondition();\n        final PsiStatement body = doWhileStatement.getBody();\n        return expressionAssignsVariable(condition, variable, checkedMethods)\n                || statementAssignsVariable(body, variable, checkedMethods);\n    }","id":65372,"modified_method":"private boolean doWhileAssignsVariable(\n            @NotNull PsiDoWhileStatement doWhileStatement,\n            @NotNull PsiVariable variable,\n            int stamp, @NotNull Set<MethodSignature> checkedMethods){\n        final PsiExpression condition = doWhileStatement.getCondition();\n        final PsiStatement body = doWhileStatement.getBody();\n        return expressionAssignsVariable(condition, variable, stamp,\n                checkedMethods)\n                || statementAssignsVariable(body, variable, stamp,\n                checkedMethods);\n    }","commit_id":"705266743e2516133555c09b5c6458a9940a86f0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean forStatementAssignsVariable(\n            @NotNull PsiForStatement forStatement,\n            @NotNull PsiVariable variable,\n            @NotNull Set<MethodSignature> checkedMethods){\n        final PsiStatement initialization = forStatement.getInitialization();\n        if(statementAssignsVariable(initialization, variable, checkedMethods)){\n            return true;\n        }\n        final PsiExpression condition = forStatement.getCondition();\n        if(expressionAssignsVariable(condition, variable, checkedMethods)){\n            return true;\n        }\n        if(BoolUtils.isTrue(condition)){\n            final PsiStatement body = forStatement.getBody();\n            if(statementAssignsVariable(body, variable, checkedMethods)){\n                return true;\n            }\n            final PsiStatement update = forStatement.getUpdate();\n            if(statementAssignsVariable(update, variable, checkedMethods)){\n                return true;\n            }\n        }\n        return false;\n    }","id":65373,"modified_method":"private boolean forStatementAssignsVariable(\n            @NotNull PsiForStatement forStatement,\n            @NotNull PsiVariable variable,\n            int stamp, @NotNull Set<MethodSignature> checkedMethods){\n        final PsiStatement initialization = forStatement.getInitialization();\n        if(statementAssignsVariable(initialization, variable, stamp,\n                checkedMethods)){\n            return true;\n        }\n        final PsiExpression condition = forStatement.getCondition();\n        if(expressionAssignsVariable(condition, variable, stamp, checkedMethods)){\n            return true;\n        }\n        if(BoolUtils.isTrue(condition)){\n            final PsiStatement body = forStatement.getBody();\n            if(statementAssignsVariable(body, variable, stamp, checkedMethods)){\n                return true;\n            }\n            final PsiStatement update = forStatement.getUpdate();\n            if(statementAssignsVariable(update, variable, stamp, checkedMethods)){\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"705266743e2516133555c09b5c6458a9940a86f0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean statementAssignsVariable(\n            @Nullable PsiStatement statement, @NotNull PsiVariable variable,\n            @NotNull Set<MethodSignature> checkedMethods){\n        if(statement == null){\n            return false;\n        }\n        if(ExceptionUtils.statementThrowsException(statement)){\n            return true;\n        }\n        if(statement instanceof PsiBreakStatement ||\n                statement instanceof PsiContinueStatement ||\n                statement instanceof PsiAssertStatement ||\n                statement instanceof PsiEmptyStatement){\n            return false;\n        } else if(statement instanceof PsiReturnStatement){\n            //final PsiReturnStatement returnStatement =\n            //        (PsiReturnStatement) statement;\n            //final PsiExpression returnValue = returnStatement.getReturnValue();\n            //return expressionAssignsVariable(returnValue, variable,\n            //                                 checkedMethods);\n            return true;\n        } else if(statement instanceof PsiThrowStatement){\n            final PsiThrowStatement throwStatement =\n                    (PsiThrowStatement) statement;\n            final PsiExpression exception = throwStatement.getException();\n            return expressionAssignsVariable(exception, variable,\n                                             checkedMethods);\n        } else if(statement instanceof PsiExpressionListStatement){\n            final PsiExpressionListStatement list =\n                    (PsiExpressionListStatement) statement;\n            final PsiExpressionList expressionList = list.getExpressionList();\n            final PsiExpression[] expressions = expressionList.getExpressions();\n            for(final PsiExpression expression : expressions){\n                if(expressionAssignsVariable(expression, variable,\n                                             checkedMethods)){\n                    return true;\n                }\n            }\n            return false;\n        } else if(statement instanceof PsiExpressionStatement){\n            final PsiExpressionStatement expressionStatement =\n                    (PsiExpressionStatement) statement;\n            final PsiExpression expression =\n                    expressionStatement.getExpression();\n            return expressionAssignsVariable(expression, variable,\n                    checkedMethods);\n        } else if (statement instanceof PsiDeclarationStatement){\n            final PsiDeclarationStatement declarationStatement =\n                    (PsiDeclarationStatement)statement;\n            return declarationStatementAssignsVariable(declarationStatement,\n                    variable, checkedMethods);\n        } else if (statement instanceof PsiForStatement){\n            final PsiForStatement forStatement = (PsiForStatement)statement;\n            return forStatementAssignsVariable(forStatement, variable,\n                    checkedMethods);\n        } else if(statement instanceof PsiForeachStatement){\n            final PsiForeachStatement foreachStatement =\n                    (PsiForeachStatement)statement;\n            return foreachStatementAssignsVariable(foreachStatement, variable);\n        } else if(statement instanceof PsiWhileStatement){\n            final PsiWhileStatement whileStatement =\n                    (PsiWhileStatement) statement;\n            return whileStatementAssignsVariable(whileStatement, variable,\n                                                 checkedMethods);\n        } else if(statement instanceof PsiDoWhileStatement) {\n            final PsiDoWhileStatement doWhileStatement =\n                    (PsiDoWhileStatement)statement;\n            return doWhileAssignsVariable(doWhileStatement, variable,\n                    checkedMethods);\n        } else if(statement instanceof PsiSynchronizedStatement){\n            final PsiSynchronizedStatement synchronizedStatement =\n                    (PsiSynchronizedStatement)statement;\n            final PsiCodeBlock body = synchronizedStatement.getBody();\n            return blockAssignsVariable(body, variable, checkedMethods);\n        } else if(statement instanceof PsiBlockStatement){\n            final PsiBlockStatement blockStatement =\n                    (PsiBlockStatement) statement;\n            final PsiCodeBlock codeBlock = blockStatement.getCodeBlock();\n            return blockAssignsVariable(codeBlock, variable, checkedMethods);\n        } else if (statement instanceof PsiLabeledStatement){\n            final PsiLabeledStatement labeledStatement =\n                    (PsiLabeledStatement) statement;\n            final PsiStatement statementLabeled =\n                    labeledStatement.getStatement();\n            return statementAssignsVariable(statementLabeled, variable,\n                                            checkedMethods);\n        } else if(statement instanceof PsiIfStatement){\n            final PsiIfStatement ifStatement = (PsiIfStatement) statement;\n            return ifStatementAssignsVariable(ifStatement, variable,\n                                              checkedMethods);\n        } else if(statement instanceof PsiTryStatement){\n            final PsiTryStatement tryStatement = (PsiTryStatement) statement;\n            return tryStatementAssignsVariable(tryStatement, variable,\n                                               checkedMethods);\n        } else if(statement instanceof PsiSwitchStatement){\n            final PsiSwitchStatement switchStatement =\n                    (PsiSwitchStatement) statement;\n            return switchStatementAssignsVariable(switchStatement, variable,\n                                                  checkedMethods);\n        } else{\n            // unknown statement type\n            return false;\n        }\n    }","id":65374,"modified_method":"private boolean statementAssignsVariable(\n            @Nullable PsiStatement statement, @NotNull PsiVariable variable,\n            int stamp, @NotNull Set<MethodSignature> checkedMethods){\n        if(statement == null){\n            return false;\n        }\n        if(ExceptionUtils.statementThrowsException(statement)){\n            return true;\n        }\n        if(statement instanceof PsiBreakStatement ||\n                statement instanceof PsiContinueStatement ||\n                statement instanceof PsiAssertStatement ||\n                statement instanceof PsiEmptyStatement){\n            return false;\n        } else if(statement instanceof PsiReturnStatement){\n            final PsiReturnStatement returnStatement =\n                    (PsiReturnStatement) statement;\n            final PsiExpression returnValue = returnStatement.getReturnValue();\n            return expressionAssignsVariable(returnValue, variable,\n                    stamp, checkedMethods);\n        } else if(statement instanceof PsiThrowStatement){\n            final PsiThrowStatement throwStatement =\n                    (PsiThrowStatement) statement;\n            final PsiExpression exception = throwStatement.getException();\n            return expressionAssignsVariable(exception, variable,\n                    stamp, checkedMethods);\n        } else if(statement instanceof PsiExpressionListStatement){\n            final PsiExpressionListStatement list =\n                    (PsiExpressionListStatement) statement;\n            final PsiExpressionList expressionList = list.getExpressionList();\n            final PsiExpression[] expressions = expressionList.getExpressions();\n            for(final PsiExpression expression : expressions){\n                if(expressionAssignsVariable(expression, variable,\n                        stamp, checkedMethods)){\n                    return true;\n                }\n            }\n            return false;\n        } else if(statement instanceof PsiExpressionStatement){\n            final PsiExpressionStatement expressionStatement =\n                    (PsiExpressionStatement) statement;\n            final PsiExpression expression =\n                    expressionStatement.getExpression();\n            return expressionAssignsVariable(expression, variable,\n                    stamp, checkedMethods);\n        } else if (statement instanceof PsiDeclarationStatement){\n            final PsiDeclarationStatement declarationStatement =\n                    (PsiDeclarationStatement)statement;\n            return declarationStatementAssignsVariable(declarationStatement,\n                    variable, stamp, checkedMethods);\n        } else if (statement instanceof PsiForStatement){\n            final PsiForStatement forStatement = (PsiForStatement)statement;\n            return forStatementAssignsVariable(forStatement, variable,\n                    stamp, checkedMethods);\n        } else if(statement instanceof PsiForeachStatement){\n            final PsiForeachStatement foreachStatement =\n                    (PsiForeachStatement)statement;\n            return foreachStatementAssignsVariable(foreachStatement, variable);\n        } else if(statement instanceof PsiWhileStatement){\n            final PsiWhileStatement whileStatement =\n                    (PsiWhileStatement) statement;\n            return whileStatementAssignsVariable(whileStatement, variable,\n                    stamp, checkedMethods);\n        } else if(statement instanceof PsiDoWhileStatement) {\n            final PsiDoWhileStatement doWhileStatement =\n                    (PsiDoWhileStatement)statement;\n            return doWhileAssignsVariable(doWhileStatement, variable,\n                    stamp, checkedMethods);\n        } else if(statement instanceof PsiSynchronizedStatement){\n            final PsiSynchronizedStatement synchronizedStatement =\n                    (PsiSynchronizedStatement)statement;\n            final PsiCodeBlock body = synchronizedStatement.getBody();\n            return blockAssignsVariable(body, variable, stamp, checkedMethods);\n        } else if(statement instanceof PsiBlockStatement){\n            final PsiBlockStatement blockStatement =\n                    (PsiBlockStatement) statement;\n            final PsiCodeBlock codeBlock = blockStatement.getCodeBlock();\n            return blockAssignsVariable(codeBlock, variable, stamp,\n                    checkedMethods);\n        } else if (statement instanceof PsiLabeledStatement){\n            final PsiLabeledStatement labeledStatement =\n                    (PsiLabeledStatement) statement;\n            final PsiStatement statementLabeled =\n                    labeledStatement.getStatement();\n            return statementAssignsVariable(statementLabeled, variable,\n                    stamp, checkedMethods);\n        } else if(statement instanceof PsiIfStatement){\n            final PsiIfStatement ifStatement = (PsiIfStatement) statement;\n            return ifStatementAssignsVariable(ifStatement, variable,\n                    stamp, checkedMethods);\n        } else if(statement instanceof PsiTryStatement){\n            final PsiTryStatement tryStatement = (PsiTryStatement) statement;\n            return tryStatementAssignsVariable(tryStatement, variable,\n                    stamp, checkedMethods);\n        } else if(statement instanceof PsiSwitchStatement){\n            final PsiSwitchStatement switchStatement =\n                    (PsiSwitchStatement) statement;\n            return switchStatementAssignsVariable(switchStatement, variable,\n                    stamp, checkedMethods);\n        } else{\n            throw new RuntimeException(\"unknown statement: \" + statement);\n            // unknown statement type\n            //return false;\n        }\n    }","commit_id":"705266743e2516133555c09b5c6458a9940a86f0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean assignmentExpressonAssignsVariable(\n            @NotNull PsiAssignmentExpression assignment,\n            @NotNull PsiVariable variable,\n            @NotNull Set<MethodSignature> checkedMethods) {\n        final PsiExpression lhs = assignment.getLExpression();\n        if(expressionAssignsVariable(lhs, variable, checkedMethods)){\n            return true;\n        }\n        final PsiExpression rhs = assignment.getRExpression();\n        if(expressionAssignsVariable(rhs, variable, checkedMethods)){\n            return true;\n        }\n        if(lhs instanceof PsiReferenceExpression){\n            final PsiElement element = ((PsiReference) lhs).resolve();\n            if(element != null && element.equals(variable)){\n                return true;\n            }\n        }\n        return false;\n    }","id":65375,"modified_method":"private boolean assignmentExpressonAssignsVariable(\n            @NotNull PsiAssignmentExpression assignment,\n            @NotNull PsiVariable variable,\n            int stamp, @NotNull Set<MethodSignature> checkedMethods) {\n        final PsiExpression lhs = assignment.getLExpression();\n        if(expressionAssignsVariable(lhs, variable, stamp, checkedMethods)){\n            return true;\n        }\n        final PsiExpression rhs = assignment.getRExpression();\n        if(expressionAssignsVariable(rhs, variable, stamp, checkedMethods)){\n            return true;\n        }\n        if(lhs instanceof PsiReferenceExpression){\n            final PsiElement element = ((PsiReference) lhs).resolve();\n            if(element != null && element.equals(variable)){\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"705266743e2516133555c09b5c6458a9940a86f0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean tryStatementAssignsVariable(\n            @NotNull PsiTryStatement tryStatement,\n            @NotNull PsiVariable variable,\n            @NotNull Set<MethodSignature> checkedMethods){\n        final PsiCodeBlock tryBlock = tryStatement.getTryBlock();\n        boolean initializedInTryOrCatch =\n                blockAssignsVariable(tryBlock, variable, checkedMethods);\n        final PsiCodeBlock[] catchBlocks = tryStatement.getCatchBlocks();\n        for (final PsiCodeBlock catchBlock : catchBlocks){\n            initializedInTryOrCatch &=\n                    blockAssignsVariable(catchBlock, variable,\n                                         checkedMethods);\n        }\n        if (initializedInTryOrCatch) {\n            return true;\n        }\n        final PsiCodeBlock finallyBlock = tryStatement.getFinallyBlock();\n        return blockAssignsVariable(finallyBlock, variable,\n                                    checkedMethods);\n    }","id":65376,"modified_method":"private boolean tryStatementAssignsVariable(\n            @NotNull PsiTryStatement tryStatement,\n            @NotNull PsiVariable variable,\n            int stamp, @NotNull Set<MethodSignature> checkedMethods){\n        final PsiCodeBlock tryBlock = tryStatement.getTryBlock();\n        boolean initializedInTryOrCatch =\n                blockAssignsVariable(tryBlock, variable, stamp, checkedMethods);\n        final PsiCodeBlock[] catchBlocks = tryStatement.getCatchBlocks();\n        for (final PsiCodeBlock catchBlock : catchBlocks){\n            initializedInTryOrCatch &=\n                    blockAssignsVariable(catchBlock, variable,\n                            stamp, checkedMethods);\n        }\n        if (initializedInTryOrCatch) {\n            return true;\n        }\n        final PsiCodeBlock finallyBlock = tryStatement.getFinallyBlock();\n        return blockAssignsVariable(finallyBlock, variable,\n                stamp, checkedMethods);\n    }","commit_id":"705266743e2516133555c09b5c6458a9940a86f0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean whileStatementAssignsVariable(\n            @NotNull PsiWhileStatement whileStatement,\n            @NotNull PsiVariable variable,\n            @NotNull Set<MethodSignature> checkedMethods){\n        final PsiExpression condition = whileStatement.getCondition();\n        if(expressionAssignsVariable(condition, variable, checkedMethods)){\n            return true;\n        }\n        if(BoolUtils.isTrue(condition)){\n            final PsiStatement body = whileStatement.getBody();\n            if(statementAssignsVariable(body, variable, checkedMethods)){\n                return true;\n            }\n        }\n        return false;\n    }","id":65377,"modified_method":"private boolean whileStatementAssignsVariable(\n            @NotNull PsiWhileStatement whileStatement,\n            @NotNull PsiVariable variable,\n            int stamp, @NotNull Set<MethodSignature> checkedMethods){\n        final PsiExpression condition = whileStatement.getCondition();\n        if(expressionAssignsVariable(condition, variable, stamp, checkedMethods)){\n            return true;\n        }\n        if(BoolUtils.isTrue(condition)){\n            final PsiStatement body = whileStatement.getBody();\n            if(statementAssignsVariable(body, variable, stamp, checkedMethods)){\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"705266743e2516133555c09b5c6458a9940a86f0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean switchStatementAssignsVariable(\n            @NotNull PsiSwitchStatement switchStatement,\n            @NotNull PsiVariable variable,\n            @NotNull Set<MethodSignature> checkedMethods) {\n        final PsiExpression expression = switchStatement.getExpression();\n        if (expressionAssignsVariable(expression, variable, checkedMethods)) {\n            return true;\n        }\n        final PsiCodeBlock body = switchStatement.getBody();\n        if (body == null) {\n            return false;\n        }\n        final PsiStatement[] statements = body.getStatements();\n        boolean containsDefault = false;\n        boolean assigns = false;\n        for (int i = 0; i < statements.length; i++) {\n            final PsiStatement statement = statements[i];\n            if (statement instanceof PsiSwitchLabelStatement) {\n                final PsiSwitchLabelStatement labelStatement\n                        = (PsiSwitchLabelStatement) statement;\n                if (i == statements.length - 1) {\n                    return false;\n                }\n                if (labelStatement.isDefaultCase()) {\n                    containsDefault = true;\n                }\n                assigns = false;\n            } else if (statement instanceof PsiBreakStatement) {\n                final PsiBreakStatement breakStatement\n                        = (PsiBreakStatement) statement;\n                if (breakStatement.getLabelIdentifier() != null) {\n                    return false;\n                }\n                if (!assigns) {\n                    return false;\n                }\n                assigns = false;\n            } else {\n                assigns |= statementAssignsVariable(statement, variable,\n                                                    checkedMethods);\n                if (i == statements.length - 1 && !assigns) {\n                    return false;\n                }\n            }\n        }\n        return containsDefault;\n    }","id":65378,"modified_method":"private boolean switchStatementAssignsVariable(\n            @NotNull PsiSwitchStatement switchStatement,\n            @NotNull PsiVariable variable,\n            int stamp, @NotNull Set<MethodSignature> checkedMethods) {\n        final PsiExpression expression = switchStatement.getExpression();\n        if (expressionAssignsVariable(expression, variable, stamp,\n                checkedMethods)) {\n            return true;\n        }\n        final PsiCodeBlock body = switchStatement.getBody();\n        if (body == null) {\n            return false;\n        }\n        final PsiStatement[] statements = body.getStatements();\n        boolean containsDefault = false;\n        boolean assigns = false;\n        for (int i = 0; i < statements.length; i++) {\n            final PsiStatement statement = statements[i];\n            if (statement instanceof PsiSwitchLabelStatement) {\n                final PsiSwitchLabelStatement labelStatement\n                        = (PsiSwitchLabelStatement) statement;\n                if (i == statements.length - 1) {\n                    return false;\n                }\n                if (labelStatement.isDefaultCase()) {\n                    containsDefault = true;\n                }\n                assigns = false;\n            } else if (statement instanceof PsiBreakStatement) {\n                final PsiBreakStatement breakStatement\n                        = (PsiBreakStatement) statement;\n                if (breakStatement.getLabelIdentifier() != null) {\n                    return false;\n                }\n                if (!assigns) {\n                    return false;\n                }\n                assigns = false;\n            } else {\n                assigns |= statementAssignsVariable(statement, variable,\n                        stamp, checkedMethods);\n                if (i == statements.length - 1 && !assigns) {\n                    return false;\n                }\n            }\n        }\n        return containsDefault;\n    }","commit_id":"705266743e2516133555c09b5c6458a9940a86f0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean newExpressionAssignsVariable(\n            @NotNull PsiNewExpression newExpression,\n            @NotNull PsiVariable variable,\n            @NotNull Set<MethodSignature> checkedMethods){\n        final PsiExpressionList argumentList = newExpression.getArgumentList();\n        if(argumentList != null){\n            final PsiExpression[] args = argumentList.getExpressions();\n            for(final PsiExpression arg : args){\n                if(expressionAssignsVariable(arg, variable, checkedMethods)){\n                    return true;\n                }\n            }\n        }\n        final PsiArrayInitializerExpression arrayInitializer =\n                newExpression.getArrayInitializer();\n        if(expressionAssignsVariable(arrayInitializer, variable,\n                                     checkedMethods)){\n            return true;\n        }\n        final PsiExpression[] arrayDimensions =\n                newExpression.getArrayDimensions();\n        for(final PsiExpression dim : arrayDimensions){\n            if(expressionAssignsVariable(dim, variable, checkedMethods)){\n                return true;\n            }\n        }\n        return false;\n    }","id":65379,"modified_method":"private boolean newExpressionAssignsVariable(\n            @NotNull PsiNewExpression newExpression,\n            @NotNull PsiVariable variable,\n            int stamp, @NotNull Set<MethodSignature> checkedMethods){\n        final PsiExpressionList argumentList = newExpression.getArgumentList();\n        if(argumentList != null){\n            final PsiExpression[] args = argumentList.getExpressions();\n            for(final PsiExpression arg : args){\n                if(expressionAssignsVariable(arg, variable, stamp,\n                        checkedMethods)){\n                    return true;\n                }\n            }\n        }\n        final PsiArrayInitializerExpression arrayInitializer =\n                newExpression.getArrayInitializer();\n        if(expressionAssignsVariable(arrayInitializer, variable,\n                stamp, checkedMethods)){\n            return true;\n        }\n        final PsiExpression[] arrayDimensions =\n                newExpression.getArrayDimensions();\n        for(final PsiExpression dim : arrayDimensions){\n            if(expressionAssignsVariable(dim, variable, stamp, checkedMethods)){\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"705266743e2516133555c09b5c6458a9940a86f0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean blockAssignsVariable(\n            @Nullable PsiCodeBlock block, @NotNull PsiVariable variable,\n            @NotNull Set<MethodSignature> checkedMethods){\n        if(block == null){\n            return false;\n        }\n        final PsiStatement[] statements = block.getStatements();\n        for(final PsiStatement statement : statements){\n            if(statementAssignsVariable(statement, variable, checkedMethods)){\n                return true;\n            }\n        }\n        return false;\n    }","id":65380,"modified_method":"private boolean blockAssignsVariable(\n            @Nullable PsiCodeBlock block, @NotNull PsiVariable variable,\n            int stamp, @NotNull Set<MethodSignature> checkedMethods){\n        if(counter != stamp){\n            return true;\n        }\n        if(block == null){\n            return false;\n        }\n        final PsiStatement[] statements = block.getStatements();\n        for(final PsiStatement statement : statements){\n            if(statementAssignsVariable(statement, variable, stamp,\n                    checkedMethods)){\n                return true;\n            }\n            if(counter != stamp){\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"705266743e2516133555c09b5c6458a9940a86f0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean ifStatementAssignsVariable(\n            @NotNull PsiIfStatement ifStatement, @NotNull PsiVariable variable,\n            @NotNull Set<MethodSignature> checkedMethods){\n        final PsiExpression condition = ifStatement.getCondition();\n        if(expressionAssignsVariable(condition, variable, checkedMethods)){\n            return true;\n        }\n        final PsiStatement thenBranch = ifStatement.getThenBranch();\n        final PsiStatement elseBranch = ifStatement.getElseBranch();\n        return statementAssignsVariable(thenBranch, variable, checkedMethods) &&\n                statementAssignsVariable(elseBranch, variable, checkedMethods);\n    }","id":65381,"modified_method":"private boolean ifStatementAssignsVariable(\n            @NotNull PsiIfStatement ifStatement, @NotNull PsiVariable variable,\n            int stamp, @NotNull Set<MethodSignature> checkedMethods){\n        final PsiExpression condition = ifStatement.getCondition();\n        if(expressionAssignsVariable(condition, variable, stamp, checkedMethods)){\n            return true;\n        }\n        final PsiStatement thenBranch = ifStatement.getThenBranch();\n        final PsiStatement elseBranch = ifStatement.getElseBranch();\n        return statementAssignsVariable(thenBranch, variable, stamp,\n                checkedMethods) &&\n                statementAssignsVariable(elseBranch, variable, stamp,\n                        checkedMethods);\n    }","commit_id":"705266743e2516133555c09b5c6458a9940a86f0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean referenceExpressionAssignsVariable(\n            @NotNull PsiReferenceExpression referenceExpression,\n            @NotNull PsiVariable variable,\n            @NotNull Set<MethodSignature> checkedMethods) {\n        final PsiExpression qualifierExpression =\n                referenceExpression.getQualifierExpression();\n        if(variable.equals(referenceExpression.resolve())){\n            final PsiElement parent = referenceExpression.getParent();\n            if(parent instanceof PsiAssignmentExpression){\n                final PsiAssignmentExpression assignmentExpression =\n                        (PsiAssignmentExpression)parent;\n                final PsiExpression rhs =\n                        assignmentExpression.getRExpression();\n                if (rhs != null && rhs.equals(referenceExpression)) {\n                    if (!referenceExpression.isQualified() ||\n                            qualifierExpression instanceof PsiThisExpression) {\n                        uninitializedReads.add(referenceExpression);\n                    }\n                }\n            } else if (!referenceExpression.isQualified() ||\n                    qualifierExpression instanceof PsiThisExpression) {\n                uninitializedReads.add(referenceExpression);\n            }\n        }\n        if(referenceExpression.isQualified()){\n            return expressionAssignsVariable(qualifierExpression, variable,\n                    checkedMethods);\n        } else{\n            return false;\n        }\n    }","id":65382,"modified_method":"private boolean referenceExpressionAssignsVariable(\n            @NotNull PsiReferenceExpression referenceExpression,\n            @NotNull PsiVariable variable,\n            int stamp, @NotNull Set<MethodSignature> checkedMethods) {\n        final PsiExpression qualifierExpression =\n                referenceExpression.getQualifierExpression();\n        if(variable.equals(referenceExpression.resolve())){\n            final PsiElement parent = referenceExpression.getParent();\n            if(parent instanceof PsiAssignmentExpression){\n                final PsiAssignmentExpression assignmentExpression =\n                        (PsiAssignmentExpression)parent;\n                final PsiExpression rhs =\n                        assignmentExpression.getRExpression();\n                if (rhs != null && rhs.equals(referenceExpression)) {\n                    checkReferenceExpression(referenceExpression, variable,\n                            qualifierExpression);\n                }\n            } else {\n                checkReferenceExpression(referenceExpression, variable,\n                        qualifierExpression);\n            }\n        }\n        return referenceExpression.isQualified() &&\n                expressionAssignsVariable(qualifierExpression, variable,\n                        stamp, checkedMethods);\n    }","commit_id":"705266743e2516133555c09b5c6458a9940a86f0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean declarationStatementAssignsVariable(\n            @NotNull PsiDeclarationStatement declarationStatement,\n            @NotNull PsiVariable variable,\n            @NotNull Set<MethodSignature> checkedMethods){\n        final PsiElement[] elements =\n                declarationStatement.getDeclaredElements();\n        for(PsiElement element : elements){\n            if(element instanceof PsiVariable){\n                final PsiVariable variableElement = (PsiVariable) element;\n                final PsiExpression initializer =\n                        variableElement.getInitializer();\n                if(expressionAssignsVariable(initializer, variable,\n                                             checkedMethods)){\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","id":65383,"modified_method":"private boolean declarationStatementAssignsVariable(\n            @NotNull PsiDeclarationStatement declarationStatement,\n            @NotNull PsiVariable variable,\n            int stamp, @NotNull Set<MethodSignature> checkedMethods){\n        final PsiElement[] elements =\n                declarationStatement.getDeclaredElements();\n        for(PsiElement element : elements){\n            if(element instanceof PsiVariable){\n                final PsiVariable variableElement = (PsiVariable) element;\n                final PsiExpression initializer =\n                        variableElement.getInitializer();\n                if(expressionAssignsVariable(initializer, variable,\n                        stamp, checkedMethods)){\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","commit_id":"705266743e2516133555c09b5c6458a9940a86f0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean expressionAssignsVariable(\n            @Nullable PsiExpression expression, @NotNull PsiVariable variable,\n            @NotNull Set<MethodSignature> checkedMethods){\n        if(expression == null){\n            return false;\n        }\n        if(expression instanceof PsiThisExpression ||\n                expression instanceof PsiLiteralExpression ||\n                expression instanceof PsiSuperExpression ||\n                expression instanceof PsiClassObjectAccessExpression){\n            return false;\n        } else if(expression instanceof PsiReferenceExpression){\n            final PsiReferenceExpression referenceExpression =\n                    (PsiReferenceExpression) expression;\n            return referenceExpressionAssignsVariable(referenceExpression,\n                                                      variable,\n                                                      checkedMethods);\n        } else if(expression instanceof PsiMethodCallExpression){\n            final PsiMethodCallExpression callExpression =\n                    (PsiMethodCallExpression)expression;\n            return methodCallAssignsVariable(callExpression, variable,\n                                             checkedMethods);\n        } else if(expression instanceof PsiNewExpression){\n            final PsiNewExpression newExpression = (PsiNewExpression)expression;\n            return newExpressionAssignsVariable(newExpression, variable,\n                                                checkedMethods);\n        } else if(expression instanceof PsiArrayInitializerExpression){\n            final PsiArrayInitializerExpression array =\n                    (PsiArrayInitializerExpression) expression;\n            final PsiExpression[] initializers = array.getInitializers();\n            for(final PsiExpression initializer : initializers){\n                if(expressionAssignsVariable(initializer, variable,\n                                             checkedMethods)){\n                    return true;\n                }\n            }\n            return false;\n        } else if(expression instanceof PsiTypeCastExpression){\n            final PsiTypeCastExpression typeCast =\n                    (PsiTypeCastExpression) expression;\n            final PsiExpression operand = typeCast.getOperand();\n            return expressionAssignsVariable(operand, variable, checkedMethods);\n        } else if(expression instanceof PsiArrayAccessExpression){\n            final PsiArrayAccessExpression accessExpression =\n                    (PsiArrayAccessExpression) expression;\n            final PsiExpression arrayExpression =\n                    accessExpression.getArrayExpression();\n            final PsiExpression indexExpression =\n                    accessExpression.getIndexExpression();\n            return expressionAssignsVariable(arrayExpression, variable,\n                                             checkedMethods) ||\n                    expressionAssignsVariable(indexExpression, variable,\n                            checkedMethods);\n        } else if(expression instanceof PsiPrefixExpression){\n            final PsiPrefixExpression prefixExpression =\n                    (PsiPrefixExpression) expression;\n            final PsiExpression operand = prefixExpression.getOperand();\n            return expressionAssignsVariable(operand, variable, checkedMethods);\n        } else if(expression instanceof PsiPostfixExpression){\n            final PsiPostfixExpression postfixExpression =\n                    (PsiPostfixExpression) expression;\n            final PsiExpression operand = postfixExpression.getOperand();\n            return expressionAssignsVariable(operand, variable, checkedMethods);\n        } else if(expression instanceof PsiBinaryExpression){\n            final PsiBinaryExpression binaryExpression =\n                    (PsiBinaryExpression) expression;\n            final PsiExpression lhs = binaryExpression.getLOperand();\n            final PsiExpression rhs = binaryExpression.getROperand();\n            return expressionAssignsVariable(lhs, variable, checkedMethods) ||\n                    expressionAssignsVariable(rhs, variable, checkedMethods);\n        } else if(expression instanceof PsiConditionalExpression){\n            final PsiConditionalExpression conditional =\n                    (PsiConditionalExpression) expression;\n            final PsiExpression condition = conditional.getCondition();\n            if(expressionAssignsVariable(condition, variable, checkedMethods)){\n                return true;\n            }\n            final PsiExpression thenExpression =\n                    conditional.getThenExpression();\n            final PsiExpression elseExpression =\n                    conditional.getElseExpression();\n            return expressionAssignsVariable(thenExpression, variable,\n                                             checkedMethods)\n                    && expressionAssignsVariable(elseExpression, variable,\n                                                 checkedMethods);\n        } else if(expression instanceof PsiAssignmentExpression){\n            final PsiAssignmentExpression assignment =\n                    (PsiAssignmentExpression) expression;\n            return assignmentExpressonAssignsVariable(assignment, variable,\n                                                      checkedMethods);\n        } else{\n            return false;\n        }\n    }","id":65384,"modified_method":"private boolean expressionAssignsVariable(\n            @Nullable PsiExpression expression, @NotNull PsiVariable variable,\n            int stamp, @NotNull Set<MethodSignature> checkedMethods){\n        if (counter != stamp) {\n            return true;\n        }\n        if(expression == null){\n            return false;\n        }\n        if(expression instanceof PsiThisExpression ||\n                expression instanceof PsiLiteralExpression ||\n                expression instanceof PsiSuperExpression ||\n                expression instanceof PsiClassObjectAccessExpression){\n            return false;\n        } else if(expression instanceof PsiReferenceExpression){\n            final PsiReferenceExpression referenceExpression =\n                    (PsiReferenceExpression) expression;\n            return referenceExpressionAssignsVariable(referenceExpression,\n                                                      variable,\n                    stamp, checkedMethods);\n        } else if(expression instanceof PsiMethodCallExpression){\n            final PsiMethodCallExpression callExpression =\n                    (PsiMethodCallExpression)expression;\n            return methodCallAssignsVariable(callExpression, variable,\n                    stamp, checkedMethods);\n        } else if(expression instanceof PsiNewExpression){\n            final PsiNewExpression newExpression = (PsiNewExpression)expression;\n            return newExpressionAssignsVariable(newExpression, variable,\n                    stamp, checkedMethods);\n        } else if(expression instanceof PsiArrayInitializerExpression){\n            final PsiArrayInitializerExpression array =\n                    (PsiArrayInitializerExpression) expression;\n            final PsiExpression[] initializers = array.getInitializers();\n            for(final PsiExpression initializer : initializers){\n                if(expressionAssignsVariable(initializer, variable,\n                        stamp, checkedMethods)){\n                    return true;\n                }\n            }\n            return false;\n        } else if(expression instanceof PsiTypeCastExpression){\n            final PsiTypeCastExpression typeCast =\n                    (PsiTypeCastExpression) expression;\n            final PsiExpression operand = typeCast.getOperand();\n            return expressionAssignsVariable(operand, variable, stamp,\n                    checkedMethods);\n        } else if(expression instanceof PsiArrayAccessExpression){\n            final PsiArrayAccessExpression accessExpression =\n                    (PsiArrayAccessExpression) expression;\n            final PsiExpression arrayExpression =\n                    accessExpression.getArrayExpression();\n            final PsiExpression indexExpression =\n                    accessExpression.getIndexExpression();\n            return expressionAssignsVariable(arrayExpression, variable,\n                    stamp, checkedMethods) ||\n                    expressionAssignsVariable(indexExpression, variable,\n                            stamp, checkedMethods);\n        } else if(expression instanceof PsiPrefixExpression){\n            final PsiPrefixExpression prefixExpression =\n                    (PsiPrefixExpression) expression;\n            final PsiExpression operand = prefixExpression.getOperand();\n            return expressionAssignsVariable(operand, variable, stamp,\n                    checkedMethods);\n        } else if(expression instanceof PsiPostfixExpression){\n            final PsiPostfixExpression postfixExpression =\n                    (PsiPostfixExpression) expression;\n            final PsiExpression operand = postfixExpression.getOperand();\n            return expressionAssignsVariable(operand, variable, stamp,\n                    checkedMethods);\n        } else if(expression instanceof PsiBinaryExpression){\n            final PsiBinaryExpression binaryExpression =\n                    (PsiBinaryExpression) expression;\n            final PsiExpression lhs = binaryExpression.getLOperand();\n            final PsiExpression rhs = binaryExpression.getROperand();\n            return expressionAssignsVariable(lhs, variable, stamp,\n                    checkedMethods) ||\n                    expressionAssignsVariable(rhs, variable, stamp,\n                            checkedMethods);\n        } else if(expression instanceof PsiConditionalExpression){\n            final PsiConditionalExpression conditional =\n                    (PsiConditionalExpression) expression;\n            final PsiExpression condition = conditional.getCondition();\n            if(expressionAssignsVariable(condition, variable, stamp,\n                    checkedMethods)){\n                return true;\n            }\n            final PsiExpression thenExpression =\n                    conditional.getThenExpression();\n            final PsiExpression elseExpression =\n                    conditional.getElseExpression();\n            return expressionAssignsVariable(thenExpression, variable,\n                    stamp, checkedMethods)\n                    && expressionAssignsVariable(elseExpression, variable,\n                    stamp, checkedMethods);\n        } else if(expression instanceof PsiAssignmentExpression){\n            final PsiAssignmentExpression assignment =\n                    (PsiAssignmentExpression) expression;\n            return assignmentExpressonAssignsVariable(assignment, variable,\n                    stamp, checkedMethods);\n        } else{\n            return false;\n        }\n    }","commit_id":"705266743e2516133555c09b5c6458a9940a86f0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean methodCallAssignsVariable(\n            @NotNull PsiMethodCallExpression callExpression,\n            @NotNull PsiVariable variable,\n            @NotNull Set<MethodSignature> checkedMethods){\n        final PsiExpressionList argumentList = callExpression.getArgumentList();\n        final PsiExpression[] arguments = argumentList.getExpressions();\n        for(final PsiExpression argument : arguments){\n            if(expressionAssignsVariable(argument, variable,\n                    checkedMethods)){\n                return true;\n            }\n        }\n        final PsiReferenceExpression methodExpression =\n                callExpression.getMethodExpression();\n        if(expressionAssignsVariable(methodExpression, variable,\n                                     checkedMethods)) {\n            return true;\n        }\n        final PsiMethod method = callExpression.resolveMethod();\n        if(method == null){\n            return false;\n        }\n        final MethodSignature methodSignature =\n                method.getSignature(PsiSubstitutor.EMPTY);\n        if(!checkedMethods.add(methodSignature)){\n            return false;\n        }\n        final PsiClass containingClass =\n                ClassUtils.getContainingClass(callExpression);\n        final PsiClass calledClass = method.getContainingClass();\n\n        // Can remark out this block to continue chase outside of of\n        // current class\n        if(!calledClass.equals(containingClass)){\n            return false;\n        }\n\n        if(method.hasModifierProperty(PsiModifier.STATIC)\n                || method.isConstructor()\n                || method.hasModifierProperty(PsiModifier.PRIVATE)\n                || method.hasModifierProperty(PsiModifier.FINAL)\n                || calledClass.hasModifierProperty(PsiModifier.FINAL)){\n            final PsiCodeBlock body = method.getBody();\n            return blockAssignsVariable(body, variable, checkedMethods);\n        }\n        return false;\n    }","id":65385,"modified_method":"private boolean methodCallAssignsVariable(\n            @NotNull PsiMethodCallExpression callExpression,\n            @NotNull PsiVariable variable,\n            int stamp, @NotNull Set<MethodSignature> checkedMethods){\n        final PsiExpressionList argumentList = callExpression.getArgumentList();\n        final PsiExpression[] arguments = argumentList.getExpressions();\n        for(final PsiExpression argument : arguments){\n            if(expressionAssignsVariable(argument, variable,\n                    stamp, checkedMethods)){\n                return true;\n            }\n        }\n        final PsiReferenceExpression methodExpression =\n                callExpression.getMethodExpression();\n        if(expressionAssignsVariable(methodExpression, variable,\n                stamp, checkedMethods)) {\n            return true;\n        }\n        final PsiMethod method = callExpression.resolveMethod();\n        if(method == null){\n            return false;\n        }\n        final MethodSignature methodSignature =\n                method.getSignature(PsiSubstitutor.EMPTY);\n        if(!checkedMethods.add(methodSignature)){\n            return false;\n        }\n        final PsiClass containingClass =\n                ClassUtils.getContainingClass(callExpression);\n        final PsiClass calledClass = method.getContainingClass();\n\n        // Can remark out this block to continue chase outside of of\n        // current class\n        if(!calledClass.equals(containingClass)){\n            return false;\n        }\n\n        if(method.hasModifierProperty(PsiModifier.STATIC)\n                || method.isConstructor()\n                || method.hasModifierProperty(PsiModifier.PRIVATE)\n                || method.hasModifierProperty(PsiModifier.FINAL)\n                || calledClass.hasModifierProperty(PsiModifier.FINAL)){\n            final PsiCodeBlock body = method.getBody();\n            return blockAssignsVariable(body, variable, stamp, checkedMethods);\n        }\n        return false;\n    }","commit_id":"705266743e2516133555c09b5c6458a9940a86f0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * For each reference in the collection, finds a definition of name visible from the point of the reference. Returns a list of\n   * such definitions.\n   * @param name what to look for.\n   * @param references references to check.\n   * @param ignored if an element defining the name is also listed here, ignore it.\n   * @return a list of pairs (referring element, element that defines name).\n   */\n  @NotNull\n  public static List<Pair<PsiElement, PsiElement>> findDefinitions(@NotNull String name,\n                                                                   @NotNull Collection<PsiReference> references,\n                                                                   @NotNull Set<PsiElement> ignored) {\n    List<Pair<PsiElement, PsiElement>> conflicts = new ArrayList<Pair<PsiElement, PsiElement>>();\n    for (PsiReference ref : references) {\n      final PsiElement refElement = ref.getElement();\n      final ScopeOwner owner = ScopeUtil.getScopeOwner(refElement);\n      final PyResolveProcessor processor = new PyResolveProcessor(name, true);\n      if (owner != null) {\n        PyResolveUtil.scopeCrawlUp(processor, owner, name, null);\n        for (PsiElement element : processor.getElements()) {\n          if (!ignored.contains(element)) {\n            conflicts.add(Pair.create(refElement, element));\n          }\n        }\n      }\n    }\n    return conflicts;\n  }","id":65386,"modified_method":"/**\n   * For each reference in the collection, finds a definition of name visible from the point of the reference. Returns a list of\n   * such definitions.\n   * @param name what to look for.\n   * @param references references to check.\n   * @param ignored if an element defining the name is also listed here, ignore it.\n   * @return a list of pairs (referring element, element that defines name).\n   */\n  @NotNull\n  public static List<Pair<PsiElement, PsiElement>> findDefinitions(@NotNull String name,\n                                                                   @NotNull Collection<PsiReference> references,\n                                                                   @NotNull Set<PsiElement> ignored) {\n    final List<Pair<PsiElement, PsiElement>> conflicts = new ArrayList<Pair<PsiElement, PsiElement>>();\n    for (PsiReference ref : references) {\n      final PsiElement refElement = ref.getElement();\n      final ScopeOwner owner = ScopeUtil.getScopeOwner(refElement);\n      if (owner != null) {\n        for (PsiElement element : PyResolveUtil.resolveLocally(owner, name)) {\n          if (!ignored.contains(element)) {\n            conflicts.add(Pair.create(refElement, element));\n          }\n        }\n      }\n    }\n    return conflicts;\n  }","commit_id":"8dbf66d862f311b1962e22ce1217ce59a127372f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PyCallExpression findPropertyCallSite(@Nullable PyExpression source) {\n    if (source instanceof PyCallExpression) {\n      final PyCallExpression call = (PyCallExpression)source;\n      PyExpression callee = call.getCallee();\n      if (callee instanceof PyReferenceExpression) {\n        PyReferenceExpression ref = (PyReferenceExpression)callee;\n        if (ref.isQualified()) return null;\n        if (PyNames.PROPERTY.equals(callee.getName())) {\n          PsiFile file = source.getContainingFile();\n          if (isBuiltinFile(file) || !resolvesLocally(ref)) {\n            // we assume that a non-local name 'property' is a built-in name.\n            // ref.resolve() is not used because we run in stub building phase where resolve() is frowned upon.\n            // NOTE: this logic fails if (quite unusually) name 'property' is directly imported from builtins.\n            return call;\n          }\n        }\n      }\n    }\n    return null;\n  }","id":65387,"modified_method":"@Nullable\n  public static PyCallExpression findPropertyCallSite(@Nullable PyExpression source) {\n    if (source instanceof PyCallExpression) {\n      final PyCallExpression call = (PyCallExpression)source;\n      final PyExpression callee = call.getCallee();\n      if (callee instanceof PyReferenceExpression) {\n        final PyReferenceExpression ref = (PyReferenceExpression)callee;\n\n        if (!ref.isQualified() &&\n            PyNames.PROPERTY.equals(callee.getName()) &&\n            (isBuiltinFile(source.getContainingFile()) || PyResolveUtil.resolveLocally(ref).stream().allMatch(Objects::isNull))) {\n          // we assume that a non-local name 'property' is a built-in name.\n          // ref.resolve() is not used because we run in stub building phase where resolve() is frowned upon.\n          // NOTE: this logic fails if (quite unusually) name 'property' is directly imported from builtins.\n          return call;\n        }\n      }\n    }\n    return null;\n  }","commit_id":"8dbf66d862f311b1962e22ce1217ce59a127372f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static QualifiedName resolveOriginalSuperClassQName(@NotNull PyExpression superClassExpression) {\n    if (superClassExpression instanceof PyReferenceExpression) {\n      final PyReferenceExpression reference = (PyReferenceExpression)superClassExpression;\n      final String referenceName = reference.getName();\n\n      if (referenceName == null) {\n        return PyPsiUtils.asQualifiedName(superClassExpression);\n      }\n\n      final PyResolveProcessor processor = new PyResolveProcessor(referenceName, true);\n      PyResolveUtil.scopeCrawlUp(processor, reference, referenceName, null);\n\n      final Optional<QualifiedName> qualifiedName = processor.getElements().stream()\n        .filter(PyImportElement.class::isInstance)\n        .map(PyImportElement.class::cast)\n        .filter(element -> element.getAsName() != null)\n        .map(PyImportElement::getImportedQName)\n        .findAny();\n\n      if (qualifiedName.isPresent()) {\n        return qualifiedName.get();\n      }\n    }\n\n    return PyPsiUtils.asQualifiedName(superClassExpression);\n  }","id":65388,"modified_method":"@Nullable\n  private static QualifiedName resolveOriginalSuperClassQName(@NotNull PyExpression superClassExpression) {\n    if (superClassExpression instanceof PyReferenceExpression) {\n      final PyReferenceExpression reference = (PyReferenceExpression)superClassExpression;\n      final String referenceName = reference.getName();\n\n      if (referenceName == null) {\n        return PyPsiUtils.asQualifiedName(superClassExpression);\n      }\n\n      final Optional<QualifiedName> qualifiedName = PyResolveUtil.resolveLocally(reference)\n        .stream()\n        .filter(PyImportElement.class::isInstance)\n        .map(PyImportElement.class::cast)\n        .filter(element -> element.getAsName() != null)\n        .map(PyImportElement::getImportedQName)\n        .findAny();\n\n      if (qualifiedName.isPresent()) {\n        return qualifiedName.get();\n      }\n    }\n\n    return PyPsiUtils.asQualifiedName(superClassExpression);\n  }","commit_id":"8dbf66d862f311b1962e22ce1217ce59a127372f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PyExpression fullResolveLocally(@NotNull PyReferenceExpression referenceExpression) {\n    for (PsiElement element : resolveLocally(referenceExpression)) {\n      if (element instanceof PyTargetExpression) {\n        final PyExpression assignedValue = ((PyTargetExpression)element).findAssignedValue();\n\n        if (assignedValue instanceof PyReferenceExpression) {\n          return fullResolveLocally((PyReferenceExpression)assignedValue);\n        }\n\n        return assignedValue;\n      }\n    }\n\n    return null;\n  }","id":65389,"modified_method":"@Nullable\n  private static PyExpression fullResolveLocally(@NotNull PyReferenceExpression referenceExpression) {\n    for (PsiElement element : PyResolveUtil.resolveLocally(referenceExpression)) {\n      if (element instanceof PyTargetExpression) {\n        final PyExpression assignedValue = ((PyTargetExpression)element).findAssignedValue();\n\n        if (assignedValue instanceof PyReferenceExpression) {\n          return fullResolveLocally((PyReferenceExpression)assignedValue);\n        }\n\n        return assignedValue;\n      }\n    }\n\n    return null;\n  }","commit_id":"8dbf66d862f311b1962e22ce1217ce59a127372f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean resolvesToCollections(@NotNull PyReferenceExpression referenceExpression) {\n    for (PsiElement element : resolveLocally(referenceExpression)) {\n      if (element instanceof PyImportElement) {\n        final PyImportElement importElement = (PyImportElement)element;\n\n        if (equals(importElement.getImportedQName(), PyNames.COLLECTIONS)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }","id":65390,"modified_method":"private static boolean resolvesToCollections(@NotNull PyReferenceExpression referenceExpression) {\n    for (PsiElement element : PyResolveUtil.resolveLocally(referenceExpression)) {\n      if (element instanceof PyImportElement) {\n        final PyImportElement importElement = (PyImportElement)element;\n\n        if (equals(importElement.getImportedQName(), PyNames.COLLECTIONS)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }","commit_id":"8dbf66d862f311b1962e22ce1217ce59a127372f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static QualifiedName getImportedNamedTupleQName(@NotNull PyReferenceExpression referenceExpression) {\n    // SUPPORTED CASES:\n\n    // from collections import namedtuple\n    // Point = namedtuple(...)\n\n    // from collections import namedtuple as NT\n    // Point = NT(...)\n\n    for (PsiElement element : resolveLocally(referenceExpression)) {\n      if (element instanceof PyImportElement) {\n        final PyImportElement importElement = (PyImportElement)element;\n\n        if (equals(importElement.getImportedQName(), PyNames.NAMEDTUPLE)) {\n          final PyStatement importStatement = importElement.getContainingImportStatement();\n\n          if (importStatement instanceof PyFromImportStatement) {\n            final PyFromImportStatement fromImportStatement = (PyFromImportStatement)importStatement;\n\n            if (equals(fromImportStatement.getImportSourceQName(), PyNames.COLLECTIONS)) {\n              return QualifiedName.fromComponents(referenceExpression.getName());\n            }\n          }\n        }\n      }\n    }\n\n    return null;\n  }","id":65391,"modified_method":"@Nullable\n  private static QualifiedName getImportedNamedTupleQName(@NotNull PyReferenceExpression referenceExpression) {\n    // SUPPORTED CASES:\n\n    // from collections import namedtuple\n    // Point = namedtuple(...)\n\n    // from collections import namedtuple as NT\n    // Point = NT(...)\n\n    for (PsiElement element : PyResolveUtil.resolveLocally(referenceExpression)) {\n      if (element instanceof PyImportElement) {\n        final PyImportElement importElement = (PyImportElement)element;\n\n        if (equals(importElement.getImportedQName(), PyNames.NAMEDTUPLE)) {\n          final PyStatement importStatement = importElement.getContainingImportStatement();\n\n          if (importStatement instanceof PyFromImportStatement) {\n            final PyFromImportStatement fromImportStatement = (PyFromImportStatement)importStatement;\n\n            if (equals(fromImportStatement.getImportSourceQName(), PyNames.COLLECTIONS)) {\n              return QualifiedName.fromComponents(referenceExpression.getName());\n            }\n          }\n        }\n      }\n    }\n\n    return null;\n  }","commit_id":"8dbf66d862f311b1962e22ce1217ce59a127372f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Generates companion fields ($Foo$impl) and methods\n     */\n    private void concreteMembersFromSuperinterfaces(final Class model,\n            ClassDefinitionBuilder classBuilder, \n            ProducedType satisfiedType, Set<Interface> satisfiedInterfaces) {\n        Interface iface = (Interface)satisfiedType.getDeclaration();\n        if (satisfiedInterfaces.contains(iface)) {\n            return;\n        }\n        boolean goRaw = false;\n        Map<TypeDeclaration, java.util.List<ProducedType>> m = new HashMap<TypeDeclaration, java.util.List<ProducedType>>();\n        for (ProducedType t : model.getType().getSupertypes()) {\n            TypeDeclaration declaration = t.getDeclaration();\n            java.util.List<ProducedType> typeArguments = t.getTypeArgumentList();\n            java.util.List<ProducedType> existingTypeArgs = m.put(declaration, typeArguments);\n            if (existingTypeArgs != null) {\n                goRaw = true;\n                break;\n            }\n        }   \n        // If there is no $impl (e.g. implementing a Java interface) \n        // then don't instantiate it...\n        if (hasImpl(iface)) {\n            // ... otherwise for each satisfied interface, \n            // instantiate an instance of the \n            // companion class in the constructor and assign it to a\n            // $Interface$impl field\n            transformInstantiateCompanions(classBuilder,\n                    iface, satisfiedType, goRaw);\n        }\n        \n        // For each super interface\n        for (Declaration member : iface.getMembers()) {\n            if (member instanceof Method) {\n                Method method = (Method)member;\n                final java.util.List<TypeParameter> typeParameters = method.getTypeParameters();\n                final java.util.List<Parameter> parameters = method.getParameterLists().get(0).getParameters();\n                if (!satisfiedInterfaces.contains((Interface)method.getContainer())) {\n                    \n                    for (Parameter param : parameters) {\n                        if (param.isDefaulted()) {\n                            // If that method has a defaulted parameter, \n                            // we need to generate a default value method\n                            // which also delegates to the $impl\n                            final JCMethodDecl defaultValueDelegate = makeDelegateToCompanion(iface, \n                                    PUBLIC | FINAL, typeParameters, param, param.getType(), \n                                    CodegenUtil.getDefaultedParamMethodName(method, param), parameters.subList(0, parameters.indexOf(param)),\n                                    Decl.isAncestorLocal(model));\n                            classBuilder.defs(defaultValueDelegate);\n                            // If that method has a defaulted parameter, \n                            // we need to generate a overload method\n                            // which also delegates to the $impl\n                            MethodDefinitionBuilder overloadBuilder = MethodDefinitionBuilder.method(\n                                    gen(), Decl.isAncestorLocal(model), true, method.getName());\n                            final MethodDefinitionBuilder overload = makeOverloadsForDefaultedParameter(true, true,  \n                                    overloadBuilder, method, parameters, param);\n                            classBuilder.defs(overload.build());\n                        }\n                    }\n                }\n                // if it has the *most refined* default concrete member, \n                // then generate a method on the class\n                // delegating to the $impl instance\n                if (needsCompanionDelegate(model, member)) {\n                    final JCMethodDecl concreteMemberDelegate = makeDelegateToCompanion(iface,\n                            PUBLIC, method.getTypeParameters(), \n                            method,\n                            method.getType(), method.getName(), method.getParameterLists().get(0).getParameters(),\n                            Decl.isAncestorLocal(model));\n                    classBuilder.defs(concreteMemberDelegate);\n                     \n                }\n            } else if (member instanceof Getter) {// Concrete getter\n                Getter getter = (Getter)member;\n                if (needsCompanionDelegate(model, member)) {\n                    final JCMethodDecl getterDelegate = makeDelegateToCompanion(iface, \n                            PUBLIC | (getter.isDefault() ? 0 : FINAL), \n                            Collections.<TypeParameter>emptyList(), \n                            getter, \n                            getter.getType(), \n                            CodegenUtil.getGetterName(member), \n                            Collections.<Parameter>emptyList(),\n                            Decl.isAncestorLocal(model));\n                    classBuilder.defs(getterDelegate);\n                }\n            } else if (needsCompanionDelegate(model, member)) {\n                log.error(\"ceylon\", \"Unhandled concrete interface member \" + member.getName());\n            }\n        }\n        \n        // Add $impl instances for the whole interface hierarchy\n        satisfiedInterfaces.add(iface);\n        for (ProducedType sat : iface.getSatisfiedTypes()) {\n            concreteMembersFromSuperinterfaces(model, classBuilder, sat, satisfiedInterfaces);\n        }\n        \n    }","id":65392,"modified_method":"/**\n     * Generates companion fields ($Foo$impl) and methods\n     */\n    private void concreteMembersFromSuperinterfaces(final Class model,\n            ClassDefinitionBuilder classBuilder, \n            ProducedType satisfiedType, Set<Interface> satisfiedInterfaces) {\n        Interface iface = (Interface)satisfiedType.getDeclaration();\n        if (satisfiedInterfaces.contains(iface)) {\n            return;\n        }\n        boolean goRaw = false;\n        Map<TypeDeclaration, java.util.List<ProducedType>> m = new HashMap<TypeDeclaration, java.util.List<ProducedType>>();\n        for (ProducedType t : model.getType().getSupertypes()) {\n            TypeDeclaration declaration = t.getDeclaration();\n            java.util.List<ProducedType> typeArguments = t.getTypeArgumentList();\n            java.util.List<ProducedType> existingTypeArgs = m.put(declaration, typeArguments);\n            if (existingTypeArgs != null) {\n                goRaw = true;\n                break;\n            }\n        }   \n        // If there is no $impl (e.g. implementing a Java interface) \n        // then don't instantiate it...\n        if (hasImpl(iface)) {\n            // ... otherwise for each satisfied interface, \n            // instantiate an instance of the \n            // companion class in the constructor and assign it to a\n            // $Interface$impl field\n            transformInstantiateCompanions(classBuilder,\n                    iface, satisfiedType, goRaw);\n        }\n        \n        // For each super interface\n        for (Declaration member : iface.getMembers()) {\n            if (member instanceof Method) {\n                Method method = (Method)member;\n                final java.util.List<TypeParameter> typeParameters = method.getTypeParameters();\n                final java.util.List<Parameter> parameters = method.getParameterLists().get(0).getParameters();\n                if (!satisfiedInterfaces.contains((Interface)method.getContainer())) {\n                    \n                    for (Parameter param : parameters) {\n                        if (param.isDefaulted()\n                                || param.isSequenced()) {\n                            // If that method has a defaulted parameter, \n                            // we need to generate a default value method\n                            // which also delegates to the $impl\n                            final JCMethodDecl defaultValueDelegate = makeDelegateToCompanion(iface, \n                                    PUBLIC | FINAL, typeParameters, param, param.getType(), \n                                    CodegenUtil.getDefaultedParamMethodName(method, param), parameters.subList(0, parameters.indexOf(param)),\n                                    Decl.isAncestorLocal(model));\n                            classBuilder.defs(defaultValueDelegate);\n                            // If that method has a defaulted parameter, \n                            // we need to generate a overload method\n                            // which also delegates to the $impl\n                            MethodDefinitionBuilder overloadBuilder = MethodDefinitionBuilder.method(\n                                    gen(), Decl.isAncestorLocal(model), true, method.getName());\n                            final MethodDefinitionBuilder overload = makeOverloadsForDefaultedParameter(true, true,  \n                                    overloadBuilder, method, parameters, param);\n                            classBuilder.defs(overload.build());\n                        }\n                    }\n                }\n                // if it has the *most refined* default concrete member, \n                // then generate a method on the class\n                // delegating to the $impl instance\n                if (needsCompanionDelegate(model, member)) {\n                    final JCMethodDecl concreteMemberDelegate = makeDelegateToCompanion(iface,\n                            PUBLIC, method.getTypeParameters(), \n                            method,\n                            method.getType(), method.getName(), method.getParameterLists().get(0).getParameters(),\n                            Decl.isAncestorLocal(model));\n                    classBuilder.defs(concreteMemberDelegate);\n                     \n                }\n            } else if (member instanceof Getter) {// Concrete getter\n                Getter getter = (Getter)member;\n                if (needsCompanionDelegate(model, member)) {\n                    final JCMethodDecl getterDelegate = makeDelegateToCompanion(iface, \n                            PUBLIC | (getter.isDefault() ? 0 : FINAL), \n                            Collections.<TypeParameter>emptyList(), \n                            getter, \n                            getter.getType(), \n                            CodegenUtil.getGetterName(member), \n                            Collections.<Parameter>emptyList(),\n                            Decl.isAncestorLocal(model));\n                    classBuilder.defs(getterDelegate);\n                }\n            } else if (needsCompanionDelegate(model, member)) {\n                log.error(\"ceylon\", \"Unhandled concrete interface member \" + member.getName());\n            }\n        }\n        \n        // Add $impl instances for the whole interface hierarchy\n        satisfiedInterfaces.add(iface);\n        for (ProducedType sat : iface.getSatisfiedTypes()) {\n            concreteMembersFromSuperinterfaces(model, classBuilder, sat, satisfiedInterfaces);\n        }\n        \n    }","commit_id":"b1305a6129c66a1cf035a3ca4b49ae9c03f9f2bc","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private JCTree makeDefaultedCall(int i, boolean isVariadic) {\n        // collect every parameter\n        int a = 0;\n        ListBuffer<JCStatement> stmts = new ListBuffer<JCStatement>();\n        for(Parameter param : paramLists.getParameters()){\n            // read the value\n            JCExpression paramExpression = getTypedParameter(param, a, i>3);\n            JCExpression varInitialExpression;\n            if(param.isDefaulted()){\n                if(i > 3){\n                    // must check if it's defined\n                    JCExpression test = gen.make().Binary(JCTree.GT, gen.makeSelect(getParamName(0), \"length\"), gen.makeInteger(a));\n                    JCExpression elseBranch = makeDefaultValueCall(param, a);\n                    varInitialExpression = gen.make().Conditional(test, paramExpression, elseBranch);\n                }else if(a >= i){\n                    // get its default value because we don't have it\n                    varInitialExpression = makeDefaultValueCall(param, a);\n                }else{\n                    // we must have it\n                    varInitialExpression = paramExpression;\n                }\n            }else{\n                varInitialExpression = paramExpression;\n            }\n            // store it in a local var\n            JCStatement var = gen.make().VarDef(gen.make().Modifiers(0), \n                    gen.naming.makeUnquotedName(param.getName()), \n                    gen.makeJavaType(param.getType()),\n                    varInitialExpression);\n            stmts.append(var);\n            a++;\n        }\n        if(isVariadic){\n            // chain to n param typed method\n            List<JCExpression> args = List.nil();\n            // pass along the parameters\n            for(a=paramLists.getParameters().size()-1;a>=0;a--){\n                Parameter param = paramLists.getParameters().get(a);\n                args = args.prepend(gen.makeUnquotedIdent(param.getName()));\n            }\n            JCMethodInvocation chain = gen.make().Apply(null, gen.makeUnquotedIdent(Naming.getCallableTypedMethodName()), args);\n            stmts.append(gen.make().Return(chain));\n        }else{\n            // insert the method body directly\n            stmts.appendList(this.body);\n        }\n        List<JCStatement> body = stmts.toList();\n        return makeCallMethod(body, i);\n    }","id":65393,"modified_method":"private JCTree makeDefaultedCall(int i, boolean isVariadic) {\n        // collect every parameter\n        int a = 0;\n        ListBuffer<JCStatement> stmts = new ListBuffer<JCStatement>();\n        for(Parameter param : paramLists.getParameters()){\n            // read the value\n            JCExpression paramExpression = getTypedParameter(param, a, i>3);\n            JCExpression varInitialExpression;\n            if(param.isDefaulted() || param.isSequenced()){\n                if(i > 3){\n                    // must check if it's defined\n                    JCExpression test = gen.make().Binary(JCTree.GT, gen.makeSelect(getParamName(0), \"length\"), gen.makeInteger(a));\n                    JCExpression elseBranch = makeDefaultValueCall(param, a);\n                    varInitialExpression = gen.make().Conditional(test, paramExpression, elseBranch);\n                }else if(a >= i){\n                    // get its default value because we don't have it\n                    varInitialExpression = makeDefaultValueCall(param, a);\n                }else{\n                    // we must have it\n                    varInitialExpression = paramExpression;\n                }\n            }else{\n                varInitialExpression = paramExpression;\n            }\n            // store it in a local var\n            JCStatement var = gen.make().VarDef(gen.make().Modifiers(0), \n                    gen.naming.makeUnquotedName(param.getName()), \n                    gen.makeJavaType(param.getType()),\n                    varInitialExpression);\n            stmts.append(var);\n            a++;\n        }\n        if(isVariadic){\n            // chain to n param typed method\n            List<JCExpression> args = List.nil();\n            // pass along the parameters\n            for(a=paramLists.getParameters().size()-1;a>=0;a--){\n                Parameter param = paramLists.getParameters().get(a);\n                args = args.prepend(gen.makeUnquotedIdent(param.getName()));\n            }\n            JCMethodInvocation chain = gen.make().Apply(null, gen.makeUnquotedIdent(Naming.getCallableTypedMethodName()), args);\n            stmts.append(gen.make().Return(chain));\n        }else{\n            // insert the method body directly\n            stmts.appendList(this.body);\n        }\n        List<JCStatement> body = stmts.toList();\n        return makeCallMethod(body, i);\n    }","commit_id":"b932f368af8ef33c16cab4eccdb0d7f0adab00b0","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public JCNewClass build() {\n        // Generate a subclass of Callable\n        ListBuffer<JCTree> classBody = new ListBuffer<JCTree>();\n        int numParams = paramLists.getParameters().size();\n        int minimumParams = 0;\n        for(Parameter p : paramLists.getParameters()){\n            if(p.isDefaulted())\n                break;\n            minimumParams++;\n        }\n        boolean isVariadic = minimumParams != numParams;\n        // generate a method for each defaulted param\n        for(Tree.Parameter p : parameterListTree.getParameters()){\n            if(p.getDefaultArgument() != null){\n                MethodDefinitionBuilder methodBuilder = gen.classGen().makeParamDefaultValueMethod(false, null, parameterListTree, p);\n                classBody.append(methodBuilder.build());\n            }\n        }\n        \n        // now generate a method for each supported minimum number of parameters below 4\n        // which delegates to the $call$typed method if required\n        for(int i=minimumParams,max = Math.min(numParams,4);i<max;i++){\n            classBody.append(makeDefaultedCall(i, isVariadic));\n        }\n        // generate the $call method for the max number of parameters,\n        // which delegates to the $call$typed method if required\n        classBody.append(makeDefaultedCall(numParams, isVariadic));\n        // generate the $call$typed method if required\n        if(isVariadic)\n            classBody.append(makeCallTypedMethod(body));\n        \n        JCClassDecl classDef = gen.make().AnonymousClassDef(gen.make().Modifiers(0), classBody.toList());\n        \n        JCNewClass instance = gen.make().NewClass(null, \n                null, \n                gen.makeJavaType(typeModel, JT_EXTENDS | JT_CLASS_NEW), \n                List.<JCExpression>of(gen.make().Literal(typeModel.getProducedTypeName(true))),\n                classDef);\n        return instance;\n    }","id":65394,"modified_method":"public JCNewClass build() {\n        // Generate a subclass of Callable\n        ListBuffer<JCTree> classBody = new ListBuffer<JCTree>();\n        int numParams = paramLists.getParameters().size();\n        int minimumParams = 0;\n        for(Parameter p : paramLists.getParameters()){\n            if(p.isDefaulted() || p.isSequenced())\n                break;\n            minimumParams++;\n        }\n        boolean isVariadic = minimumParams != numParams;\n        // generate a method for each defaulted param\n        for(Tree.Parameter p : parameterListTree.getParameters()){\n            if(p.getDefaultArgument() != null || p.getDeclarationModel().isSequenced()){\n                MethodDefinitionBuilder methodBuilder = gen.classGen().makeParamDefaultValueMethod(false, null, parameterListTree, p);\n                classBody.append(methodBuilder.build());\n            }\n        }\n        \n        // now generate a method for each supported minimum number of parameters below 4\n        // which delegates to the $call$typed method if required\n        for(int i=minimumParams,max = Math.min(numParams,4);i<max;i++){\n            classBody.append(makeDefaultedCall(i, isVariadic));\n        }\n        // generate the $call method for the max number of parameters,\n        // which delegates to the $call$typed method if required\n        classBody.append(makeDefaultedCall(numParams, isVariadic));\n        // generate the $call$typed method if required\n        if(isVariadic)\n            classBody.append(makeCallTypedMethod(body));\n        \n        JCClassDecl classDef = gen.make().AnonymousClassDef(gen.make().Modifiers(0), classBody.toList());\n        \n        JCNewClass instance = gen.make().NewClass(null, \n                null, \n                gen.makeJavaType(typeModel, JT_EXTENDS | JT_CLASS_NEW), \n                List.<JCExpression>of(gen.make().Literal(typeModel.getProducedTypeName(true))),\n                classDef);\n        return instance;\n    }","commit_id":"b932f368af8ef33c16cab4eccdb0d7f0adab00b0","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n\tpublic boolean canWrite(Class<?> clazz, MediaType mediaType) {\n\t\tif (!canWrite(mediaType)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!logger.isWarnEnabled()) {\n\t\t\treturn this.objectMapper.canSerialize(clazz);\n\t\t}\n\t\tAtomicReference<Throwable> causeRef = new AtomicReference<Throwable>();\n\t\tif (this.objectMapper.canSerialize(clazz, causeRef)) {\n\t\t\treturn true;\n\t\t}\n\t\tThrowable cause = causeRef.get();\n\t\tif (cause != null) {\n\t\t\tString msg = \"Failed to evaluate serialization for type [\" + clazz + \"]\";\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.warn(msg, cause);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.warn(msg + \": \" + cause);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","id":65395,"modified_method":"@Override\n\tpublic boolean canWrite(Class<?> clazz, MediaType mediaType) {\n\t\tif (!canWrite(mediaType)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!logger.isWarnEnabled()) {\n\t\t\treturn this.objectMapper.canSerialize(clazz);\n\t\t}\n\t\tAtomicReference<Throwable> causeRef = new AtomicReference<Throwable>();\n\t\tif (this.objectMapper.canSerialize(clazz, causeRef)) {\n\t\t\treturn true;\n\t\t}\n\t\tlogWarningIfNecessary(clazz, causeRef.get());\n\t\treturn false;\n\t}","commit_id":"5f4e838f4165f99ac6166a14e8ce6afcc39a5ba0","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic boolean canRead(Type type, Class<?> contextClass, MediaType mediaType) {\n\t\tJavaType javaType = getJavaType(type, contextClass);\n\t\tif (!canRead(mediaType)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!logger.isWarnEnabled()) {\n\t\t\treturn this.objectMapper.canDeserialize(javaType);\n\t\t}\n\t\tAtomicReference<Throwable> causeRef = new AtomicReference<Throwable>();\n\t\tif (this.objectMapper.canDeserialize(javaType, causeRef)) {\n\t\t\treturn true;\n\t\t}\n\t\tThrowable cause = causeRef.get();\n\t\tif (cause != null) {\n\t\t\tString msg = \"Failed to evaluate deserialization for type \" + javaType;\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.warn(msg, cause);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.warn(msg + \": \" + cause);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","id":65396,"modified_method":"@Override\n\tpublic boolean canRead(Type type, Class<?> contextClass, MediaType mediaType) {\n\t\tJavaType javaType = getJavaType(type, contextClass);\n\t\tif (!canRead(mediaType)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!logger.isWarnEnabled()) {\n\t\t\treturn this.objectMapper.canDeserialize(javaType);\n\t\t}\n\t\tAtomicReference<Throwable> causeRef = new AtomicReference<Throwable>();\n\t\tif (this.objectMapper.canDeserialize(javaType, causeRef)) {\n\t\t\treturn true;\n\t\t}\n\t\tlogWarningIfNecessary(javaType, causeRef.get());\n\t\treturn false;\n\t}","commit_id":"5f4e838f4165f99ac6166a14e8ce6afcc39a5ba0","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tprotected boolean canConvertTo(Object payload, MessageHeaders headers) {\n\t\tif (!logger.isWarnEnabled()) {\n\t\t\treturn (this.objectMapper.canSerialize(payload.getClass()) && supportsMimeType(headers));\n\t\t}\n\t\tAtomicReference<Throwable> causeRef = new AtomicReference<Throwable>();\n\t\tif (this.objectMapper.canSerialize(payload.getClass(), causeRef) && supportsMimeType(headers)) {\n\t\t\treturn true;\n\t\t}\n\t\tThrowable cause = causeRef.get();\n\t\tif (cause != null) {\n\t\t\tString msg = \"Failed to evaluate serialization for type [\" + payload.getClass() + \"]\";\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.warn(msg, cause);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.warn(msg + \": \" + cause);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","id":65397,"modified_method":"@Override\n\tprotected boolean canConvertTo(Object payload, MessageHeaders headers) {\n\t\tif (payload == null || !supportsMimeType(headers)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!logger.isWarnEnabled()) {\n\t\t\treturn this.objectMapper.canSerialize(payload.getClass());\n\t\t}\n\t\tAtomicReference<Throwable> causeRef = new AtomicReference<Throwable>();\n\t\tif (this.objectMapper.canSerialize(payload.getClass(), causeRef)) {\n\t\t\treturn true;\n\t\t}\n\t\tlogWarningIfNecessary(payload.getClass(), causeRef.get());\n\t\treturn false;\n\t}","commit_id":"5f4e838f4165f99ac6166a14e8ce6afcc39a5ba0","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tprotected boolean canConvertFrom(Message<?> message, Class<?> targetClass) {\n\t\tif (targetClass == null) {\n\t\t\treturn false;\n\t\t}\n\t\tJavaType javaType = this.objectMapper.constructType(targetClass);\n\t\tif (!logger.isWarnEnabled()) {\n\t\t\treturn (this.objectMapper.canDeserialize(javaType) && supportsMimeType(message.getHeaders()));\n\t\t}\n\t\tAtomicReference<Throwable> causeRef = new AtomicReference<Throwable>();\n\t\tif (this.objectMapper.canDeserialize(javaType, causeRef) && supportsMimeType(message.getHeaders())) {\n\t\t\treturn true;\n\t\t}\n\t\tThrowable cause = causeRef.get();\n\t\tif (cause != null) {\n\t\t\tString msg = \"Failed to evaluate deserialization for type \" + javaType;\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.warn(msg, cause);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.warn(msg + \": \" + cause);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","id":65398,"modified_method":"@Override\n\tprotected boolean canConvertFrom(Message<?> message, Class<?> targetClass) {\n\t\tif (targetClass == null || !supportsMimeType(message.getHeaders())) {\n\t\t\treturn false;\n\t\t}\n\t\tJavaType javaType = this.objectMapper.constructType(targetClass);\n\t\tif (!logger.isWarnEnabled()) {\n\t\t\treturn this.objectMapper.canDeserialize(javaType);\n\t\t}\n\t\tAtomicReference<Throwable> causeRef = new AtomicReference<Throwable>();\n\t\tif (this.objectMapper.canDeserialize(javaType, causeRef)) {\n\t\t\treturn true;\n\t\t}\n\t\tlogWarningIfNecessary(javaType, causeRef.get());\n\t\treturn false;\n\t}","commit_id":"5f4e838f4165f99ac6166a14e8ce6afcc39a5ba0","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private OptionsPanel() {\n      super(new GridBagLayout());\n\n      GridBagConstraints gc = new GridBagConstraints();\n      gc.weighty = 0;\n      gc.weightx = 1;\n      gc.fill = GridBagConstraints.HORIZONTAL;\n      gc.anchor = GridBagConstraints.NORTHWEST;\n\n      myReportInitializer = new JCheckBox(InspectionsBundle.message(\"inspection.unused.assignment.option2\"));\n      myReportInitializer.setSelected(REPORT_REDUNDANT_INITIALIZER);\n      myReportInitializer.getModel().addChangeListener(new ChangeListener() {\n        @Override\n        public void stateChanged(ChangeEvent e) {\n          REPORT_REDUNDANT_INITIALIZER = myReportInitializer.isSelected();\n        }\n      });\n      gc.insets = new Insets(0, 0, 15, 0);\n      gc.gridy = 0;\n      add(myReportInitializer, gc);\n\n      myReportPrefix = new JCheckBox(InspectionsBundle.message(\"inspection.unused.assignment.option\"));\n      myReportPrefix.setSelected(REPORT_PREFIX_EXPRESSIONS);\n      myReportPrefix.getModel().addChangeListener(new ChangeListener() {\n        @Override\n        public void stateChanged(ChangeEvent e) {\n          REPORT_PREFIX_EXPRESSIONS = myReportPrefix.isSelected();\n        }\n      });\n      gc.insets = new Insets(0, 0, 0, 0);\n      gc.gridy++;\n      add(myReportPrefix, gc);\n\n      myReportPostfix = new JCheckBox(InspectionsBundle.message(\"inspection.unused.assignment.option1\"));\n      myReportPostfix.setSelected(REPORT_POSTFIX_EXPRESSIONS);\n      myReportPostfix.getModel().addChangeListener(new ChangeListener() {\n        @Override\n        public void stateChanged(ChangeEvent e) {\n          REPORT_POSTFIX_EXPRESSIONS = myReportPostfix.isSelected();\n        }\n      });\n\n      gc.weighty = 1;\n      gc.gridy++;\n      add(myReportPostfix, gc);\n    }","id":65399,"modified_method":"private OptionsPanel() {\n      super(new GridBagLayout());\n\n      GridBagConstraints gc = new GridBagConstraints();\n      gc.weighty = 0;\n      gc.weightx = 1;\n      gc.fill = GridBagConstraints.HORIZONTAL;\n      gc.anchor = GridBagConstraints.NORTHWEST;\n\n      myReportInitializer = new JCheckBox(InspectionsBundle.message(\"inspection.unused.assignment.option2\"));\n      myReportInitializer.setSelected(REPORT_REDUNDANT_INITIALIZER);\n      myReportInitializer.getModel().addChangeListener(e -> REPORT_REDUNDANT_INITIALIZER = myReportInitializer.isSelected());\n      gc.insets = JBUI.insetsBottom(15);\n      gc.gridy = 0;\n      add(myReportInitializer, gc);\n\n      myReportPrefix = new JCheckBox(InspectionsBundle.message(\"inspection.unused.assignment.option\"));\n      myReportPrefix.setSelected(REPORT_PREFIX_EXPRESSIONS);\n      myReportPrefix.getModel().addChangeListener(e -> REPORT_PREFIX_EXPRESSIONS = myReportPrefix.isSelected());\n      gc.insets = JBUI.emptyInsets();\n      gc.gridy++;\n      add(myReportPrefix, gc);\n\n      myReportPostfix = new JCheckBox(InspectionsBundle.message(\"inspection.unused.assignment.option1\"));\n      myReportPostfix.setSelected(REPORT_POSTFIX_EXPRESSIONS);\n      myReportPostfix.getModel().addChangeListener(e -> REPORT_POSTFIX_EXPRESSIONS = myReportPostfix.isSelected());\n      gc.weighty = 1;\n      gc.gridy++;\n      add(myReportPostfix, gc);\n    }","commit_id":"bd258f4a8372cbd8242c9c07cee547e2b92cc599","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkCodeBlock(final PsiCodeBlock body,\n                              final ProblemsHolder holder,\n                              final boolean isOnTheFly) {\n    if (body == null) return;\n    final Set<PsiVariable> usedVariables = new THashSet<PsiVariable>();\n    List<DefUseUtil.Info> unusedDefs = DefUseUtil.getUnusedDefs(body, usedVariables);\n\n    if (unusedDefs != null && !unusedDefs.isEmpty()) {\n      Collections.sort(unusedDefs, (o1, o2) -> {\n        int offset1 = o1.getContext().getTextOffset();\n        int offset2 = o2.getContext().getTextOffset();\n\n        if (offset1 == offset2) return 0;\n        if (offset1 < offset2) return -1;\n\n        return 1;\n      });\n\n      for (DefUseUtil.Info info : unusedDefs) {\n        PsiElement context = info.getContext();\n        PsiVariable psiVariable = info.getVariable();\n\n        if (context instanceof PsiDeclarationStatement || context instanceof PsiResourceVariable) {\n          if (!info.isRead()) {\n            if (!isOnTheFly) {\n              holder.registerProblem(ObjectUtils.notNull(psiVariable.getNameIdentifier(), psiVariable),\n                                     InspectionsBundle.message(\"inspection.unused.assignment.problem.descriptor1\", \"<code>#ref<\/code> #loc\"),\n                                     ProblemHighlightType.LIKE_UNUSED_SYMBOL);\n            }\n          }\n          else {\n            if (REPORT_REDUNDANT_INITIALIZER) {\n              List<LocalQuickFix> fixes = ContainerUtil.createMaybeSingletonList(\n                isOnTheFlyOrNoSideEffects(isOnTheFly, psiVariable, psiVariable.getInitializer()) ? createRemoveInitializerFix() : null);\n              holder.registerProblem(ObjectUtils.notNull(psiVariable.getInitializer(), psiVariable),\n                                     InspectionsBundle.message(\"inspection.unused.assignment.problem.descriptor2\",\n                                                               \"<code>\" + psiVariable.getName() + \"<\/code>\", \"<code>#ref<\/code> #loc\"),\n                                     ProblemHighlightType.LIKE_UNUSED_SYMBOL,\n                                     fixes.toArray(new LocalQuickFix[fixes.size()])\n              );\n            }\n          }\n        }\n        else if (context instanceof PsiAssignmentExpression) {\n          final PsiAssignmentExpression assignment = (PsiAssignmentExpression)context;\n          List<LocalQuickFix> fixes = ContainerUtil.createMaybeSingletonList(\n            isOnTheFlyOrNoSideEffects(isOnTheFly, psiVariable, assignment.getRExpression()) ? createRemoveAssignmentFix() : null);\n          holder.registerProblem(assignment.getLExpression(),\n                                 InspectionsBundle.message(\"inspection.unused.assignment.problem.descriptor3\",\n                                                           ObjectUtils.assertNotNull(assignment.getRExpression()).getText(), \"<code>#ref<\/code>\" + \" #loc\"),\n                                 ProblemHighlightType.LIKE_UNUSED_SYMBOL, fixes.toArray(new LocalQuickFix[fixes.size()])\n          );\n        }\n        else {\n          if (context instanceof PsiPrefixExpression && REPORT_PREFIX_EXPRESSIONS ||\n              context instanceof PsiPostfixExpression && REPORT_POSTFIX_EXPRESSIONS) {\n            holder.registerProblem(context,\n                                   InspectionsBundle.message(\"inspection.unused.assignment.problem.descriptor4\", \"<code>#ref<\/code> #loc\"));\n          }\n        }\n      }\n    }\n\n    body.accept(new JavaRecursiveElementWalkingVisitor() {\n      @Override public void visitClass(PsiClass aClass) { }\n\n      @Override public void visitLocalVariable(PsiLocalVariable variable) {\n        if (!usedVariables.contains(variable) && variable.getInitializer() == null && !isOnTheFly) {\n          holder.registerProblem(ObjectUtils.notNull(variable.getNameIdentifier(), variable),\n                                 InspectionsBundle.message(\"inspection.unused.assignment.problem.descriptor5\", \"<code>#ref<\/code> #loc\"),\n                                 ProblemHighlightType.LIKE_UNUSED_SYMBOL);\n        }\n      }\n    });\n  }","id":65400,"modified_method":"private void checkCodeBlock(final PsiCodeBlock body,\n                              final ProblemsHolder holder,\n                              final boolean isOnTheFly) {\n    if (body == null) return;\n    final Set<PsiVariable> usedVariables = new THashSet<PsiVariable>();\n    List<DefUseUtil.Info> unusedDefs = DefUseUtil.getUnusedDefs(body, usedVariables);\n\n    if (unusedDefs != null && !unusedDefs.isEmpty()) {\n      Collections.sort(unusedDefs, (o1, o2) -> {\n        int offset1 = o1.getContext().getTextOffset();\n        int offset2 = o2.getContext().getTextOffset();\n\n        if (offset1 == offset2) return 0;\n        if (offset1 < offset2) return -1;\n\n        return 1;\n      });\n\n      for (DefUseUtil.Info info : unusedDefs) {\n        PsiElement context = info.getContext();\n        PsiVariable psiVariable = info.getVariable();\n\n        if (context instanceof PsiDeclarationStatement || context instanceof PsiResourceVariable) {\n          if (!info.isRead()) {\n            if (!isOnTheFly) {\n              holder.registerProblem(ObjectUtils.notNull(psiVariable.getNameIdentifier(), psiVariable),\n                                     InspectionsBundle.message(\"inspection.unused.assignment.problem.descriptor1\", \"<code>#ref<\/code> #loc\"),\n                                     ProblemHighlightType.LIKE_UNUSED_SYMBOL);\n            }\n          }\n          else {\n            if (REPORT_REDUNDANT_INITIALIZER) {\n              List<LocalQuickFix> fixes = ContainerUtil.createMaybeSingletonList(\n                isOnTheFlyOrNoSideEffects(isOnTheFly, psiVariable, psiVariable.getInitializer()) ? createRemoveInitializerFix() : null);\n              holder.registerProblem(ObjectUtils.notNull(psiVariable.getInitializer(), psiVariable),\n                                     InspectionsBundle.message(\"inspection.unused.assignment.problem.descriptor2\",\n                                                               \"<code>\" + psiVariable.getName() + \"<\/code>\", \"<code>#ref<\/code> #loc\"),\n                                     ProblemHighlightType.LIKE_UNUSED_SYMBOL,\n                                     fixes.toArray(new LocalQuickFix[fixes.size()])\n              );\n            }\n          }\n        }\n        else if (context instanceof PsiAssignmentExpression) {\n          final PsiAssignmentExpression assignment = (PsiAssignmentExpression)context;\n          List<LocalQuickFix> fixes = ContainerUtil.createMaybeSingletonList(\n            isOnTheFlyOrNoSideEffects(isOnTheFly, psiVariable, assignment.getRExpression()) ? createRemoveAssignmentFix() : null);\n          holder.registerProblem(assignment.getLExpression(),\n                                 InspectionsBundle.message(\"inspection.unused.assignment.problem.descriptor3\",\n                                                           ObjectUtils.assertNotNull(assignment.getRExpression()).getText(), \"<code>#ref<\/code>\" + \" #loc\"),\n                                 ProblemHighlightType.LIKE_UNUSED_SYMBOL, fixes.toArray(new LocalQuickFix[fixes.size()])\n          );\n        }\n        else {\n          if (context instanceof PsiPrefixExpression && REPORT_PREFIX_EXPRESSIONS ||\n              context instanceof PsiPostfixExpression && REPORT_POSTFIX_EXPRESSIONS) {\n            holder.registerProblem(context,\n                                   InspectionsBundle.message(\"inspection.unused.assignment.problem.descriptor4\", \"<code>#ref<\/code> #loc\"));\n          }\n        }\n      }\n    }\n\n    if (!isOnTheFly) {\n      body.accept(new JavaRecursiveElementWalkingVisitor() {\n        @Override\n        public void visitClass(PsiClass aClass) { }\n\n        @Override\n        public void visitLocalVariable(PsiLocalVariable variable) {\n          if (!usedVariables.contains(variable) && variable.getInitializer() == null) {\n            PsiElement element = ObjectUtils.notNull(variable.getNameIdentifier(), variable);\n            String message = InspectionsBundle.message(\"inspection.unused.assignment.problem.descriptor5\", \"<code>#ref<\/code> #loc\");\n            holder.registerProblem(element, message, ProblemHighlightType.LIKE_UNUSED_SYMBOL);\n          }\n        }\n      });\n    }\n  }","commit_id":"bd258f4a8372cbd8242c9c07cee547e2b92cc599","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void onFacetCreated(final StrutsFacet strutsFacet,\n                                final ModifiableRootModel modifiableRootModel,\n                                final FrameworkVersion version) {\n    final Module module = strutsFacet.getModule();\n    StartupManager.getInstance(module.getProject()).runWhenProjectIsInitialized(new Runnable() {\n      public void run() {\n        final VirtualFile[] sourceRoots = ModuleRootManager.getInstance(module).getSourceRoots();\n        if (sourceRoots.length <= 0) {\n          return;\n        }\n\n        final PsiDirectory directory = PsiManager.getInstance(module.getProject()).findDirectory(sourceRoots[0]);\n        if (directory == null ||\n            directory.findFile(StrutsConstants.STRUTS_XML_DEFAULT_FILENAME) != null) {\n          return;\n        }\n\n        final StrutsFileTemplateProvider templateProvider = new StrutsFileTemplateProvider(module);\n        final FileTemplate strutsXmlTemplate = templateProvider.determineFileTemplate(directory.getProject());\n\n        try {\n          final StrutsFacetConfiguration strutsFacetConfiguration = strutsFacet.getConfiguration();\n\n          // create empty struts.xml & fileset with all found struts-*.xml files (struts2.jar, plugins)\n          final PsiElement psiElement = FileTemplateUtil.createFromTemplate(strutsXmlTemplate,\n                                                                            StrutsConstants.STRUTS_XML_DEFAULT_FILENAME,\n                                                                            null,\n                                                                            directory);\n          final Set<StrutsFileSet> empty = Collections.emptySet();\n          final StrutsFileSet fileSet = new StrutsFileSet(StrutsFileSet.getUniqueId(empty),\n                                                          StrutsFileSet.getUniqueName(\"Default File Set\", empty),\n                                                          strutsFacetConfiguration);\n          fileSet.addFile(((XmlFile) psiElement).getVirtualFile());\n\n          final StrutsConfigsSearcher searcher = new StrutsConfigsSearcher(module);\n          searcher.search();\n          final MultiMap<VirtualFile, PsiFile> jarConfigFiles = searcher.getJars();\n          for (final VirtualFile virtualFile : jarConfigFiles.keySet()) {\n            final Collection<PsiFile> psiFiles = jarConfigFiles.get(virtualFile);\n            for (final PsiFile psiFile : psiFiles) {\n              fileSet.addFile(psiFile.getVirtualFile());\n            }\n          }\n          strutsFacetConfiguration.getFileSets().add(fileSet);\n\n\n          // create filter & mapping in web.xml (if present)\n          new WriteCommandAction.Simple(modifiableRootModel.getProject()) {\n            protected void run() throws Throwable {\n              final WebFacet webFacet = strutsFacet.getWebFacet();\n\n              final ConfigFile configFile = webFacet.getWebXmlDescriptor();\n              if (configFile == null) return;\n\n              final XmlFile webXmlFile = configFile.getXmlFile();\n              final WebApp webApp = JamCommonUtil.getRootElement(webXmlFile, WebApp.class, null);\n              if (webApp == null) return;\n              if (!FileModificationService.getInstance().prepareFileForWrite(webXmlFile)) return;\n\n              final Filter strutsFilter = webApp.addFilter();\n              strutsFilter.getFilterName().setStringValue(\"struts2\");\n\n              @NonNls final String filterClass = templateProvider.is21orNewer() ?\n                  StrutsConstants.STRUTS_2_1_FILTER_CLASS :\n                  StrutsConstants.STRUTS_2_0_FILTER_CLASS;\n              strutsFilter.getFilterClass().setStringValue(filterClass);\n\n              final FilterMapping filterMapping = webApp.addFilterMapping();\n              filterMapping.getFilterName().setValue(strutsFilter);\n              filterMapping.addUrlPattern().setStringValue(\"/*\");\n            }\n          }.execute();\n\n\n          final NotificationListener showFacetSettingsListener = new NotificationListener() {\n            public void hyperlinkUpdate(@NotNull final Notification notification,\n                                        @NotNull final HyperlinkEvent event) {\n              if (event.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {\n                notification.expire();\n                ModulesConfigurator.showFacetSettingsDialog(strutsFacet, null);\n              }\n            }\n          };\n\n          Notifications.Bus.notify(\n              new Notification(\"Struts 2\", \"Struts 2 Setup\",\n                               \"Struts 2 Facet has been created, please check <a href=\\\"more\\\">created fileset<\/a>\",\n                               NotificationType.INFORMATION,\n                               showFacetSettingsListener),\n              module.getProject());\n\n        } catch (Exception e) {\n          LOG.error(\"error creating struts.xml from template\", e);\n        }\n      }\n    });\n  }","id":65401,"modified_method":"@Override\n  protected void onFacetCreated(final StrutsFacet strutsFacet,\n                                final ModifiableRootModel modifiableRootModel,\n                                final FrameworkVersion version) {\n    final Module module = strutsFacet.getModule();\n    StartupManager.getInstance(module.getProject()).runWhenProjectIsInitialized(new Runnable() {\n      public void run() {\n        DumbService.getInstance(module.getProject()).runWhenSmart(new Runnable() {\n          @Override\n          public void run() {\n            final VirtualFile[] sourceRoots = ModuleRootManager.getInstance(module).getSourceRoots();\n            if (sourceRoots.length <= 0) {\n              return;\n            }\n\n            final PsiDirectory directory = PsiManager.getInstance(module.getProject()).findDirectory(sourceRoots[0]);\n            if (directory == null ||\n                directory.findFile(StrutsConstants.STRUTS_XML_DEFAULT_FILENAME) != null) {\n              return;\n            }\n\n            final StrutsFileTemplateProvider templateProvider = new StrutsFileTemplateProvider(module);\n            final FileTemplate strutsXmlTemplate = templateProvider.determineFileTemplate(directory.getProject());\n\n            try {\n              final StrutsFacetConfiguration strutsFacetConfiguration = strutsFacet.getConfiguration();\n\n              // create empty struts.xml & fileset with all found struts-*.xml files (struts2.jar, plugins)\n              final PsiElement psiElement = FileTemplateUtil.createFromTemplate(strutsXmlTemplate,\n                                                                                StrutsConstants.STRUTS_XML_DEFAULT_FILENAME,\n                                                                                null,\n                                                                                directory);\n              final Set<StrutsFileSet> empty = Collections.emptySet();\n              final StrutsFileSet fileSet = new StrutsFileSet(StrutsFileSet.getUniqueId(empty),\n                                                              StrutsFileSet.getUniqueName(\"Default File Set\", empty),\n                                                              strutsFacetConfiguration);\n              fileSet.addFile(((XmlFile)psiElement).getVirtualFile());\n\n              final StrutsConfigsSearcher searcher = new StrutsConfigsSearcher(module);\n              searcher.search();\n              final MultiMap<VirtualFile, PsiFile> jarConfigFiles = searcher.getJars();\n              for (final VirtualFile virtualFile : jarConfigFiles.keySet()) {\n                final Collection<PsiFile> psiFiles = jarConfigFiles.get(virtualFile);\n                for (final PsiFile psiFile : psiFiles) {\n                  fileSet.addFile(psiFile.getVirtualFile());\n                }\n              }\n              strutsFacetConfiguration.getFileSets().add(fileSet);\n\n\n              // create filter & mapping in web.xml (if present)\n              new WriteCommandAction.Simple(modifiableRootModel.getProject()) {\n                protected void run() throws Throwable {\n                  final WebFacet webFacet = strutsFacet.getWebFacet();\n\n                  final ConfigFile configFile = webFacet.getWebXmlDescriptor();\n                  if (configFile == null) return;\n\n                  final XmlFile webXmlFile = configFile.getXmlFile();\n                  final WebApp webApp = JamCommonUtil.getRootElement(webXmlFile, WebApp.class, null);\n                  if (webApp == null) return;\n                  if (!FileModificationService.getInstance().prepareFileForWrite(webXmlFile)) return;\n\n                  final Filter strutsFilter = webApp.addFilter();\n                  strutsFilter.getFilterName().setStringValue(\"struts2\");\n\n                  @NonNls final String filterClass = templateProvider.is21orNewer() ?\n                                                     StrutsConstants.STRUTS_2_1_FILTER_CLASS :\n                                                     StrutsConstants.STRUTS_2_0_FILTER_CLASS;\n                  strutsFilter.getFilterClass().setStringValue(filterClass);\n\n                  final FilterMapping filterMapping = webApp.addFilterMapping();\n                  filterMapping.getFilterName().setValue(strutsFilter);\n                  filterMapping.addUrlPattern().setStringValue(\"/*\");\n                }\n              }.execute();\n\n\n              final NotificationListener showFacetSettingsListener = new NotificationListener() {\n                public void hyperlinkUpdate(@NotNull final Notification notification,\n                                            @NotNull final HyperlinkEvent event) {\n                  if (event.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {\n                    notification.expire();\n                    ModulesConfigurator.showFacetSettingsDialog(strutsFacet, null);\n                  }\n                }\n              };\n\n              Notifications.Bus.notify(\n                new Notification(\"Struts 2\", \"Struts 2 Setup\",\n                                 \"Struts 2 Facet has been created, please check <a href=\\\"more\\\">created fileset<\/a>\",\n                                 NotificationType.INFORMATION,\n                                 showFacetSettingsListener),\n                module.getProject());\n            }\n            catch (Exception e) {\n              LOG.error(\"error creating struts.xml from template\", e);\n            }\n          }\n        });\n      }\n    });\n  }","commit_id":"3362df61f67a464ce8812e8fb76ea7c6b4a4bdcd","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public void executeWizard() {\n    final MigrationAssistantWizard wizard = new MigrationAssistantWizard(myProject, myMigrationManager);\n    // final reload is needed to cleanup memory (unload models) and do possible switches (e.g. to a new persistence) \n    wizard.showAndGetOk().doWhenDone(new Consumer<Boolean>() {\n      @Override\n      public void consume(Boolean finished) {\n        if (!(finished)) {\n          return;\n        }\n        if (wizard.isFinishSuccessfull()) {\n          myState.migrationRequired = false;\n          ApplicationManager.getApplication().runWriteAction(new Runnable() {\n            public void run() {\n              ProjectManagerEx.getInstance().reloadProject(myProject);\n            }\n          });\n          return;\n        }\n\n        MigrationErrorStep lastStep = as_feb5zp_a0a3a0a0a0a2a23(wizard.getCurrentStepObject(), MigrationErrorStep.class);\n        if (lastStep == null) {\n          return;\n        }\n\n        final _FunctionTypes._void_P0_E0 afterProjectInitialized = lastStep.afterProjectInitialized();\n        if (afterProjectInitialized == null) {\n          return;\n        }\n\n        StartupManager.getInstance(myProject).runWhenProjectIsInitialized(new Runnable() {\n          public void run() {\n            ApplicationManager.getApplication().invokeLater(new Runnable() {\n              public void run() {\n                afterProjectInitialized.invoke();\n              }\n            }, ModalityState.NON_MODAL);\n\n          }\n        });\n      }\n    });\n  }","id":65402,"modified_method":"@Override\n  public void executeWizard() {\n    final MigrationAssistantWizard wizard = new MigrationAssistantWizard(myProject, myMigrationManager);\n    // final reload is needed to cleanup memory (unload models) and do possible switches (e.g. to a new persistence) \n    wizard.showAndGetOk().doWhenDone(new Consumer<Boolean>() {\n      @Override\n      public void consume(Boolean finished) {\n        if (!(finished)) {\n          return;\n        }\n        if (wizard.isFinishSuccessfull()) {\n          myState.migrationRequired = false;\n          ApplicationManager.getApplication().runWriteAction(new Runnable() {\n            public void run() {\n              ProjectManagerEx.getInstance().reloadProject(myProject);\n            }\n          });\n          return;\n        }\n\n        MigrationErrorStep lastStep = as_feb5zp_a0a3a0a0a0a2a82(wizard.getCurrentStepObject(), MigrationErrorStep.class);\n        if (lastStep == null) {\n          return;\n        }\n\n        final _FunctionTypes._void_P0_E0 afterProjectInitialized = lastStep.afterProjectInitialized();\n        if (afterProjectInitialized == null) {\n          return;\n        }\n\n        StartupManager.getInstance(myProject).runWhenProjectIsInitialized(new Runnable() {\n          public void run() {\n            ApplicationManager.getApplication().invokeLater(new Runnable() {\n              public void run() {\n                afterProjectInitialized.invoke();\n              }\n            }, ModalityState.NON_MODAL);\n\n          }\n        });\n      }\n    });\n  }","commit_id":"e30d9581fdce0ea6e39262de3dca5546d5c1dc14","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static <T> T as_feb5zp_a0a3a0a0a0a2a23(Object o, Class<T> type) {\n    return (type.isInstance(o) ? (T) o : null);\n  }","id":65403,"modified_method":"private static <T> T as_feb5zp_a0a3a0a0a0a2a82(Object o, Class<T> type) {\n    return (type.isInstance(o) ? (T) o : null);\n  }","commit_id":"e30d9581fdce0ea6e39262de3dca5546d5c1dc14","url":"https://github.com/JetBrains/MPS"},{"original_method":"private synchronized void postponeMigration() {\n    // note this check is under sync block so we don't queue more than 1 reload \n    if (myMigrationQueued) {\n      return;\n    }\n\n    final com.intellij.openapi.project.Project ideaProject = ProjectHelper.toIdeaProject(myMpsProject);\n\n    // wait until project is fully loaded (if not yet) \n    StartupManager.getInstance(ideaProject).runWhenProjectIsInitialized(new Runnable() {\n      public void run() {\n        // as we use ui, postpone to EDT \n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          public void run() {\n            String[] choises = new String[]{\"Migrate\", \"Postpone\"};\n            final int result = Messages.showCheckboxMessageDialog(DIALOG_TEXT, \"Migration required\", choises, \"Clean generated sources\", true, 0, 0, null, new PairFunction<Integer, JCheckBox, Integer>() {\n              public Integer fun(Integer selected, JCheckBox cb) {\n                if (selected == 1) {\n                  return 2;\n                }\n                return (cb.isSelected() ? 0 : 1);\n              }\n            });\n            if (result == 2) {\n              return;\n            }\n\n            ApplicationManager.getApplication().runWriteAction(new Runnable() {\n              public void run() {\n                if (result == 0) {\n                  removeGenSources();\n                }\n\n                // clean genclasses \n                removeClassesGen();\n                // invalidate FS caches (see InvalidateCachesAction) \n                FSRecords.invalidateCaches();\n              }\n            });\n            // set flag to execute migration after startup \n            myState.migrationRequired = true;\n            // reload project and start migration assist \n            ProjectManagerEx.getInstance().reloadProject(ideaProject);\n          }\n        });\n      }\n    });\n\n    myMigrationQueued = true;\n  }","id":65404,"modified_method":"private synchronized void postponeMigration() {\n    // note this check is under sync block so we don't queue more than 1 reload \n    if (myMigrationQueued) {\n      return;\n    }\n\n    final com.intellij.openapi.project.Project ideaProject = ProjectHelper.toIdeaProject(myMpsProject);\n\n    // wait until project is fully loaded (if not yet) \n    StartupManager.getInstance(ideaProject).runWhenProjectIsInitialized(new Runnable() {\n      public void run() {\n        // as we use ui, postpone to EDT \n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          public void run() {\n            int result = Messages.showYesNoDialog(myProject, DIALOG_TEXT, \"Migration required\", \"Migrate\", \"Postpone\", null);\n            if (result == Messages.NO) {\n              return;\n            }\n\n            // set flag to execute migration after startup \n            myState.migrationRequired = true;\n            // reload project and start migration assist \n            ProjectManagerEx.getInstance().reloadProject(ideaProject);\n          }\n        });\n      }\n    });\n\n    myMigrationQueued = true;\n  }","commit_id":"e30d9581fdce0ea6e39262de3dca5546d5c1dc14","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected String getText() {\n    return \"Migration was not completed.<br>\" + \"Some migration scripts are missing or finished with errors.<br><br>\" + \"Now the project will be reloaded.<br><br>\" + \"You can try to continue migrations manually or execute Migration Assistant later by selecting Tools->Run Migration Assistant from the main menu.\";\n  }","id":65405,"modified_method":"protected String getText() {\n    return \"Migration was not completed.<br>\" + \"Some migration scripts are missing or finished with errors.<br><br>\" + \"Problems will be shown in Usages tool after the project is loaded.<br>\" + \"You can try to continue migrations manually or execute Migration Assistant later by selecting Tools->Run Migration Assistant from the main menu.\";\n  }","commit_id":"efd1edf7e18c3b65ce2659bc59d0497d4702b61a","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void executeWizard() {\n    myState.migrationRequired = false;\n\n    final MigrationAssistantWizard wizard = new MigrationAssistantWizard(myProject, myMigrationManager);\n    // final reload is needed to cleanup memory (unload models) and do possible switches (e.g. to a new persistence) \n    boolean finished = wizard.showAndGet();\n    restoreTipsState();\n    if (!(finished)) {\n      return;\n    }\n\n    if (wizard.isFinishSuccessfull()) {\n      ApplicationManager.getApplication().runWriteAction(new Runnable() {\n        public void run() {\n          ProjectManagerEx.getInstance().reloadProject(myProject);\n        }\n      });\n      return;\n    }\n\n    MigrationErrorStep lastStep = as_feb5zp_a0a01a04(wizard.getCurrentStepObject(), MigrationErrorStep.class);\n    if (lastStep == null) {\n      return;\n    }\n\n    final _FunctionTypes._void_P0_E0 afterProjectInitialized = lastStep.afterProjectInitialized();\n    if (afterProjectInitialized == null) {\n      return;\n    }\n\n    StartupManager.getInstance(myProject).runWhenProjectIsInitialized(new Runnable() {\n      public void run() {\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          public void run() {\n            afterProjectInitialized.invoke();\n          }\n        }, ModalityState.NON_MODAL);\n\n      }\n    });\n  }","id":65406,"modified_method":"@Override\n  public void executeWizard() {\n    myState.migrationRequired = false;\n\n    final MigrationAssistantWizard wizard = new MigrationAssistantWizard(myProject, myMigrationManager);\n    // final reload is needed to cleanup memory (unload models) and do possible switches (e.g. to a new persistence) \n    boolean finished = wizard.showAndGet();\n    restoreTipsState();\n    if (!(finished)) {\n      return;\n    }\n\n    if (wizard.isFinishSuccessfull()) {\n      ApplicationManager.getApplication().runWriteAction(new Runnable() {\n        public void run() {\n          ProjectManagerEx.getInstance().reloadProject(myProject);\n        }\n      });\n      return;\n    }\n\n    MigrationErrorStep lastStep = as_feb5zp_a0a01a04(wizard.getCurrentStepObject(), MigrationErrorStep.class);\n    if (lastStep == null) {\n      return;\n    }\n\n    final Iterable<Problem> problems = lastStep.getProblems();\n    if (Sequence.fromIterable(problems).isEmpty()) {\n      return;\n    }\n\n    StartupManager.getInstance(myProject).runWhenProjectIsInitialized(new Runnable() {\n      public void run() {\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          public void run() {\n            ModelAccess.instance().runReadAction(new Runnable() {\n              public void run() {\n                ModelCheckerViewer v = new ModelCheckerViewer(myProject) {\n                  @Override\n                  protected void close() {\n                    ModelCheckerTool.getInstance(myProject).closeTab(this);\n                    super.close();\n                  }\n                };\n                final SearchResults<ModelCheckerIssue> result = new SearchResults<ModelCheckerIssue>();\n                Sequence.fromIterable(problems).visitAll(new IVisitor<Problem>() {\n                  public void visit(Problem it) {\n                    Object r = it.getReason();\n\n                    ModelCheckerIssue mci;\n                    if (r instanceof SNode) {\n                      mci = new ModelCheckerIssue.NodeIssue(((org.jetbrains.mps.openapi.model.SNode) r), it.getMessage(), null);\n                    } else if (r instanceof SModule) {\n                      mci = new ModelCheckerIssue.ModuleIssue(it.getMessage(), null);\n                    } else {\n                      throw new IllegalArgumentException(r.getClass().getName());\n                    }\n                    result.add(new SearchResult<ModelCheckerIssue>(mci, r, it.getCategory()));\n                  }\n                });\n                v.setSearchResults(result);\n                ModelCheckerTool.getInstance(myProject).showTabWithResults(v, \"Migration issues\", IdeIcons.MODULE_GROUP_CLOSED);\n              }\n            });\n          }\n        }, ModalityState.NON_MODAL);\n\n      }\n    });\n  }","commit_id":"efd1edf7e18c3b65ce2659bc59d0497d4702b61a","url":"https://github.com/JetBrains/MPS"},{"original_method":"private synchronized void postponeMigration() {\n    // note this check is under sync block so we don't queue more than 1 reload \n    if (myMigrationQueued) {\n      return;\n    }\n\n    final com.intellij.openapi.project.Project ideaProject = ProjectHelper.toIdeaProject(myMpsProject);\n\n    // wait until project is fully loaded (if not yet) \n    StartupManager.getInstance(ideaProject).runWhenProjectIsInitialized(new Runnable() {\n      public void run() {\n        // as we use ui, postpone to EDT \n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          public void run() {\n            String[] choises = new String[]{\"Clean sources and migrate\", \"Migrate\", \"Postpone\"};\n            int result = Messages.showChooseDialog(ideaProject, \"Some of the modules in project require migration.\\n\" + \"It is advised to clean generated files before you start the migration.\\n\" + \"Would you like to reload project and start the migration immediately?\", \"Migration required\", null, choises, choises[0]);\n            if (result == 2) {\n              return;\n            }\n            if (result == 0) {\n              removeGenSources();\n            }\n\n            // clean genclasses \n            removeClassesGen();\n            // invalidate FS caches (see InvalidateCachesAction) \n            FSRecords.invalidateCaches();\n            // set flag to execute migration after startup \n            myState.migrationRequired = true;\n            // reload project and start migration assist \n            ProjectManagerEx.getInstance().reloadProject(ideaProject);\n          }\n        });\n      }\n    });\n\n    myMigrationQueued = true;\n  }","id":65407,"modified_method":"private synchronized void postponeMigration() {\n    // note this check is under sync block so we don't queue more than 1 reload \n    if (myMigrationQueued) {\n      return;\n    }\n\n    final com.intellij.openapi.project.Project ideaProject = ProjectHelper.toIdeaProject(myMpsProject);\n\n    // wait until project is fully loaded (if not yet) \n    StartupManager.getInstance(ideaProject).runWhenProjectIsInitialized(new Runnable() {\n      public void run() {\n        // as we use ui, postpone to EDT \n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          public void run() {\n            String[] choises = new String[]{\"Clean sources and migrate\", \"Migrate\", \"Postpone\"};\n            final int result = Messages.showChooseDialog(ideaProject, \"Some of the modules in project require migration.\\n\" + \"It is advised to clean generated files before you start the migration.\\n\" + \"Would you like to reload project and start the migration immediately?\", \"Migration required\", null, choises, choises[0]);\n            if (result == 2) {\n              return;\n            }\n\n            ApplicationManager.getApplication().runWriteAction(new Runnable() {\n              public void run() {\n                if (result == 0) {\n                  removeGenSources();\n                }\n\n                // clean genclasses \n                removeClassesGen();\n                // invalidate FS caches (see InvalidateCachesAction) \n                FSRecords.invalidateCaches();\n              }\n            });\n            // set flag to execute migration after startup \n            myState.migrationRequired = true;\n            // reload project and start migration assist \n            ProjectManagerEx.getInstance().reloadProject(ideaProject);\n          }\n        });\n      }\n    });\n\n    myMigrationQueued = true;\n  }","commit_id":"64dde8bf51b06267c98294251752eaf0c4637377","url":"https://github.com/JetBrains/MPS"},{"original_method":"public synchronized void postponeMigration() {\n    if (myBlocked.get() != 0) {\n      return;\n    }\n\n    final com.intellij.openapi.project.Project ideaProject = myProject;\n    final Iterable<SModule> allModules = MigrationsUtil.getMigrateableModulesFromProject(myMpsProject);\n    saveAndSetTipsState();\n\n    // wait until project is fully loaded (if not yet) \n    StartupManager.getInstance(ideaProject).runWhenProjectIsInitialized(new Runnable() {\n      public void run() {\n        // as we use ui, postpone to EDT \n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          public void run() {\n            boolean migrate = MigrationDialogUtil.showMigrationConfirmation(myProject, allModules, myMigrationManager);\n            restoreTipsState();\n\n            // set flag to execute migration after startup \n            // NOTE we need to set it here as in invokeLater it can  \n            // be executed when save session already passed, see MPS-22045 \n            myState.migrationRequired = migrate;\n\n            if (!(migrate)) {\n              return;\n            }\n\n            VirtualFileUtils.refreshSynchronouslyRecursively(myProject.getBaseDir());\n            VirtualFileManager.getInstance().asyncRefresh(new Runnable() {\n              public void run() {\n                ApplicationManager.getApplication().invokeLater(new Runnable() {\n                  public void run() {\n                    ReloadManager.getInstance().flush();\n                    // reload project and start migration assist \n                    ProjectManagerEx.getInstance().reloadProject(ideaProject);\n                  }\n                });\n              }\n            });\n          }\n        });\n      }\n    });\n\n    myMigrationQueued = true;\n  }","id":65408,"modified_method":"public synchronized void postponeMigration() {\n    if (myBlocked.get() != 0) {\n      return;\n    }\n\n    final com.intellij.openapi.project.Project ideaProject = myProject;\n    final Iterable<SModule> allModules = MigrationsUtil.getMigrateableModulesFromProject(myMpsProject);\n    saveAndSetTipsState();\n\n    // wait until project is fully loaded (if not yet) \n    StartupManager.getInstance(ideaProject).runWhenProjectIsInitialized(new Runnable() {\n      public void run() {\n        // as we use ui, postpone to EDT \n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          public void run() {\n            ModelAccess.instance().runWriteAction(new Runnable() {\n              public void run() {\n                updateUsedLanguagesVersions(allModules);\n              }\n            });\n            boolean migrate = MigrationDialogUtil.showMigrationConfirmation(myProject, allModules, myMigrationManager);\n            restoreTipsState();\n\n            // set flag to execute migration after startup \n            // NOTE we need to set it here as in invokeLater it can  \n            // be executed when save session already passed, see MPS-22045 \n            myState.migrationRequired = migrate;\n\n            if (!(migrate)) {\n              return;\n            }\n\n            VirtualFileUtils.refreshSynchronouslyRecursively(myProject.getBaseDir());\n            VirtualFileManager.getInstance().asyncRefresh(new Runnable() {\n              public void run() {\n                ApplicationManager.getApplication().invokeLater(new Runnable() {\n                  public void run() {\n                    ReloadManager.getInstance().flush();\n                    // reload project and start migration assist \n                    ProjectManagerEx.getInstance().reloadProject(ideaProject);\n                  }\n                });\n              }\n            });\n          }\n        });\n      }\n    });\n\n    myMigrationQueued = true;\n  }","commit_id":"8a90a9d142172b32f738e7b443a9f5e10417406b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void readDirectoryMappings(final Element element) {\n    myMappings.clear();\n\n    final List<VcsDirectoryMapping> mappingsList = new ArrayList<VcsDirectoryMapping>();\n    final List list = element.getChildren(ELEMENT_MAPPING);\n    boolean haveNonEmptyMappings = false;\n    for(Object childObj: list) {\n      Element child = (Element) childObj;\n      final String vcs = child.getAttributeValue(ATTRIBUTE_VCS);\n      if (vcs != null && vcs.length() > 0) {\n        haveNonEmptyMappings = true;\n      }\n      VcsDirectoryMapping mapping = new VcsDirectoryMapping(child.getAttributeValue(ATTRIBUTE_DIRECTORY), vcs);\n      mappingsList.add(mapping);\n\n      Element rootSettingsElement = child.getChild(ELEMENT_ROOT_SETTINGS);\n      if (rootSettingsElement != null) {\n        String className = rootSettingsElement.getAttributeValue(ATTRIBUTE_CLASS);\n        AbstractVcs vcsInstance = findVcsByName(mapping.getVcs());\n        if (vcsInstance != null && className != null) {\n          final VcsRootSettings rootSettings = vcsInstance.createEmptyVcsRootSettings();\n          if (rootSettings != null) {\n            try {\n              rootSettings.readExternal(rootSettingsElement);\n              mapping.setRootSettings(rootSettings);\n            } catch (InvalidDataException e) {\n              LOG.error(\"Failed to load VCS root settings class \"+ className + \" for VCS \" + vcsInstance.getClass().getName(), e);\n            }\n          }\n        }\n      }\n    }\n    boolean defaultProject = Boolean.TRUE.toString().equals(element.getAttributeValue(ATTRIBUTE_DEFAULT_PROJECT));\n    // run autodetection if there's no VCS in default project and \n    if (haveNonEmptyMappings || !defaultProject) {\n      myMappingsLoaded = true;\n    }\n    StartupManager.getInstance(myProject).runWhenProjectIsInitialized(new Runnable() {\n      public void run() {\n        myMappings.setDirectoryMappings(mappingsList);\n      }\n    });\n  }","id":65409,"modified_method":"public void readDirectoryMappings(final Element element) {\n    myMappings.clear();\n\n    final List<VcsDirectoryMapping> mappingsList = new ArrayList<VcsDirectoryMapping>();\n    final List list = element.getChildren(ELEMENT_MAPPING);\n    boolean haveNonEmptyMappings = false;\n    for(Object childObj: list) {\n      Element child = (Element) childObj;\n      final String vcs = child.getAttributeValue(ATTRIBUTE_VCS);\n      if (vcs != null && vcs.length() > 0) {\n        haveNonEmptyMappings = true;\n      }\n      VcsDirectoryMapping mapping = new VcsDirectoryMapping(child.getAttributeValue(ATTRIBUTE_DIRECTORY), vcs);\n      mappingsList.add(mapping);\n\n      Element rootSettingsElement = child.getChild(ELEMENT_ROOT_SETTINGS);\n      if (rootSettingsElement != null) {\n        String className = rootSettingsElement.getAttributeValue(ATTRIBUTE_CLASS);\n        AbstractVcs vcsInstance = findVcsByName(mapping.getVcs());\n        if (vcsInstance != null && className != null) {\n          final VcsRootSettings rootSettings = vcsInstance.createEmptyVcsRootSettings();\n          if (rootSettings != null) {\n            try {\n              rootSettings.readExternal(rootSettingsElement);\n              mapping.setRootSettings(rootSettings);\n            } catch (InvalidDataException e) {\n              LOG.error(\"Failed to load VCS root settings class \"+ className + \" for VCS \" + vcsInstance.getClass().getName(), e);\n            }\n          }\n        }\n      }\n    }\n    boolean defaultProject = Boolean.TRUE.toString().equals(element.getAttributeValue(ATTRIBUTE_DEFAULT_PROJECT));\n    // run autodetection if there's no VCS in default project and \n    if (haveNonEmptyMappings || !defaultProject) {\n      myMappingsLoaded = true;\n    }\n    StartupManager.getInstance(myProject).runWhenProjectIsInitialized(new Runnable() {\n      public void run() {\n        DumbService.getInstance(myProject).runWhenSmart(new Runnable() {\n          public void run() {\n            myMappings.setDirectoryMappings(mappingsList);\n          }\n        });\n      }\n    });\n  }","commit_id":"1d882d6e943d99603043c8273775683459ffc652","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void projectOpened() {\n    if (!(myState.migrationRequired)) {\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          MPSModuleRepository.getInstance().addRepositoryListener(MigrationTrigger.this.myRepoListener);\n          ClassLoaderManager.getInstance().addClassesHandler(MigrationTrigger.this.myClassesListener);\n          myProject.getComponent(ProjectMigrationProperties.class).addListener(MigrationTrigger.this.myPropertiesListener);\n        }\n      });\n      ModelAccess.instance().runWriteAction(new Runnable() {\n        public void run() {\n          tryMigratingProject();\n        }\n      });\n      return;\n    }\n\n    StartupManager.getInstance(myProject).registerPostStartupActivity(new Runnable() {\n      public void run() {\n        // this line should be executed in post-startup activity as we can have language in the same project \n        // with the solution to migrate, and in this case classes of this language will be cleared, but after \n        // they are compiled at startup, they are only reloaded in a pre-startup activity \n        if (!(myMigrationManager.isMigrationRequired())) {\n          return;\n        }\n\n        ApplicationManager.getApplication().runWriteAction(new Runnable() {\n          public void run() {\n            VirtualFileUtils.refreshSynchronouslyRecursively(myProject.getBaseDir());\n            VirtualFileManager.getInstance().asyncRefresh(new Runnable() {\n              public void run() {\n                SwingUtilities.invokeLater(new Runnable() {\n                  public void run() {\n                    executeWizard();\n                  }\n                });\n              }\n            });\n          }\n        });\n      }\n    });\n  }","id":65410,"modified_method":"public void projectOpened() {\n    if (!(myState.migrationRequired)) {\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          MPSModuleRepository.getInstance().addRepositoryListener(MigrationTrigger.this.myRepoListener);\n          ClassLoaderManager.getInstance().addClassesHandler(MigrationTrigger.this.myClassesListener);\n          myProject.getComponent(ProjectMigrationProperties.class).addListener(MigrationTrigger.this.myPropertiesListener);\n        }\n      });\n      ModelAccess.instance().runWriteAction(new Runnable() {\n        public void run() {\n          tryMigratingProject();\n        }\n      });\n      return;\n    }\n\n    StartupManager.getInstance(myProject).registerPostStartupActivity(new Runnable() {\n      public void run() {\n        // this line should be executed in post-startup activity as we can have language in the same project \n        // with the solution to migrate, and in this case classes of this language will be cleared, but after \n        // they are compiled at startup, they are only reloaded in a pre-startup activity \n        if (!(myMigrationManager.isMigrationRequired())) {\n          return;\n        }\n\n        ApplicationManager.getApplication().runWriteAction(new Runnable() {\n          public void run() {\n            VirtualFileUtils.refreshSynchronouslyRecursively(myProject.getBaseDir());\n            VirtualFileManager.getInstance().asyncRefresh(new Runnable() {\n              public void run() {\n                SwingUtilities.invokeLater(new Runnable() {\n                  public void run() {\n                    ReloadManager.getInstance().flush();\n                    executeWizard();\n                  }\n                });\n              }\n            });\n          }\n        });\n      }\n    });\n  }","commit_id":"9464875e63d54bfe50417543a7171791e03beba6","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void postponeMigration() {\n    final com.intellij.openapi.project.Project ideaProject = ProjectHelper.toIdeaProject(myMpsProject);\n\n    // wait until project is fully loaded (if not yet) \n    StartupManager.getInstance(ideaProject).runWhenProjectIsInitialized(new Runnable() {\n      public void run() {\n        // as we use ui, postpone to EDT \n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          public void run() {\n            int result = Messages.showYesNoDialog(myProject, DIALOG_TEXT, \"Migration required\", \"Migrate\", \"Postpone\", null);\n            if (result == Messages.NO) {\n              return;\n            }\n\n            // set flag to execute migration after startup \n            myState.migrationRequired = true;\n            // reload project and start migration assist \n            ProjectManagerEx.getInstance().reloadProject(ideaProject);\n          }\n        });\n      }\n    });\n\n    myMigrationQueued = true;\n  }","id":65411,"modified_method":"private void postponeMigration() {\n    final com.intellij.openapi.project.Project ideaProject = myProject;\n\n    // wait until project is fully loaded (if not yet) \n    StartupManager.getInstance(ideaProject).runWhenProjectIsInitialized(new Runnable() {\n      public void run() {\n        // as we use ui, postpone to EDT \n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          public void run() {\n            int result = Messages.showYesNoDialog(myProject, DIALOG_TEXT, \"Migration Required\", \"Migrate\", \"Postpone\", null);\n            if (result == Messages.NO) {\n              return;\n            }\n\n            VirtualFileUtils.refreshSynchronouslyRecursively(myProject.getBaseDir());\n            VirtualFileManager.getInstance().asyncRefresh(new Runnable() {\n              public void run() {\n                ApplicationManager.getApplication().invokeLater(new Runnable() {\n                  public void run() {\n                    ReloadManager.getInstance().flush();\n                    // set flag to execute migration after startup \n                    myState.migrationRequired = true;\n                    // reload project and start migration assist \n                    ProjectManagerEx.getInstance().reloadProject(ideaProject);\n                  }\n                });\n              }\n            });\n          }\n        });\n      }\n    });\n\n    myMigrationQueued = true;\n  }","commit_id":"9464875e63d54bfe50417543a7171791e03beba6","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void projectOpened() {\n    StartupManager.getInstance(myProject).runWhenProjectIsInitialized(new DumbAwareRunnable() {\n      public void run() {\n        VirtualFile file = ProjectBaseDirectory.getInstance(myProject).getBaseDir(myProject.getBaseDir());\n        if (myVcsManager.needAutodetectMappings()) {\n          AbstractVcs vcs = myVcsManager.findVersioningVcs(file);\n          if (vcs != null && vcs != myVcsManager.getVcsFor(file)) {\n            myVcsManager.removeDirectoryMapping(new VcsDirectoryMapping(\"\", \"\"));\n            myVcsManager.setAutoDirectoryMapping(file.getPath(), vcs.getName());\n            myVcsManager.cleanupMappings();\n            myVcsManager.updateActiveVcss();\n          }\n        }\n      }\n    });\n  }","id":65412,"modified_method":"public void projectOpened() {\n    StartupManager.getInstance(myProject).runWhenProjectIsInitialized(new DumbAwareRunnable() {\n      public void run() {\n        AppUIUtil.invokeLaterIfProjectAlive(myProject, new DumbAwareRunnable() {\n          @Override\n          public void run() {\n            VirtualFile file = ProjectBaseDirectory.getInstance(myProject).getBaseDir(myProject.getBaseDir());\n            if (myVcsManager.needAutodetectMappings()) {\n              AbstractVcs vcs = myVcsManager.findVersioningVcs(file);\n              if (vcs != null && vcs != myVcsManager.getVcsFor(file)) {\n                myVcsManager.removeDirectoryMapping(new VcsDirectoryMapping(\"\", \"\"));\n                myVcsManager.setAutoDirectoryMapping(file.getPath(), vcs.getName());\n                myVcsManager.cleanupMappings();\n                myVcsManager.updateActiveVcss();\n              }\n            }\n          }\n        });\n      }\n    });\n  }","commit_id":"3819161621a3fabec79c4fa742a9bb6bf6367385","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    public static String readFile(@NotNull String path) throws IOException {\n        @SuppressWarnings(\"IOResourceOpenedButNotSafelyClosed\")\n        FileInputStream stream = new FileInputStream(new File(path));\n        return FileUtil.loadTextAndClose(stream);\n    }","id":65413,"modified_method":"@NotNull\n    public static String readFile(@NotNull String path) throws IOException {\n        return FileUtil.loadFile(new File(path), /*convertLineSeparators = */ true);\n    }","commit_id":"23922c138730f03e78ccf4c3b0ab939315096a31","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private List<JetFile> traverseArchive(@NotNull ZipFile file) throws IOException {\n        List<JetFile> result = Lists.newArrayList();\n        Enumeration<? extends ZipEntry> zipEntries = file.entries();\n        while (zipEntries.hasMoreElements()) {\n            ZipEntry entry = zipEntries.nextElement();\n            if (!entry.isDirectory() && entry.getName().endsWith(\".kt\")) {\n                InputStream stream = file.getInputStream(entry);\n                String text = FileUtil.loadTextAndClose(stream);\n                JetFile jetFile = JetPsiFactory.createFile(getProject(), entry.getName(), text);\n                jetFile.putUserData(EXTERNAL_MODULE_NAME, UNKNOWN_EXTERNAL_MODULE_NAME);\n                result.add(jetFile);\n            }\n        }\n        return result;\n    }","id":65414,"modified_method":"@NotNull\n    private List<JetFile> traverseArchive(@NotNull ZipFile file) throws IOException {\n        List<JetFile> result = Lists.newArrayList();\n        Enumeration<? extends ZipEntry> zipEntries = file.entries();\n        while (zipEntries.hasMoreElements()) {\n            ZipEntry entry = zipEntries.nextElement();\n            if (!entry.isDirectory() && entry.getName().endsWith(\".kt\")) {\n                InputStream stream = file.getInputStream(entry);\n                String text = StringUtil.convertLineSeparators(FileUtil.loadTextAndClose(stream));\n                JetFile jetFile = JetPsiFactory.createFile(getProject(), entry.getName(), text);\n                jetFile.putUserData(EXTERNAL_MODULE_NAME, UNKNOWN_EXTERNAL_MODULE_NAME);\n                result.add(jetFile);\n            }\n        }\n        return result;\n    }","commit_id":"23922c138730f03e78ccf4c3b0ab939315096a31","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static void loadLibFiles(@NotNull Enumeration<URL> resources,\n            @NotNull Set<URL> urlsLoaded,\n            @NotNull List<JetFile> libFiles,\n            @NotNull Project project)\n            throws IOException {\n        while (resources.hasMoreElements()) {\n            URL url = resources.nextElement();\n            if (url != null) {\n                if (urlsLoaded.add(url)) {\n                    BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                    try {\n                        while (true) {\n                            String line = reader.readLine();\n                            if (line == null) {\n                                break;\n                            }\n                            else {\n                                line = line.trim();\n                                if (line.length() == 0 || line.startsWith(\"#\")) continue;\n                                // lets try to discover the file\n                                InputStream stream = loadClasspathResource(line);\n                                if (stream != null) {\n                                    String text = FileUtil.loadTextAndClose(stream);\n                                    libFiles.add(JetPsiFactory.createFile(project, line, text));\n                                }\n                            }\n                        }\n                    }\n                    finally {\n                        reader.close();\n                    }\n                }\n            }\n        }\n    }","id":65415,"modified_method":"private static void loadLibFiles(@NotNull Enumeration<URL> resources,\n            @NotNull Set<URL> urlsLoaded,\n            @NotNull List<JetFile> libFiles,\n            @NotNull Project project)\n            throws IOException {\n        while (resources.hasMoreElements()) {\n            URL url = resources.nextElement();\n            if (url != null) {\n                if (urlsLoaded.add(url)) {\n                    BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                    try {\n                        while (true) {\n                            String line = reader.readLine();\n                            if (line == null) {\n                                break;\n                            }\n                            else {\n                                line = line.trim();\n                                if (line.length() == 0 || line.startsWith(\"#\")) continue;\n                                // lets try to discover the file\n                                InputStream stream = loadClasspathResource(line);\n                                if (stream != null) {\n                                    String text = StringUtil.convertLineSeparators(FileUtil.loadTextAndClose(stream));\n                                    libFiles.add(JetPsiFactory.createFile(project, line, text));\n                                }\n                            }\n                        }\n                    }\n                    finally {\n                        reader.close();\n                    }\n                }\n            }\n        }\n    }","commit_id":"23922c138730f03e78ccf4c3b0ab939315096a31","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void checkHasNoToStringCalls() throws IOException {\n        for (EcmaVersion ecmaVersion : DEFAULT_ECMA_VERSIONS) {\n            String filePath = getOutputFilePath(getTestName(true) + \".kt\", ecmaVersion);\n            //noinspection IOResourceOpenedButNotSafelyClosed\n            String text = loadTextAndClose(new FileInputStream(filePath));\n            assertFalse(filePath + \" should not contain toString calls\", text.contains(\"toString\"));\n        }\n    }","id":65416,"modified_method":"private void checkHasNoToStringCalls() throws IOException {\n        for (EcmaVersion ecmaVersion : DEFAULT_ECMA_VERSIONS) {\n            String filePath = getOutputFilePath(getTestName(true) + \".kt\", ecmaVersion);\n            String text = FileUtil.loadFile(new File(filePath), /*convertLineSeparators = */ true);\n            assertFalse(filePath + \" should not contain toString calls\", text.contains(\"toString\"));\n        }\n    }","commit_id":"23922c138730f03e78ccf4c3b0ab939315096a31","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n   * Reads the content of the resource and return it as a String.\n   * <p/>Uses the class loader that loaded this class to find the resource in its classpath.\n   *\n   * @param resource the resource name. Will lookup using the classpath.\n   * @return the content if the resource\n   * @throws IOException error reading the file.\n   */\n  private static String readFile(String resource) throws IOException {\n    BufferedInputStream in = new BufferedInputStream(TemplateResourceLocator.class.getResourceAsStream(resource));\n    return FileUtil.loadTextAndClose(new InputStreamReader(in, \"UTF-8\"));\n  }","id":65417,"modified_method":"/**\n   * Reads the content of the resource and return it as a String.\n   * <p/>Uses the class loader that loaded this class to find the resource in its classpath.\n   *\n   * @param resource the resource name. Will lookup using the classpath.\n   * @return the content if the resource\n   * @throws IOException error reading the file.\n   */\n  private static String readFile(String resource) throws IOException {\n    BufferedInputStream in = new BufferedInputStream(TemplateResourceLocator.class.getResourceAsStream(resource));\n    return StringUtil.convertLineSeparators(FileUtil.loadTextAndClose(new InputStreamReader(in, \"UTF-8\")));\n  }","commit_id":"dc0d79df41452755066004a12cdf55ae304791eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void prepareServiceContext(\n\t\t\tServiceContext serviceContext, FileEntry fileEntry)\n\t\tthrows SystemException {\n\n\t\tlong[] assetCategoryIds = AssetCategoryLocalServiceUtil.getCategoryIds(\n\t\t\tDLFileEntryConstants.getClassName(), fileEntry.getFileEntryId());\n\n\t\tString[] assetTagNames = AssetTagLocalServiceUtil.getTagNames(\n\t\t\tDLFileEntryConstants.getClassName(), fileEntry.getFileEntryId());\n\n\t\tAssetEntry entry = AssetEntryLocalServiceUtil.fetchEntry(\n\t\t\tDLFileEntryConstants.getClassName(), fileEntry.getFileEntryId());\n\n\t\tList<AssetLink> assetLinks = AssetLinkLocalServiceUtil.getDirectLinks(\n\t\t\tentry.getEntryId(), AssetLinkConstants.TYPE_RELATED);\n\n\t\tlong[] assetLinkEntryIds = StringUtil.split(\n\t\t\tListUtil.toString(assetLinks, AssetLink.ENTRY_ID2_ACCESSOR), 0L);\n\n\t\tserviceContext.setAssetCategoryIds(assetCategoryIds);\n\t\tserviceContext.setAssetLinkEntryIds(assetLinkEntryIds);\n\t\tserviceContext.setAssetTagNames(assetTagNames);\n\t\tserviceContext.setExpandoBridgeAttributes(\n\t\t\tfileEntry.getExpandoBridge().getAttributes());\n\t}","id":65418,"modified_method":"protected void prepareServiceContext(\n\t\t\tServiceContext serviceContext, FileEntry fileEntry)\n\t\tthrows SystemException {\n\n\t\tString className = DLFileEntryConstants.getClassName();\n\n\t\tlong[] assetCategoryIds = AssetCategoryLocalServiceUtil.getCategoryIds(\n\t\t\tclassName, fileEntry.getFileEntryId());\n\n\t\tserviceContext.setAssetCategoryIds(assetCategoryIds);\n\n\t\tAssetEntry assetEntry = AssetEntryLocalServiceUtil.fetchEntry(\n\t\t\tclassName, fileEntry.getFileEntryId());\n\n\t\tList<AssetLink> assetLinks = AssetLinkLocalServiceUtil.getLinks(\n\t\t\tassetEntry.getEntryId());\n\n\t\tlong[] assetLinkEntryIds = StringUtil.split(\n\t\t\tListUtil.toString(assetLinks, AssetLink.ENTRY_ID2_ACCESSOR), 0L);\n\n\t\tserviceContext.setAssetLinkEntryIds(assetLinkEntryIds);\n\n\t\tString[] assetTagNames = AssetTagLocalServiceUtil.getTagNames(\n\t\t\tclassName, fileEntry.getFileEntryId());\n\n\t\tserviceContext.setAssetTagNames(assetTagNames);\n\n\t\tExpandoBridge expandoBridge = fileEntry.getExpandoBridge();\n\n\t\tserviceContext.setExpandoBridgeAttributes(\n\t\t\texpandoBridge.getAttributes());\n\t}","commit_id":"4d76bfa94f0e8d9b0b4af9d553320e5489135d6f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @throws XMLStreamException\n     */\n    public void setupValidation(XMLStreamReader reader, ServiceInfo serviceInfo) throws XMLStreamException {\n        // Gosh, this is bad, but I don't know a better solution, unless we're willing\n        // to require the stax2 API no matter what.\n        XMLStreamReader effectiveReader = reader;\n        if (effectiveReader instanceof DepthXMLStreamReader) {\n            effectiveReader = ((DepthXMLStreamReader)reader).getReader();\n        }\n        final XMLStreamReader2 reader2 = (XMLStreamReader2)effectiveReader;\n        XMLValidationSchema vs = getValidator(serviceInfo);\n        reader2.setValidationProblemHandler(new ValidationProblemHandler() {\n\n            public void reportProblem(XMLValidationProblem problem) throws XMLValidationException {\n                throw new Fault(new Message(\"READ_VALIDATION_ERROR\", LOG, problem.getMessage()),\n                                Fault.FAULT_CODE_CLIENT);\n            }\n        });\n        reader2.validateAgainst(vs);\n    }","id":65419,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @throws XMLStreamException\n     */\n    public boolean setupValidation(XMLStreamReader reader, Endpoint endpoint, ServiceInfo serviceInfo) \n        throws XMLStreamException {\n        \n        // Gosh, this is bad, but I don't know a better solution, unless we're willing\n        // to require the stax2 API no matter what.\n        XMLStreamReader effectiveReader = reader;\n        if (effectiveReader instanceof DepthXMLStreamReader) {\n            effectiveReader = ((DepthXMLStreamReader)reader).getReader();\n        }\n        final XMLStreamReader2 reader2 = (XMLStreamReader2)effectiveReader;\n        XMLValidationSchema vs = getValidator(endpoint, serviceInfo);\n        if (vs == null) {\n            return false;\n        }\n        reader2.setValidationProblemHandler(new ValidationProblemHandler() {\n\n            public void reportProblem(XMLValidationProblem problem) throws XMLValidationException {\n                throw new Fault(new Message(\"READ_VALIDATION_ERROR\", LOG, problem.getMessage()),\n                                Fault.FAULT_CODE_CLIENT);\n            }\n        });\n        reader2.validateAgainst(vs);\n        return true;\n    }","commit_id":"4ef48b93801110085ca9a95b715a32618f477f4b","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Create woodstox validator for a schema set.\n     * \n     * @param schemas\n     * @return\n     * @throws XMLStreamException\n     */\n    private XMLValidationSchema getValidator(ServiceInfo serviceInfo) throws XMLStreamException {\n        Map<String, EmbeddedSchema> sources = new TreeMap<String, EmbeddedSchema>();\n\n        for (SchemaInfo schemaInfo : serviceInfo.getSchemas()) {\n            XmlSchema sch = schemaInfo.getSchema();\n            String uri = sch.getTargetNamespace();\n            if (XMLConstants.W3C_XML_SCHEMA_NS_URI.equals(uri)) {\n                continue;\n            }\n            LOG.info(uri);\n\n            Element serialized = schemaInfo.getElement();\n            String schemaSystemId = sch.getSourceURI();\n            if (null == schemaSystemId) {\n                schemaSystemId = sch.getTargetNamespace();\n            }\n\n            EmbeddedSchema embeddedSchema = new EmbeddedSchema(schemaSystemId, serialized);\n            sources.put(sch.getTargetNamespace(), embeddedSchema);\n        }\n\n        W3CMultiSchemaFactory factory = new W3CMultiSchemaFactory();\n        XMLValidationSchema vs;\n        // I don't think that we need the baseURI.\n        vs = factory.loadSchemas(null, sources);\n        return vs;\n    }","id":65420,"modified_method":"/**\n     * Create woodstox validator for a schema set.\n     * \n     * @param schemas\n     * @return\n     * @throws XMLStreamException\n     */\n    private XMLValidationSchema getValidator(Endpoint endpoint, ServiceInfo serviceInfo) throws XMLStreamException {\n        synchronized (endpoint) {\n            XMLValidationSchema ret = (XMLValidationSchema)endpoint.get(KEY);\n            if (ret == null) {\n                if (endpoint.containsKey(KEY)) {\n                    return null;\n                }\n                Map<String, EmbeddedSchema> sources = new TreeMap<String, EmbeddedSchema>();\n        \n                for (SchemaInfo schemaInfo : serviceInfo.getSchemas()) {\n                    XmlSchema sch = schemaInfo.getSchema();\n                    String uri = sch.getTargetNamespace();\n                    if (XMLConstants.W3C_XML_SCHEMA_NS_URI.equals(uri)) {\n                        continue;\n                    }\n                    LOG.info(uri);\n        \n                    Element serialized = schemaInfo.getElement();\n                    String schemaSystemId = sch.getSourceURI();\n                    if (null == schemaSystemId) {\n                        schemaSystemId = sch.getTargetNamespace();\n                    }\n        \n                    EmbeddedSchema embeddedSchema = new EmbeddedSchema(schemaSystemId, serialized);\n                    sources.put(sch.getTargetNamespace(), embeddedSchema);\n                }\n        \n                W3CMultiSchemaFactory factory = new W3CMultiSchemaFactory();\n                // I don't think that we need the baseURI.\n                try {\n                    ret = factory.loadSchemas(null, sources);\n                    endpoint.put(KEY, ret);\n                } catch (XMLStreamException ex) {\n                    LOG.log(Level.INFO, \"Problem loading schemas. Falling back to slower method.\", ret);\n                    endpoint.put(KEY, null);\n                }\n            }\n            return ret;\n        }\n    }","commit_id":"4ef48b93801110085ca9a95b715a32618f477f4b","url":"https://github.com/apache/cxf"},{"original_method":"public void setupValidation(XMLStreamWriter writer, ServiceInfo serviceInfo) throws XMLStreamException {\n        XMLStreamWriter2 writer2 = (XMLStreamWriter2)writer;\n        XMLValidationSchema vs = getValidator(serviceInfo);\n        writer2.setValidationProblemHandler(new ValidationProblemHandler() {\n\n            public void reportProblem(XMLValidationProblem problem) throws XMLValidationException {\n                throw new Fault(problem.getMessage(), LOG);\n            }\n        });\n        writer2.validateAgainst(vs);\n    }","id":65421,"modified_method":"public boolean setupValidation(XMLStreamWriter writer, Endpoint endpoint, ServiceInfo serviceInfo) \n        throws XMLStreamException {\n        \n        XMLStreamWriter2 writer2 = (XMLStreamWriter2)writer;\n        XMLValidationSchema vs = getValidator(endpoint, serviceInfo);\n        if (vs == null) {\n            return false;\n        }\n        writer2.setValidationProblemHandler(new ValidationProblemHandler() {\n\n            public void reportProblem(XMLValidationProblem problem) throws XMLValidationException {\n                throw new Fault(problem.getMessage(), LOG);\n            }\n        });\n        writer2.validateAgainst(vs);\n        return true;\n    }","commit_id":"4ef48b93801110085ca9a95b715a32618f477f4b","url":"https://github.com/apache/cxf"},{"original_method":"private void setSchemaInMessage(Message message, XMLStreamReader reader) throws XMLStreamException  {\n        if (ServiceUtils.isSchemaValidationEnabled(SchemaValidationType.IN, message)) {\n            try {\n                WoodstoxValidationImpl mgr = new WoodstoxValidationImpl();\n                if (mgr.canValidate()) {\n                    mgr.setupValidation(reader, message.getExchange().getService().getServiceInfos().get(0));\n                }\n            } catch (Throwable t) {\n                //likely no MSV or similar\n                LOG.log(Level.FINE, \"Problem initializing MSV validation\", t);\n            }\n        }\n    }","id":65422,"modified_method":"private void setSchemaInMessage(Message message, XMLStreamReader reader) throws XMLStreamException  {\n        if (ServiceUtils.isSchemaValidationEnabled(SchemaValidationType.IN, message)) {\n            try {\n                WoodstoxValidationImpl mgr = new WoodstoxValidationImpl();\n                if (mgr.canValidate()) {\n                    mgr.setupValidation(reader, message.getExchange().getEndpoint(),\n                                        message.getExchange().getService().getServiceInfos().get(0));\n                }\n            } catch (Throwable t) {\n                //likely no MSV or similar\n                LOG.log(Level.FINE, \"Problem initializing MSV validation\", t);\n            }\n        }\n    }","commit_id":"4ef48b93801110085ca9a95b715a32618f477f4b","url":"https://github.com/apache/cxf"},{"original_method":"private void setSchemaInMessage(Message message, XMLStreamWriter writer) throws XMLStreamException  {\n        if (ServiceUtils.isSchemaValidationEnabled(SchemaValidationType.OUT, message)) {\n            try {\n                WoodstoxValidationImpl mgr = new WoodstoxValidationImpl();\n                if (mgr.canValidate()) {\n                    mgr.setupValidation(writer, message.getExchange().getService().getServiceInfos().get(0));\n                }\n            } catch (Throwable t) {\n                //likely no MSV or similar\n                LOG.log(Level.FINE, \"Problem initializing MSV validation\", t);\n            }\n        }\n    }","id":65423,"modified_method":"private void setSchemaInMessage(Message message, XMLStreamWriter writer) throws XMLStreamException  {\n        if (ServiceUtils.isSchemaValidationEnabled(SchemaValidationType.OUT, message)) {\n            try {\n                WoodstoxValidationImpl mgr = new WoodstoxValidationImpl();\n                if (mgr.canValidate()) {\n                    mgr.setupValidation(writer, message.getExchange().getEndpoint(),\n                                        message.getExchange().getService().getServiceInfos().get(0));\n                }\n            } catch (Throwable t) {\n                //likely no MSV or similar\n                LOG.log(Level.FINE, \"Problem initializing MSV validation\", t);\n            }\n        }\n    }","commit_id":"4ef48b93801110085ca9a95b715a32618f477f4b","url":"https://github.com/apache/cxf"},{"original_method":"public void setupValidation(XMLStreamWriter writer, ServiceInfo serviceInfo) throws XMLStreamException {\n        if (utils != null && writer != null) {\n            utils.setupValidation(writer, serviceInfo);\n        }\n    }","id":65424,"modified_method":"public void setupValidation(XMLStreamWriter writer, \n                                Endpoint endpoint,\n                                ServiceInfo serviceInfo) throws XMLStreamException {\n        if (utils != null && writer != null && !utils.setupValidation(writer, endpoint, serviceInfo)) {\n            utils = null;\n        }\n    }","commit_id":"4ef48b93801110085ca9a95b715a32618f477f4b","url":"https://github.com/apache/cxf"},{"original_method":"/** {@inheritDoc}\n     * @throws XMLStreamException */\n    public void setupValidation(XMLStreamReader reader, \n                                ServiceInfo serviceInfo) throws XMLStreamException {\n        if (utils != null && reader != null) {\n            utils.setupValidation(reader, serviceInfo);\n        }\n    }","id":65425,"modified_method":"/** {@inheritDoc}\n     * @throws XMLStreamException */\n    public void setupValidation(XMLStreamReader reader, \n                                Endpoint endpoint,\n                                ServiceInfo serviceInfo) throws XMLStreamException {\n        if (utils != null && reader != null && !utils.setupValidation(reader, endpoint, serviceInfo)) {\n            utils = null;\n        }\n    }","commit_id":"4ef48b93801110085ca9a95b715a32618f477f4b","url":"https://github.com/apache/cxf"},{"original_method":"private Element validate(XMLStreamReader input) throws XMLStreamException, IOException {\n        DOMSource ds = read(input);\n        Element rootElement = null;\n        if (ds.getNode() instanceof Document) {\n            rootElement = ((Document)ds.getNode()).getDocumentElement();\n        } else {\n            rootElement = (Element)ds.getNode();\n        }\n\n        WoodstoxValidationImpl impl = new WoodstoxValidationImpl();\n        XMLStreamWriter nullWriter = null;\n        boolean canValidate = impl.canValidate();\n        if (canValidate) {\n            nullWriter = StaxUtils.createXMLStreamWriter(new NUllOutputStream());\n            try {\n                impl.setupValidation(nullWriter, message.getExchange().getService().getServiceInfos().get(0));\n            } catch (Throwable t) {\n                LOG.log(Level.FINE, \"Trouble setting up validation.\", t);\n                canValidate = false;\n            }\n        }\n        if (canValidate) {\n            //Can use the MSV libs and woodstox to handle the schema validation during \n            //parsing and processing.   Much faster and single traversal\n            //filter xop node\n            XMLStreamReader reader = StaxUtils.createXMLStreamReader(ds);\n            XMLStreamReader filteredReader = \n                StaxUtils.createFilteredReader(reader, \n                                               new StaxStreamFilter(new QName[] {XOP}));\n            \n            StaxUtils.copy(filteredReader, nullWriter);\n        } else {\n            //MSV not available, use a slower method of cloning the data, replace the xop's, validate\n            LOG.fine(\"NO_MSV_AVAILABLE\");\n            Element newElement = rootElement;\n            if (DOMUtils.hasElementWithName(rootElement, \"http://www.w3.org/2004/08/xop/include\", \"Include\")) {\n                newElement = (Element)rootElement.cloneNode(true);\n                List<Element> elems = DOMUtils.findAllElementsByTagNameNS(newElement, \n                                                                          \"http://www.w3.org/2004/08/xop/include\",\n                                                                          \"Include\");\n                for (Element include : elems) {\n                    Node parentNode = include.getParentNode();\n                    parentNode.removeChild(include);\n                    String cid = DOMUtils.getAttribute(include, \"href\");\n                    //set the fake base64Binary to validate instead of reading the attachment from message\n                    parentNode.setTextContent(javax.xml.bind.DatatypeConverter.printBase64Binary(cid.getBytes()));\n                }\n            }\n            try {\n                schema.newValidator().validate(new DOMSource(newElement));\n            } catch (SAXException e) {\n                throw new XMLStreamException(e);\n            }\n        }\n        return rootElement;        \n    }","id":65426,"modified_method":"private Element validate(XMLStreamReader input) throws XMLStreamException, IOException {\n        DOMSource ds = read(input);\n        Element rootElement = null;\n        if (ds.getNode() instanceof Document) {\n            rootElement = ((Document)ds.getNode()).getDocumentElement();\n        } else {\n            rootElement = (Element)ds.getNode();\n        }\n\n        WoodstoxValidationImpl impl = new WoodstoxValidationImpl();\n        XMLStreamWriter nullWriter = null;\n        if (impl.canValidate()) {\n            nullWriter = StaxUtils.createXMLStreamWriter(new NUllOutputStream());\n            impl.setupValidation(nullWriter, message.getExchange().getEndpoint(),\n                                 message.getExchange().getService().getServiceInfos().get(0));\n        }\n        //check if the impl can still validate after the setup, possible issue loading schemas or similar\n        if (impl.canValidate()) {\n            //Can use the MSV libs and woodstox to handle the schema validation during \n            //parsing and processing.   Much faster and single traversal\n            //filter xop node\n            XMLStreamReader reader = StaxUtils.createXMLStreamReader(ds);\n            XMLStreamReader filteredReader = \n                StaxUtils.createFilteredReader(reader, \n                                               new StaxStreamFilter(new QName[] {XOP}));\n            \n            StaxUtils.copy(filteredReader, nullWriter);\n        } else {\n            //MSV not available, use a slower method of cloning the data, replace the xop's, validate\n            LOG.fine(\"NO_MSV_AVAILABLE\");\n            Element newElement = rootElement;\n            if (DOMUtils.hasElementWithName(rootElement, \"http://www.w3.org/2004/08/xop/include\", \"Include\")) {\n                newElement = (Element)rootElement.cloneNode(true);\n                List<Element> elems = DOMUtils.findAllElementsByTagNameNS(newElement, \n                                                                          \"http://www.w3.org/2004/08/xop/include\",\n                                                                          \"Include\");\n                for (Element include : elems) {\n                    Node parentNode = include.getParentNode();\n                    parentNode.removeChild(include);\n                    String cid = DOMUtils.getAttribute(include, \"href\");\n                    //set the fake base64Binary to validate instead of reading the attachment from message\n                    parentNode.setTextContent(javax.xml.bind.DatatypeConverter.printBase64Binary(cid.getBytes()));\n                }\n            }\n            try {\n                schema.newValidator().validate(new DOMSource(newElement));\n            } catch (SAXException e) {\n                throw new XMLStreamException(e);\n            }\n        }\n        return rootElement;        \n    }","commit_id":"4ef48b93801110085ca9a95b715a32618f477f4b","url":"https://github.com/apache/cxf"},{"original_method":"private Element validate(XMLStreamReader input) throws XMLStreamException {\n        DOMSource ds = read(input);\n        Element rootElement = null;\n        if (ds.getNode() instanceof Document) {\n            rootElement = ((Document)ds.getNode()).getDocumentElement();\n        } else {\n            rootElement = (Element)ds.getNode();\n        }\n\n        //filter xop node\n        XMLStreamReader reader = StaxUtils.createXMLStreamReader(ds);\n        XMLStreamReader filteredReader = \n            StaxUtils.createFilteredReader(reader, \n                                           new StaxStreamFilter(new QName[] {XOP}));\n        \n        XMLStreamWriter nullWriter = StaxUtils.createXMLStreamWriter(new NUllOutputStream());\n        //TODO: expensive to create WoodstoxValidationImpl ?\n        WoodstoxValidationImpl impl = new WoodstoxValidationImpl();\n        if (impl.canValidate()) {\n            impl.setupValidation(nullWriter, message.getExchange().getService().getServiceInfos().get(0));\n            StaxUtils.copy(filteredReader, nullWriter);\n        } else {\n            throw new Fault(\"COULD_NOT_VALIDATE_XML_STREAM\", LOG);\n        }\n        return rootElement;        \n    }","id":65427,"modified_method":"private Element validate(XMLStreamReader input) throws XMLStreamException, IOException {\n        DOMSource ds = read(input);\n        Element rootElement = null;\n        if (ds.getNode() instanceof Document) {\n            rootElement = ((Document)ds.getNode()).getDocumentElement();\n        } else {\n            rootElement = (Element)ds.getNode();\n        }\n\n        WoodstoxValidationImpl impl = new WoodstoxValidationImpl();\n        if (impl.canValidate()) {\n            //Can use the MSV libs and woodstox to handle the schema validation during \n            //parsing and processing.   Much faster and single traversal\n            //filter xop node\n            XMLStreamReader reader = StaxUtils.createXMLStreamReader(ds);\n            XMLStreamReader filteredReader = \n                StaxUtils.createFilteredReader(reader, \n                                               new StaxStreamFilter(new QName[] {XOP}));\n            \n            XMLStreamWriter nullWriter = StaxUtils.createXMLStreamWriter(new NUllOutputStream());\n            \n            impl.setupValidation(nullWriter, message.getExchange().getService().getServiceInfos().get(0));\n            StaxUtils.copy(filteredReader, nullWriter);\n        } else {\n            //MSV not available, use a slower method of cloning the data, replace the xop's, validate\n            LOG.fine(\"NO_MSV_AVAILABLE\");\n            if (DOMUtils.hasElementWithName(rootElement, \"http://www.w3.org/2004/08/xop/include\", \"Include\")) {\n                Element newElement = (Element)rootElement.cloneNode(true);\n                List<Element> elems = DOMUtils.findAllElementsByTagNameNS(newElement, \n                                                                          \"http://www.w3.org/2004/08/xop/include\",\n                                                                          \"Include\");\n                for (Element include : elems) {\n                    Node parentNode = include.getParentNode();\n                    parentNode.removeChild(include);\n                    String cid = DOMUtils.getAttribute(include, \"href\");\n                    //set the fake base64Binary to validate instead of reading the attachment from message\n                    parentNode.setTextContent(javax.xml.bind.DatatypeConverter.printBase64Binary(cid.getBytes()));\n                }\n                try {\n                    schema.newValidator().validate(new DOMSource(newElement));\n                } catch (SAXException e) {\n                    throw new XMLStreamException(e);\n                }\n            }\n        }\n        return rootElement;        \n    }","commit_id":"9fa2780b617ed626f22d238ed1d3a39186b0f293","url":"https://github.com/apache/cxf"},{"original_method":"public void projectClosed() {\n    assert myInitialized : \"Disposing not initialized component\";\n    assert !myDisposed : \"Double dispose\";\n\n    // clear dangling references to PsiFiles/Documents. SCR#10358\n    myFileStatusMap.markAllFilesDirty();\n\n    stopProcess(false);\n\n    myDisposed = true;\n    myLastSettings = null;\n    myInitialized = false;\n  }","id":65428,"modified_method":"public void projectClosed() {\n    assert myInitialized : \"Disposing not initialized component\";\n    assert !myDisposed : \"Double dispose\";\n\n    stopProcess(false);\n\n    myDisposed = true;\n    myLastSettings = null;\n    myInitialized = false;\n  }","commit_id":"fdc7391d76740de2b9545e431c2916ceab04a4ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@TestOnly\n  public void cleanupAfterTest(boolean forceDispose) {\n    projectClosed();\n    if (forceDispose) {\n      Disposer.dispose(myStatusBarUpdater);\n      myStatusBarUpdater = null;\n      Disposer.dispose(myDaemonListeners);\n      myDaemonListeners = null;\n    }\n    setUpdateByTimerEnabled(false);\n    waitForTermination();\n  }","id":65429,"modified_method":"@TestOnly\n  public void cleanupAfterTest() {\n    projectClosed();\n    Disposer.dispose(myStatusBarUpdater);\n    myStatusBarUpdater = null;\n    Disposer.dispose(myDaemonListeners);\n    myDaemonListeners = null;\n    setUpdateByTimerEnabled(false);\n    waitForTermination();\n  }","commit_id":"fdc7391d76740de2b9545e431c2916ceab04a4ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void globalSchemeChange(EditorColorsScheme scheme) {\n      myDaemonCodeAnalyzer.restart();\n    }","id":65430,"modified_method":"public void globalSchemeChange(EditorColorsScheme scheme) {\n      stopDaemonAndRestartAllFiles();\n    }","commit_id":"fdc7391d76740de2b9545e431c2916ceab04a4ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void profileActivated(Profile oldProfile, Profile profile) {\n      myDaemonCodeAnalyzer.restart();\n    }","id":65431,"modified_method":"public void profileActivated(Profile oldProfile, Profile profile) {\n      stopDaemonAndRestartAllFiles();\n    }","commit_id":"fdc7391d76740de2b9545e431c2916ceab04a4ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void stopDaemon(boolean toRestartAlarm) {\n    myDaemonCodeAnalyzer.stopProcess(toRestartAlarm);\n  }","id":65432,"modified_method":"private void stopDaemon(boolean toRestartAlarm) {\n    myDaemonEventPublisher.daemonCancelEventOccurred();\n    myDaemonCodeAnalyzer.stopProcess(toRestartAlarm);\n  }","commit_id":"fdc7391d76740de2b9545e431c2916ceab04a4ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void profileChanged(Profile profile) {\n      myDaemonCodeAnalyzer.restart();\n    }","id":65433,"modified_method":"public void profileChanged(Profile profile) {\n      stopDaemonAndRestartAllFiles();\n    }","commit_id":"fdc7391d76740de2b9545e431c2916ceab04a4ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void propertyChange(PropertyChangeEvent evt) {\n      if (TodoConfiguration.PROP_TODO_PATTERNS.equals(evt.getPropertyName())) {\n        myDaemonCodeAnalyzer.restart();\n      }\n    }","id":65434,"modified_method":"public void propertyChange(PropertyChangeEvent evt) {\n      if (TodoConfiguration.PROP_TODO_PATTERNS.equals(evt.getPropertyName())) {\n        stopDaemonAndRestartAllFiles();\n      }\n    }","commit_id":"fdc7391d76740de2b9545e431c2916ceab04a4ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void dispose() {\n  }","id":65435,"modified_method":"public void dispose() {\n    LOG.assertTrue(((UserDataHolderEx)myProject).replace(DAEMON_INITIALIZED, Boolean.TRUE, null), \"Daemon listeners already disposed for the project \"+myProject);\n  }","commit_id":"fdc7391d76740de2b9545e431c2916ceab04a4ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DaemonListeners(Project project, DaemonCodeAnalyzerImpl daemonCodeAnalyzer, EditorTracker editorTracker) {\n    myProject = project;\n    myDaemonCodeAnalyzer = daemonCodeAnalyzer;\n\n    final MessageBusConnection connection = myProject.getMessageBus().connect();\n    EditorEventMulticaster eventMulticaster = EditorFactory.getInstance().getEventMulticaster();\n\n    eventMulticaster.addDocumentListener(new DocumentAdapter() {\n      // clearing highlighters before changing document because change can damage editor highlighters drastically, so we'll clear more than necessary\n      public void beforeDocumentChange(final DocumentEvent e) {\n        if (isUnderIgnoredAction(null)) return;\n        Document document = e.getDocument();\n        VirtualFile virtualFile = FileDocumentManager.getInstance().getFile(document);\n        Project project = virtualFile == null ? null : ProjectUtil.guessProjectForFile(virtualFile);\n        if (!worthBothering(document, project)) {\n          return; //no need to stop daemon if something happened in the console\n        }\n        stopDaemon(true);\n        UpdateHighlightersUtil.updateHighlightersByTyping(myProject, e);\n      }\n    }, this);\n\n    eventMulticaster.addCaretListener(new CaretListener() {\n      public void caretPositionChanged(CaretEvent e) {\n        Editor editor = e.getEditor();\n        if (!worthBothering(editor.getDocument(), editor.getProject())) {\n          return; //no need to stop daemon if something happened in the console\n        }\n\n        stopDaemon(true);\n        myDaemonCodeAnalyzer.hideLastIntentionHint();\n      }\n    }, this);\n\n    eventMulticaster.addEditorMouseMotionListener(new MyEditorMouseMotionListener(), this);\n    eventMulticaster.addEditorMouseListener(new MyEditorMouseListener(), this);\n\n    myEditorTracker = editorTracker;\n    EditorTrackerListener editorTrackerListener = new EditorTrackerListener() {\n      private List<Editor> myActiveEditors = Collections.emptyList();\n      public void activeEditorsChanged(@NotNull List<Editor> editors) {\n        List<Editor> activeEditors = myEditorTracker.getActiveEditors();\n        if (!myActiveEditors.equals(activeEditors)) {\n          myActiveEditors = activeEditors;\n          stopDaemon(true);  // do not stop daemon if idea loses/gains focus\n          if (LaterInvocator.isInModalContext()) {\n            // editor appear in modal context, reenable the daemon\n            myDaemonCodeAnalyzer.setUpdateByTimerEnabled(true);\n          }\n        }\n      }\n    };\n    myEditorTracker.addEditorTrackerListener(editorTrackerListener, this);\n\n    EditorFactoryListener editorFactoryListener = new EditorFactoryAdapter() {\n      public void editorCreated(EditorFactoryEvent event) {\n        Editor editor = event.getEditor();\n        Document document = editor.getDocument();\n        if (!worthBothering(document, editor.getProject())) {\n          return;\n        }\n        myDaemonCodeAnalyzer.repaintErrorStripeRenderer(editor);\n      }\n    };\n    EditorFactory.getInstance().addEditorFactoryListener(editorFactoryListener, this);\n\n    PsiDocumentManagerImpl documentManager = (PsiDocumentManagerImpl)PsiDocumentManager.getInstance(myProject);\n    PsiChangeHandler changeHandler = new PsiChangeHandler(myProject, documentManager, EditorFactory.getInstance(),connection,\n                                                          daemonCodeAnalyzer.getFileStatusMap());\n    Disposer.register(this, changeHandler);\n    PsiManager.getInstance(myProject).addPsiTreeChangeListener(changeHandler, changeHandler);\n\n    connection.subscribe(ProjectTopics.PROJECT_ROOTS, new ModuleRootListener() {\n      public void beforeRootsChange(ModuleRootEvent event) {\n      }\n\n      public void rootsChanged(ModuleRootEvent event) {\n        final FileEditor[] editors = FileEditorManager.getInstance(myProject).getSelectedEditors();\n        if (editors.length == 0) return;\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          public void run() {\n            if (myProject.isDisposed()) return;\n            for (FileEditor fileEditor : editors) {\n              if (fileEditor instanceof TextEditor) {\n                myDaemonCodeAnalyzer.repaintErrorStripeRenderer(((TextEditor)fileEditor).getEditor());\n              }\n            }\n          }\n        }, ModalityState.stateForComponent(editors[0].getComponent()));\n      }\n    });\n\n    connection.subscribe(DumbService.DUMB_MODE, new DumbService.DumbModeListener() {\n      public void enteredDumbMode() {\n        myDaemonCodeAnalyzer.restart();\n      }\n\n      public void exitDumbMode() {\n        myDaemonCodeAnalyzer.restart();\n      }\n    });\n\n    connection.subscribe(PowerSaveMode.TOPIC, new PowerSaveMode.Listener() {\n      @Override\n      public void powerSaveStateChanged() {\n        stopDaemon(true);\n      }\n    });\n\n    CommandProcessor.getInstance().addCommandListener(new MyCommandListener(), this);\n    ApplicationListener applicationListener = new MyApplicationListener();\n    ApplicationManager.getApplication().addApplicationListener(applicationListener, this);\n    EditorColorsManager.getInstance().addEditorColorsListener(new MyEditorColorsListener(),this);\n    InspectionProfileManager.getInstance().addProfileChangeListener(new MyProfileChangeListener(), this);\n    TodoConfiguration.getInstance().addPropertyChangeListener(new MyTodoListener(), this);\n    ActionManagerEx.getInstanceEx().addAnActionListener(new MyAnActionListener(), this);\n    VirtualFileManager.getInstance().addVirtualFileListener(new VirtualFileAdapter() {\n      public void propertyChanged(VirtualFilePropertyEvent event) {\n        String propertyName = event.getPropertyName();\n        if (VirtualFile.PROP_NAME.equals(propertyName)) {\n          myDaemonCodeAnalyzer.restart();\n          PsiFile psiFile = PsiManager.getInstance(myProject).findFile(event.getFile());\n          if (psiFile != null && !myDaemonCodeAnalyzer.isHighlightingAvailable(psiFile)) {\n            Document document = FileDocumentManager.getInstance().getCachedDocument(event.getFile());\n            if (document != null) {\n              // highlight markers no more\n              //todo clear all highlights regardless the pass id\n\n              // Here color scheme required for TextEditorFields, as far as I understand this\n              // code related to standard file editors, which always use Global color scheme,\n              // thus we can pass null here.\n              final EditorColorsScheme editorColorScheme = null;\n\n              UpdateHighlightersUtil.setHighlightersToEditor(myProject, document, 0, document.getTextLength(),\n                                                             Collections.<HighlightInfo>emptyList(),\n                                                             editorColorScheme,\n                                                             Pass.UPDATE_ALL);\n            }\n          }\n        }\n        if (!propertyName.equals(PsiTreeChangeEvent.PROP_WRITABLE)) {\n          stopDaemon(true);\n        }\n      }\n    }, this);\n\n    ((EditorEventMulticasterEx)eventMulticaster).addErrorStripeListener(new ErrorStripeHandler(myProject), this);\n\n    final NamedScopesHolder[] holders = NamedScopesHolder.getAllNamedScopeHolders(project);\n    NamedScopesHolder.ScopeListener scopeListener = new NamedScopesHolder.ScopeListener() {\n      public void scopesChanged() {\n        myDaemonCodeAnalyzer.reloadScopes();\n      }\n    };\n    for (NamedScopesHolder holder : holders) {\n      holder.addScopeListener(scopeListener);\n    }\n\n    ModalityStateListener modalityStateListener = new ModalityStateListener() {\n      public void beforeModalityStateChanged(boolean entering) {\n        // before showing dialog we are in non-modal context yet, and before closing dialog we are still in modal context\n        boolean inModalContext = LaterInvocator.isInModalContext();\n        stopDaemon(inModalContext);\n        myDaemonCodeAnalyzer.setUpdateByTimerEnabled(inModalContext);\n      }\n    };\n    LaterInvocator.addModalityStateListener(modalityStateListener,this);\n  }","id":65436,"modified_method":"public DaemonListeners(Project project, DaemonCodeAnalyzerImpl daemonCodeAnalyzer, EditorTracker editorTracker) {\n    myProject = project;\n    myDaemonCodeAnalyzer = daemonCodeAnalyzer;\n    LOG.assertTrue(((UserDataHolderEx)myProject).replace(DAEMON_INITIALIZED, null, Boolean.TRUE), \"Daemon listeners already initialized for the project \"+myProject);\n\n    MessageBus messageBus = myProject.getMessageBus();\n    myDaemonEventPublisher = messageBus.syncPublisher(DaemonCodeAnalyzer.DAEMON_EVENT_TOPIC);\n    final MessageBusConnection connection = messageBus.connect();\n\n    EditorEventMulticaster eventMulticaster = EditorFactory.getInstance().getEventMulticaster();\n\n    eventMulticaster.addDocumentListener(new DocumentAdapter() {\n      // clearing highlighters before changing document because change can damage editor highlighters drastically, so we'll clear more than necessary\n      public void beforeDocumentChange(final DocumentEvent e) {\n        if (isUnderIgnoredAction(null)) return;\n        Document document = e.getDocument();\n        VirtualFile virtualFile = FileDocumentManager.getInstance().getFile(document);\n        Project project = virtualFile == null ? null : ProjectUtil.guessProjectForFile(virtualFile);\n        if (!worthBothering(document, project)) {\n          return; //no need to stop daemon if something happened in the console\n        }\n        stopDaemon(true);\n        UpdateHighlightersUtil.updateHighlightersByTyping(myProject, e);\n      }\n    }, this);\n\n    eventMulticaster.addCaretListener(new CaretListener() {\n      public void caretPositionChanged(CaretEvent e) {\n        Editor editor = e.getEditor();\n        if (!worthBothering(editor.getDocument(), editor.getProject())) {\n          return; //no need to stop daemon if something happened in the console\n        }\n\n        stopDaemon(true);\n        myDaemonCodeAnalyzer.hideLastIntentionHint();\n      }\n    }, this);\n\n    eventMulticaster.addEditorMouseMotionListener(new MyEditorMouseMotionListener(), this);\n    eventMulticaster.addEditorMouseListener(new MyEditorMouseListener(), this);\n\n    myEditorTracker = editorTracker;\n    EditorTrackerListener editorTrackerListener = new EditorTrackerListener() {\n      private List<Editor> myActiveEditors = Collections.emptyList();\n      public void activeEditorsChanged(@NotNull List<Editor> editors) {\n        List<Editor> activeEditors = myEditorTracker.getActiveEditors();\n        if (!myActiveEditors.equals(activeEditors)) {\n          myActiveEditors = activeEditors;\n          stopDaemon(true);  // do not stop daemon if idea loses/gains focus\n          if (LaterInvocator.isInModalContext()) {\n            // editor appear in modal context, reenable the daemon\n            myDaemonCodeAnalyzer.setUpdateByTimerEnabled(true);\n          }\n        }\n      }\n    };\n    myEditorTracker.addEditorTrackerListener(editorTrackerListener, this);\n\n    EditorFactoryListener editorFactoryListener = new EditorFactoryAdapter() {\n      public void editorCreated(EditorFactoryEvent event) {\n        Editor editor = event.getEditor();\n        Document document = editor.getDocument();\n        if (!worthBothering(document, editor.getProject())) {\n          return;\n        }\n        myDaemonCodeAnalyzer.repaintErrorStripeRenderer(editor);\n      }\n    };\n    EditorFactory.getInstance().addEditorFactoryListener(editorFactoryListener, this);\n\n    PsiDocumentManagerImpl documentManager = (PsiDocumentManagerImpl)PsiDocumentManager.getInstance(myProject);\n    PsiChangeHandler changeHandler = new PsiChangeHandler(myProject, documentManager, EditorFactory.getInstance(),connection,\n                                                          daemonCodeAnalyzer.getFileStatusMap());\n    Disposer.register(this, changeHandler);\n    PsiManager.getInstance(myProject).addPsiTreeChangeListener(changeHandler, changeHandler);\n\n    connection.subscribe(ProjectTopics.PROJECT_ROOTS, new ModuleRootListener() {\n      public void beforeRootsChange(ModuleRootEvent event) {\n      }\n\n      public void rootsChanged(ModuleRootEvent event) {\n        final FileEditor[] editors = FileEditorManager.getInstance(myProject).getSelectedEditors();\n        if (editors.length == 0) return;\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          public void run() {\n            if (myProject.isDisposed()) return;\n            for (FileEditor fileEditor : editors) {\n              if (fileEditor instanceof TextEditor) {\n                myDaemonCodeAnalyzer.repaintErrorStripeRenderer(((TextEditor)fileEditor).getEditor());\n              }\n            }\n          }\n        }, ModalityState.stateForComponent(editors[0].getComponent()));\n      }\n    });\n\n    connection.subscribe(DumbService.DUMB_MODE, new DumbService.DumbModeListener() {\n      public void enteredDumbMode() {\n        stopDaemonAndRestartAllFiles();\n      }\n\n      public void exitDumbMode() {\n        stopDaemonAndRestartAllFiles();\n      }\n    });\n\n    connection.subscribe(PowerSaveMode.TOPIC, new PowerSaveMode.Listener() {\n      @Override\n      public void powerSaveStateChanged() {\n        stopDaemon(true);\n      }\n    });\n\n\n    CommandProcessor.getInstance().addCommandListener(new MyCommandListener(), this);\n    ApplicationListener applicationListener = new MyApplicationListener();\n    ApplicationManager.getApplication().addApplicationListener(applicationListener, this);\n    EditorColorsManager.getInstance().addEditorColorsListener(new MyEditorColorsListener(),this);\n    InspectionProfileManager.getInstance().addProfileChangeListener(new MyProfileChangeListener(), this);\n    TodoConfiguration.getInstance().addPropertyChangeListener(new MyTodoListener(), this);\n    ActionManagerEx.getInstanceEx().addAnActionListener(new MyAnActionListener(), this);\n    VirtualFileManager.getInstance().addVirtualFileListener(new VirtualFileAdapter() {\n      public void propertyChanged(VirtualFilePropertyEvent event) {\n        String propertyName = event.getPropertyName();\n        if (VirtualFile.PROP_NAME.equals(propertyName)) {\n          stopDaemonAndRestartAllFiles();\n          PsiFile psiFile = PsiManager.getInstance(myProject).findFile(event.getFile());\n          if (psiFile != null && !myDaemonCodeAnalyzer.isHighlightingAvailable(psiFile)) {\n            Document document = FileDocumentManager.getInstance().getCachedDocument(event.getFile());\n            if (document != null) {\n              // highlight markers no more\n              //todo clear all highlights regardless the pass id\n\n              // Here color scheme required for TextEditorFields, as far as I understand this\n              // code related to standard file editors, which always use Global color scheme,\n              // thus we can pass null here.\n              final EditorColorsScheme editorColorScheme = null;\n\n              UpdateHighlightersUtil.setHighlightersToEditor(myProject, document, 0, document.getTextLength(),\n                                                             Collections.<HighlightInfo>emptyList(),\n                                                             editorColorScheme,\n                                                             Pass.UPDATE_ALL);\n            }\n          }\n        }\n        if (!propertyName.equals(PsiTreeChangeEvent.PROP_WRITABLE)) {\n          stopDaemon(true);\n        }\n      }\n    }, this);\n\n    ((EditorEventMulticasterEx)eventMulticaster).addErrorStripeListener(new ErrorStripeHandler(myProject), this);\n\n    final NamedScopesHolder[] holders = NamedScopesHolder.getAllNamedScopeHolders(project);\n    NamedScopesHolder.ScopeListener scopeListener = new NamedScopesHolder.ScopeListener() {\n      public void scopesChanged() {\n        myDaemonCodeAnalyzer.reloadScopes();\n      }\n    };\n    for (NamedScopesHolder holder : holders) {\n      holder.addScopeListener(scopeListener);\n    }\n\n    ModalityStateListener modalityStateListener = new ModalityStateListener() {\n      public void beforeModalityStateChanged(boolean entering) {\n        // before showing dialog we are in non-modal context yet, and before closing dialog we are still in modal context\n        boolean inModalContext = LaterInvocator.isInModalContext();\n        stopDaemon(inModalContext);\n        myDaemonCodeAnalyzer.setUpdateByTimerEnabled(inModalContext);\n      }\n    };\n    LaterInvocator.addModalityStateListener(modalityStateListener,this);\n  }","commit_id":"fdc7391d76740de2b9545e431c2916ceab04a4ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public StatusBarUpdater(Project project) {\n    myProject = project;\n\n    CaretListener caretListener = new CaretListener() {\n      public void caretPositionChanged(CaretEvent e) {\n        updateLater();\n      }\n    };\n    EditorFactory.getInstance().getEventMulticaster().addCaretListener(caretListener, this);\n\n    project.getMessageBus().connect(this).subscribe(FileEditorManagerListener.FILE_EDITOR_MANAGER, new FileEditorManagerAdapter() {\n      @Override\n      public void selectionChanged(FileEditorManagerEvent event) {\n        updateLater();\n      }\n    });\n\n    project.getMessageBus().connect(this).subscribe(DaemonCodeAnalyzer.DAEMON_EVENT_TOPIC, new DaemonCodeAnalyzer.DaemonListener() {\n      @Override\n      public void daemonFinished() {\n        updateLater();\n      }\n    });\n  }","id":65437,"modified_method":"public StatusBarUpdater(Project project) {\n    myProject = project;\n\n    CaretListener caretListener = new CaretListener() {\n      public void caretPositionChanged(CaretEvent e) {\n        updateLater();\n      }\n    };\n    EditorFactory.getInstance().getEventMulticaster().addCaretListener(caretListener, this);\n\n    project.getMessageBus().connect(this).subscribe(FileEditorManagerListener.FILE_EDITOR_MANAGER, new FileEditorManagerAdapter() {\n      @Override\n      public void selectionChanged(FileEditorManagerEvent event) {\n        updateLater();\n      }\n    });\n\n    project.getMessageBus().connect(this).subscribe(DaemonCodeAnalyzer.DAEMON_EVENT_TOPIC, new DaemonCodeAnalyzer.DaemonListener() {\n      @Override\n      public void daemonFinished() {\n        updateLater();\n      }\n\n      @Override\n      public void daemonCancelEventOccurred() {\n      }\n    });\n  }","commit_id":"fdc7391d76740de2b9545e431c2916ceab04a4ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void execute() throws HgCommandException, VcsException {\n    if (StringUtils.isBlank(message)) {\n      throw new HgCommandException(HgVcsMessages.message(\"hg4idea.commit.error.messageEmpty\"));\n    }\n    try {\n      List<String> parameters = new LinkedList<String>();\n      parameters.add(\"--logfile\");\n      parameters.add(saveCommitMessage().getAbsolutePath());\n      for (HgFile hgFile : files) {\n        parameters.add(hgFile.getRelativePath());\n      }\n      ensureSuccess(new HgCommandExecutor(project).executeInCurrentThread(repo, \"commit\", parameters));\n      project.getMessageBus().syncPublisher(HgVcs.REMOTE_TOPIC).update(project);\n    } catch (IOException e) {\n      LOG.info(e);\n    }\n  }","id":65438,"modified_method":"public void execute() throws HgCommandException, VcsException {\n    if (StringUtils.isBlank(message)) {\n      throw new HgCommandException(HgVcsMessages.message(\"hg4idea.commit.error.messageEmpty\"));\n    }\n    try {\n      List<String> parameters = new LinkedList<String>();\n      parameters.add(\"--logfile\");\n      parameters.add(saveCommitMessage().getAbsolutePath());\n      for (HgFile hgFile : files) {\n        parameters.add(hgFile.getRelativePath());\n      }\n      ensureSuccess(new HgCommandExecutor(project).executeInCurrentThread(repo, \"commit\", parameters));\n      final MessageBus messageBus = project.getMessageBus();\n      messageBus.syncPublisher(HgVcs.REMOTE_TOPIC).update(project);\n      messageBus.syncPublisher(HgVcs.BRANCH_TOPIC).update(project);\n    } catch (IOException e) {\n      LOG.info(e);\n    }\n  }","commit_id":"38c0f53af13f5d48e18cdda207fff00acab13177","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ExportDataResponseType exportData( final ExportDataType request ) throws EucalyptusCloudException {\n    final ExportDataResponseType reply = request.getReply();\n    reply.getResponseMetadata().setRequestId( reply.getCorrelationId( ) );\n    final Context ctx = Contexts.lookup();\n    final User requestUser = ctx.getUser( );\n\n    if ( !requestUser.isSystemAdmin() ) {\n      throw new ReportingException( HttpResponseStatus.UNUATHORIZED, ReportingException.NOT_AUTHORIZED, \"Not authorized\");\n    }\n\n    final Conjunction criterion = Restrictions.conjunction();\n    if ( request.getStartDate() != null ) {\n      criterion.add( Restrictions.ge( CREATION_TIMESTAMP, request.getStartDate() ) );\n    }\n    if ( request.getEndDate() != null ) {\n      criterion.add( Restrictions.lt( CREATION_TIMESTAMP, request.getEndDate() ) );\n    }\n\n    final List<Serializable> exportData = Lists.newArrayList();\n    final Set<EventDependency> dependencies = Sets.newHashSet();\n    for ( final Class<? extends AbstractPersistent> eventClass : eventClasses ) {\n      final EntityTransaction transaction = Entities.get( eventClass );\n      try {\n        addToExportList(\n            exportData,\n            dependencies,\n            criteriaFor(eventClass, criterion).list() );\n      } catch ( Exception e) {\n        log.error(e, e);\n      } finally {\n        transaction.rollback();\n      }\n    }\n\n    final ByteArrayOutputStream out = new ByteArrayOutputStream();\n    try {\n      final ObjectOutputStream oout = new ObjectOutputStream( out );\n      oout.writeObject( exportData );\n      oout.flush();\n      oout.close();\n      reply.setResult( new ExportDataResultType( B64.standard.encString( out.toByteArray() ) ) );\n    } catch (IOException e) {\n      throw new EucalyptusCloudException( e );\n    }\n\n    return reply;\n  }","id":65439,"modified_method":"public ExportDataResponseType exportData( final ExportDataType request ) throws EucalyptusCloudException {\n    final ExportDataResponseType reply = request.getReply();\n    reply.getResponseMetadata().setRequestId( reply.getCorrelationId( ) );\n    final Context ctx = Contexts.lookup();\n    final User requestUser = ctx.getUser( );\n\n    if ( !requestUser.isSystemAdmin() ) {\n      throw new ReportingException( HttpResponseStatus.UNUATHORIZED, ReportingException.NOT_AUTHORIZED, \"Not authorized\");\n    }\n\n    final ReportingExport export = Export.export( request.getStartDate(), request.getEndDate() );\n    reply.setResult( new ExportDataResultType(export ) );\n\n    return reply;\n  }","commit_id":"f2c2c39ec86c84ecd4b5545b1f0789e1b2cd9486","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@SuppressWarnings( \"deprecation\" )\n  public static EntityManagerFactoryImpl getEntityManagerFactory( final String persistenceContext ) {\n    Databases.awaitSynchronized( );\n    if ( emf.containsKey( persistenceContext ) ) {\n      return emf.get( persistenceContext );\n    } else {\n      for ( int i = 0; i < MAX_EMF_RETRIES; ++i ) {\n        if ( emf.containsKey( persistenceContext ) ) {\n          return emf.get( persistenceContext );\n        }\n        Exceptions.trace( persistenceContext\n                          + \": Persistence context has not been configured yet.\"\n                          + \" (see debug logs for details)\"\n                          + \"\\nThe available contexts are: \\n\"\n                          + Joiner.on( \"\\n\" ).join( emf.keySet( ) ) );\n        try {\n          TimeUnit.MILLISECONDS.sleep( 100 );\n        } catch ( InterruptedException ex ) {\n          throw Exceptions.toUndeclared( Exceptions.maybeInterrupted( ex ) );\n        }\n      }\n    }\n    throw Exceptions.error( \"Failed to lookup persistence context after \" + MAX_EMF_RETRIES + \" tries.\\n\" );\n  }","id":65440,"modified_method":"@SuppressWarnings( \"deprecation\" )\n  public static EntityManagerFactoryImpl getEntityManagerFactory( final String persistenceContext ) {\n    PersistenceContextLookupInterceptorDiscovery.dispatcher().onLookup();\n    if ( emf.containsKey( persistenceContext ) ) {\n      return emf.get( persistenceContext );\n    } else {\n      for ( int i = 0; i < MAX_EMF_RETRIES; ++i ) {\n        if ( emf.containsKey( persistenceContext ) ) {\n          return emf.get( persistenceContext );\n        }\n        Exceptions.trace( persistenceContext\n                          + \": Persistence context has not been configured yet.\"\n                          + \" (see debug logs for details)\"\n                          + \"\\nThe available contexts are: \\n\"\n                          + Joiner.on( \"\\n\" ).join( emf.keySet( ) ) );\n        try {\n          TimeUnit.MILLISECONDS.sleep( 100 );\n        } catch ( InterruptedException ex ) {\n          throw Exceptions.toUndeclared( Exceptions.maybeInterrupted( ex ) );\n        }\n      }\n    }\n    throw Exceptions.error( \"Failed to lookup persistence context after \" + MAX_EMF_RETRIES + \" tries.\\n\" );\n  }","commit_id":"25077af8f3b2f7d420f58d174c43f565e3042fa2","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public ExportDataResponseType exportData( final ExportDataType request ) throws EucalyptusCloudException {\n    final ExportDataResponseType reply = request.getReply();\n    reply.getResponseMetadata().setRequestId( reply.getCorrelationId( ) );\n    final Context ctx = Contexts.lookup();\n    final User requestUser = ctx.getUser( );\n\n    if ( !requestUser.isSystemAdmin() ) {\n      throw new ReportingException( HttpResponseStatus.UNUATHORIZED, ReportingException.NOT_AUTHORIZED, \"Not authorized\");\n    }\n\n    final Conjunction criterion = Restrictions.conjunction();\n    if ( request.getStartDate() != null ) {\n      criterion.add( Restrictions.ge( CREATION_TIMESTAMP, request.getStartDate() ) );\n    }\n    if ( request.getEndDate() != null ) {\n      criterion.add( Restrictions.lt( CREATION_TIMESTAMP, request.getEndDate() ) );\n    }\n\n    final List<Serializable> exportData = Lists.newArrayList();\n    final Set<EventDependency> dependencies = Sets.newHashSet();\n    for ( final Class<? extends AbstractPersistent> eventClass : eventClasses ) {\n      final EntityTransaction transaction = Entities.get( eventClass );\n      try {\n        addToExportList(\n            exportData,\n            dependencies,\n            criteriaFor(eventClass, criterion).list() );\n      } catch ( Exception e) {\n        log.error(e, e);\n      } finally {\n        transaction.rollback();\n      }\n    }\n\n    final ByteArrayOutputStream out = new ByteArrayOutputStream();\n    try {\n      final ObjectOutputStream oout = new ObjectOutputStream( out );\n      oout.writeObject( exportData );\n      oout.flush();\n      oout.close();\n      reply.setResult( new ExportDataResultType( B64.standard.encString( out.toByteArray() ) ) );\n    } catch (IOException e) {\n      throw new EucalyptusCloudException( e );\n    }\n\n    return reply;\n  }","id":65441,"modified_method":"public ExportDataResponseType exportData( final ExportDataType request ) throws EucalyptusCloudException {\n    final ExportDataResponseType reply = request.getReply();\n    reply.getResponseMetadata().setRequestId( reply.getCorrelationId( ) );\n    final Context ctx = Contexts.lookup();\n    final User requestUser = ctx.getUser( );\n\n    if ( !requestUser.isSystemAdmin() ) {\n      throw new ReportingException( HttpResponseStatus.UNUATHORIZED, ReportingException.NOT_AUTHORIZED, \"Not authorized\");\n    }\n\n    final ReportingExport export = Export.export( request.getStartDate(), request.getEndDate() );\n    reply.setResult( new ExportDataResultType(export ) );\n\n    return reply;\n  }","commit_id":"25077af8f3b2f7d420f58d174c43f565e3042fa2","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public String getOuterAttrs() {\n\t\tfinal String attrs = super.getOuterAttrs();\n\t\tfinal StringBuffer sb = new StringBuffer(80).append(attrs);\n\t\tif (getConstraint() instanceof SimpleDateConstraint) {\n\t\t\tfinal SimpleDateConstraint st = (SimpleDateConstraint)getConstraint();\n\t\t\tif (st.getBeginDate() != null)\n\t\t\t\tsb.append(\" z.bd=\\\"\").append(st.getBeginDate().getTime()).append(\"\\\"\");\n\t\t\tif (st.getEndDate() != null)\n\t\t\t\tsb.append(\" z.ed=\\\"\").append(st.getEndDate().getTime()).append(\"\\\"\");\n\t\t}\n\t\tif (!_lenient) sb.append(\" z.lenient=\\\"false\\\"\");\n\t\tif (_compact) sb.append(\" z.compact=\\\"true\\\"\");\n\t\treturn sb.toString();\n\t}","id":65442,"modified_method":"public String getOuterAttrs() {\n\t\tfinal StringBuffer sb = new StringBuffer(80).append(super.getOuterAttrs());\n\t\tif (getConstraint() instanceof SimpleDateConstraint) {\n\t\t\tfinal SimpleDateConstraint st = (SimpleDateConstraint)getConstraint();\n\t\t\tDate d = st.getBeginDate();\n\t\t\tif (d != null)\n\t\t\t\tsb.append(\" z.bd=\\\"\").append(d.getTime()).append(\"\\\"\");\n\t\t\td = st.getEndDate();\n\t\t\tif (d != null)\n\t\t\t\tsb.append(\" z.ed=\\\"\").append(d.getTime()).append(\"\\\"\");\n\t\t}\n\t\tif (!_lenient) sb.append(\" z.lenient=\\\"false\\\"\");\n\t\tif (_compact) sb.append(\" z.compact=\\\"true\\\"\");\n\t\treturn sb.toString();\n\t}","commit_id":"e77dc597d8eaa38d2fdf78219ae4b6ef103a2c64","url":"https://github.com/zkoss/zk"},{"original_method":"/** @param knownType May be null if the type is unknown.\r\n\t * @param elementType May be null if the type is unknown. */\r\n\tpublic void writeValue (Object value, Class knownType, Class elementType) {\r\n\t\ttry {\r\n\t\t\tif (value == null) {\r\n\t\t\t\twriter.value(null);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tClass actualType = value.getClass();\r\n\r\n\t\t\tif (actualType.isPrimitive() || actualType == String.class || actualType == Integer.class || actualType == Boolean.class\r\n\t\t\t\t|| actualType == Float.class || actualType == Long.class || actualType == Double.class || actualType == Short.class\r\n\t\t\t\t|| actualType == Byte.class || actualType == Character.class) {\r\n\t\t\t\twriter.value(value);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (value instanceof Serializable) {\r\n\t\t\t\twriteObjectStart(actualType, knownType);\r\n\t\t\t\t((Serializable)value).write(this);\r\n\t\t\t\twriteObjectEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tSerializer serializer = classToSerializer.get(actualType);\r\n\t\t\tif (serializer != null) {\r\n\t\t\t\tserializer.write(this, value, knownType);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (value instanceof Array) {\r\n\t\t\t\tif (knownType != null && actualType != knownType)\r\n\t\t\t\t\tthrow new SerializationException(\"Serialization of an Array other than the known type is not supported.\\n\"\r\n\t\t\t\t\t\t+ \"Known type: \" + knownType + \"\\nActual type: \" + actualType);\r\n\t\t\t\twriteArrayStart();\r\n\t\t\t\tArray array = (Array)value;\r\n\t\t\t\tfor (int i = 0, n = array.size; i < n; i++)\r\n\t\t\t\t\twriteValue(array.get(i), elementType, null);\r\n\t\t\t\twriteArrayEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (value instanceof Collection) {\r\n\t\t\t\tif (knownType != null && actualType != knownType && actualType != ArrayList.class)\r\n\t\t\t\t\tthrow new SerializationException(\"Serialization of a Collection other than the known type is not supported.\\n\"\r\n\t\t\t\t\t\t+ \"Known type: \" + knownType + \"\\nActual type: \" + actualType);\r\n\t\t\t\twriteArrayStart();\r\n\t\t\t\tfor (Object item : (Collection)value)\r\n\t\t\t\t\twriteValue(item, elementType, null);\r\n\t\t\t\twriteArrayEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (actualType.isArray()) {\r\n\t\t\t\tif (elementType == null) elementType = actualType.getComponentType();\r\n\t\t\t\tint length = java.lang.reflect.Array.getLength(value);\r\n\t\t\t\twriteArrayStart();\r\n\t\t\t\tfor (int i = 0; i < length; i++)\r\n\t\t\t\t\twriteValue(java.lang.reflect.Array.get(value, i), elementType, null);\r\n\t\t\t\twriteArrayEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (value instanceof OrderedMap) {\r\n\t\t\t\tif (knownType == null) knownType = OrderedMap.class;\r\n\t\t\t\twriteObjectStart(actualType, knownType);\r\n\t\t\t\tOrderedMap map = (OrderedMap)value;\r\n\t\t\t\tfor (Object key : map.orderedKeys()) {\r\n\t\t\t\t\twriter.name(convertToString(key));\r\n\t\t\t\t\twriteValue(map.get(key), elementType, null);\r\n\t\t\t\t}\r\n\t\t\t\twriteObjectEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (value instanceof ArrayMap) {\r\n\t\t\t\tif (knownType == null) knownType = ArrayMap.class;\r\n\t\t\t\twriteObjectStart(actualType, knownType);\r\n\t\t\t\tArrayMap map = (ArrayMap)value;\r\n\t\t\t\tfor (int i = 0, n = map.size; i < n; i++) {\r\n\t\t\t\t\twriter.name(convertToString(map.keys[i]));\r\n\t\t\t\t\twriteValue(map.values[i], elementType, null);\r\n\t\t\t\t}\r\n\t\t\t\twriteObjectEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (value instanceof ObjectMap) {\r\n\t\t\t\tif (knownType == null) knownType = OrderedMap.class;\r\n\t\t\t\twriteObjectStart(actualType, knownType);\r\n\t\t\t\tfor (Entry entry : ((ObjectMap<?, ?>)value).entries()) {\r\n\t\t\t\t\twriter.name(convertToString(entry.key));\r\n\t\t\t\t\twriteValue(entry.value, elementType, null);\r\n\t\t\t\t}\r\n\t\t\t\twriteObjectEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (value instanceof Map) {\r\n\t\t\t\tif (knownType == null) knownType = OrderedMap.class;\r\n\t\t\t\twriteObjectStart(actualType, knownType);\r\n\t\t\t\tfor (Map.Entry entry : ((Map<?, ?>)value).entrySet()) {\r\n\t\t\t\t\twriter.name(convertToString(entry.getKey()));\r\n\t\t\t\t\twriteValue(entry.getValue(), elementType, null);\r\n\t\t\t\t}\r\n\t\t\t\twriteObjectEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (actualType.isEnum()) {\r\n\t\t\t\twriter.value(value);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\twriteObjectStart(actualType, knownType);\r\n\t\t\twriteFields(value);\r\n\t\t\twriteObjectEnd();\r\n\t\t} catch (IOException ex) {\r\n\t\t\tthrow new SerializationException(ex);\r\n\t\t}\r\n\t}","id":65443,"modified_method":"/** @param value May be null.\r\n\t * @param knownType May be null if the type is unknown.\r\n\t * @param elementType May be null if the type is unknown. */\r\n\tpublic void writeValue (Object value, Class knownType, Class elementType) {\r\n\t\ttry {\r\n\t\t\tif (value == null) {\r\n\t\t\t\twriter.value(null);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tClass actualType = value.getClass();\r\n\r\n\t\t\tif (actualType.isPrimitive() || actualType == String.class || actualType == Integer.class || actualType == Boolean.class\r\n\t\t\t\t|| actualType == Float.class || actualType == Long.class || actualType == Double.class || actualType == Short.class\r\n\t\t\t\t|| actualType == Byte.class || actualType == Character.class) {\r\n\t\t\t\twriter.value(value);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (value instanceof Serializable) {\r\n\t\t\t\twriteObjectStart(actualType, knownType);\r\n\t\t\t\t((Serializable)value).write(this);\r\n\t\t\t\twriteObjectEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tSerializer serializer = classToSerializer.get(actualType);\r\n\t\t\tif (serializer != null) {\r\n\t\t\t\tserializer.write(this, value, knownType);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (value instanceof Array) {\r\n\t\t\t\tif (knownType != null && actualType != knownType)\r\n\t\t\t\t\tthrow new SerializationException(\"Serialization of an Array other than the known type is not supported.\\n\"\r\n\t\t\t\t\t\t+ \"Known type: \" + knownType + \"\\nActual type: \" + actualType);\r\n\t\t\t\twriteArrayStart();\r\n\t\t\t\tArray array = (Array)value;\r\n\t\t\t\tfor (int i = 0, n = array.size; i < n; i++)\r\n\t\t\t\t\twriteValue(array.get(i), elementType, null);\r\n\t\t\t\twriteArrayEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (value instanceof Collection) {\r\n\t\t\t\tif (knownType != null && actualType != knownType && actualType != ArrayList.class)\r\n\t\t\t\t\tthrow new SerializationException(\"Serialization of a Collection other than the known type is not supported.\\n\"\r\n\t\t\t\t\t\t+ \"Known type: \" + knownType + \"\\nActual type: \" + actualType);\r\n\t\t\t\twriteArrayStart();\r\n\t\t\t\tfor (Object item : (Collection)value)\r\n\t\t\t\t\twriteValue(item, elementType, null);\r\n\t\t\t\twriteArrayEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (actualType.isArray()) {\r\n\t\t\t\tif (elementType == null) elementType = actualType.getComponentType();\r\n\t\t\t\tint length = java.lang.reflect.Array.getLength(value);\r\n\t\t\t\twriteArrayStart();\r\n\t\t\t\tfor (int i = 0; i < length; i++)\r\n\t\t\t\t\twriteValue(java.lang.reflect.Array.get(value, i), elementType, null);\r\n\t\t\t\twriteArrayEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (value instanceof OrderedMap) {\r\n\t\t\t\tif (knownType == null) knownType = OrderedMap.class;\r\n\t\t\t\twriteObjectStart(actualType, knownType);\r\n\t\t\t\tOrderedMap map = (OrderedMap)value;\r\n\t\t\t\tfor (Object key : map.orderedKeys()) {\r\n\t\t\t\t\twriter.name(convertToString(key));\r\n\t\t\t\t\twriteValue(map.get(key), elementType, null);\r\n\t\t\t\t}\r\n\t\t\t\twriteObjectEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (value instanceof ArrayMap) {\r\n\t\t\t\tif (knownType == null) knownType = ArrayMap.class;\r\n\t\t\t\twriteObjectStart(actualType, knownType);\r\n\t\t\t\tArrayMap map = (ArrayMap)value;\r\n\t\t\t\tfor (int i = 0, n = map.size; i < n; i++) {\r\n\t\t\t\t\twriter.name(convertToString(map.keys[i]));\r\n\t\t\t\t\twriteValue(map.values[i], elementType, null);\r\n\t\t\t\t}\r\n\t\t\t\twriteObjectEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (value instanceof ObjectMap) {\r\n\t\t\t\tif (knownType == null) knownType = OrderedMap.class;\r\n\t\t\t\twriteObjectStart(actualType, knownType);\r\n\t\t\t\tfor (Entry entry : ((ObjectMap<?, ?>)value).entries()) {\r\n\t\t\t\t\twriter.name(convertToString(entry.key));\r\n\t\t\t\t\twriteValue(entry.value, elementType, null);\r\n\t\t\t\t}\r\n\t\t\t\twriteObjectEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (value instanceof Map) {\r\n\t\t\t\tif (knownType == null) knownType = OrderedMap.class;\r\n\t\t\t\twriteObjectStart(actualType, knownType);\r\n\t\t\t\tfor (Map.Entry entry : ((Map<?, ?>)value).entrySet()) {\r\n\t\t\t\t\twriter.name(convertToString(entry.getKey()));\r\n\t\t\t\t\twriteValue(entry.getValue(), elementType, null);\r\n\t\t\t\t}\r\n\t\t\t\twriteObjectEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (actualType.isEnum()) {\r\n\t\t\t\twriter.value(value);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\twriteObjectStart(actualType, knownType);\r\n\t\t\twriteFields(value);\r\n\t\t\twriteObjectEnd();\r\n\t\t} catch (IOException ex) {\r\n\t\t\tthrow new SerializationException(ex);\r\n\t\t}\r\n\t}","commit_id":"1c2d6c1c368d977acc68d7087cdf005bfa9d0058","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** @param knownType May be null if the type is unknown. */\r\n\tpublic void writeValue (Object value, Class knownType) {\r\n\t\twriteValue(value, knownType, null);\r\n\t}","id":65444,"modified_method":"/** @param value May be null.\r\n\t * @param knownType May be null if the type is unknown. */\r\n\tpublic void writeValue (Object value, Class knownType) {\r\n\t\twriteValue(value, knownType, null);\r\n\t}","commit_id":"1c2d6c1c368d977acc68d7087cdf005bfa9d0058","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** @param type May be null if the type is unknown.\r\n\t * @param elementType May be null if the type is unknown. */\r\n\tpublic <T> T fromJson (Class<T> type, Class elementType, FileHandle file) {\r\n\t\ttry {\r\n\t\t\treturn (T)readValue(type, elementType, new JsonReader().parse(file));\r\n\t\t} catch (Exception ex) {\r\n\t\t\tthrow new SerializationException(\"Error reading file: \" + file, ex);\r\n\t\t}\r\n\t}","id":65445,"modified_method":"/** @param type May be null if the type is unknown.\r\n\t * @param elementType May be null if the type is unknown.\r\n\t * @return May be null. */\r\n\tpublic <T> T fromJson (Class<T> type, Class elementType, FileHandle file) {\r\n\t\ttry {\r\n\t\t\treturn (T)readValue(type, elementType, new JsonReader().parse(file));\r\n\t\t} catch (Exception ex) {\r\n\t\t\tthrow new SerializationException(\"Error reading file: \" + file, ex);\r\n\t\t}\r\n\t}","commit_id":"1c2d6c1c368d977acc68d7087cdf005bfa9d0058","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** @param type May be null if the type is unknown. */\r\n\tpublic <T> T fromJson (Class<T> type, FileHandle file) {\r\n\t\ttry {\r\n\t\t\treturn (T)readValue(type, null, new JsonReader().parse(file));\r\n\t\t} catch (Exception ex) {\r\n\t\t\tthrow new SerializationException(\"Error reading file: \" + file, ex);\r\n\t\t}\r\n\t}","id":65446,"modified_method":"/** @param type May be null if the type is unknown.\r\n\t * @return May be null. */\r\n\tpublic <T> T fromJson (Class<T> type, FileHandle file) {\r\n\t\ttry {\r\n\t\t\treturn (T)readValue(type, null, new JsonReader().parse(file));\r\n\t\t} catch (Exception ex) {\r\n\t\t\tthrow new SerializationException(\"Error reading file: \" + file, ex);\r\n\t\t}\r\n\t}","commit_id":"1c2d6c1c368d977acc68d7087cdf005bfa9d0058","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** @param type May be null if the type is unknown. */\r\n\tpublic <T> T readValue (Class<T> type, Object jsonData) {\r\n\t\treturn (T)readValue(type, null, jsonData);\r\n\t}","id":65447,"modified_method":"/** @param type May be null if the type is unknown.\r\n\t * @return May be null. */\r\n\tpublic <T> T readValue (Class<T> type, Object jsonData) {\r\n\t\treturn (T)readValue(type, null, jsonData);\r\n\t}","commit_id":"1c2d6c1c368d977acc68d7087cdf005bfa9d0058","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** @param type May be null if the type is unknown.\r\n\t * @param elementType May be null if the type is unknown. */\r\n\tpublic <T> T fromJson (Class<T> type, Class elementType, char[] data, int offset, int length) {\r\n\t\treturn (T)readValue(type, elementType, new JsonReader().parse(data, offset, length));\r\n\t}","id":65448,"modified_method":"/** @param type May be null if the type is unknown.\r\n\t * @param elementType May be null if the type is unknown.\r\n\t * @return May be null. */\r\n\tpublic <T> T fromJson (Class<T> type, Class elementType, char[] data, int offset, int length) {\r\n\t\treturn (T)readValue(type, elementType, new JsonReader().parse(data, offset, length));\r\n\t}","commit_id":"1c2d6c1c368d977acc68d7087cdf005bfa9d0058","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** @param type May be null if the type is unknown. */\r\n\tpublic <T> T fromJson (Class<T> type, char[] data, int offset, int length) {\r\n\t\treturn (T)readValue(type, null, new JsonReader().parse(data, offset, length));\r\n\t}","id":65449,"modified_method":"/** @param type May be null if the type is unknown.\r\n\t * @return May be null. */\r\n\tpublic <T> T fromJson (Class<T> type, char[] data, int offset, int length) {\r\n\t\treturn (T)readValue(type, null, new JsonReader().parse(data, offset, length));\r\n\t}","commit_id":"1c2d6c1c368d977acc68d7087cdf005bfa9d0058","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** @param type May be null if the type is unknown.\r\n\t * @param elementType May be null if the type is unknown. */\r\n\tpublic <T> T readValue (Class<T> type, Class elementType, Object jsonData) {\r\n\t\tif (jsonData == null) return null;\r\n\r\n\t\tif (jsonData instanceof OrderedMap) {\r\n\t\t\tOrderedMap<String, Object> jsonMap = (OrderedMap)jsonData;\r\n\r\n\t\t\tString className = typeName == null ? null : (String)jsonMap.remove(typeName);\r\n\t\t\tif (className != null) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\ttype = (Class<T>)Class.forName(className);\r\n\t\t\t\t} catch (ClassNotFoundException ex) {\r\n\t\t\t\t\ttype = tagToClass.get(className);\r\n\t\t\t\t\tif (type == null) throw new SerializationException(ex);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tObject object;\r\n\t\t\tif (type != null) {\r\n\t\t\t\tSerializer serializer = classToSerializer.get(type);\r\n\t\t\t\tif (serializer != null) return (T)serializer.read(this, jsonMap, type);\r\n\r\n\t\t\t\tobject = newInstance(type);\r\n\r\n\t\t\t\tif (object instanceof Serializable) {\r\n\t\t\t\t\t((Serializable)object).read(this, jsonMap);\r\n\t\t\t\t\treturn (T)object;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (object instanceof HashMap) {\r\n\t\t\t\t\tHashMap result = (HashMap)object;\r\n\t\t\t\t\tfor (Entry entry : jsonMap.entries())\r\n\t\t\t\t\t\tresult.put(entry.key, readValue(elementType, null, entry.value));\r\n\t\t\t\t\treturn (T)result;\r\n\t\t\t\t}\r\n\t\t\t} else\r\n\t\t\t\tobject = new OrderedMap();\r\n\r\n\t\t\tif (object instanceof ObjectMap) {\r\n\t\t\t\tObjectMap result = (ObjectMap)object;\r\n\t\t\t\tfor (String key : jsonMap.orderedKeys())\r\n\t\t\t\t\tresult.put(key, readValue(elementType, null, jsonMap.get(key)));\r\n\t\t\t\treturn (T)result;\r\n\t\t\t}\r\n\r\n\t\t\treadFields(object, jsonMap);\r\n\t\t\treturn (T)object;\r\n\t\t}\r\n\r\n\t\tif (type != null) {\r\n\t\t\tSerializer serializer = classToSerializer.get(type);\r\n\t\t\tif (serializer != null) return (T)serializer.read(this, jsonData, type);\r\n\t\t}\r\n\r\n\t\tif (jsonData instanceof Array) {\r\n\t\t\tArray array = (Array)jsonData;\r\n\t\t\tif (type == null || Array.class.isAssignableFrom(type)) {\r\n\t\t\t\tArray newArray = new Array(array.size);\r\n\t\t\t\tfor (int i = 0, n = array.size; i < n; i++)\r\n\t\t\t\t\tnewArray.add(readValue(elementType, null, array.get(i)));\r\n\t\t\t\treturn (T)newArray;\r\n\t\t\t}\r\n\t\t\tif (ArrayList.class.isAssignableFrom(type)) {\r\n\t\t\t\tArrayList newArray = new ArrayList(array.size);\r\n\t\t\t\tfor (int i = 0, n = array.size; i < n; i++)\r\n\t\t\t\t\tnewArray.add(readValue(elementType, null, array.get(i)));\r\n\t\t\t\treturn (T)newArray;\r\n\t\t\t}\r\n\t\t\tif (type.isArray()) {\r\n\t\t\t\tClass componentType = type.getComponentType();\r\n\t\t\t\tif (elementType == null) elementType = componentType;\r\n\t\t\t\tObject newArray = java.lang.reflect.Array.newInstance(componentType, array.size);\r\n\t\t\t\tfor (int i = 0, n = array.size; i < n; i++)\r\n\t\t\t\t\tjava.lang.reflect.Array.set(newArray, i, readValue(elementType, null, array.get(i)));\r\n\t\t\t\treturn (T)newArray;\r\n\t\t\t}\r\n\t\t\tthrow new SerializationException(\"Unable to convert value to required type: \" + jsonData + \" (\" + type.getName() + \")\");\r\n\t\t}\r\n\r\n\t\tif (jsonData instanceof Float) {\r\n\t\t\tFloat floatValue = (Float)jsonData;\r\n\t\t\ttry {\r\n\t\t\t\tif (type == null || type == float.class || type == Float.class) return (T)(Float)floatValue;\r\n\t\t\t\tif (type == int.class || type == Integer.class) return (T)(Integer)floatValue.intValue();\r\n\t\t\t\tif (type == long.class || type == Long.class) return (T)(Long)floatValue.longValue();\r\n\t\t\t\tif (type == double.class || type == Double.class) return (T)(Double)floatValue.doubleValue();\r\n\t\t\t\tif (type == short.class || type == Short.class) return (T)(Short)floatValue.shortValue();\r\n\t\t\t\tif (type == byte.class || type == Byte.class) return (T)(Byte)floatValue.byteValue();\r\n\t\t\t} catch (NumberFormatException ignored) {\r\n\t\t\t}\r\n\t\t\tjsonData = String.valueOf(jsonData);\r\n\t\t}\r\n\r\n\t\tif (jsonData instanceof Boolean) jsonData = String.valueOf(jsonData);\r\n\r\n\t\tif (jsonData instanceof String) {\r\n\t\t\tString string = (String)jsonData;\r\n\t\t\tif (type == null || type == String.class) return (T)jsonData;\r\n\t\t\ttry {\r\n\t\t\t\tif (type == int.class || type == Integer.class) return (T)Integer.valueOf(string);\r\n\t\t\t\tif (type == float.class || type == Float.class) return (T)Float.valueOf(string);\r\n\t\t\t\tif (type == long.class || type == Long.class) return (T)Long.valueOf(string);\r\n\t\t\t\tif (type == double.class || type == Double.class) return (T)Double.valueOf(string);\r\n\t\t\t\tif (type == short.class || type == Short.class) return (T)Short.valueOf(string);\r\n\t\t\t\tif (type == byte.class || type == Byte.class) return (T)Byte.valueOf(string);\r\n\t\t\t} catch (NumberFormatException ignored) {\r\n\t\t\t}\r\n\t\t\tif (type == boolean.class || type == Boolean.class) return (T)Boolean.valueOf(string);\r\n\t\t\tif (type == char.class || type == Character.class) return (T)(Character)string.charAt(0);\r\n\t\t\tif (type.isEnum()) {\r\n\t\t\t\tObject[] constants = type.getEnumConstants();\r\n\t\t\t\tfor (int i = 0, n = constants.length; i < n; i++)\r\n\t\t\t\t\tif (string.equals(constants[i].toString())) return (T)constants[i];\r\n\t\t\t}\r\n\t\t\tif (type == CharSequence.class) return (T)string;\r\n\t\t\tthrow new SerializationException(\"Unable to convert value to required type: \" + jsonData + \" (\" + type.getName() + \")\");\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t}","id":65450,"modified_method":"/** @param type May be null if the type is unknown.\r\n\t * @param elementType May be null if the type is unknown.\r\n\t * @return May be null. */\r\n\tpublic <T> T readValue (Class<T> type, Class elementType, Object jsonData) {\r\n\t\tif (jsonData == null) return null;\r\n\r\n\t\tif (jsonData instanceof OrderedMap) {\r\n\t\t\tOrderedMap<String, Object> jsonMap = (OrderedMap)jsonData;\r\n\r\n\t\t\tString className = typeName == null ? null : (String)jsonMap.remove(typeName);\r\n\t\t\tif (className != null) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\ttype = (Class<T>)Class.forName(className);\r\n\t\t\t\t} catch (ClassNotFoundException ex) {\r\n\t\t\t\t\ttype = tagToClass.get(className);\r\n\t\t\t\t\tif (type == null) throw new SerializationException(ex);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tObject object;\r\n\t\t\tif (type != null) {\r\n\t\t\t\tSerializer serializer = classToSerializer.get(type);\r\n\t\t\t\tif (serializer != null) return (T)serializer.read(this, jsonMap, type);\r\n\r\n\t\t\t\tobject = newInstance(type);\r\n\r\n\t\t\t\tif (object instanceof Serializable) {\r\n\t\t\t\t\t((Serializable)object).read(this, jsonMap);\r\n\t\t\t\t\treturn (T)object;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (object instanceof HashMap) {\r\n\t\t\t\t\tHashMap result = (HashMap)object;\r\n\t\t\t\t\tfor (Entry entry : jsonMap.entries())\r\n\t\t\t\t\t\tresult.put(entry.key, readValue(elementType, null, entry.value));\r\n\t\t\t\t\treturn (T)result;\r\n\t\t\t\t}\r\n\t\t\t} else\r\n\t\t\t\tobject = new OrderedMap();\r\n\r\n\t\t\tif (object instanceof ObjectMap) {\r\n\t\t\t\tObjectMap result = (ObjectMap)object;\r\n\t\t\t\tfor (String key : jsonMap.orderedKeys())\r\n\t\t\t\t\tresult.put(key, readValue(elementType, null, jsonMap.get(key)));\r\n\t\t\t\treturn (T)result;\r\n\t\t\t}\r\n\r\n\t\t\treadFields(object, jsonMap);\r\n\t\t\treturn (T)object;\r\n\t\t}\r\n\r\n\t\tif (type != null) {\r\n\t\t\tSerializer serializer = classToSerializer.get(type);\r\n\t\t\tif (serializer != null) return (T)serializer.read(this, jsonData, type);\r\n\t\t}\r\n\r\n\t\tif (jsonData instanceof Array) {\r\n\t\t\tArray array = (Array)jsonData;\r\n\t\t\tif (type == null || Array.class.isAssignableFrom(type)) {\r\n\t\t\t\tArray newArray = new Array(array.size);\r\n\t\t\t\tfor (int i = 0, n = array.size; i < n; i++)\r\n\t\t\t\t\tnewArray.add(readValue(elementType, null, array.get(i)));\r\n\t\t\t\treturn (T)newArray;\r\n\t\t\t}\r\n\t\t\tif (ArrayList.class.isAssignableFrom(type)) {\r\n\t\t\t\tArrayList newArray = new ArrayList(array.size);\r\n\t\t\t\tfor (int i = 0, n = array.size; i < n; i++)\r\n\t\t\t\t\tnewArray.add(readValue(elementType, null, array.get(i)));\r\n\t\t\t\treturn (T)newArray;\r\n\t\t\t}\r\n\t\t\tif (type.isArray()) {\r\n\t\t\t\tClass componentType = type.getComponentType();\r\n\t\t\t\tif (elementType == null) elementType = componentType;\r\n\t\t\t\tObject newArray = java.lang.reflect.Array.newInstance(componentType, array.size);\r\n\t\t\t\tfor (int i = 0, n = array.size; i < n; i++)\r\n\t\t\t\t\tjava.lang.reflect.Array.set(newArray, i, readValue(elementType, null, array.get(i)));\r\n\t\t\t\treturn (T)newArray;\r\n\t\t\t}\r\n\t\t\tthrow new SerializationException(\"Unable to convert value to required type: \" + jsonData + \" (\" + type.getName() + \")\");\r\n\t\t}\r\n\r\n\t\tif (jsonData instanceof Float) {\r\n\t\t\tFloat floatValue = (Float)jsonData;\r\n\t\t\ttry {\r\n\t\t\t\tif (type == null || type == float.class || type == Float.class) return (T)(Float)floatValue;\r\n\t\t\t\tif (type == int.class || type == Integer.class) return (T)(Integer)floatValue.intValue();\r\n\t\t\t\tif (type == long.class || type == Long.class) return (T)(Long)floatValue.longValue();\r\n\t\t\t\tif (type == double.class || type == Double.class) return (T)(Double)floatValue.doubleValue();\r\n\t\t\t\tif (type == short.class || type == Short.class) return (T)(Short)floatValue.shortValue();\r\n\t\t\t\tif (type == byte.class || type == Byte.class) return (T)(Byte)floatValue.byteValue();\r\n\t\t\t} catch (NumberFormatException ignored) {\r\n\t\t\t}\r\n\t\t\tjsonData = String.valueOf(jsonData);\r\n\t\t}\r\n\r\n\t\tif (jsonData instanceof Boolean) jsonData = String.valueOf(jsonData);\r\n\r\n\t\tif (jsonData instanceof String) {\r\n\t\t\tString string = (String)jsonData;\r\n\t\t\tif (type == null || type == String.class) return (T)jsonData;\r\n\t\t\ttry {\r\n\t\t\t\tif (type == int.class || type == Integer.class) return (T)Integer.valueOf(string);\r\n\t\t\t\tif (type == float.class || type == Float.class) return (T)Float.valueOf(string);\r\n\t\t\t\tif (type == long.class || type == Long.class) return (T)Long.valueOf(string);\r\n\t\t\t\tif (type == double.class || type == Double.class) return (T)Double.valueOf(string);\r\n\t\t\t\tif (type == short.class || type == Short.class) return (T)Short.valueOf(string);\r\n\t\t\t\tif (type == byte.class || type == Byte.class) return (T)Byte.valueOf(string);\r\n\t\t\t} catch (NumberFormatException ignored) {\r\n\t\t\t}\r\n\t\t\tif (type == boolean.class || type == Boolean.class) return (T)Boolean.valueOf(string);\r\n\t\t\tif (type == char.class || type == Character.class) return (T)(Character)string.charAt(0);\r\n\t\t\tif (type.isEnum()) {\r\n\t\t\t\tObject[] constants = type.getEnumConstants();\r\n\t\t\t\tfor (int i = 0, n = constants.length; i < n; i++)\r\n\t\t\t\t\tif (string.equals(constants[i].toString())) return (T)constants[i];\r\n\t\t\t}\r\n\t\t\tif (type == CharSequence.class) return (T)string;\r\n\t\t\tthrow new SerializationException(\"Unable to convert value to required type: \" + jsonData + \" (\" + type.getName() + \")\");\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t}","commit_id":"1c2d6c1c368d977acc68d7087cdf005bfa9d0058","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** @param type May be null if the type is unknown. */\r\n\tpublic <T> T fromJson (Class<T> type, Class elementType, String json) {\r\n\t\treturn (T)readValue(type, elementType, new JsonReader().parse(json));\r\n\t}","id":65451,"modified_method":"/** @param type May be null if the type is unknown.\r\n\t * @return May be null. */\r\n\tpublic <T> T fromJson (Class<T> type, Class elementType, String json) {\r\n\t\treturn (T)readValue(type, elementType, new JsonReader().parse(json));\r\n\t}","commit_id":"1c2d6c1c368d977acc68d7087cdf005bfa9d0058","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void writeValue (String name, Object value) {\r\n\t\ttry {\r\n\t\t\twriter.name(name);\r\n\t\t} catch (IOException ex) {\r\n\t\t\tthrow new SerializationException(ex);\r\n\t\t}\r\n\t\twriteValue(value, value.getClass(), null);\r\n\t}","id":65452,"modified_method":"/** @param value May be null. */\r\n\tpublic void writeValue (String name, Object value) {\r\n\t\ttry {\r\n\t\t\twriter.name(name);\r\n\t\t} catch (IOException ex) {\r\n\t\t\tthrow new SerializationException(ex);\r\n\t\t}\r\n\t\tif (value == null)\r\n\t\t\twriteValue(value, null, null);\r\n\t\telse\r\n\t\t\twriteValue(value, value.getClass(), null);\r\n\t}","commit_id":"1c2d6c1c368d977acc68d7087cdf005bfa9d0058","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** @param type May be null if the type is unknown.\r\n\t * @param elementType May be null if the type is unknown. */\r\n\tpublic <T> T fromJson (Class<T> type, Class elementType, Reader reader) {\r\n\t\treturn (T)readValue(type, elementType, new JsonReader().parse(reader));\r\n\t}","id":65453,"modified_method":"/** @param type May be null if the type is unknown.\r\n\t * @param elementType May be null if the type is unknown.\r\n\t * @return May be null. */\r\n\tpublic <T> T fromJson (Class<T> type, Class elementType, Reader reader) {\r\n\t\treturn (T)readValue(type, elementType, new JsonReader().parse(reader));\r\n\t}","commit_id":"1c2d6c1c368d977acc68d7087cdf005bfa9d0058","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** @param type May be null if the type is unknown. */\r\n\tpublic <T> T fromJson (Class<T> type, InputStream input) {\r\n\t\treturn (T)readValue(type, null, new JsonReader().parse(input));\r\n\t}","id":65454,"modified_method":"/** @param type May be null if the type is unknown.\r\n\t * @return May be null. */\r\n\tpublic <T> T fromJson (Class<T> type, InputStream input) {\r\n\t\treturn (T)readValue(type, null, new JsonReader().parse(input));\r\n\t}","commit_id":"1c2d6c1c368d977acc68d7087cdf005bfa9d0058","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** @param type May be null if the type is unknown.\r\n\t * @param elementType May be null if the type is unknown. */\r\n\tpublic <T> T readValue (String name, Class<T> type, Class elementType, T defaultValue, Object jsonData) {\r\n\t\tOrderedMap jsonMap = (OrderedMap)jsonData;\r\n\t\tObject jsonValue = jsonMap.get(name);\r\n\t\tif (jsonValue == null) return defaultValue;\r\n\t\treturn (T)readValue(type, elementType, jsonValue);\r\n\t}","id":65455,"modified_method":"/** @param type May be null if the type is unknown.\r\n\t * @param elementType May be null if the type is unknown.\r\n\t * @return May be null. */\r\n\tpublic <T> T readValue (String name, Class<T> type, Class elementType, T defaultValue, Object jsonData) {\r\n\t\tOrderedMap jsonMap = (OrderedMap)jsonData;\r\n\t\tObject jsonValue = jsonMap.get(name);\r\n\t\tif (jsonValue == null) return defaultValue;\r\n\t\treturn (T)readValue(type, elementType, jsonValue);\r\n\t}","commit_id":"1c2d6c1c368d977acc68d7087cdf005bfa9d0058","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** @param type May be null if the type is unknown. */\r\n\tpublic <T> T readValue (String name, Class<T> type, Object jsonData) {\r\n\t\tOrderedMap jsonMap = (OrderedMap)jsonData;\r\n\t\treturn (T)readValue(type, null, jsonMap.get(name));\r\n\t}","id":65456,"modified_method":"/** @param type May be null if the type is unknown.\r\n\t * @return May be null. */\r\n\tpublic <T> T readValue (String name, Class<T> type, Object jsonData) {\r\n\t\tOrderedMap jsonMap = (OrderedMap)jsonData;\r\n\t\treturn (T)readValue(type, null, jsonMap.get(name));\r\n\t}","commit_id":"1c2d6c1c368d977acc68d7087cdf005bfa9d0058","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** @param type May be null if the type is unknown. */\r\n\tpublic <T> T fromJson (Class<T> type, Reader reader) {\r\n\t\treturn (T)readValue(type, null, new JsonReader().parse(reader));\r\n\t}","id":65457,"modified_method":"/** @param type May be null if the type is unknown.\r\n\t * @return May be null. */\r\n\tpublic <T> T fromJson (Class<T> type, Reader reader) {\r\n\t\treturn (T)readValue(type, null, new JsonReader().parse(reader));\r\n\t}","commit_id":"1c2d6c1c368d977acc68d7087cdf005bfa9d0058","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** @param type May be null if the type is unknown. */\r\n\tpublic <T> T fromJson (Class<T> type, String json) {\r\n\t\treturn (T)readValue(type, null, new JsonReader().parse(json));\r\n\t}","id":65458,"modified_method":"/** @param type May be null if the type is unknown.\r\n\t * @return May be null. */\r\n\tpublic <T> T fromJson (Class<T> type, String json) {\r\n\t\treturn (T)readValue(type, null, new JsonReader().parse(json));\r\n\t}","commit_id":"1c2d6c1c368d977acc68d7087cdf005bfa9d0058","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void writeValue (Object value) {\r\n\t\twriteValue(value, value.getClass(), null);\r\n\t}","id":65459,"modified_method":"/** @param value May be null. */\r\n\tpublic void writeValue (Object value) {\r\n\t\tif (value == null)\r\n\t\t\twriteValue(value, null, null);\r\n\t\telse\r\n\t\t\twriteValue(value, value.getClass(), null);\r\n\t}","commit_id":"1c2d6c1c368d977acc68d7087cdf005bfa9d0058","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** @param knownType May be null if the type is unknown.\r\n\t * @param elementType May be null if the type is unknown. */\r\n\tpublic void writeValue (String name, Object value, Class knownType, Class elementType) {\r\n\t\ttry {\r\n\t\t\twriter.name(name);\r\n\t\t} catch (IOException ex) {\r\n\t\t\tthrow new SerializationException(ex);\r\n\t\t}\r\n\t\twriteValue(value, knownType, elementType);\r\n\t}","id":65460,"modified_method":"/** @param value May be null.\r\n\t * @param knownType May be null if the type is unknown.\r\n\t * @param elementType May be null if the type is unknown. */\r\n\tpublic void writeValue (String name, Object value, Class knownType, Class elementType) {\r\n\t\ttry {\r\n\t\t\twriter.name(name);\r\n\t\t} catch (IOException ex) {\r\n\t\t\tthrow new SerializationException(ex);\r\n\t\t}\r\n\t\twriteValue(value, knownType, elementType);\r\n\t}","commit_id":"1c2d6c1c368d977acc68d7087cdf005bfa9d0058","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** @param type May be null if the type is unknown.\r\n\t * @param elementType May be null if the type is unknown. */\r\n\tpublic <T> T readValue (Class<T> type, Class elementType, T defaultValue, Object jsonData) {\r\n\t\treturn (T)readValue(type, elementType, jsonData);\r\n\t}","id":65461,"modified_method":"/** @param type May be null if the type is unknown.\r\n\t * @param elementType May be null if the type is unknown.\r\n\t * @return May be null. */\r\n\tpublic <T> T readValue (Class<T> type, Class elementType, T defaultValue, Object jsonData) {\r\n\t\treturn (T)readValue(type, elementType, jsonData);\r\n\t}","commit_id":"1c2d6c1c368d977acc68d7087cdf005bfa9d0058","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** @param type May be null if the type is unknown.\r\n\t * @param elementType May be null if the type is unknown. */\r\n\tpublic <T> T fromJson (Class<T> type, Class elementType, InputStream input) {\r\n\t\treturn (T)readValue(type, elementType, new JsonReader().parse(input));\r\n\t}","id":65462,"modified_method":"/** @param type May be null if the type is unknown.\r\n\t * @param elementType May be null if the type is unknown.\r\n\t * @return May be null. */\r\n\tpublic <T> T fromJson (Class<T> type, Class elementType, InputStream input) {\r\n\t\treturn (T)readValue(type, elementType, new JsonReader().parse(input));\r\n\t}","commit_id":"1c2d6c1c368d977acc68d7087cdf005bfa9d0058","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** @param type May be null if the type is unknown. */\r\n\tpublic <T> T readValue (String name, Class<T> type, T defaultValue, Object jsonData) {\r\n\t\tOrderedMap jsonMap = (OrderedMap)jsonData;\r\n\t\tObject jsonValue = jsonMap.get(name);\r\n\t\tif (jsonValue == null) return defaultValue;\r\n\t\treturn (T)readValue(type, null, jsonValue);\r\n\t}","id":65463,"modified_method":"/** @param type May be null if the type is unknown.\r\n\t * @return May be null. */\r\n\tpublic <T> T readValue (String name, Class<T> type, T defaultValue, Object jsonData) {\r\n\t\tOrderedMap jsonMap = (OrderedMap)jsonData;\r\n\t\tObject jsonValue = jsonMap.get(name);\r\n\t\tif (jsonValue == null) return defaultValue;\r\n\t\treturn (T)readValue(type, null, jsonValue);\r\n\t}","commit_id":"1c2d6c1c368d977acc68d7087cdf005bfa9d0058","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** @param knownType May be null if the type is unknown. */\r\n\tpublic void writeValue (String name, Object value, Class knownType) {\r\n\t\ttry {\r\n\t\t\twriter.name(name);\r\n\t\t} catch (IOException ex) {\r\n\t\t\tthrow new SerializationException(ex);\r\n\t\t}\r\n\t\twriteValue(value, knownType, null);\r\n\t}","id":65464,"modified_method":"/** @param value May be null.\r\n\t * @param knownType May be null if the type is unknown. */\r\n\tpublic void writeValue (String name, Object value, Class knownType) {\r\n\t\ttry {\r\n\t\t\twriter.name(name);\r\n\t\t} catch (IOException ex) {\r\n\t\t\tthrow new SerializationException(ex);\r\n\t\t}\r\n\t\twriteValue(value, knownType, null);\r\n\t}","commit_id":"1c2d6c1c368d977acc68d7087cdf005bfa9d0058","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** @param type May be null if the type is unknown.\r\n\t * @param elementType May be null if the type is unknown. */\r\n\tpublic <T> T readValue (String name, Class<T> type, Class elementType, Object jsonData) {\r\n\t\tOrderedMap jsonMap = (OrderedMap)jsonData;\r\n\t\treturn (T)readValue(type, elementType, jsonMap.get(name));\r\n\t}","id":65465,"modified_method":"/** @param type May be null if the type is unknown.\r\n\t * @param elementType May be null if the type is unknown.\r\n\t * @return May be null. */\r\n\tpublic <T> T readValue (String name, Class<T> type, Class elementType, Object jsonData) {\r\n\t\tOrderedMap jsonMap = (OrderedMap)jsonData;\r\n\t\treturn (T)readValue(type, elementType, jsonMap.get(name));\r\n\t}","commit_id":"1c2d6c1c368d977acc68d7087cdf005bfa9d0058","url":"https://github.com/libgdx/libgdx"},{"original_method":"public StreamSnapshotDataTarget(long hsId, Map<Integer, byte[]> schemas)\n    throws IOException {\n        super();\n        m_schemas = schemas;\n        m_destHSId = hsId;\n        m_mb = VoltDB.instance().getHostMessenger().createMailbox();\n\n        m_ackTracker = new StreamSnapshotAckTracker(m_numBuffers);\n        m_in = new StreamSnapshotAckReceiver(m_mb, m_ackTracker);\n        m_inThread = new Thread(m_in);\n        m_inThread.setDaemon(true);\n        m_out = new StreamSnapshotSender(m_mb, m_destHSId);\n        m_outThread = new Thread(m_out);\n\n        m_inThread.start();\n        m_outThread.start();\n    }","id":65466,"modified_method":"public StreamSnapshotDataTarget(long hsId, Map<Integer, byte[]> schemas)\n    throws IOException {\n        super();\n        m_schemas = schemas;\n        m_destHSId = hsId;\n        m_mb = VoltDB.instance().getHostMessenger().createMailbox();\n\n        m_in = new AckReceiver();\n        m_in.setDaemon(true);\n        m_in.start();\n    }","commit_id":"fa0a0f5f0f49324dbc5c0071c0143ce5cf0a235d","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public long getBytesWritten() {\n        return m_out.getBytesSent();\n    }","id":65467,"modified_method":"@Override\n    public long getBytesWritten() {\n        return m_bytesSent.get();\n    }","commit_id":"fa0a0f5f0f49324dbc5c0071c0143ce5cf0a235d","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public ListenableFuture<?> write(Callable<BBContainer> tupleData,\n                                     SnapshotTableTask context) {\n        assert(context != null);\n\n        BBContainer chunk = null;\n        try {\n            chunk = tupleData.call();\n        } catch (Exception e) {\n            return Futures.immediateFailedFuture(e);\n        }\n\n        if (m_writeFailed) {\n            if (chunk != null) {\n                chunk.discard();\n            }\n            return null;\n        }\n        if (!m_outThread.isAlive()) {\n            if (chunk != null) {\n                chunk.discard();\n            }\n\n            m_writeFailed = true;\n            IOException e = new IOException(\"Trying to write snapshot data \" +\n                    \"after the stream is closed\");\n            return Futures.immediateFailedFuture(e);\n        }\n\n        if (chunk != null) {\n            // Have we seen this table before, if not, send schema\n            if (m_schemas.containsKey(context.getTableId())) {\n                // remove the schema once sent\n                byte[] schema = m_schemas.remove(context.getTableId());\n                rejoinLog.debug(\"Sending schema for table \" + context.getTableId());\n                sendSchema(schema);\n            }\n\n            chunk.b.put((byte) StreamSnapshotMessageType.DATA.ordinal());\n            chunk.b.putInt(m_blockIndex++); // put chunk index\n            chunk.b.putInt(context.getTableId()); // put table ID\n            chunk.b.position(0);\n\n            m_ackTracker.waitForAcks(m_blockIndex - 1, 1);\n            m_out.offer(chunk);\n        }\n\n        return null;\n    }","id":65468,"modified_method":"@Override\n    public ListenableFuture<?> write(Callable<BBContainer> tupleData,\n                                     SnapshotTableTask context) {\n        assert(context != null);\n\n        rejoinLog.info(\"Starting write\");\n\n        try {\n            BBContainer chunk = null;\n            try {\n                chunk = tupleData.call();\n            } catch (Exception e) {\n                return Futures.immediateFailedFuture(e);\n            }\n\n            if (m_writeFailed) {\n                if (chunk != null) {\n                    chunk.discard();\n                }\n                return null;\n            }\n            if (m_closed) {\n                if (chunk != null) {\n                    chunk.discard();\n                }\n\n                m_writeFailed = true;\n                IOException e = new IOException(\"Trying to write snapshot data \" +\n                        \"after the stream is closed\");\n                return Futures.immediateFailedFuture(e);\n            }\n\n            if (chunk != null) {\n                BBContainer schemaContainer = null;\n\n                // Have we seen this table before, if not, send schema\n                if (m_schemas.containsKey(context.getTableId())) {\n                    // remove the schema once sent\n                    byte[] schema = m_schemas.remove(context.getTableId());\n                    rejoinLog.debug(\"Sending schema for table \" + context.getTableId());\n\n                    ByteBuffer buf = ByteBuffer.allocate(schema.length + 1); // 1 byte for the type\n                    buf.put((byte) StreamSnapshotMessageType.SCHEMA.ordinal());\n                    buf.put(schema);\n                    buf.flip();\n                    schemaContainer = DBBPool.wrapBB(buf);\n\n                    rejoinLog.info(\"Writing schema as part of this write\");\n                }\n\n                chunk.b.put((byte) StreamSnapshotMessageType.DATA.ordinal());\n                chunk.b.putInt(m_blockIndex); // put chunk index\n                chunk.b.putInt(context.getTableId()); // put table ID\n                chunk.b.position(0);\n\n                SendWork sendWork = new SendWork(m_blockIndex, schemaContainer, chunk);\n                m_outstandingWork.put(m_blockIndex, sendWork);\n                m_outstandingWorkCount.incrementAndGet();\n                m_es.submit(sendWork);\n\n                rejoinLog.info(\"Submitted write with index \" + String.valueOf(m_blockIndex));\n\n                m_blockIndex++;\n            }\n\n            return null;\n        }\n        finally {\n            rejoinLog.info(\"Finished call to write\");\n        }\n    }","commit_id":"fa0a0f5f0f49324dbc5c0071c0143ce5cf0a235d","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public synchronized void close() throws IOException, InterruptedException {\n        /*\n         * could be called multiple times, because all tables share one stream\n         * target\n         */\n        if (m_mb != null) {\n            closeIO();\n            /*\n             * only join the out thread, once the socket is closed, the in\n             * thread will terminate\n             */\n            m_outThread.join();\n            VoltDB.instance().getHostMessenger().removeMailbox(m_mb.getHSId());\n            m_mb = null;\n        }\n\n        if (m_onCloseHandler != null) {\n            m_onCloseHandler.run();\n        }\n    }","id":65469,"modified_method":"@Override\n    public synchronized void close() throws IOException, InterruptedException {\n        /*\n         * could be called multiple times, because all tables share one stream\n         * target\n         */\n        if (!m_closed) {\n            rejoinLog.debug(\"Closing stream snapshot target\");\n\n            // block until all acks have arrived\n            while (!m_writeFailed && m_outstandingWorkCount.get() > 0) {\n                Thread.yield();\n            }\n\n            // Send EOF\n            ByteBuffer buf = ByteBuffer.allocate(1);\n            buf.put((byte) StreamSnapshotMessageType.END.ordinal());\n            buf.flip();\n            byte compressedBytes[] =\n                    CompressionService.compressBytes(\n                            buf.array(), buf.position(),\n                            buf.remaining());\n            RejoinDataMessage msg = new RejoinDataMessage(compressedBytes);\n            m_mb.send(m_destHSId, msg);\n            m_bytesSent.addAndGet(compressedBytes.length);\n\n            // release the mailbox and close the socket\n            VoltDB.instance().getHostMessenger().removeMailbox(m_mb.getHSId());\n            m_mb = null;\n\n            m_closed = true;\n\n            rejoinLog.debug(\"Closed stream snapshot target\");\n        }\n\n        if (m_onCloseHandler != null) {\n            m_onCloseHandler.run();\n        }\n    }","commit_id":"fa0a0f5f0f49324dbc5c0071c0143ce5cf0a235d","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public Throwable getLastWriteException() {\n        Throwable lastException = m_out.getLastException();\n        if (lastException == null) {\n            lastException = m_in.getLastException();\n        }\n        return lastException;\n    }","id":65470,"modified_method":"@Override\n    public Throwable getLastWriteException() {\n        if (m_lastSenderException != null) {\n            return m_lastSenderException;\n        }\n        return m_lastAckReceiverException;\n    }","commit_id":"fa0a0f5f0f49324dbc5c0071c0143ce5cf0a235d","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Process a message pulled off from the network thread, and discard the\n     * container once it's processed.\n     *\n     * @param msg A pair of <sourceHSId, blockContainer>\n     * @return The processed message, or null if there's no data block to return\n     *         to the site.\n     */\n    private Pair<Integer, ByteBuffer> processMessage(Pair<Long, BBContainer> msg) {\n        if (msg == null) {\n            return null;\n        }\n\n        long hsId = msg.getFirst();\n        BBContainer container = msg.getSecond();\n        try {\n            ByteBuffer block = container.b;\n            byte typeByte = block.get(StreamSnapshotDataTarget.typeOffset);\n            StreamSnapshotMessageType type = StreamSnapshotMessageType.values()[typeByte];\n            if (type == StreamSnapshotMessageType.END) {\n                // End of stream, no need to ack this buffer\n                m_EOF = true;\n                return null;\n            } else if (type == StreamSnapshotMessageType.SCHEMA) {\n                block.position(block.position() + 1);\n                m_schema = new byte[block.remaining()];\n                block.get(m_schema);\n                return null;\n            }\n\n            // It's normal snapshot data afterwards\n\n            final int blockIndex = block.getInt(StreamSnapshotDataTarget.blockIndexOffset);\n            final int tableId = block.getInt(StreamSnapshotDataTarget.tableIdOffset);\n\n            if (m_schema == null) {\n                VoltDB.crashLocalVoltDB(\"No schema for table with ID \" + tableId,\n                                        false, null);\n            }\n\n            // Get the byte buffer ready to be consumed\n            block.position(StreamSnapshotDataTarget.contentOffset);\n            ByteBuffer nextChunk = getNextChunk(block);\n            m_bytesReceived += nextChunk.remaining();\n\n            // Queue ack to this block\n            m_ack.ack(hsId, blockIndex);\n\n            return Pair.of(tableId, nextChunk);\n        } finally {\n            container.discard();\n        }\n    }","id":65471,"modified_method":"/**\n     * Process a message pulled off from the network thread, and discard the\n     * container once it's processed.\n     *\n     * @param msg A pair of <sourceHSId, blockContainer>\n     * @return The processed message, or null if there's no data block to return\n     *         to the site.\n     */\n    private Pair<Integer, ByteBuffer> processMessage(Pair<Long, BBContainer> msg) {\n        if (msg == null) {\n            return null;\n        }\n\n        long hsId = msg.getFirst();\n        BBContainer container = msg.getSecond();\n        try {\n            ByteBuffer block = container.b;\n            byte typeByte = block.get(StreamSnapshotDataTarget.typeOffset);\n            StreamSnapshotMessageType type = StreamSnapshotMessageType.values()[typeByte];\n            if (type == StreamSnapshotMessageType.END) {\n                rejoinLog.trace(\"Got END message\");\n\n                // End of stream, no need to ack this buffer\n                m_EOF = true;\n                return null;\n            } else if (type == StreamSnapshotMessageType.SCHEMA) {\n                rejoinLog.trace(\"Got SCHEMA message\");\n\n                block.position(block.position() + 1);\n                m_schema = new byte[block.remaining()];\n                block.get(m_schema);\n                return null;\n            }\n\n            // It's normal snapshot data afterwards\n\n            final int blockIndex = block.getInt(StreamSnapshotDataTarget.blockIndexOffset);\n            final int tableId = block.getInt(StreamSnapshotDataTarget.tableIdOffset);\n\n            if (m_schema == null) {\n                VoltDB.crashLocalVoltDB(\"No schema for table with ID \" + tableId,\n                                        false, null);\n            }\n\n            // Get the byte buffer ready to be consumed\n            block.position(StreamSnapshotDataTarget.contentOffset);\n            ByteBuffer nextChunk = getNextChunk(block);\n            m_bytesReceived += nextChunk.remaining();\n\n            // Queue ack to this block\n            m_ack.ack(hsId, blockIndex);\n\n            return Pair.of(tableId, nextChunk);\n        } finally {\n            container.discard();\n        }\n    }","commit_id":"fa0a0f5f0f49324dbc5c0071c0143ce5cf0a235d","url":"https://github.com/VoltDB/voltdb"},{"original_method":"protected SPDYServerConnector newHTTPSPDYServerConnector()\n    {\n        return new HTTPSPDYServerConnector();\n    }","id":65472,"modified_method":"protected SPDYServerConnector newHTTPSPDYServerConnector()\n    {\n        // For these tests, we need the connector to speak HTTP over SPDY even in non-SSL\n        return new HTTPSPDYServerConnector()\n        {\n            @Override\n            protected AsyncConnectionFactory getDefaultAsyncConnectionFactory()\n            {\n                return new ServerHTTPSPDYAsyncConnectionFactory(SPDY.V2, this);\n            }\n        };\n    }","commit_id":"34509312f0c365e1cf76359558a1359332f45cd1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private boolean onPair()\n    {\n        settings.put(key, value);\n        state = State.KEY;\n        key = null;\n        value = 0;\n        --count;\n        if (count == 0)\n        {\n            onSettings();\n            return true;\n        }\n        return false;\n    }","id":65473,"modified_method":"private boolean onPair()\n    {\n        int id = (idAndFlags & 0xFF_FF_FF_00) >>> 8;\n        int flags = idAndFlags & 0xFF;\n        settings.put(new Settings.Setting(Settings.ID.from(id), Settings.Flag.from(flags), value));\n        state = State.KEY;\n        idAndFlags = 0;\n        value = 0;\n        --count;\n        if (count == 0)\n        {\n            onSettings();\n            return true;\n        }\n        return false;\n    }","commit_id":"34509312f0c365e1cf76359558a1359332f45cd1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public boolean parse(ByteBuffer buffer) throws StreamException\n    {\n        while (buffer.hasRemaining())\n        {\n            switch (state)\n            {\n                case COUNT:\n                {\n                    if (buffer.remaining() >= 4)\n                    {\n                        count = buffer.getInt();\n                        state = State.KEY;\n                    }\n                    else\n                    {\n                        state = State.COUNT_BYTES;\n                        cursor = 4;\n                    }\n                    break;\n                }\n                case COUNT_BYTES:\n                {\n                    byte currByte = buffer.get();\n                    --cursor;\n                    count += (currByte & 0xFF) << 8 * cursor;\n                    if (cursor == 0)\n                        state = State.KEY;\n                    break;\n                }\n                case KEY:\n                {\n                    if (buffer.remaining() >= 4)\n                    {\n                        int idAndFlags = convertIdAndFlags(controlFrameParser.getVersion(), buffer.getInt());\n                        key = new SettingsInfo.Key(idAndFlags);\n                        state = State.VALUE;\n                    }\n                    else\n                    {\n                        state = State.KEY_BYTES;\n                        cursor = 4;\n                    }\n                    break;\n                }\n                case KEY_BYTES:\n                {\n                    byte currByte = buffer.get();\n                    --cursor;\n                    value += (currByte & 0xFF) << 8 * cursor;\n                    if (cursor == 0)\n                    {\n                        int idAndFlags = convertIdAndFlags(controlFrameParser.getVersion(), value);\n                        key = new SettingsInfo.Key(idAndFlags);\n                        state = State.VALUE;\n                    }\n                    break;\n                }\n                case VALUE:\n                {\n                    if (buffer.remaining() >= 4)\n                    {\n                        value = buffer.getInt();\n                        if (onPair())\n                            return true;\n                    }\n                    else\n                    {\n                        state = State.VALUE_BYTES;\n                        cursor = 4;\n                        value = 0;\n                    }\n                    break;\n                }\n                case VALUE_BYTES:\n                {\n                    byte currByte = buffer.get();\n                    --cursor;\n                    value += (currByte & 0xFF) << 8 * cursor;\n                    if (cursor == 0)\n                    {\n                        if (onPair())\n                            return true;\n                    }\n                    break;\n                }\n                default:\n                {\n                    throw new IllegalStateException();\n                }\n            }\n        }\n        return false;\n    }","id":65474,"modified_method":"@Override\n    public boolean parse(ByteBuffer buffer) throws StreamException\n    {\n        while (buffer.hasRemaining())\n        {\n            switch (state)\n            {\n                case COUNT:\n                {\n                    if (buffer.remaining() >= 4)\n                    {\n                        count = buffer.getInt();\n                        state = State.KEY;\n                    }\n                    else\n                    {\n                        state = State.COUNT_BYTES;\n                        cursor = 4;\n                    }\n                    break;\n                }\n                case COUNT_BYTES:\n                {\n                    byte currByte = buffer.get();\n                    --cursor;\n                    count += (currByte & 0xFF) << 8 * cursor;\n                    if (cursor == 0)\n                        state = State.KEY;\n                    break;\n                }\n                case KEY:\n                {\n                    if (buffer.remaining() >= 4)\n                    {\n                        idAndFlags = convertIdAndFlags(controlFrameParser.getVersion(), buffer.getInt());\n                        state = State.VALUE;\n                    }\n                    else\n                    {\n                        state = State.KEY_BYTES;\n                        cursor = 4;\n                    }\n                    break;\n                }\n                case KEY_BYTES:\n                {\n                    byte currByte = buffer.get();\n                    --cursor;\n                    value += (currByte & 0xFF) << 8 * cursor;\n                    if (cursor == 0)\n                    {\n                        idAndFlags = convertIdAndFlags(controlFrameParser.getVersion(), value);\n                        state = State.VALUE;\n                    }\n                    break;\n                }\n                case VALUE:\n                {\n                    if (buffer.remaining() >= 4)\n                    {\n                        value = buffer.getInt();\n                        if (onPair())\n                            return true;\n                    }\n                    else\n                    {\n                        state = State.VALUE_BYTES;\n                        cursor = 4;\n                        value = 0;\n                    }\n                    break;\n                }\n                case VALUE_BYTES:\n                {\n                    byte currByte = buffer.get();\n                    --cursor;\n                    value += (currByte & 0xFF) << 8 * cursor;\n                    if (cursor == 0)\n                    {\n                        if (onPair())\n                            return true;\n                    }\n                    break;\n                }\n                default:\n                {\n                    throw new IllegalStateException();\n                }\n            }\n        }\n        return false;\n    }","commit_id":"34509312f0c365e1cf76359558a1359332f45cd1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void reset()\n    {\n        settings.clear();\n        state = State.COUNT;\n        cursor = 0;\n        count = 0;\n        key = null;\n        value = 0;\n    }","id":65475,"modified_method":"private void reset()\n    {\n        settings.clear();\n        state = State.COUNT;\n        cursor = 0;\n        count = 0;\n        idAndFlags = 0;\n        value = 0;\n    }","commit_id":"34509312f0c365e1cf76359558a1359332f45cd1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void onSettings()\n    {\n        SettingsFrame frame = new SettingsFrame(controlFrameParser.getVersion(), controlFrameParser.getFlags(), new HashMap<>(settings));\n        controlFrameParser.onControlFrame(frame);\n        reset();\n    }","id":65476,"modified_method":"private void onSettings()\n    {\n        SettingsFrame frame = new SettingsFrame(controlFrameParser.getVersion(), controlFrameParser.getFlags(), new Settings(settings, true));\n        controlFrameParser.onControlFrame(frame);\n        reset();\n    }","commit_id":"34509312f0c365e1cf76359558a1359332f45cd1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public SettingsFrame(short version, byte flags, Map<SettingsInfo.Key, Integer> settings)\n    {\n        super(version, ControlFrameType.SETTINGS, flags);\n        this.settings = settings;\n    }","id":65477,"modified_method":"public SettingsFrame(short version, byte flags, Settings settings)\n    {\n        super(version, ControlFrameType.SETTINGS, flags);\n        this.settings = settings;\n    }","commit_id":"34509312f0c365e1cf76359558a1359332f45cd1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerateParseOneByteAtATime() throws Exception\n    {\n        byte flags = SettingsInfo.CLEAR_PERSISTED;\n        Map<SettingsInfo.Key, Integer> pairs = new HashMap<>();\n        pairs.put(new SettingsInfo.Key(SettingsInfo.Key.FLAG_PERSIST | SettingsInfo.Key.MAX_CONCURRENT_STREAMS), 100);\n        pairs.put(new SettingsInfo.Key(SettingsInfo.Key.FLAG_PERSISTED | SettingsInfo.Key.ROUND_TRIP_TIME), 500);\n        SettingsFrame frame1 = new SettingsFrame(SPDY.V2, flags, pairs);\n        Generator generator = new Generator(new StandardCompressionFactory().newCompressor());\n        ByteBuffer buffer = generator.control(frame1);\n\n        Assert.assertNotNull(buffer);\n\n        TestSPDYParserListener listener = new TestSPDYParserListener();\n        Parser parser = new Parser(new StandardCompressionFactory().newDecompressor());\n        parser.addListener(listener);\n        while (buffer.hasRemaining())\n            parser.parse(ByteBuffer.wrap(new byte[]{buffer.get()}));\n        ControlFrame frame2 = listener.getControlFrame();\n\n        Assert.assertNotNull(frame2);\n        Assert.assertEquals(ControlFrameType.SETTINGS, frame2.getType());\n        SettingsFrame settings = (SettingsFrame)frame2;\n        Assert.assertEquals(SPDY.V2, settings.getVersion());\n        Assert.assertEquals(flags, settings.getFlags());\n        Assert.assertEquals(pairs, settings.getSettings());\n    }","id":65478,"modified_method":"@Test\n    public void testGenerateParseOneByteAtATime() throws Exception\n    {\n        byte flags = SettingsInfo.CLEAR_PERSISTED;\n        Settings settings = new Settings();\n        settings.put(new Settings.Setting(Settings.ID.DOWNLOAD_RETRANSMISSION_RATE, 100));\n        settings.put(new Settings.Setting(Settings.ID.ROUND_TRIP_TIME, 500));\n        SettingsFrame frame1 = new SettingsFrame(SPDY.V2, flags, settings);\n        Generator generator = new Generator(new StandardCompressionFactory().newCompressor());\n        ByteBuffer buffer = generator.control(frame1);\n\n        Assert.assertNotNull(buffer);\n\n        TestSPDYParserListener listener = new TestSPDYParserListener();\n        Parser parser = new Parser(new StandardCompressionFactory().newDecompressor());\n        parser.addListener(listener);\n        while (buffer.hasRemaining())\n            parser.parse(ByteBuffer.wrap(new byte[]{buffer.get()}));\n        ControlFrame frame2 = listener.getControlFrame();\n\n        Assert.assertNotNull(frame2);\n        Assert.assertEquals(ControlFrameType.SETTINGS, frame2.getType());\n        SettingsFrame settingsFrame = (SettingsFrame)frame2;\n        Assert.assertEquals(SPDY.V2, settingsFrame.getVersion());\n        Assert.assertEquals(flags, settingsFrame.getFlags());\n        Assert.assertEquals(settings, settingsFrame.getSettings());\n    }","commit_id":"34509312f0c365e1cf76359558a1359332f45cd1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerateParse() throws Exception\n    {\n        byte flags = SettingsInfo.CLEAR_PERSISTED;\n        Map<SettingsInfo.Key, Integer> pairs = new HashMap<>();\n        pairs.put(new SettingsInfo.Key(SettingsInfo.Key.FLAG_PERSIST | SettingsInfo.Key.MAX_CONCURRENT_STREAMS), 100);\n        pairs.put(new SettingsInfo.Key(SettingsInfo.Key.FLAG_PERSISTED | SettingsInfo.Key.ROUND_TRIP_TIME), 500);\n        SettingsFrame frame1 = new SettingsFrame(SPDY.V2, flags, pairs);\n        Generator generator = new Generator(new StandardCompressionFactory().newCompressor());\n        ByteBuffer buffer = generator.control(frame1);\n\n        Assert.assertNotNull(buffer);\n\n        TestSPDYParserListener listener = new TestSPDYParserListener();\n        Parser parser = new Parser(new StandardCompressionFactory().newDecompressor());\n        parser.addListener(listener);\n        parser.parse(buffer);\n        ControlFrame frame2 = listener.getControlFrame();\n\n        Assert.assertNotNull(frame2);\n        Assert.assertEquals(ControlFrameType.SETTINGS, frame2.getType());\n        SettingsFrame settings = (SettingsFrame)frame2;\n        Assert.assertEquals(SPDY.V2, settings.getVersion());\n        Assert.assertEquals(flags, settings.getFlags());\n        Assert.assertEquals(pairs, settings.getSettings());\n    }","id":65479,"modified_method":"@Test\n    public void testGenerateParse() throws Exception\n    {\n        byte flags = SettingsInfo.CLEAR_PERSISTED;\n        Settings settings = new Settings();\n        settings.put(new Settings.Setting(Settings.ID.MAX_CONCURRENT_STREAMS, Settings.Flag.PERSIST, 100));\n        settings.put(new Settings.Setting(Settings.ID.ROUND_TRIP_TIME, Settings.Flag.PERSISTED, 500));\n        SettingsFrame frame1 = new SettingsFrame(SPDY.V2, flags, settings);\n        Generator generator = new Generator(new StandardCompressionFactory().newCompressor());\n        ByteBuffer buffer = generator.control(frame1);\n\n        Assert.assertNotNull(buffer);\n\n        TestSPDYParserListener listener = new TestSPDYParserListener();\n        Parser parser = new Parser(new StandardCompressionFactory().newDecompressor());\n        parser.addListener(listener);\n        parser.parse(buffer);\n        ControlFrame frame2 = listener.getControlFrame();\n\n        Assert.assertNotNull(frame2);\n        Assert.assertEquals(ControlFrameType.SETTINGS, frame2.getType());\n        SettingsFrame settingsFrame = (SettingsFrame)frame2;\n        Assert.assertEquals(SPDY.V2, settingsFrame.getVersion());\n        Assert.assertEquals(flags, settingsFrame.getFlags());\n        Assert.assertEquals(settings, settingsFrame.getSettings());\n    }","commit_id":"34509312f0c365e1cf76359558a1359332f45cd1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public ByteBuffer generate(ControlFrame frame) throws StreamException\n    {\n        SettingsFrame settings = (SettingsFrame)frame;\n\n        Map<SettingsInfo.Key, Integer> pairs = settings.getSettings();\n        int size = pairs.size();\n        int frameBodyLength = 4 + 8 * size;\n        int totalLength = ControlFrame.HEADER_LENGTH + frameBodyLength;\n        ByteBuffer buffer = ByteBuffer.allocate(totalLength);\n        generateControlFrameHeader(settings, frameBodyLength, buffer);\n\n        buffer.putInt(size);\n\n        for (Map.Entry<SettingsInfo.Key, Integer> entry : pairs.entrySet())\n        {\n            int idAndFlags = convertIdAndFlags(frame.getVersion(), entry.getKey().getKey());\n            buffer.putInt(idAndFlags);\n            buffer.putInt(entry.getValue());\n        }\n\n        buffer.flip();\n        return buffer;\n    }","id":65480,"modified_method":"@Override\n    public ByteBuffer generate(ControlFrame frame) throws StreamException\n    {\n        SettingsFrame settingsFrame = (SettingsFrame)frame;\n\n        Settings settings = settingsFrame.getSettings();\n        int size = settings.size();\n        int frameBodyLength = 4 + 8 * size;\n        int totalLength = ControlFrame.HEADER_LENGTH + frameBodyLength;\n        ByteBuffer buffer = ByteBuffer.allocate(totalLength);\n        generateControlFrameHeader(settingsFrame, frameBodyLength, buffer);\n\n        buffer.putInt(size);\n\n        for (Settings.Setting setting : settings)\n        {\n            int id = setting.getId().getCode();\n            int flags = setting.getFlag().getCode();\n            int idAndFlags = (id << 8) + flags;\n            idAndFlags = convertIdAndFlags(frame.getVersion(), idAndFlags);\n            buffer.putInt(idAndFlags);\n            buffer.putInt(setting.getValue());\n        }\n\n        buffer.flip();\n        return buffer;\n    }","commit_id":"34509312f0c365e1cf76359558a1359332f45cd1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public SettingsInfo(Map<Key, Integer> settings, boolean clearPersisted)\n    {\n        this.settings = settings;\n        this.clearPersisted = clearPersisted;\n    }","id":65481,"modified_method":"public SettingsInfo(Settings settings, boolean clearPersisted)\n    {\n        this.settings = settings;\n        this.clearPersisted = clearPersisted;\n    }","commit_id":"34509312f0c365e1cf76359558a1359332f45cd1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testServerSettings() throws Exception\n    {\n        Map<SettingsInfo.Key,Integer> settings = new HashMap<>();\n        settings.put(new SettingsInfo.Key(SettingsInfo.Key.UPLOAD_BANDWIDTH), 1024 * 1024);\n        settings.put(new SettingsInfo.Key(SettingsInfo.Key.DOWNLOAD_BANDWIDTH), 1024 * 1024);\n        settings.put(new SettingsInfo.Key(SettingsInfo.Key.FLAG_PERSIST | SettingsInfo.Key.CURRENT_CONGESTION_WINDOW), 1024);\n        final SettingsInfo serverSettingsInfo = new SettingsInfo(settings);\n        ServerSessionFrameListener serverSessionFrameListener = new ServerSessionFrameListener.Adapter()\n        {\n            @Override\n            public void onConnect(Session session)\n            {\n                session.settings(serverSettingsInfo);\n            }\n        };\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        SessionFrameListener clientSessionFrameListener = new SessionFrameListener.Adapter()\n        {\n            @Override\n            public void onSettings(Session session, SettingsInfo clientSettingsInfo)\n            {\n                Assert.assertEquals(serverSettingsInfo, clientSettingsInfo);\n                latch.countDown();\n            }\n        };\n\n        startClient(startServer(serverSessionFrameListener), clientSessionFrameListener);\n\n        Assert.assertTrue(latch.await(5, TimeUnit.SECONDS));\n    }","id":65482,"modified_method":"@Test\n    public void testServerSettings() throws Exception\n    {\n        Settings settings = new Settings();\n        settings.put(new Settings.Setting(Settings.ID.UPLOAD_BANDWIDTH, 1024 * 1024));\n        settings.put(new Settings.Setting(Settings.ID.DOWNLOAD_BANDWIDTH, 1024 * 1024));\n        settings.put(new Settings.Setting(Settings.ID.CURRENT_CONGESTION_WINDOW, Settings.Flag.PERSIST, 1024));\n        final SettingsInfo serverSettingsInfo = new SettingsInfo(settings);\n        ServerSessionFrameListener serverSessionFrameListener = new ServerSessionFrameListener.Adapter()\n        {\n            @Override\n            public void onConnect(Session session)\n            {\n                session.settings(serverSettingsInfo);\n            }\n        };\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        SessionFrameListener clientSessionFrameListener = new SessionFrameListener.Adapter()\n        {\n            @Override\n            public void onSettings(Session session, SettingsInfo clientSettingsInfo)\n            {\n                Assert.assertEquals(serverSettingsInfo.getFlags(), clientSettingsInfo.getFlags());\n                Assert.assertEquals(serverSettingsInfo.getSettings(), clientSettingsInfo.getSettings());\n                latch.countDown();\n            }\n        };\n\n        startClient(startServer(serverSessionFrameListener), clientSessionFrameListener);\n\n        Assert.assertTrue(latch.await(5, TimeUnit.SECONDS));\n    }","commit_id":"34509312f0c365e1cf76359558a1359332f45cd1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSettings() throws Exception\n    {\n        Map<SettingsInfo.Key,Integer> settings = new HashMap<>();\n        settings.put(new SettingsInfo.Key(SettingsInfo.Key.UPLOAD_BANDWIDTH), 1024 * 1024);\n        settings.put(new SettingsInfo.Key(SettingsInfo.Key.DOWNLOAD_BANDWIDTH), 1024 * 1024);\n        settings.put(new SettingsInfo.Key(SettingsInfo.Key.FLAG_PERSISTED | SettingsInfo.Key.CURRENT_CONGESTION_WINDOW), 1024);\n        final SettingsInfo clientSettingsInfo = new SettingsInfo(settings);\n        final CountDownLatch latch = new CountDownLatch(1);\n        ServerSessionFrameListener serverSessionFrameListener = new ServerSessionFrameListener.Adapter()\n        {\n            @Override\n            public void onSettings(Session session, SettingsInfo serverSettingsInfo)\n            {\n                Assert.assertEquals(clientSettingsInfo, serverSettingsInfo);\n                latch.countDown();\n            }\n        };\n        Session session = startClient(startServer(serverSessionFrameListener), null);\n\n        session.settings(clientSettingsInfo);\n\n        Assert.assertTrue(latch.await(5, TimeUnit.SECONDS));\n    }","id":65483,"modified_method":"@Test\n    public void testSettings() throws Exception\n    {\n        Settings settings = new Settings();\n        settings.put(new Settings.Setting(Settings.ID.UPLOAD_BANDWIDTH, 1024 * 1024));\n        settings.put(new Settings.Setting(Settings.ID.DOWNLOAD_BANDWIDTH, 1024 * 1024));\n        settings.put(new Settings.Setting(Settings.ID.CURRENT_CONGESTION_WINDOW, Settings.Flag.PERSISTED, 1024));\n        final SettingsInfo clientSettingsInfo = new SettingsInfo(settings);\n        final CountDownLatch latch = new CountDownLatch(1);\n        ServerSessionFrameListener serverSessionFrameListener = new ServerSessionFrameListener.Adapter()\n        {\n            @Override\n            public void onSettings(Session session, SettingsInfo serverSettingsInfo)\n            {\n                Assert.assertEquals(clientSettingsInfo.getFlags(), serverSettingsInfo.getFlags());\n                Assert.assertEquals(clientSettingsInfo.getSettings(), serverSettingsInfo.getSettings());\n                latch.countDown();\n            }\n        };\n        Session session = startClient(startServer(serverSessionFrameListener), null);\n\n        session.settings(clientSettingsInfo);\n\n        Assert.assertTrue(latch.await(5, TimeUnit.SECONDS));\n    }","commit_id":"34509312f0c365e1cf76359558a1359332f45cd1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void onSettings(SettingsFrame frame)\n    {\n        notifyOnSettings(frame);\n        flush();\n    }","id":65484,"modified_method":"private void onSettings(SettingsFrame frame)\n    {\n        Settings.Setting windowSizeSetting = frame.getSettings().get(Settings.ID.INITIAL_WINDOW_SIZE);\n        if (windowSizeSetting != null)\n            this.windowSize = windowSizeSetting.getValue();\n        notifyOnSettings(frame);\n        flush();\n    }","commit_id":"34509312f0c365e1cf76359558a1359332f45cd1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public int getWindowSize()\n    {\n        // TODO: make this configurable through SETTINGS frame\n        return 65535;\n    }","id":65485,"modified_method":"@Override\n    public int getWindowSize()\n    {\n        return windowSize;\n    }","commit_id":"34509312f0c365e1cf76359558a1359332f45cd1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Send a pong message to the client\n     *\n     * @param data      Optional message.\n     *\n     * @throws IOException  If an error occurs writing to the client\n     */\n    public void pong(ByteBuffer data) throws IOException {\n        // TODO Think about threading requirements for writing. This is not\n        // currently thread safe and writing almost certainly needs to be.\n        if (closed) {\n            // TODO - handle this - ISE?\n        }\n\n        doFlush(true);\n\n        upgradeOutbound.write(0x8A);\n        if (data == null) {\n            upgradeOutbound.write(0);\n        } else {\n            upgradeOutbound.write(data.limit());\n            upgradeOutbound.write(data.array(), 0, data.limit());\n        }\n\n        upgradeOutbound.flush();\n    }","id":65486,"modified_method":"/**\n     * Send a pong message to the client\n     *\n     * @param data      Optional message.\n     *\n     * @throws IOException  If an error occurs writing to the client\n     */\n    public void pong(ByteBuffer data) throws IOException {\n        // TODO Think about threading requirements for writing. This is not\n        // currently thread safe and writing almost certainly needs to be.\n        if (closed) {\n            // TODO - handle this - ISE?\n        }\n\n        doFlush(true);\n\n        upgradeOutbound.write(0x8A);\n        if (data == null) {\n            upgradeOutbound.write(0);\n        } else {\n            upgradeOutbound.write(data.limit());\n            upgradeOutbound.write(data.array(), data.position(),\n                    data.limit() - data.position());\n        }\n\n        upgradeOutbound.flush();\n    }","commit_id":"f002271d69c5930a99342b01a7de4696b4920dc7","url":"https://github.com/apache/tomcat"},{"original_method":"public void close(int status, ByteBuffer data) throws IOException {\n        // TODO Think about threading requirements for writing. This is not\n        // currently thread safe and writing almost certainly needs to be.\n        if (closed) {\n            return;\n        }\n        closed = true;\n\n        upgradeOutbound.write(0x88);\n        if (status == 0) {\n            upgradeOutbound.write(0);\n        } else if (data == null || data.position() == data.limit()) {\n            upgradeOutbound.write(2);\n            upgradeOutbound.write(status >>> 8);\n            upgradeOutbound.write(status);\n        } else {\n            upgradeOutbound.write(2 + data.limit() - data.position());\n            upgradeOutbound.write(status >>> 8);\n            upgradeOutbound.write(status);\n            upgradeOutbound.write(data.array(), data.position(), data.limit());\n        }\n        upgradeOutbound.flush();\n\n        bb = null;\n        cb = null;\n        upgradeOutbound = null;\n    }","id":65487,"modified_method":"public void close(int status, ByteBuffer data) throws IOException {\n        // TODO Think about threading requirements for writing. This is not\n        // currently thread safe and writing almost certainly needs to be.\n        if (closed) {\n            return;\n        }\n        closed = true;\n\n        upgradeOutbound.write(0x88);\n        if (status == 0) {\n            upgradeOutbound.write(0);\n        } else if (data == null || data.position() == data.limit()) {\n            upgradeOutbound.write(2);\n            upgradeOutbound.write(status >>> 8);\n            upgradeOutbound.write(status);\n        } else {\n            upgradeOutbound.write(2 + data.limit() - data.position());\n            upgradeOutbound.write(status >>> 8);\n            upgradeOutbound.write(status);\n            upgradeOutbound.write(data.array(), data.position(),\n                    data.limit() - data.position());\n        }\n        upgradeOutbound.flush();\n\n        bb = null;\n        cb = null;\n        upgradeOutbound = null;\n    }","commit_id":"4568d1b49cb1b50b4f1f4101bd2bd5243568cc2b","url":"https://github.com/apache/tomcat"},{"original_method":"private static void skipUntilSemiColon(ByteBuffer bb) {\n        while(bb.hasRemaining()) {\n            if (bb.get() == EQUALS_BYTE) {\n                break;\n            }\n        }\n    }","id":65488,"modified_method":"private static void skipUntilSemiColon(ByteBuffer bb) {\n        while(bb.hasRemaining()) {\n            if (bb.get() == SEMICOLON_BYTE) {\n                break;\n            }\n        }\n    }","commit_id":"e22a3f94aa1c2598fdea26220ff113d5596fedea","url":"https://github.com/apache/tomcat"},{"original_method":"private static void logInvalidHeader(ByteBuffer bb) {\n        UserDataHelper.Mode logMode = invalidCookieLog.getNextMode();\n        if (logMode != null) {\n            String headerValue = new String(bb.array(), bb.position(), bb.limit(),\n                        StandardCharsets.UTF_8);\n            String message = sm.getString(\"cookie.invalidCookieValue\", headerValue);\n            switch (logMode) {\n                case INFO_THEN_DEBUG:\n                    message += sm.getString(\"cookie.fallToDebug\");\n                    //$FALL-THROUGH$\n                case INFO:\n                    log.info(message);\n                    break;\n                case DEBUG:\n                    log.debug(message);\n            }\n        }\n    }","id":65489,"modified_method":"private static void logInvalidHeader(ByteBuffer bb) {\n        UserDataHelper.Mode logMode = invalidCookieLog.getNextMode();\n        if (logMode != null) {\n            String headerValue = new String(bb.array(), bb.position(), bb.limit() - bb.position(),\n                        StandardCharsets.UTF_8);\n            String message = sm.getString(\"cookie.invalidCookieValue\", headerValue);\n            switch (logMode) {\n                case INFO_THEN_DEBUG:\n                    message += sm.getString(\"cookie.fallToDebug\");\n                    //$FALL-THROUGH$\n                case INFO:\n                    log.info(message);\n                    break;\n                case DEBUG:\n                    log.debug(message);\n            }\n        }\n    }","commit_id":"e22a3f94aa1c2598fdea26220ff113d5596fedea","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n  public long append(ByteBuffer inputBuf) throws IOException {\n    return write(mLocalFileChannel.size(), inputBuf);\n  }","id":65490,"modified_method":"@Override\n  public long append(ByteBuffer inputBuf) throws IOException {\n    return write(mLocalFileChannel.size(), inputBuf.duplicate());\n  }","commit_id":"7439ed7b1a4001c67215796140d17995733a2531","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Writes data to the block from an input {@link ByteBuffer}.\n   *\n   * @param offset starting offset of the block file to write\n   * @param inputBuf {@link ByteBuffer} that input data is stored in\n   * @return the size of data that was written\n   * @throws IOException\n   */\n  private long write(long offset, ByteBuffer inputBuf) throws IOException {\n    int inputBufLength = inputBuf.limit();\n    ByteBuffer outputBuf =\n        mLocalFileChannel.map(FileChannel.MapMode.READ_WRITE, offset, inputBufLength);\n    outputBuf.put(inputBuf);\n    int bytesWritten = outputBuf.limit();\n    BufferUtils.cleanDirectBuffer(outputBuf);\n    return bytesWritten;\n  }","id":65491,"modified_method":"/**\n   * Writes data to the block from an input {@link ByteBuffer}.\n   *\n   * @param offset starting offset of the block file to write\n   * @param inputBuf {@link ByteBuffer} that input data is stored in\n   * @return the size of data that was written\n   * @throws IOException\n   */\n  private long write(long offset, ByteBuffer inputBuf) throws IOException {\n    int inputBufLength = inputBuf.limit() - inputBuf.position();\n    ByteBuffer outputBuf =\n        mLocalFileChannel.map(FileChannel.MapMode.READ_WRITE, offset, inputBufLength);\n    outputBuf.put(inputBuf);\n    int bytesWritten = outputBuf.limit();\n    BufferUtils.cleanDirectBuffer(outputBuf);\n    return bytesWritten;\n  }","commit_id":"7439ed7b1a4001c67215796140d17995733a2531","url":"https://github.com/amplab/tachyon"},{"original_method":"public static String string(ByteBuffer buffer, int offset, int length, Charset charset)\n    {\n        if (buffer.hasArray())\n            return new String(buffer.array(), buffer.arrayOffset() + offset, length + buffer.arrayOffset(), charset);\n\n        byte[] buff = getArray(buffer, offset, length);\n        return new String(buff, charset);\n    }","id":65492,"modified_method":"public static String string(ByteBuffer buffer, int offset, int length, Charset charset)\n    {\n        if (buffer.hasArray())\n            return new String(buffer.array(), buffer.arrayOffset() + offset, length, charset);\n\n        byte[] buff = getArray(buffer, offset, length);\n        return new String(buff, charset);\n    }","commit_id":"b814afa4838f26524b984b1101f90d3fa0faf9ce","url":"https://github.com/apache/cassandra"},{"original_method":"/** loads a version of keyspace definitions from storage */\n    public static synchronized Collection<KSMetaData> loadFromStorage(UUID version) throws IOException\n    {\n        DecoratedKey vkey = StorageService.getPartitioner().decorateKey(Migration.toUTF8Bytes(version));\n        Table defs = Table.open(Table.SYSTEM_TABLE);\n        ColumnFamilyStore cfStore = defs.getColumnFamilyStore(Migration.SCHEMA_CF);\n        QueryFilter filter = QueryFilter.getIdentityFilter(vkey, new QueryPath(Migration.SCHEMA_CF));\n        ColumnFamily cf = cfStore.getColumnFamily(filter);\n        IColumn avroschema = cf.getColumn(DEFINITION_SCHEMA_COLUMN_NAME);\n        if (avroschema == null)\n            // TODO: more polite way to handle this?\n            throw new RuntimeException(\"Cannot read system table! Are you upgrading a pre-release version?\");\n\n        ByteBuffer value = avroschema.value();\n        Schema schema = Schema.parse(ByteBufferUtil.string(value, value.position(), value.remaining()));\n\n        // deserialize keyspaces using schema\n        Collection<KSMetaData> keyspaces = new ArrayList<KSMetaData>();\n        for (IColumn column : cf.getSortedColumns())\n        {\n            if (column.name().equals(DEFINITION_SCHEMA_COLUMN_NAME))\n                continue;\n            org.apache.cassandra.avro.KsDef ks = SerDeUtils.deserialize(schema, column.value(), new org.apache.cassandra.avro.KsDef());\n            keyspaces.add(KSMetaData.inflate(ks));\n        }\n        return keyspaces;\n    }","id":65493,"modified_method":"/** loads a version of keyspace definitions from storage */\n    public static synchronized Collection<KSMetaData> loadFromStorage(UUID version) throws IOException\n    {\n        DecoratedKey vkey = StorageService.getPartitioner().decorateKey(Migration.toUTF8Bytes(version));\n        Table defs = Table.open(Table.SYSTEM_TABLE);\n        ColumnFamilyStore cfStore = defs.getColumnFamilyStore(Migration.SCHEMA_CF);\n        QueryFilter filter = QueryFilter.getIdentityFilter(vkey, new QueryPath(Migration.SCHEMA_CF));\n        ColumnFamily cf = cfStore.getColumnFamily(filter);\n        IColumn avroschema = cf.getColumn(DEFINITION_SCHEMA_COLUMN_NAME);\n        if (avroschema == null)\n            // TODO: more polite way to handle this?\n            throw new RuntimeException(\"Cannot read system table! Are you upgrading a pre-release version?\");\n\n        ByteBuffer value = avroschema.value();\n        Schema schema = Schema.parse(ByteBufferUtil.string(value));\n\n        // deserialize keyspaces using schema\n        Collection<KSMetaData> keyspaces = new ArrayList<KSMetaData>();\n        for (IColumn column : cf.getSortedColumns())\n        {\n            if (column.name().equals(DEFINITION_SCHEMA_COLUMN_NAME))\n                continue;\n            org.apache.cassandra.avro.KsDef ks = SerDeUtils.deserialize(schema, column.value(), new org.apache.cassandra.avro.KsDef());\n            keyspaces.add(KSMetaData.inflate(ks));\n        }\n        return keyspaces;\n    }","commit_id":"b814afa4838f26524b984b1101f90d3fa0faf9ce","url":"https://github.com/apache/cassandra"},{"original_method":"private static String[] getTableAndCFNames(ByteBuffer joined)\n    {\n        int index = ByteBufferUtil.lastIndexOf(joined, SEPARATOR.getBytes()[0], joined.limit());\n\n        if (index == -1 || index < (joined.position() + 1))\n            throw new RuntimeException(\"Corrupted hint name \" + ByteBufferUtil.string(joined));\n\n        return new String[] {\n                                ByteBufferUtil.string(joined, joined.position(), index),\n                                ByteBufferUtil.string(joined, index + 1, joined.limit())\n                            };\n    }","id":65494,"modified_method":"private static String[] getTableAndCFNames(ByteBuffer joined)\n    {\n        int index = ByteBufferUtil.lastIndexOf(joined, SEPARATOR.getBytes()[0], joined.limit());\n\n        if (index == -1 || index < (joined.position() + 1))\n            throw new RuntimeException(\"Corrupted hint name \" + ByteBufferUtil.string(joined));\n\n        return new String[] {\n                                ByteBufferUtil.string(joined, joined.position(), index - joined.position()),\n                                ByteBufferUtil.string(joined, index + 1, joined.limit() - (index + 1))\n                            };\n    }","commit_id":"b814afa4838f26524b984b1101f90d3fa0faf9ce","url":"https://github.com/apache/cassandra"},{"original_method":"public DecoratedKey<BigIntegerToken> convertFromDiskFormat(ByteBuffer fromdisk)\n    {\n        // find the delimiter position\n        int splitPoint = -1;\n        for (int i = fromdisk.position(); i < fromdisk.limit(); i++)\n        {\n            if (fromdisk.get(i) == DELIMITER_BYTE)\n            {\n                splitPoint = i;\n                break;\n            }\n        }\n        assert splitPoint != -1;\n\n        // and decode the token and key\n        String token = ByteBufferUtil.string(fromdisk, fromdisk.position(), splitPoint, UTF_8);\n        ByteBuffer key = fromdisk.duplicate();\n        key.position(splitPoint + 1);\n        return new DecoratedKey<BigIntegerToken>(new BigIntegerToken(token), key);\n    }","id":65495,"modified_method":"public DecoratedKey<BigIntegerToken> convertFromDiskFormat(ByteBuffer fromdisk)\n    {\n        // find the delimiter position\n        int splitPoint = -1;\n        for (int i = fromdisk.position(); i < fromdisk.limit(); i++)\n        {\n            if (fromdisk.get(i) == DELIMITER_BYTE)\n            {\n                splitPoint = i;\n                break;\n            }\n        }\n        assert splitPoint != -1;\n\n        // and decode the token and key\n        String token = ByteBufferUtil.string(fromdisk, fromdisk.position(), splitPoint - fromdisk.position(), UTF_8);\n        ByteBuffer key = fromdisk.duplicate();\n        key.position(splitPoint + 1);\n        return new DecoratedKey<BigIntegerToken>(new BigIntegerToken(token), key);\n    }","commit_id":"b814afa4838f26524b984b1101f90d3fa0faf9ce","url":"https://github.com/apache/cassandra"},{"original_method":"public static void parseCookie(byte[] bytes, int offset, int len,\n            ServerCookies serverCookies) {\n\n        // ByteBuffer is used throughout this parser as it allows the byte[]\n        // and position information to be easily passed between parsing methods\n        ByteBuffer bb = new ByteBuffer(bytes, offset, len);\n\n        // Using RFC6265 parsing rules, check to see if the header starts with a\n        // version marker. An RFC2109 version marker may be read using RFC6265\n        // parsing rules. If version 1, use RFC2109. Else use RFC6265.\n\n        skipLWS(bb);\n\n        // Record position in case we need to return.\n        int mark = bb.position();\n\n        SkipResult skipResult = skipBytes(bb, VERSION_BYTES);\n        if (skipResult != SkipResult.FOUND) {\n            // No need to reset position since skipConstant() will have done it\n            parseCookieRfc6265(bb, serverCookies);\n            return;\n        }\n\n        skipLWS(bb);\n\n        skipResult = skipByte(bb, EQUALS_BYTE);\n        if (skipResult != SkipResult.FOUND) {\n            // Need to reset position as skipConstant() will only have reset to\n            // position before it was called\n            bb.position(mark);\n            parseCookieRfc6265(bb, serverCookies);\n            return;\n        }\n\n        skipLWS(bb);\n\n        ByteBuffer value = readCookieValue(bb);\n        if (value != null && value.remaining() == 1 && value.get() == (byte) 49) {\n            // $Version=1 -> RFC2109\n            parseCookieRfc2109(bb, serverCookies);\n            return;\n        } else {\n            // Unrecognised version.\n            // Ignore this header.\n            logInvalidVersion(value);\n        }\n    }","id":65496,"modified_method":"public static void parseCookie(byte[] bytes, int offset, int len,\n            ServerCookies serverCookies) {\n\n        // ByteBuffer is used throughout this parser as it allows the byte[]\n        // and position information to be easily passed between parsing methods\n        ByteBuffer bb = new ByteBuffer(bytes, offset, len);\n\n        // Using RFC6265 parsing rules, check to see if the header starts with a\n        // version marker. An RFC2109 version marker may be read using RFC6265\n        // parsing rules. If version 1, use RFC2109. Else use RFC6265.\n\n        skipLWS(bb);\n\n        // Record position in case we need to return.\n        int mark = bb.position();\n\n        SkipResult skipResult = skipBytes(bb, VERSION_BYTES);\n        if (skipResult != SkipResult.FOUND) {\n            // No need to reset position since skipConstant() will have done it\n            parseCookieRfc6265(bb, serverCookies);\n            return;\n        }\n\n        skipLWS(bb);\n\n        skipResult = skipByte(bb, EQUALS_BYTE);\n        if (skipResult != SkipResult.FOUND) {\n            // Need to reset position as skipConstant() will only have reset to\n            // position before it was called\n            bb.position(mark);\n            parseCookieRfc6265(bb, serverCookies);\n            return;\n        }\n\n        skipLWS(bb);\n\n        ByteBuffer value = readCookieValue(bb);\n        if (value != null && value.remaining() == 1) {\n            if (value.get() == (byte) 49) {\n                // $Version=1 -> RFC2109\n                parseCookieRfc2109(bb, serverCookies);\n                return;\n            } else {\n                // Unrecognised version.\n                // Ignore this header.\n                value.rewind();\n                logInvalidVersion(value);\n            }\n        } else {\n            // Unrecognised version.\n            // Ignore this header.\n            logInvalidVersion(value);\n        }\n    }","commit_id":"5801abc703566861fa244f8247a6b4b0cd4d214e","url":"https://github.com/apache/tomcat"},{"original_method":"private static void logInvalidVersion(ByteBuffer value) {\n        UserDataHelper.Mode logMode = invalidCookieVersionLog.getNextMode();\n        if (logMode != null) {\n            String version;\n            if (value == null) {\n                version = sm.getString(\"cookie.valueNotPresent\");\n            } else {\n                version = new String(value.bytes, value.position(), value.limit(),\n                        StandardCharsets.UTF_8);\n            }\n            String message = sm.getString(\"cookie.invalidCookieVersion\", version);\n            switch (logMode) {\n                case INFO_THEN_DEBUG:\n                    message += sm.getString(\"cookie.fallToDebug\");\n                    //$FALL-THROUGH$\n                case INFO:\n                    log.info(message);\n                    break;\n                case DEBUG:\n                    log.debug(message);\n            }\n        }\n    }","id":65497,"modified_method":"private static void logInvalidVersion(ByteBuffer value) {\n        UserDataHelper.Mode logMode = invalidCookieVersionLog.getNextMode();\n        if (logMode != null) {\n            String version;\n            if (value == null) {\n                version = sm.getString(\"cookie.valueNotPresent\");\n            } else {\n                version = new String(value.bytes, value.position(),\n                        value.limit() - value.position(), StandardCharsets.UTF_8);\n            }\n            String message = sm.getString(\"cookie.invalidCookieVersion\", version);\n            switch (logMode) {\n                case INFO_THEN_DEBUG:\n                    message += sm.getString(\"cookie.fallToDebug\");\n                    //$FALL-THROUGH$\n                case INFO:\n                    log.info(message);\n                    break;\n                case DEBUG:\n                    log.debug(message);\n            }\n        }\n    }","commit_id":"5801abc703566861fa244f8247a6b4b0cd4d214e","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Send a pong message to the client\n     *\n     * @param data      Optional message.\n     *\n     * @throws IOException  If an error occurs writing to the client\n     */\n    public void pong(ByteBuffer data) throws IOException {\n        // TODO Think about threading requirements for writing. This is not\n        // currently thread safe and writing almost certainly needs to be.\n        if (closed) {\n            throw new IOException(\"Closed\");\n        }\n\n        doFlush(true);\n\n        upgradeOutbound.write(0x8A);\n        if (data == null) {\n            upgradeOutbound.write(0);\n        } else {\n            upgradeOutbound.write(data.limit());\n            upgradeOutbound.write(data.array(), data.position(),\n                    data.limit() - data.position());\n        }\n\n        upgradeOutbound.flush();\n    }","id":65498,"modified_method":"/**\n     * Send a pong message to the client\n     *\n     * @param data      Optional message.\n     *\n     * @throws IOException  If an error occurs writing to the client\n     */\n    public void pong(ByteBuffer data) throws IOException {\n        // TODO Think about threading requirements for writing. This is not\n        // currently thread safe and writing almost certainly needs to be.\n        if (closed) {\n            throw new IOException(\"Closed\");\n        }\n\n        doFlush(true);\n\n        upgradeOutbound.write(0x8A);\n        if (data == null) {\n            upgradeOutbound.write(0);\n        } else {\n            upgradeOutbound.write(data.limit() - data.position());\n            upgradeOutbound.write(data.array(), data.position(),\n                    data.limit() - data.position());\n        }\n\n        upgradeOutbound.flush();\n    }","commit_id":"e8a0f194fc23c702d6296f99a7e6d621053ae702","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public <C> void output(C context, Callback<C> callback, WebSocketFrame frame)\n    {\n        if (frame.getOpCode().isControlFrame())\n        {\n            // Cannot fragment Control Frames\n            nextOutput(context,callback,frame);\n            return;\n        }\n\n        int fragments = 1;\n        int length = frame.getPayloadLength();\n\n        OpCode opcode = frame.getOpCode();\n        ByteBuffer payload = frame.getPayload().slice();\n        int originalLimit = payload.limit();\n\n        // break apart payload based on maxLength rules\n        if (maxLength > 0)\n        {\n            while (length > maxLength)\n            {\n                fragments++;\n\n                WebSocketFrame frag = new WebSocketFrame(frame);\n                frag.setOpCode(opcode);\n                frag.setFin(false);\n                payload.limit(Math.min(payload.limit() + maxLength,originalLimit));\n                frag.setPayload(payload);\n\n                nextOutputNoCallback(frag);\n\n                length -= maxLength;\n                opcode = OpCode.CONTINUATION;\n            }\n        }\n\n        // break apart payload based on minimum # of fragments\n        if (fragments < minFragments)\n        {\n            int fragmentsLeft = (minFragments - fragments);\n            int fragLength = length / fragmentsLeft; // equal sized fragments\n\n            while (fragments < minFragments)\n            {\n                fragments++;\n\n                WebSocketFrame frag = new WebSocketFrame(frame);\n                frag.setOpCode(opcode);\n                frag.setFin(false);\n                frag.setPayload(payload);\n\n                nextOutputNoCallback(frag);\n                length -= fragLength;\n                opcode = OpCode.CONTINUATION;\n            }\n        }\n\n        // output whatever is left\n        WebSocketFrame frag = new WebSocketFrame(frame);\n        frag.setOpCode(opcode);\n        payload.limit(originalLimit);\n        frag.setPayload(payload);\n\n        nextOutput(context,callback,frag);\n    }","id":65499,"modified_method":"@Override\n    public <C> void output(C context, Callback<C> callback, WebSocketFrame frame)\n    {\n        if (frame.getOpCode().isControlFrame())\n        {\n            // Cannot fragment Control Frames\n            nextOutput(context,callback,frame);\n            return;\n        }\n\n        int fragments = 1;\n        int length = frame.getPayloadLength();\n\n        OpCode opcode = frame.getOpCode(); // original opcode\n        ByteBuffer payload = frame.getPayload().slice();\n        int originalLimit = payload.limit();\n        int currentPosition = payload.position();\n\n        // break apart payload based on maxLength rules\n        if (maxLength > 0)\n        {\n            while (length > maxLength)\n            {\n                fragments++;\n\n                WebSocketFrame frag = new WebSocketFrame(frame);\n                frag.setOpCode(opcode);\n                frag.setFin(false); // always false here\n                payload.position(currentPosition);\n                payload.limit(Math.min(payload.position() + maxLength,originalLimit));\n                frag.setPayload(payload);\n\n                nextOutputNoCallback(frag);\n\n                length -= maxLength;\n                opcode = OpCode.CONTINUATION;\n                currentPosition = payload.limit();\n            }\n\n            // write remaining\n            WebSocketFrame frag = new WebSocketFrame(frame);\n            frag.setOpCode(opcode);\n            frag.setFin(frame.isFin()); // use original fin\n            payload.position(currentPosition);\n            payload.limit(originalLimit);\n            frag.setPayload(payload);\n\n            nextOutput(context,callback,frag);\n            return;\n        }\n\n        // break apart payload based on minimum # of fragments\n        if (fragments < minFragments)\n        {\n            int fragmentsLeft = (minFragments - fragments);\n            int fragLength = length / fragmentsLeft; // equal sized fragments\n\n            while (fragments < minFragments)\n            {\n                fragments++;\n\n                WebSocketFrame frag = new WebSocketFrame(frame);\n                frag.setOpCode(opcode);\n                frag.setFin(false);\n                frag.setPayload(payload);\n\n                nextOutputNoCallback(frag);\n                length -= fragLength;\n                opcode = OpCode.CONTINUATION;\n            }\n        }\n\n        // output whatever is left\n        WebSocketFrame frag = new WebSocketFrame(frame);\n        frag.setOpCode(opcode);\n        payload.limit(originalLimit);\n        frag.setPayload(payload);\n\n        nextOutput(context,callback,frag);\n    }","commit_id":"36360ae1d2b8788e59c7835946baa011633a22e1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * @param annotationProcessorClasses List of classes that implements\n     *            {@link AnnotationProcessor} interface.\n     * @throws SCRDescriptorFailureException\n     */\n    public AnnotationProcessorManager(\n            final String[] annotationProcessorClasses,\n            final ClassLoader classLoader )\n    throws SCRDescriptorFailureException {\n        // search for providers\n        final Iterator<AnnotationProcessor> serviceIter = ServiceRegistry.lookupProviders(AnnotationProcessor.class, classLoader);\n        while ( serviceIter.hasNext() ) {\n            final AnnotationProcessor provider = serviceIter.next();\n            this.addProvider(provider);\n        }\n\n        // add custom processors defined in the tool (maven, ant...)\n        for ( int i = 0; i < annotationProcessorClasses.length; i++ ) {\n            loadProcessor( classLoader, annotationProcessorClasses[i] );\n        }\n\n        // create ordered list\n        for(final AnnotationProcessor pro : this.processors.values() ) {\n            this.cachedProcessors.add(pro);\n        }\n        Collections.sort(this.cachedProcessors, new Comparator<AnnotationProcessor>() {\n\n            public int compare(AnnotationProcessor o1, AnnotationProcessor o2) {\n                return Integer.valueOf(o1.getRanking()).compareTo(Integer.valueOf(o2.getRanking()));\n            }\n        });\n    }","id":65500,"modified_method":"/**\n     * Create annotation processor manager.\n     * @throws SCRDescriptorFailureException\n     */\n    public AnnotationProcessorManager(final Log log,\n            final ClassLoader classLoader )\n    throws SCRDescriptorFailureException {\n        // search for providers\n        final Iterator<AnnotationProcessor> serviceIter = ServiceRegistry.lookupProviders(AnnotationProcessor.class, classLoader);\n        while ( serviceIter.hasNext() ) {\n            final AnnotationProcessor provider = serviceIter.next();\n            this.addProvider(provider);\n        }\n\n        // create ordered list\n        for(final AnnotationProcessor pro : this.processors.values() ) {\n            this.cachedProcessors.add(pro);\n        }\n        Collections.sort(this.cachedProcessors, new Comparator<AnnotationProcessor>() {\n\n            public int compare(AnnotationProcessor o1, AnnotationProcessor o2) {\n                return Integer.valueOf(o1.getRanking()).compareTo(Integer.valueOf(o2.getRanking()));\n            }\n        });\n        if ( this.cachedProcessors.size() == 0 ) {\n            throw new SCRDescriptorFailureException(\"No annotation processors found in classpath.\");\n        }\n        log.debug(\"Using annotation processors: \");\n        for(final AnnotationProcessor pro : this.cachedProcessors) {\n            log.debug(\"- \" + pro.getName() + \" - \" + pro.getRanking());\n        }\n    }","commit_id":"15e7368ff41289d1ffe57cbb75c9081455a05793","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Actually generates the Declarative Services and Metatype descriptors\n     * scanning the java sources provided by the {@link #setProject(Project)}\n     *\n     * @return A list of generated file names, relative to the output directory\n     *\n     * @throws SCRDescriptorException\n     * @throws SCRDescriptorFailureException\n     */\n    public Result execute() throws SCRDescriptorException, SCRDescriptorFailureException {\n        if (this.project == null) {\n            throw new SCRDescriptorFailureException(\"Project has not been set!\");\n        }\n        if (this.options == null) {\n            // use default options\n            this.options = new Options();\n        }\n\n        this.logger.debug(\"Starting SCRDescriptorMojo....\");\n        this.logger.debug(\"..generating accessors: \" + this.options.isGenerateAccessors());\n\n        // check speck version configuration\n        SpecVersion specVersion = options.getSpecVersion();\n        if (specVersion == null) {\n            this.logger.debug(\"..auto detecting spec version\");\n        } else {\n            this.logger.debug(\"..using spec version \" + specVersion.getName());\n        }\n\n        // create a log\n        this.iLog = new IssueLog(this.options.isStrictMode());\n\n        // create the annotation processor manager\n        final AnnotationProcessor aProcessor = new AnnotationProcessorManager(options.getAnnotationProcessors(),\n                        this.project.getClassLoader());\n\n        // create the class scanner - and start scanning\n        this.scanner = new ClassScanner(logger, iLog, project, aProcessor);\n        final List<ClassDescription> scannedDescriptions = scanner.scanSources();\n\n        // setup metadata\n        final MetaData metaData = new MetaData();\n        metaData.setLocalization(MetaTypeService.METATYPE_DOCUMENTS_LOCATION + \"/metatype\");\n\n        final List<Component> processedComponents = new ArrayList<Component>();\n        for (final ClassDescription desc : scannedDescriptions) {\n            this.logger.debug(\"Processing component class \" + desc.getSource());\n\n            // check if there is more than one component definition\n            if (desc.getDescriptions(ComponentDescription.class).size() > 1) {\n                iLog.addError(\"Class has more than one component definition.\" +\n                             \" Check the annotations and merge the definitions to a single definition.\",\n                                desc.getSource());\n            } else {\n                try {\n                    final Component comp = this.createComponent(desc, metaData, iLog);\n                    if (comp.getSpecVersion() != null) {\n                        if ( specVersion == null ) {\n                            specVersion = comp.getSpecVersion();\n                            logger.debug(\"Setting used spec version to \" + specVersion);\n                        } else if (comp.getSpecVersion().ordinal() > specVersion.ordinal() && this.options.getSpecVersion() != null) {\n                            // if a spec version has been configured and a component requires a higher\n                            // version, this is considered an error!\n                            iLog.addError(\"Component \" + comp + \" requires spec version \" + comp.getSpecVersion().name()\n                                            + \" but plugin is configured to use version \" + this.options.getSpecVersion(),\n                                            desc.getSource());\n                        }\n                    }\n                    processedComponents.add(comp);\n                } catch (final SCRDescriptorException sde) {\n                    iLog.addError(sde.getMessage(), sde.getSourceLocation());\n                }\n            }\n        }\n        // if spec version is still not set, we're using lowest available\n        if ( specVersion == null ) {\n            specVersion = SpecVersion.VERSION_1_0;\n            logger.debug(\"Using default spec version \" + specVersion);\n        }\n        this.logger.debug(\"Generating descriptor for spec version: \" + specVersion);\n\n        // now check for abstract components and fill components objects\n        final Components components = new Components();\n        components.setSpecVersion(specVersion);\n\n        for (final Component comp : processedComponents) {\n            final int errorCount = iLog.getNumberOfErrors();\n\n            final Validator validator = new Validator(comp.getClassDescription(),\n                            comp, specVersion, project, options);\n\n            if ( this.options.isGenerateAccessors() ) {\n                // before we can validate we should check the references for bind/unbind method\n                // in order to create them if possible\n\n                for (final Reference ref : comp.getReferences()) {\n                    // if this is a field with a single cardinality,\n                    // we look for the bind/unbind methods\n                    // and create them if they are not availabe\n                    if (!ref.isLookupStrategy() && ref.getField() != null\n                        && (ref.getCardinality() == ReferenceCardinality.OPTIONAL_UNARY || ref.getCardinality() == ReferenceCardinality.MANDATORY_UNARY)) {\n\n                        final String bindValue = ref.getBind();\n                        final String unbindValue = ref.getUnbind();\n                        final String name = ref.getName();\n                        final String type = ref.getInterfacename();\n\n                        boolean createBind = false;\n                        boolean createUnbind = false;\n\n                        // Only create method if no bind name has been specified\n                        if (bindValue == null && validator.findMethod(iLog, ref, \"bind\") == null) {\n                            // create bind method\n                            createBind = true;\n                        }\n                        if (unbindValue == null && validator.findMethod(iLog, ref, \"unbind\") == null) {\n                            // create unbind method\n                            createUnbind = true;\n                        }\n                        if (createBind || createUnbind) {\n                            ClassModifier.addMethods(comp.getClassDescription().getDescribedClass().getName(),\n                                            name,\n                                            ref.getField().getName(),\n                                            type,\n                                            createBind,\n                                            createUnbind,\n                                            this.project.getClassesDirectory());\n                        }\n                    }\n                }\n            }\n            validator.validate(iLog);\n\n            // ignore component if it has errors\n            if (iLog.getNumberOfErrors() == errorCount) {\n                if (!comp.isDs()) {\n                    logger.debug(\"Ignoring descriptor for DS : \" + comp);\n                } else if (!comp.isAbstract()) {\n                    this.logger.debug(\"Adding descriptor for DS : \" + comp);\n                    components.addComponent(comp);\n                }\n            }\n        }\n\n        // log issues\n        iLog.logMessages(logger);\n\n        // after checking all classes, throw if there were any failures\n        if (iLog.hasErrors()) {\n            throw new SCRDescriptorFailureException(\"SCR Descriptor parsing had failures (see log)\");\n        }\n\n        final Result result = new Result();\n        // write meta type info if there is a file name\n        if (!StringUtils.isEmpty(this.metaTypeName)) {\n            final String path = \"OSGI-INF\" + File.separator + \"metatype\" + File.separator + this.metaTypeName;\n            final File mtFile = new File(this.outputDirectory, path);\n            final int size = metaData.getOCDs().size() + metaData.getDesignates().size();\n            if (size > 0) {\n                this.logger.info(\"Generating \" + size + \" MetaType Descriptors to \" + mtFile);\n                mtFile.getParentFile().mkdirs();\n                MetaTypeIO.write(metaData, mtFile);\n                result.setMetatypeFiles(Collections.singletonList(path.replace(File.separatorChar, '/')));\n            } else {\n                if (mtFile.exists()) {\n                    mtFile.delete();\n                }\n            }\n\n        } else {\n            this.logger.info(\"Meta type file name is not set: meta type info is not written.\");\n        }\n\n        // check descriptor file\n        final String descriptorPath = \"OSGI-INF\" + File.separator + this.finalName;\n        final File descriptorFile = StringUtils.isEmpty(this.finalName) ? null : new File(this.outputDirectory, descriptorPath);\n\n        // terminate if there is nothing else to write\n        if (components.getComponents().isEmpty()) {\n            this.logger.debug(\"No Service Component Descriptors found in project.\");\n            // remove file if it exists\n            if (descriptorFile != null && descriptorFile.exists()) {\n                this.logger.debug(\"Removing obsolete service descriptor \" + descriptorFile);\n                descriptorFile.delete();\n            }\n        } else {\n            if (descriptorFile == null) {\n                throw new SCRDescriptorFailureException(\"Descriptor file name must not be empty.\");\n            }\n\n            // finally the descriptors have to be written ....\n            descriptorFile.getParentFile().mkdirs(); // ensure parent dir\n\n            this.logger.info(\"Writing \" + components.getComponents().size() + \" Service Component Descriptors to \"\n                            + descriptorFile);\n\n            ComponentDescriptorIO.write(components, descriptorFile);\n            result.setScrFiles(Collections.singletonList(descriptorPath.replace(File.separatorChar, '/')));\n        }\n\n        return result;\n    }","id":65501,"modified_method":"/**\n     * Actually generates the Declarative Services and Metatype descriptors\n     * scanning the java sources provided by the {@link #setProject(Project)}\n     *\n     * @return A list of generated file names, relative to the output directory\n     *\n     * @throws SCRDescriptorException\n     * @throws SCRDescriptorFailureException\n     */\n    public Result execute() throws SCRDescriptorException, SCRDescriptorFailureException {\n        if (this.project == null) {\n            throw new SCRDescriptorFailureException(\"Project has not been set!\");\n        }\n        if (this.options == null) {\n            // use default options\n            this.options = new Options();\n        }\n\n        this.logger.debug(\"Starting SCRDescriptorMojo....\");\n        this.logger.debug(\"..generating accessors: \" + this.options.isGenerateAccessors());\n\n        // check speck version configuration\n        SpecVersion specVersion = options.getSpecVersion();\n        if (specVersion == null) {\n            this.logger.debug(\"..auto detecting spec version\");\n        } else {\n            this.logger.debug(\"..using spec version \" + specVersion.getName());\n        }\n\n        // create a log\n        this.iLog = new IssueLog(this.options.isStrictMode());\n\n        // create the annotation processor manager\n        final AnnotationProcessor aProcessor = new AnnotationProcessorManager(this.logger,\n                        this.project.getClassLoader());\n\n        // create the class scanner - and start scanning\n        this.scanner = new ClassScanner(logger, iLog, project, aProcessor);\n        final List<ClassDescription> scannedDescriptions = scanner.scanSources();\n\n        // setup metadata\n        final MetaData metaData = new MetaData();\n        metaData.setLocalization(MetaTypeService.METATYPE_DOCUMENTS_LOCATION + \"/metatype\");\n\n        final List<Component> processedComponents = new ArrayList<Component>();\n        for (final ClassDescription desc : scannedDescriptions) {\n            this.logger.debug(\"Processing component class \" + desc.getSource());\n\n            // check if there is more than one component definition\n            if (desc.getDescriptions(ComponentDescription.class).size() > 1) {\n                iLog.addError(\"Class has more than one component definition.\" +\n                             \" Check the annotations and merge the definitions to a single definition.\",\n                                desc.getSource());\n            } else {\n                try {\n                    final Component comp = this.createComponent(desc, metaData, iLog);\n                    if (comp.getSpecVersion() != null) {\n                        if ( specVersion == null ) {\n                            specVersion = comp.getSpecVersion();\n                            logger.debug(\"Setting used spec version to \" + specVersion);\n                        } else if (comp.getSpecVersion().ordinal() > specVersion.ordinal() && this.options.getSpecVersion() != null) {\n                            // if a spec version has been configured and a component requires a higher\n                            // version, this is considered an error!\n                            iLog.addError(\"Component \" + comp + \" requires spec version \" + comp.getSpecVersion().name()\n                                            + \" but plugin is configured to use version \" + this.options.getSpecVersion(),\n                                            desc.getSource());\n                        }\n                    }\n                    processedComponents.add(comp);\n                } catch (final SCRDescriptorException sde) {\n                    iLog.addError(sde.getMessage(), sde.getSourceLocation());\n                }\n            }\n        }\n        // if spec version is still not set, we're using lowest available\n        if ( specVersion == null ) {\n            specVersion = SpecVersion.VERSION_1_0;\n            logger.debug(\"Using default spec version \" + specVersion);\n        }\n        this.logger.debug(\"Generating descriptor for spec version: \" + specVersion);\n\n        // now check for abstract components and fill components objects\n        final Components components = new Components();\n        components.setSpecVersion(specVersion);\n\n        for (final Component comp : processedComponents) {\n            final int errorCount = iLog.getNumberOfErrors();\n\n            final Validator validator = new Validator(comp.getClassDescription(),\n                            comp, specVersion, project, options);\n\n            if ( this.options.isGenerateAccessors() ) {\n                // before we can validate we should check the references for bind/unbind method\n                // in order to create them if possible\n\n                for (final Reference ref : comp.getReferences()) {\n                    // if this is a field with a single cardinality,\n                    // we look for the bind/unbind methods\n                    // and create them if they are not availabe\n                    if (!ref.isLookupStrategy() && ref.getField() != null\n                        && (ref.getCardinality() == ReferenceCardinality.OPTIONAL_UNARY || ref.getCardinality() == ReferenceCardinality.MANDATORY_UNARY)) {\n\n                        final String bindValue = ref.getBind();\n                        final String unbindValue = ref.getUnbind();\n                        final String name = ref.getName();\n                        final String type = ref.getInterfacename();\n\n                        boolean createBind = false;\n                        boolean createUnbind = false;\n\n                        // Only create method if no bind name has been specified\n                        if (bindValue == null && validator.findMethod(iLog, ref, \"bind\") == null) {\n                            // create bind method\n                            createBind = true;\n                        }\n                        if (unbindValue == null && validator.findMethod(iLog, ref, \"unbind\") == null) {\n                            // create unbind method\n                            createUnbind = true;\n                        }\n                        if (createBind || createUnbind) {\n                            ClassModifier.addMethods(comp.getClassDescription().getDescribedClass().getName(),\n                                            name,\n                                            ref.getField().getName(),\n                                            type,\n                                            createBind,\n                                            createUnbind,\n                                            this.project.getClassesDirectory());\n                        }\n                    }\n                }\n            }\n            validator.validate(iLog);\n\n            // ignore component if it has errors\n            if (iLog.getNumberOfErrors() == errorCount) {\n                if (!comp.isDs()) {\n                    logger.debug(\"Ignoring descriptor for DS : \" + comp);\n                } else if (!comp.isAbstract()) {\n                    this.logger.debug(\"Adding descriptor for DS : \" + comp);\n                    components.addComponent(comp);\n                }\n            }\n        }\n\n        // log issues\n        iLog.logMessages(logger);\n\n        // after checking all classes, throw if there were any failures\n        if (iLog.hasErrors()) {\n            throw new SCRDescriptorFailureException(\"SCR Descriptor parsing had failures (see log)\");\n        }\n\n        final Result result = new Result();\n        // write meta type info if there is a file name\n        if (!StringUtils.isEmpty(this.options.getMetaTypeName())) {\n            final String path = \"OSGI-INF\" + File.separator + \"metatype\" + File.separator + this.options.getMetaTypeName();\n            final File mtFile = new File(this.options.getOutputDirectory(), path);\n            final int size = metaData.getOCDs().size() + metaData.getDesignates().size();\n            if (size > 0) {\n                this.logger.info(\"Generating \" + size + \" MetaType Descriptors to \" + mtFile);\n                mtFile.getParentFile().mkdirs();\n                MetaTypeIO.write(metaData, mtFile);\n                result.setMetatypeFiles(Collections.singletonList(path.replace(File.separatorChar, '/')));\n            } else {\n                if (mtFile.exists()) {\n                    mtFile.delete();\n                }\n            }\n\n        } else {\n            this.logger.info(\"Meta type file name is not set: meta type info is not written.\");\n        }\n\n        // check descriptor file\n        final String descriptorPath = \"OSGI-INF\" + File.separator + this.options.getSCRName();\n        final File descriptorFile = StringUtils.isEmpty(this.options.getSCRName()) ? null : new File(this.options.getOutputDirectory(), descriptorPath);\n\n        // terminate if there is nothing else to write\n        if (components.getComponents().isEmpty()) {\n            this.logger.debug(\"No Service Component Descriptors found in project.\");\n            // remove file if it exists\n            if (descriptorFile != null && descriptorFile.exists()) {\n                this.logger.debug(\"Removing obsolete service descriptor \" + descriptorFile);\n                descriptorFile.delete();\n            }\n        } else {\n            if (descriptorFile == null) {\n                throw new SCRDescriptorFailureException(\"Descriptor file name must not be empty.\");\n            }\n\n            // finally the descriptors have to be written ....\n            descriptorFile.getParentFile().mkdirs(); // ensure parent dir\n\n            this.logger.info(\"Writing \" + components.getComponents().size() + \" Service Component Descriptors to \"\n                            + descriptorFile);\n\n            ComponentDescriptorIO.write(components, descriptorFile);\n            result.setScrFiles(Collections.singletonList(descriptorPath.replace(File.separatorChar, '/')));\n        }\n\n        return result;\n    }","commit_id":"15e7368ff41289d1ffe57cbb75c9081455a05793","url":"https://github.com/apache/felix"},{"original_method":"public void execute() throws MojoExecutionException, MojoFailureException {\n        // create the log for the generator\n        final org.apache.felix.scrplugin.Log scrLog = new MavenLog(getLog());\n        // create the class loader\n        final ClassLoader classLoader = new URLClassLoader(getClassPath(), this\n                .getClass().getClassLoader());\n\n        // create project\n        final MavenProjectScanner scanner = new MavenProjectScanner(\n                this.project, this.sourceIncludes, this.sourceExcludes, scrLog);\n\n        final Project project = new Project();\n        project.setClassLoader(classLoader);\n        project.setDependencies(scanner.getDependencies());\n        project.setSources(scanner.getSources());\n        project.setClassesDirectory(this.project.getBuild().getOutputDirectory());\n\n        // create options\n        final Options options = new Options();\n        options.setGenerateAccessors(generateAccessors);\n        options.setStrictMode(strictMode);\n        options.setProperties(properties);\n        options.setSpecVersion(SpecVersion.fromName(specVersion));\n        if ( specVersion != null && options.getSpecVersion() == null ) {\n            throw new MojoExecutionException(\"Unknown spec version specified: \" + specVersion);\n        }\n        options.setAnnotationProcessors(annotationProcessors);\n        try {\n\n            final SCRDescriptorGenerator generator = new SCRDescriptorGenerator(\n                    scrLog);\n\n            // setup from plugin configuration\n            generator.setOutputDirectory(outputDirectory);\n            generator.setOptions(options);\n            generator.setProject(project);\n            generator.setFinalName(finalName);\n            generator.setMetaTypeName(metaTypeName);\n\n            final Result result = generator.execute();\n            this.setServiceComponentHeader(result.getScrFiles());\n            this.updateProjectResources();\n\n        } catch (final SCRDescriptorException sde) {\n            throw new MojoExecutionException(sde.getMessage(), sde.getCause());\n        } catch (SCRDescriptorFailureException sdfe) {\n            throw (MojoFailureException) new MojoFailureException(\n                    sdfe.getMessage()).initCause(sdfe);\n        }\n    }","id":65502,"modified_method":"public void execute() throws MojoExecutionException, MojoFailureException {\n        // create the log for the generator\n        final org.apache.felix.scrplugin.Log scrLog = new MavenLog(getLog());\n        // create the class loader\n        final ClassLoader classLoader = new URLClassLoader(getClassPath(), this\n                .getClass().getClassLoader());\n\n        // create project\n        final MavenProjectScanner scanner = new MavenProjectScanner(\n                this.project, this.sourceIncludes, this.sourceExcludes, scrLog);\n\n        final Project project = new Project();\n        project.setClassLoader(classLoader);\n        project.setDependencies(scanner.getDependencies());\n        project.setSources(scanner.getSources());\n        project.setClassesDirectory(this.project.getBuild().getOutputDirectory());\n\n        // create options\n        final Options options = new Options();\n        options.setOutputDirectory(outputDirectory);\n        options.setSCRName(finalName);\n        options.setMetaTypeName(metaTypeName);\n        options.setGenerateAccessors(generateAccessors);\n        options.setStrictMode(strictMode);\n        options.setProperties(properties);\n        options.setSpecVersion(SpecVersion.fromName(specVersion));\n        if ( specVersion != null && options.getSpecVersion() == null ) {\n            throw new MojoExecutionException(\"Unknown spec version specified: \" + specVersion);\n        }\n\n        try {\n\n            final SCRDescriptorGenerator generator = new SCRDescriptorGenerator(\n                    scrLog);\n\n            // setup from plugin configuration\n            generator.setOptions(options);\n            generator.setProject(project);\n\n            final Result result = generator.execute();\n            this.setServiceComponentHeader(result.getScrFiles());\n            this.updateProjectResources();\n\n        } catch (final SCRDescriptorException sde) {\n            throw new MojoExecutionException(sde.getMessage(), sde.getCause());\n        } catch (SCRDescriptorFailureException sdfe) {\n            throw (MojoFailureException) new MojoFailureException(\n                    sdfe.getMessage()).initCause(sdfe);\n        }\n    }","commit_id":"15e7368ff41289d1ffe57cbb75c9081455a05793","url":"https://github.com/apache/felix"},{"original_method":"@Override\n    public void execute() throws BuildException {\n\n        // ensure we know the source\n        if (getImplicitFileSet().getDir() == null) {\n            throw new BuildException( \"srcdir attribute must be set!\", getLocation());\n        }\n\n        // while debugging\n        final org.apache.felix.scrplugin.Log scrLog = new AntLog( this );\n\n        scrLog.debug( \"SCRDescriptorTask Configuration\" );\n        scrLog.debug( \"  implicitFileset: \" + getImplicitFileSet() );\n        scrLog.debug( \"  outputDirectory: \" + destdir );\n        scrLog.debug( \"  classpath: \" + classpath );\n        scrLog.debug( \"  finalName: \" + finalName );\n        scrLog.debug( \"  metaTypeName: \" + metaTypeName );\n        scrLog.debug( \"  generateAccessors: \" + generateAccessors );\n        scrLog.debug( \"  strictMode: \" + strictMode );\n        scrLog.debug( \"  specVersion: \" + specVersion );\n\n        try {\n            final Path classPath = createClasspath();\n            final ClassLoader classLoader = getClassLoader( this.getClass().getClassLoader() );\n            final org.apache.felix.scrplugin.Project project = new org.apache.felix.scrplugin.Project();\n            project.setClassLoader(classLoader);\n            project.setDependencies(getDependencies(classPath));\n            project.setSources(getSourceFiles(getImplicitFileSet()));\n            project.setClassesDirectory(destdir.getAbsolutePath());\n\n            // create options\n            final Options options = new Options();\n            options.setGenerateAccessors(generateAccessors);\n            options.setStrictMode(strictMode);\n            options.setProperties(new HashMap<String, String>());\n            options.setSpecVersion(SpecVersion.fromName(specVersion));\n            if ( specVersion != null && options.getSpecVersion() == null ) {\n                throw new BuildException(\"Unknown spec version specified: \" + specVersion);\n            }\n            options.setAnnotationProcessors(annotationTagProviders);\n\n            final SCRDescriptorGenerator generator = new SCRDescriptorGenerator( scrLog );\n\n            // setup from plugin configuration\n            generator.setOutputDirectory(destdir);\n            generator.setOptions(options);\n            generator.setProject(project);\n            generator.setFinalName(finalName);\n            generator.setMetaTypeName(metaTypeName);\n\n            generator.execute();\n        } catch ( final SCRDescriptorException sde ) {\n            if ( sde.getSourceLocation() != null )  {\n                Location loc = new Location( sde.getSourceLocation(), sde.getLineNumber(), 0 );\n                throw new BuildException( sde.getMessage(), sde.getCause(), loc );\n            }\n            throw new BuildException( sde.getMessage(), sde.getCause() );\n        } catch ( SCRDescriptorFailureException sdfe ) {\n            throw new BuildException( sdfe.getMessage(), sdfe.getCause() );\n        }\n    }","id":65503,"modified_method":"@Override\n    public void execute() throws BuildException {\n\n        // ensure we know the source\n        if (getImplicitFileSet().getDir() == null) {\n            throw new BuildException( \"srcdir attribute must be set!\", getLocation());\n        }\n\n        // while debugging\n        final org.apache.felix.scrplugin.Log scrLog = new AntLog( this );\n\n        scrLog.debug( \"SCRDescriptorTask Configuration\" );\n        scrLog.debug( \"  implicitFileset: \" + getImplicitFileSet() );\n        scrLog.debug( \"  outputDirectory: \" + destdir );\n        scrLog.debug( \"  classpath: \" + classpath );\n        scrLog.debug( \"  finalName: \" + finalName );\n        scrLog.debug( \"  metaTypeName: \" + metaTypeName );\n        scrLog.debug( \"  generateAccessors: \" + generateAccessors );\n        scrLog.debug( \"  strictMode: \" + strictMode );\n        scrLog.debug( \"  specVersion: \" + specVersion );\n\n        try {\n            final Path classPath = createClasspath();\n            final ClassLoader classLoader = getClassLoader( this.getClass().getClassLoader() );\n            final org.apache.felix.scrplugin.Project project = new org.apache.felix.scrplugin.Project();\n            project.setClassLoader(classLoader);\n            project.setDependencies(getDependencies(classPath));\n            project.setSources(getSourceFiles(getImplicitFileSet()));\n            project.setClassesDirectory(destdir.getAbsolutePath());\n\n            // create options\n            final Options options = new Options();\n            options.setOutputDirectory(destdir);\n            options.setSCRName(finalName);\n            options.setMetaTypeName(metaTypeName);\n            options.setGenerateAccessors(generateAccessors);\n            options.setStrictMode(strictMode);\n            options.setProperties(new HashMap<String, String>());\n            options.setSpecVersion(SpecVersion.fromName(specVersion));\n            if ( specVersion != null && options.getSpecVersion() == null ) {\n                throw new BuildException(\"Unknown spec version specified: \" + specVersion);\n            }\n\n            final SCRDescriptorGenerator generator = new SCRDescriptorGenerator( scrLog );\n\n            // setup from plugin configuration\n            generator.setOptions(options);\n            generator.setProject(project);\n\n            generator.execute();\n        } catch ( final SCRDescriptorException sde ) {\n            if ( sde.getSourceLocation() != null )  {\n                Location loc = new Location( sde.getSourceLocation(), sde.getLineNumber(), 0 );\n                throw new BuildException( sde.getMessage(), sde.getCause(), loc );\n            }\n            throw new BuildException( sde.getMessage(), sde.getCause() );\n        } catch ( SCRDescriptorFailureException sdfe ) {\n            throw new BuildException( sdfe.getMessage(), sdfe.getCause() );\n        }\n    }","commit_id":"15e7368ff41289d1ffe57cbb75c9081455a05793","url":"https://github.com/apache/felix"},{"original_method":"protected GeneratorConfigurationState createDefaultSet() {\n\t\tGeneratorConfigurationState state = new GeneratorConfigurationState();\n\t\tstate.setActivated(true);\n\t\treturn state;\n\t}","id":65504,"modified_method":"protected GeneratorConfigurationState createDefaultSet() {\n\t\tOutputConfiguration defOutput = Iterables.find(outputConfigDefaults.getOutputConfigurations(), new Predicate<OutputConfiguration>() {\n\t\t\t@Override\n\t\t\tpublic boolean apply(OutputConfiguration conf) {\n\t\t\t\treturn IFileSystemAccess.DEFAULT_OUTPUT.equals(conf.getName());\n\t\t\t}\n\t\t});\n\t\tGeneratorConfigurationState state = new GeneratorConfigurationState();\n\t\tstate.setActivated(true);\n\t\tif (defOutput != null) {\n\t\t\tstate.setOutputDirectory(defOutput.getOutputDirectory());\n\t\t\tstate.setTestOutputDirectory(defOutput.getOutputDirectory());\n\t\t\tstate.setCreateDirectory(defOutput.isCreateOutputDirectory());\n\t\t\tstate.setDeleteGenerated(defOutput.isCanClearOutputDirectory());\n\t\t\tstate.setOverwriteExisting(defOutput.isOverrideExistingResources());\n\t\t}\n\t\treturn state;\n\t}","commit_id":"9ac713387f2ae94a2cd4619eb754fb884067a1c1","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public ISourceFolder findSourceFolderContaining(final URI member) {\n    VirtualFileManager _instance = VirtualFileManager.getInstance();\n    String _string = member.toString();\n    final VirtualFile file = _instance.findFileByUrl(_string);\n    boolean _equals = Objects.equal(file, null);\n    if (_equals) {\n      return null;\n    }\n    Project _project = this.module.getProject();\n    ProjectRootManager _instance_1 = ProjectRootManager.getInstance(_project);\n    ProjectFileIndex _fileIndex = _instance_1.getFileIndex();\n    final VirtualFile sourceRoot = _fileIndex.getSourceRootForFile(file);\n    boolean _equals_1 = Objects.equal(sourceRoot, null);\n    if (_equals_1) {\n      return null;\n    }\n    Iterable<SourceFolder> _existingSourceFolders = RootModelExtensions.getExistingSourceFolders(this.module);\n    final Function1<SourceFolder, Boolean> _function = new Function1<SourceFolder, Boolean>() {\n      @Override\n      public Boolean apply(final SourceFolder it) {\n        return Boolean.valueOf(Objects.equal(file, sourceRoot));\n      }\n    };\n    final SourceFolder sourceFolder = IterableExtensions.<SourceFolder>findFirst(_existingSourceFolders, _function);\n    boolean _equals_2 = Objects.equal(sourceFolder, null);\n    if (_equals_2) {\n      return null;\n    }\n    return new IdeaSourceFolder(sourceFolder);\n  }","id":65505,"modified_method":"@Override\n  public ISourceFolder findSourceFolderContaining(final URI member) {\n    VirtualFileManager _instance = VirtualFileManager.getInstance();\n    String _string = member.toString();\n    final VirtualFile file = _instance.findFileByUrl(_string);\n    boolean _equals = Objects.equal(file, null);\n    if (_equals) {\n      return null;\n    }\n    Project _project = this.module.getProject();\n    ProjectRootManager _instance_1 = ProjectRootManager.getInstance(_project);\n    ProjectFileIndex _fileIndex = _instance_1.getFileIndex();\n    final VirtualFile sourceRoot = _fileIndex.getSourceRootForFile(file);\n    boolean _equals_1 = Objects.equal(sourceRoot, null);\n    if (_equals_1) {\n      return null;\n    }\n    Iterable<SourceFolder> _existingSourceFolders = RootModelExtensions.getExistingSourceFolders(this.module);\n    final Function1<SourceFolder, Boolean> _function = new Function1<SourceFolder, Boolean>() {\n      @Override\n      public Boolean apply(final SourceFolder folder) {\n        VirtualFile _file = folder.getFile();\n        return Boolean.valueOf(Objects.equal(_file, sourceRoot));\n      }\n    };\n    final SourceFolder sourceFolder = IterableExtensions.<SourceFolder>findFirst(_existingSourceFolders, _function);\n    boolean _equals_2 = Objects.equal(sourceFolder, null);\n    if (_equals_2) {\n      return null;\n    }\n    return new IdeaSourceFolder(sourceFolder);\n  }","commit_id":"9ac713387f2ae94a2cd4619eb754fb884067a1c1","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n   * TODO need a delegate to default output configs\n   */\n  @Override\n  public Set<OutputConfiguration> getOutputConfigurations(final Resource context) {\n    boolean _equals = Objects.equal(this.languageFacet, null);\n    if (_equals) {\n      return Sets.<OutputConfiguration>newHashSet();\n    }\n    ResourceSet _resourceSet = context.getResourceSet();\n    final Object module = ((XtextResourceSet) _resourceSet).getClasspathURIContext();\n    if ((module instanceof Module)) {\n      FacetManager _instance = FacetManager.getInstance(((Module)module));\n      FacetTypeId<Facet<AbstractFacetConfiguration>> _id = this.languageFacet.getId();\n      final Facet<AbstractFacetConfiguration> facet = _instance.<Facet<AbstractFacetConfiguration>>getFacetByType(_id);\n      AbstractFacetConfiguration _configuration = facet.getConfiguration();\n      final GeneratorConfigurationState generatorConf = _configuration.getState();\n      final OutputConfiguration defOut = new OutputConfiguration(IFileSystemAccess.DEFAULT_OUTPUT);\n      String _outputDirectory = generatorConf.getOutputDirectory();\n      defOut.setOutputDirectory(_outputDirectory);\n      final OutputConfiguration testOut = new OutputConfiguration(IdeaOutputConfigurationProvider.TEST_OUTPUT);\n      String _testOutputDirectory = generatorConf.getTestOutputDirectory();\n      testOut.setOutputDirectory(_testOutputDirectory);\n      return Sets.<OutputConfiguration>newHashSet(defOut, testOut);\n    }\n    return Sets.<OutputConfiguration>newHashSet();\n  }","id":65506,"modified_method":"@Override\n  public Set<OutputConfiguration> getOutputConfigurations(final Resource context) {\n    boolean _equals = Objects.equal(this.languageFacet, null);\n    if (_equals) {\n      return Sets.<OutputConfiguration>newHashSet();\n    }\n    ResourceSet _resourceSet = context.getResourceSet();\n    final Object module = ((XtextResourceSet) _resourceSet).getClasspathURIContext();\n    if ((module instanceof Module)) {\n      FacetManager _instance = FacetManager.getInstance(((Module)module));\n      FacetTypeId<Facet<AbstractFacetConfiguration>> _id = this.languageFacet.getId();\n      final Facet<AbstractFacetConfiguration> facet = _instance.<Facet<AbstractFacetConfiguration>>getFacetByType(_id);\n      boolean _notEquals = (!Objects.equal(facet, null));\n      if (_notEquals) {\n        AbstractFacetConfiguration _configuration = facet.getConfiguration();\n        final GeneratorConfigurationState generatorConf = _configuration.getState();\n        final OutputConfiguration defOut = new OutputConfiguration(IFileSystemAccess.DEFAULT_OUTPUT);\n        String _outputDirectory = generatorConf.getOutputDirectory();\n        defOut.setOutputDirectory(_outputDirectory);\n        boolean _isCreateDirectory = generatorConf.isCreateDirectory();\n        defOut.setCreateOutputDirectory(_isCreateDirectory);\n        boolean _isDeleteGenerated = generatorConf.isDeleteGenerated();\n        defOut.setCanClearOutputDirectory(_isDeleteGenerated);\n        boolean _isOverwriteExisting = generatorConf.isOverwriteExisting();\n        defOut.setOverrideExistingResources(_isOverwriteExisting);\n        defOut.setUseOutputPerSourceFolder(true);\n        final Iterable<SourceFolder> allSrcFolders = RootModelExtensions.getSourceFolders(((Module)module));\n        for (final SourceFolder srcFolder : allSrcFolders) {\n          {\n            ContentEntry _contentEntry = srcFolder.getContentEntry();\n            VirtualFile _file = _contentEntry.getFile();\n            VirtualFile _file_1 = srcFolder.getFile();\n            String _path = VfsUtil.getPath(_file, _file_1, '/');\n            final OutputConfiguration.SourceMapping mapping = new OutputConfiguration.SourceMapping(_path);\n            boolean _isTestSource = srcFolder.isTestSource();\n            if (_isTestSource) {\n              String _testOutputDirectory = generatorConf.getTestOutputDirectory();\n              mapping.setOutputDirectory(_testOutputDirectory);\n            } else {\n              String _outputDirectory_1 = generatorConf.getOutputDirectory();\n              mapping.setOutputDirectory(_outputDirectory_1);\n            }\n            Set<OutputConfiguration.SourceMapping> _sourceMappings = defOut.getSourceMappings();\n            _sourceMappings.add(mapping);\n          }\n        }\n        return Sets.<OutputConfiguration>newHashSet(defOut);\n      }\n    }\n    return Sets.<OutputConfiguration>newHashSet();\n  }","commit_id":"9ac713387f2ae94a2cd4619eb754fb884067a1c1","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void generate(final Resource resource, final BuildRequest request, final Source2GeneratedMapping newMappings) {\n      URI _uRI = resource.getURI();\n      final IResourceServiceProvider serviceProvider = this.context.getResourceServiceProvider(_uRI);\n      final GeneratorDelegate generator = serviceProvider.<GeneratorDelegate>get(GeneratorDelegate.class);\n      boolean _equals = Objects.equal(generator, null);\n      if (_equals) {\n        return;\n      }\n      URI _uRI_1 = resource.getURI();\n      final Set<URI> previous = newMappings.deleteSource(_uRI_1);\n      URIBasedFileSystemAccess _uRIBasedFileSystemAccess = new URIBasedFileSystemAccess();\n      final Procedure1<URIBasedFileSystemAccess> _function = new Procedure1<URIBasedFileSystemAccess>() {\n        @Override\n        public void apply(final URIBasedFileSystemAccess it) {\n          final IContextualOutputConfigurationProvider outputConfigProvider = serviceProvider.<IContextualOutputConfigurationProvider>get(IContextualOutputConfigurationProvider.class);\n          Set<OutputConfiguration> _outputConfigurations = outputConfigProvider.getOutputConfigurations(resource);\n          final Function1<OutputConfiguration, String> _function = new Function1<OutputConfiguration, String>() {\n            @Override\n            public String apply(final OutputConfiguration it) {\n              return it.getName();\n            }\n          };\n          Map<String, OutputConfiguration> _map = IterableExtensions.<String, OutputConfiguration>toMap(_outputConfigurations, _function);\n          it.setOutputConfigurations(_map);\n          URI _baseDir = request.getBaseDir();\n          it.setBaseDir(_baseDir);\n          ResourceSet _resourceSet = resource.getResourceSet();\n          URIConverter _uRIConverter = _resourceSet.getURIConverter();\n          it.setConverter(_uRIConverter);\n          final URIBasedFileSystemAccess.BeforeWrite _function_1 = new URIBasedFileSystemAccess.BeforeWrite() {\n            @Override\n            public InputStream beforeWrite(final URI uri, final InputStream contents) {\n              URI _uRI = resource.getURI();\n              newMappings.addSource2Generated(_uRI, uri);\n              previous.remove(uri);\n              Procedure2<? super URI, ? super URI> _afterGenerateFile = request.getAfterGenerateFile();\n              URI _uRI_1 = resource.getURI();\n              _afterGenerateFile.apply(_uRI_1, uri);\n              return contents;\n            }\n          };\n          it.setBeforeWrite(_function_1);\n          final URIBasedFileSystemAccess.BeforeDelete _function_2 = new URIBasedFileSystemAccess.BeforeDelete() {\n            @Override\n            public boolean beforeDelete(final URI uri) {\n              newMappings.deleteGenerated(uri);\n              Procedure1<? super URI> _afterDeleteFile = request.getAfterDeleteFile();\n              _afterDeleteFile.apply(uri);\n              return true;\n            }\n          };\n          it.setBeforeDelete(_function_2);\n        }\n      };\n      final URIBasedFileSystemAccess fileSystemAccess = ObjectExtensions.<URIBasedFileSystemAccess>operator_doubleArrow(_uRIBasedFileSystemAccess, _function);\n      fileSystemAccess.setContext(resource);\n      boolean _isWriteStorageResources = request.isWriteStorageResources();\n      if (_isWriteStorageResources) {\n        boolean _matched = false;\n        if (!_matched) {\n          if (resource instanceof StorageAwareResource) {\n            IResourceStorageFacade _resourceStorageFacade = ((StorageAwareResource)resource).getResourceStorageFacade();\n            boolean _notEquals = (!Objects.equal(_resourceStorageFacade, null));\n            if (_notEquals) {\n              _matched=true;\n              IResourceStorageFacade _resourceStorageFacade_1 = ((StorageAwareResource)resource).getResourceStorageFacade();\n              _resourceStorageFacade_1.saveResource(((StorageAwareResource)resource), fileSystemAccess);\n            }\n          }\n        }\n      }\n      generator.beforeGenerate(resource, fileSystemAccess);\n      generator.doGenerate(resource, fileSystemAccess);\n      generator.afterGenerate(resource, fileSystemAccess);\n      final Procedure1<URI> _function_1 = new Procedure1<URI>() {\n        @Override\n        public void apply(final URI it) {\n          try {\n            IncrementalBuilder.InternalStatefulIncrementalBuilder.LOG.info((\"Deleting stale generated file \" + it));\n            XtextResourceSet _resourceSet = InternalStatefulIncrementalBuilder.this.context.getResourceSet();\n            URIConverter _uRIConverter = _resourceSet.getURIConverter();\n            Map<Object, Object> _emptyMap = CollectionLiterals.<Object, Object>emptyMap();\n            _uRIConverter.delete(it, _emptyMap);\n            Procedure1<? super URI> _afterDeleteFile = request.getAfterDeleteFile();\n            _afterDeleteFile.apply(it);\n          } catch (Throwable _e) {\n            throw Exceptions.sneakyThrow(_e);\n          }\n        }\n      };\n      IterableExtensions.<URI>forEach(previous, _function_1);\n    }","id":65507,"modified_method":"protected void generate(final Resource resource, final BuildRequest request, final Source2GeneratedMapping newMappings) {\n      URI _uRI = resource.getURI();\n      final IResourceServiceProvider serviceProvider = this.context.getResourceServiceProvider(_uRI);\n      final GeneratorDelegate generator = serviceProvider.<GeneratorDelegate>get(GeneratorDelegate.class);\n      boolean _equals = Objects.equal(generator, null);\n      if (_equals) {\n        return;\n      }\n      URI _uRI_1 = resource.getURI();\n      final Set<URI> previous = newMappings.deleteSource(_uRI_1);\n      final IWorkspaceConfigProvider wsConfProvider = serviceProvider.<IWorkspaceConfigProvider>get(IWorkspaceConfigProvider.class);\n      URIBasedFileSystemAccess _uRIBasedFileSystemAccess = new URIBasedFileSystemAccess();\n      final Procedure1<URIBasedFileSystemAccess> _function = new Procedure1<URIBasedFileSystemAccess>() {\n        @Override\n        public void apply(final URIBasedFileSystemAccess it) {\n          final IContextualOutputConfigurationProvider outputConfigProvider = serviceProvider.<IContextualOutputConfigurationProvider>get(IContextualOutputConfigurationProvider.class);\n          Set<OutputConfiguration> _outputConfigurations = outputConfigProvider.getOutputConfigurations(resource);\n          final Function1<OutputConfiguration, String> _function = new Function1<OutputConfiguration, String>() {\n            @Override\n            public String apply(final OutputConfiguration it) {\n              return it.getName();\n            }\n          };\n          Map<String, OutputConfiguration> _map = IterableExtensions.<String, OutputConfiguration>toMap(_outputConfigurations, _function);\n          it.setOutputConfigurations(_map);\n          URI _baseDir = request.getBaseDir();\n          it.setBaseDir(_baseDir);\n          ResourceSet _resourceSet = resource.getResourceSet();\n          URIConverter _uRIConverter = _resourceSet.getURIConverter();\n          it.setConverter(_uRIConverter);\n          ResourceSet _resourceSet_1 = resource.getResourceSet();\n          IWorkspaceConfig _workspaceConfig = wsConfProvider.getWorkspaceConfig(_resourceSet_1);\n          URI _uRI = resource.getURI();\n          IProjectConfig _findProjectContaining = _workspaceConfig.findProjectContaining(_uRI);\n          URI _uRI_1 = resource.getURI();\n          final ISourceFolder srcFolder = _findProjectContaining.findSourceFolderContaining(_uRI_1);\n          boolean _notEquals = (!Objects.equal(srcFolder, null));\n          if (_notEquals) {\n            String _name = srcFolder.getName();\n            it.setCurrentSource(_name);\n          }\n          final URIBasedFileSystemAccess.BeforeWrite _function_1 = new URIBasedFileSystemAccess.BeforeWrite() {\n            @Override\n            public InputStream beforeWrite(final URI uri, final InputStream contents) {\n              URI _uRI = resource.getURI();\n              newMappings.addSource2Generated(_uRI, uri);\n              previous.remove(uri);\n              Procedure2<? super URI, ? super URI> _afterGenerateFile = request.getAfterGenerateFile();\n              URI _uRI_1 = resource.getURI();\n              _afterGenerateFile.apply(_uRI_1, uri);\n              return contents;\n            }\n          };\n          it.setBeforeWrite(_function_1);\n          final URIBasedFileSystemAccess.BeforeDelete _function_2 = new URIBasedFileSystemAccess.BeforeDelete() {\n            @Override\n            public boolean beforeDelete(final URI uri) {\n              newMappings.deleteGenerated(uri);\n              Procedure1<? super URI> _afterDeleteFile = request.getAfterDeleteFile();\n              _afterDeleteFile.apply(uri);\n              return true;\n            }\n          };\n          it.setBeforeDelete(_function_2);\n        }\n      };\n      final URIBasedFileSystemAccess fileSystemAccess = ObjectExtensions.<URIBasedFileSystemAccess>operator_doubleArrow(_uRIBasedFileSystemAccess, _function);\n      fileSystemAccess.setContext(resource);\n      boolean _isWriteStorageResources = request.isWriteStorageResources();\n      if (_isWriteStorageResources) {\n        boolean _matched = false;\n        if (!_matched) {\n          if (resource instanceof StorageAwareResource) {\n            IResourceStorageFacade _resourceStorageFacade = ((StorageAwareResource)resource).getResourceStorageFacade();\n            boolean _notEquals = (!Objects.equal(_resourceStorageFacade, null));\n            if (_notEquals) {\n              _matched=true;\n              IResourceStorageFacade _resourceStorageFacade_1 = ((StorageAwareResource)resource).getResourceStorageFacade();\n              _resourceStorageFacade_1.saveResource(((StorageAwareResource)resource), fileSystemAccess);\n            }\n          }\n        }\n      }\n      generator.beforeGenerate(resource, fileSystemAccess);\n      generator.doGenerate(resource, fileSystemAccess);\n      generator.afterGenerate(resource, fileSystemAccess);\n      final Procedure1<URI> _function_1 = new Procedure1<URI>() {\n        @Override\n        public void apply(final URI it) {\n          try {\n            IncrementalBuilder.InternalStatefulIncrementalBuilder.LOG.info((\"Deleting stale generated file \" + it));\n            XtextResourceSet _resourceSet = InternalStatefulIncrementalBuilder.this.context.getResourceSet();\n            URIConverter _uRIConverter = _resourceSet.getURIConverter();\n            Map<Object, Object> _emptyMap = CollectionLiterals.<Object, Object>emptyMap();\n            _uRIConverter.delete(it, _emptyMap);\n            Procedure1<? super URI> _afterDeleteFile = request.getAfterDeleteFile();\n            _afterDeleteFile.apply(it);\n          } catch (Throwable _e) {\n            throw Exceptions.sneakyThrow(_e);\n          }\n        }\n      };\n      IterableExtensions.<URI>forEach(previous, _function_1);\n    }","commit_id":"9ac713387f2ae94a2cd4619eb754fb884067a1c1","url":"https://github.com/eclipse/xtext"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public int collect(CollectionAgent agent, EventProxy eproxy, Map<String, String> parameters) {\n        String collectionName=parameters.get(\"nsclient-collection\");\n        final CollectionAgent theAgent=agent; //For ResourceIdentifier anonymous class to access the var\n        \n        //Find out what attribs to collect for this node, then collect and store them\n        \n        //Find attribs to collect - check groups in configuration.  For each, check scheduled nodes to see if that group should be collected\n        NsclientCollection collection=NSClientDataCollectionConfigFactory.getInstance().getNSClientCollection(collectionName);\n        NSClientAgentState agentState=m_scheduledNodes.get(agent.getNodeId());\n \n        for(Wpm wpm : collection.getWpms().getWpm()) {\n            //A wpm consists of a list of attributes, identified by name\n            if(agentState.shouldCheckAvailability(wpm.getName(), wpm.getRecheckInterval())) {\n                log().debug(\"Checking availability of group \"+wpm.getName());\n                try {\n                    NsclientManager manager = agentState.getManager();\n                    manager.init();\n                    NsclientCheckParams params = new NsclientCheckParams(wpm.getKeyvalue());\n                    NsclientPacket result = manager.processCheckCommand(\n                                                                        NsclientManager.CHECK_COUNTER,\n                                                                        params);\n                    manager.close();\n                    boolean isAvailable=(result.getResultCode()==NsclientPacket.RES_STATE_OK);\n                    agentState.setGroupIsAvailable(wpm.getName(), isAvailable);\n                } catch (NsclientException e) {\n                    throw new NSClientCollectorException(\n                    \"Error checking group (\"+wpm.getName()+\") availability\", e);\n                }\n          }\n            \n            if(agentState.groupIsAvailable(wpm.getName())) {\n                //Collect the data\n                RrdRepository rrdRepository = NSClientDataCollectionConfigFactory.getInstance().getRrdRepository(collectionName);\n                ResourceIdentifier resource = new ResourceIdentifier() {\n                    public String getOwnerName() {\n                        return theAgent.getHostAddress();\n                    }\n                    public File getResourceDir(RrdRepository repository) {\n                        return new File(repository.getRrdBaseDir(), Integer.toString(theAgent.getNodeId()));\n                    }\n                };\n                try {\n                    NsclientManager manager = agentState.getManager();\n                    manager.init(); //Open the connection, then do each attribute\n\n                    for (Attrib attrib : wpm.getAttrib()) {\n                        NsclientCheckParams params = new NsclientCheckParams(\n                                                                             attrib.getName());\n                        NsclientPacket result = manager.processCheckCommand(\n                                                             NsclientManager.CHECK_COUNTER,\n                                                             params);\n\n                        NSClientCollectionAttribute attribute = new NSClientCollectionAttribute(\n                                                                                                attrib.getAlias(),\n                                                                                                attrib.getType(),\n                                                                                                result.getResponse());\n                        PersistOperationBuilder builder = new PersistOperationBuilder(\n                                                                                      rrdRepository,\n                                                                                      resource,\n                                                                                      attribute.getName());\n                        builder.declareAttribute(attribute);\n                        log().debug(\n                                    \"doCollection: setting attribute: \"\n                                            + attribute);\n                        builder.setAttributeValue(attribute,\n                                                  attribute.getValue());\n                        try {\n                            builder.commit();\n                        } catch (RrdException e) {\n                            throw new NSClientCollectorException(\n                                                                 \"Error writing RRD\", e);\n                        }\n                    }\n                    manager.close(); //Only close once all the attribs have been done (optimizing as much as possible with NSClient)\n                } catch (NsclientException e) {\n                    throw new NSClientCollectorException(\n                                                         \"Error collecting data\", e);\n                }\n            }\n        }\n         \n\n        \n        return ServiceCollector.COLLECTION_SUCCEEDED;\n    }","id":65508,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public int collect(CollectionAgent agent, EventProxy eproxy, Map<String, String> parameters) {\n        String collectionName = parameters.get(\"nsclient-collection\");\n        final CollectionAgent theAgent = agent; // For ResourceIdentifier\n                                                // anonymous class to access the\n                                                // var\n\n        // Find out what attribs to collect for this node, then collect and\n        // store them\n\n        // Find attribs to collect - check groups in configuration. For each,\n        // check scheduled nodes to see if that group should be collected\n        NsclientCollection collection = NSClientDataCollectionConfigFactory.getInstance().getNSClientCollection(collectionName);\n        NSClientAgentState agentState = m_scheduledNodes.get(agent.getNodeId());\n\n        for (Wpm wpm : collection.getWpms().getWpm()) {\n            // A wpm consists of a list of attributes, identified by name\n            if (agentState.shouldCheckAvailability(wpm.getName(), wpm.getRecheckInterval())) {\n                log().debug(\"Checking availability of group \" + wpm.getName());\n                try {\n                    NsclientManager manager = agentState.getManager();\n                    manager.init();\n                    NsclientCheckParams params = new NsclientCheckParams(wpm.getKeyvalue());\n                    NsclientPacket result = manager.processCheckCommand(NsclientManager.CHECK_COUNTER, params);\n                    manager.close();\n                    boolean isAvailable = (result.getResultCode() == NsclientPacket.RES_STATE_OK);\n                    agentState.setGroupIsAvailable(wpm.getName(), isAvailable);\n                } catch (NsclientException e) {\n                    throw new NSClientCollectorException(\"Error checking group (\" + wpm.getName() + \") availability\", e);\n                }\n            }\n\n            if (agentState.groupIsAvailable(wpm.getName())) {\n                // Collect the data\n                RrdRepository rrdRepository = NSClientDataCollectionConfigFactory.getInstance().getRrdRepository(collectionName);\n                ResourceIdentifier resource = new ResourceIdentifier() {\n                    public String getOwnerName() {\n                        return theAgent.getHostAddress();\n                    }\n\n                    public File getResourceDir(RrdRepository repository) {\n                        return new File(repository.getRrdBaseDir(), Integer.toString(theAgent.getNodeId()));\n                    }\n                };\n                try {\n                    NsclientManager manager = agentState.getManager();\n                    manager.init(); // Open the connection, then do each\n                                    // attribute\n\n                    for (Attrib attrib : wpm.getAttrib()) {\n                        NsclientPacket result = null;\n                        NSClientCollectionAttribute attribute;\n                        PersistOperationBuilder builder;\n                        \n                        try {\n                            NsclientCheckParams params = new NsclientCheckParams(attrib.getName());\n                            result = manager.processCheckCommand(NsclientManager.CHECK_COUNTER, params);\n                        } catch (NsclientException e) {\n                            log().info(\"unable to collect params for attribute '\" + attrib.getName() + \"'\", e);\n                        }\n\n                        attribute = new NSClientCollectionAttribute(attrib.getAlias(), attrib.getType(), result.getResponse());\n                        builder = new PersistOperationBuilder(rrdRepository, resource, attribute.getName());\n                        builder.declareAttribute(attribute);\n                        log().debug(\"doCollection: setting attribute: \" + attribute);\n                        builder.setAttributeValue(attribute, attribute.getValue());\n\n                        try {\n                            builder.commit();\n                        } catch (RrdException e) {\n                            throw new NSClientCollectorException(\"Error writing RRD\", e);\n                        }\n                    }\n                    manager.close(); // Only close once all the attribs have\n                                        // been done (optimizing as much as\n                                        // possible with NSClient)\n                } catch (NsclientException e) {\n                    throw new NSClientCollectorException(\"Error collecting data\", e);\n                }\n            }\n        }\n\n        return ServiceCollector.COLLECTION_SUCCEEDED;\n    }","commit_id":"5fc0556fecf0803dcfc6d045c32a624cf79bc853","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method performs a check of a perfmon object as defined by the\n     * 'parameter' string. An example of this string would be:\n     * \\Memory(_Total)\\Pool Paged Bytes - the warning and critical members of\n     * param will define thresholds used to validate the perfmon object value.\n     * \n     * @param param\n     *            The param string should contain a perfmon OID, warning and\n     *            critical should contain non-zero values.\n     * @return the processed <code>NsclientPacket<\/code>.\n     * @throws NsclientException\n     *             this method rethrows the exception thrown by\n     *             <code>sendCheckRequest<\/code>\n     */\n    private NsclientPacket checkPerfCounter(NsclientCheckParams param)\n            throws NsclientException {\n        NsclientPacket pack = null;\n\n        try {\n            // send/receive the request\n            pack = sendCheckRequest(m_Password + \"&\" + CHECK_COUNTER + \"&\"\n                    + prepList(param.getParamString()));\n            pack.setResultCode(NsclientPacket.RES_STATE_OK);\n\n            // Check for \"ERROR\" string.\n            if (pack.getResponse().matches(\".*ERROR.*\")) {\n                pack.setResultCode(NsclientPacket.RES_STATE_UNKNOWN);\n                return pack;\n            }\n\n            // parse out the response.\n            float counterValue = Float.parseFloat(pack.getResponse().replace(\",\", \".\"));\n\n            // if a warning percent was configured, check it.\n            if (param.getWarningPercent() != 0) {\n                if (counterValue > (float) param.getWarningPercent()) {\n                    pack.setResultCode(NsclientPacket.RES_STATE_WARNING);\n                }\n            }\n\n            // if a critical percent was configured, check it, overriding\n            // warning percent.\n            if (param.getCriticalPercent() != 0) {\n                if (counterValue > (float) param.getCriticalPercent()) {\n                    pack.setResultCode(NsclientPacket.RES_STATE_CRIT);\n                }\n            }\n\n            return pack;\n        } catch (NsclientException e) {\n            throw e;\n        }\n    }","id":65509,"modified_method":"/**\n     * This method performs a check of a perfmon object as defined by the\n     * 'parameter' string. An example of this string would be:\n     * \\Memory(_Total)\\Pool Paged Bytes - the warning and critical members of\n     * param will define thresholds used to validate the perfmon object value.\n     * \n     * @param param\n     *            The param string should contain a perfmon OID, warning and\n     *            critical should contain non-zero values.\n     * @return the processed <code>NsclientPacket<\/code>.\n     * @throws NsclientException\n     *             this method rethrows the exception thrown by\n     *             <code>sendCheckRequest<\/code>\n     */\n    private NsclientPacket checkPerfCounter(NsclientCheckParams param)\n            throws NsclientException {\n        NsclientPacket pack = null;\n\n        try {\n            // send/receive the request\n            pack = sendCheckRequest(m_Password + \"&\" + CHECK_COUNTER + \"&\"\n                    + prepList(param.getParamString()));\n            pack.setResultCode(NsclientPacket.RES_STATE_OK);\n\n            // Check for \"ERROR\" string.\n            if (pack.getResponse().matches(\".*ERROR.*\")) {\n                pack.setResultCode(NsclientPacket.RES_STATE_UNKNOWN);\n                return pack;\n            }\n\n            // parse out the response.\n            float counterValue = Float.parseFloat(pack.getResponse().replace(\",\", \".\"));\n\n            // if a warning percent was configured, check it.\n            if (param.getWarningPercent() != 0) {\n                if (counterValue > (float) param.getWarningPercent()) {\n                    pack.setResultCode(NsclientPacket.RES_STATE_WARNING);\n                }\n            }\n\n            // if a critical percent was configured, check it, overriding\n            // warning percent.\n            if (param.getCriticalPercent() != 0) {\n                if (counterValue > (float) param.getCriticalPercent()) {\n                    pack.setResultCode(NsclientPacket.RES_STATE_CRIT);\n                }\n            }\n\n            return pack;\n        } catch (NumberFormatException nfe) {\n            throw new NsclientException(\"Unable to parse numeric value returned from parameter '\" + param.getParamString() + \"'\", nfe);\n        } catch (NsclientException e) {\n            throw e;\n        }\n    }","commit_id":"5fc0556fecf0803dcfc6d045c32a624cf79bc853","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method performs a check of a file's age as defined by the\n     * 'parameter' string.\n     * \n     * @param param\n     *            The param string should contain a full path to a file,\n     *            warning and critical should contain non-zero ages in\n     *            minutes.\n     * @return the processed <code>NsclientPacket<\/code>.\n     * @throws NsclientException\n     *             this method rethrows the exception thrown by\n     *             <code>sendCheckRequest<\/code>\n     */\n    private NsclientPacket checkFileAge(NsclientCheckParams param)\n            throws NsclientException {\n        NsclientPacket pack = null;\n        try {\n            // send/receive the request\n            pack = sendCheckRequest(m_Password + \"&\" + CHECK_FILEAGE + \"&\"\n                    + param.getParamString());\n            pack.setResultCode(NsclientPacket.RES_STATE_OK);\n\n            // Check for \"ERROR\" string.\n            if (pack.getResponse().matches(\".*ERROR.*\")) {\n                pack.setResultCode(NsclientPacket.RES_STATE_UNKNOWN);\n                return pack;\n            }\n\n            // this will store our date.\n            // SimpleDateFormat dateFormat = new SimpleDateFormat(\"MM/dd/yyyy\n            // h:mm:ss a\");\n            String[] results = pack.getResponse().split(\"&\");\n            double minutes = Double.parseDouble(results[0]);\n\n            // check the age of the file, if it's newer than the\n            // warning/critical, change the state.\n            if (param.getWarningPercent() != 0) {\n                if (minutes < param.getWarningPercent())\n                    pack.setResultCode(NsclientPacket.RES_STATE_WARNING);\n            }\n            if (param.getCriticalPercent() != 0) {\n                if (minutes < param.getCriticalPercent())\n                    pack.setResultCode(NsclientPacket.RES_STATE_CRIT);\n            }\n\n            return pack;\n        } catch (NsclientException e) {\n            throw e;\n        }\n    }","id":65510,"modified_method":"/**\n     * This method performs a check of a file's age as defined by the\n     * 'parameter' string.\n     * \n     * @param param\n     *            The param string should contain a full path to a file,\n     *            warning and critical should contain non-zero ages in\n     *            minutes.\n     * @return the processed <code>NsclientPacket<\/code>.\n     * @throws NsclientException\n     *             this method rethrows the exception thrown by\n     *             <code>sendCheckRequest<\/code>\n     */\n    private NsclientPacket checkFileAge(NsclientCheckParams param)\n            throws NsclientException {\n        NsclientPacket pack = null;\n        String responseValue = \"\";\n        try {\n            // send/receive the request\n            pack = sendCheckRequest(m_Password + \"&\" + CHECK_FILEAGE + \"&\"\n                    + param.getParamString());\n            pack.setResultCode(NsclientPacket.RES_STATE_OK);\n\n            // Check for \"ERROR\" string.\n            if (pack.getResponse().matches(\".*ERROR.*\")) {\n                pack.setResultCode(NsclientPacket.RES_STATE_UNKNOWN);\n                return pack;\n            }\n\n            // this will store our date.\n            // SimpleDateFormat dateFormat = new SimpleDateFormat(\"MM/dd/yyyy\n            // h:mm:ss a\");\n            String[] results = pack.getResponse().split(\"&\");\n            responseValue = results[0];\n            double minutes = Double.parseDouble(responseValue);\n\n            // check the age of the file, if it's newer than the\n            // warning/critical, change the state.\n            if (param.getWarningPercent() != 0) {\n                if (minutes < param.getWarningPercent())\n                    pack.setResultCode(NsclientPacket.RES_STATE_WARNING);\n            }\n            if (param.getCriticalPercent() != 0) {\n                if (minutes < param.getCriticalPercent())\n                    pack.setResultCode(NsclientPacket.RES_STATE_CRIT);\n            }\n\n            return pack;\n        } catch (NumberFormatException nfe) {\n            throw new NsclientException(\"Unable to parse result '\" + responseValue + \"' as a Double\", nfe);\n        } catch (NsclientException e) {\n            throw e;\n        }\n    }","commit_id":"5fc0556fecf0803dcfc6d045c32a624cf79bc853","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public int collect(CollectionAgent agent, EventProxy eproxy, Map<String, String> parameters) {\n        String collectionName=parameters.get(\"nsclient-collection\");\n        final CollectionAgent theAgent=agent; //For ResourceIdentifier anonymous class to access the var\n        \n        //Find out what attribs to collect for this node, then collect and store them\n        \n        //Find attribs to collect - check groups in configuration.  For each, check scheduled nodes to see if that group should be collected\n        NsclientCollection collection=NSClientDataCollectionConfigFactory.getInstance().getNSClientCollection(collectionName);\n        NSClientAgentState agentState=m_scheduledNodes.get(agent.getNodeId());\n \n        for(Wpm wpm : collection.getWpms().getWpm()) {\n            //A wpm consists of a list of attributes, identified by name\n            if(agentState.shouldCheckAvailability(wpm.getName(), wpm.getRecheckInterval())) {\n                log().debug(\"Checking availability of group \"+wpm.getName());\n                try {\n                    NsclientManager manager = agentState.getManager();\n                    manager.init();\n                    NsclientCheckParams params = new NsclientCheckParams(wpm.getKeyvalue());\n                    NsclientPacket result = manager.processCheckCommand(\n                                                                        NsclientManager.CHECK_COUNTER,\n                                                                        params);\n                    manager.close();\n                    boolean isAvailable=(result.getResultCode()==NsclientPacket.RES_STATE_OK);\n                    agentState.setGroupIsAvailable(wpm.getName(), isAvailable);\n                } catch (NsclientException e) {\n                    throw new NSClientCollectorException(\n                    \"Error checking group (\"+wpm.getName()+\") availability\", e);\n                }\n          }\n            \n            if(agentState.groupIsAvailable(wpm.getName())) {\n                //Collect the data\n                RrdRepository rrdRepository = NSClientDataCollectionConfigFactory.getInstance().getRrdRepository(collectionName);\n                ResourceIdentifier resource = new ResourceIdentifier() {\n                    public String getOwnerName() {\n                        return theAgent.getHostAddress();\n                    }\n                    public File getResourceDir(RrdRepository repository) {\n                        return new File(repository.getRrdBaseDir(), Integer.toString(theAgent.getNodeId()));\n                    }\n                };\n                try {\n                    NsclientManager manager = agentState.getManager();\n                    manager.init(); //Open the connection, then do each attribute\n\n                    for (Attrib attrib : wpm.getAttrib()) {\n                        NsclientCheckParams params = new NsclientCheckParams(\n                                                                             attrib.getName());\n                        NsclientPacket result = manager.processCheckCommand(\n                                                             NsclientManager.CHECK_COUNTER,\n                                                             params);\n\n                        NSClientCollectionAttribute attribute = new NSClientCollectionAttribute(\n                                                                                                attrib.getAlias(),\n                                                                                                attrib.getType(),\n                                                                                                result.getResponse());\n                        PersistOperationBuilder builder = new PersistOperationBuilder(\n                                                                                      rrdRepository,\n                                                                                      resource,\n                                                                                      attribute.getName());\n                        builder.declareAttribute(attribute);\n                        log().debug(\n                                    \"doCollection: setting attribute: \"\n                                            + attribute);\n                        builder.setAttributeValue(attribute,\n                                                  attribute.getValue());\n                        try {\n                            builder.commit();\n                        } catch (RrdException e) {\n                            throw new NSClientCollectorException(\n                                                                 \"Error writing RRD\", e);\n                        }\n                    }\n                    manager.close(); //Only close once all the attribs have been done (optimizing as much as possible with NSClient)\n                } catch (NsclientException e) {\n                    throw new NSClientCollectorException(\n                                                         \"Error collecting data\", e);\n                }\n            }\n        }\n         \n\n        \n        return ServiceCollector.COLLECTION_SUCCEEDED;\n    }","id":65511,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public int collect(CollectionAgent agent, EventProxy eproxy, Map<String, String> parameters) {\n        String collectionName = parameters.get(\"nsclient-collection\");\n        final CollectionAgent theAgent = agent; // For ResourceIdentifier\n                                                // anonymous class to access the\n                                                // var\n\n        // Find out what attribs to collect for this node, then collect and\n        // store them\n\n        // Find attribs to collect - check groups in configuration. For each,\n        // check scheduled nodes to see if that group should be collected\n        NsclientCollection collection = NSClientDataCollectionConfigFactory.getInstance().getNSClientCollection(collectionName);\n        NSClientAgentState agentState = m_scheduledNodes.get(agent.getNodeId());\n\n        for (Wpm wpm : collection.getWpms().getWpm()) {\n            // A wpm consists of a list of attributes, identified by name\n            if (agentState.shouldCheckAvailability(wpm.getName(), wpm.getRecheckInterval())) {\n                log().debug(\"Checking availability of group \" + wpm.getName());\n                try {\n                    NsclientManager manager = agentState.getManager();\n                    manager.init();\n                    NsclientCheckParams params = new NsclientCheckParams(wpm.getKeyvalue());\n                    NsclientPacket result = manager.processCheckCommand(NsclientManager.CHECK_COUNTER, params);\n                    manager.close();\n                    boolean isAvailable = (result.getResultCode() == NsclientPacket.RES_STATE_OK);\n                    agentState.setGroupIsAvailable(wpm.getName(), isAvailable);\n                } catch (NsclientException e) {\n                    throw new NSClientCollectorException(\"Error checking group (\" + wpm.getName() + \") availability\", e);\n                }\n            }\n\n            if (agentState.groupIsAvailable(wpm.getName())) {\n                // Collect the data\n                RrdRepository rrdRepository = NSClientDataCollectionConfigFactory.getInstance().getRrdRepository(collectionName);\n                ResourceIdentifier resource = new ResourceIdentifier() {\n                    public String getOwnerName() {\n                        return theAgent.getHostAddress();\n                    }\n\n                    public File getResourceDir(RrdRepository repository) {\n                        return new File(repository.getRrdBaseDir(), Integer.toString(theAgent.getNodeId()));\n                    }\n                };\n                try {\n                    NsclientManager manager = agentState.getManager();\n                    manager.init(); // Open the connection, then do each\n                                    // attribute\n\n                    for (Attrib attrib : wpm.getAttrib()) {\n                        NsclientPacket result = null;\n                        NSClientCollectionAttribute attribute;\n                        PersistOperationBuilder builder;\n                        \n                        try {\n                            NsclientCheckParams params = new NsclientCheckParams(attrib.getName());\n                            result = manager.processCheckCommand(NsclientManager.CHECK_COUNTER, params);\n                        } catch (NsclientException e) {\n                            log().info(\"unable to collect params for attribute '\" + attrib.getName() + \"'\", e);\n                        }\n\n                        attribute = new NSClientCollectionAttribute(attrib.getAlias(), attrib.getType(), result.getResponse());\n                        builder = new PersistOperationBuilder(rrdRepository, resource, attribute.getName());\n                        builder.declareAttribute(attribute);\n                        log().debug(\"doCollection: setting attribute: \" + attribute);\n                        builder.setAttributeValue(attribute, attribute.getValue());\n\n                        try {\n                            builder.commit();\n                        } catch (RrdException e) {\n                            throw new NSClientCollectorException(\"Error writing RRD\", e);\n                        }\n                    }\n                    manager.close(); // Only close once all the attribs have\n                                        // been done (optimizing as much as\n                                        // possible with NSClient)\n                } catch (NsclientException e) {\n                    throw new NSClientCollectorException(\"Error collecting data\", e);\n                }\n            }\n        }\n\n        return ServiceCollector.COLLECTION_SUCCEEDED;\n    }","commit_id":"c316eb0b4d066adff92958b030c9eb7f0c07f766","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method performs a check of a file's age as defined by the\n     * 'parameter' string.\n     * \n     * @param param\n     *            The param string should contain a full path to a file,\n     *            warning and critical should contain non-zero ages in\n     *            minutes.\n     * @return the processed <code>NsclientPacket<\/code>.\n     * @throws NsclientException\n     *             this method rethrows the exception thrown by\n     *             <code>sendCheckRequest<\/code>\n     */\n    private NsclientPacket checkFileAge(NsclientCheckParams param)\n            throws NsclientException {\n        NsclientPacket pack = null;\n        try {\n            // send/receive the request\n            pack = sendCheckRequest(m_Password + \"&\" + CHECK_FILEAGE + \"&\"\n                    + param.getParamString());\n            pack.setResultCode(NsclientPacket.RES_STATE_OK);\n\n            // Check for \"ERROR\" string.\n            if (pack.getResponse().matches(\".*ERROR.*\")) {\n                pack.setResultCode(NsclientPacket.RES_STATE_UNKNOWN);\n                return pack;\n            }\n\n            // this will store our date.\n            // SimpleDateFormat dateFormat = new SimpleDateFormat(\"MM/dd/yyyy\n            // h:mm:ss a\");\n            String[] results = pack.getResponse().split(\"&\");\n            double minutes = Double.parseDouble(results[0]);\n\n            // check the age of the file, if it's newer than the\n            // warning/critical, change the state.\n            if (param.getWarningPercent() != 0) {\n                if (minutes < param.getWarningPercent())\n                    pack.setResultCode(NsclientPacket.RES_STATE_WARNING);\n            }\n            if (param.getCriticalPercent() != 0) {\n                if (minutes < param.getCriticalPercent())\n                    pack.setResultCode(NsclientPacket.RES_STATE_CRIT);\n            }\n\n            return pack;\n        } catch (NsclientException e) {\n            throw e;\n        }\n    }","id":65512,"modified_method":"/**\n     * This method performs a check of a file's age as defined by the\n     * 'parameter' string.\n     * \n     * @param param\n     *            The param string should contain a full path to a file,\n     *            warning and critical should contain non-zero ages in\n     *            minutes.\n     * @return the processed <code>NsclientPacket<\/code>.\n     * @throws NsclientException\n     *             this method rethrows the exception thrown by\n     *             <code>sendCheckRequest<\/code>\n     */\n    private NsclientPacket checkFileAge(NsclientCheckParams param)\n            throws NsclientException {\n        NsclientPacket pack = null;\n        String responseValue = \"\";\n        try {\n            // send/receive the request\n            pack = sendCheckRequest(m_Password + \"&\" + CHECK_FILEAGE + \"&\"\n                    + param.getParamString());\n            pack.setResultCode(NsclientPacket.RES_STATE_OK);\n\n            // Check for \"ERROR\" string.\n            if (pack.getResponse().matches(\".*ERROR.*\")) {\n                pack.setResultCode(NsclientPacket.RES_STATE_UNKNOWN);\n                return pack;\n            }\n\n            // this will store our date.\n            // SimpleDateFormat dateFormat = new SimpleDateFormat(\"MM/dd/yyyy\n            // h:mm:ss a\");\n            String[] results = pack.getResponse().split(\"&\");\n            responseValue = results[0];\n            double minutes = Double.parseDouble(responseValue);\n\n            // check the age of the file, if it's newer than the\n            // warning/critical, change the state.\n            if (param.getWarningPercent() != 0) {\n                if (minutes < param.getWarningPercent())\n                    pack.setResultCode(NsclientPacket.RES_STATE_WARNING);\n            }\n            if (param.getCriticalPercent() != 0) {\n                if (minutes < param.getCriticalPercent())\n                    pack.setResultCode(NsclientPacket.RES_STATE_CRIT);\n            }\n\n            return pack;\n        } catch (NumberFormatException nfe) {\n            throw new NsclientException(\"Unable to parse result '\" + responseValue + \"' as a Double\", nfe);\n        } catch (NsclientException e) {\n            throw e;\n        }\n    }","commit_id":"c316eb0b4d066adff92958b030c9eb7f0c07f766","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method performs a check of a perfmon object as defined by the\n     * 'parameter' string. An example of this string would be:\n     * \\Memory(_Total)\\Pool Paged Bytes - the warning and critical members of\n     * param will define thresholds used to validate the perfmon object value.\n     * \n     * @param param\n     *            The param string should contain a perfmon OID, warning and\n     *            critical should contain non-zero values.\n     * @return the processed <code>NsclientPacket<\/code>.\n     * @throws NsclientException\n     *             this method rethrows the exception thrown by\n     *             <code>sendCheckRequest<\/code>\n     */\n    private NsclientPacket checkPerfCounter(NsclientCheckParams param)\n            throws NsclientException {\n        NsclientPacket pack = null;\n\n        try {\n            // send/receive the request\n            pack = sendCheckRequest(m_Password + \"&\" + CHECK_COUNTER + \"&\"\n                    + prepList(param.getParamString()));\n            pack.setResultCode(NsclientPacket.RES_STATE_OK);\n\n            // Check for \"ERROR\" string.\n            if (pack.getResponse().matches(\".*ERROR.*\")) {\n                pack.setResultCode(NsclientPacket.RES_STATE_UNKNOWN);\n                return pack;\n            }\n\n            // parse out the response.\n            float counterValue = Float.parseFloat(pack.getResponse().replace(\",\", \".\"));\n\n            // if a warning percent was configured, check it.\n            if (param.getWarningPercent() != 0) {\n                if (counterValue > (float) param.getWarningPercent()) {\n                    pack.setResultCode(NsclientPacket.RES_STATE_WARNING);\n                }\n            }\n\n            // if a critical percent was configured, check it, overriding\n            // warning percent.\n            if (param.getCriticalPercent() != 0) {\n                if (counterValue > (float) param.getCriticalPercent()) {\n                    pack.setResultCode(NsclientPacket.RES_STATE_CRIT);\n                }\n            }\n\n            return pack;\n        } catch (NsclientException e) {\n            throw e;\n        }\n    }","id":65513,"modified_method":"/**\n     * This method performs a check of a perfmon object as defined by the\n     * 'parameter' string. An example of this string would be:\n     * \\Memory(_Total)\\Pool Paged Bytes - the warning and critical members of\n     * param will define thresholds used to validate the perfmon object value.\n     * \n     * @param param\n     *            The param string should contain a perfmon OID, warning and\n     *            critical should contain non-zero values.\n     * @return the processed <code>NsclientPacket<\/code>.\n     * @throws NsclientException\n     *             this method rethrows the exception thrown by\n     *             <code>sendCheckRequest<\/code>\n     */\n    private NsclientPacket checkPerfCounter(NsclientCheckParams param)\n            throws NsclientException {\n        NsclientPacket pack = null;\n\n        try {\n            // send/receive the request\n            pack = sendCheckRequest(m_Password + \"&\" + CHECK_COUNTER + \"&\"\n                    + prepList(param.getParamString()));\n            pack.setResultCode(NsclientPacket.RES_STATE_OK);\n\n            // Check for \"ERROR\" string.\n            if (pack.getResponse().matches(\".*ERROR.*\")) {\n                pack.setResultCode(NsclientPacket.RES_STATE_UNKNOWN);\n                return pack;\n            }\n\n            // parse out the response.\n            float counterValue = Float.parseFloat(pack.getResponse().replace(\",\", \".\"));\n\n            // if a warning percent was configured, check it.\n            if (param.getWarningPercent() != 0) {\n                if (counterValue > (float) param.getWarningPercent()) {\n                    pack.setResultCode(NsclientPacket.RES_STATE_WARNING);\n                }\n            }\n\n            // if a critical percent was configured, check it, overriding\n            // warning percent.\n            if (param.getCriticalPercent() != 0) {\n                if (counterValue > (float) param.getCriticalPercent()) {\n                    pack.setResultCode(NsclientPacket.RES_STATE_CRIT);\n                }\n            }\n\n            return pack;\n        } catch (NumberFormatException nfe) {\n            throw new NsclientException(\"Unable to parse numeric value returned from parameter '\" + param.getParamString() + \"'\", nfe);\n        } catch (NsclientException e) {\n            throw e;\n        }\n    }","commit_id":"c316eb0b4d066adff92958b030c9eb7f0c07f766","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public int collect(CollectionAgent agent, EventProxy eproxy, Map<String, String> parameters) {\n        String collectionName=parameters.get(\"nsclient-collection\");\n        final CollectionAgent theAgent=agent; //For ResourceIdentifier anonymous class to access the var\n        \n        //Find out what attribs to collect for this node, then collect and store them\n        \n        //Find attribs to collect - check groups in configuration.  For each, check scheduled nodes to see if that group should be collected\n        NsclientCollection collection=NSClientDataCollectionConfigFactory.getInstance().getNSClientCollection(collectionName);\n        NSClientAgentState agentState=m_scheduledNodes.get(agent.getNodeId());\n \n        for(Wpm wpm : collection.getWpms().getWpm()) {\n            //A wpm consists of a list of attributes, identified by name\n            if(agentState.shouldCheckAvailability(wpm.getName(), wpm.getRecheckInterval())) {\n                log().debug(\"Checking availability of group \"+wpm.getName());\n                try {\n                    NsclientManager manager = agentState.getManager();\n                    manager.init();\n                    NsclientCheckParams params = new NsclientCheckParams(wpm.getKeyvalue());\n                    NsclientPacket result = manager.processCheckCommand(\n                                                                        NsclientManager.CHECK_COUNTER,\n                                                                        params);\n                    manager.close();\n                    boolean isAvailable=(result.getResultCode()==NsclientPacket.RES_STATE_OK);\n                    agentState.setGroupIsAvailable(wpm.getName(), isAvailable);\n                } catch (NsclientException e) {\n                    throw new NSClientCollectorException(\n                    \"Error checking group (\"+wpm.getName()+\") availability\", e);\n                }\n          }\n            \n            if(agentState.groupIsAvailable(wpm.getName())) {\n                //Collect the data\n                RrdRepository rrdRepository = NSClientDataCollectionConfigFactory.getInstance().getRrdRepository(collectionName);\n                ResourceIdentifier resource = new ResourceIdentifier() {\n                    public String getOwnerName() {\n                        return theAgent.getHostAddress();\n                    }\n                    public File getResourceDir(RrdRepository repository) {\n                        return new File(repository.getRrdBaseDir(), Integer.toString(theAgent.getNodeId()));\n                    }\n                };\n                try {\n                    NsclientManager manager = agentState.getManager();\n                    manager.init(); //Open the connection, then do each attribute\n\n                    for (Attrib attrib : wpm.getAttrib()) {\n                        NsclientCheckParams params = new NsclientCheckParams(\n                                                                             attrib.getName());\n                        NsclientPacket result = manager.processCheckCommand(\n                                                             NsclientManager.CHECK_COUNTER,\n                                                             params);\n\n                        NSClientCollectionAttribute attribute = new NSClientCollectionAttribute(\n                                                                                                attrib.getAlias(),\n                                                                                                attrib.getType(),\n                                                                                                result.getResponse());\n                        PersistOperationBuilder builder = new PersistOperationBuilder(\n                                                                                      rrdRepository,\n                                                                                      resource,\n                                                                                      attribute.getName());\n                        builder.declareAttribute(attribute);\n                        log().debug(\n                                    \"doCollection: setting attribute: \"\n                                            + attribute);\n                        builder.setAttributeValue(attribute,\n                                                  attribute.getValue());\n                        try {\n                            builder.commit();\n                        } catch (RrdException e) {\n                            throw new NSClientCollectorException(\n                                                                 \"Error writing RRD\", e);\n                        }\n                    }\n                    manager.close(); //Only close once all the attribs have been done (optimizing as much as possible with NSClient)\n                } catch (NsclientException e) {\n                    throw new NSClientCollectorException(\n                                                         \"Error collecting data\", e);\n                }\n            }\n        }\n         \n\n        \n        return ServiceCollector.COLLECTION_SUCCEEDED;\n    }","id":65514,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public int collect(CollectionAgent agent, EventProxy eproxy, Map<String, String> parameters) {\n        String collectionName = parameters.get(\"nsclient-collection\");\n        final CollectionAgent theAgent = agent; // For ResourceIdentifier\n                                                // anonymous class to access the\n                                                // var\n\n        // Find out what attribs to collect for this node, then collect and\n        // store them\n\n        // Find attribs to collect - check groups in configuration. For each,\n        // check scheduled nodes to see if that group should be collected\n        NsclientCollection collection = NSClientDataCollectionConfigFactory.getInstance().getNSClientCollection(collectionName);\n        NSClientAgentState agentState = m_scheduledNodes.get(agent.getNodeId());\n\n        for (Wpm wpm : collection.getWpms().getWpm()) {\n            // A wpm consists of a list of attributes, identified by name\n            if (agentState.shouldCheckAvailability(wpm.getName(), wpm.getRecheckInterval())) {\n                log().debug(\"Checking availability of group \" + wpm.getName());\n                try {\n                    NsclientManager manager = agentState.getManager();\n                    manager.init();\n                    NsclientCheckParams params = new NsclientCheckParams(wpm.getKeyvalue());\n                    NsclientPacket result = manager.processCheckCommand(NsclientManager.CHECK_COUNTER, params);\n                    manager.close();\n                    boolean isAvailable = (result.getResultCode() == NsclientPacket.RES_STATE_OK);\n                    agentState.setGroupIsAvailable(wpm.getName(), isAvailable);\n                } catch (NsclientException e) {\n                    throw new NSClientCollectorException(\"Error checking group (\" + wpm.getName() + \") availability\", e);\n                }\n            }\n\n            if (agentState.groupIsAvailable(wpm.getName())) {\n                // Collect the data\n                RrdRepository rrdRepository = NSClientDataCollectionConfigFactory.getInstance().getRrdRepository(collectionName);\n                ResourceIdentifier resource = new ResourceIdentifier() {\n                    public String getOwnerName() {\n                        return theAgent.getHostAddress();\n                    }\n\n                    public File getResourceDir(RrdRepository repository) {\n                        return new File(repository.getRrdBaseDir(), Integer.toString(theAgent.getNodeId()));\n                    }\n                };\n                try {\n                    NsclientManager manager = agentState.getManager();\n                    manager.init(); // Open the connection, then do each\n                                    // attribute\n\n                    for (Attrib attrib : wpm.getAttrib()) {\n                        NsclientPacket result = null;\n                        NSClientCollectionAttribute attribute;\n                        PersistOperationBuilder builder;\n                        \n                        try {\n                            NsclientCheckParams params = new NsclientCheckParams(attrib.getName());\n                            result = manager.processCheckCommand(NsclientManager.CHECK_COUNTER, params);\n                        } catch (NsclientException e) {\n                            log().info(\"unable to collect params for attribute '\" + attrib.getName() + \"'\", e);\n                        }\n\n                        attribute = new NSClientCollectionAttribute(attrib.getAlias(), attrib.getType(), result.getResponse());\n                        builder = new PersistOperationBuilder(rrdRepository, resource, attribute.getName());\n                        builder.declareAttribute(attribute);\n                        log().debug(\"doCollection: setting attribute: \" + attribute);\n                        builder.setAttributeValue(attribute, attribute.getValue());\n\n                        try {\n                            builder.commit();\n                        } catch (RrdException e) {\n                            throw new NSClientCollectorException(\"Error writing RRD\", e);\n                        }\n                    }\n                    manager.close(); // Only close once all the attribs have\n                                        // been done (optimizing as much as\n                                        // possible with NSClient)\n                } catch (NsclientException e) {\n                    throw new NSClientCollectorException(\"Error collecting data\", e);\n                }\n            }\n        }\n\n        return ServiceCollector.COLLECTION_SUCCEEDED;\n    }","commit_id":"2068871bf212dc83ee463b67abb0f3ed55a53ce4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method performs a check of a file's age as defined by the\n     * 'parameter' string.\n     * \n     * @param param\n     *            The param string should contain a full path to a file,\n     *            warning and critical should contain non-zero ages in\n     *            minutes.\n     * @return the processed <code>NsclientPacket<\/code>.\n     * @throws NsclientException\n     *             this method rethrows the exception thrown by\n     *             <code>sendCheckRequest<\/code>\n     */\n    private NsclientPacket checkFileAge(NsclientCheckParams param)\n            throws NsclientException {\n        NsclientPacket pack = null;\n        try {\n            // send/receive the request\n            pack = sendCheckRequest(m_Password + \"&\" + CHECK_FILEAGE + \"&\"\n                    + param.getParamString());\n            pack.setResultCode(NsclientPacket.RES_STATE_OK);\n\n            // Check for \"ERROR\" string.\n            if (pack.getResponse().matches(\".*ERROR.*\")) {\n                pack.setResultCode(NsclientPacket.RES_STATE_UNKNOWN);\n                return pack;\n            }\n\n            // this will store our date.\n            // SimpleDateFormat dateFormat = new SimpleDateFormat(\"MM/dd/yyyy\n            // h:mm:ss a\");\n            String[] results = pack.getResponse().split(\"&\");\n            double minutes = Double.parseDouble(results[0]);\n\n            // check the age of the file, if it's newer than the\n            // warning/critical, change the state.\n            if (param.getWarningPercent() != 0) {\n                if (minutes < param.getWarningPercent())\n                    pack.setResultCode(NsclientPacket.RES_STATE_WARNING);\n            }\n            if (param.getCriticalPercent() != 0) {\n                if (minutes < param.getCriticalPercent())\n                    pack.setResultCode(NsclientPacket.RES_STATE_CRIT);\n            }\n\n            return pack;\n        } catch (NsclientException e) {\n            throw e;\n        }\n    }","id":65515,"modified_method":"/**\n     * This method performs a check of a file's age as defined by the\n     * 'parameter' string.\n     * \n     * @param param\n     *            The param string should contain a full path to a file,\n     *            warning and critical should contain non-zero ages in\n     *            minutes.\n     * @return the processed <code>NsclientPacket<\/code>.\n     * @throws NsclientException\n     *             this method rethrows the exception thrown by\n     *             <code>sendCheckRequest<\/code>\n     */\n    private NsclientPacket checkFileAge(NsclientCheckParams param)\n            throws NsclientException {\n        NsclientPacket pack = null;\n        String responseValue = \"\";\n        try {\n            // send/receive the request\n            pack = sendCheckRequest(m_Password + \"&\" + CHECK_FILEAGE + \"&\"\n                    + param.getParamString());\n            pack.setResultCode(NsclientPacket.RES_STATE_OK);\n\n            // Check for \"ERROR\" string.\n            if (pack.getResponse().matches(\".*ERROR.*\")) {\n                pack.setResultCode(NsclientPacket.RES_STATE_UNKNOWN);\n                return pack;\n            }\n\n            // this will store our date.\n            // SimpleDateFormat dateFormat = new SimpleDateFormat(\"MM/dd/yyyy\n            // h:mm:ss a\");\n            String[] results = pack.getResponse().split(\"&\");\n            responseValue = results[0];\n            double minutes = Double.parseDouble(responseValue);\n\n            // check the age of the file, if it's newer than the\n            // warning/critical, change the state.\n            if (param.getWarningPercent() != 0) {\n                if (minutes < param.getWarningPercent())\n                    pack.setResultCode(NsclientPacket.RES_STATE_WARNING);\n            }\n            if (param.getCriticalPercent() != 0) {\n                if (minutes < param.getCriticalPercent())\n                    pack.setResultCode(NsclientPacket.RES_STATE_CRIT);\n            }\n\n            return pack;\n        } catch (NumberFormatException nfe) {\n            throw new NsclientException(\"Unable to parse result '\" + responseValue + \"' as a Double\", nfe);\n        } catch (NsclientException e) {\n            throw e;\n        }\n    }","commit_id":"2068871bf212dc83ee463b67abb0f3ed55a53ce4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method performs a check of a perfmon object as defined by the\n     * 'parameter' string. An example of this string would be:\n     * \\Memory(_Total)\\Pool Paged Bytes - the warning and critical members of\n     * param will define thresholds used to validate the perfmon object value.\n     * \n     * @param param\n     *            The param string should contain a perfmon OID, warning and\n     *            critical should contain non-zero values.\n     * @return the processed <code>NsclientPacket<\/code>.\n     * @throws NsclientException\n     *             this method rethrows the exception thrown by\n     *             <code>sendCheckRequest<\/code>\n     */\n    private NsclientPacket checkPerfCounter(NsclientCheckParams param)\n            throws NsclientException {\n        NsclientPacket pack = null;\n\n        try {\n            // send/receive the request\n            pack = sendCheckRequest(m_Password + \"&\" + CHECK_COUNTER + \"&\"\n                    + prepList(param.getParamString()));\n            pack.setResultCode(NsclientPacket.RES_STATE_OK);\n\n            // Check for \"ERROR\" string.\n            if (pack.getResponse().matches(\".*ERROR.*\")) {\n                pack.setResultCode(NsclientPacket.RES_STATE_UNKNOWN);\n                return pack;\n            }\n\n            // parse out the response.\n            float counterValue = Float.parseFloat(pack.getResponse().replace(\",\", \".\"));\n\n            // if a warning percent was configured, check it.\n            if (param.getWarningPercent() != 0) {\n                if (counterValue > (float) param.getWarningPercent()) {\n                    pack.setResultCode(NsclientPacket.RES_STATE_WARNING);\n                }\n            }\n\n            // if a critical percent was configured, check it, overriding\n            // warning percent.\n            if (param.getCriticalPercent() != 0) {\n                if (counterValue > (float) param.getCriticalPercent()) {\n                    pack.setResultCode(NsclientPacket.RES_STATE_CRIT);\n                }\n            }\n\n            return pack;\n        } catch (NsclientException e) {\n            throw e;\n        }\n    }","id":65516,"modified_method":"/**\n     * This method performs a check of a perfmon object as defined by the\n     * 'parameter' string. An example of this string would be:\n     * \\Memory(_Total)\\Pool Paged Bytes - the warning and critical members of\n     * param will define thresholds used to validate the perfmon object value.\n     * \n     * @param param\n     *            The param string should contain a perfmon OID, warning and\n     *            critical should contain non-zero values.\n     * @return the processed <code>NsclientPacket<\/code>.\n     * @throws NsclientException\n     *             this method rethrows the exception thrown by\n     *             <code>sendCheckRequest<\/code>\n     */\n    private NsclientPacket checkPerfCounter(NsclientCheckParams param)\n            throws NsclientException {\n        NsclientPacket pack = null;\n\n        try {\n            // send/receive the request\n            pack = sendCheckRequest(m_Password + \"&\" + CHECK_COUNTER + \"&\"\n                    + prepList(param.getParamString()));\n            pack.setResultCode(NsclientPacket.RES_STATE_OK);\n\n            // Check for \"ERROR\" string.\n            if (pack.getResponse().matches(\".*ERROR.*\")) {\n                pack.setResultCode(NsclientPacket.RES_STATE_UNKNOWN);\n                return pack;\n            }\n\n            // parse out the response.\n            float counterValue = Float.parseFloat(pack.getResponse().replace(\",\", \".\"));\n\n            // if a warning percent was configured, check it.\n            if (param.getWarningPercent() != 0) {\n                if (counterValue > (float) param.getWarningPercent()) {\n                    pack.setResultCode(NsclientPacket.RES_STATE_WARNING);\n                }\n            }\n\n            // if a critical percent was configured, check it, overriding\n            // warning percent.\n            if (param.getCriticalPercent() != 0) {\n                if (counterValue > (float) param.getCriticalPercent()) {\n                    pack.setResultCode(NsclientPacket.RES_STATE_CRIT);\n                }\n            }\n\n            return pack;\n        } catch (NumberFormatException nfe) {\n            throw new NsclientException(\"Unable to parse numeric value returned from parameter '\" + param.getParamString() + \"'\", nfe);\n        } catch (NsclientException e) {\n            throw e;\n        }\n    }","commit_id":"2068871bf212dc83ee463b67abb0f3ed55a53ce4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public final void appendToResponse(WOResponse response, WOContext context) {\n        SCItem item = SCItem.pushItem(id(), className(), outlet(), root());\n        for (String key : bindingKeys()) {\n            Object value = valueForBinding(key);\n            value = evaluateValueForBinding(key, value);\n            \n            boolean binding = key.startsWith(\"?\");\n            String itemName;\n            if (binding) {\n            \titemName = key.substring(1);\n            }\n            else {\n            \titemName = key;\n            }\n            \n            String movedPropertyName = _movedProperties.objectForKey(itemName);\n            if (movedPropertyName != null) {\n            \titemName = movedPropertyName;\n            }\n            \n            if (!_removedProperties.containsObject(itemName)) {\n\t            if (binding) {\n\t                item.addBinding(itemName, value == null ? NSKeyValueCoding.NullValue : value);\n\t            } else if (value == null && !skipPropertyIfNull(itemName)) {\n\t            \titem.addProperty(itemName, NSKeyValueCoding.NullValue);\n\t            } else if (value != null) {\n\t            \titem.addProperty(itemName, value);\n\t            }\n            }\n        }\n        String id =  containerID();\n        if(id != null) {\n            response._appendContentAsciiString(\"<div id=\\\"\" + containerID() + \"\\\" class=\\\"\" + containerClass() + \"\\\">\");\n        } else {\n            response._appendContentAsciiString(\"<div class=\\\"\" + containerClass() + \"\\\">\");\n        }\n        doAppendToResponse(response, context);\n        SCItem.popItem();\n        response._appendContentAsciiString(\"<\/div>\");\n    }","id":65517,"modified_method":"@Override\n    public final void appendToResponse(WOResponse response, WOContext context) {\n        SCItem item = SCItem.pushItem(id(), className(), outlet(), root());\n        for (String key : bindingKeys()) {\n            Object value = valueForBinding(key);\n            value = evaluateValueForBinding(key, value);\n            \n            boolean binding = key.startsWith(\"?\");\n            String itemName;\n            if (binding) {\n            \titemName = key.substring(1);\n            }\n            else {\n            \titemName = key;\n            }\n            \n            String movedPropertyName = _movedProperties.objectForKey(itemName);\n            if (movedPropertyName != null) {\n            \titemName = movedPropertyName;\n            }\n            \n            if (!_removedProperties.containsObject(itemName)) {\n\t            if (binding) {\n\t                item.addBinding(itemName, value == null ? NSKeyValueCoding.NullValue : value);\n\t            } else if (value == null && !skipPropertyIfNull(itemName)) {\n\t            \titem.addProperty(itemName, NSKeyValueCoding.NullValue);\n\t            } else if (value != null) {\n\t            \titem.addProperty(itemName, value);\n\t            }\n            }\n        }\n        String id =  containerID();\n        String elementName = elementName(); \n        response._appendContentAsciiString(\"<\" + elementName);\n        \n        if(id != null) {\n            response._appendContentAsciiString(\" id=\\\"\" + containerID() + \"\\\"\");\n        }\n        String containerClass = containerClass();\n        if (containerClass != null) {\n        \tresponse._appendContentAsciiString(\" class=\\\"\" + containerClass + \"\\\"\");\n        }\n        \n        String style = style();\n        if (style != null) {\n        \tresponse._appendContentAsciiString(\" style=\\\"\" + style + \"\\\"\");\n        }\n        \n        response._appendContentAsciiString(\">\");\n\n        doAppendToResponse(response, context);\n        SCItem.popItem();\n        response._appendContentAsciiString(\"<\/\" + elementName + \">\");\n    }","commit_id":"1d749f99a7f8d0cf6f96fa362d4095f4e3fb4c31","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected void _appendHiddenFieldsToResponse(WOResponse response, WOContext context) {\n    \tboolean flag = _actionClass != null;\n    \tNSDictionary nsdictionary = computeQueryDictionaryInContext(_actionClass, _directActionName, _queryDictionary, flag, _otherQueryAssociations, context);\n    \tif(nsdictionary.count() > 0) {\n    \t\tfor(Enumeration enumeration = nsdictionary.keyEnumerator(); enumeration.hasMoreElements(); response._appendContentAsciiString(\">\\n\")) {\n    \t\t\tString s = (String)enumeration.nextElement();\n    \t\t\tObject obj = nsdictionary.objectForKey(s);\n    \t\t\tresponse._appendContentAsciiString(\"<input type=hidden\");\n    \t\t\tresponse._appendTagAttributeAndValue(\"name\", s, false);\n    \t\t\tresponse._appendTagAttributeAndValue(\"value\", obj.toString(), false);\n    \t\t}\n\n    \t}\n    }","id":65518,"modified_method":"protected void _appendHiddenFieldsToResponse(WOResponse response, WOContext context) {\n    \tboolean flag = _actionClass != null;\n    \tNSDictionary nsdictionary = computeQueryDictionaryInContext(_actionClass, _directActionName, _queryDictionary, flag, _otherQueryAssociations, context);\n    \tif(nsdictionary.count() > 0) {\n    \t\tfor(Enumeration enumeration = nsdictionary.keyEnumerator(); enumeration.hasMoreElements(); ) {\n    \t\t\tString s = (String)enumeration.nextElement();\n    \t\t\tObject obj = nsdictionary.objectForKey(s);\n    \t\t\tresponse._appendContentAsciiString(\"<input type=\\\"hidden\\\"\");\n    \t\t\tresponse._appendTagAttributeAndValue(\"name\", s, false);\n    \t\t\tresponse._appendTagAttributeAndValue(\"value\", obj.toString(), false);\n    \t\t\tresponse._appendContentAsciiString(\" />\\n\");\n    \t\t}\n\n    \t}\n    }","commit_id":"e37701a1f2e1b240640cd38a09e488a4c8f90293","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Appends the &ltlink&gt; tag, either by using the style sheet name and\n\t * framework or by using the component content and then generating a link to\n\t * it.\n\t */\n\t@Override\n\tpublic void appendToResponse( WOResponse originalResponse, WOContext wocontext ) {\n\t\tString styleSheetFrameworkName = styleSheetFrameworkName();\n\t\tString styleSheetName = styleSheetName();\n\t\tboolean isResourceStyleSheet = styleSheetName != null;\n\t\tif( isResourceStyleSheet && ERXResponseRewriter.isResourceAddedToHead( wocontext, styleSheetFrameworkName, styleSheetName ) ) {\n\t\t\t// Skip, because this has already been added ... \n\t\t}\n\t\telse {\n\t\t\t// default to inline for ajax requests\n\t\t\tboolean inline = booleanValueForBinding( \"inline\", ERXAjaxApplication.isAjaxRequest( wocontext.request() ) );\n\t\t\tWOResponse response = inline ? originalResponse : new WOResponse();\n\n\t\t\tString href = styleSheetUrl();\n\t\t\tif( href == null ) {\n\t\t\t\tString key = styleSheetKey();\n\t\t\t\tERXExpiringCache<String, WOResponse> cache = cache( session() );\n\t\t\t\tString md5;\n\t\t\t\tWOResponse cachedResponse = cache.objectForKey( key );\n\t\t\t\tif( cache.isStale( key ) || ERXApplication.isDevelopmentModeSafe() ) {\n\t\t\t\t\tcachedResponse = new WOResponse();\n\t\t\t\t\tsuper.appendToResponse( cachedResponse, wocontext );\n\t\t\t\t\t// appendToResponse above will change the response of\n\t\t\t\t\t// \"wocontext\" to \"newresponse\". When this happens during an\n\t\t\t\t\t// Ajax request, it will lead to backtracking errors on\n\t\t\t\t\t// subsequent requests, so restore the original response \"r\"\n\t\t\t\t\twocontext._setResponse( originalResponse );\n\t\t\t\t\tcachedResponse.setHeader( \"text/css\", \"content-type\" );\n\t\t\t\t\tcache.setObjectForKey( cachedResponse, key );\n\t\t\t\t\tmd5 = ERXStringUtilities.md5Hex( cachedResponse.contentString(), null );\n\t\t\t\t\tcachedResponse.setHeader( md5, \"checksum\" );\n\t\t\t\t}\n\t\t\t\tmd5 = cachedResponse.headerForKey( \"checksum\" );\n\t\t\t\tNSDictionary query = new NSDictionary<String, String>( md5, \"checksum\" );\n\t\t\t\thref = wocontext.directActionURLForActionNamed( Sheet.class.getName() + \"/\" + key, query );\n\t\t\t}\n\n\t\t\tresponse._appendContentAsciiString( \"<link \" );\n\n\t\t\tString rel = rel();\n\n\t\t\tif( rel == null )\n\t\t\t\trel = \"stylesheet\";\n\n\t\t\tresponse._appendTagAttributeAndValue( \"rel\", rel, false );\n\t\t\tresponse._appendTagAttributeAndValue( \"type\", \"text/css\", false );\n\t\t\tresponse._appendTagAttributeAndValue( \"href\", href, false );\n\n\t\t\tString media = mediaType();\n\t\t\tif( media != null ) {\n\t\t\t\tresponse._appendTagAttributeAndValue( \"media\", media, false );\n\t\t\t}\n\n\t\t\tString title = title();\n\t\t\tif( title != null ) {\n\t\t\t\tresponse._appendTagAttributeAndValue( \"title\", title, false );\n\t\t\t}\n\n\t\t\tresponse._appendContentAsciiString( \">\" );\n\t\t\tif( ERXStyleSheet.shouldCloseLinkTags() ) {\n\t\t\t\tresponse._appendContentAsciiString( \"<\/link>\" );\n\t\t\t}\n\t\t\tresponse.appendContentString(\"\\n\");\n\t\t\tboolean inserted = true;\n\t\t\tif( !inline ) {\n\t\t\t\tString stylesheetLink = response.contentString();\n\t\t\t\tinserted = ERXResponseRewriter.insertInResponseBeforeHead( originalResponse, wocontext, stylesheetLink, ERXResponseRewriter.TagMissingBehavior.Inline );\n\t\t\t}\n\t\t\tif( inserted ) {\n\t\t\t\tif( isResourceStyleSheet ) {\n\t\t\t\t\tERXResponseRewriter.resourceAddedToHead( wocontext, styleSheetFrameworkName, styleSheetName );\n\t\t\t\t}\n\t\t\t\telse if( href != null ) {\n\t\t\t\t\tERXResponseRewriter.resourceAddedToHead( wocontext, null, href );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":65519,"modified_method":"/**\n\t * Appends the &ltlink&gt; tag, either by using the style sheet name and\n\t * framework or by using the component content and then generating a link to\n\t * it.\n\t */\n\t@Override\n\tpublic void appendToResponse( WOResponse originalResponse, WOContext wocontext ) {\n\t\tString styleSheetFrameworkName = styleSheetFrameworkName();\n\t\tString styleSheetName = styleSheetName();\n\t\tboolean isResourceStyleSheet = styleSheetName != null;\n\t\tif( isResourceStyleSheet && ERXResponseRewriter.isResourceAddedToHead( wocontext, styleSheetFrameworkName, styleSheetName ) ) {\n\t\t\t// Skip, because this has already been added ... \n\t\t}\n\t\telse {\n\t\t\t// default to inline for ajax requests\n\t\t\tboolean inline = booleanValueForBinding( \"inline\", ERXAjaxApplication.isAjaxRequest( wocontext.request() ) );\n\t\t\tWOResponse response = inline ? originalResponse : new WOResponse();\n\n\t\t\tString href = styleSheetUrl();\n\t\t\tif( href == null ) {\n\t\t\t\tString key = styleSheetKey();\n\t\t\t\tERXExpiringCache<String, WOResponse> cache = cache( session() );\n\t\t\t\tString md5;\n\t\t\t\tWOResponse cachedResponse = cache.objectForKey( key );\n\t\t\t\tif( cache.isStale( key ) || ERXApplication.isDevelopmentModeSafe() ) {\n\t\t\t\t\tcachedResponse = new WOResponse();\n\t\t\t\t\tsuper.appendToResponse( cachedResponse, wocontext );\n\t\t\t\t\t// appendToResponse above will change the response of\n\t\t\t\t\t// \"wocontext\" to \"newresponse\". When this happens during an\n\t\t\t\t\t// Ajax request, it will lead to backtracking errors on\n\t\t\t\t\t// subsequent requests, so restore the original response \"r\"\n\t\t\t\t\twocontext._setResponse( originalResponse );\n\t\t\t\t\tcachedResponse.setHeader( \"text/css\", \"content-type\" );\n\t\t\t\t\tcache.setObjectForKey( cachedResponse, key );\n\t\t\t\t\tmd5 = ERXStringUtilities.md5Hex( cachedResponse.contentString(), null );\n\t\t\t\t\tcachedResponse.setHeader( md5, \"checksum\" );\n\t\t\t\t}\n\t\t\t\tmd5 = cachedResponse.headerForKey( \"checksum\" );\n\t\t\t\tNSDictionary query = new NSDictionary<String, String>( md5, \"checksum\" );\n\t\t\t\thref = wocontext.directActionURLForActionNamed( Sheet.class.getName() + \"/\" + key, query );\n\t\t\t}\n\n\t\t\tresponse._appendContentAsciiString( \"<link \" );\n\n\t\t\tString rel = rel();\n\n\t\t\tif( rel == null )\n\t\t\t\trel = \"stylesheet\";\n\n\t\t\tresponse._appendTagAttributeAndValue( \"rel\", rel, false );\n\t\t\tresponse._appendTagAttributeAndValue( \"type\", \"text/css\", false );\n\t\t\tresponse._appendTagAttributeAndValue( \"href\", href, false );\n\n\t\t\tString media = mediaType();\n\t\t\tif( media != null ) {\n\t\t\t\tresponse._appendTagAttributeAndValue( \"media\", media, false );\n\t\t\t}\n\n\t\t\tString title = title();\n\t\t\tif( title != null ) {\n\t\t\t\tresponse._appendTagAttributeAndValue( \"title\", title, false );\n\t\t\t}\n\n\t\t\tif( ERXStyleSheet.shouldCloseLinkTags() ) {\n\t\t\t\tresponse._appendContentAsciiString( \"><\/link>\" );\n\t\t\t} else {\n\t\t\t\tresponse._appendContentAsciiString( \" />\" );\n\t\t\t}\n\t\t\tresponse.appendContentString(\"\\n\");\n\t\t\tboolean inserted = true;\n\t\t\tif( !inline ) {\n\t\t\t\tString stylesheetLink = response.contentString();\n\t\t\t\tinserted = ERXResponseRewriter.insertInResponseBeforeHead( originalResponse, wocontext, stylesheetLink, ERXResponseRewriter.TagMissingBehavior.Inline );\n\t\t\t}\n\t\t\tif( inserted ) {\n\t\t\t\tif( isResourceStyleSheet ) {\n\t\t\t\t\tERXResponseRewriter.resourceAddedToHead( wocontext, styleSheetFrameworkName, styleSheetName );\n\t\t\t\t}\n\t\t\t\telse if( href != null ) {\n\t\t\t\t\tERXResponseRewriter.resourceAddedToHead( wocontext, null, href );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"d87aaa7a24b70c100a17600c8d45c5994bd4f49a","url":"https://github.com/wocommunity/wonder"},{"original_method":"void addKieBase(String kBaseName, KieBase kBase) {\n        kbases.put(kBaseName, kBase);\n    }","id":65520,"modified_method":"public void addKieBase(String kBaseName, KieBase kBase) {\n        kbases.put(kBaseName, kBase);\n    }","commit_id":"b53e192ddafe0cd8a11342f94a0c6a8d43758aa4","url":"https://github.com/droolsjbpm/drools"},{"original_method":"KieBase getKieBase(String kBaseName) {\n        return kbases.get(kBaseName);\n    }","id":65521,"modified_method":"public KieBase getKieBase(String kBaseName) {\n        return kbases.get(kBaseName);\n    }","commit_id":"b53e192ddafe0cd8a11342f94a0c6a8d43758aa4","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public Messages getMessages(Level... levels) {\n        build();\n        return new MessagesImpl( MessageImpl.filterMessages( messages,\n                                                             levels ),\n                                 null );\n    }","id":65522,"modified_method":"public Messages getMessages(Level... levels) {\n        if ( !isBuilt() ) {\n            build();\n        }\n        return new MessagesImpl( MessageImpl.filterMessages( messages,\n                                                             levels ),\n                                 null );\n    }","commit_id":"b53e192ddafe0cd8a11342f94a0c6a8d43758aa4","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private ClassLoader compileJavaClasses() {\n        List<String> javaFiles = new ArrayList<String>();\n        for ( String fileName : srcMfs.getFileNames() ) {\n            if ( fileName.endsWith( \".java\" ) ) {\n                javaFiles.add( fileName );\n            }\n        }\n        if ( javaFiles.isEmpty() ) {\n            return getClass().getClassLoader();\n        }\n\n        String[] sourceFiles = javaFiles.toArray( new String[javaFiles.size()] );\n\n        EclipseJavaCompiler compiler = createCompiler( \"src/main/java/\" );\n        CompilationResult res = compiler.compile( sourceFiles,\n                                                  srcMfs,\n                                                  trgMfs );\n\n        for ( CompilationProblem problem : res.getErrors() ) {\n            messages.add( new MessageImpl( idGenerator++,\n                                           problem ) );\n        }\n        for ( CompilationProblem problem : res.getWarnings() ) {\n            messages.add( new MessageImpl( idGenerator++,\n                                           problem ) );\n        }\n\n        if ( res.getErrors().length == 0 ) {\n            CompositeClassLoader ccl = ClassLoaderUtil.getClassLoader( null,\n                                                                       getClass(),\n                                                                       true );\n            ccl.addClassLoader( new ClassUtils.MapClassLoader( trgMfs.getMap(),\n                                                               ccl ) );\n            return ccl;\n        }\n        return getClass().getClassLoader();\n    }","id":65523,"modified_method":"private ClassLoader compileJavaClasses() {\n        List<String> classFiles = new ArrayList<String>();\n        for ( String fileName : srcMfs.getFileNames() ) {\n            if ( fileName.endsWith( \".class\" ) ) {\n                trgMfs.write(fileName, srcMfs.getBytes(fileName), true);\n                classFiles.add(fileName.substring(0, fileName.length() - \".class\".length()));\n            }\n        }\n\n        List<String> javaFiles = new ArrayList<String>();\n        for ( String fileName : srcMfs.getFileNames() ) {\n            if ( fileName.endsWith( \".java\" ) && !classFiles.contains(fileName.substring(0, fileName.length() - \".java\".length())) ) {\n                javaFiles.add( fileName );\n            }\n        }\n        if ( javaFiles.isEmpty() ) {\n            return getCompositeClassLoader();\n        }\n\n        String[] sourceFiles = javaFiles.toArray( new String[javaFiles.size()] );\n\n        EclipseJavaCompiler compiler = createCompiler( \"src/main/java/\" );\n        CompilationResult res = compiler.compile( sourceFiles,\n                                                  srcMfs,\n                                                  trgMfs );\n\n        for ( CompilationProblem problem : res.getErrors() ) {\n            messages.add( new MessageImpl( idGenerator++,\n                                           problem ) );\n        }\n        for ( CompilationProblem problem : res.getWarnings() ) {\n            messages.add( new MessageImpl( idGenerator++,\n                                           problem ) );\n        }\n\n        return res.getErrors().length == 0 ? getCompositeClassLoader() : getClass().getClassLoader();\n    }","commit_id":"b53e192ddafe0cd8a11342f94a0c6a8d43758aa4","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private void addKBaseFileToBuilder(CompositeKnowledgeBuilder ckbuilder,\n                                       KieBaseModel kieBase) {\n        for ( String fileName : srcMfs.getFileNames() ) {\n            if ( filterFileInKBase( kieBase,\n                                    fileName ) ) {\n                ckbuilder.add( ResourceFactory.newByteArrayResource( srcMfs.getBytes( fileName ) ),\n                               ResourceType.determineResourceType( fileName ) );\n            }\n        }\n    }","id":65524,"modified_method":"private void addKBaseFileToBuilder(CompositeKnowledgeBuilder ckbuilder,\n                                       KieBaseModel kieBase) {\n        for ( String fileName : srcMfs.getFileNames() ) {\n            if ( filterFileInKBase( kieBase,\n                                    fileName ) ) {\n                byte[] bytes = srcMfs.getBytes(fileName);\n                ckbuilder.add( ResourceFactory.newByteArrayResource( srcMfs.getBytes( fileName ) ),\n                               ResourceType.determineResourceType( fileName ) );\n                trgMfs.write( fileName, bytes, true );\n            }\n        }\n    }","commit_id":"b53e192ddafe0cd8a11342f94a0c6a8d43758aa4","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public KieJar getKieJar() {\n        build();\n        if ( hasMessages( Level.ERROR ) || kieJar == null ) {\n            throw new RuntimeException( \"Unable to get KieJar, Errors Existed\" );\n        }\n        return kieJar;\n    }","id":65525,"modified_method":"public KieJar getKieJar() {\n        if ( !isBuilt() ) {\n            build();\n        }\n        if ( hasMessages( Level.ERROR ) || kieJar == null ) {\n            throw new RuntimeException( \"Unable to get KieJar, Errors Existed\" );\n        }\n        return kieJar;\n    }","commit_id":"b53e192ddafe0cd8a11342f94a0c6a8d43758aa4","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public boolean hasMessages(Level... levels) {\n        build();\n        return !MessageImpl.filterMessages( messages,\n                                            levels ).isEmpty();\n    }","id":65526,"modified_method":"public boolean hasMessages(Level... levels) {\n        if ( !isBuilt() ) {\n            build();\n        }\n        return !MessageImpl.filterMessages( messages,\n                                            levels ).isEmpty();\n    }","commit_id":"b53e192ddafe0cd8a11342f94a0c6a8d43758aa4","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private void init() {\n        messages = new ArrayList<Message>();\n        gav = getGAV();        \n        kieProject = getKieProject();\n        if (gav == null && kieProject != null) {\n            gav = kieProject.getGroupArtifactVersion();\n        }\n    }","id":65527,"modified_method":"private void init() {\n        messages = new ArrayList<Message>();\n        gav = getGAV();        \n        kieProject = getKieProject();\n        if (!invalidPomXml && gav == null && kieProject != null) {\n            gav = kieProject.getGroupArtifactVersion();\n        }\n    }","commit_id":"b53e192ddafe0cd8a11342f94a0c6a8d43758aa4","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public Messages getMessages() {\n        build();\n        return new MessagesImpl( messages,\n                                 null );\n    }","id":65528,"modified_method":"public Messages getMessages() {\n        if ( !isBuilt() ) {\n            build();\n        }\n        return new MessagesImpl( messages,\n                                 null );\n    }","commit_id":"b53e192ddafe0cd8a11342f94a0c6a8d43758aa4","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public KieFileSystemImpl() {\n    }","id":65529,"modified_method":"public KieFileSystemImpl() {\n        this(new MemoryFileSystem());\n    }","commit_id":"b53e192ddafe0cd8a11342f94a0c6a8d43758aa4","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void scanNow() {\n        if (usedDependencies == null) {\n            return;\n        }\n        Collection<Artifact> updatedArtifacts = scanForUpdates(usedDependencies);\n        if (updatedArtifacts.isEmpty()) {\n            return;\n        }\n        for (Artifact artifact : updatedArtifacts) {\n            File kJar = artifact.getFile();\n            DependencyDescriptor depDescr = new DependencyDescriptor(artifact);\n            usedDependencies.remove(depDescr);\n            usedDependencies.add(depDescr);\n            if (kieContainer.getGAV().equals(depDescr.getGav())) {\n                ((InternalKieContainer)kieContainer).updateKieJar(new FileKieJar(kJar));\n            }\n        }\n        log.info(\"The following artifacts have been updated: \" + updatedArtifacts);\n    }","id":65530,"modified_method":"public void scanNow() {\n        if (usedDependencies == null) {\n            return;\n        }\n        Collection<Artifact> updatedArtifacts = scanForUpdates(usedDependencies);\n        if (updatedArtifacts.isEmpty()) {\n            return;\n        }\n        for (Artifact artifact : updatedArtifacts) {\n            File kJar = artifact.getFile();\n            DependencyDescriptor depDescr = new DependencyDescriptor(artifact);\n            usedDependencies.remove(depDescr);\n            usedDependencies.add(depDescr);\n            if (kieContainer.getGAV().equals(depDescr.getGav())) {\n                updateKieJar(kJar);\n            }\n        }\n        log.info(\"The following artifacts have been updated: \" + updatedArtifacts);\n    }","commit_id":"b53e192ddafe0cd8a11342f94a0c6a8d43758aa4","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private KieJar createKieJarWithClass(KieServices ks, KieFactory kf, int value, int factor) throws IOException {\n        KieFileSystem kieFileSystem = kf.newKieFileSystem();\n\n        KieProject kproj = kf.newKieProject()\n                .setGroupArtifactVersion(kf.newGav(\"org.kie\", \"scanner-test\", \"1.0-SNAPSHOT\"));\n\n        KieBaseModel kieBaseModel1 = kproj.newKieBaseModel(\"KBase1\")\n                .setEqualsBehavior( AssertBehaviorOption.EQUALITY )\n                .setEventProcessingMode( EventProcessingOption.STREAM );\n\n        KieSessionModel ksession1 = kieBaseModel1.newKieSessionModel(\"KSession1\")\n                .setType( \"stateful\" )\n                .setClockType( ClockTypeOption.get(\"realtime\") );\n\n        kieFileSystem\n                .write(KieProject.KPROJECT_JAR_PATH, kproj.toXML())\n                .write(\"src/kbases/\" + kieBaseModel1.getName() + \"/rule1.drl\", createDRLForJavaSource(value))\n                .write(\"org/kie/test/Bean.java\", createJavaSource(factor));\n\n        KieBuilder kieBuilder = ks.newKieBuilder(kieFileSystem);\n        assertTrue(kieBuilder.build().getInsertedMessages().isEmpty());\n        return kieBuilder.getKieJar();\n    }","id":65531,"modified_method":"private KieJar createKieJarWithClass(KieServices ks, KieFactory kf, int value, int factor) throws IOException {\n        KieFileSystem kieFileSystem = kf.newKieFileSystem();\n\n        KieProject kproj = kf.newKieProject()\n                .setGroupArtifactVersion(kf.newGav(\"org.kie\", \"scanner-test\", \"1.0-SNAPSHOT\"));\n\n        KieBaseModel kieBaseModel1 = kproj.newKieBaseModel(\"KBase1\")\n                .setEqualsBehavior( AssertBehaviorOption.EQUALITY )\n                .setEventProcessingMode( EventProcessingOption.STREAM );\n\n        KieSessionModel ksession1 = kieBaseModel1.newKieSessionModel(\"KSession1\")\n                .setType( \"stateful\" )\n                .setClockType( ClockTypeOption.get(\"realtime\") );\n\n        kieFileSystem\n                .write(KieProject.KPROJECT_JAR_PATH, kproj.toXML())\n                .write(\"src/kbases/\" + kieBaseModel1.getName() + \"/rule1.drl\", createDRLForJavaSource(value))\n                .write(\"src/main/java/org/kie/test/Bean.java\", createJavaSource(factor));\n\n        KieBuilder kieBuilder = ks.newKieBuilder(kieFileSystem);\n        assertTrue(kieBuilder.build().getInsertedMessages().isEmpty());\n        return kieBuilder.getKieJar();\n    }","commit_id":"b53e192ddafe0cd8a11342f94a0c6a8d43758aa4","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private File createKPom() throws IOException {\n        String pom =\n                \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                \"<project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\" +\n                \"         xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\\\">\\n\" +\n                \"  <modelVersion>4.0.0<\/modelVersion>\\n\" +\n                \"\\n\" +\n                \"  <groupId>org.drools<\/groupId>\\n\" +\n                \"  <artifactId>scanner-test<\/artifactId>\\n\" +\n                \"  <version>1.0-SNAPSHOT<\/version>\\n\" +\n                \"\\n\" +\n                \"<\/project>\";\n\n        File pomFile = fileManager.newFile(\"pom.xml\");\n        fileManager.write(pomFile, pom);\n        return pomFile;\n    }","id":65532,"modified_method":"private File createKPom() throws IOException {\n        String pom =\n                \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                \"<project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\" +\n                \"         xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\\\">\\n\" +\n                \"  <modelVersion>4.0.0<\/modelVersion>\\n\" +\n                \"\\n\" +\n                \"  <groupId>org.kie<\/groupId>\\n\" +\n                \"  <artifactId>scanner-test<\/artifactId>\\n\" +\n                \"  <version>1.0-SNAPSHOT<\/version>\\n\" +\n                \"\\n\" +\n                \"<\/project>\";\n\n        File pomFile = fileManager.newFile(\"pom.xml\");\n        fileManager.write(pomFile, pom);\n        return pomFile;\n    }","commit_id":"b53e192ddafe0cd8a11342f94a0c6a8d43758aa4","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Test @Ignore\n    public void testKScanner() throws Exception {\n        KieServices ks = KieServices.Factory.get();\n        KieFactory kf = KieFactory.Factory.get();\n\n        KieJar kJar1 = createKieJar(ks, kf, \"rule1\", \"rule2\");\n        KieContainer kieContainer = ks.getKieContainer(kf.newGav(\"org.kie\", \"scanner-test\", \"1.0-SNAPSHOT\"));\n\n        MavenRepository repository = new MavenRepository();\n        repository.deployArtifact(\"org.kie\", \"scanner-test\", \"1.0-SNAPSHOT\", ((InternalKieJar)kJar1).asFile(), kPom);\n\n        // create a ksesion and check it works as expected\n        KieSession ksession = kieContainer.getKieSession(\"KSession1\");\n        checkKSession(ksession, \"rule1\", \"rule2\");\n\n        // create a new kjar\n        KieJar kJar2 = createKieJar(ks, kf, \"rule2\", \"rule3\");\n\n        // deploy it on maven\n        repository.deployArtifact(\"org.drools\", \"scanner-test\", \"1.0-SNAPSHOT\", ((InternalKieJar)kJar2).asFile(), kPom);\n\n        // since I am not calling start() on the scanner it means it won't have automatic scheduled scanning\n        KieScanner scanner = ks.newKieScanner(kieContainer);\n\n        // scan the maven repo to get the new kjar version and deploy it on the kcontainer\n        scanner.scanNow();\n\n        // create a ksesion and check it works as expected\n        KieSession ksession2 = kieContainer.getKieSession(\"KSession1\");\n        checkKSession(ksession2, \"rule2\", \"rule3\");\n    }","id":65533,"modified_method":"@Test @Ignore\n    public void testKScanner() throws Exception {\n        KieServices ks = KieServices.Factory.get();\n        KieFactory kf = KieFactory.Factory.get();\n\n        KieJar kJar1 = createKieJar(ks, kf, \"rule1\", \"rule2\");\n        KieContainer kieContainer = ks.getKieContainer(kf.newGav(\"org.kie\", \"scanner-test\", \"1.0-SNAPSHOT\"));\n\n        MavenRepository repository = new MavenRepository();\n        repository.deployArtifact(\"org.kie\", \"scanner-test\", \"1.0-SNAPSHOT\", ((InternalKieJar)kJar1).asFile(), kPom);\n\n        // create a ksesion and check it works as expected\n        KieSession ksession = kieContainer.getKieSession(\"KSession1\");\n        checkKSession(ksession, \"rule1\", \"rule2\");\n\n        // create a new kjar\n        KieJar kJar2 = createKieJar(ks, kf, \"rule2\", \"rule3\");\n\n        // deploy it on maven\n        repository.deployArtifact(\"org.kie\", \"scanner-test\", \"1.0-SNAPSHOT\", ((InternalKieJar)kJar2).asFile(), kPom);\n\n        // since I am not calling start() on the scanner it means it won't have automatic scheduled scanning\n        KieScanner scanner = ks.newKieScanner(kieContainer);\n\n        // scan the maven repo to get the new kjar version and deploy it on the kcontainer\n        scanner.scanNow();\n\n        // create a ksesion and check it works as expected\n        KieSession ksession2 = kieContainer.getKieSession(\"KSession1\");\n        checkKSession(ksession2, \"rule2\", \"rule3\");\n    }","commit_id":"b53e192ddafe0cd8a11342f94a0c6a8d43758aa4","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void create(InputStream is) throws IOException {\n        if ( exists() ) {\n            throw new IOException( \"File does already exists, cannot create contents\" );\n        }\n        \n        mfs.setFileContents( this, StringUtils.toString( is ).getBytes() );\n    }","id":65534,"modified_method":"public void create(InputStream is) throws IOException {\n        if ( exists() ) {\n            throw new IOException( \"File does already exists, cannot create contents\" );\n        }\n\n        mfs.setFileContents( this, getBytesFromInputStream(is) );\n    }","commit_id":"b53e192ddafe0cd8a11342f94a0c6a8d43758aa4","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void listFilesAndDirectories(DirectoryObject directoryObject, Collection fileNames, Collection directoryNames, ICvsFileSystem cvsFileSystem) {\n  }","id":65535,"modified_method":"public void listFilesAndDirectories(DirectoryObject directoryObject, Collection<String> fileNames, Collection<String> directoryNames, ICvsFileSystem cvsFileSystem) {\n  }","commit_id":"e6cc913fbe958ba1516d0b6be0a2997bc90ff255","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void scanDirectories(DirectoryObject rootDirectoryObject, CvsFiles cvsFiles) throws IOException {\n\t\tfinal List directories = new LinkedList();\n\t\tdirectories.add(rootDirectoryObject);\n\t\twhile (directories.size() > 0) {\n\t\t\tfinal DirectoryObject directoryObject = (DirectoryObject)directories.remove(0);\n\n\t\t\tfinal List subDirectories = scanDirectory(directoryObject, cvsFiles);\n\t\t\tif (recursive) {\n\t\t\t\tdirectories.addAll(subDirectories);\n\t\t\t}\n\t\t}\n\t}","id":65536,"modified_method":"private void scanDirectories(DirectoryObject rootDirectoryObject, CvsFiles cvsFiles) throws IOException {\n    final List<DirectoryObject> directories = new LinkedList<DirectoryObject>();\n    directories.add(rootDirectoryObject);\n    while (directories.size() > 0) {\n      final DirectoryObject directoryObject = directories.remove(0);\n\n      final List<DirectoryObject> subDirectories = scanDirectory(directoryObject, cvsFiles);\n      if (recursive) {\n        directories.addAll(subDirectories);\n      }\n    }\n  }","commit_id":"e6cc913fbe958ba1516d0b6be0a2997bc90ff255","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private List scanDirectory(DirectoryObject directoryObject, CvsFiles cvsFiles) throws IOException {\n\t\tif (!clientEnvironment.getLocalFileReader().exists(directoryObject, clientEnvironment.getCvsFileSystem())) {\n\t\t\treturn Collections.EMPTY_LIST;\n\t\t}\n\n\t\tcvsFiles.add(CvsFile.createCvsDirectory(directoryObject));\n\n\t\tfinal Set subDirectoryNames = new HashSet();\n\t\tfinal LocalFiles localFiles = new LocalFiles(directoryObject, clientEnvironment);\n\n\t\t// get all the entries we know about, and process them\n\t\tfinal Collection entries = clientEnvironment.getAdminReader().getEntries(directoryObject, clientEnvironment.getCvsFileSystem());\n\t\tfor (Iterator it = entries.iterator(); it.hasNext();) {\n\t\t\tfinal Entry entry = (Entry)it.next();\n\t\t\tif (entry.isDirectory()) {\n\t\t\t\tsubDirectoryNames.add(entry.getFileName());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinal FileObject fileObject = FileObject.createInstance(directoryObject, entry.getFileName());\n\t\t\t\tfinal boolean fileExists = clientEnvironment.getLocalFileReader().exists(fileObject, clientEnvironment.getCvsFileSystem());\n\n\t\t\t\tcvsFiles.add(CvsFile.createCvsFileForEntry(fileObject, entry, fileExists));\n\n\t\t\t\tlocalFiles.removeFile(entry.getFileName());\n\t\t\t}\n\t\t}\n\n\t\tfor (Iterator it = localFiles.getFileNames().iterator(); it.hasNext();) {\n\t\t\tfinal String fileName = (String)it.next();\n\n\t\t\tcvsFiles.add(CvsFile.createCvsFileForExistingFile(FileObject.createInstance(directoryObject, fileName)));\n\t\t}\n\n\t\tfinal List subDirectories = new ArrayList(subDirectoryNames.size());\n\t\tfor (Iterator it = subDirectoryNames.iterator(); it.hasNext();) {\n\t\t\tfinal String directoryName = (String)it.next();\n\t\t\tsubDirectories.add(DirectoryObject.createInstance(directoryObject, directoryName));\n\t\t}\n\t\treturn subDirectories;\n\t}","id":65537,"modified_method":"private List<DirectoryObject> scanDirectory(DirectoryObject directoryObject, CvsFiles cvsFiles) throws IOException {\n    if (!clientEnvironment.getLocalFileReader().exists(directoryObject, clientEnvironment.getCvsFileSystem())) {\n      return Collections.EMPTY_LIST;\n    }\n\n    cvsFiles.add(CvsFile.createCvsDirectory(directoryObject));\n\n    final Set<String> subDirectoryNames = new HashSet<String>();\n    final LocalFiles localFiles = new LocalFiles(directoryObject, clientEnvironment);\n\n    // get all the entries we know about, and process them\n    final Collection<Entry> entries = clientEnvironment.getAdminReader().getEntries(directoryObject, clientEnvironment.getCvsFileSystem());\n    for (final Entry entry : entries) {\n      if (entry.isDirectory()) {\n        subDirectoryNames.add(entry.getFileName());\n      }\n      else {\n        final FileObject fileObject = FileObject.createInstance(directoryObject, entry.getFileName());\n        final boolean fileExists = clientEnvironment.getLocalFileReader().exists(fileObject, clientEnvironment.getCvsFileSystem());\n\n        cvsFiles.add(CvsFile.createCvsFileForEntry(fileObject, entry, fileExists));\n\n        localFiles.removeFile(entry.getFileName());\n      }\n    }\n\n    for (final String fileName : localFiles.getFileNames()) {\n      cvsFiles.add(CvsFile.createCvsFileForExistingFile(FileObject.createInstance(directoryObject, fileName)));\n    }\n\n    final List<DirectoryObject> subDirectories = new ArrayList<DirectoryObject>(subDirectoryNames.size());\n    for (final String directoryName : subDirectoryNames) {\n      subDirectories.add(DirectoryObject.createInstance(directoryObject, directoryName));\n    }\n    return subDirectories;\n  }","commit_id":"e6cc913fbe958ba1516d0b6be0a2997bc90ff255","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void listFilesAndDirectories(DirectoryObject directoryObject,\n                                      Collection fileNames,\n                                      Collection directoryNames,\n                                      ICvsFileSystem cvsFileSystem) {\n    VirtualFile virtualDirectory = getVirtualFile(directoryObject, cvsFileSystem);\n    if (virtualDirectory == null) return;\n    VirtualFile[] children = CvsVfsUtil.getChildrenOf(virtualDirectory);\n    if (children == null) return;\n\n    for (int i = 0; i < children.length; i++) {\n      final VirtualFile fileOrDirectory = children[i];\n      if (CvsUtil.CVS.equals(fileOrDirectory.getName())) continue;\n      if (!myProjectContentInfoProvider.fileIsUnderProject(fileOrDirectory)) continue;\n      final String name = fileOrDirectory.getName();\n      if (fileOrDirectory.isDirectory()) {\n        if (directoryNames != null) {\n          directoryNames.add(name);\n        }\n      }\n      else {\n        if (fileNames != null) {\n          LOG.assertTrue(name.length() > 0);\n          fileNames.add(name);\n        }\n      }\n    }\n\n  }","id":65538,"modified_method":"public void listFilesAndDirectories(DirectoryObject directoryObject,\n                                      Collection<String> fileNames,\n                                      Collection<String> directoryNames,\n                                      ICvsFileSystem cvsFileSystem) {\n    VirtualFile virtualDirectory = getVirtualFile(directoryObject, cvsFileSystem);\n    if (virtualDirectory == null) return;\n    VirtualFile[] children = CvsVfsUtil.getChildrenOf(virtualDirectory);\n    if (children == null) return;\n\n    for (final VirtualFile fileOrDirectory : children) {\n      if (CvsUtil.CVS.equals(fileOrDirectory.getName())) continue;\n      if (!myProjectContentInfoProvider.fileIsUnderProject(fileOrDirectory)) continue;\n      final String name = fileOrDirectory.getName();\n      if (fileOrDirectory.isDirectory()) {\n        if (directoryNames != null) {\n          directoryNames.add(name);\n        }\n      }\n      else {\n        if (fileNames != null) {\n          LOG.assertTrue(name.length() > 0);\n          fileNames.add(name);\n        }\n      }\n    }\n\n  }","commit_id":"e6cc913fbe958ba1516d0b6be0a2997bc90ff255","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n\tpublic final void format() throws Exception {\n\t\tpreFormat();\n\n\t\tfor (String fileName : getFileNames()) {\n\t\t\ttry {\n\t\t\t\tformat(fileName);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new RuntimeException(\"Unable to format \" + fileName, e);\n\t\t\t}\n\t\t}\n\n\t\tpostFormat();\n\n\t\t_sourceFormatterHelper.close();\n\t}","id":65539,"modified_method":"@Override\n\tpublic final void format() throws Exception {\n\t\tpreFormat();\n\n\t\tList<String> fileNames = getFileNames();\n\n\t\tExecutorService executorService = Executors.newFixedThreadPool(5);\n\n\t\tList<Future<Void>> futures = new ArrayList<>(fileNames.size());\n\n\t\tfor (final String fileName : fileNames) {\n\t\t\tFuture<Void> future = executorService.submit(\n\t\t\t\tnew Callable<Void>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Void call() throws Exception {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tformat(fileName);\n\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\t\"Unable to format \" + fileName, e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t});\n\n\t\t\tfutures.add(future);\n\t\t}\n\n\t\tfor (Future<Void> future : futures) {\n\t\t\tfuture.get();\n\t\t}\n\n\t\texecutorService.shutdown();\n\n\t\tpostFormat();\n\n\t\t_sourceFormatterHelper.close();\n\t}","commit_id":"ecbe43a47761a835001e5bb12ac340e2d80a6530","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Verifies that the required parameters are not null.\n     * @throws IllegalArgumentException thrown if label, name, user or summary\n     *  are null.\n     */\n    protected void verifyRequiredParameters() {\n        if (user == null || summary == null) {\n            throw new IllegalArgumentException(\n                  \"Required parameters not set: user, or summary\");\n        }\n    }","id":65540,"modified_method":"/**\n     * Verifies that the required parameters are not null.\n     * @throws IllegalArgumentException thrown if label, name, user or summary\n     *  are null.\n     */\n    protected void verifyRequiredParameters() {\n        if (user == null || StringUtils.isEmpty(summary)) {\n            throw new IllegalArgumentException(\n                  \"Required parameters not set: user, or summary\");\n        }\n    }","commit_id":"fd47b8b638de8066e6ec76cff1a54c0034c1404a","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/** {@inheritDoc} */\n    public ActionForward execute (ActionMapping mapping,\n                                  ActionForm formIn,\n                                  HttpServletRequest request,\n                                  HttpServletResponse response) {\n    \n        ActionErrors errors = new ActionErrors();\n        DynaActionForm form = (DynaActionForm)formIn;\n        Map params = makeParamMap(request);\n        RequestContext ctx = new RequestContext(request);\n\n        if (!isSubmitted(form)) {\n            setupForm(request, form);\n            return getStrutsDelegate().forwardParams(\n                    mapping.findForward(\"default\"),\n                    request.getParameterMap());\n        }\n\n        System.out.println(\"--------------------------------------\");\n        Enumeration paramNames = request.getParameterNames();\n        while (paramNames.hasMoreElements()) {\n            System.out.println((String) paramNames.nextElement());\n        }\n        System.out.println(\"--------------------------------------\");\n        Map map = form.getMap();\n        for (Iterator itr = map.keySet().iterator(); itr.hasNext();) {\n            System.out.println((String) itr.next());\n        }\n        System.out.println(\"--------------------------------------\");\n\n/*\nchannel.edit.jsp.createchannel\nchannel.edit.jsp.editchannel\n*/\n        if (ctx.hasParam(\"create_button\")) {\n            Long cid = create(form, errors, ctx);\n            params.put(\"cid\", cid);\n        }\n        else if (ctx.hasParam(\"edit_button\")) {\n            params.put(\"cid\", ctx.getParam(\"cid\", true));\n            edit(form, errors, ctx);\n        }\n\n        if (!errors.isEmpty()) {\n            addErrors(request, errors);\n            prepDropdowns(new RequestContext(request));\n            return getStrutsDelegate().forwardParams(\n                    mapping.findForward(\"default\"), \n                    params);\n        }\n\n        return getStrutsDelegate().forwardParams(\n                mapping.findForward(\"success\"), params);\n    }","id":65541,"modified_method":"/** {@inheritDoc} */\n    public ActionForward execute (ActionMapping mapping,\n                                  ActionForm formIn,\n                                  HttpServletRequest request,\n                                  HttpServletResponse response) {\n    \n        ActionErrors errors = new ActionErrors();\n        DynaActionForm form = (DynaActionForm)formIn;\n        Map params = makeParamMap(request);\n        RequestContext ctx = new RequestContext(request);\n        \n        // keep the cid\n        if (ctx.hasParam(\"cid\")) {\n            params.put(\"cid\", ctx.getParam(\"cid\", true));\n        }\n\n        if (!isSubmitted(form)) {\n            setupForm(request, form);\n            return getStrutsDelegate().forwardParams(\n                    mapping.findForward(\"default\"),\n                    request.getParameterMap());\n        }\n\n        if (ctx.hasParam(\"create_button\")) {\n            Long cid = create(form, errors, ctx);\n            params.put(\"cid\", cid);\n        }\n        else if (ctx.hasParam(\"edit_button\")) {\n            //params.put(\"cid\", ctx.getParam(\"cid\", true));\n            edit(form, errors, ctx);\n            if (!errors.isEmpty()) {\n                request.setAttribute(\"channel_label\", (String) form.get(\"label\"));\n                request.setAttribute(\"channel_name\", (String) form.get(\"name\"));\n                request.setAttribute(\"channel_arch\", (String) form.get(\"arch_name\"));\n                request.setAttribute(\"channel_arch_label\", (String) form.get(\"arch\"));\n            }\n        }\n\n        if (!errors.isEmpty()) {\n            addErrors(request, errors);\n            prepDropdowns(new RequestContext(request));\n            return getStrutsDelegate().forwardParams(\n                    mapping.findForward(\"default\"), \n                    params);\n        }\n\n        return getStrutsDelegate().forwardParams(\n                mapping.findForward(\"success\"), params);\n    }","commit_id":"fd47b8b638de8066e6ec76cff1a54c0034c1404a","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"private Long create(DynaActionForm form,\n                        ActionErrors errors,\n                        RequestContext ctx) {\n\n        User loggedInUser = ctx.getLoggedInUser();\n        Long cid = null;\n\n        // handle submission\n        // why can't I just pass in a dictionary? sigh, there are\n        // times where python would make this SOOOO much easier.\n        CreateChannelCommand ccc = new CreateChannelCommand();\n        ccc.setArchLabel((String)form.get(\"arch\"));\n        ccc.setLabel((String)form.get(\"label\"));\n        ccc.setName((String)form.get(\"name\"));\n        ccc.setSummary((String)form.get(\"summary\"));\n        ccc.setDescription((String)form.get(\"description\"));\n        ccc.setParentLabel(null);\n        ccc.setUser(loggedInUser);\n        ccc.setGpgKeyId((String)form.get(\"gpg_key_id\"));\n        ccc.setGpgKeyUrl((String)form.get(\"gpg_key_url\"));\n        ccc.setGpgKeyFp((String)form.get(\"gpg_key_fingerprint\"));\n        ccc.setMaintainerName((String)form.get(\"maintainer_name\"));\n        ccc.setMaintainerEmail((String)form.get(\"maintainer_email\"));\n        ccc.setMaintainerPhone((String)form.get(\"maintainer_phone\"));\n        ccc.setSupportPolicy((String)form.get(\"support_policy\"));\n\n        String parent = (String)form.get(\"parent\");\n        if (parent == null || parent.equals(\"\")) {\n            ccc.setParentId(null);\n        }\n        else {\n            ccc.setParentId(Long.valueOf(parent));\n        }\n\n        try {\n            Channel c = ccc.create();\n            cid = c.getId();\n        }\n        catch (InvalidGPGFingerprintException borg) {\n            errors.add(ActionMessages.GLOBAL_MESSAGE,\n                    new ActionMessage(\"edit.channel.invalidgpgfp\"));\n        }\n        catch (InvalidGPGKeyException dukat) {\n            errors.add(ActionMessages.GLOBAL_MESSAGE,\n                    new ActionMessage(\"edit.channel.invalidgpgkey\"));\n        }\n        catch (InvalidGPGUrlException khan) {\n            errors.add(ActionMessages.GLOBAL_MESSAGE,\n                    new ActionMessage(\"edit.channel.invalidgpgurl\"));\n        }\n        catch (InvalidChannelNameException ferengi) {\n            errors.add(ActionMessages.GLOBAL_MESSAGE,\n                    new ActionMessage(\"edit.channel.invalidchannelname\"));\n        }\n        catch (InvalidChannelLabelException q) {\n            errors.add(ActionMessages.GLOBAL_MESSAGE,\n                    new ActionMessage(\"edit.channel.invalidchannellabel\"));\n        }\n\n        return cid;\n    }","id":65542,"modified_method":"private Long create(DynaActionForm form,\n                        ActionErrors errors,\n                        RequestContext ctx) {\n\n        User loggedInUser = ctx.getLoggedInUser();\n        Long cid = null;\n\n        // handle submission\n        // why can't I just pass in a dictionary? sigh, there are\n        // times where python would make this SOOOO much easier.\n        CreateChannelCommand ccc = new CreateChannelCommand();\n        ccc.setArchLabel((String)form.get(\"arch\"));\n        ccc.setLabel((String)form.get(\"label\"));\n        ccc.setName((String)form.get(\"name\"));\n        ccc.setSummary((String)form.get(\"summary\"));\n        ccc.setDescription((String)form.get(\"description\"));\n        ccc.setParentLabel(null);\n        ccc.setUser(loggedInUser);\n        ccc.setGpgKeyId((String)form.get(\"gpg_key_id\"));\n        ccc.setGpgKeyUrl((String)form.get(\"gpg_key_url\"));\n        ccc.setGpgKeyFp((String)form.get(\"gpg_key_fingerprint\"));\n        ccc.setMaintainerName((String)form.get(\"maintainer_name\"));\n        ccc.setMaintainerEmail((String)form.get(\"maintainer_email\"));\n        ccc.setMaintainerPhone((String)form.get(\"maintainer_phone\"));\n        ccc.setSupportPolicy((String)form.get(\"support_policy\"));\n        ccc.setAccess((String)form.get(\"org_sharing\"));\n\n        String parent = (String)form.get(\"parent\");\n        if (parent == null || parent.equals(\"\")) {\n            ccc.setParentId(null);\n        }\n        else {\n            ccc.setParentId(Long.valueOf(parent));\n        }\n\n        try {\n            Channel c = ccc.create();\n            cid = c.getId();\n        }\n        catch (InvalidGPGFingerprintException borg) {\n            errors.add(ActionMessages.GLOBAL_MESSAGE,\n                    new ActionMessage(\"edit.channel.invalidgpgfp\"));\n        }\n        catch (InvalidGPGKeyException dukat) {\n            errors.add(ActionMessages.GLOBAL_MESSAGE,\n                    new ActionMessage(\"edit.channel.invalidgpgkey\"));\n        }\n        catch (InvalidGPGUrlException khan) {\n            errors.add(ActionMessages.GLOBAL_MESSAGE,\n                    new ActionMessage(\"edit.channel.invalidgpgurl\"));\n        }\n        catch (InvalidChannelNameException ferengi) {\n            errors.add(ActionMessages.GLOBAL_MESSAGE,\n                    new ActionMessage(\"edit.channel.invalidchannelname\"));\n        }\n        catch (InvalidChannelLabelException q) {\n            errors.add(ActionMessages.GLOBAL_MESSAGE,\n                    new ActionMessage(\"edit.channel.invalidchannellabel\"));\n        }\n        catch (IllegalArgumentException iae) {\n            errors.add(ActionMessages.GLOBAL_MESSAGE,\n                    new ActionMessage(\"edit.channel.invalidchannelsummary\"));\n        }\n\n        return cid;\n    }","commit_id":"fd47b8b638de8066e6ec76cff1a54c0034c1404a","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"private void edit(DynaActionForm form,\n                      ActionErrors errors,\n                      RequestContext ctx) {\n\n        User loggedInUser = ctx.getLoggedInUser();\n\n        // handle submission\n        // why can't I just pass in a dictionary? sigh, there are\n        // times where python would make this SOOOO much easier.\n        UpdateChannelCommand ucc = new UpdateChannelCommand();\n        ucc.setArchLabel((String)form.get(\"arch\"));\n        ucc.setLabel((String)form.get(\"label\"));\n        ucc.setName((String)form.get(\"name\"));\n        ucc.setSummary((String)form.get(\"summary\"));\n        ucc.setDescription((String)form.get(\"description\"));\n        ucc.setParentLabel(null);\n        ucc.setUser(loggedInUser);\n        ucc.setGpgKeyId((String)form.get(\"gpg_key_id\"));\n        ucc.setGpgKeyUrl((String)form.get(\"gpg_key_url\"));\n        ucc.setGpgKeyFp((String)form.get(\"gpg_key_fingerprint\"));\n        ucc.setMaintainerName((String)form.get(\"maintainer_name\"));\n        ucc.setMaintainerEmail((String)form.get(\"maintainer_email\"));\n        ucc.setMaintainerPhone((String)form.get(\"maintainer_phone\"));\n        ucc.setSupportPolicy((String)form.get(\"support_policy\"));\n\n        String parent = (String)form.get(\"parent\");\n        if (parent == null || parent.equals(\"\")) {\n            ucc.setParentId(null);\n        }\n        else {\n            ucc.setParentId(Long.valueOf(parent));\n        }\n\n        try {\n            ucc.update(ctx.getParamAsLong(\"cid\"));\n        }\n        catch (InvalidGPGFingerprintException borg) {\n            errors.add(ActionMessages.GLOBAL_MESSAGE,\n                    new ActionMessage(\"edit.channel.invalidgpgfp\"));\n        }\n        catch (InvalidGPGKeyException dukat) {\n            errors.add(ActionMessages.GLOBAL_MESSAGE,\n                    new ActionMessage(\"edit.channel.invalidgpgkey\"));\n        }\n        catch (InvalidGPGUrlException khan) {\n            errors.add(ActionMessages.GLOBAL_MESSAGE,\n                    new ActionMessage(\"edit.channel.invalidgpgurl\"));\n        }\n        catch (InvalidChannelNameException ferengi) {\n            errors.add(ActionMessages.GLOBAL_MESSAGE,\n                    new ActionMessage(\"edit.channel.invalidchannelname\"));\n        }\n        catch (InvalidChannelLabelException q) {\n            errors.add(ActionMessages.GLOBAL_MESSAGE,\n                    new ActionMessage(\"edit.channel.invalidchannellabel\"));\n        }\n    }","id":65543,"modified_method":"private Channel edit(DynaActionForm form,\n                      ActionErrors errors,\n                      RequestContext ctx) {\n\n        User loggedInUser = ctx.getLoggedInUser();\n        Channel updated = null;\n\n        // handle submission\n        // why can't I just pass in a dictionary? sigh, there are\n        // times where python would make this SOOOO much easier.\n        UpdateChannelCommand ucc = new UpdateChannelCommand();\n        ucc.setArchLabel((String)form.get(\"arch\"));\n        ucc.setLabel((String)form.get(\"label\"));\n        ucc.setName((String)form.get(\"name\"));\n        ucc.setSummary((String)form.get(\"summary\"));\n        ucc.setDescription((String)form.get(\"description\"));\n        ucc.setUser(loggedInUser);\n        ucc.setGpgKeyId((String)form.get(\"gpg_key_id\"));\n        ucc.setGpgKeyUrl((String)form.get(\"gpg_key_url\"));\n        ucc.setGpgKeyFp((String)form.get(\"gpg_key_fingerprint\"));\n        ucc.setMaintainerName((String)form.get(\"maintainer_name\"));\n        ucc.setMaintainerEmail((String)form.get(\"maintainer_email\"));\n        ucc.setMaintainerPhone((String)form.get(\"maintainer_phone\"));\n        ucc.setSupportPolicy((String)form.get(\"support_policy\"));\n        ucc.setAccess((String)form.get(\"org_sharing\"));\n\n        String parent = (String)form.get(\"parent\");\n        if (parent == null || parent.equals(\"\")) {\n            ucc.setParentId(null);\n        }\n        else {\n            ucc.setParentId(Long.valueOf(parent));\n        }\n\n        try {\n            updated = ucc.update(ctx.getParamAsLong(\"cid\"));\n        }\n        catch (InvalidGPGFingerprintException borg) {\n            errors.add(ActionMessages.GLOBAL_MESSAGE,\n                    new ActionMessage(\"edit.channel.invalidgpgfp\"));\n        }\n        catch (InvalidGPGKeyException dukat) {\n            errors.add(ActionMessages.GLOBAL_MESSAGE,\n                    new ActionMessage(\"edit.channel.invalidgpgkey\"));\n        }\n        catch (InvalidGPGUrlException khan) {\n            errors.add(ActionMessages.GLOBAL_MESSAGE,\n                    new ActionMessage(\"edit.channel.invalidgpgurl\"));\n        }\n        catch (InvalidChannelNameException ferengi) {\n            errors.add(ActionMessages.GLOBAL_MESSAGE,\n                    new ActionMessage(\"edit.channel.invalidchannelname\"));\n        }\n        catch (InvalidChannelLabelException q) {\n            errors.add(ActionMessages.GLOBAL_MESSAGE,\n                    new ActionMessage(\"edit.channel.invalidchannellabel\"));\n        }\n        catch (IllegalArgumentException iae) {\n            errors.add(ActionMessages.GLOBAL_MESSAGE,\n                    new ActionMessage(\"edit.channel.invalidchannelsummary\"));\n        }\n        \n        return updated;\n    }","commit_id":"fd47b8b638de8066e6ec76cff1a54c0034c1404a","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"private void setupForm(HttpServletRequest request, DynaActionForm form) {\n        RequestContext ctx = new RequestContext(request);\n        prepDropdowns(ctx);\n        Long cid = ctx.getParamAsLong(\"cid\");\n\n        if (cid != null) {\n            Channel c = ChannelManager.lookupByIdAndUser(cid,\n                                                         ctx.getLoggedInUser());\n\n            form.set(\"name\", c.getName());\n            form.set(\"summary\", c.getSummary());\n            form.set(\"description\", c.getDescription());\n            form.set(\"org_sharing\", c.getAccess());\n            form.set(\"gpg_key_url\", c.getGPGKeyUrl());\n            form.set(\"gpg_key_id\", c.getGPGKeyId());\n            form.set(\"gpg_key_fingerprint\", c.getGPGKeyFp());\n            form.set(\"maintainer_name\", c.getMaintainerName());\n            form.set(\"maintainer_phone\", c.getMaintainerPhone());\n            form.set(\"maintainer_email\", c.getMaintainerEmail());\n            form.set(\"support_policy\", c.getSupportPolicy());\n\n            if (c.getParentChannel() != null) {\n                request.setAttribute(\"parent_name\",\n                                     c.getParentChannel().getName());\n                request.setAttribute(\"parent_id\",\n                                     c.getParentChannel().getId());\n            }\n            else {\n                request.setAttribute(\"parent_name\",\n                    LocalizationService.getInstance()\n                                       .getMessage(\"generic.jsp.none\"));\n            }\n\n            request.setAttribute(\"channel_label\", c.getLabel());\n            request.setAttribute(\"channel_name\", c.getName());\n            request.setAttribute(\"channel_arch\", c.getChannelArch().getName());\n        }\n        else {\n            request.setAttribute(\"channel_name\", \"\");\n        }\n    }","id":65544,"modified_method":"private void setupForm(HttpServletRequest request, DynaActionForm form) {\n        RequestContext ctx = new RequestContext(request);\n        prepDropdowns(ctx);\n        Long cid = ctx.getParamAsLong(\"cid\");\n\n        if (cid != null) {\n            Channel c = ChannelManager.lookupByIdAndUser(cid,\n                                                         ctx.getLoggedInUser());\n\n            form.set(\"name\", c.getName());\n            form.set(\"summary\", c.getSummary());\n            form.set(\"description\", c.getDescription());\n            form.set(\"org_sharing\", c.getAccess());\n            form.set(\"gpg_key_url\", c.getGPGKeyUrl());\n            form.set(\"gpg_key_id\", c.getGPGKeyId());\n            form.set(\"gpg_key_fingerprint\", c.getGPGKeyFp());\n            form.set(\"maintainer_name\", c.getMaintainerName());\n            form.set(\"maintainer_phone\", c.getMaintainerPhone());\n            form.set(\"maintainer_email\", c.getMaintainerEmail());\n            form.set(\"support_policy\", c.getSupportPolicy());\n\n            if (c.getParentChannel() != null) {\n                request.setAttribute(\"parent_name\",\n                                     c.getParentChannel().getName());\n                request.setAttribute(\"parent_id\",\n                                     c.getParentChannel().getId());\n            }\n            else {\n                request.setAttribute(\"parent_name\",\n                    LocalizationService.getInstance()\n                                       .getMessage(\"generic.jsp.none\"));\n            }\n\n            request.setAttribute(\"channel_label\", c.getLabel());\n            request.setAttribute(\"channel_name\", c.getName());\n            request.setAttribute(\"channel_arch\", c.getChannelArch().getName());\n            request.setAttribute(\"channel_arch_label\", c.getChannelArch().getLabel());\n        }\n        else {\n            request.setAttribute(\"channel_name\", \"\");\n            form.set(\"org_sharing\", \"private\");\n        }\n    }","commit_id":"fd47b8b638de8066e6ec76cff1a54c0034c1404a","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Updates the Channel based on the parameters that were set.\n     * @param cid id of Channel to be updated.\n     * @return the updated Channel\n     * @throws InvalidChannelLabelException thrown if label is in use or invalid.\n     * @throws InvalidChannelNameException throw if name is in use or invalid.\n     * @throws IllegalArgumentException thrown if label, name or user are null.\n     * @throws InvalidParentChannelException thrown if parent label is not a\n     * valid base channel.\n     */\n    public Channel update(Long cid)\n        throws InvalidChannelLabelException, InvalidChannelNameException,\n        InvalidParentChannelException {\n\n        verifyRequiredParameters();\n        verifyChannelName(name);\n        verifyChannelLabel(label);\n        verifyGpgInformation();\n        \n        if (ChannelFactory.doesChannelNameExist(name)) {\n            throw new InvalidChannelNameException();\n        }\n        \n        if (ChannelFactory.doesChannelLabelExist(label)) {\n            throw new InvalidChannelLabelException();\n        }\n        \n        ChannelArch ca = ChannelFactory.findArchByLabel(archLabel);\n        if (ca == null) {\n            throw new IllegalArgumentException(\"Invalid architecture label\");\n        }\n        \n        Channel c = ChannelFactory.lookupById(cid);\n        c.setLabel(label);\n        c.setName(name);\n        c.setSummary(summary);\n        c.setDescription(description);\n        c.setOrg(user.getOrg());\n        c.setBaseDir(\"/dev/null\");\n        c.setChannelArch(ca);\n        c.setGPGKeyId(gpgKeyId);\n        c.setGPGKeyUrl(gpgKeyUrl);\n        c.setGPGKeyFp(gpgKeyFp);\n        c.setAccess(access);\n        c.setMaintainerName(maintainerName);\n        c.setMaintainerEmail(maintainerEmail);\n        c.setMaintainerPhone(maintainerPhone);\n        c.setSupportPolicy(supportPolicy);\n\n        // handles either parent id or label\n        setParentChannel(c, user, parentLabel, parentId);\n        \n        c.addChannelFamily(user.getOrg().getPrivateChannelFamily());\n        \n        // need to save before calling stored proc below\n        ChannelFactory.save(c);\n        \n        ChannelFactory.refreshNewestPackageCache(c, WEB_CHANNEL_CREATED);\n\n        return c;\n    }","id":65545,"modified_method":"/**\n     * Updates the Channel based on the parameters that were set.\n     * @param cid id of Channel to be updated.\n     * @return the updated Channel\n     * @throws InvalidChannelLabelException thrown if label is in use or invalid.\n     * @throws InvalidChannelNameException throw if name is in use or invalid.\n     * @throws IllegalArgumentException thrown if label, name or user are null.\n     * @throws InvalidParentChannelException thrown if parent label is not a\n     * valid base channel.\n     */\n    public Channel update(Long cid)\n        throws InvalidChannelLabelException, InvalidChannelNameException,\n        InvalidParentChannelException {\n\n        verifyRequiredParameters();\n        verifyChannelName(name);\n        verifyGpgInformation();\n        \n        // lookup the channel first.\n        Channel c = ChannelFactory.lookupById(cid);\n        \n        if (ChannelFactory.doesChannelNameExist(name) &&\n                !name.equals(c.getName())) {\n            throw new InvalidChannelNameException();\n        }\n        \n        if (ChannelFactory.findArchByLabel(archLabel) == null) {\n            throw new IllegalArgumentException(\"Invalid architecture label\");\n        }\n\n        c.setName(name);\n        c.setSummary(summary);\n        c.setDescription(description);\n        c.setOrg(user.getOrg());\n        c.setBaseDir(\"/dev/null\");\n        c.setGPGKeyId(gpgKeyId);\n        c.setGPGKeyUrl(gpgKeyUrl);\n        c.setGPGKeyFp(gpgKeyFp);\n        c.setAccess(access);\n        c.setMaintainerName(maintainerName);\n        c.setMaintainerEmail(maintainerEmail);\n        c.setMaintainerPhone(maintainerPhone);\n        c.setSupportPolicy(supportPolicy);\n\n        // need to save before calling stored proc below\n        ChannelFactory.save(c);\n        \n        ChannelFactory.refreshNewestPackageCache(c, WEB_CHANNEL_CREATED);\n\n        return c;\n    }","commit_id":"fd47b8b638de8066e6ec76cff1a54c0034c1404a","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"@Override\n        public void handleRequest(final RestRequest request, final RestChannel channel) {\n            NodesStatsRequest nodesStatsRequest = new NodesStatsRequest(Strings.splitStringByCommaToArray(request.param(\"nodeId\")));\n            CommonStatsFlags flags = this.flags;\n            if (flags.isSet(Flag.FieldData) && request.hasParam(\"fields\")) {\n                flags = flags.clone().fieldDataFields(request.paramAsStringArray(\"fields\", null));\n            }\n            nodesStatsRequest.clear().indices(flags);\n            executeNodeStats(request, channel, nodesStatsRequest);\n        }","id":65546,"modified_method":"@Override\n        public void handleRequest(final RestRequest request, final RestChannel channel) {\n            NodesStatsRequest nodesStatsRequest = new NodesStatsRequest(Strings.splitStringByCommaToArray(request.param(\"nodeId\")));\n            CommonStatsFlags flags = this.flags;\n            if (flags.isSet(Flag.FieldData) && (request.hasParam(\"fields\") || request.hasParam(\"fielddata_fields\"))) {\n                flags = flags.clone().fieldDataFields(request.paramAsStringArray(\"fielddata_fields\", request.paramAsStringArray(\"fields\", null)));\n            } else if (flags.isSet(Flag.Completion) && (request.hasParam(\"fields\") || request.hasParam(\"completion_fields\"))) {\n                flags = flags.clone().completionDataFields(request.paramAsStringArray(\"completion_fields\", request.paramAsStringArray(\"fields\", null)));\n            }\n            nodesStatsRequest.clear().indices(flags);\n            executeNodeStats(request, channel, nodesStatsRequest);\n        }","commit_id":"57f962d620b4011be545994dfef6690603e9683b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Inject\n    public RestNodesStatsAction(Settings settings, Client client, RestController controller) {\n        super(settings, client);\n        controller.registerHandler(RestRequest.Method.GET, \"/_cluster/nodes/stats\", this);\n        controller.registerHandler(RestRequest.Method.GET, \"/_cluster/nodes/{nodeId}/stats\", this);\n\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/stats\", this);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/stats\", this);\n\n        RestIndicesHandler indicesHandler = new RestIndicesHandler(new CommonStatsFlags().all());\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/stats/indices\", indicesHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/stats/indices\", indicesHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/indices/stats\", indicesHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/indices/stats\", indicesHandler);\n        for (Flag flag : CommonStatsFlags.Flag.values()) {\n            indicesHandler = new RestIndicesHandler(new CommonStatsFlags().clear().set(flag, true));\n            controller.registerHandler(RestRequest.Method.GET, \"/_nodes/stats/indices/\" + flag.getRestName(), indicesHandler);\n            controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/stats/indices/\" + flag.getRestName(), indicesHandler);\n            controller.registerHandler(RestRequest.Method.GET, \"/_nodes/indices/\" + flag.getRestName() + \"/stats\", indicesHandler);\n            controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/indices/\" + flag.getRestName() + \"/stats\", indicesHandler);\n            if (flag == Flag.FieldData) {\n                // add field specific endpoint\n                controller.registerHandler(RestRequest.Method.GET, \"/_nodes/stats/indices/\" + flag.getRestName() + \"/{fields}\", indicesHandler);\n                controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/stats/indices/\" + flag.getRestName() + \"/{fields}\", indicesHandler);\n                controller.registerHandler(RestRequest.Method.GET, \"/_nodes/indices/\" + flag.getRestName() + \"/{fields}/stats\", indicesHandler);\n                controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/indices/\" + flag.getRestName() + \"/{fields}/stats\", indicesHandler);\n            }\n        }\n\n        RestOsHandler osHandler = new RestOsHandler();\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/stats/os\", osHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/stats/os\", osHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/os/stats\", osHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/os/stats\", osHandler);\n\n        RestProcessHandler processHandler = new RestProcessHandler();\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/stats/process\", processHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/stats/process\", processHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/process/stats\", processHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/process/stats\", processHandler);\n\n        RestJvmHandler jvmHandler = new RestJvmHandler();\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/stats/jvm\", jvmHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/stats/jvm\", jvmHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/jvm/stats\", jvmHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/jvm/stats\", jvmHandler);\n\n        RestThreadPoolHandler threadPoolHandler = new RestThreadPoolHandler();\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/stats/thread_pool\", threadPoolHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/stats/thread_pool\", threadPoolHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/thread_pool/stats\", threadPoolHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/thread_pool/stats\", threadPoolHandler);\n\n        RestNetworkHandler networkHandler = new RestNetworkHandler();\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/stats/network\", networkHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/stats/network\", networkHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/network/stats\", networkHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/network/stats\", networkHandler);\n\n        RestFsHandler fsHandler = new RestFsHandler();\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/stats/fs\", fsHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/stats/fs\", fsHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/fs/stats\", fsHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/fs/stats\", fsHandler);\n\n        RestTransportHandler transportHandler = new RestTransportHandler();\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/stats/transport\", transportHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/stats/transport\", transportHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/transport/stats\", transportHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/transport/stats\", transportHandler);\n\n        RestHttpHandler httpHandler = new RestHttpHandler();\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/stats/http\", httpHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/stats/http\", httpHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/http/stats\", httpHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/http/stats\", httpHandler);\n    }","id":65547,"modified_method":"@Inject\n    public RestNodesStatsAction(Settings settings, Client client, RestController controller) {\n        super(settings, client);\n        controller.registerHandler(RestRequest.Method.GET, \"/_cluster/nodes/stats\", this);\n        controller.registerHandler(RestRequest.Method.GET, \"/_cluster/nodes/{nodeId}/stats\", this);\n\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/stats\", this);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/stats\", this);\n\n        RestIndicesHandler indicesHandler = new RestIndicesHandler(new CommonStatsFlags().all());\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/stats/indices\", indicesHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/stats/indices\", indicesHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/indices/stats\", indicesHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/indices/stats\", indicesHandler);\n        for (Flag flag : CommonStatsFlags.Flag.values()) {\n            indicesHandler = new RestIndicesHandler(new CommonStatsFlags().clear().set(flag, true));\n            controller.registerHandler(RestRequest.Method.GET, \"/_nodes/stats/indices/\" + flag.getRestName(), indicesHandler);\n            controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/stats/indices/\" + flag.getRestName(), indicesHandler);\n            controller.registerHandler(RestRequest.Method.GET, \"/_nodes/indices/\" + flag.getRestName() + \"/stats\", indicesHandler);\n            controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/indices/\" + flag.getRestName() + \"/stats\", indicesHandler);\n            if (flag == Flag.FieldData || flag == Flag.Completion) {\n                // add field specific endpoints\n                controller.registerHandler(RestRequest.Method.GET, \"/_nodes/stats/indices/\" + flag.getRestName() + \"/{fields}\", indicesHandler);\n                controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/stats/indices/\" + flag.getRestName() + \"/{fields}\", indicesHandler);\n                controller.registerHandler(RestRequest.Method.GET, \"/_nodes/indices/\" + flag.getRestName() + \"/{fields}/stats\", indicesHandler);\n                controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/indices/\" + flag.getRestName() + \"/{fields}/stats\", indicesHandler);\n            }\n        }\n\n        RestOsHandler osHandler = new RestOsHandler();\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/stats/os\", osHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/stats/os\", osHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/os/stats\", osHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/os/stats\", osHandler);\n\n        RestProcessHandler processHandler = new RestProcessHandler();\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/stats/process\", processHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/stats/process\", processHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/process/stats\", processHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/process/stats\", processHandler);\n\n        RestJvmHandler jvmHandler = new RestJvmHandler();\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/stats/jvm\", jvmHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/stats/jvm\", jvmHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/jvm/stats\", jvmHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/jvm/stats\", jvmHandler);\n\n        RestThreadPoolHandler threadPoolHandler = new RestThreadPoolHandler();\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/stats/thread_pool\", threadPoolHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/stats/thread_pool\", threadPoolHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/thread_pool/stats\", threadPoolHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/thread_pool/stats\", threadPoolHandler);\n\n        RestNetworkHandler networkHandler = new RestNetworkHandler();\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/stats/network\", networkHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/stats/network\", networkHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/network/stats\", networkHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/network/stats\", networkHandler);\n\n        RestFsHandler fsHandler = new RestFsHandler();\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/stats/fs\", fsHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/stats/fs\", fsHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/fs/stats\", fsHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/fs/stats\", fsHandler);\n\n        RestTransportHandler transportHandler = new RestTransportHandler();\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/stats/transport\", transportHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/stats/transport\", transportHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/transport/stats\", transportHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/transport/stats\", transportHandler);\n\n        RestHttpHandler httpHandler = new RestHttpHandler();\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/stats/http\", httpHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/stats/http\", httpHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/http/stats\", httpHandler);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/http/stats\", httpHandler);\n    }","commit_id":"57f962d620b4011be545994dfef6690603e9683b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void paintLineFragments(Graphics2D g, Rectangle clip, int visualLine, int y, LineFragmentPainter painter) {\n    float x = visualLine == 0 ? myView.getPrefixTextWidthInPixels() : 0;\n    int offset = myView.visualPositionToOffset(new VisualPosition(visualLine, 0));\n    int visualLineEndOffset = myView.visualPositionToOffset(new VisualPosition(visualLine, Integer.MAX_VALUE, true));\n    IterationState it = null;\n    int prevEndOffset = -1;\n    boolean firstFragment = true;\n    int maxColumn = 0;\n    for (VisualLineFragmentsIterator.Fragment fragment : VisualLineFragmentsIterator.create(myView, offset, false, null)) {\n      int fragmentStartOffset = fragment.getStartOffset();\n      int start = fragmentStartOffset;\n      int end = fragment.getEndOffset();\n      x = fragment.getStartX();\n      if (firstFragment) {\n        firstFragment = false;\n        SoftWrap softWrap = myEditor.getSoftWrapModel().getSoftWrap(offset);\n        if (softWrap != null) {\n          prevEndOffset = offset;\n          it = new IterationState(myEditor, offset == 0 ? 0 : offset - 1, visualLineEndOffset, true, false, false, false);\n          if (it.getEndOffset() <= offset) {\n            it.advance();\n          }\n          painter.paintBeforeLineStart(g, it.getStartOffset() == offset ? it.getBeforeLineStartBackgroundAttributes() :\n                                          it.getMergedAttributes(), fragment.getStartVisualColumn(), fragment.getStartX(), y);\n        }\n      }\n      FoldRegion foldRegion = fragment.getCurrentFoldRegion();\n      if (foldRegion == null) {\n        if (start != prevEndOffset) {\n          it = new IterationState(myEditor, start, fragment.isRtl() ? offset : visualLineEndOffset, true, false, false, fragment.isRtl());\n        }\n        prevEndOffset = end;\n        assert it != null;\n        while (fragment.isRtl() ? start > end : start < end) {\n          if (fragment.isRtl() ? it.getEndOffset() >= start : it.getEndOffset() <= start) {\n            assert !it.atEnd();\n            it.advance();\n          }\n          TextAttributes attributes = it.getMergedAttributes();\n          int curEnd = fragment.isRtl() ? Math.max(it.getEndOffset(), end) : Math.min(it.getEndOffset(), end);\n          float xNew = fragment.offsetToX(x, start, curEnd);\n          painter.paint(g, fragment, \n                        fragment.isRtl() ? fragmentStartOffset - start : start - fragmentStartOffset,\n                        fragment.isRtl() ? fragmentStartOffset - curEnd : curEnd - fragmentStartOffset, \n                        attributes, x, xNew, y);\n          x = xNew;\n          start = curEnd;\n        }\n      }\n      else {\n        float xNew = fragment.getEndX();\n        painter.paint(g, fragment, 0, fragment.getEndVisualColumn() - fragment.getStartVisualColumn(), getFoldRegionAttributes(foldRegion), \n                      x, xNew, y);\n        x = xNew;\n        prevEndOffset = -1;\n        it = null;\n      }\n      maxColumn = fragment.getEndVisualColumn();\n    }\n    if (it == null || it.getEndOffset() != visualLineEndOffset) {\n      it = new IterationState(myEditor, visualLineEndOffset == offset ? visualLineEndOffset : visualLineEndOffset - 1, visualLineEndOffset, \n                              true, false, false, false);\n    }\n    if (!it.atEnd()) {\n      it.advance();\n    }\n    assert it.atEnd();\n    painter.paintAfterLineEnd(g, clip, it, maxColumn, x, y);\n  }","id":65548,"modified_method":"private void paintLineFragments(Graphics2D g, Rectangle clip, int visualLine, int y, LineFragmentPainter painter) {\n    float x = visualLine == 0 ? myView.getPrefixTextWidthInPixels() : 0;\n    int offset = myView.visualPositionToOffset(new VisualPosition(visualLine, 0));\n    int visualLineEndOffset = myView.visualPositionToOffset(new VisualPosition(visualLine, Integer.MAX_VALUE, true));\n    IterationState it = null;\n    int prevEndOffset = -1;\n    boolean firstFragment = true;\n    int maxColumn = 0;\n    for (VisualLineFragmentsIterator.Fragment fragment : VisualLineFragmentsIterator.create(myView, offset, false, null)) {\n      int fragmentStartOffset = fragment.getStartOffset();\n      int start = fragmentStartOffset;\n      int end = fragment.getEndOffset();\n      x = fragment.getStartX();\n      if (firstFragment) {\n        firstFragment = false;\n        SoftWrap softWrap = myEditor.getSoftWrapModel().getSoftWrap(offset);\n        if (softWrap != null) {\n          prevEndOffset = offset;\n          it = new IterationState(myEditor, offset == 0 ? 0 : offset - 1, visualLineEndOffset, true, false, false, false);\n          if (it.getEndOffset() <= offset) {\n            it.advance();\n          }\n          if (x >= clip.getMinX()) {\n            painter.paintBeforeLineStart(g, it.getStartOffset() == offset ? it.getBeforeLineStartBackgroundAttributes() :\n                                            it.getMergedAttributes(), fragment.getStartVisualColumn(), x, y);\n          }\n        }\n      }\n      FoldRegion foldRegion = fragment.getCurrentFoldRegion();\n      if (foldRegion == null) {\n        if (start != prevEndOffset) {\n          it = new IterationState(myEditor, start, fragment.isRtl() ? offset : visualLineEndOffset, true, false, false, fragment.isRtl());\n        }\n        prevEndOffset = end;\n        assert it != null;\n        while (fragment.isRtl() ? start > end : start < end) {\n          if (fragment.isRtl() ? it.getEndOffset() >= start : it.getEndOffset() <= start) {\n            assert !it.atEnd();\n            it.advance();\n          }\n          TextAttributes attributes = it.getMergedAttributes();\n          int curEnd = fragment.isRtl() ? Math.max(it.getEndOffset(), end) : Math.min(it.getEndOffset(), end);\n          float xNew = fragment.offsetToX(x, start, curEnd);\n          if (xNew >= clip.getMinX()) {\n            painter.paint(g, fragment, \n                          fragment.isRtl() ? fragmentStartOffset - start : start - fragmentStartOffset,\n                          fragment.isRtl() ? fragmentStartOffset - curEnd : curEnd - fragmentStartOffset, \n                          attributes, x, xNew, y);\n          }\n          x = xNew;\n          start = curEnd;\n        }\n      }\n      else {\n        float xNew = fragment.getEndX();\n        if (xNew >= clip.getMinX()) {\n          painter.paint(g, fragment, 0, fragment.getEndVisualColumn() - fragment.getStartVisualColumn(), getFoldRegionAttributes(foldRegion), \n                        x, xNew, y);\n        }\n        x = xNew;\n        prevEndOffset = -1;\n        it = null;\n      }\n      if (x > clip.getMaxX()) return;\n      maxColumn = fragment.getEndVisualColumn();\n    }\n    if (it == null || it.getEndOffset() != visualLineEndOffset) {\n      it = new IterationState(myEditor, visualLineEndOffset == offset ? visualLineEndOffset : visualLineEndOffset - 1, visualLineEndOffset, \n                              true, false, false, false);\n    }\n    if (!it.atEnd()) {\n      it.advance();\n    }\n    assert it.atEnd();\n    painter.paintAfterLineEnd(g, clip, it, maxColumn, x, y);\n  }","commit_id":"c6ce85f0a40061cd5c4a6e1b91aa2ace91d9b644","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Inject\n   public HistoryPanel(BranchToolbarButton branchToolbarButton,\n                       Commands commands)\n   {\n      Styles styles = GWT.<Resources>create(Resources.class).styles();\n      commitTable_ = new CommitListTable(styles);\n      splitPanel_ = new SplitLayoutPanel(4);\n      pager_ = new SimplePager(\n            TextLocation.CENTER,\n            GWT.<SimplePagerResources>create(SimplePagerResources.class),\n            true, 500, true);\n      pager_.getElement().setAttribute(\"align\", \"center\");\n\n      initWidget(GWT.<Binder>create(Binder.class).createAndBindUi(this));\n\n      commitDetail_.setScrollPanel(detailScrollPanel_);\n\n      topToolbar_.addStyleName(styles.toolbar());\n\n      switchViewButton_ = new LeftRightToggleButton(\"Changes\", \"History\", false);\n      topToolbar_.addLeftWidget(switchViewButton_);\n      topToolbar_.addLeftWidget(branchToolbarButton);\n\n\n      filterText_ = new SearchWidget(new MultiWordSuggestOracle(),\n                                     new TextBoxWithCue(\"Search\"),\n                                     null);\n      topToolbar_.addRightWidget(filterText_);\n      topToolbar_.addRightSeparator();\n\n      refreshButton_ = new ToolbarButton(\n            \"Refresh\", commands.vcsRefresh().getImageResource(),\n            (ClickHandler) null);\n      topToolbar_.addRightWidget(refreshButton_);\n\n      topToolbar_.addRightSeparator();\n\n      topToolbar_.addRightWidget(new ToolbarButton(\n            \"Pull\", commands.vcsPull().getImageResource(),\n            commands.vcsPull()));\n\n      topToolbar_.addRightSeparator();\n\n      topToolbar_.addRightWidget(new ToolbarButton(\n            \"Push\", commands.vcsPush().getImageResource(),\n            commands.vcsPush()));\n\n      pager_.setPageSize(100);\n      pager_.setDisplay(commitTable_);\n\n   }","id":65549,"modified_method":"@Inject\n   public HistoryPanel(BranchToolbarButton branchToolbarButton,\n                       Commands commands)\n   {\n      Styles styles = GWT.<Resources>create(Resources.class).styles();\n      commitTable_ = new CommitListTable(styles);\n      splitPanel_ = new SplitLayoutPanel(4);\n      pager_ = new SimplePager(\n            TextLocation.CENTER,\n            GWT.<SimplePagerResources>create(SimplePagerResources.class),\n            true, 500, true);\n      pager_.getElement().setAttribute(\"align\", \"center\");\n\n      initWidget(GWT.<Binder>create(Binder.class).createAndBindUi(this));\n\n      commitDetail_.setScrollPanel(detailScrollPanel_);\n\n      topToolbar_.addStyleName(styles.toolbar());\n\n      switchViewButton_ = new LeftRightToggleButton(\"Changes\", \"History\", false);\n      topToolbar_.addLeftWidget(switchViewButton_);\n      topToolbar_.addLeftWidget(branchToolbarButton);\n\n\n      filterText_ = new SearchWidget(new MultiWordSuggestOracle(),\n                                     new TextBoxWithCue(\"Search\"),\n                                     null);\n      topToolbar_.addRightWidget(filterText_);\n      topToolbar_.addRightSeparator();\n\n      refreshButton_ = new ToolbarButton(\n            \"Refresh\", commands.vcsRefresh().getImageResource(),\n            (ClickHandler) null);\n      topToolbar_.addRightWidget(refreshButton_);\n\n      topToolbar_.addRightSeparator();\n\n      topToolbar_.addRightWidget(commands.vcsPull().createToolbarButton());\n     \n      topToolbar_.addRightSeparator();\n\n      topToolbar_.addRightWidget(commands.vcsPush().createToolbarButton());\n\n      pager_.setPageSize(100);\n      pager_.setDisplay(commitTable_);\n\n   }","commit_id":"a1b31c6be5dfc9119d712b44f8b8c70303b71995","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Inject\n   public ReviewPanel(GitChangelistTablePresenter changelist,\n                      LineTableView diffPane,\n                      final Commands commands,\n                      FileTypeRegistry fileTypeRegistry,\n                      BranchToolbarButton branchToolbarButton)\n   {\n      fileTypeRegistry_ = fileTypeRegistry;\n      splitPanel_ = new SplitLayoutPanel(4);\n      splitPanelCommit_ = new SplitLayoutPanel(4);\n\n      commitButton_ = new ThemedButton(\"Commit\");\n      commitButton_.addStyleName(RES.styles().commitButton());\n\n      changelist_ = changelist.getView();\n      lines_ = diffPane;\n      lines_.getElement().setTabIndex(-1);\n\n      overrideSizeWarning_ = new SizeWarningWidget(\"diff\");\n\n      changelist.setSelectFirstItemByDefault(true);\n\n      Widget widget = GWT.<Binder>create(Binder.class).createAndBindUi(this);\n      initWidget(widget);\n\n      topToolbar_.addStyleName(RES.styles().toolbar());\n\n      switchViewButton_ = new LeftRightToggleButton(\"Changes\", \"History\", true);\n      topToolbar_.addLeftWidget(switchViewButton_);\n\n      topToolbar_.addLeftWidget(branchToolbarButton);\n\n      stageFilesButton_ = topToolbar_.addLeftWidget(new ToolbarButton(\n            \"Stage\",\n            RES.stage(),\n            (ClickHandler) null));\n\n      topToolbar_.addLeftSeparator();\n\n      revertFilesButton_ = topToolbar_.addLeftWidget(new ToolbarButton(\n            \"Revert\",\n            commands.vcsRevert().getImageResource(),\n            (ClickHandler) null));\n\n/*\n      topToolbar_.addLeftSeparator();\n\n      ignoreButton_ = topToolbar_.addLeftWidget(new ToolbarButton(\n            \"Ignore\", RES.ignore(), (ClickHandler) null));\n*/\n\n      topToolbar_.addRightWidget(new ToolbarButton(\n            \"Refresh\", commands.vcsRefresh().getImageResource(),\n            new ClickHandler() {\n               @Override\n               public void onClick(ClickEvent event)\n               {\n                  changelist_.showProgress();\n                  commands.vcsRefresh().execute();\n               }\n            }));\n\n      topToolbar_.addRightSeparator();\n\n      topToolbar_.addRightWidget(new ToolbarButton(\n            \"Pull\", commands.vcsPull().getImageResource(),\n            commands.vcsPull()));\n\n      topToolbar_.addRightSeparator();\n\n      topToolbar_.addRightWidget(new ToolbarButton(\n            \"Push\", commands.vcsPush().getImageResource(),\n            commands.vcsPush()));\n\n      diffToolbar_.addStyleName(RES.styles().toolbar());\n      diffToolbar_.addStyleName(RES.styles().diffToolbar());\n\n      stageAllButton_ = diffToolbar_.addLeftWidget(new ToolbarButton(\n            \"Stage All\", RES.stage(), (ClickHandler) null));\n      diffToolbar_.addLeftSeparator();\n      discardAllButton_ = diffToolbar_.addLeftWidget(new ToolbarButton(\n            \"Discard All\", RES.discard(), (ClickHandler) null));\n\n      unstageAllButton_ = diffToolbar_.addLeftWidget(new ToolbarButton(\n            \"Unstage All\", RES.discard(), (ClickHandler) null));\n      unstageAllButton_.setVisible(false);\n\n      unstagedCheckBox_.addValueChangeHandler(new ValueChangeHandler<Boolean>()\n      {\n         @Override\n         public void onValueChange(ValueChangeEvent<Boolean> e)\n         {\n            ValueChangeEvent.fire(stagedCheckBox_, stagedCheckBox_.getValue());\n         }\n      });\n\n      stagedCheckBox_.addValueChangeHandler(new ValueChangeHandler<Boolean>()\n      {\n         @Override\n         public void onValueChange(ValueChangeEvent<Boolean> e)\n         {\n            stageAllButton_.setVisible(!e.getValue());\n            discardAllButton_.setVisible(!e.getValue());\n            unstageAllButton_.setVisible(e.getValue());\n            diffToolbar_.invalidateSeparators();\n         }\n      });\n\n      listBoxAdapter_ = new ListBoxAdapter(contextLines_);\n\n      FontSizer.applyNormalFontSize(commitMessage_);\n\n      new WidgetHandlerRegistration(this)\n      {\n         @Override\n         protected HandlerRegistration doRegister()\n         {\n            return Event.addNativePreviewHandler(new NativePreviewHandler()\n            {\n               @Override\n               public void onPreviewNativeEvent(NativePreviewEvent event)\n               {\n                  NativeEvent nativeEvent = event.getNativeEvent();\n                  if (event.getTypeInt() == Event.ONKEYDOWN\n                      && KeyboardShortcut.getModifierValue(nativeEvent) == KeyboardShortcut.CTRL)\n                  {\n                     switch (nativeEvent.getKeyCode())\n                     {\n                        case KeyCodes.KEY_DOWN:\n                           nativeEvent.preventDefault();\n                           scrollBy(diffScroll_, getLineScroll(diffScroll_), 0);\n                           break;\n                        case KeyCodes.KEY_UP:\n                           nativeEvent.preventDefault();\n                           scrollBy(diffScroll_, -getLineScroll(diffScroll_), 0);\n                           break;\n                        case KeyCodes.KEY_PAGEDOWN:\n                           nativeEvent.preventDefault();\n                           scrollBy(diffScroll_, getPageScroll(diffScroll_), 0);\n                           break;\n                        case KeyCodes.KEY_PAGEUP:\n                           nativeEvent.preventDefault();\n                           scrollBy(diffScroll_, -getPageScroll(diffScroll_), 0);\n                           break;\n                     }\n                  }\n               }\n            });\n         }\n      };\n   }","id":65550,"modified_method":"@Inject\n   public ReviewPanel(GitChangelistTablePresenter changelist,\n                      LineTableView diffPane,\n                      final Commands commands,\n                      FileTypeRegistry fileTypeRegistry,\n                      BranchToolbarButton branchToolbarButton)\n   {\n      fileTypeRegistry_ = fileTypeRegistry;\n      splitPanel_ = new SplitLayoutPanel(4);\n      splitPanelCommit_ = new SplitLayoutPanel(4);\n\n      commitButton_ = new ThemedButton(\"Commit\");\n      commitButton_.addStyleName(RES.styles().commitButton());\n\n      changelist_ = changelist.getView();\n      lines_ = diffPane;\n      lines_.getElement().setTabIndex(-1);\n\n      overrideSizeWarning_ = new SizeWarningWidget(\"diff\");\n\n      changelist.setSelectFirstItemByDefault(true);\n\n      Widget widget = GWT.<Binder>create(Binder.class).createAndBindUi(this);\n      initWidget(widget);\n\n      topToolbar_.addStyleName(RES.styles().toolbar());\n\n      switchViewButton_ = new LeftRightToggleButton(\"Changes\", \"History\", true);\n      topToolbar_.addLeftWidget(switchViewButton_);\n\n      topToolbar_.addLeftWidget(branchToolbarButton);\n\n      stageFilesButton_ = topToolbar_.addLeftWidget(new ToolbarButton(\n            \"Stage\",\n            RES.stage(),\n            (ClickHandler) null));\n\n      topToolbar_.addLeftSeparator();\n\n      revertFilesButton_ = topToolbar_.addLeftWidget(new ToolbarButton(\n            \"Revert\",\n            commands.vcsRevert().getImageResource(),\n            (ClickHandler) null));\n\n/*\n      topToolbar_.addLeftSeparator();\n\n      ignoreButton_ = topToolbar_.addLeftWidget(new ToolbarButton(\n            \"Ignore\", RES.ignore(), (ClickHandler) null));\n*/\n\n      topToolbar_.addRightWidget(new ToolbarButton(\n            \"Refresh\", commands.vcsRefresh().getImageResource(),\n            new ClickHandler() {\n               @Override\n               public void onClick(ClickEvent event)\n               {\n                  changelist_.showProgress();\n                  commands.vcsRefresh().execute();\n               }\n            }));\n\n      topToolbar_.addRightSeparator();\n\n      \n      topToolbar_.addRightWidget(commands.vcsPull().createToolbarButton());\n\n      topToolbar_.addRightSeparator();\n\n      topToolbar_.addRightWidget(commands.vcsPush().createToolbarButton());\n\n      diffToolbar_.addStyleName(RES.styles().toolbar());\n      diffToolbar_.addStyleName(RES.styles().diffToolbar());\n\n      stageAllButton_ = diffToolbar_.addLeftWidget(new ToolbarButton(\n            \"Stage All\", RES.stage(), (ClickHandler) null));\n      diffToolbar_.addLeftSeparator();\n      discardAllButton_ = diffToolbar_.addLeftWidget(new ToolbarButton(\n            \"Discard All\", RES.discard(), (ClickHandler) null));\n\n      unstageAllButton_ = diffToolbar_.addLeftWidget(new ToolbarButton(\n            \"Unstage All\", RES.discard(), (ClickHandler) null));\n      unstageAllButton_.setVisible(false);\n\n      unstagedCheckBox_.addValueChangeHandler(new ValueChangeHandler<Boolean>()\n      {\n         @Override\n         public void onValueChange(ValueChangeEvent<Boolean> e)\n         {\n            ValueChangeEvent.fire(stagedCheckBox_, stagedCheckBox_.getValue());\n         }\n      });\n\n      stagedCheckBox_.addValueChangeHandler(new ValueChangeHandler<Boolean>()\n      {\n         @Override\n         public void onValueChange(ValueChangeEvent<Boolean> e)\n         {\n            stageAllButton_.setVisible(!e.getValue());\n            discardAllButton_.setVisible(!e.getValue());\n            unstageAllButton_.setVisible(e.getValue());\n            diffToolbar_.invalidateSeparators();\n         }\n      });\n\n      listBoxAdapter_ = new ListBoxAdapter(contextLines_);\n\n      FontSizer.applyNormalFontSize(commitMessage_);\n\n      new WidgetHandlerRegistration(this)\n      {\n         @Override\n         protected HandlerRegistration doRegister()\n         {\n            return Event.addNativePreviewHandler(new NativePreviewHandler()\n            {\n               @Override\n               public void onPreviewNativeEvent(NativePreviewEvent event)\n               {\n                  NativeEvent nativeEvent = event.getNativeEvent();\n                  if (event.getTypeInt() == Event.ONKEYDOWN\n                      && KeyboardShortcut.getModifierValue(nativeEvent) == KeyboardShortcut.CTRL)\n                  {\n                     switch (nativeEvent.getKeyCode())\n                     {\n                        case KeyCodes.KEY_DOWN:\n                           nativeEvent.preventDefault();\n                           scrollBy(diffScroll_, getLineScroll(diffScroll_), 0);\n                           break;\n                        case KeyCodes.KEY_UP:\n                           nativeEvent.preventDefault();\n                           scrollBy(diffScroll_, -getLineScroll(diffScroll_), 0);\n                           break;\n                        case KeyCodes.KEY_PAGEDOWN:\n                           nativeEvent.preventDefault();\n                           scrollBy(diffScroll_, getPageScroll(diffScroll_), 0);\n                           break;\n                        case KeyCodes.KEY_PAGEUP:\n                           nativeEvent.preventDefault();\n                           scrollBy(diffScroll_, -getPageScroll(diffScroll_), 0);\n                           break;\n                     }\n                  }\n               }\n            });\n         }\n      };\n   }","commit_id":"a1b31c6be5dfc9119d712b44f8b8c70303b71995","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Deprecated // Creates wrong resolved calls, should be removed\n    @NotNull\n    public OverloadResolutionResults<FunctionDescriptor> resolveExactSignature(@NotNull JetScope scope, @NotNull ReceiverDescriptor receiver, @NotNull Name name, @NotNull List<JetType> parameterTypes) {\n        List<ResolutionCandidate<FunctionDescriptor>> candidates = findCandidatesByExactSignature(scope, receiver, name, parameterTypes);\n\n        BindingTraceContext trace = new BindingTraceContext();\n        TemporaryBindingTrace temporaryBindingTrace = TemporaryBindingTrace.create(trace, \"trace for resolve exact signature call\", name);\n        Set<ResolvedCallWithTrace<FunctionDescriptor>> calls = Sets.newLinkedHashSet();\n        for (ResolutionCandidate<FunctionDescriptor> candidate : candidates) {\n            ResolvedCallImpl<FunctionDescriptor> call = ResolvedCallImpl.create(candidate, temporaryBindingTrace);\n            calls.add(call);\n        }\n        return computeResultAndReportErrors(trace, TracingStrategy.EMPTY, calls, Collections.<ResolvedCallWithTrace<FunctionDescriptor>>emptySet());\n    }","id":65551,"modified_method":"@Deprecated // Creates wrong resolved calls, should be removed\n    @NotNull\n    public OverloadResolutionResults<FunctionDescriptor> resolveExactSignature(@NotNull JetScope scope, @NotNull ReceiverDescriptor receiver, @NotNull Name name, @NotNull List<JetType> parameterTypes) {\n        List<ResolutionCandidate<FunctionDescriptor>> candidates = findCandidatesByExactSignature(scope, receiver, name, parameterTypes);\n\n        BindingTraceContext trace = new BindingTraceContext();\n        TemporaryBindingTrace temporaryBindingTrace = TemporaryBindingTrace.create(trace, \"trace for resolve exact signature call\", name);\n        Set<ResolvedCallWithTrace<FunctionDescriptor>> calls = Sets.newLinkedHashSet();\n        for (ResolutionCandidate<FunctionDescriptor> candidate : candidates) {\n            ResolvedCallImpl<FunctionDescriptor> call = ResolvedCallImpl.create(candidate, temporaryBindingTrace);\n            calls.add(call);\n        }\n        return resolutionResultsHandler.computeResultAndReportErrors(trace, TracingStrategy.EMPTY, calls,\n                                                                     Collections.<ResolvedCallWithTrace<FunctionDescriptor>>emptySet());\n    }","commit_id":"fc705edb6502073ef87f33799b083925e3dd6a57","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private <D extends CallableDescriptor> OverloadResolutionResults<D> completeTypeInferenceDependentOnExpectedType(\n            @NotNull BasicResolutionContext context,\n            @NotNull OverloadResolutionResults<D> resultsWithIncompleteTypeInference,\n            @NotNull TracingStrategy tracing\n    ) {\n        if (resultsWithIncompleteTypeInference.getResultCode() != OverloadResolutionResults.Code.INCOMPLETE_TYPE_INFERENCE)\n            return resultsWithIncompleteTypeInference;\n        Set<ResolvedCallWithTrace<D>> successful = Sets.newLinkedHashSet();\n        Set<ResolvedCallWithTrace<D>> failed = Sets.newLinkedHashSet();\n        for (ResolvedCall<? extends D> call : resultsWithIncompleteTypeInference.getResultingCalls()) {\n            if (!(call instanceof ResolvedCallImpl)) continue;\n            ResolvedCallImpl<D> resolvedCall = CallResolverUtil.copy((ResolvedCallImpl<D>) call, context);\n            if (!resolvedCall.hasUnknownTypeParameters()) {\n                if (resolvedCall.getStatus().isSuccess()) {\n                    successful.add(resolvedCall);\n                }\n                else {\n                    failed.add(resolvedCall);\n                }\n                continue;\n            }\n            completeTypeInferenceDependentOnExpectedTypeForCall(CallResolutionContext.create(context, tracing, resolvedCall), successful, failed);\n        }\n        OverloadResolutionResultsImpl<D> results = computeResultAndReportErrors(context.trace, tracing, successful, failed);\n        if (!results.isSingleResult()) {\n            checkTypesWithNoCallee(context);\n        }\n        return results;\n    }","id":65552,"modified_method":"private <D extends CallableDescriptor> OverloadResolutionResults<D> completeTypeInferenceDependentOnExpectedType(\n            @NotNull BasicResolutionContext context,\n            @NotNull OverloadResolutionResults<D> resultsWithIncompleteTypeInference,\n            @NotNull TracingStrategy tracing\n    ) {\n        if (resultsWithIncompleteTypeInference.getResultCode() != OverloadResolutionResults.Code.INCOMPLETE_TYPE_INFERENCE)\n            return resultsWithIncompleteTypeInference;\n        Set<ResolvedCallWithTrace<D>> successful = Sets.newLinkedHashSet();\n        Set<ResolvedCallWithTrace<D>> failed = Sets.newLinkedHashSet();\n        for (ResolvedCall<? extends D> call : resultsWithIncompleteTypeInference.getResultingCalls()) {\n            if (!(call instanceof ResolvedCallImpl)) continue;\n            ResolvedCallImpl<D> resolvedCall = CallResolverUtil.copy((ResolvedCallImpl<D>) call, context);\n            if (!resolvedCall.hasUnknownTypeParameters()) {\n                if (resolvedCall.getStatus().isSuccess()) {\n                    successful.add(resolvedCall);\n                }\n                else {\n                    failed.add(resolvedCall);\n                }\n                continue;\n            }\n            completeTypeInferenceDependentOnExpectedTypeForCall(CallResolutionContext.create(context, tracing, resolvedCall), successful, failed);\n        }\n        OverloadResolutionResultsImpl<D> results = resolutionResultsHandler.computeResultAndReportErrors(context.trace, tracing, successful,\n                                                                                                         failed);\n        if (!results.isSingleResult()) {\n            checkTypesWithNoCallee(context);\n        }\n        return results;\n    }","commit_id":"fc705edb6502073ef87f33799b083925e3dd6a57","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private <D extends CallableDescriptor, F extends D> OverloadResolutionResultsImpl<F> performResolution(\n            @NotNull ResolutionTask<D, F> task,\n            @NotNull CallTransformer<D, F> callTransformer,\n            @NotNull BindingTrace traceForResolutionCache) {\n\n        for (ResolutionCandidate<D> resolutionCandidate : task.getCandidates()) {\n            TemporaryBindingTrace candidateTrace = TemporaryBindingTrace.create(\n                    task.trace, \"trace to resolve candidate\");\n            Collection<CallResolutionContext<D, F>> contexts = callTransformer.createCallContexts(resolutionCandidate, task, candidateTrace);\n            for (CallResolutionContext<D, F> context : contexts) {\n\n                performResolutionForCandidateCall(context, task);\n\n                /* important for 'variable as function case': temporary bind reference to descriptor (will be rewritten)\n                to have a binding to variable while 'invoke' call resolve */\n                task.tracing.bindReference(context.candidateCall.getTrace(), context.candidateCall);\n\n                Collection<ResolvedCallWithTrace<F>> calls = callTransformer.transformCall(context, this, task);\n\n                for (ResolvedCallWithTrace<F> call : calls) {\n                    task.tracing.bindReference(call.getTrace(), call);\n                    task.tracing.bindResolvedCall(call.getTrace(), call);\n                    task.getResolvedCalls().add(call);\n                }\n\n                context.candidateCall.getTrace().addAllMyDataTo(traceForResolutionCache, new TraceEntryFilter() {\n                    @Override\n                    public boolean accept(@NotNull WritableSlice<?, ?> slice, Object key) {\n                        return slice == BindingContext.RESOLUTION_RESULTS_FOR_FUNCTION || slice == BindingContext.RESOLUTION_RESULTS_FOR_PROPERTY ||\n                               slice == BindingContext.TRACE_DELTAS_CACHE;\n                    }\n                }, false);\n            }\n        }\n\n        Set<ResolvedCallWithTrace<F>> successfulCandidates = Sets.newLinkedHashSet();\n        Set<ResolvedCallWithTrace<F>> failedCandidates = Sets.newLinkedHashSet();\n        for (ResolvedCallWithTrace<F> candidateCall : task.getResolvedCalls()) {\n            ResolutionStatus status = candidateCall.getStatus();\n            if (status.isSuccess()) {\n                successfulCandidates.add(candidateCall);\n            }\n            else {\n                assert status != UNKNOWN_STATUS : \"No resolution for \" + candidateCall.getCandidateDescriptor();\n                if (candidateCall.getStatus() != STRONG_ERROR) {\n                    failedCandidates.add(candidateCall);\n                }\n            }\n        }\n        \n        OverloadResolutionResultsImpl<F> results = computeResultAndReportErrors(task.trace, task.tracing, successfulCandidates,\n                                                                                failedCandidates);\n        if (!results.isSingleResult() && !results.isIncomplete()) {\n            checkTypesWithNoCallee(task.toBasic());\n        }\n        return results;\n    }","id":65553,"modified_method":"@NotNull\n    private <D extends CallableDescriptor, F extends D> OverloadResolutionResultsImpl<F> performResolution(\n            @NotNull ResolutionTask<D, F> task,\n            @NotNull CallTransformer<D, F> callTransformer,\n            @NotNull BindingTrace traceForResolutionCache) {\n\n        for (ResolutionCandidate<D> resolutionCandidate : task.getCandidates()) {\n            TemporaryBindingTrace candidateTrace = TemporaryBindingTrace.create(\n                    task.trace, \"trace to resolve candidate\");\n            Collection<CallResolutionContext<D, F>> contexts = callTransformer.createCallContexts(resolutionCandidate, task, candidateTrace);\n            for (CallResolutionContext<D, F> context : contexts) {\n\n                performResolutionForCandidateCall(context, task);\n\n                /* important for 'variable as function case': temporary bind reference to descriptor (will be rewritten)\n                to have a binding to variable while 'invoke' call resolve */\n                task.tracing.bindReference(context.candidateCall.getTrace(), context.candidateCall);\n\n                Collection<ResolvedCallWithTrace<F>> calls = callTransformer.transformCall(context, this, task);\n\n                for (ResolvedCallWithTrace<F> call : calls) {\n                    task.tracing.bindReference(call.getTrace(), call);\n                    task.tracing.bindResolvedCall(call.getTrace(), call);\n                    task.getResolvedCalls().add(call);\n                }\n\n                context.candidateCall.getTrace().addAllMyDataTo(traceForResolutionCache, new TraceEntryFilter() {\n                    @Override\n                    public boolean accept(@NotNull WritableSlice<?, ?> slice, Object key) {\n                        return slice == BindingContext.RESOLUTION_RESULTS_FOR_FUNCTION || slice == BindingContext.RESOLUTION_RESULTS_FOR_PROPERTY ||\n                               slice == BindingContext.TRACE_DELTAS_CACHE;\n                    }\n                }, false);\n            }\n        }\n\n        Set<ResolvedCallWithTrace<F>> successfulCandidates = Sets.newLinkedHashSet();\n        Set<ResolvedCallWithTrace<F>> failedCandidates = Sets.newLinkedHashSet();\n        for (ResolvedCallWithTrace<F> candidateCall : task.getResolvedCalls()) {\n            ResolutionStatus status = candidateCall.getStatus();\n            if (status.isSuccess()) {\n                successfulCandidates.add(candidateCall);\n            }\n            else {\n                assert status != UNKNOWN_STATUS : \"No resolution for \" + candidateCall.getCandidateDescriptor();\n                if (candidateCall.getStatus() != STRONG_ERROR) {\n                    failedCandidates.add(candidateCall);\n                }\n            }\n        }\n        \n        OverloadResolutionResultsImpl<F> results = resolutionResultsHandler.computeResultAndReportErrors(task.trace, task.tracing,\n                                                                                                         successfulCandidates,\n                                                                                                         failedCandidates);\n        if (!results.isSingleResult() && !results.isIncomplete()) {\n            checkTypesWithNoCallee(task.toBasic());\n        }\n        return results;\n    }","commit_id":"fc705edb6502073ef87f33799b083925e3dd6a57","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public InjectorForBodyResolve(\n        @NotNull Project project,\n        @NotNull TopDownAnalysisParameters topDownAnalysisParameters,\n        @NotNull BindingTrace bindingTrace,\n        @NotNull BodiesResolveContext bodiesResolveContext,\n        @NotNull ModuleConfiguration moduleConfiguration\n    ) {\n        this.bodyResolver = new BodyResolver();\n        this.project = project;\n        this.topDownAnalysisParameters = topDownAnalysisParameters;\n        this.bindingTrace = bindingTrace;\n        this.bodiesResolveContext = bodiesResolveContext;\n        this.moduleConfiguration = moduleConfiguration;\n        this.callResolver = new CallResolver();\n        this.descriptorResolver = new DescriptorResolver();\n        this.annotationResolver = new AnnotationResolver();\n        this.expressionTypingServices = new ExpressionTypingServices();\n        this.typeResolver = new TypeResolver();\n        this.qualifiedExpressionResolver = new QualifiedExpressionResolver();\n        this.overloadingConflictResolver = new OverloadingConflictResolver();\n        this.controlFlowAnalyzer = new ControlFlowAnalyzer();\n        this.declarationsChecker = new DeclarationsChecker();\n        this.scriptBodyResolver = new ScriptBodyResolver();\n        this.topDownAnalysisContext = new TopDownAnalysisContext();\n\n        this.bodyResolver.setCallResolver(callResolver);\n        this.bodyResolver.setContext(bodiesResolveContext);\n        this.bodyResolver.setControlFlowAnalyzer(controlFlowAnalyzer);\n        this.bodyResolver.setDeclarationsChecker(declarationsChecker);\n        this.bodyResolver.setDescriptorResolver(descriptorResolver);\n        this.bodyResolver.setExpressionTypingServices(expressionTypingServices);\n        this.bodyResolver.setScriptBodyResolverResolver(scriptBodyResolver);\n        this.bodyResolver.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        this.bodyResolver.setTrace(bindingTrace);\n\n        callResolver.setDescriptorResolver(descriptorResolver);\n        callResolver.setExpressionTypingServices(expressionTypingServices);\n        callResolver.setOverloadingConflictResolver(overloadingConflictResolver);\n        callResolver.setTypeResolver(typeResolver);\n\n        descriptorResolver.setAnnotationResolver(annotationResolver);\n        descriptorResolver.setExpressionTypingServices(expressionTypingServices);\n        descriptorResolver.setTypeResolver(typeResolver);\n\n        annotationResolver.setCallResolver(callResolver);\n        annotationResolver.setExpressionTypingServices(expressionTypingServices);\n\n        expressionTypingServices.setCallResolver(callResolver);\n        expressionTypingServices.setDescriptorResolver(descriptorResolver);\n        expressionTypingServices.setProject(project);\n        expressionTypingServices.setTypeResolver(typeResolver);\n\n        typeResolver.setAnnotationResolver(annotationResolver);\n        typeResolver.setDescriptorResolver(descriptorResolver);\n        typeResolver.setModuleConfiguration(moduleConfiguration);\n        typeResolver.setQualifiedExpressionResolver(qualifiedExpressionResolver);\n\n        controlFlowAnalyzer.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        controlFlowAnalyzer.setTrace(bindingTrace);\n\n        declarationsChecker.setTrace(bindingTrace);\n\n        scriptBodyResolver.setContext(topDownAnalysisContext);\n        scriptBodyResolver.setExpressionTypingServices(expressionTypingServices);\n        scriptBodyResolver.setTrace(bindingTrace);\n\n        topDownAnalysisContext.setTopDownAnalysisParameters(topDownAnalysisParameters);\n\n    }","id":65554,"modified_method":"public InjectorForBodyResolve(\n        @NotNull Project project,\n        @NotNull TopDownAnalysisParameters topDownAnalysisParameters,\n        @NotNull BindingTrace bindingTrace,\n        @NotNull BodiesResolveContext bodiesResolveContext,\n        @NotNull ModuleConfiguration moduleConfiguration\n    ) {\n        this.bodyResolver = new BodyResolver();\n        this.project = project;\n        this.topDownAnalysisParameters = topDownAnalysisParameters;\n        this.bindingTrace = bindingTrace;\n        this.bodiesResolveContext = bodiesResolveContext;\n        this.moduleConfiguration = moduleConfiguration;\n        this.callResolver = new CallResolver();\n        this.descriptorResolver = new DescriptorResolver();\n        this.annotationResolver = new AnnotationResolver();\n        this.expressionTypingServices = new ExpressionTypingServices();\n        this.typeResolver = new TypeResolver();\n        this.qualifiedExpressionResolver = new QualifiedExpressionResolver();\n        this.resolutionResultsHandler = new ResolutionResultsHandler();\n        this.overloadingConflictResolver = new OverloadingConflictResolver();\n        this.controlFlowAnalyzer = new ControlFlowAnalyzer();\n        this.declarationsChecker = new DeclarationsChecker();\n        this.scriptBodyResolver = new ScriptBodyResolver();\n        this.topDownAnalysisContext = new TopDownAnalysisContext();\n\n        this.bodyResolver.setCallResolver(callResolver);\n        this.bodyResolver.setContext(bodiesResolveContext);\n        this.bodyResolver.setControlFlowAnalyzer(controlFlowAnalyzer);\n        this.bodyResolver.setDeclarationsChecker(declarationsChecker);\n        this.bodyResolver.setDescriptorResolver(descriptorResolver);\n        this.bodyResolver.setExpressionTypingServices(expressionTypingServices);\n        this.bodyResolver.setScriptBodyResolverResolver(scriptBodyResolver);\n        this.bodyResolver.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        this.bodyResolver.setTrace(bindingTrace);\n\n        callResolver.setDescriptorResolver(descriptorResolver);\n        callResolver.setExpressionTypingServices(expressionTypingServices);\n        callResolver.setResolutionResultsHandler(resolutionResultsHandler);\n        callResolver.setTypeResolver(typeResolver);\n\n        descriptorResolver.setAnnotationResolver(annotationResolver);\n        descriptorResolver.setExpressionTypingServices(expressionTypingServices);\n        descriptorResolver.setTypeResolver(typeResolver);\n\n        annotationResolver.setCallResolver(callResolver);\n        annotationResolver.setExpressionTypingServices(expressionTypingServices);\n\n        expressionTypingServices.setCallResolver(callResolver);\n        expressionTypingServices.setDescriptorResolver(descriptorResolver);\n        expressionTypingServices.setProject(project);\n        expressionTypingServices.setTypeResolver(typeResolver);\n\n        typeResolver.setAnnotationResolver(annotationResolver);\n        typeResolver.setDescriptorResolver(descriptorResolver);\n        typeResolver.setModuleConfiguration(moduleConfiguration);\n        typeResolver.setQualifiedExpressionResolver(qualifiedExpressionResolver);\n\n        resolutionResultsHandler.setOverloadingConflictResolver(overloadingConflictResolver);\n\n        controlFlowAnalyzer.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        controlFlowAnalyzer.setTrace(bindingTrace);\n\n        declarationsChecker.setTrace(bindingTrace);\n\n        scriptBodyResolver.setContext(topDownAnalysisContext);\n        scriptBodyResolver.setExpressionTypingServices(expressionTypingServices);\n        scriptBodyResolver.setTrace(bindingTrace);\n\n        topDownAnalysisContext.setTopDownAnalysisParameters(topDownAnalysisParameters);\n\n    }","commit_id":"fc705edb6502073ef87f33799b083925e3dd6a57","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public InjectorForLazyResolve(\n        @NotNull Project project,\n        @NotNull ResolveSession resolveSession,\n        @NotNull BindingTrace bindingTrace,\n        @NotNull ModuleConfiguration moduleConfiguration\n    ) {\n        this.project = project;\n        this.resolveSession = resolveSession;\n        this.bindingTrace = bindingTrace;\n        this.moduleConfiguration = moduleConfiguration;\n        this.descriptorResolver = new DescriptorResolver();\n        this.expressionTypingServices = new ExpressionTypingServices();\n        this.typeResolver = new TypeResolver();\n        this.scopeProvider = new ScopeProvider(resolveSession);\n        this.annotationResolver = new AnnotationResolver();\n        this.qualifiedExpressionResolver = new QualifiedExpressionResolver();\n        this.callResolver = new CallResolver();\n        this.overloadingConflictResolver = new OverloadingConflictResolver();\n\n        this.descriptorResolver.setAnnotationResolver(annotationResolver);\n        this.descriptorResolver.setExpressionTypingServices(expressionTypingServices);\n        this.descriptorResolver.setTypeResolver(typeResolver);\n\n        this.expressionTypingServices.setCallResolver(callResolver);\n        this.expressionTypingServices.setDescriptorResolver(descriptorResolver);\n        this.expressionTypingServices.setProject(project);\n        this.expressionTypingServices.setTypeResolver(typeResolver);\n\n        this.typeResolver.setAnnotationResolver(annotationResolver);\n        this.typeResolver.setDescriptorResolver(descriptorResolver);\n        this.typeResolver.setModuleConfiguration(moduleConfiguration);\n        this.typeResolver.setQualifiedExpressionResolver(qualifiedExpressionResolver);\n\n        this.annotationResolver.setCallResolver(callResolver);\n        this.annotationResolver.setExpressionTypingServices(expressionTypingServices);\n\n        callResolver.setDescriptorResolver(descriptorResolver);\n        callResolver.setExpressionTypingServices(expressionTypingServices);\n        callResolver.setOverloadingConflictResolver(overloadingConflictResolver);\n        callResolver.setTypeResolver(typeResolver);\n\n    }","id":65555,"modified_method":"public InjectorForLazyResolve(\n        @NotNull Project project,\n        @NotNull ResolveSession resolveSession,\n        @NotNull BindingTrace bindingTrace,\n        @NotNull ModuleConfiguration moduleConfiguration\n    ) {\n        this.project = project;\n        this.resolveSession = resolveSession;\n        this.bindingTrace = bindingTrace;\n        this.moduleConfiguration = moduleConfiguration;\n        this.descriptorResolver = new DescriptorResolver();\n        this.expressionTypingServices = new ExpressionTypingServices();\n        this.typeResolver = new TypeResolver();\n        this.scopeProvider = new ScopeProvider(resolveSession);\n        this.annotationResolver = new AnnotationResolver();\n        this.qualifiedExpressionResolver = new QualifiedExpressionResolver();\n        this.callResolver = new CallResolver();\n        this.resolutionResultsHandler = new ResolutionResultsHandler();\n        this.overloadingConflictResolver = new OverloadingConflictResolver();\n\n        this.descriptorResolver.setAnnotationResolver(annotationResolver);\n        this.descriptorResolver.setExpressionTypingServices(expressionTypingServices);\n        this.descriptorResolver.setTypeResolver(typeResolver);\n\n        this.expressionTypingServices.setCallResolver(callResolver);\n        this.expressionTypingServices.setDescriptorResolver(descriptorResolver);\n        this.expressionTypingServices.setProject(project);\n        this.expressionTypingServices.setTypeResolver(typeResolver);\n\n        this.typeResolver.setAnnotationResolver(annotationResolver);\n        this.typeResolver.setDescriptorResolver(descriptorResolver);\n        this.typeResolver.setModuleConfiguration(moduleConfiguration);\n        this.typeResolver.setQualifiedExpressionResolver(qualifiedExpressionResolver);\n\n        this.annotationResolver.setCallResolver(callResolver);\n        this.annotationResolver.setExpressionTypingServices(expressionTypingServices);\n\n        callResolver.setDescriptorResolver(descriptorResolver);\n        callResolver.setExpressionTypingServices(expressionTypingServices);\n        callResolver.setResolutionResultsHandler(resolutionResultsHandler);\n        callResolver.setTypeResolver(typeResolver);\n\n        resolutionResultsHandler.setOverloadingConflictResolver(overloadingConflictResolver);\n\n    }","commit_id":"fc705edb6502073ef87f33799b083925e3dd6a57","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public InjectorForMacros(\n        @NotNull Project project,\n        @NotNull ModuleConfiguration moduleConfiguration\n    ) {\n        this.expressionTypingServices = new ExpressionTypingServices();\n        this.project = project;\n        this.moduleConfiguration = moduleConfiguration;\n        this.callResolver = new CallResolver();\n        this.descriptorResolver = new DescriptorResolver();\n        this.annotationResolver = new AnnotationResolver();\n        this.typeResolver = new TypeResolver();\n        this.qualifiedExpressionResolver = new QualifiedExpressionResolver();\n        this.overloadingConflictResolver = new OverloadingConflictResolver();\n\n        this.expressionTypingServices.setCallResolver(callResolver);\n        this.expressionTypingServices.setDescriptorResolver(descriptorResolver);\n        this.expressionTypingServices.setProject(project);\n        this.expressionTypingServices.setTypeResolver(typeResolver);\n\n        callResolver.setDescriptorResolver(descriptorResolver);\n        callResolver.setExpressionTypingServices(expressionTypingServices);\n        callResolver.setOverloadingConflictResolver(overloadingConflictResolver);\n        callResolver.setTypeResolver(typeResolver);\n\n        descriptorResolver.setAnnotationResolver(annotationResolver);\n        descriptorResolver.setExpressionTypingServices(expressionTypingServices);\n        descriptorResolver.setTypeResolver(typeResolver);\n\n        annotationResolver.setCallResolver(callResolver);\n        annotationResolver.setExpressionTypingServices(expressionTypingServices);\n\n        typeResolver.setAnnotationResolver(annotationResolver);\n        typeResolver.setDescriptorResolver(descriptorResolver);\n        typeResolver.setModuleConfiguration(moduleConfiguration);\n        typeResolver.setQualifiedExpressionResolver(qualifiedExpressionResolver);\n\n    }","id":65556,"modified_method":"public InjectorForMacros(\n        @NotNull Project project,\n        @NotNull ModuleConfiguration moduleConfiguration\n    ) {\n        this.expressionTypingServices = new ExpressionTypingServices();\n        this.project = project;\n        this.moduleConfiguration = moduleConfiguration;\n        this.callResolver = new CallResolver();\n        this.descriptorResolver = new DescriptorResolver();\n        this.annotationResolver = new AnnotationResolver();\n        this.typeResolver = new TypeResolver();\n        this.qualifiedExpressionResolver = new QualifiedExpressionResolver();\n        this.resolutionResultsHandler = new ResolutionResultsHandler();\n        this.overloadingConflictResolver = new OverloadingConflictResolver();\n\n        this.expressionTypingServices.setCallResolver(callResolver);\n        this.expressionTypingServices.setDescriptorResolver(descriptorResolver);\n        this.expressionTypingServices.setProject(project);\n        this.expressionTypingServices.setTypeResolver(typeResolver);\n\n        callResolver.setDescriptorResolver(descriptorResolver);\n        callResolver.setExpressionTypingServices(expressionTypingServices);\n        callResolver.setResolutionResultsHandler(resolutionResultsHandler);\n        callResolver.setTypeResolver(typeResolver);\n\n        descriptorResolver.setAnnotationResolver(annotationResolver);\n        descriptorResolver.setExpressionTypingServices(expressionTypingServices);\n        descriptorResolver.setTypeResolver(typeResolver);\n\n        annotationResolver.setCallResolver(callResolver);\n        annotationResolver.setExpressionTypingServices(expressionTypingServices);\n\n        typeResolver.setAnnotationResolver(annotationResolver);\n        typeResolver.setDescriptorResolver(descriptorResolver);\n        typeResolver.setModuleConfiguration(moduleConfiguration);\n        typeResolver.setQualifiedExpressionResolver(qualifiedExpressionResolver);\n\n        resolutionResultsHandler.setOverloadingConflictResolver(overloadingConflictResolver);\n\n    }","commit_id":"fc705edb6502073ef87f33799b083925e3dd6a57","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public InjectorForTests(\n        @NotNull Project project\n    ) {\n        this.descriptorResolver = new DescriptorResolver();\n        this.expressionTypingServices = new ExpressionTypingServices();\n        this.typeResolver = new TypeResolver();\n        this.callResolver = new CallResolver();\n        this.kotlinBuiltIns = KotlinBuiltIns.getInstance();\n        this.moduleConfiguration = ModuleConfiguration.EMPTY;\n        this.project = project;\n        this.annotationResolver = new AnnotationResolver();\n        this.qualifiedExpressionResolver = new QualifiedExpressionResolver();\n        this.overloadingConflictResolver = new OverloadingConflictResolver();\n\n        this.descriptorResolver.setAnnotationResolver(annotationResolver);\n        this.descriptorResolver.setExpressionTypingServices(expressionTypingServices);\n        this.descriptorResolver.setTypeResolver(typeResolver);\n\n        this.expressionTypingServices.setCallResolver(callResolver);\n        this.expressionTypingServices.setDescriptorResolver(descriptorResolver);\n        this.expressionTypingServices.setProject(project);\n        this.expressionTypingServices.setTypeResolver(typeResolver);\n\n        this.typeResolver.setAnnotationResolver(annotationResolver);\n        this.typeResolver.setDescriptorResolver(descriptorResolver);\n        this.typeResolver.setModuleConfiguration(moduleConfiguration);\n        this.typeResolver.setQualifiedExpressionResolver(qualifiedExpressionResolver);\n\n        this.callResolver.setDescriptorResolver(descriptorResolver);\n        this.callResolver.setExpressionTypingServices(expressionTypingServices);\n        this.callResolver.setOverloadingConflictResolver(overloadingConflictResolver);\n        this.callResolver.setTypeResolver(typeResolver);\n\n        annotationResolver.setCallResolver(callResolver);\n        annotationResolver.setExpressionTypingServices(expressionTypingServices);\n\n    }","id":65557,"modified_method":"public InjectorForTests(\n        @NotNull Project project\n    ) {\n        this.descriptorResolver = new DescriptorResolver();\n        this.expressionTypingServices = new ExpressionTypingServices();\n        this.typeResolver = new TypeResolver();\n        this.callResolver = new CallResolver();\n        this.kotlinBuiltIns = KotlinBuiltIns.getInstance();\n        this.moduleConfiguration = ModuleConfiguration.EMPTY;\n        this.project = project;\n        this.annotationResolver = new AnnotationResolver();\n        this.qualifiedExpressionResolver = new QualifiedExpressionResolver();\n        this.resolutionResultsHandler = new ResolutionResultsHandler();\n        this.overloadingConflictResolver = new OverloadingConflictResolver();\n\n        this.descriptorResolver.setAnnotationResolver(annotationResolver);\n        this.descriptorResolver.setExpressionTypingServices(expressionTypingServices);\n        this.descriptorResolver.setTypeResolver(typeResolver);\n\n        this.expressionTypingServices.setCallResolver(callResolver);\n        this.expressionTypingServices.setDescriptorResolver(descriptorResolver);\n        this.expressionTypingServices.setProject(project);\n        this.expressionTypingServices.setTypeResolver(typeResolver);\n\n        this.typeResolver.setAnnotationResolver(annotationResolver);\n        this.typeResolver.setDescriptorResolver(descriptorResolver);\n        this.typeResolver.setModuleConfiguration(moduleConfiguration);\n        this.typeResolver.setQualifiedExpressionResolver(qualifiedExpressionResolver);\n\n        this.callResolver.setDescriptorResolver(descriptorResolver);\n        this.callResolver.setExpressionTypingServices(expressionTypingServices);\n        this.callResolver.setResolutionResultsHandler(resolutionResultsHandler);\n        this.callResolver.setTypeResolver(typeResolver);\n\n        annotationResolver.setCallResolver(callResolver);\n        annotationResolver.setExpressionTypingServices(expressionTypingServices);\n\n        resolutionResultsHandler.setOverloadingConflictResolver(overloadingConflictResolver);\n\n    }","commit_id":"fc705edb6502073ef87f33799b083925e3dd6a57","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public InjectorForTopDownAnalyzerBasic(\n        @NotNull Project project,\n        @NotNull TopDownAnalysisParameters topDownAnalysisParameters,\n        @NotNull BindingTrace bindingTrace,\n        @NotNull ModuleDescriptor moduleDescriptor,\n        @NotNull ModuleConfiguration moduleConfiguration\n    ) {\n        this.topDownAnalyzer = new TopDownAnalyzer();\n        this.topDownAnalysisContext = new TopDownAnalysisContext();\n        this.bodyResolver = new BodyResolver();\n        this.controlFlowAnalyzer = new ControlFlowAnalyzer();\n        this.declarationsChecker = new DeclarationsChecker();\n        this.descriptorResolver = new DescriptorResolver();\n        this.project = project;\n        this.topDownAnalysisParameters = topDownAnalysisParameters;\n        this.bindingTrace = bindingTrace;\n        this.moduleDescriptor = moduleDescriptor;\n        this.moduleConfiguration = moduleConfiguration;\n        this.dependencyClassByQualifiedNameResolverDummy = new DependencyClassByQualifiedNameResolverDummyImpl();\n        this.namespaceFactory = new NamespaceFactoryImpl();\n        this.declarationResolver = new DeclarationResolver();\n        this.annotationResolver = new AnnotationResolver();\n        this.callResolver = new CallResolver();\n        this.expressionTypingServices = new ExpressionTypingServices();\n        this.typeResolver = new TypeResolver();\n        this.qualifiedExpressionResolver = new QualifiedExpressionResolver();\n        this.overloadingConflictResolver = new OverloadingConflictResolver();\n        this.importsResolver = new ImportsResolver();\n        this.scriptHeaderResolver = new ScriptHeaderResolver();\n        this.overloadResolver = new OverloadResolver();\n        this.overrideResolver = new OverrideResolver();\n        this.typeHierarchyResolver = new TypeHierarchyResolver();\n        this.scriptBodyResolver = new ScriptBodyResolver();\n\n        this.topDownAnalyzer.setBodyResolver(bodyResolver);\n        this.topDownAnalyzer.setContext(topDownAnalysisContext);\n        this.topDownAnalyzer.setDeclarationResolver(declarationResolver);\n        this.topDownAnalyzer.setModuleDescriptor(moduleDescriptor);\n        this.topDownAnalyzer.setNamespaceFactory(namespaceFactory);\n        this.topDownAnalyzer.setOverloadResolver(overloadResolver);\n        this.topDownAnalyzer.setOverrideResolver(overrideResolver);\n        this.topDownAnalyzer.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        this.topDownAnalyzer.setTrace(bindingTrace);\n        this.topDownAnalyzer.setTypeHierarchyResolver(typeHierarchyResolver);\n\n        this.topDownAnalysisContext.setTopDownAnalysisParameters(topDownAnalysisParameters);\n\n        this.bodyResolver.setCallResolver(callResolver);\n        this.bodyResolver.setContext(topDownAnalysisContext);\n        this.bodyResolver.setControlFlowAnalyzer(controlFlowAnalyzer);\n        this.bodyResolver.setDeclarationsChecker(declarationsChecker);\n        this.bodyResolver.setDescriptorResolver(descriptorResolver);\n        this.bodyResolver.setExpressionTypingServices(expressionTypingServices);\n        this.bodyResolver.setScriptBodyResolverResolver(scriptBodyResolver);\n        this.bodyResolver.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        this.bodyResolver.setTrace(bindingTrace);\n\n        this.controlFlowAnalyzer.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        this.controlFlowAnalyzer.setTrace(bindingTrace);\n\n        this.declarationsChecker.setTrace(bindingTrace);\n\n        this.descriptorResolver.setAnnotationResolver(annotationResolver);\n        this.descriptorResolver.setExpressionTypingServices(expressionTypingServices);\n        this.descriptorResolver.setTypeResolver(typeResolver);\n\n        namespaceFactory.setConfiguration(moduleConfiguration);\n        namespaceFactory.setModuleDescriptor(moduleDescriptor);\n        namespaceFactory.setTrace(bindingTrace);\n\n        declarationResolver.setAnnotationResolver(annotationResolver);\n        declarationResolver.setContext(topDownAnalysisContext);\n        declarationResolver.setDescriptorResolver(descriptorResolver);\n        declarationResolver.setImportsResolver(importsResolver);\n        declarationResolver.setScriptHeaderResolver(scriptHeaderResolver);\n        declarationResolver.setTrace(bindingTrace);\n\n        annotationResolver.setCallResolver(callResolver);\n        annotationResolver.setExpressionTypingServices(expressionTypingServices);\n\n        callResolver.setDescriptorResolver(descriptorResolver);\n        callResolver.setExpressionTypingServices(expressionTypingServices);\n        callResolver.setOverloadingConflictResolver(overloadingConflictResolver);\n        callResolver.setTypeResolver(typeResolver);\n\n        expressionTypingServices.setCallResolver(callResolver);\n        expressionTypingServices.setDescriptorResolver(descriptorResolver);\n        expressionTypingServices.setProject(project);\n        expressionTypingServices.setTypeResolver(typeResolver);\n\n        typeResolver.setAnnotationResolver(annotationResolver);\n        typeResolver.setDescriptorResolver(descriptorResolver);\n        typeResolver.setModuleConfiguration(moduleConfiguration);\n        typeResolver.setQualifiedExpressionResolver(qualifiedExpressionResolver);\n\n        importsResolver.setConfiguration(moduleConfiguration);\n        importsResolver.setContext(topDownAnalysisContext);\n        importsResolver.setQualifiedExpressionResolver(qualifiedExpressionResolver);\n        importsResolver.setTrace(bindingTrace);\n\n        scriptHeaderResolver.setContext(topDownAnalysisContext);\n        scriptHeaderResolver.setDependencyClassByQualifiedNameResolver(dependencyClassByQualifiedNameResolverDummy);\n        scriptHeaderResolver.setNamespaceFactory(namespaceFactory);\n        scriptHeaderResolver.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        scriptHeaderResolver.setTrace(bindingTrace);\n\n        overloadResolver.setContext(topDownAnalysisContext);\n        overloadResolver.setTrace(bindingTrace);\n\n        overrideResolver.setContext(topDownAnalysisContext);\n        overrideResolver.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        overrideResolver.setTrace(bindingTrace);\n\n        typeHierarchyResolver.setContext(topDownAnalysisContext);\n        typeHierarchyResolver.setDescriptorResolver(descriptorResolver);\n        typeHierarchyResolver.setImportsResolver(importsResolver);\n        typeHierarchyResolver.setNamespaceFactory(namespaceFactory);\n        typeHierarchyResolver.setScriptHeaderResolver(scriptHeaderResolver);\n        typeHierarchyResolver.setTrace(bindingTrace);\n\n        scriptBodyResolver.setContext(topDownAnalysisContext);\n        scriptBodyResolver.setExpressionTypingServices(expressionTypingServices);\n        scriptBodyResolver.setTrace(bindingTrace);\n\n    }","id":65558,"modified_method":"public InjectorForTopDownAnalyzerBasic(\n        @NotNull Project project,\n        @NotNull TopDownAnalysisParameters topDownAnalysisParameters,\n        @NotNull BindingTrace bindingTrace,\n        @NotNull ModuleDescriptor moduleDescriptor,\n        @NotNull ModuleConfiguration moduleConfiguration\n    ) {\n        this.topDownAnalyzer = new TopDownAnalyzer();\n        this.topDownAnalysisContext = new TopDownAnalysisContext();\n        this.bodyResolver = new BodyResolver();\n        this.controlFlowAnalyzer = new ControlFlowAnalyzer();\n        this.declarationsChecker = new DeclarationsChecker();\n        this.descriptorResolver = new DescriptorResolver();\n        this.project = project;\n        this.topDownAnalysisParameters = topDownAnalysisParameters;\n        this.bindingTrace = bindingTrace;\n        this.moduleDescriptor = moduleDescriptor;\n        this.moduleConfiguration = moduleConfiguration;\n        this.dependencyClassByQualifiedNameResolverDummy = new DependencyClassByQualifiedNameResolverDummyImpl();\n        this.namespaceFactory = new NamespaceFactoryImpl();\n        this.declarationResolver = new DeclarationResolver();\n        this.annotationResolver = new AnnotationResolver();\n        this.callResolver = new CallResolver();\n        this.expressionTypingServices = new ExpressionTypingServices();\n        this.typeResolver = new TypeResolver();\n        this.qualifiedExpressionResolver = new QualifiedExpressionResolver();\n        this.resolutionResultsHandler = new ResolutionResultsHandler();\n        this.overloadingConflictResolver = new OverloadingConflictResolver();\n        this.importsResolver = new ImportsResolver();\n        this.scriptHeaderResolver = new ScriptHeaderResolver();\n        this.overloadResolver = new OverloadResolver();\n        this.overrideResolver = new OverrideResolver();\n        this.typeHierarchyResolver = new TypeHierarchyResolver();\n        this.scriptBodyResolver = new ScriptBodyResolver();\n\n        this.topDownAnalyzer.setBodyResolver(bodyResolver);\n        this.topDownAnalyzer.setContext(topDownAnalysisContext);\n        this.topDownAnalyzer.setDeclarationResolver(declarationResolver);\n        this.topDownAnalyzer.setModuleDescriptor(moduleDescriptor);\n        this.topDownAnalyzer.setNamespaceFactory(namespaceFactory);\n        this.topDownAnalyzer.setOverloadResolver(overloadResolver);\n        this.topDownAnalyzer.setOverrideResolver(overrideResolver);\n        this.topDownAnalyzer.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        this.topDownAnalyzer.setTrace(bindingTrace);\n        this.topDownAnalyzer.setTypeHierarchyResolver(typeHierarchyResolver);\n\n        this.topDownAnalysisContext.setTopDownAnalysisParameters(topDownAnalysisParameters);\n\n        this.bodyResolver.setCallResolver(callResolver);\n        this.bodyResolver.setContext(topDownAnalysisContext);\n        this.bodyResolver.setControlFlowAnalyzer(controlFlowAnalyzer);\n        this.bodyResolver.setDeclarationsChecker(declarationsChecker);\n        this.bodyResolver.setDescriptorResolver(descriptorResolver);\n        this.bodyResolver.setExpressionTypingServices(expressionTypingServices);\n        this.bodyResolver.setScriptBodyResolverResolver(scriptBodyResolver);\n        this.bodyResolver.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        this.bodyResolver.setTrace(bindingTrace);\n\n        this.controlFlowAnalyzer.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        this.controlFlowAnalyzer.setTrace(bindingTrace);\n\n        this.declarationsChecker.setTrace(bindingTrace);\n\n        this.descriptorResolver.setAnnotationResolver(annotationResolver);\n        this.descriptorResolver.setExpressionTypingServices(expressionTypingServices);\n        this.descriptorResolver.setTypeResolver(typeResolver);\n\n        namespaceFactory.setConfiguration(moduleConfiguration);\n        namespaceFactory.setModuleDescriptor(moduleDescriptor);\n        namespaceFactory.setTrace(bindingTrace);\n\n        declarationResolver.setAnnotationResolver(annotationResolver);\n        declarationResolver.setContext(topDownAnalysisContext);\n        declarationResolver.setDescriptorResolver(descriptorResolver);\n        declarationResolver.setImportsResolver(importsResolver);\n        declarationResolver.setScriptHeaderResolver(scriptHeaderResolver);\n        declarationResolver.setTrace(bindingTrace);\n\n        annotationResolver.setCallResolver(callResolver);\n        annotationResolver.setExpressionTypingServices(expressionTypingServices);\n\n        callResolver.setDescriptorResolver(descriptorResolver);\n        callResolver.setExpressionTypingServices(expressionTypingServices);\n        callResolver.setResolutionResultsHandler(resolutionResultsHandler);\n        callResolver.setTypeResolver(typeResolver);\n\n        expressionTypingServices.setCallResolver(callResolver);\n        expressionTypingServices.setDescriptorResolver(descriptorResolver);\n        expressionTypingServices.setProject(project);\n        expressionTypingServices.setTypeResolver(typeResolver);\n\n        typeResolver.setAnnotationResolver(annotationResolver);\n        typeResolver.setDescriptorResolver(descriptorResolver);\n        typeResolver.setModuleConfiguration(moduleConfiguration);\n        typeResolver.setQualifiedExpressionResolver(qualifiedExpressionResolver);\n\n        resolutionResultsHandler.setOverloadingConflictResolver(overloadingConflictResolver);\n\n        importsResolver.setConfiguration(moduleConfiguration);\n        importsResolver.setContext(topDownAnalysisContext);\n        importsResolver.setQualifiedExpressionResolver(qualifiedExpressionResolver);\n        importsResolver.setTrace(bindingTrace);\n\n        scriptHeaderResolver.setContext(topDownAnalysisContext);\n        scriptHeaderResolver.setDependencyClassByQualifiedNameResolver(dependencyClassByQualifiedNameResolverDummy);\n        scriptHeaderResolver.setNamespaceFactory(namespaceFactory);\n        scriptHeaderResolver.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        scriptHeaderResolver.setTrace(bindingTrace);\n\n        overloadResolver.setContext(topDownAnalysisContext);\n        overloadResolver.setTrace(bindingTrace);\n\n        overrideResolver.setContext(topDownAnalysisContext);\n        overrideResolver.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        overrideResolver.setTrace(bindingTrace);\n\n        typeHierarchyResolver.setContext(topDownAnalysisContext);\n        typeHierarchyResolver.setDescriptorResolver(descriptorResolver);\n        typeHierarchyResolver.setImportsResolver(importsResolver);\n        typeHierarchyResolver.setNamespaceFactory(namespaceFactory);\n        typeHierarchyResolver.setScriptHeaderResolver(scriptHeaderResolver);\n        typeHierarchyResolver.setTrace(bindingTrace);\n\n        scriptBodyResolver.setContext(topDownAnalysisContext);\n        scriptBodyResolver.setExpressionTypingServices(expressionTypingServices);\n        scriptBodyResolver.setTrace(bindingTrace);\n\n    }","commit_id":"fc705edb6502073ef87f33799b083925e3dd6a57","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public InjectorForTopDownAnalyzerForJs(\n        @NotNull Project project,\n        @NotNull TopDownAnalysisParameters topDownAnalysisParameters,\n        @NotNull BindingTrace bindingTrace,\n        @NotNull ModuleDescriptor moduleDescriptor,\n        @NotNull ModuleConfiguration moduleConfiguration\n    ) {\n        this.topDownAnalyzer = new TopDownAnalyzer();\n        this.topDownAnalysisContext = new TopDownAnalysisContext();\n        this.bodyResolver = new BodyResolver();\n        this.controlFlowAnalyzer = new ControlFlowAnalyzer();\n        this.declarationsChecker = new DeclarationsChecker();\n        this.descriptorResolver = new DescriptorResolver();\n        this.project = project;\n        this.topDownAnalysisParameters = topDownAnalysisParameters;\n        this.bindingTrace = bindingTrace;\n        this.moduleDescriptor = moduleDescriptor;\n        this.moduleConfiguration = moduleConfiguration;\n        this.dependencyClassByQualifiedNameResolverDummy = new DependencyClassByQualifiedNameResolverDummyImpl();\n        this.namespaceFactory = new NamespaceFactoryImpl();\n        this.declarationResolver = new DeclarationResolver();\n        this.annotationResolver = new AnnotationResolver();\n        this.callResolver = new CallResolver();\n        this.expressionTypingServices = new ExpressionTypingServices();\n        this.typeResolver = new TypeResolver();\n        this.qualifiedExpressionResolver = new QualifiedExpressionResolver();\n        this.overloadingConflictResolver = new OverloadingConflictResolver();\n        this.importsResolver = new ImportsResolver();\n        this.scriptHeaderResolver = new ScriptHeaderResolver();\n        this.overloadResolver = new OverloadResolver();\n        this.overrideResolver = new OverrideResolver();\n        this.typeHierarchyResolver = new TypeHierarchyResolver();\n        this.scriptBodyResolver = new ScriptBodyResolver();\n\n        this.topDownAnalyzer.setBodyResolver(bodyResolver);\n        this.topDownAnalyzer.setContext(topDownAnalysisContext);\n        this.topDownAnalyzer.setDeclarationResolver(declarationResolver);\n        this.topDownAnalyzer.setModuleDescriptor(moduleDescriptor);\n        this.topDownAnalyzer.setNamespaceFactory(namespaceFactory);\n        this.topDownAnalyzer.setOverloadResolver(overloadResolver);\n        this.topDownAnalyzer.setOverrideResolver(overrideResolver);\n        this.topDownAnalyzer.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        this.topDownAnalyzer.setTrace(bindingTrace);\n        this.topDownAnalyzer.setTypeHierarchyResolver(typeHierarchyResolver);\n\n        this.topDownAnalysisContext.setTopDownAnalysisParameters(topDownAnalysisParameters);\n\n        this.bodyResolver.setCallResolver(callResolver);\n        this.bodyResolver.setContext(topDownAnalysisContext);\n        this.bodyResolver.setControlFlowAnalyzer(controlFlowAnalyzer);\n        this.bodyResolver.setDeclarationsChecker(declarationsChecker);\n        this.bodyResolver.setDescriptorResolver(descriptorResolver);\n        this.bodyResolver.setExpressionTypingServices(expressionTypingServices);\n        this.bodyResolver.setScriptBodyResolverResolver(scriptBodyResolver);\n        this.bodyResolver.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        this.bodyResolver.setTrace(bindingTrace);\n\n        this.controlFlowAnalyzer.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        this.controlFlowAnalyzer.setTrace(bindingTrace);\n\n        this.declarationsChecker.setTrace(bindingTrace);\n\n        this.descriptorResolver.setAnnotationResolver(annotationResolver);\n        this.descriptorResolver.setExpressionTypingServices(expressionTypingServices);\n        this.descriptorResolver.setTypeResolver(typeResolver);\n\n        namespaceFactory.setConfiguration(moduleConfiguration);\n        namespaceFactory.setModuleDescriptor(moduleDescriptor);\n        namespaceFactory.setTrace(bindingTrace);\n\n        declarationResolver.setAnnotationResolver(annotationResolver);\n        declarationResolver.setContext(topDownAnalysisContext);\n        declarationResolver.setDescriptorResolver(descriptorResolver);\n        declarationResolver.setImportsResolver(importsResolver);\n        declarationResolver.setScriptHeaderResolver(scriptHeaderResolver);\n        declarationResolver.setTrace(bindingTrace);\n\n        annotationResolver.setCallResolver(callResolver);\n        annotationResolver.setExpressionTypingServices(expressionTypingServices);\n\n        callResolver.setDescriptorResolver(descriptorResolver);\n        callResolver.setExpressionTypingServices(expressionTypingServices);\n        callResolver.setOverloadingConflictResolver(overloadingConflictResolver);\n        callResolver.setTypeResolver(typeResolver);\n\n        expressionTypingServices.setCallResolver(callResolver);\n        expressionTypingServices.setDescriptorResolver(descriptorResolver);\n        expressionTypingServices.setProject(project);\n        expressionTypingServices.setTypeResolver(typeResolver);\n\n        typeResolver.setAnnotationResolver(annotationResolver);\n        typeResolver.setDescriptorResolver(descriptorResolver);\n        typeResolver.setModuleConfiguration(moduleConfiguration);\n        typeResolver.setQualifiedExpressionResolver(qualifiedExpressionResolver);\n\n        importsResolver.setConfiguration(moduleConfiguration);\n        importsResolver.setContext(topDownAnalysisContext);\n        importsResolver.setQualifiedExpressionResolver(qualifiedExpressionResolver);\n        importsResolver.setTrace(bindingTrace);\n\n        scriptHeaderResolver.setContext(topDownAnalysisContext);\n        scriptHeaderResolver.setDependencyClassByQualifiedNameResolver(dependencyClassByQualifiedNameResolverDummy);\n        scriptHeaderResolver.setNamespaceFactory(namespaceFactory);\n        scriptHeaderResolver.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        scriptHeaderResolver.setTrace(bindingTrace);\n\n        overloadResolver.setContext(topDownAnalysisContext);\n        overloadResolver.setTrace(bindingTrace);\n\n        overrideResolver.setContext(topDownAnalysisContext);\n        overrideResolver.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        overrideResolver.setTrace(bindingTrace);\n\n        typeHierarchyResolver.setContext(topDownAnalysisContext);\n        typeHierarchyResolver.setDescriptorResolver(descriptorResolver);\n        typeHierarchyResolver.setImportsResolver(importsResolver);\n        typeHierarchyResolver.setNamespaceFactory(namespaceFactory);\n        typeHierarchyResolver.setScriptHeaderResolver(scriptHeaderResolver);\n        typeHierarchyResolver.setTrace(bindingTrace);\n\n        scriptBodyResolver.setContext(topDownAnalysisContext);\n        scriptBodyResolver.setExpressionTypingServices(expressionTypingServices);\n        scriptBodyResolver.setTrace(bindingTrace);\n\n    }","id":65559,"modified_method":"public InjectorForTopDownAnalyzerForJs(\n        @NotNull Project project,\n        @NotNull TopDownAnalysisParameters topDownAnalysisParameters,\n        @NotNull BindingTrace bindingTrace,\n        @NotNull ModuleDescriptor moduleDescriptor,\n        @NotNull ModuleConfiguration moduleConfiguration\n    ) {\n        this.topDownAnalyzer = new TopDownAnalyzer();\n        this.topDownAnalysisContext = new TopDownAnalysisContext();\n        this.bodyResolver = new BodyResolver();\n        this.controlFlowAnalyzer = new ControlFlowAnalyzer();\n        this.declarationsChecker = new DeclarationsChecker();\n        this.descriptorResolver = new DescriptorResolver();\n        this.project = project;\n        this.topDownAnalysisParameters = topDownAnalysisParameters;\n        this.bindingTrace = bindingTrace;\n        this.moduleDescriptor = moduleDescriptor;\n        this.moduleConfiguration = moduleConfiguration;\n        this.dependencyClassByQualifiedNameResolverDummy = new DependencyClassByQualifiedNameResolverDummyImpl();\n        this.namespaceFactory = new NamespaceFactoryImpl();\n        this.declarationResolver = new DeclarationResolver();\n        this.annotationResolver = new AnnotationResolver();\n        this.callResolver = new CallResolver();\n        this.expressionTypingServices = new ExpressionTypingServices();\n        this.typeResolver = new TypeResolver();\n        this.qualifiedExpressionResolver = new QualifiedExpressionResolver();\n        this.resolutionResultsHandler = new ResolutionResultsHandler();\n        this.overloadingConflictResolver = new OverloadingConflictResolver();\n        this.importsResolver = new ImportsResolver();\n        this.scriptHeaderResolver = new ScriptHeaderResolver();\n        this.overloadResolver = new OverloadResolver();\n        this.overrideResolver = new OverrideResolver();\n        this.typeHierarchyResolver = new TypeHierarchyResolver();\n        this.scriptBodyResolver = new ScriptBodyResolver();\n\n        this.topDownAnalyzer.setBodyResolver(bodyResolver);\n        this.topDownAnalyzer.setContext(topDownAnalysisContext);\n        this.topDownAnalyzer.setDeclarationResolver(declarationResolver);\n        this.topDownAnalyzer.setModuleDescriptor(moduleDescriptor);\n        this.topDownAnalyzer.setNamespaceFactory(namespaceFactory);\n        this.topDownAnalyzer.setOverloadResolver(overloadResolver);\n        this.topDownAnalyzer.setOverrideResolver(overrideResolver);\n        this.topDownAnalyzer.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        this.topDownAnalyzer.setTrace(bindingTrace);\n        this.topDownAnalyzer.setTypeHierarchyResolver(typeHierarchyResolver);\n\n        this.topDownAnalysisContext.setTopDownAnalysisParameters(topDownAnalysisParameters);\n\n        this.bodyResolver.setCallResolver(callResolver);\n        this.bodyResolver.setContext(topDownAnalysisContext);\n        this.bodyResolver.setControlFlowAnalyzer(controlFlowAnalyzer);\n        this.bodyResolver.setDeclarationsChecker(declarationsChecker);\n        this.bodyResolver.setDescriptorResolver(descriptorResolver);\n        this.bodyResolver.setExpressionTypingServices(expressionTypingServices);\n        this.bodyResolver.setScriptBodyResolverResolver(scriptBodyResolver);\n        this.bodyResolver.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        this.bodyResolver.setTrace(bindingTrace);\n\n        this.controlFlowAnalyzer.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        this.controlFlowAnalyzer.setTrace(bindingTrace);\n\n        this.declarationsChecker.setTrace(bindingTrace);\n\n        this.descriptorResolver.setAnnotationResolver(annotationResolver);\n        this.descriptorResolver.setExpressionTypingServices(expressionTypingServices);\n        this.descriptorResolver.setTypeResolver(typeResolver);\n\n        namespaceFactory.setConfiguration(moduleConfiguration);\n        namespaceFactory.setModuleDescriptor(moduleDescriptor);\n        namespaceFactory.setTrace(bindingTrace);\n\n        declarationResolver.setAnnotationResolver(annotationResolver);\n        declarationResolver.setContext(topDownAnalysisContext);\n        declarationResolver.setDescriptorResolver(descriptorResolver);\n        declarationResolver.setImportsResolver(importsResolver);\n        declarationResolver.setScriptHeaderResolver(scriptHeaderResolver);\n        declarationResolver.setTrace(bindingTrace);\n\n        annotationResolver.setCallResolver(callResolver);\n        annotationResolver.setExpressionTypingServices(expressionTypingServices);\n\n        callResolver.setDescriptorResolver(descriptorResolver);\n        callResolver.setExpressionTypingServices(expressionTypingServices);\n        callResolver.setResolutionResultsHandler(resolutionResultsHandler);\n        callResolver.setTypeResolver(typeResolver);\n\n        expressionTypingServices.setCallResolver(callResolver);\n        expressionTypingServices.setDescriptorResolver(descriptorResolver);\n        expressionTypingServices.setProject(project);\n        expressionTypingServices.setTypeResolver(typeResolver);\n\n        typeResolver.setAnnotationResolver(annotationResolver);\n        typeResolver.setDescriptorResolver(descriptorResolver);\n        typeResolver.setModuleConfiguration(moduleConfiguration);\n        typeResolver.setQualifiedExpressionResolver(qualifiedExpressionResolver);\n\n        resolutionResultsHandler.setOverloadingConflictResolver(overloadingConflictResolver);\n\n        importsResolver.setConfiguration(moduleConfiguration);\n        importsResolver.setContext(topDownAnalysisContext);\n        importsResolver.setQualifiedExpressionResolver(qualifiedExpressionResolver);\n        importsResolver.setTrace(bindingTrace);\n\n        scriptHeaderResolver.setContext(topDownAnalysisContext);\n        scriptHeaderResolver.setDependencyClassByQualifiedNameResolver(dependencyClassByQualifiedNameResolverDummy);\n        scriptHeaderResolver.setNamespaceFactory(namespaceFactory);\n        scriptHeaderResolver.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        scriptHeaderResolver.setTrace(bindingTrace);\n\n        overloadResolver.setContext(topDownAnalysisContext);\n        overloadResolver.setTrace(bindingTrace);\n\n        overrideResolver.setContext(topDownAnalysisContext);\n        overrideResolver.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        overrideResolver.setTrace(bindingTrace);\n\n        typeHierarchyResolver.setContext(topDownAnalysisContext);\n        typeHierarchyResolver.setDescriptorResolver(descriptorResolver);\n        typeHierarchyResolver.setImportsResolver(importsResolver);\n        typeHierarchyResolver.setNamespaceFactory(namespaceFactory);\n        typeHierarchyResolver.setScriptHeaderResolver(scriptHeaderResolver);\n        typeHierarchyResolver.setTrace(bindingTrace);\n\n        scriptBodyResolver.setContext(topDownAnalysisContext);\n        scriptBodyResolver.setExpressionTypingServices(expressionTypingServices);\n        scriptBodyResolver.setTrace(bindingTrace);\n\n    }","commit_id":"fc705edb6502073ef87f33799b083925e3dd6a57","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public InjectorForTopDownAnalyzerForJvm(\n        @NotNull Project project,\n        @NotNull TopDownAnalysisParameters topDownAnalysisParameters,\n        @NotNull BindingTrace bindingTrace,\n        @NotNull ModuleDescriptor moduleDescriptor\n    ) {\n        this.topDownAnalyzer = new TopDownAnalyzer();\n        this.topDownAnalysisContext = new TopDownAnalysisContext();\n        this.bodyResolver = new BodyResolver();\n        this.controlFlowAnalyzer = new ControlFlowAnalyzer();\n        this.declarationsChecker = new DeclarationsChecker();\n        this.descriptorResolver = new DescriptorResolver();\n        this.project = project;\n        this.topDownAnalysisParameters = topDownAnalysisParameters;\n        this.bindingTrace = bindingTrace;\n        this.moduleDescriptor = moduleDescriptor;\n        this.moduleConfiguration = new JavaBridgeConfiguration();\n        this.javaDescriptorResolver = new JavaDescriptorResolver();\n        this.psiClassFinder = new PsiClassFinderImpl();\n        this.namespaceFactory = new NamespaceFactoryImpl();\n        this.declarationResolver = new DeclarationResolver();\n        this.annotationResolver = new AnnotationResolver();\n        this.callResolver = new CallResolver();\n        this.expressionTypingServices = new ExpressionTypingServices();\n        this.typeResolver = new TypeResolver();\n        this.qualifiedExpressionResolver = new QualifiedExpressionResolver();\n        this.overloadingConflictResolver = new OverloadingConflictResolver();\n        this.importsResolver = new ImportsResolver();\n        this.scriptHeaderResolver = new ScriptHeaderResolver();\n        this.overloadResolver = new OverloadResolver();\n        this.overrideResolver = new OverrideResolver();\n        this.typeHierarchyResolver = new TypeHierarchyResolver();\n        this.scriptBodyResolver = new ScriptBodyResolver();\n        this.javaSemanticServices = new JavaSemanticServices();\n        this.javaTypeTransformer = new JavaTypeTransformer();\n        this.javaClassResolver = new JavaClassResolver();\n        this.javaAnnotationResolver = new JavaAnnotationResolver();\n        this.javaCompileTimeConstResolver = new JavaCompileTimeConstResolver();\n        this.javaClassObjectResolver = new JavaClassObjectResolver();\n        this.javaSupertypesResolver = new JavaSupertypesResolver();\n        this.javaNamespaceResolver = new JavaNamespaceResolver();\n        this.javaSignatureResolver = new JavaSignatureResolver();\n        this.javaConstructorResolver = new JavaConstructorResolver();\n        this.javaValueParameterResolver = new JavaValueParameterResolver();\n        this.javaFunctionResolver = new JavaFunctionResolver();\n        this.javaInnerClassResolver = new JavaInnerClassResolver();\n        this.javaPropertiesResolver = new JavaPropertiesResolver();\n\n        this.topDownAnalyzer.setBodyResolver(bodyResolver);\n        this.topDownAnalyzer.setContext(topDownAnalysisContext);\n        this.topDownAnalyzer.setDeclarationResolver(declarationResolver);\n        this.topDownAnalyzer.setModuleDescriptor(moduleDescriptor);\n        this.topDownAnalyzer.setNamespaceFactory(namespaceFactory);\n        this.topDownAnalyzer.setOverloadResolver(overloadResolver);\n        this.topDownAnalyzer.setOverrideResolver(overrideResolver);\n        this.topDownAnalyzer.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        this.topDownAnalyzer.setTrace(bindingTrace);\n        this.topDownAnalyzer.setTypeHierarchyResolver(typeHierarchyResolver);\n\n        this.topDownAnalysisContext.setTopDownAnalysisParameters(topDownAnalysisParameters);\n\n        this.bodyResolver.setCallResolver(callResolver);\n        this.bodyResolver.setContext(topDownAnalysisContext);\n        this.bodyResolver.setControlFlowAnalyzer(controlFlowAnalyzer);\n        this.bodyResolver.setDeclarationsChecker(declarationsChecker);\n        this.bodyResolver.setDescriptorResolver(descriptorResolver);\n        this.bodyResolver.setExpressionTypingServices(expressionTypingServices);\n        this.bodyResolver.setScriptBodyResolverResolver(scriptBodyResolver);\n        this.bodyResolver.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        this.bodyResolver.setTrace(bindingTrace);\n\n        this.controlFlowAnalyzer.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        this.controlFlowAnalyzer.setTrace(bindingTrace);\n\n        this.declarationsChecker.setTrace(bindingTrace);\n\n        this.descriptorResolver.setAnnotationResolver(annotationResolver);\n        this.descriptorResolver.setExpressionTypingServices(expressionTypingServices);\n        this.descriptorResolver.setTypeResolver(typeResolver);\n\n        this.moduleConfiguration.setJavaSemanticServices(javaSemanticServices);\n        this.moduleConfiguration.setProject(project);\n\n        javaDescriptorResolver.setClassResolver(javaClassResolver);\n        javaDescriptorResolver.setConstructorResolver(javaConstructorResolver);\n        javaDescriptorResolver.setFunctionResolver(javaFunctionResolver);\n        javaDescriptorResolver.setInnerClassResolver(javaInnerClassResolver);\n        javaDescriptorResolver.setNamespaceResolver(javaNamespaceResolver);\n        javaDescriptorResolver.setPropertiesResolver(javaPropertiesResolver);\n\n        psiClassFinder.setProject(project);\n\n        this.namespaceFactory.setConfiguration(moduleConfiguration);\n        this.namespaceFactory.setModuleDescriptor(moduleDescriptor);\n        this.namespaceFactory.setTrace(bindingTrace);\n\n        declarationResolver.setAnnotationResolver(annotationResolver);\n        declarationResolver.setContext(topDownAnalysisContext);\n        declarationResolver.setDescriptorResolver(descriptorResolver);\n        declarationResolver.setImportsResolver(importsResolver);\n        declarationResolver.setScriptHeaderResolver(scriptHeaderResolver);\n        declarationResolver.setTrace(bindingTrace);\n\n        annotationResolver.setCallResolver(callResolver);\n        annotationResolver.setExpressionTypingServices(expressionTypingServices);\n\n        callResolver.setDescriptorResolver(descriptorResolver);\n        callResolver.setExpressionTypingServices(expressionTypingServices);\n        callResolver.setOverloadingConflictResolver(overloadingConflictResolver);\n        callResolver.setTypeResolver(typeResolver);\n\n        expressionTypingServices.setCallResolver(callResolver);\n        expressionTypingServices.setDescriptorResolver(descriptorResolver);\n        expressionTypingServices.setProject(project);\n        expressionTypingServices.setTypeResolver(typeResolver);\n\n        typeResolver.setAnnotationResolver(annotationResolver);\n        typeResolver.setDescriptorResolver(descriptorResolver);\n        typeResolver.setModuleConfiguration(moduleConfiguration);\n        typeResolver.setQualifiedExpressionResolver(qualifiedExpressionResolver);\n\n        importsResolver.setConfiguration(moduleConfiguration);\n        importsResolver.setContext(topDownAnalysisContext);\n        importsResolver.setQualifiedExpressionResolver(qualifiedExpressionResolver);\n        importsResolver.setTrace(bindingTrace);\n\n        scriptHeaderResolver.setContext(topDownAnalysisContext);\n        scriptHeaderResolver.setDependencyClassByQualifiedNameResolver(javaDescriptorResolver);\n        scriptHeaderResolver.setNamespaceFactory(namespaceFactory);\n        scriptHeaderResolver.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        scriptHeaderResolver.setTrace(bindingTrace);\n\n        overloadResolver.setContext(topDownAnalysisContext);\n        overloadResolver.setTrace(bindingTrace);\n\n        overrideResolver.setContext(topDownAnalysisContext);\n        overrideResolver.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        overrideResolver.setTrace(bindingTrace);\n\n        typeHierarchyResolver.setContext(topDownAnalysisContext);\n        typeHierarchyResolver.setDescriptorResolver(descriptorResolver);\n        typeHierarchyResolver.setImportsResolver(importsResolver);\n        typeHierarchyResolver.setNamespaceFactory(namespaceFactory);\n        typeHierarchyResolver.setScriptHeaderResolver(scriptHeaderResolver);\n        typeHierarchyResolver.setTrace(bindingTrace);\n\n        scriptBodyResolver.setContext(topDownAnalysisContext);\n        scriptBodyResolver.setExpressionTypingServices(expressionTypingServices);\n        scriptBodyResolver.setTrace(bindingTrace);\n\n        javaSemanticServices.setDescriptorResolver(javaDescriptorResolver);\n        javaSemanticServices.setPsiClassFinder(psiClassFinder);\n        javaSemanticServices.setTrace(bindingTrace);\n        javaSemanticServices.setTypeTransformer(javaTypeTransformer);\n\n        javaTypeTransformer.setJavaSemanticServices(javaSemanticServices);\n        javaTypeTransformer.setResolver(javaDescriptorResolver);\n\n        javaClassResolver.setAnnotationResolver(javaAnnotationResolver);\n        javaClassResolver.setClassObjectResolver(javaClassObjectResolver);\n        javaClassResolver.setJavaDescriptorResolver(javaDescriptorResolver);\n        javaClassResolver.setNamespaceResolver(javaNamespaceResolver);\n        javaClassResolver.setPsiClassFinder(psiClassFinder);\n        javaClassResolver.setSemanticServices(javaSemanticServices);\n        javaClassResolver.setSignatureResolver(javaSignatureResolver);\n        javaClassResolver.setSupertypesResolver(javaSupertypesResolver);\n        javaClassResolver.setTrace(bindingTrace);\n\n        javaAnnotationResolver.setClassResolver(javaClassResolver);\n        javaAnnotationResolver.setCompileTimeConstResolver(javaCompileTimeConstResolver);\n\n        javaCompileTimeConstResolver.setAnnotationResolver(javaAnnotationResolver);\n        javaCompileTimeConstResolver.setClassResolver(javaClassResolver);\n\n        javaClassObjectResolver.setJavaDescriptorResolver(javaDescriptorResolver);\n        javaClassObjectResolver.setSemanticServices(javaSemanticServices);\n        javaClassObjectResolver.setSupertypesResolver(javaSupertypesResolver);\n        javaClassObjectResolver.setTrace(bindingTrace);\n\n        javaSupertypesResolver.setClassResolver(javaClassResolver);\n        javaSupertypesResolver.setSemanticServices(javaSemanticServices);\n        javaSupertypesResolver.setTrace(bindingTrace);\n        javaSupertypesResolver.setTypeTransformer(javaTypeTransformer);\n\n        javaNamespaceResolver.setJavaSemanticServices(javaSemanticServices);\n        javaNamespaceResolver.setPsiClassFinder(psiClassFinder);\n        javaNamespaceResolver.setTrace(bindingTrace);\n\n        javaSignatureResolver.setJavaSemanticServices(javaSemanticServices);\n\n        javaConstructorResolver.setTrace(bindingTrace);\n        javaConstructorResolver.setTypeTransformer(javaTypeTransformer);\n        javaConstructorResolver.setValueParameterResolver(javaValueParameterResolver);\n\n        javaValueParameterResolver.setTypeTransformer(javaTypeTransformer);\n\n        javaFunctionResolver.setAnnotationResolver(javaAnnotationResolver);\n        javaFunctionResolver.setParameterResolver(javaValueParameterResolver);\n        javaFunctionResolver.setSignatureResolver(javaSignatureResolver);\n        javaFunctionResolver.setTrace(bindingTrace);\n        javaFunctionResolver.setTypeTransformer(javaTypeTransformer);\n\n        javaInnerClassResolver.setClassResolver(javaClassResolver);\n\n        javaPropertiesResolver.setAnnotationResolver(javaAnnotationResolver);\n        javaPropertiesResolver.setClassResolver(javaClassResolver);\n        javaPropertiesResolver.setJavaSignatureResolver(javaSignatureResolver);\n        javaPropertiesResolver.setSemanticServices(javaSemanticServices);\n        javaPropertiesResolver.setTrace(bindingTrace);\n\n        moduleConfiguration.init();\n\n        psiClassFinder.initialize();\n\n    }","id":65560,"modified_method":"public InjectorForTopDownAnalyzerForJvm(\n        @NotNull Project project,\n        @NotNull TopDownAnalysisParameters topDownAnalysisParameters,\n        @NotNull BindingTrace bindingTrace,\n        @NotNull ModuleDescriptor moduleDescriptor\n    ) {\n        this.topDownAnalyzer = new TopDownAnalyzer();\n        this.topDownAnalysisContext = new TopDownAnalysisContext();\n        this.bodyResolver = new BodyResolver();\n        this.controlFlowAnalyzer = new ControlFlowAnalyzer();\n        this.declarationsChecker = new DeclarationsChecker();\n        this.descriptorResolver = new DescriptorResolver();\n        this.project = project;\n        this.topDownAnalysisParameters = topDownAnalysisParameters;\n        this.bindingTrace = bindingTrace;\n        this.moduleDescriptor = moduleDescriptor;\n        this.moduleConfiguration = new JavaBridgeConfiguration();\n        this.javaDescriptorResolver = new JavaDescriptorResolver();\n        this.psiClassFinder = new PsiClassFinderImpl();\n        this.namespaceFactory = new NamespaceFactoryImpl();\n        this.declarationResolver = new DeclarationResolver();\n        this.annotationResolver = new AnnotationResolver();\n        this.callResolver = new CallResolver();\n        this.expressionTypingServices = new ExpressionTypingServices();\n        this.typeResolver = new TypeResolver();\n        this.qualifiedExpressionResolver = new QualifiedExpressionResolver();\n        this.resolutionResultsHandler = new ResolutionResultsHandler();\n        this.overloadingConflictResolver = new OverloadingConflictResolver();\n        this.importsResolver = new ImportsResolver();\n        this.scriptHeaderResolver = new ScriptHeaderResolver();\n        this.overloadResolver = new OverloadResolver();\n        this.overrideResolver = new OverrideResolver();\n        this.typeHierarchyResolver = new TypeHierarchyResolver();\n        this.scriptBodyResolver = new ScriptBodyResolver();\n        this.javaSemanticServices = new JavaSemanticServices();\n        this.javaTypeTransformer = new JavaTypeTransformer();\n        this.javaClassResolver = new JavaClassResolver();\n        this.javaAnnotationResolver = new JavaAnnotationResolver();\n        this.javaCompileTimeConstResolver = new JavaCompileTimeConstResolver();\n        this.javaClassObjectResolver = new JavaClassObjectResolver();\n        this.javaSupertypesResolver = new JavaSupertypesResolver();\n        this.javaNamespaceResolver = new JavaNamespaceResolver();\n        this.javaSignatureResolver = new JavaSignatureResolver();\n        this.javaConstructorResolver = new JavaConstructorResolver();\n        this.javaValueParameterResolver = new JavaValueParameterResolver();\n        this.javaFunctionResolver = new JavaFunctionResolver();\n        this.javaInnerClassResolver = new JavaInnerClassResolver();\n        this.javaPropertiesResolver = new JavaPropertiesResolver();\n\n        this.topDownAnalyzer.setBodyResolver(bodyResolver);\n        this.topDownAnalyzer.setContext(topDownAnalysisContext);\n        this.topDownAnalyzer.setDeclarationResolver(declarationResolver);\n        this.topDownAnalyzer.setModuleDescriptor(moduleDescriptor);\n        this.topDownAnalyzer.setNamespaceFactory(namespaceFactory);\n        this.topDownAnalyzer.setOverloadResolver(overloadResolver);\n        this.topDownAnalyzer.setOverrideResolver(overrideResolver);\n        this.topDownAnalyzer.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        this.topDownAnalyzer.setTrace(bindingTrace);\n        this.topDownAnalyzer.setTypeHierarchyResolver(typeHierarchyResolver);\n\n        this.topDownAnalysisContext.setTopDownAnalysisParameters(topDownAnalysisParameters);\n\n        this.bodyResolver.setCallResolver(callResolver);\n        this.bodyResolver.setContext(topDownAnalysisContext);\n        this.bodyResolver.setControlFlowAnalyzer(controlFlowAnalyzer);\n        this.bodyResolver.setDeclarationsChecker(declarationsChecker);\n        this.bodyResolver.setDescriptorResolver(descriptorResolver);\n        this.bodyResolver.setExpressionTypingServices(expressionTypingServices);\n        this.bodyResolver.setScriptBodyResolverResolver(scriptBodyResolver);\n        this.bodyResolver.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        this.bodyResolver.setTrace(bindingTrace);\n\n        this.controlFlowAnalyzer.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        this.controlFlowAnalyzer.setTrace(bindingTrace);\n\n        this.declarationsChecker.setTrace(bindingTrace);\n\n        this.descriptorResolver.setAnnotationResolver(annotationResolver);\n        this.descriptorResolver.setExpressionTypingServices(expressionTypingServices);\n        this.descriptorResolver.setTypeResolver(typeResolver);\n\n        this.moduleConfiguration.setJavaSemanticServices(javaSemanticServices);\n        this.moduleConfiguration.setProject(project);\n\n        javaDescriptorResolver.setClassResolver(javaClassResolver);\n        javaDescriptorResolver.setConstructorResolver(javaConstructorResolver);\n        javaDescriptorResolver.setFunctionResolver(javaFunctionResolver);\n        javaDescriptorResolver.setInnerClassResolver(javaInnerClassResolver);\n        javaDescriptorResolver.setNamespaceResolver(javaNamespaceResolver);\n        javaDescriptorResolver.setPropertiesResolver(javaPropertiesResolver);\n\n        psiClassFinder.setProject(project);\n\n        this.namespaceFactory.setConfiguration(moduleConfiguration);\n        this.namespaceFactory.setModuleDescriptor(moduleDescriptor);\n        this.namespaceFactory.setTrace(bindingTrace);\n\n        declarationResolver.setAnnotationResolver(annotationResolver);\n        declarationResolver.setContext(topDownAnalysisContext);\n        declarationResolver.setDescriptorResolver(descriptorResolver);\n        declarationResolver.setImportsResolver(importsResolver);\n        declarationResolver.setScriptHeaderResolver(scriptHeaderResolver);\n        declarationResolver.setTrace(bindingTrace);\n\n        annotationResolver.setCallResolver(callResolver);\n        annotationResolver.setExpressionTypingServices(expressionTypingServices);\n\n        callResolver.setDescriptorResolver(descriptorResolver);\n        callResolver.setExpressionTypingServices(expressionTypingServices);\n        callResolver.setResolutionResultsHandler(resolutionResultsHandler);\n        callResolver.setTypeResolver(typeResolver);\n\n        expressionTypingServices.setCallResolver(callResolver);\n        expressionTypingServices.setDescriptorResolver(descriptorResolver);\n        expressionTypingServices.setProject(project);\n        expressionTypingServices.setTypeResolver(typeResolver);\n\n        typeResolver.setAnnotationResolver(annotationResolver);\n        typeResolver.setDescriptorResolver(descriptorResolver);\n        typeResolver.setModuleConfiguration(moduleConfiguration);\n        typeResolver.setQualifiedExpressionResolver(qualifiedExpressionResolver);\n\n        resolutionResultsHandler.setOverloadingConflictResolver(overloadingConflictResolver);\n\n        importsResolver.setConfiguration(moduleConfiguration);\n        importsResolver.setContext(topDownAnalysisContext);\n        importsResolver.setQualifiedExpressionResolver(qualifiedExpressionResolver);\n        importsResolver.setTrace(bindingTrace);\n\n        scriptHeaderResolver.setContext(topDownAnalysisContext);\n        scriptHeaderResolver.setDependencyClassByQualifiedNameResolver(javaDescriptorResolver);\n        scriptHeaderResolver.setNamespaceFactory(namespaceFactory);\n        scriptHeaderResolver.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        scriptHeaderResolver.setTrace(bindingTrace);\n\n        overloadResolver.setContext(topDownAnalysisContext);\n        overloadResolver.setTrace(bindingTrace);\n\n        overrideResolver.setContext(topDownAnalysisContext);\n        overrideResolver.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        overrideResolver.setTrace(bindingTrace);\n\n        typeHierarchyResolver.setContext(topDownAnalysisContext);\n        typeHierarchyResolver.setDescriptorResolver(descriptorResolver);\n        typeHierarchyResolver.setImportsResolver(importsResolver);\n        typeHierarchyResolver.setNamespaceFactory(namespaceFactory);\n        typeHierarchyResolver.setScriptHeaderResolver(scriptHeaderResolver);\n        typeHierarchyResolver.setTrace(bindingTrace);\n\n        scriptBodyResolver.setContext(topDownAnalysisContext);\n        scriptBodyResolver.setExpressionTypingServices(expressionTypingServices);\n        scriptBodyResolver.setTrace(bindingTrace);\n\n        javaSemanticServices.setDescriptorResolver(javaDescriptorResolver);\n        javaSemanticServices.setPsiClassFinder(psiClassFinder);\n        javaSemanticServices.setTrace(bindingTrace);\n        javaSemanticServices.setTypeTransformer(javaTypeTransformer);\n\n        javaTypeTransformer.setJavaSemanticServices(javaSemanticServices);\n        javaTypeTransformer.setResolver(javaDescriptorResolver);\n\n        javaClassResolver.setAnnotationResolver(javaAnnotationResolver);\n        javaClassResolver.setClassObjectResolver(javaClassObjectResolver);\n        javaClassResolver.setJavaDescriptorResolver(javaDescriptorResolver);\n        javaClassResolver.setNamespaceResolver(javaNamespaceResolver);\n        javaClassResolver.setPsiClassFinder(psiClassFinder);\n        javaClassResolver.setSemanticServices(javaSemanticServices);\n        javaClassResolver.setSignatureResolver(javaSignatureResolver);\n        javaClassResolver.setSupertypesResolver(javaSupertypesResolver);\n        javaClassResolver.setTrace(bindingTrace);\n\n        javaAnnotationResolver.setClassResolver(javaClassResolver);\n        javaAnnotationResolver.setCompileTimeConstResolver(javaCompileTimeConstResolver);\n\n        javaCompileTimeConstResolver.setAnnotationResolver(javaAnnotationResolver);\n        javaCompileTimeConstResolver.setClassResolver(javaClassResolver);\n\n        javaClassObjectResolver.setJavaDescriptorResolver(javaDescriptorResolver);\n        javaClassObjectResolver.setSemanticServices(javaSemanticServices);\n        javaClassObjectResolver.setSupertypesResolver(javaSupertypesResolver);\n        javaClassObjectResolver.setTrace(bindingTrace);\n\n        javaSupertypesResolver.setClassResolver(javaClassResolver);\n        javaSupertypesResolver.setSemanticServices(javaSemanticServices);\n        javaSupertypesResolver.setTrace(bindingTrace);\n        javaSupertypesResolver.setTypeTransformer(javaTypeTransformer);\n\n        javaNamespaceResolver.setJavaSemanticServices(javaSemanticServices);\n        javaNamespaceResolver.setPsiClassFinder(psiClassFinder);\n        javaNamespaceResolver.setTrace(bindingTrace);\n\n        javaSignatureResolver.setJavaSemanticServices(javaSemanticServices);\n\n        javaConstructorResolver.setTrace(bindingTrace);\n        javaConstructorResolver.setTypeTransformer(javaTypeTransformer);\n        javaConstructorResolver.setValueParameterResolver(javaValueParameterResolver);\n\n        javaValueParameterResolver.setTypeTransformer(javaTypeTransformer);\n\n        javaFunctionResolver.setAnnotationResolver(javaAnnotationResolver);\n        javaFunctionResolver.setParameterResolver(javaValueParameterResolver);\n        javaFunctionResolver.setSignatureResolver(javaSignatureResolver);\n        javaFunctionResolver.setTrace(bindingTrace);\n        javaFunctionResolver.setTypeTransformer(javaTypeTransformer);\n\n        javaInnerClassResolver.setClassResolver(javaClassResolver);\n\n        javaPropertiesResolver.setAnnotationResolver(javaAnnotationResolver);\n        javaPropertiesResolver.setClassResolver(javaClassResolver);\n        javaPropertiesResolver.setJavaSignatureResolver(javaSignatureResolver);\n        javaPropertiesResolver.setSemanticServices(javaSemanticServices);\n        javaPropertiesResolver.setTrace(bindingTrace);\n\n        moduleConfiguration.init();\n\n        psiClassFinder.initialize();\n\n    }","commit_id":"fc705edb6502073ef87f33799b083925e3dd6a57","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n  private static PsiBuilder.Marker parseClassFromKeyword(final PsiBuilder builder, final PsiBuilder.Marker declaration,\n                                                         final boolean isAnnotation) {\n    final IElementType keywordTokenType = builder.getTokenType();\n    assert ElementType.CLASS_KEYWORD_BIT_SET.contains(keywordTokenType) : keywordTokenType;\n    builder.advanceLexer();\n    final boolean isEnum = (keywordTokenType == JavaTokenType.ENUM_KEYWORD);\n\n    if (!expect(builder, JavaTokenType.IDENTIFIER)) {\n      error(builder, JavaErrorMessages.message(\"expected.identifier\"));\n      declaration.drop();\n      return null;\n    }\n\n    ReferenceParser.parseTypeParameters(builder);\n    ReferenceParser.parseReferenceList(builder, JavaTokenType.EXTENDS_KEYWORD, JavaElementType.EXTENDS_LIST, JavaTokenType.COMMA);\n    ReferenceParser.parseReferenceList(builder, JavaTokenType.IMPLEMENTS_KEYWORD, JavaElementType.IMPLEMENTS_LIST, JavaTokenType.COMMA);\n\n    if (builder.getTokenType() != JavaTokenType.LBRACE) {\n      final PsiBuilder.Marker error = builder.mark();\n      while (BEFORE_LBRACE_ELEMENTS_SET.contains(builder.getTokenType())) {\n        builder.advanceLexer();\n      }\n      error.error(JavaErrorMessages.message(\"expected.lbrace\"));\n    }\n\n    parseClassBodyWithBraces(builder, isAnnotation, isEnum);\n\n    declaration.done(JavaElementType.CLASS);\n    return declaration;\n  }","id":65561,"modified_method":"@Nullable\n  private static PsiBuilder.Marker parseClassFromKeyword(final PsiBuilder builder, final PsiBuilder.Marker declaration,\n                                                         final boolean isAnnotation, final Context context) {\n    final IElementType keywordTokenType = builder.getTokenType();\n    assert ElementType.CLASS_KEYWORD_BIT_SET.contains(keywordTokenType) : keywordTokenType;\n    builder.advanceLexer();\n    final boolean isEnum = (keywordTokenType == JavaTokenType.ENUM_KEYWORD);\n\n    if (!expect(builder, JavaTokenType.IDENTIFIER)) {\n      error(builder, JavaErrorMessages.message(\"expected.identifier\"));\n      declaration.drop();\n      return null;\n    }\n\n    ReferenceParser.parseTypeParameters(builder);\n    ReferenceParser.parseReferenceList(builder, JavaTokenType.EXTENDS_KEYWORD, JavaElementType.EXTENDS_LIST, JavaTokenType.COMMA);\n    ReferenceParser.parseReferenceList(builder, JavaTokenType.IMPLEMENTS_KEYWORD, JavaElementType.IMPLEMENTS_LIST, JavaTokenType.COMMA);\n\n    if (builder.getTokenType() != JavaTokenType.LBRACE) {\n      final PsiBuilder.Marker error = builder.mark();\n      while (BEFORE_LBRACE_ELEMENTS_SET.contains(builder.getTokenType())) {\n        builder.advanceLexer();\n      }\n      error.error(JavaErrorMessages.message(\"expected.lbrace\"));\n    }\n\n    parseClassBodyWithBraces(builder, isAnnotation, isEnum);\n\n    if (context == Context.FILE) {\n      boolean declarationsAfterEnd = false;\n\n      while (builder.getTokenType() != null && builder.getTokenType() != JavaTokenType.RBRACE) {\n        final PsiBuilder.Marker position = builder.mark();\n        final PsiBuilder.Marker extra = parse(builder, Context.CLASS);\n        if (extra != null && AFTER_END_DECLARATION_SET.contains(exprType(extra))) {\n          if (!declarationsAfterEnd) {\n            error(builder, JavaErrorMessages.message(\"expected.class.or.interface\"), extra);\n          }\n          declarationsAfterEnd = true;\n          position.drop();\n        }\n        else {\n          position.rollbackTo();\n          break;\n        }\n      }\n\n      if (declarationsAfterEnd) {\n        expectOrError(builder, JavaTokenType.RBRACE, JavaErrorMessages.message(\"expected.rbrace\"));\n      }\n    }\n\n    declaration.done(JavaElementType.CLASS);\n    return declaration;\n  }","commit_id":"05be23db87df2a882fde6132e5e002007db90c57","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PsiBuilder.Marker parse(final PsiBuilder builder, final Context context) {\n    final IElementType tokenType = builder.getTokenType();\n    if (tokenType == null) return null;\n\n    if (tokenType == JavaTokenType.LBRACE) {\n      if (context == Context.FILE || context == Context.CODE_BLOCK) return null;\n    }\n    else if (tokenType == JavaTokenType.IDENTIFIER || ElementType.PRIMITIVE_TYPE_BIT_SET.contains(tokenType)) {\n      if (context == Context.FILE) return null;\n    }\n    else if (tokenType instanceof ILazyParseableElementType) {\n      builder.advanceLexer();\n      return null;\n    }\n    else if (!ElementType.MODIFIER_BIT_SET.contains(tokenType) &&\n             !ElementType.CLASS_KEYWORD_BIT_SET.contains(tokenType) &&\n             tokenType != JavaTokenType.AT &&\n             (context == Context.CODE_BLOCK || tokenType != JavaTokenType.LT)) {\n      return null;\n    }\n\n    final PsiBuilder.Marker declaration = builder.mark();\n    final int declarationStart = builder.getCurrentOffset();\n\n    final Pair<PsiBuilder.Marker, Boolean> modListInfo = parseModifierList(builder);\n    final PsiBuilder.Marker modList = modListInfo.first;\n\n    if (expect(builder, JavaTokenType.AT)) {\n      if (builder.getTokenType() == JavaTokenType.INTERFACE_KEYWORD) {\n        return parseClassFromKeyword(builder, declaration, true);\n      }\n      else {\n        declaration.rollbackTo();\n        return null;\n      }\n    }\n    else if (ElementType.CLASS_KEYWORD_BIT_SET.contains(builder.getTokenType())) {\n      final PsiBuilder.Marker root = parseClassFromKeyword(builder, declaration, false);\n      if (context == Context.FILE) {\n        // todo: append following declarations to root (?)\n        boolean declarationsAfterEnd = false;\n\n        while (builder.getTokenType() != null && builder.getTokenType() != JavaTokenType.RBRACE) {\n          final PsiBuilder.Marker position = builder.mark();\n          final PsiBuilder.Marker element = parse(builder, Context.CLASS);\n          if (element != null && AFTER_END_DECLARATION_SET.contains(exprType(element))) {\n            if (!declarationsAfterEnd) {\n              element.precede().error(JavaErrorMessages.message(\"expected.class.or.interface\"));\n            }\n            declarationsAfterEnd = true;\n            position.drop();\n          }\n          else {\n            position.rollbackTo();\n            break;\n          }\n        }\n\n        if (declarationsAfterEnd) {\n          expectOrError(builder, JavaTokenType.RBRACE, JavaErrorMessages.message(\"expected.rbrace\"));\n        }\n      }\n      return root;\n    }\n\n    PsiBuilder.Marker typeParams = null;\n    if (builder.getTokenType() == JavaTokenType.LT) {\n      typeParams = ReferenceParser.parseTypeParameters(builder);\n    }\n\n    if (context == Context.FILE) {\n      error(builder, JavaErrorMessages.message(\"expected.class.or.interface\"), typeParams);\n      declaration.drop();\n      return modList;\n    }\n\n    PsiBuilder.Marker type;\n    if (ElementType.PRIMITIVE_TYPE_BIT_SET.contains(builder.getTokenType())) {\n      type = parseTypeNotNull(builder);\n    }\n    else if (builder.getTokenType() == JavaTokenType.IDENTIFIER) {\n      final PsiBuilder.Marker idPos = builder.mark();\n      type = parseTypeNotNull(builder);\n      if (builder.getTokenType() == JavaTokenType.LPARENTH) {  // constructor\n        if (context == Context.CODE_BLOCK) {\n          declaration.rollbackTo();\n          return null;\n        }\n        idPos.rollbackTo();\n        if (typeParams == null) {\n          emptyElement(builder, JavaElementType.TYPE_PARAMETER_LIST);\n        }\n        builder.advanceLexer();\n        if (builder.getTokenType() != JavaTokenType.LPARENTH) {\n          declaration.rollbackTo();\n          return null;\n        }\n        return parseMethodFromLeftParenth(builder, declaration, false);\n      }\n      idPos.drop();\n    }\n    else if (builder.getTokenType() == JavaTokenType.LBRACE) {\n      if (context == Context.CODE_BLOCK) {\n        error(builder, JavaErrorMessages.message(\"expected.identifier.or.type\"), typeParams);\n        declaration.drop();\n        return modList;\n      }\n\n      final PsiBuilder.Marker codeBlock = StatementParser.parseCodeBlock(builder);\n      assert codeBlock != null : builder.getOriginalText();\n\n      if (typeParams != null) {\n        final PsiBuilder.Marker error = typeParams.precede();\n        error.errorBefore(JavaErrorMessages.message(\"unexpected.token\"), codeBlock);\n      }\n      declaration.done(JavaElementType.CLASS_INITIALIZER);\n      return declaration;\n    }\n    else {\n      final PsiBuilder.Marker error;\n      if (typeParams != null) {\n        error = typeParams.precede();\n      }\n      else {\n        error = builder.mark();\n      }\n      error.error(JavaErrorMessages.message(\"expected.identifier.or.type\"));\n      declaration.drop();\n      return modList;\n    }\n\n    if (!expect(builder, JavaTokenType.IDENTIFIER)) {\n      if (context == Context.CODE_BLOCK && modListInfo.second) {\n        declaration.rollbackTo();\n        return null;\n      }\n      else {\n        if (typeParams != null) {\n          typeParams.precede().errorBefore(JavaErrorMessages.message(\"unexpected.token\"), type);\n        }\n        builder.error(JavaErrorMessages.message(\"expected.identifier\"));\n        declaration.drop();\n        return modList;\n      }\n    }\n\n    if (builder.getTokenType() == JavaTokenType.LPARENTH) {\n      if (context == Context.CLASS || context == Context.ANNOTATION_INTERFACE) {  // method\n        if (typeParams == null) {\n          emptyElement(type, JavaElementType.TYPE_PARAMETER_LIST);\n        }\n        return parseMethodFromLeftParenth(builder, declaration, (context == Context.ANNOTATION_INTERFACE));\n      }\n    }\n\n    if (typeParams != null) {\n      typeParams.precede().errorBefore(JavaErrorMessages.message(\"unexpected.token\"), type);\n    }\n    return parseFieldOrLocalVariable(builder, declaration, declarationStart, context);\n  }","id":65562,"modified_method":"@Nullable\n  public static PsiBuilder.Marker parse(final PsiBuilder builder, final Context context) {\n    final IElementType tokenType = builder.getTokenType();\n    if (tokenType == null) return null;\n\n    if (tokenType == JavaTokenType.LBRACE) {\n      if (context == Context.FILE || context == Context.CODE_BLOCK) return null;\n    }\n    else if (tokenType == JavaTokenType.IDENTIFIER || ElementType.PRIMITIVE_TYPE_BIT_SET.contains(tokenType)) {\n      if (context == Context.FILE) return null;\n    }\n    else if (tokenType instanceof ILazyParseableElementType) {\n      builder.advanceLexer();\n      return null;\n    }\n    else if (!ElementType.MODIFIER_BIT_SET.contains(tokenType) &&\n             !ElementType.CLASS_KEYWORD_BIT_SET.contains(tokenType) &&\n             tokenType != JavaTokenType.AT &&\n             (context == Context.CODE_BLOCK || tokenType != JavaTokenType.LT)) {\n      return null;\n    }\n\n    final PsiBuilder.Marker declaration = builder.mark();\n    final int declarationStart = builder.getCurrentOffset();\n\n    final Pair<PsiBuilder.Marker, Boolean> modListInfo = parseModifierList(builder);\n    final PsiBuilder.Marker modList = modListInfo.first;\n\n    if (expect(builder, JavaTokenType.AT)) {\n      if (builder.getTokenType() == JavaTokenType.INTERFACE_KEYWORD) {\n        return parseClassFromKeyword(builder, declaration, true, context);\n      }\n      else {\n        declaration.rollbackTo();\n        return null;\n      }\n    }\n    else if (ElementType.CLASS_KEYWORD_BIT_SET.contains(builder.getTokenType())) {\n      return parseClassFromKeyword(builder, declaration, false, context);\n    }\n\n    PsiBuilder.Marker typeParams = null;\n    if (builder.getTokenType() == JavaTokenType.LT) {\n      typeParams = ReferenceParser.parseTypeParameters(builder);\n    }\n\n    if (context == Context.FILE) {\n      error(builder, JavaErrorMessages.message(\"expected.class.or.interface\"), typeParams);\n      declaration.drop();\n      return modList;\n    }\n\n    PsiBuilder.Marker type;\n    if (ElementType.PRIMITIVE_TYPE_BIT_SET.contains(builder.getTokenType())) {\n      type = parseTypeNotNull(builder);\n    }\n    else if (builder.getTokenType() == JavaTokenType.IDENTIFIER) {\n      final PsiBuilder.Marker idPos = builder.mark();\n      type = parseTypeNotNull(builder);\n      if (builder.getTokenType() == JavaTokenType.LPARENTH) {  // constructor\n        if (context == Context.CODE_BLOCK) {\n          declaration.rollbackTo();\n          return null;\n        }\n        idPos.rollbackTo();\n        if (typeParams == null) {\n          emptyElement(builder, JavaElementType.TYPE_PARAMETER_LIST);\n        }\n        builder.advanceLexer();\n        if (builder.getTokenType() != JavaTokenType.LPARENTH) {\n          declaration.rollbackTo();\n          return null;\n        }\n        return parseMethodFromLeftParenth(builder, declaration, false);\n      }\n      idPos.drop();\n    }\n    else if (builder.getTokenType() == JavaTokenType.LBRACE) {\n      if (context == Context.CODE_BLOCK) {\n        error(builder, JavaErrorMessages.message(\"expected.identifier.or.type\"), typeParams);\n        declaration.drop();\n        return modList;\n      }\n\n      final PsiBuilder.Marker codeBlock = StatementParser.parseCodeBlock(builder);\n      assert codeBlock != null : builder.getOriginalText();\n\n      if (typeParams != null) {\n        final PsiBuilder.Marker error = typeParams.precede();\n        error.errorBefore(JavaErrorMessages.message(\"unexpected.token\"), codeBlock);\n      }\n      declaration.done(JavaElementType.CLASS_INITIALIZER);\n      return declaration;\n    }\n    else {\n      final PsiBuilder.Marker error;\n      if (typeParams != null) {\n        error = typeParams.precede();\n      }\n      else {\n        error = builder.mark();\n      }\n      error.error(JavaErrorMessages.message(\"expected.identifier.or.type\"));\n      declaration.drop();\n      return modList;\n    }\n\n    if (!expect(builder, JavaTokenType.IDENTIFIER)) {\n      if (context == Context.CODE_BLOCK && modListInfo.second) {\n        declaration.rollbackTo();\n        return null;\n      }\n      else {\n        if (typeParams != null) {\n          typeParams.precede().errorBefore(JavaErrorMessages.message(\"unexpected.token\"), type);\n        }\n        builder.error(JavaErrorMessages.message(\"expected.identifier\"));\n        declaration.drop();\n        return modList;\n      }\n    }\n\n    if (builder.getTokenType() == JavaTokenType.LPARENTH) {\n      if (context == Context.CLASS || context == Context.ANNOTATION_INTERFACE) {  // method\n        if (typeParams == null) {\n          emptyElement(type, JavaElementType.TYPE_PARAMETER_LIST);\n        }\n        return parseMethodFromLeftParenth(builder, declaration, (context == Context.ANNOTATION_INTERFACE));\n      }\n    }\n\n    if (typeParams != null) {\n      typeParams.precede().errorBefore(JavaErrorMessages.message(\"unexpected.token\"), type);\n    }\n    return parseFieldOrLocalVariable(builder, declaration, declarationStart, context);\n  }","commit_id":"05be23db87df2a882fde6132e5e002007db90c57","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testError() { doTestDefaultParser(true);}","id":65563,"modified_method":"public void testError() { doTest(true); }","commit_id":"f8501192160544064dc90430a7f84c8b8b12fb93","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PsiBuilder.Marker parseClassFromKeyword(final PsiBuilder builder, final PsiBuilder.Marker declaration,\n                                                         final boolean isAnnotation, final Context context) {\n    final IElementType keywordTokenType = builder.getTokenType();\n    assert ElementType.CLASS_KEYWORD_BIT_SET.contains(keywordTokenType) : keywordTokenType;\n    builder.advanceLexer();\n    final boolean isEnum = (keywordTokenType == JavaTokenType.ENUM_KEYWORD);\n\n    if (!expect(builder, JavaTokenType.IDENTIFIER)) {\n      error(builder, JavaErrorMessages.message(\"expected.identifier\"));\n      declaration.drop();\n      return null;\n    }\n\n    ReferenceParser.parseTypeParameters(builder);\n    ReferenceParser.parseReferenceList(builder, JavaTokenType.EXTENDS_KEYWORD, JavaElementType.EXTENDS_LIST, JavaTokenType.COMMA);\n    ReferenceParser.parseReferenceList(builder, JavaTokenType.IMPLEMENTS_KEYWORD, JavaElementType.IMPLEMENTS_LIST, JavaTokenType.COMMA);\n\n    if (builder.getTokenType() != JavaTokenType.LBRACE) {\n      final PsiBuilder.Marker error = builder.mark();\n      while (BEFORE_LBRACE_ELEMENTS_SET.contains(builder.getTokenType())) {\n        builder.advanceLexer();\n      }\n      error.error(JavaErrorMessages.message(\"expected.lbrace\"));\n    }\n\n    parseClassBodyWithBraces(builder, isAnnotation, isEnum);\n\n    if (context == Context.FILE) {\n      boolean declarationsAfterEnd = false;\n\n      while (builder.getTokenType() != null && builder.getTokenType() != JavaTokenType.RBRACE) {\n        final PsiBuilder.Marker position = builder.mark();\n        final PsiBuilder.Marker extra = parse(builder, Context.CLASS);\n        if (extra != null && AFTER_END_DECLARATION_SET.contains(exprType(extra))) {\n          if (!declarationsAfterEnd) {\n            error(builder, JavaErrorMessages.message(\"expected.class.or.interface\"), extra);\n          }\n          declarationsAfterEnd = true;\n          position.drop();\n        }\n        else {\n          position.rollbackTo();\n          break;\n        }\n      }\n\n      if (declarationsAfterEnd) {\n        expectOrError(builder, JavaTokenType.RBRACE, JavaErrorMessages.message(\"expected.rbrace\"));\n      }\n    }\n\n    declaration.done(JavaElementType.CLASS);\n    return declaration;\n  }","id":65564,"modified_method":"@Nullable\n  private static PsiBuilder.Marker parseClassFromKeyword(final PsiBuilder builder, final PsiBuilder.Marker declaration,\n                                                         final boolean isAnnotation, final Context context) {\n    final IElementType keywordTokenType = builder.getTokenType();\n    assert ElementType.CLASS_KEYWORD_BIT_SET.contains(keywordTokenType) : keywordTokenType;\n    builder.advanceLexer();\n    final boolean isEnum = (keywordTokenType == JavaTokenType.ENUM_KEYWORD);\n\n    if (!expect(builder, JavaTokenType.IDENTIFIER)) {\n      error(builder, JavaErrorMessages.message(\"expected.identifier\"));\n      declaration.drop();\n      return null;\n    }\n\n    ReferenceParser.parseTypeParameters(builder);\n    ReferenceParser.parseReferenceList(builder, JavaTokenType.EXTENDS_KEYWORD, JavaElementType.EXTENDS_LIST, JavaTokenType.COMMA);\n    ReferenceParser.parseReferenceList(builder, JavaTokenType.IMPLEMENTS_KEYWORD, JavaElementType.IMPLEMENTS_LIST, JavaTokenType.COMMA);\n\n    if (builder.getTokenType() != JavaTokenType.LBRACE) {\n      final PsiBuilder.Marker error = builder.mark();\n      while (BEFORE_LBRACE_ELEMENTS_SET.contains(builder.getTokenType())) {\n        builder.advanceLexer();\n      }\n      error.error(JavaErrorMessages.message(\"expected.lbrace\"));\n    }\n    else {\n      parseClassBodyWithBraces(builder, isAnnotation, isEnum);\n    }\n\n    if (context == Context.FILE) {\n      boolean declarationsAfterEnd = false;\n\n      while (builder.getTokenType() != null && builder.getTokenType() != JavaTokenType.RBRACE) {\n        final PsiBuilder.Marker position = builder.mark();\n        final PsiBuilder.Marker extra = parse(builder, Context.CLASS);\n        if (extra != null && AFTER_END_DECLARATION_SET.contains(exprType(extra))) {\n          if (!declarationsAfterEnd) {\n            error(builder, JavaErrorMessages.message(\"expected.class.or.interface\"), extra);\n          }\n          declarationsAfterEnd = true;\n          position.drop();\n        }\n        else {\n          position.rollbackTo();\n          break;\n        }\n      }\n\n      if (declarationsAfterEnd) {\n        expectOrError(builder, JavaTokenType.RBRACE, JavaErrorMessages.message(\"expected.rbrace\"));\n      }\n    }\n\n    declaration.done(JavaElementType.CLASS);\n    return declaration;\n  }","commit_id":"f8501192160544064dc90430a7f84c8b8b12fb93","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PsiBuilder.Marker parse(final PsiBuilder builder, final Context context) {\n    final IElementType tokenType = builder.getTokenType();\n    if (tokenType == null) return null;\n\n    if (tokenType == JavaTokenType.LBRACE) {\n      if (context == Context.FILE || context == Context.CODE_BLOCK) return null;\n    }\n    else if (tokenType == JavaTokenType.IDENTIFIER || ElementType.PRIMITIVE_TYPE_BIT_SET.contains(tokenType)) {\n      if (context == Context.FILE) return null;\n    }\n    else if (tokenType instanceof ILazyParseableElementType) {\n      builder.advanceLexer();\n      return null;\n    }\n    else if (!ElementType.MODIFIER_BIT_SET.contains(tokenType) &&\n             !ElementType.CLASS_KEYWORD_BIT_SET.contains(tokenType) &&\n             tokenType != JavaTokenType.AT &&\n             (context == Context.CODE_BLOCK || tokenType != JavaTokenType.LT)) {\n      return null;\n    }\n\n    final PsiBuilder.Marker declaration = builder.mark();\n    final int declarationStart = builder.getCurrentOffset();\n\n    final Pair<PsiBuilder.Marker, Boolean> modListInfo = parseModifierList(builder);\n    final PsiBuilder.Marker modList = modListInfo.first;\n\n    if (expect(builder, JavaTokenType.AT)) {\n      if (builder.getTokenType() == JavaTokenType.INTERFACE_KEYWORD) {\n        return parseClassFromKeyword(builder, declaration, true, context);\n      }\n      else {\n        declaration.rollbackTo();\n        return null;\n      }\n    }\n    else if (ElementType.CLASS_KEYWORD_BIT_SET.contains(builder.getTokenType())) {\n      return parseClassFromKeyword(builder, declaration, false, context);\n    }\n\n    PsiBuilder.Marker typeParams = null;\n    if (builder.getTokenType() == JavaTokenType.LT) {\n      typeParams = ReferenceParser.parseTypeParameters(builder);\n    }\n\n    if (context == Context.FILE) {\n      error(builder, JavaErrorMessages.message(\"expected.class.or.interface\"), typeParams);\n      declaration.drop();\n      return modList;\n    }\n\n    PsiBuilder.Marker type;\n    if (ElementType.PRIMITIVE_TYPE_BIT_SET.contains(builder.getTokenType())) {\n      type = parseTypeNotNull(builder);\n    }\n    else if (builder.getTokenType() == JavaTokenType.IDENTIFIER) {\n      final PsiBuilder.Marker idPos = builder.mark();\n      type = parseTypeNotNull(builder);\n      if (builder.getTokenType() == JavaTokenType.LPARENTH) {  // constructor\n        if (context == Context.CODE_BLOCK) {\n          declaration.rollbackTo();\n          return null;\n        }\n        idPos.rollbackTo();\n        if (typeParams == null) {\n          emptyElement(builder, JavaElementType.TYPE_PARAMETER_LIST);\n        }\n        builder.advanceLexer();\n        if (builder.getTokenType() != JavaTokenType.LPARENTH) {\n          declaration.rollbackTo();\n          return null;\n        }\n        return parseMethodFromLeftParenth(builder, declaration, false);\n      }\n      idPos.drop();\n    }\n    else if (builder.getTokenType() == JavaTokenType.LBRACE) {\n      if (context == Context.CODE_BLOCK) {\n        error(builder, JavaErrorMessages.message(\"expected.identifier.or.type\"), typeParams);\n        declaration.drop();\n        return modList;\n      }\n\n      final PsiBuilder.Marker codeBlock = StatementParser.parseCodeBlock(builder);\n      assert codeBlock != null : builder.getOriginalText();\n\n      if (typeParams != null) {\n        final PsiBuilder.Marker error = typeParams.precede();\n        error.errorBefore(JavaErrorMessages.message(\"unexpected.token\"), codeBlock);\n      }\n      declaration.done(JavaElementType.CLASS_INITIALIZER);\n      return declaration;\n    }\n    else {\n      final PsiBuilder.Marker error;\n      if (typeParams != null) {\n        error = typeParams.precede();\n      }\n      else {\n        error = builder.mark();\n      }\n      error.error(JavaErrorMessages.message(\"expected.identifier.or.type\"));\n      declaration.drop();\n      return modList;\n    }\n\n    if (!expect(builder, JavaTokenType.IDENTIFIER)) {\n      if (context == Context.CODE_BLOCK && modListInfo.second) {\n        declaration.rollbackTo();\n        return null;\n      }\n      else {\n        if (typeParams != null) {\n          typeParams.precede().errorBefore(JavaErrorMessages.message(\"unexpected.token\"), type);\n        }\n        builder.error(JavaErrorMessages.message(\"expected.identifier\"));\n        declaration.drop();\n        return modList;\n      }\n    }\n\n    if (builder.getTokenType() == JavaTokenType.LPARENTH) {\n      if (context == Context.CLASS || context == Context.ANNOTATION_INTERFACE) {  // method\n        if (typeParams == null) {\n          emptyElement(type, JavaElementType.TYPE_PARAMETER_LIST);\n        }\n        return parseMethodFromLeftParenth(builder, declaration, (context == Context.ANNOTATION_INTERFACE));\n      }\n    }\n\n    if (typeParams != null) {\n      typeParams.precede().errorBefore(JavaErrorMessages.message(\"unexpected.token\"), type);\n    }\n    return parseFieldOrLocalVariable(builder, declaration, declarationStart, context);\n  }","id":65565,"modified_method":"@Nullable\n  public static PsiBuilder.Marker parse(final PsiBuilder builder, final Context context) {\n    final IElementType tokenType = builder.getTokenType();\n    if (tokenType == null) return null;\n\n    if (tokenType == JavaTokenType.LBRACE) {\n      if (context == Context.FILE || context == Context.CODE_BLOCK) return null;\n    }\n    else if (tokenType == JavaTokenType.IDENTIFIER || ElementType.PRIMITIVE_TYPE_BIT_SET.contains(tokenType)) {\n      if (context == Context.FILE) return null;\n    }\n    else if (tokenType instanceof ILazyParseableElementType) {\n      builder.advanceLexer();\n      return null;\n    }\n    else if (!ElementType.MODIFIER_BIT_SET.contains(tokenType) &&\n             !ElementType.CLASS_KEYWORD_BIT_SET.contains(tokenType) &&\n             tokenType != JavaTokenType.AT &&\n             (context == Context.CODE_BLOCK || tokenType != JavaTokenType.LT)) {\n      return null;\n    }\n\n    final PsiBuilder.Marker declaration = builder.mark();\n    final int declarationStart = builder.getCurrentOffset();\n\n    final Pair<PsiBuilder.Marker, Boolean> modListInfo = parseModifierList(builder);\n    final PsiBuilder.Marker modList = modListInfo.first;\n\n    if (expect(builder, JavaTokenType.AT)) {\n      if (builder.getTokenType() == JavaTokenType.INTERFACE_KEYWORD) {\n        return parseClassFromKeyword(builder, declaration, true, context);\n      }\n      else {\n        declaration.rollbackTo();\n        return null;\n      }\n    }\n    else if (ElementType.CLASS_KEYWORD_BIT_SET.contains(builder.getTokenType())) {\n      final PsiBuilder.Marker result = parseClassFromKeyword(builder, declaration, false, context);\n      return result != null ? result : modList;\n    }\n\n    PsiBuilder.Marker typeParams = null;\n    if (builder.getTokenType() == JavaTokenType.LT) {\n      typeParams = ReferenceParser.parseTypeParameters(builder);\n    }\n\n    if (context == Context.FILE) {\n      error(builder, JavaErrorMessages.message(\"expected.class.or.interface\"), typeParams);\n      declaration.drop();\n      return modList;\n    }\n\n    PsiBuilder.Marker type;\n    if (ElementType.PRIMITIVE_TYPE_BIT_SET.contains(builder.getTokenType())) {\n      type = parseTypeNotNull(builder);\n    }\n    else if (builder.getTokenType() == JavaTokenType.IDENTIFIER) {\n      final PsiBuilder.Marker idPos = builder.mark();\n      type = parseTypeNotNull(builder);\n      if (builder.getTokenType() == JavaTokenType.LPARENTH) {  // constructor\n        if (context == Context.CODE_BLOCK) {\n          declaration.rollbackTo();\n          return null;\n        }\n        idPos.rollbackTo();\n        if (typeParams == null) {\n          emptyElement(builder, JavaElementType.TYPE_PARAMETER_LIST);\n        }\n        builder.advanceLexer();\n        if (builder.getTokenType() != JavaTokenType.LPARENTH) {\n          declaration.rollbackTo();\n          return null;\n        }\n        return parseMethodFromLeftParenth(builder, declaration, false);\n      }\n      idPos.drop();\n    }\n    else if (builder.getTokenType() == JavaTokenType.LBRACE) {\n      if (context == Context.CODE_BLOCK) {\n        error(builder, JavaErrorMessages.message(\"expected.identifier.or.type\"), typeParams);\n        declaration.drop();\n        return modList;\n      }\n\n      final PsiBuilder.Marker codeBlock = StatementParser.parseCodeBlock(builder);\n      assert codeBlock != null : builder.getOriginalText();\n\n      if (typeParams != null) {\n        final PsiBuilder.Marker error = typeParams.precede();\n        error.errorBefore(JavaErrorMessages.message(\"unexpected.token\"), codeBlock);\n      }\n      declaration.done(JavaElementType.CLASS_INITIALIZER);\n      return declaration;\n    }\n    else {\n      final PsiBuilder.Marker error;\n      if (typeParams != null) {\n        error = typeParams.precede();\n      }\n      else {\n        error = builder.mark();\n      }\n      error.error(JavaErrorMessages.message(\"expected.identifier.or.type\"));\n      declaration.drop();\n      return modList;\n    }\n\n    if (!expect(builder, JavaTokenType.IDENTIFIER)) {\n      if (context == Context.CODE_BLOCK && modListInfo.second) {\n        declaration.rollbackTo();\n        return null;\n      }\n      else {\n        if (typeParams != null) {\n          typeParams.precede().errorBefore(JavaErrorMessages.message(\"unexpected.token\"), type);\n        }\n        builder.error(JavaErrorMessages.message(\"expected.identifier\"));\n        declaration.drop();\n        return modList;\n      }\n    }\n\n    if (builder.getTokenType() == JavaTokenType.LPARENTH) {\n      if (context == Context.CLASS || context == Context.ANNOTATION_INTERFACE) {  // method\n        if (typeParams == null) {\n          emptyElement(type, JavaElementType.TYPE_PARAMETER_LIST);\n        }\n        return parseMethodFromLeftParenth(builder, declaration, (context == Context.ANNOTATION_INTERFACE));\n      }\n    }\n\n    if (typeParams != null) {\n      typeParams.precede().errorBefore(JavaErrorMessages.message(\"unexpected.token\"), type);\n    }\n    return parseFieldOrLocalVariable(builder, declaration, declarationStart, context);\n  }","commit_id":"f8501192160544064dc90430a7f84c8b8b12fb93","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PsiBuilder.Marker parse(final PsiBuilder builder, final Context context) {\n    final IElementType tokenType = builder.getTokenType();\n    if (tokenType == null) return null;\n\n    if (tokenType == JavaTokenType.LBRACE) {\n      if (context == Context.FILE || context == Context.CODE_BLOCK) return null;\n    }\n    else if (tokenType == JavaTokenType.IDENTIFIER || ElementType.PRIMITIVE_TYPE_BIT_SET.contains(tokenType)) {\n      if (context == Context.FILE) return null;\n    }\n    else if (tokenType instanceof ILazyParseableElementType) {\n      builder.advanceLexer();\n      return null;\n    }\n    else if (!ElementType.MODIFIER_BIT_SET.contains(tokenType) &&\n             !ElementType.CLASS_KEYWORD_BIT_SET.contains(tokenType) &&\n             tokenType != JavaTokenType.AT &&\n             (context == Context.CODE_BLOCK || tokenType != JavaTokenType.LT)) {\n      return null;\n    }\n\n    final PsiBuilder.Marker declaration = builder.mark();\n    final int declarationStart = builder.getCurrentOffset();\n\n    final Pair<PsiBuilder.Marker, Boolean> modListInfo = parseModifierList(builder);\n    final PsiBuilder.Marker modList = modListInfo.first;\n\n    if (expect(builder, JavaTokenType.AT)) {\n      if (builder.getTokenType() == JavaTokenType.INTERFACE_KEYWORD) {\n        return parseClassFromKeyword(builder, declaration, true, context);\n      }\n      else {\n        declaration.rollbackTo();\n        return null;\n      }\n    }\n    else if (ElementType.CLASS_KEYWORD_BIT_SET.contains(builder.getTokenType())) {\n      final PsiBuilder.Marker result = parseClassFromKeyword(builder, declaration, false, context);\n      return result != null ? result : modList;\n    }\n\n    PsiBuilder.Marker typeParams = null;\n    if (builder.getTokenType() == JavaTokenType.LT) {\n      typeParams = ReferenceParser.parseTypeParameters(builder);\n    }\n\n    if (context == Context.FILE) {\n      error(builder, JavaErrorMessages.message(\"expected.class.or.interface\"), typeParams);\n      declaration.drop();\n      return modList;\n    }\n\n    PsiBuilder.Marker type;\n    if (ElementType.PRIMITIVE_TYPE_BIT_SET.contains(builder.getTokenType())) {\n      type = parseTypeNotNull(builder);\n    }\n    else if (builder.getTokenType() == JavaTokenType.IDENTIFIER) {\n      final PsiBuilder.Marker idPos = builder.mark();\n      type = parseTypeNotNull(builder);\n      if (builder.getTokenType() == JavaTokenType.LPARENTH) {  // constructor\n        if (context == Context.CODE_BLOCK) {\n          declaration.rollbackTo();\n          return null;\n        }\n        idPos.rollbackTo();\n        if (typeParams == null) {\n          emptyElement(builder, JavaElementType.TYPE_PARAMETER_LIST);\n        }\n        builder.advanceLexer();\n        if (builder.getTokenType() != JavaTokenType.LPARENTH) {\n          declaration.rollbackTo();\n          return null;\n        }\n        return parseMethodFromLeftParenth(builder, declaration, false);\n      }\n      idPos.drop();\n    }\n    else if (builder.getTokenType() == JavaTokenType.LBRACE) {\n      if (context == Context.CODE_BLOCK) {\n        error(builder, JavaErrorMessages.message(\"expected.identifier.or.type\"), typeParams);\n        declaration.drop();\n        return modList;\n      }\n\n      final PsiBuilder.Marker codeBlock = StatementParser.parseCodeBlock(builder);\n      assert codeBlock != null : builder.getOriginalText();\n\n      if (typeParams != null) {\n        final PsiBuilder.Marker error = typeParams.precede();\n        error.errorBefore(JavaErrorMessages.message(\"unexpected.token\"), codeBlock);\n      }\n      declaration.done(JavaElementType.CLASS_INITIALIZER);\n      return declaration;\n    }\n    else {\n      final PsiBuilder.Marker error;\n      if (typeParams != null) {\n        error = typeParams.precede();\n      }\n      else {\n        error = builder.mark();\n      }\n      error.error(JavaErrorMessages.message(\"expected.identifier.or.type\"));\n      declaration.drop();\n      return modList;\n    }\n\n    if (!expect(builder, JavaTokenType.IDENTIFIER)) {\n      if (context == Context.CODE_BLOCK && modListInfo.second) {\n        declaration.rollbackTo();\n        return null;\n      }\n      else {\n        if (typeParams != null) {\n          typeParams.precede().errorBefore(JavaErrorMessages.message(\"unexpected.token\"), type);\n        }\n        builder.error(JavaErrorMessages.message(\"expected.identifier\"));\n        declaration.drop();\n        return modList;\n      }\n    }\n\n    if (builder.getTokenType() == JavaTokenType.LPARENTH) {\n      if (context == Context.CLASS || context == Context.ANNOTATION_INTERFACE) {  // method\n        if (typeParams == null) {\n          emptyElement(type, JavaElementType.TYPE_PARAMETER_LIST);\n        }\n        return parseMethodFromLeftParenth(builder, declaration, (context == Context.ANNOTATION_INTERFACE));\n      }\n    }\n\n    if (typeParams != null) {\n      typeParams.precede().errorBefore(JavaErrorMessages.message(\"unexpected.token\"), type);\n    }\n    return parseFieldOrLocalVariable(builder, declaration, declarationStart, context);\n  }","id":65566,"modified_method":"@Nullable\n  public static PsiBuilder.Marker parse(final PsiBuilder builder, final Context context) {\n    final IElementType tokenType = builder.getTokenType();\n    if (tokenType == null) return null;\n\n    if (tokenType == JavaTokenType.LBRACE) {\n      if (context == Context.FILE || context == Context.CODE_BLOCK) return null;\n    }\n    else if (tokenType == JavaTokenType.IDENTIFIER || ElementType.PRIMITIVE_TYPE_BIT_SET.contains(tokenType)) {\n      if (context == Context.FILE) return null;\n    }\n    else if (tokenType instanceof ILazyParseableElementType) {\n      builder.advanceLexer();\n      return null;\n    }\n    else if (!ElementType.MODIFIER_BIT_SET.contains(tokenType) &&\n             !ElementType.CLASS_KEYWORD_BIT_SET.contains(tokenType) &&\n             tokenType != JavaTokenType.AT &&\n             (context == Context.CODE_BLOCK || tokenType != JavaTokenType.LT)) {\n      return null;\n    }\n\n    final PsiBuilder.Marker declaration = builder.mark();\n    final int declarationStart = builder.getCurrentOffset();\n\n    final Pair<PsiBuilder.Marker, Boolean> modListInfo = parseModifierList(builder);\n    final PsiBuilder.Marker modList = modListInfo.first;\n\n    if (expect(builder, JavaTokenType.AT)) {\n      if (builder.getTokenType() == JavaTokenType.INTERFACE_KEYWORD) {\n        final PsiBuilder.Marker result = parseClassFromKeyword(builder, declaration, true, context);\n        return result != null ? result : modList;\n      }\n      else {\n        declaration.rollbackTo();\n        return null;\n      }\n    }\n    else if (ElementType.CLASS_KEYWORD_BIT_SET.contains(builder.getTokenType())) {\n      final PsiBuilder.Marker result = parseClassFromKeyword(builder, declaration, false, context);\n      return result != null ? result : modList;\n    }\n\n    PsiBuilder.Marker typeParams = null;\n    if (builder.getTokenType() == JavaTokenType.LT) {\n      typeParams = ReferenceParser.parseTypeParameters(builder);\n    }\n\n    if (context == Context.FILE) {\n      error(builder, JavaErrorMessages.message(\"expected.class.or.interface\"), typeParams);\n      declaration.drop();\n      return modList;\n    }\n\n    PsiBuilder.Marker type;\n    if (ElementType.PRIMITIVE_TYPE_BIT_SET.contains(builder.getTokenType())) {\n      type = parseTypeNotNull(builder);\n    }\n    else if (builder.getTokenType() == JavaTokenType.IDENTIFIER) {\n      final PsiBuilder.Marker idPos = builder.mark();\n      type = parseTypeNotNull(builder);\n      if (builder.getTokenType() == JavaTokenType.LPARENTH) {  // constructor\n        if (context == Context.CODE_BLOCK) {\n          declaration.rollbackTo();\n          return null;\n        }\n        idPos.rollbackTo();\n        if (typeParams == null) {\n          emptyElement(builder, JavaElementType.TYPE_PARAMETER_LIST);\n        }\n        builder.advanceLexer();\n        if (builder.getTokenType() != JavaTokenType.LPARENTH) {\n          declaration.rollbackTo();\n          return null;\n        }\n        return parseMethodFromLeftParenth(builder, declaration, false);\n      }\n      idPos.drop();\n    }\n    else if (builder.getTokenType() == JavaTokenType.LBRACE) {\n      if (context == Context.CODE_BLOCK) {\n        error(builder, JavaErrorMessages.message(\"expected.identifier.or.type\"), typeParams);\n        declaration.drop();\n        return modList;\n      }\n\n      final PsiBuilder.Marker codeBlock = StatementParser.parseCodeBlock(builder);\n      assert codeBlock != null : builder.getOriginalText();\n\n      if (typeParams != null) {\n        final PsiBuilder.Marker error = typeParams.precede();\n        error.errorBefore(JavaErrorMessages.message(\"unexpected.token\"), codeBlock);\n      }\n      declaration.done(JavaElementType.CLASS_INITIALIZER);\n      return declaration;\n    }\n    else {\n      final PsiBuilder.Marker error;\n      if (typeParams != null) {\n        error = typeParams.precede();\n      }\n      else {\n        error = builder.mark();\n      }\n      error.error(JavaErrorMessages.message(\"expected.identifier.or.type\"));\n      declaration.drop();\n      return modList;\n    }\n\n    if (!expect(builder, JavaTokenType.IDENTIFIER)) {\n      if (context == Context.CODE_BLOCK && modListInfo.second) {\n        declaration.rollbackTo();\n        return null;\n      }\n      else {\n        if (typeParams != null) {\n          typeParams.precede().errorBefore(JavaErrorMessages.message(\"unexpected.token\"), type);\n        }\n        builder.error(JavaErrorMessages.message(\"expected.identifier\"));\n        declaration.drop();\n        return modList;\n      }\n    }\n\n    if (builder.getTokenType() == JavaTokenType.LPARENTH) {\n      if (context == Context.CLASS || context == Context.ANNOTATION_INTERFACE) {  // method\n        if (typeParams == null) {\n          emptyElement(type, JavaElementType.TYPE_PARAMETER_LIST);\n        }\n        return parseMethodFromLeftParenth(builder, declaration, (context == Context.ANNOTATION_INTERFACE));\n      }\n    }\n\n    if (typeParams != null) {\n      typeParams.precede().errorBefore(JavaErrorMessages.message(\"unexpected.token\"), type);\n    }\n    return parseFieldOrLocalVariable(builder, declaration, declarationStart, context);\n  }","commit_id":"7f8ba694f25efb528620c72086cbff8f8b2440ec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n\t * @return True unless the noderef is bogus.\n\t */\n\tprivate boolean transferNoderef() {\n\t\tlong xferUID = msg.getLong(DMT.TRANSFER_UID);\n\t\tnoderefLength = msg.getInt(DMT.NODEREF_LENGTH);\n\t\tint paddedLength = msg.getInt(DMT.PADDED_LENGTH);\n\t\tnoderefBuf = OpennetManager.innerWaitForOpennetNoderef(xferUID, paddedLength, noderefLength, source, false, uid, true, this, node);\n\t\tif(noderefBuf == null) {\n\t\t\treturn false;\n\t\t}\n\t\tSimpleFieldSet fs = OpennetManager.validateNoderef(noderefBuf, 0, noderefLength, source, false);\n\t\tif(fs == null) {\n\t\t\tOpennetManager.rejectRef(uid, source, DMT.NODEREF_REJECTED_INVALID, this);\n\t\t\treturn false;\n\t\t}\n\t\t// If we want it, add it and send it.\n\t\ttry {\n\t\t\tif(om.addNewOpennetNode(fs, ConnectionType.ANNOUNCE) != null) {\n\t\t\t\tsendOurRef(source, om.crypto.myCompressedFullRef());\n\t\t\t} else {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Don't need the node\");\n\t\t\t\tsendNotWanted();\n\t\t\t\t// Okay, just route it.\n\t\t\t}\n\t\t} catch (FSParseException e) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Rejecting noderef: \"+e, e);\n\t\t\tOpennetManager.rejectRef(uid, source, DMT.NODEREF_REJECTED_INVALID, this);\n\t\t\treturn false;\n\t\t} catch (PeerParseException e) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Rejecting noderef: \"+e, e);\n\t\t\tOpennetManager.rejectRef(uid, source, DMT.NODEREF_REJECTED_INVALID, this);\n\t\t\treturn false;\n\t\t} catch (ReferenceSignatureVerificationException e) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Rejecting noderef: \"+e, e);\n\t\t\tOpennetManager.rejectRef(uid, source, DMT.NODEREF_REJECTED_INVALID, this);\n\t\t\treturn false;\n\t\t} catch (NotConnectedException e) {\n\t\t\tLogger.normal(this, \"Could not receive noderef, disconnected\");\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}","id":65567,"modified_method":"/**\n\t * @return True unless the noderef is bogus.\n\t */\n\tprivate boolean transferNoderef() {\n\t\tlong xferUID = msg.getLong(DMT.TRANSFER_UID);\n\t\tnoderefLength = msg.getInt(DMT.NODEREF_LENGTH);\n\t\tint paddedLength = msg.getInt(DMT.PADDED_LENGTH);\n\t\tnoderefBuf = OpennetManager.innerWaitForOpennetNoderef(xferUID, paddedLength, noderefLength, source, false, uid, true, this, node);\n\t\tif(noderefBuf == null) {\n\t\t\treturn false;\n\t\t}\n\t\tSimpleFieldSet fs = OpennetManager.validateNoderef(noderefBuf, 0, noderefLength, source, false);\n\t\tif(fs == null) {\n\t\t\tOpennetManager.rejectRef(uid, source, DMT.NODEREF_REJECTED_INVALID, this);\n\t\t\treturn false;\n\t\t}\n\t\t// If we want it, add it and send it.\n\t\ttry {\n\t\t\tif(om.addNewOpennetNode(fs, ConnectionType.ANNOUNCE) != null) {\n\t\t\t\tsendOurRef(source, om.crypto.myCompressedFullRef());\n\t\t\t} else {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Don't need the node\");\n\t\t\t\tsendNotWanted();\n\t\t\t\t// Okay, just route it.\n\t\t\t}\n\t\t} catch (FSParseException e) {\n\t\t\tLogger.warning(this, \"Rejecting noderef: \"+e, e);\n\t\t\tOpennetManager.rejectRef(uid, source, DMT.NODEREF_REJECTED_INVALID, this);\n\t\t\treturn false;\n\t\t} catch (PeerParseException e) {\n\t\t\tLogger.warning(this, \"Rejecting noderef: \"+e, e);\n\t\t\tOpennetManager.rejectRef(uid, source, DMT.NODEREF_REJECTED_INVALID, this);\n\t\t\treturn false;\n\t\t} catch (ReferenceSignatureVerificationException e) {\n\t\t\tLogger.warning(this, \"Rejecting noderef: \"+e, e);\n\t\t\tOpennetManager.rejectRef(uid, source, DMT.NODEREF_REJECTED_INVALID, this);\n\t\t\treturn false;\n\t\t} catch (NotConnectedException e) {\n\t\t\tLogger.normal(this, \"Could not receive noderef, disconnected\");\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}","commit_id":"ffd1472ecf1e4e79c41e99b3638ecca19295b137","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * @return True unless the noderef is bogus.\n\t */\n\tprivate boolean transferNoderef() {\n\t\tlong xferUID = msg.getLong(DMT.TRANSFER_UID);\n\t\tnoderefLength = msg.getInt(DMT.NODEREF_LENGTH);\n\t\tint paddedLength = msg.getInt(DMT.PADDED_LENGTH);\n\t\tnoderefBuf = OpennetManager.innerWaitForOpennetNoderef(xferUID, paddedLength, noderefLength, source, false, uid, true, this, node);\n\t\tif(noderefBuf == null) {\n\t\t\treturn false;\n\t\t}\n\t\tSimpleFieldSet fs = OpennetManager.validateNoderef(noderefBuf, 0, noderefLength, source, false);\n\t\tif(fs == null) {\n\t\t\tOpennetManager.rejectRef(uid, source, DMT.NODEREF_REJECTED_INVALID, this);\n\t\t\treturn false;\n\t\t}\n\t\t// If we want it, add it and send it.\n\t\ttry {\n\t\t\tif(om.addNewOpennetNode(fs, ConnectionType.ANNOUNCE) != null) {\n\t\t\t\tsendOurRef(source, om.crypto.myCompressedFullRef());\n\t\t\t} else {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Don't need the node\");\n\t\t\t\tsendNotWanted();\n\t\t\t\t// Okay, just route it.\n\t\t\t}\n\t\t} catch (FSParseException e) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Rejecting noderef: \"+e, e);\n\t\t\tOpennetManager.rejectRef(uid, source, DMT.NODEREF_REJECTED_INVALID, this);\n\t\t\treturn false;\n\t\t} catch (PeerParseException e) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Rejecting noderef: \"+e, e);\n\t\t\tOpennetManager.rejectRef(uid, source, DMT.NODEREF_REJECTED_INVALID, this);\n\t\t\treturn false;\n\t\t} catch (ReferenceSignatureVerificationException e) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Rejecting noderef: \"+e, e);\n\t\t\tOpennetManager.rejectRef(uid, source, DMT.NODEREF_REJECTED_INVALID, this);\n\t\t\treturn false;\n\t\t} catch (NotConnectedException e) {\n\t\t\tLogger.normal(this, \"Could not receive noderef, disconnected\");\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}","id":65568,"modified_method":"/**\n\t * @return True unless the noderef is bogus.\n\t */\n\tprivate boolean transferNoderef() {\n\t\tlong xferUID = msg.getLong(DMT.TRANSFER_UID);\n\t\tnoderefLength = msg.getInt(DMT.NODEREF_LENGTH);\n\t\tint paddedLength = msg.getInt(DMT.PADDED_LENGTH);\n\t\tnoderefBuf = OpennetManager.innerWaitForOpennetNoderef(xferUID, paddedLength, noderefLength, source, false, uid, true, this, node);\n\t\tif(noderefBuf == null) {\n\t\t\treturn false;\n\t\t}\n\t\tSimpleFieldSet fs = OpennetManager.validateNoderef(noderefBuf, 0, noderefLength, source, false);\n\t\tif(fs == null) {\n\t\t\tOpennetManager.rejectRef(uid, source, DMT.NODEREF_REJECTED_INVALID, this);\n\t\t\treturn false;\n\t\t}\n\t\t// If we want it, add it and send it.\n\t\ttry {\n\t\t\tif(om.addNewOpennetNode(fs, ConnectionType.ANNOUNCE) != null) {\n\t\t\t\tsendOurRef(source, om.crypto.myCompressedFullRef());\n\t\t\t} else {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Don't need the node\");\n\t\t\t\tsendNotWanted();\n\t\t\t\t// Okay, just route it.\n\t\t\t}\n\t\t} catch (FSParseException e) {\n\t\t\tLogger.warning(this, \"Rejecting noderef: \"+e, e);\n\t\t\tOpennetManager.rejectRef(uid, source, DMT.NODEREF_REJECTED_INVALID, this);\n\t\t\treturn false;\n\t\t} catch (PeerParseException e) {\n\t\t\tLogger.warning(this, \"Rejecting noderef: \"+e, e);\n\t\t\tOpennetManager.rejectRef(uid, source, DMT.NODEREF_REJECTED_INVALID, this);\n\t\t\treturn false;\n\t\t} catch (ReferenceSignatureVerificationException e) {\n\t\t\tLogger.warning(this, \"Rejecting noderef: \"+e, e);\n\t\t\tOpennetManager.rejectRef(uid, source, DMT.NODEREF_REJECTED_INVALID, this);\n\t\t\treturn false;\n\t\t} catch (NotConnectedException e) {\n\t\t\tLogger.normal(this, \"Could not receive noderef, disconnected\");\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}","commit_id":"a6a5836dea1a860129a18f6dff06de92f4d6a930","url":"https://github.com/freenet/fred"},{"original_method":"private void handleNoContextsException(NoContextsException e,\n\t\t\tfreenet.node.FNPPacketMangler.NoContextsException.CONTEXT context) {\n\t\tif(node.getUptime() < 30*1000) {\n\t\t\tif(logMINOR) Logger.minor(this, \"No contexts available, unable to handle or send packet (\"+context+\") on \"+this);\n\t\t\treturn;\n\t\t}\n\t\t// Log it immediately.\n\t\tLogger.warning(this, \"No contexts available \"+context+\" - running out of entropy or severe CPU usage problems?\");\n\t\t// More loudly periodically.\n\t\tlong now = System.currentTimeMillis();\n\t\tsynchronized(this) {\n\t\t\tif(now < lastLoggedNoContexts + LOG_NO_CONTEXTS_INTERVAL)\n\t\t\t\treturn;\n\t\t\tlastLoggedNoContexts = now;\n\t\t}\n\t\tlogLoudErrorNoContexts();\n\t}","id":65569,"modified_method":"private void handleNoContextsException(NoContextsException e,\n\t\t\tfreenet.node.FNPPacketMangler.NoContextsException.CONTEXT context) {\n\t\tif(node.getUptime() < 30*1000) {\n\t\t\tLogger.warning(this, \"No contexts available, unable to handle or send packet (\"+context+\") on \"+this);\n\t\t\treturn;\n\t\t}\n\t\t// Log it immediately.\n\t\tLogger.warning(this, \"No contexts available \"+context+\" - running out of entropy or severe CPU usage problems?\");\n\t\t// More loudly periodically.\n\t\tlong now = System.currentTimeMillis();\n\t\tsynchronized(this) {\n\t\t\tif(now < lastLoggedNoContexts + LOG_NO_CONTEXTS_INTERVAL)\n\t\t\t\treturn;\n\t\t\tlastLoggedNoContexts = now;\n\t\t}\n\t\tlogLoudErrorNoContexts();\n\t}","commit_id":"5170e711b5a7652fcf88181aea49b472e5924124","url":"https://github.com/freenet/fred"},{"original_method":"public boolean maybeSendPacket(long now, Vector<ResendPacketItem> rpiTemp, int[] rpiIntTemp)\n\t                throws BlockedTooLongException {\n\t\tSentPacket sentPacket = new SentPacket();\n\t\tint maxPacketSize = pn.crypto.socket.getMaxPacketSize();\n\t\tNPFPacket packet = new NPFPacket();\n\t\tpacket.setSequenceNumber(nextSequenceNumber++);\n\n\t\tint numAcks = 0;\n\t\tsynchronized(acks) {\n\t\t\tlong firstAck = 0;\n\t\t\tIterator<Long> it = acks.iterator();\n\t\t\twhile (it.hasNext() && numAcks < 256 && packet.getLength() < maxPacketSize) {\n\t\t\t\tlong ack = it.next();\n\t\t\t\tif(numAcks == 0) {\n\t\t\t\t\tfirstAck = ack;\n\t\t\t\t} else {\n\t\t\t\t\t// Check that it can be compressed\n\t\t\t\t\tlong compressedAck = ack - firstAck;\n\t\t\t\t\tif((compressedAck < 0) || (compressedAck > 255)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpacket.addAck(ack);\n\t\t\t\t++numAcks;\n\t\t\t\tit.remove();\n\t\t\t}\n\t\t}\n\n\t\t//Try to finish messages that have been started\n\t\tsynchronized(started) {\n\t\t\tIterator<MessageWrapper> it = started.values().iterator();\n\t\t\twhile(it.hasNext() && packet.getLength() < maxPacketSize) {\n\t\t\t\tMessageWrapper wrapper = it.next();\n\t\t\t\tMessageFragment frag = wrapper.getMessageFragment(maxPacketSize - packet.getLength());\n\t\t\t\tif(frag == null) continue;\n\t\t\t\tpacket.addMessageFragment(frag);\n\t\t\t\tsentPacket.addFragment(wrapper, frag.fragmentOffset, frag.fragmentLength);\n\t\t\t}\n\t\t}\n\n\t\t//Add messages from the message queue\n\t\tPeerMessageQueue messageQueue = pn.getMessageQueue();\n\t\twhile ((packet.getLength() + 10) < maxPacketSize) { //Fragment header is max 9 bytes, allow min 1 byte data\n\t\t\tMessageItem item = null;\n\t\t\tsynchronized(messageQueue) {\n\t\t\t\titem = messageQueue.grabQueuedMessageItem();\n\t\t\t}\n\t\t\tif(item == null) break;\n\n\t\t\tint messageID = getMessageID();\n\t\t\tif(messageID == -1) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"No availiable message ID, requeuing and sending packet\");\n\t\t\t\tmessageQueue.pushfrontPrioritizedMessageItem(item);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tMessageWrapper wrapper = new MessageWrapper(item, messageID);\n\t\t\tMessageFragment frag = wrapper.getMessageFragment(maxPacketSize - packet.getLength());\n\t\t\tif(frag == null) break;\n\t\t\tpacket.addMessageFragment(frag);\n\t\t\tsentPacket.addFragment(wrapper, frag.fragmentOffset, frag.fragmentLength);\n\n\t\t\tsynchronized(started) {\n\t\t\t\tstarted.put(messageID, wrapper);\n\t\t\t}\n\t\t}\n\n\t\tif(packet.getLength() == 5) return false;\n\n\t\tbyte[] data = new byte[packet.getLength() + HMAC_LENGTH];\n\t\tpacket.toBytes(data, HMAC_LENGTH);\n\n\t\tSessionKey sessionKey = pn.getCurrentKeyTracker();\n\t\tif(sessionKey == null) {\n\t\t\tLogger.warning(this, \"No key for encrypting hash\");\n\t\t\tsentPacket.lost();\n\t\t\treturn false;\n\t\t}\n\n\t\tPCFBMode payloadCipher = PCFBMode.create(sessionKey.sessionCipher);\n\t\tpayloadCipher.blockEncipher(data, HMAC_LENGTH, packet.getLength());\n\n\t\t//Add hash\n\t\tMessageDigest md = SHA256.getMessageDigest();\n\t\tmd.update(data, HMAC_LENGTH, packet.getLength());\n\t\tbyte[] hash = md.digest();\n\n\t\tPCFBMode hashCipher = PCFBMode.create(sessionKey.sessionCipher);\n\t\thashCipher.blockEncipher(hash, 0, HMAC_LENGTH);\n\n\t\tSystem.arraycopy(hash, 0, data, 0, HMAC_LENGTH);\n\n\t\ttry {\n\t                pn.crypto.socket.sendPacket(data, pn.getPeer(), pn.allowLocalAddresses());\n                } catch (LocalAddressException e) {\n\t                Logger.error(this, \"Caught exception while sending packet\", e);\n\t\t\tsentPacket.lost();\n\t\t\treturn false;\n                }\n\n\t\tsynchronized(sentPackets) {\n\t\t\tsentPackets.put(packet.getSequenceNumber(), sentPacket);\n\t\t}\n\t\treturn true;\n\t}","id":65570,"modified_method":"public boolean maybeSendPacket(long now, Vector<ResendPacketItem> rpiTemp, int[] rpiIntTemp)\n\t                throws BlockedTooLongException {\n\t\tSentPacket sentPacket = new SentPacket();\n\t\tint maxPacketSize = pn.crypto.socket.getMaxPacketSize();\n\t\tNPFPacket packet = new NPFPacket();\n\t\tpacket.setSequenceNumber(nextSequenceNumber++);\n\n\t\tint numAcks = 0;\n\t\tsynchronized(acks) {\n\t\t\tlong firstAck = 0;\n\t\t\tIterator<Long> it = acks.iterator();\n\t\t\twhile (it.hasNext() && numAcks < 256 && packet.getLength() < maxPacketSize) {\n\t\t\t\tlong ack = it.next();\n\t\t\t\tif(numAcks == 0) {\n\t\t\t\t\tfirstAck = ack;\n\t\t\t\t} else {\n\t\t\t\t\t// Check that it can be compressed\n\t\t\t\t\tlong compressedAck = ack - firstAck;\n\t\t\t\t\tif((compressedAck < 0) || (compressedAck > 255)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpacket.addAck(ack);\n\t\t\t\t++numAcks;\n\t\t\t\tit.remove();\n\t\t\t}\n\t\t}\n\n\t\t//Try to finish messages that have been started\n\t\tsynchronized(started) {\n\t\t\tIterator<MessageWrapper> it = started.values().iterator();\n\t\t\twhile(it.hasNext() && packet.getLength() < maxPacketSize) {\n\t\t\t\tMessageWrapper wrapper = it.next();\n\t\t\t\tMessageFragment frag = wrapper.getMessageFragment(maxPacketSize - packet.getLength());\n\t\t\t\tif(frag == null) continue;\n\t\t\t\tpacket.addMessageFragment(frag);\n\t\t\t\tsentPacket.addFragment(wrapper, frag.fragmentOffset, frag.fragmentLength);\n\t\t\t}\n\t\t}\n\n\t\t//Add messages from the message queue\n\t\tPeerMessageQueue messageQueue = pn.getMessageQueue();\n\t\twhile ((packet.getLength() + 10) < maxPacketSize) { //Fragment header is max 9 bytes, allow min 1 byte data\n\t\t\tMessageItem item = null;\n\t\t\tsynchronized(messageQueue) {\n\t\t\t\titem = messageQueue.grabQueuedMessageItem();\n\t\t\t}\n\t\t\tif(item == null) break;\n\n\t\t\tint messageID = getMessageID();\n\t\t\tif(messageID == -1) {\n\t\t\t\tLogger.warning(this, \"No availiable message ID, requeuing and sending packet\");\n\t\t\t\tmessageQueue.pushfrontPrioritizedMessageItem(item);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tMessageWrapper wrapper = new MessageWrapper(item, messageID);\n\t\t\tMessageFragment frag = wrapper.getMessageFragment(maxPacketSize - packet.getLength());\n\t\t\tif(frag == null) break;\n\t\t\tpacket.addMessageFragment(frag);\n\t\t\tsentPacket.addFragment(wrapper, frag.fragmentOffset, frag.fragmentLength);\n\n\t\t\tsynchronized(started) {\n\t\t\t\tstarted.put(messageID, wrapper);\n\t\t\t}\n\t\t}\n\n\t\tif(packet.getLength() == 5) return false;\n\n\t\tbyte[] data = new byte[packet.getLength() + HMAC_LENGTH];\n\t\tpacket.toBytes(data, HMAC_LENGTH);\n\n\t\tSessionKey sessionKey = pn.getCurrentKeyTracker();\n\t\tif(sessionKey == null) {\n\t\t\tLogger.warning(this, \"No key for encrypting hash\");\n\t\t\tsentPacket.lost();\n\t\t\treturn false;\n\t\t}\n\n\t\tPCFBMode payloadCipher = PCFBMode.create(sessionKey.sessionCipher);\n\t\tpayloadCipher.blockEncipher(data, HMAC_LENGTH, packet.getLength());\n\n\t\t//Add hash\n\t\tMessageDigest md = SHA256.getMessageDigest();\n\t\tmd.update(data, HMAC_LENGTH, packet.getLength());\n\t\tbyte[] hash = md.digest();\n\n\t\tPCFBMode hashCipher = PCFBMode.create(sessionKey.sessionCipher);\n\t\thashCipher.blockEncipher(hash, 0, HMAC_LENGTH);\n\n\t\tSystem.arraycopy(hash, 0, data, 0, HMAC_LENGTH);\n\n\t\ttry {\n\t                pn.crypto.socket.sendPacket(data, pn.getPeer(), pn.allowLocalAddresses());\n                } catch (LocalAddressException e) {\n\t                Logger.error(this, \"Caught exception while sending packet\", e);\n\t\t\tsentPacket.lost();\n\t\t\treturn false;\n                }\n\n\t\tsynchronized(sentPackets) {\n\t\t\tsentPackets.put(packet.getSequenceNumber(), sentPacket);\n\t\t}\n\t\treturn true;\n\t}","commit_id":"d2a1fedd5488cfefa6b7a5993772e44272607a18","url":"https://github.com/freenet/fred"},{"original_method":"private NPFPacket tryDecipherPacket(byte[] buf, int offset, int length, SessionKey sessionKey) {\n\t\t// Create the watchlist if the key has changed\n\t\tif(watchListKey == null || !watchListKey.equals(sessionKey)) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Creating watchlist starting at \" + watchListOffset);\n\n\t\t\twatchListKey = sessionKey;\n\t\t\tseqNumWatchList = new byte[NUM_SEQNUMS_TO_WATCH_FOR][4];\n\t\t\twatchListPointer = 0;\n\n\t\t\tint seqNum = watchListOffset;\n\t\t\tfor(int i = 0; i < seqNumWatchList.length; i++) {\n\t\t\t\tseqNumWatchList[i] = encryptSequenceNumber(seqNum++, sessionKey);\n\t\t\t\tif((seqNum == NUM_SEQNUMS) || (seqNum < 0)) seqNum = 0;\n\t\t\t}\n\t\t}\n\n\t\t// Move the watchlist if needed\n\t\tint highestReceivedSeqNum;\n\t\tsynchronized(this) {\n\t\t\thighestReceivedSeqNum = highestReceivedSequenceNumber;\n\t\t}\n\t\t// The entry for the highest received sequence number is kept in the middle of the list\n\t\tint oldHighestReceived = (int) ((0l + watchListOffset + (seqNumWatchList.length / 2)) % NUM_SEQNUMS);\n\t\tif(seqNumGreaterThan(highestReceivedSeqNum, oldHighestReceived, 31)) {\n\t\t\tint moveBy;\n\t\t\tif(highestReceivedSeqNum > oldHighestReceived) {\n\t\t\t\tmoveBy = highestReceivedSeqNum - oldHighestReceived;\n\t\t\t} else {\n\t\t\t\tmoveBy = ((int) (NUM_SEQNUMS - oldHighestReceived)) + highestReceivedSeqNum;\n\t\t\t}\n\n\t\t\tif(moveBy > seqNumWatchList.length) {\n\t\t\t\tLogger.warning(this, \"Moving watchlist pointer by \" + moveBy);\n\t\t\t} else if(moveBy < 0) {\n\t\t\t\t//Tends to happen on startup when not starting at seqnum 0 and highestReceived has been\n\t\t\t\t//set wrong and then go away, so log at minor and ignore it for now\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Tried moving watchlist pointer by \" + moveBy);\n\t\t\t\tmoveBy = 0;\n\t\t\t} else {\n\t\t\t\tif(logDEBUG) Logger.debug(this, \"Moving watchlist pointer by \" + moveBy);\n\t\t\t}\n\n\t\t\tint seqNum = (int) ((0l + watchListOffset + seqNumWatchList.length) % NUM_SEQNUMS);\n\t\t\tfor(int i = watchListPointer; i < (watchListPointer + moveBy); i++) {\n\t\t\t\tseqNumWatchList[i % seqNumWatchList.length] = encryptSequenceNumber(seqNum++, sessionKey);\n\t\t\t\tif(seqNum == NUM_SEQNUMS) seqNum = 0;\n\t\t\t}\n\n\t\t\twatchListPointer = (watchListPointer + moveBy) % seqNumWatchList.length;\n\t\t\twatchListOffset = (int) ((0l + watchListOffset + moveBy) % NUM_SEQNUMS);\n\t\t}\n\nouter:\n\t\tfor(int i = 0; i < seqNumWatchList.length; i++) {\n\t\t\tint index = (watchListPointer + i) % seqNumWatchList.length;\n\t\t\tfor(int j = 0; j < seqNumWatchList[index].length; j++) {\n\t\t\t\tif(seqNumWatchList[index][j] != buf[offset + HMAC_LENGTH + j]) continue outer;\n\t\t\t}\n\t\t\t\n\t\t\tint sequenceNumber = (int) ((0l + watchListOffset + i) % NUM_SEQNUMS);\n\t\t\tif(logDEBUG) Logger.debug(this, \"Received packet matches sequence number \" + sequenceNumber);\n\t\t\tNPFPacket p = decipherFromSeqnum(buf, offset, length, sessionKey, sequenceNumber);\n\t\t\tif(p != null) return p;\n\t\t}\n\n\t\treturn null;\n\t}","id":65571,"modified_method":"private NPFPacket tryDecipherPacket(byte[] buf, int offset, int length, SessionKey sessionKey) {\n\t\t// Create the watchlist if the key has changed\n\t\tif(watchListKey == null || !watchListKey.equals(sessionKey)) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Creating watchlist starting at \" + watchListOffset);\n\n\t\t\twatchListKey = sessionKey;\n\t\t\tseqNumWatchList = new byte[NUM_SEQNUMS_TO_WATCH_FOR][4];\n\t\t\twatchListPointer = 0;\n\n\t\t\tint seqNum = watchListOffset;\n\t\t\tfor(int i = 0; i < seqNumWatchList.length; i++) {\n\t\t\t\tseqNumWatchList[i] = encryptSequenceNumber(seqNum++, sessionKey);\n\t\t\t\tif((seqNum == NUM_SEQNUMS) || (seqNum < 0)) seqNum = 0;\n\t\t\t}\n\t\t}\n\n\t\t// Move the watchlist if needed\n\t\tint highestReceivedSeqNum;\n\t\tsynchronized(this) {\n\t\t\thighestReceivedSeqNum = highestReceivedSequenceNumber;\n\t\t}\n\t\t// The entry for the highest received sequence number is kept in the middle of the list\n\t\tint oldHighestReceived = (int) ((0l + watchListOffset + (seqNumWatchList.length / 2)) % NUM_SEQNUMS);\n\t\tif(seqNumGreaterThan(highestReceivedSeqNum, oldHighestReceived, 31)) {\n\t\t\tint moveBy;\n\t\t\tif(highestReceivedSeqNum > oldHighestReceived) {\n\t\t\t\tmoveBy = highestReceivedSeqNum - oldHighestReceived;\n\t\t\t} else {\n\t\t\t\tmoveBy = ((int) (NUM_SEQNUMS - oldHighestReceived)) + highestReceivedSeqNum;\n\t\t\t}\n\n\t\t\tif(moveBy > seqNumWatchList.length) {\n\t\t\t\tLogger.warning(this, \"Moving watchlist pointer by \" + moveBy);\n\t\t\t} else if(moveBy < 0) {\n\t\t\t\tLogger.warning(this, \"Tried moving watchlist pointer by \" + moveBy);\n\t\t\t\tmoveBy = 0;\n\t\t\t} else {\n\t\t\t\tif(logDEBUG) Logger.debug(this, \"Moving watchlist pointer by \" + moveBy);\n\t\t\t}\n\n\t\t\tint seqNum = (int) ((0l + watchListOffset + seqNumWatchList.length) % NUM_SEQNUMS);\n\t\t\tfor(int i = watchListPointer; i < (watchListPointer + moveBy); i++) {\n\t\t\t\tseqNumWatchList[i % seqNumWatchList.length] = encryptSequenceNumber(seqNum++, sessionKey);\n\t\t\t\tif(seqNum == NUM_SEQNUMS) seqNum = 0;\n\t\t\t}\n\n\t\t\twatchListPointer = (watchListPointer + moveBy) % seqNumWatchList.length;\n\t\t\twatchListOffset = (int) ((0l + watchListOffset + moveBy) % NUM_SEQNUMS);\n\t\t}\n\nouter:\n\t\tfor(int i = 0; i < seqNumWatchList.length; i++) {\n\t\t\tint index = (watchListPointer + i) % seqNumWatchList.length;\n\t\t\tfor(int j = 0; j < seqNumWatchList[index].length; j++) {\n\t\t\t\tif(seqNumWatchList[index][j] != buf[offset + HMAC_LENGTH + j]) continue outer;\n\t\t\t}\n\t\t\t\n\t\t\tint sequenceNumber = (int) ((0l + watchListOffset + i) % NUM_SEQNUMS);\n\t\t\tif(logDEBUG) Logger.debug(this, \"Received packet matches sequence number \" + sequenceNumber);\n\t\t\tNPFPacket p = decipherFromSeqnum(buf, offset, length, sessionKey, sequenceNumber);\n\t\t\tif(p != null) return p;\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"85ffa354f1544bdae6db9e196b6df71314f68e78","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n    public List<String> getScheduleIds(Id.Program program, ProgramType programType) {\n      Preconditions.checkNotNull(scheduler, \"Scheduler not yet initialized\");\n\n      List<String> scheduleIds = Lists.newArrayList();\n      String key = getJobKey(program, programType);\n      try {\n        for (Trigger trigger : scheduler.getTriggersOfJob(new JobKey(key))) {\n          scheduleIds.add(trigger.getKey().getName());\n        }\n      }   catch (SchedulerException e) {\n        throw Throwables.propagate(e);\n      }\n      return scheduleIds;\n    }","id":65572,"modified_method":"@Override\n    public List<String> getScheduleIds(Id.Program program, ProgramType programType) {\n      checkInitialized();\n\n      List<String> scheduleIds = Lists.newArrayList();\n      try {\n        for (Trigger trigger : scheduler.getTriggersOfJob(getJobKey(program, programType))) {\n          scheduleIds.add(trigger.getKey().getName());\n        }\n      }   catch (SchedulerException e) {\n        throw Throwables.propagate(e);\n      }\n      return scheduleIds;\n    }","commit_id":"87d0225df2c5eb607f739ac98d2d761800a94122","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public void deleteSchedules(Id.Program program, ProgramType programType, List<String> scheduleIds) {\n      Preconditions.checkNotNull(scheduler, \"Scheduler not yet initialized\");\n      try {\n        for (String scheduleId : scheduleIds) {\n          scheduler.pauseTrigger(new TriggerKey(scheduleId));\n        }\n        String key = getJobKey(program, programType);\n        scheduler.deleteJob(new JobKey(key));\n      } catch (SchedulerException e) {\n        throw Throwables.propagate(e);\n      }\n    }","id":65573,"modified_method":"@Override\n    public void deleteAssociatedSchedules(Id.Program program, ProgramType programType) {\n      checkInitialized();\n      try {\n        scheduler.deleteJob(getJobKey(program, programType));\n      } catch (SchedulerException e) {\n        throw Throwables.propagate(e);\n      }\n    }","commit_id":"87d0225df2c5eb607f739ac98d2d761800a94122","url":"https://github.com/caskdata/cdap"},{"original_method":"private String getJobKey(Id.Program program, ProgramType programType) {\n      return String.format(\"%s:%s:%s:%s\", programType.name(), program.getAccountId(),\n                           program.getApplicationId(), program.getId());\n    }","id":65574,"modified_method":"private JobKey getJobKey(Id.Program program, ProgramType programType) {\n      return new JobKey(String.format(\"%s:%s:%s:%s\", programType.name(), program.getAccountId(),\n                                      program.getApplicationId(), program.getId()));\n    }","commit_id":"87d0225df2c5eb607f739ac98d2d761800a94122","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public void resumeSchedule(String scheduleId) {\n      Preconditions.checkNotNull(scheduler, \"Scheduler not yet initialized\");\n      try {\n        scheduler.resumeTrigger(new TriggerKey(scheduleId));\n      } catch (SchedulerException e) {\n        throw Throwables.propagate(e);\n      }\n    }","id":65575,"modified_method":"@Override\n    public void resumeSchedule(String scheduleId) {\n      checkInitialized();\n      try {\n        scheduler.resumeTrigger(new TriggerKey(scheduleId));\n      } catch (SchedulerException e) {\n        throw Throwables.propagate(e);\n      }\n    }","commit_id":"87d0225df2c5eb607f739ac98d2d761800a94122","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public void suspendSchedule(String scheduleId) {\n      Preconditions.checkNotNull(scheduler, \"Scheduler not yet initialized\");\n      try {\n        scheduler.pauseTrigger(new TriggerKey(scheduleId));\n      } catch (SchedulerException e) {\n        throw Throwables.propagate(e);\n      }\n    }","id":65576,"modified_method":"@Override\n    public void suspendSchedule(String scheduleId) {\n      checkInitialized();\n      try {\n        scheduler.pauseTrigger(new TriggerKey(scheduleId));\n      } catch (SchedulerException e) {\n        throw Throwables.propagate(e);\n      }\n    }","commit_id":"87d0225df2c5eb607f739ac98d2d761800a94122","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public List<ScheduledRuntime> nextScheduledRuntime(Id.Program program, ProgramType programType) {\n      Preconditions.checkNotNull(scheduler, \"Scheduler not yet initialized\");\n\n      List<ScheduledRuntime> scheduledRuntimes = Lists.newArrayList();\n      String key = getJobKey(program, programType);\n      try {\n        for (Trigger trigger : scheduler.getTriggersOfJob(new JobKey(key))) {\n          ScheduledRuntime runtime = new ScheduledRuntime(trigger.getKey().toString(),\n                                                          trigger.getNextFireTime().getTime());\n          scheduledRuntimes.add(runtime);\n        }\n      } catch (SchedulerException e) {\n        throw Throwables.propagate(e);\n      }\n      return scheduledRuntimes;\n    }","id":65577,"modified_method":"@Override\n    public List<ScheduledRuntime> nextScheduledRuntime(Id.Program program, ProgramType programType) {\n      checkInitialized();\n\n      List<ScheduledRuntime> scheduledRuntimes = Lists.newArrayList();\n      try {\n        for (Trigger trigger : scheduler.getTriggersOfJob(getJobKey(program, programType))) {\n          ScheduledRuntime runtime = new ScheduledRuntime(trigger.getKey().toString(),\n                                                          trigger.getNextFireTime().getTime());\n          scheduledRuntimes.add(runtime);\n        }\n      } catch (SchedulerException e) {\n        throw Throwables.propagate(e);\n      }\n      return scheduledRuntimes;\n    }","commit_id":"87d0225df2c5eb607f739ac98d2d761800a94122","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public ScheduleState scheduleState(String scheduleId) {\n      Preconditions.checkNotNull(scheduler, \"Scheduler not yet initialized\");\n      try {\n        Trigger.TriggerState state = scheduler.getTriggerState(new TriggerKey(scheduleId));\n        // Map trigger state to schedule state.\n        // This method is only interested in returning if the scheduler is\n        // Paused, Scheduled or NotFound.\n        switch (state) {\n          case NONE:\n            return ScheduleState.NOT_FOUND;\n          case PAUSED:\n            return ScheduleState.SUSPENDED;\n          default:\n            return ScheduleState.SCHEDULED;\n        }\n      } catch (SchedulerException e) {\n        throw Throwables.propagate(e);\n      }\n    }","id":65578,"modified_method":"@Override\n    public ScheduleState scheduleState(String scheduleId) {\n      checkInitialized();\n      try {\n        Trigger.TriggerState state = scheduler.getTriggerState(new TriggerKey(scheduleId));\n        // Map trigger state to schedule state.\n        // This method is only interested in returning if the scheduler is\n        // Paused, Scheduled or NotFound.\n        switch (state) {\n          case NONE:\n            return ScheduleState.NOT_FOUND;\n          case PAUSED:\n            return ScheduleState.SUSPENDED;\n          default:\n            return ScheduleState.SCHEDULED;\n        }\n      } catch (SchedulerException e) {\n        throw Throwables.propagate(e);\n      }\n    }","commit_id":"87d0225df2c5eb607f739ac98d2d761800a94122","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public void schedule(Id.Program programId, ProgramType programType, Iterable<Schedule> schedules) {\n      Preconditions.checkNotNull(scheduler, \"Scheduler not yet initialized\");\n      Preconditions.checkNotNull(schedules);\n\n      String key = getJobKey(programId, programType);\n      JobDetail job = JobBuilder.newJob(DefaultSchedulerService.ScheduledJob.class)\n        .withIdentity(key)\n        .storeDurably(true)\n        .build();\n      try {\n        scheduler.addJob(job, true);\n      } catch (SchedulerException e) {\n        throw Throwables.propagate(e);\n      }\n      int idx = 0;\n      for (Schedule schedule : schedules) {\n        String scheduleName = schedule.getName();\n        String cronEntry = schedule.getCronEntry();\n        String triggerKey = String.format(\"%s:%s:%s:%s:%d:%s\",\n                                          programType.name(), programId.getAccountId(),\n                                          programId.getApplicationId(), programId.getId(), idx, schedule.getName());\n\n        LOG.debug(\"Scheduling job {} with cron {}\", scheduleName, cronEntry);\n\n        Trigger trigger = TriggerBuilder.newTrigger()\n          .withIdentity(triggerKey)\n          .forJob(job)\n          .withSchedule(CronScheduleBuilder\n                          .cronSchedule(getQuartzCronExpression(cronEntry)))\n          .build();\n        try {\n          scheduler.scheduleJob(trigger);\n        } catch (SchedulerException e) {\n          throw Throwables.propagate(e);\n        }\n      }\n    }","id":65579,"modified_method":"@Override\n    public void schedule(Id.Program programId, ProgramType programType, Iterable<Schedule> schedules) {\n      checkInitialized();\n      Preconditions.checkNotNull(schedules);\n\n      String jobKey = getJobKey(programId, programType).getName();\n      JobDetail job = JobBuilder.newJob(DefaultSchedulerService.ScheduledJob.class)\n        .withIdentity(jobKey)\n        .storeDurably(true)\n        .build();\n      try {\n        scheduler.addJob(job, true);\n      } catch (SchedulerException e) {\n        throw Throwables.propagate(e);\n      }\n      for (Schedule schedule : schedules) {\n        String scheduleName = schedule.getName();\n        String cronEntry = schedule.getCronEntry();\n        String triggerKey = String.format(\"%s:%s\", jobKey, scheduleName);\n\n        LOG.debug(\"Scheduling job {} with cron {}\", scheduleName, cronEntry);\n\n        Trigger trigger = TriggerBuilder.newTrigger()\n          .withIdentity(triggerKey)\n          .forJob(job)\n          .withSchedule(CronScheduleBuilder\n                          .cronSchedule(getQuartzCronExpression(cronEntry)))\n          .build();\n        try {\n          scheduler.scheduleJob(trigger);\n        } catch (SchedulerException e) {\n          throw Throwables.propagate(e);\n        }\n      }\n    }","commit_id":"87d0225df2c5eb607f739ac98d2d761800a94122","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void deleteSchedules(Id.Program program, ProgramType programType,\n                              List<String> scheduleIds) {\n    delegate.deleteSchedules(program, programType, scheduleIds);\n  }","id":65580,"modified_method":"@Override\n  public void deleteAssociatedSchedules(Id.Program program, ProgramType programType) {\n    delegate.deleteAssociatedSchedules(program, programType);\n  }","commit_id":"87d0225df2c5eb607f739ac98d2d761800a94122","url":"https://github.com/caskdata/cdap"},{"original_method":"private Scheduler createNoopScheduler() {\n    return new Scheduler() {\n      @Override\n      public void schedule(Id.Program program, ProgramType programType, Iterable<Schedule> schedules) {\n      }\n\n      @Override\n      public List<ScheduledRuntime> nextScheduledRuntime(Id.Program program, ProgramType programType) {\n        return ImmutableList.of();\n      }\n\n      @Override\n      public List<String> getScheduleIds(Id.Program program, ProgramType programType) {\n        return ImmutableList.of();\n      }\n\n      @Override\n      public void suspendSchedule(String scheduleId) {\n      }\n\n      @Override\n      public void resumeSchedule(String scheduleId) {\n      }\n\n      @Override\n      public void deleteSchedules(Id.Program programId, ProgramType programType, List<String> scheduleIds) {\n      }\n\n      @Override\n      public ScheduleState scheduleState(String scheduleId) {\n        return ScheduleState.NOT_FOUND;\n      }\n    };\n  }","id":65581,"modified_method":"private Scheduler createNoopScheduler() {\n    return new Scheduler() {\n      @Override\n      public void schedule(Id.Program program, ProgramType programType, Iterable<Schedule> schedules) {\n      }\n\n      @Override\n      public List<ScheduledRuntime> nextScheduledRuntime(Id.Program program, ProgramType programType) {\n        return ImmutableList.of();\n      }\n\n      @Override\n      public List<String> getScheduleIds(Id.Program program, ProgramType programType) {\n        return ImmutableList.of();\n      }\n\n      @Override\n      public void suspendSchedule(String scheduleId) {\n      }\n\n      @Override\n      public void resumeSchedule(String scheduleId) {\n      }\n\n      @Override\n      public void deleteSchedule(String scheduleId) {\n      }\n\n      @Override\n      public void deleteAssociatedSchedules(Id.Program programId, ProgramType programType) {\n      }\n\n      @Override\n      public ScheduleState scheduleState(String scheduleId) {\n        return ScheduleState.NOT_FOUND;\n      }\n    };\n  }","commit_id":"87d0225df2c5eb607f739ac98d2d761800a94122","url":"https://github.com/caskdata/cdap"},{"original_method":"private void setupSchedules(String namespaceId, ApplicationSpecification specification)  throws IOException {\n\n    for (Map.Entry<String, WorkflowSpecification> entry : specification.getWorkflows().entrySet()) {\n      Id.Program programId = Id.Program.from(namespaceId, specification.getName(), entry.getKey());\n      List<String> existingSchedules = scheduler.getScheduleIds(programId, ProgramType.WORKFLOW);\n      //Delete the existing schedules and add new ones.\n      if (!existingSchedules.isEmpty()) {\n        scheduler.deleteSchedules(programId, ProgramType.WORKFLOW, existingSchedules);\n      }\n      // Add new schedules.\n      if (!entry.getValue().getSchedules().isEmpty()) {\n        scheduler.schedule(programId, ProgramType.WORKFLOW, entry.getValue().getSchedules());\n      }\n    }\n  }","id":65582,"modified_method":"private void setupSchedules(String namespaceId, ApplicationSpecification specification)  throws IOException {\n\n    for (Map.Entry<String, WorkflowSpecification> entry : specification.getWorkflows().entrySet()) {\n      Id.Program programId = Id.Program.from(namespaceId, specification.getName(), entry.getKey());\n      //Delete the existing schedules and add new ones.\n      scheduler.deleteAssociatedSchedules(programId, ProgramType.WORKFLOW);\n\n      // Add new schedules.\n      if (!entry.getValue().getSchedules().isEmpty()) {\n        scheduler.schedule(programId, ProgramType.WORKFLOW, entry.getValue().getSchedules());\n      }\n    }\n  }","commit_id":"87d0225df2c5eb607f739ac98d2d761800a94122","url":"https://github.com/caskdata/cdap"},{"original_method":"private AppFabricServiceStatus removeApplication(Id.Program identifier) throws Exception {\n    Id.Account accountId = Id.Account.from(identifier.getAccountId());\n    final Id.Application appId = Id.Application.from(accountId, identifier.getApplicationId());\n\n    //Check if all are stopped.\n    boolean appRunning = checkAnyRunning(new Predicate<Id.Program>() {\n      @Override\n      public boolean apply(Id.Program programId) {\n        return programId.getApplication().equals(appId);\n      }\n    }, ProgramType.values());\n\n    if (appRunning) {\n      return AppFabricServiceStatus.PROGRAM_STILL_RUNNING;\n    }\n\n    ApplicationSpecification spec = store.getApplication(appId);\n    if (spec == null) {\n      return AppFabricServiceStatus.PROGRAM_NOT_FOUND;\n    }\n\n    //Delete the schedules\n    for (WorkflowSpecification workflowSpec : spec.getWorkflows().values()) {\n      Id.Program workflowProgramId = Id.Program.from(appId, workflowSpec.getName());\n      List<String> schedules = scheduler.getScheduleIds(workflowProgramId, ProgramType.WORKFLOW);\n      if (!schedules.isEmpty()) {\n        scheduler.deleteSchedules(workflowProgramId, ProgramType.WORKFLOW, schedules);\n      }\n    }\n\n    deleteMetrics(identifier.getAccountId(), identifier.getApplicationId());\n\n    // Delete all streams and queues state of each flow\n    // TODO: This should be unified with the DeletedProgramHandlerStage\n    for (FlowSpecification flowSpecification : spec.getFlows().values()) {\n      Id.Program flowProgramId = Id.Program.from(appId, flowSpecification.getName());\n\n      // Collects stream name to all group ids consuming that stream\n      Multimap<String, Long> streamGroups = HashMultimap.create();\n      for (FlowletConnection connection : flowSpecification.getConnections()) {\n        if (connection.getSourceType() == FlowletConnection.Type.STREAM) {\n          long groupId = FlowUtils.generateConsumerGroupId(flowProgramId, connection.getTargetName());\n          streamGroups.put(connection.getSourceName(), groupId);\n        }\n      }\n      // Remove all process states and group states for each stream\n      String namespace = String.format(\"%s.%s\", flowProgramId.getApplicationId(), flowProgramId.getId());\n      for (Map.Entry<String, Collection<Long>> entry : streamGroups.asMap().entrySet()) {\n        streamConsumerFactory.dropAll(QueueName.fromStream(entry.getKey()), namespace, entry.getValue());\n      }\n\n      queueAdmin.dropAllForFlow(identifier.getApplicationId(), flowSpecification.getName());\n    }\n    deleteProgramLocations(appId);\n\n    Location appArchive = store.getApplicationArchiveLocation(appId);\n    Preconditions.checkNotNull(appArchive, \"Could not find the location of application\", appId.getId());\n    appArchive.delete();\n    store.removeApplication(appId);\n    return AppFabricServiceStatus.OK;\n  }","id":65583,"modified_method":"private AppFabricServiceStatus removeApplication(Id.Program identifier) throws Exception {\n    Id.Account accountId = Id.Account.from(identifier.getAccountId());\n    final Id.Application appId = Id.Application.from(accountId, identifier.getApplicationId());\n\n    //Check if all are stopped.\n    boolean appRunning = checkAnyRunning(new Predicate<Id.Program>() {\n      @Override\n      public boolean apply(Id.Program programId) {\n        return programId.getApplication().equals(appId);\n      }\n    }, ProgramType.values());\n\n    if (appRunning) {\n      return AppFabricServiceStatus.PROGRAM_STILL_RUNNING;\n    }\n\n    ApplicationSpecification spec = store.getApplication(appId);\n    if (spec == null) {\n      return AppFabricServiceStatus.PROGRAM_NOT_FOUND;\n    }\n\n    //Delete the schedules\n    for (WorkflowSpecification workflowSpec : spec.getWorkflows().values()) {\n      Id.Program workflowProgramId = Id.Program.from(appId, workflowSpec.getName());\n      scheduler.deleteAssociatedSchedules(workflowProgramId, ProgramType.WORKFLOW);\n    }\n\n    deleteMetrics(identifier.getAccountId(), identifier.getApplicationId());\n\n    // Delete all streams and queues state of each flow\n    // TODO: This should be unified with the DeletedProgramHandlerStage\n    for (FlowSpecification flowSpecification : spec.getFlows().values()) {\n      Id.Program flowProgramId = Id.Program.from(appId, flowSpecification.getName());\n\n      // Collects stream name to all group ids consuming that stream\n      Multimap<String, Long> streamGroups = HashMultimap.create();\n      for (FlowletConnection connection : flowSpecification.getConnections()) {\n        if (connection.getSourceType() == FlowletConnection.Type.STREAM) {\n          long groupId = FlowUtils.generateConsumerGroupId(flowProgramId, connection.getTargetName());\n          streamGroups.put(connection.getSourceName(), groupId);\n        }\n      }\n      // Remove all process states and group states for each stream\n      String namespace = String.format(\"%s.%s\", flowProgramId.getApplicationId(), flowProgramId.getId());\n      for (Map.Entry<String, Collection<Long>> entry : streamGroups.asMap().entrySet()) {\n        streamConsumerFactory.dropAll(QueueName.fromStream(entry.getKey()), namespace, entry.getValue());\n      }\n\n      queueAdmin.dropAllForFlow(identifier.getApplicationId(), flowSpecification.getName());\n    }\n    deleteProgramLocations(appId);\n\n    Location appArchive = store.getApplicationArchiveLocation(appId);\n    Preconditions.checkNotNull(appArchive, \"Could not find the location of application\", appId.getId());\n    appArchive.delete();\n    store.removeApplication(appId);\n    return AppFabricServiceStatus.OK;\n  }","commit_id":"87d0225df2c5eb607f739ac98d2d761800a94122","url":"https://github.com/caskdata/cdap"},{"original_method":"private void deleteHandler(Id.Program programId, ProgramType type)\n    throws ExecutionException {\n    try {\n      switch (type) {\n        case FLOW:\n          stopProgramIfRunning(programId, type);\n          break;\n        case PROCEDURE:\n          stopProgramIfRunning(programId, type);\n          break;\n        case WORKFLOW:\n          List<String> scheduleIds = scheduler.getScheduleIds(programId, type);\n          scheduler.deleteSchedules(programId, ProgramType.WORKFLOW, scheduleIds);\n          break;\n        case MAPREDUCE:\n          //no-op\n          break;\n        case SERVICE:\n          stopProgramIfRunning(programId, type);\n          break;\n      }\n    } catch (InterruptedException e) {\n      throw new ExecutionException(e);\n    }\n  }","id":65584,"modified_method":"private void deleteHandler(Id.Program programId, ProgramType type)\n    throws ExecutionException {\n    try {\n      switch (type) {\n        case FLOW:\n          stopProgramIfRunning(programId, type);\n          break;\n        case PROCEDURE:\n          stopProgramIfRunning(programId, type);\n          break;\n        case WORKFLOW:\n          scheduler.deleteAssociatedSchedules(programId, ProgramType.WORKFLOW);\n          break;\n        case MAPREDUCE:\n          //no-op\n          break;\n        case SERVICE:\n          stopProgramIfRunning(programId, type);\n          break;\n      }\n    } catch (InterruptedException e) {\n      throw new ExecutionException(e);\n    }\n  }","commit_id":"87d0225df2c5eb607f739ac98d2d761800a94122","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n    public void testCdiInjectedEjb() {\n        Assert.assertEquals(\"Hello\", injectingCDIBean.sayHello());\n        Assert.assertEquals(\"Goodbye\", injectingCDIBean.sayGoodbye());\n    }","id":65585,"modified_method":"@Test\n    public void testCdiInjectedEjb() {\n        Assert.assertEquals(\"Hello\", injectingCDIBean.sayHello());\n        Assert.assertEquals(\"Goodbye\", injectingCDIBean.sayGoodbye());\n        Assert.assertEquals(\"Interface\", injectingCDIBean.callInterfaceMethod());\n    }","commit_id":"9098cce6d22e25d562bb571505fc2f3cdc850b09","url":"https://github.com/wildfly/wildfly"},{"original_method":"public SessionObjectReferenceImpl(EjbDescriptorImpl<?> descriptor, ServiceRegistry serviceRegistry) {\n        final ServiceName createServiceName = descriptor.getCreateServiceName();\n        final ServiceController<?> controller = serviceRegistry.getRequiredService(createServiceName);\n\n        final Map<String, ServiceName> viewServices = new HashMap<String, ServiceName>();\n        final Map<String, Class<?>> views = new HashMap<String, Class<?>>();\n        for (BusinessInterfaceDescriptor<?> view : descriptor.getRemoteBusinessInterfaces()) {\n            views.put(view.getInterface().getName(), view.getInterface());\n        }\n        for (BusinessInterfaceDescriptor<?> view : descriptor.getLocalBusinessInterfaces()) {\n            views.put(view.getInterface().getName(), view.getInterface());\n        }\n\n        for (ViewDescription view : descriptor.getComponentDescription().getViews()) {\n            final Class<?> viewClass = views.get(view.getViewClassName());\n            if (viewClass != null) {\n                //see WELD-921\n                //this is horrible, but until it is fixed there is not much that can be done\n                Class<?> clazz = viewClass;\n                while (clazz != Object.class && clazz != null) {\n                    viewServices.put(clazz.getName(), view.getServiceName());\n                    clazz = clazz.getSuperclass();\n                }\n            }\n        }\n\n        this.viewServices = viewServices;\n\n    }","id":65586,"modified_method":"public SessionObjectReferenceImpl(EjbDescriptorImpl<?> descriptor, ServiceRegistry serviceRegistry) {\n        final ServiceName createServiceName = descriptor.getCreateServiceName();\n\n        final Map<String, ServiceName> viewServices = new HashMap<String, ServiceName>();\n        final Map<String, Class<?>> views = new HashMap<String, Class<?>>();\n        for (BusinessInterfaceDescriptor<?> view : descriptor.getRemoteBusinessInterfaces()) {\n            views.put(view.getInterface().getName(), view.getInterface());\n        }\n        for (BusinessInterfaceDescriptor<?> view : descriptor.getLocalBusinessInterfaces()) {\n            views.put(view.getInterface().getName(), view.getInterface());\n        }\n\n\n        for (ViewDescription view : descriptor.getComponentDescription().getViews()) {\n            final Class<?> viewClass = views.get(view.getViewClassName());\n            if (viewClass != null) {\n                //see WELD-921\n                //this is horrible, but until it is fixed there is not much that can be done\n\n                final Set<Class<?>> seen = new HashSet<Class<?>>();\n                final Set<Class<?>> toProcess = new HashSet<Class<?>>();\n\n                toProcess.add(viewClass);\n\n                while (!toProcess.isEmpty()) {\n                    Iterator<Class<?>> it = toProcess.iterator();\n                    final Class<?> clazz = it.next();\n                    it.remove();\n                    seen.add(clazz);\n                    viewServices.put(clazz.getName(), view.getServiceName());\n                    final Class<?> superclass = clazz.getSuperclass();\n                    if(superclass != Object.class && superclass != null && !seen.contains(superclass)) {\n                        toProcess.add(superclass);\n                    }\n                    for(Class<?> iface : clazz.getInterfaces()) {\n                        if(!seen.contains(iface)) {\n                            toProcess.add(iface);\n                        }\n                    }\n                }\n            }\n        }\n\n        this.viewServices = viewServices;\n\n    }","commit_id":"9098cce6d22e25d562bb571505fc2f3cdc850b09","url":"https://github.com/wildfly/wildfly"},{"original_method":"public StatefulSessionObjectReferenceImpl(EjbDescriptorImpl<?> descriptor) {\n        createServiceName = descriptor.getCreateServiceName();\n\n        final Map<String, ServiceName> viewServices = new HashMap<String, ServiceName>();\n       final Map<String, Class<?>> views = new HashMap<String, Class<?>>();\n        for (BusinessInterfaceDescriptor<?> view : descriptor.getRemoteBusinessInterfaces()) {\n            views.put(view.getInterface().getName(), view.getInterface());\n        }\n        for (BusinessInterfaceDescriptor<?> view : descriptor.getLocalBusinessInterfaces()) {\n            views.put(view.getInterface().getName(), view.getInterface());\n        }\n\n        for (ViewDescription view : descriptor.getComponentDescription().getViews()) {\n            final Class<?> viewClass = views.get(view.getViewClassName());\n            if (viewClass != null) {\n                //see WELD-921\n                //this is horrible, but until it is fixed there is not much that can be done\n                Class<?> clazz = viewClass;\n                while (clazz != Object.class && clazz != null) {\n                    viewServices.put(clazz.getName(), view.getServiceName());\n                    clazz = clazz.getSuperclass();\n                }\n            }\n        }\n        id = getComponent().createSession();\n        this.viewServices = viewServices;\n\n    }","id":65587,"modified_method":"public StatefulSessionObjectReferenceImpl(EjbDescriptorImpl<?> descriptor) {\n        createServiceName = descriptor.getCreateServiceName();\n\n        final Map<String, ServiceName> viewServices = new HashMap<String, ServiceName>();\n        final Map<String, Class<?>> views = new HashMap<String, Class<?>>();\n        for (BusinessInterfaceDescriptor<?> view : descriptor.getRemoteBusinessInterfaces()) {\n            views.put(view.getInterface().getName(), view.getInterface());\n        }\n        for (BusinessInterfaceDescriptor<?> view : descriptor.getLocalBusinessInterfaces()) {\n            views.put(view.getInterface().getName(), view.getInterface());\n        }\n\n        for (ViewDescription view : descriptor.getComponentDescription().getViews()) {\n            final Class<?> viewClass = views.get(view.getViewClassName());\n            if (viewClass != null) {\n                //see WELD-921\n                //this is horrible, but until it is fixed there is not much that can be done\n\n                final Set<Class<?>> seen = new HashSet<Class<?>>();\n                final Set<Class<?>> toProcess = new HashSet<Class<?>>();\n\n                toProcess.add(viewClass);\n\n                while (!toProcess.isEmpty()) {\n                    Iterator<Class<?>> it = toProcess.iterator();\n                    final Class<?> clazz = it.next();\n                    it.remove();\n                    seen.add(clazz);\n                    viewServices.put(clazz.getName(), view.getServiceName());\n                    final Class<?> superclass = clazz.getSuperclass();\n                    if (superclass != Object.class && superclass != null && !seen.contains(superclass)) {\n                        toProcess.add(superclass);\n                    }\n                    for (Class<?> iface : clazz.getInterfaces()) {\n                        if (!seen.contains(iface)) {\n                            toProcess.add(iface);\n                        }\n                    }\n                }\n            }\n        }\n        id = getComponent().createSession();\n        this.viewServices = viewServices;\n\n    }","commit_id":"9098cce6d22e25d562bb571505fc2f3cdc850b09","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** Writes the value, writing the class of the object if it differs from the specified known type. The specified element type is\r\n\t * used as the default type for collections.\r\n\t * @param value May be null.\r\n\t * @param knownType May be null if the type is unknown.\r\n\t * @param elementType May be null if the type is unknown. */\r\n\tpublic void writeValue (Object value, Class knownType, Class elementType) {\r\n\t\ttry {\r\n\t\t\tif (value == null) {\r\n\t\t\t\twriter.value(null);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif ((knownType != null && knownType.isPrimitive()) || knownType == String.class || knownType == Integer.class\r\n\t\t\t\t|| knownType == Boolean.class || knownType == Float.class || knownType == Long.class || knownType == Double.class\r\n\t\t\t\t|| knownType == Short.class || knownType == Byte.class || knownType == Character.class) {\r\n\t\t\t\twriter.value(value);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tClass actualType = value.getClass();\r\n\r\n\t\t\tif (actualType.isPrimitive() || actualType == String.class || actualType == Integer.class || actualType == Boolean.class\r\n\t\t\t\t|| actualType == Float.class || actualType == Long.class || actualType == Double.class || actualType == Short.class\r\n\t\t\t\t|| actualType == Byte.class || actualType == Character.class) {\r\n\t\t\t\twriteObjectStart(actualType, null);\r\n\t\t\t\twriteValue(\"value\", value);\r\n\t\t\t\twriteObjectEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (value instanceof Serializable) {\r\n\t\t\t\twriteObjectStart(actualType, knownType);\r\n\t\t\t\t((Serializable)value).write(this);\r\n\t\t\t\twriteObjectEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tSerializer serializer = classToSerializer.get(actualType);\r\n\t\t\tif (serializer != null) {\r\n\t\t\t\tserializer.write(this, value, knownType);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (value instanceof Array) {\r\n\t\t\t\tif (knownType != null && actualType != knownType && actualType != Array.class)\r\n\t\t\t\t\tthrow new SerializationException(\"Serialization of an Array other than the known type is not supported.\\n\"\r\n\t\t\t\t\t\t+ \"Known type: \" + knownType + \"\\nActual type: \" + actualType);\r\n\t\t\t\twriteArrayStart();\r\n\t\t\t\tArray array = (Array)value;\r\n\t\t\t\tfor (int i = 0, n = array.size; i < n; i++)\r\n\t\t\t\t\twriteValue(array.get(i), elementType, null);\r\n\t\t\t\twriteArrayEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (value instanceof Collection) {\r\n\t\t\t\tif (knownType != null && actualType != knownType && actualType != ArrayList.class)\r\n\t\t\t\t\tthrow new SerializationException(\"Serialization of a Collection other than the known type is not supported.\\n\"\r\n\t\t\t\t\t\t+ \"Known type: \" + knownType + \"\\nActual type: \" + actualType);\r\n\t\t\t\twriteArrayStart();\r\n\t\t\t\tfor (Object item : (Collection)value)\r\n\t\t\t\t\twriteValue(item, elementType, null);\r\n\t\t\t\twriteArrayEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (actualType.isArray()) {\r\n\t\t\t\tif (elementType == null) elementType = actualType.getComponentType();\r\n\t\t\t\tint length = ArrayReflection.getLength(value);\r\n\t\t\t\twriteArrayStart();\r\n\t\t\t\tfor (int i = 0; i < length; i++)\r\n\t\t\t\t\twriteValue(ArrayReflection.get(value, i), elementType, null);\r\n\t\t\t\twriteArrayEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (value instanceof OrderedMap) {\r\n\t\t\t\tif (knownType == null) knownType = OrderedMap.class;\r\n\t\t\t\twriteObjectStart(actualType, knownType);\r\n\t\t\t\tOrderedMap map = (OrderedMap)value;\r\n\t\t\t\tfor (Object key : map.orderedKeys()) {\r\n\t\t\t\t\twriter.name(convertToString(key));\r\n\t\t\t\t\twriteValue(map.get(key), elementType, null);\r\n\t\t\t\t}\r\n\t\t\t\twriteObjectEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (value instanceof ArrayMap) {\r\n\t\t\t\tif (knownType == null) knownType = ArrayMap.class;\r\n\t\t\t\twriteObjectStart(actualType, knownType);\r\n\t\t\t\tArrayMap map = (ArrayMap)value;\r\n\t\t\t\tfor (int i = 0, n = map.size; i < n; i++) {\r\n\t\t\t\t\twriter.name(convertToString(map.keys[i]));\r\n\t\t\t\t\twriteValue(map.values[i], elementType, null);\r\n\t\t\t\t}\r\n\t\t\t\twriteObjectEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (value instanceof ObjectMap) {\r\n\t\t\t\tif (knownType == null) knownType = OrderedMap.class;\r\n\t\t\t\twriteObjectStart(actualType, knownType);\r\n\t\t\t\tfor (Entry entry : ((ObjectMap<?, ?>)value).entries()) {\r\n\t\t\t\t\twriter.name(convertToString(entry.key));\r\n\t\t\t\t\twriteValue(entry.value, elementType, null);\r\n\t\t\t\t}\r\n\t\t\t\twriteObjectEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (value instanceof Map) {\r\n\t\t\t\tif (knownType == null) knownType = HashMap.class;\r\n\t\t\t\twriteObjectStart(actualType, knownType);\r\n\t\t\t\tfor (Map.Entry entry : ((Map<?, ?>)value).entrySet()) {\r\n\t\t\t\t\twriter.name(convertToString(entry.getKey()));\r\n\t\t\t\t\twriteValue(entry.getValue(), elementType, null);\r\n\t\t\t\t}\r\n\t\t\t\twriteObjectEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (ClassReflection.isAssignableFrom(Enum.class, actualType)) {\r\n\t\t\t\tif (knownType == null || !knownType.equals(actualType)) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Ensures that enums with specific implementations (abstract logic) serialize correctly\r\n\t\t\t\t\tif(actualType.isAnonymousClass())\r\n\t\t\t\t\t\tactualType = actualType.getSuperclass();\r\n\t\t\t\t\t\r\n\t\t\t\t\twriteObjectStart(actualType, null);\r\n\t\t\t\t\twriter.name(\"value\");\r\n\t\t\t\t\twriter.value(value);\r\n\t\t\t\t\twriteObjectEnd();\r\n\t\t\t\t} else {\r\n\t\t\t\t\twriter.value(value);\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\twriteObjectStart(actualType, knownType);\r\n\t\t\twriteFields(value);\r\n\t\t\twriteObjectEnd();\r\n\t\t} catch (IOException ex) {\r\n\t\t\tthrow new SerializationException(ex);\r\n\t\t}\r\n\t}","id":65588,"modified_method":"/** Writes the value, writing the class of the object if it differs from the specified known type. The specified element type is\r\n\t * used as the default type for collections.\r\n\t * @param value May be null.\r\n\t * @param knownType May be null if the type is unknown.\r\n\t * @param elementType May be null if the type is unknown. */\r\n\tpublic void writeValue (Object value, Class knownType, Class elementType) {\r\n\t\ttry {\r\n\t\t\tif (value == null) {\r\n\t\t\t\twriter.value(null);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif ((knownType != null && knownType.isPrimitive()) || knownType == String.class || knownType == Integer.class\r\n\t\t\t\t|| knownType == Boolean.class || knownType == Float.class || knownType == Long.class || knownType == Double.class\r\n\t\t\t\t|| knownType == Short.class || knownType == Byte.class || knownType == Character.class) {\r\n\t\t\t\twriter.value(value);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tClass actualType = value.getClass();\r\n\r\n\t\t\tif (actualType.isPrimitive() || actualType == String.class || actualType == Integer.class || actualType == Boolean.class\r\n\t\t\t\t|| actualType == Float.class || actualType == Long.class || actualType == Double.class || actualType == Short.class\r\n\t\t\t\t|| actualType == Byte.class || actualType == Character.class) {\r\n\t\t\t\twriteObjectStart(actualType, null);\r\n\t\t\t\twriteValue(\"value\", value);\r\n\t\t\t\twriteObjectEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (value instanceof Serializable) {\r\n\t\t\t\twriteObjectStart(actualType, knownType);\r\n\t\t\t\t((Serializable)value).write(this);\r\n\t\t\t\twriteObjectEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tSerializer serializer = classToSerializer.get(actualType);\r\n\t\t\tif (serializer != null) {\r\n\t\t\t\tserializer.write(this, value, knownType);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (value instanceof Array) {\r\n\t\t\t\tif (knownType != null && actualType != knownType && actualType != Array.class)\r\n\t\t\t\t\tthrow new SerializationException(\"Serialization of an Array other than the known type is not supported.\\n\"\r\n\t\t\t\t\t\t+ \"Known type: \" + knownType + \"\\nActual type: \" + actualType);\r\n\t\t\t\twriteArrayStart();\r\n\t\t\t\tArray array = (Array)value;\r\n\t\t\t\tfor (int i = 0, n = array.size; i < n; i++)\r\n\t\t\t\t\twriteValue(array.get(i), elementType, null);\r\n\t\t\t\twriteArrayEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (value instanceof Collection) {\r\n\t\t\t\tif (knownType != null && actualType != knownType && actualType != ArrayList.class)\r\n\t\t\t\t\tthrow new SerializationException(\"Serialization of a Collection other than the known type is not supported.\\n\"\r\n\t\t\t\t\t\t+ \"Known type: \" + knownType + \"\\nActual type: \" + actualType);\r\n\t\t\t\twriteArrayStart();\r\n\t\t\t\tfor (Object item : (Collection)value)\r\n\t\t\t\t\twriteValue(item, elementType, null);\r\n\t\t\t\twriteArrayEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (actualType.isArray()) {\r\n\t\t\t\tif (elementType == null) elementType = actualType.getComponentType();\r\n\t\t\t\tint length = ArrayReflection.getLength(value);\r\n\t\t\t\twriteArrayStart();\r\n\t\t\t\tfor (int i = 0; i < length; i++)\r\n\t\t\t\t\twriteValue(ArrayReflection.get(value, i), elementType, null);\r\n\t\t\t\twriteArrayEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (value instanceof OrderedMap) {\r\n\t\t\t\tif (knownType == null) knownType = OrderedMap.class;\r\n\t\t\t\twriteObjectStart(actualType, knownType);\r\n\t\t\t\tOrderedMap map = (OrderedMap)value;\r\n\t\t\t\tfor (Object key : map.orderedKeys()) {\r\n\t\t\t\t\twriter.name(convertToString(key));\r\n\t\t\t\t\twriteValue(map.get(key), elementType, null);\r\n\t\t\t\t}\r\n\t\t\t\twriteObjectEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (value instanceof ArrayMap) {\r\n\t\t\t\tif (knownType == null) knownType = ArrayMap.class;\r\n\t\t\t\twriteObjectStart(actualType, knownType);\r\n\t\t\t\tArrayMap map = (ArrayMap)value;\r\n\t\t\t\tfor (int i = 0, n = map.size; i < n; i++) {\r\n\t\t\t\t\twriter.name(convertToString(map.keys[i]));\r\n\t\t\t\t\twriteValue(map.values[i], elementType, null);\r\n\t\t\t\t}\r\n\t\t\t\twriteObjectEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (value instanceof ObjectMap) {\r\n\t\t\t\tif (knownType == null) knownType = OrderedMap.class;\r\n\t\t\t\twriteObjectStart(actualType, knownType);\r\n\t\t\t\tfor (Entry entry : ((ObjectMap<?, ?>)value).entries()) {\r\n\t\t\t\t\twriter.name(convertToString(entry.key));\r\n\t\t\t\t\twriteValue(entry.value, elementType, null);\r\n\t\t\t\t}\r\n\t\t\t\twriteObjectEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (value instanceof Map) {\r\n\t\t\t\tif (knownType == null) knownType = HashMap.class;\r\n\t\t\t\twriteObjectStart(actualType, knownType);\r\n\t\t\t\tfor (Map.Entry entry : ((Map<?, ?>)value).entrySet()) {\r\n\t\t\t\t\twriter.name(convertToString(entry.getKey()));\r\n\t\t\t\t\twriteValue(entry.getValue(), elementType, null);\r\n\t\t\t\t}\r\n\t\t\t\twriteObjectEnd();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (ClassReflection.isAssignableFrom(Enum.class, actualType)) {\r\n\t\t\t\tif (knownType == null || !knownType.equals(actualType)) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Ensures that enums with specific implementations (abstract logic) serialize correctly\r\n\t\t\t\t\tif(actualType.getEnumConstants() == null)\r\n\t\t\t\t\t\tactualType = actualType.getSuperclass();\r\n\t\t\t\t\t\r\n\t\t\t\t\twriteObjectStart(actualType, null);\r\n\t\t\t\t\twriter.name(\"value\");\r\n\t\t\t\t\twriter.value(value);\r\n\t\t\t\t\twriteObjectEnd();\r\n\t\t\t\t} else {\r\n\t\t\t\t\twriter.value(value);\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\twriteObjectStart(actualType, knownType);\r\n\t\t\twriteFields(value);\r\n\t\t\twriteObjectEnd();\r\n\t\t} catch (IOException ex) {\r\n\t\t\tthrow new SerializationException(ex);\r\n\t\t}\r\n\t}","commit_id":"e098c4615c46e1ea8eb2823ff71144b0d8182723","url":"https://github.com/libgdx/libgdx"},{"original_method":"protected Object newInstance (Class type) {\r\n\t\ttry {\r\n\t\t\treturn ClassReflection.newInstance(type);\r\n\t\t} catch (Exception ex) {\r\n\t\t\ttry {\r\n\t\t\t\t// Try a private constructor.\r\n\t\t\t\tConstructor constructor = ClassReflection.getDeclaredConstructor(type);\r\n\t\t\t\tconstructor.setAccessible(true);\r\n\t\t\t\treturn constructor.newInstance();\r\n\t\t\t} catch (SecurityException ignored) {\r\n\t\t\t} catch (ReflectionException ignored) {\r\n\t\t\t\t\r\n\t\t\t\tif (type.isEnum()) {\r\n\t\t\t\t\treturn type.getEnumConstants()[0];\r\n\t\t\t\t}\r\n\t\t\t\r\n\t\t\t\tif(type.isAnonymousClass() && type.getSuperclass().isEnum()){\r\n\t\t\t\t\treturn type.getSuperclass().getEnumConstants()[0];\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (type.isArray())\r\n\t\t\t\t\tthrow new SerializationException(\"Encountered JSON object when expected array of type: \" + type.getName(), ex);\r\n\t\t\t\telse if (ClassReflection.isMemberClass(type) && !ClassReflection.isStaticClass(type))\r\n\t\t\t\t\tthrow new SerializationException(\"Class cannot be created (non-static member class): \" + type.getName(), ex);\r\n\t\t\t\telse\r\n\t\t\t\t\tthrow new SerializationException(\"Class cannot be created (missing no-arg constructor): \" + type.getName(), ex);\r\n\t\t\t} catch (Exception privateConstructorException) {\r\n\t\t\t\tex = privateConstructorException;\r\n\t\t\t}\r\n\t\t\tthrow new SerializationException(\"Error constructing instance of class: \" + type.getName(), ex);\r\n\t\t}\r\n\t}","id":65589,"modified_method":"protected Object newInstance (Class type) {\r\n\t\ttry {\r\n\t\t\treturn ClassReflection.newInstance(type);\r\n\t\t} catch (Exception ex) {\r\n\t\t\ttry {\r\n\t\t\t\t// Try a private constructor.\r\n\t\t\t\tConstructor constructor = ClassReflection.getDeclaredConstructor(type);\r\n\t\t\t\tconstructor.setAccessible(true);\r\n\t\t\t\treturn constructor.newInstance();\r\n\t\t\t} catch (SecurityException ignored) {\r\n\t\t\t} catch (ReflectionException ignored) {\r\n\t\t\t\t\r\n\t\t\t\tif(ClassReflection.isAssignableFrom(Enum.class, type)){\r\n\r\n\t\t\t\t\tif(type.getEnumConstants() == null)\r\n\t\t\t\t\t\ttype = type.getSuperclass();\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn type.getEnumConstants()[0];\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (type.isArray())\r\n\t\t\t\t\tthrow new SerializationException(\"Encountered JSON object when expected array of type: \" + type.getName(), ex);\r\n\t\t\t\telse if (ClassReflection.isMemberClass(type) && !ClassReflection.isStaticClass(type))\r\n\t\t\t\t\tthrow new SerializationException(\"Class cannot be created (non-static member class): \" + type.getName(), ex);\r\n\t\t\t\telse\r\n\t\t\t\t\tthrow new SerializationException(\"Class cannot be created (missing no-arg constructor): \" + type.getName(), ex);\r\n\t\t\t} catch (Exception privateConstructorException) {\r\n\t\t\t\tex = privateConstructorException;\r\n\t\t\t}\r\n\t\t\tthrow new SerializationException(\"Error constructing instance of class: \" + type.getName(), ex);\r\n\t\t}\r\n\t}","commit_id":"e098c4615c46e1ea8eb2823ff71144b0d8182723","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\n\t * @see org.apache.wicket.protocol.http.SecondLevelCacheSessionStore.ISerializationAwarePageStore#restoreAfterSerialization(java.io.Serializable)\n\t */\n\tpublic Page restoreAfterSerialization(Serializable serializable)\n\t{\n\t\tif (serializable instanceof Page)\n\t\t{\n\t\t\treturn (Page)serializable;\n\t\t}\n\t\telse if (serializable instanceof SerializedPageWithSession)\n\t\t{\n\t\t\tSerializedPageWithSession page = (SerializedPageWithSession)serializable;\n\t\t\tstoreSerializedPages(page.sessionId, page.pages);\n\t\t\treturn getPage(page.sessionId, page.pageMapName, page.pageId, page.versionNumber,\n\t\t\t\tpage.ajaxVersionNumber);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"Unknown object type\");\n\t\t}\n\t}","id":65590,"modified_method":"/**\n\t * @see org.apache.wicket.protocol.http.SecondLevelCacheSessionStore.ISerializationAwarePageStore#restoreAfterSerialization(java.io.Serializable)\n\t */\n\tpublic Object restoreAfterSerialization(Serializable serializable)\n\t{\n\t\tif (!storeAfterSessionReplication() || serializable instanceof Page)\n\t\t{\n\t\t\treturn serializable;\n\t\t}\n\t\telse if (serializable instanceof SerializedPageWithSession)\n\t\t{\n\t\t\tSerializedPageWithSession page = (SerializedPageWithSession)serializable;\n\t\t\tif (page.page == null || page.page.get() != SerializedPageWithSession.NO_PAGE)\n\t\t\t{\n\t\t\t\tstoreSerializedPages(page.sessionId, page.pages);\n\t\t\t\treturn stripSerializedPage(page);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn page;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tString type = serializable != null ? serializable.getClass().getName() : null;\n\t\t\tthrow new IllegalArgumentException(\"Unknown object type \" + type);\n\t\t}\n\t}","commit_id":"18b254464877727d171d63d86fb7ced0046242dc","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see org.apache.wicket.protocol.http.SecondLevelCacheSessionStore.IPageStore#storePage(java.lang.String,\n\t *      org.apache.wicket.Page)\n\t */\n\tpublic void storePage(String sessionId, Page page)\n\t{\n\t\tList pages = serializePage(page);\n\n\t\tcacheSerializedPage(sessionId, page, pages);\n\n\t\tonPagesSerialized(sessionId, pages);\n\n\t\tstoreSerializedPages(sessionId, pages);\n\t}","id":65591,"modified_method":"/**\n\t * @see org.apache.wicket.protocol.http.SecondLevelCacheSessionStore.IPageStore#storePage(java.lang.String,\n\t *      org.apache.wicket.Page)\n\t */\n\tpublic void storePage(String sessionId, Page page)\n\t{\n\t\tList pages = serializePage(page);\n\n\t\tserializedPagesCache.storePage(sessionId, page, pages);\n\n\t\tonPagesSerialized(sessionId, pages);\n\n\t\tstoreSerializedPages(sessionId, pages);\n\t}","commit_id":"18b254464877727d171d63d86fb7ced0046242dc","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see org.apache.wicket.protocol.http.SecondLevelCacheSessionStore.ISerializationAwarePageStore#prepareForSerialization(org.apache.wicket.Page)\n\t */\n\tpublic Serializable prepareForSerialization(Page page)\n\t{\n\t\tSerializable result = page;\n\n\t\tif (getLastRecentlySerializedPagesCacheSize() > 0)\n\t\t{\n\t\t\tSerializedPageWithSession entry;\n\t\t\tsynchronized (lastRecentlySerializedPagesCache)\n\t\t\t{\n\t\t\t\tentry = removePageFromLastRecentlySerializedPagesCache(page);\n\t\t\t}\n\n\t\t\tif (entry != null)\n\t\t\t{\n\t\t\t\tresult = entry;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}","id":65592,"modified_method":"/**\n\t * {@inheritDoc}\n\t */\n\tpublic Serializable prepareForSerialization(String sessionId, Object page)\n\t{\n\t\tSerializedPageWithSession result = null;\n\t\tif (page instanceof Page)\n\t\t{\n\t\t\tresult = serializedPagesCache.getPage((Page)page);\n\t\t\tif (result == null)\n\t\t\t{\n\t\t\t\tList serialized = serializePage((Page)page);\n\t\t\t\tresult = serializedPagesCache.storePage(sessionId, (Page)page, serialized);\n\t\t\t}\n\t\t}\n\t\telse if (page instanceof SerializedPageWithSession)\n\t\t{\n\t\t\tSerializedPageWithSession serialized = (SerializedPageWithSession)page;\n\t\t\tif (serialized.page.get() == SerializedPageWithSession.NO_PAGE)\n\t\t\t{\n\t\t\t\t// stripped page, need to restore it first\n\t\t\t\tresult = restoreStrippedSerializedPage(serialized);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = serialized;\n\t\t\t}\n\t\t}\n\n\t\tif (result != null)\n\t\t{\n\t\t\treturn result;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn (Serializable)page;\n\t\t}\n\t}","commit_id":"18b254464877727d171d63d86fb7ced0046242dc","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @return\n\t */\n\tpublic int getLastRecentlySerializedPagesCacheSize()\n\t{\n\t\treturn lastRecentlySerializedPagesCacheSize;\n\t}","id":65593,"modified_method":"/**\n\t * @return\n\t */\n\tprotected int getLastRecentlySerializedPagesCacheSize()\n\t{\n\t\treturn lastRecentlySerializedPagesCacheSize;\n\t}","commit_id":"18b254464877727d171d63d86fb7ced0046242dc","url":"https://github.com/apache/wicket"},{"original_method":"public boolean containsPage(int id, int versionNumber)\n\t\t{\n\t\t\tPage lastPage = this.lastPage;\n\t\t\tif (lastPage != null && lastPage.getNumericId() == id &&\n\t\t\t\tlastPage.getCurrentVersionNumber() == versionNumber)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn getStore().containsPage(getSession().getId(), getName(), id, versionNumber);\n\t\t\t}\n\t\t}","id":65594,"modified_method":"public boolean containsPage(int id, int versionNumber)\n\t\t{\n\t\t\tPage lastPage = this.lastPage instanceof Page ? (Page)this.lastPage : null;\n\t\t\tif (lastPage != null && lastPage.getNumericId() == id &&\n\t\t\t\tlastPage.getCurrentVersionNumber() == versionNumber)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn getStore().containsPage(getSession().getId(), getName(), id, versionNumber);\n\t\t\t}\n\t\t}","commit_id":"18b254464877727d171d63d86fb7ced0046242dc","url":"https://github.com/apache/wicket"},{"original_method":"private void readObject(java.io.ObjectInputStream s) throws IOException,\n\t\t\tClassNotFoundException\n\t\t{\n\t\t\ts.defaultReadObject();\n\n\t\t\t// if the pagestore is not clustered, we need to read the lastPage\n\t\t\t// instance\n\t\t\tif (serializeLastPage)\n\t\t\t{\n\t\t\t\tSerializable page = (Serializable)s.readObject();\n\t\t\t\tif (page != null)\n\t\t\t\t{\n\t\t\t\t\tlastPageDeserialized = page;\n\t\t\t\t}\n\t\t\t}\n\t\t}","id":65595,"modified_method":"private void readObject(java.io.ObjectInputStream s) throws IOException,\n\t\t\tClassNotFoundException\n\t\t{\n\t\t\ts.defaultReadObject();\n\n\t\t\tIPageStore store = getPageStore();\n\n\t\t\tif (sessionId != null && store instanceof IClusteredPageStore == false)\n\t\t\t{\n\t\t\t\tObject lastPage = s.readObject();\n\t\t\t\tif (store instanceof ISerializationAwarePageStore)\n\t\t\t\t{\n\t\t\t\t\tlastPage = ((ISerializationAwarePageStore)store).restoreAfterSerialization((Serializable)lastPage);\n\t\t\t\t}\n\t\t\t\tthis.lastPage = lastPage;\n\t\t\t}\n\t\t}","commit_id":"18b254464877727d171d63d86fb7ced0046242dc","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t\t * Process the page before the it gets serialized\n\t\t * \n\t\t * @param page\n\t\t * @return The Page itself or a SerializedContainer for that page\n\t\t */\n\t\tpublic Serializable prepareForSerialization(Page page);","id":65596,"modified_method":"/**\n\t\t * Process the page before the it gets serialized. The page can be either real page instance\n\t\t * of object returned by {@link #restoreAfterSerialization(Serializable)}.\n\t\t * \n\t\t * @param sessionId\n\t\t * @param page\n\t\t * @return The Page itself or a SerializedContainer for that page\n\t\t */\n\t\tpublic Serializable prepareForSerialization(String sessionId, Object page);","commit_id":"18b254464877727d171d63d86fb7ced0046242dc","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see org.apache.wicket.protocol.http.HttpSessionStore#createPageMap(java.lang.String,\n\t *      org.apache.wicket.Session)\n\t */\n\tpublic IPageMap createPageMap(String name)\n\t{\n\t\treturn new SecondLevelCachePageMap(this, name);\n\t}","id":65597,"modified_method":"/**\n\t * @see org.apache.wicket.protocol.http.HttpSessionStore#createPageMap(java.lang.String,\n\t *      org.apache.wicket.Session)\n\t */\n\tpublic IPageMap createPageMap(String name)\n\t{\n\t\treturn new SecondLevelCachePageMap(Session.get().getId(), Application.get(), name);\n\t}","commit_id":"18b254464877727d171d63d86fb7ced0046242dc","url":"https://github.com/apache/wicket"},{"original_method":"private void writeObject(java.io.ObjectOutputStream s) throws IOException\n\t\t{\n\n\t\t\ts.defaultWriteObject();\n\n\t\t\t// if the pagestore is not clustered, we need to serialize the\n\t\t\t// lastPage instance\n\t\t\tif (serializeLastPage)\n\t\t\t{\n\t\t\t\tSerializable page = lastPage;\n\n\t\t\t\tIPageStore store = getPageStore();\n\t\t\t\tif (page != null && store instanceof ISerializationAwarePageStore)\n\t\t\t\t{\n\t\t\t\t\tpage = ((ISerializationAwarePageStore)store).prepareForSerialization(lastPage);\n\t\t\t\t}\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\ts.writeObject(page);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tthrow new WicketRuntimeException(\"Failed to serialize \" + page.toString(), e);\n\t\t\t\t}\n\t\t\t}\n\t\t}","id":65598,"modified_method":"private void writeObject(java.io.ObjectOutputStream s) throws IOException\n\t\t{\n\n\t\t\ts.defaultWriteObject();\n\n\t\t\tIPageStore store = getPageStore();\n\n\t\t\t// for IClusteredPageStore we just skip serializing the page, pagestore takes care of it\n\t\t\tif (sessionId != null && store instanceof IClusteredPageStore == false)\n\t\t\t{\n\t\t\t\tObject page = lastPage;\n\t\t\t\tif (store instanceof ISerializationAwarePageStore)\n\t\t\t\t{\n\t\t\t\t\tpage = ((ISerializationAwarePageStore)store).prepareForSerialization(sessionId,\n\t\t\t\t\t\tpage);\n\t\t\t\t}\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\ts.writeObject(page);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tthrow new WicketRuntimeException(\"Failed to serialize \" + page.toString(), e);\n\t\t\t\t}\n\t\t\t}\n\t\t}","commit_id":"18b254464877727d171d63d86fb7ced0046242dc","url":"https://github.com/apache/wicket"},{"original_method":"private IPageStore getPageStore()\n\t\t{\n\t\t\tif (sessionStore == null)\n\t\t\t{\n\t\t\t\tApplication app = Application.exists() ? Application.get() : null;\n\t\t\t\tif (app != null)\n\t\t\t\t{\n\t\t\t\t\tsessionStore = (SecondLevelCacheSessionStore)app.getSessionStore();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sessionStore != null)\n\t\t\t{\n\t\t\t\treturn sessionStore.getStore();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}","id":65599,"modified_method":"private IPageStore getPageStore()\n\t\t{\n\t\t\tApplication application = Application.get(applicationKey);\n\n\t\t\tif (application != null)\n\t\t\t{\n\t\t\t\tSecondLevelCacheSessionStore store = (SecondLevelCacheSessionStore)application.getSessionStore();\n\n\t\t\t\treturn store.getStore();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// may happen when getPageStore() is called before application is initialized\n\t\t\t\t// for example on session initialization when cluster node starts\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}","commit_id":"18b254464877727d171d63d86fb7ced0046242dc","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t\t * This method should restore the given object to the original page.\n\t\t * \n\t\t * @param serializable\n\t\t * @return Page\n\t\t */\n\t\tpublic Page restoreAfterSerialization(Serializable serializable);","id":65600,"modified_method":"/**\n\t\t * This method should restore the serialized page to intermediate object that can be\n\t\t * converted to real page instance using {@link #convertToPage(Object)}.\n\t\t * \n\t\t * @param sessionId\n\t\t * @param serializable\n\t\t * @return Page\n\t\t */\n\t\tpublic Object restoreAfterSerialization(Serializable serializable);","commit_id":"18b254464877727d171d63d86fb7ced0046242dc","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t\t * @see org.apache.wicket.PageMap#put(org.apache.wicket.Page)\n\t\t */\n\t\tpublic void put(Page page)\n\t\t{\n\t\t\tif (!page.isPageStateless())\n\t\t\t{\n\t\t\t\tSession session = getSession();\n\t\t\t\tString sessionId = session.getId();\n\t\t\t\tif (sessionId != null && !session.isSessionInvalidated())\n\t\t\t\t{\n\t\t\t\t\tgetStore().storePage(sessionId, page);\n\t\t\t\t\tsetLastPage(page);\n\t\t\t\t\tdirty();\n\t\t\t\t}\n\t\t\t}\n\t\t}","id":65601,"modified_method":"/**\n\t\t * @see org.apache.wicket.PageMap#put(org.apache.wicket.Page)\n\t\t */\n\t\tpublic void put(Page page)\n\t\t{\n\t\t\tif (!page.isPageStateless())\n\t\t\t{\n\t\t\t\tSession session = getSession();\n\t\t\t\tString sessionId = session.getId();\n\t\t\t\tif (sessionId != null && !session.isSessionInvalidated())\n\t\t\t\t{\n\t\t\t\t\t// the id could have changed from null during request\n\t\t\t\t\tthis.sessionId = sessionId;\n\t\t\t\t\tgetStore().storePage(sessionId, page);\n\t\t\t\t\tsetLastPage(page);\n\t\t\t\t\tdirty();\n\t\t\t\t}\n\t\t\t}\n\t\t}","commit_id":"18b254464877727d171d63d86fb7ced0046242dc","url":"https://github.com/apache/wicket"},{"original_method":"private void setLastPage(Page lastPage)\n\t\t{\n\t\t\tthis.lastPage = lastPage;\n\t\t\tlastPageDeserialized = null;\n\t\t}","id":65602,"modified_method":"private void setLastPage(Page lastPage)\n\t\t{\n\t\t\tthis.lastPage = lastPage;\n\t\t}","commit_id":"18b254464877727d171d63d86fb7ced0046242dc","url":"https://github.com/apache/wicket"},{"original_method":"private Page getLastPage()\n\t\t{\n\t\t\tif (lastPage == null && lastPageDeserialized != null)\n\t\t\t{\n\t\t\t\tIPageStore store = getPageStore();\n\t\t\t\t// initialize lastPage if necessary (we intentionally delay this\n\t\t\t\t// until the first demand)\n\t\t\t\tif (store instanceof ISerializationAwarePageStore)\n\t\t\t\t{\n\t\t\t\t\tlastPage = ((ISerializationAwarePageStore)store).restoreAfterSerialization(lastPageDeserialized);\n\t\t\t\t}\n\t\t\t\telse if (lastPageDeserialized instanceof Page)\n\t\t\t\t{\n\t\t\t\t\tlastPage = (Page)lastPageDeserialized;\n\t\t\t\t}\n\t\t\t\tlastPageDeserialized = null;\n\t\t\t}\n\t\t\treturn lastPage;\n\t\t}","id":65603,"modified_method":"private Page getLastPage()\n\t\t{\n\t\t\tPage result = null;\n\t\t\tif (lastPage instanceof Page)\n\t\t\t{\n\t\t\t\tresult = (Page)lastPage;\n\t\t\t}\n\t\t\telse if (lastPage != null)\n\t\t\t{\n\t\t\t\tIPageStore store = getPageStore();\n\t\t\t\tif (store instanceof ISerializationAwarePageStore)\n\t\t\t\t{\n\t\t\t\t\tlastPage = result = ((ISerializationAwarePageStore)store).convertToPage(lastPage);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}","commit_id":"18b254464877727d171d63d86fb7ced0046242dc","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t\t * Construct.\n\t\t * \n\t\t * @param sessionStore\n\t\t * @param name\n\t\t */\n\t\tprivate SecondLevelCachePageMap(SecondLevelCacheSessionStore sessionStore, String name)\n\t\t{\n\t\t\tsuper(name);\n\t\t\tthis.sessionStore = sessionStore;\n\t\t\tserializeLastPage = sessionStore.isPageStoreClustered() == false;\n\t\t}","id":65604,"modified_method":"/**\n\t\t * Construct.\n\t\t * \n\t\t * @param sessionId\n\t\t * @param application\n\t\t * @param name\n\t\t */\n\t\tprivate SecondLevelCachePageMap(String sessionId, Application application, String name)\n\t\t{\n\t\t\tsuper(name);\n\t\t\tapplicationKey = application.getApplicationKey();\n\t\t\tthis.sessionId = sessionId;\n\t\t}","commit_id":"18b254464877727d171d63d86fb7ced0046242dc","url":"https://github.com/apache/wicket"},{"original_method":"@Test\n    public void testMapSizeWhileRandomDeaths() throws InterruptedException {\n        IMap map = getInstance(0).getMap(\"testMapSizeWhileRandomDeaths\");\n        int size = 1000;\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n        }\n\n        Random rand = new Random(System.currentTimeMillis());\n\n        for (int i = 0; i < 30; i++) {\n            map = getInstance(0).getMap(\"testMapSizeWhileRandomDeaths\");\n            assertEquals(map.size(), size);\n            System.out.println(\"trial:\" + i + \" instance count:\" + instanceCount);\n            if ((rand.nextInt(10) % 2 == 0 && instanceCount > 2) || instanceCount > 6) {\n                System.out.println(\"remove...\");\n                System.out.println(\"remove...\");\n                System.out.println(\"remove...\");\n                removeInstance();\n                System.out.println(\"removed!!!\");\n                System.out.println(\"removed!!!\");\n                System.out.println(\"removed!!!\");\n            } else {\n                System.out.println(\"new instance...\");\n                System.out.println(\"new instance...\");\n                System.out.println(\"new instance...\");\n                newInstance();\n            }\n            Thread.sleep(10000);\n            int realSize = getInstance(0).getCluster().getMembers().size();\n            System.out.println(\"Instance count Real:\" + realSize + \" Expected:\" + instanceCount);\n            System.out.println(\"Instance count Real:\" + realSize + \" Expected:\" + instanceCount);\n            System.out.println(\"Instance count Real:\" + realSize + \" Expected:\" + instanceCount);\n\n            instanceCount = realSize;\n        }\n\n\n    }","id":65605,"modified_method":"@Test\n    public void testMapSizeWhileRandomDeaths() throws InterruptedException {\n        IMap map = getInstance(0).getMap(\"testMapSizeWhileRandomDeaths\");\n        int size = 1000;\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n        }\n\n        Random rand = new Random(System.currentTimeMillis());\n\n        for (int i = 0; i < 30; i++) {\n            map = getInstance(0).getMap(\"testMapSizeWhileRandomDeaths\");\n            assertEquals(map.size(), size);\n            System.out.println(\"trial:\" + i + \" instance count:\" + instanceCount);\n            if ((rand.nextInt(10) % 2 == 0 && instanceCount > 2) || instanceCount > 6) {\n                removeInstance();\n            } else {\n                newInstance();\n            }\n            Thread.sleep(10000);\n            int realSize = getInstance(0).getCluster().getMembers().size();\n            instanceCount = realSize;\n        }\n\n\n    }","commit_id":"3ef0902faa846a2ceaedafc634985271c15d042f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"protected void writeInternal(final ObjectDataOutput out) throws IOException {\n        out.writeInt(data.size());\n        for (Entry<String, Map<Data, Record>> mapEntry : data.entrySet()) {\n            out.writeUTF(mapEntry.getKey());\n            Map<Data, Record> map = mapEntry.getValue();\n            out.writeInt(map.size());\n            for (Entry<Data, Record> entry : map.entrySet()) {\n                entry.getKey().writeData(out);\n                out.writeObject(entry.getValue());\n            }\n        }\n        final int txSize = transactionItems.size();\n        out.writeInt(txSize);\n        if (txSize > 0) {\n            for (TransactionItem item : transactionItems) {\n                item.writeData(out);\n            }\n        }\n    }","id":65606,"modified_method":"protected void writeInternal(final ObjectDataOutput out) throws IOException {\n        out.writeInt(data.size());\n        for (Entry<String, Set<Record>> mapEntry : data.entrySet()) {\n            out.writeUTF(mapEntry.getKey());\n            Set<Record> recordSet = mapEntry.getValue();\n            out.writeInt(recordSet.size());\n            for (Record record : recordSet) {\n                record.getKey().writeData(out);\n                out.writeObject(record);\n            }\n        }\n        final int txSize = transactionItems.size();\n        out.writeInt(txSize);\n        if (txSize > 0) {\n            for (TransactionItem item : transactionItems) {\n                item.writeData(out);\n            }\n        }\n    }","commit_id":"3ef0902faa846a2ceaedafc634985271c15d042f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"protected void readInternal(final ObjectDataInput in) throws IOException {\n        int size = in.readInt();\n        data = new HashMap<String, Map<Data, Record>>(size);\n        for (int i = 0; i < size; i++) {\n            String name = in.readUTF();\n            int mapSize = in.readInt();\n            Map<Data, Record> map = new HashMap<Data, Record>(mapSize);\n            for (int j = 0; j < mapSize; j++) {\n                Data key = new Data();\n                key.readData(in);\n                Record recordEntry = in.readObject();\n                map.put(key, recordEntry);\n            }\n            data.put(name, map);\n        }\n        int txSize = in.readInt();\n        if (txSize > 0) {\n            transactionItems = new ArrayList<TransactionItem>(txSize);\n            for (int i = 0; i < txSize; i++) {\n                TransactionItem item = new TransactionItem();\n                item.readData(in);\n                transactionItems.add(item);\n            }\n        }\n    }","id":65607,"modified_method":"protected void readInternal(final ObjectDataInput in) throws IOException {\n        int size = in.readInt();\n        data = new HashMap<String, Set<Record>>(size);\n        for (int i = 0; i < size; i++) {\n            String name = in.readUTF();\n            int mapSize = in.readInt();\n            Set<Record> recordSet = new HashSet<Record>(mapSize);\n            for (int j = 0; j < mapSize; j++) {\n                Data key = new Data();\n                key.readData(in);\n                Record recordEntry = in.readObject();\n                recordSet.add(recordEntry);\n            }\n            data.put(name, recordSet);\n        }\n        int txSize = in.readInt();\n        if (txSize > 0) {\n            transactionItems = new ArrayList<TransactionItem>(txSize);\n            for (int i = 0; i < txSize; i++) {\n                TransactionItem item = new TransactionItem();\n                item.readData(in);\n                transactionItems.add(item);\n            }\n        }\n    }","commit_id":"3ef0902faa846a2ceaedafc634985271c15d042f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void run() {\n        MapService mapService = (MapService) getService();\n        if (data != null) {\n            for (Entry<String, Map<Data, Record>> dataEntry : data.entrySet()) {\n                Map<Data, Record> dataMap = dataEntry.getValue();\n                final String mapName = dataEntry.getKey();\n                RecordStore recordStore = mapService.getRecordStore(getPartitionId(), mapName);\n                for (Entry<Data, Record> entry : dataMap.entrySet()) {\n                    final Record recordEntry = entry.getValue();\n                    Record record = mapService.createRecord(mapName, recordEntry.getKey(), recordEntry.getValue(), -1);\n                    record.setState(recordEntry.getState());\n                    record.setStatistics(recordEntry.getStatistics());\n                    recordStore.getRecords().put(entry.getKey(), record);\n                }\n            }\n        }\n        if (transactionItems != null && !transactionItems.isEmpty()) {\n            for (TransactionItem item : transactionItems) {\n                final PartitionContainer partitionContainer = mapService.getPartitionContainer(getPartitionId());\n                partitionContainer.addTransactionItem(item);\n            }\n        }\n    }","id":65608,"modified_method":"public void run() {\n        MapService mapService = (MapService) getService();\n        if (data != null) {\n            for (Entry<String, Set<Record>> dataEntry : data.entrySet()) {\n                Set<Record> recordSet = dataEntry.getValue();\n                final String mapName = dataEntry.getKey();\n                RecordStore recordStore = mapService.getRecordStore(getPartitionId(), mapName);\n                for (Record recordEntry: recordSet) {\n                    Record record = mapService.createRecord(mapName, recordEntry.getKey(), recordEntry.getValue(), -1);\n                    record.setState(recordEntry.getState());\n                    record.setStatistics(recordEntry.getStatistics());\n                    recordStore.getRecords().put(recordEntry.getKey(), record);\n                }\n            }\n        }\n        if (transactionItems != null && !transactionItems.isEmpty()) {\n            for (TransactionItem item : transactionItems) {\n                final PartitionContainer partitionContainer = mapService.getPartitionContainer(getPartitionId());\n                partitionContainer.addTransactionItem(item);\n            }\n        }\n    }","commit_id":"3ef0902faa846a2ceaedafc634985271c15d042f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public MapMigrationOperation(PartitionContainer container, int partitionId, int replicaIndex) {\n        this.setPartitionId(partitionId).setReplicaIndex(replicaIndex);\n        data = new HashMap<String, Map<Data, Record>>(container.maps.size());\n        for (Entry<String, PartitionRecordStore> entry : container.maps.entrySet()) {\n            String name = entry.getKey();\n            final MapConfig mapConfig = entry.getValue().getMapContainer().getMapConfig();\n            if (mapConfig.getTotalBackupCount() < replicaIndex) {\n                continue;\n            }\n            RecordStore recordStore = entry.getValue();\n            Map<Data, Record> map = new HashMap<Data, Record>(recordStore.getRecords().size());\n            for (Entry<Data, Record> recordEntry : recordStore.getRecords().entrySet()) {\n                map.put(recordEntry.getKey(), recordEntry.getValue());\n            }\n            data.put(name, map);\n        }\n        transactionItems = container.transactionItems.values();\n    }","id":65609,"modified_method":"public MapMigrationOperation(PartitionContainer container, int partitionId, int replicaIndex) {\n        this.setPartitionId(partitionId).setReplicaIndex(replicaIndex);\n        data = new HashMap<String, Set<Record>>(container.maps.size());\n        for (Entry<String, PartitionRecordStore> entry : container.maps.entrySet()) {\n            String name = entry.getKey();\n            final MapConfig mapConfig = entry.getValue().getMapContainer().getMapConfig();\n            if (mapConfig.getTotalBackupCount() < replicaIndex) {\n                continue;\n            }\n            RecordStore recordStore = entry.getValue();\n            Set<Record> recordSet = new HashSet<Record>(recordStore.getRecords().size());\n            for (Entry<Data, Record> recordEntry : recordStore.getRecords().entrySet()) {\n                recordSet.add(recordEntry.getValue());\n            }\n            data.put(name, recordSet);\n        }\n        transactionItems = container.transactionItems.values();\n    }","commit_id":"3ef0902faa846a2ceaedafc634985271c15d042f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"protected Data getInternal(Data key) {\n        final MapService mapService = getService();\n        final boolean nearCacheEnabled = mapService.getMapContainer(name).isNearCacheEnabled();\n        if (nearCacheEnabled) {\n            Data cachedData = mapService.getFromNearCache(name, key);\n            if (cachedData != null) {\n                return cachedData;\n            }\n        }\n        GetOperation operation = new GetOperation(name, key);\n        Data result = (Data) invokeOperation(key, operation);\n        if (nearCacheEnabled) {\n            final NodeEngine nodeEngine = getNodeEngine();\n            int partitionId = nodeEngine.getPartitionService().getPartitionId(key);\n            if (nodeEngine.getPartitionService().getPartitionOwner(partitionId).equals(nodeEngine.getClusterService().getThisAddress())) {\n                mapService.putNearCache(name, key, result);\n            }\n        }\n        return result;\n    }","id":65610,"modified_method":"protected Data getInternal(Data key) {\n        final MapService mapService = getService();\n        final boolean nearCacheEnabled = mapService.getMapContainer(name).isNearCacheEnabled();\n        if (nearCacheEnabled) {\n            Data cachedData = mapService.getFromNearCache(name, key);\n            if (cachedData != null) {\n                return cachedData;\n            }\n        }\n        GetOperation operation = new GetOperation(name, key);\n        Data result = (Data) invokeOperation(key, operation);\n        if (nearCacheEnabled) {\n            final NodeEngine nodeEngine = getNodeEngine();\n            int partitionId = nodeEngine.getPartitionService().getPartitionId(key);\n            if (!nodeEngine.getPartitionService().getPartitionOwner(partitionId).equals(nodeEngine.getClusterService().getThisAddress())) {\n                mapService.putNearCache(name, key, result);\n            }\n        }\n        return result;\n    }","commit_id":"3ef0902faa846a2ceaedafc634985271c15d042f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void run() {\n        NodeEngine nodeEngine = getNodeEngine();\n        SerializationService serializationService = nodeEngine.getSerializationService();\n        ObjectDataInput in = null;\n        try {\n            final byte[] taskData = IOUtil.decompress(zippedTaskData);\n            in = serializationService.createObjectDataInput(taskData);\n            int size = in.readInt();\n            tasks = new ArrayList<Operation>(size);\n            for (int i = 0; i < size; i++) {\n                Operation task = (Operation) serializationService.readObject(in);\n                tasks.add(task);\n            }\n            if (taskCount != tasks.size()) {\n                getLogger().log(Level.SEVERE, \"Migration task count mismatch! => \" +\n                        \"expected-count: \" + size + \", actual-count: \" + tasks.size() +\n                        \"\\nfrom: \" + migrationInfo.getFromAddress() + \", partition: \" + getPartitionId()\n                        + \", replica: \" + getReplicaIndex());\n            }\n            success = runMigrationTasks();\n        } catch (Throwable e) {\n            Level level = Level.WARNING;\n            if (e instanceof IllegalStateException) {\n                level = Level.FINEST;\n            }\n            getLogger().log(level, e.getMessage(), e);\n            success = false;\n        } finally {\n            IOUtil.closeResource(in);\n        }\n    }","id":65611,"modified_method":"public void run() {\n        NodeEngine nodeEngine = getNodeEngine();\n        SerializationService serializationService = nodeEngine.getSerializationService();\n        ObjectDataInput in = null;\n        try {\n            final byte[] taskData = IOUtil.decompress(zippedTaskData);\n            in = serializationService.createObjectDataInput(taskData);\n            int size = in.readInt();\n            tasks = new ArrayList<Operation>(size);\n            for (int i = 0; i < size; i++) {\n                Object o = serializationService.readObject(in);\n                if(!(o instanceof Operation)) {\n                    System.out.println(\"not operation\");\n                    LockNamespace ln = (LockNamespace) o;\n                    System.out.println(ln.getServiceName() + \" oid:\"+ ln.getObjectId());\n                }\n                Operation task = (Operation) o;\n                tasks.add(task);\n            }\n            if (taskCount != tasks.size()) {\n                getLogger().log(Level.SEVERE, \"Migration task count mismatch! => \" +\n                        \"expected-count: \" + size + \", actual-count: \" + tasks.size() +\n                        \"\\nfrom: \" + migrationInfo.getFromAddress() + \", partition: \" + getPartitionId()\n                        + \", replica: \" + getReplicaIndex());\n            }\n            success = runMigrationTasks();\n        } catch (Throwable e) {\n            Level level = Level.WARNING;\n            if (e instanceof IllegalStateException) {\n                level = Level.FINEST;\n            }\n            getLogger().log(level, e.getMessage(), e);\n            success = false;\n        } finally {\n            IOUtil.closeResource(in);\n        }\n    }","commit_id":"3ef0902faa846a2ceaedafc634985271c15d042f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        nameButtonGroup = new javax.swing.ButtonGroup();\n        typeButtonGroup = new javax.swing.ButtonGroup();\n        ruleNameLabel = new javax.swing.JLabel();\n        ruleNameTextField = new javax.swing.JTextField();\n        jLabel1 = new javax.swing.JLabel();\n        nameTextField = new javax.swing.JTextField();\n        fullNameRadioButton = new javax.swing.JRadioButton();\n        extensionRadioButton = new javax.swing.JRadioButton();\n        nameRegexCheckbox = new javax.swing.JCheckBox();\n        pathTextField = new javax.swing.JTextField();\n        pathRegexCheckBox = new javax.swing.JCheckBox();\n        pathSeparatorInfoLabel = new javax.swing.JLabel();\n        jLabel5 = new javax.swing.JLabel();\n        mimeTypeComboBox = new javax.swing.JComboBox<String>();\n        equalitySymbolComboBox = new javax.swing.JComboBox<String>();\n        fileSizeComboBox = new javax.swing.JComboBox<String>();\n        fileSizeSpinner = new javax.swing.JSpinner();\n        nameCheck = new javax.swing.JCheckBox();\n        pathCheck = new javax.swing.JCheckBox();\n        mimeCheck = new javax.swing.JCheckBox();\n        fileSizeCheck = new javax.swing.JCheckBox();\n        filesRadio = new javax.swing.JRadioButton();\n        dirsRadio = new javax.swing.JRadioButton();\n        filesAndDirsRadio = new javax.swing.JRadioButton();\n\n        org.openide.awt.Mnemonics.setLocalizedText(ruleNameLabel, org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.ruleNameLabel.text\")); // NOI18N\n\n        ruleNameTextField.setText(org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.ruleNameTextField.text\")); // NOI18N\n        ruleNameTextField.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                ruleNameTextFieldActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.jLabel1.text\")); // NOI18N\n\n        nameTextField.setText(org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.nameTextField.text\")); // NOI18N\n        nameTextField.setEnabled(false);\n\n        nameButtonGroup.add(fullNameRadioButton);\n        org.openide.awt.Mnemonics.setLocalizedText(fullNameRadioButton, org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.fullNameRadioButton.text\")); // NOI18N\n        fullNameRadioButton.setEnabled(false);\n\n        nameButtonGroup.add(extensionRadioButton);\n        org.openide.awt.Mnemonics.setLocalizedText(extensionRadioButton, org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.extensionRadioButton.text\")); // NOI18N\n        extensionRadioButton.setEnabled(false);\n\n        org.openide.awt.Mnemonics.setLocalizedText(nameRegexCheckbox, org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.nameRegexCheckbox.text\")); // NOI18N\n        nameRegexCheckbox.setEnabled(false);\n\n        pathTextField.setText(org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.pathTextField.text\")); // NOI18N\n        pathTextField.setEnabled(false);\n\n        org.openide.awt.Mnemonics.setLocalizedText(pathRegexCheckBox, org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.pathRegexCheckBox.text\")); // NOI18N\n        pathRegexCheckBox.setEnabled(false);\n\n        pathSeparatorInfoLabel.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/images/info-icon-16.png\"))); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(pathSeparatorInfoLabel, org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.pathSeparatorInfoLabel.text\")); // NOI18N\n        pathSeparatorInfoLabel.setEnabled(false);\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel5, org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.jLabel5.text\")); // NOI18N\n\n        mimeTypeComboBox.setEditable(true);\n        mimeTypeComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] {\"\"}));\n        mimeTypeComboBox.setEnabled(false);\n        mimeTypeComboBox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                mimeTypeComboBoxActionPerformed(evt);\n            }\n        });\n\n        equalitySymbolComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { \"=\", \">\", \"\", \"<\", \"\" }));\n        equalitySymbolComboBox.setEnabled(false);\n\n        fileSizeComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { Bundle.FilesSetRulePanel_bytes(), Bundle.FilesSetRulePanel_kiloBytes(), Bundle.FilesSetRulePanel_megaBytes(), Bundle.FilesSetRulePanel_gigaBytes() }));\n        fileSizeComboBox.setEnabled(false);\n\n        fileSizeSpinner.setModel(new javax.swing.SpinnerNumberModel(Integer.valueOf(0), Integer.valueOf(0), null, Integer.valueOf(1)));\n        fileSizeSpinner.setEnabled(false);\n\n        org.openide.awt.Mnemonics.setLocalizedText(nameCheck, org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.nameCheck.text\")); // NOI18N\n        nameCheck.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                nameCheckActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(pathCheck, org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.pathCheck.text\")); // NOI18N\n        pathCheck.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                pathCheckActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(mimeCheck, org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.mimeCheck.text\")); // NOI18N\n        mimeCheck.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                mimeCheckActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(fileSizeCheck, org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.fileSizeCheck.text\")); // NOI18N\n        fileSizeCheck.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                fileSizeCheckActionPerformed(evt);\n            }\n        });\n\n        typeButtonGroup.add(filesRadio);\n        org.openide.awt.Mnemonics.setLocalizedText(filesRadio, org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.filesRadio.text\")); // NOI18N\n        filesRadio.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                filesRadioActionPerformed(evt);\n            }\n        });\n\n        typeButtonGroup.add(dirsRadio);\n        org.openide.awt.Mnemonics.setLocalizedText(dirsRadio, org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.dirsRadio.text\")); // NOI18N\n        dirsRadio.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                dirsRadioActionPerformed(evt);\n            }\n        });\n\n        typeButtonGroup.add(filesAndDirsRadio);\n        org.openide.awt.Mnemonics.setLocalizedText(filesAndDirsRadio, org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.filesAndDirsRadio.text\")); // NOI18N\n        filesAndDirsRadio.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                filesAndDirsRadioActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGap(8, 8, 8)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(layout.createSequentialGroup()\n                                .addComponent(ruleNameLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(ruleNameTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 234, javax.swing.GroupLayout.PREFERRED_SIZE))\n                            .addGroup(layout.createSequentialGroup()\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addComponent(jLabel5)\n                                    .addGroup(layout.createSequentialGroup()\n                                        .addComponent(jLabel1)\n                                        .addGap(65, 65, 65)\n                                        .addComponent(filesRadio)\n                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                        .addComponent(dirsRadio)\n                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                        .addComponent(filesAndDirsRadio)))\n                                .addGap(0, 0, Short.MAX_VALUE))))\n                    .addGroup(layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addComponent(nameCheck)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                        .addComponent(nameTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 249, javax.swing.GroupLayout.PREFERRED_SIZE))\n                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addComponent(pathCheck)\n                        .addGap(4, 4, 4)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(layout.createSequentialGroup()\n                                .addComponent(pathRegexCheckBox)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                                .addComponent(pathSeparatorInfoLabel))\n                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                                .addGap(0, 0, Short.MAX_VALUE)\n                                .addComponent(pathTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 250, javax.swing.GroupLayout.PREFERRED_SIZE))\n                            .addGroup(layout.createSequentialGroup()\n                                .addComponent(fullNameRadioButton)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(extensionRadioButton, javax.swing.GroupLayout.PREFERRED_SIZE, 114, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(nameRegexCheckbox)\n                                .addGap(0, 0, Short.MAX_VALUE))))\n                    .addGroup(layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(mimeCheck)\n                            .addComponent(fileSizeCheck))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                            .addGroup(layout.createSequentialGroup()\n                                .addComponent(equalitySymbolComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 36, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addGap(18, 18, 18)\n                                .addComponent(fileSizeSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, 94, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addGap(18, 18, 18)\n                                .addComponent(fileSizeComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 82, javax.swing.GroupLayout.PREFERRED_SIZE))\n                            .addComponent(mimeTypeComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 250, javax.swing.GroupLayout.PREFERRED_SIZE))))\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addComponent(jLabel5)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(jLabel1)\n                    .addComponent(filesRadio)\n                    .addComponent(dirsRadio)\n                    .addComponent(filesAndDirsRadio))\n                .addGap(5, 5, 5)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(nameTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(nameCheck))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(fullNameRadioButton)\n                    .addComponent(extensionRadioButton)\n                    .addComponent(nameRegexCheckbox))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(pathTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(pathCheck))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(pathRegexCheckBox)\n                    .addComponent(pathSeparatorInfoLabel))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 8, Short.MAX_VALUE)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(mimeTypeComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(mimeCheck))\n                .addGap(11, 11, 11)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(equalitySymbolComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(fileSizeComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(fileSizeSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(fileSizeCheck))\n                .addGap(15, 15, 15)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(ruleNameTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(ruleNameLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n                .addContainerGap())\n        );\n    }","id":65612,"modified_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        nameButtonGroup = new javax.swing.ButtonGroup();\n        typeButtonGroup = new javax.swing.ButtonGroup();\n        ruleNameLabel = new javax.swing.JLabel();\n        ruleNameTextField = new javax.swing.JTextField();\n        jLabel1 = new javax.swing.JLabel();\n        nameTextField = new javax.swing.JTextField();\n        fullNameRadioButton = new javax.swing.JRadioButton();\n        extensionRadioButton = new javax.swing.JRadioButton();\n        nameRegexCheckbox = new javax.swing.JCheckBox();\n        pathTextField = new javax.swing.JTextField();\n        pathRegexCheckBox = new javax.swing.JCheckBox();\n        pathSeparatorInfoLabel = new javax.swing.JLabel();\n        jLabel5 = new javax.swing.JLabel();\n        mimeTypeComboBox = new javax.swing.JComboBox<String>();\n        equalitySymbolComboBox = new javax.swing.JComboBox<String>();\n        fileSizeComboBox = new javax.swing.JComboBox<String>();\n        fileSizeSpinner = new javax.swing.JSpinner();\n        nameCheck = new javax.swing.JCheckBox();\n        pathCheck = new javax.swing.JCheckBox();\n        mimeCheck = new javax.swing.JCheckBox();\n        fileSizeCheck = new javax.swing.JCheckBox();\n        filesRadio = new javax.swing.JRadioButton();\n        dirsRadio = new javax.swing.JRadioButton();\n        filesAndDirsRadio = new javax.swing.JRadioButton();\n\n        org.openide.awt.Mnemonics.setLocalizedText(ruleNameLabel, org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.ruleNameLabel.text\")); // NOI18N\n\n        ruleNameTextField.setText(org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.ruleNameTextField.text\")); // NOI18N\n        ruleNameTextField.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                ruleNameTextFieldActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.jLabel1.text\")); // NOI18N\n\n        nameTextField.setText(org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.nameTextField.text\")); // NOI18N\n        nameTextField.setEnabled(false);\n\n        nameButtonGroup.add(fullNameRadioButton);\n        org.openide.awt.Mnemonics.setLocalizedText(fullNameRadioButton, org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.fullNameRadioButton.text\")); // NOI18N\n        fullNameRadioButton.setEnabled(false);\n\n        nameButtonGroup.add(extensionRadioButton);\n        org.openide.awt.Mnemonics.setLocalizedText(extensionRadioButton, org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.extensionRadioButton.text\")); // NOI18N\n        extensionRadioButton.setEnabled(false);\n\n        org.openide.awt.Mnemonics.setLocalizedText(nameRegexCheckbox, org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.nameRegexCheckbox.text\")); // NOI18N\n        nameRegexCheckbox.setEnabled(false);\n\n        pathTextField.setText(org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.pathTextField.text\")); // NOI18N\n        pathTextField.setEnabled(false);\n\n        org.openide.awt.Mnemonics.setLocalizedText(pathRegexCheckBox, org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.pathRegexCheckBox.text\")); // NOI18N\n        pathRegexCheckBox.setEnabled(false);\n\n        pathSeparatorInfoLabel.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/images/info-icon-16.png\"))); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(pathSeparatorInfoLabel, org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.pathSeparatorInfoLabel.text\")); // NOI18N\n        pathSeparatorInfoLabel.setEnabled(false);\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel5, org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.jLabel5.text\")); // NOI18N\n\n        mimeTypeComboBox.setEditable(true);\n        mimeTypeComboBox.setModel(new javax.swing.DefaultComboBoxModel<String>(new String[] {\"\"}));\n        mimeTypeComboBox.setEnabled(false);\n        mimeTypeComboBox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                mimeTypeComboBoxActionPerformed(evt);\n            }\n        });\n\n        equalitySymbolComboBox.setModel(new javax.swing.DefaultComboBoxModel<String>(new String[] { \"=\", \">\", \"\", \"<\", \"\" }));\n        equalitySymbolComboBox.setEnabled(false);\n\n        fileSizeComboBox.setModel(new javax.swing.DefaultComboBoxModel<String>(new String[] { Bundle.FilesSetRulePanel_bytes(), Bundle.FilesSetRulePanel_kiloBytes(), Bundle.FilesSetRulePanel_megaBytes(), Bundle.FilesSetRulePanel_gigaBytes() }));\n        fileSizeComboBox.setEnabled(false);\n\n        fileSizeSpinner.setModel(new javax.swing.SpinnerNumberModel(Integer.valueOf(0), Integer.valueOf(0), null, Integer.valueOf(1)));\n        fileSizeSpinner.setEnabled(false);\n\n        org.openide.awt.Mnemonics.setLocalizedText(nameCheck, org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.nameCheck.text\")); // NOI18N\n        nameCheck.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                nameCheckActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(pathCheck, org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.pathCheck.text\")); // NOI18N\n        pathCheck.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                pathCheckActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(mimeCheck, org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.mimeCheck.text\")); // NOI18N\n        mimeCheck.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                mimeCheckActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(fileSizeCheck, org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.fileSizeCheck.text\")); // NOI18N\n        fileSizeCheck.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                fileSizeCheckActionPerformed(evt);\n            }\n        });\n\n        typeButtonGroup.add(filesRadio);\n        org.openide.awt.Mnemonics.setLocalizedText(filesRadio, org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.filesRadio.text\")); // NOI18N\n        filesRadio.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                filesRadioActionPerformed(evt);\n            }\n        });\n\n        typeButtonGroup.add(dirsRadio);\n        org.openide.awt.Mnemonics.setLocalizedText(dirsRadio, org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.dirsRadio.text\")); // NOI18N\n        dirsRadio.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                dirsRadioActionPerformed(evt);\n            }\n        });\n\n        typeButtonGroup.add(filesAndDirsRadio);\n        org.openide.awt.Mnemonics.setLocalizedText(filesAndDirsRadio, org.openide.util.NbBundle.getMessage(FilesSetRulePanel.class, \"FilesSetRulePanel.filesAndDirsRadio.text\")); // NOI18N\n        filesAndDirsRadio.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                filesAndDirsRadioActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGap(8, 8, 8)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(layout.createSequentialGroup()\n                                .addComponent(ruleNameLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(ruleNameTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 234, javax.swing.GroupLayout.PREFERRED_SIZE))\n                            .addGroup(layout.createSequentialGroup()\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addComponent(jLabel5)\n                                    .addGroup(layout.createSequentialGroup()\n                                        .addComponent(jLabel1)\n                                        .addGap(65, 65, 65)\n                                        .addComponent(filesRadio)\n                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                        .addComponent(dirsRadio)\n                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                        .addComponent(filesAndDirsRadio)))\n                                .addGap(0, 0, Short.MAX_VALUE))))\n                    .addGroup(layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addComponent(nameCheck)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                        .addComponent(nameTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 249, javax.swing.GroupLayout.PREFERRED_SIZE))\n                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addComponent(pathCheck)\n                        .addGap(4, 4, 4)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(layout.createSequentialGroup()\n                                .addComponent(pathRegexCheckBox)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                                .addComponent(pathSeparatorInfoLabel))\n                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                                .addGap(0, 0, Short.MAX_VALUE)\n                                .addComponent(pathTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 250, javax.swing.GroupLayout.PREFERRED_SIZE))\n                            .addGroup(layout.createSequentialGroup()\n                                .addComponent(fullNameRadioButton)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(extensionRadioButton, javax.swing.GroupLayout.PREFERRED_SIZE, 114, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(nameRegexCheckbox)\n                                .addGap(0, 0, Short.MAX_VALUE))))\n                    .addGroup(layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(mimeCheck)\n                            .addComponent(fileSizeCheck))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                            .addGroup(layout.createSequentialGroup()\n                                .addComponent(equalitySymbolComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 36, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addGap(18, 18, 18)\n                                .addComponent(fileSizeSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, 94, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addGap(18, 18, 18)\n                                .addComponent(fileSizeComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 82, javax.swing.GroupLayout.PREFERRED_SIZE))\n                            .addComponent(mimeTypeComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 250, javax.swing.GroupLayout.PREFERRED_SIZE))))\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addComponent(jLabel5)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(jLabel1)\n                    .addComponent(filesRadio)\n                    .addComponent(dirsRadio)\n                    .addComponent(filesAndDirsRadio))\n                .addGap(5, 5, 5)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(nameTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(nameCheck))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(fullNameRadioButton)\n                    .addComponent(extensionRadioButton)\n                    .addComponent(nameRegexCheckbox))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(pathTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(pathCheck))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(pathRegexCheckBox)\n                    .addComponent(pathSeparatorInfoLabel))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 8, Short.MAX_VALUE)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(mimeTypeComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(mimeCheck))\n                .addGap(11, 11, 11)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(equalitySymbolComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(fileSizeComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(fileSizeSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(fileSizeCheck))\n                .addGap(15, 15, 15)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(ruleNameTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(ruleNameLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n                .addContainerGap())\n        );\n    }","commit_id":"25e63e198b271fcacd37e72d331f09cff87b53aa","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n         * Writes interesting files set definitions to disk as an XML file,\n         * logging any errors.\n         *\n         * @param filePath Path of the set definitions file as a string.\n         *\n         * @returns True if the definitions are written to disk, false\n         * otherwise.\n         */\n        // Note: This method takes a file path to support the possibility of \n        // multiple intersting files set definition files, e.g., one for \n        // definitions that ship with Autopsy and one for user definitions.\n        static boolean writeDefinitionsFile(String filePath, Map<String, FilesSet> interestingFilesSets) {\n            try (NbObjectOutputStream out = new NbObjectOutputStream(new FileOutputStream(filePath))) {\n                out.writeObject(interestingFilesSets);\n                File xmlFile = new File(DEFAULT_FILE_SET_DEFS_PATH);\n                if (xmlFile.exists()) {\n                    xmlFile.delete();\n                }\n                return true;\n            } catch (IOException ex) {\n                throw new PersistenceException(String.format(\"Failed to write settings to %s\", filePath), ex);\n            }\n        }","id":65613,"modified_method":"/**\n         * Writes interesting files set definitions to disk as an XML file,\n         * logging any errors.\n         *\n         * @param filePath Path of the set definitions file as a string.\n         *\n         * @returns True if the definitions are written to disk, false\n         * otherwise.\n         */\n        // Note: This method takes a file path to support the possibility of \n        // multiple intersting files set definition files, e.g., one for \n        // definitions that ship with Autopsy and one for user definitions.\n        static boolean writeDefinitionsFile(String filePath, Map<String, FilesSet> interestingFilesSets) {\n            try (NbObjectOutputStream out = new NbObjectOutputStream(new FileOutputStream(filePath))) {\n                out.writeObject(new InterestingItemsFilesSetSettings(interestingFilesSets));\n                File xmlFile = new File(DEFAULT_FILE_SET_DEFS_PATH);\n                if (xmlFile.exists()) {\n                    xmlFile.delete();\n                }\n                return true;\n            } catch (IOException ex) {\n                throw new PersistenceException(String.format(\"Failed to write settings to %s\", filePath), ex);\n            }\n        }","commit_id":"25e63e198b271fcacd37e72d331f09cff87b53aa","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private static Map<String, FilesSet> readSerializedDefinitions() {\n            String filePath = INTERESING_FILES_SET_DEFS_SERIALIZATION_PATH;\n            try (NbObjectInputStream in = new NbObjectInputStream(new FileInputStream(filePath.toString()))) {\n                Map<String, FilesSet> filesSetMap = (Map<String, FilesSet>) in.readObject();\n                return filesSetMap;\n            } catch (IOException | ClassNotFoundException ex) {\n                throw new PersistenceException(String.format(\"Failed to read settings from %s\", filePath), ex);\n            }\n        }","id":65614,"modified_method":"private static Map<String, FilesSet> readSerializedDefinitions() {\n            String filePath = INTERESING_FILES_SET_DEFS_SERIALIZATION_PATH;\n            File fileSetFile = new File(filePath);\n            if (fileSetFile.exists()) {\n                try {\n                    try (NbObjectInputStream in = new NbObjectInputStream(new FileInputStream(filePath))) {\n                        InterestingItemsFilesSetSettings filesSetsSettings = (InterestingItemsFilesSetSettings) in.readObject();\n                        return filesSetsSettings.getFilesSets();\n                    }\n                } catch (IOException | ClassNotFoundException ex) {\n                    throw new PersistenceException(String.format(\"Failed to read settings from %s\", filePath), ex);\n                }\n            }\n            else {\n                return new HashMap<String, FilesSet>();\n            }\n        }","commit_id":"25e63e198b271fcacd37e72d331f09cff87b53aa","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        fileNameButtonGroup = new javax.swing.ButtonGroup();\n        typeButtonGroup = new javax.swing.ButtonGroup();\n        jScrollPane1 = new javax.swing.JScrollPane();\n        jPanel1 = new javax.swing.JPanel();\n        jLabel6 = new javax.swing.JLabel();\n        newRuleButton = new javax.swing.JButton();\n        filesRadioButton = new javax.swing.JRadioButton();\n        editRuleButton = new javax.swing.JButton();\n        rulesListLabel = new javax.swing.JLabel();\n        rulesListScrollPane = new javax.swing.JScrollPane();\n        rulesList = new javax.swing.JList<FilesSet.Rule>();\n        setDescScrollPanel = new javax.swing.JScrollPane();\n        setDescriptionTextArea = new javax.swing.JTextArea();\n        editSetButton = new javax.swing.JButton();\n        setsListScrollPane = new javax.swing.JScrollPane();\n        setsList = new javax.swing.JList<FilesSet>();\n        fileNameExtensionRadioButton = new javax.swing.JRadioButton();\n        jLabel3 = new javax.swing.JLabel();\n        fileNameTextField = new javax.swing.JTextField();\n        jLabel5 = new javax.swing.JLabel();\n        fileNameRadioButton = new javax.swing.JRadioButton();\n        rulePathConditionTextField = new javax.swing.JTextField();\n        ignoreKnownFilesCheckbox = new javax.swing.JCheckBox();\n        fileNameRegexCheckbox = new javax.swing.JCheckBox();\n        separator = new javax.swing.JSeparator();\n        setsListLabel = new javax.swing.JLabel();\n        bothRadioButton = new javax.swing.JRadioButton();\n        deleteSetButton = new javax.swing.JButton();\n        deleteRuleButton = new javax.swing.JButton();\n        newSetButton = new javax.swing.JButton();\n        jLabel2 = new javax.swing.JLabel();\n        dirsRadioButton = new javax.swing.JRadioButton();\n        jLabel1 = new javax.swing.JLabel();\n        jLabel4 = new javax.swing.JLabel();\n        rulePathConditionRegexCheckBox = new javax.swing.JCheckBox();\n        jScrollPane2 = new javax.swing.JScrollPane();\n        jTextArea1 = new javax.swing.JTextArea();\n        jLabel7 = new javax.swing.JLabel();\n        mimeTypeComboBox = new javax.swing.JComboBox();\n        jLabel8 = new javax.swing.JLabel();\n        equalitySignComboBox = new javax.swing.JComboBox<String>();\n        jSpinner1 = new javax.swing.JSpinner();\n        fileSizeUnitComboBox = new javax.swing.JComboBox<String>();\n\n        setFont(getFont().deriveFont(getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n\n        jScrollPane1.setFont(jScrollPane1.getFont().deriveFont(jScrollPane1.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n\n        jPanel1.setFont(jPanel1.getFont().deriveFont(jPanel1.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n\n        jLabel6.setFont(jLabel6.getFont().deriveFont(jLabel6.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel6, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.jLabel6.text\")); // NOI18N\n\n        newRuleButton.setFont(newRuleButton.getFont().deriveFont(newRuleButton.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        newRuleButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/images/add16.png\"))); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(newRuleButton, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.newRuleButton.text\")); // NOI18N\n        newRuleButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                newRuleButtonActionPerformed(evt);\n            }\n        });\n\n        typeButtonGroup.add(filesRadioButton);\n        filesRadioButton.setFont(filesRadioButton.getFont().deriveFont(filesRadioButton.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        filesRadioButton.setSelected(true);\n        org.openide.awt.Mnemonics.setLocalizedText(filesRadioButton, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.filesRadioButton.text\")); // NOI18N\n        filesRadioButton.setEnabled(false);\n\n        editRuleButton.setFont(editRuleButton.getFont().deriveFont(editRuleButton.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        editRuleButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/images/edit16.png\"))); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(editRuleButton, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.editRuleButton.text\")); // NOI18N\n        editRuleButton.setEnabled(false);\n        editRuleButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                editRuleButtonActionPerformed(evt);\n            }\n        });\n\n        rulesListLabel.setFont(rulesListLabel.getFont().deriveFont(rulesListLabel.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(rulesListLabel, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.rulesListLabel.text\")); // NOI18N\n\n        rulesListScrollPane.setFont(rulesListScrollPane.getFont().deriveFont(rulesListScrollPane.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n\n        rulesList.setFont(rulesList.getFont().deriveFont(rulesList.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        rulesList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);\n        rulesListScrollPane.setViewportView(rulesList);\n\n        setDescScrollPanel.setFont(setDescScrollPanel.getFont().deriveFont(setDescScrollPanel.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n\n        setDescriptionTextArea.setEditable(false);\n        setDescriptionTextArea.setBackground(new java.awt.Color(240, 240, 240));\n        setDescriptionTextArea.setColumns(20);\n        setDescriptionTextArea.setFont(setDescriptionTextArea.getFont().deriveFont(setDescriptionTextArea.getFont().getStyle() & ~java.awt.Font.BOLD, 13));\n        setDescriptionTextArea.setLineWrap(true);\n        setDescriptionTextArea.setRows(2);\n        setDescScrollPanel.setViewportView(setDescriptionTextArea);\n\n        editSetButton.setFont(editSetButton.getFont().deriveFont(editSetButton.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        editSetButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/images/edit16.png\"))); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(editSetButton, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.editSetButton.text\")); // NOI18N\n        editSetButton.setEnabled(false);\n        editSetButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                editSetButtonActionPerformed(evt);\n            }\n        });\n\n        setsListScrollPane.setFont(setsListScrollPane.getFont().deriveFont(setsListScrollPane.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n\n        setsList.setFont(setsList.getFont().deriveFont(setsList.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        setsList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);\n        setsListScrollPane.setViewportView(setsList);\n\n        fileNameButtonGroup.add(fileNameExtensionRadioButton);\n        fileNameExtensionRadioButton.setFont(fileNameExtensionRadioButton.getFont().deriveFont(fileNameExtensionRadioButton.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(fileNameExtensionRadioButton, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.fileNameExtensionRadioButton.text\")); // NOI18N\n        fileNameExtensionRadioButton.setEnabled(false);\n\n        jLabel3.setFont(jLabel3.getFont().deriveFont(jLabel3.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel3, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.jLabel3.text\")); // NOI18N\n\n        fileNameTextField.setEditable(false);\n        fileNameTextField.setFont(fileNameTextField.getFont().deriveFont(fileNameTextField.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        fileNameTextField.setText(org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.fileNameTextField.text\")); // NOI18N\n        fileNameTextField.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                fileNameTextFieldActionPerformed(evt);\n            }\n        });\n\n        jLabel5.setFont(jLabel5.getFont().deriveFont(jLabel5.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel5, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.jLabel5.text\")); // NOI18N\n\n        fileNameButtonGroup.add(fileNameRadioButton);\n        fileNameRadioButton.setFont(fileNameRadioButton.getFont().deriveFont(fileNameRadioButton.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(fileNameRadioButton, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.fileNameRadioButton.text\")); // NOI18N\n        fileNameRadioButton.setEnabled(false);\n\n        rulePathConditionTextField.setEditable(false);\n        rulePathConditionTextField.setFont(rulePathConditionTextField.getFont().deriveFont(rulePathConditionTextField.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        rulePathConditionTextField.setText(org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.rulePathConditionTextField.text\")); // NOI18N\n\n        ignoreKnownFilesCheckbox.setFont(ignoreKnownFilesCheckbox.getFont().deriveFont(ignoreKnownFilesCheckbox.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(ignoreKnownFilesCheckbox, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.ignoreKnownFilesCheckbox.text\")); // NOI18N\n        ignoreKnownFilesCheckbox.setEnabled(false);\n        ignoreKnownFilesCheckbox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                ignoreKnownFilesCheckboxActionPerformed(evt);\n            }\n        });\n\n        fileNameRegexCheckbox.setFont(fileNameRegexCheckbox.getFont().deriveFont(fileNameRegexCheckbox.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(fileNameRegexCheckbox, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.fileNameRegexCheckbox.text\")); // NOI18N\n        fileNameRegexCheckbox.setEnabled(false);\n\n        separator.setOrientation(javax.swing.SwingConstants.VERTICAL);\n\n        setsListLabel.setFont(setsListLabel.getFont().deriveFont(setsListLabel.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(setsListLabel, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.setsListLabel.text\")); // NOI18N\n\n        typeButtonGroup.add(bothRadioButton);\n        bothRadioButton.setFont(bothRadioButton.getFont().deriveFont(bothRadioButton.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(bothRadioButton, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.bothRadioButton.text\")); // NOI18N\n        bothRadioButton.setEnabled(false);\n\n        deleteSetButton.setFont(deleteSetButton.getFont().deriveFont(deleteSetButton.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        deleteSetButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/images/delete16.png\"))); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(deleteSetButton, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.deleteSetButton.text\")); // NOI18N\n        deleteSetButton.setEnabled(false);\n        deleteSetButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                deleteSetButtonActionPerformed(evt);\n            }\n        });\n\n        deleteRuleButton.setFont(deleteRuleButton.getFont().deriveFont(deleteRuleButton.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        deleteRuleButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/images/delete16.png\"))); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(deleteRuleButton, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.deleteRuleButton.text\")); // NOI18N\n        deleteRuleButton.setEnabled(false);\n        deleteRuleButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                deleteRuleButtonActionPerformed(evt);\n            }\n        });\n\n        newSetButton.setFont(newSetButton.getFont().deriveFont(newSetButton.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        newSetButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/images/add16.png\"))); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(newSetButton, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.newSetButton.text\")); // NOI18N\n        newSetButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                newSetButtonActionPerformed(evt);\n            }\n        });\n\n        jLabel2.setFont(jLabel2.getFont().deriveFont(jLabel2.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel2, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.jLabel2.text\")); // NOI18N\n\n        typeButtonGroup.add(dirsRadioButton);\n        dirsRadioButton.setFont(dirsRadioButton.getFont().deriveFont(dirsRadioButton.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(dirsRadioButton, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.dirsRadioButton.text\")); // NOI18N\n        dirsRadioButton.setEnabled(false);\n        dirsRadioButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                dirsRadioButtonActionPerformed(evt);\n            }\n        });\n\n        jLabel1.setFont(jLabel1.getFont().deriveFont(jLabel1.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.jLabel1.text\")); // NOI18N\n\n        jLabel4.setFont(jLabel4.getFont().deriveFont(jLabel4.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel4, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.jLabel4.text\")); // NOI18N\n\n        rulePathConditionRegexCheckBox.setFont(rulePathConditionRegexCheckBox.getFont().deriveFont(rulePathConditionRegexCheckBox.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(rulePathConditionRegexCheckBox, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.rulePathConditionRegexCheckBox.text\")); // NOI18N\n        rulePathConditionRegexCheckBox.setEnabled(false);\n\n        jScrollPane2.setFont(jScrollPane2.getFont().deriveFont(jScrollPane2.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n\n        jTextArea1.setEditable(false);\n        jTextArea1.setBackground(new java.awt.Color(240, 240, 240));\n        jTextArea1.setColumns(20);\n        jTextArea1.setFont(jTextArea1.getFont().deriveFont(jTextArea1.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        jTextArea1.setLineWrap(true);\n        jTextArea1.setRows(3);\n        jTextArea1.setText(org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.jTextArea1.text\")); // NOI18N\n        jTextArea1.setWrapStyleWord(true);\n        jScrollPane2.setViewportView(jTextArea1);\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel7, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.jLabel7.text\")); // NOI18N\n\n        mimeTypeComboBox.setEditable(true);\n        mimeTypeComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] {\"\"}));\n        mimeTypeComboBox.setEnabled(false);\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel8, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.jLabel8.text\")); // NOI18N\n\n        equalitySignComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { \"=\", \">\", \"\", \"<\", \"\" }));\n        equalitySignComboBox.setEnabled(false);\n\n        jSpinner1.setEnabled(false);\n\n        fileSizeUnitComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { Bundle.InterestingItemDefsPanel_bytes(), Bundle.InterestingItemDefsPanel_kiloBytes(), Bundle.InterestingItemDefsPanel_megaBytes(), Bundle.InterestingItemDefsPanel_gigaBytes() }));\n        fileSizeUnitComboBox.setEnabled(false);\n\n        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);\n        jPanel1.setLayout(jPanel1Layout);\n        jPanel1Layout.setHorizontalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel1Layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(setsListLabel)\n                    .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)\n                        .addComponent(setsListScrollPane, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 314, Short.MAX_VALUE)\n                        .addComponent(jScrollPane2, javax.swing.GroupLayout.Alignment.LEADING))\n                    .addGroup(jPanel1Layout.createSequentialGroup()\n                        .addComponent(newSetButton, javax.swing.GroupLayout.PREFERRED_SIZE, 93, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(editSetButton, javax.swing.GroupLayout.PREFERRED_SIZE, 89, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(deleteSetButton)))\n                .addGap(18, 18, 18)\n                .addComponent(separator, javax.swing.GroupLayout.PREFERRED_SIZE, 6, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(12, 12, 12)\n                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addGroup(jPanel1Layout.createSequentialGroup()\n                        .addComponent(jLabel1)\n                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n                    .addGroup(jPanel1Layout.createSequentialGroup()\n                        .addComponent(jLabel2)\n                        .addGap(27, 27, 27)\n                        .addComponent(filesRadioButton, javax.swing.GroupLayout.PREFERRED_SIZE, 47, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(dirsRadioButton)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(bothRadioButton)\n                        .addGap(27, 27, 27))))\n            .addGroup(jPanel1Layout.createSequentialGroup()\n                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(jPanel1Layout.createSequentialGroup()\n                        .addGap(380, 380, 380)\n                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(jPanel1Layout.createSequentialGroup()\n                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addComponent(jLabel3)\n                                    .addComponent(jLabel7)\n                                    .addComponent(jLabel8))\n                                .addGap(6, 6, 6))\n                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()\n                                .addComponent(jLabel4)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)))\n                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)\n                            .addComponent(rulePathConditionTextField, javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(javax.swing.GroupLayout.Alignment.LEADING, jPanel1Layout.createSequentialGroup()\n                                .addComponent(equalitySignComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 38, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(jSpinner1, javax.swing.GroupLayout.PREFERRED_SIZE, 104, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(fileSizeUnitComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 83, javax.swing.GroupLayout.PREFERRED_SIZE))\n                            .addComponent(mimeTypeComboBox, javax.swing.GroupLayout.Alignment.LEADING, 0, 245, Short.MAX_VALUE)\n                            .addComponent(fileNameTextField)))\n                    .addGroup(jPanel1Layout.createSequentialGroup()\n                        .addGap(360, 360, 360)\n                        .addComponent(rulesListLabel))\n                    .addGroup(jPanel1Layout.createSequentialGroup()\n                        .addGap(360, 360, 360)\n                        .addComponent(jLabel5))\n                    .addGroup(jPanel1Layout.createSequentialGroup()\n                        .addGap(360, 360, 360)\n                        .addComponent(ignoreKnownFilesCheckbox))\n                    .addGroup(jPanel1Layout.createSequentialGroup()\n                        .addGap(360, 360, 360)\n                        .addComponent(setDescScrollPanel, javax.swing.GroupLayout.PREFERRED_SIZE, 336, javax.swing.GroupLayout.PREFERRED_SIZE))\n                    .addGroup(jPanel1Layout.createSequentialGroup()\n                        .addGap(360, 360, 360)\n                        .addComponent(jLabel6))\n                    .addGroup(jPanel1Layout.createSequentialGroup()\n                        .addGap(360, 360, 360)\n                        .addComponent(rulesListScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 336, javax.swing.GroupLayout.PREFERRED_SIZE))\n                    .addGroup(jPanel1Layout.createSequentialGroup()\n                        .addGap(360, 360, 360)\n                        .addComponent(newRuleButton)\n                        .addGap(18, 18, 18)\n                        .addComponent(editRuleButton)\n                        .addGap(18, 18, 18)\n                        .addComponent(deleteRuleButton))\n                    .addGroup(jPanel1Layout.createSequentialGroup()\n                        .addGap(456, 456, 456)\n                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(jPanel1Layout.createSequentialGroup()\n                                .addComponent(fileNameRadioButton)\n                                .addGap(4, 4, 4)\n                                .addComponent(fileNameExtensionRadioButton)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                .addComponent(fileNameRegexCheckbox))\n                            .addComponent(rulePathConditionRegexCheckBox))))\n                .addGap(20, 20, 20))\n        );\n        jPanel1Layout.setVerticalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel1Layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(separator)\n                    .addGroup(jPanel1Layout.createSequentialGroup()\n                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(jPanel1Layout.createSequentialGroup()\n                                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addGap(18, 18, 18)\n                                .addComponent(setsListLabel)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(setsListScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 199, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                                    .addComponent(newSetButton)\n                                    .addComponent(editSetButton)\n                                    .addComponent(deleteSetButton)))\n                            .addGroup(jPanel1Layout.createSequentialGroup()\n                                .addComponent(jLabel6)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(jLabel5)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(setDescScrollPanel, javax.swing.GroupLayout.PREFERRED_SIZE, 42, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(ignoreKnownFilesCheckbox)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                .addComponent(rulesListLabel)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(rulesListScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 64, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                                    .addComponent(newRuleButton)\n                                    .addComponent(editRuleButton)\n                                    .addComponent(deleteRuleButton))\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(jLabel1)\n                                .addGap(2, 2, 2)\n                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                                    .addComponent(jLabel2)\n                                    .addComponent(filesRadioButton)\n                                    .addComponent(dirsRadioButton)\n                                    .addComponent(bothRadioButton))\n                                .addGap(16, 16, 16)\n                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                                    .addComponent(jLabel3)\n                                    .addComponent(fileNameTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                                    .addComponent(fileNameRadioButton)\n                                    .addComponent(fileNameExtensionRadioButton)\n                                    .addComponent(fileNameRegexCheckbox))))\n                        .addGap(14, 14, 14)\n                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(jLabel4)\n                            .addComponent(rulePathConditionTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(rulePathConditionRegexCheckBox)\n                        .addGap(10, 10, 10)\n                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(jLabel7)\n                            .addComponent(mimeTypeComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addGap(16, 16, 16)\n                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(jLabel8)\n                            .addComponent(equalitySignComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addComponent(jSpinner1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addComponent(fileSizeUnitComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))))\n                .addContainerGap())\n        );\n\n        jPanel1Layout.linkSize(javax.swing.SwingConstants.VERTICAL, new java.awt.Component[] {deleteRuleButton, deleteSetButton, editRuleButton, editSetButton, newRuleButton, newSetButton});\n\n        jScrollPane1.setViewportView(jPanel1);\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 728, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(0, 34, Short.MAX_VALUE))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 503, Short.MAX_VALUE)\n        );\n    }","id":65615,"modified_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        fileNameButtonGroup = new javax.swing.ButtonGroup();\n        typeButtonGroup = new javax.swing.ButtonGroup();\n        jScrollPane1 = new javax.swing.JScrollPane();\n        jPanel1 = new javax.swing.JPanel();\n        jLabel6 = new javax.swing.JLabel();\n        newRuleButton = new javax.swing.JButton();\n        filesRadioButton = new javax.swing.JRadioButton();\n        editRuleButton = new javax.swing.JButton();\n        rulesListLabel = new javax.swing.JLabel();\n        rulesListScrollPane = new javax.swing.JScrollPane();\n        rulesList = new javax.swing.JList<FilesSet.Rule>();\n        setDescScrollPanel = new javax.swing.JScrollPane();\n        setDescriptionTextArea = new javax.swing.JTextArea();\n        editSetButton = new javax.swing.JButton();\n        setsListScrollPane = new javax.swing.JScrollPane();\n        setsList = new javax.swing.JList<FilesSet>();\n        fileNameExtensionRadioButton = new javax.swing.JRadioButton();\n        jLabel3 = new javax.swing.JLabel();\n        fileNameTextField = new javax.swing.JTextField();\n        jLabel5 = new javax.swing.JLabel();\n        fileNameRadioButton = new javax.swing.JRadioButton();\n        rulePathConditionTextField = new javax.swing.JTextField();\n        ignoreKnownFilesCheckbox = new javax.swing.JCheckBox();\n        fileNameRegexCheckbox = new javax.swing.JCheckBox();\n        separator = new javax.swing.JSeparator();\n        setsListLabel = new javax.swing.JLabel();\n        bothRadioButton = new javax.swing.JRadioButton();\n        deleteSetButton = new javax.swing.JButton();\n        deleteRuleButton = new javax.swing.JButton();\n        newSetButton = new javax.swing.JButton();\n        jLabel2 = new javax.swing.JLabel();\n        dirsRadioButton = new javax.swing.JRadioButton();\n        jLabel1 = new javax.swing.JLabel();\n        jLabel4 = new javax.swing.JLabel();\n        rulePathConditionRegexCheckBox = new javax.swing.JCheckBox();\n        jScrollPane2 = new javax.swing.JScrollPane();\n        jTextArea1 = new javax.swing.JTextArea();\n        jLabel7 = new javax.swing.JLabel();\n        mimeTypeComboBox = new javax.swing.JComboBox<String>();\n        jLabel8 = new javax.swing.JLabel();\n        equalitySignComboBox = new javax.swing.JComboBox<String>();\n        jSpinner1 = new javax.swing.JSpinner();\n        fileSizeUnitComboBox = new javax.swing.JComboBox<String>();\n\n        setFont(getFont().deriveFont(getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n\n        jScrollPane1.setFont(jScrollPane1.getFont().deriveFont(jScrollPane1.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n\n        jPanel1.setFont(jPanel1.getFont().deriveFont(jPanel1.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n\n        jLabel6.setFont(jLabel6.getFont().deriveFont(jLabel6.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel6, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.jLabel6.text\")); // NOI18N\n\n        newRuleButton.setFont(newRuleButton.getFont().deriveFont(newRuleButton.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        newRuleButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/images/add16.png\"))); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(newRuleButton, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.newRuleButton.text\")); // NOI18N\n        newRuleButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                newRuleButtonActionPerformed(evt);\n            }\n        });\n\n        typeButtonGroup.add(filesRadioButton);\n        filesRadioButton.setFont(filesRadioButton.getFont().deriveFont(filesRadioButton.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        filesRadioButton.setSelected(true);\n        org.openide.awt.Mnemonics.setLocalizedText(filesRadioButton, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.filesRadioButton.text\")); // NOI18N\n        filesRadioButton.setEnabled(false);\n\n        editRuleButton.setFont(editRuleButton.getFont().deriveFont(editRuleButton.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        editRuleButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/images/edit16.png\"))); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(editRuleButton, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.editRuleButton.text\")); // NOI18N\n        editRuleButton.setEnabled(false);\n        editRuleButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                editRuleButtonActionPerformed(evt);\n            }\n        });\n\n        rulesListLabel.setFont(rulesListLabel.getFont().deriveFont(rulesListLabel.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(rulesListLabel, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.rulesListLabel.text\")); // NOI18N\n\n        rulesListScrollPane.setFont(rulesListScrollPane.getFont().deriveFont(rulesListScrollPane.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n\n        rulesList.setFont(rulesList.getFont().deriveFont(rulesList.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        rulesList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);\n        rulesListScrollPane.setViewportView(rulesList);\n\n        setDescScrollPanel.setFont(setDescScrollPanel.getFont().deriveFont(setDescScrollPanel.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n\n        setDescriptionTextArea.setEditable(false);\n        setDescriptionTextArea.setBackground(new java.awt.Color(240, 240, 240));\n        setDescriptionTextArea.setColumns(20);\n        setDescriptionTextArea.setFont(setDescriptionTextArea.getFont().deriveFont(setDescriptionTextArea.getFont().getStyle() & ~java.awt.Font.BOLD, 13));\n        setDescriptionTextArea.setLineWrap(true);\n        setDescriptionTextArea.setRows(2);\n        setDescScrollPanel.setViewportView(setDescriptionTextArea);\n\n        editSetButton.setFont(editSetButton.getFont().deriveFont(editSetButton.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        editSetButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/images/edit16.png\"))); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(editSetButton, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.editSetButton.text\")); // NOI18N\n        editSetButton.setEnabled(false);\n        editSetButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                editSetButtonActionPerformed(evt);\n            }\n        });\n\n        setsListScrollPane.setFont(setsListScrollPane.getFont().deriveFont(setsListScrollPane.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n\n        setsList.setFont(setsList.getFont().deriveFont(setsList.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        setsList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);\n        setsListScrollPane.setViewportView(setsList);\n\n        fileNameButtonGroup.add(fileNameExtensionRadioButton);\n        fileNameExtensionRadioButton.setFont(fileNameExtensionRadioButton.getFont().deriveFont(fileNameExtensionRadioButton.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(fileNameExtensionRadioButton, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.fileNameExtensionRadioButton.text\")); // NOI18N\n        fileNameExtensionRadioButton.setEnabled(false);\n\n        jLabel3.setFont(jLabel3.getFont().deriveFont(jLabel3.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel3, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.jLabel3.text\")); // NOI18N\n\n        fileNameTextField.setEditable(false);\n        fileNameTextField.setFont(fileNameTextField.getFont().deriveFont(fileNameTextField.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        fileNameTextField.setText(org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.fileNameTextField.text\")); // NOI18N\n        fileNameTextField.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                fileNameTextFieldActionPerformed(evt);\n            }\n        });\n\n        jLabel5.setFont(jLabel5.getFont().deriveFont(jLabel5.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel5, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.jLabel5.text\")); // NOI18N\n\n        fileNameButtonGroup.add(fileNameRadioButton);\n        fileNameRadioButton.setFont(fileNameRadioButton.getFont().deriveFont(fileNameRadioButton.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(fileNameRadioButton, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.fileNameRadioButton.text\")); // NOI18N\n        fileNameRadioButton.setEnabled(false);\n\n        rulePathConditionTextField.setEditable(false);\n        rulePathConditionTextField.setFont(rulePathConditionTextField.getFont().deriveFont(rulePathConditionTextField.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        rulePathConditionTextField.setText(org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.rulePathConditionTextField.text\")); // NOI18N\n\n        ignoreKnownFilesCheckbox.setFont(ignoreKnownFilesCheckbox.getFont().deriveFont(ignoreKnownFilesCheckbox.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(ignoreKnownFilesCheckbox, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.ignoreKnownFilesCheckbox.text\")); // NOI18N\n        ignoreKnownFilesCheckbox.setEnabled(false);\n        ignoreKnownFilesCheckbox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                ignoreKnownFilesCheckboxActionPerformed(evt);\n            }\n        });\n\n        fileNameRegexCheckbox.setFont(fileNameRegexCheckbox.getFont().deriveFont(fileNameRegexCheckbox.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(fileNameRegexCheckbox, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.fileNameRegexCheckbox.text\")); // NOI18N\n        fileNameRegexCheckbox.setEnabled(false);\n\n        separator.setOrientation(javax.swing.SwingConstants.VERTICAL);\n\n        setsListLabel.setFont(setsListLabel.getFont().deriveFont(setsListLabel.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(setsListLabel, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.setsListLabel.text\")); // NOI18N\n\n        typeButtonGroup.add(bothRadioButton);\n        bothRadioButton.setFont(bothRadioButton.getFont().deriveFont(bothRadioButton.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(bothRadioButton, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.bothRadioButton.text\")); // NOI18N\n        bothRadioButton.setEnabled(false);\n\n        deleteSetButton.setFont(deleteSetButton.getFont().deriveFont(deleteSetButton.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        deleteSetButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/images/delete16.png\"))); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(deleteSetButton, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.deleteSetButton.text\")); // NOI18N\n        deleteSetButton.setEnabled(false);\n        deleteSetButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                deleteSetButtonActionPerformed(evt);\n            }\n        });\n\n        deleteRuleButton.setFont(deleteRuleButton.getFont().deriveFont(deleteRuleButton.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        deleteRuleButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/images/delete16.png\"))); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(deleteRuleButton, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.deleteRuleButton.text\")); // NOI18N\n        deleteRuleButton.setEnabled(false);\n        deleteRuleButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                deleteRuleButtonActionPerformed(evt);\n            }\n        });\n\n        newSetButton.setFont(newSetButton.getFont().deriveFont(newSetButton.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        newSetButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/images/add16.png\"))); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(newSetButton, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.newSetButton.text\")); // NOI18N\n        newSetButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                newSetButtonActionPerformed(evt);\n            }\n        });\n\n        jLabel2.setFont(jLabel2.getFont().deriveFont(jLabel2.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel2, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.jLabel2.text\")); // NOI18N\n\n        typeButtonGroup.add(dirsRadioButton);\n        dirsRadioButton.setFont(dirsRadioButton.getFont().deriveFont(dirsRadioButton.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(dirsRadioButton, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.dirsRadioButton.text\")); // NOI18N\n        dirsRadioButton.setEnabled(false);\n        dirsRadioButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                dirsRadioButtonActionPerformed(evt);\n            }\n        });\n\n        jLabel1.setFont(jLabel1.getFont().deriveFont(jLabel1.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.jLabel1.text\")); // NOI18N\n\n        jLabel4.setFont(jLabel4.getFont().deriveFont(jLabel4.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel4, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.jLabel4.text\")); // NOI18N\n\n        rulePathConditionRegexCheckBox.setFont(rulePathConditionRegexCheckBox.getFont().deriveFont(rulePathConditionRegexCheckBox.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(rulePathConditionRegexCheckBox, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.rulePathConditionRegexCheckBox.text\")); // NOI18N\n        rulePathConditionRegexCheckBox.setEnabled(false);\n\n        jScrollPane2.setFont(jScrollPane2.getFont().deriveFont(jScrollPane2.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n\n        jTextArea1.setEditable(false);\n        jTextArea1.setBackground(new java.awt.Color(240, 240, 240));\n        jTextArea1.setColumns(20);\n        jTextArea1.setFont(jTextArea1.getFont().deriveFont(jTextArea1.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        jTextArea1.setLineWrap(true);\n        jTextArea1.setRows(3);\n        jTextArea1.setText(org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.jTextArea1.text\")); // NOI18N\n        jTextArea1.setWrapStyleWord(true);\n        jScrollPane2.setViewportView(jTextArea1);\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel7, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.jLabel7.text\")); // NOI18N\n\n        mimeTypeComboBox.setEditable(true);\n        mimeTypeComboBox.setModel(new javax.swing.DefaultComboBoxModel<String>(new String[] {\"\"}));\n        mimeTypeComboBox.setEnabled(false);\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel8, org.openide.util.NbBundle.getMessage(InterestingItemDefsPanel.class, \"InterestingItemDefsPanel.jLabel8.text\")); // NOI18N\n\n        equalitySignComboBox.setModel(new javax.swing.DefaultComboBoxModel<String>(new String[] { \"=\", \">\", \"\", \"<\", \"\" }));\n        equalitySignComboBox.setEnabled(false);\n\n        jSpinner1.setEnabled(false);\n\n        fileSizeUnitComboBox.setModel(new javax.swing.DefaultComboBoxModel<String>(new String[] { Bundle.InterestingItemDefsPanel_bytes(), Bundle.InterestingItemDefsPanel_kiloBytes(), Bundle.InterestingItemDefsPanel_megaBytes(), Bundle.InterestingItemDefsPanel_gigaBytes() }));\n        fileSizeUnitComboBox.setEnabled(false);\n\n        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);\n        jPanel1.setLayout(jPanel1Layout);\n        jPanel1Layout.setHorizontalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel1Layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(setsListLabel)\n                    .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)\n                        .addComponent(setsListScrollPane, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 314, Short.MAX_VALUE)\n                        .addComponent(jScrollPane2, javax.swing.GroupLayout.Alignment.LEADING))\n                    .addGroup(jPanel1Layout.createSequentialGroup()\n                        .addComponent(newSetButton, javax.swing.GroupLayout.PREFERRED_SIZE, 93, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(editSetButton, javax.swing.GroupLayout.PREFERRED_SIZE, 89, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(deleteSetButton)))\n                .addGap(18, 18, 18)\n                .addComponent(separator, javax.swing.GroupLayout.PREFERRED_SIZE, 6, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(12, 12, 12)\n                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addGroup(jPanel1Layout.createSequentialGroup()\n                        .addComponent(jLabel1)\n                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n                    .addGroup(jPanel1Layout.createSequentialGroup()\n                        .addComponent(jLabel2)\n                        .addGap(27, 27, 27)\n                        .addComponent(filesRadioButton, javax.swing.GroupLayout.PREFERRED_SIZE, 47, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(dirsRadioButton)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(bothRadioButton)\n                        .addGap(27, 27, 27))))\n            .addGroup(jPanel1Layout.createSequentialGroup()\n                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(jPanel1Layout.createSequentialGroup()\n                        .addGap(380, 380, 380)\n                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(jPanel1Layout.createSequentialGroup()\n                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addComponent(jLabel3)\n                                    .addComponent(jLabel7)\n                                    .addComponent(jLabel8))\n                                .addGap(6, 6, 6))\n                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()\n                                .addComponent(jLabel4)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)))\n                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)\n                            .addComponent(rulePathConditionTextField, javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(javax.swing.GroupLayout.Alignment.LEADING, jPanel1Layout.createSequentialGroup()\n                                .addComponent(equalitySignComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 38, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(jSpinner1, javax.swing.GroupLayout.PREFERRED_SIZE, 104, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(fileSizeUnitComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 83, javax.swing.GroupLayout.PREFERRED_SIZE))\n                            .addComponent(mimeTypeComboBox, javax.swing.GroupLayout.Alignment.LEADING, 0, 245, Short.MAX_VALUE)\n                            .addComponent(fileNameTextField)))\n                    .addGroup(jPanel1Layout.createSequentialGroup()\n                        .addGap(360, 360, 360)\n                        .addComponent(rulesListLabel))\n                    .addGroup(jPanel1Layout.createSequentialGroup()\n                        .addGap(360, 360, 360)\n                        .addComponent(jLabel5))\n                    .addGroup(jPanel1Layout.createSequentialGroup()\n                        .addGap(360, 360, 360)\n                        .addComponent(ignoreKnownFilesCheckbox))\n                    .addGroup(jPanel1Layout.createSequentialGroup()\n                        .addGap(360, 360, 360)\n                        .addComponent(setDescScrollPanel, javax.swing.GroupLayout.PREFERRED_SIZE, 336, javax.swing.GroupLayout.PREFERRED_SIZE))\n                    .addGroup(jPanel1Layout.createSequentialGroup()\n                        .addGap(360, 360, 360)\n                        .addComponent(jLabel6))\n                    .addGroup(jPanel1Layout.createSequentialGroup()\n                        .addGap(360, 360, 360)\n                        .addComponent(rulesListScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 336, javax.swing.GroupLayout.PREFERRED_SIZE))\n                    .addGroup(jPanel1Layout.createSequentialGroup()\n                        .addGap(360, 360, 360)\n                        .addComponent(newRuleButton)\n                        .addGap(18, 18, 18)\n                        .addComponent(editRuleButton)\n                        .addGap(18, 18, 18)\n                        .addComponent(deleteRuleButton))\n                    .addGroup(jPanel1Layout.createSequentialGroup()\n                        .addGap(456, 456, 456)\n                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(jPanel1Layout.createSequentialGroup()\n                                .addComponent(fileNameRadioButton)\n                                .addGap(4, 4, 4)\n                                .addComponent(fileNameExtensionRadioButton)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                .addComponent(fileNameRegexCheckbox))\n                            .addComponent(rulePathConditionRegexCheckBox))))\n                .addGap(20, 20, 20))\n        );\n        jPanel1Layout.setVerticalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel1Layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(separator)\n                    .addGroup(jPanel1Layout.createSequentialGroup()\n                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(jPanel1Layout.createSequentialGroup()\n                                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addGap(18, 18, 18)\n                                .addComponent(setsListLabel)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(setsListScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 199, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                                    .addComponent(newSetButton)\n                                    .addComponent(editSetButton)\n                                    .addComponent(deleteSetButton)))\n                            .addGroup(jPanel1Layout.createSequentialGroup()\n                                .addComponent(jLabel6)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(jLabel5)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(setDescScrollPanel, javax.swing.GroupLayout.PREFERRED_SIZE, 42, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(ignoreKnownFilesCheckbox)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                .addComponent(rulesListLabel)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(rulesListScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 64, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                                    .addComponent(newRuleButton)\n                                    .addComponent(editRuleButton)\n                                    .addComponent(deleteRuleButton))\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(jLabel1)\n                                .addGap(2, 2, 2)\n                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                                    .addComponent(jLabel2)\n                                    .addComponent(filesRadioButton)\n                                    .addComponent(dirsRadioButton)\n                                    .addComponent(bothRadioButton))\n                                .addGap(16, 16, 16)\n                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                                    .addComponent(jLabel3)\n                                    .addComponent(fileNameTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                                    .addComponent(fileNameRadioButton)\n                                    .addComponent(fileNameExtensionRadioButton)\n                                    .addComponent(fileNameRegexCheckbox))))\n                        .addGap(14, 14, 14)\n                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(jLabel4)\n                            .addComponent(rulePathConditionTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(rulePathConditionRegexCheckBox)\n                        .addGap(10, 10, 10)\n                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(jLabel7)\n                            .addComponent(mimeTypeComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addGap(16, 16, 16)\n                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(jLabel8)\n                            .addComponent(equalitySignComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addComponent(jSpinner1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addComponent(fileSizeUnitComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))))\n                .addContainerGap())\n        );\n\n        jPanel1Layout.linkSize(javax.swing.SwingConstants.VERTICAL, new java.awt.Component[] {deleteRuleButton, deleteSetButton, editRuleButton, editSetButton, newRuleButton, newSetButton});\n\n        jScrollPane1.setViewportView(jPanel1);\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 728, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(0, 34, Short.MAX_VALUE))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 503, Short.MAX_VALUE)\n        );\n    }","commit_id":"25e63e198b271fcacd37e72d331f09cff87b53aa","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"protected UserResponse<RSP> perform(Channel channel) throws EXC {\n        try {\n            ClassLoader cl = channel.importedClassLoaders.get(classLoaderProxy);\n\n            RSP r = null;\n            Channel oldc = Channel.setCurrent(channel);\n            try {\n                Object o = new ObjectInputStreamEx(new ByteArrayInputStream(request), cl).readObject();\n                \n                Callable<RSP,EXC> callable = (Callable<RSP,EXC>)o;\n\n                ClassLoader old = Thread.currentThread().getContextClassLoader();\n                Thread.currentThread().setContextClassLoader(cl);\n                // execute the service\n                try {\n                    r = callable.call();\n                } finally {\n                    Thread.currentThread().setContextClassLoader(old);\n                }\n            } finally {\n                Channel.setCurrent(oldc);\n            }\n\n            return new UserResponse<RSP>(serialize(r,channel));\n        } catch (IOException e) {\n            // propagate this to the calling process\n            throw (EXC)e;\n        } catch (ClassNotFoundException e) {\n            // propagate this to the calling process\n            throw (EXC)e;\n        }\n    }","id":65616,"modified_method":"protected UserResponse<RSP,EXC> perform(Channel channel) throws EXC {\n        try {\n            ClassLoader cl = channel.importedClassLoaders.get(classLoaderProxy);\n\n            RSP r = null;\n            Channel oldc = Channel.setCurrent(channel);\n            try {\n                Object o = new ObjectInputStreamEx(new ByteArrayInputStream(request), cl).readObject();\n                \n                Callable<RSP,EXC> callable = (Callable<RSP,EXC>)o;\n\n                ClassLoader old = Thread.currentThread().getContextClassLoader();\n                Thread.currentThread().setContextClassLoader(cl);\n                // execute the service\n                try {\n                    r = callable.call();\n                } finally {\n                    Thread.currentThread().setContextClassLoader(old);\n                }\n            } finally {\n                Channel.setCurrent(oldc);\n            }\n\n            return new UserResponse<RSP,EXC>(serialize(r,channel),false);\n        } catch (Throwable e) {\n            // propagate this to the calling process\n            try {\n                return new UserResponse<RSP,EXC>(serialize(e,channel),true);\n            } catch (IOException x) {\n                // throw it as a lower-level exception\n                throw (EXC)x;\n            }\n        }\n    }","commit_id":"98e7aa7d7f8b7585eca36e607b367741436bb259","url":"https://github.com/kohsuke/hudson"},{"original_method":"public RSP retrieve(Channel channel, ClassLoader cl) throws IOException, ClassNotFoundException {\n        return (RSP) new ObjectInputStreamEx(new ByteArrayInputStream(response),cl).readObject();\n    }","id":65617,"modified_method":"public RSP retrieve(Channel channel, ClassLoader cl) throws IOException, ClassNotFoundException, EXC {\n        Object o = new ObjectInputStreamEx(new ByteArrayInputStream(response), cl).readObject();\n        if(isException)\n            throw (EXC)o;\n        else\n            return (RSP) o;\n    }","commit_id":"98e7aa7d7f8b7585eca36e607b367741436bb259","url":"https://github.com/kohsuke/hudson"},{"original_method":"public UserResponse(byte[] response) {\n        this.response = response;\n    }","id":65618,"modified_method":"public UserResponse(byte[] response, boolean isException) {\n        this.response = response;\n        this.isException = isException;\n    }","commit_id":"98e7aa7d7f8b7585eca36e607b367741436bb259","url":"https://github.com/kohsuke/hudson"},{"original_method":"public static void getActionsToShow(@NotNull final Editor hostEditor,\n                                      @NotNull final PsiFile hostFile,\n                                      @NotNull final IntentionsInfo intentions,\n                                      int passIdToShowIntentionsFor) {\n    final PsiElement psiElement = hostFile.findElementAt(hostEditor.getCaretModel().getOffset());\n    LOG.assertTrue(psiElement == null || psiElement.isValid(), psiElement);\n\n    int offset = hostEditor.getCaretModel().getOffset();\n    final Project project = hostFile.getProject();\n\n    List<HighlightInfo.IntentionActionDescriptor> fixes = getAvailableActions(hostEditor, hostFile, passIdToShowIntentionsFor);\n    final DaemonCodeAnalyzer codeAnalyzer = DaemonCodeAnalyzer.getInstance(project);\n    final Document hostDocument = hostEditor.getDocument();\n    HighlightInfo infoAtCursor = ((DaemonCodeAnalyzerImpl)codeAnalyzer).findHighlightByOffset(hostDocument, offset, true);\n    if (infoAtCursor == null) {\n      intentions.errorFixesToShow.addAll(fixes);\n    }\n    else {\n      final boolean isError = infoAtCursor.getSeverity() == HighlightSeverity.ERROR;\n      for (HighlightInfo.IntentionActionDescriptor fix : fixes) {\n        if (fix.isError() && isError) {\n          intentions.errorFixesToShow.add(fix);\n        }\n        else {\n          intentions.inspectionFixesToShow.add(fix);\n        }\n      }\n    }\n\n    for (final IntentionAction action : IntentionManager.getInstance().getAvailableIntentionActions()) {\n      Pair<PsiFile, Editor> place =\n        ShowIntentionActionsHandler.chooseBetweenHostAndInjected(hostFile, hostEditor,\n                                                                 (psiFile, editor) -> ShowIntentionActionsHandler.availableFor(psiFile, editor, action));\n\n      if (place != null) {\n        List<IntentionAction> enableDisableIntentionAction = new ArrayList<>();\n        enableDisableIntentionAction.add(new IntentionHintComponent.EnableDisableIntentionAction(action));\n        enableDisableIntentionAction.add(new IntentionHintComponent.EditIntentionSettingsAction(action));\n        HighlightInfo.IntentionActionDescriptor descriptor = new HighlightInfo.IntentionActionDescriptor(action, enableDisableIntentionAction, null);\n        if (!fixes.contains(descriptor)) {\n          intentions.intentionsToShow.add(descriptor);\n        }\n      }\n    }\n\n    if (HighlightingLevelManager.getInstance(project).shouldInspect(hostFile)) {\n      collectIntentionsFromDoNotShowLeveledInspections(project, hostFile, psiElement, offset, intentions);\n    }\n\n    final int line = hostDocument.getLineNumber(offset);\n    MarkupModelEx model = (MarkupModelEx)DocumentMarkupModel.forDocument(hostDocument, project, true);\n    List<RangeHighlighterEx> result = new ArrayList<>();\n    Processor<RangeHighlighterEx> processor = Processors.cancelableCollectProcessor(result);\n    model.processRangeHighlightersOverlappingWith(hostDocument.getLineStartOffset(line),\n                                                  hostDocument.getLineEndOffset(line),\n                                                  processor);\n\n    GutterIntentionAction.addActions(hostEditor, intentions, project, result);\n\n    boolean cleanup = appendCleanupCode(intentions.inspectionFixesToShow, hostFile);\n    if (!cleanup) {\n      appendCleanupCode(intentions.errorFixesToShow, hostFile);\n    }\n    \n    EditorNotificationActions.collectDescriptorsForEditor(hostEditor, intentions.notificationActionsToShow);\n  }","id":65619,"modified_method":"public static void getActionsToShow(@NotNull final Editor hostEditor,\n                                      @NotNull final PsiFile hostFile,\n                                      @NotNull final IntentionsInfo intentions,\n                                      int passIdToShowIntentionsFor) {\n    final PsiElement psiElement = hostFile.findElementAt(hostEditor.getCaretModel().getOffset());\n    LOG.assertTrue(psiElement == null || psiElement.isValid(), psiElement);\n\n    int offset = hostEditor.getCaretModel().getOffset();\n    final Project project = hostFile.getProject();\n\n    List<HighlightInfo.IntentionActionDescriptor> fixes = getAvailableActions(hostEditor, hostFile, passIdToShowIntentionsFor);\n    final DaemonCodeAnalyzer codeAnalyzer = DaemonCodeAnalyzer.getInstance(project);\n    final Document hostDocument = hostEditor.getDocument();\n    HighlightInfo infoAtCursor = ((DaemonCodeAnalyzerImpl)codeAnalyzer).findHighlightByOffset(hostDocument, offset, true);\n    if (infoAtCursor == null) {\n      intentions.errorFixesToShow.addAll(fixes);\n    }\n    else {\n      final boolean isError = infoAtCursor.getSeverity() == HighlightSeverity.ERROR;\n      for (HighlightInfo.IntentionActionDescriptor fix : fixes) {\n        if (fix.isError() && isError) {\n          intentions.errorFixesToShow.add(fix);\n        }\n        else {\n          intentions.inspectionFixesToShow.add(fix);\n        }\n      }\n    }\n\n    for (final IntentionAction action : IntentionManager.getInstance().getAvailableIntentionActions()) {\n      Pair<PsiFile, Editor> place =\n        ShowIntentionActionsHandler.chooseBetweenHostAndInjected(hostFile, hostEditor,\n                                                                 (psiFile, editor) -> ShowIntentionActionsHandler.availableFor(psiFile, editor, action));\n\n      if (place != null) {\n        List<IntentionAction> enableDisableIntentionAction = new ArrayList<>();\n        enableDisableIntentionAction.add(new IntentionHintComponent.EnableDisableIntentionAction(action));\n        enableDisableIntentionAction.add(new IntentionHintComponent.EditIntentionSettingsAction(action));\n        HighlightInfo.IntentionActionDescriptor descriptor = new HighlightInfo.IntentionActionDescriptor(action, enableDisableIntentionAction, null);\n        if (!fixes.contains(descriptor)) {\n          intentions.intentionsToShow.add(descriptor);\n        }\n      }\n    }\n\n    if (HighlightingLevelManager.getInstance(project).shouldInspect(hostFile)) {\n      PsiElement adjustedElement = psiElement;\n      int adjustedOffset = offset;\n      if (psiElement instanceof PsiWhiteSpace) {\n        final PsiElement prev = psiElement.getPrevSibling();\n        if (prev != null) {\n          adjustedElement = prev;\n          final TextRange range = prev.getTextRange();\n          adjustedOffset = range.isEmpty() ? range.getEndOffset() : range.getEndOffset() - 1;\n        }\n      }\n      collectIntentionsFromDoNotShowLeveledInspections(project, hostFile, adjustedElement, adjustedOffset, intentions);\n    }\n\n    final int line = hostDocument.getLineNumber(offset);\n    MarkupModelEx model = (MarkupModelEx)DocumentMarkupModel.forDocument(hostDocument, project, true);\n    List<RangeHighlighterEx> result = new ArrayList<>();\n    Processor<RangeHighlighterEx> processor = Processors.cancelableCollectProcessor(result);\n    model.processRangeHighlightersOverlappingWith(hostDocument.getLineStartOffset(line),\n                                                  hostDocument.getLineEndOffset(line),\n                                                  processor);\n\n    GutterIntentionAction.addActions(hostEditor, intentions, project, result);\n\n    boolean cleanup = appendCleanupCode(intentions.inspectionFixesToShow, hostFile);\n    if (!cleanup) {\n      appendCleanupCode(intentions.errorFixesToShow, hostFile);\n    }\n    \n    EditorNotificationActions.collectDescriptorsForEditor(hostEditor, intentions.notificationActionsToShow);\n  }","commit_id":"f0752dd7b012fe29ed730ca0cd0df4cfdf64e7b1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void getActionsToShow(@NotNull final Editor hostEditor,\n                                      @NotNull final PsiFile hostFile,\n                                      @NotNull final IntentionsInfo intentions,\n                                      int passIdToShowIntentionsFor) {\n    final PsiElement psiElement = hostFile.findElementAt(hostEditor.getCaretModel().getOffset());\n    LOG.assertTrue(psiElement == null || psiElement.isValid(), psiElement);\n\n    int offset = hostEditor.getCaretModel().getOffset();\n    final Project project = hostFile.getProject();\n\n    List<HighlightInfo.IntentionActionDescriptor> fixes = getAvailableActions(hostEditor, hostFile, passIdToShowIntentionsFor);\n    final DaemonCodeAnalyzer codeAnalyzer = DaemonCodeAnalyzer.getInstance(project);\n    final Document hostDocument = hostEditor.getDocument();\n    HighlightInfo infoAtCursor = ((DaemonCodeAnalyzerImpl)codeAnalyzer).findHighlightByOffset(hostDocument, offset, true);\n    if (infoAtCursor == null) {\n      intentions.errorFixesToShow.addAll(fixes);\n    }\n    else {\n      final boolean isError = infoAtCursor.getSeverity() == HighlightSeverity.ERROR;\n      for (HighlightInfo.IntentionActionDescriptor fix : fixes) {\n        if (fix.isError() && isError) {\n          intentions.errorFixesToShow.add(fix);\n        }\n        else {\n          intentions.inspectionFixesToShow.add(fix);\n        }\n      }\n    }\n\n    for (final IntentionAction action : IntentionManager.getInstance().getAvailableIntentionActions()) {\n      Pair<PsiFile, Editor> place =\n        ShowIntentionActionsHandler.chooseBetweenHostAndInjected(hostFile, hostEditor,\n                                                                 (psiFile, editor) -> ShowIntentionActionsHandler.availableFor(psiFile, editor, action));\n\n      if (place != null) {\n        List<IntentionAction> enableDisableIntentionAction = new ArrayList<IntentionAction>();\n        enableDisableIntentionAction.add(new IntentionHintComponent.EnableDisableIntentionAction(action));\n        enableDisableIntentionAction.add(new IntentionHintComponent.EditIntentionSettingsAction(action));\n        HighlightInfo.IntentionActionDescriptor descriptor = new HighlightInfo.IntentionActionDescriptor(action, enableDisableIntentionAction, null);\n        if (!fixes.contains(descriptor)) {\n          intentions.intentionsToShow.add(descriptor);\n        }\n      }\n    }\n\n    collectIntentionsFromDoNotShowLeveledInspections(project, hostFile, psiElement, offset, intentions);\n\n    final int line = hostDocument.getLineNumber(offset);\n    MarkupModelEx model = (MarkupModelEx)DocumentMarkupModel.forDocument(hostDocument, project, true);\n    List<RangeHighlighterEx> result = new ArrayList<>();\n    Processor<RangeHighlighterEx> processor = Processors.cancelableCollectProcessor(result);\n    model.processRangeHighlightersOverlappingWith(hostDocument.getLineStartOffset(line),\n                                                  hostDocument.getLineEndOffset(line),\n                                                  processor);\n\n    GutterIntentionAction.addActions(hostEditor, intentions, project, result);\n\n    boolean cleanup = appendCleanupCode(intentions.inspectionFixesToShow, hostFile);\n    if (!cleanup) {\n      appendCleanupCode(intentions.errorFixesToShow, hostFile);\n    }\n    \n    EditorNotificationActions.collectDescriptorsForEditor(hostEditor, intentions.notificationActionsToShow);\n  }","id":65620,"modified_method":"public static void getActionsToShow(@NotNull final Editor hostEditor,\n                                      @NotNull final PsiFile hostFile,\n                                      @NotNull final IntentionsInfo intentions,\n                                      int passIdToShowIntentionsFor) {\n    final PsiElement psiElement = hostFile.findElementAt(hostEditor.getCaretModel().getOffset());\n    LOG.assertTrue(psiElement == null || psiElement.isValid(), psiElement);\n\n    int offset = hostEditor.getCaretModel().getOffset();\n    final Project project = hostFile.getProject();\n\n    List<HighlightInfo.IntentionActionDescriptor> fixes = getAvailableActions(hostEditor, hostFile, passIdToShowIntentionsFor);\n    final DaemonCodeAnalyzer codeAnalyzer = DaemonCodeAnalyzer.getInstance(project);\n    final Document hostDocument = hostEditor.getDocument();\n    HighlightInfo infoAtCursor = ((DaemonCodeAnalyzerImpl)codeAnalyzer).findHighlightByOffset(hostDocument, offset, true);\n    if (infoAtCursor == null) {\n      intentions.errorFixesToShow.addAll(fixes);\n    }\n    else {\n      final boolean isError = infoAtCursor.getSeverity() == HighlightSeverity.ERROR;\n      for (HighlightInfo.IntentionActionDescriptor fix : fixes) {\n        if (fix.isError() && isError) {\n          intentions.errorFixesToShow.add(fix);\n        }\n        else {\n          intentions.inspectionFixesToShow.add(fix);\n        }\n      }\n    }\n\n    for (final IntentionAction action : IntentionManager.getInstance().getAvailableIntentionActions()) {\n      Pair<PsiFile, Editor> place =\n        ShowIntentionActionsHandler.chooseBetweenHostAndInjected(hostFile, hostEditor,\n                                                                 (psiFile, editor) -> ShowIntentionActionsHandler.availableFor(psiFile, editor, action));\n\n      if (place != null) {\n        List<IntentionAction> enableDisableIntentionAction = new ArrayList<IntentionAction>();\n        enableDisableIntentionAction.add(new IntentionHintComponent.EnableDisableIntentionAction(action));\n        enableDisableIntentionAction.add(new IntentionHintComponent.EditIntentionSettingsAction(action));\n        HighlightInfo.IntentionActionDescriptor descriptor = new HighlightInfo.IntentionActionDescriptor(action, enableDisableIntentionAction, null);\n        if (!fixes.contains(descriptor)) {\n          intentions.intentionsToShow.add(descriptor);\n        }\n      }\n    }\n\n    if (HighlightingLevelManager.getInstance(project).shouldInspect(hostFile)) {\n      collectIntentionsFromDoNotShowLeveledInspections(project, hostFile, psiElement, offset, intentions);\n    }\n\n    final int line = hostDocument.getLineNumber(offset);\n    MarkupModelEx model = (MarkupModelEx)DocumentMarkupModel.forDocument(hostDocument, project, true);\n    List<RangeHighlighterEx> result = new ArrayList<>();\n    Processor<RangeHighlighterEx> processor = Processors.cancelableCollectProcessor(result);\n    model.processRangeHighlightersOverlappingWith(hostDocument.getLineStartOffset(line),\n                                                  hostDocument.getLineEndOffset(line),\n                                                  processor);\n\n    GutterIntentionAction.addActions(hostEditor, intentions, project, result);\n\n    boolean cleanup = appendCleanupCode(intentions.inspectionFixesToShow, hostFile);\n    if (!cleanup) {\n      appendCleanupCode(intentions.errorFixesToShow, hostFile);\n    }\n    \n    EditorNotificationActions.collectDescriptorsForEditor(hostEditor, intentions.notificationActionsToShow);\n  }","commit_id":"51cd51c0cbf1b2c8c8d2d0c6c52a6b14d470a7ae","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void getActionsToShow(@NotNull final Editor hostEditor,\n                                      @NotNull final PsiFile hostFile,\n                                      @NotNull final IntentionsInfo intentions,\n                                      int passIdToShowIntentionsFor) {\n    final PsiElement psiElement = hostFile.findElementAt(hostEditor.getCaretModel().getOffset());\n    LOG.assertTrue(psiElement == null || psiElement.isValid(), psiElement);\n\n    int offset = hostEditor.getCaretModel().getOffset();\n    final Project project = hostFile.getProject();\n\n    List<HighlightInfo.IntentionActionDescriptor> fixes = getAvailableActions(hostEditor, hostFile, passIdToShowIntentionsFor);\n    final DaemonCodeAnalyzer codeAnalyzer = DaemonCodeAnalyzer.getInstance(project);\n    final Document hostDocument = hostEditor.getDocument();\n    HighlightInfo infoAtCursor = ((DaemonCodeAnalyzerImpl)codeAnalyzer).findHighlightByOffset(hostDocument, offset, true);\n    if (infoAtCursor == null) {\n      intentions.errorFixesToShow.addAll(fixes);\n    }\n    else {\n      final boolean isError = infoAtCursor.getSeverity() == HighlightSeverity.ERROR;\n      for (HighlightInfo.IntentionActionDescriptor fix : fixes) {\n        if (fix.isError() && isError) {\n          intentions.errorFixesToShow.add(fix);\n        }\n        else {\n          intentions.inspectionFixesToShow.add(fix);\n        }\n      }\n    }\n\n    for (final IntentionAction action : IntentionManager.getInstance().getAvailableIntentionActions()) {\n      Pair<PsiFile, Editor> place =\n        ShowIntentionActionsHandler.chooseBetweenHostAndInjected(hostFile, hostEditor,\n                                                                 (psiFile, editor) -> ShowIntentionActionsHandler.availableFor(psiFile, editor, action));\n\n      if (place != null) {\n        List<IntentionAction> enableDisableIntentionAction = new ArrayList<>();\n        enableDisableIntentionAction.add(new IntentionHintComponent.EnableDisableIntentionAction(action));\n        enableDisableIntentionAction.add(new IntentionHintComponent.EditIntentionSettingsAction(action));\n        HighlightInfo.IntentionActionDescriptor descriptor = new HighlightInfo.IntentionActionDescriptor(action, enableDisableIntentionAction, null);\n        if (!fixes.contains(descriptor)) {\n          intentions.intentionsToShow.add(descriptor);\n        }\n      }\n    }\n\n    if (HighlightingLevelManager.getInstance(project).shouldInspect(hostFile)) {\n      PsiElement intentionElement = psiElement;\n      int intentionOffset = offset;\n      if (psiElement instanceof PsiWhiteSpace && offset == psiElement.getTextRange().getStartOffset() && offset > 0) {\n        final PsiElement prev = hostFile.findElementAt(offset - 1);\n        if (prev != null && prev.isValid()) {\n          intentionElement = prev;\n          intentionOffset = offset - 1;\n        }\n      }\n      collectIntentionsFromDoNotShowLeveledInspections(project, hostFile, intentionElement, intentionOffset, intentions);\n    }\n\n    final int line = hostDocument.getLineNumber(offset);\n    MarkupModelEx model = (MarkupModelEx)DocumentMarkupModel.forDocument(hostDocument, project, true);\n    List<RangeHighlighterEx> result = new ArrayList<>();\n    Processor<RangeHighlighterEx> processor = Processors.cancelableCollectProcessor(result);\n    model.processRangeHighlightersOverlappingWith(hostDocument.getLineStartOffset(line),\n                                                  hostDocument.getLineEndOffset(line),\n                                                  processor);\n\n    GutterIntentionAction.addActions(hostEditor, intentions, project, result);\n\n    boolean cleanup = appendCleanupCode(intentions.inspectionFixesToShow, hostFile);\n    if (!cleanup) {\n      appendCleanupCode(intentions.errorFixesToShow, hostFile);\n    }\n    \n    EditorNotificationActions.collectDescriptorsForEditor(hostEditor, intentions.notificationActionsToShow);\n  }","id":65621,"modified_method":"public static void getActionsToShow(@NotNull final Editor hostEditor,\n                                      @NotNull final PsiFile hostFile,\n                                      @NotNull final IntentionsInfo intentions,\n                                      int passIdToShowIntentionsFor) {\n    final PsiElement psiElement = hostFile.findElementAt(hostEditor.getCaretModel().getOffset());\n    LOG.assertTrue(psiElement == null || psiElement.isValid(), psiElement);\n\n    int offset = hostEditor.getCaretModel().getOffset();\n    final Project project = hostFile.getProject();\n\n    List<HighlightInfo.IntentionActionDescriptor> fixes = getAvailableActions(hostEditor, hostFile, passIdToShowIntentionsFor);\n    final DaemonCodeAnalyzer codeAnalyzer = DaemonCodeAnalyzer.getInstance(project);\n    final Document hostDocument = hostEditor.getDocument();\n    HighlightInfo infoAtCursor = ((DaemonCodeAnalyzerImpl)codeAnalyzer).findHighlightByOffset(hostDocument, offset, true);\n    if (infoAtCursor == null) {\n      intentions.errorFixesToShow.addAll(fixes);\n    }\n    else {\n      final boolean isError = infoAtCursor.getSeverity() == HighlightSeverity.ERROR;\n      for (HighlightInfo.IntentionActionDescriptor fix : fixes) {\n        if (fix.isError() && isError) {\n          intentions.errorFixesToShow.add(fix);\n        }\n        else {\n          intentions.inspectionFixesToShow.add(fix);\n        }\n      }\n    }\n\n    for (final IntentionAction action : IntentionManager.getInstance().getAvailableIntentionActions()) {\n      Pair<PsiFile, Editor> place =\n        ShowIntentionActionsHandler.chooseBetweenHostAndInjected(hostFile, hostEditor,\n                                                                 (psiFile, editor) -> ShowIntentionActionsHandler.availableFor(psiFile, editor, action));\n\n      if (place != null) {\n        List<IntentionAction> enableDisableIntentionAction = new ArrayList<>();\n        enableDisableIntentionAction.add(new IntentionHintComponent.EnableDisableIntentionAction(action));\n        enableDisableIntentionAction.add(new IntentionHintComponent.EditIntentionSettingsAction(action));\n        HighlightInfo.IntentionActionDescriptor descriptor = new HighlightInfo.IntentionActionDescriptor(action, enableDisableIntentionAction, null);\n        if (!fixes.contains(descriptor)) {\n          intentions.intentionsToShow.add(descriptor);\n        }\n      }\n    }\n\n    if (HighlightingLevelManager.getInstance(project).shouldInspect(hostFile)) {\n      PsiElement intentionElement = psiElement;\n      int intentionOffset = offset;\n      if (psiElement instanceof PsiWhiteSpace && offset == psiElement.getTextRange().getStartOffset() && offset > 0) {\n        final PsiElement prev = hostFile.findElementAt(offset - 1);\n        if (prev != null && prev.isValid()) {\n          intentionElement = prev;\n          intentionOffset = offset - 1;\n        }\n      }\n      if (intentionElement != null && intentionElement.getManager().isInProject(intentionElement)) {\n        collectIntentionsFromDoNotShowLeveledInspections(project, hostFile, intentionElement, intentionOffset, intentions);\n      }\n    }\n\n    final int line = hostDocument.getLineNumber(offset);\n    MarkupModelEx model = (MarkupModelEx)DocumentMarkupModel.forDocument(hostDocument, project, true);\n    List<RangeHighlighterEx> result = new ArrayList<>();\n    Processor<RangeHighlighterEx> processor = Processors.cancelableCollectProcessor(result);\n    model.processRangeHighlightersOverlappingWith(hostDocument.getLineStartOffset(line),\n                                                  hostDocument.getLineEndOffset(line),\n                                                  processor);\n\n    GutterIntentionAction.addActions(hostEditor, intentions, project, result);\n\n    boolean cleanup = appendCleanupCode(intentions.inspectionFixesToShow, hostFile);\n    if (!cleanup) {\n      appendCleanupCode(intentions.errorFixesToShow, hostFile);\n    }\n    \n    EditorNotificationActions.collectDescriptorsForEditor(hostEditor, intentions.notificationActionsToShow);\n  }","commit_id":"29e8db04e35ca415cafd31303030792d8c9e482d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/** Returns whether it is a ZK attribute.\n\t */\n\tprivate static final boolean\n\tisZkAttr(LanguageDefinition langdef, Namespace attrns) {\n\t\t//if native we will make sure URI is ZK or lang's namespace\n\t\tif (langdef.isNative()) {\n\t\t\tfinal String uri = attrns.getURI();\n\t\t\treturn LanguageDefinition.ZK_NAMESPACE.equals(uri)\n\t\t\t\t|| langdef.getNamespace().equals(uri);\n\t\t}\n\t\treturn true;\n\t}","id":65622,"modified_method":"/** Returns whether it is a ZK attribute (in a non-ZK element).\n\t */\n\tprivate static final boolean\n\tisZkAttr(LanguageDefinition langdef, Namespace attrns) {\n\t\t//if native we will make sure URI is ZK or lang's namespace\n\t\tif (langdef.isNative()\n\t\t&& attrns != null && \"\".equals(attrns.getPrefix()))\n\t\t\treturn false; //if navtive, \"\" means not ZK\n\n\t\treturn isZkElementAttr(langdef, attrns);\n\t}","commit_id":"23e231146de944a5288e120af8c168b9989be868","url":"https://github.com/zkoss/zk"},{"original_method":"private static void parseVariables(NodeInfo parent, Element el,\n\tAnnotationHelper annHelper) throws Exception {\n\t\t//if (!el.getElements().isEmpty())\n\t\t//\tthrow new UiException(\"Child elements are not allowed for <variables> element, \"+el.getLocator());\n\n\t\tif (el.getAttributeItem(\"forEach\") != null)\n\t\t\tthrow new UiException(\"forEach not applicable to <variables>, \"+el.getLocator());\n\t\tif (annHelper.clear())\n\t\t\tlog.warning(\"Annotations are ignored since <variables> doesn't support them, \"+el.getLocator());\n\n\t\tString ifc = null, unless = null, composite = null;\n\t\tboolean local = false;\n\t\tfinal Map vars = new HashMap();\n\t\tfor (Iterator it = el.getAttributeItems().iterator();\n\t\tit.hasNext();) {\n\t\t\tfinal Attribute attr = (Attribute)it.next();\n\t\t\tfinal String attnm = attr.getLocalName();\n\t\t\tfinal String attval = attr.getValue();\n\t\t\tif (\"if\".equals(attnm)) {\n\t\t\t\tifc = attval;\n\t\t\t} else if (\"unless\".equals(attnm)) {\n\t\t\t\tunless = attval;\n\t\t\t} else if (\"local\".equals(attnm)) {\n\t\t\t\tlocal = \"true\".equals(attval);\n\t\t\t} else if (\"composite\".equals(attnm)) {\n\t\t\t\tcomposite = attval;\n\t\t\t} else if (\"forEach\".equals(attnm)) {\n\t\t\t\tthrow new UiException(\"forEach not applicable to <variables>, \"+el.getLocator());\n\t\t\t} else {\n\t\t\t\tvars.put(attnm, attval);\n\t\t\t}\n\t\t}\n\t\tif (!vars.isEmpty())\n\t\t\tparent.appendChild(new VariablesInfo(\n\t\t\t\tparent.getEvaluatorRef(),\n\t\t\t\tvars, local, composite, ConditionImpl.getInstance(ifc, unless)));\n\t}","id":65623,"modified_method":"private static void parseVariables(LanguageDefinition langdef,\n\tNodeInfo parent, Element el, AnnotationHelper annHelper) throws Exception {\n\t\t//if (!el.getElements().isEmpty())\n\t\t//\tthrow new UiException(\"Child elements are not allowed for <variables> element, \"+el.getLocator());\n\n\t\tif (annHelper.clear())\n\t\t\tlog.warning(\"Annotations are ignored since <variables> doesn't support them, \"+el.getLocator());\n\n\t\tString ifc = null, unless = null, composite = null;\n\t\tboolean local = false;\n\t\tfinal Map vars = new HashMap();\n\t\tfor (Iterator it = el.getAttributeItems().iterator();\n\t\tit.hasNext();) {\n\t\t\tfinal Attribute attr = (Attribute)it.next();\n\t\t\tfinal Namespace attrns = attr.getNamespace();\n\t\t\tfinal String attnm = attr.getLocalName();\n\t\t\tfinal String attval = attr.getValue();\n\t\t\tif (\"if\".equals(attnm) && isZkElementAttr(langdef, attrns)) {\n\t\t\t\tifc = attval;\n\t\t\t} else if (\"unless\".equals(attnm) && isZkElementAttr(langdef, attrns)) {\n\t\t\t\tunless = attval;\n\t\t\t} else if (\"local\".equals(attnm) && isZkElementAttr(langdef, attrns)) {\n\t\t\t\tlocal = \"true\".equals(attval);\n\t\t\t} else if (\"composite\".equals(attnm) && isZkElementAttr(langdef, attrns)) {\n\t\t\t\tcomposite = attval;\n\t\t\t} else if (\"forEach\".equals(attnm) && isZkElementAttr(langdef, attrns)) {\n\t\t\t\tthrow new UiException(\"forEach not applicable to <variables>, \"+el.getLocator());\n\t\t\t} else {\n\t\t\t\tvars.put(attnm, attval);\n\t\t\t}\n\t\t}\n\t\tif (!vars.isEmpty())\n\t\t\tparent.appendChild(new VariablesInfo(\n\t\t\t\tparent.getEvaluatorRef(),\n\t\t\t\tvars, local, composite, ConditionImpl.getInstance(ifc, unless)));\n\t}","commit_id":"23e231146de944a5288e120af8c168b9989be868","url":"https://github.com/zkoss/zk"},{"original_method":"private static void parseCustomAttributes(NodeInfo parent, Element el,\n\tAnnotationHelper annHelper) throws Exception {\n\t\t//if (!el.getElements().isEmpty())\n\t\t//\tthrow new UiException(\"Child elements are not allowed for <custom-attributes>, \"+el.getLocator());\n\n\t\tif (parent instanceof PageDefinition)\n\t\t\tthrow new UiException(\"custom-attributes must be used under a component, \"+el.getLocator());\n\t\tif (annHelper.clear())\n\t\t\tlog.warning(\"Annotations are ignored since <custom-attribute> doesn't support them, \"+el.getLocator());\n\n\t\tString ifc = null, unless = null, scope = null, composite = null;\n\t\tfinal Map attrs = new HashMap();\n\t\tfor (Iterator it = el.getAttributeItems().iterator();\n\t\tit.hasNext();) {\n\t\t\tfinal Attribute attr = (Attribute)it.next();\n\t\t\tfinal String attnm = attr.getLocalName();\n\t\t\tfinal String attval = attr.getValue();\n\t\t\tif (\"if\".equals(attnm)) {\n\t\t\t\tifc = attval;\n\t\t\t} else if (\"unless\".equals(attnm)) {\n\t\t\t\tunless = attval;\n\t\t\t} else if (\"scope\".equals(attnm)) {\n\t\t\t\tscope = attval;\n\t\t\t} else if (\"composite\".equals(attnm)) {\n\t\t\t\tcomposite = attval;\n\t\t\t} else if (\"forEach\".equals(attnm)) {\n\t\t\t\tthrow new UiException(\"forEach not applicable to <custom-attributes>, \"+el.getLocator());\n\t\t\t} else {\n\t\t\t\tattrs.put(attnm, attval);\n\t\t\t}\n\t\t}\n\n\t\tif (!attrs.isEmpty())\n\t\t\tparent.appendChild(new AttributesInfo(\n\t\t\t\tparent.getEvaluatorRef(),\n\t\t\t\tattrs, scope, composite, ConditionImpl.getInstance(ifc, unless)));\n\t}","id":65624,"modified_method":"private static void parseCustomAttributes(LanguageDefinition langdef,\n\tNodeInfo parent, Element el, AnnotationHelper annHelper) throws Exception {\n\t\t//if (!el.getElements().isEmpty())\n\t\t//\tthrow new UiException(\"Child elements are not allowed for <custom-attributes>, \"+el.getLocator());\n\n\t\tif (parent instanceof PageDefinition)\n\t\t\tthrow new UiException(\"custom-attributes must be used under a component, \"+el.getLocator());\n\t\tif (annHelper.clear())\n\t\t\tlog.warning(\"Annotations are ignored since <custom-attribute> doesn't support them, \"+el.getLocator());\n\n\t\tString ifc = null, unless = null, scope = null, composite = null;\n\t\tfinal Map attrs = new HashMap();\n\t\tfor (Iterator it = el.getAttributeItems().iterator();\n\t\tit.hasNext();) {\n\t\t\tfinal Attribute attr = (Attribute)it.next();\n\t\t\tfinal Namespace attrns = attr.getNamespace();\n\t\t\tfinal String attnm = attr.getLocalName();\n\t\t\tfinal String attval = attr.getValue();\n\t\t\tif (\"if\".equals(attnm) && isZkElementAttr(langdef, attrns)) {\n\t\t\t\tifc = attval;\n\t\t\t} else if (\"unless\".equals(attnm) && isZkElementAttr(langdef, attrns)) {\n\t\t\t\tunless = attval;\n\t\t\t} else if (\"scope\".equals(attnm) && isZkElementAttr(langdef, attrns)) {\n\t\t\t\tscope = attval;\n\t\t\t} else if (\"composite\".equals(attnm) && isZkElementAttr(langdef, attrns)) {\n\t\t\t\tcomposite = attval;\n\t\t\t} else if (\"forEach\".equals(attnm) && isZkElementAttr(langdef, attrns)) {\n\t\t\t\tthrow new UiException(\"forEach not applicable to <custom-attributes>, \"+el.getLocator());\n\t\t\t} else {\n\t\t\t\tattrs.put(attnm, attval);\n\t\t\t}\n\t\t}\n\n\t\tif (!attrs.isEmpty())\n\t\t\tparent.appendChild(new AttributesInfo(\n\t\t\t\tparent.getEvaluatorRef(),\n\t\t\t\tattrs, scope, composite, ConditionImpl.getInstance(ifc, unless)));\n\t}","commit_id":"23e231146de944a5288e120af8c168b9989be868","url":"https://github.com/zkoss/zk"},{"original_method":"/** Parse an component definition specified in the given element.\n\t * @param bNativeContent whether to consider the child element all native\n\t * It is true if a component definition with text-as is found\n\t */\n\tprivate void parse(PageDefinition pgdef, NodeInfo parent,\n\tElement el, AnnotationHelper annHelper, boolean bNativeContent)\n\tthrows Exception {\n\t\tfinal String nm = el.getLocalName();\n\t\tfinal Namespace ns = el.getNamespace();\n\t\tfinal String pref = ns != null ? ns.getPrefix(): \"\";\n\t\tfinal String uri = ns != null ? ns.getURI(): \"\";\n\t\tLanguageDefinition langdef = pgdef.getLanguageDefinition();\n\t\tif (\"zscript\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\tparseZScript(parent, el, annHelper);\n\t\t} else if (\"attribute\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\tif (!(parent instanceof ComponentInfo))\n\t\t\t\tthrow new UiException(\"<attribute> cannot be the root element, \"+el.getLocator());\n\n\t\t\tparseAttribute(pgdef, (ComponentInfo)parent, el, annHelper);\n\t\t} else if (\"custom-attributes\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\tparseCustomAttributes(parent, el, annHelper);\n\t\t} else if (\"variables\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\tparseVariables(parent, el, annHelper);\n\t\t} else if (LanguageDefinition.ANNO_NAMESPACE.equals(uri)) {\n\t\t\tparseAnnotation(el, annHelper);\n\t\t} else {\n\t\t\t//if (D.ON && log.debugable()) log.debug(\"component: \"+nm+\", ns:\"+ns);\n\t\t\tfinal ComponentInfo compInfo;\n\t\t\tfinal boolean bzk =\n\t\t\t\t\"zk\".equals(nm) && isZkElement(langdef, nm, pref, uri);\n\t\t\tif (bzk) {\n\t\t\t\tif (annHelper.clear())\n\t\t\t\t\tlog.warning(\"Annotations are ignored since <zk> doesn't support them, \"+el.getLocator());\n\t\t\t\tcompInfo = new ZkInfo(parent); \n\t\t\t} else {\n\t\t\t\tif (isZkSwitch(parent))\n\t\t\t\t\tthrow new UiException(\"Only <zk> can be used in <zk switch>, \"+el.getLocator());\n\n\t\t\t\tboolean prefRequired =\n\t\t\t\t\turi.startsWith(LanguageDefinition.NATIVE_NAMESPACE_PREFIX);\n\t\t\t\tboolean bNative = bNativeContent || prefRequired ||\n\t\t\t\t\tLanguageDefinition.NATIVE_NAMESPACE.equals(uri);\n\n\t\t\t\tif (!bNative && langdef.isNative()\n\t\t\t\t&& !langdef.getNamespace().equals(uri))\n\t\t\t\t\tbNative = prefRequired =\n\t\t\t\t\t\t(\"\".equals(pref) && \"\".equals(uri))\n\t\t\t\t\t\t|| !LanguageDefinition.exists(uri);\n\t\t\t\t\t//Spec: if pref/URI not specified => native\n\t\t\t\t\t//\t\tif uri unknown => native\n\n\t\t\t\tif (bNative) {\n\t\t\t\t\tif (annHelper.clear())\n\t\t\t\t\t\tlog.warning(\"Annotations are ignored since native doesn't support them, \"+el.getLocator());\n\n\t\t\t\t\tfinal NativeInfo ni;\n\t\t\t\t\tcompInfo = ni = new NativeInfo(\n\t\t\t\t\t\tparent, langdef.getNativeDefinition(),\n\t\t\t\t\t\tprefRequired && pref.length() > 0 ? pref + \":\" + nm: nm);\n\n\t\t\t\t\t//add declared namespace if starting with native:\n\t\t\t\t\tfinal Collection dns = el.getDeclaredNamespaces();\n\t\t\t\t\tif (!dns.isEmpty())\n\t\t\t\t\t\taddDeclaredNamespace(ni, dns, langdef);\n\t\t\t\t} else {\n\t\t\t\t\tfinal boolean defaultNS = isDefaultNS(langdef, pref, uri);\n\t\t\t\t\tfinal LanguageDefinition complangdef =\n\t\t\t\t\t\tdefaultNS ? langdef: LanguageDefinition.lookup(uri);\n\t\t\t\t\tComponentDefinition compdef =\n\t\t\t\t\t\tdefaultNS ? pgdef.getComponentDefinitionMap().get(nm): null;\n\t\t\t\t\tif (compdef != null) {\n\t\t\t\t\t\tcompInfo = new ComponentInfo(parent, compdef);\n\t\t\t\t\t} else if (complangdef.hasComponentDefinition(nm)) {\n\t\t\t\t\t\tcompdef = complangdef.getComponentDefinition(nm);\n\t\t\t\t\t\tcompInfo = new ComponentInfo(parent, compdef);\n\t\t\t\t\t\tlangdef = complangdef;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcompdef = complangdef.getDynamicTagDefinition();\n\t\t\t\t\t\tif (compdef == null)\n\t\t\t\t\t\t\tthrow new DefinitionNotFoundException(\"Component definition not found: \"+nm+\" in \"+complangdef+\", \"+el.getLocator());\n\t\t\t\t\t\tcompInfo = new ComponentInfo(parent, compdef, nm);\n\t\t\t\t\t\tlangdef = complangdef;\n\t\t\t\t\t}\n\n\t\t\t\t\t//process use first because addProperty needs it\n\t\t\t\t\tString use = el.getAttributeValue(\"use\");\n\t\t\t\t\tif (use != null) {\n\t\t\t\t\t\tuse = use.trim();\n\t\t\t\t\t\tif (use.length() != 0)\n\t\t\t\t\t\t\tcompInfo.setImplementationClass(use);\n\t\t\t\t\t\t\t//Resolve later since might defined in zscript\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString ifc = null, unless = null,\n\t\t\t\tforEach = null, forEachBegin = null, forEachEnd = null;\n\t\t\tAnnotationHelper attrAnnHelper = null;\n\t\t\tfor (Iterator it = el.getAttributeItems().iterator();\n\t\t\tit.hasNext();) {\n\t\t\t\tfinal Attribute attr = (Attribute)it.next();\n\t\t\t\tfinal Namespace attrns = attr.getNamespace();\n\t\t\t\tfinal String attnm = attr.getLocalName();\n\t\t\t\tfinal String attval = attr.getValue();\n\t\t\t\tif (attrns != null\n\t\t\t\t&& LanguageDefinition.ANNO_NAMESPACE.equals(attrns.getURI())) {\n\t\t\t\t\tif (bzk) warnWrongZkAttr(attr);\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (attrAnnHelper == null)\n\t\t\t\t\t\t\tattrAnnHelper = new AnnotationHelper();\n\t\t\t\t\t\tattrAnnHelper.addByRawValue(attnm, attval);\n\t\t\t\t\t}\n\t\t\t\t} else if (\"apply\".equals(attnm) && isZkAttr(langdef, attrns)) {\n\t\t\t\t\tif (bzk) warnWrongZkAttr(attr);\n\t\t\t\t\telse compInfo.setApply(attval);\n\t\t\t\t} else if (\"forward\".equals(attnm) && isZkAttr(langdef, attrns)) {\n\t\t\t\t\tif (bzk) warnWrongZkAttr(attr);\n\t\t\t\t\telse compInfo.setForward(attval);\n\t\t\t\t} else if (\"if\".equals(attnm) && isZkAttr(langdef, attrns)) {\n\t\t\t\t\tifc = attval;\n\t\t\t\t} else if (\"unless\".equals(attnm) && isZkAttr(langdef, attrns)) {\n\t\t\t\t\tunless = attval;\n\t\t\t\t} else if (\"forEach\".equals(attnm) && isZkAttr(langdef, attrns)) {\n\t\t\t\t\tforEach = attval;\n\t\t\t\t} else if (\"forEachBegin\".equals(attnm) && isZkAttr(langdef, attrns)) {\n\t\t\t\t\tforEachBegin = attval;\n\t\t\t\t} else if (\"forEachEnd\".equals(attnm) && isZkAttr(langdef, attrns)) {\n\t\t\t\t\tforEachEnd = attval;\n\t\t\t\t} else if (\"fulfill\".equals(attnm) && isZkAttr(langdef, attrns)) {\n\t\t\t\t\tif (bzk) warnWrongZkAttr(attr);\n\t\t\t\t\telse compInfo.setFulfill(attval);\n\t\t\t\t} else if (bzk) {\n\t\t\t\t\tif (\"switch\".equals(attnm) || \"choose\".equals(attnm)) {\n\t\t\t\t\t\tif (isZkSwitch(parent))\n\t\t\t\t\t\t\tthrow new UiException(\"<zk \"+attnm+\"> cannot be used in <zk switch/choose>, \"+el.getLocator());\n\t\t\t\t\t\t((ZkInfo)compInfo).setSwitch(attval);\n\t\t\t\t\t} else if (\"case\".equals(attnm)) {\n\t\t\t\t\t\tif (!isZkSwitch(parent))\n\t\t\t\t\t\t\tthrow new UiException(\"<zk case> can be used only in <zk switch>, \"+attr.getLocator());\n\t\t\t\t\t\t((ZkInfo)compInfo).setCase(attval);\n\t\t\t\t\t} else if (\"when\".equals(attnm)) {\n\t\t\t\t\t\tifc = attval;\n\t\t\t\t\t} else {\n\t\t\t\t\t\twarnWrongZkAttr(attr);\n\t\t\t\t\t}\n\t\t\t\t} else if (!(\"use\".equals(attnm) && isZkAttr(langdef, attrns))) {\n\t\t\t\t\tfinal Namespace attns = attr.getNamespace();\n\t\t\t\t\tfinal String attpref = attns != null ? attns.getPrefix(): \"\";\n\t\t\t\t\tfinal String attruri = attns != null ? attns.getURI(): \"\";\n\t\t\t\t\tif (!\"xmlns\".equals(attpref)\n\t\t\t\t\t&& !(\"xmlns\".equals(attnm) && \"\".equals(attpref))\n\t\t\t\t\t&& !\"http://www.w3.org/2001/XMLSchema-instance\".equals(attruri)) {\n\t\t\t\t\t\tfinal int len = attval.length();\n\t\t\t\t\t\tif (len >= 3 && attval.charAt(0) == '@'\n\t\t\t\t\t\t&& attval.charAt(1) == '{' && attval.charAt(len-1) == '}') { //annotation\n\t\t\t\t\t\t\tif (attrAnnHelper == null)\n\t\t\t\t\t\t\t\tattrAnnHelper = new AnnotationHelper();\n\t\t\t\t\t\t\tattrAnnHelper.addByCompoundValue(\n\t\t\t\t\t\t\t\tattval.substring(2, len -1));\n\t\t\t\t\t\t\tattrAnnHelper.applyAnnotations(compInfo,\n\t\t\t\t\t\t\t\t\"self\".equals(attnm) ? null: attnm, true);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taddAttribute(compInfo, attns, attnm, attval, null);\n\t\t\t\t\t\t\tif (attrAnnHelper != null)\n\t\t\t\t\t\t\t\tattrAnnHelper.applyAnnotations(compInfo, attnm, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcompInfo.setCondition(ConditionImpl.getInstance(ifc, unless));\n\t\t\tcompInfo.setForEach(forEach, forEachBegin, forEachEnd);\n\t\t\tannHelper.applyAnnotations(compInfo, null, true);\n\n\t\t\tparse(pgdef, compInfo, el.getChildren(), annHelper, bNativeContent); //recursive\n\n\t\t\t//optimize native components\n\t\t\tif (compInfo instanceof NativeInfo\n\t\t\t&& !compInfo.getChildren().isEmpty())\n\t\t\t\toptimizeNativeInfos((NativeInfo)compInfo);\n\t\t}\n\t}","id":65625,"modified_method":"/** Parse an component definition specified in the given element.\n\t * @param bNativeContent whether to consider the child element all native\n\t * It is true if a component definition with text-as is found\n\t */\n\tprivate void parse(PageDefinition pgdef, NodeInfo parent,\n\tElement el, AnnotationHelper annHelper, boolean bNativeContent)\n\tthrows Exception {\n\t\tfinal String nm = el.getLocalName();\n\t\tfinal Namespace ns = el.getNamespace();\n\t\tfinal String pref = ns != null ? ns.getPrefix(): \"\";\n\t\tfinal String uri = ns != null ? ns.getURI(): \"\";\n\t\tLanguageDefinition langdef = pgdef.getLanguageDefinition();\n\t\tif (\"zscript\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\tparseZScript(parent, el, annHelper);\n\t\t} else if (\"attribute\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\tif (!(parent instanceof ComponentInfo))\n\t\t\t\tthrow new UiException(\"<attribute> cannot be the root element, \"+el.getLocator());\n\n\t\t\tparseAttribute(pgdef, (ComponentInfo)parent, el, annHelper);\n\t\t} else if (\"custom-attributes\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\tparseCustomAttributes(langdef, parent, el, annHelper);\n\t\t} else if (\"variables\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\tparseVariables(langdef, parent, el, annHelper);\n\t\t} else if (LanguageDefinition.ANNO_NAMESPACE.equals(uri)) {\n\t\t\tparseAnnotation(el, annHelper);\n\t\t} else {\n\t\t\t//if (D.ON && log.debugable()) log.debug(\"component: \"+nm+\", ns:\"+ns);\n\t\t\tfinal ComponentInfo compInfo;\n\t\t\tfinal boolean bzk =\n\t\t\t\t\"zk\".equals(nm) && isZkElement(langdef, nm, pref, uri);\n\t\t\tif (bzk) {\n\t\t\t\tif (annHelper.clear())\n\t\t\t\t\tlog.warning(\"Annotations are ignored since <zk> doesn't support them, \"+el.getLocator());\n\t\t\t\tcompInfo = new ZkInfo(parent); \n\t\t\t} else {\n\t\t\t\tif (isZkSwitch(parent))\n\t\t\t\t\tthrow new UiException(\"Only <zk> can be used in <zk switch>, \"+el.getLocator());\n\n\t\t\t\tboolean prefRequired =\n\t\t\t\t\turi.startsWith(LanguageDefinition.NATIVE_NAMESPACE_PREFIX);\n\t\t\t\tboolean bNative = bNativeContent || prefRequired ||\n\t\t\t\t\tLanguageDefinition.NATIVE_NAMESPACE.equals(uri);\n\n\t\t\t\tif (!bNative && langdef.isNative()\n\t\t\t\t&& !langdef.getNamespace().equals(uri))\n\t\t\t\t\tbNative = prefRequired =\n\t\t\t\t\t\t(\"\".equals(pref) && \"\".equals(uri))\n\t\t\t\t\t\t|| !LanguageDefinition.exists(uri);\n\t\t\t\t\t//Spec: if pref/URI not specified => native\n\t\t\t\t\t//\t\tif uri unknown => native\n\n\t\t\t\tif (bNative) {\n\t\t\t\t\tif (annHelper.clear())\n\t\t\t\t\t\tlog.warning(\"Annotations are ignored since native doesn't support them, \"+el.getLocator());\n\n\t\t\t\t\tfinal NativeInfo ni;\n\t\t\t\t\tcompInfo = ni = new NativeInfo(\n\t\t\t\t\t\tparent, langdef.getNativeDefinition(),\n\t\t\t\t\t\tprefRequired && pref.length() > 0 ? pref + \":\" + nm: nm);\n\n\t\t\t\t\t//add declared namespace if starting with native:\n\t\t\t\t\tfinal Collection dns = el.getDeclaredNamespaces();\n\t\t\t\t\tif (!dns.isEmpty())\n\t\t\t\t\t\taddDeclaredNamespace(ni, dns, langdef);\n\t\t\t\t} else {\n\t\t\t\t\tfinal boolean defaultNS = isDefaultNS(langdef, pref, uri);\n\t\t\t\t\tfinal LanguageDefinition complangdef =\n\t\t\t\t\t\tdefaultNS ? langdef: LanguageDefinition.lookup(uri);\n\t\t\t\t\tComponentDefinition compdef =\n\t\t\t\t\t\tdefaultNS ? pgdef.getComponentDefinitionMap().get(nm): null;\n\t\t\t\t\tif (compdef != null) {\n\t\t\t\t\t\tcompInfo = new ComponentInfo(parent, compdef);\n\t\t\t\t\t} else if (complangdef.hasComponentDefinition(nm)) {\n\t\t\t\t\t\tcompdef = complangdef.getComponentDefinition(nm);\n\t\t\t\t\t\tcompInfo = new ComponentInfo(parent, compdef);\n\t\t\t\t\t\tlangdef = complangdef;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcompdef = complangdef.getDynamicTagDefinition();\n\t\t\t\t\t\tif (compdef == null)\n\t\t\t\t\t\t\tthrow new DefinitionNotFoundException(\"Component definition not found: \"+nm+\" in \"+complangdef+\", \"+el.getLocator());\n\t\t\t\t\t\tcompInfo = new ComponentInfo(parent, compdef, nm);\n\t\t\t\t\t\tlangdef = complangdef;\n\t\t\t\t\t}\n\n\t\t\t\t\t//process use first because addProperty needs it\n\t\t\t\t\tString use = el.getAttributeValue(\"use\");\n\t\t\t\t\tif (use != null) {\n\t\t\t\t\t\tuse = use.trim();\n\t\t\t\t\t\tif (use.length() != 0)\n\t\t\t\t\t\t\tcompInfo.setImplementationClass(use);\n\t\t\t\t\t\t\t//Resolve later since might defined in zscript\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString ifc = null, unless = null,\n\t\t\t\tforEach = null, forEachBegin = null, forEachEnd = null;\n\t\t\tAnnotationHelper attrAnnHelper = null;\n\t\t\tfor (Iterator it = el.getAttributeItems().iterator();\n\t\t\tit.hasNext();) {\n\t\t\t\tfinal Attribute attr = (Attribute)it.next();\n\t\t\t\tfinal Namespace attrns = attr.getNamespace();\n\t\t\t\tfinal String attnm = attr.getLocalName();\n\t\t\t\tfinal String attval = attr.getValue();\n\t\t\t\tif (attrns != null\n\t\t\t\t&& LanguageDefinition.ANNO_NAMESPACE.equals(attrns.getURI())) {\n\t\t\t\t\tif (bzk) warnWrongZkAttr(attr);\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (attrAnnHelper == null)\n\t\t\t\t\t\t\tattrAnnHelper = new AnnotationHelper();\n\t\t\t\t\t\tattrAnnHelper.addByRawValue(attnm, attval);\n\t\t\t\t\t}\n\t\t\t\t} else if (\"apply\".equals(attnm) && isZkAttr(langdef, attrns)) {\n\t\t\t\t\tif (bzk) warnWrongZkAttr(attr);\n\t\t\t\t\telse compInfo.setApply(attval);\n\t\t\t\t} else if (\"forward\".equals(attnm) && isZkAttr(langdef, attrns)) {\n\t\t\t\t\tif (bzk) warnWrongZkAttr(attr);\n\t\t\t\t\telse compInfo.setForward(attval);\n\t\t\t\t} else if (\"if\".equals(attnm) && isZkAttr(langdef, attrns)) {\n\t\t\t\t\tifc = attval;\n\t\t\t\t} else if (\"unless\".equals(attnm) && isZkAttr(langdef, attrns)) {\n\t\t\t\t\tunless = attval;\n\t\t\t\t} else if (\"forEach\".equals(attnm) && isZkAttr(langdef, attrns)) {\n\t\t\t\t\tforEach = attval;\n\t\t\t\t} else if (\"forEachBegin\".equals(attnm) && isZkAttr(langdef, attrns)) {\n\t\t\t\t\tforEachBegin = attval;\n\t\t\t\t} else if (\"forEachEnd\".equals(attnm) && isZkAttr(langdef, attrns)) {\n\t\t\t\t\tforEachEnd = attval;\n\t\t\t\t} else if (\"fulfill\".equals(attnm) && isZkAttr(langdef, attrns)) {\n\t\t\t\t\tif (bzk) warnWrongZkAttr(attr);\n\t\t\t\t\telse compInfo.setFulfill(attval);\n\t\t\t\t} else if (bzk) {\n\t\t\t\t\tif (\"switch\".equals(attnm) || \"choose\".equals(attnm)) {\n\t\t\t\t\t\tif (isZkSwitch(parent))\n\t\t\t\t\t\t\tthrow new UiException(\"<zk \"+attnm+\"> cannot be used in <zk switch/choose>, \"+el.getLocator());\n\t\t\t\t\t\t((ZkInfo)compInfo).setSwitch(attval);\n\t\t\t\t\t} else if (\"case\".equals(attnm)) {\n\t\t\t\t\t\tif (!isZkSwitch(parent))\n\t\t\t\t\t\t\tthrow new UiException(\"<zk case> can be used only in <zk switch>, \"+attr.getLocator());\n\t\t\t\t\t\t((ZkInfo)compInfo).setCase(attval);\n\t\t\t\t\t} else if (\"when\".equals(attnm)) {\n\t\t\t\t\t\tifc = attval;\n\t\t\t\t\t} else {\n\t\t\t\t\t\twarnWrongZkAttr(attr);\n\t\t\t\t\t}\n\t\t\t\t} else if (!(\"use\".equals(attnm) && isZkAttr(langdef, attrns))) {\n\t\t\t\t\tfinal Namespace attns = attr.getNamespace();\n\t\t\t\t\tfinal String attpref = attns != null ? attns.getPrefix(): \"\";\n\t\t\t\t\tfinal String attruri = attns != null ? attns.getURI(): \"\";\n\t\t\t\t\tif (!\"xmlns\".equals(attpref)\n\t\t\t\t\t&& !(\"xmlns\".equals(attnm) && \"\".equals(attpref))\n\t\t\t\t\t&& !\"http://www.w3.org/2001/XMLSchema-instance\".equals(attruri)) {\n\t\t\t\t\t\tfinal int len = attval.length();\n\t\t\t\t\t\tif (len >= 3 && attval.charAt(0) == '@'\n\t\t\t\t\t\t&& attval.charAt(1) == '{' && attval.charAt(len-1) == '}') { //annotation\n\t\t\t\t\t\t\tif (attrAnnHelper == null)\n\t\t\t\t\t\t\t\tattrAnnHelper = new AnnotationHelper();\n\t\t\t\t\t\t\tattrAnnHelper.addByCompoundValue(\n\t\t\t\t\t\t\t\tattval.substring(2, len -1));\n\t\t\t\t\t\t\tattrAnnHelper.applyAnnotations(compInfo,\n\t\t\t\t\t\t\t\t\"self\".equals(attnm) ? null: attnm, true);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taddAttribute(compInfo, attns, attnm, attval, null);\n\t\t\t\t\t\t\tif (attrAnnHelper != null)\n\t\t\t\t\t\t\t\tattrAnnHelper.applyAnnotations(compInfo, attnm, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcompInfo.setCondition(ConditionImpl.getInstance(ifc, unless));\n\t\t\tcompInfo.setForEach(forEach, forEachBegin, forEachEnd);\n\t\t\tannHelper.applyAnnotations(compInfo, null, true);\n\n\t\t\tparse(pgdef, compInfo, el.getChildren(), annHelper, bNativeContent); //recursive\n\n\t\t\t//optimize native components\n\t\t\tif (compInfo instanceof NativeInfo\n\t\t\t&& !compInfo.getChildren().isEmpty())\n\t\t\t\toptimizeNativeInfos((NativeInfo)compInfo);\n\t\t}\n\t}","commit_id":"23e231146de944a5288e120af8c168b9989be868","url":"https://github.com/zkoss/zk"},{"original_method":"/** Parse an component definition specified in the given element.\n\t */\n\tprivate void parse(PageDefinition pgdef, NodeInfo parent,\n\tElement el, AnnotationHelper annHelper)\n\tthrows Exception {\n\t\tfinal String nm = el.getLocalName();\n\t\tfinal Namespace ns = el.getNamespace();\n\t\tfinal String pref = ns != null ? ns.getPrefix(): \"\";\n\t\tfinal String uri = ns != null ? ns.getURI(): \"\";\n\t\tfinal LanguageDefinition langdef = pgdef.getLanguageDefinition();\n\t\tif (\"zscript\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\tparseZScript(parent, el, annHelper);\n\t\t} else if (\"attribute\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\tif (!(parent instanceof ComponentInfo))\n\t\t\t\tthrow new UiException(\"<attribute> cannot be the root element, \"+el.getLocator());\n\n\t\t\tparseAttribute((ComponentInfo)parent, el, annHelper);\n\t\t} else if (\"custom-attributes\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\tparseCustomAttributes(parent, el, annHelper);\n\t\t} else if (\"variables\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\tparseVariables(parent, el, annHelper);\n\t\t} else if (LanguageDefinition.ANNO_NAMESPACE.equals(uri)) {\n\t\t\tparseAnnotation(el, annHelper);\n\t\t} else {\n\t\t\t//if (D.ON && log.debugable()) log.debug(\"component: \"+nm+\", ns:\"+ns);\n\t\t\tComponentInfo compInfo = null;\n\t\t\tif (\"zk\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\t\tif (annHelper.clear())\n\t\t\t\t\tlog.warning(\"Annotations are ignored since <zk> doesn't support them, \"+el.getLocator());\n\t\t\t\tcompInfo = new ComponentInfo(parent, ComponentDefinition.ZK); \n\t\t\t} else {\n\t\t\t\tboolean prefRequired =\n\t\t\t\t\turi.startsWith(LanguageDefinition.NATIVE_NAMESPACE_PREFIX);\n\t\t\t\tboolean bNative = prefRequired ||\n\t\t\t\t\tLanguageDefinition.NATIVE_NAMESPACE.equals(uri);\n\n\t\t\t\tif (!bNative) {\n\t\t\t\t\tboolean inDefaultNS = isDefaultNS(langdef, pref, uri);\n\t\t\t\t\tif (!inDefaultNS && langdef.isNative()) {\n\t\t\t\t\t\tbNative = prefRequired = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfinal LanguageDefinition complangdef =\n\t\t\t\t\t\t\tinDefaultNS ? langdef: LanguageDefinition.lookup(uri);\n\n\t\t\t\t\t\tComponentDefinition compdef =\n\t\t\t\t\t\t\tpgdef.getComponentDefinitionMap().get(nm);\n\t\t\t\t\t\tif (compdef != null) {\n\t\t\t\t\t\t\tcompInfo = new ComponentInfo(parent, compdef);\n\t\t\t\t\t\t} else if (complangdef.hasComponentDefinition(nm)) {\n\t\t\t\t\t\t\tcompdef = complangdef.getComponentDefinition(nm);\n\t\t\t\t\t\t\tcompInfo = new ComponentInfo(parent, compdef);\n\t\t\t\t\t\t} else if (langdef.isNative()) {\n\t\t\t\t\t\t\tbNative = prefRequired = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcompdef = complangdef.getDynamicTagDefinition();\n\t\t\t\t\t\t\tif (compdef == null)\n\t\t\t\t\t\t\t\tthrow new DefinitionNotFoundException(\"Component definition not found: \"+nm+\" in \"+complangdef+\", \"+el.getLocator());\n\t\t\t\t\t\t\tcompInfo = new ComponentInfo(parent, compdef, nm);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (bNative) {\n\t\t\t\t\tif (annHelper.clear())\n\t\t\t\t\t\tlog.warning(\"Annotations are ignored since native doesn't support them, \"+el.getLocator());\n\n\t\t\t\t\tfinal NativeInfo ni;\n\t\t\t\t\tcompInfo = ni = new NativeInfo(\n\t\t\t\t\t\tparent, langdef.getNativeDefinition(),\n\t\t\t\t\t\tprefRequired && pref.length() > 0 ? pref + \":\" + nm: nm);\n\n\t\t\t\t\t//add declared namespace if starting with native:\n\t\t\t\t\taddDeclaredNamespace(\n\t\t\t\t\t\tni, el.getDeclaredNamespaces(), langdef.isNative());\n\t\t\t\t} else {\n\t\t\t\t\t//process use first because addProperty needs it\n\t\t\t\t\tfinal String use = el.getAttributeValue(\"use\");\n\t\t\t\t\tif (use != null) {\n\t\t\t\t\t\tnoEmpty(\"use\", use, el);\n\t\t\t\t\t\tnoEL(\"use\", use, el);\n\t\t\t\t\t\tcompInfo.setImplementationClass(use);\n\t\t\t\t\t\t\t//Resolve later since might defined in zscript\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString ifc = null, unless = null,\n\t\t\t\tforEach = null, forEachBegin = null, forEachEnd = null;\n\t\t\tAnnotationHelper attrAnnHelper = null;\n\t\t\tfor (Iterator it = el.getAttributeItems().iterator();\n\t\t\tit.hasNext();) {\n\t\t\t\tfinal Attribute attr = (Attribute)it.next();\n\t\t\t\tfinal Namespace attrns = attr.getNamespace();\n\t\t\t\tfinal String attnm = attr.getLocalName();\n\t\t\t\tfinal String attval = attr.getValue();\n\t\t\t\tif (attrns != null\n\t\t\t\t&& LanguageDefinition.ANNO_NAMESPACE.equals(attrns.getURI())) {\n\t\t\t\t\tif (attrAnnHelper == null)\n\t\t\t\t\t\tattrAnnHelper = new AnnotationHelper();\n\t\t\t\t\tattrAnnHelper.addByRawValue(attnm, attval);\n\t\t\t\t} else if (\"forward\".equals(attnm)) {\n\t\t\t\t\tcompInfo.setForward(attval);\n\t\t\t\t} else if (\"if\".equals(attnm)) {\n\t\t\t\t\tifc = attval;\n\t\t\t\t} else if (\"unless\".equals(attnm)) {\n\t\t\t\t\tunless = attval;\n\t\t\t\t} else if (\"forEach\".equals(attnm)) {\n\t\t\t\t\tforEach = attval;\n\t\t\t\t} else if (\"forEachBegin\".equals(attnm)) {\n\t\t\t\t\tforEachBegin = attval;\n\t\t\t\t} else if (\"forEachEnd\".equals(attnm)) {\n\t\t\t\t\tforEachEnd = attval;\n\t\t\t\t} else if (\"fulfill\".equals(attnm)) {\n\t\t\t\t\tcompInfo.setFulfill(attval);\n\t\t\t\t} else if (!\"use\".equals(attnm)) {\n\t\t\t\t\tfinal Namespace attns = attr.getNamespace();\n\t\t\t\t\tfinal String attpref = attns != null ? attns.getPrefix(): \"\";\n\t\t\t\t\tfinal String attruri = attns != null ? attns.getURI(): \"\";\n\t\t\t\t\tif (!\"xmlns\".equals(attpref)\n\t\t\t\t\t&& !(\"xmlns\".equals(attnm) && \"\".equals(attpref))\n\t\t\t\t\t&& !\"http://www.w3.org/2001/XMLSchema-instance\".equals(attruri)) {\n\t\t\t\t\t\tfinal int len = attval.length();\n\t\t\t\t\t\tif (len >= 3 && attval.charAt(0) == '@'\n\t\t\t\t\t\t&& attval.charAt(1) == '{' && attval.charAt(len-1) == '}') { //annotation\n\t\t\t\t\t\t\tif (attrAnnHelper == null)\n\t\t\t\t\t\t\t\tattrAnnHelper = new AnnotationHelper();\n\t\t\t\t\t\t\tattrAnnHelper.addByCompoundValue(\n\t\t\t\t\t\t\t\tattval.substring(2, len -1));\n\t\t\t\t\t\t\tattrAnnHelper.applyAnnotations(compInfo,\n\t\t\t\t\t\t\t\t\"self\".equals(attnm) ? null: attnm, true);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taddAttribute(compInfo, attns, attnm, attval, null);\n\t\t\t\t\t\t\tif (attrAnnHelper != null)\n\t\t\t\t\t\t\t\tattrAnnHelper.applyAnnotations(compInfo, attnm, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcompInfo.setCondition(ConditionImpl.getInstance(ifc, unless));\n\t\t\tcompInfo.setForEach(forEach, forEachBegin, forEachEnd);\n\t\t\tannHelper.applyAnnotations(compInfo, null, true);\n\n\t\t\tparse(pgdef, compInfo, el.getChildren(), annHelper); //recursive\n\n\t\t\t//optimize native components\n\t\t\tif (compInfo instanceof NativeInfo\n\t\t\t&& !compInfo.getChildren().isEmpty())\n\t\t\t\toptimizeNativeInfos((NativeInfo)compInfo);\n\t\t}\n\t}","id":65626,"modified_method":"/** Parse an component definition specified in the given element.\n\t */\n\tprivate void parse(PageDefinition pgdef, NodeInfo parent,\n\tElement el, AnnotationHelper annHelper)\n\tthrows Exception {\n\t\tfinal String nm = el.getLocalName();\n\t\tfinal Namespace ns = el.getNamespace();\n\t\tfinal String pref = ns != null ? ns.getPrefix(): \"\";\n\t\tfinal String uri = ns != null ? ns.getURI(): \"\";\n\t\tfinal LanguageDefinition langdef = pgdef.getLanguageDefinition();\n\t\tif (\"zscript\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\tparseZScript(parent, el, annHelper);\n\t\t} else if (\"attribute\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\tif (!(parent instanceof ComponentInfo))\n\t\t\t\tthrow new UiException(\"<attribute> cannot be the root element, \"+el.getLocator());\n\n\t\t\tparseAttribute((ComponentInfo)parent, el, annHelper);\n\t\t} else if (\"custom-attributes\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\tparseCustomAttributes(parent, el, annHelper);\n\t\t} else if (\"variables\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\tparseVariables(parent, el, annHelper);\n\t\t} else if (LanguageDefinition.ANNO_NAMESPACE.equals(uri)) {\n\t\t\tparseAnnotation(el, annHelper);\n\t\t} else {\n\t\t\t//if (D.ON && log.debugable()) log.debug(\"component: \"+nm+\", ns:\"+ns);\n\t\t\tfinal ComponentInfo compInfo;\n\t\t\tif (\"zk\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\t\tif (annHelper.clear())\n\t\t\t\t\tlog.warning(\"Annotations are ignored since <zk> doesn't support them, \"+el.getLocator());\n\t\t\t\tcompInfo = new ComponentInfo(parent, ComponentDefinition.ZK); \n\t\t\t} else {\n\t\t\t\tboolean prefRequired =\n\t\t\t\t\turi.startsWith(LanguageDefinition.NATIVE_NAMESPACE_PREFIX);\n\t\t\t\tboolean bNative = prefRequired ||\n\t\t\t\t\tLanguageDefinition.NATIVE_NAMESPACE.equals(uri);\n\n\t\t\t\tif (!bNative && langdef.isNative()\n\t\t\t\t&& !langdef.getNamespace().equals(uri))\n\t\t\t\t\tbNative = prefRequired =\n\t\t\t\t\t\t(\"\".equals(pref) && \"\".equals(uri))\n\t\t\t\t\t\t|| !LanguageDefinition.exists(uri);\n\t\t\t\t\t//Spec: if pref/URI not specified => native\n\n\t\t\t\tif (bNative) {\n\t\t\t\t\tif (annHelper.clear())\n\t\t\t\t\t\tlog.warning(\"Annotations are ignored since native doesn't support them, \"+el.getLocator());\n\n\t\t\t\t\tfinal NativeInfo ni;\n\t\t\t\t\tcompInfo = ni = new NativeInfo(\n\t\t\t\t\t\tparent, langdef.getNativeDefinition(),\n\t\t\t\t\t\tprefRequired && pref.length() > 0 ? pref + \":\" + nm: nm);\n\n\t\t\t\t\t//add declared namespace if starting with native:\n\t\t\t\t\tfinal Collection dns = el.getDeclaredNamespaces();\n\t\t\t\t\tif (!dns.isEmpty())\n\t\t\t\t\t\taddDeclaredNamespace(ni, dns, langdef.isNative());\n\t\t\t\t} else {\n\t\t\t\t\tfinal LanguageDefinition complangdef =\n\t\t\t\t\t\tisDefaultNS(langdef, pref, uri) ?\n\t\t\t\t\t\t\tlangdef: LanguageDefinition.lookup(uri);\n\n\t\t\t\t\tComponentDefinition compdef =\n\t\t\t\t\t\tpgdef.getComponentDefinitionMap().get(nm);\n\t\t\t\t\tif (compdef != null) {\n\t\t\t\t\t\tcompInfo = new ComponentInfo(parent, compdef);\n\t\t\t\t\t} else if (complangdef.hasComponentDefinition(nm)) {\n\t\t\t\t\t\tcompdef = complangdef.getComponentDefinition(nm);\n\t\t\t\t\t\tcompInfo = new ComponentInfo(parent, compdef);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcompdef = complangdef.getDynamicTagDefinition();\n\t\t\t\t\t\tif (compdef == null)\n\t\t\t\t\t\t\tthrow new DefinitionNotFoundException(\"Component definition not found: \"+nm+\" in \"+complangdef+\", \"+el.getLocator());\n\t\t\t\t\t\tcompInfo = new ComponentInfo(parent, compdef, nm);\n\t\t\t\t\t}\n\n\t\t\t\t\t//process use first because addProperty needs it\n\t\t\t\t\tfinal String use = el.getAttributeValue(\"use\");\n\t\t\t\t\tif (use != null) {\n\t\t\t\t\t\tnoEmpty(\"use\", use, el);\n\t\t\t\t\t\tnoEL(\"use\", use, el);\n\t\t\t\t\t\tcompInfo.setImplementationClass(use);\n\t\t\t\t\t\t\t//Resolve later since might defined in zscript\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString ifc = null, unless = null,\n\t\t\t\tforEach = null, forEachBegin = null, forEachEnd = null;\n\t\t\tAnnotationHelper attrAnnHelper = null;\n\t\t\tfor (Iterator it = el.getAttributeItems().iterator();\n\t\t\tit.hasNext();) {\n\t\t\t\tfinal Attribute attr = (Attribute)it.next();\n\t\t\t\tfinal Namespace attrns = attr.getNamespace();\n\t\t\t\tfinal String attnm = attr.getLocalName();\n\t\t\t\tfinal String attval = attr.getValue();\n\t\t\t\tif (attrns != null\n\t\t\t\t&& LanguageDefinition.ANNO_NAMESPACE.equals(attrns.getURI())) {\n\t\t\t\t\tif (attrAnnHelper == null)\n\t\t\t\t\t\tattrAnnHelper = new AnnotationHelper();\n\t\t\t\t\tattrAnnHelper.addByRawValue(attnm, attval);\n\t\t\t\t} else if (\"forward\".equals(attnm)) {\n\t\t\t\t\tcompInfo.setForward(attval);\n\t\t\t\t} else if (\"if\".equals(attnm)) {\n\t\t\t\t\tifc = attval;\n\t\t\t\t} else if (\"unless\".equals(attnm)) {\n\t\t\t\t\tunless = attval;\n\t\t\t\t} else if (\"forEach\".equals(attnm)) {\n\t\t\t\t\tforEach = attval;\n\t\t\t\t} else if (\"forEachBegin\".equals(attnm)) {\n\t\t\t\t\tforEachBegin = attval;\n\t\t\t\t} else if (\"forEachEnd\".equals(attnm)) {\n\t\t\t\t\tforEachEnd = attval;\n\t\t\t\t} else if (\"fulfill\".equals(attnm)) {\n\t\t\t\t\tcompInfo.setFulfill(attval);\n\t\t\t\t} else if (!\"use\".equals(attnm)) {\n\t\t\t\t\tfinal Namespace attns = attr.getNamespace();\n\t\t\t\t\tfinal String attpref = attns != null ? attns.getPrefix(): \"\";\n\t\t\t\t\tfinal String attruri = attns != null ? attns.getURI(): \"\";\n\t\t\t\t\tif (!\"xmlns\".equals(attpref)\n\t\t\t\t\t&& !(\"xmlns\".equals(attnm) && \"\".equals(attpref))\n\t\t\t\t\t&& !\"http://www.w3.org/2001/XMLSchema-instance\".equals(attruri)) {\n\t\t\t\t\t\tfinal int len = attval.length();\n\t\t\t\t\t\tif (len >= 3 && attval.charAt(0) == '@'\n\t\t\t\t\t\t&& attval.charAt(1) == '{' && attval.charAt(len-1) == '}') { //annotation\n\t\t\t\t\t\t\tif (attrAnnHelper == null)\n\t\t\t\t\t\t\t\tattrAnnHelper = new AnnotationHelper();\n\t\t\t\t\t\t\tattrAnnHelper.addByCompoundValue(\n\t\t\t\t\t\t\t\tattval.substring(2, len -1));\n\t\t\t\t\t\t\tattrAnnHelper.applyAnnotations(compInfo,\n\t\t\t\t\t\t\t\t\"self\".equals(attnm) ? null: attnm, true);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taddAttribute(compInfo, attns, attnm, attval, null);\n\t\t\t\t\t\t\tif (attrAnnHelper != null)\n\t\t\t\t\t\t\t\tattrAnnHelper.applyAnnotations(compInfo, attnm, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcompInfo.setCondition(ConditionImpl.getInstance(ifc, unless));\n\t\t\tcompInfo.setForEach(forEach, forEachBegin, forEachEnd);\n\t\t\tannHelper.applyAnnotations(compInfo, null, true);\n\n\t\t\tparse(pgdef, compInfo, el.getChildren(), annHelper); //recursive\n\n\t\t\t//optimize native components\n\t\t\tif (compInfo instanceof NativeInfo\n\t\t\t&& !compInfo.getChildren().isEmpty())\n\t\t\t\toptimizeNativeInfos((NativeInfo)compInfo);\n\t\t}\n\t}","commit_id":"22f26621b5ca1bf5276f195f9ca224194c3f8c63","url":"https://github.com/zkoss/zk"},{"original_method":"/** Adds the declared namespaces to the native info, if necessary.\n\t */\n\tprivate static void addDeclaredNamespace(\n\tNativeInfo nativeInfo, Collection namespaces, boolean nativeLang) {\n\t\tif (!namespaces.isEmpty()) {\n\t\t\tfor (Iterator it = namespaces.iterator(); it.hasNext();) {\n\t\t\t\tfinal Namespace ns = (Namespace)it.next();\n\t\t\t\tfinal String uri = ns.getURI();\n\t\t\t\tboolean bNatPrefix =\n\t\t\t\t\turi.startsWith(LanguageDefinition.NATIVE_NAMESPACE_PREFIX);\n\t\t\t\tif (bNatPrefix || nativeLang)\n\t\t\t\t\tnativeInfo.addDeclaredNamespace(\n\t\t\t\t\t\tnew Namespace(ns.getPrefix(),\n\t\t\t\t\t\t\tbNatPrefix ? uri.substring(LanguageDefinition.NATIVE_NAMESPACE_PREFIX.length()):\n\t\t\t\t\t\t\t\turi));\n\t\t\t}\n\t\t}\n\t}","id":65627,"modified_method":"/** Adds the declared namespaces to the native info, if necessary.\n\t */\n\tprivate static void addDeclaredNamespace(\n\tNativeInfo nativeInfo, Collection namespaces, boolean nativeLang) {\n\t\tfor (Iterator it = namespaces.iterator(); it.hasNext();) {\n\t\t\tfinal Namespace ns = (Namespace)it.next();\n\t\t\tfinal String uri = ns.getURI();\n\t\t\tboolean bNatPrefix =\n\t\t\t\turi.startsWith(LanguageDefinition.NATIVE_NAMESPACE_PREFIX);\n\t\t\tif (bNatPrefix || nativeLang)\n\t\t\t\tnativeInfo.addDeclaredNamespace(\n\t\t\t\t\tnew Namespace(ns.getPrefix(),\n\t\t\t\t\t\tbNatPrefix ? uri.substring(LanguageDefinition.NATIVE_NAMESPACE_PREFIX.length()):\n\t\t\t\t\t\t\turi));\n\t\t}\n\t}","commit_id":"22f26621b5ca1bf5276f195f9ca224194c3f8c63","url":"https://github.com/zkoss/zk"},{"original_method":"/** Parse an component definition specified in the given element.\n\t */\n\tprivate void parse(PageDefinition pgdef, NodeInfo parent,\n\tElement el, AnnotationHelper annHelper)\n\tthrows Exception {\n\t\tfinal String nm = el.getLocalName();\n\t\tfinal Namespace ns = el.getNamespace();\n\t\tfinal String pref = ns != null ? ns.getPrefix(): \"\";\n\t\tfinal String uri = ns != null ? ns.getURI(): \"\";\n\t\tfinal LanguageDefinition langdef = pgdef.getLanguageDefinition();\n\t\tif (\"zscript\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\tparseZScript(parent, el, annHelper);\n\t\t} else if (\"attribute\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\tif (!(parent instanceof ComponentInfo))\n\t\t\t\tthrow new UiException(\"<attribute> cannot be the root element, \"+el.getLocator());\n\n\t\t\tparseAttribute((ComponentInfo)parent, el, annHelper);\n\t\t} else if (\"custom-attributes\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\tparseCustomAttributes(parent, el, annHelper);\n\t\t} else if (\"variables\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\tparseVariables(parent, el, annHelper);\n\t\t} else if (LanguageDefinition.ANNO_NAMESPACE.equals(uri)) {\n\t\t\tparseAnnotation(el, annHelper);\n\t\t} else {\n\t\t\t//if (D.ON && log.debugable()) log.debug(\"component: \"+nm+\", ns:\"+ns);\n\t\t\tfinal ComponentInfo compInfo;\n\t\t\tif (\"zk\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\t\tif (annHelper.clear())\n\t\t\t\t\tlog.warning(\"Annotations are ignored since <zk> doesn't support them, \"+el.getLocator());\n\t\t\t\tcompInfo = new ComponentInfo(parent, ComponentDefinition.ZK); \n\t\t\t} else if (langdef.isNative()\n\t\t\t|| LanguageDefinition.NATIVE_NAMESPACE.equals(uri)\n\t\t\t|| uri.startsWith(LanguageDefinition.NATIVE_NAMESPACE_PREFIX)) {\n\t\t\t\tfinal boolean prefRequired = langdef.isNative()\n\t\t\t\t\t|| uri.startsWith(LanguageDefinition.NATIVE_NAMESPACE_PREFIX);\n\t\t\t\tif (annHelper.clear())\n\t\t\t\t\tlog.warning(\"Annotations are ignored since inline doesn't support them, \"+el.getLocator());\n\t\t\t\tfinal NativeInfo ni;\n\t\t\t\tcompInfo = ni = new NativeInfo(\n\t\t\t\t\tparent, langdef.getNativeDefinition(),\n\t\t\t\t\t\tprefRequired && pref.length() > 0 ? pref + \":\" + nm: nm);\n\n\t\t\t\t//add declared namespace if starting with native-\n\t\t\t\tfinal Collection col = el.getDeclaredNamespaces();\n\t\t\t\tif (!col.isEmpty()) {\n\t\t\t\t\tfor (Iterator it = col.iterator(); it.hasNext();) {\n\t\t\t\t\t\tfinal Namespace dns = (Namespace)it.next();\n\t\t\t\t\t\tfinal String duri = dns.getURI();\n\t\t\t\t\t\tboolean bNatPrefix =\n\t\t\t\t\t\t\tduri.startsWith(LanguageDefinition.NATIVE_NAMESPACE_PREFIX);\n\t\t\t\t\t\tif (bNatPrefix || langdef.isNative())\n\t\t\t\t\t\t\tni.addDeclaredNamespace(\n\t\t\t\t\t\t\t\tnew Namespace(dns.getPrefix(),\n\t\t\t\t\t\t\t\t\tbNatPrefix ? duri.substring(LanguageDefinition.NATIVE_NAMESPACE_PREFIX.length()):\n\t\t\t\t\t\t\t\t\t\tduri));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (LanguageDefinition.ZK_NAMESPACE.equals(uri))\n\t\t\t\t\tthrow new UiException(\"Unknown ZK component: \"+el+\", \"+el.getLocator());\n\n\t\t\t\tfinal LanguageDefinition complangdef;\n\t\t\t\tif (isDefault(langdef, pref, uri)) {\n\t\t\t\t\tcomplangdef = langdef;\n\t\t\t\t} else {\n\t\t\t\t\tcomplangdef = LanguageDefinition.lookup(uri);\n\t\t\t\t}\n\n\t\t\t\tComponentDefinition compdef =\n\t\t\t\t\tpgdef.getComponentDefinitionMap().get(nm);\n\t\t\t\tif (compdef != null) {\n\t\t\t\t\tcompInfo = new ComponentInfo(parent, compdef);\n\t\t\t\t} else if (complangdef.hasComponentDefinition(nm)) {\n\t\t\t\t\tcompdef = complangdef.getComponentDefinition(nm);\n\t\t\t\t\tcompInfo = new ComponentInfo(parent, compdef);\n\t\t\t\t} else {\n\t\t\t\t\tcompdef = complangdef.getDynamicTagDefinition();\n\t\t\t\t\tif (compdef == null)\n\t\t\t\t\t\tthrow new DefinitionNotFoundException(\"Component definition not found: \"+nm+\" in \"+complangdef+\", \"+el.getLocator());\n\t\t\t\t\tcompInfo = new ComponentInfo(parent, compdef, nm);\n\t\t\t\t}\n\n\t\t\t\t//process use first because addProperty needs it\n\t\t\t\tfinal String use = el.getAttributeValue(\"use\");\n\t\t\t\tif (use != null) {\n\t\t\t\t\tnoEmpty(\"use\", use, el);\n\t\t\t\t\tnoEL(\"use\", use, el);\n\t\t\t\t\tcompInfo.setImplementationClass(use);\n\t\t\t\t\t\t//Resolve later since might defined in zscript\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString ifc = null, unless = null,\n\t\t\t\tforEach = null, forEachBegin = null, forEachEnd = null;\n\t\t\tAnnotationHelper attrAnnHelper = null;\n\t\t\tfor (Iterator it = el.getAttributeItems().iterator();\n\t\t\tit.hasNext();) {\n\t\t\t\tfinal Attribute attr = (Attribute)it.next();\n\t\t\t\tfinal Namespace attrns = attr.getNamespace();\n\t\t\t\tfinal String attnm = attr.getLocalName();\n\t\t\t\tfinal String attval = attr.getValue();\n\t\t\t\tif (attrns != null\n\t\t\t\t&& LanguageDefinition.ANNO_NAMESPACE.equals(attrns.getURI())) {\n\t\t\t\t\tif (attrAnnHelper == null)\n\t\t\t\t\t\tattrAnnHelper = new AnnotationHelper();\n\t\t\t\t\tattrAnnHelper.addByRawValue(attnm, attval);\n\t\t\t\t} else if (\"forward\".equals(attnm)) {\n\t\t\t\t\tcompInfo.setForward(attval);\n\t\t\t\t} else if (\"if\".equals(attnm)) {\n\t\t\t\t\tifc = attval;\n\t\t\t\t} else if (\"unless\".equals(attnm)) {\n\t\t\t\t\tunless = attval;\n\t\t\t\t} else if (\"forEach\".equals(attnm)) {\n\t\t\t\t\tforEach = attval;\n\t\t\t\t} else if (\"forEachBegin\".equals(attnm)) {\n\t\t\t\t\tforEachBegin = attval;\n\t\t\t\t} else if (\"forEachEnd\".equals(attnm)) {\n\t\t\t\t\tforEachEnd = attval;\n\t\t\t\t} else if (\"fulfill\".equals(attnm)) {\n\t\t\t\t\tcompInfo.setFulfill(attval);\n\t\t\t\t} else if (!\"use\".equals(attnm)) {\n\t\t\t\t\tfinal Namespace attns = attr.getNamespace();\n\t\t\t\t\tfinal String attpref = attns != null ? attns.getPrefix(): \"\";\n\t\t\t\t\tfinal String attruri = attns != null ? attns.getURI(): \"\";\n\t\t\t\t\tif (!\"xmlns\".equals(attpref)\n\t\t\t\t\t&& !(\"xmlns\".equals(attnm) && \"\".equals(attpref))\n\t\t\t\t\t&& !\"http://www.w3.org/2001/XMLSchema-instance\".equals(attruri)) {\n\t\t\t\t\t\tfinal int len = attval.length();\n\t\t\t\t\t\tif (len >= 3 && attval.charAt(0) == '@'\n\t\t\t\t\t\t&& attval.charAt(1) == '{' && attval.charAt(len-1) == '}') { //annotation\n\t\t\t\t\t\t\tif (attrAnnHelper == null)\n\t\t\t\t\t\t\t\tattrAnnHelper = new AnnotationHelper();\n\t\t\t\t\t\t\tattrAnnHelper.addByCompoundValue(\n\t\t\t\t\t\t\t\tattval.substring(2, len -1));\n\t\t\t\t\t\t\tattrAnnHelper.applyAnnotations(compInfo,\n\t\t\t\t\t\t\t\t\"self\".equals(attnm) ? null: attnm, true);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taddAttribute(compInfo, attns, attnm, attval, null);\n\t\t\t\t\t\t\tif (attrAnnHelper != null)\n\t\t\t\t\t\t\t\tattrAnnHelper.applyAnnotations(compInfo, attnm, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcompInfo.setCondition(ConditionImpl.getInstance(ifc, unless));\n\t\t\tcompInfo.setForEach(forEach, forEachBegin, forEachEnd);\n\t\t\tannHelper.applyAnnotations(compInfo, null, true);\n\n\t\t\tparse(pgdef, compInfo, el.getChildren(), annHelper); //recursive\n\n\t\t\t//optimize native components\n\t\t\tif (compInfo instanceof NativeInfo\n\t\t\t&& !compInfo.getChildren().isEmpty())\n\t\t\t\toptimizeNativeInfos((NativeInfo)compInfo);\n\t\t}\n\t}","id":65628,"modified_method":"/** Parse an component definition specified in the given element.\n\t */\n\tprivate void parse(PageDefinition pgdef, NodeInfo parent,\n\tElement el, AnnotationHelper annHelper)\n\tthrows Exception {\n\t\tfinal String nm = el.getLocalName();\n\t\tfinal Namespace ns = el.getNamespace();\n\t\tfinal String pref = ns != null ? ns.getPrefix(): \"\";\n\t\tfinal String uri = ns != null ? ns.getURI(): \"\";\n\t\tfinal LanguageDefinition langdef = pgdef.getLanguageDefinition();\n\t\tif (\"zscript\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\tparseZScript(parent, el, annHelper);\n\t\t} else if (\"attribute\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\tif (!(parent instanceof ComponentInfo))\n\t\t\t\tthrow new UiException(\"<attribute> cannot be the root element, \"+el.getLocator());\n\n\t\t\tparseAttribute((ComponentInfo)parent, el, annHelper);\n\t\t} else if (\"custom-attributes\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\tparseCustomAttributes(parent, el, annHelper);\n\t\t} else if (\"variables\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\tparseVariables(parent, el, annHelper);\n\t\t} else if (LanguageDefinition.ANNO_NAMESPACE.equals(uri)) {\n\t\t\tparseAnnotation(el, annHelper);\n\t\t} else {\n\t\t\t//if (D.ON && log.debugable()) log.debug(\"component: \"+nm+\", ns:\"+ns);\n\t\t\tComponentInfo compInfo = null;\n\t\t\tif (\"zk\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\t\tif (annHelper.clear())\n\t\t\t\t\tlog.warning(\"Annotations are ignored since <zk> doesn't support them, \"+el.getLocator());\n\t\t\t\tcompInfo = new ComponentInfo(parent, ComponentDefinition.ZK); \n\t\t\t} else {\n\t\t\t\tboolean prefRequired =\n\t\t\t\t\turi.startsWith(LanguageDefinition.NATIVE_NAMESPACE_PREFIX);\n\t\t\t\tboolean bNative = prefRequired ||\n\t\t\t\t\tLanguageDefinition.NATIVE_NAMESPACE.equals(uri);\n\n\t\t\t\tif (!bNative) {\n\t\t\t\t\tfinal LanguageDefinition complangdef =\n\t\t\t\t\t\tisDefault(langdef, pref, uri) ||\n\t\t\t\t\t\t(langdef.isNative() && !LanguageDefinition.exists(uri)) ?\n\t\t\t\t\t\t\tlangdef: LanguageDefinition.lookup(uri);\n\n\t\t\t\t\tComponentDefinition compdef =\n\t\t\t\t\t\tpgdef.getComponentDefinitionMap().get(nm);\n\t\t\t\t\tif (compdef != null) {\n\t\t\t\t\t\tcompInfo = new ComponentInfo(parent, compdef);\n\t\t\t\t\t} else if (complangdef.hasComponentDefinition(nm)) {\n\t\t\t\t\t\tcompdef = complangdef.getComponentDefinition(nm);\n\t\t\t\t\t\tcompInfo = new ComponentInfo(parent, compdef);\n\t\t\t\t\t} else if (langdef.isNative()) {\n\t\t\t\t\t\tbNative = prefRequired = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcompdef = complangdef.getDynamicTagDefinition();\n\t\t\t\t\t\tif (compdef == null)\n\t\t\t\t\t\t\tthrow new DefinitionNotFoundException(\"Component definition not found: \"+nm+\" in \"+complangdef+\", \"+el.getLocator());\n\t\t\t\t\t\tcompInfo = new ComponentInfo(parent, compdef, nm);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (bNative) {\n\t\t\t\t\tif (annHelper.clear())\n\t\t\t\t\t\tlog.warning(\"Annotations are ignored since native doesn't support them, \"+el.getLocator());\n\n\t\t\t\t\tfinal NativeInfo ni;\n\t\t\t\t\tcompInfo = ni = new NativeInfo(\n\t\t\t\t\t\tparent, langdef.getNativeDefinition(),\n\t\t\t\t\t\tprefRequired && pref.length() > 0 ? pref + \":\" + nm: nm);\n\n\t\t\t\t\t//add declared namespace if starting with native:\n\t\t\t\t\taddDeclaredNamespace(\n\t\t\t\t\t\tni, el.getDeclaredNamespaces(), langdef.isNative());\n\t\t\t\t} else {\n\t\t\t\t\t//process use first because addProperty needs it\n\t\t\t\t\tfinal String use = el.getAttributeValue(\"use\");\n\t\t\t\t\tif (use != null) {\n\t\t\t\t\t\tnoEmpty(\"use\", use, el);\n\t\t\t\t\t\tnoEL(\"use\", use, el);\n\t\t\t\t\t\tcompInfo.setImplementationClass(use);\n\t\t\t\t\t\t\t//Resolve later since might defined in zscript\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString ifc = null, unless = null,\n\t\t\t\tforEach = null, forEachBegin = null, forEachEnd = null;\n\t\t\tAnnotationHelper attrAnnHelper = null;\n\t\t\tfor (Iterator it = el.getAttributeItems().iterator();\n\t\t\tit.hasNext();) {\n\t\t\t\tfinal Attribute attr = (Attribute)it.next();\n\t\t\t\tfinal Namespace attrns = attr.getNamespace();\n\t\t\t\tfinal String attnm = attr.getLocalName();\n\t\t\t\tfinal String attval = attr.getValue();\n\t\t\t\tif (attrns != null\n\t\t\t\t&& LanguageDefinition.ANNO_NAMESPACE.equals(attrns.getURI())) {\n\t\t\t\t\tif (attrAnnHelper == null)\n\t\t\t\t\t\tattrAnnHelper = new AnnotationHelper();\n\t\t\t\t\tattrAnnHelper.addByRawValue(attnm, attval);\n\t\t\t\t} else if (\"forward\".equals(attnm)) {\n\t\t\t\t\tcompInfo.setForward(attval);\n\t\t\t\t} else if (\"if\".equals(attnm)) {\n\t\t\t\t\tifc = attval;\n\t\t\t\t} else if (\"unless\".equals(attnm)) {\n\t\t\t\t\tunless = attval;\n\t\t\t\t} else if (\"forEach\".equals(attnm)) {\n\t\t\t\t\tforEach = attval;\n\t\t\t\t} else if (\"forEachBegin\".equals(attnm)) {\n\t\t\t\t\tforEachBegin = attval;\n\t\t\t\t} else if (\"forEachEnd\".equals(attnm)) {\n\t\t\t\t\tforEachEnd = attval;\n\t\t\t\t} else if (\"fulfill\".equals(attnm)) {\n\t\t\t\t\tcompInfo.setFulfill(attval);\n\t\t\t\t} else if (!\"use\".equals(attnm)) {\n\t\t\t\t\tfinal Namespace attns = attr.getNamespace();\n\t\t\t\t\tfinal String attpref = attns != null ? attns.getPrefix(): \"\";\n\t\t\t\t\tfinal String attruri = attns != null ? attns.getURI(): \"\";\n\t\t\t\t\tif (!\"xmlns\".equals(attpref)\n\t\t\t\t\t&& !(\"xmlns\".equals(attnm) && \"\".equals(attpref))\n\t\t\t\t\t&& !\"http://www.w3.org/2001/XMLSchema-instance\".equals(attruri)) {\n\t\t\t\t\t\tfinal int len = attval.length();\n\t\t\t\t\t\tif (len >= 3 && attval.charAt(0) == '@'\n\t\t\t\t\t\t&& attval.charAt(1) == '{' && attval.charAt(len-1) == '}') { //annotation\n\t\t\t\t\t\t\tif (attrAnnHelper == null)\n\t\t\t\t\t\t\t\tattrAnnHelper = new AnnotationHelper();\n\t\t\t\t\t\t\tattrAnnHelper.addByCompoundValue(\n\t\t\t\t\t\t\t\tattval.substring(2, len -1));\n\t\t\t\t\t\t\tattrAnnHelper.applyAnnotations(compInfo,\n\t\t\t\t\t\t\t\t\"self\".equals(attnm) ? null: attnm, true);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taddAttribute(compInfo, attns, attnm, attval, null);\n\t\t\t\t\t\t\tif (attrAnnHelper != null)\n\t\t\t\t\t\t\t\tattrAnnHelper.applyAnnotations(compInfo, attnm, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcompInfo.setCondition(ConditionImpl.getInstance(ifc, unless));\n\t\t\tcompInfo.setForEach(forEach, forEachBegin, forEachEnd);\n\t\t\tannHelper.applyAnnotations(compInfo, null, true);\n\n\t\t\tparse(pgdef, compInfo, el.getChildren(), annHelper); //recursive\n\n\t\t\t//optimize native components\n\t\t\tif (compInfo instanceof NativeInfo\n\t\t\t&& !compInfo.getChildren().isEmpty())\n\t\t\t\toptimizeNativeInfos((NativeInfo)compInfo);\n\t\t}\n\t}","commit_id":"16543d12387be3ffe9689bb7246349ac7bdc0203","url":"https://github.com/zkoss/zk"},{"original_method":"protected void processMouseEvent(final MouseEvent e) {\n    if (e.getID() == MouseEvent.MOUSE_PRESSED) {\n      myPressPoint = e.getPoint();\n    }\n    else if (e.getID() == MouseEvent.MOUSE_RELEASED) {\n      if (!myDragStarted && e.isControlDown()) {\n        RadComponent component = FormEditingUtil.getRadComponentAt(myEditor.getRootContainer(), e.getX(), e.getY());\n        if (component != null) {\n          component.setSelected(!component.isSelected());\n        }\n      }\n    }\n    else if (e.getID() == MouseEvent.MOUSE_DRAGGED) {\n      if (!myDragStarted) {\n        if ((Math.abs(e.getX() - myPressPoint.getX()) > TREMOR || Math.abs(e.getY() - myPressPoint.getY()) > TREMOR)) {\n          ArrayList<InputEvent> eventList = new ArrayList<InputEvent>();\n          eventList.add(e);\n          myDragGestureRecognizer.setTriggerEvent(e);\n          DragGestureEvent dge = new DragGestureEvent(myDragGestureRecognizer,\n                                                      UIUtil.isControlKeyDown(e) ? DnDConstants.ACTION_COPY : DnDConstants.ACTION_MOVE,\n                                                      myPressPoint, eventList);\n\n          myDragStarted = true;\n          myEditor.getDropTargetListener().setUseDragDelta(true);\n          dge.startDrag(null,\n                        DraggedComponentList.pickupSelection(myEditor, e.getPoint()),\n                        myDragSourceListener);\n        }\n      }\n    }\n  }","id":65629,"modified_method":"protected void processMouseEvent(final MouseEvent e) {\n    if (e.getID() == MouseEvent.MOUSE_PRESSED) {\n      myPressPoint = e.getPoint();\n    }\n    else if (e.getID() == MouseEvent.MOUSE_RELEASED) {\n      if (!myDragStarted && UIUtil.isControlKeyDown(e)) {\n        RadComponent component = FormEditingUtil.getRadComponentAt(myEditor.getRootContainer(), e.getX(), e.getY());\n        if (component != null) {\n          component.setSelected(!component.isSelected());\n        }\n      }\n    }\n    else if (e.getID() == MouseEvent.MOUSE_DRAGGED) {\n      if (!myDragStarted) {\n        if ((Math.abs(e.getX() - myPressPoint.getX()) > TREMOR || Math.abs(e.getY() - myPressPoint.getY()) > TREMOR)) {\n          ArrayList<InputEvent> eventList = new ArrayList<InputEvent>();\n          eventList.add(e);\n          myDragGestureRecognizer.setTriggerEvent(e);\n          DragGestureEvent dge = new DragGestureEvent(myDragGestureRecognizer,\n                                                      UIUtil.isControlKeyDown(e) ? DnDConstants.ACTION_COPY : DnDConstants.ACTION_MOVE,\n                                                      myPressPoint, eventList);\n\n          myDragStarted = true;\n          myEditor.getDropTargetListener().setUseDragDelta(true);\n          dge.startDrag(null,\n                        DraggedComponentList.pickupSelection(myEditor, e.getPoint()),\n                        myDragSourceListener);\n        }\n      }\n    }\n  }","commit_id":"735622d36f7df6f07feb06c3e0dfa2382d2297ca","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processMousePressed(final MouseEvent e){\n    if(myCurrentProcessor != null){\n      if (myCurrentProcessor.needMousePressed()) {\n        myCurrentProcessor.processMouseEvent(e);\n        return;\n      }\n      // Sun sometimes skips mouse released events...\n      myCurrentProcessor.cancelOperation();\n      myCurrentProcessor = null;\n    }\n\n    RadComponent component = null;\n    final RadComponent draggerHost = FormEditingUtil.getDraggerHost(myEditor);\n    // Try to understand whether we pressed inside dragger area\n    if(draggerHost != null){\n      final JComponent delegee = draggerHost.getDelegee();\n      final Point p = SwingUtilities.convertPoint(delegee, 0, 0, e.getComponent());\n      if(\n        p.x - MainProcessor.DRAGGER_SIZE <= e.getX() && e.getX() <= p.x &&\n        p.y - MainProcessor.DRAGGER_SIZE <= e.getY() && e.getY() <= p.y\n      ){\n        component = draggerHost;\n      }\n    }\n\n    // If user clicked not inside dragger then we have find RadComponent at the click point\n    if(component == null){\n      component = FormEditingUtil.getRadComponentAt(myEditor.getRootContainer(), e.getX(), e.getY());\n    }\n\n    if (component == null) {\n      return;\n    }\n\n    final ComponentItem selectedItem = PaletteManager.getInstance(myEditor.getProject()).getActiveItem(ComponentItem.class);\n    if (selectedItem != null) {\n      myInsertComponentProcessor.setSticky(e.isControlDown());\n      myCurrentProcessor = myInsertComponentProcessor;\n      return;\n    }\n\n    if (e.isControlDown()) {\n      //component.setSelected(!(component.isSelected()));\n    }\n    else if (e.isShiftDown()) {\n      // Do not select component is shift is pressed\n    }\n    else {\n      if (!component.isSelected()) {\n        FormEditingUtil.clearSelection(myEditor.getRootContainer());\n        component.setSelected(true);\n      }\n    }\n\n    final Point point = SwingUtilities.convertPoint(e.getComponent(), e.getPoint(), component.getDelegee());\n    final int resizeMask = Painter.getResizeMask(component, point.x, point.y);\n\n    if (resizeMask != 0) {\n      myCurrentProcessor = new ResizeProcessor(myEditor, component, resizeMask);\n    }\n    else if (component instanceof RadRootContainer || ((component instanceof RadContainer) && e.isShiftDown())) {\n      myCurrentProcessor = new GroupSelectionProcessor(myEditor, (RadContainer)component);\n    }\n    else if (!e.isShiftDown()) {\n      myCurrentProcessor = new DragSelectionProcessor(myEditor);\n    }\n\n    updateDragger(e);\n  }","id":65630,"modified_method":"private void processMousePressed(final MouseEvent e){\n    if(myCurrentProcessor != null){\n      if (myCurrentProcessor.needMousePressed()) {\n        myCurrentProcessor.processMouseEvent(e);\n        return;\n      }\n      // Sun sometimes skips mouse released events...\n      myCurrentProcessor.cancelOperation();\n      myCurrentProcessor = null;\n    }\n\n    RadComponent component = null;\n    final RadComponent draggerHost = FormEditingUtil.getDraggerHost(myEditor);\n    // Try to understand whether we pressed inside dragger area\n    if(draggerHost != null){\n      final JComponent delegee = draggerHost.getDelegee();\n      final Point p = SwingUtilities.convertPoint(delegee, 0, 0, e.getComponent());\n      if(\n        p.x - MainProcessor.DRAGGER_SIZE <= e.getX() && e.getX() <= p.x &&\n        p.y - MainProcessor.DRAGGER_SIZE <= e.getY() && e.getY() <= p.y\n      ){\n        component = draggerHost;\n      }\n    }\n\n    // If user clicked not inside dragger then we have find RadComponent at the click point\n    if(component == null){\n      component = FormEditingUtil.getRadComponentAt(myEditor.getRootContainer(), e.getX(), e.getY());\n    }\n\n    if (component == null) {\n      return;\n    }\n\n    final ComponentItem selectedItem = PaletteManager.getInstance(myEditor.getProject()).getActiveItem(ComponentItem.class);\n    if (selectedItem != null) {\n      myInsertComponentProcessor.setSticky(UIUtil.isControlKeyDown(e));\n      myCurrentProcessor = myInsertComponentProcessor;\n      return;\n    }\n\n    if (!UIUtil.isControlKeyDown(e) && !e.isShiftDown() && !component.isSelected()) {\n      FormEditingUtil.clearSelection(myEditor.getRootContainer());\n      component.setSelected(true);\n    }\n\n    final Point point = SwingUtilities.convertPoint(e.getComponent(), e.getPoint(), component.getDelegee());\n    final int resizeMask = Painter.getResizeMask(component, point.x, point.y);\n\n    if (resizeMask != 0) {\n      myCurrentProcessor = new ResizeProcessor(myEditor, component, resizeMask);\n    }\n    else if (component instanceof RadRootContainer || ((component instanceof RadContainer) && e.isShiftDown())) {\n      myCurrentProcessor = new GroupSelectionProcessor(myEditor, (RadContainer)component);\n    }\n    else if (!e.isShiftDown()) {\n      myCurrentProcessor = new DragSelectionProcessor(myEditor);\n    }\n\n    updateDragger(e);\n  }","commit_id":"735622d36f7df6f07feb06c3e0dfa2382d2297ca","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PaletteComponentList(Project project, PaletteGroup group) {\n    myProject = project;\n    myGroup = group;\n    setModel(new AbstractListModel() {\n      public int getSize() {\n        return myGroup.getItems().length;\n      }\n\n      public Object getElementAt(int index) {\n        return myGroup.getItems() [index];\n      }\n    });\n\n    addMouseListener(new MouseAdapter() {\n      @Override public void mouseEntered(MouseEvent e) {\n        setHoverIndex(locationToIndex(e.getPoint()));\n      }\n\n      @Override public void mouseExited(MouseEvent e) {\n        setHoverIndex(-1);\n      }\n\n      @Override public void mousePressed(MouseEvent e) {\n        myNeedClearSelection = (SwingUtilities.isLeftMouseButton(e) &&\n                                myBeforeClickSelectedRow >= 0 &&\n                                locationToIndex(e.getPoint()) == myBeforeClickSelectedRow &&\n                                !e.isControlDown() && !e.isShiftDown());\n      }\n\n      @Override public void mouseReleased(MouseEvent e) {\n        if (SwingUtilities.isLeftMouseButton(e) &&\n            myBeforeClickSelectedRow >= 0 &&\n            locationToIndex(e.getPoint()) == myBeforeClickSelectedRow &&\n            !e.isControlDown() && !e.isShiftDown() && myNeedClearSelection) {\n          clearSelection();\n        }\n      }\n    });\n\n    addMouseListener(new PopupHandler() {\n      public void invokePopup(final Component comp, final int x, final int y) {\n        requestFocusInWindow();\n        SwingUtilities.invokeLater(new Runnable() {\n          public void run() {\n            int index = locationToIndex(new Point(x, y));\n            PaletteItem[] items = myGroup.getItems();\n            if (index >= 0 && index < items.length) {\n              if (getSelectedIndex() != index) {\n                addSelectionInterval(index, index);\n              }\n              PaletteItem item = items [index];\n              ActionGroup group = item.getPopupActionGroup();\n              if (group != null) {\n                ActionPopupMenu popupMenu = ActionManager.getInstance().createActionPopupMenu(ActionPlaces.UNKNOWN, group);\n                popupMenu.getComponent().show(comp, x, y);\n              }\n            }\n          }\n        });\n      }\n    });\n\n    addMouseMotionListener(new MouseMotionAdapter() {\n      public void mouseMoved(MouseEvent e) {\n        setHoverIndex(locationToIndex(e.getPoint()));\n      }\n    });\n\n    setCellRenderer(new ComponentCellRenderer());\n\n    setVisibleRowCount(0);\n    setLayoutOrientation(HORIZONTAL_WRAP);\n    setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n\n    final DnDManager dndManager = DnDManager.getInstance(project);\n    dndManager.registerSource(new MyDnDSource(), this);\n    dndManager.registerTarget(new MyDnDTarget(), this);\n\n    initActions();\n  }","id":65631,"modified_method":"public PaletteComponentList(Project project, PaletteGroup group) {\n    myProject = project;\n    myGroup = group;\n    setModel(new AbstractListModel() {\n      public int getSize() {\n        return myGroup.getItems().length;\n      }\n\n      public Object getElementAt(int index) {\n        return myGroup.getItems() [index];\n      }\n    });\n\n    addMouseListener(new MouseAdapter() {\n      @Override public void mouseEntered(MouseEvent e) {\n        setHoverIndex(locationToIndex(e.getPoint()));\n      }\n\n      @Override public void mouseExited(MouseEvent e) {\n        setHoverIndex(-1);\n      }\n\n      @Override public void mousePressed(MouseEvent e) {\n        myNeedClearSelection = (SwingUtilities.isLeftMouseButton(e) &&\n                                myBeforeClickSelectedRow >= 0 &&\n                                locationToIndex(e.getPoint()) == myBeforeClickSelectedRow &&\n                                !UIUtil.isControlKeyDown(e) && !e.isShiftDown());\n      }\n\n      @Override public void mouseReleased(MouseEvent e) {\n        if (SwingUtilities.isLeftMouseButton(e) &&\n            myBeforeClickSelectedRow >= 0 &&\n            locationToIndex(e.getPoint()) == myBeforeClickSelectedRow &&\n            !UIUtil.isControlKeyDown(e) && !e.isShiftDown() && myNeedClearSelection) {\n          clearSelection();\n        }\n      }\n    });\n\n    addMouseListener(new PopupHandler() {\n      public void invokePopup(final Component comp, final int x, final int y) {\n        requestFocusInWindow();\n        SwingUtilities.invokeLater(new Runnable() {\n          public void run() {\n            int index = locationToIndex(new Point(x, y));\n            PaletteItem[] items = myGroup.getItems();\n            if (index >= 0 && index < items.length) {\n              if (getSelectedIndex() != index) {\n                addSelectionInterval(index, index);\n              }\n              PaletteItem item = items [index];\n              ActionGroup group = item.getPopupActionGroup();\n              if (group != null) {\n                ActionPopupMenu popupMenu = ActionManager.getInstance().createActionPopupMenu(ActionPlaces.UNKNOWN, group);\n                popupMenu.getComponent().show(comp, x, y);\n              }\n            }\n          }\n        });\n      }\n    });\n\n    addMouseMotionListener(new MouseMotionAdapter() {\n      public void mouseMoved(MouseEvent e) {\n        setHoverIndex(locationToIndex(e.getPoint()));\n      }\n    });\n\n    setCellRenderer(new ComponentCellRenderer());\n\n    setVisibleRowCount(0);\n    setLayoutOrientation(HORIZONTAL_WRAP);\n    setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n\n    final DnDManager dndManager = DnDManager.getInstance(project);\n    dndManager.registerSource(new MyDnDSource(), this);\n    dndManager.registerTarget(new MyDnDTarget(), this);\n\n    initActions();\n  }","commit_id":"735622d36f7df6f07feb06c3e0dfa2382d2297ca","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\r\n   * Refreshes item list and coordinates if the selection has changed. So far\r\n   * only numerical data is considered for plotting. If the selected attribute\r\n   * is of kind TEXT, it is treated as INT.\r\n   */\r\n  void refreshAxis() {\r\n    final Data data = GUI.context.data();\r\n    final StatsKey key = isTag ? data.tags.stat(attrID) :\r\n      data.atts.stat(attrID);\r\n    type = key.kind;\r\n    if(type == Kind.CAT)\r\n      type = Kind.TEXT;\r\n\r\n    final int[] items = plotData.pres;\r\n    co = new double[items.length];\r\n    byte[][] vals = new byte[items.length][];\r\n    for(int i = 0; i < items.length; i++) {\r\n      byte[] value = getValue(items[i]);\r\n      if(type == Kind.TEXT && value.length > TEXTLENGTH) {\r\n        value = substring(value, 0, TEXTLENGTH);\r\n      }\r\n      vals[i] = value;\r\n    }\r\n    \r\n    if(type == Kind.TEXT)\r\n      textToNum(vals);\r\n    else {\r\n      calcExtremeValues(vals);\r\n      // coordinates for TEXT already calculated in textToNum()\r\n      for(int i = 0; i < vals.length; i++)\r\n        co[i] = calcPosition(vals[i]);\r\n    }\r\n    vals = null;\r\n  }","id":65632,"modified_method":"/**\r\n   * Refreshes item list and coordinates if the selection has changed. So far\r\n   * only numerical data is considered for plotting. If the selected attribute\r\n   * is of kind TEXT, it is treated as INT.\r\n   */\r\n  void refreshAxis() {\r\n    final Data data = GUI.context.data();\r\n    final StatsKey key = isTag ? data.tags.stat(attrID) :\r\n      data.atts.stat(attrID);\r\n    type = key.kind;\r\n    if(type == Kind.CAT)\r\n      type = Kind.TEXT;\r\n\r\n    final int[] items = plotData.pres;\r\n    co = new double[items.length];\r\n    byte[][] vals = new byte[items.length][];\r\n    for(int i = 0; i < items.length; i++) {\r\n      byte[] value = getValue(items[i]);\r\n      if(type == Kind.TEXT && value.length > TEXTLENGTH) {\r\n        value = substring(value, 0, TEXTLENGTH);\r\n      }\r\n      vals[i] = lc(value);\r\n    }\r\n    \r\n    if(type == Kind.TEXT)\r\n      textToNum(vals);\r\n    else {\r\n      calcExtremeValues(vals);\r\n      // coordinates for TEXT already calculated in textToNum()\r\n      for(int i = 0; i < vals.length; i++)\r\n        co[i] = calcPosition(vals[i]);\r\n    }\r\n    vals = null;\r\n  }","commit_id":"1cfe261c137bd621312fb5542c3d1a2747f605d5","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  protected void refreshInit() {\r\n    plotData = null;\r\n\r\n    final Data data = GUI.context.data();\r\n    if(data != null) {\r\n      if(!GUIProp.showplot) return;\r\n      \r\n      viewDimension = Integer.MAX_VALUE;\r\n      plotData = new PlotData();\r\n\r\n      final String[] items = plotData.getItems().finishString();\r\n      itemCombo.setModel(new DefaultComboBoxModel(items));\r\n\r\n      // set first item and trigger assignment of axis assignments\r\n      if(items.length != 0) itemCombo.setSelectedIndex(0);\r\n\r\n      drawContextMarked = true;\r\n      plotChanged = true;\r\n      repaint();\r\n    }\r\n  }","id":65633,"modified_method":"@Override\r\n  protected void refreshInit() {\r\n    plotData = null;\r\n\r\n    final Data data = GUI.context.data();\r\n    if(data != null) {\r\n      if(!GUIProp.showplot) return;\r\n      \r\n      viewDimension = Integer.MAX_VALUE;\r\n      plotData = new PlotData();\r\n\r\n      final String[] items = plotData.getItems().finishString();\r\n      itemCombo.setModel(new DefaultComboBoxModel(items));\r\n\r\n      // set first item and trigger assignment of axis assignments\r\n      if(items.length != 0) itemCombo.setSelectedIndex(0);\r\n\r\n      drawMarkedContext = true;\r\n      plotChanged = true;\r\n      repaint();\r\n    }\r\n  }","commit_id":"1cfe261c137bd621312fb5542c3d1a2747f605d5","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  protected void refreshContext(final boolean more, final boolean quick) {\r\n    if(!GUIProp.showplot) return;\r\n    \r\n    // all plot data is recalculated, assignments stay the same\r\n    plotData.refreshItems();\r\n    plotData.xAxis.refreshAxis();\r\n    plotData.yAxis.refreshAxis();\r\n\r\n    tmpMarked.reset();\r\n    drawContextMarked = true;\r\n    plotChanged = true;\r\n    repaint();\r\n  }","id":65634,"modified_method":"@Override\r\n  protected void refreshContext(final boolean more, final boolean quick) {\r\n    if(!GUIProp.showplot) return;\r\n    \r\n    // all plot data is recalculated, assignments stay the same\r\n    plotData.refreshItems();\r\n    plotData.xAxis.refreshAxis();\r\n    plotData.yAxis.refreshAxis();\r\n\r\n    tmpMarked.reset();\r\n    drawMarkedContext = true;\r\n    plotChanged = true;\r\n    repaint();\r\n  }","commit_id":"1cfe261c137bd621312fb5542c3d1a2747f605d5","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Draws marked nodes.\r\n   * @param g graphics reference\r\n   */\r\n  private void drawMarkedNodes(final Graphics g) {\r\n    final Data data = GUI.context.data();\r\n    if(!drawContextMarked) {\r\n      final int[] t = tmpMarked.finish();\r\n      for(int i = 0; i < t.length; i++) {\r\n        drawItem(g, plotData.xAxis.co[t[i]], \r\n            plotData.yAxis.co[t[i]], false, true, false);\r\n      }\r\n      return;\r\n    }\r\n\r\n    // if nodes are marked in another view, the given nodes as well as their\r\n    // descendants are checked for intersection with the nodes displayed in\r\n    // the plot\r\n    final Nodes marked = GUI.context.marked();\r\n    if(marked.size() <= 0) return;\r\n    final int[] m = Array.finish(marked.nodes, marked.nodes.length);\r\n    Arrays.sort(m);\r\n    final int[] p = plotData.pres;\r\n    int i = 0;\r\n    int k = plotData.findPre(m[0]);\r\n      \r\n    if(k > -1) {\r\n      drawItem(g, plotData.xAxis.co[k], plotData.yAxis.co[k], false, \r\n          true, false);\r\n      k++;\r\n    } else {\r\n      k *= -1;\r\n      k--;\r\n    }\r\n    \r\n    // context change. descendants of marked node set are\r\n    // also checked for intersection with plotted nodes\r\n    while(i < m.length && k < p.length) {\r\n      final int a = m[i];\r\n      final int b = p[k];\r\n      final int ns = data.size(a, data.kind(a)) - 1;\r\n      if(a == b) {\r\n        drawItem(g, plotData.xAxis.co[k], plotData.yAxis.co[k], false, \r\n            true, false);\r\n        k++;\r\n      } else if(a + ns >= b) {\r\n        if(a < b) drawItem(g, plotData.xAxis.co[k], plotData.yAxis.co[k], \r\n            false, false, true);\r\n        k++;\r\n      } else {\r\n        i++;\r\n      }\r\n    }\r\n  }","id":65635,"modified_method":"/**\r\n   * Draws marked nodes.\r\n   * @param g graphics reference\r\n   */\r\n  private void drawMarkedNodes(final Graphics g) {\r\n    final Data data = GUI.context.data();\r\n//    if(!drawMarkedContext) {\r\n//      final int[] t = tmpMarked.finish();\r\n//      for(int i = 0; i < t.length; i++) {\r\n//        drawItem(g, plotData.xAxis.co[t[i]], \r\n//            plotData.yAxis.co[t[i]], false, true, false);\r\n//      }\r\n//      return;\r\n//    }\r\n\r\n    // if nodes are marked in another view, the given nodes as well as their\r\n    // descendants are checked for intersection with the nodes displayed in\r\n    // the plot\r\n    final Nodes marked = GUI.context.marked();\r\n    if(marked.size() <= 0) return;\r\n    final int[] m = Array.finish(marked.nodes, marked.nodes.length);\r\n    Arrays.sort(m);\r\n    final int[] p = plotData.pres;\r\n    int i = 0;\r\n    int k = plotData.findPre(m[0]);\r\n      \r\n    if(k > -1) {\r\n      drawItem(g, plotData.xAxis.co[k], plotData.yAxis.co[k], false, \r\n          true, false);\r\n      k++;\r\n    } else {\r\n      k *= -1;\r\n      k--;\r\n    }\r\n    \r\n    // context change. descendants of marked node set are\r\n    // also checked for intersection with plotted nodes\r\n    while(i < m.length && k < p.length) {\r\n      final int a = m[i];\r\n      final int b = p[k];\r\n      final int ns = data.size(a, data.kind(a)) - 1;\r\n      if(a == b) {\r\n        drawItem(g, plotData.xAxis.co[k], plotData.yAxis.co[k], false, \r\n            true, false);\r\n        k++;\r\n      } else if(a + ns >= b) {\r\n        if(a < b) drawItem(g, plotData.xAxis.co[k], plotData.yAxis.co[k], \r\n            false, false, true);\r\n        k++;\r\n      } else {\r\n        i++;\r\n      }\r\n    }\r\n  }","commit_id":"1cfe261c137bd621312fb5542c3d1a2747f605d5","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Default Constructor.\r\n   * @param hlp help text\r\n   */\r\n  public PlotView(final byte[] hlp) {\r\n    super(hlp);\r\n    setLayout(new BorderLayout());\r\n    setBorder(5, 5, 5, 5);\r\n    final Box box = new Box(BoxLayout.X_AXIS);\r\n    xCombo = new BaseXCombo();\r\n    xCombo.addActionListener(new ActionListener() {\r\n      public void actionPerformed(final ActionEvent e) {\r\n        if(plotData.xAxis.setAxis((String) xCombo.getSelectedItem())) {\r\n          plotChanged = true;\r\n          repaint();\r\n        }\r\n      }\r\n    });\r\n    yCombo = new BaseXCombo();\r\n    yCombo.addActionListener(new ActionListener() {\r\n      public void actionPerformed(final ActionEvent e) {\r\n        if(plotData.yAxis.setAxis((String) yCombo.getSelectedItem())) {\r\n          plotChanged = true;\r\n          repaint();\r\n        }\r\n      }\r\n    });\r\n    itemCombo = new BaseXCombo();\r\n    itemCombo.addActionListener(new ActionListener() {\r\n      public void actionPerformed(final ActionEvent e) {\r\n        final String item = (String) itemCombo.getSelectedItem();\r\n        if(plotData.setItem(item)) {\r\n          plotChanged = true;\r\n          \r\n          final String[] keys =\r\n            plotData.getCategories(token(item)).finishString();\r\n          xCombo.setModel(new DefaultComboBoxModel(keys));\r\n          yCombo.setModel(new DefaultComboBoxModel(keys));\r\n          if(keys.length > 0) {\r\n            // choose size category as default for vertical axis\r\n            int y = 0;\r\n            for(int k = 0; k < keys.length; k++) {\r\n              if(keys[k].equals(\"@size\") || keys[k].equals(\"size\")) {\r\n                y = k;\r\n                break;\r\n              }\r\n            }\r\n            // choose name category as default for horizontal axis\r\n            int x = y == 0 ? Math.min(1, keys.length) : 0;\r\n            for(int k = 0; k < keys.length; k++) {\r\n              if(keys[k].equals(\"@name\") || keys[k].equals(\"name\")) {\r\n                x = k;\r\n                break;\r\n              }\r\n            }\r\n            xCombo.setSelectedIndex(x);\r\n            yCombo.setSelectedIndex(y);\r\n          }\r\n        }\r\n        tmpMarked.reset();\r\n        repaint();\r\n      }\r\n    });\r\n    box.add(yCombo);\r\n    box.add(Box.createHorizontalStrut(3));\r\n    box.add(new JLabel(\"Y\"));\r\n    box.add(Box.createHorizontalGlue());\r\n    box.add(itemCombo);\r\n    box.add(Box.createHorizontalGlue());\r\n    box.add(new JLabel(\"X\"));\r\n    box.add(Box.createHorizontalStrut(3));\r\n    box.add(xCombo);\r\n    add(box, BorderLayout.SOUTH);\r\n    \r\n    popup = new BaseXPopup(this, GUIConstants.POPUP);\r\n    selectionBox = new PlotBoundingBox();\r\n    tmpMarked = new IntList();\r\n    refreshLayout();\r\n  }","id":65636,"modified_method":"/**\r\n   * Default Constructor.\r\n   * @param hlp help text\r\n   */\r\n  public PlotView(final byte[] hlp) {\r\n    super(hlp);\r\n    setLayout(new BorderLayout());\r\n    setBorder(5, 5, 5, 5);\r\n    final Box box = new Box(BoxLayout.X_AXIS);\r\n    xCombo = new BaseXCombo();\r\n    xCombo.addActionListener(new ActionListener() {\r\n      public void actionPerformed(final ActionEvent e) {\r\n        if(plotData.xAxis.setAxis((String) xCombo.getSelectedItem())) {\r\n          plotChanged = true;\r\n          repaint();\r\n        }\r\n      }\r\n    });\r\n    yCombo = new BaseXCombo();\r\n    yCombo.addActionListener(new ActionListener() {\r\n      public void actionPerformed(final ActionEvent e) {\r\n        if(plotData.yAxis.setAxis((String) yCombo.getSelectedItem())) {\r\n          plotChanged = true;\r\n          repaint();\r\n        }\r\n      }\r\n    });\r\n    itemCombo = new BaseXCombo();\r\n    itemCombo.addActionListener(new ActionListener() {\r\n      public void actionPerformed(final ActionEvent e) {\r\n        final String item = (String) itemCombo.getSelectedItem();\r\n        if(plotData.setItem(item)) {\r\n          plotChanged = true;\r\n          \r\n          final String[] keys =\r\n            plotData.getCategories(token(item)).finishString();\r\n          xCombo.setModel(new DefaultComboBoxModel(keys));\r\n          yCombo.setModel(new DefaultComboBoxModel(keys));\r\n          if(keys.length > 0) {\r\n            // choose size category as default for vertical axis\r\n            int y = 0;\r\n            for(int k = 0; k < keys.length; k++) {\r\n              if(keys[k].equals(\"@size\") || keys[k].equals(\"size\")) {\r\n                y = k;\r\n                break;\r\n              }\r\n            }\r\n            // choose name category as default for horizontal axis\r\n            int x = y == 0 ? Math.min(1, keys.length) : 0;\r\n            for(int k = 0; k < keys.length; k++) {\r\n              if(keys[k].equals(\"@name\") || keys[k].equals(\"name\")) {\r\n                x = k;\r\n                break;\r\n              }\r\n            }\r\n            xCombo.setSelectedIndex(x);\r\n            yCombo.setSelectedIndex(y);\r\n          }\r\n        }\r\n        tmpMarked.reset();\r\n        drawMarkedContext = true;\r\n        repaint();\r\n      }\r\n    });\r\n    box.add(yCombo);\r\n    box.add(Box.createHorizontalStrut(3));\r\n    box.add(new JLabel(\"Y\"));\r\n    box.add(Box.createHorizontalGlue());\r\n    box.add(itemCombo);\r\n    box.add(Box.createHorizontalGlue());\r\n    box.add(new JLabel(\"X\"));\r\n    box.add(Box.createHorizontalStrut(3));\r\n    box.add(xCombo);\r\n    add(box, BorderLayout.SOUTH);\r\n    \r\n    popup = new BaseXPopup(this, GUIConstants.POPUP);\r\n    selectionBox = new PlotBoundingBox();\r\n    tmpMarked = new IntList();\r\n    refreshLayout();\r\n  }","commit_id":"1cfe261c137bd621312fb5542c3d1a2747f605d5","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public void mousePressed(final MouseEvent e) {\r\n    if(working || painting) return;\r\n    super.mousePressed(e);\r\n    mouseX = e.getX();\r\n    mouseY = e.getY();\r\n    focus();\r\n    // no item is focused. no nodes marked after mouse click\r\n    if(focused == -1) {\r\n      // a marking update is triggered with an empty node set as argument\r\n      Nodes n = new Nodes(GUI.context.data());\r\n      notifyMark(n, this);\r\n      tmpMarked.reset();\r\n      return;\r\n    }\r\n    drawContextMarked = false;\r\n    \r\n    // node marking if item focused. if more than one icon is in focus range\r\n    // all of these are marked. focus range means exact same x AND y coordinate.\r\n    final int pre = plotData.findPre(focused);\r\n    if(pre < 0) return;\r\n    // marking operation is executed depending on mouse action\r\n    final boolean left = SwingUtilities.isLeftMouseButton(e);\r\n    \r\n    final IntList il = new IntList();\r\n    if(left) tmpMarked.reset();\r\n    // get coordinates for focused item\r\n    final int mx = calcCoordinate(true, plotData.xAxis.co[pre]);\r\n    final int my = calcCoordinate(false, plotData.yAxis.co[pre]);\r\n    for(int i = 0; i < plotData.size; i++) {\r\n      // get coordinates for current item \r\n      final int x = calcCoordinate(true, plotData.xAxis.co[i]);\r\n      final int y = calcCoordinate(false, plotData.yAxis.co[i]);\r\n      if(mx == x && my == y) {\r\n        il.add(plotData.pres[i]);\r\n        tmpMarked.add(i);\r\n      }\r\n    }\r\n    \r\n    // right mouse or shift down\r\n    if(e.isShiftDown() || !left) {\r\n      final Nodes marked = GUI.context.marked();\r\n      marked.union(il.finish());\r\n      notifyMark(marked, this);\r\n      // double click\r\n    } else if(e.getClickCount() == 2) {\r\n      final Nodes marked = new Nodes(GUI.context.data());\r\n      marked.union(il.finish());\r\n      notifyContext(marked, false, null);\r\n      // simple mouse click\r\n    } else {\r\n      final Nodes marked = new Nodes(GUI.context.data());\r\n      marked.union(il.finish());\r\n      notifyMark(marked, this);\r\n    }\r\n  }","id":65637,"modified_method":"@Override\r\n  public void mousePressed(final MouseEvent e) {\r\n    if(working || painting) return;\r\n//    super.mousePressed(e);\r\n    mouseX = e.getX();\r\n    mouseY = e.getY();\r\n    focus();\r\n    // no item is focused. no nodes marked after mouse click\r\n    if(focused == -1) {\r\n      // a marking update is triggered with an empty node set as argument\r\n      Nodes n = new Nodes(GUI.context.data());\r\n      notifyMark(n, this);\r\n      tmpMarked.reset();\r\n      return;\r\n    }\r\n\r\n    // node marking if item focused. if more than one icon is in focus range\r\n    // all of these are marked. focus range means exact same x AND y coordinate.\r\n    final int pre = plotData.findPre(focused);\r\n    if(pre < 0) return;\r\n    // marking operation is executed depending on mouse action\r\n    final boolean left = SwingUtilities.isLeftMouseButton(e);\r\n    \r\n    final IntList il = new IntList();\r\n    if(left && !e.isShiftDown()) tmpMarked.reset();\r\n    // get coordinates for focused item\r\n    final int mx = calcCoordinate(true, plotData.xAxis.co[pre]);\r\n    final int my = calcCoordinate(false, plotData.yAxis.co[pre]);\r\n    for(int i = 0; i < plotData.size; i++) {\r\n      // get coordinates for current item \r\n      final int x = calcCoordinate(true, plotData.xAxis.co[i]);\r\n      final int y = calcCoordinate(false, plotData.yAxis.co[i]);\r\n      if(mx == x && my == y) {\r\n        il.add(plotData.pres[i]);\r\n        tmpMarked.add(i);\r\n      }\r\n    }\r\n    \r\n    if(SwingUtilities.isRightMouseButton(e)) drawMarkedContext = false;\r\n    // right mouse or shift down\r\n    if(e.isShiftDown()) {\r\n      final Nodes marked = GUI.context.marked();\r\n      marked.union(il.finish());\r\n      notifyMark(marked, this);\r\n      // double click\r\n    } else if(e.getClickCount() == 2) {\r\n      final Nodes marked = new Nodes(GUI.context.data());\r\n      marked.union(il.finish());\r\n      notifyContext(marked, false, null);\r\n      // simple mouse click\r\n    } else {\r\n      final Nodes marked = new Nodes(GUI.context.data());\r\n      marked.union(il.finish());\r\n      notifyMark(marked, this);\r\n    }\r\n  }","commit_id":"1cfe261c137bd621312fb5542c3d1a2747f605d5","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  protected void refreshMark() {\r\n    drawContextMarked = true;\r\n    repaint();\r\n  }","id":65638,"modified_method":"@Override\r\n  protected void refreshMark() {\r\n    drawMarkedContext = true;\r\n    repaint();\r\n  }","commit_id":"1cfe261c137bd621312fb5542c3d1a2747f605d5","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public void mouseDragged(final MouseEvent e) {\r\n    if(working || painting) return;\r\n    if(dragging) {\r\n      // to avoid significant offset between coordinates of mouse click and the\r\n      // start coordinates of the bounding box, mouseX and mouseY are determined\r\n      // by mousePressed()\r\n      mouseX = e.getX();\r\n      mouseY = e.getY();\r\n    }\r\n    final int h = getHeight();\r\n    final int w = getWidth();\r\n    final int th = 14;\r\n    final int lb = MARGIN[1] - th;\r\n    final int rb = w - MARGIN[3] + th;\r\n    final int tb = MARGIN[0] - th;\r\n    final int bb = h - MARGIN[2] + th;\r\n    // flag which indicates if mouse pointer is located on the plot inside.\r\n    boolean inBox = mouseY > tb && mouseY < bb && mouseX > lb && mouseX < rb;\r\n    if(!dragging && !inBox)\r\n      return;\r\n    // first time method is called when mouse dragged\r\n    if(!dragging) {\r\n      dragging = true;\r\n      selectionBox.setStart(mouseX, mouseY);\r\n    }\r\n    drawContextMarked = false;\r\n    \r\n    // keeps selection box on the plot inside. if mouse pointer is outside box\r\n    // the corners of the selection box are set to the predefined values s.a. \r\n    if(!inBox) {\r\n      if(mouseX < lb) {\r\n        if(mouseY > bb) {\r\n          selectionBox.setEnd(lb, bb);\r\n        } else if(mouseY < tb) {\r\n          selectionBox.setEnd(lb, tb);\r\n        } else {\r\n          selectionBox.setEnd(lb, mouseY);\r\n        }\r\n      } else if(mouseX > rb) {\r\n        if(mouseY > bb) {\r\n          selectionBox.setEnd(rb, bb);\r\n        } else if(mouseY < tb) {\r\n          selectionBox.setEnd(rb, tb);\r\n        } else {\r\n          selectionBox.setEnd(rb, mouseY);\r\n        }\r\n      } else if(mouseY < tb) {\r\n        selectionBox.setEnd(mouseX, tb);\r\n      } else\r\n        selectionBox.setEnd(mouseX, bb);\r\n      \r\n      // mouse pointer position is in the plot\r\n    } else {\r\n      selectionBox.setEnd(mouseX, mouseY);\r\n    }\r\n    \r\n    // searches for items located in the selection box\r\n    IntList il = new IntList();\r\n    tmpMarked.reset();\r\n    for(int i = 0; i < plotData.size; i++) {\r\n      final int x = calcCoordinate(true, plotData.xAxis.co[i]);\r\n      final int y = calcCoordinate(false, plotData.yAxis.co[i]);\r\n      if(((x >= selectionBox.x1 && x <= selectionBox.x2) || \r\n          (x <= selectionBox.x1 && x >= selectionBox.x2)) && \r\n          ((y >= selectionBox.y1 && y <= selectionBox.y2) || \r\n             (y <= selectionBox.y1 && y >= selectionBox.y2))) {\r\n        tmpMarked.add(i);\r\n        il.add(plotData.pres[i]);\r\n      }\r\n    }\r\n    notifyMark(new Nodes(il.finish(), GUI.context.data()), this);\r\n    repaint();\r\n  }","id":65639,"modified_method":"@Override\r\n  public void mouseDragged(final MouseEvent e) {\r\n    if(working || painting) return;\r\n    if(dragging) {\r\n      // to avoid significant offset between coordinates of mouse click and the\r\n      // start coordinates of the bounding box, mouseX and mouseY are determined\r\n      // by mousePressed()\r\n      mouseX = e.getX();\r\n      mouseY = e.getY();\r\n    }\r\n    final int h = getHeight();\r\n    final int w = getWidth();\r\n    final int th = 14;\r\n    final int lb = MARGIN[1] - th;\r\n    final int rb = w - MARGIN[3] + th;\r\n    final int tb = MARGIN[0] - th;\r\n    final int bb = h - MARGIN[2] + th;\r\n    // flag which indicates if mouse pointer is located on the plot inside.\r\n    boolean inBox = mouseY > tb && mouseY < bb && mouseX > lb && mouseX < rb;\r\n    if(!dragging && !inBox)\r\n      return;\r\n    // first time method is called when mouse dragged\r\n    if(!dragging) {\r\n      dragging = true;\r\n      selectionBox.setStart(mouseX, mouseY);\r\n    }\r\n    drawMarkedContext = false;\r\n    \r\n    // keeps selection box on the plot inside. if mouse pointer is outside box\r\n    // the corners of the selection box are set to the predefined values s.a. \r\n    if(!inBox) {\r\n      if(mouseX < lb) {\r\n        if(mouseY > bb) {\r\n          selectionBox.setEnd(lb, bb);\r\n        } else if(mouseY < tb) {\r\n          selectionBox.setEnd(lb, tb);\r\n        } else {\r\n          selectionBox.setEnd(lb, mouseY);\r\n        }\r\n      } else if(mouseX > rb) {\r\n        if(mouseY > bb) {\r\n          selectionBox.setEnd(rb, bb);\r\n        } else if(mouseY < tb) {\r\n          selectionBox.setEnd(rb, tb);\r\n        } else {\r\n          selectionBox.setEnd(rb, mouseY);\r\n        }\r\n      } else if(mouseY < tb) {\r\n        selectionBox.setEnd(mouseX, tb);\r\n      } else\r\n        selectionBox.setEnd(mouseX, bb);\r\n      \r\n      // mouse pointer position is in the plot\r\n    } else {\r\n      selectionBox.setEnd(mouseX, mouseY);\r\n    }\r\n    \r\n    // searches for items located in the selection box\r\n    IntList il = new IntList();\r\n    tmpMarked.reset();\r\n    for(int i = 0; i < plotData.size; i++) {\r\n      final int x = calcCoordinate(true, plotData.xAxis.co[i]);\r\n      final int y = calcCoordinate(false, plotData.yAxis.co[i]);\r\n      if(((x >= selectionBox.x1 && x <= selectionBox.x2) || \r\n          (x <= selectionBox.x1 && x >= selectionBox.x2)) && \r\n          ((y >= selectionBox.y1 && y <= selectionBox.y2) || \r\n             (y <= selectionBox.y1 && y >= selectionBox.y2))) {\r\n        tmpMarked.add(i);\r\n        il.add(plotData.pres[i]);\r\n      }\r\n    }\r\n    notifyMark(new Nodes(il.finish(), GUI.context.data()), this);\r\n    repaint();\r\n  }","commit_id":"1cfe261c137bd621312fb5542c3d1a2747f605d5","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n\t * Obtain the file represenation from the given URI.\n\t */\n\tprotected abstract SomeFile asFile(AbsoluteURI absoluteURI);","id":65640,"modified_method":"/**\n\t * Obtain the file represenation from the given URI.\n\t */\n\tprotected abstract SomeFile asFile(AbsoluteURI absoluteURI, IProjectConfig project);","commit_id":"d8ed4d862e69aefec8143015baec9c47cdc1ac1a","url":"https://github.com/eclipse/xtext"},{"original_method":"protected SomeFile asFile(SourceRelativeURI srcRelativeDerivedResource, IProjectConfig project) {\n\t\tString[] pathSegments = srcRelativeDerivedResource.getURI().segments();\n\t\tSet<? extends ISourceFolder> sourceFolders = project.getSourceFolders();\n\t\tfor(ISourceFolder folder: sourceFolders) {\n\t\t\tURI srcFolderPath = folder.getPath();\n\t\t\tURI absoluteURI = srcFolderPath.appendSegments(pathSegments);\n\t\t\tSomeFile result = asFile(new AbsoluteURI(absoluteURI));\n\t\t\tif (result != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\tURI fromRoot = project.getPath().appendSegments(pathSegments);\n\t\treturn asFile(new AbsoluteURI(fromRoot));\n\t}","id":65641,"modified_method":"protected SomeFile asFile(SourceRelativeURI srcRelativeDerivedResource, IProjectConfig project) {\n\t\tString[] pathSegments = srcRelativeDerivedResource.getURI().segments();\n\t\tSet<? extends ISourceFolder> sourceFolders = project.getSourceFolders();\n\t\tfor(ISourceFolder folder: sourceFolders) {\n\t\t\tURI srcFolderPath = folder.getPath();\n\t\t\tURI absoluteURI = srcFolderPath.appendSegments(pathSegments);\n\t\t\tSomeFile result = asFile(new AbsoluteURI(absoluteURI), project);\n\t\t\tif (result != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\tURI fromRoot = project.getPath().appendSegments(pathSegments);\n\t\treturn asFile(new AbsoluteURI(fromRoot), project);\n\t}","commit_id":"d8ed4d862e69aefec8143015baec9c47cdc1ac1a","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic Trace getTraceToTarget(final AbsoluteURI absoluteSourceResource) {\n\t\tfinal SomeFile sourceFile = asFile(absoluteSourceResource);\n\t\treturn getTraceToTarget(sourceFile, absoluteSourceResource, getProjectConfig(sourceFile));\n\t}","id":65642,"modified_method":"@Override\n\tpublic Trace getTraceToTarget(final AbsoluteURI absoluteSourceResource, IWorkspaceConfig context) {\n\t\tfinal SomeFile sourceFile = asFile(absoluteSourceResource, context);\n\t\treturn getTraceToTarget(sourceFile, absoluteSourceResource, getProjectConfig(sourceFile));\n\t}","commit_id":"d8ed4d862e69aefec8143015baec9c47cdc1ac1a","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic Trace getTraceToSource(AbsoluteURI absoluteDerivedResource) {\n\t\tfinal SomeFile generatedFile = asFile(absoluteDerivedResource);\n\t\treturn getTraceToSource(generatedFile);\n\t}","id":65643,"modified_method":"@Override\n\tpublic Trace getTraceToSource(AbsoluteURI absoluteDerivedResource, IWorkspaceConfig context) {\n\t\tfinal SomeFile generatedFile = asFile(absoluteDerivedResource, context);\n\t\treturn getTraceToSource(generatedFile);\n\t}","commit_id":"d8ed4d862e69aefec8143015baec9c47cdc1ac1a","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public VirtualFile getPlatformResource() {\n    VirtualFileBasedTrace _trace = this.getTrace();\n    SourceRelativeURI _srcRelativeResourceURI = this.getSrcRelativeResourceURI();\n    Module _project = this.getProject();\n    return _trace.findVirtualFile(_srcRelativeResourceURI, _project);\n  }","id":65644,"modified_method":"@Override\n  public VirtualFileInProject getPlatformResource() {\n    VirtualFileBasedTrace _trace = this.getTrace();\n    SourceRelativeURI _srcRelativeResourceURI = this.getSrcRelativeResourceURI();\n    Module _project = this.getProject();\n    return _trace.findVirtualFileInProject(_srcRelativeResourceURI, _project);\n  }","commit_id":"d8ed4d862e69aefec8143015baec9c47cdc1ac1a","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic Trace getTraceToTarget(AbsoluteURI absoluteSourceResource) {\n\t\treturn null;\n\t}","id":65645,"modified_method":"@Override\n\tpublic Trace getTraceToTarget(AbsoluteURI absoluteSourceResource, IWorkspaceConfig context) {\n\t\treturn null;\n\t}","commit_id":"d8ed4d862e69aefec8143015baec9c47cdc1ac1a","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic Trace getTraceToSource(AbsoluteURI absoluteDerivedResource) {\n\t\treturn null;\n\t}","id":65646,"modified_method":"@Override\n\tpublic Trace getTraceToSource(AbsoluteURI absoluteDerivedResource, IWorkspaceConfig context) {\n\t\treturn null;\n\t}","commit_id":"d8ed4d862e69aefec8143015baec9c47cdc1ac1a","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected IFile asFile(AbsoluteURI absoluteURI) {\n\t\tURI uri = absoluteURI.getURI();\n\t\tif (uri.isPlatformResource()) {\n\t\t\tIFile result = workspace.getRoot().getFile(new Path(uri.toPlatformString(true)));\n\t\t\tif (result.exists()) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","id":65647,"modified_method":"@Override\n\tprotected IFile asFile(AbsoluteURI absoluteURI, IProjectConfig project) {\n\t\tURI uri = absoluteURI.getURI();\n\t\tif (uri.isPlatformResource()) {\n\t\t\tIFile result = workspace.getRoot().getFile(new Path(uri.toPlatformString(true)));\n\t\t\tif (result.exists()) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","commit_id":"d8ed4d862e69aefec8143015baec9c47cdc1ac1a","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  protected AbsoluteURI getAbsoluteLocation(final VirtualFile file) {\n    throw new UnsupportedOperationException(\"TODO: auto-generated method stub\");\n  }","id":65648,"modified_method":"protected AbsoluteURI getAbsoluteLocation(final VirtualFile file) {\n    URI _uRI = VirtualFileURIUtil.getURI(file);\n    return new AbsoluteURI(_uRI);\n  }","commit_id":"d8ed4d862e69aefec8143015baec9c47cdc1ac1a","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  protected VirtualFile asFile(final AbsoluteURI absoluteURI) {\n    VirtualFileManager _instance = VirtualFileManager.getInstance();\n    URI _uRI = absoluteURI.getURI();\n    String _string = _uRI.toString();\n    return _instance.findFileByUrl(_string);\n  }","id":65649,"modified_method":"@Override\n  protected VirtualFileInProject asFile(final AbsoluteURI absoluteURI, final IProjectConfig project) {\n    VirtualFileManager _instance = VirtualFileManager.getInstance();\n    URI _uRI = absoluteURI.getURI();\n    String _string = _uRI.toString();\n    final VirtualFile file = _instance.findFileByUrl(_string);\n    final Module module = ((IdeaModuleConfig) project).getModule();\n    final Project ideaProject = module.getProject();\n    return new VirtualFileInProject(file, ideaProject);\n  }","commit_id":"d8ed4d862e69aefec8143015baec9c47cdc1ac1a","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  protected IProjectConfig getProjectConfig(final VirtualFile sourceFile) {\n    throw new UnsupportedOperationException(\"TODO: auto-generated method stub\");\n  }","id":65650,"modified_method":"@Override\n  protected IProjectConfig getProjectConfig(final VirtualFileInProject sourceFile) {\n    Project _project = sourceFile.getProject();\n    IdeaWorkspaceConfig _ideaWorkspaceConfig = new IdeaWorkspaceConfig(_project);\n    VirtualFile _file = sourceFile.getFile();\n    URI _uRI = VirtualFileURIUtil.getURI(_file);\n    return _ideaWorkspaceConfig.findProjectContaining(_uRI);\n  }","commit_id":"d8ed4d862e69aefec8143015baec9c47cdc1ac1a","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  protected List<AbstractTraceForURIProvider.PersistedTrace> findInverseTraceFiles(final VirtualFile sourceFile) {\n    throw new UnsupportedOperationException(\"TODO: auto-generated method stub\");\n  }","id":65651,"modified_method":"@Override\n  protected List<AbstractTraceForURIProvider.PersistedTrace> findInverseTraceFiles(final VirtualFileInProject sourceFile) {\n    final Project ideaProject = sourceFile.getProject();\n    final XtextAutoBuilderComponent builder = ideaProject.<XtextAutoBuilderComponent>getComponent(XtextAutoBuilderComponent.class);\n    VirtualFile _file = sourceFile.getFile();\n    URI _uRI = VirtualFileURIUtil.getURI(_file);\n    final Iterable<URI> generatedSources = builder.getGeneratedSources(_uRI);\n    final Function1<URI, AbstractTraceForURIProvider.PersistedTrace> _function = new Function1<URI, AbstractTraceForURIProvider.PersistedTrace>() {\n      @Override\n      public AbstractTraceForURIProvider.PersistedTrace apply(final URI it) {\n        VirtualFileManager _instance = VirtualFileManager.getInstance();\n        String _string = it.toString();\n        final VirtualFile file = _instance.findFileByUrl(_string);\n        VirtualFileInProject _virtualFileInProject = new VirtualFileInProject(file, ideaProject);\n        return TraceForVirtualFileProvider.this.findPersistedTrace(_virtualFileInProject);\n      }\n    };\n    Iterable<AbstractTraceForURIProvider.PersistedTrace> _map = IterableExtensions.<URI, AbstractTraceForURIProvider.PersistedTrace>map(generatedSources, _function);\n    return IterableExtensions.<AbstractTraceForURIProvider.PersistedTrace>toList(_map);\n  }","commit_id":"d8ed4d862e69aefec8143015baec9c47cdc1ac1a","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public IIdeaTrace getTraceToTarget(final VirtualFile sourceResource) {\n    throw new UnsupportedOperationException(\"TODO: auto-generated method stub\");\n  }","id":65652,"modified_method":"@Override\n  public IIdeaTrace getTraceToTarget(final VirtualFileInProject sourceResource) {\n    AbsoluteURI _absoluteLocation = this.getAbsoluteLocation(sourceResource);\n    IProjectConfig _projectConfig = this.getProjectConfig(sourceResource);\n    return this.getTraceToTarget(sourceResource, _absoluteLocation, _projectConfig);\n  }","commit_id":"d8ed4d862e69aefec8143015baec9c47cdc1ac1a","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  protected VirtualFileBasedTrace newAbstractTrace(final VirtualFile file) {\n    throw new UnsupportedOperationException(\"TODO: auto-generated method stub\");\n  }","id":65653,"modified_method":"@Override\n  protected VirtualFileBasedTrace newAbstractTrace(final VirtualFileInProject file) {\n    final VirtualFileBasedTrace result = this.traceProvider.get();\n    result.setLocalStorage(file);\n    return result;\n  }","commit_id":"d8ed4d862e69aefec8143015baec9c47cdc1ac1a","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  protected AbstractTraceForURIProvider.PersistedTrace findPersistedTrace(final VirtualFile generatedFile) {\n    throw new UnsupportedOperationException(\"TODO: auto-generated method stub\");\n  }","id":65654,"modified_method":"@Override\n  protected AbstractTraceForURIProvider.PersistedTrace findPersistedTrace(final VirtualFileInProject generatedFile) {\n    final VirtualFile virtualFile = generatedFile.getFile();\n    VirtualFile _traceFile = this.getTraceFile(virtualFile);\n    return new TraceForVirtualFileProvider.VirtualFilePersistedTrace(_traceFile, this);\n  }","commit_id":"d8ed4d862e69aefec8143015baec9c47cdc1ac1a","url":"https://github.com/eclipse/xtext"},{"original_method":"public InputStream getContents(final SourceRelativeURI uri, final Module project) throws IOException {\n    final VirtualFile file = this.findVirtualFile(uri, project);\n    byte[] _contentsToByteArray = file.contentsToByteArray();\n    return new ByteArrayInputStream(_contentsToByteArray);\n  }","id":65655,"modified_method":"public InputStream getContents(final SourceRelativeURI uri, final Module project) throws IOException {\n    final VirtualFileInProject file = this.findVirtualFileInProject(uri, project);\n    VirtualFile _file = file.getFile();\n    byte[] _contentsToByteArray = _file.contentsToByteArray();\n    return new ByteArrayInputStream(_contentsToByteArray);\n  }","commit_id":"d8ed4d862e69aefec8143015baec9c47cdc1ac1a","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public Iterable<? extends ILocationInVirtualFile> getAllAssociatedLocations(final VirtualFile associatedVirtualFile) {\n    final AbsoluteURI uri = this.getURIForVirtualFile(associatedVirtualFile);\n    return this.getAllAssociatedLocations(uri);\n  }","id":65656,"modified_method":"@Override\n  public Iterable<? extends ILocationInVirtualFile> getAllAssociatedLocations(final VirtualFileInProject associatedVirtualFile) {\n    final AbsoluteURI uri = this.getURIForVirtualFile(associatedVirtualFile);\n    return this.getAllAssociatedLocations(uri);\n  }","commit_id":"d8ed4d862e69aefec8143015baec9c47cdc1ac1a","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public Iterable<? extends ILocationInVirtualFile> getAllAssociatedLocations(final ITextRegion localRegion, final VirtualFile associatedVirtualFile) {\n    final AbsoluteURI uri = this.getURIForVirtualFile(associatedVirtualFile);\n    return this.getAllAssociatedLocations(localRegion, uri);\n  }","id":65657,"modified_method":"@Override\n  public Iterable<? extends ILocationInVirtualFile> getAllAssociatedLocations(final ITextRegion localRegion, final VirtualFileInProject associatedVirtualFile) {\n    final AbsoluteURI uri = this.getURIForVirtualFile(associatedVirtualFile);\n    return this.getAllAssociatedLocations(localRegion, uri);\n  }","commit_id":"d8ed4d862e69aefec8143015baec9c47cdc1ac1a","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public VirtualFile getLocalStorage() {\n    return this.localVirtualFile;\n  }","id":65658,"modified_method":"@Override\n  public VirtualFileInProject getLocalStorage() {\n    return this.localVirtualFile;\n  }","commit_id":"d8ed4d862e69aefec8143015baec9c47cdc1ac1a","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public ILocationInVirtualFile getBestAssociatedLocation(final ITextRegion region, final VirtualFile associatedVirtualFile) {\n    final AbsoluteURI uri = this.getURIForVirtualFile(associatedVirtualFile);\n    return this.getBestAssociatedLocation(region, uri);\n  }","id":65659,"modified_method":"@Override\n  public ILocationInVirtualFile getBestAssociatedLocation(final ITextRegion region, final VirtualFileInProject associatedVirtualFile) {\n    final AbsoluteURI uri = this.getURIForVirtualFile(associatedVirtualFile);\n    return this.getBestAssociatedLocation(region, uri);\n  }","commit_id":"d8ed4d862e69aefec8143015baec9c47cdc1ac1a","url":"https://github.com/eclipse/xtext"},{"original_method":"public VirtualFile findVirtualFile(final SourceRelativeURI srcRelativeLocation, final Module module) {\n    final ModuleRootManager mngr = ModuleRootManager.getInstance(module);\n    final VirtualFile[] sourceRoots = mngr.getSourceRoots(true);\n    URI _uRI = srcRelativeLocation.getURI();\n    final String path = _uRI.path();\n    for (final VirtualFile sourceRoot : sourceRoots) {\n      {\n        final VirtualFile result = sourceRoot.findFileByRelativePath(path);\n        boolean _notEquals = (!Objects.equal(result, null));\n        if (_notEquals) {\n          return result;\n        }\n      }\n    }\n    return null;\n  }","id":65660,"modified_method":"public VirtualFileInProject findVirtualFileInProject(final SourceRelativeURI srcRelativeLocation, final Module module) {\n    final ModuleRootManager mngr = ModuleRootManager.getInstance(module);\n    final VirtualFile[] sourceRoots = mngr.getSourceRoots(true);\n    URI _uRI = srcRelativeLocation.getURI();\n    final String path = _uRI.path();\n    for (final VirtualFile sourceRoot : sourceRoots) {\n      {\n        final VirtualFile result = sourceRoot.findFileByRelativePath(path);\n        boolean _notEquals = (!Objects.equal(result, null));\n        if (_notEquals) {\n          Project _project = module.getProject();\n          return new VirtualFileInProject(result, _project);\n        }\n      }\n    }\n    return null;\n  }","commit_id":"d8ed4d862e69aefec8143015baec9c47cdc1ac1a","url":"https://github.com/eclipse/xtext"},{"original_method":"public Iterable<URI> getGeneratedSources(final URI source) {\n    Collection<Source2GeneratedMapping> _values = this.module2GeneratedMapping.values();\n    final Function1<Source2GeneratedMapping, Iterable<URI>> _function = new Function1<Source2GeneratedMapping, Iterable<URI>>() {\n      @Override\n      public Iterable<URI> apply(final Source2GeneratedMapping it) {\n        return it.getGenerated(source);\n      }\n    };\n    Iterable<Iterable<URI>> _map = IterableExtensions.<Source2GeneratedMapping, Iterable<URI>>map(_values, _function);\n    final Function2<Iterable<URI>, Iterable<URI>, Iterable<URI>> _function_1 = new Function2<Iterable<URI>, Iterable<URI>, Iterable<URI>>() {\n      @Override\n      public Iterable<URI> apply(final Iterable<URI> $0, final Iterable<URI> $1) {\n        return Iterables.<URI>concat($0, $1);\n      }\n    };\n    return IterableExtensions.<Iterable<URI>>reduce(_map, _function_1);\n  }","id":65661,"modified_method":"public Iterable<URI> getGeneratedSources(final URI source) {\n    Collection<Source2GeneratedMapping> _values = this.module2GeneratedMapping.values();\n    final Function1<Source2GeneratedMapping, Iterable<URI>> _function = new Function1<Source2GeneratedMapping, Iterable<URI>>() {\n      @Override\n      public Iterable<URI> apply(final Source2GeneratedMapping it) {\n        return it.getGenerated(source);\n      }\n    };\n    Iterable<Iterable<URI>> _map = IterableExtensions.<Source2GeneratedMapping, Iterable<URI>>map(_values, _function);\n    return Iterables.<URI>concat(_map);\n  }","commit_id":"d8ed4d862e69aefec8143015baec9c47cdc1ac1a","url":"https://github.com/eclipse/xtext"},{"original_method":"public Iterable<URI> getSource4GeneratedSource(final URI generated) {\n    Collection<Source2GeneratedMapping> _values = this.module2GeneratedMapping.values();\n    final Function1<Source2GeneratedMapping, Iterable<URI>> _function = new Function1<Source2GeneratedMapping, Iterable<URI>>() {\n      @Override\n      public Iterable<URI> apply(final Source2GeneratedMapping it) {\n        return it.getSource(generated);\n      }\n    };\n    Iterable<Iterable<URI>> _map = IterableExtensions.<Source2GeneratedMapping, Iterable<URI>>map(_values, _function);\n    final Function2<Iterable<URI>, Iterable<URI>, Iterable<URI>> _function_1 = new Function2<Iterable<URI>, Iterable<URI>, Iterable<URI>>() {\n      @Override\n      public Iterable<URI> apply(final Iterable<URI> $0, final Iterable<URI> $1) {\n        return Iterables.<URI>concat($0, $1);\n      }\n    };\n    return IterableExtensions.<Iterable<URI>>reduce(_map, _function_1);\n  }","id":65662,"modified_method":"public Iterable<URI> getSource4GeneratedSource(final URI generated) {\n    Collection<Source2GeneratedMapping> _values = this.module2GeneratedMapping.values();\n    final Function1<Source2GeneratedMapping, Iterable<URI>> _function = new Function1<Source2GeneratedMapping, Iterable<URI>>() {\n      @Override\n      public Iterable<URI> apply(final Source2GeneratedMapping it) {\n        return it.getSource(generated);\n      }\n    };\n    Iterable<Iterable<URI>> _map = IterableExtensions.<Source2GeneratedMapping, Iterable<URI>>map(_values, _function);\n    return Iterables.<URI>concat(_map);\n  }","commit_id":"d8ed4d862e69aefec8143015baec9c47cdc1ac1a","url":"https://github.com/eclipse/xtext"},{"original_method":"private void onClone() {\n    FileTemplate selected = myCurrentTab.getSelectedTemplate();\n    if (selected == null) return;\n\n    final FileTemplate[] templates = myCurrentTab.getTemplates();\n    ArrayList<String> names = new ArrayList<String>(templates.length);\n    for (FileTemplate template : templates) {\n      names.add(template.getName());\n    }\n    String nameTemplate = IdeBundle.message(\"template.copy.N.of.T\");\n    String name = MessageFormat.format(nameTemplate, \"\", selected.getName());\n    int i = 0;\n    while (names.contains(name)) {\n      name = MessageFormat.format(nameTemplate, (++i) + \" \", selected.getName());\n    }\n    FileTemplate newTemplate = new FileTemplateImpl(selected.getText(), name, selected.getExtension());\n    myCurrentTab.addTemplate(newTemplate);\n    myModified = true;\n    myCurrentTab.selectTemplate(newTemplate);\n    fireListChanged();\n  }","id":65663,"modified_method":"private void onClone() {\n    FileTemplate selected = myCurrentTab.getSelectedTemplate();\n    if (selected == null) return;\n\n    final FileTemplate[] templates = myCurrentTab.getTemplates();\n    ArrayList<String> names = new ArrayList<String>(templates.length);\n    for (FileTemplate template : templates) {\n      names.add(template.getName());\n    }\n    @SuppressWarnings({\"UnresolvedPropertyKey\"})\n    String nameTemplate = IdeBundle.message(\"template.copy.N.of.T\");\n    String name = MessageFormat.format(nameTemplate, \"\", selected.getName());\n    int i = 0;\n    while (names.contains(name)) {\n      name = MessageFormat.format(nameTemplate, (++i) + \" \", selected.getName());\n    }\n    FileTemplate newTemplate = new FileTemplateImpl(selected.getText(), name, selected.getExtension());\n    myCurrentTab.addTemplate(newTemplate);\n    myModified = true;\n    myCurrentTab.selectTemplate(newTemplate);\n    fireListChanged();\n  }","commit_id":"c597936f8e94541e34c702bf08cd5766dc94fac7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public String getText(){\n    String text = \"\";\n    try{\n      text = getContent();\n    }\n    catch (IOException e){\n      LOG.error(\"Unable to read template \\\"\"+myName+\"\\\"\", e);\n    }\n    return text;\n  }","id":65664,"modified_method":"@NotNull\n  public String getText(){\n    try{\n      return getContent();\n    }\n    catch (IOException e){\n      LOG.error(\"Unable to read template \\\"\"+myName+\"\\\"\", e);\n      return \"\";\n    }\n  }","commit_id":"c597936f8e94541e34c702bf08cd5766dc94fac7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/** Creates new template. This template is marked as 'new', i.e. it will be saved to new file at IDEA end. */\n  FileTemplateImpl(String content, @NotNull String name, @NotNull String extension){\n    if(content != null){\n      content = StringUtil.convertLineSeparators(content);\n    }\n    myContent = content;\n    myName = replaceFileSeparatorChar(name);\n    myExtension = extension;\n    myModified = true;\n  }","id":65665,"modified_method":"/** Creates new template. This template is marked as 'new', i.e. it will be saved to new file at IDEA end. */\n  FileTemplateImpl(@NotNull String content, @NotNull String name, @NotNull String extension){\n    myContent = StringUtil.convertLineSeparators(content);\n    myName = replaceFileSeparatorChar(name);\n    myExtension = extension;\n    myModified = true;\n  }","commit_id":"c597936f8e94541e34c702bf08cd5766dc94fac7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/** Save template to file. If template is new, it is saved to specified directory. Otherwise it is saved to file from which it was read.\n   *  If template was not modified, it is not saved.\n   */\n  void writeExternal(File defaultDir) throws IOException{\n    if (!myModified && !myRenamed) {\n      return;\n    }\n    if(myRenamed){\n      LOG.assertTrue(myTemplateFile != null);\n      LOG.assertTrue(myTemplateFile.delete());\n      myTemplateFile = null;\n      myRenamed = false;\n    }\n    File templateFile = myReadOnly ? null : myTemplateFile;\n    if(templateFile == null){\n      LOG.assertTrue(defaultDir.isDirectory());\n      templateFile = new File(defaultDir, myName+\".\"+myExtension);\n    }\n    FileOutputStream fileOutputStream = new FileOutputStream(templateFile);\n    OutputStreamWriter outputStreamWriter;\n    try{\n      outputStreamWriter = new OutputStreamWriter(fileOutputStream, ourEncoding);\n    }\n    catch (UnsupportedEncodingException e){\n      Messages.showMessageDialog(IdeBundle.message(\"error.unable.to.save.file.template.using.encoding\", getName(), ourEncoding),\n                                 CommonBundle.getErrorTitle(), Messages.getErrorIcon());\n      outputStreamWriter = new OutputStreamWriter(fileOutputStream);\n    }\n    String content = getContent();\n    Project project = ProjectManagerEx.getInstanceEx().getDefaultProject();\n    String lineSeparator = CodeStyleSettingsManager.getSettings(project).getLineSeparator();\n\n    if (!lineSeparator.equals(\"\\n\")){\n      content = StringUtil.convertLineSeparators(content, lineSeparator);\n    }\n\n    outputStreamWriter.write(content);\n    outputStreamWriter.close();\n    fileOutputStream.close();\n\n//    StringReader reader = new StringReader(getContent());\n//    FileWriter fileWriter = new FileWriter(templateFile);\n//    BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);\n//    for(int currChar = reader.read(); currChar != -1; currChar = reader.read()){\n//      bufferedWriter.write(currChar);\n//    }\n//    bufferedWriter.close();\n//    fileWriter.close();\n    myModified = false;\n    myTemplateFile = templateFile;\n  }","id":65666,"modified_method":"/** Save template to file. If template is new, it is saved to specified directory. Otherwise it is saved to file from which it was read.\n   *  If template was not modified, it is not saved.\n   */\n  void writeExternal(File defaultDir) throws IOException{\n    File templateFile;\n    synchronized (this) {\n      if (!myModified && !myRenamed) {\n        return;\n      }\n      if(myRenamed){\n        LOG.assertTrue(myTemplateFile != null);\n        LOG.assertTrue(myTemplateFile.delete());\n        myTemplateFile = null;\n        myRenamed = false;\n      }\n      templateFile = myReadOnly ? null : myTemplateFile;\n      if(templateFile == null){\n        LOG.assertTrue(defaultDir.isDirectory());\n        templateFile = new File(defaultDir, myName+\".\"+myExtension);\n      }\n    }\n\n    FileOutputStream fileOutputStream = new FileOutputStream(templateFile);\n    OutputStreamWriter outputStreamWriter;\n    try{\n      outputStreamWriter = new OutputStreamWriter(fileOutputStream, ourEncoding);\n    }\n    catch (UnsupportedEncodingException e){\n      Messages.showMessageDialog(IdeBundle.message(\"error.unable.to.save.file.template.using.encoding\", getName(), ourEncoding),\n                                 CommonBundle.getErrorTitle(), Messages.getErrorIcon());\n      outputStreamWriter = new OutputStreamWriter(fileOutputStream);\n    }\n    String content = getContent();\n    Project project = ProjectManagerEx.getInstanceEx().getDefaultProject();\n    String lineSeparator = CodeStyleSettingsManager.getSettings(project).getLineSeparator();\n\n    if (!lineSeparator.equals(\"\\n\")){\n      content = StringUtil.convertLineSeparators(content, lineSeparator);\n    }\n\n    outputStreamWriter.write(content);\n    outputStreamWriter.close();\n    fileOutputStream.close();\n\n//    StringReader reader = new StringReader(getContent());\n//    FileWriter fileWriter = new FileWriter(templateFile);\n//    BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);\n//    for(int currChar = reader.read(); currChar != -1; currChar = reader.read()){\n//      bufferedWriter.write(currChar);\n//    }\n//    bufferedWriter.close();\n//    fileWriter.close();\n    synchronized (this) {\n      myModified = false;\n      myTemplateFile = templateFile;\n    }\n  }","commit_id":"c597936f8e94541e34c702bf08cd5766dc94fac7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setInternal(boolean isInternal) {\n    myIsInternal = true;\n  }","id":65667,"modified_method":"public synchronized void setInternal(boolean isInternal) {\n    myIsInternal = isInternal;\n  }","commit_id":"c597936f8e94541e34c702bf08cd5766dc94fac7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void resetToDefault() {\n    LOG.assertTrue(!isDefault());\n    VirtualFile file = FileTemplateManagerImpl.getInstance().getDefaultTemplate(myName, myExtension);\n    if (file == null) return;\n    try {\n      String text = readExternal(file);\n      setText(text);\n      myReadOnly = true;\n    } catch (IOException e) {\n      LOG.error (\"Error reading template\");\n    }\n  }","id":65668,"modified_method":"public void resetToDefault() {\n    LOG.assertTrue(!isDefault());\n    String name;\n    String extension;\n    synchronized (this) {\n      name = myName;\n      extension = myExtension;\n    }\n    VirtualFile file = FileTemplateManagerImpl.getInstance().getDefaultTemplate(name, extension);\n    if (file == null) return;\n    try {\n      String text = readExternal(file);\n      setText(text);\n      synchronized (this) {\n        myReadOnly = true;\n      }\n    }\n    catch (IOException e) {\n      LOG.error (\"Error reading template\");\n    }\n  }","commit_id":"c597936f8e94541e34c702bf08cd5766dc94fac7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public String getDescription(){\n    try {\n      return myDescription != null ? VfsUtil.loadText(VirtualFileManager.getInstance().findFileByUrl(myDescription)) : \"\";\n    }\n    catch (IOException e) {\n      return \"\";\n    }\n  }","id":65669,"modified_method":"@NotNull\n  public String getDescription(){\n    try {\n      String description;\n      synchronized (this) {\n        description = myDescription;\n      }\n      if (description == null) return \"\";\n      VirtualFile virtualFile = VirtualFileManager.getInstance().findFileByUrl(description);\n      LOG.assertTrue(virtualFile != null, \"Unable to find description at '\" + description + \"'\");\n      return VfsUtil.loadText(virtualFile);\n    }\n    catch (IOException e) {\n      return \"\";\n    }\n  }","commit_id":"c597936f8e94541e34c702bf08cd5766dc94fac7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private String getContent() throws IOException{\n    if(myContent == null){\n      if(myTemplateFile != null){\n        myContent = StringUtil.convertLineSeparators(readExternal(myTemplateFile));\n      }\n      else if(myTemplateURL != null){\n        VirtualFile templateFile = VirtualFileManager.getInstance().findFileByUrl(myTemplateURL);\n        if (templateFile != null) {\n          myContent = StringUtil.convertLineSeparators(readExternal(templateFile));\n        }\n        else {\n          myContent = \"\";\n        }\n      }\n      else{\n        myContent = \"\";\n      }\n    }\n    return myContent;\n  }","id":65670,"modified_method":"@NotNull\n  private String getContent() throws IOException{\n    String content;\n    File templateIOFile;\n    String templateURL;\n    synchronized (this) {\n      content = myContent;\n      templateIOFile = myTemplateFile;\n      templateURL = myTemplateURL;\n    }\n    if(content == null) {\n      if(templateIOFile != null){\n        content = StringUtil.convertLineSeparators(readExternal(templateIOFile));\n      }\n      else {\n        if(templateURL != null){\n          VirtualFile templateFile = VirtualFileManager.getInstance().findFileByUrl(templateURL);\n          content = templateFile == null ? \"\" : StringUtil.convertLineSeparators(readExternal(templateFile));\n        }\n        else{\n          content = \"\";\n        }\n      }\n      synchronized (this) {\n        myContent = content;\n      }\n    }\n\n    return content;\n  }","commit_id":"c597936f8e94541e34c702bf08cd5766dc94fac7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public String getUrl() {\n    return myFile.getUrl();\n  }","id":65671,"modified_method":"@NotNull\n  public String getUrl() {\n    return myUrl;\n  }","commit_id":"e058374198bcfe0d65e895a7f5ee769d122f4307","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public String getFileName() {\n    return myFile.getName();\n  }","id":65672,"modified_method":"@NotNull\n  public String getFileName() {\n    return getUrl();\n  }","commit_id":"e058374198bcfe0d65e895a7f5ee769d122f4307","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"IdentityVirtualFilePointer(@NotNull VirtualFile file) {\n    myFile = file;\n  }","id":65673,"modified_method":"IdentityVirtualFilePointer(VirtualFile file, @NotNull String url) {\n    myFile = file;\n    myUrl = url;\n  }","commit_id":"e058374198bcfe0d65e895a7f5ee769d122f4307","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isValid() {\n    return myFile.isValid();\n  }","id":65674,"modified_method":"public boolean isValid() {\n    return myFile == null || myFile.isValid();\n  }","commit_id":"e058374198bcfe0d65e895a7f5ee769d122f4307","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private VirtualFilePointer create(VirtualFile file, @NotNull String url, @NotNull final Disposable parentDisposable, VirtualFilePointerListener listener) {\n    if (file != null && file.getFileSystem() != LocalFileSystem.getInstance() && file.getFileSystem() != JarFileSystem.getInstance()) {\n      // we are unable to track alien file systems for now\n      return new IdentityVirtualFilePointer(file);\n    }\n\n    String protocol = VirtualFileManager.extractProtocol(url);\n    VirtualFileSystem fileSystem = myVirtualFileManager.getFileSystem(protocol);\n    if (fileSystem == null) {\n      // this pointer will never be alive\n      return new NullVirtualFilePointer(url);\n    }\n    if (fileSystem != LocalFileSystem.getInstance() && fileSystem != JarFileSystem.getInstance()) {\n      // we are unable to track alien file systems for now\n      VirtualFile found = VirtualFileManager.getInstance().findFileByUrl(url);\n      return found == null ? new NullVirtualFilePointer(url) : new IdentityVirtualFilePointer(found);\n    }\n\n    String path;\n    if (file == null) {\n      path = VirtualFileManager.extractPath(url);\n      path = cleanupPath(path, protocol);\n      url = VirtualFileManager.constructUrl(protocol, path);\n    }\n    else {\n      path = file.getPath();\n      // url has come from VirtualFile.getUrl() and is good enough\n    }\n\n    VirtualFilePointerImpl pointer = getOrCreate(file, url, parentDisposable, listener, path);\n\n    int newCount = pointer.incrementUsageCount();\n\n    if (newCount == 1) {\n      Disposer.register(parentDisposable, pointer);\n    }\n    else {\n      //already registered\n      register(parentDisposable, pointer);\n    }\n\n    return pointer;\n  }","id":65675,"modified_method":"@NotNull\n  private VirtualFilePointer create(VirtualFile file, @NotNull String url, @NotNull final Disposable parentDisposable, VirtualFilePointerListener listener) {\n    String protocol;\n    VirtualFileSystem fileSystem;\n    if (file == null) {\n      protocol = VirtualFileManager.extractProtocol(url);\n      fileSystem = myVirtualFileManager.getFileSystem(protocol);\n    }\n    else {\n      protocol = null;\n      fileSystem = file.getFileSystem();\n    }\n    if (fileSystem != LocalFileSystem.getInstance() && fileSystem != JarFileSystem.getInstance()) {\n      // we are unable to track alien file systems for now\n      VirtualFile found = fileSystem == null ? null : file != null ? file : VirtualFileManager.getInstance().findFileByUrl(url);\n      // if file is null, this pointer will never be alive\n      return getOrCreateIdentity(url, found);\n    }\n\n    String path;\n    if (file == null) {\n      path = VirtualFileManager.extractPath(url);\n      path = cleanupPath(path, protocol);\n      url = VirtualFileManager.constructUrl(protocol, path);\n    }\n    else {\n      path = file.getPath();\n      // url has come from VirtualFile.getUrl() and is good enough\n    }\n\n    VirtualFilePointerImpl pointer = getOrCreate(file, url, parentDisposable, listener, path);\n\n    int newCount = pointer.incrementUsageCount();\n\n    if (newCount == 1) {\n      Disposer.register(parentDisposable, pointer);\n    }\n    else {\n      //already registered\n      register(parentDisposable, pointer);\n    }\n\n    return pointer;\n  }","commit_id":"e058374198bcfe0d65e895a7f5ee769d122f4307","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DartCommandLineBreakpointsHandler(DartCommandLineDebugProcess process,\n                                           final Class<? extends XBreakpointType<XLineBreakpoint<XBreakpointProperties>,?>> breakpointTypeClass) {\n    myDebugProcess = process;\n\n    myBreakpointHandlers = new XBreakpointHandler<?>[]{\n      new XBreakpointHandler<XLineBreakpoint<XBreakpointProperties>>(breakpointTypeClass) {\n        public void registerBreakpoint(@NotNull final XLineBreakpoint<XBreakpointProperties> breakpoint) {\n          final XSourcePosition position = breakpoint.getSourcePosition();\n          if (position != null) {\n            myDebugProcess.sendCommand(getSetBreakpointCommand(breakpoint), new AbstractResponseToRequestHandler<JsonResponse>() {\n              @Override\n              public boolean processResponse(JsonResponse response) {\n                if (response.getJsonObject().get(\"error\") != null) {\n                  myDebugProcess.getSession().updateBreakpointPresentation(breakpoint, AllIcons.Debugger.Db_invalid_breakpoint, null);\n                  return true;\n                }\n                final JsonObject result = response.getJsonObject().get(\"result\").getAsJsonObject();\n                final int id = result.get(\"breakpointId\").getAsInt();\n                myBreakpointToIndexMap.put(breakpoint, id);\n                myIndexToBreakpointMap.put(id, breakpoint);\n                return true;\n              }\n            });\n          }\n        }\n\n        private boolean isValidSourceBreakpoint(XSourcePosition position) {\n          ProjectFileIndex projectFileIndex = ProjectRootManager.getInstance(myDebugProcess.getSession().getProject()).getFileIndex();\n          VirtualFile rootForFile = projectFileIndex.getSourceRootForFile(position.getFile());\n          return rootForFile != null;\n        }\n\n        public void unregisterBreakpoint(@NotNull final XLineBreakpoint<XBreakpointProperties> breakpoint, final boolean temporary) {\n          final XSourcePosition position = breakpoint.getSourcePosition();\n          if (position != null && isValidSourceBreakpoint(position)) {\n            myDebugProcess.sendCommand(getRemoveBreakpointCommand(breakpoint), new AbstractResponseToRequestHandler<JsonResponse>() {\n              @Override\n              public boolean processResponse(JsonResponse response) {\n                final Integer id = myBreakpointToIndexMap.remove(breakpoint);\n                if (myIndexToBreakpointMap.containsKey(id)) {\n                  myIndexToBreakpointMap.remove(id);\n                }\n                return true;\n              }\n            });\n          }\n        }\n      }\n    };\n  }","id":65676,"modified_method":"public DartCommandLineBreakpointsHandler(DartCommandLineDebugProcess process) {\n    myDebugProcess = process;\n\n    List<XBreakpointHandler> handlers = new ArrayList<XBreakpointHandler>(2);\n    for (DartCommandLineBreakpointTypeProvider breakpointTypeProvider : DartCommandLineBreakpointTypeProvider.EP_NAME.getExtensions()) {\n      handlers.add(new XBreakpointHandler<XLineBreakpoint<XBreakpointProperties>>(breakpointTypeProvider.provideBreakpointClass()) {\n        public void registerBreakpoint(@NotNull final XLineBreakpoint<XBreakpointProperties> breakpoint) {\n          final XSourcePosition position = breakpoint.getSourcePosition();\n          if (position != null) {\n            myDebugProcess.sendCommand(getSetBreakpointCommand(breakpoint), new AbstractResponseToRequestHandler<JsonResponse>() {\n              @Override\n              public boolean processResponse(JsonResponse response) {\n                if (response.getJsonObject().get(\"error\") != null) {\n                  myDebugProcess.getSession().updateBreakpointPresentation(breakpoint, AllIcons.Debugger.Db_invalid_breakpoint, null);\n                  return true;\n                }\n                final JsonObject result = response.getJsonObject().get(\"result\").getAsJsonObject();\n                final int id = result.get(\"breakpointId\").getAsInt();\n                myBreakpointToIndexMap.put(breakpoint, id);\n                myIndexToBreakpointMap.put(id, breakpoint);\n                return true;\n              }\n            });\n          }\n        }\n\n        private boolean isValidSourceBreakpoint(XSourcePosition position) {\n          ProjectFileIndex projectFileIndex = ProjectRootManager.getInstance(myDebugProcess.getSession().getProject()).getFileIndex();\n          VirtualFile rootForFile = projectFileIndex.getSourceRootForFile(position.getFile());\n          return rootForFile != null;\n        }\n\n        public void unregisterBreakpoint(@NotNull final XLineBreakpoint<XBreakpointProperties> breakpoint, final boolean temporary) {\n          final XSourcePosition position = breakpoint.getSourcePosition();\n          if (position != null && isValidSourceBreakpoint(position)) {\n            myDebugProcess.sendCommand(getRemoveBreakpointCommand(breakpoint), new AbstractResponseToRequestHandler<JsonResponse>() {\n              @Override\n              public boolean processResponse(JsonResponse response) {\n                final Integer id = myBreakpointToIndexMap.remove(breakpoint);\n                if (myIndexToBreakpointMap.containsKey(id)) {\n                  myIndexToBreakpointMap.remove(id);\n                }\n                return true;\n              }\n            });\n          }\n        }\n      });\n    }\n\n    myBreakpointHandlers = handlers.toArray(new XBreakpointHandler<?>[handlers.size()]);\n  }","commit_id":"a9706c03fe7cbf06ca19e2adb299105ba3a524ca","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  protected void applyEditorTo(DartCommandLineRunConfiguration configuration) throws ConfigurationException {\n    configuration.setFilePath(StringUtil.nullize(FileUtil.toSystemIndependentName(myFileField.getText()), true));\n    configuration.setArguments(StringUtil.nullize(myArguments.getText(), true));\n    configuration.setVMOptions(StringUtil.nullize(myVMOptions.getText(), true));\n    configuration.setModule(getSelectedModule());\n  }","id":65677,"modified_method":"@Override\n  protected void applyEditorTo(DartCommandLineRunConfiguration configuration) throws ConfigurationException {\n    configuration.setFilePath(StringUtil.nullize(FileUtil.toSystemIndependentName(myFileField.getText()), true));\n    configuration.setArguments(StringUtil.nullize(myArguments.getText(), true));\n    configuration.setVMOptions(StringUtil.nullize(myVMOptions.getText(), true));\n  }","commit_id":"a9706c03fe7cbf06ca19e2adb299105ba3a524ca","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  protected void resetEditorFrom(DartCommandLineRunConfiguration configuration) {\n    myFileField.setText(FileUtil.toSystemDependentName(StringUtil.notNullize(configuration.getFilePath())));\n    myArguments.setText(StringUtil.notNullize(configuration.getArguments()));\n    myVMOptions.setText(StringUtil.notNullize(configuration.getVMOptions()));\n\n    myComboModules.removeAllItems();\n\n    final Module[] modules = ModuleManager.getInstance(configuration.getProject()).getModules();\n    for (final Module module : modules) {\n      if (ModuleType.get(module) instanceof DartModuleTypeBase) {\n        myComboModules.addItem(module);\n      }\n    }\n    myComboModules.setSelectedItem(configuration.getConfigurationModule().getModule());\n\n    myComboModules.setRenderer(new ListCellRendererWrapper() {\n      @Override\n      public void customize(JList list, Object value, int index, boolean selected, boolean hasFocus) {\n        if (value instanceof Module) {\n          final Module module = (Module)value;\n          setText(module.getName());\n        }\n      }\n    });\n  }","id":65678,"modified_method":"@Override\n  protected void resetEditorFrom(DartCommandLineRunConfiguration configuration) {\n    myFileField.setText(FileUtil.toSystemDependentName(StringUtil.notNullize(configuration.getFilePath())));\n    myArguments.setText(StringUtil.notNullize(configuration.getArguments()));\n    myVMOptions.setText(StringUtil.notNullize(configuration.getVMOptions()));\n  }","commit_id":"a9706c03fe7cbf06ca19e2adb299105ba3a524ca","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public DartCommandLineDebugProcess(@NotNull XDebugSession session,\n                                     int debuggingPort,\n                                     ExecutionResult executionResult,\n                                     Class<? extends XBreakpointType<XLineBreakpoint<XBreakpointProperties>, ?>> breakpointTypeClass)\n    throws IOException {\n    super(session);\n\n    myBreakpointsHandler = new DartCommandLineBreakpointsHandler(this, breakpointTypeClass);\n    myExecutionResult = executionResult;\n    startCommandProcessingThread(debuggingPort);\n  }","id":65679,"modified_method":"public DartCommandLineDebugProcess(@NotNull XDebugSession session,\n                                     int debuggingPort,\n                                     ExecutionResult executionResult)\n    throws IOException {\n    super(session);\n\n    myBreakpointsHandler = new DartCommandLineBreakpointsHandler(this);\n    myExecutionResult = executionResult;\n    startCommandProcessingThread(debuggingPort);\n  }","commit_id":"a9706c03fe7cbf06ca19e2adb299105ba3a524ca","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void handlePaused(JsonElement paramsElement) {\n    final JsonArray callFrames = paramsElement.getAsJsonObject().getAsJsonArray(\"callFrames\");\n    List<DartStackFrame> frames = DartStackFrame.fromJson(this, callFrames);\n    getSession().positionReached(new DartSuspendContext(this, frames));\n  }","id":65680,"modified_method":"private void handlePaused(JsonElement paramsElement) {\n    final JsonArray callFrames = paramsElement.getAsJsonObject().getAsJsonArray(\"callFrames\");\n    if (callFrames != null) {\n      final List<DartStackFrame> frames = DartStackFrame.fromJson(this, callFrames);\n      DartStackFrame.requestLines(this, frames, new Runnable() {\n        @Override\n        public void run() {\n          getSession().positionReached(new DartSuspendContext(DartCommandLineDebugProcess.this, frames));\n        }\n      });\n    }\n    else {\n      sendSimpleCommand(\"getStackTrace\", new AbstractResponseToRequestHandler<JsonResponse>() {\n        @Override\n        public boolean processResponse(JsonResponse response) {\n          JsonObject result = response.getJsonObject().getAsJsonObject().getAsJsonObject(\"result\");\n          final JsonArray callFrames = result == null ? null : result.getAsJsonArray(\"callFrames\");\n          final List<DartStackFrame> frames = callFrames == null ?\n                                              new ArrayList<DartStackFrame>() :\n                                              DartStackFrame.fromJson(DartCommandLineDebugProcess.this, callFrames);\n          DartStackFrame.requestLines(DartCommandLineDebugProcess.this, frames, new Runnable() {\n            @Override\n            public void run() {\n              getSession().positionReached(new DartSuspendContext(DartCommandLineDebugProcess.this, frames));\n            }\n          });\n          return true;\n        }\n      });\n    }\n  }","commit_id":"a9706c03fe7cbf06ca19e2adb299105ba3a524ca","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static JsonObject getCommandObject(String commandName) {\n    JsonObject command = new JsonObject();\n    command.addProperty(\"command\", commandName);\n    return command;\n  }","id":65681,"modified_method":"public static JsonObject getCommandObject(String commandName) {\n    JsonObject command = new JsonObject();\n    command.addProperty(\"command\", commandName);\n    return command;\n  }","commit_id":"a9706c03fe7cbf06ca19e2adb299105ba3a524ca","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void handleBreakpointResolved(JsonElement paramsElement) {\n    final int breakpointId = getBreakpointId(paramsElement);\n    XLineBreakpoint<XBreakpointProperties> breakpoint = myBreakpointsHandler.getBreakpointById(breakpointId);\n    if (breakpoint != null) {\n      getSession().breakpointReached(breakpoint, null, new DartSuspendContext(this));\n    }\n    else {\n      resume();\n    }\n  }","id":65682,"modified_method":"private void handleBreakpointResolved(JsonElement paramsElement) {\n    final int breakpointId = getBreakpointId(paramsElement);\n    XLineBreakpoint<XBreakpointProperties> breakpoint = myBreakpointsHandler.getBreakpointById(breakpointId);\n    if (breakpoint == null) {\n      resume();\n    }\n  }","commit_id":"a9706c03fe7cbf06ca19e2adb299105ba3a524ca","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  protected RunContentDescriptor doExecute(Project project,\n                                           Executor executor,\n                                           RunProfileState state,\n                                           RunContentDescriptor contentToReuse,\n                                           ExecutionEnvironment env) throws ExecutionException {\n    final DartCommandLineRunConfiguration configuration = (DartCommandLineRunConfiguration)env.getRunProfile();\n    FileDocumentManager.getInstance().saveAllDocuments();\n    final Module module = configuration.getConfigurationModule().getModule();\n\n    final String filePath = configuration.getFilePath();\n    assert filePath != null;\n\n    final int debuggingPort = DartSdkUtil.findFreePortForDebugging();\n\n    final DartCommandLineRunningState dartCommandLineRunningState = new DartCommandLineRunningState(\n      env,\n      module,\n      filePath,\n      (\"--debug:\" + debuggingPort) + \" \" + StringUtil.notNullize(configuration.getVMOptions()),\n      StringUtil.notNullize(configuration.getArguments())\n    );\n\n    final ExecutionResult executionResult = dartCommandLineRunningState.execute(executor, this);\n\n    final XDebugSession debugSession =\n      XDebuggerManager.getInstance(project).startSession(this, env, contentToReuse, new XDebugProcessStarter() {\n        @NotNull\n        public XDebugProcess start(@NotNull final XDebugSession session) throws ExecutionException {\n          try {\n            return new DartCommandLineDebugProcess(session, debuggingPort, executionResult, DartBreakpointType.class);\n          }\n          catch (IOException e) {\n            throw new ExecutionException(e.getMessage(), e);\n          }\n        }\n      });\n\n    return debugSession.getRunContentDescriptor();\n  }","id":65683,"modified_method":"@Override\n  protected RunContentDescriptor doExecute(Project project,\n                                           Executor executor,\n                                           RunProfileState state,\n                                           RunContentDescriptor contentToReuse,\n                                           ExecutionEnvironment env) throws ExecutionException {\n    final DartCommandLineRunConfiguration configuration = (DartCommandLineRunConfiguration)env.getRunProfile();\n    FileDocumentManager.getInstance().saveAllDocuments();\n    final Module module = configuration.getModule();\n\n    final String filePath = configuration.getFilePath();\n    assert filePath != null;\n\n    final int debuggingPort = DartSdkUtil.findFreePortForDebugging();\n\n    final DartCommandLineRunningState dartCommandLineRunningState = new DartCommandLineRunningState(\n      env,\n      module,\n      filePath,\n      (\"--debug:\" + debuggingPort) + \" \" + StringUtil.notNullize(configuration.getVMOptions()),\n      StringUtil.notNullize(configuration.getArguments())\n    );\n\n    final ExecutionResult executionResult = dartCommandLineRunningState.execute(executor, this);\n\n    final XDebugSession debugSession =\n      XDebuggerManager.getInstance(project).startSession(this, env, contentToReuse, new XDebugProcessStarter() {\n        @NotNull\n        public XDebugProcess start(@NotNull final XDebugSession session) throws ExecutionException {\n          try {\n            return new DartCommandLineDebugProcess(session, debuggingPort, executionResult);\n          }\n          catch (IOException e) {\n            throw new ExecutionException(e.getMessage(), e);\n          }\n        }\n      });\n\n    return debugSession.getRunContentDescriptor();\n  }","commit_id":"a9706c03fe7cbf06ca19e2adb299105ba3a524ca","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void readExternal(final Element element) throws InvalidDataException {\n    super.readExternal(element);\n    readModule(element);\n    XmlSerializer.deserializeInto(this, element);\n  }","id":65684,"modified_method":"public void readExternal(final Element element) throws InvalidDataException {\n    super.readExternal(element);\n    XmlSerializer.deserializeInto(this, element);\n  }","commit_id":"a9706c03fe7cbf06ca19e2adb299105ba3a524ca","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public Collection<Module> getValidModules() {\n    Module[] modules = ModuleManager.getInstance(getProject()).getModules();\n    return ContainerUtil.filter(modules, new Condition<Module>() {\n      @Override\n      public boolean value(Module module) {\n        ModuleType moduleType = ModuleType.get(module);\n        return moduleType instanceof DartModuleTypeBase || moduleType instanceof WebModuleTypeBase;\n      }\n    });\n  }","id":65685,"modified_method":"@Nullable\n  public Module getModule() {\n    try {\n      return findModule();\n    }\n    catch (RuntimeConfigurationException e) {\n      return null;\n    }\n  }","commit_id":"a9706c03fe7cbf06ca19e2adb299105ba3a524ca","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public void checkConfiguration() throws RuntimeConfigurationException {\n    super.checkConfiguration();\n    final RunConfigurationModule configurationModule = getConfigurationModule();\n    final Module module = configurationModule.getModule();\n    if (module == null) {\n      throw new RuntimeConfigurationException(DartBundle.message(\"dart.run.no.module\", getName()));\n    }\n  }","id":65686,"modified_method":"@Override\n  public void checkConfiguration() throws RuntimeConfigurationException {\n    super.checkConfiguration();\n    final Module module = findModule();\n    if (module == null) {\n      throw new RuntimeConfigurationException(DartBundle.message(\"dart.run.no.module\", getName()));\n    }\n  }","commit_id":"a9706c03fe7cbf06ca19e2adb299105ba3a524ca","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void writeExternal(final Element element) throws WriteExternalException {\n    super.writeExternal(element);\n    writeModule(element);\n    XmlSerializer.serializeInto(this, element);\n  }","id":65687,"modified_method":"public void writeExternal(final Element element) throws WriteExternalException {\n    super.writeExternal(element);\n    XmlSerializer.serializeInto(this, element);\n  }","commit_id":"a9706c03fe7cbf06ca19e2adb299105ba3a524ca","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public DartCommandLineRunConfiguration(String name, Project project, DartCommandLineRunConfigurationType configurationType) {\n    super(name, new RunConfigurationModule(project), configurationType.getConfigurationFactories()[0]);\n    myConfigurationType = configurationType;\n  }","id":65688,"modified_method":"public DartCommandLineRunConfiguration(String name, Project project, DartCommandLineRunConfigurationType configurationType) {\n    super(name, project, configurationType.getConfigurationFactories()[0]);\n  }","commit_id":"a9706c03fe7cbf06ca19e2adb299105ba3a524ca","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  protected RunContentDescriptor doExecute(Project project,\n                                           Executor executor,\n                                           RunProfileState state,\n                                           RunContentDescriptor contentToReuse,\n                                           ExecutionEnvironment env) throws ExecutionException {\n    final DartCommandLineRunConfiguration configuration = (DartCommandLineRunConfiguration)env.getRunProfile();\n    final Module module = configuration.getConfigurationModule().getModule();\n\n    final String filePath = configuration.getFilePath();\n    assert filePath != null;\n\n    final DartCommandLineRunningState dartCommandLineRunningState = new DartCommandLineRunningState(\n      env,\n      module,\n      filePath,\n      StringUtil.notNullize(configuration.getVMOptions()),\n      StringUtil.notNullize(configuration.getArguments())\n    );\n\n    return super.doExecute(project, executor, dartCommandLineRunningState, contentToReuse, env);\n  }","id":65689,"modified_method":"@Override\n  protected RunContentDescriptor doExecute(Project project,\n                                           Executor executor,\n                                           RunProfileState state,\n                                           RunContentDescriptor contentToReuse,\n                                           ExecutionEnvironment env) throws ExecutionException {\n    final DartCommandLineRunConfiguration configuration = (DartCommandLineRunConfiguration)env.getRunProfile();\n    final Module module = configuration.getModule();\n\n    final String filePath = configuration.getFilePath();\n    assert filePath != null;\n\n    final DartCommandLineRunningState dartCommandLineRunningState = new DartCommandLineRunningState(\n      env,\n      module,\n      filePath,\n      StringUtil.notNullize(configuration.getVMOptions()),\n      StringUtil.notNullize(configuration.getArguments())\n    );\n\n    return super.doExecute(project, executor, dartCommandLineRunningState, contentToReuse, env);\n  }","commit_id":"a9706c03fe7cbf06ca19e2adb299105ba3a524ca","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static boolean setupRunConfiguration(DartCommandLineRunConfiguration configuration, PsiFile psiFile) {\n    VirtualFile virtualFile = DartResolveUtil.getRealVirtualFile(psiFile);\n    if (virtualFile == null) {\n      return false;\n    }\n    configuration.setFilePath(FileUtil.toSystemIndependentName(virtualFile.getPath()));\n    configuration.setModule(ModuleUtilCore.findModuleForFile(virtualFile, psiFile.getProject()));\n    return true;\n  }","id":65690,"modified_method":"private static boolean setupRunConfiguration(DartCommandLineRunConfiguration configuration, PsiFile psiFile) {\n    VirtualFile virtualFile = DartResolveUtil.getRealVirtualFile(psiFile);\n    if (virtualFile == null) {\n      return false;\n    }\n    configuration.setFilePath(FileUtil.toSystemIndependentName(virtualFile.getPath()));\n    return true;\n  }","commit_id":"a9706c03fe7cbf06ca19e2adb299105ba3a524ca","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static boolean run(CompileContext context, DartCommandLineRunConfiguration configuration) {\n    final Module module = configuration.getConfigurationModule().getModule();\n    if (module == null) {\n      context.addMessage(CompilerMessageCategory.ERROR,\n                         DartBundle.message(\"no.module.for.run.configuration\", configuration.getName()), null, -1, -1);\n      return false;\n    }\n    if (ModuleType.get(module) != DartModuleType.getInstance()) {\n      // skip\n      return true;\n    }\n    return compileModule(context, module, configuration);\n  }","id":65691,"modified_method":"private static boolean run(CompileContext context, DartCommandLineRunConfiguration configuration) {\n    final Module module = configuration.getModule();\n    if (module == null) {\n      context.addMessage(CompilerMessageCategory.ERROR,\n                         DartBundle.message(\"no.module.for.run.configuration\", configuration.getName()), null, -1, -1);\n      return false;\n    }\n    if (ModuleType.get(module) != DartModuleType.getInstance()) {\n      // skip\n      return true;\n    }\n    return compileModule(context, module, configuration);\n  }","commit_id":"a9706c03fe7cbf06ca19e2adb299105ba3a524ca","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public void computeStackFrames(final int firstFrameIndex, final XStackFrameContainer container) {\n    if (!myStackFrames.isEmpty()) {\n      addStackFrames(container, firstFrameIndex);\n      return;\n    }\n    myDebugProcess.sendSimpleCommand(\"getStackTrace\", new AbstractResponseToRequestHandler<JsonResponse>() {\n      @Override\n      public boolean processResponse(JsonResponse response) {\n        if (response.getJsonObject().get(\"error\") == null) {\n          final JsonObject result = response.getJsonObject().getAsJsonObject(\"result\");\n          myStackFrames.clear();\n          myStackFrames.addAll(DartStackFrame.fromJson(myDebugProcess, result.getAsJsonArray(\"callFrames\")));\n        }\n        addStackFrames(container, firstFrameIndex);\n        return true;\n      }\n    });\n  }","id":65692,"modified_method":"@Override\n  public void computeStackFrames(final int firstFrameIndex, final XStackFrameContainer container) {\n    if (!myStackFrames.isEmpty()) {\n      addStackFrames(container, firstFrameIndex - 1);\n      return;\n    }\n    myDebugProcess.sendSimpleCommand(\"getStackTrace\", new AbstractResponseToRequestHandler<JsonResponse>() {\n      @Override\n      public boolean processResponse(JsonResponse response) {\n        if (response.getJsonObject().get(\"error\") == null) {\n          final JsonObject result = response.getJsonObject().getAsJsonObject(\"result\");\n          myStackFrames.clear();\n          myStackFrames.addAll(DartStackFrame.fromJson(myDebugProcess, result.getAsJsonArray(\"callFrames\")));\n          DartStackFrame.requestLines(myDebugProcess, myStackFrames, null);\n        }\n        addStackFrames(container, firstFrameIndex - 1);\n        return true;\n      }\n    });\n  }","commit_id":"a9706c03fe7cbf06ca19e2adb299105ba3a524ca","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public static DartStackFrame fromJson(DartCommandLineDebugProcess debugProcess, JsonObject object) {\n    final String functionName = object.get(\"functionName\").getAsString();\n    JsonObject location = object.get(\"location\").getAsJsonObject();\n    final String url = location.get(\"url\").getAsString();\n    final int line = location.get(\"lineNumber\").getAsInt() - 1;\n    final int libraryId = object.get(\"libraryId\").getAsInt();\n    return new DartStackFrame(debugProcess, functionName, url, line, libraryId,\n                              DartVMValue.fromJson(debugProcess, object.getAsJsonArray(\"locals\")));\n  }","id":65693,"modified_method":"public static DartStackFrame fromJson(DartCommandLineDebugProcess debugProcess, JsonObject object) {\n    final String functionName = object.get(\"functionName\").getAsString();\n    JsonObject location = object.get(\"location\").getAsJsonObject();\n    final String url = location.get(\"url\").getAsString();\n    JsonElement tokenOffset = location.get(\"tokenOffset\");\n    final int offset = (tokenOffset == null ? -1 : tokenOffset.getAsInt());\n    final int libraryId = location.get(\"libraryId\").getAsInt();\n    return new DartStackFrame(debugProcess, functionName, url, offset, libraryId,\n                              DartVMValue.fromJson(debugProcess, object.getAsJsonArray(\"locals\")));\n  }","commit_id":"a9706c03fe7cbf06ca19e2adb299105ba3a524ca","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"protected DartStackFrame(DartCommandLineDebugProcess debugProcess,\n                           String functionName,\n                           String url,\n                           int line,\n                           int libraryId,\n                           List<DartVMValue> locals) {\n    myDebugProcess = debugProcess;\n    myFunctionName = functionName;\n    myFileUrl = url;\n    myLine = line;\n    myLibraryId = libraryId;\n    myLocals = locals;\n  }","id":65694,"modified_method":"protected DartStackFrame(DartCommandLineDebugProcess debugProcess,\n                           String functionName,\n                           String url,\n                           int offset,\n                           int libraryId,\n                           List<DartVMValue> locals) {\n    myDebugProcess = debugProcess;\n    myFunctionName = functionName;\n    myFileUrl = url;\n    myOffset = offset;\n    myLibraryId = libraryId;\n    myLocals = locals;\n  }","commit_id":"a9706c03fe7cbf06ca19e2adb299105ba3a524ca","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public XSourcePosition getSourcePosition() {\n    return XSourcePositionImpl.create(VirtualFileManager.getInstance().findFileByUrl(myFileUrl), myLine);\n  }","id":65695,"modified_method":"@Override\n  public XSourcePosition getSourcePosition() {\n    VirtualFile virtualFile = VirtualFileManager.getInstance().findFileByUrl(myFileUrl);\n    return virtualFile != null && myLine >= 0 ? XSourcePositionImpl.create(virtualFile, myLine) : null;\n  }","commit_id":"a9706c03fe7cbf06ca19e2adb299105ba3a524ca","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  protected RunContentDescriptor doExecute(Project project,\n                                           Executor executor,\n                                           RunProfileState state,\n                                           RunContentDescriptor contentToReuse,\n                                           ExecutionEnvironment env) throws ExecutionException {\n    final DartUnitRunConfiguration configuration = (DartUnitRunConfiguration)env.getRunProfile();\n\n    final DartUnitRunnerParameters parameters = configuration.getRunnerParameters();\n    final String filePath = parameters.getFilePath();\n    assert filePath != null;\n\n    final VirtualFile virtualFile = VirtualFileManager.getInstance().findFileByUrl(VfsUtilCore.pathToUrl(filePath));\n    if (virtualFile == null) {\n      throw new ExecutionException(\"Can't find file: \" + filePath);\n    }\n\n    final Module module = ModuleUtilCore.findModuleForFile(virtualFile, project);\n    final DartSettings dartSettings = DartSettings.getSettingsForModule(module);\n\n    final int debuggingPort = DartSdkUtil.findFreePortForDebugging();\n\n    final DartUnitRunningState dartUnitRunningState = new DartUnitRunningState(env, parameters, dartSettings, debuggingPort);\n    final ExecutionResult executionResult = dartUnitRunningState.execute(executor, this);\n\n    // debug unit tests for web module\n    final Class<? extends XBreakpointType<XLineBreakpoint<XBreakpointProperties>, ?>> breakPointType =\n      DartSettings.shouldTakeWebSettings(module) ? JavaScriptBreakpointType.class : DartBreakpointType.class;\n\n    final XDebugSession debugSession =\n      XDebuggerManager.getInstance(project).startSession(this, env, contentToReuse, new XDebugProcessStarter() {\n        @NotNull\n        public XDebugProcess start(@NotNull final XDebugSession session) throws ExecutionException {\n          try {\n            return new DartCommandLineDebugProcess(session, debuggingPort, executionResult, breakPointType);\n          }\n          catch (IOException e) {\n            throw new ExecutionException(e.getMessage(), e);\n          }\n        }\n      });\n\n    return debugSession.getRunContentDescriptor();\n  }","id":65696,"modified_method":"@Override\n  protected RunContentDescriptor doExecute(Project project,\n                                           Executor executor,\n                                           RunProfileState state,\n                                           RunContentDescriptor contentToReuse,\n                                           ExecutionEnvironment env) throws ExecutionException {\n    final DartUnitRunConfiguration configuration = (DartUnitRunConfiguration)env.getRunProfile();\n\n    final DartUnitRunnerParameters parameters = configuration.getRunnerParameters();\n    final String filePath = parameters.getFilePath();\n    assert filePath != null;\n\n    final VirtualFile virtualFile = VirtualFileManager.getInstance().findFileByUrl(VfsUtilCore.pathToUrl(filePath));\n    if (virtualFile == null) {\n      throw new ExecutionException(\"Can't find file: \" + filePath);\n    }\n\n    final Module module = ModuleUtilCore.findModuleForFile(virtualFile, project);\n    final DartSettings dartSettings = DartSettings.getSettingsForModule(module);\n\n    final int debuggingPort = DartSdkUtil.findFreePortForDebugging();\n\n    final DartUnitRunningState dartUnitRunningState = new DartUnitRunningState(env, parameters, dartSettings, debuggingPort);\n    final ExecutionResult executionResult = dartUnitRunningState.execute(executor, this);\n\n    // debug unit tests for web module\n    final Class<? extends XBreakpointType<XLineBreakpoint<XBreakpointProperties>, ?>> breakPointType =\n      DartSettings.shouldTakeWebSettings(module) ? JavaScriptBreakpointType.class : DartBreakpointType.class;\n\n    final XDebugSession debugSession =\n      XDebuggerManager.getInstance(project).startSession(this, env, contentToReuse, new XDebugProcessStarter() {\n        @NotNull\n        public XDebugProcess start(@NotNull final XDebugSession session) throws ExecutionException {\n          try {\n            return new DartCommandLineDebugProcess(session, debuggingPort, executionResult);\n          }\n          catch (IOException e) {\n            throw new ExecutionException(e.getMessage(), e);\n          }\n        }\n      });\n\n    return debugSession.getRunContentDescriptor();\n  }","commit_id":"a9706c03fe7cbf06ca19e2adb299105ba3a524ca","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static String pathToDartUrl(String path) {\n    return VfsUtilCore.pathToUrl(path).replace(\"file://\", \"file:///\");\n  }","id":65697,"modified_method":"private static String pathToDartUrl(@NonNls @NotNull String path) {\n    return VfsUtilCore.pathToUrl(path);\n  }","commit_id":"a9706c03fe7cbf06ca19e2adb299105ba3a524ca","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void setupUserProperties(GeneralCommandLine commandLine) throws ExecutionException {\n    commandLine.getEnvironment().put(\"com.google.dart.sdk\", myDartSettings.getSdkPath());\n\n    commandLine.addParameter(\"--ignore-unrecognized-flags\");\n\n    StringTokenizer argumentsTokenizer = new StringTokenizer(StringUtil.notNullize(myUnitParameters.getVMOptions()));\n    while (argumentsTokenizer.hasMoreTokens()) {\n      commandLine.addParameter(argumentsTokenizer.nextToken());\n    }\n\n    String libUrl = VfsUtilCore.pathToUrl(myUnitParameters.getFilePath());\n    final VirtualFile libraryRoot = VirtualFileManager.getInstance().findFileByUrl(libUrl);\n    final VirtualFile packages = DartResolveUtil.findPackagesFolder(libraryRoot, getEnvironment().getProject());\n    if (packages != null && packages.isDirectory()) {\n      commandLine.addParameter(\"--package-root=\" + packages.getPath() + \"/\");\n    }\n\n    if (myDebuggingPort > 0) {\n      commandLine.addParameter(\"--debug:\" + myDebuggingPort);\n    }\n\n    try {\n      commandLine.addParameter(createPatchedFile());\n    }\n    catch (IOException e) {\n      LOG.debug(e);\n      throw new ExecutionException(\"Can't create runner!\");\n    }\n\n    argumentsTokenizer = new StringTokenizer(StringUtil.notNullize(myUnitParameters.getArguments()));\n    while (argumentsTokenizer.hasMoreTokens()) {\n      commandLine.addParameter(argumentsTokenizer.nextToken());\n    }\n  }","id":65698,"modified_method":"private void setupUserProperties(GeneralCommandLine commandLine) throws ExecutionException {\n    if (myDartSettings != null) {\n      commandLine.getEnvironment().put(\"com.google.dart.sdk\", myDartSettings.getSdkPath());\n    }\n\n    commandLine.addParameter(\"--ignore-unrecognized-flags\");\n\n    StringTokenizer argumentsTokenizer = new StringTokenizer(StringUtil.notNullize(myUnitParameters.getVMOptions()));\n    while (argumentsTokenizer.hasMoreTokens()) {\n      commandLine.addParameter(argumentsTokenizer.nextToken());\n    }\n\n    String libUrl = VfsUtilCore.pathToUrl(myUnitParameters.getFilePath());\n    final VirtualFile libraryRoot = VirtualFileManager.getInstance().findFileByUrl(libUrl);\n    final VirtualFile packages = DartResolveUtil.findPackagesFolder(libraryRoot, getEnvironment().getProject());\n    if (packages != null && packages.isDirectory()) {\n      commandLine.addParameter(\"--package-root=\" + packages.getPath() + \"/\");\n    }\n\n    if (myDebuggingPort > 0) {\n      commandLine.addParameter(\"--debug:\" + myDebuggingPort);\n    }\n\n    try {\n      commandLine.addParameter(createPatchedFile());\n    }\n    catch (IOException e) {\n      LOG.debug(e);\n      throw new ExecutionException(\"Can't create runner!\");\n    }\n\n    argumentsTokenizer = new StringTokenizer(StringUtil.notNullize(myUnitParameters.getArguments()));\n    while (argumentsTokenizer.hasMoreTokens()) {\n      commandLine.addParameter(argumentsTokenizer.nextToken());\n    }\n  }","commit_id":"a9706c03fe7cbf06ca19e2adb299105ba3a524ca","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private String getUnitPath(String path) {\n    VirtualFile libRoot = VirtualFileManager.getInstance().findFileByUrl(VfsUtilCore.pathToUrl(path));\n    VirtualFile packagesFolder = DartResolveUtil.findPackagesFolder(libRoot, getEnvironment().getProject());\n    if (packagesFolder != null && packagesFolder.findChild(\"unittest\") != null) {\n      return \"package:unittest/unittest.dart\";\n    }\n    return pathToDartUrl(StringUtil.notNullize(myDartSettings.getSdkPath()) + \"/pkg/unittest/unittest.dart\");\n  }","id":65699,"modified_method":"private String getUnitPath(String path) {\n    VirtualFile libRoot = VirtualFileManager.getInstance().findFileByUrl(VfsUtilCore.pathToUrl(path));\n    VirtualFile packagesFolder = DartResolveUtil.findPackagesFolder(libRoot, getEnvironment().getProject());\n    if (myDartSettings == null || (packagesFolder != null && packagesFolder.findChild(\"unittest\") != null)) {\n      return \"package:unittest/unittest.dart\";\n    }\n    return pathToDartUrl(StringUtil.notNullize(myDartSettings.getSdkPath()) + \"/pkg/unittest/unittest.dart\");\n  }","commit_id":"a9706c03fe7cbf06ca19e2adb299105ba3a524ca","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n     * If this param is set then the sakai session for the current request is set to this rather than establishing one,\n     * will allow changing the session as well\n     */\n\n    /* (non-Javadoc)\n     * @see org.sakaiproject.entitybroker.EntityRequestHandler#handleEntityAccess(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)\n     */\n    public String handleEntityAccess(HttpServletRequest req, HttpServletResponse res, String path) {\n        // set the servlet context if not set\n        if (this.servletContext == null) {\n            setServletContext( RequestUtils.getServletContext(req) );\n        }\n\n        // get the path info if not set\n        if (path == null) {\n            path = req.getPathInfo();\n        }\n\n        String handledReference = null;\n\n        // special handling in case the session ID is sent in the request \n        // (allows setting up and reusing a session over and over without holding cookies)\n        if (entityBrokerManager.getExternalIntegrationProvider() != null) {\n            try {\n                entityBrokerManager.getExternalIntegrationProvider().handleUserSessionKey(req);\n            } catch (Exception e) {\n                System.out.println(\"WARN: EntityRequestHandler: External handleUserSessionKey method failed, continuing...: \" + e);\n            }\n        }\n\n        if (path == null || \"\".equals(path) || \"/\".equals(path)) {\n            // SPECIAL handling for empty path\n            res.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY);\n            try {\n                res.sendRedirect( res.encodeRedirectURL(getServletContext() + SLASH_DESCRIBE) );\n            } catch (IOException e) {\n                // should never happen\n                throw new RuntimeException(\"Could not encode the redirect URL\");\n            }\n            // immediate exit from redirect\n            return \"/\";\n        } else {\n            // regular handling for direct URLs\n            if ( (SLASH_DESCRIBE).equals(path) \n                    || path.startsWith(SLASH_DESCRIBE + EntityReference.PERIOD)) {\n                // SPECIAL handling for the describe all URL\n                String format = TemplateParseUtil.findExtension(path)[2];\n                if (format == null) {\n                    format = Formats.HTML;\n                }\n                RequestUtils.setResponseEncoding(format, res);\n                String output = entityDescriptionManager.makeDescribeAll(format, req.getLocale()); // possibly get the locale from other places?\n                res.setContentLength(output.getBytes().length);\n                try {\n                    res.getWriter().write(output);\n                } catch (IOException e) {\n                    // should never happen\n                    throw new RuntimeException(\"Failed to put output into the response writer: \" + e.getMessage(), e);\n                }\n                res.setStatus(HttpServletResponse.SC_OK);\n                handledReference = EntityView.SEPARATOR+\"\";\n            } else {\n                // STANDARD processing for the incoming view\n                EntityView view;\n                try {\n                    view = entityBrokerManager.parseEntityURL(path);\n                } catch (IllegalArgumentException e) {\n                    // FAILURE indicates we could not parse the reference\n                    throw new EntityException(\"Could not parse entity path (\"+path+\"): \" + e.getMessage(), path, HttpServletResponse.SC_BAD_REQUEST);\n                }\n\n                if (view == null) {\n                    // FAILURE no provider for this entity prefix\n                    throw new EntityException( \"Could not parse the incoming path (\"+path+\") and no entity provider could be found to handle the prefix\", \n                            path, HttpServletResponse.SC_NOT_IMPLEMENTED );\n                } else if ( DESCRIBE.equals(view.getEntityReference().getId()) ) {\n                    // SPECIAL handling for entity describe URLs\n                    String format = TemplateParseUtil.findExtension(path)[2];\n                    if (format == null) {\n                        format = Formats.HTML;\n                    }\n                    RequestUtils.setResponseEncoding(format, res);\n                    String entityId = req.getParameter(\"_id\");\n                    if (entityId == null || \"\".equals(entityId)) {\n                        entityId = FAKE_ID;\n                    }\n                    String output = entityDescriptionManager.makeDescribeEntity(view.getEntityReference().getPrefix(), entityId, format, req.getLocale());\n                    res.setContentLength(output.getBytes().length);\n                    try {\n                        res.getWriter().write(output);\n                    } catch (IOException e) {\n                        throw new RuntimeException(\"Failed to put output into the response writer: \" + e.getMessage(), e);\n                    }\n                    res.setStatus(HttpServletResponse.SC_OK);\n                    handledReference = view.getEntityReference().getSpaceReference() + SLASH_DESCRIBE;\n\n                } else {\n                    // STANDARD reference successfully parsed\n                    String prefix = view.getEntityReference().getPrefix();\n\n                    // check for redirect\n                    Redirectable urlConfigurable = entityProviderManager.getProviderByPrefixAndCapability(prefix, Redirectable.class);\n                    if (urlConfigurable != null) {\n                        // SPECIAL check for redirect\n                        String redirectURL = entityRedirectsManager.checkForTemplateMatch(urlConfigurable, path, req.getQueryString());\n                        if (redirectURL != null) {\n                            // SPECIAL handling for redirect\n                            if (\"\".equals(redirectURL)) {\n                                // do nothing but return an empty response\n                                res.setStatus(HttpServletResponse.SC_OK);\n                            } else {\n                                // do the redirect\n                                System.out.println(\"INFO: EntityRequestHandler: Entity Redirect: redirecting from (\"+path+\") to (\"+redirectURL+\")\");\n                                RequestUtils.handleURLRedirect(redirectURL, true, req, res);\n                            }\n                            return EntityView.SEPARATOR + prefix; // exit here for redirects\n                        }\n                    }\n\n                    // check for custom action\n                    CustomAction customAction = entityActionsManager.getCustomAction(prefix, view.getPathSegment(1));\n                    if (customAction == null) {\n                        customAction = entityActionsManager.getCustomAction(prefix, view.getPathSegment(2));\n                    }\n                    if (customAction == null) {\n                        // check to see if the entity exists\n                        if (! entityBrokerManager.entityExists(view.getEntityReference()) ) {\n                            // FAILURE invalid entity reference (entity does not exist)\n                            throw new EntityException( \"Attempted to access an entity URL path (\" + path + \") for an entity (\"\n                                    + view.getEntityReference() + \") that does not exist\", \n                                    view.getEntityReference()+\"\", HttpServletResponse.SC_NOT_FOUND );\n                        }\n                    } else {\n                        // cleanup the entity reference, this has to be done because otherwise the custom action\n                        // on collections appears to be the id of an entity in the collection\n                        EntityReference cRef = view.getEntityReference();\n                        if (cRef.getId().equals(customAction.action)) {\n                            view.setEntityReference( new EntityReference(prefix, \"\") );\n                        }\n                    }\n                    res.setStatus(HttpServletResponse.SC_OK); // default - other things can switch this later on\n\n                    // store format in attribute\n                    req.setAttribute(\"entity-format\", view.getFormat());\n\n                    // STANDARD initial processing complete\n                    // wrap in try block so that request storage is always cleaned up\n                    try {\n                        // store the current request and response\n                        requestGetter.setRequest(req);\n                        requestGetter.setResponse(res);\n                        // set the request variables\n                        requestStorage.setRequestValue(RequestStorage.ReservedKeys._requestEntityReference.name(), view.getEntityReference().toString());\n                        requestStorage.setRequestValue(RequestStorage.ReservedKeys._requestOrigin.name(), RequestStorage.RequestOrigin.REST.name());\n                        requestStorage.setRequestValue(RequestStorage.ReservedKeys._requestActive.name(), true);\n\n                        // handle the before interceptor\n                        RequestInterceptor interceptor = (RequestInterceptor) entityProviderManager.getProviderByPrefixAndCapability(prefix, RequestInterceptor.class);\n                        if (interceptor != null) {\n                            interceptor.before(view, req, res);\n                        }\n\n                        if (BATCH.equals(prefix)) {\n                            // special batch handling\n                            if (view.getExtension() == null) {\n                                // default extension is JSON\n                                view.setExtension(Formats.JSON);\n                            }\n                            entityBatchHandler.handleBatch(view, req, res);\n                        } else {\n                            // check for provider handling of this request\n                            RequestHandler handler = (RequestHandler) entityProviderManager.getProviderByPrefixAndCapability(prefix, RequestHandler.class);\n                            if (handler != null) {\n                                // SPECIAL provider is handling this request\n                                handleClassLoaderAccess(handler, req, res, view);\n                            } else {\n                                // STANDARD processing of the entity request internally start here\n                                // try to handle the request internally if possible\n    \n                                // identify the type of request (input or output) and the action (will be encoded in the viewKey)\n                                boolean output = RequestUtils.isRequestOutput(req, view);\n                                setResponseHeaders(view, res, requestStorage.getStorageMapCopy(), null);\n    \n                                boolean handled = false;\n                                // PROCESS CUSTOM ACTIONS\n                                ActionReturn actionReturn = null;\n                                if (customAction != null) {\n                                    // SPECIAL handle the custom action\n                                    ActionsExecutable actionProvider = entityProviderManager.getProviderByPrefixAndCapability(prefix, ActionsExecutable.class);\n                                    if (actionProvider == null) {\n                                        throw new EntityException( \"The provider for prefix (\"+prefix+\") cannot handle custom actions\", \n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_BAD_REQUEST );\n                                    }\n                                    // make sure this request is a valid type for this action\n                                    if (customAction.viewKey != null \n                                            && ! view.getViewKey().equals(customAction.viewKey)) {\n                                        throw new EntityException( \"Cannot execute custom action (\"+customAction.action+\") for request method \" + req.getMethod()\n                                                + \", The custom action view key (\"+customAction.viewKey+\") must match the request view key (\"+view.getViewKey()+\")\", \n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_BAD_REQUEST );\n                                    }\n                                    try {\n                                        actionReturn = entityActionsManager.handleCustomActionRequest(actionProvider, view, customAction.action, req, res, \n                                                requestStorage.getStorageMapCopy(true, false, true, true) );\n                                    } catch (SecurityException se) {\n                                        // AJAX/WS type security exceptions are handled specially, no redirect\n                                        throw new EntityException(\"Security exception handling request for view (\"+view+\"), \"\n                                                + \"this is typically caused by the current user not having access to the \"\n                                                + \"data requested or the user not being logged in at all :: message=\" + se.getMessage(),\n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_FORBIDDEN);\n                                    } catch (EntityNotFoundException e) {\n                                        throw new EntityException( \"Cannot execute custom action (\"+customAction.action+\"): Could not find entity (\"+e.entityReference+\"): \" + e.getMessage(), \n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_NOT_FOUND );\n                                    } catch (FormatUnsupportedException e) {\n                                        throw new EntityException( \"Cannot execute custom action (\"+customAction.action+\"): Format not supported (\"+e.format+\"): \" + e.getMessage(), \n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_NOT_ACCEPTABLE );\n                                    } catch (IllegalArgumentException e) {\n                                        throw new EntityException( \"Cannot execute custom action (\"+customAction.action+\"): Illegal arguments: \" + e.getMessage(), \n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_BAD_REQUEST );\n                                    } catch (UnsupportedOperationException e) {\n                                        throw new EntityException( \"Cannot execute custom action (\"+customAction.action+\"): Could not execute action: \" + e.getMessage(), \n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_BAD_REQUEST );\n                                    }\n                                    if (actionReturn == null \n                                            || actionReturn.output != null) {\n                                        // custom action processing complete\n                                        /* actionReturn.output != null - this means that there is an \n                                         * outputstream set and that the encoding has been,\n                                         * handled, however, the response status code should be set still\n                                         */\n                                        handled = true;\n                                    } else {\n                                        // if there are headers then set them now\n                                        addResponseHeaders(res, actionReturn.getHeaders());\n                                        // if the custom action returned entity data then we will encode it for output\n                                        if (actionReturn.entitiesList == null\n                                                && actionReturn.entityData == null) {\n                                            handled = true;\n                                        } else {\n                                            // there is entity data to return\n                                            output = true;\n                                            handled = false;\n                                            // populate the entity data\n                                            if (actionReturn.entitiesList != null) {\n                                                if (actionReturn.entitiesList.size() > 1) {\n                                                    // correct the view key which should be used now\n                                                    view.setViewKey(EntityView.VIEW_LIST);\n                                                }\n                                                entityBrokerManager.populateEntityData(actionReturn.entitiesList);\n                                            } else if (actionReturn.entityData != null) {\n                                                // correct the view key which should be used now\n                                                view.setViewKey(EntityView.VIEW_SHOW);\n                                                entityBrokerManager.populateEntityData( new EntityData[] {actionReturn.entityData} );\n                                            }\n                                        }\n                                    }\n                                }\n    \n                                boolean formatInvalidFailure = false;\n                                if (!handled) {\n                                    // INTERNAL PROCESSING OF REQUEST\n                                    try {\n                                        String format = view.getFormat();\n                                        if (output) {\n                                            // output request\n                                            String viewKey = view.getViewKey();\n                                            if (EntityView.VIEW_NEW.equals(viewKey)\n                                                    || EntityView.VIEW_EDIT.equals(viewKey) \n                                                    || EntityView.VIEW_DELETE.equals(viewKey) ) {\n                                                // request for the create/edit/delete entity forms\n                                                handled = false; // if we handle this then switch this to true\n                                                if (Formats.FORM.equals(format)) {\n                                                    // generate new/edit/delete forms internally if the provider allows it\n                                                    Outputable outputable = (Outputable) entityProviderManager.getProviderByPrefixAndCapability(prefix, Outputable.class);\n                                                    if (outputable != null) {\n                                                        String[] outputFormats = outputable.getHandledOutputFormats();\n                                                        if (outputFormats != null && ReflectUtils.contains(outputFormats, Formats.FORM) ) {\n                                                            // we are handling this type of format for this entity\n                                                            RequestUtils.setResponseEncoding(format, res);\n                                                            if (EntityView.Method.HEAD.name().equals(view.getMethod())) {\n                                                                // HEADER only\n                                                                res.setStatus(HttpServletResponse.SC_NO_CONTENT);\n                                                                handled = true;\n                                                            } else {\n                                                                // GET\n                                                                String form = entityEncodingManager.encodeEntity(prefix, format, null, view);\n                                                                // if the encoder returned something useful then we output it, if nothing comes back we pass on\n                                                                if (form != null && form.length() > 0) {\n                                                                    try {\n                                                                        res.getWriter().print(form);\n                                                                    } catch (IOException e) {\n                                                                        throw new RuntimeException(\"Failed to get writer from response: \" + view, e);\n                                                                    }\n                                                                    handled = true;\n                                                                    setNoCacheHeaders(res);\n                                                                    res.setStatus(HttpServletResponse.SC_OK);\n                                                                }\n                                                            }\n                                                        } else {\n                                                            // format type not handled\n                                                            throw new FormatUnsupportedException(\"Outputable restriction (formats list) for \" \n                                                                    + prefix + \" does not allow form generation, add the FORM format (\"\n                                                                    +Formats.FORM+\") to the list of allowed output formats to enable this\",\n                                                                    view.getEntityReference()+\"\", format);\n                                                        }\n                                                    }\n                                                }\n                                            } else {\n                                                Outputable outputable = (Outputable) entityProviderManager.getProviderByPrefixAndCapability(prefix, Outputable.class);\n                                                if (outputable != null) {\n                                                    if (customAction != null) {\n                                                        // override format from the custom action\n                                                        if (actionReturn != null \n                                                                && actionReturn.format != null) {\n                                                            format = actionReturn.format;\n                                                        }\n                                                    }\n                                                    String[] outputFormats = outputable.getHandledOutputFormats();\n                                                    if (outputFormats == null || ReflectUtils.contains(outputFormats, format) ) {\n                                                        // we are handling this type of format for this entity\n                                                        RequestUtils.setResponseEncoding(format, res);\n    \n                                                        EntityReference ref = view.getEntityReference();\n                                                        // get the entities to output\n                                                        List<EntityData> entities = null;\n                                                        if (customAction != null \n                                                                && actionReturn != null) {\n                                                            // get entities from a custom action\n                                                            entities = actionReturn.entitiesList;\n                                                            if (entities != null) {\n                                                                // recode the collection\n                                                                if (entities.size() > 0) {\n                                                                    EntityData ed = entities.get(0);\n                                                                    ref = new EntityReference(ed.getEntityRef().getPrefix(), \"\");\n                                                                    view.setEntityReference( ref );\n                                                                    view.setViewKey(EntityView.VIEW_LIST);\n                                                                }\n                                                            } else if (actionReturn.entityData != null) {\n                                                                // this was a single object return so it should be encoded as such, thus we will recode the correct reference into the view\n                                                                ArrayList<EntityData> eList = new ArrayList<EntityData>();\n                                                                EntityData ed = actionReturn.entityData;\n                                                                // set title if not set\n                                                                if (! ed.isDisplayTitleSet()) {\n                                                                    ed.setDisplayTitle(customAction.action);\n                                                                }\n                                                                // add to list\n                                                                eList.add( ed );\n                                                                entities = eList;\n                                                                // make entity reference\n                                                                ref = ed.getEntityRef();\n                                                                if (ref == null) {\n                                                                    ref = new EntityReference(prefix, customAction.action);\n                                                                } else if (ref.getId() == null) {\n                                                                    ref = new EntityReference(ref.getPrefix(), customAction.action);\n                                                                }\n                                                                view.setEntityReference( ref );\n                                                                view.setViewKey(EntityView.VIEW_SHOW);\n                                                            }\n                                                        } else {\n                                                            // get from a search\n                                                            Search search = RequestUtils.makeSearchFromRequestParams(requestStorage.getStorageMapCopy(true, false, true, true)); // leave out headers));\n                                                            entities = entityBrokerManager.getEntitiesData(ref, search, requestStorage.getStorageMapCopy());\n                                                        }\n                                                        // set the modified header (use the sole entity in the list if there is one only)\n                                                        setLastModifiedHeaders(res, (entities != null && entities.size()==1 ? entities.get(0) : null), System.currentTimeMillis());\n    \n                                                        if (EntityView.Method.HEAD.name().equals(view.getMethod())) {\n                                                            // HEADER only\n                                                            res.setStatus(HttpServletResponse.SC_NO_CONTENT);\n                                                        } else {\n                                                            // GET\n                                                            OutputStream outputStream = new LazyResponseOutputStream(res);\n    \n                                                            /* try to use the provider formatter if one available,\n                                                             * if it decided not to handle it or none is available then control passes to internal\n                                                             */\n                                                            try {\n                                                                OutputFormattable formattable = (OutputFormattable) entityProviderManager.getProviderByPrefixAndCapability(prefix, OutputFormattable.class);\n                                                                if (formattable != null) {\n                                                                    // use provider's formatter\n                                                                    formattable.formatOutput(ref, format, entities, requestStorage.getStorageMapCopy(), outputStream);\n                                                                    handled = true;\n                                                                }\n                                                            } catch (FormatUnsupportedException e) {\n                                                                // provider decided not to handle this format\n                                                                handled = false;\n                                                            }\n                                                            if (!handled) {\n                                                                // handle internally or fail\n                                                                entityEncodingManager.internalOutputFormatter(ref, format, entities, requestStorage.getStorageMapCopy(), outputStream, view);\n                                                                // SPECIAL CASE: FORM\n                                                                if (Formats.FORM.equals(format)) {\n                                                                    setNoCacheHeaders(res);\n                                                                }\n                                                            }\n                                                            handled = true;\n                                                            res.setStatus(HttpServletResponse.SC_OK);\n                                                        }\n                                                    } else {\n                                                        // format type not handled\n                                                        throw new FormatUnsupportedException(\"Outputable restriction (formats list) for \" \n                                                                + prefix + \" blocked handling this format (\"+format+\")\",\n                                                                view.getEntityReference()+\"\", format);\n                                                    }\n                                                }\n                                            }\n                                        } else {\n                                            // input request\n                                            if (EntityView.VIEW_DELETE.equals(view.getViewKey())) {\n                                                // delete request\n                                                Deleteable deleteable = (Deleteable) entityProviderManager.getProviderByPrefixAndCapability(prefix, Deleteable.class);\n                                                if (deleteable != null) {\n                                                    deleteable.deleteEntity(view.getEntityReference(), requestStorage.getStorageMapCopy());\n                                                    res.setStatus(HttpServletResponse.SC_NO_CONTENT);\n                                                    handled = true;\n                                                }\n                                            } else {\n                                                // save request\n                                                Inputable inputable = (Inputable) entityProviderManager.getProviderByPrefixAndCapability(prefix, Inputable.class);\n                                                if (inputable != null) {\n                                                    String[] inputFormats = inputable.getHandledInputFormats();\n                                                    if (inputFormats == null || ReflectUtils.contains(inputFormats, format) ) {\n                                                        // we are handling this type of format for this entity\n                                                        Object entity = null;\n                                                        InputStream inputStream = null;\n                                                        try {\n                                                            inputStream = req.getInputStream();\n                                                        } catch (IOException e) {\n                                                            throw new RuntimeException(\"Failed to get output stream from response: \" + view.getEntityReference(), e);\n                                                        }\n    \n                                                        /* try to use the provider translator if one available,\n                                                         * if it decided not to handle it or none is available then control passes to internal\n                                                         */\n                                                        try {\n                                                            InputTranslatable translatable = (InputTranslatable) entityProviderManager.getProviderByPrefixAndCapability(prefix, InputTranslatable.class);\n                                                            if (translatable != null) {\n                                                                // use provider's translator\n                                                                entity = translatable.translateFormattedData(view.getEntityReference(), \n                                                                        format, inputStream, requestStorage.getStorageMapCopy());\n                                                                handled = true;\n                                                            }\n                                                        } catch (FormatUnsupportedException e) {\n                                                            // provider decided not to handle this format\n                                                            handled = false;\n                                                        }\n                                                        if (!handled) {\n                                                            // use internal translators or fail\n                                                            entity = entityEncodingManager.internalInputTranslator(view.getEntityReference(), \n                                                                    format, inputStream, req);\n                                                        }\n    \n                                                        if (entity == null) {\n                                                            // FAILURE input could not be translated into an entity object\n                                                            handled = false;\n                                                            throw new EntityException(\"Unable to save entity (\"+view.getEntityReference()+\") with format (\"\n                                                                    +format+\"), translated entity object was null\", \n                                                                    view.toString(), HttpServletResponse.SC_BAD_REQUEST);\n                                                        } else {\n                                                            // setup all the headers for the response\n                                                            if (EntityView.VIEW_NEW.equals(view.getViewKey())) {\n                                                                Createable createable = entityProviderManager.getProviderByPrefixAndCapability(prefix, Createable.class);\n                                                                if (createable == null) {\n                                                                    throw new EntityException(\"Unable to create new entity (\"+view+\"), \"\n                                                                            +Createable.class.getName()+\" is not implemented for this entity type (\"+prefix+\")\", \n                                                                            view+\"\", HttpServletResponse.SC_NOT_IMPLEMENTED);\n                                                                }\n                                                                String createdId = createable.createEntity(view.getEntityReference(), entity, requestStorage.getStorageMapCopy());\n                                                                if (createdId == null || \"\".equals(createdId)) {\n                                                                    throw new IllegalStateException(\"Could not get the createdId from the newly created entity for (\"+view+\"), please ensure the provider is returning a non-null and non-empty value from the create method, if the item was not created then an exception should have been thrown\");\n                                                                }\n                                                                view.setEntityReference( new EntityReference(prefix, createdId) ); // update the entity view\n                                                                res.setHeader(EntityRequestHandler.HEADER_ENTITY_ID, createdId);\n                                                                res.setStatus(HttpServletResponse.SC_CREATED);\n                                                                // added the id to the response to make it easier on Nico\n                                                                try {\n                                                                    OutputStream outputStream = res.getOutputStream();\n                                                                    outputStream.write( createdId.getBytes() );\n                                                                } catch (IOException e) {\n                                                                    // oh well, no id in the output\n                                                                } catch (RuntimeException e) {\n                                                                    // oh well, no id in the output\n                                                                }\n                                                            } else if (EntityView.VIEW_EDIT.equals(view.getViewKey())) {\n                                                                Updateable updateable = entityProviderManager.getProviderByPrefixAndCapability(prefix, Updateable.class);\n                                                                if (updateable == null) {\n                                                                    throw new EntityException(\"Unable to create new entity (\"+view+\"), \"\n                                                                            +Updateable.class.getName()+\" is not implemented for this entity type (\"+prefix+\")\", \n                                                                            view+\"\", HttpServletResponse.SC_NOT_IMPLEMENTED);\n                                                                }\n                                                                updateable.updateEntity(view.getEntityReference(), entity, requestStorage.getStorageMapCopy());\n                                                                res.setStatus(HttpServletResponse.SC_NO_CONTENT);\n                                                            } else {\n                                                                // FAILURE not delete, edit, or new\n                                                                throw new EntityException(\"Unable to handle entity input (\"+view.getEntityReference()+\"), \" +\n                                                                        \"action was not understood: \" + view.getViewKey(), \n                                                                        view.getEntityReference()+\"\", HttpServletResponse.SC_BAD_REQUEST);\n                                                            }\n                                                            // return the location of this updated or created entity (without any extension)\n                                                            res.setHeader(EntityRequestHandler.HEADER_ENTITY_URL, view.getEntityURL() );\n                                                            res.setHeader(EntityRequestHandler.HEADER_ENTITY_REFERENCE, view.getEntityReference().toString() );\n                                                            handled = true;\n                                                        }\n                                                    } else {\n                                                        // format type not handled\n                                                        throw new FormatUnsupportedException(\"Inputable restriction for \" \n                                                                + prefix + \" blocked handling this format (\"+format+\")\",\n                                                                view.getEntityReference()+\"\", format);\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    } catch (FormatUnsupportedException e) {\n                                        // this format could not be handled internally so we will pass it to the access provider, nothing else to do here\n                                        formatInvalidFailure = true;\n                                        handled = false;\n                                    } catch (SecurityException se) {\n                                        // AJAX/WS type security exceptions are handled specially, no redirect\n                                        throw new EntityException(\"Security exception handling request for view (\"+view+\"), \"\n                                                + \"this is typically caused by the current user not having access to the \"\n                                                + \"data requested or the user not being logged in at all :: message=\" + se.getMessage(),\n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_FORBIDDEN);\n                                    } catch (EntityEncodingException e) {\n                                        // translate EEE into EE - internal server error\n                                        throw new EntityException(\"EntityEncodingException: Unable to handle \" + (output ? \"output\" : \"input\") + \" request for format  \"+view.getFormat()+\" for this path (\" \n                                                + path + \") for prefix (\" + prefix + \") for entity (\" + view.getEntityReference() + \"), request url (\" + view.getOriginalEntityUrl() + \"): \" + e.getMessage(),\n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_INTERNAL_SERVER_ERROR);        \n                                    } catch (IllegalArgumentException e) {\n                                        // translate IAE into EE - bad request\n                                        throw new EntityException(\"IllegalArgumentException: Unable to handle \" + (output ? \"output\" : \"input\") + \" request for format  \"+view.getFormat()+\" for this path (\" \n                                                + path + \") for prefix (\" + prefix + \") for entity (\" + view.getEntityReference() + \"), request url (\" + view.getOriginalEntityUrl() + \"): \" + e.getMessage(),\n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_BAD_REQUEST);        \n                                    } catch (IllegalStateException e) {\n                                        // translate ISE into EE - internal server error\n                                        throw new EntityException(\"IllegalStateException: Unable to handle \" + (output ? \"output\" : \"input\") + \" request for format  \"+view.getFormat()+\" for this path (\" \n                                                + path + \") for prefix (\" + prefix + \") for entity (\" + view.getEntityReference() + \"), request url (\" + view.getOriginalEntityUrl() + \"): \" + e.getMessage(),\n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n                                    }\n                                }\n    \n                                if (! handled) {\n                                    // default handling, send to the access provider if there is one (if none this will throw EntityException)\n                                    try {\n                                        boolean accessProviderExists = handleAccessProvider(view, req, res);\n                                        if (!accessProviderExists) {\n                                            if (formatInvalidFailure) {\n                                                // trigger the format \n                                                throw new FormatUnsupportedException(\"Nothing (AP and internal) available to handle the requested format\", view.getEntityReference()+\"\", view.getFormat());\n                                            }\n                                            String message = \"Access Provider: Attempted to access an entity URL path (\"\n                                                + view + \") using method (\"+view.getMethod()+\") for an entity (\" + view.getEntityReference() \n                                                + \") and view (\"+view.getViewKey()+\") when there is no \" \n                                                + \"access provider to handle the request for prefix (\" + view.getEntityReference().getPrefix() + \")\";\n                                            throw new EntityException( message, view.toString(), HttpServletResponse.SC_METHOD_NOT_ALLOWED );\n                                        }\n                                    } catch (FormatUnsupportedException e) {\n                                        // TODO add in the methods \"allowed\" header?\n                                        throw new EntityException( \"AccessProvider: Method/Format unsupported: Will not handle \" + (output ? \"output\" : \"input\") + \" request for format  \"+view.getFormat()+\" for this path (\" \n                                                + path + \") for prefix (\" + prefix + \") for entity (\" + view.getEntityReference() + \"), request url (\" + view.getOriginalEntityUrl() + \")\",\n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_NOT_ACCEPTABLE );\n                                    }\n                                }\n                            }\n                        }\n                        handledReference = view.getEntityReference().toString();\n                        requestStorage.setRequestValue(RequestStorage.ReservedKeys._requestEntityReference.name(), handledReference);\n\n                        // handle the after interceptor\n                        if (interceptor != null) {\n                            interceptor.after(view, req, res);\n                        }\n                    } finally {\n                        // clear the request data no matter what happens\n                        requestStorage.reset();\n                        requestGetter.setRequest(null);\n                        requestGetter.setResponse(null);\n                    }\n                }\n            }\n        }\n        return handledReference;\n    }","id":65700,"modified_method":"/**\n     * If this param is set then the sakai session for the current request is set to this rather than establishing one,\n     * will allow changing the session as well\n     */\n\n    /* (non-Javadoc)\n     * @see org.sakaiproject.entitybroker.EntityRequestHandler#handleEntityAccess(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)\n     */\n    public String handleEntityAccess(HttpServletRequest req, HttpServletResponse res, String path) {\n        // set the servlet context if not set\n        if (this.servletContext == null) {\n            setServletContext( RequestUtils.getServletContext(req) );\n        }\n\n        // get the path info if not set\n        if (path == null) {\n            path = req.getPathInfo();\n        }\n\n        String handledReference = null;\n\n        // special handling in case the session ID is sent in the request \n        // (allows setting up and reusing a session over and over without holding cookies)\n        if (entityBrokerManager.getExternalIntegrationProvider() != null) {\n            try {\n                entityBrokerManager.getExternalIntegrationProvider().handleUserSessionKey(req);\n            } catch (Exception e) {\n                System.out.println(\"WARN: EntityRequestHandler: External handleUserSessionKey method failed, continuing...: \" + e);\n            }\n        }\n\n        if (path == null || \"\".equals(path) || \"/\".equals(path)) {\n            // SPECIAL handling for empty path\n            res.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY);\n            try {\n                res.sendRedirect( res.encodeRedirectURL(getServletContext() + SLASH_DESCRIBE) );\n            } catch (IOException e) {\n                // should never happen\n                throw new RuntimeException(\"Could not encode the redirect URL\");\n            }\n            // immediate exit from redirect\n            return \"/\";\n        } else {\n            // regular handling for direct URLs\n            if ( (SLASH_DESCRIBE).equals(path) \n                    || path.startsWith(SLASH_DESCRIBE + EntityReference.PERIOD)) {\n                // SPECIAL handling for the describe all URL\n                String format = RequestUtils.findAndHandleFormat(req, res, Formats.HTML);\n                String output = entityDescriptionManager.makeDescribeAll(format, req.getLocale()); // possibly get the locale from other places?\n                res.setContentLength(output.getBytes().length);\n                try {\n                    res.getWriter().write(output);\n                } catch (IOException e) {\n                    // should never happen\n                    throw new RuntimeException(\"Failed to put output into the response writer: \" + e.getMessage(), e);\n                }\n                res.setStatus(HttpServletResponse.SC_OK);\n                handledReference = EntityView.SEPARATOR+\"\";\n            } else {\n                // STANDARD processing for the incoming view\n                EntityView view;\n                try {\n                    view = entityBrokerManager.parseEntityURL(path);\n                } catch (IllegalArgumentException e) {\n                    // FAILURE indicates we could not parse the reference\n                    throw new EntityException(\"Could not parse entity path (\"+path+\"): \" + e.getMessage(), path, HttpServletResponse.SC_BAD_REQUEST);\n                }\n\n                if (view == null) {\n                    // FAILURE no provider for this entity prefix\n                    throw new EntityException( \"Could not parse the incoming path (\"+path+\") and no entity provider could be found to handle the prefix\", \n                            path, HttpServletResponse.SC_NOT_IMPLEMENTED );\n                } else if ( DESCRIBE.equals(view.getEntityReference().getId()) ) {\n                    // SPECIAL handling for entity describe URLs\n                    String format = RequestUtils.findAndHandleFormat(req, res, Formats.HTML);\n                    String entityId = req.getParameter(\"_id\");\n                    if (entityId == null || \"\".equals(entityId)) {\n                        entityId = FAKE_ID;\n                    }\n                    String output = entityDescriptionManager.makeDescribeEntity(view.getEntityReference().getPrefix(), entityId, format, req.getLocale());\n                    res.setContentLength(output.getBytes().length);\n                    try {\n                        res.getWriter().write(output);\n                    } catch (IOException e) {\n                        throw new RuntimeException(\"Failed to put output into the response writer: \" + e.getMessage(), e);\n                    }\n                    res.setStatus(HttpServletResponse.SC_OK);\n                    handledReference = view.getEntityReference().getSpaceReference() + SLASH_DESCRIBE;\n\n                } else {\n                    // STANDARD reference successfully parsed\n                    String prefix = view.getEntityReference().getPrefix();\n\n                    // check for redirect\n                    Redirectable urlConfigurable = entityProviderManager.getProviderByPrefixAndCapability(prefix, Redirectable.class);\n                    if (urlConfigurable != null) {\n                        // SPECIAL check for redirect\n                        String redirectURL = entityRedirectsManager.checkForTemplateMatch(urlConfigurable, path, req.getQueryString());\n                        if (redirectURL != null) {\n                            // SPECIAL handling for redirect\n                            if (\"\".equals(redirectURL)) {\n                                // do nothing but return an empty response\n                                res.setStatus(HttpServletResponse.SC_OK);\n                            } else {\n                                // do the redirect\n                                System.out.println(\"INFO: EntityRequestHandler: Entity Redirect: redirecting from (\"+path+\") to (\"+redirectURL+\")\");\n                                RequestUtils.handleURLRedirect(redirectURL, true, req, res);\n                            }\n                            return EntityView.SEPARATOR + prefix; // exit here for redirects\n                        }\n                    }\n\n                    // check for custom action\n                    CustomAction customAction = entityActionsManager.getCustomAction(prefix, view.getPathSegment(1));\n                    if (customAction == null) {\n                        customAction = entityActionsManager.getCustomAction(prefix, view.getPathSegment(2));\n                    }\n                    if (customAction == null) {\n                        // check to see if the entity exists\n                        if (! entityBrokerManager.entityExists(view.getEntityReference()) ) {\n                            // FAILURE invalid entity reference (entity does not exist)\n                            throw new EntityException( \"Attempted to access an entity URL path (\" + path + \") for an entity (\"\n                                    + view.getEntityReference() + \") that does not exist\", \n                                    view.getEntityReference()+\"\", HttpServletResponse.SC_NOT_FOUND );\n                        }\n                    } else {\n                        // cleanup the entity reference, this has to be done because otherwise the custom action\n                        // on collections appears to be the id of an entity in the collection\n                        EntityReference cRef = view.getEntityReference();\n                        if (cRef.getId().equals(customAction.action)) {\n                            view.setEntityReference( new EntityReference(prefix, \"\") );\n                        }\n                    }\n                    res.setStatus(HttpServletResponse.SC_OK); // default - other things can switch this later on\n\n                    // store format in attribute\n                    req.setAttribute(\"entity-format\", view.getFormat());\n\n                    // STANDARD initial processing complete\n                    // wrap in try block so that request storage is always cleaned up\n                    try {\n                        // store the current request and response\n                        requestGetter.setRequest(req);\n                        requestGetter.setResponse(res);\n                        // set the request variables\n                        requestStorage.setRequestValue(RequestStorage.ReservedKeys._requestEntityReference.name(), view.getEntityReference().toString());\n                        requestStorage.setRequestValue(RequestStorage.ReservedKeys._requestOrigin.name(), RequestStorage.RequestOrigin.REST.name());\n                        requestStorage.setRequestValue(RequestStorage.ReservedKeys._requestActive.name(), true);\n\n                        // handle the before interceptor\n                        RequestInterceptor interceptor = (RequestInterceptor) entityProviderManager.getProviderByPrefixAndCapability(prefix, RequestInterceptor.class);\n                        if (interceptor != null) {\n                            interceptor.before(view, req, res);\n                        }\n\n                        if (BATCH.equals(prefix)) {\n                            // special batch handling\n                            // set the default format to JSON for batch handling\n                            view.setExtension( RequestUtils.findAndHandleFormat(req, res, Formats.JSON) );\n                            entityBatchHandler.handleBatch(view, req, res);\n                        } else {\n                            // ensure the format is set correctly for the response and the view\n                            String format = RequestUtils.findAndHandleFormat(req, res, Formats.HTML);\n                            view.setExtension( format );\n\n                            // check for provider handling of this request\n                            RequestHandler handler = (RequestHandler) entityProviderManager.getProviderByPrefixAndCapability(prefix, RequestHandler.class);\n                            if (handler != null) {\n                                // SPECIAL provider is handling this request\n                                handleClassLoaderAccess(handler, req, res, view);\n                            } else {\n                                // STANDARD processing of the entity request internally start here\n                                // try to handle the request internally if possible\n    \n                                // identify the type of request (input or output) and the action (will be encoded in the viewKey)\n                                boolean output = RequestUtils.isRequestOutput(req, view);\n                                setResponseHeaders(view, res, requestStorage.getStorageMapCopy(), null);\n    \n                                boolean handled = false;\n                                // PROCESS CUSTOM ACTIONS\n                                ActionReturn actionReturn = null;\n                                if (customAction != null) {\n                                    // SPECIAL handle the custom action\n                                    ActionsExecutable actionProvider = entityProviderManager.getProviderByPrefixAndCapability(prefix, ActionsExecutable.class);\n                                    if (actionProvider == null) {\n                                        throw new EntityException( \"The provider for prefix (\"+prefix+\") cannot handle custom actions\", \n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_BAD_REQUEST );\n                                    }\n                                    // make sure this request is a valid type for this action\n                                    if (customAction.viewKey != null \n                                            && ! view.getViewKey().equals(customAction.viewKey)) {\n                                        throw new EntityException( \"Cannot execute custom action (\"+customAction.action+\") for request method \" + req.getMethod()\n                                                + \", The custom action view key (\"+customAction.viewKey+\") must match the request view key (\"+view.getViewKey()+\")\", \n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_BAD_REQUEST );\n                                    }\n                                    try {\n                                        actionReturn = entityActionsManager.handleCustomActionRequest(actionProvider, view, customAction.action, req, res, \n                                                requestStorage.getStorageMapCopy(true, false, true, true) );\n                                    } catch (SecurityException se) {\n                                        // AJAX/WS type security exceptions are handled specially, no redirect\n                                        throw new EntityException(\"Security exception handling request for view (\"+view+\"), \"\n                                                + \"this is typically caused by the current user not having access to the \"\n                                                + \"data requested or the user not being logged in at all :: message=\" + se.getMessage(),\n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_FORBIDDEN);\n                                    } catch (EntityNotFoundException e) {\n                                        throw new EntityException( \"Cannot execute custom action (\"+customAction.action+\"): Could not find entity (\"+e.entityReference+\"): \" + e.getMessage(), \n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_NOT_FOUND );\n                                    } catch (FormatUnsupportedException e) {\n                                        throw new EntityException( \"Cannot execute custom action (\"+customAction.action+\"): Format not supported (\"+e.format+\"): \" + e.getMessage(), \n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_NOT_ACCEPTABLE );\n                                    } catch (IllegalArgumentException e) {\n                                        throw new EntityException( \"Cannot execute custom action (\"+customAction.action+\"): Illegal arguments: \" + e.getMessage(), \n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_BAD_REQUEST );\n                                    } catch (UnsupportedOperationException e) {\n                                        throw new EntityException( \"Cannot execute custom action (\"+customAction.action+\"): Could not execute action: \" + e.getMessage(), \n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_BAD_REQUEST );\n                                    }\n                                    if (actionReturn == null \n                                            || actionReturn.output != null) {\n                                        // custom action processing complete\n                                        /* actionReturn.output != null - this means that there is an \n                                         * outputstream set and that the encoding has been,\n                                         * handled, however, the response status code should be set still\n                                         */\n                                        handled = true;\n                                    } else {\n                                        // if there are headers then set them now\n                                        addResponseHeaders(res, actionReturn.getHeaders());\n                                        // if the custom action returned entity data then we will encode it for output\n                                        if (actionReturn.entitiesList == null\n                                                && actionReturn.entityData == null) {\n                                            handled = true;\n                                        } else {\n                                            // there is entity data to return\n                                            output = true;\n                                            handled = false;\n                                            // populate the entity data\n                                            if (actionReturn.entitiesList != null) {\n                                                if (actionReturn.entitiesList.size() > 1) {\n                                                    // correct the view key which should be used now\n                                                    view.setViewKey(EntityView.VIEW_LIST);\n                                                }\n                                                entityBrokerManager.populateEntityData(actionReturn.entitiesList);\n                                            } else if (actionReturn.entityData != null) {\n                                                // correct the view key which should be used now\n                                                view.setViewKey(EntityView.VIEW_SHOW);\n                                                entityBrokerManager.populateEntityData( new EntityData[] {actionReturn.entityData} );\n                                            }\n                                        }\n                                    }\n                                }\n    \n                                boolean formatInvalidFailure = false;\n                                if (!handled) {\n                                    // INTERNAL PROCESSING OF REQUEST\n                                    try {\n                                        if (output) {\n                                            // output request\n                                            String viewKey = view.getViewKey();\n                                            if (EntityView.VIEW_NEW.equals(viewKey)\n                                                    || EntityView.VIEW_EDIT.equals(viewKey) \n                                                    || EntityView.VIEW_DELETE.equals(viewKey) ) {\n                                                // request for the create/edit/delete entity forms\n                                                handled = false; // if we handle this then switch this to true\n                                                if (Formats.FORM.equals(format)) {\n                                                    // generate new/edit/delete forms internally if the provider allows it\n                                                    Outputable outputable = (Outputable) entityProviderManager.getProviderByPrefixAndCapability(prefix, Outputable.class);\n                                                    if (outputable != null) {\n                                                        String[] outputFormats = outputable.getHandledOutputFormats();\n                                                        if (outputFormats != null && ReflectUtils.contains(outputFormats, Formats.FORM) ) {\n                                                            // we are handling this type of format for this entity\n                                                            RequestUtils.setResponseEncoding(format, res);\n                                                            if (EntityView.Method.HEAD.name().equals(view.getMethod())) {\n                                                                // HEADER only\n                                                                res.setStatus(HttpServletResponse.SC_NO_CONTENT);\n                                                                handled = true;\n                                                            } else {\n                                                                // GET\n                                                                String form = entityEncodingManager.encodeEntity(prefix, format, null, view);\n                                                                // if the encoder returned something useful then we output it, if nothing comes back we pass on\n                                                                if (form != null && form.length() > 0) {\n                                                                    try {\n                                                                        res.getWriter().print(form);\n                                                                    } catch (IOException e) {\n                                                                        throw new RuntimeException(\"Failed to get writer from response: \" + view, e);\n                                                                    }\n                                                                    handled = true;\n                                                                    setNoCacheHeaders(res);\n                                                                    res.setStatus(HttpServletResponse.SC_OK);\n                                                                }\n                                                            }\n                                                        } else {\n                                                            // format type not handled\n                                                            throw new FormatUnsupportedException(\"Outputable restriction (formats list) for \" \n                                                                    + prefix + \" does not allow form generation, add the FORM format (\"\n                                                                    +Formats.FORM+\") to the list of allowed output formats to enable this\",\n                                                                    view.getEntityReference()+\"\", format);\n                                                        }\n                                                    }\n                                                }\n                                            } else {\n                                                Outputable outputable = (Outputable) entityProviderManager.getProviderByPrefixAndCapability(prefix, Outputable.class);\n                                                if (outputable != null) {\n                                                    if (customAction != null) {\n                                                        // override format from the custom action\n                                                        if (actionReturn != null \n                                                                && actionReturn.format != null) {\n                                                            format = actionReturn.format;\n                                                        }\n                                                    }\n                                                    String[] outputFormats = outputable.getHandledOutputFormats();\n                                                    if (outputFormats == null || ReflectUtils.contains(outputFormats, format) ) {\n                                                        // we are handling this type of format for this entity\n                                                        RequestUtils.setResponseEncoding(format, res);\n    \n                                                        EntityReference ref = view.getEntityReference();\n                                                        // get the entities to output\n                                                        List<EntityData> entities = null;\n                                                        if (customAction != null \n                                                                && actionReturn != null) {\n                                                            // get entities from a custom action\n                                                            entities = actionReturn.entitiesList;\n                                                            if (entities != null) {\n                                                                // recode the collection\n                                                                if (entities.size() > 0) {\n                                                                    EntityData ed = entities.get(0);\n                                                                    ref = new EntityReference(ed.getEntityRef().getPrefix(), \"\");\n                                                                    view.setEntityReference( ref );\n                                                                    view.setViewKey(EntityView.VIEW_LIST);\n                                                                }\n                                                            } else if (actionReturn.entityData != null) {\n                                                                // this was a single object return so it should be encoded as such, thus we will recode the correct reference into the view\n                                                                ArrayList<EntityData> eList = new ArrayList<EntityData>();\n                                                                EntityData ed = actionReturn.entityData;\n                                                                // set title if not set\n                                                                if (! ed.isDisplayTitleSet()) {\n                                                                    ed.setDisplayTitle(customAction.action);\n                                                                }\n                                                                // add to list\n                                                                eList.add( ed );\n                                                                entities = eList;\n                                                                // make entity reference\n                                                                ref = ed.getEntityRef();\n                                                                if (ref == null) {\n                                                                    ref = new EntityReference(prefix, customAction.action);\n                                                                } else if (ref.getId() == null) {\n                                                                    ref = new EntityReference(ref.getPrefix(), customAction.action);\n                                                                }\n                                                                view.setEntityReference( ref );\n                                                                view.setViewKey(EntityView.VIEW_SHOW);\n                                                            }\n                                                        } else {\n                                                            // get from a search\n                                                            Search search = RequestUtils.makeSearchFromRequestParams(requestStorage.getStorageMapCopy(true, false, true, true)); // leave out headers));\n                                                            entities = entityBrokerManager.getEntitiesData(ref, search, requestStorage.getStorageMapCopy());\n                                                        }\n                                                        // set the modified header (use the sole entity in the list if there is one only)\n                                                        setLastModifiedHeaders(res, (entities != null && entities.size()==1 ? entities.get(0) : null), System.currentTimeMillis());\n    \n                                                        if (EntityView.Method.HEAD.name().equals(view.getMethod())) {\n                                                            // HEADER only\n                                                            res.setStatus(HttpServletResponse.SC_NO_CONTENT);\n                                                        } else {\n                                                            // GET\n                                                            OutputStream outputStream = new LazyResponseOutputStream(res);\n    \n                                                            /* try to use the provider formatter if one available,\n                                                             * if it decided not to handle it or none is available then control passes to internal\n                                                             */\n                                                            try {\n                                                                OutputFormattable formattable = (OutputFormattable) entityProviderManager.getProviderByPrefixAndCapability(prefix, OutputFormattable.class);\n                                                                if (formattable != null) {\n                                                                    // use provider's formatter\n                                                                    formattable.formatOutput(ref, format, entities, requestStorage.getStorageMapCopy(), outputStream);\n                                                                    handled = true;\n                                                                }\n                                                            } catch (FormatUnsupportedException e) {\n                                                                // provider decided not to handle this format\n                                                                handled = false;\n                                                            }\n                                                            if (!handled) {\n                                                                // handle internally or fail\n                                                                entityEncodingManager.internalOutputFormatter(ref, format, entities, requestStorage.getStorageMapCopy(), outputStream, view);\n                                                                // SPECIAL CASE: FORM\n                                                                if (Formats.FORM.equals(format)) {\n                                                                    setNoCacheHeaders(res);\n                                                                }\n                                                            }\n                                                            handled = true;\n                                                            res.setStatus(HttpServletResponse.SC_OK);\n                                                        }\n                                                    } else {\n                                                        // format type not handled\n                                                        throw new FormatUnsupportedException(\"Outputable restriction (formats list) for \" \n                                                                + prefix + \" blocked handling this format (\"+format+\")\",\n                                                                view.getEntityReference()+\"\", format);\n                                                    }\n                                                }\n                                            }\n                                        } else {\n                                            // input request\n                                            if (EntityView.VIEW_DELETE.equals(view.getViewKey())) {\n                                                // delete request\n                                                Deleteable deleteable = (Deleteable) entityProviderManager.getProviderByPrefixAndCapability(prefix, Deleteable.class);\n                                                if (deleteable != null) {\n                                                    deleteable.deleteEntity(view.getEntityReference(), requestStorage.getStorageMapCopy());\n                                                    res.setStatus(HttpServletResponse.SC_NO_CONTENT);\n                                                    handled = true;\n                                                }\n                                            } else {\n                                                // save request\n                                                Inputable inputable = (Inputable) entityProviderManager.getProviderByPrefixAndCapability(prefix, Inputable.class);\n                                                if (inputable != null) {\n                                                    String[] inputFormats = inputable.getHandledInputFormats();\n                                                    if (inputFormats == null || ReflectUtils.contains(inputFormats, format) ) {\n                                                        // we are handling this type of format for this entity\n                                                        Object entity = null;\n                                                        InputStream inputStream = null;\n                                                        try {\n                                                            inputStream = req.getInputStream();\n                                                        } catch (IOException e) {\n                                                            throw new RuntimeException(\"Failed to get output stream from response: \" + view.getEntityReference(), e);\n                                                        }\n    \n                                                        /* try to use the provider translator if one available,\n                                                         * if it decided not to handle it or none is available then control passes to internal\n                                                         */\n                                                        try {\n                                                            InputTranslatable translatable = (InputTranslatable) entityProviderManager.getProviderByPrefixAndCapability(prefix, InputTranslatable.class);\n                                                            if (translatable != null) {\n                                                                // use provider's translator\n                                                                entity = translatable.translateFormattedData(view.getEntityReference(), \n                                                                        format, inputStream, requestStorage.getStorageMapCopy());\n                                                                handled = true;\n                                                            }\n                                                        } catch (FormatUnsupportedException e) {\n                                                            // provider decided not to handle this format\n                                                            handled = false;\n                                                        }\n                                                        if (!handled) {\n                                                            // use internal translators or fail\n                                                            entity = entityEncodingManager.internalInputTranslator(view.getEntityReference(), \n                                                                    format, inputStream, req);\n                                                        }\n    \n                                                        if (entity == null) {\n                                                            // FAILURE input could not be translated into an entity object\n                                                            handled = false;\n                                                            throw new EntityException(\"Unable to save entity (\"+view.getEntityReference()+\") with format (\"\n                                                                    +format+\"), translated entity object was null\", \n                                                                    view.toString(), HttpServletResponse.SC_BAD_REQUEST);\n                                                        } else {\n                                                            // setup all the headers for the response\n                                                            if (EntityView.VIEW_NEW.equals(view.getViewKey())) {\n                                                                Createable createable = entityProviderManager.getProviderByPrefixAndCapability(prefix, Createable.class);\n                                                                if (createable == null) {\n                                                                    throw new EntityException(\"Unable to create new entity (\"+view+\"), \"\n                                                                            +Createable.class.getName()+\" is not implemented for this entity type (\"+prefix+\")\", \n                                                                            view+\"\", HttpServletResponse.SC_NOT_IMPLEMENTED);\n                                                                }\n                                                                String createdId = createable.createEntity(view.getEntityReference(), entity, requestStorage.getStorageMapCopy());\n                                                                if (createdId == null || \"\".equals(createdId)) {\n                                                                    throw new IllegalStateException(\"Could not get the createdId from the newly created entity for (\"+view+\"), please ensure the provider is returning a non-null and non-empty value from the create method, if the item was not created then an exception should have been thrown\");\n                                                                }\n                                                                view.setEntityReference( new EntityReference(prefix, createdId) ); // update the entity view\n                                                                res.setHeader(EntityRequestHandler.HEADER_ENTITY_ID, createdId);\n                                                                res.setStatus(HttpServletResponse.SC_CREATED);\n                                                                // added the id to the response to make it easier on Nico\n                                                                try {\n                                                                    OutputStream outputStream = res.getOutputStream();\n                                                                    outputStream.write( createdId.getBytes() );\n                                                                } catch (IOException e) {\n                                                                    // oh well, no id in the output\n                                                                } catch (RuntimeException e) {\n                                                                    // oh well, no id in the output\n                                                                }\n                                                            } else if (EntityView.VIEW_EDIT.equals(view.getViewKey())) {\n                                                                Updateable updateable = entityProviderManager.getProviderByPrefixAndCapability(prefix, Updateable.class);\n                                                                if (updateable == null) {\n                                                                    throw new EntityException(\"Unable to create new entity (\"+view+\"), \"\n                                                                            +Updateable.class.getName()+\" is not implemented for this entity type (\"+prefix+\")\", \n                                                                            view+\"\", HttpServletResponse.SC_NOT_IMPLEMENTED);\n                                                                }\n                                                                updateable.updateEntity(view.getEntityReference(), entity, requestStorage.getStorageMapCopy());\n                                                                res.setStatus(HttpServletResponse.SC_NO_CONTENT);\n                                                            } else {\n                                                                // FAILURE not delete, edit, or new\n                                                                throw new EntityException(\"Unable to handle entity input (\"+view.getEntityReference()+\"), \" +\n                                                                        \"action was not understood: \" + view.getViewKey(), \n                                                                        view.getEntityReference()+\"\", HttpServletResponse.SC_BAD_REQUEST);\n                                                            }\n                                                            // return the location of this updated or created entity (without any extension)\n                                                            res.setHeader(EntityRequestHandler.HEADER_ENTITY_URL, view.getEntityURL() );\n                                                            res.setHeader(EntityRequestHandler.HEADER_ENTITY_REFERENCE, view.getEntityReference().toString() );\n                                                            handled = true;\n                                                        }\n                                                    } else {\n                                                        // format type not handled\n                                                        throw new FormatUnsupportedException(\"Inputable restriction for \" \n                                                                + prefix + \" blocked handling this format (\"+format+\")\",\n                                                                view.getEntityReference()+\"\", format);\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    } catch (FormatUnsupportedException e) {\n                                        // this format could not be handled internally so we will pass it to the access provider, nothing else to do here\n                                        formatInvalidFailure = true;\n                                        handled = false;\n                                    } catch (SecurityException se) {\n                                        // AJAX/WS type security exceptions are handled specially, no redirect\n                                        throw new EntityException(\"Security exception handling request for view (\"+view+\"), \"\n                                                + \"this is typically caused by the current user not having access to the \"\n                                                + \"data requested or the user not being logged in at all :: message=\" + se.getMessage(),\n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_FORBIDDEN);\n                                    } catch (EntityEncodingException e) {\n                                        // translate EEE into EE - internal server error\n                                        throw new EntityException(\"EntityEncodingException: Unable to handle \" + (output ? \"output\" : \"input\") + \" request for format  \"+view.getFormat()+\" for this path (\" \n                                                + path + \") for prefix (\" + prefix + \") for entity (\" + view.getEntityReference() + \"), request url (\" + view.getOriginalEntityUrl() + \"): \" + e.getMessage(),\n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_INTERNAL_SERVER_ERROR);        \n                                    } catch (IllegalArgumentException e) {\n                                        // translate IAE into EE - bad request\n                                        throw new EntityException(\"IllegalArgumentException: Unable to handle \" + (output ? \"output\" : \"input\") + \" request for format  \"+view.getFormat()+\" for this path (\" \n                                                + path + \") for prefix (\" + prefix + \") for entity (\" + view.getEntityReference() + \"), request url (\" + view.getOriginalEntityUrl() + \"): \" + e.getMessage(),\n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_BAD_REQUEST);        \n                                    } catch (IllegalStateException e) {\n                                        // translate ISE into EE - internal server error\n                                        throw new EntityException(\"IllegalStateException: Unable to handle \" + (output ? \"output\" : \"input\") + \" request for format  \"+view.getFormat()+\" for this path (\" \n                                                + path + \") for prefix (\" + prefix + \") for entity (\" + view.getEntityReference() + \"), request url (\" + view.getOriginalEntityUrl() + \"): \" + e.getMessage(),\n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n                                    }\n                                }\n    \n                                if (! handled) {\n                                    // default handling, send to the access provider if there is one (if none this will throw EntityException)\n                                    try {\n                                        boolean accessProviderExists = handleAccessProvider(view, req, res);\n                                        if (!accessProviderExists) {\n                                            if (formatInvalidFailure) {\n                                                // trigger the format \n                                                throw new FormatUnsupportedException(\"Nothing (AP and internal) available to handle the requested format\", view.getEntityReference()+\"\", view.getFormat());\n                                            }\n                                            String message = \"Access Provider: Attempted to access an entity URL path (\"\n                                                + view + \") using method (\"+view.getMethod()+\") for an entity (\" + view.getEntityReference() \n                                                + \") and view (\"+view.getViewKey()+\") when there is no \" \n                                                + \"access provider to handle the request for prefix (\" + view.getEntityReference().getPrefix() + \")\";\n                                            throw new EntityException( message, view.toString(), HttpServletResponse.SC_METHOD_NOT_ALLOWED );\n                                        }\n                                    } catch (FormatUnsupportedException e) {\n                                        // TODO add in the methods \"allowed\" header?\n                                        throw new EntityException( \"AccessProvider: Method/Format unsupported: Will not handle \" + (output ? \"output\" : \"input\") + \" request for format  \"+view.getFormat()+\" for this path (\" \n                                                + path + \") for prefix (\" + prefix + \") for entity (\" + view.getEntityReference() + \"), request url (\" + view.getOriginalEntityUrl() + \")\",\n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_NOT_ACCEPTABLE );\n                                    }\n                                }\n                            }\n                        }\n                        handledReference = view.getEntityReference().toString();\n                        requestStorage.setRequestValue(RequestStorage.ReservedKeys._requestEntityReference.name(), handledReference);\n\n                        // handle the after interceptor\n                        if (interceptor != null) {\n                            interceptor.after(view, req, res);\n                        }\n                    } finally {\n                        // clear the request data no matter what happens\n                        requestStorage.reset();\n                        requestGetter.setRequest(null);\n                        requestGetter.setResponse(null);\n                    }\n                }\n            }\n        }\n        return handledReference;\n    }","commit_id":"999baa68f6a2263f913d52dc0bd49beef99b6b59","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n     * This will set the response mime type correctly based on the format constant,\n     * also sets the response encoding to UTF_8\n     * @param format the format constant, example {@link Formats#XML}\n     * @param res the current outgoing response\n     */\n    public static void setResponseEncoding(String format, HttpServletResponse res) {\n        String encoding;\n        if (Formats.XML.equals(format)) {\n            encoding = Formats.XML_MIME_TYPE;\n        } else if (Formats.HTML.equals(format)) {\n            encoding = Formats.HTML_MIME_TYPE;\n        } else if (Formats.FORM.equals(format)) {\n            encoding = Formats.FORM_MIME_TYPE;\n        } else if (Formats.JSON.equals(format)) {\n            encoding = Formats.JSON_MIME_TYPE;\n        } else if (Formats.RSS.equals(format)) {\n            encoding = Formats.RSS_MIME_TYPE;                        \n        } else if (Formats.ATOM.equals(format)) {\n            encoding = Formats.ATOM_MIME_TYPE;                        \n        } else {\n            encoding = Formats.TXT_MIME_TYPE;\n        }\n        res.setContentType(encoding);\n        res.setCharacterEncoding(Formats.UTF_8);\n    }","id":65701,"modified_method":"/**\n     * This will set the response mime type correctly based on the format constant,\n     * also sets the response encoding to UTF_8\n     * @param format the format constant, example {@link Formats#XML}\n     * @param res the current outgoing response\n     */\n    public static void setResponseEncoding(String format, HttpServletResponse res) {\n        String encoding = Formats.TXT_MIME_TYPE;\n        if (format != null) {\n            String mimeType = formatToMimeType.get(format);\n            if (mimeType != null) {\n                encoding = mimeType;\n            }\n        }\n        res.setContentType(encoding);\n        res.setCharacterEncoding(Formats.UTF_8);\n    }","commit_id":"999baa68f6a2263f913d52dc0bd49beef99b6b59","url":"https://github.com/sakaiproject/sakai"},{"original_method":"private void saveSignature(\n            @NotNull CallableMemberDescriptor callable,\n            @NotNull ProtoBuf.Callable.Builder proto,\n            @NotNull NameTable nameTable\n    ) {\n        SignatureSerializer signatureSerializer = new SignatureSerializer(nameTable);\n        if (callable instanceof FunctionDescriptor) {\n            Method method = bindings.get(METHOD_FOR_FUNCTION, (FunctionDescriptor) callable);\n            if (method != null) {\n                proto.setExtension(JavaProtoBuf.methodSignature, signatureSerializer.methodSignature(method));\n            }\n        }\n        else if (callable instanceof PropertyDescriptor) {\n            PropertyDescriptor property = (PropertyDescriptor) callable;\n\n            PropertyGetterDescriptor getter = property.getGetter();\n            PropertySetterDescriptor setter = property.getSetter();\n            Method getterMethod = getter == null ? null : bindings.get(METHOD_FOR_FUNCTION, getter);\n            Method setterMethod = setter == null ? null : bindings.get(METHOD_FOR_FUNCTION, setter);\n\n            Pair<Type, String> field = bindings.get(FIELD_FOR_PROPERTY, property);\n            Type fieldType;\n            String fieldName;\n            boolean isStaticInOuter;\n            Method syntheticMethod;\n            if (field != null) {\n                fieldType = field.first;\n                fieldName = field.second;\n                isStaticInOuter = bindings.get(STATIC_FIELD_IN_OUTER_CLASS, property);\n                syntheticMethod = null;\n            }\n            else {\n                fieldType = null;\n                fieldName = null;\n                isStaticInOuter = false;\n                syntheticMethod = bindings.get(SYNTHETIC_METHOD_FOR_PROPERTY, property);\n            }\n\n            JavaProtoBuf.JavaPropertySignature signature;\n            if (callable instanceof DeserializedPropertyDescriptor) {\n                DeserializedPropertyDescriptor deserializedCallable = (DeserializedPropertyDescriptor) callable;\n                signature = signatureSerializer.copyPropertySignature(\n                        deserializedCallable.getProto().getExtension(JavaProtoBuf.propertySignature),\n                        deserializedCallable.getNameResolver()\n                );\n            }\n            else {\n                signature = signatureSerializer\n                        .propertySignature(fieldType, fieldName, isStaticInOuter, syntheticMethod, getterMethod, setterMethod);\n            }\n            proto.setExtension(JavaProtoBuf.propertySignature, signature);\n        }\n    }","id":65702,"modified_method":"private void saveSignature(\n            @NotNull CallableMemberDescriptor callable,\n            @NotNull ProtoBuf.Callable.Builder proto,\n            @NotNull NameTable nameTable\n    ) {\n        SignatureSerializer signatureSerializer = new SignatureSerializer(nameTable);\n        if (callable instanceof FunctionDescriptor) {\n            JavaProtoBuf.JavaMethodSignature signature;\n            if (callable instanceof DeserializedSimpleFunctionDescriptor) {\n                DeserializedSimpleFunctionDescriptor deserialized = (DeserializedSimpleFunctionDescriptor) callable;\n                signature = signatureSerializer.copyMethodSignature(\n                        deserialized.getProto().getExtension(JavaProtoBuf.methodSignature), deserialized.getNameResolver());\n            }\n            else {\n                Method method = bindings.get(METHOD_FOR_FUNCTION, (FunctionDescriptor) callable);\n                signature = method != null ? signatureSerializer.methodSignature(method) : null;\n            }\n            if (signature != null) {\n                proto.setExtension(JavaProtoBuf.methodSignature, signature);\n            }\n        }\n        else if (callable instanceof PropertyDescriptor) {\n            PropertyDescriptor property = (PropertyDescriptor) callable;\n\n            PropertyGetterDescriptor getter = property.getGetter();\n            PropertySetterDescriptor setter = property.getSetter();\n            Method getterMethod = getter == null ? null : bindings.get(METHOD_FOR_FUNCTION, getter);\n            Method setterMethod = setter == null ? null : bindings.get(METHOD_FOR_FUNCTION, setter);\n\n            Pair<Type, String> field = bindings.get(FIELD_FOR_PROPERTY, property);\n            Type fieldType;\n            String fieldName;\n            boolean isStaticInOuter;\n            Method syntheticMethod;\n            if (field != null) {\n                fieldType = field.first;\n                fieldName = field.second;\n                isStaticInOuter = bindings.get(STATIC_FIELD_IN_OUTER_CLASS, property);\n                syntheticMethod = null;\n            }\n            else {\n                fieldType = null;\n                fieldName = null;\n                isStaticInOuter = false;\n                syntheticMethod = bindings.get(SYNTHETIC_METHOD_FOR_PROPERTY, property);\n            }\n\n            JavaProtoBuf.JavaPropertySignature signature;\n            if (callable instanceof DeserializedPropertyDescriptor) {\n                DeserializedPropertyDescriptor deserializedCallable = (DeserializedPropertyDescriptor) callable;\n                signature = signatureSerializer.copyPropertySignature(\n                        deserializedCallable.getProto().getExtension(JavaProtoBuf.propertySignature),\n                        deserializedCallable.getNameResolver()\n                );\n            }\n            else {\n                signature = signatureSerializer\n                        .propertySignature(fieldType, fieldName, isStaticInOuter, syntheticMethod, getterMethod, setterMethod);\n            }\n            proto.setExtension(JavaProtoBuf.propertySignature, signature);\n        }\n    }","commit_id":"9f8a16fb1a6c2a4942fb4a18854a5fb13aa39d4a","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void generateDelegationsToAlreadyCompiled(Map<CallableMemberDescriptor, Runnable> generateCallableMemberTasks) {\n        for (final DeserializedCallableMemberDescriptor member : getAlreadyCompiledCallables()) {\n            generateCallableMemberTasks.put(member, new Runnable() {\n                @Override\n                public void run() {\n                    FieldOwnerContext context = CodegenContext.STATIC.intoPackageFacade(\n                            Type.getObjectType(getPackagePartInternalName(member)),\n                            compiledPackageFragment);\n\n                    FunctionCodegen functionCodegen = new FunctionCodegen(\n                            context,\n                            v.getClassBuilder(),\n                            state,\n                            getMemberCodegen(context)\n                    );\n\n                    if (member instanceof DeserializedSimpleFunctionDescriptor) {\n                        DeserializedSimpleFunctionDescriptor function = (DeserializedSimpleFunctionDescriptor) member;\n                        JvmMethodSignature signature = typeMapper.mapSignature(function, OwnerKind.PACKAGE);\n                        functionCodegen.generateMethod(null, signature, function,\n                                                       new FunctionGenerationStrategy() {\n                                                           @Override\n                                                           public void generateBody(\n                                                                   @NotNull MethodVisitor mv,\n                                                                   @NotNull JvmMethodSignature signature,\n                                                                   @NotNull MethodContext context,\n                                                                   @Nullable MemberCodegen parentCodegen\n                                                           ) {\n                                                               throw new IllegalStateException(\"shouldn't be called\");\n                                                           }\n                                                       });\n\n                        v.getClassBuilder().getSerializationBindings().put(METHOD_FOR_FUNCTION, function, signature.getAsmMethod());\n                    }\n                    else if (member instanceof DeserializedPropertyDescriptor) {\n                        PropertyCodegen propertyCodegen = new PropertyCodegen(\n                                context, v.getClassBuilder(), functionCodegen, getMemberCodegen(context));\n                        propertyCodegen.generateInPackageFacade((DeserializedPropertyDescriptor) member);\n                    }\n                    else {\n                        throw new IllegalStateException(\"Unexpected member: \" + member);\n                    }\n                }\n            });\n        }\n    }","id":65703,"modified_method":"private void generateDelegationsToAlreadyCompiled(Map<CallableMemberDescriptor, Runnable> generateCallableMemberTasks) {\n        for (final DeserializedCallableMemberDescriptor member : getAlreadyCompiledCallables()) {\n            generateCallableMemberTasks.put(member, new Runnable() {\n                @Override\n                public void run() {\n                    FieldOwnerContext context = CodegenContext.STATIC.intoPackageFacade(\n                            Type.getObjectType(getPackagePartInternalName(member)),\n                            compiledPackageFragment);\n\n                    FunctionCodegen functionCodegen = new FunctionCodegen(\n                            context,\n                            v.getClassBuilder(),\n                            state,\n                            getMemberCodegen(context)\n                    );\n\n                    if (member instanceof DeserializedSimpleFunctionDescriptor) {\n                        DeserializedSimpleFunctionDescriptor function = (DeserializedSimpleFunctionDescriptor) member;\n                        JvmMethodSignature signature = typeMapper.mapSignature(function, OwnerKind.PACKAGE);\n                        functionCodegen.generateMethod(null, signature, function,\n                                                       new FunctionGenerationStrategy() {\n                                                           @Override\n                                                           public void generateBody(\n                                                                   @NotNull MethodVisitor mv,\n                                                                   @NotNull JvmMethodSignature signature,\n                                                                   @NotNull MethodContext context,\n                                                                   @Nullable MemberCodegen parentCodegen\n                                                           ) {\n                                                               throw new IllegalStateException(\"shouldn't be called\");\n                                                           }\n                                                       }\n                        );\n                    }\n                    else if (member instanceof DeserializedPropertyDescriptor) {\n                        PropertyCodegen propertyCodegen = new PropertyCodegen(\n                                context, v.getClassBuilder(), functionCodegen, getMemberCodegen(context));\n                        propertyCodegen.generateInPackageFacade((DeserializedPropertyDescriptor) member);\n                    }\n                    else {\n                        throw new IllegalStateException(\"Unexpected member: \" + member);\n                    }\n                }\n            });\n        }\n    }","commit_id":"9f8a16fb1a6c2a4942fb4a18854a5fb13aa39d4a","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public BusApplicationContext(URL[] url, boolean include, ApplicationContext parent) {\n        super(new String[0], false, parent);\n        cfgFileURLs = url;\n        includeDefaults = include;\n        try {\n            AccessController.doPrivileged(new PrivilegedExceptionAction<Boolean>() {\n                public Boolean run() throws Exception {\n                    refresh();\n                    return Boolean.TRUE;\n                }\n                \n            });\n        } catch (PrivilegedActionException e) {\n            if (e.getException() instanceof RuntimeException) {\n                throw (RuntimeException)e.getException();\n            }\n            throw new Fault(e);\n        }\n    }","id":65704,"modified_method":"public BusApplicationContext(URL[] url, boolean include,\n                                 ApplicationContext parent) {\n        this(url, include, parent, null);\n    }","commit_id":"31a9e92ac26fec2a899bc5d6f9738656ae352970","url":"https://github.com/apache/cxf"},{"original_method":"public BusApplicationContext(String[] cf, boolean include, ApplicationContext parent) {\n        super(new String[0], false, parent);\n        cfgFiles = cf;\n        includeDefaults = include;\n        try {\n            AccessController.doPrivileged(new PrivilegedExceptionAction<Boolean>() {\n                public Boolean run() throws Exception {\n                    refresh();\n                    return Boolean.TRUE;\n                }\n                \n            });\n        } catch (PrivilegedActionException e) {\n            if (e.getException() instanceof RuntimeException) {\n                throw (RuntimeException)e.getException();\n            }\n            throw new Fault(e);\n        }\n    }","id":65705,"modified_method":"public BusApplicationContext(String[] cf, boolean include, ApplicationContext parent) {\n        this(cf, include, parent, null);\n    }","commit_id":"31a9e92ac26fec2a899bc5d6f9738656ae352970","url":"https://github.com/apache/cxf"},{"original_method":"public BusApplicationContext(URL url, boolean include, ApplicationContext parent) {\n        this(new URL[] {url}, include, parent);\n    }","id":65706,"modified_method":"public BusApplicationContext(URL url, boolean include, ApplicationContext parent) {\n        this(new URL[] {url}, include, parent, null);\n    }","commit_id":"31a9e92ac26fec2a899bc5d6f9738656ae352970","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws IOException {\n            // Create a new XmlBeanDefinitionReader for the given BeanFactory.\n        XmlBeanDefinitionReader beanDefinitionReader = \n            new ControlledValidationXmlBeanDefinitionReader(beanFactory);\n        \n        // Configure the bean definition reader with this context's\n        // resource loading environment.\n        beanDefinitionReader.setResourceLoader(this);\n        beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));\n\n        // Allow a subclass to provide custom initialization of the reader,\n        // then proceed with actually loading the bean definitions.\n        initBeanDefinitionReader(beanDefinitionReader);\n        loadBeanDefinitions(beanDefinitionReader);\n    }","id":65707,"modified_method":"@Override\n    protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws IOException {\n            // Create a new XmlBeanDefinitionReader for the given BeanFactory.\n        XmlBeanDefinitionReader beanDefinitionReader = \n            new ControlledValidationXmlBeanDefinitionReader(beanFactory);\n        beanDefinitionReader.setNamespaceHandlerResolver(nsHandlerResolver);\n        \n        // Configure the bean definition reader with this context's\n        // resource loading environment.\n        beanDefinitionReader.setResourceLoader(this);\n        beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));\n\n        // Allow a subclass to provide custom initialization of the reader,\n        // then proceed with actually loading the bean definitions.\n        initBeanDefinitionReader(beanDefinitionReader);\n        loadBeanDefinitions(beanDefinitionReader);\n    }","commit_id":"31a9e92ac26fec2a899bc5d6f9738656ae352970","url":"https://github.com/apache/cxf"},{"original_method":"public SpringBeanLocator(ApplicationContext ctx, Bus bus) {\n        context = ctx;\n        orig = bus.getExtension(ConfiguredBeanLocator.class);\n        if (orig instanceof ExtensionManagerImpl) {\n            List<String> names = new ArrayList<String>();\n            for (String s : ctx.getBeanDefinitionNames()) {\n                ConfigurableApplicationContext ctxt = (ConfigurableApplicationContext)context;\n                BeanDefinition def = ctxt.getBeanFactory().getBeanDefinition(s);\n                String cn =  def.getBeanClassName();\n                if (OldSpringSupport.class.getName().equals(cn)) {\n                    passThroughs.add(s);\n                    for (String s2 : ctx.getAliases(s)) {\n                        passThroughs.add(s2);\n                    }\n                } else {\n                    names.add(s);\n                    for (String s2 : ctx.getAliases(s)) {\n                        names.add(s2);\n                    }\n                }\n            }\n            \n            ((ExtensionManagerImpl)orig).removeBeansOfNames(names);\n        }\n        \n        loadOSGIContext(bus);\n    }","id":65708,"modified_method":"public SpringBeanLocator(ApplicationContext ctx, Bus bus) {\n        context = ctx;\n        if (bus != null) {\n            orig = bus.getExtension(ConfiguredBeanLocator.class);\n            if (orig instanceof ExtensionManagerImpl) {\n                List<String> names = new ArrayList<String>();\n                for (String s : ctx.getBeanDefinitionNames()) {\n                    ConfigurableApplicationContext ctxt = (ConfigurableApplicationContext)context;\n                    BeanDefinition def = ctxt.getBeanFactory().getBeanDefinition(s);\n                    String cn =  def.getBeanClassName();\n                    if (OldSpringSupport.class.getName().equals(cn)) {\n                        passThroughs.add(s);\n                        for (String s2 : ctx.getAliases(s)) {\n                            passThroughs.add(s2);\n                        }\n                    } else {\n                        names.add(s);\n                        for (String s2 : ctx.getAliases(s)) {\n                            names.add(s2);\n                        }\n                    }\n                }\n                \n                ((ExtensionManagerImpl)orig).removeBeansOfNames(names);\n            }\n        }\n        \n        loadOSGIContext(bus);\n    }","commit_id":"31a9e92ac26fec2a899bc5d6f9738656ae352970","url":"https://github.com/apache/cxf"},{"original_method":"private void loadOSGIContext(Bus b) {\n        try {\n            //use a little reflection to allow this to work without the spring-dm jars\n            //for the non-osgi cases\n            Method m = context.getClass().getMethod(\"getBundleContext\");\n            bundleContext = m.invoke(context);\n            @SuppressWarnings(\"unchecked\")\n            Class<Object> cls = (Class<Object>)m.getReturnType();\n            b.setExtension(bundleContext, cls);\n        } catch (Throwable t) {\n            //ignore\n            osgi = false;\n        }\n    }","id":65709,"modified_method":"private void loadOSGIContext(Bus b) {\n        try {\n            //use a little reflection to allow this to work without the spring-dm jars\n            //for the non-osgi cases\n            Method m = context.getClass().getMethod(\"getBundleContext\");\n            bundleContext = m.invoke(context);\n            if (b != null) {\n                @SuppressWarnings(\"unchecked\")\n                Class<Object> cls = (Class<Object>)m.getReturnType();\n                b.setExtension(bundleContext, cls);\n            }\n        } catch (Throwable t) {\n            //ignore\n            osgi = false;\n        }\n    }","commit_id":"31a9e92ac26fec2a899bc5d6f9738656ae352970","url":"https://github.com/apache/cxf"},{"original_method":"private Bus finishCreatingBus(BusApplicationContext bac) {\n        final Bus bus = (Bus)bac.getBean(Bus.DEFAULT_BUS_ID);\n\n        bus.setExtension(bac, BusApplicationContext.class);\n\n        possiblySetDefaultBus(bus);\n        \n        initializeBus(bus);        \n        \n        registerApplicationContextLifeCycleListener(bus, bac);\n        \n        if (bus instanceof SpringBus && defaultBusNotExists()) {\n            ((SpringBus)bus).setCloseContext(true);\n        }\n        return bus;\n    }","id":65710,"modified_method":"protected Bus finishCreatingBus(ConfigurableApplicationContext bac) {\n        final Bus bus = (Bus)bac.getBean(Bus.DEFAULT_BUS_ID);\n\n        bus.setExtension(bac, ApplicationContext.class);\n        if (bac instanceof BusApplicationContext) {\n            bus.setExtension((BusApplicationContext)bac, BusApplicationContext.class);\n        }\n        possiblySetDefaultBus(bus);\n        \n        initializeBus(bus);        \n        \n        registerApplicationContextLifeCycleListener(bus, bac);\n        \n        if (bus instanceof SpringBus && defaultBusNotExists()) {\n            ((SpringBus)bus).setCloseContext(true);\n        }\n        return bus;\n    }","commit_id":"31a9e92ac26fec2a899bc5d6f9738656ae352970","url":"https://github.com/apache/cxf"},{"original_method":"public Bus createBus(URL[] urls, boolean includeDefaults) {\n        try {      \n            return finishCreatingBus(new BusApplicationContext(urls, includeDefaults, context));\n        } catch (BeansException ex) {\n            LogUtils.log(LOG, Level.WARNING, \"APP_CONTEXT_CREATION_FAILED_MSG\", ex, (Object[])null);\n            throw new RuntimeException(ex);\n        }\n    }","id":65711,"modified_method":"public Bus createBus(URL[] urls, boolean includeDefaults) {\n        try {      \n            return finishCreatingBus(createAppContext(urls, includeDefaults));\n        } catch (BeansException ex) {\n            LogUtils.log(LOG, Level.WARNING, \"APP_CONTEXT_CREATION_FAILED_MSG\", ex, (Object[])null);\n            throw new RuntimeException(ex);\n        }\n    }","commit_id":"31a9e92ac26fec2a899bc5d6f9738656ae352970","url":"https://github.com/apache/cxf"},{"original_method":"public SpringBusFactory(ApplicationContext context) {\n        this.context = context;\n    }","id":65712,"modified_method":"public SpringBusFactory(ApplicationContext context) {\n        this.context = context;\n        this.resolver = tryFindNamespaceHandler(context);\n    }","commit_id":"31a9e92ac26fec2a899bc5d6f9738656ae352970","url":"https://github.com/apache/cxf"},{"original_method":"private BusApplicationContext createApplicationContext(String cfgFiles[], boolean includeDefaults) {\n        try {      \n            return new BusApplicationContext(cfgFiles, includeDefaults, context);\n        } catch (BeansException ex) {\n            LogUtils.log(LOG, Level.WARNING, \"INITIAL_APP_CONTEXT_CREATION_FAILED_MSG\", ex, (Object[])null);\n            ClassLoader contextLoader = Thread.currentThread().getContextClassLoader();\n            if (contextLoader != BusApplicationContext.class.getClassLoader()) {\n                Thread.currentThread().setContextClassLoader(\n                    BusApplicationContext.class.getClassLoader());\n                try {\n                    return new BusApplicationContext(cfgFiles, includeDefaults, context);        \n                } finally {\n                    Thread.currentThread().setContextClassLoader(contextLoader);\n                }\n            } else {\n                throw ex;\n            }\n        }\n    }","id":65713,"modified_method":"protected ConfigurableApplicationContext createApplicationContext(String cfgFiles[], boolean includeDefaults) {\n        try {      \n            return new BusApplicationContext(cfgFiles, includeDefaults, context, resolver);\n        } catch (BeansException ex) {\n            LogUtils.log(LOG, Level.WARNING, \"INITIAL_APP_CONTEXT_CREATION_FAILED_MSG\", ex, (Object[])null);\n            ClassLoader contextLoader = Thread.currentThread().getContextClassLoader();\n            if (contextLoader != BusApplicationContext.class.getClassLoader()) {\n                Thread.currentThread().setContextClassLoader(\n                    BusApplicationContext.class.getClassLoader());\n                try {\n                    return new BusApplicationContext(cfgFiles, includeDefaults, context);        \n                } finally {\n                    Thread.currentThread().setContextClassLoader(contextLoader);\n                }\n            } else {\n                throw ex;\n            }\n        }\n    }","commit_id":"31a9e92ac26fec2a899bc5d6f9738656ae352970","url":"https://github.com/apache/cxf"},{"original_method":"void registerApplicationContextLifeCycleListener(Bus bus, BusApplicationContext bac) {\n        BusLifeCycleManager lm = bus.getExtension(BusLifeCycleManager.class);\n        if (null != lm) {\n            lm.registerLifeCycleListener(new BusApplicationContextLifeCycleListener(bac));\n        }\n    }","id":65714,"modified_method":"void registerApplicationContextLifeCycleListener(Bus bus, ConfigurableApplicationContext bac) {\n        BusLifeCycleManager lm = bus.getExtension(BusLifeCycleManager.class);\n        if (null != lm) {\n            lm.registerLifeCycleListener(new BusApplicationContextLifeCycleListener(bac));\n        }\n    }","commit_id":"31a9e92ac26fec2a899bc5d6f9738656ae352970","url":"https://github.com/apache/cxf"},{"original_method":"BusApplicationContextLifeCycleListener(BusApplicationContext b) {\n            bac = b;\n        }","id":65715,"modified_method":"BusApplicationContextLifeCycleListener(ConfigurableApplicationContext b) {\n            bac = b;\n        }","commit_id":"31a9e92ac26fec2a899bc5d6f9738656ae352970","url":"https://github.com/apache/cxf"},{"original_method":"public void testSearchUserQuotes() throws Exception {\n\t\tselenium.selectWindow(\"null\");\n\t\tselenium.selectFrame(\"relative=top\");\n\t\tselenium.open(\"/web/guest/home/\");\n\t\tselenium.waitForVisible(\"link=Search Test Page\");\n\t\tselenium.clickAt(\"link=Search Test Page\",\n\t\t\tRuntimeVariables.replace(\"Search Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.waitForVisible(\"//input[@name='_3_keywords']\");\n\t\tselenium.type(\"//input[@name='_3_keywords']\",\n\t\t\tRuntimeVariables.replace(\"\\\"selenium01\\\"\"));\n\t\tselenium.clickAt(\"//input[@type='image']\",\n\t\t\tRuntimeVariables.replace(\"Search\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tassertEquals(RuntimeVariables.replace(\"selen01 lenn nium01\"),\n\t\t\tselenium.getText(\"//span[@class='asset-entry-title']/a\"));\n\t}","id":65716,"modified_method":"public void testSearchUserQuotes() throws Exception {\n\t\tselenium.selectWindow(\"null\");\n\t\tselenium.selectFrame(\"relative=top\");\n\t\tselenium.open(\"/web/guest/home/\");\n\t\tselenium.clickAt(\"link=Search Test Page\",\n\t\t\tRuntimeVariables.replace(\"Search Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.waitForVisible(\"//input[@name='_3_keywords']\");\n\t\tselenium.type(\"//input[@name='_3_keywords']\",\n\t\t\tRuntimeVariables.replace(\"\\\"usersn\\\"\"));\n\t\tselenium.clickAt(\"//input[@type='image']\",\n\t\t\tRuntimeVariables.replace(\"Search\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tassertEquals(RuntimeVariables.replace(\"userfn userln\"),\n\t\t\tselenium.getText(\"//span[@class='asset-entry-title']/a\"));\n\t\tassertEquals(RuntimeVariables.replace(\"User\"),\n\t\t\tselenium.getText(\"//span[@class='asset-entry-type']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Showing 1 - 1.\"),\n\t\t\tselenium.getText(\"//div[@class='search-results']\"));\n\t\tselenium.type(\"//input[@name='_3_keywords']\",\n\t\t\tRuntimeVariables.replace(\"\\\"userfn\\\"\"));\n\t\tselenium.clickAt(\"//input[@type='image']\",\n\t\t\tRuntimeVariables.replace(\"Search\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tassertEquals(RuntimeVariables.replace(\"userfn userln\"),\n\t\t\tselenium.getText(\"//span[@class='asset-entry-title']/a\"));\n\t\tassertEquals(RuntimeVariables.replace(\"User\"),\n\t\t\tselenium.getText(\"//span[@class='asset-entry-type']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Showing 1 - 1.\"),\n\t\t\tselenium.getText(\"//div[@class='search-results']\"));\n\t}","commit_id":"e8029e13c4f8d53bf5e6eff18ddfd6f94b219770","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testSearchUser() throws Exception {\n\t\tselenium.selectWindow(\"null\");\n\t\tselenium.selectFrame(\"relative=top\");\n\t\tselenium.open(\"/web/guest/home/\");\n\t\tselenium.waitForVisible(\"link=Search Test Page\");\n\t\tselenium.clickAt(\"link=Search Test Page\",\n\t\t\tRuntimeVariables.replace(\"Search Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.waitForVisible(\"//input[@name='_3_keywords']\");\n\t\tselenium.type(\"//input[@name='_3_keywords']\",\n\t\t\tRuntimeVariables.replace(\"selenium*\"));\n\t\tselenium.clickAt(\"//input[@type='image']\",\n\t\t\tRuntimeVariables.replace(\"Search\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tassertEquals(RuntimeVariables.replace(\"selen01 lenn nium01\"),\n\t\t\tselenium.getText(\"//span[@class='asset-entry-title']/a\"));\n\t}","id":65717,"modified_method":"public void testSearchUser() throws Exception {\n\t\tselenium.selectWindow(\"null\");\n\t\tselenium.selectFrame(\"relative=top\");\n\t\tselenium.open(\"/web/guest/home/\");\n\t\tselenium.clickAt(\"link=Search Test Page\",\n\t\t\tRuntimeVariables.replace(\"Search Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.waitForVisible(\"//input[@name='_3_keywords']\");\n\t\tselenium.type(\"//input[@name='_3_keywords']\",\n\t\t\tRuntimeVariables.replace(\"users*\"));\n\t\tselenium.clickAt(\"//input[@type='image']\",\n\t\t\tRuntimeVariables.replace(\"Search\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tassertEquals(RuntimeVariables.replace(\"userfn userln\"),\n\t\t\tselenium.getText(\"//span[@class='asset-entry-title']/a\"));\n\t\tassertEquals(RuntimeVariables.replace(\"User\"),\n\t\t\tselenium.getText(\"//span[@class='asset-entry-type']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Showing 1 - 1.\"),\n\t\t\tselenium.getText(\"//div[@class='search-results']\"));\n\t\tselenium.type(\"//input[@name='_3_keywords']\",\n\t\t\tRuntimeVariables.replace(\"userf*\"));\n\t\tselenium.clickAt(\"//input[@type='image']\",\n\t\t\tRuntimeVariables.replace(\"Search\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tassertEquals(RuntimeVariables.replace(\"userfn userln\"),\n\t\t\tselenium.getText(\"//span[@class='asset-entry-title']/a\"));\n\t\tassertEquals(RuntimeVariables.replace(\"User\"),\n\t\t\tselenium.getText(\"//span[@class='asset-entry-type']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Showing 1 - 1.\"),\n\t\t\tselenium.getText(\"//div[@class='search-results']\"));\n\t}","commit_id":"e8029e13c4f8d53bf5e6eff18ddfd6f94b219770","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Test suite() {\n\t\tTestSuite testSuite = new TestSuite();\n\t\ttestSuite.addTestSuite(AddPageSearchTest.class);\n\t\ttestSuite.addTestSuite(AddPortletSearchTest.class);\n\t\ttestSuite.addTestSuite(AddUserTest.class);\n\t\ttestSuite.addTestSuite(SearchUserTest.class);\n\t\ttestSuite.addTestSuite(SearchUserQuotesTest.class);\n\t\ttestSuite.addTestSuite(TearDownPageTest.class);\n\n\t\treturn testSuite;\n\t}","id":65718,"modified_method":"public static Test suite() {\n\t\tTestSuite testSuite = new TestSuite();\n\t\ttestSuite.addTestSuite(AddPageSearchTest.class);\n\t\ttestSuite.addTestSuite(AddPortletSearchTest.class);\n\t\ttestSuite.addTestSuite(AddUserTest.class);\n\t\ttestSuite.addTestSuite(EditUserPasswordTest.class);\n\t\ttestSuite.addTestSuite(SearchUserTest.class);\n\t\ttestSuite.addTestSuite(SearchUserQuotesTest.class);\n\t\ttestSuite.addTestSuite(TearDownUserTest.class);\n\t\ttestSuite.addTestSuite(TearDownPageTest.class);\n\n\t\treturn testSuite;\n\t}","commit_id":"e8029e13c4f8d53bf5e6eff18ddfd6f94b219770","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Implements the <tt>AdHocChatRoomMessageListener.messageReceived<\/tt>\n     * method.\n     * <br>\n     * @param evt the <tt>AdHocChatRoomMessageReceivedEvent<\/tt> that notified\n     * us\n     */\n    public void messageReceived(AdHocChatRoomMessageReceivedEvent evt)\n    {\n        try\n        {\n            AdHocChatRoom sourceChatRoom = evt.getSourceChatRoom();\n            Contact sourceParticipant = evt.getSourceChatRoomParticipant();\n\n            // Fire notification\n            boolean fireChatNotification;\n\n            String nickname = sourceChatRoom.getName();\n            String messageContent = evt.getMessage().getContent();\n\n            fireChatNotification =\n                (nickname == null)\n                    || messageContent.toLowerCase().contains(\n                            nickname.toLowerCase());\n\n            if (fireChatNotification)\n            {\n                String title\n                    = NotificationWiringActivator.getResources().getI18NString(\n                            \"service.gui.MSG_RECEIVED\",\n                            new String[] { sourceParticipant.getDisplayName() });\n\n                fireChatNotification(\n                    sourceChatRoom,\n                    INCOMING_MESSAGE,\n                    title,\n                    messageContent,\n                    evt.getMessage().getMessageUID());\n            }\n        }\n        catch(Throwable t)\n        {\n            logger.error(\"Error notifying for adhoc message received\", t);\n        }\n    }","id":65719,"modified_method":"/**\n     * Implements the <tt>AdHocChatRoomMessageListener.messageReceived<\/tt>\n     * method.\n     * <br>\n     * @param evt the <tt>AdHocChatRoomMessageReceivedEvent<\/tt> that notified\n     * us\n     */\n    public void messageReceived(AdHocChatRoomMessageReceivedEvent evt)\n    {\n        try\n        {\n            AdHocChatRoom sourceChatRoom = evt.getSourceChatRoom();\n            Contact sourceParticipant = evt.getSourceChatRoomParticipant();\n\n            // Fire notification\n            boolean fireChatNotification;\n\n            String nickname = sourceChatRoom.getName();\n            String messageContent = evt.getMessage().getContent();\n\n            fireChatNotification =\n                (nickname == null)\n                    || messageContent.toLowerCase().contains(\n                            nickname.toLowerCase());\n\n            if (fireChatNotification)\n            {\n                String title\n                    = NotificationWiringActivator.getResources().getI18NString(\n                            \"service.gui.MSG_RECEIVED\",\n                            new String[] { sourceParticipant.getDisplayName() });\n                final String htmlContent;\n                if (HTML_CONTENT_TYPE.equals(evt.getMessage().getContentType()))\n                {\n                    htmlContent = messageContent;\n                }\n                else\n                {\n                    htmlContent = StringEscapeUtils.escapeHtml4(messageContent);\n                }\n                fireChatNotification(\n                    sourceChatRoom,\n                    INCOMING_MESSAGE,\n                    title,\n                    htmlContent,\n                    evt.getMessage().getMessageUID());\n            }\n        }\n        catch(Throwable t)\n        {\n            logger.error(\"Error notifying for adhoc message received\", t);\n        }\n    }","commit_id":"baeca0ef7bdd708c92ca67724ba5cb9985bdb332","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     *  Fired on new messages.\n     * @param evt the <tt>MessageReceivedEvent<\/tt> containing\n     * details on the received message\n     */\n    public void messageReceived(MessageReceivedEvent evt)\n    {\n        try\n        {\n            // Fire notification\n            String title = NotificationWiringActivator.getResources().getI18NString(\n                \"service.gui.MSG_RECEIVED\",\n                new String[]{evt.getSourceContact().getDisplayName()});\n\n            fireChatNotification(\n                    evt.getSourceContact(),\n                    INCOMING_MESSAGE,\n                    title,\n                    evt.getSourceMessage().getContent(),\n                    evt.getSourceMessage().getMessageUID());\n        }\n        catch(Throwable t)\n        {\n            logger.error(\"Error notifying for message received\", t);\n        }\n    }","id":65720,"modified_method":"/**\n     *  Fired on new messages.\n     * @param evt the <tt>MessageReceivedEvent<\/tt> containing\n     * details on the received message\n     */\n    public void messageReceived(MessageReceivedEvent evt)\n    {\n        try\n        {\n            // Fire notification\n            String title = NotificationWiringActivator.getResources().getI18NString(\n                \"service.gui.MSG_RECEIVED\",\n                new String[]{evt.getSourceContact().getDisplayName()});\n\n            final Message sourceMsg = evt.getSourceMessage();\n            final String htmlContent;\n            if (HTML_CONTENT_TYPE.equals(sourceMsg.getContentType()))\n            {\n                htmlContent = sourceMsg.getContent();\n            }\n            else\n            {\n                htmlContent =\n                    StringEscapeUtils.escapeHtml4(sourceMsg.getContent());\n            }\n            fireChatNotification(\n                    evt.getSourceContact(),\n                    INCOMING_MESSAGE,\n                    title,\n                    htmlContent,\n                    sourceMsg.getMessageUID());\n        }\n        catch(Throwable t)\n        {\n            logger.error(\"Error notifying for message received\", t);\n        }\n    }","commit_id":"baeca0ef7bdd708c92ca67724ba5cb9985bdb332","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Fires a chat message notification for the given event type through the\n     * <tt>NotificationService<\/tt>.\n     *\n     * @param chatContact the chat contact to which the chat message corresponds;\n     * the chat contact could be a Contact or a ChatRoom.\n     * @param eventType the event type for which we fire a notification\n     * @param messageTitle the title of the message\n     * @param message the content of the message\n     */\n    public static void fireChatNotification(Object chatContact,\n                                            String eventType,\n                                            String messageTitle,\n                                            String message,\n                                            String messageUID)\n    {\n        NotificationService notificationService\n            = NotificationWiringActivator.getNotificationService();\n\n        if(notificationService == null)\n            return;\n\n        NotificationAction popupActionHandler = null;\n        UIService uiService = NotificationWiringActivator.getUIService();\n\n        Chat chatPanel = null;\n        byte[] contactIcon = null;\n        if (chatContact instanceof Contact)\n        {\n            Contact contact = (Contact) chatContact;\n\n            if(uiService != null)\n                chatPanel = uiService.getChat(contact, messageUID);\n\n            contactIcon = contact.getImage();\n            if(contactIcon == null)\n            {\n                contactIcon =\n                    NotificationWiringActivator.getImageLoaderService()\n                        .getImageBytes(DEFAULT_USER_PHOTO);\n            }\n        }\n        else if (chatContact instanceof ChatRoom)\n        {\n            ChatRoom chatRoom = (ChatRoom) chatContact;\n\n            // For system rooms we don't want to send notification events.\n            if (chatRoom.isSystem())\n                return;\n\n            if(uiService != null)\n                chatPanel = uiService.getChat(chatRoom);\n        }\n\n        if (chatPanel != null)\n        {\n            if (eventType.equals(INCOMING_MESSAGE)\n                    && chatPanel.isChatFocused())\n            {\n                popupActionHandler = notificationService\n                        .getEventNotificationAction(eventType,\n                                NotificationAction.ACTION_POPUP_MESSAGE);\n\n                popupActionHandler.setEnabled(false);\n            }\n        }\n\n        Map<String,Object> extras = new HashMap<String,Object>();\n\n        extras.put(\n                NotificationData.POPUP_MESSAGE_HANDLER_TAG_EXTRA,\n                chatContact);\n        notificationService.fireNotification(\n                eventType,\n                messageTitle,\n                message,\n                contactIcon,\n                extras);\n\n        if(popupActionHandler != null)\n            popupActionHandler.setEnabled(true);\n    }","id":65721,"modified_method":"/**\n     * Fires a chat message notification for the given event type through the\n     * <tt>NotificationService<\/tt>.\n     *\n     * @param chatContact the chat contact to which the chat message corresponds;\n     * the chat contact could be a Contact or a ChatRoom.\n     * @param eventType the event type for which we fire a notification\n     * @param messageTitle the title of the message\n     * @param message the content of the message\n     * @param messageUID the message UID\n     */\n    public static void fireChatNotification(Object chatContact,\n                                            String eventType,\n                                            String messageTitle,\n                                            String message,\n                                            String messageUID)\n    {\n        NotificationService notificationService\n            = NotificationWiringActivator.getNotificationService();\n\n        if(notificationService == null)\n            return;\n\n        NotificationAction popupActionHandler = null;\n        UIService uiService = NotificationWiringActivator.getUIService();\n\n        Chat chatPanel = null;\n        byte[] contactIcon = null;\n        if (chatContact instanceof Contact)\n        {\n            Contact contact = (Contact) chatContact;\n\n            if(uiService != null)\n                chatPanel = uiService.getChat(contact, messageUID);\n\n            contactIcon = contact.getImage();\n            if(contactIcon == null)\n            {\n                contactIcon =\n                    NotificationWiringActivator.getImageLoaderService()\n                        .getImageBytes(DEFAULT_USER_PHOTO);\n            }\n        }\n        else if (chatContact instanceof ChatRoom)\n        {\n            ChatRoom chatRoom = (ChatRoom) chatContact;\n\n            // For system rooms we don't want to send notification events.\n            if (chatRoom.isSystem())\n                return;\n\n            if(uiService != null)\n                chatPanel = uiService.getChat(chatRoom);\n        }\n\n        if (chatPanel != null)\n        {\n            if (eventType.equals(INCOMING_MESSAGE)\n                    && chatPanel.isChatFocused())\n            {\n                popupActionHandler = notificationService\n                        .getEventNotificationAction(eventType,\n                                NotificationAction.ACTION_POPUP_MESSAGE);\n\n                popupActionHandler.setEnabled(false);\n            }\n        }\n\n        Map<String,Object> extras = new HashMap<String,Object>();\n\n        extras.put(\n                NotificationData.POPUP_MESSAGE_HANDLER_TAG_EXTRA,\n                chatContact);\n        notificationService.fireNotification(\n                eventType,\n                messageTitle,\n                message,\n                contactIcon,\n                extras);\n\n        if(popupActionHandler != null)\n            popupActionHandler.setEnabled(true);\n    }","commit_id":"baeca0ef7bdd708c92ca67724ba5cb9985bdb332","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Implements the <tt>ChatRoomMessageListener.messageReceived<\/tt> method.\n     * <br>\n     * Obtains the corresponding <tt>ChatPanel<\/tt> and process the message\n     * there.\n     * @param evt the <tt>ChatRoomMessageReceivedEvent<\/tt> that notified us\n     * that a message has been received\n     */\n    public void messageReceived(ChatRoomMessageReceivedEvent evt)\n    {\n        try\n        {\n            ChatRoom sourceChatRoom = evt.getSourceChatRoom();\n            ChatRoomMember sourceMember = evt.getSourceChatRoomMember();\n\n            // Fire notification\n            boolean fireChatNotification;\n\n            String messageContent = evt.getMessage().getContent();\n\n            /*\n             * It is uncommon for IRC clients to display popup notifications for\n             * messages which are sent to public channels and which do not mention\n             * the nickname of the local user.\n             */\n            if (sourceChatRoom.isSystem()\n                || isPrivate(sourceChatRoom)\n                || (messageContent == null))\n                fireChatNotification = true;\n            else\n            {\n                String nickname = sourceChatRoom.getUserNickname();\n\n                int atIx = -1;\n\n                if(nickname != null)\n                    atIx = nickname.indexOf(\"@\");\n\n                fireChatNotification =\n                    (nickname == null)\n                        || messageContent.toLowerCase().contains(\n                            nickname.toLowerCase())\n                        || ((atIx == -1)? false : messageContent.toLowerCase()\n                            .contains(nickname.substring(0, atIx).toLowerCase()));\n            }\n\n            if (fireChatNotification)\n            {\n                String title\n                    = NotificationWiringActivator.getResources().getI18NString(\n                        \"service.gui.MSG_RECEIVED\",\n                        new String[] { sourceMember.getName() });\n\n                fireChatNotification(\n                        sourceChatRoom,\n                        INCOMING_MESSAGE,\n                        title,\n                        messageContent,\n                        evt.getMessage().getMessageUID());\n            }\n        }\n        catch(Throwable t)\n        {\n            logger.error(\"Error notifying for chat room message received\", t);\n        }\n    }","id":65722,"modified_method":"/**\n     * Implements the <tt>ChatRoomMessageListener.messageReceived<\/tt> method.\n     * <br>\n     * Obtains the corresponding <tt>ChatPanel<\/tt> and process the message\n     * there.\n     * @param evt the <tt>ChatRoomMessageReceivedEvent<\/tt> that notified us\n     * that a message has been received\n     */\n    public void messageReceived(ChatRoomMessageReceivedEvent evt)\n    {\n        try\n        {\n            ChatRoom sourceChatRoom = evt.getSourceChatRoom();\n            ChatRoomMember sourceMember = evt.getSourceChatRoomMember();\n\n            // Fire notification\n            boolean fireChatNotification;\n\n            final Message sourceMsg = evt.getMessage();\n            String messageContent = sourceMsg.getContent();\n\n            /*\n             * It is uncommon for IRC clients to display popup notifications for\n             * messages which are sent to public channels and which do not mention\n             * the nickname of the local user.\n             */\n            if (sourceChatRoom.isSystem()\n                || isPrivate(sourceChatRoom)\n                || (messageContent == null))\n                fireChatNotification = true;\n            else\n            {\n                String nickname = sourceChatRoom.getUserNickname();\n\n                int atIx = -1;\n\n                if(nickname != null)\n                    atIx = nickname.indexOf(\"@\");\n\n                fireChatNotification =\n                    (nickname == null)\n                        || messageContent.toLowerCase().contains(\n                            nickname.toLowerCase())\n                        || ((atIx == -1)? false : messageContent.toLowerCase()\n                            .contains(nickname.substring(0, atIx).toLowerCase()));\n            }\n\n            if (fireChatNotification)\n            {\n                String title\n                    = NotificationWiringActivator.getResources().getI18NString(\n                        \"service.gui.MSG_RECEIVED\",\n                        new String[] { sourceMember.getName() });\n                final String htmlContent;\n                if (HTML_CONTENT_TYPE.equals(sourceMsg.getContentType()))\n                {\n                    htmlContent = messageContent;\n                }\n                else\n                {\n                    htmlContent = StringEscapeUtils.escapeHtml4(messageContent);\n                }\n                fireChatNotification(\n                        sourceChatRoom,\n                        INCOMING_MESSAGE,\n                        title,\n                        htmlContent,\n                        sourceMsg.getMessageUID());\n            }\n        }\n        catch(Throwable t)\n        {\n            logger.error(\"Error notifying for chat room message received\", t);\n        }\n    }","commit_id":"baeca0ef7bdd708c92ca67724ba5cb9985bdb332","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates an instance of <tt>DatesPanel<\/tt>.\n     *\n     * @param historyWindow the parent <tt>HistoryWindow<\/tt>, where\n     * this panel is contained.\n     */\n    public DatesPanel(HistoryWindow historyWindow)\n    {\n        this.historyWindow = historyWindow;\n\n        this.setPreferredSize(new Dimension(100, 100));\n        this.setBorder(BorderFactory.createCompoundBorder(\n                BorderFactory.createEmptyBorder(3, 3, 3, 0),\n                SIPCommBorders.getBoldRoundBorder()));\n        this.setOpaque(false);\n\n        this.datesList.setModel(listModel);\n        this.datesList.setCellRenderer(new DatesListRenderer());\n        this.datesList.setFont(datesList.getFont().deriveFont(Font.BOLD));\n        this.datesList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n        this.datesList.addListSelectionListener(this);\n\n        JPanel listPanel = new TransparentPanel(new BorderLayout());\n        listPanel.add(datesList, BorderLayout.NORTH);\n\n        this.setViewportView(listPanel);\n        this.getVerticalScrollBar().setUnitIncrement(30);\n\n    }","id":65723,"modified_method":"/**\n     * Creates an instance of <tt>DatesPanel<\/tt>.\n     *\n     * @param historyWindow the parent <tt>HistoryWindow<\/tt>, where\n     * this panel is contained.\n     */\n    public DatesPanel(HistoryWindow historyWindow)\n    {\n        this.historyWindow = historyWindow;\n\n        this.setPreferredSize(new Dimension(100, 100));\n        this.setBorder(SIPCommBorders.getBoldRoundBorder());\n        this.setOpaque(false);\n\n        this.datesList.setModel(listModel);\n        this.datesList.setCellRenderer(new DatesListRenderer());\n        this.datesList.setFont(datesList.getFont().deriveFont(Font.BOLD));\n        this.datesList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n        this.datesList.addListSelectionListener(this);\n\n        JPanel listPanel = new TransparentPanel(new BorderLayout());\n        listPanel.add(datesList, BorderLayout.NORTH);\n\n        this.setViewportView(listPanel);\n        this.getVerticalScrollBar().setUnitIncrement(30);\n    }","commit_id":"3c53069887ddf95b1fb3d046390f3d4e1556e38e","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Implements MessageListener.messageReceived method in order to refresh the\n     * history when new message is received.\n     */\n    public void messageReceived(MessageReceivedEvent evt)\n    {\n        Contact sourceContact = evt.getSourceContact();\n\n        this.processMessage(sourceContact, evt.getTimestamp(),\n            Chat.INCOMING_MESSAGE,\n            evt.getSourceMessage().getContent(),\n            evt.getSourceMessage().getContentType());\n    }","id":65724,"modified_method":"/**\n     * Implements MessageListener.messageReceived method in order to refresh the\n     * history when new message is received.\n     */\n    public void messageReceived(MessageReceivedEvent evt)\n    {\n        Contact sourceContact = evt.getSourceContact();\n        Message sourceMessage = evt.getSourceMessage();\n\n        this.processMessage(\n                sourceContact,\n                evt.getTimestamp(),\n                Chat.INCOMING_MESSAGE,\n                sourceMessage.getContent(),\n                sourceMessage.getContentType());\n    }","commit_id":"3c53069887ddf95b1fb3d046390f3d4e1556e38e","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Implements MessageListener.messageDelivered method in order to refresh the\n     * history when new message is sent.\n     */\n    public void messageDelivered(MessageDeliveredEvent evt)\n    {\n        Contact destContact = evt.getDestinationContact();\n        \n        this.processMessage(destContact, evt.getTimestamp(),\n            Chat.OUTGOING_MESSAGE,\n            evt.getSourceMessage().getContent(),\n            evt.getSourceMessage().getContentType());\n    }","id":65725,"modified_method":"/**\n     * Implements MessageListener.messageDelivered method in order to refresh the\n     * history when new message is sent.\n     */\n    public void messageDelivered(MessageDeliveredEvent evt)\n    {\n        Contact destContact = evt.getDestinationContact();\n        Message sourceMessage = evt.getSourceMessage();\n        \n        this.processMessage(\n                destContact,\n                evt.getTimestamp(),\n                Chat.OUTGOING_MESSAGE,\n                sourceMessage.getContent(),\n                sourceMessage.getContentType());\n    }","commit_id":"3c53069887ddf95b1fb3d046390f3d4e1556e38e","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void run()\n        {\n            Collection<Object> msgList = null;\n\n            if (historyContact instanceof MetaContact)\n            {\n                msgList = history.findByEndDate(\n                    historyFilter,\n                    (MetaContact) historyContact,\n                    new Date(System.currentTimeMillis()));\n            }\n            else if(historyContact instanceof ChatRoomWrapper)\n            {\n                ChatRoomWrapper chatRoomWrapper\n                    = (ChatRoomWrapper) historyContact;\n\n                if(chatRoomWrapper.getChatRoom() == null)\n                    return;\n\n                msgList = history.findByEndDate(\n                    historyFilter,\n                    chatRoomWrapper.getChatRoom(),\n                    new Date(System.currentTimeMillis()));\n            }\n\n            if (msgList != null)\n            for (Object o : msgList)\n            {\n                long date = 0;\n\n                if (o instanceof MessageDeliveredEvent)\n                {\n                    MessageDeliveredEvent evt = (MessageDeliveredEvent)o;\n                    date = evt.getTimestamp();\n                }\n                else if (o instanceof MessageReceivedEvent)\n                {\n                    MessageReceivedEvent evt = (MessageReceivedEvent)o;\n                    date = evt.getTimestamp();\n                }\n                else if (o instanceof ChatRoomMessageReceivedEvent)\n                {\n                    ChatRoomMessageReceivedEvent\n                        evt = (ChatRoomMessageReceivedEvent) o;\n                    date = evt.getTimestamp();\n                }\n                else if (o instanceof ChatRoomMessageDeliveredEvent)\n                {\n                    ChatRoomMessageDeliveredEvent\n                        evt = (ChatRoomMessageDeliveredEvent) o;\n                    date = evt.getTimestamp();\n                }\n                else if (o instanceof FileRecord)\n                {\n                    FileRecord fileRecord = (FileRecord) o;\n                    date = fileRecord.getDate();\n                }\n\n                boolean containsDate = false;\n                long milisecondsPerDay = 24*60*60*1000;\n                for(int j = 0; !containsDate && j < datesVector.size(); j ++)\n                {\n                    Date date1 = datesVector.get(j);\n\n                    containsDate = Math.floor(date1.getTime()/milisecondsPerDay)\n                        == Math.floor(date/milisecondsPerDay);\n                }\n\n                if(!containsDate)\n                {\n                    datesVector.add(new Date(date - date % milisecondsPerDay));\n                }\n            }\n\n            if((msgList != null) && (msgList.size() > 0))\n            {\n                Runnable updateDatesPanel = new Runnable() {\n                    public void run() {\n                        Date date = null;\n                        for(int i = 0; i < datesVector.size(); i++) {\n                            date = datesVector.get(i);\n                            datesPanel.addDate(date);\n                        }\n                        if(date != null) {\n                            ignoreProgressDate = date;\n                        }\n                        //Initializes the conversation panel with the data of\n                        //the last conversation.\n                        int lastDateIndex = datesPanel.getDatesNumber() - 1;\n                        datesPanel.setSelected(lastDateIndex);\n                    }\n                };\n                SwingUtilities.invokeLater(updateDatesPanel);\n            } \n        }","id":65726,"modified_method":"public void run()\n        {\n            Collection<Object> msgList = null;\n\n            if (historyContact instanceof MetaContact)\n            {\n                msgList = history.findByEndDate(\n                    HISTORY_FILTER,\n                    (MetaContact) historyContact,\n                    new Date(System.currentTimeMillis()));\n            }\n            else if(historyContact instanceof ChatRoomWrapper)\n            {\n                ChatRoomWrapper chatRoomWrapper\n                    = (ChatRoomWrapper) historyContact;\n\n                if(chatRoomWrapper.getChatRoom() == null)\n                    return;\n\n                msgList = history.findByEndDate(\n                    HISTORY_FILTER,\n                    chatRoomWrapper.getChatRoom(),\n                    new Date(System.currentTimeMillis()));\n            }\n\n            if (msgList != null)\n            for (Object o : msgList)\n            {\n                long date = 0;\n\n                if (o instanceof MessageDeliveredEvent)\n                {\n                    MessageDeliveredEvent evt = (MessageDeliveredEvent)o;\n                    date = evt.getTimestamp();\n                }\n                else if (o instanceof MessageReceivedEvent)\n                {\n                    MessageReceivedEvent evt = (MessageReceivedEvent)o;\n                    date = evt.getTimestamp();\n                }\n                else if (o instanceof ChatRoomMessageReceivedEvent)\n                {\n                    ChatRoomMessageReceivedEvent\n                        evt = (ChatRoomMessageReceivedEvent) o;\n                    date = evt.getTimestamp();\n                }\n                else if (o instanceof ChatRoomMessageDeliveredEvent)\n                {\n                    ChatRoomMessageDeliveredEvent\n                        evt = (ChatRoomMessageDeliveredEvent) o;\n                    date = evt.getTimestamp();\n                }\n                else if (o instanceof FileRecord)\n                {\n                    FileRecord fileRecord = (FileRecord) o;\n                    date = fileRecord.getDate();\n                }\n\n                boolean containsDate = false;\n                long milisecondsPerDay = 24*60*60*1000;\n                for(int j = 0; !containsDate && j < datesVector.size(); j ++)\n                {\n                    Date date1 = datesVector.get(j);\n\n                    containsDate = Math.floor(date1.getTime()/milisecondsPerDay)\n                        == Math.floor(date/milisecondsPerDay);\n                }\n\n                if(!containsDate)\n                {\n                    datesVector.add(new Date(date - date % milisecondsPerDay));\n                }\n            }\n\n            if((msgList != null) && (msgList.size() > 0))\n            {\n                Runnable updateDatesPanel = new Runnable() {\n                    public void run() {\n                        Date date = null;\n                        for(int i = 0; i < datesVector.size(); i++) {\n                            date = datesVector.get(i);\n                            datesPanel.addDate(date);\n                        }\n                        if(date != null) {\n                            ignoreProgressDate = date;\n                        }\n                        //Initializes the conversation panel with the data of\n                        //the last conversation.\n                        int lastDateIndex = datesPanel.getDatesNumber() - 1;\n                        datesPanel.setSelected(lastDateIndex);\n                    }\n                };\n                SwingUtilities.invokeLater(updateDatesPanel);\n            } \n        }","commit_id":"3c53069887ddf95b1fb3d046390f3d4e1556e38e","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void run()\n        {\n            final Collection<Object> msgList;\n\n            if(historyContact instanceof MetaContact)\n            {\n                msgList = history.findByPeriod(\n                    historyFilter,\n                    (MetaContact) historyContact,\n                    startDate, endDate);\n            }\n            else if (historyContact instanceof ChatRoomWrapper)\n            {\n                ChatRoomWrapper chatRoomWrapper\n                    = (ChatRoomWrapper) historyContact;\n\n                if(chatRoomWrapper.getChatRoom() == null)\n                    return;\n\n                msgList = history.findByPeriod(\n                    historyFilter,\n                    chatRoomWrapper.getChatRoom(),\n                    startDate, endDate);\n            }\n            else\n                msgList = null;\n\n            Runnable updateMessagesPanel = new Runnable()\n            {\n                public void run()\n                {\n                    HTMLDocument doc = createHistory(msgList);\n\n                    if(searchKeyword == null || searchKeyword == \"\")\n                    {\n                        dateHistoryTable.put(startDate, doc);\n                    }\n                }\n            };\n            SwingUtilities.invokeLater(updateMessagesPanel);\n        }","id":65727,"modified_method":"public void run()\n        {\n            final Collection<Object> msgList;\n\n            if(historyContact instanceof MetaContact)\n            {\n                msgList = history.findByPeriod(\n                    HISTORY_FILTER,\n                    (MetaContact) historyContact,\n                    startDate, endDate);\n            }\n            else if (historyContact instanceof ChatRoomWrapper)\n            {\n                ChatRoomWrapper chatRoomWrapper\n                    = (ChatRoomWrapper) historyContact;\n\n                if(chatRoomWrapper.getChatRoom() == null)\n                    return;\n\n                msgList = history.findByPeriod(\n                    HISTORY_FILTER,\n                    chatRoomWrapper.getChatRoom(),\n                    startDate, endDate);\n            }\n            else\n                msgList = null;\n\n            Runnable updateMessagesPanel = new Runnable()\n            {\n                public void run()\n                {\n                    HTMLDocument doc = createHistory(msgList);\n\n                    if(searchKeyword == null || searchKeyword == \"\")\n                    {\n                        dateHistoryTable.put(startDate, doc);\n                    }\n                }\n            };\n            SwingUtilities.invokeLater(updateMessagesPanel);\n        }","commit_id":"3c53069887ddf95b1fb3d046390f3d4e1556e38e","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Constructs the window, by adding all components and panels.\n     */\n    private void initPanels()\n    {\n        this.northPanel.add(searchPanel, BorderLayout.CENTER);\n\n        this.mainPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\n\n        this.mainPanel.add(northPanel, BorderLayout.NORTH);\n\n        this.mainPanel.add(chatConvPanel, BorderLayout.CENTER);\n\n        this.mainPanel.add(datesPanel, BorderLayout.WEST);\n\n        this.mainPanel.setPreferredSize(new Dimension(500, 400));\n\n        this.getContentPane().add(mainPanel);\n    }","id":65728,"modified_method":"/**\n     * Constructs the window, by adding all components and panels.\n     */\n    private void initPanels()\n    {\n        this.mainPanel\n                .setBorder(\n                    BorderFactory\n                        .createEmptyBorder(SPACING, SPACING, SPACING, SPACING));\n        this.mainPanel.setPreferredSize(new Dimension(500, 400));\n\n        this.mainPanel.add(new SearchPanel(this), BorderLayout.NORTH);\n        this.mainPanel.add(chatConvPanel, BorderLayout.CENTER);\n        this.mainPanel.add(datesPanel, BorderLayout.WEST);\n\n        this.getContentPane().add(mainPanel);\n    }","commit_id":"3c53069887ddf95b1fb3d046390f3d4e1556e38e","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void run()\n        {\n            Collection<Object> msgList = null;\n\n            if (historyContact instanceof MetaContact)\n            {\n                msgList = history.findByKeyword(\n                    historyFilter,\n                    (MetaContact) historyContact, keyword);\n            }\n            else if (historyContact instanceof ChatRoomWrapper)\n            {\n                ChatRoomWrapper chatRoomWrapper\n                    = (ChatRoomWrapper) historyContact;\n\n                if (chatRoomWrapper.getChatRoom() == null)\n                    return;\n\n                msgList = history.findByKeyword(\n                    historyFilter,\n                    chatRoomWrapper.getChatRoom(), keyword);\n            }\n\n            if (msgList != null)\n            for (Object o : msgList)\n            {\n                long date = 0;\n\n                if (o instanceof MessageDeliveredEvent)\n                {\n                    MessageDeliveredEvent evt = (MessageDeliveredEvent)o;\n                    date = evt.getTimestamp();\n                }\n                else if (o instanceof MessageReceivedEvent)\n                {\n                    MessageReceivedEvent evt = (MessageReceivedEvent)o;\n                    date = evt.getTimestamp();\n                }\n\n                long milisecondsPerDay = 24*60*60*1000;\n                for(int j = 0; j < datesVector.size(); j ++)\n                {\n                    Date date1 = datesVector.get(j);\n\n                    if(Math.floor(date1.getTime()/milisecondsPerDay)\n                        == Math.floor(date/milisecondsPerDay)\n                        && !keywordDatesVector.contains(date1))\n                    {\n\n                        keywordDatesVector.add(date1);\n                    }\n                }\n            }\n            \n            Runnable updateDatesPanel = new Runnable()\n            {\n                public void run()\n                {\n                    datesPanel.removeAllDates();\n                    if(keywordDatesVector.size() > 0)\n                    {\n                        Date date = null;\n                        for(int i = 0; i < keywordDatesVector.size(); i++)\n                        {\n                            date = keywordDatesVector.get(i);\n                            \n                            /* I have tried to remove and add dates in the\n                             * datesList. A lot of problems occured because\n                             * it seems that the list generates selection events\n                             * when removing elements. This was solved but after\n                             * that a problem occured when one and the same\n                             * selection was done twice.\n                             *  \n                             * if(!keywordDatesVector.contains(date)) {\n                             *    datesPanel.removeDate(date);\n                             * }\n                             * else {\n                             *    if(!datesPanel.containsDate(date)) {\n                             *        datesPanel.addDate(date);\n                             *    }\n                            }*/\n                            datesPanel.addDate(date);\n                        }\n                        if(date != null)\n                        {\n                            ignoreProgressDate = date;\n                        }\n                        datesPanel.setSelected(datesPanel.getDatesNumber() - 1);\n                    }\n                    else\n                    {\n                        chatConvPanel.setDefaultContent();\n                    }\n                }\n            };\n            SwingUtilities.invokeLater(updateDatesPanel);\n        }","id":65729,"modified_method":"public void run()\n        {\n            Collection<Object> msgList = null;\n\n            if (historyContact instanceof MetaContact)\n            {\n                msgList = history.findByKeyword(\n                    HISTORY_FILTER,\n                    (MetaContact) historyContact, keyword);\n            }\n            else if (historyContact instanceof ChatRoomWrapper)\n            {\n                ChatRoomWrapper chatRoomWrapper\n                    = (ChatRoomWrapper) historyContact;\n\n                if (chatRoomWrapper.getChatRoom() == null)\n                    return;\n\n                msgList = history.findByKeyword(\n                    HISTORY_FILTER,\n                    chatRoomWrapper.getChatRoom(), keyword);\n            }\n\n            if (msgList != null)\n            for (Object o : msgList)\n            {\n                long date = 0;\n\n                if (o instanceof MessageDeliveredEvent)\n                {\n                    MessageDeliveredEvent evt = (MessageDeliveredEvent)o;\n                    date = evt.getTimestamp();\n                }\n                else if (o instanceof MessageReceivedEvent)\n                {\n                    MessageReceivedEvent evt = (MessageReceivedEvent)o;\n                    date = evt.getTimestamp();\n                }\n\n                long milisecondsPerDay = 24*60*60*1000;\n                for(int j = 0; j < datesVector.size(); j ++)\n                {\n                    Date date1 = datesVector.get(j);\n\n                    if(Math.floor(date1.getTime()/milisecondsPerDay)\n                        == Math.floor(date/milisecondsPerDay)\n                        && !keywordDatesVector.contains(date1))\n                    {\n\n                        keywordDatesVector.add(date1);\n                    }\n                }\n            }\n            \n            Runnable updateDatesPanel = new Runnable()\n            {\n                public void run()\n                {\n                    datesPanel.removeAllDates();\n                    if(keywordDatesVector.size() > 0)\n                    {\n                        Date date = null;\n                        for(int i = 0; i < keywordDatesVector.size(); i++)\n                        {\n                            date = keywordDatesVector.get(i);\n                            \n                            /* I have tried to remove and add dates in the\n                             * datesList. A lot of problems occured because\n                             * it seems that the list generates selection events\n                             * when removing elements. This was solved but after\n                             * that a problem occured when one and the same\n                             * selection was done twice.\n                             *  \n                             * if(!keywordDatesVector.contains(date)) {\n                             *    datesPanel.removeDate(date);\n                             * }\n                             * else {\n                             *    if(!datesPanel.containsDate(date)) {\n                             *        datesPanel.addDate(date);\n                             *    }\n                            }*/\n                            datesPanel.addDate(date);\n                        }\n                        if(date != null)\n                        {\n                            ignoreProgressDate = date;\n                        }\n                        datesPanel.setSelected(datesPanel.getDatesNumber() - 1);\n                    }\n                    else\n                    {\n                        chatConvPanel.setDefaultContent();\n                    }\n                }\n            };\n            SwingUtilities.invokeLater(updateDatesPanel);\n        }","commit_id":"3c53069887ddf95b1fb3d046390f3d4e1556e38e","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates an instance of the <tt>HistoryWindow<\/tt>.\n     * @param historyContact the <tt>MetaContact<\/tt> or the <tt>ChatRoom<\/tt>\n     */\n    public HistoryWindow(Object historyContact)\n    {\n        this.historyContact = historyContact;\n\n        chatConvPanel = new ChatConversationPanel(this);\n\n        this.progressBar = new JProgressBar(\n            HistorySearchProgressListener.PROGRESS_MINIMUM_VALUE,\n            HistorySearchProgressListener.PROGRESS_MAXIMUM_VALUE);\n\n        this.progressBar.setValue(0);\n        this.progressBar.setStringPainted(true);\n\n        this.history = GuiActivator.getMetaHistoryService();\n        this.history.addSearchProgressListener(this);\n\n        this.datesPanel = new DatesPanel(this);\n        this.historyMenu = new HistoryMenu(this);\n        this.searchPanel = new SearchPanel(this);\n\n        this.initPanels();\n\n        this.initDates();\n\n        this.pack();\n\n        if (historyContact instanceof MetaContact)\n        {\n            MetaContact metaContact = (MetaContact) historyContact;\n\n            this.setTitle(GuiActivator.getResources().getI18NString(\n                    \"service.gui.HISTORY_CONTACT\",\n                    new String[]{metaContact.getDisplayName()}));\n\n            Iterator<Contact> protoContacts = metaContact.getContacts();\n\n            basicInstantMessagings\n                = new ArrayList<OperationSetBasicInstantMessaging>();\n            while(protoContacts.hasNext())\n            {\n                Contact protoContact = protoContacts.next();\n\n                OperationSetBasicInstantMessaging basicInstantMessaging\n                    = protoContact\n                        .getProtocolProvider()\n                            .getOperationSet(\n                                OperationSetBasicInstantMessaging.class);\n\n                if (basicInstantMessaging != null)\n                {\n                    basicInstantMessaging.addMessageListener(this);\n                    basicInstantMessagings.add(basicInstantMessaging);\n                }\n            }\n        }\n        else if (historyContact instanceof ChatRoomWrapper)\n        {\n            chatRoom = ((ChatRoomWrapper) historyContact).getChatRoom();\n            chatRoom.addMessageListener(this);\n        }\n    }","id":65730,"modified_method":"/**\n     * Creates an instance of the <tt>HistoryWindow<\/tt>.\n     * @param historyContact the <tt>MetaContact<\/tt> or the <tt>ChatRoom<\/tt>\n     */\n    public HistoryWindow(Object historyContact)\n    {\n        this.historyContact = historyContact;\n\n        chatConvPanel = new ChatConversationPanel(this);\n\n        this.progressBar = new JProgressBar(\n            HistorySearchProgressListener.PROGRESS_MINIMUM_VALUE,\n            HistorySearchProgressListener.PROGRESS_MAXIMUM_VALUE);\n\n        this.progressBar.setValue(0);\n        this.progressBar.setStringPainted(true);\n\n        this.history = GuiActivator.getMetaHistoryService();\n        this.history.addSearchProgressListener(this);\n\n        this.datesPanel = new DatesPanel(this);\n        this.historyMenu = new HistoryMenu(this);\n\n        this.initPanels();\n\n        this.initDates();\n\n        this.pack();\n\n        if (historyContact instanceof MetaContact)\n        {\n            MetaContact metaContact = (MetaContact) historyContact;\n\n            this.setTitle(GuiActivator.getResources().getI18NString(\n                    \"service.gui.HISTORY_CONTACT\",\n                    new String[]{metaContact.getDisplayName()}));\n\n            Iterator<Contact> protoContacts = metaContact.getContacts();\n\n            basicInstantMessagings\n                = new ArrayList<OperationSetBasicInstantMessaging>();\n            while(protoContacts.hasNext())\n            {\n                Contact protoContact = protoContacts.next();\n\n                OperationSetBasicInstantMessaging basicInstantMessaging\n                    = protoContact\n                        .getProtocolProvider()\n                            .getOperationSet(\n                                OperationSetBasicInstantMessaging.class);\n\n                if (basicInstantMessaging != null)\n                {\n                    basicInstantMessaging.addMessageListener(this);\n                    basicInstantMessagings.add(basicInstantMessaging);\n                }\n            }\n        }\n        else if (historyContact instanceof ChatRoomWrapper)\n        {\n            chatRoom = ((ChatRoomWrapper) historyContact).getChatRoom();\n            chatRoom.addMessageListener(this);\n        }\n    }","commit_id":"3c53069887ddf95b1fb3d046390f3d4e1556e38e","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates an instance of the <tt>SearchPanel<\/tt>.\n     */\n    public SearchPanel(HistoryWindow historyWindow) {\n        \n        super(new BorderLayout());\n\n        this.historyWindow = historyWindow;\n\n        this.setBorder(BorderFactory.createCompoundBorder(\n                BorderFactory.createTitledBorder(searchString),\n                BorderFactory.createEmptyBorder(5, 5, 5, 5))); \n        \n        this.textFieldPanel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));\n        \n        this.init();\n    }","id":65731,"modified_method":"/**\n     * Creates an instance of the <tt>SearchPanel<\/tt>.\n     */\n    public SearchPanel(HistoryWindow historyWindow)\n    {\n        super(new BorderLayout(5, 5));\n\n        this.historyWindow = historyWindow;\n\n        this.init();\n    }","commit_id":"3c53069887ddf95b1fb3d046390f3d4e1556e38e","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Constructs the <tt>SearchPanel<\/tt>.\n     */\n    public void init() {\n        this.textFieldPanel.add(searchTextField);\n        \n        this.searchTextField.getDocument().addDocumentListener(this);\n        \n        this.add(searchLabel, BorderLayout.WEST);\n        this.add(textFieldPanel, BorderLayout.CENTER);\n\n        /*\n        this.detailsLabelsPanel.add(dateLabel);\n        this.detailsLabelsPanel.add(hourLabel);\n        this.detailsLabelsPanel.add(lastNMessagesLabel);\n\n        this.detailsFieldsPanel.add(dateTextField);\n        this.detailsFieldsPanel.add(hourTextField);\n        this.detailsFieldsPanel.add(lastNMessagesTextField);\n\n        this.detailsPanel.add(detailsLabelsPanel, BorderLayout.WEST);\n        this.detailsPanel.add(detailsFieldsPanel, BorderLayout.CENTER);\n\n        this.radiosGroup.add(allMessagesRadio);\n        this.radiosGroup.add(todayMessagesRadio);\n        this.radiosGroup.add(yesterdayMessagesRadio);\n\n        this.checksPanel.add(allMessagesRadio);\n        this.checksPanel.add(todayMessagesRadio);\n        this.checksPanel.add(yesterdayMessagesRadio);\n\n        this.datePanel.add(checksPanel);\n        this.datePanel.add(detailsPanel);\n\n        this.dateCenteredPanel.add(datePanel);\n        */\n        \n        this.searchButton.setName(\"search\");\n        this.searchButton.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\"service.gui.SEARCH\"));\n        \n        // this.extendedSearchButton.setName(\"extendedSearch\");\n        // this.extendedSearchOpenedButton.setName(\"extendedSearchOpened\");\n\n        this.searchButton.addActionListener(this);\n\n        this.historyWindow.getRootPane().setDefaultButton(searchButton);\n        // this.extendedSearchPanel.add(extendedSearchButton,\n        // BorderLayout.CENTER);\n        this.add(searchButton, BorderLayout.EAST);\n\n        // this.add(extendedSearchPanel, BorderLayout.SOUTH);\n\n        // this.extendedSearchButton.addActionListener(this);\n        // this.extendedSearchOpenedButton.addActionListener(this);\n\n        //this.enableDefaultSearchSettings();\n    }","id":65732,"modified_method":"/**\n     * Constructs the <tt>SearchPanel<\/tt>.\n     */\n    private void init()\n    {\n        String searchString\n            = GuiActivator.getResources().getI18NString(\"service.gui.SEARCH\");\n        JLabel searchLabel = new JLabel(searchString + \": \");\n        JButton searchButton\n            = new JButton(\n                    searchString,\n                    new ImageIcon(\n                            ImageLoader.getImage(ImageLoader.SEARCH_ICON)));\n\n        this.searchTextField.getDocument().addDocumentListener(this);\n\n        this.add(searchLabel, BorderLayout.WEST);\n        this.add(searchTextField, BorderLayout.CENTER);\n\n        /*\n        this.detailsLabelsPanel.add(dateLabel);\n        this.detailsLabelsPanel.add(hourLabel);\n        this.detailsLabelsPanel.add(lastNMessagesLabel);\n\n        this.detailsFieldsPanel.add(dateTextField);\n        this.detailsFieldsPanel.add(hourTextField);\n        this.detailsFieldsPanel.add(lastNMessagesTextField);\n\n        this.detailsPanel.add(detailsLabelsPanel, BorderLayout.WEST);\n        this.detailsPanel.add(detailsFieldsPanel, BorderLayout.CENTER);\n\n        this.radiosGroup.add(allMessagesRadio);\n        this.radiosGroup.add(todayMessagesRadio);\n        this.radiosGroup.add(yesterdayMessagesRadio);\n\n        this.checksPanel.add(allMessagesRadio);\n        this.checksPanel.add(todayMessagesRadio);\n        this.checksPanel.add(yesterdayMessagesRadio);\n\n        this.datePanel.add(checksPanel);\n        this.datePanel.add(detailsPanel);\n\n        this.dateCenteredPanel.add(datePanel);\n        */\n        \n        searchButton.setName(\"search\");\n        searchButton.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\"service.gui.SEARCH\"));\n        \n        // this.extendedSearchButton.setName(\"extendedSearch\");\n        // this.extendedSearchOpenedButton.setName(\"extendedSearchOpened\");\n\n        searchButton.addActionListener(this);\n\n        this.historyWindow.getRootPane().setDefaultButton(searchButton);\n        // this.extendedSearchPanel.add(extendedSearchButton,\n        // BorderLayout.CENTER);\n        this.add(searchButton, BorderLayout.EAST);\n\n        // this.add(extendedSearchPanel, BorderLayout.SOUTH);\n\n        // this.extendedSearchButton.addActionListener(this);\n        // this.extendedSearchOpenedButton.addActionListener(this);\n\n        //this.enableDefaultSearchSettings();\n    }","commit_id":"3c53069887ddf95b1fb3d046390f3d4e1556e38e","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Shows message in the chat conversation panel when\n     * delivered.\n     *\n     * @param evt the event containing details on the message delivery\n     */\n    public void messageDelivered(MessageDeliveredEvent evt) {\n\n        Message msg = evt.getSourceMessage();\n        Hashtable waitToBeDelivered = this.mainFrame.getWaitToBeDeliveredMsgs();\n        String msgUID = msg.getMessageUID();\n\n        if (waitToBeDelivered.containsKey(msgUID)) {\n            ChatPanel chatPanel = (ChatPanel) waitToBeDelivered.get(msgUID);\n            \n            ProtocolProviderService protocolProvider = evt\n                    .getDestinationContact().getProtocolProvider();\n\n            chatPanel.processMessage(\n                    this.mainFrame.getDefaultAccount(protocolProvider),\n                    evt.getTimestamp(), Constants.OUTGOING_MESSAGE,\n                    msg.getContent());\n            \n            chatPanel.refreshWriteArea();\n        }\n    }","id":65733,"modified_method":"/**\n     * Shows message in the chat conversation panel when\n     * delivered.\n     *\n     * @param evt the event containing details on the message delivery\n     */\n    public void messageDelivered(MessageDeliveredEvent evt) {\n\n        Message msg = evt.getSourceMessage();\n        Hashtable waitToBeDelivered = this.mainFrame.getWaitToBeDeliveredMsgs();\n        String msgUID = msg.getMessageUID();\n\n        if (waitToBeDelivered.containsKey(msgUID)) {\n            ChatPanel chatPanel = (ChatPanel) waitToBeDelivered.get(msgUID);\n            \n            ProtocolProviderService protocolProvider = evt\n                    .getDestinationContact().getProtocolProvider();\n\n            chatPanel.processMessage(\n                    this.mainFrame.getAccount(protocolProvider),\n                    evt.getTimestamp(), Constants.OUTGOING_MESSAGE,\n                    msg.getContent());\n            \n            chatPanel.refreshWriteArea();\n        }\n    }","commit_id":"bc82c46a62a7545e7211477f73f1a4de7d7398d5","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * When message is received determines whether to open a new chat\n     * window or chat window tab, or to indicate that a message is received\n     * from a contact which already has an open chat. When the chat is found\n     * shows the message in the appropriate chat panel.\n     *\n     * @param evt the event containing details on the received message\n     */\n    public void messageReceived(MessageReceivedEvent evt) {\n        MetaContact metaContact = mainFrame.getContactList()\n                .findMetaContactByContact(evt.getSourceContact());\n\n        PresenceStatus contactStatus = ((ContactListModel) this.contactList\n                .getModel()).getMetaContactStatus(metaContact);\n\n        Contact protocolContact = evt.getSourceContact();\n\n        if (!Constants.TABBED_CHAT_WINDOW) {\n            //If in mode \"open all messages in new window\"\n            if (contactMsgWindows.containsKey(metaContact)) {\n                /*\n                 * If a chat window for this contact is already opened\n                 * show it.\n                 */\n                ChatWindow msgWindow = (ChatWindow) contactMsgWindows\n                        .get(metaContact);\n\n                msgWindow.getCurrentChatPanel().processMessage(\n                                evt.getSourceContact().getDisplayName(),\n                                evt.getTimestamp(), Constants.INCOMING_MESSAGE,\n                                evt.getSourceMessage().getContent());\n\n                msgWindow.setVisible(true);\n            } else {\n                /*\n                 * If there's no chat window for the contact\n                 * create it and show it.\n                 */\n                ChatWindow msgWindow = new ChatWindow(mainFrame);\n\n                contactMsgWindows.put(metaContact, msgWindow);\n\n                msgWindow.addChat(metaContact, contactStatus, protocolContact);\n\n                msgWindow.getCurrentChatPanel().processMessage(\n                                evt.getSourceContact().getDisplayName(),\n                                evt.getTimestamp(), Constants.INCOMING_MESSAGE,\n                                evt.getSourceMessage().getContent());\n\n                msgWindow.pack();\n\n                msgWindow.setVisible(true);\n            }\n        } else {\n            // If in mode \"group messages in one chat window\"\n            if (tabbedChatWindow == null) {\n                // If there's no open chat window\n                tabbedChatWindow = new ChatWindow(mainFrame);\n\n                tabbedChatWindow.addWindowListener(new WindowAdapter() {\n\n                    public void windowClosing(WindowEvent e) {\n                        tabbedChatWindow = null;\n                    }\n                });\n            }\n            /*\n             * Get the hashtable containg all tabs and corresponding\n             * chat panels.\n             */\n            Hashtable contactTabsTable = tabbedChatWindow.getContactTabsTable();\n            ChatPanel chatPanel;\n\n            //If there's no open tab for the given contact.\n            if (contactTabsTable.get(metaContact.getMetaUID()) == null) {                \n                chatPanel = tabbedChatWindow.addChatTab(metaContact,\n                        contactStatus, protocolContact);\n\n                chatPanel.processMessage(\n                        evt.getSourceContact().getDisplayName(),\n                        evt.getTimestamp(), Constants.INCOMING_MESSAGE,\n                        evt.getSourceMessage().getContent());\n\n                tabbedChatWindow.setVisible(true);\n\n                tabbedChatWindow.getCurrentChatPanel()\n                    .requestFocusInWriteArea();\n            } else {\n                chatPanel = tabbedChatWindow.getChatPanel(metaContact);\n                chatPanel.processMessage(\n                        evt.getSourceContact().getDisplayName(),\n                        evt.getTimestamp(), Constants.INCOMING_MESSAGE,\n                        evt.getSourceMessage().getContent());\n\n                tabbedChatWindow.setVisible(true);\n            }\n\n            if (tabbedChatWindow.getTabCount() > 1) {\n                tabbedChatWindow.highlightTab(metaContact);\n            }\n        }\n        Constants.getDefaultAudio().play();\n    }","id":65734,"modified_method":"/**\n     * When message is received determines whether to open a new chat\n     * window or chat window tab, or to indicate that a message is received\n     * from a contact which already has an open chat. When the chat is found\n     * shows the message in the appropriate chat panel.\n     *\n     * @param evt the event containing details on the received message\n     */\n    public void messageReceived(MessageReceivedEvent evt) {\n        Contact protocolContact = evt.getSourceContact();\n        Date date = evt.getTimestamp();\n        Message message = evt.getSourceMessage();\n        \n        MetaContact metaContact = mainFrame.getContactList()\n                .findMetaContactByContact(protocolContact);\n\n        PresenceStatus contactStatus = ((ContactListModel) this.contactList\n                .getModel()).getMetaContactStatus(metaContact);\n\n        \n        \n        if (!Constants.TABBED_CHAT_WINDOW) {\n            //If in mode \"open all messages in new window\"\n            if (contactMsgWindows.containsKey(metaContact)) {\n                /*\n                 * If a chat window for this contact is already opened\n                 * show it.\n                 */\n                ChatWindow msgWindow = (ChatWindow) contactMsgWindows\n                        .get(metaContact);\n\n                msgWindow.getCurrentChatPanel().processMessage(\n                                protocolContact.getDisplayName(),\n                                date, Constants.INCOMING_MESSAGE,\n                                message.getContent());\n\n                msgWindow.setVisible(true);\n            } else {\n                /*\n                 * If there's no chat window for the contact\n                 * create it and show it.\n                 */\n                ChatWindow msgWindow = new ChatWindow(mainFrame);\n\n                contactMsgWindows.put(metaContact, msgWindow);\n\n                msgWindow.addChat(metaContact, contactStatus, protocolContact);\n\n                msgWindow.getCurrentChatPanel().processMessage(\n                                protocolContact.getDisplayName(),\n                                date, Constants.INCOMING_MESSAGE,\n                                message.getContent());\n\n                msgWindow.pack();\n\n                msgWindow.setVisible(true);\n            }\n        } else {\n            // If in mode \"group messages in one chat window\"\n            if (tabbedChatWindow == null) {\n                // If there's no open chat window\n                tabbedChatWindow = new ChatWindow(mainFrame);\n\n                tabbedChatWindow.addWindowListener(new WindowAdapter() {\n\n                    public void windowClosing(WindowEvent e) {\n                        tabbedChatWindow = null;\n                    }\n                });\n            }\n            /*\n             * Get the hashtable containg all tabs and corresponding\n             * chat panels.\n             */\n            Hashtable contactTabsTable = tabbedChatWindow.getContactTabsTable();\n            ChatPanel chatPanel;\n\n            //If there's no open tab for the given contact.\n            if (contactTabsTable.get(metaContact.getMetaUID()) == null) {                \n                chatPanel = tabbedChatWindow.addChatTab(metaContact,\n                        contactStatus, protocolContact);\n\n                chatPanel.processMessage(\n                        protocolContact.getDisplayName(),\n                        date, Constants.INCOMING_MESSAGE,\n                        message.getContent());\n\n                tabbedChatWindow.setVisible(true);\n\n                tabbedChatWindow.getCurrentChatPanel()\n                    .requestFocusInWriteArea();\n            } else {\n                chatPanel = tabbedChatWindow.getChatPanel(metaContact);\n                chatPanel.processMessage(\n                        protocolContact.getDisplayName(),\n                        date, Constants.INCOMING_MESSAGE,\n                        message.getContent());\n\n                tabbedChatWindow.setVisible(true);\n            }\n\n            if (tabbedChatWindow.getTabCount() > 1) {\n                tabbedChatWindow.highlightTab(metaContact);\n            }\n        }\n        Constants.getDefaultAudio().play();\n    }","commit_id":"bc82c46a62a7545e7211477f73f1a4de7d7398d5","url":"https://github.com/jitsi/jitsi"},{"original_method":"public static void displayHelp() // todo: use HelpFormatter to avoid duplication between help and OptionBuilder\n    {\n        System.err.println(\"Usage: groovyc <options> <source files>\");\n        System.err.println(\"where possible options include: \");\n        System.err.println(\"  --classpath <path>        Specify where to find user class files\");\n        System.err.println(\"  -d <directory>            Specify where to place generated class files\");\n        System.err.println(\"  --encoding <encoding>     Specify the encoding of the user class files\");\n//        System.err.println(\"  --strict                  Turn on strict type safety\");\n        System.err.println(\"  --version                 Print the verion\");\n        System.err.println(\"  --help                    Print a synopsis of standard options\");\n        System.err.println(\"  --exception               Print stack trace on error\");\n        System.err.println(\"  --jointCompilation        attach javac compiler to compile .java files\");\n        System.err.println(\"\");\n    }","id":65735,"modified_method":"public static void displayHelp(final Options options)\n    {\n      final HelpFormatter formatter = new HelpFormatter ( ) ;\n      formatter.printHelp ( formatter.getWidth ( ) , \"groovyc <options> <source-files>\" , \"where possible options are:\" , options , \"\" ) ;\n    }","commit_id":"a778081c4fd25416e0a92e4ad4bb3968317f998a","url":"https://github.com/apache/groovy"},{"original_method":"/**\n    *  Primary entry point for compiling from the command line\n    *  (using the groovyc script).\n    */\n    \n    public static void main( String[] args )\n    {\n        boolean displayStackTraceOnError = false;\n        boolean jointCompilation = false;\n        \n        try\n        {\n            //\n            // Parse the command line\n            \n            Options options = new Options();\n    \n            options.addOption(OptionBuilder.withLongOpt(\"classpath\").hasArg().withArgName(\"classpath\").create());\n            options.addOption(OptionBuilder.withLongOpt(\"sourcepath\").hasArg().withArgName(\"sourcepath\").create());\n            options.addOption(OptionBuilder.withLongOpt(\"temp\").hasArg().withArgName(\"temp\").create());\n            options.addOption(OptionBuilder.withLongOpt(\"encoding\").hasArg().withArgName(\"encoding\").create());\n            options.addOption(OptionBuilder.hasArg().create('d'));\n//            options.addOption(OptionBuilder.withLongOpt(\"strict\").create('s'));\n            options.addOption(OptionBuilder.withLongOpt(\"help\").create('h'));\n            options.addOption(OptionBuilder.withLongOpt(\"version\").create('v'));\n            options.addOption(OptionBuilder.withLongOpt(\"exception\").create('e'));\n            options.addOption(OptionBuilder.withLongOpt(\"jointCompilation\").create('j'));\n    \n            options.addOption(\n                    OptionBuilder.withArgName( \"property=value\" )\n                    .withValueSeparator()\n                    .hasArgs(2)\n                    .create( \"J\" ));\n            options.addOption(\n                    OptionBuilder.withArgName( \"property=value\" )\n                    .hasArg()\n                    .create( \"F\" ));\n            \n            PosixParser cliParser = new PosixParser();\n    \n            CommandLine cli = cliParser.parse(options, args);\n    \n            if( cli.hasOption('h') ) \n            {\n                displayHelp();\n                return;\n            }\n    \n            if( cli.hasOption('v') ) \n            {\n                displayVersion();\n            }\n    \n            \n            //\n            // Setup the configuration data\n            \n            CompilerConfiguration configuration = new CompilerConfiguration();\n    \n            if( cli.hasOption(\"classpath\") ) \n            {\n                configuration.setClasspath( cli.getOptionValue(\"classpath\") );\n            }\n    \n            if( cli.hasOption('d') ) \n            {\n                configuration.setTargetDirectory( cli.getOptionValue('d') );\n            }\n\n            if (cli.hasOption(\"encoding\")) {\n                configuration.setSourceEncoding(cli.getOptionValue(\"encoding\"));\n            }\n\n            displayStackTraceOnError = cli.hasOption('e');\n            \n            // joint compilation parameters\n            jointCompilation = cli.hasOption('j');\n            if (jointCompilation) {\n                Map compilerOptions =  new HashMap();\n                \n                String[] opts = cli.getOptionValues(\"J\");\n                compilerOptions.put(\"namedValues\", opts);\n                \n                opts = cli.getOptionValues(\"F\");\n                compilerOptions.put(\"flags\", opts);\n                \n                configuration.setJointCompilationOptions(compilerOptions);\n            }            \n            \n            //\n            // Load the file name list\n            \n            String[] filenames = cli.getArgs();\n            if( filenames.length == 0 ) \n            {\n                displayHelp();\n                return;\n            }\n    \n            int errors = checkFiles( filenames );\n    \n            //\n            // Create and start the compiler\n            \n            if( errors == 0 ) \n            {\n                if (jointCompilation) {\n                    File tmpDir = createTempDir();\n                    configuration.getJointCompilationOptions().put(\"stubDir\",tmpDir);\n                }\n                FileSystemCompiler compiler = new FileSystemCompiler(configuration);\n                compiler.compile( filenames );\n            }\n        }\n        catch( Throwable e ) \n        {\n            new ErrorReporter( e, displayStackTraceOnError ).write( System.err );\n        }\n    }","id":65736,"modified_method":"/**\n    *  Primary entry point for compiling from the command line\n    *  (using the groovyc script).\n    */\n    \n    public static void main( String[] args )\n    {\n        boolean displayStackTraceOnError = false;\n        boolean jointCompilation = false;\n        \n        try\n        {\n            //\n            // Parse the command line\n            \n            Options options = new Options();\n    \n            options.addOption(OptionBuilder.withLongOpt(\"classpath\").hasArg().withArgName(\"path\").withDescription(\"Specify where to find the class files.\").create());\n            options.addOption(OptionBuilder.withLongOpt(\"sourcepath\").hasArg().withArgName(\"path\").withDescription(\"Specify where to find the source files.\").create());\n            options.addOption(OptionBuilder.withLongOpt(\"temp\").hasArg().withArgName(\"temp\").withDescription(\"\").create());\n            options.addOption(OptionBuilder.withLongOpt(\"encoding\").hasArg().withArgName(\"encoding\").withDescription(\"Specify the encoding of the user class files.\").create());\n            options.addOption(OptionBuilder.hasArg().withDescription(\"Specify where to place generated class files.\").create('d'));\n//            options.addOption(OptionBuilder.withLongOpt(\"strict\").withDescription(\"Turn on strict type safety.\").create('s'));\n            options.addOption(OptionBuilder.withLongOpt(\"help\").withDescription(\"Print a synopsis of standard options.\").create('h'));\n            options.addOption(OptionBuilder.withLongOpt(\"version\").withDescription(\"Print the version.\").create('v'));\n            options.addOption(OptionBuilder.withLongOpt(\"exception\").withDescription(\"Print stack trace on error.\").create('e'));\n            options.addOption(OptionBuilder.withLongOpt(\"jointCompilation\").withDescription(\"Attach javac compiler to compile .java files.\").create('j'));\n    \n            options.addOption(\n                    OptionBuilder.withArgName( \"property=value\" )\n                    .withValueSeparator()\n                    .hasArgs(2)\n                    .withDescription(\"\")\n                    .create( \"J\" ));\n            options.addOption(\n                    OptionBuilder.withArgName( \"property=value\" )\n                    .hasArg()\n                    .withDescription(\"\")\n                    .create( \"F\" ));\n            \n            PosixParser cliParser = new PosixParser();\n    \n            CommandLine cli = cliParser.parse(options, args);\n    \n            if( cli.hasOption('h') ) \n            {\n                displayHelp(options);\n                return;\n            }\n    \n            if( cli.hasOption('v') ) \n            {\n                displayVersion();\n            }\n    \n            \n            //\n            // Setup the configuration data\n            \n            CompilerConfiguration configuration = new CompilerConfiguration();\n    \n            if( cli.hasOption(\"classpath\") ) \n            {\n                configuration.setClasspath( cli.getOptionValue(\"classpath\") );\n            }\n    \n            if( cli.hasOption('d') ) \n            {\n                configuration.setTargetDirectory( cli.getOptionValue('d') );\n            }\n\n            if (cli.hasOption(\"encoding\")) {\n                configuration.setSourceEncoding(cli.getOptionValue(\"encoding\"));\n            }\n\n            displayStackTraceOnError = cli.hasOption('e');\n            \n            // joint compilation parameters\n            jointCompilation = cli.hasOption('j');\n            if (jointCompilation) {\n                Map compilerOptions =  new HashMap();\n                \n                String[] opts = cli.getOptionValues(\"J\");\n                compilerOptions.put(\"namedValues\", opts);\n                \n                opts = cli.getOptionValues(\"F\");\n                compilerOptions.put(\"flags\", opts);\n                \n                configuration.setJointCompilationOptions(compilerOptions);\n            }            \n            \n            //\n            // Load the file name list\n            \n            String[] filenames = cli.getArgs();\n            if( filenames.length == 0 ) \n            {\n                displayHelp(options);\n                return;\n            }\n    \n            int errors = checkFiles( filenames );\n    \n            //\n            // Create and start the compiler\n            \n            if( errors == 0 ) \n            {\n                if (jointCompilation) {\n                    File tmpDir = createTempDir();\n                    configuration.getJointCompilationOptions().put(\"stubDir\",tmpDir);\n                }\n                FileSystemCompiler compiler = new FileSystemCompiler(configuration);\n                compiler.compile( filenames );\n            }\n        }\n        catch( Throwable e ) \n        {\n            new ErrorReporter( e, displayStackTraceOnError ).write( System.err );\n        }\n    }","commit_id":"a778081c4fd25416e0a92e4ad4bb3968317f998a","url":"https://github.com/apache/groovy"},{"original_method":"public void setSchema(ModelSchema<T> schema) {\n            this.schema = schema;\n        }","id":65737,"modified_method":"public void setSchema(ModelSchema<S> schema) {\n            this.schema = schema;\n        }","commit_id":"637e5fd1649b6004af3b32d0e13d9c912690114e","url":"https://github.com/gradle/gradle"},{"original_method":"private <P> DefaultManagedSet<P> createManagedSetInstance(final ModelSchema<P> elementSchema) {\n            Factory<P> factory = new Factory<P>() {\n                public P create() {\n                    return elementSchema.createInstance();\n                }\n            };\n            return new DefaultManagedSet<P>(factory);\n        }","id":65738,"modified_method":"private <E> DefaultManagedSet<E> createManagedSetInstance(final ModelSchema<E> elementSchema) {\n            Factory<E> factory = new Factory<E>() {\n                public E create() {\n                    return elementSchema.createInstance();\n                }\n            };\n            return new DefaultManagedSet<E>(factory);\n        }","commit_id":"637e5fd1649b6004af3b32d0e13d9c912690114e","url":"https://github.com/gradle/gradle"},{"original_method":"public ManagedSetSchemaExtractionHandler() {\n        super(MANAGED_SET_MODEL_TYPE);\n    }","id":65739,"modified_method":"private ManagedSetSchemaExtractionHandler(ModelType<T> type) {\n        this.type = type;\n    }","commit_id":"637e5fd1649b6004af3b32d0e13d9c912690114e","url":"https://github.com/gradle/gradle"},{"original_method":"public <T> ModelSchemaExtractionResult<T> extract(ModelType<T> type, ModelSchemaCache cache, ModelSchemaExtractionContext context) {\n        List<ModelType<?>> typeVariables = type.getTypeVariables();\n\n        if (typeVariables.isEmpty()) {\n            throw invalid(type, String.format(\"type parameter of %s has to be specified\", ManagedSet.class.getName()));\n        }\n        if (type.isHasWildcardTypeVariables()) {\n            throw invalid(type, String.format(\"type parameter of %s cannot be a wildcard\", ManagedSet.class.getName()));\n        }\n        if (MANAGED_SET_MODEL_TYPE.isAssignableFrom(typeVariables.get(0))) {\n            throw invalid(type, String.format(\"%1$s cannot be used as type parameter of %1$s\", ManagedSet.class.getName()));\n        }\n\n        ManagedSetInstantiator<T> elementInstantiator = new ManagedSetInstantiator<T>(cache);\n        ModelSchema<T> schema = new ModelSchema<T>(type, elementInstantiator);\n        elementInstantiator.setSchema(schema);\n        ModelType<? extends ManagedSet<?>> managedSetSchema = Cast.uncheckedCast(type);\n        return new ModelSchemaExtractionResult<T>(schema, ImmutableList.of(new ManagedSetElementTypeExtractionContext(managedSetSchema, context)));\n    }","id":65740,"modified_method":"public <R extends T> ModelSchemaExtractionResult<R> extract(ModelType<R> type, ModelSchemaCache cache, ModelSchemaExtractionContext context) {\n        List<ModelType<?>> typeVariables = type.getTypeVariables();\n\n        if (typeVariables.isEmpty()) {\n            throw new InvalidManagedModelElementTypeException(type, String.format(\"type parameter of %s has to be specified\", ManagedSet.class.getName()));\n        }\n        if (type.isHasWildcardTypeVariables()) {\n            throw new InvalidManagedModelElementTypeException(type, String.format(\"type parameter of %s cannot be a wildcard\", ManagedSet.class.getName()));\n        }\n        if (MANAGED_SET_MODEL_TYPE.isAssignableFrom(typeVariables.get(0))) {\n            throw new InvalidManagedModelElementTypeException(type, String.format(\"%1$s cannot be used as type parameter of %1$s\", ManagedSet.class.getName()));\n        }\n\n        ModelSchema<R> schema = createSchema(type, cache);\n        return new ModelSchemaExtractionResult<R>(schema, ImmutableList.of(new ManagedSetElementTypeExtractionContext(type, context)));\n    }","commit_id":"637e5fd1649b6004af3b32d0e13d9c912690114e","url":"https://github.com/gradle/gradle"},{"original_method":"public T create() {\n            final ModelSchema<?> elementSchema = cache.get(schema.getType().getTypeVariables().get(0));\n            T set = Cast.uncheckedCast(createManagedSetInstance(elementSchema));\n            return set;\n        }","id":65741,"modified_method":"public S create() {\n            ModelType<?> elementType = schema.getType().getTypeVariables().get(0);\n            final ModelSchema<?> elementSchema = cache.get(elementType);\n            return Cast.uncheckedCast(createManagedSetInstance(elementSchema));\n        }","commit_id":"637e5fd1649b6004af3b32d0e13d9c912690114e","url":"https://github.com/gradle/gradle"},{"original_method":"private <T> ModelProperty<T> extractPropertyOfManagedType(final ModelSchemaCache schemaCache, ModelType<?> type, Map<String, Method> methods, String getterName, final ModelType<T> propertyType,\n                                                              List<String> handled) {\n        String propertyNameCapitalized = getterName.substring(3);\n        String propertyName = StringUtils.uncapitalize(propertyNameCapitalized);\n        String setterName = \"set\" + propertyNameCapitalized;\n\n        if (methods.containsKey(setterName)) {\n            validateSetter(type, propertyType, methods.get(setterName));\n            handled.add(setterName);\n            return new ModelProperty<T>(propertyName, propertyType, true);\n        } else {\n            return new ModelProperty<T>(propertyName, propertyType, true, new Factory<T>() {\n                public T create() {\n                    ModelSchema<T> modelSchema = schemaCache.get(propertyType);\n                    return modelSchema.createInstance();\n                }\n            });\n\n        }\n    }","id":65742,"modified_method":"private <P> ModelProperty<P> extractPropertyOfManagedType(final ModelSchemaCache schemaCache, ModelType<?> type, Map<String, Method> methods, String getterName, final ModelType<P> propertyType,\n                                                              List<String> handled) {\n        String propertyNameCapitalized = getterName.substring(3);\n        String propertyName = StringUtils.uncapitalize(propertyNameCapitalized);\n        String setterName = \"set\" + propertyNameCapitalized;\n\n        if (methods.containsKey(setterName)) {\n            validateSetter(type, propertyType, methods.get(setterName));\n            handled.add(setterName);\n            return new ModelProperty<P>(propertyName, propertyType, true);\n        } else {\n            return new ModelProperty<P>(propertyName, propertyType, true, new Factory<P>() {\n                public P create() {\n                    ModelSchema<P> modelSchema = schemaCache.get(propertyType);\n                    return modelSchema.createInstance();\n                }\n            });\n\n        }\n    }","commit_id":"637e5fd1649b6004af3b32d0e13d9c912690114e","url":"https://github.com/gradle/gradle"},{"original_method":"private <T> Iterable<? extends ModelSchemaExtractionContext> getModelSchemaDependencies(Iterable<ModelProperty<?>> properties, final ModelType<T> type, final ModelSchemaExtractionContext context) {\n        Iterable<ModelProperty<?>> managedProperties = Iterables.filter(properties, new Predicate<ModelProperty<?>>() {\n            public boolean apply(ModelProperty<?> input) {\n                return input.isManaged();\n            }\n        });\n        return Iterables.transform(managedProperties, new Function<ModelProperty<?>, ModelSchemaExtractionContext>() {\n            public ModelSchemaExtractionContext apply(ModelProperty<?> property) {\n                return new PropertyExtractionContext(type, property, context);\n            }\n        });\n    }","id":65743,"modified_method":"private <R extends T> Iterable<? extends ModelSchemaExtractionContext> getModelSchemaDependencies(Iterable<ModelProperty<?>> properties, final ModelType<R> type,\n                                                                                                      final ModelSchemaExtractionContext context) {\n        Iterable<ModelProperty<?>> managedProperties = Iterables.filter(properties, new Predicate<ModelProperty<?>>() {\n            public boolean apply(ModelProperty<?> input) {\n                return input.isManaged();\n            }\n        });\n        return Iterables.transform(managedProperties, new Function<ModelProperty<?>, ModelSchemaExtractionContext>() {\n            public ModelSchemaExtractionContext apply(ModelProperty<?> property) {\n                return new PropertyExtractionContext(type, property, context);\n            }\n        });\n    }","commit_id":"637e5fd1649b6004af3b32d0e13d9c912690114e","url":"https://github.com/gradle/gradle"},{"original_method":"private <T> void validateSetter(ModelType<?> type, ModelType<T> propertyType, Method setter) {\n        if (!setter.getReturnType().equals(void.class)) {\n            throw invalidMethod(type, setter.getName(), \"setter method must have void return type\");\n        }\n\n        Type[] setterParameterTypes = setter.getGenericParameterTypes();\n        if (setterParameterTypes.length != 1) {\n            throw invalidMethod(type, setter.getName(), \"setter method must have exactly one parameter\");\n        }\n\n        ModelType<?> setterType = ModelType.of(setterParameterTypes[0]);\n        if (!setterType.equals(propertyType)) {\n            throw invalidMethod(type, setter.getName(), \"setter method param must be of exactly the same type as the getter returns (expected: \" + propertyType + \", found: \" + setterType + \")\");\n        }\n    }","id":65744,"modified_method":"private void validateSetter(ModelType<?> type, ModelType<?> propertyType, Method setter) {\n        if (!setter.getReturnType().equals(void.class)) {\n            throw invalidMethod(type, setter.getName(), \"setter method must have void return type\");\n        }\n\n        Type[] setterParameterTypes = setter.getGenericParameterTypes();\n        if (setterParameterTypes.length != 1) {\n            throw invalidMethod(type, setter.getName(), \"setter method must have exactly one parameter\");\n        }\n\n        ModelType<?> setterType = ModelType.of(setterParameterTypes[0]);\n        if (!setterType.equals(propertyType)) {\n            throw invalidMethod(type, setter.getName(), \"setter method param must be of exactly the same type as the getter returns (expected: \" + propertyType + \", found: \" + setterType + \")\");\n        }\n    }","commit_id":"637e5fd1649b6004af3b32d0e13d9c912690114e","url":"https://github.com/gradle/gradle"},{"original_method":"public <T> void validateType(ModelType<T> type) {\n        Class<T> typeClass = type.getConcreteClass();\n\n        if (!typeClass.isInterface()) {\n            throw invalid(type, \"must be defined as an interface\");\n        }\n\n        if (typeClass.getInterfaces().length > 0) {\n            throw invalid(type, \"cannot extend other types\");\n        }\n\n        if (typeClass.getTypeParameters().length > 0) {\n            throw invalid(type, \"cannot be a parameterized type\");\n        }\n    }","id":65745,"modified_method":"public void validateType(ModelType<?> type) {\n        Class<?> typeClass = type.getConcreteClass();\n\n        if (!typeClass.isInterface()) {\n            throw new InvalidManagedModelElementTypeException(type, \"must be defined as an interface\");\n        }\n\n        if (typeClass.getInterfaces().length > 0) {\n            throw new InvalidManagedModelElementTypeException(type, \"cannot extend other types\");\n        }\n\n        if (typeClass.getTypeParameters().length > 0) {\n            throw new InvalidManagedModelElementTypeException(type, \"cannot be a parameterized type\");\n        }\n    }","commit_id":"637e5fd1649b6004af3b32d0e13d9c912690114e","url":"https://github.com/gradle/gradle"},{"original_method":"public ManagedTypeModelSchemaExtractionHandler() {\n        super(new Spec<ModelType<?>>() {\n            public boolean isSatisfiedBy(ModelType<?> type) {\n                return isManaged(type);\n            }\n        });\n    }","id":65746,"modified_method":"private ManagedTypeModelSchemaExtractionHandler(ModelType<T> type) {\n        this.type = type;\n    }","commit_id":"637e5fd1649b6004af3b32d0e13d9c912690114e","url":"https://github.com/gradle/gradle"},{"original_method":"private <T> ModelProperty<T> extractPropertyOfUnmanagedType(ModelType<?> type, Map<String, Method> methods, String getterName, final ModelType<T> propertyType, List<String> handled) {\n        Class<?> boxedType = BOXED_REPLACEMENTS.get(propertyType);\n        if (boxedType != null) {\n            throw invalidMethod(type, getterName, String.format(\"%s is not a supported property type, use %s instead\", propertyType, boxedType.getName()));\n        }\n        if (!isSupportedUnmanagedType(propertyType)) {\n            String supportedTypes = Joiner.on(\", \").join(SUPPORTED_UNMANAGED_TYPES);\n            throw invalidMethod(type, getterName, String.format(\"%s is not a supported property type, only managed and the following unmanaged types are supported: %s\", propertyType, supportedTypes));\n        }\n\n        String propertyNameCapitalized = getterName.substring(3);\n        final String propertyName = StringUtils.uncapitalize(propertyNameCapitalized);\n        String setterName = \"set\" + propertyNameCapitalized;\n\n        if (!methods.containsKey(setterName)) {\n            throw invalidMethod(type, getterName, \"no corresponding setter for getter\");\n        }\n\n        validateSetter(type, propertyType, methods.get(setterName));\n        handled.add(setterName);\n        return new ModelProperty<T>(propertyName, propertyType);\n    }","id":65747,"modified_method":"private <P> ModelProperty<P> extractPropertyOfUnmanagedType(ModelType<?> type, Map<String, Method> methods, String getterName, final ModelType<P> propertyType, List<String> handled) {\n        Class<?> boxedType = BOXED_REPLACEMENTS.get(propertyType);\n        if (boxedType != null) {\n            throw invalidMethod(type, getterName, String.format(\"%s is not a supported property type, use %s instead\", propertyType, boxedType.getName()));\n        }\n        if (!isSupportedUnmanagedType(propertyType)) {\n            String supportedTypes = Joiner.on(\", \").join(SUPPORTED_UNMANAGED_TYPES);\n            throw invalidMethod(type, getterName, String.format(\"%s is not a supported property type, only managed and the following unmanaged types are supported: %s\", propertyType, supportedTypes));\n        }\n\n        String propertyNameCapitalized = getterName.substring(3);\n        final String propertyName = StringUtils.uncapitalize(propertyNameCapitalized);\n        String setterName = \"set\" + propertyNameCapitalized;\n\n        if (!methods.containsKey(setterName)) {\n            throw invalidMethod(type, getterName, \"no corresponding setter for getter\");\n        }\n\n        validateSetter(type, propertyType, methods.get(setterName));\n        handled.add(setterName);\n        return new ModelProperty<P>(propertyName, propertyType);\n    }","commit_id":"637e5fd1649b6004af3b32d0e13d9c912690114e","url":"https://github.com/gradle/gradle"},{"original_method":"public <T> ModelSchemaExtractionResult<T> extract(final ModelType<T> type, ModelSchemaCache cache, final ModelSchemaExtractionContext context) {\n        validateType(type);\n\n        List<Method> methodList = Arrays.asList(type.getRawClass().getDeclaredMethods());\n        if (methodList.isEmpty()) {\n            ManagedTypeInstantiator<T> elementInstantiator = new ManagedTypeInstantiator<T>();\n            ModelSchema<T> schema = new ModelSchema<T>(type, elementInstantiator);\n            elementInstantiator.setSchema(schema);\n            return new ModelSchemaExtractionResult<T>(schema);\n        }\n\n        List<ModelProperty<?>> properties = Lists.newLinkedList();\n\n        Map<String, Method> methods = Maps.newHashMap();\n        for (Method method : methodList) {\n            String name = method.getName();\n            if (methods.containsKey(name)) {\n                throw invalidMethod(type, name, \"overloaded methods are not supported\");\n            }\n            methods.put(name, method);\n        }\n\n        List<String> methodNames = Lists.newLinkedList(methods.keySet());\n        List<String> handled = Lists.newArrayList();\n\n        for (String methodName : methodNames) {\n            Method method = methods.get(methodName);\n            if (methodName.startsWith(\"get\") && !methodName.equals(\"get\")) {\n                if (method.getParameterTypes().length != 0) {\n                    throw invalidMethod(type, methodName, \"getter methods cannot take parameters\");\n                }\n\n                Character getterPropertyNameFirstChar = methodName.charAt(3);\n                if (!Character.isUpperCase(getterPropertyNameFirstChar)) {\n                    throw invalidMethod(type, methodName, \"the 4th character of the getter method name must be an uppercase character\");\n                }\n\n                ModelType<?> returnType = ModelType.of(method.getGenericReturnType());\n                if (isManaged(returnType)) {\n                    properties.add(extractPropertyOfManagedType(cache, type, methods, methodName, returnType, handled));\n                } else {\n                    properties.add(extractPropertyOfUnmanagedType(type, methods, methodName, returnType, handled));\n                }\n                handled.add(methodName);\n            }\n        }\n\n        methodNames.removeAll(handled);\n\n        // TODO - should call out valid getters without setters\n        if (!methodNames.isEmpty()) {\n            throw invalid(type, \"only paired getter/setter methods are supported (invalid methods: [\" + Joiner.on(\", \").join(methodNames) + \"])\");\n        }\n\n        ManagedTypeInstantiator<T> elementInstantiator = new ManagedTypeInstantiator<T>();\n        ModelSchema<T> schema = new ModelSchema<T>(type, properties, elementInstantiator);\n        elementInstantiator.setSchema(schema);\n        Iterable<? extends ModelSchemaExtractionContext> dependencies = getModelSchemaDependencies(properties, type, context);\n        return new ModelSchemaExtractionResult<T>(schema, dependencies);\n    }","id":65748,"modified_method":"public <R extends T> ModelSchemaExtractionResult<R> extract(final ModelType<R> type, ModelSchemaCache cache, final ModelSchemaExtractionContext context) {\n        validateType(type);\n\n        List<Method> methodList = Arrays.asList(type.getRawClass().getDeclaredMethods());\n        if (methodList.isEmpty()) {\n            ManagedTypeInstantiator<R> elementInstantiator = new ManagedTypeInstantiator<R>();\n            ModelSchema<R> schema = new ModelSchema<R>(type, elementInstantiator);\n            elementInstantiator.setSchema(schema);\n            return new ModelSchemaExtractionResult<R>(schema);\n        }\n\n        List<ModelProperty<?>> properties = Lists.newLinkedList();\n\n        Map<String, Method> methods = Maps.newHashMap();\n        for (Method method : methodList) {\n            String name = method.getName();\n            if (methods.containsKey(name)) {\n                throw invalidMethod(type, name, \"overloaded methods are not supported\");\n            }\n            methods.put(name, method);\n        }\n\n        List<String> methodNames = Lists.newLinkedList(methods.keySet());\n        List<String> handled = Lists.newArrayList();\n\n        for (String methodName : methodNames) {\n            Method method = methods.get(methodName);\n            if (methodName.startsWith(\"get\") && !methodName.equals(\"get\")) {\n                if (method.getParameterTypes().length != 0) {\n                    throw invalidMethod(type, methodName, \"getter methods cannot take parameters\");\n                }\n\n                Character getterPropertyNameFirstChar = methodName.charAt(3);\n                if (!Character.isUpperCase(getterPropertyNameFirstChar)) {\n                    throw invalidMethod(type, methodName, \"the 4th character of the getter method name must be an uppercase character\");\n                }\n\n                ModelType<?> returnType = ModelType.of(method.getGenericReturnType());\n                if (isManaged(returnType)) {\n                    properties.add(extractPropertyOfManagedType(cache, type, methods, methodName, returnType, handled));\n                } else {\n                    properties.add(extractPropertyOfUnmanagedType(type, methods, methodName, returnType, handled));\n                }\n                handled.add(methodName);\n            }\n        }\n\n        methodNames.removeAll(handled);\n\n        // TODO - should call out valid getters without setters\n        if (!methodNames.isEmpty()) {\n            throw new InvalidManagedModelElementTypeException(type, \"only paired getter/setter methods are supported (invalid methods: [\" + Joiner.on(\", \").join(methodNames) + \"])\");\n        }\n\n        ManagedTypeInstantiator<R> elementInstantiator = new ManagedTypeInstantiator<R>();\n        ModelSchema<R> schema = new ModelSchema<R>(type, properties, elementInstantiator);\n        elementInstantiator.setSchema(schema);\n        Iterable<? extends ModelSchemaExtractionContext> dependencies = getModelSchemaDependencies(properties, type, context);\n        return new ModelSchemaExtractionResult<R>(schema, dependencies);\n    }","commit_id":"637e5fd1649b6004af3b32d0e13d9c912690114e","url":"https://github.com/gradle/gradle"},{"original_method":"private <T> ModelSchemaExtractionResult<T> extractSchema(final ModelType<T> type, ModelSchemaCache cache, ModelSchemaExtractionContext context) {\n        ModelSchema<T> cached = cache.get(type);\n        if (cached != null) {\n            return new ModelSchemaExtractionResult<T>(cached);\n        }\n\n        ModelSchemaExtractionHandler handler = Iterables.find(EXTRACTION_HANDLERS, new Predicate<ModelSchemaExtractionHandler>() {\n            public boolean apply(ModelSchemaExtractionHandler candidate) {\n                return candidate.getSupportedSuperType().isAssignableFrom(type) && candidate.getSpec().isSatisfiedBy(type);\n            }\n        });\n\n        ModelSchemaExtractionResult<T> schemaExtraction = handler.extract(type, cache, context);\n        cache.set(type, schemaExtraction.getSchema());\n        return schemaExtraction;\n    }","id":65749,"modified_method":"private <T> ModelSchemaExtractionResult<T> extractSchema(final ModelType<T> type, ModelSchemaCache cache, ModelSchemaExtractionContext context) {\n        ModelSchema<T> cached = cache.get(type);\n        if (cached != null) {\n            return new ModelSchemaExtractionResult<T>(cached);\n        }\n\n        ModelSchemaExtractionHandler<?> handler = Iterables.find(EXTRACTION_HANDLERS, new Predicate<ModelSchemaExtractionHandler<?>>() {\n            public boolean apply(ModelSchemaExtractionHandler<?> candidate) {\n                if (candidate.getType().isAssignableFrom(type)) {\n                    ModelSchemaExtractionHandler<? super T> castCandidate = Cast.uncheckedCast(candidate);\n                    return castCandidate.getSpec().isSatisfiedBy(type);\n                } else {\n                    return false;\n                }\n            }\n        });\n\n        ModelSchemaExtractionHandler<? super T> castHandler = Cast.uncheckedCast(handler);\n        ModelSchemaExtractionResult<T> schemaExtraction = castHandler.extract(type, cache, context);\n        cache.set(type, schemaExtraction.getSchema());\n        return schemaExtraction;\n    }","commit_id":"637e5fd1649b6004af3b32d0e13d9c912690114e","url":"https://github.com/gradle/gradle"},{"original_method":"public <T> ModelSchemaExtractionResult<T> extract(ModelType<T> type, ModelSchemaCache cache, ModelSchemaExtractionContext context) {\n        throw new UnmanagedModelElementTypeException(type);\n    }","id":65750,"modified_method":"public <R> ModelSchemaExtractionResult<R> extract(ModelType<R> type, ModelSchemaCache cache, ModelSchemaExtractionContext context) {\n        throw new UnmanagedModelElementTypeException(type);\n    }","commit_id":"637e5fd1649b6004af3b32d0e13d9c912690114e","url":"https://github.com/gradle/gradle"},{"original_method":"public CharSequenceNotationConverter(NotationConverter<String, ? extends T> delegate) {\n        this.delegate = delegate;\n    }","id":65751,"modified_method":"public CharSequenceNotationConverter(NotationConverter<? super String, ? extends T> delegate) {\n        this.delegate = delegate;\n    }","commit_id":"96321422562fca0dc2a381ad6deb9a9e0258a37f","url":"https://github.com/gradle/gradle"},{"original_method":"public Object convert(Object notation, Class<?> type, boolean primitive) throws TypeConversionException {\n\n        if (notation == null) {\n            if (primitive) {\n                throw new UnsupportedNotationException(notation,\n                    String.format(\"Cannot assign null value to primitive type %s.\", UNBOXED_TYPES.get(type).getSimpleName()), null, CANDIDATES);\n            }\n\n            return null;\n        }\n        if (type.isInstance(notation)) {\n            return notation;\n        }\n\n        if (type.isEnum()) {\n            return NotationParserBuilder\n                .toType(type)\n                .noImplicitConverters()\n                .converter(new CharSequenceNotationConverter(new EnumConverter(type)))\n                .toComposite().parseNotation(notation);\n        }\n\n        NotationParser<Object, ?> parser;\n        if (File.class.equals(type)) {\n            parser = fileParser;\n        } else {\n            parser = parsers.get(primitive ? UNBOXED_TYPES.get(type) : type);\n            if (parser == null) {\n                throw new UnsupportedNotationException(notation, \"Unsupported type\", null, CANDIDATES);\n            }\n        }\n\n        return parser.parseNotation(notation);\n    }","id":65752,"modified_method":"public Object convert(Object notation, Class<?> type, boolean primitive) throws TypeConversionException {\n\n        if (notation == null) {\n            if (primitive) {\n                throw new UnsupportedNotationException(notation,\n                    String.format(\"Cannot assign null value to primitive type %s.\", UNBOXED_TYPES.get(type).getSimpleName()), null, CANDIDATES);\n            }\n\n            return null;\n        }\n        if (type.isInstance(notation)) {\n            return notation;\n        }\n\n        if (type.isEnum()) {\n            Class<? extends Enum> enumType = Cast.uncheckedCast(type);\n            return convertEnum(enumType, notation);\n        }\n\n        NotationParser<Object, ?> parser;\n        if (File.class.equals(type)) {\n            parser = fileParser;\n        } else {\n            parser = parsers.get(primitive ? UNBOXED_TYPES.get(type) : type);\n            if (parser == null) {\n                throw new UnsupportedNotationException(notation, \"Unsupported type\", null, CANDIDATES);\n            }\n        }\n\n        return parser.parseNotation(notation);\n    }","commit_id":"96321422562fca0dc2a381ad6deb9a9e0258a37f","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * Adds a converter that accepts any CharSequence notation.\n     */\n    public NotationParserBuilder<T> fromCharSequence(NotationConverter<String, ? extends T> converter) {\n        this.notationParsers.add(new CharSequenceNotationConverter<Object, T>(converter));\n        return this;\n    }","id":65753,"modified_method":"/**\n     * Adds a converter that accepts any CharSequence notation.\n     */\n    public NotationParserBuilder<T> fromCharSequence(NotationConverter<? super String, ? extends T> converter) {\n        this.notationParsers.add(new CharSequenceNotationConverter<Object, T>(converter));\n        return this;\n    }","commit_id":"96321422562fca0dc2a381ad6deb9a9e0258a37f","url":"https://github.com/gradle/gradle"},{"original_method":"public <T> NotationParser<CharSequence, T> toComposite(Class<T> targetType) throws OptionValidationException {\n        assert targetType != null : \"resultingType cannot be null\";\n        if (targetType == Void.TYPE) {\n            return new UnsupportedNotationParser<T>();\n        }\n\n        if (targetType.isAssignableFrom(String.class)) {\n            return Cast.uncheckedCast(new NoDescriptionValuesJustReturningParser());\n        }\n        if (targetType.isEnum()) {\n            return Cast.uncheckedCast(new EnumFromCharSequenceNotationParser<Enum>(targetType.asSubclass(Enum.class)));\n        }\n\n        throw new OptionValidationException(String.format(\"Don't know how to convert strings to type '%s'.\", targetType.getName()));\n    }","id":65754,"modified_method":"public <T> NotationParser<CharSequence, T> toComposite(Class<T> targetType) throws OptionValidationException {\n        assert targetType != null : \"resultingType cannot be null\";\n        if (targetType == Void.TYPE) {\n            return new UnsupportedNotationParser<T>();\n        }\n\n        if (targetType.isAssignableFrom(String.class)) {\n            return Cast.uncheckedCast(new NoDescriptionValuesJustReturningParser());\n        }\n        if (targetType.isEnum()) {\n            NotationConverter<CharSequence, T> converter = Cast.uncheckedCast(new EnumFromCharSequenceNotationParser<Enum>(targetType.asSubclass(Enum.class)));\n            return new NotationConverterToNotationParserAdapter<CharSequence, T>(converter);\n        }\n\n        throw new OptionValidationException(String.format(\"Don't know how to convert strings to type '%s'.\", targetType.getName()));\n    }","commit_id":"96321422562fca0dc2a381ad6deb9a9e0258a37f","url":"https://github.com/gradle/gradle"},{"original_method":"private static <T, S> T adaptToEnum(Class<T> targetType, S sourceObject) {\n        try {\n            String literal;\n            if (sourceObject instanceof Enum) {\n                literal = ((Enum<?>) sourceObject).name();\n            } else if (sourceObject instanceof String) {\n                literal = (String) sourceObject;\n            } else {\n                literal = sourceObject.toString();\n            }\n            EnumFromCharSequenceNotationParser parser = new EnumFromCharSequenceNotationParser(targetType);\n            Enum parsedLiteral = parser.parseNotation(literal);\n            return targetType.cast(parsedLiteral);\n        } catch (TypeConversionException e) {\n            throw new IllegalArgumentException(String.format(\"Can't convert '%s' to enum type '%s'\", sourceObject, targetType.getSimpleName()));\n        }\n    }","id":65755,"modified_method":"private static <T, S> T adaptToEnum(Class<T> targetType, S sourceObject) {\n        try {\n            String literal;\n            if (sourceObject instanceof Enum) {\n                literal = ((Enum<?>) sourceObject).name();\n            } else if (sourceObject instanceof String) {\n                literal = (String) sourceObject;\n            } else {\n                literal = sourceObject.toString();\n            }\n            NotationParser<String, T> parser = new NotationConverterToNotationParserAdapter<String, T>(new EnumFromCharSequenceNotationParser(targetType));\n            T parsedLiteral = parser.parseNotation(literal);\n            return targetType.cast(parsedLiteral);\n        } catch (TypeConversionException e) {\n            throw new IllegalArgumentException(String.format(\"Can't convert '%s' to enum type '%s'\", sourceObject, targetType.getSimpleName()), e);\n        }\n    }","commit_id":"96321422562fca0dc2a381ad6deb9a9e0258a37f","url":"https://github.com/gradle/gradle"},{"original_method":"static public <T extends Enum<T>> T toEnumValue(Class<T> enumType, CharSequence charSequence) {\n        EnumFromCharSequenceNotationParser<T> notationParser = new EnumFromCharSequenceNotationParser<T>(enumType);\n        return notationParser.parseNotation(charSequence);\n    }","id":65756,"modified_method":"static public <T extends Enum<T>> T toEnumValue(Class<T> enumType, CharSequence charSequence) {\n        return NotationParserBuilder\n                .toType(enumType)\n                .noImplicitConverters()\n                .fromCharSequence(new EnumFromCharSequenceNotationParser<T>(enumType))\n                .toComposite()\n                .parseNotation(charSequence);\n    }","commit_id":"96321422562fca0dc2a381ad6deb9a9e0258a37f","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public FileWatcher createFileWatcher() {\n        if(JavaVersion.current().isJava7Compatible()) {\n            Class clazz;\n            try {\n                clazz = this.getClass().getClassLoader().loadClass(\"org.gradle.internal.filewatch.jdk7.DefaultFileWatcher\");\n            } catch (ClassNotFoundException e) {\n                throw new RuntimeException(\"Cannot find FileWatcher implementation class\", e);\n            }\n            Constructor<?> constructor = null;\n            try {\n                constructor = clazz.getConstructor(ExecutorService.class);\n            } catch (NoSuchMethodException e) {\n                throw new RuntimeException(\"Cannot find constructor in FileWatcher class\", e);\n            }\n            try {\n                return Cast.uncheckedCast(constructor.newInstance(executor));\n            } catch (Exception e) {\n                throw new RuntimeException(\"Cannot instantiate FileWatcher implementation\", e);\n            }\n        } else {\n            throw new RuntimeException(\"FileWatcher is only available on Java 7 compatible JVMs\");\n        }\n    }","id":65757,"modified_method":"@Override\n    public FileWatcher createFileWatcher() {\n        if(JavaVersion.current().isJava7Compatible()) {\n            Class clazz;\n            try {\n                clazz = this.getClass().getClassLoader().loadClass(\"org.gradle.internal.filewatch.jdk7.DefaultFileWatcher\");\n            } catch (ClassNotFoundException e) {\n                throw new RuntimeException(\"Cannot find FileWatcher implementation class\", e);\n            }\n            return Cast.uncheckedCast(DirectInstantiator.instantiate(clazz, executor));\n        } else {\n            throw new RuntimeException(\"FileWatcher is only available on Java 7 compatible JVMs\");\n        }\n    }","commit_id":"a52979f63f44730f97f729866d01cfbefc588337","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n\tpublic void processAction(\n\t\t\tStrutsPortletAction originalStrutsPortletAction,\n\t\t\tPortletConfig portletConfig, ActionRequest actionRequest,\n\t\t\tActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString actionName = ParamUtil.getString(\n\t\t\tactionRequest, ActionRequest.ACTION_NAME);\n\n\t\tif (actionName.equals(\"updateFieldGroup\")) {\n\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\ttry {\n\t\t\t\tupdateProjectsEntries(actionRequest, actionResponse);\n\n\t\t\t\tString redirect = ParamUtil.getString(\n\t\t\t\t\tactionRequest, \"redirect\");\n\n\t\t\t\tjsonObject.put(\"redirect\", redirect);\n\t\t\t\tjsonObject.put(\"success\", true);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tThemeDisplay themeDisplay =\n\t\t\t\t\t(ThemeDisplay)actionRequest.getAttribute(\n\t\t\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t\t\tString message = LanguageUtil.get(\n\t\t\t\t\tthemeDisplay.getLocale(),\n\t\t\t\t\t\"your-request-failed-to-complete\");\n\n\t\t\t\tjsonObject.put(\"message\", message);\n\t\t\t\tjsonObject.put(\"success\", false);\n\t\t\t}\n\n\t\t\tHttpServletResponse response = PortalUtil.getHttpServletResponse(\n\t\t\t\tactionResponse);\n\n\t\t\tresponse.setContentType(ContentTypes.TEXT_JAVASCRIPT);\n\n\t\t\tServletResponseUtil.write(response, jsonObject.toString());\n\t\t}\n\t\telse {\n\t\t\tupdateProjectsEntries(actionRequest, actionResponse);\n\n\t\t\tDynamicActionRequest dynamicActionRequest =\n\t\t\t\tnew DynamicActionRequest(actionRequest);\n\n\t\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\t\tif (cmd.equals(Constants.UPDATE)) {\n\t\t\t\tUser user = PortalUtil.getSelectedUser(actionRequest);\n\n\t\t\t\tList<Role> roles = user.getRoles();\n\n\t\t\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\t\t\tuser.getCompanyId(), RoleConstants.SOCIAL_OFFICE_USER);\n\n\t\t\t\tlong[] roleIds = getLongArray(\n\t\t\t\t\tactionRequest, \"rolesSearchContainerPrimaryKeys\");\n\n\t\t\t\tboolean newSocialOfficeUser = ArrayUtil.contains(\n\t\t\t\t\troleIds, role.getRoleId());\n\n\t\t\t\tif (newSocialOfficeUser && !roles.contains(role)) {\n\t\t\t\t\tLayoutSetPrototype publicLayoutSetPrototype =\n\t\t\t\t\t\tLayoutSetPrototypeUtil.fetchLayoutSetPrototype(\n\t\t\t\t\t\t\tuser, false);\n\n\t\t\t\t\tif (publicLayoutSetPrototype != null) {\n\t\t\t\t\t\tdynamicActionRequest.setParameter(\n\t\t\t\t\t\t\t\"publicLayoutSetPrototypeId\",\n\t\t\t\t\t\t\tString.valueOf(\n\t\t\t\t\t\t\t\tpublicLayoutSetPrototype.\n\t\t\t\t\t\t\t\t\tgetLayoutSetPrototypeId()));\n\n\t\t\t\t\t\tdynamicActionRequest.setParameter(\n\t\t\t\t\t\t\t\"publicLayoutSetPrototypeId\",\n\t\t\t\t\t\t\tString.valueOf(\n\t\t\t\t\t\t\t\tpublicLayoutSetPrototype.\n\t\t\t\t\t\t\t\t\tgetLayoutSetPrototypeId()));\n\t\t\t\t\t}\n\n\t\t\t\t\tLayoutSetPrototype privateLayoutSetPrototype =\n\t\t\t\t\t\tLayoutSetPrototypeUtil.fetchLayoutSetPrototype(\n\t\t\t\t\t\t\tuser, true);\n\n\t\t\t\t\tif (privateLayoutSetPrototype != null) {\n\t\t\t\t\t\tdynamicActionRequest.setParameter(\n\t\t\t\t\t\t\t\"privateLayoutSetPrototypeId\",\n\t\t\t\t\t\t\tString.valueOf(\n\t\t\t\t\t\t\t\tprivateLayoutSetPrototype.\n\t\t\t\t\t\t\t\t\tgetLayoutSetPrototypeId()));\n\n\t\t\t\t\t\tdynamicActionRequest.setParameter(\n\t\t\t\t\t\t\t\"privateLayoutSetPrototypeLinkEnabled\",\n\t\t\t\t\t\t\tString.valueOf(true));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (!newSocialOfficeUser && roles.contains(role)) {\n\t\t\t\t\tdynamicActionRequest.setParameter(\n\t\t\t\t\t\t\"publicLayoutSetPrototypeId\", StringPool.BLANK);\n\t\t\t\t\tdynamicActionRequest.setParameter(\n\t\t\t\t\t\t\"privateLayoutSetPrototypeId\", StringPool.BLANK);\n\t\t\t\t\tdynamicActionRequest.setParameter(\n\t\t\t\t\t\t\"publicLayoutSetPrototypeLinkEnabled\",\n\t\t\t\t\t\tString.valueOf(false));\n\t\t\t\t\tdynamicActionRequest.setParameter(\n\t\t\t\t\t\t\"privateLayoutSetPrototypeLinkEnabled\",\n\t\t\t\t\t\tString.valueOf(false));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toriginalStrutsPortletAction.processAction(\n\t\t\t\tportletConfig, dynamicActionRequest, actionResponse);\n\t\t}\n\t}","id":65758,"modified_method":"@Override\n\tpublic void processAction(\n\t\t\tStrutsPortletAction originalStrutsPortletAction,\n\t\t\tPortletConfig portletConfig, ActionRequest actionRequest,\n\t\t\tActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString actionName = ParamUtil.getString(\n\t\t\tactionRequest, ActionRequest.ACTION_NAME);\n\n\t\tif (actionName.equals(\"updateFieldGroup\")) {\n\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\ttry {\n\t\t\t\tupdateProjectsEntries(actionRequest, actionResponse);\n\n\t\t\t\tString redirect = ParamUtil.getString(\n\t\t\t\t\tactionRequest, \"redirect\");\n\n\t\t\t\tjsonObject.put(\"redirect\", redirect);\n\t\t\t\tjsonObject.put(\"success\", true);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tThemeDisplay themeDisplay =\n\t\t\t\t\t(ThemeDisplay)actionRequest.getAttribute(\n\t\t\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t\t\tString message = LanguageUtil.get(\n\t\t\t\t\tthemeDisplay.getLocale(),\n\t\t\t\t\t\"your-request-failed-to-complete\");\n\n\t\t\t\tjsonObject.put(\"message\", message);\n\t\t\t\tjsonObject.put(\"success\", false);\n\t\t\t}\n\n\t\t\tHttpServletResponse response = PortalUtil.getHttpServletResponse(\n\t\t\t\tactionResponse);\n\n\t\t\tresponse.setContentType(ContentTypes.TEXT_JAVASCRIPT);\n\n\t\t\tServletResponseUtil.write(response, jsonObject.toString());\n\t\t}\n\t\telse {\n\t\t\tupdateProjectsEntries(actionRequest, actionResponse);\n\n\t\t\tDynamicActionRequest dynamicActionRequest =\n\t\t\t\tnew DynamicActionRequest(actionRequest);\n\n\t\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\t\tif (cmd.equals(Constants.UPDATE)) {\n\t\t\t\tUser user = PortalUtil.getSelectedUser(actionRequest);\n\n\t\t\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\t\t\tuser.getCompanyId(), RoleConstants.SOCIAL_OFFICE_USER);\n\n\t\t\t\tlong[] roleIds = getLongArray(\n\t\t\t\t\tactionRequest, \"rolesSearchContainerPrimaryKeys\");\n\n\t\t\t\tboolean newSocialOfficeUser = ArrayUtil.contains(\n\t\t\t\t\troleIds, role.getRoleId());\n\n\t\t\t\tList<Role> roles = user.getRoles();\n\n\t\t\t\tif (newSocialOfficeUser && !roles.contains(role)) {\n\t\t\t\t\tLayoutSetPrototype publicLayoutSetPrototype =\n\t\t\t\t\t\tLayoutSetPrototypeUtil.fetchLayoutSetPrototype(\n\t\t\t\t\t\t\tuser, false);\n\n\t\t\t\t\tif (publicLayoutSetPrototype != null) {\n\t\t\t\t\t\tdynamicActionRequest.setParameter(\n\t\t\t\t\t\t\t\"publicLayoutSetPrototypeId\",\n\t\t\t\t\t\t\tString.valueOf(\n\t\t\t\t\t\t\t\tpublicLayoutSetPrototype.\n\t\t\t\t\t\t\t\t\tgetLayoutSetPrototypeId()));\n\n\t\t\t\t\t\tdynamicActionRequest.setParameter(\n\t\t\t\t\t\t\t\"publicLayoutSetPrototypeId\",\n\t\t\t\t\t\t\tString.valueOf(\n\t\t\t\t\t\t\t\tpublicLayoutSetPrototype.\n\t\t\t\t\t\t\t\t\tgetLayoutSetPrototypeId()));\n\t\t\t\t\t}\n\n\t\t\t\t\tLayoutSetPrototype privateLayoutSetPrototype =\n\t\t\t\t\t\tLayoutSetPrototypeUtil.fetchLayoutSetPrototype(\n\t\t\t\t\t\t\tuser, true);\n\n\t\t\t\t\tif (privateLayoutSetPrototype != null) {\n\t\t\t\t\t\tdynamicActionRequest.setParameter(\n\t\t\t\t\t\t\t\"privateLayoutSetPrototypeId\",\n\t\t\t\t\t\t\tString.valueOf(\n\t\t\t\t\t\t\t\tprivateLayoutSetPrototype.\n\t\t\t\t\t\t\t\t\tgetLayoutSetPrototypeId()));\n\n\t\t\t\t\t\tdynamicActionRequest.setParameter(\n\t\t\t\t\t\t\t\"privateLayoutSetPrototypeLinkEnabled\",\n\t\t\t\t\t\t\tString.valueOf(true));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (!newSocialOfficeUser && roles.contains(role)) {\n\t\t\t\t\tdynamicActionRequest.setParameter(\n\t\t\t\t\t\t\"publicLayoutSetPrototypeId\", StringPool.BLANK);\n\t\t\t\t\tdynamicActionRequest.setParameter(\n\t\t\t\t\t\t\"privateLayoutSetPrototypeId\", StringPool.BLANK);\n\t\t\t\t\tdynamicActionRequest.setParameter(\n\t\t\t\t\t\t\"publicLayoutSetPrototypeLinkEnabled\",\n\t\t\t\t\t\tString.valueOf(false));\n\t\t\t\t\tdynamicActionRequest.setParameter(\n\t\t\t\t\t\t\"privateLayoutSetPrototypeLinkEnabled\",\n\t\t\t\t\t\tString.valueOf(false));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toriginalStrutsPortletAction.processAction(\n\t\t\t\tportletConfig, dynamicActionRequest, actionResponse);\n\t\t}\n\t}","commit_id":"b3ab71b595375222e63f55c148c3850242e74a77","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public static LayoutSetPrototype fetchLayoutSetPrototype(\n\t\t\tUser user, boolean privateLayoutSetPrototype)\n\t\tthrows PortalException, SystemException {\n\n\t\tLayoutSetPrototype layoutSetPrototype = null;\n\n\t\tList<ExpandoValue> expandoValues =\n\t\t\tExpandoValueLocalServiceUtil.getColumnValues(\n\t\t\t\tuser.getCompanyId(), LayoutSetPrototype.class.getName(),\n\t\t\t\tExpandoTableConstants.DEFAULT_TABLE_NAME,\n\t\t\t\tSocialOfficeConstants.LAYOUT_SET_PROTOTYPE_KEY,\n\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\tfor (ExpandoValue expandoValue : expandoValues) {\n\t\t\tLayoutSetPrototype curLayoutSetPrototype =\n\t\t\t\tLayoutSetPrototypeServiceUtil.getLayoutSetPrototype(\n\t\t\t\t\texpandoValue.getClassPK());\n\n\t\t\tString layoutSetPrototypeKey =\n\t\t\t\t(String)curLayoutSetPrototype.getExpandoBridge().getAttribute(\n\t\t\t\t\tSocialOfficeConstants.LAYOUT_SET_PROTOTYPE_KEY);\n\n\t\t\tif (!privateLayoutSetPrototype) {\n\t\t\t\tif (layoutSetPrototypeKey.equals(\n\t\t\t\t\t\tSocialOfficeConstants.\n\t\t\t\t\t\t\tLAYOUT_SET_PROTOTYPE_KEY_USER_PUBLIC)) {\n\n\t\t\t\t\tlayoutSetPrototype = curLayoutSetPrototype;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (layoutSetPrototypeKey.equals(\n\t\t\t\t\t\tSocialOfficeConstants.\n\t\t\t\t\t\t\tLAYOUT_SET_PROTOTYPE_KEY_USER_PRIVATE)) {\n\n\t\t\t\t\tlayoutSetPrototype = curLayoutSetPrototype;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn layoutSetPrototype;\n\t}","id":65759,"modified_method":"public static LayoutSetPrototype fetchLayoutSetPrototype(\n\t\t\tUser user, boolean privateLayoutSetPrototype)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<ExpandoValue> expandoValues =\n\t\t\tExpandoValueLocalServiceUtil.getColumnValues(\n\t\t\t\tuser.getCompanyId(), LayoutSetPrototype.class.getName(),\n\t\t\t\tExpandoTableConstants.DEFAULT_TABLE_NAME,\n\t\t\t\tSocialOfficeConstants.LAYOUT_SET_PROTOTYPE_KEY,\n\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\tfor (ExpandoValue expandoValue : expandoValues) {\n\t\t\tLayoutSetPrototype layoutSetPrototype =\n\t\t\t\tLayoutSetPrototypeServiceUtil.getLayoutSetPrototype(\n\t\t\t\t\texpandoValue.getClassPK());\n\n\t\t\tString layoutSetPrototypeKey =\n\t\t\t\t(String)layoutSetPrototype.getExpandoBridge().getAttribute(\n\t\t\t\t\tSocialOfficeConstants.LAYOUT_SET_PROTOTYPE_KEY);\n\n\t\t\tif (privateLayoutSetPrototype &&\n\t\t\t\tlayoutSetPrototypeKey.equals(\n\t\t\t\t\tSocialOfficeConstants.\n\t\t\t\t\t\tLAYOUT_SET_PROTOTYPE_KEY_USER_PRIVATE)) {\n\n\t\t\t\treturn layoutSetPrototype;\n\t\t\t}\n\t\t\telse if (layoutSetPrototypeKey.equals(\n\t\t\t\t\t\tSocialOfficeConstants.\n\t\t\t\t\t\t\tLAYOUT_SET_PROTOTYPE_KEY_USER_PUBLIC)) {\n\n\t\t\t\treturn layoutSetPrototype;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"b3ab71b595375222e63f55c148c3850242e74a77","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public static LayoutSetPrototype fetchLayoutSetPrototype(\n\t\t\tUser user, boolean privateLayoutSetPrototype)\n\t\tthrows PortalException, SystemException {\n\n\t\tLayoutSetPrototype layoutSetPrototype = null;\n\n\t\tList<ExpandoValue> expandoValues =\n\t\t\tExpandoValueLocalServiceUtil.getColumnValues(\n\t\t\t\tuser.getCompanyId(), LayoutSetPrototype.class.getName(),\n\t\t\t\tExpandoTableConstants.DEFAULT_TABLE_NAME,\n\t\t\t\tSocialOfficeConstants.LAYOUT_SET_PROTOTYPE_KEY,\n\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\tfor (ExpandoValue expandoValue : expandoValues) {\n\t\t\tLayoutSetPrototype curLayoutSetPrototype =\n\t\t\t\tLayoutSetPrototypeServiceUtil.getLayoutSetPrototype(\n\t\t\t\t\texpandoValue.getClassPK());\n\n\t\t\tString layoutSetPrototypeKey =\n\t\t\t\t(String)curLayoutSetPrototype.getExpandoBridge().getAttribute(\n\t\t\t\t\tSocialOfficeConstants.LAYOUT_SET_PROTOTYPE_KEY);\n\n\t\t\tif (!privateLayoutSetPrototype) {\n\t\t\t\tif (layoutSetPrototypeKey.equals(\n\t\t\t\t\t\tSocialOfficeConstants.\n\t\t\t\t\t\t\tLAYOUT_SET_PROTOTYPE_KEY_USER_PUBLIC)) {\n\n\t\t\t\t\tlayoutSetPrototype = curLayoutSetPrototype;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (layoutSetPrototypeKey.equals(\n\t\t\t\t\t\tSocialOfficeConstants.\n\t\t\t\t\t\t\tLAYOUT_SET_PROTOTYPE_KEY_USER_PRIVATE)) {\n\n\t\t\t\t\tlayoutSetPrototype = curLayoutSetPrototype;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn layoutSetPrototype;\n\t}","id":65760,"modified_method":"public static LayoutSetPrototype fetchLayoutSetPrototype(\n\t\t\tUser user, boolean privateLayoutSetPrototype)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<ExpandoValue> expandoValues =\n\t\t\tExpandoValueLocalServiceUtil.getColumnValues(\n\t\t\t\tuser.getCompanyId(), LayoutSetPrototype.class.getName(),\n\t\t\t\tExpandoTableConstants.DEFAULT_TABLE_NAME,\n\t\t\t\tSocialOfficeConstants.LAYOUT_SET_PROTOTYPE_KEY,\n\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\tfor (ExpandoValue expandoValue : expandoValues) {\n\t\t\tLayoutSetPrototype layoutSetPrototype =\n\t\t\t\tLayoutSetPrototypeServiceUtil.getLayoutSetPrototype(\n\t\t\t\t\texpandoValue.getClassPK());\n\n\t\t\tString layoutSetPrototypeKey =\n\t\t\t\t(String)layoutSetPrototype.getExpandoBridge().getAttribute(\n\t\t\t\t\tSocialOfficeConstants.LAYOUT_SET_PROTOTYPE_KEY);\n\n\t\t\tif (privateLayoutSetPrototype &&\n\t\t\t\tlayoutSetPrototypeKey.equals(\n\t\t\t\t\tSocialOfficeConstants.\n\t\t\t\t\t\tLAYOUT_SET_PROTOTYPE_KEY_USER_PRIVATE)) {\n\n\t\t\t\treturn layoutSetPrototype;\n\t\t\t}\n\t\t\telse if (layoutSetPrototypeKey.equals(\n\t\t\t\t\t\tSocialOfficeConstants.\n\t\t\t\t\t\t\tLAYOUT_SET_PROTOTYPE_KEY_USER_PUBLIC)) {\n\n\t\t\t\treturn layoutSetPrototype;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"b3ab71b595375222e63f55c148c3850242e74a77","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic void onAfterAddAssociation(\n\t\t\tObject classPK, String associationClassName,\n\t\t\tObject associationClassPK)\n\t\tthrows ModelListenerException {\n\n\t\ttry {\n\t\t\tif (!associationClassName.equals(Role.class.getName())) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlong roleId = (Long)associationClassPK;\n\n\t\t\tRole role = RoleLocalServiceUtil.getRole(roleId);\n\n\t\t\tString name = role.getName();\n\n\t\t\tif (name.equals(RoleConstants.SOCIAL_OFFICE_USER)) {\n\t\t\t\tlong userId = (Long)classPK;\n\n\t\t\t\tUser user = UserLocalServiceUtil.getUser(userId);\n\n\t\t\t\tGroup group = user.getGroup();\n\n\t\t\t\tLayoutSetPrototype publicLayoutSetPrototype =\n\t\t\t\t\tLayoutSetPrototypeUtil.fetchLayoutSetPrototype(user, false);\n\n\t\t\t\tif (publicLayoutSetPrototype != null) {\n\t\t\t\t\tLayoutSetLocalServiceUtil.\n\t\t\t\t\t\tupdateLayoutSetPrototypeLinkEnabled(\n\t\t\t\t\t\t\tgroup.getGroupId(), false, true,\n\t\t\t\t\t\t\tpublicLayoutSetPrototype.getUuid());\n\n\t\t\t\t\tLayoutSet layoutSet =\n\t\t\t\t\t\tLayoutSetLocalServiceUtil.getLayoutSet(\n\t\t\t\t\t\t\tgroup.getGroupId(), false);\n\n\t\t\t\t\tPortalClassInvoker.invoke(\n\t\t\t\t\t\ttrue, _mergeLayoutSetProtypeLayoutsMethodKey, group,\n\t\t\t\t\t\tlayoutSet);\n\n\t\t\t\t\torderLayouts(getUserLayoutPlids(group, false));\n\t\t\t\t}\n\n\t\t\t\tLayoutSetPrototype privateLayoutSetPrototype =\n\t\t\t\t\tLayoutSetPrototypeUtil.fetchLayoutSetPrototype(user, true);\n\n\t\t\t\tif (privateLayoutSetPrototype != null) {\n\t\t\t\t\tLayoutSetLocalServiceUtil.\n\t\t\t\t\t\tupdateLayoutSetPrototypeLinkEnabled(\n\t\t\t\t\t\t\tgroup.getGroupId(), true, true,\n\t\t\t\t\t\t\tprivateLayoutSetPrototype.getUuid());\n\n\t\t\t\t\tLayoutSet layoutSet =\n\t\t\t\t\t\tLayoutSetLocalServiceUtil.getLayoutSet(\n\t\t\t\t\t\t\tgroup.getGroupId(), true);\n\n\t\t\t\t\tPortalClassInvoker.invoke(\n\t\t\t\t\t\ttrue, _mergeLayoutSetProtypeLayoutsMethodKey, group,\n\t\t\t\t\t\tlayoutSet);\n\n\t\t\t\t\torderLayouts(getUserLayoutPlids(group, true));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new ModelListenerException(e);\n\t\t}\n\t}","id":65761,"modified_method":"@Override\n\tpublic void onAfterAddAssociation(\n\t\t\tObject classPK, String associationClassName,\n\t\t\tObject associationClassPK)\n\t\tthrows ModelListenerException {\n\n\t\ttry {\n\t\t\tif (!associationClassName.equals(Role.class.getName())) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tRole role = RoleLocalServiceUtil.getRole((Long)associationClassPK);\n\n\t\t\tString name = role.getName();\n\n\t\t\tif (!name.equals(RoleConstants.SOCIAL_OFFICE_USER)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tUser user = UserLocalServiceUtil.getUser((Long)classPK);\n\n\t\t\tGroup group = user.getGroup();\n\n\t\t\tLayoutSetPrototype publicLayoutSetPrototype =\n\t\t\t\tLayoutSetPrototypeUtil.fetchLayoutSetPrototype(user, false);\n\n\t\t\tif (publicLayoutSetPrototype != null) {\n\t\t\t\tLayoutSetLocalServiceUtil.updateLayoutSetPrototypeLinkEnabled(\n\t\t\t\t\tgroup.getGroupId(), false, true,\n\t\t\t\t\tpublicLayoutSetPrototype.getUuid());\n\n\t\t\t\tLayoutSet layoutSet = LayoutSetLocalServiceUtil.getLayoutSet(\n\t\t\t\t\tgroup.getGroupId(), false);\n\n\t\t\t\tPortalClassInvoker.invoke(\n\t\t\t\t\ttrue, _mergeLayoutSetProtypeLayoutsMethodKey, group,\n\t\t\t\t\tlayoutSet);\n\n\t\t\t\torderUserLayouts(group, false);\n\t\t\t}\n\n\t\t\tLayoutSetPrototype privateLayoutSetPrototype =\n\t\t\t\tLayoutSetPrototypeUtil.fetchLayoutSetPrototype(user, true);\n\n\t\t\tif (privateLayoutSetPrototype != null) {\n\t\t\t\tLayoutSetLocalServiceUtil.updateLayoutSetPrototypeLinkEnabled(\n\t\t\t\t\tgroup.getGroupId(), true, true,\n\t\t\t\t\tprivateLayoutSetPrototype.getUuid());\n\n\t\t\t\tLayoutSet layoutSet = LayoutSetLocalServiceUtil.getLayoutSet(\n\t\t\t\t\tgroup.getGroupId(), true);\n\n\t\t\t\tPortalClassInvoker.invoke(\n\t\t\t\t\ttrue, _mergeLayoutSetProtypeLayoutsMethodKey, group,\n\t\t\t\t\tlayoutSet);\n\n\t\t\t\torderUserLayouts(group, true);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new ModelListenerException(e);\n\t\t}\n\t}","commit_id":"b3ab71b595375222e63f55c148c3850242e74a77","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected long[] getUserLayoutPlids(Group group, boolean privateLayout)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<Layout> layouts =\n\t\t\tLayoutLocalServiceUtil.getLayouts(\n\t\t\t\tgroup.getGroupId(), privateLayout,\n\t\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID);\n\n\t\tint size = layouts.size();\n\n\t\tlong[] plids = new long[size];\n\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tLayout layout = layouts.get(i);\n\n\t\t\tplids[i] = layout.getPlid();\n\t\t}\n\n\t\treturn plids;\n\t}","id":65762,"modified_method":"protected void orderUserLayouts(Group group, boolean privateLayout)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<Layout> layouts =\n\t\t\tLayoutLocalServiceUtil.getLayouts(\n\t\t\t\tgroup.getGroupId(), privateLayout,\n\t\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID);\n\n\t\tfor (int i = 0; i < layouts.size(); i++) {\n\t\t\tLayout layout = layouts.get(i);\n\n\t\t\tLayoutLocalServiceUtil.updatePriority(\n\t\t\t\tlayout.getPlid(), _PRIORITY + i);\n\t\t}\n\t}","commit_id":"b3ab71b595375222e63f55c148c3850242e74a77","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic void onAfterRemoveAssociation(\n\t\t\tObject classPK, String associationClassName,\n\t\t\tObject associationClassPK)\n\t\tthrows ModelListenerException {\n\n\t\ttry {\n\t\t\tif (!associationClassName.equals(Role.class.getName())) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlong roleId = (Long)associationClassPK;\n\n\t\t\tRole role = RoleLocalServiceUtil.getRole(roleId);\n\n\t\t\tString name = role.getName();\n\n\t\t\tif (name.equals(RoleConstants.SOCIAL_OFFICE_USER)) {\n\t\t\t\tlong userId = (Long)classPK;\n\n\t\t\t\tUser user = UserLocalServiceUtil.getUser(userId);\n\n\t\t\t\tLayoutSetPrototype publicLayoutSetPrototype =\n\t\t\t\t\tLayoutSetPrototypeUtil.fetchLayoutSetPrototype(user, false);\n\n\t\t\t\tremoveUserLayouts(\n\t\t\t\t\tuser, false, publicLayoutSetPrototype.getUuid());\n\n\t\t\t\tLayoutSetPrototype privateLayoutSetPrototype =\n\t\t\t\t\tLayoutSetPrototypeUtil.fetchLayoutSetPrototype(user, true);\n\n\t\t\t\tremoveUserLayouts(\n\t\t\t\t\tuser, true, privateLayoutSetPrototype.getUuid());\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new ModelListenerException(e);\n\t\t}\n\t}","id":65763,"modified_method":"@Override\n\tpublic void onAfterRemoveAssociation(\n\t\t\tObject classPK, String associationClassName,\n\t\t\tObject associationClassPK)\n\t\tthrows ModelListenerException {\n\n\t\ttry {\n\t\t\tif (!associationClassName.equals(Role.class.getName())) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tRole role = RoleLocalServiceUtil.getRole((Long)associationClassPK);\n\n\t\t\tString name = role.getName();\n\n\t\t\tif (!name.equals(RoleConstants.SOCIAL_OFFICE_USER)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tUser user = UserLocalServiceUtil.getUser((Long)classPK);\n\n\t\t\tLayoutSetPrototype publicLayoutSetPrototype =\n\t\t\t\tLayoutSetPrototypeUtil.fetchLayoutSetPrototype(user, false);\n\n\t\t\tremoveUserLayouts(user, false, publicLayoutSetPrototype.getUuid());\n\n\t\t\tLayoutSetPrototype privateLayoutSetPrototype =\n\t\t\t\tLayoutSetPrototypeUtil.fetchLayoutSetPrototype(user, true);\n\n\t\t\tremoveUserLayouts(user, true, privateLayoutSetPrototype.getUuid());\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new ModelListenerException(e);\n\t\t}\n\t}","commit_id":"b3ab71b595375222e63f55c148c3850242e74a77","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void removeUserLayouts(\n\t\t\tUser user, boolean privateLayout, String layoutSetPrototypeUuid)\n\t\tthrows PortalException, SystemException {\n\n\t\tGroup userGroup = user.getGroup();\n\n\t\tLayoutSet layoutSet = LayoutSetLocalServiceUtil.getLayoutSet(\n\t\t\tuserGroup.getGroupId(), privateLayout);\n\n\t\tUnicodeProperties settingsProperties =\n\t\t\tlayoutSet.getSettingsProperties();\n\n\t\tsettingsProperties.remove(\"last-merge-time\");\n\n\t\tlayoutSet.setSettingsProperties(settingsProperties);\n\n\t\tlayoutSet.setLayoutSetPrototypeLinkEnabled(false);\n\t\tlayoutSet.setLayoutSetPrototypeUuid(StringPool.BLANK);\n\n\t\tLayoutSetLocalServiceUtil.updateLayoutSet(layoutSet);\n\n\t\tLayoutSetLocalServiceUtil.updateLookAndFeel(\n\t\t\tuserGroup.getGroupId(), null, null, \"\", false);\n\n\t\tLayoutSetPrototype layoutSetPrototype =\n\t\t\tLayoutSetPrototypeLocalServiceUtil.getLayoutSetPrototypeByUuid(\n\t\t\t\tlayoutSetPrototypeUuid);\n\n\t\tGroup group = layoutSetPrototype.getGroup();\n\n\t\tList<Layout> layouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\tgroup.getGroupId(), true);\n\n\t\tString[] layoutUuids = new String[layouts.size()];\n\n\t\tfor (int i = 0; i < layouts.size(); i++) {\n\t\t\tLayout curLayout = layouts.get(i);\n\n\t\t\tlayoutUuids[i] = curLayout.getUuid();\n\t\t}\n\n\t\tList<Layout> userLayouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\tuserGroup.getGroupId(), privateLayout);\n\n\t\tfor (Layout userLayout : userLayouts) {\n\t\t\tif (ArrayUtil.contains(\n\t\t\t\t\tlayoutUuids, userLayout.getSourcePrototypeLayoutUuid())) {\n\n\t\t\t\tLayoutLocalServiceUtil.deleteLayout(\n\t\t\t\t\tuserLayout.getGroupId(), privateLayout,\n\t\t\t\t\tuserLayout.getLayoutId(), new ServiceContext());\n\t\t\t}\n\t\t}\n\t}","id":65764,"modified_method":"protected void removeUserLayouts(\n\t\t\tUser user, boolean privateLayout, String layoutSetPrototypeUuid)\n\t\tthrows PortalException, SystemException {\n\n\t\tGroup group = user.getGroup();\n\n\t\tLayoutSet layoutSet = LayoutSetLocalServiceUtil.getLayoutSet(\n\t\t\tgroup.getGroupId(), privateLayout);\n\n\t\tUnicodeProperties settingsProperties =\n\t\t\tlayoutSet.getSettingsProperties();\n\n\t\tsettingsProperties.remove(\"last-merge-time\");\n\n\t\tlayoutSet.setSettingsProperties(settingsProperties);\n\n\t\tlayoutSet.setLayoutSetPrototypeLinkEnabled(false);\n\t\tlayoutSet.setLayoutSetPrototypeUuid(StringPool.BLANK);\n\n\t\tLayoutSetLocalServiceUtil.updateLayoutSet(layoutSet);\n\n\t\tLayoutSetLocalServiceUtil.updateLookAndFeel(\n\t\t\tgroup.getGroupId(), null, null, StringPool.BLANK, false);\n\n\t\tLayoutSetPrototype layoutSetPrototype =\n\t\t\tLayoutSetPrototypeLocalServiceUtil.getLayoutSetPrototypeByUuid(\n\t\t\t\tlayoutSetPrototypeUuid);\n\n\t\tGroup layoutSetPrototypeGroup = layoutSetPrototype.getGroup();\n\n\t\tList<Layout> layouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\tlayoutSetPrototypeGroup.getGroupId(), true);\n\n\t\tString[] layoutUuids = new String[layouts.size()];\n\n\t\tfor (int i = 0; i < layouts.size(); i++) {\n\t\t\tLayout curLayout = layouts.get(i);\n\n\t\t\tlayoutUuids[i] = curLayout.getUuid();\n\t\t}\n\n\t\tlayouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\tgroup.getGroupId(), privateLayout);\n\n\t\tfor (Layout layout : layouts) {\n\t\t\tif (ArrayUtil.contains(\n\t\t\t\t\tlayoutUuids, layout.getSourcePrototypeLayoutUuid())) {\n\n\t\t\t\tLayoutLocalServiceUtil.deleteLayout(\n\t\t\t\t\tlayout.getGroupId(), privateLayout, layout.getLayoutId(),\n\t\t\t\t\tnew ServiceContext());\n\t\t\t}\n\t\t}\n\t}","commit_id":"b3ab71b595375222e63f55c148c3850242e74a77","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected File doExportLayoutsAsFile(\n\t\t\tlong groupId, boolean privateLayout, long[] layoutIds,\n\t\t\tMap<String, String[]> parameterMap, Date startDate, Date endDate)\n\t\tthrows Exception {\n\n\t\tboolean exportCategories = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.CATEGORIES);\n\t\tboolean exportIgnoreLastPublishDate = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.IGNORE_LAST_PUBLISH_DATE);\n\t\tboolean exportPermissions = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.PERMISSIONS);\n\t\tboolean exportPortletDataAll = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.PORTLET_DATA_ALL);\n\t\tboolean exportTheme = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.THEME);\n\t\tboolean exportThemeSettings = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.THEME_REFERENCE);\n\t\tboolean exportLogo = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.LOGO);\n\t\tboolean exportLayoutSetSettings = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.LAYOUT_SET_SETTINGS);\n\t\tboolean updateLastPublishDate = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.UPDATE_LAST_PUBLISH_DATE);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Export permissions \" + exportPermissions);\n\t\t\t_log.debug(\"Export theme \" + exportTheme);\n\t\t}\n\n\t\tLayoutSet layoutSet = LayoutSetLocalServiceUtil.getLayoutSet(\n\t\t\tgroupId, privateLayout);\n\n\t\tlong companyId = layoutSet.getCompanyId();\n\t\tlong defaultUserId = UserLocalServiceUtil.getDefaultUserId(companyId);\n\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextThreadLocal.getServiceContext();\n\n\t\tif (serviceContext == null) {\n\t\t\tserviceContext = new ServiceContext();\n\n\t\t\tserviceContext.setCompanyId(companyId);\n\t\t\tserviceContext.setSignedIn(false);\n\t\t\tserviceContext.setUserId(defaultUserId);\n\n\t\t\tServiceContextThreadLocal.pushServiceContext(serviceContext);\n\t\t}\n\n\t\tserviceContext.setAttribute(\"exporting\", Boolean.TRUE);\n\n\t\tlong layoutSetBranchId = MapUtil.getLong(\n\t\t\tparameterMap, \"layoutSetBranchId\");\n\n\t\tserviceContext.setAttribute(\"layoutSetBranchId\", layoutSetBranchId);\n\n\t\tlong lastPublishDate = System.currentTimeMillis();\n\n\t\tif (endDate != null) {\n\t\t\tlastPublishDate = endDate.getTime();\n\t\t}\n\n\t\tif (exportIgnoreLastPublishDate) {\n\t\t\tendDate = null;\n\t\t\tstartDate = null;\n\t\t}\n\n\t\tStopWatch stopWatch = null;\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\tstopWatch = new StopWatch();\n\n\t\t\tstopWatch.start();\n\t\t}\n\n\t\tLayoutCache layoutCache = new LayoutCache();\n\n\t\tZipWriter zipWriter = ZipWriterFactoryUtil.getZipWriter();\n\n\t\tPortletDataContext portletDataContext =\n\t\t\tPortletDataContextFactoryUtil.createExportPortletDataContext(\n\t\t\t\tcompanyId, groupId, parameterMap, startDate, endDate,\n\t\t\t\tzipWriter);\n\n\t\tportletDataContext.setPortetDataContextListener(\n\t\t\tnew PortletDataContextListenerImpl(portletDataContext));\n\n\t\tDocument document = SAXReaderUtil.createDocument();\n\n\t\tElement rootElement = document.addElement(\"root\");\n\n\t\tportletDataContext.setExportDataRootElement(rootElement);\n\n\t\tElement headerElement = rootElement.addElement(\"header\");\n\n\t\theaderElement.addAttribute(\n\t\t\t\"available-locales\",\n\t\t\tStringUtil.merge(\n\t\t\t\tLanguageUtil.getAvailableLocales(\n\t\t\t\t\tportletDataContext.getScopeGroupId())));\n\t\theaderElement.addAttribute(\n\t\t\t\"build-number\", String.valueOf(ReleaseInfo.getBuildNumber()));\n\t\theaderElement.addAttribute(\"export-date\", Time.getRFC822());\n\n\t\tif (portletDataContext.hasDateRange()) {\n\t\t\theaderElement.addAttribute(\n\t\t\t\t\"start-date\",\n\t\t\t\tString.valueOf(portletDataContext.getStartDate()));\n\t\t\theaderElement.addAttribute(\n\t\t\t\t\"end-date\", String.valueOf(portletDataContext.getEndDate()));\n\t\t}\n\n\t\theaderElement.addAttribute(\n\t\t\t\"company-id\", String.valueOf(portletDataContext.getCompanyId()));\n\t\theaderElement.addAttribute(\n\t\t\t\"company-group-id\",\n\t\t\tString.valueOf(portletDataContext.getCompanyGroupId()));\n\t\theaderElement.addAttribute(\"group-id\", String.valueOf(groupId));\n\t\theaderElement.addAttribute(\n\t\t\t\"user-personal-site-group-id\",\n\t\t\tString.valueOf(portletDataContext.getUserPersonalSiteGroupId()));\n\t\theaderElement.addAttribute(\n\t\t\t\"private-layout\", String.valueOf(privateLayout));\n\n\t\tGroup group = layoutSet.getGroup();\n\n\t\tString type = \"layout-set\";\n\n\t\tif (group.isLayoutPrototype()) {\n\t\t\ttype = \"layout-prototype\";\n\n\t\t\tLayoutPrototype layoutPrototype =\n\t\t\t\tLayoutPrototypeLocalServiceUtil.getLayoutPrototype(\n\t\t\t\t\tgroup.getClassPK());\n\n\t\t\theaderElement.addAttribute(\"type-uuid\", layoutPrototype.getUuid());\n\t\t}\n\t\telse if (group.isLayoutSetPrototype()) {\n\t\t\ttype =\"layout-set-prototype\";\n\n\t\t\tLayoutSetPrototype layoutSetPrototype =\n\t\t\t\tLayoutSetPrototypeLocalServiceUtil.getLayoutSetPrototype(\n\t\t\t\t\tgroup.getClassPK());\n\n\t\t\theaderElement.addAttribute(\n\t\t\t\t\"type-uuid\", layoutSetPrototype.getUuid());\n\t\t}\n\n\t\theaderElement.addAttribute(\"type\", type);\n\n\t\tif (exportTheme || exportThemeSettings) {\n\t\t\theaderElement.addAttribute(\"theme-id\", layoutSet.getThemeId());\n\t\t\theaderElement.addAttribute(\n\t\t\t\t\"color-scheme-id\", layoutSet.getColorSchemeId());\n\t\t}\n\n\t\tif (exportLogo) {\n\t\t\tImage image = ImageLocalServiceUtil.getImage(layoutSet.getLogoId());\n\n\t\t\tif ((image != null) && (image.getTextObj() != null)) {\n\t\t\t\tString logoPath = ExportImportPathUtil.getRootPath(\n\t\t\t\t\tportletDataContext);\n\n\t\t\t\tlogoPath += \"/logo\";\n\n\t\t\t\theaderElement.addAttribute(\"logo-path\", logoPath);\n\n\t\t\t\tportletDataContext.addZipEntry(logoPath, image.getTextObj());\n\t\t\t}\n\t\t}\n\n\t\tif (exportLayoutSetSettings) {\n\t\t\tElement settingsElement = headerElement.addElement(\"settings\");\n\n\t\t\tsettingsElement.addCDATA(layoutSet.getSettings());\n\t\t}\n\n\t\tElement cssElement = headerElement.addElement(\"css\");\n\n\t\tcssElement.addCDATA(layoutSet.getCss());\n\n\t\tMap<String, Object[]> portletIds =\n\t\t\tnew LinkedHashMap<String, Object[]>();\n\n\t\tList<Layout> layouts = null;\n\n\t\tif ((layoutIds == null) || (layoutIds.length == 0)) {\n\t\t\tlayouts = LayoutLocalServiceUtil.getLayouts(groupId, privateLayout);\n\t\t}\n\t\telse {\n\t\t\tlayouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\t\tgroupId, privateLayout, layoutIds);\n\t\t}\n\n\t\tList<Portlet> portlets = getDataSiteLevelPortlets(companyId);\n\n\t\tlong plid = LayoutConstants.DEFAULT_PLID;\n\n\t\tif (!layouts.isEmpty()) {\n\t\t\tLayout firstLayout = layouts.get(0);\n\n\t\t\tplid = firstLayout.getPlid();\n\t\t}\n\n\t\tif (group.isStagingGroup()) {\n\t\t\tgroup = group.getLiveGroup();\n\t\t}\n\n\t\tfor (Portlet portlet : portlets) {\n\t\t\tString portletId = portlet.getRootPortletId();\n\n\t\t\tif (!group.isStagedPortlet(portletId)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tString key = PortletPermissionUtil.getPrimaryKey(0, portletId);\n\n\t\t\tif (portletIds.get(key) == null) {\n\t\t\t\tportletIds.put(\n\t\t\t\t\tkey,\n\t\t\t\t\tnew Object[] {\n\t\t\t\t\t\tportletId, plid, groupId, StringPool.BLANK,\n\t\t\t\t\t\tStringPool.BLANK\n\t\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tElement missingReferencesElement = rootElement.addElement(\n\t\t\t\"missing-references\");\n\n\t\tportletDataContext.setMissingReferencesElement(\n\t\t\tmissingReferencesElement);\n\n\t\tportletDataContext.addDeletionSystemEventStagedModelTypes(\n\t\t\tnew StagedModelType(Layout.class));\n\n\t\tElement layoutsElement = portletDataContext.getExportDataGroupElement(\n\t\t\tLayout.class);\n\n\t\tString layoutSetPrototypeUuid = layoutSet.getLayoutSetPrototypeUuid();\n\n\t\tif (Validator.isNotNull(layoutSetPrototypeUuid)) {\n\t\t\tLayoutSetPrototype layoutSetPrototype =\n\t\t\t\tLayoutSetPrototypeLocalServiceUtil.\n\t\t\t\t\tgetLayoutSetPrototypeByUuidAndCompanyId(\n\t\t\t\t\t\tlayoutSetPrototypeUuid, companyId);\n\n\t\t\tlayoutsElement.addAttribute(\n\t\t\t\t\"layout-set-prototype-uuid\", layoutSetPrototypeUuid);\n\n\t\t\tlayoutsElement.addAttribute(\n\t\t\t\t\"layout-set-prototype-name\",\n\t\t\t\tlayoutSetPrototype.getName(LocaleUtil.getDefault()));\n\t\t}\n\n\t\tfor (Layout layout : layouts) {\n\t\t\texportLayout(\n\t\t\t\tportletDataContext, portlets, portletIds, layout,\n\t\t\t\tlayoutsElement);\n\t\t}\n\n\t\tlong previousScopeGroupId = portletDataContext.getScopeGroupId();\n\n\t\tElement portletsElement = rootElement.addElement(\"portlets\");\n\n\t\tfor (Map.Entry<String, Object[]> portletIdsEntry :\n\t\t\t\tportletIds.entrySet()) {\n\n\t\t\tObject[] portletObjects = portletIdsEntry.getValue();\n\n\t\t\tString portletId = null;\n\t\t\tplid = LayoutConstants.DEFAULT_PLID;\n\t\t\tlong scopeGroupId = 0;\n\t\t\tString scopeType = StringPool.BLANK;\n\t\t\tString scopeLayoutUuid = null;\n\n\t\t\tif (portletObjects.length == 4) {\n\t\t\t\tportletId = (String)portletIdsEntry.getValue()[0];\n\t\t\t\tplid = (Long)portletIdsEntry.getValue()[1];\n\t\t\t\tscopeGroupId = (Long)portletIdsEntry.getValue()[2];\n\t\t\t\tscopeLayoutUuid = (String)portletIdsEntry.getValue()[3];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tportletId = (String)portletIdsEntry.getValue()[0];\n\t\t\t\tplid = (Long)portletIdsEntry.getValue()[1];\n\t\t\t\tscopeGroupId = (Long)portletIdsEntry.getValue()[2];\n\t\t\t\tscopeType = (String)portletIdsEntry.getValue()[3];\n\t\t\t\tscopeLayoutUuid = (String)portletIdsEntry.getValue()[4];\n\t\t\t}\n\n\t\t\tLayout layout = LayoutLocalServiceUtil.fetchLayout(plid);\n\n\t\t\tif (layout == null) {\n\t\t\t\tif (!group.isCompany() &&\n\t\t\t\t\t(plid <= LayoutConstants.DEFAULT_PLID)) {\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Assuming global scope because no layout was found\");\n\t\t\t\t}\n\n\t\t\t\tlayout = new LayoutImpl();\n\n\t\t\t\tlayout.setGroupId(groupId);\n\t\t\t\tlayout.setCompanyId(companyId);\n\t\t\t}\n\n\t\t\tportletDataContext.setPlid(plid);\n\t\t\tportletDataContext.setOldPlid(plid);\n\t\t\tportletDataContext.setScopeGroupId(scopeGroupId);\n\t\t\tportletDataContext.setScopeType(scopeType);\n\t\t\tportletDataContext.setScopeLayoutUuid(scopeLayoutUuid);\n\n\t\t\tboolean[] exportPortletControls = getExportPortletControls(\n\t\t\t\tcompanyId, portletId, parameterMap, type);\n\n\t\t\t_portletExporter.exportPortlet(\n\t\t\t\tportletDataContext, layoutCache, portletId, layout,\n\t\t\t\tportletsElement, defaultUserId, exportPermissions,\n\t\t\t\texportPortletControls[0], exportPortletControls[1],\n\t\t\t\texportPortletControls[2], exportPortletControls[3]);\n\t\t}\n\n\t\tportletDataContext.setScopeGroupId(previousScopeGroupId);\n\n\t\texportAssetCategories(\n\t\t\tportletDataContext, exportPortletDataAll, exportCategories,\n\t\t\tgroup.isCompany());\n\n\t\t_portletExporter.exportAssetLinks(portletDataContext);\n\t\t_portletExporter.exportAssetTags(portletDataContext);\n\t\t_portletExporter.exportComments(portletDataContext);\n\t\t_portletExporter.exportExpandoTables(portletDataContext);\n\t\t_portletExporter.exportLocks(portletDataContext);\n\n\t\t_deletionSystemEventExporter.exportDeletionSystemEvents(\n\t\t\tportletDataContext);\n\n\t\tif (exportPermissions) {\n\t\t\t_permissionExporter.exportPortletDataPermissions(\n\t\t\t\tportletDataContext);\n\t\t}\n\n\t\t_portletExporter.exportRatingsEntries(portletDataContext, rootElement);\n\n\t\tif (exportTheme && !portletDataContext.isPerformDirectBinaryImport()) {\n\t\t\texportTheme(layoutSet, zipWriter);\n\t\t}\n\n\t\tExportImportHelperUtil.writeManifestSummary(\n\t\t\tdocument, portletDataContext.getManifestSummary());\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\tif (stopWatch != null) {\n\t\t\t\t_log.info(\n\t\t\t\t\t\"Exporting layouts takes \" + stopWatch.getTime() + \" ms\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.info(\"Exporting layouts is finished\");\n\t\t\t}\n\t\t}\n\n\t\tportletDataContext.addZipEntry(\n\t\t\t\"/manifest.xml\", document.formattedString());\n\n\t\ttry {\n\t\t\treturn zipWriter.getFile();\n\t\t}\n\t\tfinally {\n\t\t\tif (updateLastPublishDate) {\n\t\t\t\tupdateLastPublishDate(layoutSet, lastPublishDate);\n\t\t\t}\n\t\t}\n\t}","id":65765,"modified_method":"protected File doExportLayoutsAsFile(\n\t\t\tlong groupId, boolean privateLayout, long[] layoutIds,\n\t\t\tMap<String, String[]> parameterMap, Date startDate, Date endDate)\n\t\tthrows Exception {\n\n\t\tboolean exportCategories = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.CATEGORIES);\n\t\tboolean exportIgnoreLastPublishDate = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.IGNORE_LAST_PUBLISH_DATE);\n\t\tboolean exportPermissions = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.PERMISSIONS);\n\t\tboolean exportPortletDataAll = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.PORTLET_DATA_ALL);\n\t\tboolean exportTheme = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.THEME);\n\t\tboolean exportThemeSettings = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.THEME_REFERENCE);\n\t\tboolean exportLogo = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.LOGO);\n\t\tboolean exportLayoutSetSettings = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.LAYOUT_SET_SETTINGS);\n\t\tboolean updateLastPublishDate = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.UPDATE_LAST_PUBLISH_DATE);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Export permissions \" + exportPermissions);\n\t\t\t_log.debug(\"Export theme \" + exportTheme);\n\t\t}\n\n\t\tLayoutSet layoutSet = LayoutSetLocalServiceUtil.getLayoutSet(\n\t\t\tgroupId, privateLayout);\n\n\t\tlong companyId = layoutSet.getCompanyId();\n\t\tlong defaultUserId = UserLocalServiceUtil.getDefaultUserId(companyId);\n\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextThreadLocal.getServiceContext();\n\n\t\tif (serviceContext == null) {\n\t\t\tserviceContext = new ServiceContext();\n\n\t\t\tserviceContext.setCompanyId(companyId);\n\t\t\tserviceContext.setSignedIn(false);\n\t\t\tserviceContext.setUserId(defaultUserId);\n\n\t\t\tServiceContextThreadLocal.pushServiceContext(serviceContext);\n\t\t}\n\n\t\tserviceContext.setAttribute(\"exporting\", Boolean.TRUE);\n\n\t\tlong layoutSetBranchId = MapUtil.getLong(\n\t\t\tparameterMap, \"layoutSetBranchId\");\n\n\t\tserviceContext.setAttribute(\"layoutSetBranchId\", layoutSetBranchId);\n\n\t\tlong lastPublishDate = System.currentTimeMillis();\n\n\t\tif (endDate != null) {\n\t\t\tlastPublishDate = endDate.getTime();\n\t\t}\n\n\t\tif (exportIgnoreLastPublishDate) {\n\t\t\tendDate = null;\n\t\t\tstartDate = null;\n\t\t}\n\n\t\tStopWatch stopWatch = null;\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\tstopWatch = new StopWatch();\n\n\t\t\tstopWatch.start();\n\t\t}\n\n\t\tLayoutCache layoutCache = new LayoutCache();\n\n\t\tZipWriter zipWriter = ZipWriterFactoryUtil.getZipWriter();\n\n\t\tPortletDataContext portletDataContext =\n\t\t\tPortletDataContextFactoryUtil.createExportPortletDataContext(\n\t\t\t\tcompanyId, groupId, parameterMap, startDate, endDate,\n\t\t\t\tzipWriter);\n\n\t\tportletDataContext.setPortetDataContextListener(\n\t\t\tnew PortletDataContextListenerImpl(portletDataContext));\n\n\t\tDocument document = SAXReaderUtil.createDocument();\n\n\t\tElement rootElement = document.addElement(\"root\");\n\n\t\tportletDataContext.setExportDataRootElement(rootElement);\n\n\t\tElement headerElement = rootElement.addElement(\"header\");\n\n\t\theaderElement.addAttribute(\n\t\t\t\"available-locales\",\n\t\t\tStringUtil.merge(\n\t\t\t\tLanguageUtil.getAvailableLocales(\n\t\t\t\t\tportletDataContext.getScopeGroupId())));\n\t\theaderElement.addAttribute(\n\t\t\t\"build-number\", String.valueOf(ReleaseInfo.getBuildNumber()));\n\t\theaderElement.addAttribute(\"export-date\", Time.getRFC822());\n\n\t\tif (portletDataContext.hasDateRange()) {\n\t\t\theaderElement.addAttribute(\n\t\t\t\t\"start-date\",\n\t\t\t\tString.valueOf(portletDataContext.getStartDate()));\n\t\t\theaderElement.addAttribute(\n\t\t\t\t\"end-date\", String.valueOf(portletDataContext.getEndDate()));\n\t\t}\n\n\t\theaderElement.addAttribute(\n\t\t\t\"company-id\", String.valueOf(portletDataContext.getCompanyId()));\n\t\theaderElement.addAttribute(\n\t\t\t\"company-group-id\",\n\t\t\tString.valueOf(portletDataContext.getCompanyGroupId()));\n\t\theaderElement.addAttribute(\"group-id\", String.valueOf(groupId));\n\t\theaderElement.addAttribute(\n\t\t\t\"user-personal-site-group-id\",\n\t\t\tString.valueOf(portletDataContext.getUserPersonalSiteGroupId()));\n\t\theaderElement.addAttribute(\n\t\t\t\"private-layout\", String.valueOf(privateLayout));\n\n\t\tGroup group = layoutSet.getGroup();\n\n\t\tString type = \"layout-set\";\n\n\t\tif (group.isLayoutPrototype()) {\n\t\t\ttype = \"layout-prototype\";\n\n\t\t\tLayoutPrototype layoutPrototype =\n\t\t\t\tLayoutPrototypeLocalServiceUtil.getLayoutPrototype(\n\t\t\t\t\tgroup.getClassPK());\n\n\t\t\theaderElement.addAttribute(\"type-uuid\", layoutPrototype.getUuid());\n\t\t}\n\t\telse if (group.isLayoutSetPrototype()) {\n\t\t\ttype =\"layout-set-prototype\";\n\n\t\t\tLayoutSetPrototype layoutSetPrototype =\n\t\t\t\tLayoutSetPrototypeLocalServiceUtil.getLayoutSetPrototype(\n\t\t\t\t\tgroup.getClassPK());\n\n\t\t\theaderElement.addAttribute(\n\t\t\t\t\"type-uuid\", layoutSetPrototype.getUuid());\n\t\t}\n\n\t\theaderElement.addAttribute(\"type\", type);\n\n\t\tif (exportTheme || exportThemeSettings) {\n\t\t\theaderElement.addAttribute(\"theme-id\", layoutSet.getThemeId());\n\t\t\theaderElement.addAttribute(\n\t\t\t\t\"color-scheme-id\", layoutSet.getColorSchemeId());\n\t\t}\n\n\t\tif (exportLogo) {\n\t\t\tImage image = ImageLocalServiceUtil.getImage(layoutSet.getLogoId());\n\n\t\t\tif ((image != null) && (image.getTextObj() != null)) {\n\t\t\t\tString logoPath = ExportImportPathUtil.getRootPath(\n\t\t\t\t\tportletDataContext);\n\n\t\t\t\tlogoPath += \"/logo\";\n\n\t\t\t\theaderElement.addAttribute(\"logo-path\", logoPath);\n\n\t\t\t\tportletDataContext.addZipEntry(logoPath, image.getTextObj());\n\t\t\t}\n\t\t}\n\n\t\tif (exportLayoutSetSettings) {\n\t\t\tElement settingsElement = headerElement.addElement(\"settings\");\n\n\t\t\tsettingsElement.addCDATA(layoutSet.getSettings());\n\t\t}\n\n\t\tElement cssElement = headerElement.addElement(\"css\");\n\n\t\tcssElement.addCDATA(layoutSet.getCss());\n\n\t\tMap<String, Object[]> portletIds =\n\t\t\tnew LinkedHashMap<String, Object[]>();\n\n\t\tList<Layout> layouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\tgroupId, privateLayout);\n\n\t\tList<Portlet> portlets = getDataSiteLevelPortlets(companyId);\n\n\t\tlong plid = LayoutConstants.DEFAULT_PLID;\n\n\t\tif (!layouts.isEmpty()) {\n\t\t\tLayout firstLayout = layouts.get(0);\n\n\t\t\tplid = firstLayout.getPlid();\n\t\t}\n\n\t\tif (group.isStagingGroup()) {\n\t\t\tgroup = group.getLiveGroup();\n\t\t}\n\n\t\tfor (Portlet portlet : portlets) {\n\t\t\tString portletId = portlet.getRootPortletId();\n\n\t\t\tif (!group.isStagedPortlet(portletId)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tString key = PortletPermissionUtil.getPrimaryKey(0, portletId);\n\n\t\t\tif (portletIds.get(key) == null) {\n\t\t\t\tportletIds.put(\n\t\t\t\t\tkey,\n\t\t\t\t\tnew Object[] {\n\t\t\t\t\t\tportletId, plid, groupId, StringPool.BLANK,\n\t\t\t\t\t\tStringPool.BLANK\n\t\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tElement missingReferencesElement = rootElement.addElement(\n\t\t\t\"missing-references\");\n\n\t\tportletDataContext.setMissingReferencesElement(\n\t\t\tmissingReferencesElement);\n\n\t\tportletDataContext.addDeletionSystemEventStagedModelTypes(\n\t\t\tnew StagedModelType(Layout.class));\n\n\t\tElement layoutsElement = portletDataContext.getExportDataGroupElement(\n\t\t\tLayout.class);\n\n\t\tString layoutSetPrototypeUuid = layoutSet.getLayoutSetPrototypeUuid();\n\n\t\tif (Validator.isNotNull(layoutSetPrototypeUuid)) {\n\t\t\tLayoutSetPrototype layoutSetPrototype =\n\t\t\t\tLayoutSetPrototypeLocalServiceUtil.\n\t\t\t\t\tgetLayoutSetPrototypeByUuidAndCompanyId(\n\t\t\t\t\t\tlayoutSetPrototypeUuid, companyId);\n\n\t\t\tlayoutsElement.addAttribute(\n\t\t\t\t\"layout-set-prototype-uuid\", layoutSetPrototypeUuid);\n\n\t\t\tlayoutsElement.addAttribute(\n\t\t\t\t\"layout-set-prototype-name\",\n\t\t\t\tlayoutSetPrototype.getName(LocaleUtil.getDefault()));\n\t\t}\n\n\t\tfor (Layout layout : layouts) {\n\t\t\texportLayout(\n\t\t\t\tportletDataContext, portlets, layoutIds, portletIds, layout);\n\t\t}\n\n\t\tlong previousScopeGroupId = portletDataContext.getScopeGroupId();\n\n\t\tElement portletsElement = rootElement.addElement(\"portlets\");\n\n\t\tfor (Map.Entry<String, Object[]> portletIdsEntry :\n\t\t\t\tportletIds.entrySet()) {\n\n\t\t\tObject[] portletObjects = portletIdsEntry.getValue();\n\n\t\t\tString portletId = null;\n\t\t\tplid = LayoutConstants.DEFAULT_PLID;\n\t\t\tlong scopeGroupId = 0;\n\t\t\tString scopeType = StringPool.BLANK;\n\t\t\tString scopeLayoutUuid = null;\n\n\t\t\tif (portletObjects.length == 4) {\n\t\t\t\tportletId = (String)portletIdsEntry.getValue()[0];\n\t\t\t\tplid = (Long)portletIdsEntry.getValue()[1];\n\t\t\t\tscopeGroupId = (Long)portletIdsEntry.getValue()[2];\n\t\t\t\tscopeLayoutUuid = (String)portletIdsEntry.getValue()[3];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tportletId = (String)portletIdsEntry.getValue()[0];\n\t\t\t\tplid = (Long)portletIdsEntry.getValue()[1];\n\t\t\t\tscopeGroupId = (Long)portletIdsEntry.getValue()[2];\n\t\t\t\tscopeType = (String)portletIdsEntry.getValue()[3];\n\t\t\t\tscopeLayoutUuid = (String)portletIdsEntry.getValue()[4];\n\t\t\t}\n\n\t\t\tLayout layout = LayoutLocalServiceUtil.fetchLayout(plid);\n\n\t\t\tif (layout == null) {\n\t\t\t\tif (!group.isCompany() &&\n\t\t\t\t\t(plid <= LayoutConstants.DEFAULT_PLID)) {\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Assuming global scope because no layout was found\");\n\t\t\t\t}\n\n\t\t\t\tlayout = new LayoutImpl();\n\n\t\t\t\tlayout.setGroupId(groupId);\n\t\t\t\tlayout.setCompanyId(companyId);\n\t\t\t}\n\n\t\t\tportletDataContext.setPlid(plid);\n\t\t\tportletDataContext.setOldPlid(plid);\n\t\t\tportletDataContext.setScopeGroupId(scopeGroupId);\n\t\t\tportletDataContext.setScopeType(scopeType);\n\t\t\tportletDataContext.setScopeLayoutUuid(scopeLayoutUuid);\n\n\t\t\tboolean[] exportPortletControls = getExportPortletControls(\n\t\t\t\tcompanyId, portletId, parameterMap, type);\n\n\t\t\t_portletExporter.exportPortlet(\n\t\t\t\tportletDataContext, layoutCache, portletId, layout,\n\t\t\t\tportletsElement, defaultUserId, exportPermissions,\n\t\t\t\texportPortletControls[0], exportPortletControls[1],\n\t\t\t\texportPortletControls[2], exportPortletControls[3]);\n\t\t}\n\n\t\tportletDataContext.setScopeGroupId(previousScopeGroupId);\n\n\t\texportAssetCategories(\n\t\t\tportletDataContext, exportPortletDataAll, exportCategories,\n\t\t\tgroup.isCompany());\n\n\t\t_portletExporter.exportAssetLinks(portletDataContext);\n\t\t_portletExporter.exportAssetTags(portletDataContext);\n\t\t_portletExporter.exportComments(portletDataContext);\n\t\t_portletExporter.exportExpandoTables(portletDataContext);\n\t\t_portletExporter.exportLocks(portletDataContext);\n\n\t\t_deletionSystemEventExporter.exportDeletionSystemEvents(\n\t\t\tportletDataContext);\n\n\t\tif (exportPermissions) {\n\t\t\t_permissionExporter.exportPortletDataPermissions(\n\t\t\t\tportletDataContext);\n\t\t}\n\n\t\t_portletExporter.exportRatingsEntries(portletDataContext, rootElement);\n\n\t\tif (exportTheme && !portletDataContext.isPerformDirectBinaryImport()) {\n\t\t\texportTheme(layoutSet, zipWriter);\n\t\t}\n\n\t\tExportImportHelperUtil.writeManifestSummary(\n\t\t\tdocument, portletDataContext.getManifestSummary());\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\tif (stopWatch != null) {\n\t\t\t\t_log.info(\n\t\t\t\t\t\"Exporting layouts takes \" + stopWatch.getTime() + \" ms\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.info(\"Exporting layouts is finished\");\n\t\t\t}\n\t\t}\n\n\t\tportletDataContext.addZipEntry(\n\t\t\t\"/manifest.xml\", document.formattedString());\n\n\t\ttry {\n\t\t\treturn zipWriter.getFile();\n\t\t}\n\t\tfinally {\n\t\t\tif (updateLastPublishDate) {\n\t\t\t\tupdateLastPublishDate(layoutSet, lastPublishDate);\n\t\t\t}\n\t\t}\n\t}","commit_id":"91a635f1b0b2b0594ae0a51eeff80e91fe774d70","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void exportLayout(\n\t\t\tPortletDataContext portletDataContext, List<Portlet> portlets,\n\t\t\tMap<String, Object[]> portletIds, Layout layout,\n\t\t\tElement layoutsElement)\n\t\tthrows Exception {\n\n\t\tStagedModelDataHandlerUtil.exportStagedModel(\n\t\t\tportletDataContext, layout);\n\n\t\tif (!layout.isSupportsEmbeddedPortlets()) {\n\n\t\t\t// Only portlet type layouts support page scoping\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (layout.isTypePortlet()) {\n\t\t\tfor (Portlet portlet : portlets) {\n\t\t\t\tif (portlet.isScopeable() && layout.hasScopeGroup()) {\n\t\t\t\t\tString key = PortletPermissionUtil.getPrimaryKey(\n\t\t\t\t\t\tlayout.getPlid(), portlet.getPortletId());\n\n\t\t\t\t\tGroup scopeGroup = layout.getScopeGroup();\n\n\t\t\t\t\tportletIds.put(\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tnew Object[] {\n\t\t\t\t\t\t\tportlet.getPortletId(), layout.getPlid(),\n\t\t\t\t\t\t\tscopeGroup.getGroupId(), StringPool.BLANK,\n\t\t\t\t\t\t\tlayout.getUuid()\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tLayoutTypePortlet layoutTypePortlet =\n\t\t\t(LayoutTypePortlet)layout.getLayoutType();\n\n\t\t// The getAllPortlets method returns all effective nonsystem portlets\n\t\t// for any layout type, including embedded portlets, or in the case of\n\t\t// panel type layout, selected portlets\n\n\t\tfor (Portlet portlet : layoutTypePortlet.getAllPortlets(false)) {\n\t\t\tString portletId = portlet.getPortletId();\n\n\t\t\tjavax.portlet.PortletPreferences jxPortletPreferences =\n\t\t\t\tPortletPreferencesFactoryUtil.getLayoutPortletSetup(\n\t\t\t\t\tlayout, portletId);\n\n\t\t\tString scopeType = GetterUtil.getString(\n\t\t\t\tjxPortletPreferences.getValue(\"lfrScopeType\", null));\n\t\t\tString scopeLayoutUuid = GetterUtil.getString(\n\t\t\t\tjxPortletPreferences.getValue(\"lfrScopeLayoutUuid\", null));\n\n\t\t\tlong scopeGroupId = portletDataContext.getScopeGroupId();\n\n\t\t\tif (Validator.isNotNull(scopeType)) {\n\t\t\t\tGroup scopeGroup = null;\n\n\t\t\t\tif (scopeType.equals(\"company\")) {\n\t\t\t\t\tscopeGroup = GroupLocalServiceUtil.getCompanyGroup(\n\t\t\t\t\t\tlayout.getCompanyId());\n\t\t\t\t}\n\t\t\t\telse if (scopeType.equals(\"layout\")) {\n\t\t\t\t\tLayout scopeLayout = null;\n\n\t\t\t\t\tscopeLayout =\n\t\t\t\t\t\tLayoutLocalServiceUtil.fetchLayoutByUuidAndGroupId(\n\t\t\t\t\t\t\tscopeLayoutUuid, portletDataContext.getGroupId(),\n\t\t\t\t\t\t\tportletDataContext.isPrivateLayout());\n\n\t\t\t\t\tif (scopeLayout == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tscopeGroup = scopeLayout.getScopeGroup();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Scope type \" + scopeType + \" is invalid\");\n\t\t\t\t}\n\n\t\t\t\tif (scopeGroup != null) {\n\t\t\t\t\tscopeGroupId = scopeGroup.getGroupId();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString key = PortletPermissionUtil.getPrimaryKey(\n\t\t\t\tlayout.getPlid(), portletId);\n\n\t\t\tportletIds.put(\n\t\t\t\tkey,\n\t\t\t\tnew Object[] {\n\t\t\t\t\tportletId, layout.getPlid(), scopeGroupId, scopeType,\n\t\t\t\t\tscopeLayoutUuid\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t}","id":65766,"modified_method":"protected void exportLayout(\n\t\t\tPortletDataContext portletDataContext, List<Portlet> portlets,\n\t\t\tlong[] layoutIds, Map<String, Object[]> portletIds, Layout layout)\n\t\tthrows Exception {\n\n\t\tif (!ArrayUtil.contains(layoutIds, layout.getLayoutId()) &&\n\t\t\t(layoutIds != null) && (layoutIds.length > 0)) {\n\n\t\t\tElement layoutElement = portletDataContext.getExportDataElement(\n\t\t\t\tlayout);\n\n\t\t\tlayoutElement.addAttribute(\"action\", Constants.SKIP);\n\n\t\t\treturn;\n\t\t}\n\n\t\tStagedModelDataHandlerUtil.exportStagedModel(\n\t\t\tportletDataContext, layout);\n\n\t\tif (!layout.isSupportsEmbeddedPortlets()) {\n\n\t\t\t// Only portlet type layouts support page scoping\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (layout.isTypePortlet()) {\n\t\t\tfor (Portlet portlet : portlets) {\n\t\t\t\tif (portlet.isScopeable() && layout.hasScopeGroup()) {\n\t\t\t\t\tString key = PortletPermissionUtil.getPrimaryKey(\n\t\t\t\t\t\tlayout.getPlid(), portlet.getPortletId());\n\n\t\t\t\t\tGroup scopeGroup = layout.getScopeGroup();\n\n\t\t\t\t\tportletIds.put(\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tnew Object[] {\n\t\t\t\t\t\t\tportlet.getPortletId(), layout.getPlid(),\n\t\t\t\t\t\t\tscopeGroup.getGroupId(), StringPool.BLANK,\n\t\t\t\t\t\t\tlayout.getUuid()\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tLayoutTypePortlet layoutTypePortlet =\n\t\t\t(LayoutTypePortlet)layout.getLayoutType();\n\n\t\t// The getAllPortlets method returns all effective nonsystem portlets\n\t\t// for any layout type, including embedded portlets, or in the case of\n\t\t// panel type layout, selected portlets\n\n\t\tfor (Portlet portlet : layoutTypePortlet.getAllPortlets(false)) {\n\t\t\tString portletId = portlet.getPortletId();\n\n\t\t\tjavax.portlet.PortletPreferences jxPortletPreferences =\n\t\t\t\tPortletPreferencesFactoryUtil.getLayoutPortletSetup(\n\t\t\t\t\tlayout, portletId);\n\n\t\t\tString scopeType = GetterUtil.getString(\n\t\t\t\tjxPortletPreferences.getValue(\"lfrScopeType\", null));\n\t\t\tString scopeLayoutUuid = GetterUtil.getString(\n\t\t\t\tjxPortletPreferences.getValue(\"lfrScopeLayoutUuid\", null));\n\n\t\t\tlong scopeGroupId = portletDataContext.getScopeGroupId();\n\n\t\t\tif (Validator.isNotNull(scopeType)) {\n\t\t\t\tGroup scopeGroup = null;\n\n\t\t\t\tif (scopeType.equals(\"company\")) {\n\t\t\t\t\tscopeGroup = GroupLocalServiceUtil.getCompanyGroup(\n\t\t\t\t\t\tlayout.getCompanyId());\n\t\t\t\t}\n\t\t\t\telse if (scopeType.equals(\"layout\")) {\n\t\t\t\t\tLayout scopeLayout = null;\n\n\t\t\t\t\tscopeLayout =\n\t\t\t\t\t\tLayoutLocalServiceUtil.fetchLayoutByUuidAndGroupId(\n\t\t\t\t\t\t\tscopeLayoutUuid, portletDataContext.getGroupId(),\n\t\t\t\t\t\t\tportletDataContext.isPrivateLayout());\n\n\t\t\t\t\tif (scopeLayout == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tscopeGroup = scopeLayout.getScopeGroup();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Scope type \" + scopeType + \" is invalid\");\n\t\t\t\t}\n\n\t\t\t\tif (scopeGroup != null) {\n\t\t\t\t\tscopeGroupId = scopeGroup.getGroupId();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString key = PortletPermissionUtil.getPrimaryKey(\n\t\t\t\tlayout.getPlid(), portletId);\n\n\t\t\tportletIds.put(\n\t\t\t\tkey,\n\t\t\t\tnew Object[] {\n\t\t\t\t\tportletId, layout.getPlid(), scopeGroupId, scopeType,\n\t\t\t\t\tscopeLayoutUuid\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t}","commit_id":"91a635f1b0b2b0594ae0a51eeff80e91fe774d70","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, Layout layout)\n\t\tthrows Exception {\n\n\t\tLayoutRevision layoutRevision = null;\n\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextThreadLocal.getServiceContext();\n\n\t\tboolean exportLAR = ParamUtil.getBoolean(serviceContext, \"exportLAR\");\n\n\t\tif (!exportLAR && LayoutStagingUtil.isBranchingLayout(layout) &&\n\t\t\t!layout.isTypeURL()) {\n\n\t\t\tlong layoutSetBranchId = ParamUtil.getLong(\n\t\t\t\tserviceContext, \"layoutSetBranchId\");\n\n\t\t\tif (layoutSetBranchId <= 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlayoutRevision = LayoutRevisionLocalServiceUtil.fetchLayoutRevision(\n\t\t\t\tlayoutSetBranchId, true, layout.getPlid());\n\n\t\t\tif (layoutRevision == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tLayoutStagingHandler layoutStagingHandler =\n\t\t\t\tLayoutStagingUtil.getLayoutStagingHandler(layout);\n\n\t\t\tlayoutStagingHandler.setLayoutRevision(layoutRevision);\n\t\t}\n\n\t\tElement layoutElement = portletDataContext.getExportDataElement(layout);\n\n\t\tpopulateElementLayoutMetadata(layoutElement, layout, layoutRevision);\n\n\t\tboolean deleteLayout = MapUtil.getBoolean(\n\t\t\tportletDataContext.getParameterMap(), \"delete_\" + layout.getPlid());\n\n\t\tif (deleteLayout) {\n\t\t\tlayoutElement.addAttribute(\"action\", Constants.DELETE);\n\n\t\t\treturn;\n\t\t}\n\n\t\tportletDataContext.setPlid(layout.getPlid());\n\n\t\tlong parentLayoutId = layout.getParentLayoutId();\n\n\t\tif (parentLayoutId != LayoutConstants.DEFAULT_PARENT_LAYOUT_ID) {\n\t\t\tLayout parentLayout = LayoutLocalServiceUtil.fetchLayout(\n\t\t\t\tlayout.getGroupId(), layout.isPrivateLayout(), parentLayoutId);\n\n\t\t\tif (parentLayout != null) {\n\t\t\t\texportStagedModel(portletDataContext, parentLayout);\n\n\t\t\t\tportletDataContext.addReferenceElement(\n\t\t\t\t\tlayout, layoutElement, parentLayout,\n\t\t\t\t\tPortletDataContext.REFERENCE_TYPE_PARENT, false);\n\n\t\t\t\tlayoutElement.addAttribute(\n\t\t\t\t\t\"parent-layout-uuid\", parentLayout.getUuid());\n\t\t\t}\n\t\t}\n\n\t\tList<LayoutFriendlyURL> layoutFriendlyURLs =\n\t\t\tLayoutFriendlyURLLocalServiceUtil.getLayoutFriendlyURLs(\n\t\t\t\tlayout.getPlid());\n\n\t\tfor (LayoutFriendlyURL layoutFriendlyURL : layoutFriendlyURLs) {\n\t\t\tStagedModelDataHandlerUtil.exportStagedModel(\n\t\t\t\tportletDataContext, layoutFriendlyURL);\n\n\t\t\tportletDataContext.addReferenceElement(\n\t\t\t\tlayout, layoutElement, layoutFriendlyURL,\n\t\t\t\tPortletDataContext.REFERENCE_TYPE_DEPENDENCY, false);\n\t\t}\n\n\t\tif (layout.isIconImage()) {\n\t\t\texportLayoutIconImage(portletDataContext, layout, layoutElement);\n\t\t}\n\n\t\tif (layout.isTypeArticle()) {\n\t\t\texportJournalArticle(portletDataContext, layout, layoutElement);\n\t\t}\n\t\telse if (layout.isTypeLinkToLayout()) {\n\t\t\texportLinkedLayout(portletDataContext, layout, layoutElement);\n\t\t}\n\n\t\tfixExportTypeSettings(layout);\n\n\t\tportletDataContext.addClassedModel(\n\t\t\tlayoutElement, ExportImportPathUtil.getModelPath(layout), layout,\n\t\t\tLayoutPortletDataHandler.NAMESPACE);\n\t}","id":65767,"modified_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, Layout layout)\n\t\tthrows Exception {\n\n\t\tLayoutRevision layoutRevision = null;\n\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextThreadLocal.getServiceContext();\n\n\t\tboolean exportLAR = ParamUtil.getBoolean(serviceContext, \"exportLAR\");\n\n\t\tif (!exportLAR && LayoutStagingUtil.isBranchingLayout(layout) &&\n\t\t\t!layout.isTypeURL()) {\n\n\t\t\tlong layoutSetBranchId = ParamUtil.getLong(\n\t\t\t\tserviceContext, \"layoutSetBranchId\");\n\n\t\t\tif (layoutSetBranchId <= 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlayoutRevision = LayoutRevisionLocalServiceUtil.fetchLayoutRevision(\n\t\t\t\tlayoutSetBranchId, true, layout.getPlid());\n\n\t\t\tif (layoutRevision == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tLayoutStagingHandler layoutStagingHandler =\n\t\t\t\tLayoutStagingUtil.getLayoutStagingHandler(layout);\n\n\t\t\tlayoutStagingHandler.setLayoutRevision(layoutRevision);\n\t\t}\n\n\t\tElement layoutElement = portletDataContext.getExportDataElement(layout);\n\n\t\tpopulateElementLayoutMetadata(layoutElement, layout, layoutRevision);\n\n\t\tboolean deleteLayout = MapUtil.getBoolean(\n\t\t\tportletDataContext.getParameterMap(), \"delete_\" + layout.getPlid());\n\n\t\tif (deleteLayout) {\n\t\t\tlayoutElement.addAttribute(\"action\", Constants.DELETE);\n\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tlayoutElement.addAttribute(\"action\", Constants.ADD);\n\t\t}\n\n\t\tportletDataContext.setPlid(layout.getPlid());\n\n\t\tlong parentLayoutId = layout.getParentLayoutId();\n\n\t\tif (parentLayoutId != LayoutConstants.DEFAULT_PARENT_LAYOUT_ID) {\n\t\t\tLayout parentLayout = LayoutLocalServiceUtil.fetchLayout(\n\t\t\t\tlayout.getGroupId(), layout.isPrivateLayout(), parentLayoutId);\n\n\t\t\tif (parentLayout != null) {\n\t\t\t\texportStagedModel(portletDataContext, parentLayout);\n\n\t\t\t\tportletDataContext.addReferenceElement(\n\t\t\t\t\tlayout, layoutElement, parentLayout,\n\t\t\t\t\tPortletDataContext.REFERENCE_TYPE_PARENT, false);\n\n\t\t\t\tlayoutElement.addAttribute(\n\t\t\t\t\t\"parent-layout-uuid\", parentLayout.getUuid());\n\t\t\t}\n\t\t}\n\n\t\tList<LayoutFriendlyURL> layoutFriendlyURLs =\n\t\t\tLayoutFriendlyURLLocalServiceUtil.getLayoutFriendlyURLs(\n\t\t\t\tlayout.getPlid());\n\n\t\tfor (LayoutFriendlyURL layoutFriendlyURL : layoutFriendlyURLs) {\n\t\t\tStagedModelDataHandlerUtil.exportStagedModel(\n\t\t\t\tportletDataContext, layoutFriendlyURL);\n\n\t\t\tportletDataContext.addReferenceElement(\n\t\t\t\tlayout, layoutElement, layoutFriendlyURL,\n\t\t\t\tPortletDataContext.REFERENCE_TYPE_DEPENDENCY, false);\n\t\t}\n\n\t\tif (layout.isIconImage()) {\n\t\t\texportLayoutIconImage(portletDataContext, layout, layoutElement);\n\t\t}\n\n\t\tif (layout.isTypeArticle()) {\n\t\t\texportJournalArticle(portletDataContext, layout, layoutElement);\n\t\t}\n\t\telse if (layout.isTypeLinkToLayout()) {\n\t\t\texportLinkedLayout(portletDataContext, layout, layoutElement);\n\t\t}\n\n\t\tfixExportTypeSettings(layout);\n\n\t\tportletDataContext.addClassedModel(\n\t\t\tlayoutElement, ExportImportPathUtil.getModelPath(layout), layout,\n\t\t\tLayoutPortletDataHandler.NAMESPACE);\n\t}","commit_id":"91a635f1b0b2b0594ae0a51eeff80e91fe774d70","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteLayout(Layout layout, boolean updateLayoutSet)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Child layouts\n\n\t\tList childLayouts = LayoutUtil.findByO_P(\n\t\t\tlayout.getOwnerId(), layout.getLayoutId());\n\n\t\tfor (int i = 0; i < childLayouts.size(); i++) {\n\t\t\tLayout childLayout = (Layout)childLayouts.get(i);\n\n\t\t\tdeleteLayout(childLayout, updateLayoutSet);\n\t\t}\n\n\t\t// Portlet preferences\n\n\t\tPortletPreferencesLocalServiceUtil.deleteAllByLayout(\n\t\t\tlayout.getPrimaryKey());\n\n\t\t// Journal content searches\n\n\t\tJournalContentSearchLocalServiceUtil.deleteLayoutContentSearches(\n\t\t\tlayout.getLayoutId(), layout.getOwnerId());\n\n\t\t// Layout set\n\n\t\tif (updateLayoutSet) {\n\t\t\tLayoutSetLocalServiceUtil.updatePageCount(layout.getOwnerId());\n\t\t}\n\n\t\t// Layout\n\n\t\tLayoutUtil.remove(layout.getPrimaryKey());\n\t}","id":65768,"modified_method":"public void deleteLayout(Layout layout, boolean updateLayoutSet)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Child layouts\n\n\t\tList childLayouts = LayoutUtil.findByO_P(\n\t\t\tlayout.getOwnerId(), layout.getLayoutId());\n\n\t\tfor (int i = 0; i < childLayouts.size(); i++) {\n\t\t\tLayout childLayout = (Layout)childLayouts.get(i);\n\n\t\t\tdeleteLayout(childLayout, updateLayoutSet);\n\t\t}\n\n\t\t// Portlet preferences\n\n\t\tPortletPreferencesLocalServiceUtil.deleteAllByLayout(\n\t\t\tlayout.getPrimaryKey());\n\n\t\t// Journal content searches\n\n\t\tJournalContentSearchLocalServiceUtil.deleteLayoutContentSearches(\n\t\t\tlayout.getLayoutId(), layout.getOwnerId());\n\n\t\t// Layout set\n\n\t\tif (updateLayoutSet) {\n\t\t\tLayoutSetLocalServiceUtil.updatePageCount(layout.getOwnerId());\n\t\t}\n\n\t\t// Resources\n\n\t\tResourceLocalServiceUtil.deleteResource(\n\t\t\tlayout.getCompanyId(), Layout.class.getName(), Resource.TYPE_CLASS,\n\t\t\tResource.SCOPE_INDIVIDUAL, layout.getPrimaryKey().toString());\n\n\t\t// Layout\n\n\t\tLayoutUtil.remove(layout.getPrimaryKey());\n\t}","commit_id":"1dec32d7713d587e6cf283d78c1c88486ac2a463","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean contains(\n\t\tPermissionChecker permissionChecker, String layoutId, String ownerId,\n\t\tString actionId) {\n\n\t\tString groupId = Layout.getGroupId(ownerId);\n\n\t\tif (GroupPermission.contains(\n\t\t\t\tpermissionChecker, groupId, ActionKeys.MANAGE_LAYOUTS)) {\n\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn permissionChecker.hasPermission(\n\t\t\tgroupId, Layout.class.getName(),\n\t\t\tnew LayoutPK(layoutId, ownerId).toString(), actionId);\n\t}","id":65769,"modified_method":"public static boolean contains(\n\t\t\tPermissionChecker permissionChecker, String layoutId,\n\t\t\tString ownerId, String actionId)\n\t\tthrows PortalException, SystemException {\n\n\t\tLayout layout =\n\t\t\tLayoutLocalServiceUtil.getLayout(layoutId, ownerId);\n\n\t\treturn contains(permissionChecker, layout, actionId);\n\t}","commit_id":"1dec32d7713d587e6cf283d78c1c88486ac2a463","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void check(\n\t\t\tPermissionChecker permissionChecker, String layoutId,\n\t\t\tString ownerId, String actionId)\n\t\tthrows PrincipalException {\n\n\t\tif (!contains(permissionChecker, layoutId, ownerId, actionId)) {\n\t\t\tthrow new PrincipalException();\n\t\t}\n\t}","id":65770,"modified_method":"public static void check(\n\t\t\tPermissionChecker permissionChecker, String layoutId,\n\t\t\tString ownerId, String actionId)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (!contains(permissionChecker, layoutId, ownerId, actionId)) {\n\t\t\tthrow new PrincipalException();\n\t\t}\n\t}","commit_id":"1dec32d7713d587e6cf283d78c1c88486ac2a463","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String processPath(\n\t\t\tHttpServletRequest req, HttpServletResponse res)\n\t\tthrows IOException {\n\n\t\tString path = super.processPath(req, res);\n\n\t\tHttpSession ses = req.getSession();\n\n\t\t// Current users\n\n\t\tString companyId = PortalUtil.getCompanyId(req);\n\n\t\tMap currentUsers = (Map)WebAppPool.get(\n\t\t\tcompanyId, WebKeys.CURRENT_USERS);\n\n\t\tUserTracker userTracker = (UserTracker)currentUsers.get(ses.getId());\n\n\t\tif ((userTracker != null) &&\n\t\t\t((path != null) &&\n\t\t\t\t(!path.equals(_PATH_C)) &&\n\t\t\t\t(path.indexOf(_PATH_J_SECURITY_CHECK) == -1) &&\n\t\t\t\t(path.indexOf(_PATH_PORTAL_PROTECTED) == -1))) {\n\n\t\t\t/*Map parameterMap = null;\n\n\t\t\tif (req instanceof UploadServletRequest) {\n\t\t\t\tUploadServletRequest uploadServletReq =\n\t\t\t\t\t(UploadServletRequest)req;\n\n\t\t\t\tparameterMap = uploadServletReq.getRequest().getParameterMap();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparameterMap = req.getParameterMap();\n\t\t\t}*/\n\n\t\t\tStringBuffer fullPathSB = new StringBuffer();\n\n\t\t\tfullPathSB.append(path);\n\t\t\t//fullPathSB.append(Http.parameterMapToString(parameterMap));\n\t\t\tfullPathSB.append(StringPool.QUESTION);\n\t\t\tfullPathSB.append(req.getQueryString());\n\n\t\t\tUserTrackerPath userTrackerPath =new UserTrackerPath();\n\n\t\t\tuserTrackerPath.setUserTrackerPathId(\n\t\t\t\tuserTracker.getUserTrackerId());\n\t\t\tuserTrackerPath.setUserTrackerId(userTracker.getUserTrackerId());\n\t\t\tuserTrackerPath.setPath(fullPathSB.toString());\n\t\t\tuserTrackerPath.setPathDate(new Date());\n\n\t\t\tuserTracker.addPath(userTrackerPath);\n\t\t}\n\n\t\tString userId = req.getRemoteUser();\n\n\t\tUser user = null;\n\n\t\ttry {\n\t\t\tuser = PortalUtil.getUser(req);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\t// Last path\n\n\t\tif ((path != null) && (_lastPaths.contains(path))) {\n\t\t\tboolean saveLastPath = true;\n\n\t\t\t// /login/view\n\n\t\t\tString strutsAction = req.getParameter(\"_58_struts_action\");\n\n\t\t\tif ((strutsAction != null) &&\n\t\t\t\t(strutsAction.equals(_PATH_LOGIN_VIEW))) {\n\n\t\t\t\tsaveLastPath = false;\n\t\t\t}\n\n\t\t\t// /my_account/create_account\n\n\t\t\tstrutsAction = req.getParameter(\"_2_struts_action\");\n\n\t\t\tif ((strutsAction != null) &&\n\t\t\t\t(strutsAction.equals(_PATH_MY_ACCOUNT_CREATE_ACCOUNT))) {\n\n\t\t\t\tsaveLastPath = false;\n\t\t\t}\n\n\t\t\t// Pop up window states should never be set as the last path\n\n\t\t\tif (LiferayWindowState.isPopUp(req)) {\n\t\t\t\tsaveLastPath = false;\n\t\t\t}\n\n\t\t\t// Save last path\n\n\t\t\tif (saveLastPath) {\n\t\t\t\tString mainPath = (String)req.getAttribute(WebKeys.MAIN_PATH);\n\n\t\t\t\t// Was a last path set by another servlet that dispatched to\n\t\t\t\t// the MainServlet? If so, use that last path instead.\n\n\t\t\t\tLastPath lastPath =\n\t\t\t\t\t(LastPath)req.getAttribute(WebKeys.LAST_PATH);\n\n\t\t\t\tif (lastPath == null) {\n\t\t\t\t\tlastPath = new LastPath(\n\t\t\t\t\t\tmainPath, path, req.getParameterMap());\n\t\t\t\t}\n\n\t\t\t\tses.setAttribute(WebKeys.LAST_PATH, lastPath);\n\t\t\t}\n\t\t}\n\n\t\t// Auto login\n\n\t\tif ((userId == null) && (ses.getAttribute(\"j_username\") == null) &&\n\t\t\t(!isAutoLoginDisabledPaths(path))) {\n\n\t\t\ttry {\n\t\t\t\tString[] autoLogins = PropsUtil.getArray(\n\t\t\t\t\tPropsUtil.AUTO_LOGIN_HOOKS);\n\n\t\t\t\tfor (int i = 0; i < autoLogins.length; i++) {\n\t\t\t\t\tAutoLogin autoLogin =\n\t\t\t\t\t\t(AutoLogin)InstancePool.get(autoLogins[i]);\n\n\t\t\t\t\tString[] credentials = autoLogin.login(req, res);\n\n\t\t\t\t\tif ((credentials != null) && (credentials.length == 3)) {\n\t\t\t\t\t\tString jUsername = credentials[0];\n\t\t\t\t\t\tString jPassword = credentials[1];\n\t\t\t\t\t\tboolean encPwd = GetterUtil.getBoolean(credentials[2]);\n\n\t\t\t\t\t\tif (Validator.isNotNull(jUsername) &&\n\t\t\t\t\t\t\tValidator.isNotNull(jPassword)) {\n\n\t\t\t\t\t\t\tses.setAttribute(\"j_username\", jUsername);\n\n\t\t\t\t\t\t\t// Not having access to the unencrypted password\n\t\t\t\t\t\t\t// will not allow you to connect to external\n\t\t\t\t\t\t\t// resources that require it (mail server)\n\n\t\t\t\t\t\t\tif (encPwd) {\n\t\t\t\t\t\t\t\tses.setAttribute(\"j_password\", jPassword);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tses.setAttribute(\"j_password\",\n\t\t\t\t\t\t\t\t\tPwdEncryptor.encrypt(jPassword));\n\n\t\t\t\t\t\t\t\tses.setAttribute(\n\t\t\t\t\t\t\t\t\tWebKeys.USER_PASSWORD, jPassword);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tses.setAttribute(\"j_remoteuser\", jUsername);\n\n\t\t\t\t\t\t\treturn _PATH_PORTAL_LOGIN;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tcatch (AutoLoginException ale) {\n\t\t\t\t_log.error(ale.getMessage());\n\t\t\t}\n\t\t}\n\n\t\t// Authenticated users can always log out\n\n\t\tif ((userId != null || user != null) && (path != null) &&\n\t\t\t(path.equals(_PATH_PORTAL_LOGOUT))) {\n\n\t\t\treturn _PATH_PORTAL_LOGOUT;\n\t\t}\n\n\t\t// Authenticated users can retrieve CSS and JavaScript\n\n\t\tif ((userId != null || user != null) && (path != null) &&\n\t\t\t(path.equals(_PATH_PORTAL_CSS) ||\n\t\t\t path.equals(_PATH_PORTAL_CSS_CACHED) ||\n\t\t\t path.equals(_PATH_PORTAL_JAVASCRIPT) ||\n\t\t\t path.equals(_PATH_PORTAL_JAVASCRIPT_CACHED))) {\n\n\t\t\treturn path;\n\t\t}\n\n\t\t// Authenticated users can always agree to terms of use\n\n\t\tif ((userId != null || user != null) && (path != null) &&\n\t\t\t(path.equals(_PATH_PORTAL_UPDATE_TERMS_OF_USE))) {\n\n\t\t\treturn _PATH_PORTAL_UPDATE_TERMS_OF_USE;\n\t\t}\n\n\t\t// Authenticated users must still exist in the system\n\n\t\tif ((userId != null) && (user == null)) {\n\t\t\treturn _PATH_PORTAL_LOGOUT;\n\t\t}\n\n\t\t// Authenticated users must agree to Terms of Use\n\n\t\tif ((user != null) && (!user.isAgreedToTermsOfUse())) {\n\t\t\tboolean termsOfUseRequired = GetterUtil.get(\n\t\t\t\tPropsUtil.get(PropsUtil.TERMS_OF_USE_REQUIRED), true);\n\n\t\t\tif (termsOfUseRequired) {\n\t\t\t\treturn _PATH_PORTAL_TERMS_OF_USE;\n\t\t\t}\n\t\t}\n\n\t\t// Authenticated users must be active\n\n\t\tif ((user != null) && (!user.isActive())) {\n\t\t\tSessionErrors.add(req, UserActiveException.class.getName());\n\n\t\t\treturn _PATH_PORTAL_ERROR;\n\t\t}\n\n\t\t// Authenticated users may not be allowed to have simultaneous logins\n\n\t\tboolean simultaenousLogins = GetterUtil.get(\n\t\t\tPropsUtil.get(PropsUtil.AUTH_SIMULTANEOUS_LOGINS), true);\n\n\t\tif (!simultaenousLogins) {\n\t\t\tBoolean staleSession =\n\t\t\t\t(Boolean)ses.getAttribute(WebKeys.STALE_SESSION);\n\n\t\t\tif ((user != null) &&\n\t\t\t\t(staleSession != null && staleSession.booleanValue() == true)) {\n\n\t\t\t\treturn _PATH_PORTAL_ERROR;\n\t\t\t}\n\t\t}\n\n\t\t// Authenticated users must have a current password\n\n\t\tif ((user != null) && (user.isPasswordReset())) {\n\t\t\treturn _PATH_PORTAL_CHANGE_PASSWORD;\n\t\t}\n\n\t\t// Authenticated users must have at least one personalized page\n\n\t\tif (user != null) {\n\t\t\tThemeDisplay themeDisplay =\n\t\t\t\t(ThemeDisplay)req.getAttribute(WebKeys.THEME_DISPLAY);\n\n\t\t\tif (themeDisplay.getLayouts() == null || themeDisplay.getLayouts().size() == 0) {\n\t\t\t\tSessionErrors.add(\n\t\t\t\t\treq, RequiredLayoutException.class.getName());\n\n\t\t\t\treturn _PATH_PORTAL_ERROR;\n\t\t\t}\n\t\t}\n\n\t\t// Users must sign in\n\n\t\tif (!isPublicPath(path)) {\n\t\t\tif (user == null) {\n\t\t\t\tSessionErrors.add(req, PrincipalException.class.getName());\n\n\t\t\t\treturn _PATH_PORTAL_LOGIN;\n\t\t\t}\n\t\t}\n\n\t\tActionMapping mapping =\n\t\t\t(ActionMapping)moduleConfig.findActionConfig(path);\n\n\t\tif (path.startsWith(_PATH_WSRP)) {\n\t\t\tpath = _PATH_WSRP;\n\t\t}\n\t\telse {\n\t\t\tpath = mapping.getPath();\n\t\t}\n\n\t\t// Authenticated users must have at least one role\n\n\t\tif (user != null) {\n\t\t\ttry {\n\n\t\t\t\t// FIX ME\n\n\t\t\t\tif (false) {\n\t\t\t\t\tSessionErrors.add(\n\t\t\t\t\t\treq, RequiredRoleException.class.getName());\n\n\t\t\t\t\treturn _PATH_PORTAL_ERROR;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\t// Define the portlet objects\n\n\t\tif (isPortletPath(path)) {\n\t\t\ttry {\n\t\t\t\tPortlet portlet = null;\n\n\t\t\t\tString portletId = ParamUtil.getString(req, \"p_p_id\");\n\n\t\t\t\tif (Validator.isNotNull(portletId)) {\n\t\t\t\t\tportlet = PortletServiceUtil.getPortletById(\n\t\t\t\t\t\tcompanyId, portletId);\n\t\t\t\t}\n\n\t\t\t\tif (portlet == null) {\n\t\t\t\t\tString strutsPath = path.substring(\n\t\t\t\t\t\t1, path.lastIndexOf(StringPool.SLASH));\n\n\t\t\t\t\tportlet = PortletServiceUtil.getPortletByStrutsPath(\n\t\t\t\t\t\tcompanyId, strutsPath);\n\t\t\t\t}\n\n\t\t\t\tif (portlet != null && portlet.isActive()) {\n\t\t\t\t\tdefineObjects(req, res, portlet);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\treq.setAttribute(PageContext.EXCEPTION, e);\n\n\t\t\t\tpath = _PATH_COMMON_ERROR;\n\t\t\t}\n\t\t}\n\n\t\t// Authenticated users must have access to at least one layout\n\n\t\tif (SessionErrors.contains(req, LayoutPermissionException.class.getName())) {\n\t\t\treturn _PATH_PORTAL_ERROR;\n\t\t}\n\t\t\n\t\treturn path;\n\t}","id":65771,"modified_method":"protected String processPath(\n\t\t\tHttpServletRequest req, HttpServletResponse res)\n\t\tthrows IOException {\n\n\t\tString path = super.processPath(req, res);\n\n\t\tHttpSession ses = req.getSession();\n\n\t\t// Current users\n\n\t\tString companyId = PortalUtil.getCompanyId(req);\n\n\t\tMap currentUsers = (Map)WebAppPool.get(\n\t\t\tcompanyId, WebKeys.CURRENT_USERS);\n\n\t\tUserTracker userTracker = (UserTracker)currentUsers.get(ses.getId());\n\n\t\tif ((userTracker != null) &&\n\t\t\t((path != null) &&\n\t\t\t\t(!path.equals(_PATH_C)) &&\n\t\t\t\t(path.indexOf(_PATH_J_SECURITY_CHECK) == -1) &&\n\t\t\t\t(path.indexOf(_PATH_PORTAL_PROTECTED) == -1))) {\n\n\t\t\t/*Map parameterMap = null;\n\n\t\t\tif (req instanceof UploadServletRequest) {\n\t\t\t\tUploadServletRequest uploadServletReq =\n\t\t\t\t\t(UploadServletRequest)req;\n\n\t\t\t\tparameterMap = uploadServletReq.getRequest().getParameterMap();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparameterMap = req.getParameterMap();\n\t\t\t}*/\n\n\t\t\tStringBuffer fullPathSB = new StringBuffer();\n\n\t\t\tfullPathSB.append(path);\n\t\t\t//fullPathSB.append(Http.parameterMapToString(parameterMap));\n\t\t\tfullPathSB.append(StringPool.QUESTION);\n\t\t\tfullPathSB.append(req.getQueryString());\n\n\t\t\tUserTrackerPath userTrackerPath =new UserTrackerPath();\n\n\t\t\tuserTrackerPath.setUserTrackerPathId(\n\t\t\t\tuserTracker.getUserTrackerId());\n\t\t\tuserTrackerPath.setUserTrackerId(userTracker.getUserTrackerId());\n\t\t\tuserTrackerPath.setPath(fullPathSB.toString());\n\t\t\tuserTrackerPath.setPathDate(new Date());\n\n\t\t\tuserTracker.addPath(userTrackerPath);\n\t\t}\n\n\t\tString userId = req.getRemoteUser();\n\n\t\tUser user = null;\n\n\t\ttry {\n\t\t\tuser = PortalUtil.getUser(req);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\t// Last path\n\n\t\tif ((path != null) && (_lastPaths.contains(path))) {\n\t\t\tboolean saveLastPath = true;\n\n\t\t\t// /login/view\n\n\t\t\tString strutsAction = req.getParameter(\"_58_struts_action\");\n\n\t\t\tif ((strutsAction != null) &&\n\t\t\t\t(strutsAction.equals(_PATH_LOGIN_VIEW))) {\n\n\t\t\t\tsaveLastPath = false;\n\t\t\t}\n\n\t\t\t// /my_account/create_account\n\n\t\t\tstrutsAction = req.getParameter(\"_2_struts_action\");\n\n\t\t\tif ((strutsAction != null) &&\n\t\t\t\t(strutsAction.equals(_PATH_MY_ACCOUNT_CREATE_ACCOUNT))) {\n\n\t\t\t\tsaveLastPath = false;\n\t\t\t}\n\n\t\t\t// Pop up window states should never be set as the last path\n\n\t\t\tif (LiferayWindowState.isPopUp(req)) {\n\t\t\t\tsaveLastPath = false;\n\t\t\t}\n\n\t\t\t// Save last path\n\n\t\t\tif (saveLastPath) {\n\t\t\t\tString mainPath = (String)req.getAttribute(WebKeys.MAIN_PATH);\n\n\t\t\t\t// Was a last path set by another servlet that dispatched to\n\t\t\t\t// the MainServlet? If so, use that last path instead.\n\n\t\t\t\tLastPath lastPath =\n\t\t\t\t\t(LastPath)req.getAttribute(WebKeys.LAST_PATH);\n\n\t\t\t\tif (lastPath == null) {\n\t\t\t\t\tlastPath = new LastPath(\n\t\t\t\t\t\tmainPath, path, req.getParameterMap());\n\t\t\t\t}\n\n\t\t\t\tses.setAttribute(WebKeys.LAST_PATH, lastPath);\n\t\t\t}\n\t\t}\n\n\t\t// Auto login\n\n\t\tif ((userId == null) && (ses.getAttribute(\"j_username\") == null) &&\n\t\t\t(!isAutoLoginDisabledPaths(path))) {\n\n\t\t\ttry {\n\t\t\t\tString[] autoLogins = PropsUtil.getArray(\n\t\t\t\t\tPropsUtil.AUTO_LOGIN_HOOKS);\n\n\t\t\t\tfor (int i = 0; i < autoLogins.length; i++) {\n\t\t\t\t\tAutoLogin autoLogin =\n\t\t\t\t\t\t(AutoLogin)InstancePool.get(autoLogins[i]);\n\n\t\t\t\t\tString[] credentials = autoLogin.login(req, res);\n\n\t\t\t\t\tif ((credentials != null) && (credentials.length == 3)) {\n\t\t\t\t\t\tString jUsername = credentials[0];\n\t\t\t\t\t\tString jPassword = credentials[1];\n\t\t\t\t\t\tboolean encPwd = GetterUtil.getBoolean(credentials[2]);\n\n\t\t\t\t\t\tif (Validator.isNotNull(jUsername) &&\n\t\t\t\t\t\t\tValidator.isNotNull(jPassword)) {\n\n\t\t\t\t\t\t\tses.setAttribute(\"j_username\", jUsername);\n\n\t\t\t\t\t\t\t// Not having access to the unencrypted password\n\t\t\t\t\t\t\t// will not allow you to connect to external\n\t\t\t\t\t\t\t// resources that require it (mail server)\n\n\t\t\t\t\t\t\tif (encPwd) {\n\t\t\t\t\t\t\t\tses.setAttribute(\"j_password\", jPassword);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tses.setAttribute(\"j_password\",\n\t\t\t\t\t\t\t\t\tPwdEncryptor.encrypt(jPassword));\n\n\t\t\t\t\t\t\t\tses.setAttribute(\n\t\t\t\t\t\t\t\t\tWebKeys.USER_PASSWORD, jPassword);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tses.setAttribute(\"j_remoteuser\", jUsername);\n\n\t\t\t\t\t\t\treturn _PATH_PORTAL_LOGIN;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tcatch (AutoLoginException ale) {\n\t\t\t\t_log.error(ale.getMessage());\n\t\t\t}\n\t\t}\n\n\t\t// Authenticated users can always log out\n\n\t\tif ((userId != null || user != null) && (path != null) &&\n\t\t\t(path.equals(_PATH_PORTAL_LOGOUT))) {\n\n\t\t\treturn _PATH_PORTAL_LOGOUT;\n\t\t}\n\n\t\t// Authenticated users can retrieve CSS and JavaScript\n\n\t\tif ((userId != null || user != null) && (path != null) &&\n\t\t\t(path.equals(_PATH_PORTAL_CSS) ||\n\t\t\t path.equals(_PATH_PORTAL_CSS_CACHED) ||\n\t\t\t path.equals(_PATH_PORTAL_JAVASCRIPT) ||\n\t\t\t path.equals(_PATH_PORTAL_JAVASCRIPT_CACHED))) {\n\n\t\t\treturn path;\n\t\t}\n\n\t\t// Authenticated users can always agree to terms of use\n\n\t\tif ((userId != null || user != null) && (path != null) &&\n\t\t\t(path.equals(_PATH_PORTAL_UPDATE_TERMS_OF_USE))) {\n\n\t\t\treturn _PATH_PORTAL_UPDATE_TERMS_OF_USE;\n\t\t}\n\n\t\t// Authenticated users must still exist in the system\n\n\t\tif ((userId != null) && (user == null)) {\n\t\t\treturn _PATH_PORTAL_LOGOUT;\n\t\t}\n\n\t\t// Authenticated users must agree to Terms of Use\n\n\t\tif ((user != null) && (!user.isAgreedToTermsOfUse())) {\n\t\t\tboolean termsOfUseRequired = GetterUtil.get(\n\t\t\t\tPropsUtil.get(PropsUtil.TERMS_OF_USE_REQUIRED), true);\n\n\t\t\tif (termsOfUseRequired) {\n\t\t\t\treturn _PATH_PORTAL_TERMS_OF_USE;\n\t\t\t}\n\t\t}\n\n\t\t// Authenticated users must be active\n\n\t\tif ((user != null) && (!user.isActive())) {\n\t\t\tSessionErrors.add(req, UserActiveException.class.getName());\n\n\t\t\treturn _PATH_PORTAL_ERROR;\n\t\t}\n\n\t\t// Authenticated users may not be allowed to have simultaneous logins\n\n\t\tboolean simultaenousLogins = GetterUtil.get(\n\t\t\tPropsUtil.get(PropsUtil.AUTH_SIMULTANEOUS_LOGINS), true);\n\n\t\tif (!simultaenousLogins) {\n\t\t\tBoolean staleSession =\n\t\t\t\t(Boolean)ses.getAttribute(WebKeys.STALE_SESSION);\n\n\t\t\tif ((user != null) && (staleSession != null) &&\n\t\t\t\t(staleSession.booleanValue())) {\n\n\t\t\t\treturn _PATH_PORTAL_ERROR;\n\t\t\t}\n\t\t}\n\n\t\t// Authenticated users must have a current password\n\n\t\tif ((user != null) && (user.isPasswordReset())) {\n\t\t\treturn _PATH_PORTAL_CHANGE_PASSWORD;\n\t\t}\n\n\t\t// Authenticated users must have at least one personalized page\n\n\t\tif (user != null) {\n\t\t\tThemeDisplay themeDisplay =\n\t\t\t\t(ThemeDisplay)req.getAttribute(WebKeys.THEME_DISPLAY);\n\n\t\t\tList layouts = themeDisplay.getLayouts();\n\n\t\t\tif ((layouts == null) || (layouts.size() == 0)) {\n\t\t\t\tSessionErrors.add(\n\t\t\t\t\treq, RequiredLayoutException.class.getName());\n\n\t\t\t\treturn _PATH_PORTAL_ERROR;\n\t\t\t}\n\t\t}\n\n\t\t// Users must sign in\n\n\t\tif (!isPublicPath(path)) {\n\t\t\tif (user == null) {\n\t\t\t\tSessionErrors.add(req, PrincipalException.class.getName());\n\n\t\t\t\treturn _PATH_PORTAL_LOGIN;\n\t\t\t}\n\t\t}\n\n\t\tActionMapping mapping =\n\t\t\t(ActionMapping)moduleConfig.findActionConfig(path);\n\n\t\tif (path.startsWith(_PATH_WSRP)) {\n\t\t\tpath = _PATH_WSRP;\n\t\t}\n\t\telse {\n\t\t\tpath = mapping.getPath();\n\t\t}\n\n\t\t// Authenticated users must have at least one role\n\n\t\tif (user != null) {\n\t\t\ttry {\n\n\t\t\t\t// FIX ME\n\n\t\t\t\tif (false) {\n\t\t\t\t\tSessionErrors.add(\n\t\t\t\t\t\treq, RequiredRoleException.class.getName());\n\n\t\t\t\t\treturn _PATH_PORTAL_ERROR;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\t// Define the portlet objects\n\n\t\tif (isPortletPath(path)) {\n\t\t\ttry {\n\t\t\t\tPortlet portlet = null;\n\n\t\t\t\tString portletId = ParamUtil.getString(req, \"p_p_id\");\n\n\t\t\t\tif (Validator.isNotNull(portletId)) {\n\t\t\t\t\tportlet = PortletServiceUtil.getPortletById(\n\t\t\t\t\t\tcompanyId, portletId);\n\t\t\t\t}\n\n\t\t\t\tif (portlet == null) {\n\t\t\t\t\tString strutsPath = path.substring(\n\t\t\t\t\t\t1, path.lastIndexOf(StringPool.SLASH));\n\n\t\t\t\t\tportlet = PortletServiceUtil.getPortletByStrutsPath(\n\t\t\t\t\t\tcompanyId, strutsPath);\n\t\t\t\t}\n\n\t\t\t\tif (portlet != null && portlet.isActive()) {\n\t\t\t\t\tdefineObjects(req, res, portlet);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\treq.setAttribute(PageContext.EXCEPTION, e);\n\n\t\t\t\tpath = _PATH_COMMON_ERROR;\n\t\t\t}\n\t\t}\n\n\t\t// Authenticated users must have access to at least one layout\n\n\t\tif (SessionErrors.contains(\n\t\t\t\treq, LayoutPermissionException.class.getName())) {\n\n\t\t\treturn _PATH_PORTAL_ERROR;\n\t\t}\n\n\t\treturn path;\n\t}","commit_id":"1dec32d7713d587e6cf283d78c1c88486ac2a463","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean processRoles(\n\t\t\tHttpServletRequest req, HttpServletResponse res,\n\t\t\tActionMapping mapping, boolean action)\n\t\tthrows IOException, ServletException {\n\n\t\tUser user = null;\n\n\t\ttry {\n\t\t\tuser = PortalUtil.getUser(req);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\tif (user == null) {\n\t\t\treturn true;\n\t\t}\n\n\t\tString path = mapping.getPath();\n\n\t\ttry {\n\t\t\tPortletConfigImpl portletConfig =\n\t\t\t\t(PortletConfigImpl)req.getAttribute(\n\t\t\t\t\tWebKeys.JAVAX_PORTLET_CONFIG);\n\n\t\t\tPortlet portlet = PortletServiceUtil.getPortletById(\n\t\t\t\tuser.getCompanyId(), portletConfig.getPortletId());\n\n\t\t\tif (portlet == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tString strutsPath = path.substring(\n\t\t\t\t1, path.lastIndexOf(StringPool.SLASH));\n\n\t\t\tif (!strutsPath.equals(portlet.getStrutsPath())) {\n\t\t\t\tthrow new PrincipalException();\n\t\t\t}\n\t\t\telse if (portlet.isActive()) {\n\t\t\t\tThemeDisplay themeDisplay =\n\t\t\t\t\t(ThemeDisplay)req.getAttribute(WebKeys.THEME_DISPLAY);\n\n\t\t\t\tLayout layout = themeDisplay.getLayout();\n\t\t\t\tPermissionChecker permissionChecker =\n\t\t\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\t\t\tif (!PortletPermission.contains(\n\t\t\t\t\t\tpermissionChecker, layout.getPlid(),\n\t\t\t\t\t\tportlet.getPortletId(), ActionKeys.VIEW) &&\n\t\t\t\t\t!GroupPermission.contains(\n\t\t\t\t\t\tpermissionChecker, layout.getGroupId(),\n\t\t\t\t\t\tActionKeys.MANAGE_LAYOUTS) && \n\t\t\t\t\t!LayoutPermission.contains(\n\t\t\t\t\t\tpermissionChecker, layout.getLayoutId(),\n\t\t\t\t\t\tlayout.getOwnerId(), ActionKeys.UPDATE)) {\n\n\t\t\t\t\tthrow new PrincipalException();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!portlet.isActive()) {\n\t\t\t\tForwardConfig forwardConfig =\n\t\t\t\t\tmapping.findForward(_PATH_PORTAL_PORTLET_INACTIVE);\n\n\t\t\t\tif (!action) {\n\t\t\t\t\tprocessForwardConfig(req, res, forwardConfig);\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tForwardConfig forwardConfig =\n\t\t\t\tmapping.findForward(_PATH_PORTAL_PORTLET_ACCESS_DENIED);\n\n\t\t\tif (!action) {\n\t\t\t\tprocessForwardConfig(req, res, forwardConfig);\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}","id":65772,"modified_method":"protected boolean processRoles(\n\t\t\tHttpServletRequest req, HttpServletResponse res,\n\t\t\tActionMapping mapping, boolean action)\n\t\tthrows IOException, ServletException {\n\n\t\tUser user = null;\n\n\t\ttry {\n\t\t\tuser = PortalUtil.getUser(req);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\tif (user == null) {\n\t\t\treturn true;\n\t\t}\n\n\t\tString path = mapping.getPath();\n\n\t\ttry {\n\t\t\tPortletConfigImpl portletConfig =\n\t\t\t\t(PortletConfigImpl)req.getAttribute(\n\t\t\t\t\tWebKeys.JAVAX_PORTLET_CONFIG);\n\n\t\t\tPortlet portlet = PortletServiceUtil.getPortletById(\n\t\t\t\tuser.getCompanyId(), portletConfig.getPortletId());\n\n\t\t\tif (portlet == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tString strutsPath = path.substring(\n\t\t\t\t1, path.lastIndexOf(StringPool.SLASH));\n\n\t\t\tif (!strutsPath.equals(portlet.getStrutsPath())) {\n\t\t\t\tthrow new PrincipalException();\n\t\t\t}\n\t\t\telse if (portlet.isActive()) {\n\t\t\t\tThemeDisplay themeDisplay =\n\t\t\t\t\t(ThemeDisplay)req.getAttribute(WebKeys.THEME_DISPLAY);\n\n\t\t\t\tLayout layout = themeDisplay.getLayout();\n\t\t\t\tPermissionChecker permissionChecker =\n\t\t\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\t\t\tif (!PortletPermission.contains(\n\t\t\t\t\t\tpermissionChecker, layout.getPlid(),\n\t\t\t\t\t\tportlet.getPortletId(), ActionKeys.VIEW) &&\n\t\t\t\t\t!GroupPermission.contains(\n\t\t\t\t\t\tpermissionChecker, layout.getGroupId(),\n\t\t\t\t\t\tActionKeys.MANAGE_LAYOUTS) &&\n\t\t\t\t\t!LayoutPermission.contains(\n\t\t\t\t\t\tpermissionChecker, layout, ActionKeys.UPDATE)) {\n\n\t\t\t\t\tthrow new PrincipalException();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!portlet.isActive()) {\n\t\t\t\tForwardConfig forwardConfig =\n\t\t\t\t\tmapping.findForward(_PATH_PORTAL_PORTLET_INACTIVE);\n\n\t\t\t\tif (!action) {\n\t\t\t\t\tprocessForwardConfig(req, res, forwardConfig);\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tForwardConfig forwardConfig =\n\t\t\t\tmapping.findForward(_PATH_PORTAL_PORTLET_ACCESS_DENIED);\n\n\t\t\tif (!action) {\n\t\t\t\tprocessForwardConfig(req, res, forwardConfig);\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}","commit_id":"1dec32d7713d587e6cf283d78c1c88486ac2a463","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void run(HttpServletRequest req, HttpServletResponse res)\n\t\tthrows ActionException {\n\n\t\ttry {\n\t\t\tHttpSession ses = req.getSession();\n\n\t\t\t// Company\n\n\t\t\tCompany company = PortalUtil.getCompany(req);\n\n\t\t\tString companyId = company.getCompanyId();\n\n\t\t\t// Paths\n\n\t\t\tString contextPath = CompanyPropsUtil.get(\n\t\t\t\tcompanyId, PropsUtil.PORTAL_CTX);\n\n\t\t\tif (contextPath.equals(StringPool.SLASH)) {\n\t\t\t\tcontextPath = StringPool.BLANK;\n\t\t\t}\n\n\t\t\tString rootPath = (String)req.getAttribute(WebKeys.ROOT_PATH);\n\t\t\tString mainPath = (String)req.getAttribute(WebKeys.MAIN_PATH);\n\t\t\tString captchaPath = (String)req.getAttribute(WebKeys.CAPTCHA_PATH);\n\t\t\tString friendlyURLPrivatePath =\n\t\t\t\t(String)req.getAttribute(WebKeys.FRIENDLY_URL_PRIVATE_PATH);\n\t\t\tString friendlyURLPublicPath =\n\t\t\t\t(String)req.getAttribute(WebKeys.FRIENDLY_URL_PUBLIC_PATH);\n\t\t\tString imagePath = (String)req.getAttribute(WebKeys.IMAGE_PATH);\n\n\t\t\t// Company logo\n\n\t\t\tString companyLogo = StringPool.BLANK;\n\n\t\t\tif (true) {\n\n\t\t\t\t// For now, always set the company logo URL. This behavior may\n\t\t\t\t// change if it makes life easier for the theme designer. The\n\t\t\t\t// company logo URL would then be blank if the company has never\n\t\t\t\t// set a logo.\n\n\t\t\t\tcompanyLogo = imagePath + \"/company_logo?img_id=\" + companyId;\n\t\t\t}\n\n\t\t\t// User\n\n\t\t\tUser user = null;\n\n\t\t\ttry {\n\t\t\t\tuser = PortalUtil.getUser(req);\n\t\t\t}\n\t\t\tcatch (NoSuchUserException nsue) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Is the user signed in?\n\n\t\t\tboolean signedIn = false;\n\n\t\t\tif (user == null) {\n\t\t\t\tuser = company.getDefaultUser();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsignedIn = true;\n\t\t\t}\n\n\t\t\t// Permission checker\n\n\t\t\tPermissionChecker permissionChecker =\n\t\t\t\tPermissionCheckerFactory.create(user, signedIn);\n\n\t\t\tPermissionThreadLocal.setPermissionChecker(permissionChecker);\n\n\t\t\t// Locale\n\n\t\t\tLocale locale = (Locale)ses.getAttribute(Globals.LOCALE_KEY);\n\n\t\t\tif (locale == null) {\n\t\t\t\tif (signedIn) {\n\t\t\t\t\tlocale = user.getLocale();\n\t\t\t\t}\n\t\t\t\telse {\n\n\t\t\t\t\t// User previously set their preferred language\n\n\t\t\t\t\tString languageId = CookieUtil.get(\n\t\t\t\t\t\treq.getCookies(), CookieKeys.GUEST_LANGUAGE_ID);\n\n\t\t\t\t\tif (Validator.isNotNull(languageId)) {\n\t\t\t\t\t\tlocale = LocaleUtil.fromLanguageId(languageId);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get locale from the request\n\n\t\t\t\t\tif ((locale == null) &&\n\t\t\t\t\t\tGetterUtil.getBoolean(\n\t\t\t\t\t\t\tPropsUtil.get(PropsUtil.LOCALE_DEFAULT_REQUEST))) {\n\n\t\t\t\t\t\tlocale = req.getLocale();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get locale from the default user\n\n\t\t\t\t\tif (locale == null) {\n\t\t\t\t\t\tlocale = user.getLocale();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Validator.isNull(locale.getCountry())) {\n\n\t\t\t\t\t\t// Locales must contain the country code\n\n\t\t\t\t\t\tlocale = LanguageUtil.getLocale(locale.getLanguage());\n\t\t\t\t\t}\n\n\t\t\t\t\tList availableLocales = ListUtil.fromArray(\n\t\t\t\t\t\tLanguageUtil.getAvailableLocales());\n\n\t\t\t\t\tif (!availableLocales.contains(locale)) {\n\t\t\t\t\t\tlocale = user.getLocale();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tses.setAttribute(Globals.LOCALE_KEY, locale);\n\n\t\t\t\tLanguageUtil.updateCookie(res, locale);\n\t\t\t}\n\n\t\t\t// Cookie support\n\n\t\t\tCookieKeys.addSupportCookie(res);\n\n\t\t\t// Time zone\n\n\t\t\tTimeZone timeZone = user.getTimeZone();\n\n\t\t\tif (timeZone == null) {\n\t\t\t\ttimeZone = company.getTimeZone();\n\t\t\t}\n\n\t\t\t// Layouts\n\n\t\t\tif (signedIn) {\n\t\t\t\tboolean layoutsRequired = user.isLayoutsRequired();\n\n\t\t\t\tif (layoutsRequired) {\n\t\t\t\t\taddDefaultLayouts(user);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdeleteDefaultLayouts(user);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLayout layout = null;\n\t\t\tList layouts = null;\n\n\t\t\tString plid = ParamUtil.getString(req, \"p_l_id\");\n\n\t\t\tString layoutId = Layout.getLayoutId(plid);\n\t\t\tString ownerId = Layout.getOwnerId(plid);\n\n\t\t\tif ((layoutId != null) && (ownerId != null)) {\n\t\t\t\ttry {\n\t\t\t\t\tlayout = LayoutLocalServiceUtil.getLayout(\n\t\t\t\t\t\tlayoutId, ownerId);\n\n\t\t\t\t\tif (!isLayoutViewable(user, ownerId)) {\n\t\t\t\t\t\tlayout = null;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlayouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\t\t\t\t\townerId, Layout.DEFAULT_PARENT_LAYOUT_ID);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchLayoutException nsle) {\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (layout == null) {\n\t\t\t\tObject[] defaultLayout = getDefaultLayout(user, signedIn);\n\n\t\t\t\tlayout = (Layout)defaultLayout[0];\n\t\t\t\tlayouts = (List)defaultLayout[1];\n\t\t\t}\n\n\t\t\tif (layouts != null && layouts.size() > 0) {\n\t\t\t\tboolean isReplaceLayout = true;\n\t\t\t\t\n\t\t\t\tcheckResource(layout, company.getCompanyId());\n\t\t\t\t\n\t\t\t\tif (LayoutPermission.contains(permissionChecker, layout.getLayoutId(), layout.getOwnerId(), ActionKeys.VIEW) || !signedIn) {\n\t\t\t\t\tisReplaceLayout = false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tList accessibleLayouts = new ArrayList();\n\t\t\t\t\n\t\t\t\tfor (int i = 0; i < layouts.size(); i++) {\n\t\t\t\t\tLayout curLayout = (Layout)layouts.get(i);\n\t\n\t\t\t\t\tcheckResource(curLayout, company.getCompanyId());\n\t\t\t\t\t\n\t\t\t\t\tif (LayoutPermission.contains(permissionChecker, curLayout.getLayoutId(), curLayout.getOwnerId(), ActionKeys.VIEW) || !signedIn) {\n\t\t\t\t\t\tif (accessibleLayouts.size() == 0 && isReplaceLayout) {\n\t\t\t\t\t\t\tlayout = curLayout;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\taccessibleLayouts.add(curLayout);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (accessibleLayouts.size() == 0 && signedIn) {\n\t\t\t\t\tlayouts = null;\n\t\t\t\t\tSessionErrors.add(req, LayoutPermissionException.class.getName());\n\t\t\t\t} else {\n\t\t\t\t\tlayouts = accessibleLayouts;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (layout != null) {\n\t\t\t\tplid = layout.getPlid();\n\n\t\t\t\tlayoutId = layout.getLayoutId();\n\t\t\t\townerId = layout.getOwnerId();\n\t\t\t}\n\n\t\t\tif ((layout != null) && layout.isShared()) {\n\n\t\t\t\t// Updates to shared layouts are not reflected until the next\n\t\t\t\t// time the user logs in because group layouts are cached in the\n\t\t\t\t// session\n\n\t\t\t\tlayout = (Layout)layout.clone();\n\t\t\t}\n\n\t\t\tLayoutTypePortlet layoutTypePortlet = null;\n\n\t\t\tif (layout != null) {\n\t\t\t\treq.setAttribute(WebKeys.LAYOUT, layout);\n\t\t\t\treq.setAttribute(WebKeys.LAYOUTS, layouts);\n\n\t\t\t\tlayoutTypePortlet = (LayoutTypePortlet)layout.getLayoutType();\n\t\t\t}\n\n\t\t\tString portletGroupId = PortalUtil.getPortletGroupId(plid);\n\n\t\t\t// Theme and color scheme\n\n\t\t\tTheme theme = null;\n\t\t\tColorScheme colorScheme = null;\n\n\t\t\tif (layout != null) {\n\t\t\t\ttheme = layout.getTheme();\n\t\t\t\tcolorScheme = layout.getColorScheme();\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttheme = ThemeLocalUtil.getTheme(\n\t\t\t\t\tcompanyId,\n\t\t\t\t\tCompanyPropsUtil.get(\n\t\t\t\t\t\tcompanyId, PropsUtil.DEFAULT_THEME_ID));\n\t\t\t\tcolorScheme = ThemeLocalUtil.getColorScheme(\n\t\t\t\t\tcompanyId, theme.getThemeId(),\n\t\t\t\t\tCompanyPropsUtil.get(\n\t\t\t\t\t\tcompanyId, PropsUtil.DEFAULT_COLOR_SCHEME_ID));\n\t\t\t}\n\n\t\t\treq.setAttribute(WebKeys.THEME, theme);\n\t\t\treq.setAttribute(WebKeys.COLOR_SCHEME, colorScheme);\n\n\t\t\t// Resolution\n\n\t\t\tint resolution = Resolution.FULL_RESOLUTION;\n\n\t\t\tString resolutionKey = user.getResolution();\n\n\t\t\tif (resolutionKey.equals(Resolution.S1024X768_KEY)) {\n\t\t\t\tresolution = Resolution.S1024X768_RESOLUTION;\n\t\t\t}\n\t\t\telse if (resolutionKey.equals(Resolution.S800X600_KEY)) {\n\t\t\t\tresolution = Resolution.S800X600_RESOLUTION;\n\t\t\t}\n\n\t\t\t// Theme display\n\n\t\t\tString protocol = Http.getProtocol(req) + \"://\";\n\n\t\t\tThemeDisplay themeDisplay = ThemeDisplayFactory.create();\n\n\t\t\tthemeDisplay.setCompany(company);\n\t\t\tthemeDisplay.setCompanyLogo(companyLogo);\n\t\t\tthemeDisplay.setUser(user);\n\t\t\tthemeDisplay.setLayout(layout);\n\t\t\tthemeDisplay.setLayouts(layouts);\n\t\t\tthemeDisplay.setPlid(plid);\n\t\t\tthemeDisplay.setLayoutTypePortlet(layoutTypePortlet);\n\t\t\tthemeDisplay.setPortletGroupId(portletGroupId);\n\t\t\tthemeDisplay.setSignedIn(signedIn);\n\t\t\tthemeDisplay.setPermissionChecker(permissionChecker);\n\t\t\tthemeDisplay.setLocale(locale);\n\t\t\tthemeDisplay.setTimeZone(timeZone);\n\t\t\tthemeDisplay.setLookAndFeel(contextPath, theme, colorScheme);\n\t\t\tthemeDisplay.setResolution(resolution);\n\t\t\tthemeDisplay.setStatePopUp(LiferayWindowState.isPopUp(req));\n\t\t\tthemeDisplay.setPathApplet(contextPath + \"/applets\");\n\t\t\tthemeDisplay.setPathCaptcha(captchaPath);\n\t\t\tthemeDisplay.setPathContext(contextPath);\n\t\t\tthemeDisplay.setPathFlash(contextPath + \"/flash\");\n\t\t\tthemeDisplay.setPathFriendlyURLPrivate(friendlyURLPrivatePath);\n\t\t\tthemeDisplay.setPathFriendlyURLPublic(friendlyURLPublicPath);\n\t\t\tthemeDisplay.setPathImage(imagePath);\n\t\t\tthemeDisplay.setPathJavaScript(contextPath + \"/html/js\");\n\t\t\tthemeDisplay.setPathMain(mainPath);\n\t\t\tthemeDisplay.setPathRoot(rootPath);\n\t\t\tthemeDisplay.setPathSound(contextPath + \"/html/sound\");\n\n\t\t\t// URLs\n\n\t\t\tthemeDisplay.setShowAddContentIcon(false);\n\t\t\tthemeDisplay.setShowHomeIcon(true);\n\t\t\tthemeDisplay.setShowMyAccountIcon(signedIn);\n\t\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\t\tthemeDisplay.setShowPortalIcon(true);\n\t\t\tthemeDisplay.setShowSignInIcon(!signedIn);\n\t\t\tthemeDisplay.setShowSignOutIcon(signedIn);\n\n\t\t\tthemeDisplay.setURLHome(protocol + company.getHomeURL());\n\n\t\t\tif (layout != null) {\n\t\t\t\tboolean hasManageLayoutsPermission = GroupPermission.contains(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpermissionChecker, portletGroupId,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tActionKeys.MANAGE_LAYOUTS);\n\t\t\t\tboolean hasUpdateLayoutPermission = LayoutPermission.contains(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpermissionChecker, layoutId, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\townerId, ActionKeys.UPDATE);\n\t\t\t\t\n\t\t\t\tif (hasManageLayoutsPermission || hasUpdateLayoutPermission) {\n\t\t\t\t\tthemeDisplay.setShowAddContentIcon(true);\n\n\t\t\t\t\tthemeDisplay.setURLAddContent(\n\t\t\t\t\t\t\t\"LayoutConfiguration.toggle('\" +\n\t\t\t\t\t\t\t\tPortletKeys.LAYOUT_CONFIGURATION + \"', '\" + plid +\n\t\t\t\t\t\t\t\t\t\"', '\" + mainPath + \"','\" +\n\t\t\t\t\t\t\t\t\t\tthemeDisplay.getPathThemeImage() + \"');\");\n\t\t\t\t}\n\n\t\t\t\tif (hasManageLayoutsPermission) {\n\t\t\t\t\tthemeDisplay.setShowPageSettingsIcon(true);\n\n\t\t\t\t\tPortletURL pageSettingsURL = new PortletURLImpl(\n\t\t\t\t\t\treq, PortletKeys.LAYOUT_MANAGEMENT, plid, false);\n\n\t\t\t\t\tpageSettingsURL.setWindowState(WindowState.MAXIMIZED);\n\t\t\t\t\tpageSettingsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\t\tpageSettingsURL.setParameter(\n\t\t\t\t\t\t\"struts_action\", \"/layout_management/edit_pages\");\n\n\t\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\t\tpageSettingsURL.setParameter(\"tabs2\", \"private\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tpageSettingsURL.setParameter(\"tabs2\", \"public\");\n\t\t\t\t\t}\n\n\t\t\t\t\tpageSettingsURL.setParameter(\"selPlid\", plid);\n\n\t\t\t\t\tthemeDisplay.setURLPageSettings(pageSettingsURL);\n\t\t\t\t}\n\n\t\t\t\tPortletURL myAccountURL = new PortletURLImpl(\n\t\t\t\t\treq, PortletKeys.MY_ACCOUNT, plid, false);\n\n\t\t\t\tmyAccountURL.setWindowState(WindowState.MAXIMIZED);\n\t\t\t\tmyAccountURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tmyAccountURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/my_account/edit_user\");\n\n\t\t\t\tthemeDisplay.setURLMyAccount(myAccountURL);\n\t\t\t}\n\n\t\t\tthemeDisplay.setURLPortal(protocol + company.getPortalURL());\n\t\t\tthemeDisplay.setURLSignIn(mainPath + \"/portal/login\");\n\t\t\tthemeDisplay.setURLSignOut(\n\t\t\t\tmainPath + \"/portal/logout?referer=\" + mainPath);\n\n\t\t\treq.setAttribute(WebKeys.THEME_DISPLAY, themeDisplay);\n\n\t\t\t// Fix state\n\n\t\t\tfixState(req, themeDisplay);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(StackTraceUtil.getStackTrace(e));\n\n\t\t\tthrow new ActionException(e);\n\t\t}\n\t}","id":65773,"modified_method":"public void run(HttpServletRequest req, HttpServletResponse res)\n\t\tthrows ActionException {\n\n\t\ttry {\n\t\t\tHttpSession ses = req.getSession();\n\n\t\t\t// Company\n\n\t\t\tCompany company = PortalUtil.getCompany(req);\n\n\t\t\tString companyId = company.getCompanyId();\n\n\t\t\t// Paths\n\n\t\t\tString contextPath = CompanyPropsUtil.get(\n\t\t\t\tcompanyId, PropsUtil.PORTAL_CTX);\n\n\t\t\tif (contextPath.equals(StringPool.SLASH)) {\n\t\t\t\tcontextPath = StringPool.BLANK;\n\t\t\t}\n\n\t\t\tString rootPath = (String)req.getAttribute(WebKeys.ROOT_PATH);\n\t\t\tString mainPath = (String)req.getAttribute(WebKeys.MAIN_PATH);\n\t\t\tString captchaPath = (String)req.getAttribute(WebKeys.CAPTCHA_PATH);\n\t\t\tString friendlyURLPrivatePath =\n\t\t\t\t(String)req.getAttribute(WebKeys.FRIENDLY_URL_PRIVATE_PATH);\n\t\t\tString friendlyURLPublicPath =\n\t\t\t\t(String)req.getAttribute(WebKeys.FRIENDLY_URL_PUBLIC_PATH);\n\t\t\tString imagePath = (String)req.getAttribute(WebKeys.IMAGE_PATH);\n\n\t\t\t// Company logo\n\n\t\t\tString companyLogo = StringPool.BLANK;\n\n\t\t\tif (true) {\n\n\t\t\t\t// For now, always set the company logo URL. This behavior may\n\t\t\t\t// change if it makes life easier for the theme designer. The\n\t\t\t\t// company logo URL would then be blank if the company has never\n\t\t\t\t// set a logo.\n\n\t\t\t\tcompanyLogo = imagePath + \"/company_logo?img_id=\" + companyId;\n\t\t\t}\n\n\t\t\t// User\n\n\t\t\tUser user = null;\n\n\t\t\ttry {\n\t\t\t\tuser = PortalUtil.getUser(req);\n\t\t\t}\n\t\t\tcatch (NoSuchUserException nsue) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Is the user signed in?\n\n\t\t\tboolean signedIn = false;\n\n\t\t\tif (user == null) {\n\t\t\t\tuser = company.getDefaultUser();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsignedIn = true;\n\t\t\t}\n\n\t\t\t// Permission checker\n\n\t\t\tPermissionChecker permissionChecker =\n\t\t\t\tPermissionCheckerFactory.create(user, signedIn);\n\n\t\t\tPermissionThreadLocal.setPermissionChecker(permissionChecker);\n\n\t\t\t// Locale\n\n\t\t\tLocale locale = (Locale)ses.getAttribute(Globals.LOCALE_KEY);\n\n\t\t\tif (locale == null) {\n\t\t\t\tif (signedIn) {\n\t\t\t\t\tlocale = user.getLocale();\n\t\t\t\t}\n\t\t\t\telse {\n\n\t\t\t\t\t// User previously set their preferred language\n\n\t\t\t\t\tString languageId = CookieUtil.get(\n\t\t\t\t\t\treq.getCookies(), CookieKeys.GUEST_LANGUAGE_ID);\n\n\t\t\t\t\tif (Validator.isNotNull(languageId)) {\n\t\t\t\t\t\tlocale = LocaleUtil.fromLanguageId(languageId);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get locale from the request\n\n\t\t\t\t\tif ((locale == null) &&\n\t\t\t\t\t\tGetterUtil.getBoolean(\n\t\t\t\t\t\t\tPropsUtil.get(PropsUtil.LOCALE_DEFAULT_REQUEST))) {\n\n\t\t\t\t\t\tlocale = req.getLocale();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get locale from the default user\n\n\t\t\t\t\tif (locale == null) {\n\t\t\t\t\t\tlocale = user.getLocale();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Validator.isNull(locale.getCountry())) {\n\n\t\t\t\t\t\t// Locales must contain the country code\n\n\t\t\t\t\t\tlocale = LanguageUtil.getLocale(locale.getLanguage());\n\t\t\t\t\t}\n\n\t\t\t\t\tList availableLocales = ListUtil.fromArray(\n\t\t\t\t\t\tLanguageUtil.getAvailableLocales());\n\n\t\t\t\t\tif (!availableLocales.contains(locale)) {\n\t\t\t\t\t\tlocale = user.getLocale();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tses.setAttribute(Globals.LOCALE_KEY, locale);\n\n\t\t\t\tLanguageUtil.updateCookie(res, locale);\n\t\t\t}\n\n\t\t\t// Cookie support\n\n\t\t\tCookieKeys.addSupportCookie(res);\n\n\t\t\t// Time zone\n\n\t\t\tTimeZone timeZone = user.getTimeZone();\n\n\t\t\tif (timeZone == null) {\n\t\t\t\ttimeZone = company.getTimeZone();\n\t\t\t}\n\n\t\t\t// Layouts\n\n\t\t\tif (signedIn) {\n\t\t\t\tboolean layoutsRequired = user.isLayoutsRequired();\n\n\t\t\t\tif (layoutsRequired) {\n\t\t\t\t\taddDefaultLayouts(user);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdeleteDefaultLayouts(user);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLayout layout = null;\n\t\t\tList layouts = null;\n\n\t\t\tString plid = ParamUtil.getString(req, \"p_l_id\");\n\n\t\t\tString layoutId = Layout.getLayoutId(plid);\n\t\t\tString ownerId = Layout.getOwnerId(plid);\n\n\t\t\tif ((layoutId != null) && (ownerId != null)) {\n\t\t\t\ttry {\n\t\t\t\t\tlayout = LayoutLocalServiceUtil.getLayout(\n\t\t\t\t\t\tlayoutId, ownerId);\n\n\t\t\t\t\tif (!isLayoutViewable(user, ownerId)) {\n\t\t\t\t\t\tlayout = null;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlayouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\t\t\t\t\townerId, Layout.DEFAULT_PARENT_LAYOUT_ID);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchLayoutException nsle) {\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (layout == null) {\n\t\t\t\tObject[] defaultLayout = getDefaultLayout(user, signedIn);\n\n\t\t\t\tlayout = (Layout)defaultLayout[0];\n\t\t\t\tlayouts = (List)defaultLayout[1];\n\t\t\t}\n\n\t\t\tlayouts = checkLayoutsPermissions(\n\t\t\t\tlayout, layouts, permissionChecker, req);\n\n\t\t\tif (layout != null) {\n\t\t\t\tplid = layout.getPlid();\n\n\t\t\t\tlayoutId = layout.getLayoutId();\n\t\t\t\townerId = layout.getOwnerId();\n\t\t\t}\n\n\t\t\tif ((layout != null) && layout.isShared()) {\n\n\t\t\t\t// Updates to shared layouts are not reflected until the next\n\t\t\t\t// time the user logs in because group layouts are cached in the\n\t\t\t\t// session\n\n\t\t\t\tlayout = (Layout)layout.clone();\n\t\t\t}\n\n\t\t\tLayoutTypePortlet layoutTypePortlet = null;\n\n\t\t\tif (layout != null) {\n\t\t\t\treq.setAttribute(WebKeys.LAYOUT, layout);\n\t\t\t\treq.setAttribute(WebKeys.LAYOUTS, layouts);\n\n\t\t\t\tlayoutTypePortlet = (LayoutTypePortlet)layout.getLayoutType();\n\t\t\t}\n\n\t\t\tString portletGroupId = PortalUtil.getPortletGroupId(plid);\n\n\t\t\t// Theme and color scheme\n\n\t\t\tTheme theme = null;\n\t\t\tColorScheme colorScheme = null;\n\n\t\t\tif (layout != null) {\n\t\t\t\ttheme = layout.getTheme();\n\t\t\t\tcolorScheme = layout.getColorScheme();\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttheme = ThemeLocalUtil.getTheme(\n\t\t\t\t\tcompanyId,\n\t\t\t\t\tCompanyPropsUtil.get(\n\t\t\t\t\t\tcompanyId, PropsUtil.DEFAULT_THEME_ID));\n\t\t\t\tcolorScheme = ThemeLocalUtil.getColorScheme(\n\t\t\t\t\tcompanyId, theme.getThemeId(),\n\t\t\t\t\tCompanyPropsUtil.get(\n\t\t\t\t\t\tcompanyId, PropsUtil.DEFAULT_COLOR_SCHEME_ID));\n\t\t\t}\n\n\t\t\treq.setAttribute(WebKeys.THEME, theme);\n\t\t\treq.setAttribute(WebKeys.COLOR_SCHEME, colorScheme);\n\n\t\t\t// Resolution\n\n\t\t\tint resolution = Resolution.FULL_RESOLUTION;\n\n\t\t\tString resolutionKey = user.getResolution();\n\n\t\t\tif (resolutionKey.equals(Resolution.S1024X768_KEY)) {\n\t\t\t\tresolution = Resolution.S1024X768_RESOLUTION;\n\t\t\t}\n\t\t\telse if (resolutionKey.equals(Resolution.S800X600_KEY)) {\n\t\t\t\tresolution = Resolution.S800X600_RESOLUTION;\n\t\t\t}\n\n\t\t\t// Theme display\n\n\t\t\tString protocol = Http.getProtocol(req) + \"://\";\n\n\t\t\tThemeDisplay themeDisplay = ThemeDisplayFactory.create();\n\n\t\t\tthemeDisplay.setCompany(company);\n\t\t\tthemeDisplay.setCompanyLogo(companyLogo);\n\t\t\tthemeDisplay.setUser(user);\n\t\t\tthemeDisplay.setLayout(layout);\n\t\t\tthemeDisplay.setLayouts(layouts);\n\t\t\tthemeDisplay.setPlid(plid);\n\t\t\tthemeDisplay.setLayoutTypePortlet(layoutTypePortlet);\n\t\t\tthemeDisplay.setPortletGroupId(portletGroupId);\n\t\t\tthemeDisplay.setSignedIn(signedIn);\n\t\t\tthemeDisplay.setPermissionChecker(permissionChecker);\n\t\t\tthemeDisplay.setLocale(locale);\n\t\t\tthemeDisplay.setTimeZone(timeZone);\n\t\t\tthemeDisplay.setLookAndFeel(contextPath, theme, colorScheme);\n\t\t\tthemeDisplay.setResolution(resolution);\n\t\t\tthemeDisplay.setStatePopUp(LiferayWindowState.isPopUp(req));\n\t\t\tthemeDisplay.setPathApplet(contextPath + \"/applets\");\n\t\t\tthemeDisplay.setPathCaptcha(captchaPath);\n\t\t\tthemeDisplay.setPathContext(contextPath);\n\t\t\tthemeDisplay.setPathFlash(contextPath + \"/flash\");\n\t\t\tthemeDisplay.setPathFriendlyURLPrivate(friendlyURLPrivatePath);\n\t\t\tthemeDisplay.setPathFriendlyURLPublic(friendlyURLPublicPath);\n\t\t\tthemeDisplay.setPathImage(imagePath);\n\t\t\tthemeDisplay.setPathJavaScript(contextPath + \"/html/js\");\n\t\t\tthemeDisplay.setPathMain(mainPath);\n\t\t\tthemeDisplay.setPathRoot(rootPath);\n\t\t\tthemeDisplay.setPathSound(contextPath + \"/html/sound\");\n\n\t\t\t// URLs\n\n\t\t\tthemeDisplay.setShowAddContentIcon(false);\n\t\t\tthemeDisplay.setShowHomeIcon(true);\n\t\t\tthemeDisplay.setShowMyAccountIcon(signedIn);\n\t\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\t\tthemeDisplay.setShowPortalIcon(true);\n\t\t\tthemeDisplay.setShowSignInIcon(!signedIn);\n\t\t\tthemeDisplay.setShowSignOutIcon(signedIn);\n\n\t\t\tthemeDisplay.setURLHome(protocol + company.getHomeURL());\n\n\t\t\tif (layout != null) {\n\t\t\t\tboolean hasManageLayoutsPermission =\n\t\t\t\t\tGroupPermission.contains(\n\t\t\t\t\t\tpermissionChecker, portletGroupId,\n\t\t\t\t\t\tActionKeys.MANAGE_LAYOUTS);\n\n\t\t\t\tboolean hasUpdateLayoutPermission =\n\t\t\t\t\tLayoutPermission.contains(\n\t\t\t\t\t\tpermissionChecker, layout, ActionKeys.UPDATE);\n\n\t\t\t\tif (hasManageLayoutsPermission || hasUpdateLayoutPermission) {\n\t\t\t\t\tthemeDisplay.setShowAddContentIcon(true);\n\n\t\t\t\t\tthemeDisplay.setURLAddContent(\n\t\t\t\t\t\t\"LayoutConfiguration.toggle('\" +\n\t\t\t\t\t\t\tPortletKeys.LAYOUT_CONFIGURATION + \"', '\" + plid +\n\t\t\t\t\t\t\t\t\"', '\" + mainPath + \"','\" +\n\t\t\t\t\t\t\t\t\tthemeDisplay.getPathThemeImage() + \"');\");\n\t\t\t\t}\n\n\t\t\t\tif (hasManageLayoutsPermission) {\n\t\t\t\t\tthemeDisplay.setShowPageSettingsIcon(true);\n\n\t\t\t\t\tPortletURL pageSettingsURL = new PortletURLImpl(\n\t\t\t\t\t\treq, PortletKeys.LAYOUT_MANAGEMENT, plid, false);\n\n\t\t\t\t\tpageSettingsURL.setWindowState(WindowState.MAXIMIZED);\n\t\t\t\t\tpageSettingsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\t\tpageSettingsURL.setParameter(\n\t\t\t\t\t\t\"struts_action\", \"/layout_management/edit_pages\");\n\n\t\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\t\tpageSettingsURL.setParameter(\"tabs2\", \"private\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tpageSettingsURL.setParameter(\"tabs2\", \"public\");\n\t\t\t\t\t}\n\n\t\t\t\t\tpageSettingsURL.setParameter(\"selPlid\", plid);\n\n\t\t\t\t\tthemeDisplay.setURLPageSettings(pageSettingsURL);\n\t\t\t\t}\n\n\t\t\t\tPortletURL myAccountURL = new PortletURLImpl(\n\t\t\t\t\treq, PortletKeys.MY_ACCOUNT, plid, false);\n\n\t\t\t\tmyAccountURL.setWindowState(WindowState.MAXIMIZED);\n\t\t\t\tmyAccountURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tmyAccountURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/my_account/edit_user\");\n\n\t\t\t\tthemeDisplay.setURLMyAccount(myAccountURL);\n\t\t\t}\n\n\t\t\tthemeDisplay.setURLPortal(protocol + company.getPortalURL());\n\t\t\tthemeDisplay.setURLSignIn(mainPath + \"/portal/login\");\n\t\t\tthemeDisplay.setURLSignOut(\n\t\t\t\tmainPath + \"/portal/logout?referer=\" + mainPath);\n\n\t\t\treq.setAttribute(WebKeys.THEME_DISPLAY, themeDisplay);\n\n\t\t\t// Fix state\n\n\t\t\tfixState(req, themeDisplay);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(StackTraceUtil.getStackTrace(e));\n\n\t\t\tthrow new ActionException(e);\n\t\t}\n\t}","commit_id":"1dec32d7713d587e6cf283d78c1c88486ac2a463","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void processBridge(XMLExtendedStreamReader reader, ModelNode address, List<ModelNode> updates) throws XMLStreamException {\n\n        requireSingleAttribute(reader, CommonAttributes.NAME);\n        String name = reader.getAttributeValue(0);\n\n        ModelNode bridgeAdd = org.jboss.as.controller.operations.common.Util.getEmptyOperation(ADD, address.clone().add(CommonAttributes.BRIDGE, name));\n\n        EnumSet<Element> required = EnumSet.of(Element.QUEUE_NAME);\n        Set<Element> seen = EnumSet.noneOf(Element.class);\n        while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            if (!seen.add(element)) {\n                throw ParseUtils.duplicateNamedElement(reader, element.getLocalName());\n            }\n            required.remove(element);\n            switch (element) {\n                case QUEUE_NAME:\n                case HA:\n                case TRANSFORMER_CLASS_NAME:\n                case USER:\n                case PASSWORD:\n                    handleElementText(reader, element, bridgeAdd);\n                    break;\n                case FILTER:  {\n                    String string = readStringAttributeElement(reader, CommonAttributes.STRING);\n                    FILTER.parseAndSetParameter(string, bridgeAdd, reader);\n                    break;\n                }\n                case CHECK_PERIOD:\n                case CONNECTION_TTL:\n                case MAX_RETRY_INTERVAL:\n                case MIN_LARGE_MESSAGE_SIZE:\n                case RETRY_INTERVAL:\n                case RETRY_INTERVAL_MULTIPLIER:\n                    // Use the \"default\" variant\n                    handleElementText(reader, element, \"default\", bridgeAdd);\n                    break;\n                case CONFIRMATION_WINDOW_SIZE:\n                case FORWARDING_ADDRESS:\n                case RECONNECT_ATTEMPTS:\n                case USE_DUPLICATE_DETECTION:\n                    handleElementText(reader, element, \"bridge\", bridgeAdd);\n                    break;\n                case STATIC_CONNECTORS:\n                    checkOtherElementIsNotAlreadyDefined(reader, seen, Element.STATIC_CONNECTORS, Element.DISCOVERY_GROUP_REF);\n                    processStaticConnectors(reader, bridgeAdd, false);\n                    break;\n                case DISCOVERY_GROUP_REF: {\n                    checkOtherElementIsNotAlreadyDefined(reader, seen, Element.DISCOVERY_GROUP_REF, Element.STATIC_CONNECTORS);\n                    final String groupRef = readStringAttributeElement(reader, BridgeDefinition.DISCOVERY_GROUP_NAME.getXmlName());\n                    BridgeDefinition.DISCOVERY_GROUP_NAME.parseAndSetParameter(groupRef, bridgeAdd, reader);\n                    break;\n                }\n                case FAILOVER_ON_SERVER_SHUTDOWN: {\n                    MessagingLogger.ROOT_LOGGER.deprecatedXMLElement(element.toString());\n                    skipElementText(reader);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n        }\n\n        checkOnlyOneOfElements(reader, seen, Element.STATIC_CONNECTORS, Element.DISCOVERY_GROUP_REF);\n\n        if(!required.isEmpty()) {\n            missingRequired(reader, required);\n        }\n\n        updates.add(bridgeAdd);\n    }","id":65774,"modified_method":"protected void processBridge(XMLExtendedStreamReader reader, ModelNode address, List<ModelNode> updates) throws XMLStreamException {\n\n        requireSingleAttribute(reader, CommonAttributes.NAME);\n        String name = reader.getAttributeValue(0);\n\n        ModelNode bridgeAdd = org.jboss.as.controller.operations.common.Util.getEmptyOperation(ADD, address.clone().add(CommonAttributes.BRIDGE, name));\n\n        EnumSet<Element> required = EnumSet.of(Element.QUEUE_NAME);\n        Set<Element> seen = EnumSet.noneOf(Element.class);\n        while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            if (!seen.add(element)) {\n                throw ParseUtils.duplicateNamedElement(reader, element.getLocalName());\n            }\n            required.remove(element);\n            switch (element) {\n                case QUEUE_NAME:\n                case HA:\n                case TRANSFORMER_CLASS_NAME:\n                case USER:\n                case PASSWORD:\n                    handleElementText(reader, element, bridgeAdd);\n                    break;\n                case FILTER:  {\n                    String string = readStringAttributeElement(reader, CommonAttributes.STRING);\n                    FILTER.parseAndSetParameter(string, bridgeAdd, reader);\n                    break;\n                }\n                case CHECK_PERIOD:\n                case CONNECTION_TTL:\n                case MAX_RETRY_INTERVAL:\n                case MIN_LARGE_MESSAGE_SIZE:\n                case RETRY_INTERVAL:\n                case RETRY_INTERVAL_MULTIPLIER:\n                    // Use the \"default\" variant\n                    handleElementText(reader, element, \"default\", bridgeAdd);\n                    break;\n                case CONFIRMATION_WINDOW_SIZE:\n                case FORWARDING_ADDRESS:\n                case RECONNECT_ATTEMPTS:\n                case USE_DUPLICATE_DETECTION:\n                    handleElementText(reader, element, \"bridge\", bridgeAdd);\n                    break;\n                case STATIC_CONNECTORS:\n                    checkOtherElementIsNotAlreadyDefined(reader, seen, Element.STATIC_CONNECTORS, Element.DISCOVERY_GROUP_REF);\n                    processStaticConnectors(reader, bridgeAdd, false);\n                    break;\n                case DISCOVERY_GROUP_REF: {\n                    checkOtherElementIsNotAlreadyDefined(reader, seen, Element.DISCOVERY_GROUP_REF, Element.STATIC_CONNECTORS);\n                    final String groupRef = readStringAttributeElement(reader, BridgeDefinition.DISCOVERY_GROUP_NAME.getXmlName());\n                    BridgeDefinition.DISCOVERY_GROUP_NAME.parseAndSetParameter(groupRef, bridgeAdd, reader);\n                    break;\n                }\n                case FAILOVER_ON_SERVER_SHUTDOWN: {\n                    MessagingLogger.ROOT_LOGGER.deprecatedXMLElement(element.toString());\n                    skipElementText(reader);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n        }\n\n        checkOnlyOneOfElements(reader, seen, Element.STATIC_CONNECTORS, Element.DISCOVERY_GROUP_REF);\n\n        if(!required.isEmpty()) {\n            throw missingRequired(reader, required);\n        }\n\n        updates.add(bridgeAdd);\n    }","commit_id":"254a559ceeafcb825fb68441df01e47ef4c0ee83","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void checkBroadcastGroupConstraints(XMLExtendedStreamReader reader, Set<Element> seen) throws XMLStreamException {\n        checkNotBothElements(reader, seen, Element.SOCKET_BINDING, Element.JGROUPS_STACK);\n        checkNotBothElements(reader, seen, Element.JGROUPS_STACK, Element.GROUP_ADDRESS);\n        checkNotBothElements(reader, seen, Element.GROUP_ADDRESS, Element.SOCKET_BINDING);\n    }","id":65775,"modified_method":"@Override\n    protected void checkBroadcastGroupConstraints(XMLExtendedStreamReader reader, Set<Element> seen) throws XMLStreamException {\n        checkNotBothElements(reader, seen, Element.SOCKET_BINDING, Element.JGROUPS_STACK);\n        checkNotBothElements(reader, seen, Element.JGROUPS_STACK, Element.GROUP_ADDRESS);\n        checkNotBothElements(reader, seen, Element.GROUP_ADDRESS, Element.SOCKET_BINDING);\n        if (seen.contains(Element.GROUP_ADDRESS) && !seen.contains(Element.GROUP_PORT)) {\n            throw missingRequired(reader, EnumSet.of(Element.GROUP_PORT));\n        }\n    }","commit_id":"254a559ceeafcb825fb68441df01e47ef4c0ee83","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void checkDiscoveryGroupConstraints(XMLExtendedStreamReader reader, Set<Element> seen) throws XMLStreamException {\n        checkNotBothElements(reader, seen, Element.SOCKET_BINDING, Element.JGROUPS_STACK);\n        checkNotBothElements(reader, seen, Element.JGROUPS_STACK, Element.GROUP_ADDRESS);\n        checkNotBothElements(reader, seen, Element.GROUP_ADDRESS, Element.SOCKET_BINDING);\n    }","id":65776,"modified_method":"@Override\n    protected void checkDiscoveryGroupConstraints(XMLExtendedStreamReader reader, Set<Element> seen) throws XMLStreamException {\n        checkNotBothElements(reader, seen, Element.SOCKET_BINDING, Element.JGROUPS_STACK);\n        checkNotBothElements(reader, seen, Element.JGROUPS_STACK, Element.GROUP_ADDRESS);\n        checkNotBothElements(reader, seen, Element.GROUP_ADDRESS, Element.SOCKET_BINDING);\n        if (seen.contains(Element.GROUP_ADDRESS) && !seen.contains(Element.GROUP_PORT)) {\n            throw missingRequired(reader, EnumSet.of(Element.GROUP_PORT));\n        }\n    }","commit_id":"254a559ceeafcb825fb68441df01e47ef4c0ee83","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void processJMSQueue(final XMLExtendedStreamReader reader, String hqServer, ParseResult result) throws XMLStreamException {\n\n        requireSingleAttribute(reader, CommonAttributes.NAME);\n        final String name = propertyReplacer.replaceProperties(reader.getAttributeValue(0));\n\n        if (name == null) {\n            ParseUtils.missingRequired(reader, Collections.singleton(\"name\"));\n        }\n\n        final ModelNode queue = new ModelNode();\n\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            switch (element) {\n                case ENTRY: {\n                    final String entry = propertyReplacer.replaceProperties(readStringAttributeElement(reader, CommonAttributes.NAME));\n                    CommonAttributes.DESTINATION_ENTRIES.parseAndAddParameterElement(entry, queue, reader);\n                    break;\n                }\n                case SELECTOR: {\n                    if (queue.has(SELECTOR.getName())) {\n                        throw ParseUtils.duplicateNamedElement(reader, Element.SELECTOR.getLocalName());\n                    }\n                    requireSingleAttribute(reader, CommonAttributes.STRING);\n                    final String selector = propertyReplacer.replaceProperties(readStringAttributeElement(reader, CommonAttributes.STRING));\n                    SELECTOR.parseAndSetParameter(selector, queue, reader);\n                    break;\n                }\n                case DURABLE: {\n                    if (queue.has(DURABLE.getName())) {\n                        throw ParseUtils.duplicateNamedElement(reader, Element.DURABLE.getLocalName());\n                    }\n                    DURABLE.parseAndSetParameter(propertyReplacer.replaceProperties(reader.getElementText()), queue, reader);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n        }\n        result.getQueues().add(new JmsDestination(queue, hqServer, name));\n    }","id":65777,"modified_method":"private void processJMSQueue(final XMLExtendedStreamReader reader, String hqServer, ParseResult result) throws XMLStreamException {\n\n        requireSingleAttribute(reader, CommonAttributes.NAME);\n        final String name = propertyReplacer.replaceProperties(reader.getAttributeValue(0));\n\n        if (name == null) {\n            throw ParseUtils.missingRequired(reader, Collections.singleton(\"name\"));\n        }\n\n        final ModelNode queue = new ModelNode();\n\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            switch (element) {\n                case ENTRY: {\n                    final String entry = propertyReplacer.replaceProperties(readStringAttributeElement(reader, CommonAttributes.NAME));\n                    CommonAttributes.DESTINATION_ENTRIES.parseAndAddParameterElement(entry, queue, reader);\n                    break;\n                }\n                case SELECTOR: {\n                    if (queue.has(SELECTOR.getName())) {\n                        throw ParseUtils.duplicateNamedElement(reader, Element.SELECTOR.getLocalName());\n                    }\n                    requireSingleAttribute(reader, CommonAttributes.STRING);\n                    final String selector = propertyReplacer.replaceProperties(readStringAttributeElement(reader, CommonAttributes.STRING));\n                    SELECTOR.parseAndSetParameter(selector, queue, reader);\n                    break;\n                }\n                case DURABLE: {\n                    if (queue.has(DURABLE.getName())) {\n                        throw ParseUtils.duplicateNamedElement(reader, Element.DURABLE.getLocalName());\n                    }\n                    DURABLE.parseAndSetParameter(propertyReplacer.replaceProperties(reader.getElementText()), queue, reader);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n        }\n        result.getQueues().add(new JmsDestination(queue, hqServer, name));\n    }","commit_id":"254a559ceeafcb825fb68441df01e47ef4c0ee83","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void processJMSTopic(final XMLExtendedStreamReader reader, String hqServer, ParseResult result) throws XMLStreamException {\n\n        final String name = propertyReplacer.replaceProperties(reader.getAttributeValue(0));\n        if (name == null) {\n            ParseUtils.missingRequired(reader, Collections.singleton(\"name\"));\n        }\n\n        final ModelNode topic = new ModelNode();\n\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            switch (element) {\n                case ENTRY: {\n                    final String entry = propertyReplacer.replaceProperties(readStringAttributeElement(reader, CommonAttributes.NAME));\n                    CommonAttributes.DESTINATION_ENTRIES.parseAndAddParameterElement(entry, topic, reader);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n        }\n        result.getTopics().add(new JmsDestination(topic, hqServer, name));\n    }","id":65778,"modified_method":"private void processJMSTopic(final XMLExtendedStreamReader reader, String hqServer, ParseResult result) throws XMLStreamException {\n\n        final String name = propertyReplacer.replaceProperties(reader.getAttributeValue(0));\n        if (name == null) {\n            throw ParseUtils.missingRequired(reader, Collections.singleton(\"name\"));\n        }\n\n        final ModelNode topic = new ModelNode();\n\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            switch (element) {\n                case ENTRY: {\n                    final String entry = propertyReplacer.replaceProperties(readStringAttributeElement(reader, CommonAttributes.NAME));\n                    CommonAttributes.DESTINATION_ENTRIES.parseAndAddParameterElement(entry, topic, reader);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n        }\n        result.getTopics().add(new JmsDestination(topic, hqServer, name));\n    }","commit_id":"254a559ceeafcb825fb68441df01e47ef4c0ee83","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void checkBroadcastGroupConstraints(XMLExtendedStreamReader reader, Set<Element> seen) throws XMLStreamException {\n    }","id":65779,"modified_method":"protected void checkBroadcastGroupConstraints(XMLExtendedStreamReader reader, Set<Element> seen) throws XMLStreamException {\n        checkOnlyOneOfElements(reader, seen, Element.GROUP_ADDRESS, Element.SOCKET_BINDING);\n        if (seen.contains(Element.GROUP_ADDRESS) && !seen.contains(Element.GROUP_PORT)) {\n            throw missingRequired(reader, EnumSet.of(Element.GROUP_PORT));\n        }\n    }","commit_id":"254a559ceeafcb825fb68441df01e47ef4c0ee83","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void processConnectorService(XMLExtendedStreamReader reader, ModelNode address, List<ModelNode> updates) throws XMLStreamException {\n\n        requireSingleAttribute(reader, CommonAttributes.NAME);\n        String name = reader.getAttributeValue(0);\n\n        final ModelNode serviceAddress = address.clone().add(CommonAttributes.CONNECTOR_SERVICE, name);\n        final ModelNode add = org.jboss.as.controller.operations.common.Util.getEmptyOperation(ADD, serviceAddress);\n        updates.add(add);\n\n        EnumSet<Element> required = EnumSet.of(Element.FACTORY_CLASS);\n        Set<Element> seen = EnumSet.noneOf(Element.class);\n        while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            if (!seen.add(element) && element != Element.PARAM) {\n                throw ParseUtils.duplicateNamedElement(reader, element.getLocalName());\n            }\n            required.remove(element);\n            switch (element) {\n                case FACTORY_CLASS: {\n                    handleElementText(reader, element, add);\n                    break;\n                }\n                case PARAM: {\n                    String[] attrs = ParseUtils.requireAttributes(reader, Attribute.KEY.getLocalName(), Attribute.VALUE.getLocalName());\n                    final String key = attrs[0];\n                    final String value = attrs[1];\n                    final ModelNode paramAdd = org.jboss.as.controller.operations.common.Util.getEmptyOperation(ADD, serviceAddress.clone().add(CommonAttributes.PARAM, key));\n                    ConnectorServiceParamDefinition.VALUE.parseAndSetParameter(value, paramAdd, reader);\n                    updates.add(paramAdd);\n                    requireNoContent(reader);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n        }\n\n\n        if(!required.isEmpty()) {\n            missingRequired(reader, required);\n        }\n\n    }","id":65780,"modified_method":"private static void processConnectorService(XMLExtendedStreamReader reader, ModelNode address, List<ModelNode> updates) throws XMLStreamException {\n\n        requireSingleAttribute(reader, CommonAttributes.NAME);\n        String name = reader.getAttributeValue(0);\n\n        final ModelNode serviceAddress = address.clone().add(CommonAttributes.CONNECTOR_SERVICE, name);\n        final ModelNode add = org.jboss.as.controller.operations.common.Util.getEmptyOperation(ADD, serviceAddress);\n        updates.add(add);\n\n        EnumSet<Element> required = EnumSet.of(Element.FACTORY_CLASS);\n        Set<Element> seen = EnumSet.noneOf(Element.class);\n        while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            if (!seen.add(element) && element != Element.PARAM) {\n                throw ParseUtils.duplicateNamedElement(reader, element.getLocalName());\n            }\n            required.remove(element);\n            switch (element) {\n                case FACTORY_CLASS: {\n                    handleElementText(reader, element, add);\n                    break;\n                }\n                case PARAM: {\n                    String[] attrs = ParseUtils.requireAttributes(reader, Attribute.KEY.getLocalName(), Attribute.VALUE.getLocalName());\n                    final String key = attrs[0];\n                    final String value = attrs[1];\n                    final ModelNode paramAdd = org.jboss.as.controller.operations.common.Util.getEmptyOperation(ADD, serviceAddress.clone().add(CommonAttributes.PARAM, key));\n                    ConnectorServiceParamDefinition.VALUE.parseAndSetParameter(value, paramAdd, reader);\n                    updates.add(paramAdd);\n                    requireNoContent(reader);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n        }\n\n\n        if(!required.isEmpty()) {\n            throw missingRequired(reader, required);\n        }\n\n    }","commit_id":"254a559ceeafcb825fb68441df01e47ef4c0ee83","url":"https://github.com/wildfly/wildfly"},{"original_method":"static void processConnectors(final XMLExtendedStreamReader reader, final ModelNode address, final List<ModelNode> updates) throws XMLStreamException {\n        while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            String name = null;\n            String socketBinding = null;\n            int serverId = 0;\n\n            int count = reader.getAttributeCount();\n            for (int i = 0; i < count; i++) {\n                final String attrValue = reader.getAttributeValue(i);\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case NAME: {\n                        name = attrValue;\n                        break;\n                    }\n                    case SOCKET_BINDING: {\n                        socketBinding = attrValue;\n                        break;\n                    }\n                    case SERVER_ID: {\n                        serverId = Integer.valueOf(attrValue);\n                        break;\n                    }\n                    default: {\n                        throw ParseUtils.unexpectedAttribute(reader, i);\n                    }\n                }\n            }\n            if(name == null) {\n                ParseUtils.missingRequired(reader, Collections.singleton(Attribute.NAME));\n            }\n\n            final ModelNode connectorAddress = address.clone();\n            final ModelNode operation = new ModelNode();\n            operation.get(OP).set(ADD);\n\n            final Element element = Element.forName(reader.getLocalName());\n            switch (element) {\n                case CONNECTOR: {\n                    connectorAddress.add(CONNECTOR, name);\n                    if(socketBinding != null) operation.get(RemoteTransportDefinition.SOCKET_BINDING.getName()).set(socketBinding);\n                    parseTransportConfiguration(reader, operation, true);\n                    break;\n                } case NETTY_CONNECTOR: {\n                    connectorAddress.add(REMOTE_CONNECTOR, name);\n                    if(socketBinding == null) {\n                        ParseUtils.missingRequired(reader, Collections.singleton(Attribute.SOCKET_BINDING));\n                    }\n                    operation.get(RemoteTransportDefinition.SOCKET_BINDING.getName()).set(socketBinding);\n                    parseTransportConfiguration(reader, operation, false);\n                    break;\n                } case IN_VM_CONNECTOR: {\n                    connectorAddress.add(IN_VM_CONNECTOR, name);\n                    operation.get(InVMTransportDefinition.SERVER_ID.getName()).set(serverId);\n                    parseTransportConfiguration(reader, operation, false);\n                    break;\n                } default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n\n            operation.get(OP_ADDR).set(connectorAddress);\n            updates.add(operation);\n        }\n    }","id":65781,"modified_method":"static void processConnectors(final XMLExtendedStreamReader reader, final ModelNode address, final List<ModelNode> updates) throws XMLStreamException {\n        while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            String name = null;\n            String socketBinding = null;\n            int serverId = 0;\n\n            int count = reader.getAttributeCount();\n            for (int i = 0; i < count; i++) {\n                final String attrValue = reader.getAttributeValue(i);\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case NAME: {\n                        name = attrValue;\n                        break;\n                    }\n                    case SOCKET_BINDING: {\n                        socketBinding = attrValue;\n                        break;\n                    }\n                    case SERVER_ID: {\n                        serverId = Integer.valueOf(attrValue);\n                        break;\n                    }\n                    default: {\n                        throw ParseUtils.unexpectedAttribute(reader, i);\n                    }\n                }\n            }\n            if(name == null) {\n                throw missingRequired(reader, Collections.singleton(Attribute.NAME));\n            }\n\n            final ModelNode connectorAddress = address.clone();\n            final ModelNode operation = new ModelNode();\n            operation.get(OP).set(ADD);\n\n            final Element element = Element.forName(reader.getLocalName());\n            switch (element) {\n                case CONNECTOR: {\n                    connectorAddress.add(CONNECTOR, name);\n                    if(socketBinding != null) operation.get(RemoteTransportDefinition.SOCKET_BINDING.getName()).set(socketBinding);\n                    parseTransportConfiguration(reader, operation, true);\n                    break;\n                } case NETTY_CONNECTOR: {\n                    connectorAddress.add(REMOTE_CONNECTOR, name);\n                    if(socketBinding == null) {\n                        throw missingRequired(reader, Collections.singleton(Attribute.SOCKET_BINDING));\n                    }\n                    operation.get(RemoteTransportDefinition.SOCKET_BINDING.getName()).set(socketBinding);\n                    parseTransportConfiguration(reader, operation, false);\n                    break;\n                } case IN_VM_CONNECTOR: {\n                    connectorAddress.add(IN_VM_CONNECTOR, name);\n                    operation.get(InVMTransportDefinition.SERVER_ID.getName()).set(serverId);\n                    parseTransportConfiguration(reader, operation, false);\n                    break;\n                } default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n\n            operation.get(OP_ADDR).set(connectorAddress);\n            updates.add(operation);\n        }\n    }","commit_id":"254a559ceeafcb825fb68441df01e47ef4c0ee83","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void parseDivert(final XMLExtendedStreamReader reader, final ModelNode address, final List<ModelNode> list) throws XMLStreamException {\n\n        requireSingleAttribute(reader, CommonAttributes.NAME);\n        String name = reader.getAttributeValue(0);\n\n        ModelNode divertAdd = org.jboss.as.controller.operations.common.Util.getEmptyOperation(ADD, address.clone().add(CommonAttributes.DIVERT, name));\n\n        EnumSet<Element> required = EnumSet.of(Element.ADDRESS, Element.FORWARDING_ADDRESS);\n        while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            required.remove(element);\n            switch (element) {\n                case ROUTING_NAME: {\n                    handleElementText(reader, element, divertAdd);\n                    break;\n                }\n                case ADDRESS: {\n                    handleElementText(reader, element, DivertDefinition.ADDRESS.getName(), divertAdd);\n                    break;\n                }\n                case FORWARDING_ADDRESS: {\n                    handleElementText(reader, element, \"divert\", divertAdd);\n                    break;\n                }\n                case FILTER: {\n                    String string = readStringAttributeElement(reader, CommonAttributes.STRING);\n                    FILTER.parseAndSetParameter(string, divertAdd, reader);\n                    break;\n                }\n                case TRANSFORMER_CLASS_NAME: {\n                    handleElementText(reader, element, divertAdd);\n                    break;\n                }\n                case EXCLUSIVE: {\n                    handleElementText(reader, element, divertAdd);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n        }\n\n        if(!required.isEmpty()) {\n            missingRequired(reader, required);\n        }\n\n        list.add(divertAdd);\n    }","id":65782,"modified_method":"private static void parseDivert(final XMLExtendedStreamReader reader, final ModelNode address, final List<ModelNode> list) throws XMLStreamException {\n\n        requireSingleAttribute(reader, CommonAttributes.NAME);\n        String name = reader.getAttributeValue(0);\n\n        ModelNode divertAdd = org.jboss.as.controller.operations.common.Util.getEmptyOperation(ADD, address.clone().add(CommonAttributes.DIVERT, name));\n\n        EnumSet<Element> required = EnumSet.of(Element.ADDRESS, Element.FORWARDING_ADDRESS);\n        while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            required.remove(element);\n            switch (element) {\n                case ROUTING_NAME: {\n                    handleElementText(reader, element, divertAdd);\n                    break;\n                }\n                case ADDRESS: {\n                    handleElementText(reader, element, DivertDefinition.ADDRESS.getName(), divertAdd);\n                    break;\n                }\n                case FORWARDING_ADDRESS: {\n                    handleElementText(reader, element, \"divert\", divertAdd);\n                    break;\n                }\n                case FILTER: {\n                    String string = readStringAttributeElement(reader, CommonAttributes.STRING);\n                    FILTER.parseAndSetParameter(string, divertAdd, reader);\n                    break;\n                }\n                case TRANSFORMER_CLASS_NAME: {\n                    handleElementText(reader, element, divertAdd);\n                    break;\n                }\n                case EXCLUSIVE: {\n                    handleElementText(reader, element, divertAdd);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n        }\n\n        if(!required.isEmpty()) {\n            throw missingRequired(reader, required);\n        }\n\n        list.add(divertAdd);\n    }","commit_id":"254a559ceeafcb825fb68441df01e47ef4c0ee83","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void processStaticConnectors(XMLExtendedStreamReader reader, ModelNode addOperation, boolean cluster) throws XMLStreamException {\n\n        if (cluster) {\n\n            int count = reader.getAttributeCount();\n            for (int i = 0; i < count; i++) {\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case ALLOW_DIRECT_CONNECTIONS_ONLY: {\n                        final String attrValue = reader.getAttributeValue(i);\n                        ClusterConnectionDefinition.ALLOW_DIRECT_CONNECTIONS_ONLY.parseAndSetParameter(attrValue, addOperation, reader);\n                        break;\n                    }\n                    default: {\n                        throw ParseUtils.unexpectedAttribute(reader, i);\n                    }\n                }\n            }\n\n        } else {\n            requireNoAttributes(reader);\n        }\n\n        EnumSet<Element> required = EnumSet.of(Element.CONNECTOR_REF);\n        while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            required.remove(element);\n            switch (element) {\n                case CONNECTOR_REF: {\n                    handleElementText(reader, element, cluster ? \"cluster-connection\" : \"bridge\", addOperation);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n        }\n\n        if(!required.isEmpty()) {\n            missingRequired(reader, required);\n        }\n    }","id":65783,"modified_method":"protected void processStaticConnectors(XMLExtendedStreamReader reader, ModelNode addOperation, boolean cluster) throws XMLStreamException {\n\n        if (cluster) {\n\n            int count = reader.getAttributeCount();\n            for (int i = 0; i < count; i++) {\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case ALLOW_DIRECT_CONNECTIONS_ONLY: {\n                        final String attrValue = reader.getAttributeValue(i);\n                        ClusterConnectionDefinition.ALLOW_DIRECT_CONNECTIONS_ONLY.parseAndSetParameter(attrValue, addOperation, reader);\n                        break;\n                    }\n                    default: {\n                        throw ParseUtils.unexpectedAttribute(reader, i);\n                    }\n                }\n            }\n\n        } else {\n            requireNoAttributes(reader);\n        }\n\n        EnumSet<Element> required = EnumSet.of(Element.CONNECTOR_REF);\n        while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            required.remove(element);\n            switch (element) {\n                case CONNECTOR_REF: {\n                    handleElementText(reader, element, cluster ? \"cluster-connection\" : \"bridge\", addOperation);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n        }\n\n        if(!required.isEmpty()) {\n            throw missingRequired(reader, required);\n        }\n    }","commit_id":"254a559ceeafcb825fb68441df01e47ef4c0ee83","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void parseDiscoveryGroup(XMLExtendedStreamReader reader, ModelNode address, List<ModelNode> updates) throws XMLStreamException {\n\n        String name = null;\n\n        int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i++) {\n            final String attrValue = reader.getAttributeValue(i);\n            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case NAME: {\n                    name = attrValue;\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedAttribute(reader, i);\n                }\n            }\n        }\n        if(name == null) {\n            ParseUtils.missingRequired(reader, Collections.singleton(Attribute.NAME));\n        }\n\n        ModelNode discoveryGroup = org.jboss.as.controller.operations.common.Util.getEmptyOperation(ADD, address.clone().add(CommonAttributes.DISCOVERY_GROUP, name));\n\n        EnumSet<Element> required = EnumSet.of(Element.GROUP_ADDRESS, Element.GROUP_PORT);\n        Set<Element> seen = EnumSet.noneOf(Element.class);\n        while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            required.remove(element);\n            seen.add(element);\n            switch (element) {\n                case LOCAL_BIND_ADDRESS:\n                case GROUP_ADDRESS:\n                case GROUP_PORT:\n                case REFRESH_TIMEOUT:\n                case SOCKET_BINDING:\n                case INITIAL_WAIT_TIMEOUT:\n                    handleElementText(reader, element, discoveryGroup);\n                    break;\n                default: {\n                    handleUnknownDiscoveryGroupAttribute(reader, element, discoveryGroup);\n                }\n            }\n        }\n\n        if(!required.isEmpty()) {\n            missingRequired(reader, required);\n        }\n\n        checkDiscoveryGroupConstraints(reader, seen);\n\n        updates.add(discoveryGroup);\n    }","id":65784,"modified_method":"protected void parseDiscoveryGroup(XMLExtendedStreamReader reader, ModelNode address, List<ModelNode> updates) throws XMLStreamException {\n\n        String name = null;\n\n        int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i++) {\n            final String attrValue = reader.getAttributeValue(i);\n            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case NAME: {\n                    name = attrValue;\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedAttribute(reader, i);\n                }\n            }\n        }\n        if(name == null) {\n            throw  missingRequired(reader, Collections.singleton(Attribute.NAME));\n        }\n\n        ModelNode discoveryGroup = org.jboss.as.controller.operations.common.Util.getEmptyOperation(ADD, address.clone().add(CommonAttributes.DISCOVERY_GROUP, name));\n\n        Set<Element> seen = EnumSet.noneOf(Element.class);\n        while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            seen.add(element);\n            switch (element) {\n                case LOCAL_BIND_ADDRESS:\n                case GROUP_ADDRESS:\n                case GROUP_PORT:\n                case REFRESH_TIMEOUT:\n                case SOCKET_BINDING:\n                case INITIAL_WAIT_TIMEOUT:\n                    handleElementText(reader, element, discoveryGroup);\n                    break;\n                default: {\n                    handleUnknownDiscoveryGroupAttribute(reader, element, discoveryGroup);\n                }\n            }\n        }\n\n        checkDiscoveryGroupConstraints(reader, seen);\n\n        updates.add(discoveryGroup);\n    }","commit_id":"254a559ceeafcb825fb68441df01e47ef4c0ee83","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void parseBroadcastGroup(XMLExtendedStreamReader reader, ModelNode address, List<ModelNode> updates) throws XMLStreamException {\n\n        String name = null;\n\n        int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i++) {\n            final String attrValue = reader.getAttributeValue(i);\n            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case NAME: {\n                    name = attrValue;\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedAttribute(reader, i);\n                }\n            }\n        }\n        if(name == null) {\n            ParseUtils.missingRequired(reader, Collections.singleton(Attribute.NAME));\n        }\n\n        ModelNode broadcastGroupAdd = org.jboss.as.controller.operations.common.Util.getEmptyOperation(ADD, address.clone().add(CommonAttributes.BROADCAST_GROUP, name));\n\n        EnumSet<Element> required = EnumSet.of(Element.GROUP_ADDRESS, Element.GROUP_PORT);\n        Set<Element> seen = EnumSet.noneOf(Element.class);\n        while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            seen.add(element);\n            required.remove(element);\n            switch (element) {\n                case LOCAL_BIND_ADDRESS:\n                case LOCAL_BIND_PORT:\n                case GROUP_ADDRESS:\n                case GROUP_PORT:\n                case SOCKET_BINDING:\n                case BROADCAST_PERIOD:\n                    handleElementText(reader, element, broadcastGroupAdd);\n                    break;\n                case CONNECTOR_REF:\n                    handleElementText(reader, element, \"broadcast-group\", broadcastGroupAdd);\n                    break;\n                default: {\n                    handleUnknownBroadcastGroupAttribute(reader, element, broadcastGroupAdd);\n                }\n            }\n        }\n\n        if(!required.isEmpty()) {\n            missingRequired(reader, required);\n        }\n\n        checkBroadcastGroupConstraints(reader, seen);\n\n        updates.add(broadcastGroupAdd);\n    }","id":65785,"modified_method":"protected void parseBroadcastGroup(XMLExtendedStreamReader reader, ModelNode address, List<ModelNode> updates) throws XMLStreamException {\n\n        String name = null;\n\n        int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i++) {\n            final String attrValue = reader.getAttributeValue(i);\n            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case NAME: {\n                    name = attrValue;\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedAttribute(reader, i);\n                }\n            }\n        }\n        if(name == null) {\n            throw missingRequired(reader, Collections.singleton(Attribute.NAME));\n        }\n\n        ModelNode broadcastGroupAdd = org.jboss.as.controller.operations.common.Util.getEmptyOperation(ADD, address.clone().add(CommonAttributes.BROADCAST_GROUP, name));\n\n        Set<Element> seen = EnumSet.noneOf(Element.class);\n        while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            seen.add(element);\n            switch (element) {\n                case LOCAL_BIND_ADDRESS:\n                case LOCAL_BIND_PORT:\n                case GROUP_ADDRESS:\n                case GROUP_PORT:\n                case SOCKET_BINDING:\n                case BROADCAST_PERIOD:\n                    handleElementText(reader, element, broadcastGroupAdd);\n                    break;\n                case CONNECTOR_REF:\n                    handleElementText(reader, element, \"broadcast-group\", broadcastGroupAdd);\n                    break;\n                default: {\n                    handleUnknownBroadcastGroupAttribute(reader, element, broadcastGroupAdd);\n                }\n            }\n        }\n\n        checkBroadcastGroupConstraints(reader, seen);\n\n        updates.add(broadcastGroupAdd);\n    }","commit_id":"254a559ceeafcb825fb68441df01e47ef4c0ee83","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void processGroupingHandler(XMLExtendedStreamReader reader, ModelNode address, List<ModelNode> updates) throws XMLStreamException {\n\n        requireSingleAttribute(reader, CommonAttributes.NAME);\n        String name = reader.getAttributeValue(0);\n\n        ModelNode groupingHandlerAdd = org.jboss.as.controller.operations.common.Util.getEmptyOperation(ADD, address.clone().add(CommonAttributes.GROUPING_HANDLER, name));\n\n        EnumSet<Element> required = EnumSet.of(Element.ADDRESS, Element.TYPE);\n        while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            required.remove(element);\n            switch (element) {\n                case TYPE:\n                case TIMEOUT: {\n                    handleElementText(reader, element, groupingHandlerAdd);\n                    break;\n                }\n                case ADDRESS: {\n                    handleElementText(reader, element, GroupingHandlerDefinition.GROUPING_HANDLER_ADDRESS.getName(), groupingHandlerAdd);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n        }\n\n        if(!required.isEmpty()) {\n            missingRequired(reader, required);\n        }\n\n        updates.add(groupingHandlerAdd);\n    }","id":65786,"modified_method":"private void processGroupingHandler(XMLExtendedStreamReader reader, ModelNode address, List<ModelNode> updates) throws XMLStreamException {\n\n        requireSingleAttribute(reader, CommonAttributes.NAME);\n        String name = reader.getAttributeValue(0);\n\n        ModelNode groupingHandlerAdd = org.jboss.as.controller.operations.common.Util.getEmptyOperation(ADD, address.clone().add(CommonAttributes.GROUPING_HANDLER, name));\n\n        EnumSet<Element> required = EnumSet.of(Element.ADDRESS, Element.TYPE);\n        while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            required.remove(element);\n            switch (element) {\n                case TYPE:\n                case TIMEOUT: {\n                    handleElementText(reader, element, groupingHandlerAdd);\n                    break;\n                }\n                case ADDRESS: {\n                    handleElementText(reader, element, GroupingHandlerDefinition.GROUPING_HANDLER_ADDRESS.getName(), groupingHandlerAdd);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n        }\n\n        if(!required.isEmpty()) {\n            throw missingRequired(reader, required);\n        }\n\n        updates.add(groupingHandlerAdd);\n    }","commit_id":"254a559ceeafcb825fb68441df01e47ef4c0ee83","url":"https://github.com/wildfly/wildfly"},{"original_method":"static void processJMSTopic(final XMLExtendedStreamReader reader, ModelNode address, List<ModelNode> updates) throws XMLStreamException {\n\n        final String name = reader.getAttributeValue(0);\n        if(name == null) {\n            ParseUtils.missingRequired(reader, Collections.singleton(\"name\"));\n        }\n\n        final ModelNode topic = new ModelNode();\n        topic.get(OP).set(ADD);\n        topic.get(OP_ADDR).set(address).add(JMS_TOPIC, name);\n\n        while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            switch(element) {\n                case ENTRY: {\n                    final String entry = readStringAttributeElement(reader, CommonAttributes.NAME);\n                    CommonAttributes.DESTINATION_ENTRIES.parseAndAddParameterElement(entry, topic, reader);\n                    break;\n                } default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n        }\n        updates.add(topic);\n    }","id":65787,"modified_method":"static void processJMSTopic(final XMLExtendedStreamReader reader, ModelNode address, List<ModelNode> updates) throws XMLStreamException {\n\n        final String name = reader.getAttributeValue(0);\n        if(name == null) {\n            throw missingRequired(reader, Collections.singleton(\"name\"));\n        }\n\n        final ModelNode topic = new ModelNode();\n        topic.get(OP).set(ADD);\n        topic.get(OP_ADDR).set(address).add(JMS_TOPIC, name);\n\n        while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            switch(element) {\n                case ENTRY: {\n                    final String entry = readStringAttributeElement(reader, CommonAttributes.NAME);\n                    CommonAttributes.DESTINATION_ENTRIES.parseAndAddParameterElement(entry, topic, reader);\n                    break;\n                } default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n        }\n        updates.add(topic);\n    }","commit_id":"254a559ceeafcb825fb68441df01e47ef4c0ee83","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void processBridge(XMLExtendedStreamReader reader, ModelNode address, List<ModelNode> updates) throws XMLStreamException {\n\n        requireSingleAttribute(reader, CommonAttributes.NAME);\n        String name = reader.getAttributeValue(0);\n\n        ModelNode bridgeAdd = org.jboss.as.controller.operations.common.Util.getEmptyOperation(ADD, address.clone().add(CommonAttributes.BRIDGE, name));\n\n        EnumSet<Element> required = EnumSet.of(Element.QUEUE_NAME);\n        Set<Element> seen = EnumSet.noneOf(Element.class);\n        while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            if (!seen.add(element)) {\n                throw ParseUtils.duplicateNamedElement(reader, element.getLocalName());\n            }\n            required.remove(element);\n            switch (element) {\n                case QUEUE_NAME:\n                case HA:\n                case TRANSFORMER_CLASS_NAME:\n                case USER:\n                case PASSWORD:\n                    handleElementText(reader, element, bridgeAdd);\n                    break;\n                case CONFIRMATION_WINDOW_SIZE:\n                    handleElementText(reader, element, \"bridge\", bridgeAdd);\n                    break;\n                case FILTER:  {\n                    String string = readStringAttributeElement(reader, CommonAttributes.STRING);\n                    FILTER.parseAndSetParameter(string, bridgeAdd, reader);\n                    break;\n                }\n                case RETRY_INTERVAL_MULTIPLIER:\n                case RETRY_INTERVAL:\n                    // Use the \"default\" variant\n                    handleElementText(reader, element, DEFAULT, bridgeAdd);\n                    break;\n                case FORWARDING_ADDRESS:\n                case RECONNECT_ATTEMPTS:\n                case USE_DUPLICATE_DETECTION:\n                    handleElementText(reader, element, \"bridge\", bridgeAdd);\n                    break;\n                case STATIC_CONNECTORS:\n                    checkOtherElementIsNotAlreadyDefined(reader, seen, Element.STATIC_CONNECTORS, Element.DISCOVERY_GROUP_REF);\n                    processStaticConnectors(reader, bridgeAdd, false);\n                    break;\n                case DISCOVERY_GROUP_REF: {\n                    checkOtherElementIsNotAlreadyDefined(reader, seen, Element.DISCOVERY_GROUP_REF, Element.STATIC_CONNECTORS);\n                    final String groupRef = readStringAttributeElement(reader, BridgeDefinition.DISCOVERY_GROUP_NAME.getXmlName());\n                    BridgeDefinition.DISCOVERY_GROUP_NAME.parseAndSetParameter(groupRef, bridgeAdd, reader);\n                    break;\n                }\n                case FAILOVER_ON_SERVER_SHUTDOWN: {\n                    MessagingLogger.ROOT_LOGGER.deprecatedXMLElement(element.toString());\n                    skipElementText(reader);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n        }\n\n        checkOnlyOneOfElements(reader, seen, Element.STATIC_CONNECTORS, Element.DISCOVERY_GROUP_REF);\n\n        if(!required.isEmpty()) {\n            missingRequired(reader, required);\n        }\n\n        updates.add(bridgeAdd);\n    }","id":65788,"modified_method":"protected void processBridge(XMLExtendedStreamReader reader, ModelNode address, List<ModelNode> updates) throws XMLStreamException {\n\n        requireSingleAttribute(reader, CommonAttributes.NAME);\n        String name = reader.getAttributeValue(0);\n\n        ModelNode bridgeAdd = org.jboss.as.controller.operations.common.Util.getEmptyOperation(ADD, address.clone().add(CommonAttributes.BRIDGE, name));\n\n        EnumSet<Element> required = EnumSet.of(Element.QUEUE_NAME);\n        Set<Element> seen = EnumSet.noneOf(Element.class);\n        while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            if (!seen.add(element)) {\n                throw ParseUtils.duplicateNamedElement(reader, element.getLocalName());\n            }\n            required.remove(element);\n            switch (element) {\n                case QUEUE_NAME:\n                case HA:\n                case TRANSFORMER_CLASS_NAME:\n                case USER:\n                case PASSWORD:\n                    handleElementText(reader, element, bridgeAdd);\n                    break;\n                case CONFIRMATION_WINDOW_SIZE:\n                    handleElementText(reader, element, \"bridge\", bridgeAdd);\n                    break;\n                case FILTER:  {\n                    String string = readStringAttributeElement(reader, CommonAttributes.STRING);\n                    FILTER.parseAndSetParameter(string, bridgeAdd, reader);\n                    break;\n                }\n                case RETRY_INTERVAL_MULTIPLIER:\n                case RETRY_INTERVAL:\n                    // Use the \"default\" variant\n                    handleElementText(reader, element, DEFAULT, bridgeAdd);\n                    break;\n                case FORWARDING_ADDRESS:\n                case RECONNECT_ATTEMPTS:\n                case USE_DUPLICATE_DETECTION:\n                    handleElementText(reader, element, \"bridge\", bridgeAdd);\n                    break;\n                case STATIC_CONNECTORS:\n                    checkOtherElementIsNotAlreadyDefined(reader, seen, Element.STATIC_CONNECTORS, Element.DISCOVERY_GROUP_REF);\n                    processStaticConnectors(reader, bridgeAdd, false);\n                    break;\n                case DISCOVERY_GROUP_REF: {\n                    checkOtherElementIsNotAlreadyDefined(reader, seen, Element.DISCOVERY_GROUP_REF, Element.STATIC_CONNECTORS);\n                    final String groupRef = readStringAttributeElement(reader, BridgeDefinition.DISCOVERY_GROUP_NAME.getXmlName());\n                    BridgeDefinition.DISCOVERY_GROUP_NAME.parseAndSetParameter(groupRef, bridgeAdd, reader);\n                    break;\n                }\n                case FAILOVER_ON_SERVER_SHUTDOWN: {\n                    MessagingLogger.ROOT_LOGGER.deprecatedXMLElement(element.toString());\n                    skipElementText(reader);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n        }\n\n        checkOnlyOneOfElements(reader, seen, Element.STATIC_CONNECTORS, Element.DISCOVERY_GROUP_REF);\n\n        if(!required.isEmpty()) {\n            throw missingRequired(reader, required);\n        }\n\n        updates.add(bridgeAdd);\n    }","commit_id":"254a559ceeafcb825fb68441df01e47ef4c0ee83","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void processClusterConnection(XMLExtendedStreamReader reader, ModelNode address, List<ModelNode> updates) throws XMLStreamException {\n\n        requireSingleAttribute(reader, CommonAttributes.NAME);\n        String name = reader.getAttributeValue(0);\n\n        ModelNode clusterConnectionAdd = org.jboss.as.controller.operations.common.Util.getEmptyOperation(ADD, address.clone().add(CommonAttributes.CLUSTER_CONNECTION, name));\n\n        EnumSet<Element> required = EnumSet.of(Element.ADDRESS, Element.CONNECTOR_REF);\n        Set<Element> seen = EnumSet.noneOf(Element.class);\n        while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            if (!seen.add(element)) {\n                throw ParseUtils.duplicateNamedElement(reader, element.getLocalName());\n            }\n            required.remove(element);\n            switch (element) {\n                case FORWARD_WHEN_NO_CONSUMERS:\n                case MAX_HOPS:\n                    handleElementText(reader, element, clusterConnectionAdd);\n                    break;\n                case ADDRESS:  {\n                    handleElementText(reader, element, ClusterConnectionDefinition.ADDRESS.getName(), clusterConnectionAdd);\n                    break;\n                }\n                case CONNECTOR_REF:  {\n                    // Use the \"simple\" variant\n                    handleElementText(reader, element, \"simple\", clusterConnectionAdd);\n                    break;\n                }\n                case CONFIRMATION_WINDOW_SIZE:\n                    handleElementText(reader, element, \"bridge\", clusterConnectionAdd);\n                    break;\n                case USE_DUPLICATE_DETECTION:\n                case RETRY_INTERVAL:\n                    // Use the \"cluster\" variant\n                    handleElementText(reader, element, \"cluster\", clusterConnectionAdd);\n                    break;\n                case STATIC_CONNECTORS:\n                    checkOtherElementIsNotAlreadyDefined(reader, seen, Element.STATIC_CONNECTORS, Element.DISCOVERY_GROUP_REF);\n                    processStaticConnectors(reader, clusterConnectionAdd, true);\n                    break;\n                case DISCOVERY_GROUP_REF: {\n                    checkOtherElementIsNotAlreadyDefined(reader, seen, Element.DISCOVERY_GROUP_REF, Element.STATIC_CONNECTORS);\n                    final String groupRef = readStringAttributeElement(reader, ClusterConnectionDefinition.DISCOVERY_GROUP_NAME.getXmlName());\n                    ClusterConnectionDefinition.DISCOVERY_GROUP_NAME.parseAndSetParameter(groupRef, clusterConnectionAdd, reader);\n                    break;\n                }\n                default: {\n                    handleUnknownClusterConnectionAttribute(reader, element, clusterConnectionAdd);\n                }\n            }\n        }\n\n        if(!required.isEmpty()) {\n            missingRequired(reader, required);\n        }\n\n        checkClusterConnectionConstraints(reader, seen);\n\n        updates.add(clusterConnectionAdd);\n    }","id":65789,"modified_method":"protected void processClusterConnection(XMLExtendedStreamReader reader, ModelNode address, List<ModelNode> updates) throws XMLStreamException {\n\n        requireSingleAttribute(reader, CommonAttributes.NAME);\n        String name = reader.getAttributeValue(0);\n\n        ModelNode clusterConnectionAdd = org.jboss.as.controller.operations.common.Util.getEmptyOperation(ADD, address.clone().add(CommonAttributes.CLUSTER_CONNECTION, name));\n\n        EnumSet<Element> required = EnumSet.of(Element.ADDRESS, Element.CONNECTOR_REF);\n        Set<Element> seen = EnumSet.noneOf(Element.class);\n        while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            if (!seen.add(element)) {\n                throw ParseUtils.duplicateNamedElement(reader, element.getLocalName());\n            }\n            required.remove(element);\n            switch (element) {\n                case FORWARD_WHEN_NO_CONSUMERS:\n                case MAX_HOPS:\n                    handleElementText(reader, element, clusterConnectionAdd);\n                    break;\n                case ADDRESS:  {\n                    handleElementText(reader, element, ClusterConnectionDefinition.ADDRESS.getName(), clusterConnectionAdd);\n                    break;\n                }\n                case CONNECTOR_REF:  {\n                    // Use the \"simple\" variant\n                    handleElementText(reader, element, \"simple\", clusterConnectionAdd);\n                    break;\n                }\n                case CONFIRMATION_WINDOW_SIZE:\n                    handleElementText(reader, element, \"bridge\", clusterConnectionAdd);\n                    break;\n                case USE_DUPLICATE_DETECTION:\n                case RETRY_INTERVAL:\n                    // Use the \"cluster\" variant\n                    handleElementText(reader, element, \"cluster\", clusterConnectionAdd);\n                    break;\n                case STATIC_CONNECTORS:\n                    checkOtherElementIsNotAlreadyDefined(reader, seen, Element.STATIC_CONNECTORS, Element.DISCOVERY_GROUP_REF);\n                    processStaticConnectors(reader, clusterConnectionAdd, true);\n                    break;\n                case DISCOVERY_GROUP_REF: {\n                    checkOtherElementIsNotAlreadyDefined(reader, seen, Element.DISCOVERY_GROUP_REF, Element.STATIC_CONNECTORS);\n                    final String groupRef = readStringAttributeElement(reader, ClusterConnectionDefinition.DISCOVERY_GROUP_NAME.getXmlName());\n                    ClusterConnectionDefinition.DISCOVERY_GROUP_NAME.parseAndSetParameter(groupRef, clusterConnectionAdd, reader);\n                    break;\n                }\n                default: {\n                    handleUnknownClusterConnectionAttribute(reader, element, clusterConnectionAdd);\n                }\n            }\n        }\n\n        if(!required.isEmpty()) {\n            throw missingRequired(reader, required);\n        }\n\n        checkClusterConnectionConstraints(reader, seen);\n\n        updates.add(clusterConnectionAdd);\n    }","commit_id":"254a559ceeafcb825fb68441df01e47ef4c0ee83","url":"https://github.com/wildfly/wildfly"},{"original_method":"void processPooledConnectionFactory(final XMLExtendedStreamReader reader, ModelNode address, List<ModelNode> updates) throws XMLStreamException {\n        final String name = reader.getAttributeValue(0);\n        if(name == null) {\n            ParseUtils.missingRequired(reader, Collections.singleton(\"name\"));\n        }\n\n        final ModelNode connectionFactory = new ModelNode();\n        connectionFactory.get(OP).set(ADD);\n        connectionFactory.get(OP_ADDR).set(address).add(POOLED_CONNECTION_FACTORY, name);\n\n        updates.add(createConnectionFactory(reader, connectionFactory, true));\n    }","id":65790,"modified_method":"void processPooledConnectionFactory(final XMLExtendedStreamReader reader, ModelNode address, List<ModelNode> updates) throws XMLStreamException {\n        final String name = reader.getAttributeValue(0);\n        if(name == null) {\n            throw missingRequired(reader, Collections.singleton(\"name\"));\n        }\n\n        final ModelNode connectionFactory = new ModelNode();\n        connectionFactory.get(OP).set(ADD);\n        connectionFactory.get(OP_ADDR).set(address).add(POOLED_CONNECTION_FACTORY, name);\n\n        updates.add(createConnectionFactory(reader, connectionFactory, true));\n    }","commit_id":"254a559ceeafcb825fb68441df01e47ef4c0ee83","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void checkDiscoveryGroupConstraints(XMLExtendedStreamReader reader, Set<Element> seen) throws XMLStreamException {\n    }","id":65791,"modified_method":"protected void checkDiscoveryGroupConstraints(XMLExtendedStreamReader reader, Set<Element> seen) throws XMLStreamException {\n        checkOnlyOneOfElements(reader, seen, Element.GROUP_ADDRESS, Element.SOCKET_BINDING);\n        if (seen.contains(Element.GROUP_ADDRESS) && !seen.contains(Element.GROUP_PORT)) {\n            throw missingRequired(reader, EnumSet.of(Element.GROUP_PORT));\n        }\n    }","commit_id":"254a559ceeafcb825fb68441df01e47ef4c0ee83","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n\tprotected void onAttach()\n\t{\n\t\tsuper.onAttach();\n\t\tinitIds();\n\t}","id":65792,"modified_method":"@Override\n\tprotected void onAttach()\n\t{\n\t\tsuper.onAttach();\n\t\tif (!getForm().hasError())\n\t\t{\n\t\t\tinitIds();\n\t\t}\n\t\tattached = true;\n\t}","commit_id":"dba32d0a2cab8caf8dfc7e5b5469e996e311c555","url":"https://github.com/apache/wicket"},{"original_method":"@Override\n\tprotected void onInvalid()\n\t{\n\t\tsuper.onInvalid();\n\t\tupdateIds();\n\t}","id":65793,"modified_method":"@Override\n\tprotected void onInvalid()\n\t{\n\t\tsuper.onInvalid();\n\t\tif (attached)\n\t\t\tupdateIds();\n\t}","commit_id":"dba32d0a2cab8caf8dfc7e5b5469e996e311c555","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @param parent\n\t *            The parent of this component The parent of this component.\n\t * @param id\n\t *            component id\n\t * @param palette\n\t *            parent palette object\n\t */\n\tpublic Recorder(MarkupContainer parent, final String id, final Palette palette)\n\t{\n\t\tsuper(parent, id);\n\t\tthis.palette = palette;\n\n\t\tsetOutputMarkupId(true);\n\n\t\tinitIds();\n\t}","id":65794,"modified_method":"/**\n\t * @param parent\n\t *            The parent of this component The parent of this component.\n\t * @param id\n\t *            component id\n\t * @param palette\n\t *            parent palette object\n\t */\n\tpublic Recorder(MarkupContainer parent, final String id, final Palette palette)\n\t{\n\t\tsuper(parent, id);\n\t\tthis.palette = palette;\n\n\t\tsetOutputMarkupId(true);\n\t}","commit_id":"dba32d0a2cab8caf8dfc7e5b5469e996e311c555","url":"https://github.com/apache/wicket"},{"original_method":"@Override\n\tprotected void onValid()\n\t{\n\t\tsuper.onValid();\n\t\tupdateIds();\n\t}","id":65795,"modified_method":"@Override\n\tprotected void onValid()\n\t{\n\t\tsuper.onValid();\n\t\tif (attached)\n\t\t\tupdateIds();\n\t}","commit_id":"dba32d0a2cab8caf8dfc7e5b5469e996e311c555","url":"https://github.com/apache/wicket"},{"original_method":"protected void onInvalid()\n\t{\n\t\tsuper.onInvalid();\n\t\tupdateIds();\n\t}","id":65796,"modified_method":"protected void onInvalid()\n\t{\n\t\tsuper.onInvalid();\n\t\tif (attached)\n\t\t\tupdateIds();\n\t}","commit_id":"56fdf74248fac883cc811133d8166b187f71f93a","url":"https://github.com/apache/wicket"},{"original_method":"protected void onAttach()\n\t{\n\t\tsuper.onAttach();\n\n\t\tif (!getForm().hasError())\n\t\t{\n\t\t\tinitIds();\n\t\t}\n\n\t}","id":65797,"modified_method":"protected void onAttach()\n\t{\n\t\tsuper.onAttach();\n\n\t\tif (!getForm().hasError())\n\t\t{\n\t\t\tinitIds();\n\t\t}\n\t\tattached = true;\n\t}","commit_id":"56fdf74248fac883cc811133d8166b187f71f93a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @param id\n\t *            component id\n\t * @param palette\n\t *            parent palette object\n\t */\n\tpublic Recorder(String id, Palette palette)\n\t{\n\t\tsuper(id);\n\t\tthis.palette = palette;\n\n\t\tsetOutputMarkupId(true);\n\t\tinitIds();\n\t}","id":65798,"modified_method":"/**\n\t * @param id\n\t *            component id\n\t * @param palette\n\t *            parent palette object\n\t */\n\tpublic Recorder(String id, Palette palette)\n\t{\n\t\tsuper(id);\n\t\tthis.palette = palette;\n\n\t\tsetOutputMarkupId(true);\n\t}","commit_id":"56fdf74248fac883cc811133d8166b187f71f93a","url":"https://github.com/apache/wicket"},{"original_method":"protected void onValid()\n\t{\n\t\tsuper.onValid();\n\t\tupdateIds();\n\t}","id":65799,"modified_method":"protected void onValid()\n\t{\n\t\tsuper.onValid();\n\t\tif (attached)\n\t\t\tupdateIds();\n\t}","commit_id":"56fdf74248fac883cc811133d8166b187f71f93a","url":"https://github.com/apache/wicket"},{"original_method":"@Before\n\tpublic void setup() throws Exception {\n\n\t\tthis.wac = new AnnotationConfigWebApplicationContext();\n\t\tthis.wac.register(getAnnotatedConfigClasses());\n\t\tthis.wac.register(upgradeStrategyConfigTypes.get(this.server.getClass()));\n\n\t\tif (this.webSocketClient instanceof Lifecycle) {\n\t\t\t((Lifecycle) this.webSocketClient).start();\n\t\t}\n\n\t\tthis.server.init(this.wac);\n\t\tthis.server.start();\n\t}","id":65800,"modified_method":"@Before\n\tpublic void setup() throws Exception {\n\n\t\tthis.wac = new AnnotationConfigWebApplicationContext();\n\t\tthis.wac.register(getAnnotatedConfigClasses());\n\t\tthis.wac.register(upgradeStrategyConfigTypes.get(this.server.getClass()));\n\t\tthis.wac.refresh();\n\n\t\tif (this.webSocketClient instanceof Lifecycle) {\n\t\t\t((Lifecycle) this.webSocketClient).start();\n\t\t}\n\n\t\tthis.server.deployConfig(this.wac);\n\t\tthis.server.start();\n\t}","commit_id":"fee3148b0fa5c5fbff15cfd4c062de60bcc49711","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@After\n\tpublic void teardown() throws Exception {\n\t\ttry {\n\t\t\tif (this.webSocketClient instanceof Lifecycle) {\n\t\t\t\t((Lifecycle) this.webSocketClient).stop();\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tthis.server.stop();\n\t\t}\n\t}","id":65801,"modified_method":"@After\n\tpublic void teardown() throws Exception {\n\t\ttry {\n\t\t\tif (this.webSocketClient instanceof Lifecycle) {\n\t\t\t\t((Lifecycle) this.webSocketClient).stop();\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tlogger.error(\"Failed to stop WebSocket client\", t);\n\t\t}\n\n\t\ttry {\n\t\t\tthis.server.undeployConfig();\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tlogger.error(\"Failed to undeploy application config\", t);\n\t\t}\n\n\t\ttry {\n\t\t\tthis.server.stop();\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tlogger.error(\"Failed to stop server\", t);\n\t\t}\n\t}","commit_id":"fee3148b0fa5c5fbff15cfd4c062de60bcc49711","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Before\n\tpublic void setup() throws Exception {\n\n\t\tthis.wac = new AnnotationConfigWebApplicationContext();\n\t\tthis.wac.register(getAnnotatedConfigClasses());\n\t\tthis.wac.register(upgradeStrategyConfigTypes.get(this.server.getClass()));\n\n\t\tif (this.webSocketClient instanceof Lifecycle) {\n\t\t\t((Lifecycle) this.webSocketClient).start();\n\t\t}\n\n\t\tthis.server.init(this.wac);\n\t\tthis.server.start();\n\t}","id":65802,"modified_method":"@Before\n\tpublic void setup() throws Exception {\n\n\t\tClass<?> upgradeStrategyConfigClass = upgradeStrategyConfigTypes.get(this.server.getClass());\n\t\tAssert.notNull(upgradeStrategyConfigClass, \"No UpgradeStrategyConfig class\");\n\n\t\tthis.wac = new AnnotationConfigWebApplicationContext();\n\t\tthis.wac.register(getAnnotatedConfigClasses());\n\t\tthis.wac.register(upgradeStrategyConfigClass);\n\t\tthis.wac.refresh();\n\n\t\tif (this.webSocketClient instanceof Lifecycle) {\n\t\t\t((Lifecycle) this.webSocketClient).start();\n\t\t}\n\n\t\tthis.server.deployConfig(this.wac);\n\t\tthis.server.start();\n\t}","commit_id":"fee3148b0fa5c5fbff15cfd4c062de60bcc49711","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@After\n\tpublic void teardown() throws Exception {\n\t\ttry {\n\t\t\tif (this.webSocketClient instanceof Lifecycle) {\n\t\t\t\t((Lifecycle) this.webSocketClient).stop();\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tthis.server.stop();\n\t\t}\n\t}","id":65803,"modified_method":"@After\n\tpublic void teardown() throws Exception {\n\t\ttry {\n\t\t\tif (this.webSocketClient instanceof Lifecycle) {\n\t\t\t\t((Lifecycle) this.webSocketClient).stop();\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tlogger.error(\"Failed to stop WebSocket client\", t);\n\t\t}\n\n\t\ttry {\n\t\t\tthis.server.undeployConfig();\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tlogger.error(\"Failed to undeploy application config\", t);\n\t\t}\n\n\t\ttry {\n\t\t\tthis.server.stop();\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tlogger.error(\"Failed to stop server\", t);\n\t\t}\n\t}","commit_id":"fee3148b0fa5c5fbff15cfd4c062de60bcc49711","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic void init(WebApplicationContext cxt) {\n\t\tServletContextHandler handler = new ServletContextHandler();\n\t\thandler.addServlet(new ServletHolder(new DispatcherServlet(cxt)), \"/\");\n\t\tthis.jettyServer.setHandler(handler);\n\t}","id":65804,"modified_method":"@Override\n\tpublic void deployConfig(WebApplicationContext cxt) {\n\t\tServletContextHandler contextHandler = new ServletContextHandler();\n\t\tServletHolder servletHolder = new ServletHolder(new DispatcherServlet(cxt));\n\t\tcontextHandler.addServlet(servletHolder, \"/\");\n\t\tthis.jettyServer.setHandler(contextHandler);\n\t}","commit_id":"fee3148b0fa5c5fbff15cfd4c062de60bcc49711","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic void init(WebApplicationContext cxt) {\n\t\tServletContextHandler handler = new ServletContextHandler();\n\t\thandler.addServlet(new ServletHolder(new DispatcherServlet(cxt)), \"/\");\n\t\tthis.jettyServer.setHandler(handler);\n\t}","id":65805,"modified_method":"@Override\n\tpublic void deployConfig(WebApplicationContext cxt) {\n\t\tServletContextHandler contextHandler = new ServletContextHandler();\n\t\tServletHolder servletHolder = new ServletHolder(new DispatcherServlet(cxt));\n\t\tcontextHandler.addServlet(servletHolder, \"/\");\n\t\tthis.jettyServer.setHandler(contextHandler);\n\t}","commit_id":"fee3148b0fa5c5fbff15cfd4c062de60bcc49711","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic void upgradeInternal(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tString acceptedProtocol, Endpoint endpoint) throws HandshakeFailureException {\n\n\t\tAssert.isTrue(request instanceof ServletServerHttpRequest);\n\t\tHttpServletRequest servletRequest = ((ServletServerHttpRequest) request).getServletRequest();\n\n\t\tAssert.isTrue(response instanceof ServletServerHttpResponse);\n\t\tHttpServletResponse servletResponse = ((ServletServerHttpResponse) response).getServletResponse();\n\n\t\tif (hasDoUpgrade) {\n\t\t\tdoUpgrade(servletRequest, servletResponse, acceptedProtocol, endpoint);\n\t\t}\n\t\telse {\n\t\t\tupgradeTomcat80RC1(servletRequest, acceptedProtocol, endpoint);\n\t\t}\n\t}","id":65806,"modified_method":"@Override\n\tpublic void upgradeInternal(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tString acceptedProtocol, Endpoint endpoint) throws HandshakeFailureException {\n\n\t\tAssert.isTrue(request instanceof ServletServerHttpRequest);\n\t\tHttpServletRequest servletRequest = ((ServletServerHttpRequest) request).getServletRequest();\n\n\t\tAssert.isTrue(response instanceof ServletServerHttpResponse);\n\t\tHttpServletResponse servletResponse = ((ServletServerHttpResponse) response).getServletResponse();\n\n\t\tStringBuffer requestUrl = servletRequest.getRequestURL();\n\t\tString path = servletRequest.getRequestURI(); // shouldn't matter\n\t\tMap<String, String> pathParams = Collections.<String, String> emptyMap();\n\n\t\tServerEndpointRegistration endpointConfig = new ServerEndpointRegistration(path, endpoint);\n\t\tendpointConfig.setSubprotocols(Arrays.asList(acceptedProtocol));\n\n\t\ttry {\n\t\t\tgetContainer(servletRequest).doUpgrade(servletRequest, servletResponse, endpointConfig, pathParams);\n\t\t}\n\t\tcatch (ServletException ex) {\n\t\t\tthrow new HandshakeFailureException(\n\t\t\t\t\t\"Servlet request failed to upgrade to WebSocket, uri=\" + requestUrl, ex);\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new HandshakeFailureException(\n\t\t\t\t\t\"Response update failed during upgrade to WebSocket, uri=\" + requestUrl, ex);\n\t\t}\n\t}","commit_id":"fee3148b0fa5c5fbff15cfd4c062de60bcc49711","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void registerWebSocketHandler() throws Exception {\n\n\t\tthis.webSocketClient.doHandshake(new WebSocketHandlerAdapter(), getWsBaseUrl() + \"/ws\");\n\n\t\tTestWebSocketHandler serverHandler = this.wac.getBean(TestWebSocketHandler.class);\n\t\tassertTrue(serverHandler.latch.await(2, TimeUnit.SECONDS));\n\t}","id":65807,"modified_method":"@Test\n\tpublic void registerWebSocketHandler() throws Exception {\n\n\t\tWebSocketSession session =\n\t\t\t\tthis.webSocketClient.doHandshake(new WebSocketHandlerAdapter(), getWsBaseUrl() + \"/ws\");\n\n\t\tTestWebSocketHandler serverHandler = this.wac.getBean(TestWebSocketHandler.class);\n\t\tassertTrue(serverHandler.latch.await(2, TimeUnit.SECONDS));\n\n\t\tsession.close();\n\t}","commit_id":"fee3148b0fa5c5fbff15cfd4c062de60bcc49711","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Parameters\n\tpublic static Iterable<Object[]> arguments() {\n\t\treturn Arrays.asList(new Object[][] {\n\t\t\t\t{ new JettyTestServer(), new JettyWebSocketClient()} });\n\t}","id":65808,"modified_method":"@Parameters\n\tpublic static Iterable<Object[]> arguments() {\n\t\treturn Arrays.asList(new Object[][] {\n\t\t\t\t{new JettyTestServer(), new JettyWebSocketClient()},\n\t\t\t\t{new TomcatTestServer(), new StandardWebSocketClient()}\n\t\t});\n\t}","commit_id":"fee3148b0fa5c5fbff15cfd4c062de60bcc49711","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void registerWebSocketHandlerWithSockJS() throws Exception {\n\n\t\tthis.webSocketClient.doHandshake(new WebSocketHandlerAdapter(), getWsBaseUrl() + \"/sockjs/websocket\");\n\n\t\tTestWebSocketHandler serverHandler = this.wac.getBean(TestWebSocketHandler.class);\n\t\tassertTrue(serverHandler.latch.await(2, TimeUnit.SECONDS));\n\t}","id":65809,"modified_method":"@Test\n\tpublic void registerWebSocketHandlerWithSockJS() throws Exception {\n\n\t\tWebSocketSession session =\n\t\t\t\tthis.webSocketClient.doHandshake(new WebSocketHandlerAdapter(), getWsBaseUrl() + \"/sockjs/websocket\");\n\n\t\tTestWebSocketHandler serverHandler = this.wac.getBean(TestWebSocketHandler.class);\n\t\tassertTrue(serverHandler.latch.await(2, TimeUnit.SECONDS));\n\n\t\tsession.close();\n\t}","commit_id":"fee3148b0fa5c5fbff15cfd4c062de60bcc49711","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void sendMessage() throws Exception {\n\n\t\tfinal TextMessage textMessage = StompTextMessageBuilder.create(StompCommand.SEND)\n\t\t\t\t.headers(\"destination:/app/foo\").build();\n\n\t\tWebSocketHandler clientHandler = new TextWebSocketHandlerAdapter() {\n\t\t\t@Override\n\t\t\tpublic void afterConnectionEstablished(WebSocketSession session) throws Exception {\n\t\t\t\tsession.sendMessage(textMessage);\n\t\t\t}\n\t\t};\n\n\t\tTestController testController = this.wac.getBean(TestController.class);\n\n\t\tthis.webSocketClient.doHandshake(clientHandler, getWsBaseUrl() + \"/ws\");\n\t\tassertTrue(testController.latch.await(2, TimeUnit.SECONDS));\n\n\t\ttestController.latch = new CountDownLatch(1);\n\t\tthis.webSocketClient.doHandshake(clientHandler, getWsBaseUrl() + \"/sockjs/websocket\");\n\t\tassertTrue(testController.latch.await(2, TimeUnit.SECONDS));\n\t}","id":65810,"modified_method":"@Test\n\tpublic void sendMessage() throws Exception {\n\n\t\tfinal TextMessage textMessage = StompTextMessageBuilder.create(StompCommand.SEND)\n\t\t\t\t.headers(\"destination:/app/foo\").build();\n\n\t\tWebSocketHandler clientHandler = new TextWebSocketHandlerAdapter() {\n\t\t\t@Override\n\t\t\tpublic void afterConnectionEstablished(WebSocketSession session) throws Exception {\n\t\t\t\tsession.sendMessage(textMessage);\n\t\t\t}\n\t\t};\n\n\t\tTestController testController = this.wac.getBean(TestController.class);\n\n\t\tWebSocketSession session = this.webSocketClient.doHandshake(clientHandler, getWsBaseUrl() + \"/ws\");\n\t\tassertTrue(testController.latch.await(2, TimeUnit.SECONDS));\n\t\tsession.close();\n\n\t\ttestController.latch = new CountDownLatch(1);\n\t\tsession = this.webSocketClient.doHandshake(clientHandler, getWsBaseUrl() + \"/sockjs/websocket\");\n\t\tassertTrue(testController.latch.await(2, TimeUnit.SECONDS));\n\t\tsession.close();\n\t}","commit_id":"fee3148b0fa5c5fbff15cfd4c062de60bcc49711","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Parameters\n\tpublic static Iterable<Object[]> arguments() {\n\t\treturn Arrays.asList(new Object[][] {\n\t\t\t\t{ new JettyTestServer(), new JettyWebSocketClient()} });\n\t}","id":65811,"modified_method":"@Parameters\n\tpublic static Iterable<Object[]> arguments() {\n\t\treturn Arrays.asList(new Object[][] {\n\t\t\t\t{new JettyTestServer(), new JettyWebSocketClient()},\n\t\t\t\t{new TomcatTestServer(), new StandardWebSocketClient()}\n\t\t});\n\t}","commit_id":"fee3148b0fa5c5fbff15cfd4c062de60bcc49711","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private void writeChangelog(Issue issue, JsonWriter json) {\n    json.name(\"changelog\").beginArray();\n    IssueChangelog changelog = issueChangelogService.changelog(issue);\n    for (FieldDiffs diffs : changelog.changes()) {\n      String userLogin = diffs.userLogin();\n      json\n        .beginObject()\n        .prop(\"userName\", userLogin != null ? changelog.user(diffs).name() : null)\n        .prop(\"creationDate\", DateUtils.formatDateTime(diffs.creationDate()))\n        .prop(\"fCreationDate\", formatDate(diffs.creationDate()));\n\n      json.name(\"diffs\").beginArray();\n      List<String> diffsFormatted = issueChangelogService.formatDiffs(diffs);\n      for (String diff : diffsFormatted) {\n        json.value(diff);\n      }\n      json.endArray();\n      json.endObject();\n    }\n    json.endArray();\n  }","id":65812,"modified_method":"private void writeChangelog(Issue issue, JsonWriter json) {\n    json.name(\"changelog\").beginArray()\n      .beginObject()\n      .prop(\"creationDate\", DateUtils.formatDateTime(issue.creationDate()))\n      .prop(\"fCreationDate\", formatDate(issue.creationDate()))\n      .name(\"diffs\").beginArray()\n      .value(i18n.message(UserSession.get().locale(), \"created\", null))\n      .endArray()\n      .endObject();\n\n    IssueChangelog changelog = issueChangelogService.changelog(issue);\n    for (FieldDiffs diffs : changelog.changes()) {\n      String userLogin = diffs.userLogin();\n      json\n        .beginObject()\n        .prop(\"userName\", userLogin != null ? changelog.user(diffs).name() : null)\n        .prop(\"creationDate\", DateUtils.formatDateTime(diffs.creationDate()))\n        .prop(\"fCreationDate\", formatDate(diffs.creationDate()));\n      json.name(\"diffs\").beginArray();\n      List<String> diffsFormatted = issueChangelogService.formatDiffs(diffs);\n      for (String diff : diffsFormatted) {\n        json.value(diff);\n      }\n      json.endArray();\n      json.endObject();\n    }\n    json.endArray();\n  }","commit_id":"c9fa038627c1f7e0ede57d93269b43a001c8d04a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private DefaultIssue createStandardIssue() {\n    return new DefaultIssue()\n      .setKey(\"ABCD\")\n      .setComponentKey(\"org.sonar.server.issue.IssueClient\")\n      .setProjectKey(\"org.sonar.Sonar\")\n      .setRuleKey(RuleKey.of(\"squid\", \"AvoidCycle\"))\n      .setCreationDate(DateUtils.parseDateTime(\"2014-01-22T19:10:03+0100\"));\n  }","id":65813,"modified_method":"private DefaultIssue createStandardIssue() {\n    DefaultIssue issue = new DefaultIssue()\n      .setKey(\"ABCD\")\n      .setComponentKey(\"org.sonar.server.issue.IssueClient\")\n      .setProjectKey(\"org.sonar.Sonar\")\n      .setRuleKey(RuleKey.of(\"squid\", \"AvoidCycle\"))\n      .setCreationDate(DateUtils.parseDateTime(\"2014-01-22T19:10:03+0100\"));\n    when(i18n.formatDateTime(any(Locale.class), eq(issue.creationDate()))).thenReturn(\"Jan 22, 2014 10:03 AM\");\n    when(i18n.message(any(Locale.class), eq(\"created\"), eq((String) null))).thenReturn(\"Created\");\n    return issue;\n  }","commit_id":"c9fa038627c1f7e0ede57d93269b43a001c8d04a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void show_issue() throws Exception {\n    String issueKey = \"ABCD\";\n    Issue issue = new DefaultIssue()\n      .setKey(issueKey)\n      .setComponentKey(\"org.sonar.server.issue.IssueClient\")\n      .setProjectKey(\"org.sonar.Sonar\")\n      .setRuleKey(RuleKey.of(\"squid\", \"AvoidCycle\"))\n      .setLine(12)\n      .setEffortToFix(2.0)\n      .setMessage(\"Fix it\")\n      .setResolution(\"FIXED\")\n      .setStatus(\"CLOSED\")\n      .setSeverity(\"MAJOR\")\n      .setCreationDate(DateUtils.parseDateTime(\"2014-01-22T19:10:03+0100\"));\n    issues.add(issue);\n\n    MockUserSession.set();\n    WsTester.TestRequest request = tester.newRequest(\"show\").setParam(\"key\", issueKey);\n    request.execute().assertJson(getClass(), \"show_issue.json\");\n  }","id":65814,"modified_method":"@Test\n  public void show_issue() throws Exception {\n    String issueKey = \"ABCD\";\n    Issue issue = new DefaultIssue()\n      .setKey(issueKey)\n      .setComponentKey(\"org.sonar.server.issue.IssueClient\")\n      .setProjectKey(\"org.sonar.Sonar\")\n      .setRuleKey(RuleKey.of(\"squid\", \"AvoidCycle\"))\n      .setLine(12)\n      .setEffortToFix(2.0)\n      .setMessage(\"Fix it\")\n      .setResolution(\"FIXED\")\n      .setStatus(\"CLOSED\")\n      .setSeverity(\"MAJOR\")\n      .setCreationDate(DateUtils.parseDateTime(\"2014-01-22T19:10:03+0100\"));\n    issues.add(issue);\n\n    when(i18n.formatDateTime(any(Locale.class), eq(issue.creationDate()))).thenReturn(\"Jan 22, 2014 10:03 AM\");\n    when(i18n.message(any(Locale.class), eq(\"created\"), eq((String) null))).thenReturn(\"Created\");\n\n    MockUserSession.set();\n    WsTester.TestRequest request = tester.newRequest(\"show\").setParam(\"key\", issueKey);\n    request.execute().assertJson(getClass(), \"show_issue.json\");\n  }","commit_id":"c9fa038627c1f7e0ede57d93269b43a001c8d04a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void writeTags(Rule rule, JsonWriter json) {\n    json.name(\"tags\").beginArray();\n    // TODO\n    json.endArray();\n\n    json.name(\"sysTags\").beginArray();\n    // TODO\n    json.endArray();\n  }","id":65815,"modified_method":"private void writeTags(Rule rule, JsonWriter json) {\n    json.name(\"tags\").beginArray()\n      .value(\"Complexity\")\n      .endArray();\n\n    json.name(\"sysTags\").beginArray()\n      .value(\"Security\")\n      .endArray();\n  }","commit_id":"e4402e125fbb303da9952cb9106ae70c45cd22db","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"protected static void toggleFoldRegionState(final FoldRegion foldRegion, final boolean expanded) {\n    myEditor.getFoldingModel().runBatchFoldingOperation(new Runnable() {\n      @Override\n      public void run() {\n        foldRegion.setExpanded(expanded);\n      }\n    });\n  }","id":65816,"modified_method":"protected static void toggleFoldRegionState(final FoldRegion foldRegion, final boolean expanded) {\n    myEditor.getFoldingModel().runBatchFoldingOperation(() -> foldRegion.setExpanded(expanded));\n  }","commit_id":"64b924a99a25fb00125bf9088f90b6a1accf9111","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void tearDown() throws Exception {\n    super.tearDown();\n    FontLayoutService.setInstance(null);\n  }","id":65817,"modified_method":"@Override\n  protected void tearDown() throws Exception {\n    try {\n      FontLayoutService.setInstance(null);\n    }\n    finally {\n      super.tearDown();\n    }\n  }","commit_id":"64b924a99a25fb00125bf9088f90b6a1accf9111","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void verifySoftWrapPositions(Integer... positions) {\n    List<Integer> softWrapPositions = new ArrayList<Integer>();\n    for (SoftWrap softWrap : myEditor.getSoftWrapModel().getSoftWrapsForRange(0, myEditor.getDocument().getTextLength())) {\n      softWrapPositions.add(softWrap.getStart());\n    }\n    assertArrayEquals(positions, softWrapPositions.toArray());\n  }","id":65818,"modified_method":"public static void verifySoftWrapPositions(Integer... positions) {\n    List<Integer> softWrapPositions = new ArrayList<>();\n    for (SoftWrap softWrap : myEditor.getSoftWrapModel().getSoftWrapsForRange(0, myEditor.getDocument().getTextLength())) {\n      softWrapPositions.add(softWrap.getStart());\n    }\n    assertArrayEquals(positions, softWrapPositions.toArray());\n  }","commit_id":"64b924a99a25fb00125bf9088f90b6a1accf9111","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Setups {@link Editor#getSoftWrapModel() soft wraps model} of the {@link #getEditor() current editor} according to the given text\n   * that is expected to contain information obtained from the {@link CachingSoftWrapDataMapper#toString()}.\n   *\n   * @param data  string representation of the target soft wraps cache\n   */\n  @SuppressWarnings(\"UnusedDeclaration\")\n  protected static void setupSoftWraps(@NotNull String data) {\n    Scanner scanner = new Scanner(data);\n    Pattern generalPattern =\n      Pattern.compile(\"visual line: (\\\\d+), offsets: (\\\\d+)-(\\\\d+), logical lines: (\\\\d+)-(\\\\d+), logical columns: (\\\\d+)-(\\\\d+), \"\n                      + \"end visual column: (\\\\d+), fold regions: \\\\[([^\\\\]]*)\\\\], tab data: \\\\[([^\\\\]]*)\\\\]\");\n    Pattern foldPattern = Pattern.compile(\"width in columns: (-?\\\\d+), fold region: FoldRegion [-+]\\\\((\\\\d+):(\\\\d+)\");\n    Pattern tabPattern = Pattern.compile(\"\\\\[(\\\\d+), width: (\\\\d+)\");\n    final SoftWrapModelImpl softWrapModel = (SoftWrapModelImpl)myEditor.getSoftWrapModel();\n    final CachingSoftWrapDataMapper mapper = softWrapModel.getDataMapper();\n    mapper.release();\n    final FoldingModelEx foldingModel = (FoldingModelEx)myEditor.getFoldingModel();\n    while (scanner.findInLine(generalPattern) != null) {\n      final MatchResult generalMatch = scanner.match();\n      int visualLine = Integer.parseInt(generalMatch.group(1));\n      int startOffset = Integer.parseInt(generalMatch.group(2));\n      int endOffset = Integer.parseInt(generalMatch.group(3));\n      int startLogicalLine = Integer.parseInt(generalMatch.group(4));\n      int endLogicalLine = Integer.parseInt(generalMatch.group(5));\n      int startLogicalColumn = Integer.parseInt(generalMatch.group(6));\n      int endLogicalColumn = Integer.parseInt(generalMatch.group(7));\n      int endVisualColumn = Integer.parseInt(generalMatch.group(8));\n      \n      List<Pair<Integer, FoldRegion>> foldRegions = new ArrayList<Pair<Integer, FoldRegion>>();\n      Scanner foldScanner = new Scanner(generalMatch.group(9));\n      while (foldScanner.findInLine(foldPattern) != null) {\n        final MatchResult foldMatch = foldScanner.match();\n        int widthInColumns = Integer.parseInt(foldMatch.group(1));\n        int foldStartOffset = Integer.parseInt(foldMatch.group(2));\n        int foldEndOffset = Integer.parseInt(foldMatch.group(3));\n        FoldRegion region = null;\n        for (FoldRegion candidate : foldingModel.getAllFoldRegions()) {\n          if (candidate.getStartOffset() == foldStartOffset && candidate.getEndOffset() == foldEndOffset) {\n            region = candidate;\n            break;\n          }\n        }\n        foldRegions.add(new Pair<Integer, FoldRegion>(widthInColumns, region));\n      }\n      \n      List<Pair<Integer, Integer>> tabData = new ArrayList<Pair<Integer, Integer>>();\n      Scanner tabScanner = new Scanner(generalMatch.group(10));\n      while (tabScanner.findInLine(tabPattern) != null) {\n        final MatchResult tabMatch = tabScanner.match();\n        int offset = Integer.parseInt(tabMatch.group(1));\n        int widthInColumns = Integer.parseInt(tabMatch.group(2));\n        tabData.add(new Pair<Integer, Integer>(offset, widthInColumns));\n      }\n      \n      mapper.rawAdd(visualLine, startOffset, endOffset, startLogicalLine, startLogicalColumn, endLogicalLine, endLogicalColumn, endVisualColumn, foldRegions, tabData);\n    }\n  }","id":65819,"modified_method":"/**\n   * Setups {@link Editor#getSoftWrapModel() soft wraps model} of the {@link #getEditor() current editor} according to the given text\n   * that is expected to contain information obtained from the {@link CachingSoftWrapDataMapper#toString()}.\n   *\n   * @param data  string representation of the target soft wraps cache\n   */\n  @SuppressWarnings(\"UnusedDeclaration\")\n  protected static void setupSoftWraps(@NotNull String data) {\n    Scanner scanner = new Scanner(data);\n    Pattern generalPattern =\n      Pattern.compile(\"visual line: (\\\\d+), offsets: (\\\\d+)-(\\\\d+), logical lines: (\\\\d+)-(\\\\d+), logical columns: (\\\\d+)-(\\\\d+), \"\n                      + \"end visual column: (\\\\d+), fold regions: \\\\[([^\\\\]]*)\\\\], tab data: \\\\[([^\\\\]]*)\\\\]\");\n    Pattern foldPattern = Pattern.compile(\"width in columns: (-?\\\\d+), fold region: FoldRegion [-+]\\\\((\\\\d+):(\\\\d+)\");\n    Pattern tabPattern = Pattern.compile(\"\\\\[(\\\\d+), width: (\\\\d+)\");\n    final SoftWrapModelImpl softWrapModel = (SoftWrapModelImpl)myEditor.getSoftWrapModel();\n    final CachingSoftWrapDataMapper mapper = softWrapModel.getDataMapper();\n    mapper.release();\n    final FoldingModelEx foldingModel = (FoldingModelEx)myEditor.getFoldingModel();\n    while (scanner.findInLine(generalPattern) != null) {\n      final MatchResult generalMatch = scanner.match();\n      int visualLine = Integer.parseInt(generalMatch.group(1));\n      int startOffset = Integer.parseInt(generalMatch.group(2));\n      int endOffset = Integer.parseInt(generalMatch.group(3));\n      int startLogicalLine = Integer.parseInt(generalMatch.group(4));\n      int endLogicalLine = Integer.parseInt(generalMatch.group(5));\n      int startLogicalColumn = Integer.parseInt(generalMatch.group(6));\n      int endLogicalColumn = Integer.parseInt(generalMatch.group(7));\n      int endVisualColumn = Integer.parseInt(generalMatch.group(8));\n      \n      List<Pair<Integer, FoldRegion>> foldRegions = new ArrayList<>();\n      Scanner foldScanner = new Scanner(generalMatch.group(9));\n      while (foldScanner.findInLine(foldPattern) != null) {\n        final MatchResult foldMatch = foldScanner.match();\n        int widthInColumns = Integer.parseInt(foldMatch.group(1));\n        int foldStartOffset = Integer.parseInt(foldMatch.group(2));\n        int foldEndOffset = Integer.parseInt(foldMatch.group(3));\n        FoldRegion region = null;\n        for (FoldRegion candidate : foldingModel.getAllFoldRegions()) {\n          if (candidate.getStartOffset() == foldStartOffset && candidate.getEndOffset() == foldEndOffset) {\n            region = candidate;\n            break;\n          }\n        }\n        foldRegions.add(new Pair<>(widthInColumns, region));\n      }\n      \n      List<Pair<Integer, Integer>> tabData = new ArrayList<>();\n      Scanner tabScanner = new Scanner(generalMatch.group(10));\n      while (tabScanner.findInLine(tabPattern) != null) {\n        final MatchResult tabMatch = tabScanner.match();\n        int offset = Integer.parseInt(tabMatch.group(1));\n        int widthInColumns = Integer.parseInt(tabMatch.group(2));\n        tabData.add(new Pair<>(offset, widthInColumns));\n      }\n      \n      mapper.rawAdd(visualLine, startOffset, endOffset, startLogicalLine, startLogicalColumn, endLogicalLine, endLogicalColumn, endVisualColumn, foldRegions, tabData);\n    }\n  }","commit_id":"64b924a99a25fb00125bf9088f90b6a1accf9111","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static FoldRegion addFoldRegion(final int startOffset, final int endOffset, final String placeholder) {\n    final FoldRegion[] result = new FoldRegion[1];\n    myEditor.getFoldingModel().runBatchFoldingOperation(new Runnable() {\n      @Override\n      public void run() {\n        result[0] = myEditor.getFoldingModel().addFoldRegion(startOffset, endOffset, placeholder);\n      }\n    });\n    return result[0];\n  }","id":65820,"modified_method":"protected static FoldRegion addFoldRegion(final int startOffset, final int endOffset, final String placeholder) {\n    final FoldRegion[] result = new FoldRegion[1];\n    myEditor.getFoldingModel().runBatchFoldingOperation(\n      () -> result[0] = myEditor.getFoldingModel().addFoldRegion(startOffset, endOffset, placeholder));\n    return result[0];\n  }","commit_id":"64b924a99a25fb00125bf9088f90b6a1accf9111","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Setups {@link Editor#getFoldingModel() folding model} of the {@link #getEditor() current editor} according to the given text\n   * that is expected to contain information obtained from the {@link FoldingModelImpl#toString()}.\n   * \n   * @param data  string representation of the target fold regions\n   */\n  protected static void setupFolding(@NotNull String data) {\n    Scanner scanner = new Scanner(data);\n    Pattern pattern = Pattern.compile(\"FoldRegion ([+-])\\\\((\\\\d+):(\\\\d+)\");\n    final List<Trinity<Boolean, Integer, Integer>> infos = new ArrayList<Trinity<Boolean, Integer, Integer>>();\n    while (scanner.findInLine(pattern) != null) {\n      final MatchResult match = scanner.match();\n      boolean expanded = \"-\".equals(match.group(1));\n      int startOffset = Integer.parseInt(match.group(2));\n      int endOffset = Integer.parseInt(match.group(3));\n      infos.add(new Trinity<Boolean, Integer, Integer>(expanded, startOffset, endOffset));\n    }\n    final FoldingModel foldingModel = myEditor.getFoldingModel();\n    foldingModel.runBatchFoldingOperation(new Runnable() {\n      @Override\n      public void run() {\n        for (Trinity<Boolean, Integer, Integer> info : infos) {\n          final FoldRegion region = foldingModel.addFoldRegion(info.second, info.third, \"...\");\n          assert region != null;\n          region.setExpanded(info.first);\n        }\n      }\n    });\n  }","id":65821,"modified_method":"/**\n   * Setups {@link Editor#getFoldingModel() folding model} of the {@link #getEditor() current editor} according to the given text\n   * that is expected to contain information obtained from the {@link FoldingModelImpl#toString()}.\n   * \n   * @param data  string representation of the target fold regions\n   */\n  protected static void setupFolding(@NotNull String data) {\n    Scanner scanner = new Scanner(data);\n    Pattern pattern = Pattern.compile(\"FoldRegion ([+-])\\\\((\\\\d+):(\\\\d+)\");\n    final List<Trinity<Boolean, Integer, Integer>> infos = new ArrayList<>();\n    while (scanner.findInLine(pattern) != null) {\n      final MatchResult match = scanner.match();\n      boolean expanded = \"-\".equals(match.group(1));\n      int startOffset = Integer.parseInt(match.group(2));\n      int endOffset = Integer.parseInt(match.group(3));\n      infos.add(new Trinity<>(expanded, startOffset, endOffset));\n    }\n    final FoldingModel foldingModel = myEditor.getFoldingModel();\n    foldingModel.runBatchFoldingOperation(() -> {\n      for (Trinity<Boolean, Integer, Integer> info : infos) {\n        final FoldRegion region = foldingModel.addFoldRegion(info.second, info.third, \"...\");\n        assert region != null;\n        region.setExpanded(info.first);\n      }\n    });\n  }","commit_id":"64b924a99a25fb00125bf9088f90b6a1accf9111","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static void foldOccurrences(String textToFoldRegexp, final String placeholder) {\n    final Matcher matcher = Pattern.compile(textToFoldRegexp).matcher(myEditor.getDocument().getCharsSequence());\n    myEditor.getFoldingModel().runBatchFoldingOperation(new Runnable() {\n      @Override\n      public void run() {\n        while (matcher.find()) {\n          FoldRegion foldRegion = myEditor.getFoldingModel().addFoldRegion(matcher.start(), matcher.end(), placeholder);\n          assertNotNull(foldRegion);\n          foldRegion.setExpanded(false);\n        }\n      }\n    });\n  }","id":65822,"modified_method":"protected static void foldOccurrences(String textToFoldRegexp, final String placeholder) {\n    final Matcher matcher = Pattern.compile(textToFoldRegexp).matcher(myEditor.getDocument().getCharsSequence());\n    myEditor.getFoldingModel().runBatchFoldingOperation(() -> {\n      while (matcher.find()) {\n        FoldRegion foldRegion = myEditor.getFoldingModel().addFoldRegion(matcher.start(), matcher.end(), placeholder);\n        assertNotNull(foldRegion);\n        foldRegion.setExpanded(false);\n      }\n    });\n  }","commit_id":"64b924a99a25fb00125bf9088f90b6a1accf9111","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void update() {\n    ModelAccess.assertLegalWrite();\n    SModuleBase module = (SModuleBase) getModule();\n    assert module != null;\n\n    Set<org.jetbrains.mps.openapi.model.SModelReference> loaded = new HashSet<org.jetbrains.mps.openapi.model.SModelReference>();\n    for (SModel model : loadModels()) {\n      //todo: check if model already registered\n      if (module.getModel(model.getModelId()) != model) {\n        register(model);\n      }\n      //if (model.getRepository() != null) {\n      //  register(model);\n      //}\n      loaded.add(model.getReference());\n    }\n    Iterator<SModel> it = myModels.iterator();\n    while (it.hasNext()) {\n      SModel model = it.next();\n      if (loaded.contains(model.getReference())) continue;\n      module.unregisterModel((SModelBase) model);\n      it.remove();\n    }\n  }","id":65823,"modified_method":"public void update() {\n    ModelAccess.assertLegalWrite();\n    SModuleBase module = (SModuleBase) getModule();\n    assert module != null;\n\n    Set<SModelId> loaded = new HashSet<SModelId>();\n    Iterable<SModel> allModels = loadModels();\n    for (SModel model : allModels) {\n      SModel oldModel = module.getModel(model.getModelId());\n      if (oldModel == null) {\n        register(model);\n      } else if (oldModel == model) {\n        //do nothing\n      } else if (oldModel.getModelRoot() != model.getModelRoot()) {\n        LOG.error(\"Trying to load model `\" + model.getModelName() + \"' which is already loaded by another model root\");\n      } else if (loaded.contains(model.getModelId())) {\n        LOG.error(\"loadModels() returned model `\" + model.getModelName() + \"' twice\");\n      } else {\n        LOG.warn(\"loadModels() loaded model `\" + model.getModelName() + \"' which was already loaded. Ignoring.\");\n      }\n      loaded.add(model.getModelId());\n    }\n    Iterator<SModel> it = myModels.iterator();\n    while (it.hasNext()) {\n      SModel model = it.next();\n      if (loaded.contains(model.getModelId())) continue;\n      module.unregisterModel((SModelBase) model);\n      it.remove();\n    }\n  }","commit_id":"90c2b14dc68ff90aca88478927bb7e61cb227da1","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void register(SModel model) {\n    SModuleBase module = (SModuleBase) getModule();\n    assert module != null;\n\n    if (module.getModel(model.getModelId()) == null) {\n      module.registerModel((SModelBase) model);\n      myModels.add(model);\n    } else {\n      LOG.error(\"Model `\" + model.getModelName() + \"' already presents in module `\" + module.getModuleName() + \"'.\", new Throwable());\n    }\n  }","id":65824,"modified_method":"protected void register(SModel model) {\n    SModuleBase module = (SModuleBase) getModule();\n    assert module != null;\n    assert module.getModel(model.getModelId()) == null;\n\n    module.registerModel((SModelBase) model);\n    myModels.add(model);\n  }","commit_id":"90c2b14dc68ff90aca88478927bb7e61cb227da1","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void unregister(SModel model) {\n    SModuleBase module = (SModuleBase) getModule();\n    assert module != null;\n\n    if (module.getModel(model.getModelId()) != null) {\n      module.unregisterModel((SModelBase) model);\n      myModels.remove(model);\n    } else {\n      LOG.error(\"Model `\" + model.getModelName() + \"' is not registered in module `\" + module.getModuleName() + \"'.\", new Throwable());\n    }\n  }","id":65825,"modified_method":"protected void unregister(SModel model) {\n    SModuleBase module = (SModuleBase) getModule();\n    assert module != null;\n    assert module.getModel(model.getModelId()) != null;\n    assert myModels.contains(model);\n\n    module.unregisterModel((SModelBase) model);\n    myModels.remove(model);\n  }","commit_id":"90c2b14dc68ff90aca88478927bb7e61cb227da1","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void forgetModule(SModule module) {\n    SModelReference modelReference = getModelReference(module);\n    GeneratorDescriptorModel dm = myModels.remove(modelReference);\n    if (dm != null) {\n      Generator generator = (Generator) module;\n      // FIXME project closed and re-open leaves stale models in myModels, with getModule() != the new one, and assertion fails\n      // Note, dm.getModule().getRepository == null\n//      assert dm.getModule() == generator;\n      if (dm.getModule() == generator) {\n        generator.unregisterModel(dm);\n      }\n    }\n  }","id":65826,"modified_method":"@Override\n  public void forgetModule(SModule module) {\n    SModelReference modelReference = getModelReference(module);\n    // generator.unregisterModel below triggers module changed (to be precise, modelRemoved) event, and we may\n    // get into #refreshModule() above again, hence it's safe not to remove entry from the map unless all events have been sent\n    // (even provided we do our best in DescriptorModelComponent not to send refresh for added/removed descriptor models)\n    GeneratorDescriptorModel dm = myModels.get(modelReference);\n    if (dm != null) {\n      Generator generator = (Generator) module;\n      assert dm.getModule() == generator;\n      generator.unregisterModel(dm);\n      myModels.remove(modelReference);\n    }\n  }","commit_id":"bb13513e0d0de8ce21e0d876893f63ecb99cd927","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void dispose() {\n    SModuleBase module = (SModuleBase) getModule();\n\n    for (SModel model : myModels) {\n      if (model.getReference().resolve(myRepository) != null) {\n        LOG.error(\"Trying to dispose model `\" + model.getModelName() + \"` which was not previously removed from repository.\");\n        continue;\n      }\n      if (module != null) {\n        module.unregisterModel((SModelBase) model);\n      }\n    }\n    myModels.clear();\n    myRepository = null;\n  }","id":65827,"modified_method":"public void dispose() {\n    SModuleBase module = (SModuleBase) getModule();\n\n    for (SModel model : myModels) {\n      assert module != null;\n      assert module.getModel(model.getModelId()) != null;\n\n      module.unregisterModel((SModelBase) model);\n    }\n    myModels.clear();\n    myRepository = null;\n  }","commit_id":"834f01e24fa8d4313d806b0db93dbf9e0d1673e9","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * Read all model files from the directory in alphabetical order.\n     * Only files ending with .txt or .model are read.\n     *\n     * @param project The current maven project\n     * @param modelDirectory The directory to scan for models\n     * @param logger The logger\n     */\n    protected Model readLocalModel(\n            final MavenProject project,\n            final String inlinedModel,\n            final File modelDirectory,\n            final Logger logger)\n    throws MavenExecutionException, IOException {\n        final List<String> candidates = new ArrayList<String>();\n        if ( modelDirectory != null && modelDirectory.exists() ) {\n            for(final File f : modelDirectory.listFiles() ) {\n                if ( f.isFile() && !f.getName().startsWith(\".\") ) {\n                    if ( f.getName().endsWith(\".txt\") || f.getName().endsWith(\".model\") ) {\n                        candidates.add(f.getName());\n                    }\n                }\n            }\n            Collections.sort(candidates);\n        }\n        if ( candidates.size() == 0 && (inlinedModel == null || inlinedModel.trim().length() == 0) ) {\n            throw new MavenExecutionException(\"No model files found in \" + modelDirectory + \", and no model inlined in POM.\", (File)null);\n        }\n        final Model result = new Model();\n        if ( inlinedModel != null ) {\n            logger.debug(\"Reading inlined model from project \" + project.getId());\n            try {\n                final Reader reader = new StringReader(inlinedModel);\n                try {\n                    final Model current = ModelReader.read(reader, \"pom\");\n                    final Map<Traceable, String> errors = ModelUtility.validate(current);\n                    if (errors != null ) {\n                        throw new MavenExecutionException(\"Invalid inlined model : \" + errors, (File)null);\n                    }\n                    ModelUtility.merge(result, current, false);\n                } finally {\n                    IOUtils.closeQuietly(reader);\n                }\n            } catch ( final IOException io) {\n                throw new MavenExecutionException(\"Unable to read inlined model\", io);\n            }\n        }\n        for(final String name : candidates) {\n            logger.debug(\"Reading model \" + name + \" in project \" + project.getId());\n            try {\n                final File f = new File(modelDirectory, name);\n                final FileReader reader = new FileReader(f);\n                try {\n                    final Model current = ModelReader.read(reader, f.getAbsolutePath());\n                    final Map<Traceable, String> errors = ModelUtility.validate(current);\n                    if (errors != null ) {\n                        throw new MavenExecutionException(\"Invalid model at \" + name + \" : \" + errors, (File)null);\n                    }\n                    ModelUtility.merge(result, current, false);\n                } finally {\n                    IOUtils.closeQuietly(reader);\n                }\n            } catch ( final IOException io) {\n                throw new MavenExecutionException(\"Unable to read model at \" + name, io);\n            }\n        }\n\n        final Map<Traceable, String> errors = ModelUtility.validate(result);\n        if (errors != null ) {\n            throw new MavenExecutionException(\"Invalid assembled model : \" + errors, (File)null);\n        }\n\n        return postProcessReadModel(result);\n    }","id":65828,"modified_method":"/**\n     * Read all model files from the directory in alphabetical order.\n     * Only files ending with .txt or .model are read.\n     *\n     * @param project The current maven project\n     * @param modelDirectory The directory to scan for models\n     * @param logger The logger\n     */\n    protected Model readLocalModel(\n            final MavenProject project,\n            final String inlinedModel,\n            final File modelDirectory,\n            final String pattern,\n            final Logger logger)\n    throws MavenExecutionException, IOException {\n        final Pattern p = Pattern.compile(pattern);\n        final List<String> candidates = new ArrayList<String>();\n        if ( modelDirectory != null && modelDirectory.exists() ) {\n            for(final File f : modelDirectory.listFiles() ) {\n                if ( f.isFile() && !f.getName().startsWith(\".\") ) {\n                    if ( p.matcher(f.getName()).matches() ) {\n                        candidates.add(f.getName());\n                    }\n                }\n            }\n            Collections.sort(candidates);\n        }\n        if ( candidates.size() == 0 && (inlinedModel == null || inlinedModel.trim().length() == 0) ) {\n            throw new MavenExecutionException(\"No model files found in \" + modelDirectory + \", and no model inlined in POM.\", (File)null);\n        }\n        final Model result = new Model();\n        if ( inlinedModel != null ) {\n            logger.debug(\"Reading inlined model from project \" + project.getId());\n            try {\n                final Reader reader = new StringReader(inlinedModel);\n                try {\n                    final Model current = ModelReader.read(reader, \"pom\");\n                    final Map<Traceable, String> errors = ModelUtility.validate(current);\n                    if (errors != null ) {\n                        throw new MavenExecutionException(\"Invalid inlined model : \" + errors, (File)null);\n                    }\n                    ModelUtility.merge(result, current, false);\n                } finally {\n                    IOUtils.closeQuietly(reader);\n                }\n            } catch ( final IOException io) {\n                throw new MavenExecutionException(\"Unable to read inlined model\", io);\n            }\n        }\n        for(final String name : candidates) {\n            logger.debug(\"Reading model \" + name + \" in project \" + project.getId());\n            try {\n                final File f = new File(modelDirectory, name);\n                final FileReader reader = new FileReader(f);\n                try {\n                    final Model current = ModelReader.read(reader, f.getAbsolutePath());\n                    final Map<Traceable, String> errors = ModelUtility.validate(current);\n                    if (errors != null ) {\n                        throw new MavenExecutionException(\"Invalid model at \" + name + \" : \" + errors, (File)null);\n                    }\n                    ModelUtility.merge(result, current, false);\n                } finally {\n                    IOUtils.closeQuietly(reader);\n                }\n            } catch ( final IOException io) {\n                throw new MavenExecutionException(\"Unable to read model at \" + name, io);\n            }\n        }\n\n        final Map<Traceable, String> errors = ModelUtility.validate(result);\n        if (errors != null ) {\n            throw new MavenExecutionException(\"Invalid assembled model : \" + errors, (File)null);\n        }\n\n        return postProcessReadModel(result);\n    }","commit_id":"4374bb6a9e40ee1006d73584ac8e6ef5f25a3cfd","url":"https://github.com/apache/sling"},{"original_method":"private Model addDependencies(final Environment env, final ProjectInfo info)\n    throws MavenExecutionException {\n        if ( info.done == true ) {\n            env.logger.debug(\"Return prepared model for \" + info.project);\n            return info.model;\n        }\n        // prevent recursion and multiple processing\n        info.done = true;\n        env.logger.debug(\"Processing project \" + info.project);\n\n        // read local model\n        final String directory = nodeValue(info.plugin,\n                \"modelDirectory\",\n                new File(info.project.getBasedir(), \"src/main/provisioning\").getAbsolutePath());\n        final String inlinedModel = nodeValue(info.plugin,\n                \"model\", null);\n        try {\n            info.localModel = readLocalModel(info.project, inlinedModel, new File(directory), env.logger);\n        } catch ( final IOException ioe) {\n            throw new MavenExecutionException(ioe.getMessage(), ioe);\n        }\n\n        // prepare resolver options\n        ResolverOptions resolverOptions = new ResolverOptions();\n        if (nodeBooleanValue(info.plugin, \"usePomVariables\", false)) {\n            resolverOptions.variableResolver(new PomVariableResolver(info.project));\n        }\n        if (nodeBooleanValue(info.plugin, \"usePomDependencies\", false)) {\n            resolverOptions.artifactVersionResolver(new PomArtifactVersionResolver(info.project,\n                    nodeBooleanValue(info.plugin, \"allowUnresolvedPomDependencies\", false)));\n        }\n\n        // we have to create an effective model to add the dependencies\n        final Model effectiveModel = ModelUtility.getEffectiveModel(info.localModel, resolverOptions);\n\n        final List<Model> dependencies = searchSlingstartDependencies(env, info, info.localModel, effectiveModel);\n        info.model = new Model();\n        for(final Model d : dependencies) {\n            this.mergeModels(info.model, d);\n        }\n        this.mergeModels(info.model, info.localModel);\n        info.localModel = info.model;\n        info.model = ModelUtility.getEffectiveModel(info.model, resolverOptions);\n\n        final Map<Traceable, String> errors = ModelUtility.validate(info.model);\n        if ( errors != null ) {\n            throw new MavenExecutionException(\"Unable to create model file for \" + info.project + \" : \" + errors, (File)null);\n        }\n\n        addDependenciesFromModel(env, info);\n\n        try {\n           ProjectHelper.storeProjectInfo(info);\n        } catch ( final IOException ioe) {\n            throw new MavenExecutionException(ioe.getMessage(), ioe);\n        }\n        return info.model;\n    }","id":65829,"modified_method":"private Model addDependencies(final Environment env, final ProjectInfo info)\n    throws MavenExecutionException {\n        if ( info.done == true ) {\n            env.logger.debug(\"Return prepared model for \" + info.project);\n            return info.model;\n        }\n        // prevent recursion and multiple processing\n        info.done = true;\n        env.logger.debug(\"Processing project \" + info.project);\n\n        // read local model\n        final String directory = nodeValue(info.plugin,\n                \"modelDirectory\",\n                new File(info.project.getBasedir(), \"src/main/provisioning\").getAbsolutePath());\n        final String pattern = nodeValue(info.plugin,\n                \"modelPattern\", \"((.*)\\\\.txt|(.*)\\\\.model)\");\n\n        final String inlinedModel = nodeValue(info.plugin,\n                \"model\", null);\n        try {\n            info.localModel = readLocalModel(info.project, inlinedModel, new File(directory), pattern, env.logger);\n        } catch ( final IOException ioe) {\n            throw new MavenExecutionException(ioe.getMessage(), ioe);\n        }\n\n        // prepare resolver options\n        ResolverOptions resolverOptions = new ResolverOptions();\n        if (nodeBooleanValue(info.plugin, \"usePomVariables\", false)) {\n            resolverOptions.variableResolver(new PomVariableResolver(info.project));\n        }\n        if (nodeBooleanValue(info.plugin, \"usePomDependencies\", false)) {\n            resolverOptions.artifactVersionResolver(new PomArtifactVersionResolver(info.project,\n                    nodeBooleanValue(info.plugin, \"allowUnresolvedPomDependencies\", false)));\n        }\n\n        // we have to create an effective model to add the dependencies\n        final Model effectiveModel = ModelUtility.getEffectiveModel(info.localModel, resolverOptions);\n\n        final List<Model> dependencies = searchSlingstartDependencies(env, info, info.localModel, effectiveModel);\n        info.model = new Model();\n        for(final Model d : dependencies) {\n            this.mergeModels(info.model, d);\n        }\n        this.mergeModels(info.model, info.localModel);\n        info.localModel = info.model;\n        info.model = ModelUtility.getEffectiveModel(info.model, resolverOptions);\n\n        final Map<Traceable, String> errors = ModelUtility.validate(info.model);\n        if ( errors != null ) {\n            throw new MavenExecutionException(\"Unable to create model file for \" + info.project + \" : \" + errors, (File)null);\n        }\n\n        addDependenciesFromModel(env, info);\n\n        try {\n           ProjectHelper.storeProjectInfo(info);\n        } catch ( final IOException ioe) {\n            throw new MavenExecutionException(ioe.getMessage(), ioe);\n        }\n        return info.model;\n    }","commit_id":"4374bb6a9e40ee1006d73584ac8e6ef5f25a3cfd","url":"https://github.com/apache/sling"},{"original_method":"private static SimpleTestClassModel testModel(\n            @NotNull String rootPath,\n            boolean recursive,\n            @NotNull String extension,\n            @NotNull String doTestMethodName\n    ) {\n        return new SimpleTestClassModel(new File(rootPath), recursive, extension, doTestMethodName);\n    }","id":65830,"modified_method":"private static SimpleTestClassModel testModel(\n            @NotNull String rootPath,\n            boolean recursive,\n            @NotNull String extension,\n            @NotNull String doTestMethodName\n    ) {\n        return new SimpleTestClassModel(new File(rootPath), recursive, Pattern.compile(\"^(.+)\\\\.\" + extension + \"$\"), doTestMethodName);\n    }","commit_id":"3cf2289687c1af7f89855bd49c0c23dec625eb58","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static void assertAllTestsPresentByMetadata(\n            @NotNull Class<?> testCaseClass,\n            @NotNull String generatorClassFqName,\n            @NotNull File testDataDir,\n            @NotNull String extension,\n            boolean recursive\n    ) {\n        TestMetadata testClassMetadata = testCaseClass.getAnnotation(TestMetadata.class);\n        Assert.assertNotNull(\"No metadata for class: \" + testCaseClass, testClassMetadata);\n        String rootPath = testClassMetadata.value();\n        File rootFile = new File(rootPath);\n\n\n        Set<String> filePaths = Sets.newHashSet();\n        for (Method method : testCaseClass.getDeclaredMethods()) {\n            TestMetadata testMetadata = method.getAnnotation(TestMetadata.class);\n            if (testMetadata != null) {\n                filePaths.add(testMetadata.value());\n            }\n        }\n        File[] files = testDataDir.listFiles();\n        if (files != null) {\n            for (File file : files) {\n                if (file.isDirectory()) {\n                    if (recursive && containsTestData(file, extension)) {\n                        assertTestClassPresentByMetadata(testCaseClass, generatorClassFqName, file);\n                    }\n                }\n                else {\n                    if (file.getName().endsWith(\".\" + extension)) {\n                        String relativePath = FileUtil.getRelativePath(rootFile, file);\n                        if (!filePaths.contains(relativePath)) {\n                            Assert.fail(\"Test data file missing from the generated test class: \" +\n                                        file +\n                                        pleaseReRunGenerator(generatorClassFqName));\n                        }\n                    }\n                }\n            }\n        }\n    }","id":65831,"modified_method":"public static void assertAllTestsPresentByMetadata(\n            @NotNull Class<?> testCaseClass,\n            @NotNull String generatorClassFqName,\n            @NotNull File testDataDir,\n            @NotNull Pattern filenamePattern,\n            boolean recursive\n    ) {\n        TestMetadata testClassMetadata = testCaseClass.getAnnotation(TestMetadata.class);\n        Assert.assertNotNull(\"No metadata for class: \" + testCaseClass, testClassMetadata);\n        String rootPath = testClassMetadata.value();\n        File rootFile = new File(rootPath);\n\n\n        Set<String> filePaths = Sets.newHashSet();\n        for (Method method : testCaseClass.getDeclaredMethods()) {\n            TestMetadata testMetadata = method.getAnnotation(TestMetadata.class);\n            if (testMetadata != null) {\n                filePaths.add(testMetadata.value());\n            }\n        }\n        File[] files = testDataDir.listFiles();\n        if (files != null) {\n            for (File file : files) {\n                if (file.isDirectory()) {\n                    if (recursive && containsTestData(file, filenamePattern)) {\n                        assertTestClassPresentByMetadata(testCaseClass, generatorClassFqName, file);\n                    }\n                }\n                else {\n                    if (filenamePattern.matcher(file.getName()).matches()) {\n                        String relativePath = FileUtil.getRelativePath(rootFile, file);\n                        if (!filePaths.contains(relativePath)) {\n                            Assert.fail(\"Test data file missing from the generated test class: \" +\n                                        file +\n                                        pleaseReRunGenerator(generatorClassFqName));\n                        }\n                    }\n                }\n            }\n        }\n    }","commit_id":"3cf2289687c1af7f89855bd49c0c23dec625eb58","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static boolean containsTestData(File dir, String extension) {\n        File[] files = dir.listFiles();\n        assert files != null;\n        for (File file : files) {\n            if (file.isDirectory()) {\n                if (containsTestData(file, extension)) {\n                    return true;\n                }\n            }\n            else {\n                if (FileUtil.getExtension(file.getName()).equals(extension)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","id":65832,"modified_method":"private static boolean containsTestData(File dir, Pattern filenamePattern) {\n        File[] files = dir.listFiles();\n        assert files != null;\n        for (File file : files) {\n            if (file.isDirectory()) {\n                if (containsTestData(file, filenamePattern)) {\n                    return true;\n                }\n            }\n            else {\n                if (filenamePattern.matcher(file.getName()).matches()) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","commit_id":"3cf2289687c1af7f89855bd49c0c23dec625eb58","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public SimpleTestClassModel(@NotNull File rootFile, boolean recursive, @NotNull String extension, @NotNull String doTestMethodName) {\n        this.rootFile = rootFile;\n        this.recursive = recursive;\n        this.extension = extension;\n        this.doTestMethodName = doTestMethodName;\n        this.testClassName = StringUtil.capitalize(TestGeneratorUtil.escapeForJavaIdentifier(rootFile.getName()));\n    }","id":65833,"modified_method":"public SimpleTestClassModel(@NotNull File rootFile, boolean recursive, @NotNull Pattern filenamePattern, @NotNull String doTestMethodName) {\n        this.rootFile = rootFile;\n        this.recursive = recursive;\n        this.filenamePattern = filenamePattern;\n        this.doTestMethodName = doTestMethodName;\n        this.testClassName = StringUtil.capitalize(TestGeneratorUtil.escapeForJavaIdentifier(rootFile.getName()));\n    }","commit_id":"3cf2289687c1af7f89855bd49c0c23dec625eb58","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public Collection<TestClassModel> getInnerTestClasses() {\n        if (!rootFile.isDirectory() || !recursive) {\n            return Collections.emptyList();\n        }\n        if (innerTestClasses == null) {\n            List<TestClassModel> children = Lists.newArrayList();\n            File[] files = rootFile.listFiles();\n            if (files != null) {\n                for (File file : files) {\n                    if (file.isDirectory()) {\n                        children.add(new SimpleTestClassModel(file, recursive, extension, doTestMethodName));\n                    }\n                }\n            }\n            Collections.sort(children, BY_NAME);\n            innerTestClasses = children;\n        }\n        return innerTestClasses;\n    }","id":65834,"modified_method":"@NotNull\n    @Override\n    public Collection<TestClassModel> getInnerTestClasses() {\n        if (!rootFile.isDirectory() || !recursive) {\n            return Collections.emptyList();\n        }\n        if (innerTestClasses == null) {\n            List<TestClassModel> children = Lists.newArrayList();\n            File[] files = rootFile.listFiles();\n            if (files != null) {\n                for (File file : files) {\n                    if (file.isDirectory()) {\n                        children.add(new SimpleTestClassModel(file, recursive, filenamePattern, doTestMethodName));\n                    }\n                }\n            }\n            Collections.sort(children, BY_NAME);\n            innerTestClasses = children;\n        }\n        return innerTestClasses;\n    }","commit_id":"3cf2289687c1af7f89855bd49c0c23dec625eb58","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n        public void generateBody(@NotNull Printer p, @NotNull String generatorClassFqName) {\n            String assertTestsPresentStr =\n                    String.format(\"JetTestUtils.assertAllTestsPresentByMetadata(this.getClass(), \\\"%s\\\", new File(\\\"%s\\\"), \\\"%s\\\", %s);\",\n                                  generatorClassFqName, JetTestUtils.getFilePath(rootFile), extension, recursive);\n            p.println(assertTestsPresentStr);\n        }","id":65835,"modified_method":"@Override\n        public void generateBody(@NotNull Printer p, @NotNull String generatorClassFqName) {\n            String assertTestsPresentStr =\n                    String.format(\"JetTestUtils.assertAllTestsPresentByMetadata(this.getClass(), \\\"%s\\\", new File(\\\"%s\\\"), Pattern.compile(\\\"%s\\\"), %s);\",\n                                  generatorClassFqName, JetTestUtils.getFilePath(rootFile), StringUtil.escapeStringCharacters(filenamePattern.pattern()), recursive);\n            p.println(assertTestsPresentStr);\n        }","commit_id":"3cf2289687c1af7f89855bd49c0c23dec625eb58","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public Collection<TestMethodModel> getTestMethods() {\n        if (testMethods == null) {\n            if (!rootFile.isDirectory()) {\n                testMethods = Collections.<TestMethodModel>singletonList(new SimpleTestMethodModel(rootFile, rootFile, doTestMethodName));\n            }\n            else {\n                List<TestMethodModel> result = Lists.newArrayList();\n\n                result.add(new TestAllFilesPresentMethodModel());\n\n                File[] listFiles = rootFile.listFiles();\n                if (listFiles != null) {\n                    for (File file : listFiles) {\n                        if (!file.isDirectory() && file.getName().endsWith(\".\" + extension)) {\n                            result.add(new SimpleTestMethodModel(rootFile, file, doTestMethodName));\n                        }\n                    }\n                }\n                Collections.sort(result, BY_NAME);\n\n                testMethods = result;\n            }\n        }\n        return testMethods;\n    }","id":65836,"modified_method":"@NotNull\n    @Override\n    public Collection<TestMethodModel> getTestMethods() {\n        if (testMethods == null) {\n            if (!rootFile.isDirectory()) {\n                testMethods = Collections.<TestMethodModel>singletonList(new SimpleTestMethodModel(rootFile, rootFile, doTestMethodName, filenamePattern));\n            }\n            else {\n                List<TestMethodModel> result = Lists.newArrayList();\n\n                result.add(new TestAllFilesPresentMethodModel());\n\n                File[] listFiles = rootFile.listFiles();\n                if (listFiles != null) {\n                    for (File file : listFiles) {\n                        if (!file.isDirectory() && filenamePattern.matcher(file.getName()).matches()) {\n                            result.add(new SimpleTestMethodModel(rootFile, file, doTestMethodName, filenamePattern));\n                        }\n                    }\n                }\n                Collections.sort(result, BY_NAME);\n\n                testMethods = result;\n            }\n        }\n        return testMethods;\n    }","commit_id":"3cf2289687c1af7f89855bd49c0c23dec625eb58","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public SimpleTestMethodModel(File rootDir, File file, String doTestMethodName) {\n        this.rootDir = rootDir;\n        this.file = file;\n        this.doTestMethodName = doTestMethodName;\n    }","id":65837,"modified_method":"public SimpleTestMethodModel(File rootDir, File file, String doTestMethodName, Pattern filenamePattern) {\n        this.rootDir = rootDir;\n        this.file = file;\n        this.doTestMethodName = doTestMethodName;\n        this.filenamePattern = filenamePattern;\n    }","commit_id":"3cf2289687c1af7f89855bd49c0c23dec625eb58","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void generateAndSave() throws IOException {\n        StringBuilder out = new StringBuilder();\n        Printer p = new Printer(out);\n\n        p.println(FileUtil.loadFile(new File(\"injector-generator/copyright.txt\")));\n        p.println(\"package \", suiteClassPackage, \";\");\n        p.println();\n        for (String importedClassName : JUNIT3_IMPORTS) {\n            p.println(\"import \", importedClassName, \";\");\n        }\n        p.println();\n\n        p.println(\"import java.io.File;\");\n        p.println(\"import org.jetbrains.jet.JetTestUtils;\");\n        p.println(\"import org.jetbrains.jet.test.InnerTestClasses;\");\n        p.println(\"import org.jetbrains.jet.test.TestMetadata;\");\n        p.println();\n\n        p.println(\"import \", baseTestClassPackage, \".\", baseTestClassName, \";\");\n        p.println();\n\n        p.println(\"/** This class is generated by {@link \", generatorName, \"}. DO NOT MODIFY MANUALLY */\");\n\n        generateSuppressAllWarnings(p);\n        if (testClassModels.size() == 1) {\n            TestClassModel theOnlyTestClass = testClassModels.iterator().next();\n            generateTestClass(p, new DelegatingTestClassModel(theOnlyTestClass) {\n                @Override\n                public String getName() {\n                    return suiteClassName;\n                }\n            }, false);\n        }\n        else {\n            generateTestClass(p, new TestClassModel() {\n                @NotNull\n                @Override\n                public Collection<TestClassModel> getInnerTestClasses() {\n                    return testClassModels;\n                }\n\n                @NotNull\n                @Override\n                public Collection<TestMethodModel> getTestMethods() {\n                    return Collections.emptyList();\n                }\n\n                @Override\n                public boolean isEmpty() {\n                    return false;\n                }\n\n                @Override\n                public String getName() {\n                    return suiteClassName;\n                }\n\n                @Override\n                public String getDataString() {\n                    return null;\n                }\n            }, false);\n        }\n\n        String testSourceFilePath = baseDir + \"/\" + suiteClassPackage.replace(\".\", \"/\") + \"/\" + suiteClassName + \".java\";\n        File testSourceFile = new File(testSourceFilePath);\n        FileUtil.writeToFile(testSourceFile, out.toString());\n\n        //noinspection UseOfSystemOutOrSystemErr\n        System.out.println(\"Output written to file:\\n\" + testSourceFile.getAbsolutePath());\n    }","id":65838,"modified_method":"public void generateAndSave() throws IOException {\n        StringBuilder out = new StringBuilder();\n        Printer p = new Printer(out);\n\n        p.println(FileUtil.loadFile(new File(\"injector-generator/copyright.txt\")));\n        p.println(\"package \", suiteClassPackage, \";\");\n        p.println();\n        for (String importedClassName : JUNIT3_IMPORTS) {\n            p.println(\"import \", importedClassName, \";\");\n        }\n        p.println();\n\n        p.println(\"import java.io.File;\");\n        p.println(\"import java.util.regex.Pattern;\");\n        p.println(\"import org.jetbrains.jet.JetTestUtils;\");\n        p.println(\"import org.jetbrains.jet.test.InnerTestClasses;\");\n        p.println(\"import org.jetbrains.jet.test.TestMetadata;\");\n        p.println();\n\n        p.println(\"import \", baseTestClassPackage, \".\", baseTestClassName, \";\");\n        p.println();\n\n        p.println(\"/** This class is generated by {@link \", generatorName, \"}. DO NOT MODIFY MANUALLY */\");\n\n        generateSuppressAllWarnings(p);\n        if (testClassModels.size() == 1) {\n            TestClassModel theOnlyTestClass = testClassModels.iterator().next();\n            generateTestClass(p, new DelegatingTestClassModel(theOnlyTestClass) {\n                @Override\n                public String getName() {\n                    return suiteClassName;\n                }\n            }, false);\n        }\n        else {\n            generateTestClass(p, new TestClassModel() {\n                @NotNull\n                @Override\n                public Collection<TestClassModel> getInnerTestClasses() {\n                    return testClassModels;\n                }\n\n                @NotNull\n                @Override\n                public Collection<TestMethodModel> getTestMethods() {\n                    return Collections.emptyList();\n                }\n\n                @Override\n                public boolean isEmpty() {\n                    return false;\n                }\n\n                @Override\n                public String getName() {\n                    return suiteClassName;\n                }\n\n                @Override\n                public String getDataString() {\n                    return null;\n                }\n            }, false);\n        }\n\n        String testSourceFilePath = baseDir + \"/\" + suiteClassPackage.replace(\".\", \"/\") + \"/\" + suiteClassName + \".java\";\n        File testSourceFile = new File(testSourceFilePath);\n        FileUtil.writeToFile(testSourceFile, out.toString());\n\n        //noinspection UseOfSystemOutOrSystemErr\n        System.out.println(\"Output written to file:\\n\" + testSourceFile.getAbsolutePath());\n    }","commit_id":"3cf2289687c1af7f89855bd49c0c23dec625eb58","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static boolean isUpdateable(Resource resource) {\n        return (getVersion(resource).getQualifier().endsWith(SNAPSHOT) || getUri(resource).startsWith(BLUEPRINT_PREFIX) || getUri(resource).startsWith(SPRING_PREFIX));\n    }","id":65839,"modified_method":"private static boolean isUpdateable(Resource resource) {\n        return (getVersion(resource).getQualifier().endsWith(SNAPSHOT) || SNAPSHOT_PATTERN.matcher(getUri(resource)).matches() || getUri(resource).startsWith(BLUEPRINT_PREFIX) || getUri(resource).startsWith(SPRING_PREFIX));\n    }","commit_id":"becc055c9ac3e79615faf75594a274ce4066225c","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private static boolean isUpdateable(Bundle bundle) {\n        return (bundle.getLocation().endsWith(SNAPSHOT) || bundle.getLocation().startsWith(BLUEPRINT_PREFIX) || bundle.getLocation().startsWith(SPRING_PREFIX));\n    }","id":65840,"modified_method":"private static boolean isUpdateable(Bundle bundle) {\n        return (SNAPSHOT_PATTERN.matcher(bundle.getLocation()).matches() || bundle.getLocation().startsWith(BLUEPRINT_PREFIX) || bundle.getLocation().startsWith(SPRING_PREFIX));\n    }","commit_id":"becc055c9ac3e79615faf75594a274ce4066225c","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * @see org.opencms.workplace.list.A_CmsListDialog#setMultiActions(org.opencms.workplace.list.CmsListMetadata)\n     */\n    protected void setMultiActions(CmsListMetadata metadata) {\n\n        // add multi actions\n        // metadata.addDirectMultiAction(deleteAction);\n        // metadata.addDirectMultiAction(activateJob);\n    }","id":65841,"modified_method":"/**\n     * @see org.opencms.workplace.list.A_CmsListDialog#setMultiActions(org.opencms.workplace.list.CmsListMetadata)\n     */\n    protected void setMultiActions(CmsListMetadata metadata) {\n        \n        // add the activate job multi action\n        CmsListMultiAction activateJob = new CmsListMultiAction(LIST_ID, LIST_ACTION_MACTIVATE);\n        activateJob.setName(Messages.get().container(Messages.GUI_JOBS_LIST_ACTION_MACTIVATE_NAME_0));\n        activateJob.setConfirmationMessage(Messages.get().container(Messages.GUI_JOBS_LIST_ACTION_MACTIVATE_CONF_0));\n        activateJob.setIconPath(\"buttons/apply.gif\");\n        activateJob.setEnabled(true);\n        activateJob.setHelpText(Messages.get().container(Messages.GUI_JOBS_LIST_ACTION_MACTIVATE_HELP_0));\n        metadata.addMultiAction(activateJob);\n        \n        // add the deactivate job multi action\n        CmsListMultiAction deactivateJob = new CmsListMultiAction(LIST_ID, LIST_ACTION_MDEACTIVATE);\n        deactivateJob.setName(Messages.get().container(Messages.GUI_JOBS_LIST_ACTION_MDEACTIVATE_NAME_0));\n        deactivateJob.setConfirmationMessage(Messages.get().container(Messages.GUI_JOBS_LIST_ACTION_MDEACTIVATE_CONF_0));\n        deactivateJob.setIconPath(\"buttons/apply_in.gif\");\n        deactivateJob.setEnabled(true);\n        deactivateJob.setHelpText(Messages.get().container(Messages.GUI_JOBS_LIST_ACTION_MDEACTIVATE_HELP_0));\n        metadata.addMultiAction(deactivateJob);\n        \n        // add the delete job multi action\n        CmsListMultiAction deleteJobs = new CmsListMultiAction(LIST_ID, LIST_ACTION_MDELETE);\n        deleteJobs.setName(Messages.get().container(Messages.GUI_JOBS_LIST_ACTION_MDELETE_NAME_0));\n        deleteJobs.setConfirmationMessage(Messages.get().container(Messages.GUI_JOBS_LIST_ACTION_MDELETE_CONF_0));\n        deleteJobs.setIconPath(\"list/delete.gif\");\n        deleteJobs.setEnabled(true);\n        deleteJobs.setHelpText(Messages.get().container(Messages.GUI_JOBS_LIST_ACTION_MDELETE_HELP_0));\n        metadata.addMultiAction(deleteJobs);\n    }","commit_id":"2ce7506a0aed39fdaa00f755a18ccf5ad5092d58","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * This method should handle every defined list single action,\n     * by comparing <code>{@link #getParamListAction()}<\/code> with the id \n     * of the action to execute.<p> \n     */\n    public void executeListSingleActions() {\n\n        if (getParamListAction().equals(LIST_ACTION_EDIT)) {\n            String jobId = getSelectedItem().getId();\n            try {\n                // forward to the edit job screen\n                Map params = new HashMap();\n                params.put(\"jobId\", jobId);\n                getToolManager().jspRedirectTool(this, \"/jobs/edit\", params);\n            } catch (IOException e) {\n                // should never happen\n                throw new RuntimeException(e);\n            }\n        } else if (getParamListAction().equals(LIST_ACTION_ACTIVATE)) {\n            // execute the activate action\n            CmsListItem listItem = getSelectedItem();\n            try {\n                String jobId = listItem.getId();\n                CmsScheduledJobInfo job = OpenCms.getScheduleManager().getJob(jobId);\n                if (job.isActive()) {\n                    job.setActive(false);\n                } else {\n                    job.setActive(true);\n                }\n                OpenCms.getScheduleManager().scheduleJob(getCms(), job);\n            } catch (CmsException e) {\n                throw new RuntimeException(e);\n            }\n        } else {\n            throwListUnsupportedActionException();\n        }\n        listSave();\n    }","id":65842,"modified_method":"/**\n     * This method should handle every defined list single action,\n     * by comparing <code>{@link #getParamListAction()}<\/code> with the id \n     * of the action to execute.<p> \n     */\n    public void executeListSingleActions() {\n\n        if (getParamListAction().equals(LIST_ACTION_EDIT)) {\n            // edit a job from the list\n            String jobId = getSelectedItem().getId();\n            try {\n                // forward to the edit job screen\n                Map params = new HashMap();\n                params.put(\"jobId\", jobId);          \n                getToolManager().jspRedirectTool(this, \"/jobs/edit\", params);\n            } catch (IOException e) {\n                // should never happen\n                throw new RuntimeException(e);\n            }\n        } else if (getParamListAction().equals(LIST_ACTION_COPY)) {\n            // copy a job from the list\n            String jobId = getSelectedItem().getId();\n            CmsScheduledJobInfo job = (CmsScheduledJobInfo)OpenCms.getScheduleManager().getJob(jobId).clone();\n            job.setActive(true);\n            // copy action has to be implemented!!\n            int warn = 0;\n        } else if (getParamListAction().equals(LIST_ACTION_ACTIVATE)) {\n            // activate a job from the list\n            String jobId = getSelectedItem().getId();\n            CmsScheduledJobInfo job = (CmsScheduledJobInfo)OpenCms.getScheduleManager().getJob(jobId).clone();\n            job.setActive(true);\n            try {\n                OpenCms.getScheduleManager().scheduleJob(getCms(), job);\n                refreshList();\n            } catch (CmsSchedulerException e) {\n                // TODO: exception handling\n            } catch (CmsRoleViolationException e) {\n                // TODO: exception handling\n            }\n        } else if (getParamListAction().equals(LIST_ACTION_DEACTIVATE)) {\n            // deactivate a job from the list\n            String jobId = getSelectedItem().getId();\n            CmsScheduledJobInfo job = (CmsScheduledJobInfo)OpenCms.getScheduleManager().getJob(jobId).clone();\n            job.setActive(false);\n            try {\n                OpenCms.getScheduleManager().scheduleJob(getCms(), job);\n                refreshList();\n            } catch (CmsSchedulerException e) {\n                // TODO: exception handling\n            } catch (CmsRoleViolationException e) {\n                // TODO: exception handling\n            }\n        } else if (getParamListAction().equals(LIST_ACTION_DELETE)) {\n            // delete a job from the list\n            String jobId = getSelectedItem().getId();        \n            try {\n                OpenCms.getScheduleManager().unscheduleJob(getCms(), jobId);\n                getList().removeItem(jobId);\n            } catch (CmsRoleViolationException e) {\n                // TODO: exception handling\n            }\n        } else {\n            throwListUnsupportedActionException();\n        }\n        listSave();\n    }","commit_id":"2ce7506a0aed39fdaa00f755a18ccf5ad5092d58","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * This method should handle every defined list multi action,\n     * by comparing <code>{@link #getParamListAction()}<\/code> with the id \n     * of the action to execute.<p> \n     */\n    public void executeListMultiActions() {\n\n        if (getParamListAction().equals(LIST_ACTION_DELETE)) {\n            // execute the delete multiaction\n            try {\n                Iterator itItems = getSelectedItems().iterator();\n                while (itItems.hasNext()) {\n                    CmsListItem listItem = (CmsListItem)itItems.next();\n                    OpenCms.getScheduleManager().unscheduleJob(getCms(), listItem.getId());\n                    getList().removeItem(listItem.getId());\n                }\n            } catch (CmsException e) {\n                throw new RuntimeException(e);\n            }\n        } else if (getParamListAction().equals(LIST_ACTION_ACTIVATE)) {\n            // execute the activate multiaction\n            try {\n                Iterator itItems = getSelectedItems().iterator();\n                while (itItems.hasNext()) {\n                    CmsListItem listItem = (CmsListItem)itItems.next();\n                    String jobId = listItem.getId();\n                    CmsScheduledJobInfo job = OpenCms.getScheduleManager().getJob(jobId);\n                    if (job.isActive()) {\n                        job.setActive(false);\n                    } else {\n                        job.setActive(true);\n                    }\n                    OpenCms.getScheduleManager().scheduleJob(getCms(), job);\n                }\n            } catch (CmsException e) {\n                throw new RuntimeException(e);\n            }\n            // refreshing no needed becaus the activate action does not add/remove rows to the list\n        } else {\n            throwListUnsupportedActionException();\n        }\n        listSave();\n    }","id":65843,"modified_method":"/**\n     * This method should handle every defined list multi action,\n     * by comparing <code>{@link #getParamListAction()}<\/code> with the id \n     * of the action to execute.<p> \n     */\n    public void executeListMultiActions() {\n\n        if (getParamListAction().equals(LIST_ACTION_MDELETE)) {\n            // execute the delete multiaction\n            try {\n                Iterator itItems = getSelectedItems().iterator();\n                while (itItems.hasNext()) {\n                    CmsListItem listItem = (CmsListItem)itItems.next();\n                    OpenCms.getScheduleManager().unscheduleJob(getCms(), listItem.getId());\n                    getList().removeItem(listItem.getId());\n                }\n            } catch (CmsException e) {\n                throw new RuntimeException(e);\n            }\n        } else if (getParamListAction().equals(LIST_ACTION_MACTIVATE) || getParamListAction().equals(LIST_ACTION_MDEACTIVATE)) {\n                // execute the activate or deactivate multiaction\n                try {\n                    Iterator itItems = getSelectedItems().iterator();\n                    boolean activate = getParamListAction().equals(LIST_ACTION_MACTIVATE);\n                    while (itItems.hasNext()) {\n                        CmsListItem listItem = (CmsListItem)itItems.next();\n                        \n                        CmsScheduledJobInfo job = (CmsScheduledJobInfo)OpenCms.getScheduleManager().getJob(listItem.getId()).clone();\n                        job.setActive(activate);\n                        OpenCms.getScheduleManager().scheduleJob(getCms(), job);\n                    }\n                    refreshList();\n                } catch (CmsException e) {\n                    throw new RuntimeException(e);\n                }\n        } else {\n            throwListUnsupportedActionException();\n        }\n        listSave();\n    }","commit_id":"2ce7506a0aed39fdaa00f755a18ccf5ad5092d58","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.workplace.list.A_CmsListDialog#getListItems()\n     */\n    protected List getListItems() {\n\n        List ret = new ArrayList();\n        // fill list\n        List jobs = OpenCms.getScheduleManager().getJobs();\n        Iterator itJobs = jobs.iterator();\n        while (itJobs.hasNext()) {\n            CmsScheduledJobInfo job = (CmsScheduledJobInfo)itJobs.next();\n            CmsListItem item = getList().newItem(job.getId());\n            item.set(LIST_COLUMN_NAME, job.getJobName());\n            item.set(LIST_COLUMN_TYPE, job.getClassName());\n            item.set(LIST_COLUMN_LASTEXE, job.getExecutionTimePrevious());\n            item.set(LIST_COLUMN_NEXTEXE, job.getExecutionTimeNext());\n            ret.add(ret);\n        }\n\n        return ret;\n    }","id":65844,"modified_method":"/**\n     * @see org.opencms.workplace.list.A_CmsListDialog#getListItems()\n     */\n    protected List getListItems() {\n\n        List items = new ArrayList();\n        \n        Iterator i = OpenCms.getScheduleManager().getJobs().iterator();\n        while (i.hasNext()) {\n            CmsScheduledJobInfo job = (CmsScheduledJobInfo)i.next();\n            CmsListItem item = getList().newItem(job.getId().toString());\n            item.set(LIST_COLUMN_NAME, job.getJobName());\n            item.set(LIST_COLUMN_CLASS, job.getClassName());\n            item.set(LIST_COLUMN_LASTEXE, job.getExecutionTimePrevious());\n            item.set(LIST_COLUMN_NEXTEXE, job.getExecutionTimeNext());\n            // details: context info\n            item.set(LIST_DETAIL_CONTEXTINFO, job.getContextInfo());\n            // details: parameter\n            StringBuffer params = new StringBuffer(32);\n            Iterator paramIt = job.getParameters().keySet().iterator();\n            while (paramIt.hasNext()) {\n                String param = (String)paramIt.next();\n                String value = (String)job.getParameters().get(param);\n                params.append(param).append(\": \");\n                params.append(value).append(\"<br>\");\n            }\n            item.set(LIST_DETAIL_PARAMETER, params);\n            \n            items.add(item);\n        }\n        \n        return items;\n    }","commit_id":"2ce7506a0aed39fdaa00f755a18ccf5ad5092d58","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.workplace.list.A_CmsListDialog#setIndependentActions(org.opencms.workplace.list.CmsListMetadata)\n     */\n    protected void setIndependentActions(CmsListMetadata metadata) {\n\n        metadata.addIndependentAction(CmsListIndependentAction.getDefaultRefreshListAction(LIST_ID));\n\n    }","id":65845,"modified_method":"/**\n     * @see org.opencms.workplace.list.A_CmsListDialog#setIndependentActions(org.opencms.workplace.list.CmsListMetadata)\n     */\n    protected void setIndependentActions(CmsListMetadata metadata) {\n\n        // add default reload button\n        metadata.addIndependentAction(CmsListIndependentAction.getDefaultRefreshListAction(LIST_ID));\n        \n        // add independent job context info button\n        \n        // create show context info action\n        CmsListIndependentAction showContextInfoAction = new CmsListIndependentAction(LIST_ID, LIST_DETAIL_CONTEXTINFO);\n        showContextInfoAction.setName(Messages.get().container(Messages.GUI_JOBS_DETAIL_SHOW_CONTEXTINFO_NAME_0));\n        showContextInfoAction.setIconPath(\"buttons/properties.gif\");\n        showContextInfoAction.setHelpText(Messages.get().container(Messages.GUI_JOBS_DETAIL_SHOW_CONTEXTINFO_HELP_0));\n        showContextInfoAction.setEnabled(true);\n        showContextInfoAction.setConfirmationMessage(null);\n        // create hide context info action\n        CmsListIndependentAction hideContextInfoAction = new CmsListIndependentAction(LIST_ID, LIST_DETAIL_CONTEXTINFO);\n        hideContextInfoAction.setName(Messages.get().container(Messages.GUI_JOBS_DETAIL_HIDE_CONTEXTINFO_NAME_0));\n        hideContextInfoAction.setIconPath(\"buttons/properties.gif\");\n        hideContextInfoAction.setHelpText(Messages.get().container(Messages.GUI_JOBS_DETAIL_HIDE_CONTEXTINFO_HELP_0));\n        hideContextInfoAction.setEnabled(true);\n        hideContextInfoAction.setConfirmationMessage(null);\n        // create list item\n        CmsListItemDetails jobsContextInfoDetails = new CmsListItemDetails(LIST_DETAIL_CONTEXTINFO);\n        jobsContextInfoDetails.setAtColumn(LIST_COLUMN_NAME);\n        jobsContextInfoDetails.setVisible(false);\n        jobsContextInfoDetails.setShowAction(showContextInfoAction);\n        jobsContextInfoDetails.setHideAction(hideContextInfoAction);\n        CmsContextInfoDetailsFormatter contextFormatter = new CmsContextInfoDetailsFormatter();\n        contextFormatter.setUserMessage(Messages.get().container(Messages.GUI_JOBS_DETAIL_CONTEXTINFO_USER_0));\n        contextFormatter.setProjectMessage(Messages.get().container(Messages.GUI_JOBS_DETAIL_CONTEXTINFO_PROJECT_0));\n        contextFormatter.setLocaleMessage(Messages.get().container(Messages.GUI_JOBS_DETAIL_CONTEXTINFO_LOCALE_0));\n        contextFormatter.setRootSiteMessage(Messages.get().container(Messages.GUI_JOBS_DETAIL_CONTEXTINFO_ROOTSITE_0));\n        contextFormatter.setEncodingMessage(Messages.get().container(Messages.GUI_JOBS_DETAIL_CONTEXTINFO_ENCODING_0));\n        contextFormatter.setRemoteAddrMessage(Messages.get().container(Messages.GUI_JOBS_DETAIL_CONTEXTINFO_REMADR_0));\n        contextFormatter.setRequestedURIMessage(Messages.get().container(Messages.GUI_JOBS_DETAIL_CONTEXTINFO_REQURI_0));\n        jobsContextInfoDetails.setFormatter(contextFormatter);\n        // add item to meta data\n        metadata.addItemDetails(jobsContextInfoDetails);\n        \n        // add independent job parameter button\n        \n        // create show parameter button\n        CmsListIndependentAction showParameterAction = new CmsListIndependentAction(LIST_ID, LIST_DETAIL_PARAMETER);\n        showParameterAction.setName(Messages.get().container(Messages.GUI_JOBS_DETAIL_SHOW_PARAMETER_NAME_0));\n        showParameterAction.setIconPath(\"buttons/details.gif\");\n        showParameterAction.setHelpText(Messages.get().container(Messages.GUI_JOBS_DETAIL_SHOW_PARAMETER_HELP_0));\n        showParameterAction.setEnabled(true);\n        showParameterAction.setConfirmationMessage(null);\n        // create hide parameter button\n        CmsListIndependentAction hideParameterAction = new CmsListIndependentAction(LIST_ID, LIST_DETAIL_PARAMETER);\n        hideParameterAction.setName(Messages.get().container(Messages.GUI_JOBS_DETAIL_HIDE_PARAMETER_NAME_0));\n        hideParameterAction.setIconPath(\"buttons/details.gif\");\n        hideParameterAction.setHelpText(Messages.get().container(Messages.GUI_JOBS_DETAIL_HIDE_PARAMETER_HELP_0));\n        hideParameterAction.setEnabled(true);\n        hideParameterAction.setConfirmationMessage(null);\n        // create list item\n        CmsListItemDetails jobsParameterDetails = new CmsListItemDetails(LIST_DETAIL_PARAMETER);\n        jobsParameterDetails.setAtColumn(LIST_COLUMN_NAME);\n        jobsParameterDetails.setVisible(false);\n        jobsParameterDetails.setShowAction(showParameterAction);\n        jobsParameterDetails.setHideAction(hideParameterAction);         \n        jobsParameterDetails.setFormatter(new CmsListItemDetailsFormatter(Messages.get().container(\n            Messages.GUI_JOBS_DETAIL_PARAMETER_FORMAT_0)));\n        metadata.addItemDetails(jobsParameterDetails);\n\n    }","commit_id":"2ce7506a0aed39fdaa00f755a18ccf5ad5092d58","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.workplace.list.A_CmsListDialog#setColumns(org.opencms.workplace.list.CmsListMetadata)\n     */\n    protected void setColumns(CmsListMetadata metadata) {\n\n        // add column for direct actions\n        CmsListColumnDefinition actionsCol = new CmsListColumnDefinition(LIST_COLUMN_ACTIONS, Messages.get().container(\n            Messages.GUI_JOBS_LIST_COLS_ACTIONS_0), \"\", // no width\n            CmsListColumnAlignEnum.ALIGN_CENTER);\n        actionsCol.setSorteable(false);\n\n        I_CmsListDirectAction activateJob = new ActivateJobAction(LIST_ID);\n\n        CmsListDirectAction deleteAction = new CmsListDirectAction(\n            LIST_ID,\n            LIST_ACTION_DELETE,\n            Messages.get().container(Messages.GUI_JOBS_LIST_ACTION_DELETE_NAME_0),\n            Messages.get().container(Messages.GUI_JOBS_LIST_ACTION_DELETE_HELP_0),\n            \"list/delete.gif\",\n            true, // enabled\n            Messages.get().container(Messages.GUI_JOBS_LIST_ACTION_DELETE_CONF_0));\n\n        CmsListDirectAction copyAction = new CmsListDirectAction(LIST_ID, LIST_ACTION_COPY, Messages.get().container(\n            Messages.GUI_JOBS_LIST_ACTION_COPY_NAME_0), Messages.get().container(\n            Messages.GUI_JOBS_LIST_ACTION_COPY_HELP_0), \"list/copy.gif\", true, // enabled\n            Messages.get().container(Messages.GUI_JOBS_LIST_ACTION_COPY_CONF_0));\n\n        actionsCol.addDirectAction(activateJob);\n        actionsCol.addDirectAction(copyAction);\n        actionsCol.addDirectAction(deleteAction);\n        metadata.addColumn(actionsCol);\n\n        // add column for name and default action\n        CmsListColumnDefinition nameCol = new CmsListColumnDefinition(LIST_COLUMN_NAME, Messages.get().container(\n            Messages.GUI_JOBS_LIST_COLS_NAME_0), \"\", // no width\n            CmsListColumnAlignEnum.ALIGN_LEFT);\n        nameCol.setDefaultAction(new CmsListDefaultAction(LIST_ID, LIST_ACTION_EDIT, Messages.get().container(\n            Messages.GUI_JOBS_LIST_ACTION_EDIT_NAME_0), Messages.get().container(\n            Messages.GUI_JOBS_LIST_ACTION_EDIT_HELP_0), null, // no icon\n            true, // enabled\n            Messages.get().container(Messages.GUI_JOBS_LIST_ACTION_EDIT_CONF_0)));\n        metadata.addColumn(nameCol);\n\n        // add column for type\n        CmsListColumnDefinition typeCol = new CmsListColumnDefinition(LIST_COLUMN_TYPE, Messages.get().container(\n            Messages.GUI_JOBS_LIST_COLS_TYPE_0), \"\", // no width\n            CmsListColumnAlignEnum.ALIGN_LEFT);\n        metadata.addColumn(typeCol);\n\n        // add column for last execution time\n        CmsListColumnDefinition lastExeCol = new CmsListColumnDefinition(LIST_COLUMN_LASTEXE, Messages.get().container(\n            Messages.GUI_JOBS_LIST_COLS_LASTEXE_0), \"\", // no width\n            CmsListColumnAlignEnum.ALIGN_LEFT);\n        lastExeCol.setFormatter(new CmsListDateMacroFormatter(Messages.get().container(\n            Messages.GUI_JOBS_LIST_COLS_LASTEXE_FORMAT_0), Messages.get().container(\n            Messages.GUI_JOBS_LIST_COLS_LASTEXE_NEVER_0)));\n        metadata.addColumn(lastExeCol);\n\n        // add column for next execution time\n        CmsListColumnDefinition nextExeCol = new CmsListColumnDefinition(LIST_COLUMN_NEXTEXE, Messages.get().container(\n            Messages.GUI_JOBS_LIST_COLS_NEXTEXE_0), \"\", // no width\n            CmsListColumnAlignEnum.ALIGN_LEFT);\n        nextExeCol.setFormatter(new CmsListDateMacroFormatter(Messages.get().container(\n            Messages.GUI_JOBS_LIST_COLS_NEXTEXE_FORMAT_0), Messages.get().container(\n            Messages.GUI_JOBS_LIST_COLS_NEXTEXE_NEVER_0)));\n        metadata.addColumn(nextExeCol);\n    }","id":65846,"modified_method":"/**\n     * @see org.opencms.workplace.list.A_CmsListDialog#setColumns(org.opencms.workplace.list.CmsListMetadata)\n     */\n    protected void setColumns(CmsListMetadata metadata) {\n\n        // add column for activate/deactivate action\n        CmsListColumnDefinition activateCol = new CmsListColumnDefinition(LIST_COLUMN_ACTIVATE);\n        activateCol.setName(Messages.get().container(Messages.GUI_JOBS_LIST_COL_ACTIVE_0));\n        activateCol.setWidth(null);\n        activateCol.setAlign(CmsListColumnAlignEnum.ALIGN_CENTER);\n        activateCol.setSorteable(false);\n        // create direct action to activate/deactivate job\n        CmsActionActivateJob activateJob = new CmsActionActivateJob(\n            LIST_ID,\n            LIST_ACTION_ACTIVATE,\n            getCms());\n        CmsListDirectAction userActAction = new CmsListDirectAction(LIST_ID, LIST_ACTION_ACTIVATE);\n        userActAction.setName(Messages.get().container(Messages.GUI_JOBS_LIST_ACTION_ACTIVATE_NAME_0));\n        userActAction.setConfirmationMessage(Messages.get().container(\n            Messages.GUI_JOBS_LIST_ACTION_ACTIVATE_CONF_0));\n        userActAction.setIconPath(\"buttons/apply_in.gif\");\n        userActAction.setEnabled(true);\n        userActAction.setHelpText(Messages.get().container(Messages.GUI_JOBS_LIST_ACTION_ACTIVATE_HELP_0));\n        activateJob.setFirstAction(userActAction);\n        CmsListDirectAction userDeactAction = new CmsListDirectAction(LIST_ID, LIST_ACTION_DEACTIVATE);\n        userDeactAction.setName(Messages.get().container(Messages.GUI_JOBS_LIST_ACTION_DEACTIVATE_NAME_0));\n        userDeactAction.setConfirmationMessage(Messages.get().container(\n            Messages.GUI_JOBS_LIST_ACTION_DEACTIVATE_CONF_0));\n        userDeactAction.setIconPath(\"buttons/apply.gif\");\n        userDeactAction.setEnabled(true);\n        userDeactAction.setHelpText(Messages.get().container(Messages.GUI_JOBS_LIST_ACTION_DEACTIVATE_HELP_0));\n        activateJob.setSecondAction(userDeactAction);\n        activateCol.addDirectAction(activateJob);\n        metadata.addColumn(activateCol);\n        \n        // add column for copy action\n        CmsListColumnDefinition copyCol = new CmsListColumnDefinition(LIST_COLUMN_COPY);\n        copyCol.setName(Messages.get().container(Messages.GUI_JOBS_LIST_COL_COPY_0));\n        copyCol.setWidth(null);\n        copyCol.setAlign(CmsListColumnAlignEnum.ALIGN_CENTER);\n        copyCol.setSorteable(false);\n        // create direct action\n        CmsListDirectAction copyJob = new CmsListDirectAction(LIST_ID, LIST_COLUMN_COPY);\n        copyJob.setName(Messages.get().container(Messages.GUI_JOBS_LIST_ACTION_COPY_NAME_0));\n        copyJob.setConfirmationMessage(Messages.get().container(\n            Messages.GUI_JOBS_LIST_ACTION_COPY_CONF_0));\n        copyJob.setIconPath(\"buttons/apply.gif\");\n        copyJob.setEnabled(true);\n        copyJob.setHelpText(Messages.get().container(Messages.GUI_JOBS_LIST_ACTION_COPY_HELP_0));\n        copyCol.addDirectAction(copyJob);\n        metadata.addColumn(copyCol);\n        \n        // add column for delete action\n        CmsListColumnDefinition delCol = new CmsListColumnDefinition(LIST_COLUMN_DELETE);\n        delCol.setName(Messages.get().container(Messages.GUI_JOBS_LIST_COL_DELETE_0));\n        delCol.setWidth(null);\n        delCol.setAlign(CmsListColumnAlignEnum.ALIGN_CENTER);\n        delCol.setSorteable(false);\n        // create direct action\n        CmsListDirectAction delJob = new CmsListDirectAction(LIST_ID, LIST_ACTION_DELETE);\n        delJob.setName(Messages.get().container(Messages.GUI_JOBS_LIST_ACTION_DELETE_NAME_0));\n        delJob.setConfirmationMessage(Messages.get().container(\n            Messages.GUI_JOBS_LIST_ACTION_DELETE_CONF_0));\n        delJob.setIconPath(\"buttons/apply.gif\");\n        delJob.setEnabled(true);\n        delJob.setHelpText(Messages.get().container(Messages.GUI_JOBS_LIST_ACTION_DELETE_HELP_0));\n        delCol.addDirectAction(delJob);\n        metadata.addColumn(delCol);\n        \n        // add column for name\n        CmsListColumnDefinition nameCol = new CmsListColumnDefinition(LIST_COLUMN_NAME);\n        nameCol.setName(Messages.get().container(Messages.GUI_JOBS_LIST_COL_NAME_0));\n        nameCol.setWidth(\"20%\");\n        nameCol.setAlign(CmsListColumnAlignEnum.ALIGN_LEFT);\n        // create default edit action for name column\n        CmsListDefaultAction nameColAction = new CmsListDefaultAction (LIST_ID, LIST_ACTION_EDIT);\n        nameColAction.setName(Messages.get().container(Messages.GUI_JOBS_LIST_ACTION_EDIT_NAME_0));\n        nameColAction.setIconPath(null);\n        nameColAction.setHelpText(Messages.get().container(Messages.GUI_JOBS_LIST_ACTION_EDIT_HELP_0));\n        nameColAction.setEnabled(true);\n        nameColAction.setConfirmationMessage(Messages.get().container(Messages.GUI_JOBS_LIST_ACTION_EDIT_CONF_0));\n        // set action for the name column\n        nameCol.setDefaultAction(nameColAction);\n        metadata.addColumn(nameCol);\n        \n        // add column for class\n        CmsListColumnDefinition classCol = new CmsListColumnDefinition(LIST_COLUMN_CLASS);\n        classCol.setName(Messages.get().container(Messages.GUI_JOBS_LIST_COL_CLASS_0));\n        classCol.setWidth(\"15%\");\n        classCol.setAlign(CmsListColumnAlignEnum.ALIGN_LEFT);\n        metadata.addColumn(classCol);\n        \n        // add column for last execution time\n        CmsListColumnDefinition lastExecCol = new CmsListColumnDefinition(LIST_COLUMN_LASTEXE);\n        lastExecCol.setName(Messages.get().container(Messages.GUI_JOBS_LIST_COL_LASTEXE_0));\n        lastExecCol.setWidth(\"22.5%\");\n        lastExecCol.setAlign(CmsListColumnAlignEnum.ALIGN_LEFT);\n        // create date formatter for last execution time\n        CmsListDateMacroFormatter listDateFormatter =  new CmsListDateMacroFormatter(Messages.get().container(\n            Messages.GUI_JOBS_LIST_COL_LASTEXE_FORMAT_1), Messages.get().container(\n            Messages.GUI_JOBS_LIST_COL_LASTEXE_NEVER_0));\n        lastExecCol.setFormatter(listDateFormatter);\n        metadata.addColumn(lastExecCol);\n        \n        // add column for next execution time\n        CmsListColumnDefinition nextExecCol = new CmsListColumnDefinition(LIST_COLUMN_NEXTEXE);\n        nextExecCol.setName(Messages.get().container(Messages.GUI_JOBS_LIST_COL_NEXTEXE_0));\n        nextExecCol.setWidth(\"22.5%\");\n        nextExecCol.setAlign(CmsListColumnAlignEnum.ALIGN_LEFT);\n        // create date formatter for next execution time\n        listDateFormatter = new CmsListDateMacroFormatter(Messages.get().container(\n            Messages.GUI_JOBS_LIST_COL_NEXTEXE_FORMAT_1), Messages.get().container(\n                Messages.GUI_JOBS_LIST_COL_NEXTEXE_NEVER_0));\n        nextExecCol.setFormatter(listDateFormatter);\n        metadata.addColumn(nextExecCol);\n\n    }","commit_id":"2ce7506a0aed39fdaa00f755a18ccf5ad5092d58","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Initializes the scheduled job object to work with depending on the dialog state and request parameters.<p>\n     * \n     * Three initializations of the scheduled job object on first dialog call are possible:\n     * <ul>\n     * <li>edit an existing scheduled job<\/li>\n     * <li>create a new scheduled job<\/li>\n     * <li>copy an existing scheduled job and edit it<\/li>\n     * <\/ul>\n     */\n    protected void initScheduledJobObject() {\n\n        Object o;\n\n        boolean setActive = false;\n\n        if (CmsStringUtil.isEmpty(getParamAction())\n            || CmsDialog.DIALOG_INITIAL.equals(getParamAction())\n            || DIALOG_COPYJOB.equals(getParamAction())) {\n            // this is the initial dialog call\n            if (CmsStringUtil.isNotEmpty(getParamJobid())) {\n                // edit or copy an existing job, get the job object from manager\n                o = OpenCms.getScheduleManager().getJob(getParamJobid()).clone();\n                setActive = ((CmsScheduledJobInfo)o).isActive();\n            } else {\n                // create a new job for the new job dialog\n                o = null;\n            }\n        } else {\n            // this is not the initial call, get the job object from session\n            o = getDialogObject();\n        }\n\n        if (!(o instanceof CmsScheduledJobInfo)) {\n            // create a new job info object\n            m_jobInfo = new CmsScheduledJobInfo();\n            m_jobInfo.setContextInfo(new CmsContextInfo());\n        } else {\n            // reuse job info object stored in session\n            m_jobInfo = (CmsScheduledJobInfo)o;\n        }\n\n        if (setActive) {\n            // initial call of edit an existing job, set active state of cloned job\n            m_jobInfo.setActive(true);\n        }\n\n        if (DIALOG_COPYJOB.equals(getParamAction())) {\n            // initial call of copy job action, clear the job id of the cloned job\n            m_jobInfo.clearId();\n        }\n    }","id":65847,"modified_method":"/**\n     * Initializes the scheduled job object to work with depending on the dialog state and request parameters.<p>\n     * \n     * Three initializations of the scheduled job object on first dialog call are possible:\n     * <ul>\n     * <li>edit an existing scheduled job<\/li>\n     * <li>create a new scheduled job<\/li>\n     * <li>copy an existing scheduled job and edit it<\/li>\n     * <\/ul>\n     */\n    protected void initScheduledJobObject() {\n\n        Object o;\n\n        boolean setActive = false;\n\n        if (CmsStringUtil.isEmpty(getParamAction())\n            || CmsDialog.DIALOG_INITIAL.equals(getParamAction())\n            || DIALOG_COPYJOB.equals(getParamAction())) {\n            // this is the initial dialog call\n            if (CmsStringUtil.isNotEmpty(getParamJobid())) {\n                // edit or copy an existing job, get the job object from manager\n                CmsScheduledJobInfo job = OpenCms.getScheduleManager().getJob(getParamJobid());\n                // clone resets the active flag!\n                o = job.clone();\n                setActive = job.isActive();\n            } else {\n                // create a new job for the new job dialog\n                o = null;\n            }\n        } else {\n            // this is not the initial call, get the job object from session\n            o = getDialogObject();\n        }\n\n        if (!(o instanceof CmsScheduledJobInfo)) {\n            // create a new job info object\n            m_jobInfo = new CmsScheduledJobInfo();\n            m_jobInfo.setContextInfo(new CmsContextInfo());\n        } else {\n            // reuse job info object stored in session\n            m_jobInfo = (CmsScheduledJobInfo)o;\n        }\n\n        if (setActive) {\n            // initial call of edit an existing job, set active state of cloned job\n            m_jobInfo.setActive(true);\n        }\n\n        if (DIALOG_COPYJOB.equals(getParamAction())) {\n            // initial call of copy job action, clear the job id of the cloned job\n            m_jobInfo.clearId();\n        }\n    }","commit_id":"6a4234e6015b2302570a17fc9a2f4ed621bb3827","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Handles the client: Decodes JSON, Stores in MongoDB, ReceiveHooks\n     *\n     * @return boolean\n     */\n    public boolean handle() {\n        // Don't handle if message is incomplete.\n        if (this.clientMessage == null) {\n            return true;\n        }\n\n        try {\n             // Fills properties with values from JSON.\n            try { this.parse(); } catch(Exception e) {\n                Log.warn(\"Could not parse GELF JSON: \" + e.toString() + \" - clientMessage was: \" + this.clientMessage);\n                return false;\n            }\n\n            // Store in MongoDB.\n            // Connect to database.\n            MongoBridge m = new MongoBridge();\n\n\n            // Log if we are in debug mode.\n            Log.info(\"Got GELF message: \" + message.toString());\n\n            // Insert message into MongoDB.\n            m.insertGelfMessage(message);\n\n            // This is doing the upcounting for RRD.\n            ReceiveHookManager.postProcess(new MessageCounterHook());\n        } catch(Exception e) {\n            Log.warn(\"Could not handle GELF client: \" + e.toString());\n            return false;\n        }\n\n        return true;\n    }","id":65848,"modified_method":"/**\n     * Handles the client: Decodes JSON, Stores in MongoDB, ReceiveHooks\n     *\n     * @return boolean\n     */\n    public boolean handle() {\n        // Don't handle if message is incomplete.\n        if (this.clientMessage == null) {\n            return true;\n        }\n\n        try {\n             // Fills properties with values from JSON.\n            try { this.parse(); } catch(Exception e) {\n                Log.warn(\"Could not parse GELF JSON: \" + e.toString() + \" - clientMessage was: \" + this.clientMessage);\n                return false;\n            }\n\n            // Store in MongoDB.\n            // Connect to database.\n            MongoBridge m = new MongoBridge();\n\n\n            // Log if we are in debug mode.\n            Log.info(\"Got GELF message: \" + message.toString());\n\n            // Insert message into MongoDB.\n            m.insertGelfMessage(message);\n\n            // This is doing the upcounting for RRD.\n            ReceiveHookManager.postProcess(new MessageCounterHook());\n        } catch(Exception e) {\n            Log.warn(\"Could not handle GELF client: \" + e.toString());\n            e.printStackTrace();\n            return false;\n        }\n\n        return true;\n    }","commit_id":"ab9da4322694a084badb4be3cf8e0f31abbfc3c1","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"protected boolean parse() throws Exception{\n        JSONObject json = this.getJSON(this.clientMessage.toString());\n        if (json == null) {\n            Log.warn(\"JSON is null/could not be parsed (invalid JSON) - clientMessage was: \" + this.clientMessage);\n            return false;\n        }\n\n        this.message.shortMessage = this.jsonToString(json.get(\"short_message\"));\n        this.message.fullMessage = this.jsonToString(json.get(\"full_message\"));\n        this.message.level = this.jsonToInt(json.get(\"level\"));\n        this.message.type = this.jsonToInt(json.get(\"type\"));\n        this.message.host = this.jsonToString(json.get(\"host\"));\n        this.message.file = this.jsonToString(json.get(\"file\"));\n        this.message.line = this.jsonToInt(json.get(\"line\"));\n\n        return true;\n    }","id":65849,"modified_method":"protected boolean parse() throws Exception{\n        JSONObject json = this.getJSON(this.clientMessage.toString());\n        if (json == null) {\n            Log.warn(\"JSON is null/could not be parsed (invalid JSON) - clientMessage was: \" + this.clientMessage);\n            return false;\n        }\n\n        // Add standard fields.\n        this.message.setShortMessage(this.jsonToString(json.get(\"short_message\")));\n        this.message.setFullMessage(this.jsonToString(json.get(\"full_message\")));\n        this.message.setLevel(this.jsonToInt(json.get(\"level\")));\n        this.message.setHost(this.jsonToString(json.get(\"host\")));\n        this.message.setFile(this.jsonToString(json.get(\"file\")));\n        this.message.setLine(this.jsonToInt(json.get(\"line\")));\n\n        // Add additional data if there is some.\n        Set<String> set = json.keySet();\n        Iterator<String> iter = set.iterator();\n        while(iter.hasNext()) {\n            String key = iter.next();\n\n            // Skip standard fields.\n            if (this.standardFields.contains(key)) {\n                continue;\n            }\n\n            // Add to message.\n            this.message.addAdditionalData(key, this.jsonToString(json.get(key)));\n        }\n\n        return true;\n    }","commit_id":"ab9da4322694a084badb4be3cf8e0f31abbfc3c1","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"protected GELFClientHandlerBase() { }","id":65850,"modified_method":"protected GELFClientHandlerBase() {\n        this.standardFields.add(\"short_message\");\n        this.standardFields.add(\"full_message\");\n        this.standardFields.add(\"level\");\n        this.standardFields.add(\"host\");\n        this.standardFields.add(\"file\");\n        this.standardFields.add(\"line\");\n    }","commit_id":"ab9da4322694a084badb4be3cf8e0f31abbfc3c1","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"/**\n     * @return Human readable, descriptive and formatted string of this GELF message.\n     */\n    @Override public String toString() {\n        String str = \"shortMessage: \" + shortMessage + \" | \";\n        str += \"fullMessage: \" + fullMessage + \" | \";\n        str += \"level: \" + level + \" | \";\n        str += \"type: \" + type + \" | \";\n        str += \"host: \" + host + \" | \";\n        str += \"file: \" + file + \" | \";\n        str += \"line: \" + line;\n\n        // Replace all newlines and tabs.\n        String ret = str.replaceAll(\"\\\\n\", \"\").replaceAll(\"\\\\t\", \"\");\n\n        // Cut to 100 chars if the message is too long.\n        if (ret.length() > 150) {\n            ret = ret.substring(0, 150);\n            ret += \" (...)\";\n        }\n\n        return ret;\n    }","id":65851,"modified_method":"/**\n     * @return Human readable, descriptive and formatted string of this GELF message.\n     */\n    @Override public String toString() {\n        String str = \"shortMessage: \" + shortMessage + \" | \";\n        str += \"fullMessage: \" + fullMessage + \" | \";\n        str += \"level: \" + level + \" | \";\n        str += \"host: \" + host + \" | \";\n        str += \"file: \" + file + \" | \";\n        str += \"line: \" + line + \" | \";\n        str += \"additional: \" + this.additionalData.size();\n\n        // Replace all newlines and tabs.\n        String ret = str.replaceAll(\"\\\\n\", \"\").replaceAll(\"\\\\t\", \"\");\n\n        // Cut to 100 chars if the message is too long.\n        if (ret.length() > 225) {\n            ret = ret.substring(0, 225);\n            ret += \" (...)\";\n        }\n\n        return ret;\n    }","commit_id":"ab9da4322694a084badb4be3cf8e0f31abbfc3c1","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"/**\n     * Inserts a GELF message into the messages collection.\n     *\n     * @param message The GELF message\n     * @throws Exception\n     */\n    public void insertGelfMessage(GELFMessage message) throws Exception {\n        // Check if all required parameters are set.\n        if (message.shortMessage == null || message.shortMessage.length() == 0 || message.host == null || message.host.length() == 0) {\n            throw new Exception(\"Missing GELF message parameters. short_message and host are required.\");\n        }\n        DBCollection coll = this.getMessagesColl();\n\n        BasicDBObject dbObj = new BasicDBObject();\n\n        dbObj.put(\"gelf\", true);\n        dbObj.put(\"message\", message.shortMessage);\n        dbObj.put(\"full_message\", message.fullMessage);\n        dbObj.put(\"type\", message.type);\n        dbObj.put(\"file\", message.file);\n        dbObj.put(\"line\", message.line);\n        dbObj.put(\"host\", message.host);\n        dbObj.put(\"facility\", null);\n        dbObj.put(\"level\", message.level);\n        dbObj.put(\"created_at\", (int) (System.currentTimeMillis()/1000));\n        // Documents in capped collections cannot grow so we have to do that now and cannot just add 'deleted => true' later.\n        dbObj.put(\"deleted\", false);\n\n        coll.insert(dbObj);\n    }","id":65852,"modified_method":"/**\n     * Inserts a GELF message into the messages collection.\n     *\n     * @param message The GELF message\n     * @throws Exception\n     */\n    public void insertGelfMessage(GELFMessage message) throws Exception {\n        // Check if all required parameters are set.\n        if (message.getShortMessage() == null || message.getShortMessage().length() == 0 || message.getHost() == null || message.getHost().length() == 0) {\n            throw new Exception(\"Missing GELF message parameters. short_message and host are required.\");\n        }\n        DBCollection coll = this.getMessagesColl();\n\n        BasicDBObject dbObj = new BasicDBObject();\n\n        dbObj.put(\"gelf\", true);\n        dbObj.put(\"message\", message.getShortMessage());\n        dbObj.put(\"full_message\", message.getFullMessage());\n        dbObj.put(\"file\", message.getFile());\n        dbObj.put(\"line\", message.getLine());\n        dbObj.put(\"host\", message.getHost());\n        dbObj.put(\"facility\", null);\n        dbObj.put(\"level\", message.getLevel());\n\n        // Add additional fields.\n        Map<String,String> additionalFields = message.getAdditionalData();\n        Set<String> set = additionalFields.keySet();\n        Iterator<String> iter = set.iterator();\n        while(iter.hasNext()) {\n            String key = iter.next();\n            String value = additionalFields.get(key);\n            dbObj.put(key, value);\n        }\n\n        dbObj.put(\"created_at\", (int) (System.currentTimeMillis()/1000));\n        // Documents in capped collections cannot grow so we have to do that now and cannot just add 'deleted => true' later.\n        dbObj.put(\"deleted\", false);\n\n        coll.insert(dbObj);\n    }","commit_id":"ab9da4322694a084badb4be3cf8e0f31abbfc3c1","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"/**\n     * Test of insertGelfMessage method, of class MongoBridge.\n     */\n    @Test\n    public void testInsertGelfMessage() throws Exception {\n        GELFMessage message = new GELFMessage();\n        message.shortMessage = \"gelftest\";\n        message.fullMessage = \"full gelftest\\nstuff\";\n        message.level = 1;\n        message.type = 8;\n        message.host = \"junit-test\";\n        message.file = \"junit-testfile\";\n        message.line = 9001;\n\n        // Insert the message.\n        MongoBridge instance = new MongoBridge();\n        instance.insertGelfMessage(message);\n\n        // Fetch the event and compare\n        DBCollection coll = instance.getMessagesColl();\n        long count = coll.getCount();\n        assertTrue(count == 1);\n\n        DBObject res = coll.findOne();\n        assertEquals(res.get(\"message\"), \"gelftest\");\n        assertEquals(res.get(\"full_message\"), \"full gelftest\\nstuff\");\n        assertEquals(res.get(\"level\"), 1);\n        assertEquals(res.get(\"type\"), 8);\n        assertEquals(res.get(\"host\"), \"junit-test\");\n        assertEquals(res.get(\"file\"), \"junit-testfile\");\n        assertEquals(res.get(\"line\"), 9001);\n    }","id":65853,"modified_method":"/**\n     * Test of insertGelfMessage method, of class MongoBridge.\n     */\n    @Test\n    public void testInsertGelfMessage() throws Exception {\n        GELFMessage message = new GELFMessage();\n        message.setShortMessage(\"gelftest\");\n        message.setFullMessage(\"full gelftest\\nstuff\");\n        message.setLevel(1);\n        message.setHost(\"junit-test\");\n        message.setFile(\"junit-testfile\");\n        message.setLine(9001);\n        message.addAdditionalData(\"something\", \"yepp\");\n\n        // Insert the message.\n        MongoBridge instance = new MongoBridge();\n        instance.insertGelfMessage(message);\n\n        // Fetch the event and compare\n        DBCollection coll = instance.getMessagesColl();\n        long count = coll.getCount();\n        assertTrue(count == 1);\n\n        DBObject res = coll.findOne();\n        assertEquals(res.get(\"message\"), \"gelftest\");\n        assertEquals(res.get(\"full_message\"), \"full gelftest\\nstuff\");\n        assertEquals(res.get(\"level\"), 1);\n        assertEquals(res.get(\"type\"), 8);\n        assertEquals(res.get(\"host\"), \"junit-test\");\n        assertEquals(res.get(\"file\"), \"junit-testfile\");\n        assertEquals(res.get(\"line\"), 9001);\n        assertEquals(res.get(\"something\"), \"yepp\");\n    }","commit_id":"ab9da4322694a084badb4be3cf8e0f31abbfc3c1","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"/**\n     * Test of distinctHosts method, of class MongoBridge.\n     */\n    @Test\n    public void testDistinctHosts() throws Exception {\n        DB db = MongoConnection.getInstance().getDatabase();\n        MongoBridge m = new MongoBridge();\n\n        // Insert a message.\n        GELFMessage message = new GELFMessage();\n        message.shortMessage = \"test\";\n        message.host = \"host1\";\n        m.insertGelfMessage(message);\n\n        // Second message from another host\n        message.host = \"host2\";\n        m.insertGelfMessage(message);\n\n        // Distinct the hosts.\n        m.distinctHosts();\n\n        DBCollection coll = db.getCollection(\"hosts\");\n\n        List<String> hosts = coll.distinct(\"host\");\n        assertTrue(hosts.size() == 2);\n    }","id":65854,"modified_method":"/**\n     * Test of distinctHosts method, of class MongoBridge.\n     */\n    @Test\n    public void testDistinctHosts() throws Exception {\n        DB db = MongoConnection.getInstance().getDatabase();\n        MongoBridge m = new MongoBridge();\n\n        // Insert a message.\n        GELFMessage message = new GELFMessage();\n        message.setShortMessage(\"test\");\n        message.setHost(\"host1\");\n        m.insertGelfMessage(message);\n\n        // Second message from another host\n        message.setHost(\"host2\");\n        m.insertGelfMessage(message);\n\n        // Distinct the hosts.\n        m.distinctHosts();\n\n        DBCollection coll = db.getCollection(\"hosts\");\n\n        List<String> hosts = coll.distinct(\"host\");\n        assertTrue(hosts.size() == 2);\n    }","commit_id":"ab9da4322694a084badb4be3cf8e0f31abbfc3c1","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"/**\n     * Handles the client: Decodes JSON, Stores in MongoDB, ReceiveHooks\n     * \n     * @return boolean\n     */\n    public boolean handle() {\n        try {\n             // Fills properties with values from JSON.\n            try { this.parse(); } catch(Exception e) {\n                Log.warn(\"Could not parse GELF JSON: \" + e.toString() + \" - clientMessage was: \" + this.clientMessage);\n                return false;\n            }\n\n            // Store in MongoDB.\n            // Connect to database.\n            MongoBridge m = new MongoBridge();\n\n\n            // Log if we are in debug mode.\n            Log.info(\"Got GELF message: \" + message.toString());\n\n            // Insert message into MongoDB.\n            m.insertGelfMessage(message);\n\n            // This is doing the upcounting for RRD.\n            ReceiveHookManager.postProcess(new MessageCounterHook());\n        } catch(Exception e) {\n            Log.warn(\"Could not handle GELF client: \" + e.toString());\n            return false;\n        }\n\n        return true;\n    }","id":65855,"modified_method":"/**\n     * Handles the client: Decodes JSON, Stores in MongoDB, ReceiveHooks\n     * \n     * @return boolean\n     */\n    public boolean handle() {\n        try {\n             // Fills properties with values from JSON.\n            try { this.parse(); } catch(Exception e) {\n                Log.warn(\"Could not parse GELF JSON: \" + e.toString() + \" - clientMessage was: \" + this.clientMessage);\n                return false;\n            }\n\n            // Store in MongoDB.\n            // Connect to database.\n            MongoBridge m = new MongoBridge();\n\n\n            // Log if we are in debug mode.\n            Log.info(\"Got GELF message: \" + message.toString());\n\n            // Insert message into MongoDB.\n            m.insertGelfMessage(message);\n\n            // This is doing the upcounting for RRD.\n            ReceiveHookManager.postProcess(new MessageCounterHook());\n        } catch(Exception e) {\n            Log.warn(\"Could not handle GELF client: \" + e.toString());\n            e.printStackTrace();\n            return false;\n        }\n\n        return true;\n    }","commit_id":"ab9da4322694a084badb4be3cf8e0f31abbfc3c1","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private Animation horizontalResizeAnimation(final double start,\n                                               final double end)\n   {\n      return horizontalResizeAnimation(start, end, null);\n   }","id":65856,"modified_method":"private void resizeHorizontally(final double start,\n                                   final double end)\n   {\n      resizeHorizontally(start, end, null);\n   }","commit_id":"efe6f5fbd82a39862a05d0acb0a2a57715d84e7f","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void restoreSavedLayout()\n   {\n      // Ensure that all windows are in the 'normal' state. This allows\n      // hidden windows to display themselves, and so on.\n      for (LogicalWindow window : panes_)\n         window.onWindowStateChange(new WindowStateChangeEvent(WindowState.NORMAL, true));\n      \n      maximizedWindow_.onWindowStateChange(new WindowStateChangeEvent(WindowState.NORMAL, true));\n      horizontalResizeAnimation(panel_.getWidgetSize(right_), widgetSizePriorToZoom_).run(300);\n      \n      // Invalidate the saved state.\n      maximizedWindow_ = null;\n      maximizedTab_ = null;\n      widgetSizePriorToZoom_ = -1;\n   }","id":65857,"modified_method":"private void restoreSavedLayout()\n   {\n      // Ensure that all windows are in the 'normal' state. This allows\n      // hidden windows to display themselves, and so on.\n      for (LogicalWindow window : panes_)\n         window.onWindowStateChange(new WindowStateChangeEvent(WindowState.NORMAL, true));\n      \n      maximizedWindow_.onWindowStateChange(new WindowStateChangeEvent(WindowState.NORMAL, true));\n      resizeHorizontally(panel_.getWidgetSize(right_), widgetSizePriorToZoom_);\n      \n      // Invalidate the saved state.\n      maximizedWindow_ = null;\n      maximizedTab_ = null;\n      widgetSizePriorToZoom_ = -1;\n   }","commit_id":"efe6f5fbd82a39862a05d0acb0a2a57715d84e7f","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void fullyMaximizeWindow(final LogicalWindow window, final Tab tab)\n   {\n      if (window.equals(getSourceLogicalWindow()))\n         maximizedTab_ = Tab.Source;\n      else if (window.equals(getConsoleLogicalWindow()))\n         maximizedTab_ = Tab.Console;\n      else\n         maximizedTab_ = tab;\n         \n      maximizedWindow_ = window;\n      if (widgetSizePriorToZoom_ < 0)\n         widgetSizePriorToZoom_ = panel_.getWidgetSize(right_);\n      \n      // Put all of the panes in NORMAL mode, just to ensure an appropriate\n      // transfer to EXCLUSIVE mode works. (It seems that 'exclusive' -> 'exclusive'\n      // transfers don't always propagate as expected)\n      for (LogicalWindow pane : panes_)\n         pane.onWindowStateChange(new WindowStateChangeEvent(WindowState.NORMAL));\n      \n      boolean isLeftWidget =\n            DomUtils.contains(left_.getElement(), window.getActiveWidget().getElement());\n      \n      window.onWindowStateChange(new WindowStateChangeEvent(WindowState.EXCLUSIVE));\n      \n      final double initialSize = panel_.getWidgetSize(right_);\n      \n      // Ensure that a couple pixels are left after zoom so that the pane\n      // can be manually pulled out (with the mouse).\n      double targetSize = isLeftWidget ?\n            0 :\n            panel_.getOffsetWidth() - 3;\n      \n      if (targetSize < 0)\n         targetSize = 0;\n      \n      horizontalResizeAnimation(initialSize, targetSize).run(300);\n   }","id":65858,"modified_method":"private void fullyMaximizeWindow(final LogicalWindow window, final Tab tab)\n   {\n      if (window.equals(getSourceLogicalWindow()))\n         maximizedTab_ = Tab.Source;\n      else if (window.equals(getConsoleLogicalWindow()))\n         maximizedTab_ = Tab.Console;\n      else\n         maximizedTab_ = tab;\n         \n      maximizedWindow_ = window;\n      if (widgetSizePriorToZoom_ < 0)\n         widgetSizePriorToZoom_ = panel_.getWidgetSize(right_);\n      \n      // Put all of the panes in NORMAL mode, just to ensure an appropriate\n      // transfer to EXCLUSIVE mode works. (It seems that 'exclusive' -> 'exclusive'\n      // transfers don't always propagate as expected)\n      for (LogicalWindow pane : panes_)\n         pane.onWindowStateChange(new WindowStateChangeEvent(WindowState.NORMAL));\n      \n      boolean isLeftWidget =\n            DomUtils.contains(left_.getElement(), window.getActiveWidget().getElement());\n      \n      window.onWindowStateChange(new WindowStateChangeEvent(WindowState.EXCLUSIVE));\n      \n      final double initialSize = panel_.getWidgetSize(right_);\n      \n      // Ensure that a couple pixels are left after zoom so that the pane\n      // can be manually pulled out (with the mouse).\n      double targetSize = isLeftWidget ?\n            0 :\n            panel_.getOffsetWidth() - 3;\n      \n      if (targetSize < 0)\n         targetSize = 0;\n      \n      resizeHorizontally(initialSize, targetSize);\n   }","commit_id":"efe6f5fbd82a39862a05d0acb0a2a57715d84e7f","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void restoreFourPaneLayout()\n   {\n      // Ensure that all windows are in the 'normal' state. This allows\n      // hidden windows to display themselves, and so on. This also forces\n      // widgets to size themselves vertically.\n      for (LogicalWindow window : panes_)\n         window.onWindowStateChange(new WindowStateChangeEvent(WindowState.NORMAL, true));\n      \n      double rightWidth = panel_.getWidgetSize(right_);\n      \n      // If the right pane is already visible horizontally, bail.\n      if (rightWidth >= 10)\n         return;\n      \n      horizontalResizeAnimation(rightWidth, computeAppropriateWidth()).run(300);\n   }","id":65859,"modified_method":"private void restoreFourPaneLayout()\n   {\n      // Ensure that all windows are in the 'normal' state. This allows\n      // hidden windows to display themselves, and so on. This also forces\n      // widgets to size themselves vertically.\n      for (LogicalWindow window : panes_)\n         window.onWindowStateChange(new WindowStateChangeEvent(WindowState.NORMAL, true));\n      \n      double rightWidth = panel_.getWidgetSize(right_);\n      \n      // If the right pane is already visible horizontally, bail.\n      if (rightWidth >= 10)\n         return;\n      \n      resizeHorizontally(rightWidth, computeAppropriateWidth());\n   }","commit_id":"efe6f5fbd82a39862a05d0acb0a2a57715d84e7f","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Handler\n   void onLayoutZoomHelp() \n   { \n      paneManager_.zoomTab(Tab.Help);\n      Scheduler.get().scheduleDeferred(new ScheduledCommand()\n      {\n         @Override\n         public void execute()\n         {\n            eventBus_.fireEvent(new ActivateHelpEvent());\n         }\n      });\n   }","id":65860,"modified_method":"@Handler\n   void onLayoutZoomHelp() \n   { \n      paneManager_.zoomTab(Tab.Help);\n      fireEventDelayed(new ActivateHelpEvent(), 200);\n   }","commit_id":"efe6f5fbd82a39862a05d0acb0a2a57715d84e7f","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Handler\n   void onActivateHelp() \n   { \n      paneManager_.activateTab(Tab.Help); \n      eventBus_.fireEvent(new ActivateHelpEvent());\n   }","id":65861,"modified_method":"@Handler\n   void onActivateHelp() \n   { \n      paneManager_.activateTab(Tab.Help); \n      fireEventDelayed(new ActivateHelpEvent(), 200);\n   }","commit_id":"efe6f5fbd82a39862a05d0acb0a2a57715d84e7f","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n    public void visitPolyadicExpression(PsiPolyadicExpression expression) {\n      final PsiElement parent = expression.getParent();\n      if (parent instanceof PsiInstanceOfExpression ||\n        parent instanceof PsiConditionalExpression) {\n        registerError(expression);\n        return;\n      }\n      if (parent instanceof PsiPolyadicExpression) {\n        return;\n      }\n      final IElementType tokenType = expression.getOperationTokenType();\n      final PsiExpression[] operands = expression.getOperands();\n      for (PsiExpression operand : operands) {\n        if (operand instanceof PsiInstanceOfExpression) {\n          registerError(expression);\n          return;\n        }\n        if (!(operand instanceof PsiPolyadicExpression)) {\n          continue;\n        }\n        final PsiPolyadicExpression polyadicExpression = (PsiPolyadicExpression)operand;\n        final IElementType childTokenType = polyadicExpression.getOperationTokenType();\n        if (!tokenType.equals(childTokenType)) {\n          registerError(expression);\n          return;\n        }\n      }\n      super.visitPolyadicExpression(expression);\n    }","id":65862,"modified_method":"@Override\n    public void visitPolyadicExpression(PsiPolyadicExpression expression) {\n      super.visitPolyadicExpression(expression);\n      final PsiElement parent = expression.getParent();\n      if (mightBeConfusingExpression(parent)) {\n        return;\n      }\n      final IElementType tokenType = expression.getOperationTokenType();\n      final PsiExpression[] operands = expression.getOperands();\n      for (PsiExpression operand : operands) {\n        if (operand instanceof PsiInstanceOfExpression) {\n          registerError(expression);\n          return;\n        }\n        if (!(operand instanceof PsiPolyadicExpression)) {\n          continue;\n        }\n        final PsiPolyadicExpression polyadicExpression = (PsiPolyadicExpression)operand;\n        final IElementType childTokenType = polyadicExpression.getOperationTokenType();\n        if (!tokenType.equals(childTokenType)) {\n          registerError(expression);\n          return;\n        }\n      }\n    }","commit_id":"f0cd6bc7b7249a7ba905f4c73b72fd736bc84c9d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static StringBuilder createReplacementText(PsiExpression expression, StringBuilder out) {\n      if (expression instanceof PsiPolyadicExpression) {\n        final PsiPolyadicExpression polyadicExpression = (PsiPolyadicExpression)expression;\n        final IElementType tokenType = polyadicExpression.getOperationTokenType();\n        final PsiElement parent = expression.getParent();\n        if (parent instanceof PsiPolyadicExpression) {\n          final PsiPolyadicExpression parentPolyadicExpression = (PsiPolyadicExpression)parent;\n          final IElementType parentOperationSign = parentPolyadicExpression.getOperationTokenType();\n          if (!tokenType.equals(parentOperationSign)) {\n            out.append('(');\n            createText(polyadicExpression, out);\n            out.append(')');\n            return out;\n          }\n        } else if (parent instanceof PsiConditionalExpression || parent instanceof PsiInstanceOfExpression) {\n          out.append('(');\n          createText(polyadicExpression, out);\n          out.append(')');\n          return out;\n        }\n        createText(polyadicExpression, out);\n      }\n      else if (expression instanceof PsiParenthesizedExpression) {\n        final PsiParenthesizedExpression parenthesizedExpression = (PsiParenthesizedExpression)expression;\n        final PsiExpression unwrappedExpression = parenthesizedExpression.getExpression();\n        out.append('(');\n        createReplacementText(unwrappedExpression, out);\n        out.append(')');\n      }\n      else if (expression instanceof PsiInstanceOfExpression) {\n        out.append('(');\n        out.append(expression.getText());\n        out.append(')');\n      }\n      else if (expression != null) {\n        out.append(expression.getText());\n      }\n      return out;\n    }","id":65863,"modified_method":"private static StringBuilder createReplacementText(@Nullable PsiExpression expression, StringBuilder out) {\n      if (expression instanceof PsiPolyadicExpression) {\n        final PsiPolyadicExpression polyadicExpression = (PsiPolyadicExpression)expression;\n        final IElementType tokenType = polyadicExpression.getOperationTokenType();\n        final PsiElement parent = expression.getParent();\n        if (parent instanceof PsiPolyadicExpression) {\n          final PsiPolyadicExpression parentPolyadicExpression = (PsiPolyadicExpression)parent;\n          final IElementType parentOperationSign = parentPolyadicExpression.getOperationTokenType();\n          if (!tokenType.equals(parentOperationSign)) {\n            out.append('(');\n            createText(polyadicExpression, out);\n            out.append(')');\n            return out;\n          }\n        } else if (parent instanceof PsiConditionalExpression || parent instanceof PsiInstanceOfExpression) {\n          out.append('(');\n          createText(polyadicExpression, out);\n          out.append(')');\n          return out;\n        }\n        createText(polyadicExpression, out);\n      }\n      else if (expression instanceof PsiParenthesizedExpression) {\n        final PsiParenthesizedExpression parenthesizedExpression = (PsiParenthesizedExpression)expression;\n        final PsiExpression unwrappedExpression = parenthesizedExpression.getExpression();\n        final PsiElement parent = expression.getParent();\n        if (!(parent instanceof PsiParenthesizedExpression)) {\n          out.append('(');\n          createReplacementText(unwrappedExpression, out);\n          out.append(')');\n        }\n        else {\n          createReplacementText(unwrappedExpression, out);\n        }\n      }\n      else if (expression instanceof PsiInstanceOfExpression) {\n        final PsiElement parent = expression.getParent();\n        final PsiInstanceOfExpression instanceofExpression = (PsiInstanceOfExpression)expression;\n        if (mightBeConfusingExpression(parent)) {\n          out.append('(');\n          createText(instanceofExpression, out);\n          out.append(')');\n        }\n        else {\n          createText(instanceofExpression, out);\n        }\n      }\n      else if (expression instanceof PsiConditionalExpression) {\n        final PsiElement parent = expression.getParent();\n        final PsiConditionalExpression conditionalExpression = (PsiConditionalExpression)expression;\n        if (mightBeConfusingExpression(parent)) {\n          out.append('(');\n          createText(conditionalExpression, out);\n          out.append(')');\n        }\n        else {\n          createText(conditionalExpression, out);\n        }\n      }\n      else if (expression != null) {\n        out.append(expression.getText());\n      }\n      return out;\n    }","commit_id":"f0cd6bc7b7249a7ba905f4c73b72fd736bc84c9d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    protected void doFix(Project project, ProblemDescriptor descriptor) throws IncorrectOperationException {\n      final PsiElement element = descriptor.getPsiElement();\n      if (!(element instanceof PsiPolyadicExpression)) {\n        return;\n      }\n      final PsiPolyadicExpression polyadicExpression = (PsiPolyadicExpression)element;\n      final StringBuilder newExpressionText = createReplacementText(polyadicExpression, new StringBuilder());\n      replaceExpression(polyadicExpression, newExpressionText.toString());\n    }","id":65864,"modified_method":"@Override\n    protected void doFix(Project project, ProblemDescriptor descriptor) throws IncorrectOperationException {\n      final PsiElement element = descriptor.getPsiElement();\n      if (!(element instanceof PsiExpression)) {\n        return;\n      }\n      final PsiExpression expression = (PsiExpression)element;\n      final StringBuilder newExpressionText = createReplacementText(expression, new StringBuilder());\n      replaceExpression(expression, newExpressionText.toString());\n    }","commit_id":"f0cd6bc7b7249a7ba905f4c73b72fd736bc84c9d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static StringBuilder createReplacementText(PsiExpression element,\n                                                     StringBuilder out) {\n    if (element instanceof PsiPolyadicExpression) {\n      final PsiPolyadicExpression polyadicExpression = (PsiPolyadicExpression)element;\n      final IElementType tokenType = polyadicExpression.getOperationTokenType();\n      final PsiElement parent = element.getParent();\n      if (parent instanceof PsiPolyadicExpression) {\n        final PsiPolyadicExpression parentPolyadicExpression = (PsiPolyadicExpression)parent;\n        final IElementType parentOperationSign = parentPolyadicExpression.getOperationTokenType();\n        if (!tokenType.equals(parentOperationSign)) {\n          out.append('(');\n          createReplacementText(polyadicExpression, out);\n          out.append(')');\n          return out;\n        }\n      }\n      createReplacementText(polyadicExpression, out);\n    }\n    else if (element instanceof PsiParenthesizedExpression) {\n      final PsiParenthesizedExpression parenthesizedExpression = (PsiParenthesizedExpression)element;\n      final PsiExpression expression = parenthesizedExpression.getExpression();\n      out.append('(');\n      createReplacementText(expression, out);\n      out.append(')');\n    }\n    else if (element instanceof PsiInstanceOfExpression) {\n      out.append('(');\n      out.append(element.getText());\n      out.append(')');\n    }\n    else if (element != null) {\n      out.append(element.getText());\n    }\n    return out;\n  }","id":65865,"modified_method":"private static StringBuilder createReplacementText(PsiExpression expression, StringBuilder out) {\n    if (expression instanceof PsiPolyadicExpression) {\n      final PsiPolyadicExpression polyadicExpression = (PsiPolyadicExpression)expression;\n      final IElementType tokenType = polyadicExpression.getOperationTokenType();\n      final PsiElement parent = expression.getParent();\n      if (parent instanceof PsiPolyadicExpression) {\n        final PsiPolyadicExpression parentPolyadicExpression = (PsiPolyadicExpression)parent;\n        final IElementType parentOperationSign = parentPolyadicExpression.getOperationTokenType();\n        if (!tokenType.equals(parentOperationSign)) {\n          out.append('(');\n          createText(polyadicExpression, out);\n          out.append(')');\n          return out;\n        }\n      }\n      createText(polyadicExpression, out);\n    }\n    else if (expression instanceof PsiParenthesizedExpression) {\n      final PsiParenthesizedExpression parenthesizedExpression = (PsiParenthesizedExpression)expression;\n      final PsiExpression unwrappedExpression = parenthesizedExpression.getExpression();\n      out.append('(');\n      createReplacementText(unwrappedExpression, out);\n      out.append(')');\n    }\n    else if (expression instanceof PsiInstanceOfExpression) {\n      out.append('(');\n      out.append(expression.getText());\n      out.append(')');\n    }\n    else if (expression != null) {\n      out.append(expression.getText());\n    }\n    return out;\n  }","commit_id":"e85db82328acad1b18ef18cb849e9880d02a4d31","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void createReplacementText(PsiPolyadicExpression polyadicExpression, StringBuilder out) {\n    final PsiExpression[] operands = polyadicExpression.getOperands();\n    for (PsiExpression operand : operands) {\n      if (operand == null) {\n        continue;\n      }\n      final PsiJavaToken token = polyadicExpression.getTokenBeforeOperand(operand);\n      if (token != null) {\n        final PsiElement beforeToken = operand.getNextSibling();\n        if (beforeToken instanceof PsiWhiteSpace) {\n          out.append(beforeToken.getText());\n        }\n        out.append(token.getText());\n        final PsiElement afterToken = token.getNextSibling();\n        if (afterToken instanceof PsiWhiteSpace) {\n          out.append(afterToken.getText());\n        }\n      }\n      createReplacementText(operand, out);\n    }\n  }","id":65866,"modified_method":"private static void createText(PsiPolyadicExpression polyadicExpression, StringBuilder out) {\n    final PsiExpression[] operands = polyadicExpression.getOperands();\n    for (PsiExpression operand : operands) {\n      if (operand == null) {\n        continue;\n      }\n      if (operand.getType() == PsiType.VOID) {\n        throw new ProcessCanceledException();\n      }\n      if (operands.length == 1) {\n        createReplacementText(operand, out);\n      }\n      final PsiJavaToken token = polyadicExpression.getTokenBeforeOperand(operand);\n      if (token != null) {\n        final PsiElement beforeToken = token.getPrevSibling();\n        if (beforeToken instanceof PsiWhiteSpace) {\n          out.append(beforeToken.getText());\n        }\n        out.append(token.getText());\n        final PsiElement afterToken = token.getNextSibling();\n        if (afterToken instanceof PsiWhiteSpace) {\n          out.append(afterToken.getText());\n        }\n      }\n      if (operands.length != 1) {\n        createReplacementText(operand, out);\n      }\n    }\n  }","commit_id":"e85db82328acad1b18ef18cb849e9880d02a4d31","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static StringBuilder createReplacementText(PsiExpression expression, StringBuilder out) {\n    if (expression instanceof PsiPolyadicExpression) {\n      final PsiPolyadicExpression polyadicExpression = (PsiPolyadicExpression)expression;\n      final IElementType tokenType = polyadicExpression.getOperationTokenType();\n      final PsiElement parent = expression.getParent();\n      if (parent instanceof PsiPolyadicExpression) {\n        final PsiPolyadicExpression parentPolyadicExpression = (PsiPolyadicExpression)parent;\n        final IElementType parentOperationSign = parentPolyadicExpression.getOperationTokenType();\n        if (!tokenType.equals(parentOperationSign)) {\n          out.append('(');\n          createText(polyadicExpression, out);\n          out.append(')');\n          return out;\n        }\n      }\n      createText(polyadicExpression, out);\n    }\n    else if (expression instanceof PsiParenthesizedExpression) {\n      final PsiParenthesizedExpression parenthesizedExpression = (PsiParenthesizedExpression)expression;\n      final PsiExpression unwrappedExpression = parenthesizedExpression.getExpression();\n      out.append('(');\n      createReplacementText(unwrappedExpression, out);\n      out.append(')');\n    }\n    else if (expression instanceof PsiInstanceOfExpression) {\n      out.append('(');\n      out.append(expression.getText());\n      out.append(')');\n    }\n    else if (expression != null) {\n      out.append(expression.getText());\n    }\n    return out;\n  }","id":65867,"modified_method":"private static StringBuilder createReplacementText(@Nullable PsiExpression expression, StringBuilder out) {\n    if (expression instanceof PsiPolyadicExpression) {\n      final PsiPolyadicExpression polyadicExpression = (PsiPolyadicExpression)expression;\n      final IElementType tokenType = polyadicExpression.getOperationTokenType();\n      final PsiElement parent = expression.getParent();\n      if (parent instanceof PsiPolyadicExpression) {\n        final PsiPolyadicExpression parentPolyadicExpression = (PsiPolyadicExpression)parent;\n        final IElementType parentOperationSign = parentPolyadicExpression.getOperationTokenType();\n        final boolean parentheses = !tokenType.equals(parentOperationSign);\n        appendText(polyadicExpression, parentheses, out);\n      } else {\n        final boolean parentheses = parent instanceof PsiConditionalExpression || parent instanceof PsiInstanceOfExpression;\n        appendText(polyadicExpression, parentheses, out);\n      }\n    }\n    else if (expression instanceof PsiParenthesizedExpression) {\n      final PsiParenthesizedExpression parenthesizedExpression = (PsiParenthesizedExpression)expression;\n      final PsiExpression unwrappedExpression = parenthesizedExpression.getExpression();\n      final PsiElement parent = expression.getParent();\n      if (!(parent instanceof PsiParenthesizedExpression)) {\n        out.append('(');\n        createReplacementText(unwrappedExpression, out);\n        out.append(')');\n      }\n      else {\n        createReplacementText(unwrappedExpression, out);\n      }\n    }\n    else if (expression instanceof PsiInstanceOfExpression) {\n      final PsiInstanceOfExpression instanceofExpression = (PsiInstanceOfExpression)expression;\n      final PsiElement parent = expression.getParent();\n      final boolean parentheses = mightBeConfusingExpression(parent);\n      appendText(instanceofExpression, parentheses, out);\n    }\n    else if (expression instanceof PsiConditionalExpression) {\n      final PsiConditionalExpression conditionalExpression = (PsiConditionalExpression)expression;\n      final PsiElement parent = expression.getParent();\n      final boolean parentheses = mightBeConfusingExpression(parent);\n      appendText(conditionalExpression, parentheses, out);\n    }\n    else if (expression instanceof PsiAssignmentExpression) {\n      final PsiAssignmentExpression assignmentExpression = (PsiAssignmentExpression)expression;\n      final PsiElement parent = expression.getParent();\n      final boolean parentheses = mightBeConfusingExpression(parent) && !isSimpleAssignment(assignmentExpression, parent);\n      appendText(assignmentExpression, parentheses, out);\n    }\n    else if (expression != null) {\n      out.append(expression.getText());\n    }\n    return out;\n  }","commit_id":"137b4f00f7ac2d6ef136eade2cd7c70422013d63","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void createText(PsiPolyadicExpression polyadicExpression, StringBuilder out) {\n    final PsiExpression[] operands = polyadicExpression.getOperands();\n    for (PsiExpression operand : operands) {\n      if (operand == null) {\n        continue;\n      }\n      if (operand.getType() == PsiType.VOID) {\n        throw new ProcessCanceledException();\n      }\n      if (operands.length == 1) {\n        createReplacementText(operand, out);\n      }\n      final PsiJavaToken token = polyadicExpression.getTokenBeforeOperand(operand);\n      if (token != null) {\n        final PsiElement beforeToken = token.getPrevSibling();\n        if (beforeToken instanceof PsiWhiteSpace) {\n          out.append(beforeToken.getText());\n        }\n        out.append(token.getText());\n        final PsiElement afterToken = token.getNextSibling();\n        if (afterToken instanceof PsiWhiteSpace) {\n          out.append(afterToken.getText());\n        }\n      }\n      if (operands.length != 1) {\n        createReplacementText(operand, out);\n      }\n    }\n  }","id":65868,"modified_method":"private static void appendText(PsiPolyadicExpression polyadicExpression, boolean parentheses, StringBuilder out) {\n    if (parentheses) {\n      out.append('(');\n    }\n    final PsiExpression[] operands = polyadicExpression.getOperands();\n    for (PsiExpression operand : operands) {\n      if (operand == null) {\n        continue;\n      }\n      if (operand.getType() == PsiType.VOID) {\n        throw new ProcessCanceledException();\n      }\n      if (operands.length == 1) {\n        createReplacementText(operand, out);\n      }\n      final PsiJavaToken token = polyadicExpression.getTokenBeforeOperand(operand);\n      if (token != null) {\n        final PsiElement beforeToken = token.getPrevSibling();\n        if (beforeToken instanceof PsiWhiteSpace) {\n          out.append(beforeToken.getText());\n        }\n        out.append(token.getText());\n        final PsiElement afterToken = token.getNextSibling();\n        if (afterToken instanceof PsiWhiteSpace) {\n          out.append(afterToken.getText());\n        }\n      }\n      if (operands.length != 1) {\n        createReplacementText(operand, out);\n      }\n    }\n    if (parentheses) {\n      out.append(')');\n    }\n  }","commit_id":"137b4f00f7ac2d6ef136eade2cd7c70422013d63","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean satisfiedBy(@NotNull PsiElement element) {\n    final PsiElement parent = element.getParent();\n    if (element instanceof PsiParenthesizedExpression) {\n      return false;\n    }\n    if (element instanceof PsiPolyadicExpression) {\n      final PsiPolyadicExpression polyadicExpression = (PsiPolyadicExpression)element;\n      final IElementType tokenType = polyadicExpression.getOperationTokenType();\n      if (parent instanceof PsiExpression) {\n        final PsiExpression expression = (PsiExpression)parent;\n        if (needsParentheses(expression, tokenType)) {\n          return true;\n        }\n      }\n      final PsiExpression[] operands = polyadicExpression.getOperands();\n      for (PsiExpression operand : operands) {\n        if (needsParentheses(operand, tokenType)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    if (parent instanceof PsiConditionalExpression) {\n      final PsiConditionalExpression conditionalExpression = (PsiConditionalExpression)parent;\n      final PsiExpression condition = conditionalExpression.getCondition();\n      return element == condition;\n    }\n    return element instanceof PsiInstanceOfExpression && parent instanceof PsiPolyadicExpression;\n  }","id":65869,"modified_method":"public boolean satisfiedBy(@NotNull PsiElement element) {\n    final PsiElement parent = element.getParent();\n    if (mightBeConfusingExpression(parent)) {\n      return false;\n    }\n    if (element instanceof PsiPolyadicExpression) {\n      final PsiPolyadicExpression polyadicExpression = (PsiPolyadicExpression)element;\n      final IElementType tokenType = polyadicExpression.getOperationTokenType();\n      final PsiExpression[] operands = polyadicExpression.getOperands();\n      for (PsiExpression operand : operands) {\n        if (operand instanceof PsiInstanceOfExpression) {\n          return true;\n        }\n        if (!(operand instanceof PsiPolyadicExpression)) {\n          continue;\n        }\n        final PsiPolyadicExpression expression = (PsiPolyadicExpression)operand;\n        final IElementType otherTokenType = expression.getOperationTokenType();\n        if (!tokenType.equals(otherTokenType)) {\n          return true;\n        }\n      }\n    }\n    else if (element instanceof PsiConditionalExpression) {\n      final PsiConditionalExpression conditionalExpression = (PsiConditionalExpression)element;\n      final PsiExpression condition = conditionalExpression.getCondition();\n      if (mightBeConfusingExpression(condition)) {\n        return true;\n      }\n      final PsiExpression thenExpression = conditionalExpression.getThenExpression();\n      if (mightBeConfusingExpression(thenExpression)) {\n        return true;\n      }\n      final PsiExpression elseExpression = conditionalExpression.getElseExpression();\n      if (mightBeConfusingExpression(elseExpression)) {\n        return true;\n      }\n    }\n    else if (element instanceof PsiInstanceOfExpression) {\n      final PsiInstanceOfExpression instanceOfExpression = (PsiInstanceOfExpression)element;\n      final PsiExpression operand = instanceOfExpression.getOperand();\n      if (mightBeConfusingExpression(operand)) {\n        return true;\n      }\n    }\n    else if (element instanceof PsiAssignmentExpression) {\n      final PsiAssignmentExpression assignmentExpression = (PsiAssignmentExpression)element;\n      final PsiExpression rhs = assignmentExpression.getRExpression();\n      if (!(mightBeConfusingExpression(rhs))) {\n        return false;\n      }\n      if (rhs instanceof PsiAssignmentExpression) {\n        final PsiAssignmentExpression nestedAssignment = (PsiAssignmentExpression)rhs;\n        final IElementType nestedTokenType = nestedAssignment.getOperationTokenType();\n        final IElementType tokenType = assignmentExpression.getOperationTokenType();\n        if (nestedTokenType.equals(tokenType)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }","commit_id":"137b4f00f7ac2d6ef136eade2cd7c70422013d63","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ConsensusModule( MemberId myself, final PlatformModule platformModule,\n                            RaftOutbound raftOutbound, File clusterStateDirectory,\n                            CoreTopologyService discoveryService )\n    {\n        final Dependencies dependencies = platformModule.dependencies;\n        final Config config = platformModule.config;\n        final LogService logging = platformModule.logging;\n        final FileSystemAbstraction fileSystem = platformModule.fileSystem;\n        final LifeSupport life = platformModule.life;\n\n        LogProvider logProvider = logging.getInternalLogProvider();\n        final Supplier<DatabaseHealth> databaseHealthSupplier = dependencies.provideDependency( DatabaseHealth.class );\n\n        final CoreReplicatedContentMarshal marshal = new CoreReplicatedContentMarshal();\n        int maxQueueSize = config.get( CoreEdgeClusterSettings.outgoing_queue_size );\n        final SenderService senderService =\n                new SenderService( new RaftChannelInitializer( marshal, logProvider ), logProvider, platformModule.monitors,\n                        maxQueueSize, new NonBlockingChannels() );\n        life.add( senderService );\n\n        final MessageLogger<MemberId> messageLogger;\n        if ( config.get( CoreEdgeClusterSettings.raft_messages_log_enable ) )\n        {\n            File logsDir = config.get( GraphDatabaseSettings.logs_directory );\n            messageLogger = life.add( new BetterMessageLogger<>( myself, raftMessagesLog( logsDir ) ) );\n        }\n        else\n        {\n            messageLogger = new NullMessageLogger<>();\n        }\n\n        RaftLog underlyingLog = createRaftLog( config, life, fileSystem, clusterStateDirectory, marshal, logProvider );\n\n        raftLog = new MonitoredRaftLog( underlyingLog, platformModule.monitors );\n\n        Outbound<MemberId,RaftMessages.RaftMessage> loggingOutbound = new LoggingOutbound<>(\n                raftOutbound, myself, messageLogger );\n\n        InFlightMap<Long,RaftLogEntry> inFlightMap = new InFlightMap<>();\n\n        StateStorage<TermState> termState;\n        StateStorage<VoteState> voteState;\n        StateStorage<RaftMembershipState> raftMembershipStorage;\n\n        try\n        {\n            StateStorage<TermState> durableTermState = life.add(\n                    new DurableStateStorage<>( fileSystem, new File( clusterStateDirectory, \"term-state\" ),\n                            \"term-state\", new TermState.Marshal(),\n                            config.get( CoreEdgeClusterSettings.term_state_size ), databaseHealthSupplier,\n                            logProvider ) );\n\n            termState = new MonitoredTermStateStorage( durableTermState, platformModule.monitors );\n\n            voteState = life.add(\n                    new DurableStateStorage<>( fileSystem, new File( clusterStateDirectory, \"vote-state\" ),\n                            \"vote-state\", new VoteState.Marshal( new MemberId.MemberIdMarshal() ),\n                            config.get( CoreEdgeClusterSettings.vote_state_size ), databaseHealthSupplier,\n                            logProvider ) );\n\n            raftMembershipStorage = life.add(\n                    new DurableStateStorage<>( fileSystem, new File( clusterStateDirectory, \"membership-state\" ),\n                            \"membership-state\", new RaftMembershipState.Marshal(),\n                            config.get( CoreEdgeClusterSettings.raft_membership_state_size ), databaseHealthSupplier,\n                            logProvider ) );\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n\n        long electionTimeout1 = config.get( CoreEdgeClusterSettings.leader_election_timeout );\n        long heartbeatInterval = electionTimeout1 / 3;\n\n        Integer expectedClusterSize = config.get( CoreEdgeClusterSettings.expected_core_cluster_size );\n\n        MemberIdSetBuilder memberSetBuilder = new MemberIdSetBuilder();\n\n        SendToMyself leaderOnlyReplicator =\n                new SendToMyself( myself, loggingOutbound );\n\n        raftMembershipManager = new RaftMembershipManager( leaderOnlyReplicator, memberSetBuilder, raftLog, logProvider,\n               expectedClusterSize, electionTimeout1, systemUTC(),\n               config.get( CoreEdgeClusterSettings.join_catch_up_timeout ), raftMembershipStorage\n        );\n\n        life.add( raftMembershipManager );\n\n        RaftLogShippingManager logShipping =\n                new RaftLogShippingManager( loggingOutbound, logProvider, raftLog, systemUTC(),\n                        myself, raftMembershipManager, electionTimeout1,\n                        config.get( CoreEdgeClusterSettings.catchup_batch_size ),\n                        config.get( CoreEdgeClusterSettings.log_shipping_max_lag ), inFlightMap );\n\n        raftTimeoutService = new DelayedRenewableTimeoutService( systemUTC(), logProvider );\n\n        raftInstance =\n                new RaftInstance( myself, termState, voteState, raftLog, electionTimeout1,\n                        heartbeatInterval, raftTimeoutService, loggingOutbound, logProvider, raftMembershipManager,\n                        logShipping, inFlightMap, platformModule.monitors );\n\n        life.add( new RaftDiscoveryServiceConnector( discoveryService, raftInstance ) );\n\n        life.add(logShipping);\n    }","id":65870,"modified_method":"public ConsensusModule( MemberId myself, final PlatformModule platformModule,\n                            RaftOutbound raftOutbound, File clusterStateDirectory,\n                            CoreTopologyService discoveryService )\n    {\n        final Dependencies dependencies = platformModule.dependencies;\n        final Config config = platformModule.config;\n        final LogService logging = platformModule.logging;\n        final FileSystemAbstraction fileSystem = platformModule.fileSystem;\n        final LifeSupport life = platformModule.life;\n\n        LogProvider logProvider = logging.getInternalLogProvider();\n        final Supplier<DatabaseHealth> databaseHealthSupplier = dependencies.provideDependency( DatabaseHealth.class );\n\n        final CoreReplicatedContentMarshal marshal = new CoreReplicatedContentMarshal();\n        int maxQueueSize = config.get( CoreEdgeClusterSettings.outgoing_queue_size );\n        final SenderService senderService =\n                new SenderService( new RaftChannelInitializer( marshal, logProvider ), logProvider, platformModule.monitors,\n                        maxQueueSize, new NonBlockingChannels() );\n        life.add( senderService );\n\n        final MessageLogger<MemberId> messageLogger;\n        if ( config.get( CoreEdgeClusterSettings.raft_messages_log_enable ) )\n        {\n            File logsDir = config.get( GraphDatabaseSettings.logs_directory );\n            messageLogger = life.add( new BetterMessageLogger<>( myself, raftMessagesLog( logsDir ) ) );\n        }\n        else\n        {\n            messageLogger = new NullMessageLogger<>();\n        }\n\n        RaftLog underlyingLog = createRaftLog( config, life, fileSystem, clusterStateDirectory, marshal, logProvider );\n\n        raftLog = new MonitoredRaftLog( underlyingLog, platformModule.monitors );\n\n        Outbound<MemberId,RaftMessages.RaftMessage> loggingOutbound = new LoggingOutbound<>(\n                raftOutbound, myself, messageLogger );\n\n        InFlightMap<Long,RaftLogEntry> inFlightMap = new InFlightMap<>();\n\n        StateStorage<TermState> termState;\n        StateStorage<VoteState> voteState;\n        StateStorage<RaftMembershipState> raftMembershipStorage;\n\n        try\n        {\n            StateStorage<TermState> durableTermState = life.add(\n                    new DurableStateStorage<>( fileSystem, clusterStateDirectory, RAFT_TERM_NAME,\n                            new TermState.Marshal(), config.get( CoreEdgeClusterSettings.term_state_size ),\n                            databaseHealthSupplier, logProvider ) );\n\n            termState = new MonitoredTermStateStorage( durableTermState, platformModule.monitors );\n\n            voteState = life.add(\n                    new DurableStateStorage<>( fileSystem, clusterStateDirectory, RAFT_VOTE_NAME,\n                            new VoteState.Marshal( new MemberId.MemberIdMarshal() ),\n                            config.get( CoreEdgeClusterSettings.vote_state_size ), databaseHealthSupplier,\n                            logProvider ) );\n\n            raftMembershipStorage = life.add(\n                    new DurableStateStorage<>( fileSystem, clusterStateDirectory, RAFT_MEMBERSHIP_NAME,\n                            new RaftMembershipState.Marshal(), config.get( CoreEdgeClusterSettings.raft_membership_state_size ),\n                            databaseHealthSupplier, logProvider ) );\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n\n        long electionTimeout1 = config.get( CoreEdgeClusterSettings.leader_election_timeout );\n        long heartbeatInterval = electionTimeout1 / 3;\n\n        Integer expectedClusterSize = config.get( CoreEdgeClusterSettings.expected_core_cluster_size );\n\n        MemberIdSetBuilder memberSetBuilder = new MemberIdSetBuilder();\n\n        SendToMyself leaderOnlyReplicator =\n                new SendToMyself( myself, loggingOutbound );\n\n        raftMembershipManager = new RaftMembershipManager( leaderOnlyReplicator, memberSetBuilder, raftLog, logProvider,\n               expectedClusterSize, electionTimeout1, systemUTC(),\n               config.get( CoreEdgeClusterSettings.join_catch_up_timeout ), raftMembershipStorage\n        );\n\n        life.add( raftMembershipManager );\n\n        RaftLogShippingManager logShipping =\n                new RaftLogShippingManager( loggingOutbound, logProvider, raftLog, systemUTC(),\n                        myself, raftMembershipManager, electionTimeout1,\n                        config.get( CoreEdgeClusterSettings.catchup_batch_size ),\n                        config.get( CoreEdgeClusterSettings.log_shipping_max_lag ), inFlightMap );\n\n        raftTimeoutService = new DelayedRenewableTimeoutService( systemUTC(), logProvider );\n\n        raftInstance =\n                new RaftInstance( myself, termState, voteState, raftLog, electionTimeout1,\n                        heartbeatInterval, raftTimeoutService, loggingOutbound, logProvider, raftMembershipManager,\n                        logShipping, inFlightMap, platformModule.monitors );\n\n        life.add( new RaftDiscoveryServiceConnector( discoveryService, raftInstance ) );\n\n        life.add(logShipping);\n    }","commit_id":"4e06d5f9d7d0d68156f0f7669f3997902ad6566c","url":"https://github.com/neo4j/neo4j"},{"original_method":"public CoreServerModule( MemberId myself, final PlatformModule platformModule, ConsensusModule consensusModule, CoreStateMachinesModule coreStateMachinesModule, ReplicationModule replicationModule, File clusterStateDirectory, CoreTopologyService\n            discoveryService, LocalDatabase localDatabase, MessageLogger<MemberId> messageLogger )\n    {\n        final Dependencies dependencies = platformModule.dependencies;\n        final Config config = platformModule.config;\n        final LogService logging = platformModule.logging;\n        final FileSystemAbstraction fileSystem = platformModule.fileSystem;\n        final LifeSupport life = platformModule.life;\n        LogProvider logProvider = logging.getInternalLogProvider();\n\n        final Supplier<DatabaseHealth> databaseHealthSupplier = dependencies.provideDependency( DatabaseHealth.class );\n\n        StateStorage<Long> lastFlushedStorage;\n\n        try\n        {\n            lastFlushedStorage = life.add(\n                    new DurableStateStorage<>( fileSystem, new File( clusterStateDirectory, \"last-flushed-state\" ),\n                            \"last-flushed\", new LongIndexMarshal(), config.get( CoreEdgeClusterSettings.last_flushed_state_size ),\n                            databaseHealthSupplier, logProvider ) );\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n        consensusModule.raftMembershipManager().setRecoverFromIndex( lastFlushedStorage.getInitialState() );\n\n        ListenSocketAddress raftListenAddress = config.get( CoreEdgeClusterSettings.raft_listen_address );\n\n        RaftServer raftServer = new RaftServer( new CoreReplicatedContentMarshal(), raftListenAddress, logProvider );\n\n        LoggingInbound<RaftMessages.StoreIdAwareMessage> loggingRaftInbound =\n                new LoggingInbound<>( raftServer, messageLogger, myself );\n\n        NonBlockingChannels nonBlockingChannels = new NonBlockingChannels();\n\n        CoreToCoreClient.ChannelInitializer channelInitializer =\n                new CoreToCoreClient.ChannelInitializer( logProvider, nonBlockingChannels );\n\n        int maxQueueSize = config.get( CoreEdgeClusterSettings.outgoing_queue_size );\n        long logThresholdMillis = config.get( CoreEdgeClusterSettings.unknown_address_logging_throttle );\n\n        CoreToCoreClient coreToCoreClient = life.add(\n                new CoreToCoreClient( logProvider, channelInitializer, platformModule.monitors, maxQueueSize,\n                        nonBlockingChannels, discoveryService, logThresholdMillis ) );\n        channelInitializer.setOwner( coreToCoreClient );\n\n        StoreFetcher storeFetcher = new StoreFetcher( logProvider, fileSystem, platformModule.pageCache,\n                new StoreCopyClient( coreToCoreClient ), new TxPullClient( coreToCoreClient ),\n                new TransactionLogCatchUpFactory() );\n\n        CoreStateApplier coreStateApplier = new CoreStateApplier( logProvider );\n        CoreStateDownloader downloader = new CoreStateDownloader( localDatabase, storeFetcher,\n                coreToCoreClient, logProvider );\n\n        InFlightMap<Long,RaftLogEntry> inFlightMap = new InFlightMap<>();\n\n        NotMyselfSelectionStrategy someoneElse = new NotMyselfSelectionStrategy( discoveryService, myself );\n\n        CoreState coreState = new CoreState( coreStateMachinesModule.coreStateMachines, consensusModule.raftLog(),\n                config.get( CoreEdgeClusterSettings.state_machine_apply_max_batch_size ),\n                config.get( CoreEdgeClusterSettings.state_machine_flush_window_size ), databaseHealthSupplier,\n                logProvider, replicationModule.getProgressTracker(), lastFlushedStorage,\n                replicationModule.getSessionTracker(), someoneElse, coreStateApplier, downloader, inFlightMap,\n                platformModule.monitors );\n\n        dependencies.satisfyDependency( coreState );\n\n        life.add( new PruningScheduler( coreState, platformModule.jobScheduler,\n                config.get( CoreEdgeClusterSettings.raft_log_pruning_frequency ) ) );\n\n        int queueSize = config.get( CoreEdgeClusterSettings.raft_in_queue_size );\n        int maxBatch = config.get( CoreEdgeClusterSettings.raft_in_queue_max_batch );\n\n        BatchingMessageHandler batchingMessageHandler =\n                new BatchingMessageHandler( consensusModule.raftInstance(), logProvider, queueSize, maxBatch, localDatabase, coreState );\n\n        long electionTimeout = config.get( CoreEdgeClusterSettings.leader_election_timeout );\n\n        MembershipWaiter membershipWaiter =\n                new MembershipWaiter( myself, platformModule.jobScheduler, electionTimeout * 4, batchingMessageHandler, logProvider );\n        long joinCatchupTimeout = config.get( CoreEdgeClusterSettings.join_catch_up_timeout );\n        membershipWaiterLifecycle = new MembershipWaiterLifecycle( membershipWaiter,\n                joinCatchupTimeout, consensusModule.raftInstance(), logProvider );\n\n        life.add( new ContinuousJob( platformModule.jobScheduler, new JobScheduler.Group( \"raft-batch-handler\", NEW_THREAD ),\n                batchingMessageHandler ) );\n\n        loggingRaftInbound.registerHandler( batchingMessageHandler );\n\n        CatchupServer catchupServer = new CatchupServer( logProvider, localDatabase,\n                platformModule.dependencies.provideDependency( TransactionIdStore.class ),\n                platformModule.dependencies.provideDependency( LogicalTransactionStore.class ),\n                new DataSourceSupplier( platformModule ), new CheckpointerSupplier( platformModule.dependencies ),\n                coreState, config.get( CoreEdgeClusterSettings.transaction_listen_address ), platformModule.monitors );\n\n        startupLifecycle = new LifeSupport();\n        startupLifecycle.add( coreState );\n        startupLifecycle.add( raftServer );\n        startupLifecycle.add( catchupServer );\n    }","id":65871,"modified_method":"public CoreServerModule( MemberId myself, final PlatformModule platformModule, ConsensusModule consensusModule, CoreStateMachinesModule coreStateMachinesModule, ReplicationModule replicationModule, File clusterStateDirectory, CoreTopologyService\n            discoveryService, LocalDatabase localDatabase, MessageLogger<MemberId> messageLogger )\n    {\n        final Dependencies dependencies = platformModule.dependencies;\n        final Config config = platformModule.config;\n        final LogService logging = platformModule.logging;\n        final FileSystemAbstraction fileSystem = platformModule.fileSystem;\n        final LifeSupport life = platformModule.life;\n        LogProvider logProvider = logging.getInternalLogProvider();\n\n        final Supplier<DatabaseHealth> databaseHealthSupplier = dependencies.provideDependency( DatabaseHealth.class );\n\n        StateStorage<Long> lastFlushedStorage;\n\n        try\n        {\n            lastFlushedStorage = life.add(\n                    new DurableStateStorage<>( fileSystem, clusterStateDirectory, ReplicationModule.LAST_FLUSHED_NAME,\n                            new LongIndexMarshal(), config.get( CoreEdgeClusterSettings.last_flushed_state_size ),\n                            databaseHealthSupplier, logProvider ) );\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n        consensusModule.raftMembershipManager().setRecoverFromIndex( lastFlushedStorage.getInitialState() );\n\n        ListenSocketAddress raftListenAddress = config.get( CoreEdgeClusterSettings.raft_listen_address );\n\n        RaftServer raftServer = new RaftServer( new CoreReplicatedContentMarshal(), raftListenAddress, logProvider );\n\n        LoggingInbound<RaftMessages.StoreIdAwareMessage> loggingRaftInbound =\n                new LoggingInbound<>( raftServer, messageLogger, myself );\n\n        NonBlockingChannels nonBlockingChannels = new NonBlockingChannels();\n\n        CoreToCoreClient.ChannelInitializer channelInitializer =\n                new CoreToCoreClient.ChannelInitializer( logProvider, nonBlockingChannels );\n\n        int maxQueueSize = config.get( CoreEdgeClusterSettings.outgoing_queue_size );\n        long logThresholdMillis = config.get( CoreEdgeClusterSettings.unknown_address_logging_throttle );\n\n        CoreToCoreClient coreToCoreClient = life.add(\n                new CoreToCoreClient( logProvider, channelInitializer, platformModule.monitors, maxQueueSize,\n                        nonBlockingChannels, discoveryService, logThresholdMillis ) );\n        channelInitializer.setOwner( coreToCoreClient );\n\n        StoreFetcher storeFetcher = new StoreFetcher( logProvider, fileSystem, platformModule.pageCache,\n                new StoreCopyClient( coreToCoreClient ), new TxPullClient( coreToCoreClient ),\n                new TransactionLogCatchUpFactory() );\n\n        CoreStateApplier coreStateApplier = new CoreStateApplier( logProvider );\n        CoreStateDownloader downloader = new CoreStateDownloader( localDatabase, storeFetcher,\n                coreToCoreClient, logProvider );\n\n        InFlightMap<Long,RaftLogEntry> inFlightMap = new InFlightMap<>();\n\n        NotMyselfSelectionStrategy someoneElse = new NotMyselfSelectionStrategy( discoveryService, myself );\n\n        CoreState coreState = new CoreState( coreStateMachinesModule.coreStateMachines, consensusModule.raftLog(),\n                config.get( CoreEdgeClusterSettings.state_machine_apply_max_batch_size ),\n                config.get( CoreEdgeClusterSettings.state_machine_flush_window_size ), databaseHealthSupplier,\n                logProvider, replicationModule.getProgressTracker(), lastFlushedStorage,\n                replicationModule.getSessionTracker(), someoneElse, coreStateApplier, downloader, inFlightMap,\n                platformModule.monitors );\n\n        dependencies.satisfyDependency( coreState );\n\n        life.add( new PruningScheduler( coreState, platformModule.jobScheduler,\n                config.get( CoreEdgeClusterSettings.raft_log_pruning_frequency ) ) );\n\n        int queueSize = config.get( CoreEdgeClusterSettings.raft_in_queue_size );\n        int maxBatch = config.get( CoreEdgeClusterSettings.raft_in_queue_max_batch );\n\n        BatchingMessageHandler batchingMessageHandler =\n                new BatchingMessageHandler( consensusModule.raftInstance(), logProvider, queueSize, maxBatch, localDatabase, coreState );\n\n        long electionTimeout = config.get( CoreEdgeClusterSettings.leader_election_timeout );\n\n        MembershipWaiter membershipWaiter =\n                new MembershipWaiter( myself, platformModule.jobScheduler, electionTimeout * 4, batchingMessageHandler, logProvider );\n        long joinCatchupTimeout = config.get( CoreEdgeClusterSettings.join_catch_up_timeout );\n        membershipWaiterLifecycle = new MembershipWaiterLifecycle( membershipWaiter,\n                joinCatchupTimeout, consensusModule.raftInstance(), logProvider );\n\n        life.add( new ContinuousJob( platformModule.jobScheduler, new JobScheduler.Group( \"raft-batch-handler\", NEW_THREAD ),\n                batchingMessageHandler ) );\n\n        loggingRaftInbound.registerHandler( batchingMessageHandler );\n\n        CatchupServer catchupServer = new CatchupServer( logProvider, localDatabase,\n                platformModule.dependencies.provideDependency( TransactionIdStore.class ),\n                platformModule.dependencies.provideDependency( LogicalTransactionStore.class ),\n                new DataSourceSupplier( platformModule ), new CheckpointerSupplier( platformModule.dependencies ),\n                coreState, config.get( CoreEdgeClusterSettings.transaction_listen_address ), platformModule.monitors );\n\n        startupLifecycle = new LifeSupport();\n        startupLifecycle.add( coreState );\n        startupLifecycle.add( raftServer );\n        startupLifecycle.add( catchupServer );\n    }","commit_id":"4e06d5f9d7d0d68156f0f7669f3997902ad6566c","url":"https://github.com/neo4j/neo4j"},{"original_method":"public CoreStateMachinesModule( MemberId myself, PlatformModule platformModule, File clusterStateDirectory,\n                                    Supplier<DatabaseHealth> databaseHealthSupplier, Config config,\n                                    RaftReplicator replicator, LeaderLocator leaderLocator,\n                                    Dependencies dependencies, LocalDatabase localDatabase )\n    {\n        StateStorage<IdAllocationState> idAllocationState;\n        StateStorage<ReplicatedLockTokenState> lockTokenState;\n        final LifeSupport life = platformModule.life;\n        final FileSystemAbstraction fileSystem = platformModule.fileSystem;\n        LogService logging = platformModule.logging;\n        LogProvider logProvider = logging.getInternalLogProvider();\n\n        try\n        {\n            lockTokenState = life.add(\n                    new DurableStateStorage<>( fileSystem, new File( clusterStateDirectory, \"lock-token-state\" ),\n                            \"lock-token\", new ReplicatedLockTokenState.Marshal( new MemberId.MemberIdMarshal() ),\n                            config.get( CoreEdgeClusterSettings.replicated_lock_token_state_size ),\n                            databaseHealthSupplier, logProvider ) );\n\n            idAllocationState = life.add(\n                    new DurableStateStorage<>( fileSystem, new File( clusterStateDirectory, \"id-allocation-state\" ),\n                            \"id-allocation\", new IdAllocationState.Marshal(),\n                            config.get( CoreEdgeClusterSettings.id_alloc_state_size ), databaseHealthSupplier,\n                            logProvider ) );\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n\n        ReplicatedIdAllocationStateMachine idAllocationStateMachine =\n                new ReplicatedIdAllocationStateMachine( idAllocationState );\n\n        int allocationChunk = 1024; // TODO: AllocationChunk should be configurable and per type.\n        ReplicatedIdRangeAcquirer idRangeAcquirer =\n                new ReplicatedIdRangeAcquirer( replicator, idAllocationStateMachine, allocationChunk, myself,\n                        logProvider );\n\n        idTypeConfigurationProvider = new EnterpriseIdTypeConfigurationProvider( config );\n        replicatedIdGeneratorFactory = createIdGeneratorFactory( fileSystem, idRangeAcquirer, logProvider,\n                idTypeConfigurationProvider );\n\n        this.idGeneratorFactory = dependencies.satisfyDependency( replicatedIdGeneratorFactory );\n        dependencies.satisfyDependency( new IdBasedStoreEntityCounters( this.idGeneratorFactory ) );\n\n        Long tokenCreationTimeout = config.get( CoreEdgeClusterSettings.token_creation_timeout );\n\n        TokenRegistry<RelationshipTypeToken> relationshipTypeTokenRegistry = new TokenRegistry<>( \"RelationshipType\" );\n        ReplicatedRelationshipTypeTokenHolder relationshipTypeTokenHolder =\n                new ReplicatedRelationshipTypeTokenHolder( relationshipTypeTokenRegistry, replicator,\n                        this.idGeneratorFactory, dependencies, tokenCreationTimeout );\n\n        TokenRegistry<Token> propertyKeyTokenRegistry = new TokenRegistry<>( \"PropertyKey\" );\n        ReplicatedPropertyKeyTokenHolder propertyKeyTokenHolder =\n                new ReplicatedPropertyKeyTokenHolder( propertyKeyTokenRegistry, replicator, this.idGeneratorFactory,\n                        dependencies, tokenCreationTimeout );\n\n        TokenRegistry<Token> labelTokenRegistry = new TokenRegistry<>( \"Label\" );\n        ReplicatedLabelTokenHolder labelTokenHolder =\n                new ReplicatedLabelTokenHolder( labelTokenRegistry, replicator, this.idGeneratorFactory, dependencies,\n                        tokenCreationTimeout );\n\n        ReplicatedLockTokenStateMachine replicatedLockTokenStateMachine =\n                new ReplicatedLockTokenStateMachine( lockTokenState );\n\n        RecoverTransactionLogState txLogState = new RecoverTransactionLogState( dependencies, logProvider );\n\n        ReplicatedTokenStateMachine<Token> labelTokenStateMachine =\n                new ReplicatedTokenStateMachine<>( labelTokenRegistry, new Token.Factory(), logProvider );\n\n        ReplicatedTokenStateMachine<Token> propertyKeyTokenStateMachine =\n                new ReplicatedTokenStateMachine<>( propertyKeyTokenRegistry, new Token.Factory(), logProvider );\n\n        ReplicatedTokenStateMachine<RelationshipTypeToken> relationshipTypeTokenStateMachine =\n                new ReplicatedTokenStateMachine<>( relationshipTypeTokenRegistry, new RelationshipTypeToken.Factory(),\n                        logProvider );\n\n        ReplicatedTransactionStateMachine replicatedTxStateMachine =\n                new ReplicatedTransactionStateMachine( replicatedLockTokenStateMachine,\n                        config.get( CoreEdgeClusterSettings.state_machine_apply_max_batch_size ), logProvider );\n\n        dependencies.satisfyDependencies( replicatedTxStateMachine );\n\n        long leaderLockTokenTimeout = config.get( CoreEdgeClusterSettings.leader_lock_token_timeout );\n        lockManager = createLockManager( config, logging, replicator, myself, leaderLocator, leaderLockTokenTimeout,\n                replicatedLockTokenStateMachine );\n\n        coreStateMachines = new CoreStateMachines( replicatedTxStateMachine, labelTokenStateMachine,\n                relationshipTypeTokenStateMachine, propertyKeyTokenStateMachine, replicatedLockTokenStateMachine,\n                idAllocationStateMachine, txLogState, localDatabase );\n\n        commitProcessFactory = ( appender, applier, ignored ) -> {\n            TransactionRepresentationCommitProcess localCommit =\n                    new TransactionRepresentationCommitProcess( appender, applier );\n            coreStateMachines.refresh( localCommit ); // This gets called when a core-to-core download is performed.\n            return new ReplicatedTransactionCommitProcess( replicator );\n        };\n\n        this.relationshipTypeTokenHolder = relationshipTypeTokenHolder;\n        this.propertyKeyTokenHolder = propertyKeyTokenHolder;\n        this.labelTokenHolder = labelTokenHolder;\n    }","id":65872,"modified_method":"public CoreStateMachinesModule( MemberId myself, PlatformModule platformModule, File clusterStateDirectory,\n                                    Supplier<DatabaseHealth> databaseHealthSupplier, Config config,\n                                    RaftReplicator replicator, LeaderLocator leaderLocator,\n                                    Dependencies dependencies, LocalDatabase localDatabase )\n    {\n        StateStorage<IdAllocationState> idAllocationState;\n        StateStorage<ReplicatedLockTokenState> lockTokenState;\n        final LifeSupport life = platformModule.life;\n        final FileSystemAbstraction fileSystem = platformModule.fileSystem;\n        LogService logging = platformModule.logging;\n        LogProvider logProvider = logging.getInternalLogProvider();\n\n        try\n        {\n            lockTokenState = life.add(\n                    new DurableStateStorage<>( fileSystem, clusterStateDirectory, LOCK_TOKEN_NAME,\n                            new ReplicatedLockTokenState.Marshal( new MemberId.MemberIdMarshal() ),\n                            config.get( CoreEdgeClusterSettings.replicated_lock_token_state_size ),\n                            databaseHealthSupplier, logProvider ) );\n\n            idAllocationState = life.add(\n                    new DurableStateStorage<>( fileSystem, clusterStateDirectory, ID_ALLOCATION_NAME,\n                            new IdAllocationState.Marshal(),\n                            config.get( CoreEdgeClusterSettings.id_alloc_state_size ), databaseHealthSupplier,\n                            logProvider ) );\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n\n        ReplicatedIdAllocationStateMachine idAllocationStateMachine =\n                new ReplicatedIdAllocationStateMachine( idAllocationState );\n\n        int allocationChunk = 1024; // TODO: AllocationChunk should be configurable and per type.\n        ReplicatedIdRangeAcquirer idRangeAcquirer =\n                new ReplicatedIdRangeAcquirer( replicator, idAllocationStateMachine, allocationChunk, myself,\n                        logProvider );\n\n        idTypeConfigurationProvider = new EnterpriseIdTypeConfigurationProvider( config );\n        replicatedIdGeneratorFactory = createIdGeneratorFactory( fileSystem, idRangeAcquirer, logProvider,\n                idTypeConfigurationProvider );\n\n        this.idGeneratorFactory = dependencies.satisfyDependency( replicatedIdGeneratorFactory );\n        dependencies.satisfyDependency( new IdBasedStoreEntityCounters( this.idGeneratorFactory ) );\n\n        Long tokenCreationTimeout = config.get( CoreEdgeClusterSettings.token_creation_timeout );\n\n        TokenRegistry<RelationshipTypeToken> relationshipTypeTokenRegistry = new TokenRegistry<>( \"RelationshipType\" );\n        ReplicatedRelationshipTypeTokenHolder relationshipTypeTokenHolder =\n                new ReplicatedRelationshipTypeTokenHolder( relationshipTypeTokenRegistry, replicator,\n                        this.idGeneratorFactory, dependencies, tokenCreationTimeout );\n\n        TokenRegistry<Token> propertyKeyTokenRegistry = new TokenRegistry<>( \"PropertyKey\" );\n        ReplicatedPropertyKeyTokenHolder propertyKeyTokenHolder =\n                new ReplicatedPropertyKeyTokenHolder( propertyKeyTokenRegistry, replicator, this.idGeneratorFactory,\n                        dependencies, tokenCreationTimeout );\n\n        TokenRegistry<Token> labelTokenRegistry = new TokenRegistry<>( \"Label\" );\n        ReplicatedLabelTokenHolder labelTokenHolder =\n                new ReplicatedLabelTokenHolder( labelTokenRegistry, replicator, this.idGeneratorFactory, dependencies,\n                        tokenCreationTimeout );\n\n        ReplicatedLockTokenStateMachine replicatedLockTokenStateMachine =\n                new ReplicatedLockTokenStateMachine( lockTokenState );\n\n        RecoverTransactionLogState txLogState = new RecoverTransactionLogState( dependencies, logProvider );\n\n        ReplicatedTokenStateMachine<Token> labelTokenStateMachine =\n                new ReplicatedTokenStateMachine<>( labelTokenRegistry, new Token.Factory(), logProvider );\n\n        ReplicatedTokenStateMachine<Token> propertyKeyTokenStateMachine =\n                new ReplicatedTokenStateMachine<>( propertyKeyTokenRegistry, new Token.Factory(), logProvider );\n\n        ReplicatedTokenStateMachine<RelationshipTypeToken> relationshipTypeTokenStateMachine =\n                new ReplicatedTokenStateMachine<>( relationshipTypeTokenRegistry, new RelationshipTypeToken.Factory(),\n                        logProvider );\n\n        ReplicatedTransactionStateMachine replicatedTxStateMachine =\n                new ReplicatedTransactionStateMachine( replicatedLockTokenStateMachine,\n                        config.get( CoreEdgeClusterSettings.state_machine_apply_max_batch_size ), logProvider );\n\n        dependencies.satisfyDependencies( replicatedTxStateMachine );\n\n        long leaderLockTokenTimeout = config.get( CoreEdgeClusterSettings.leader_lock_token_timeout );\n        lockManager = createLockManager( config, logging, replicator, myself, leaderLocator, leaderLockTokenTimeout,\n                replicatedLockTokenStateMachine );\n\n        coreStateMachines = new CoreStateMachines( replicatedTxStateMachine, labelTokenStateMachine,\n                relationshipTypeTokenStateMachine, propertyKeyTokenStateMachine, replicatedLockTokenStateMachine,\n                idAllocationStateMachine, txLogState, localDatabase );\n\n        commitProcessFactory = ( appender, applier, ignored ) -> {\n            TransactionRepresentationCommitProcess localCommit =\n                    new TransactionRepresentationCommitProcess( appender, applier );\n            coreStateMachines.refresh( localCommit ); // This gets called when a core-to-core download is performed.\n            return new ReplicatedTransactionCommitProcess( replicator );\n        };\n\n        this.relationshipTypeTokenHolder = relationshipTypeTokenHolder;\n        this.propertyKeyTokenHolder = propertyKeyTokenHolder;\n        this.labelTokenHolder = labelTokenHolder;\n    }","commit_id":"4e06d5f9d7d0d68156f0f7669f3997902ad6566c","url":"https://github.com/neo4j/neo4j"},{"original_method":"public DurableStateStorage( FileSystemAbstraction fileSystemAbstraction, File stateDir, String name,\n                                StateMarshal<STATE> marshal, int numberOfEntriesBeforeRotation,\n                                Supplier<DatabaseHealth> databaseHealthSupplier, LogProvider logProvider )\n            throws IOException\n            // TODO Move file opening to start-time so that constructor doesn't need to throw exceptions\n    {\n        this.fileSystemAbstraction = fileSystemAbstraction;\n        this.marshal = marshal;\n        this.numberOfEntriesBeforeRotation = numberOfEntriesBeforeRotation;\n        this.databaseHealthSupplier = databaseHealthSupplier;\n\n        fileA = new File( stateDir, name + \".a\" );\n        fileB = new File( stateDir, name + \".b\" );\n\n        StateRecoveryManager<STATE> recoveryManager =\n                new StateRecoveryManager<>( fileSystemAbstraction, marshal );\n\n        final StateRecoveryManager.RecoveryStatus<STATE> recoveryStatus = recoveryManager.recover( fileA, fileB );\n\n        this.currentStoreFile = recoveryStatus.activeFile();\n        this.currentStoreChannel = initialiseStoreFile( currentStoreFile );\n\n        this.initialState = recoveryStatus.recoveredState();\n\n        Log log = logProvider.getLog( getClass() );\n        log.info( \"%s state restored, up to ordinal %d\", name, marshal.ordinal( initialState ) );\n    }","id":65873,"modified_method":"public DurableStateStorage( FileSystemAbstraction fileSystemAbstraction, File baseDir, String name,\n                                StateMarshal<STATE> marshal, int numberOfEntriesBeforeRotation,\n                                Supplier<DatabaseHealth> databaseHealthSupplier, LogProvider logProvider )\n            throws IOException\n            // TODO Move file opening to start-time so that constructor doesn't need to throw exceptions\n    {\n        this.fileSystemAbstraction = fileSystemAbstraction;\n        this.marshal = marshal;\n        this.numberOfEntriesBeforeRotation = numberOfEntriesBeforeRotation;\n        this.databaseHealthSupplier = databaseHealthSupplier;\n\n        fileA = new File( stateDir( baseDir, name ), name + \".a\" );\n        fileB = new File( stateDir( baseDir, name ), name + \".b\" );\n\n        StateRecoveryManager<STATE> recoveryManager =\n                new StateRecoveryManager<>( fileSystemAbstraction, marshal );\n\n        final StateRecoveryManager.RecoveryStatus<STATE> recoveryStatus = recoveryManager.recover( fileA, fileB );\n\n        this.currentStoreFile = recoveryStatus.activeFile();\n        this.currentStoreChannel = initialiseStoreFile( currentStoreFile );\n\n        this.initialState = recoveryStatus.recoveredState();\n\n        Log log = logProvider.getLog( getClass() );\n        log.info( \"%s state restored, up to ordinal %d\", name, marshal.ordinal( initialState ) );\n    }","commit_id":"4e06d5f9d7d0d68156f0f7669f3997902ad6566c","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void switchStoreFile() throws IOException\n    {\n        currentStoreChannel.close();\n\n        if ( currentStoreFile.getName().toLowerCase().endsWith( \"a\" ) )\n        {\n            currentStoreChannel = initialiseStoreFile( fileB );\n            currentStoreFile = fileB;\n        }\n        else if ( currentStoreFile.getName().toLowerCase().endsWith( \"b\" ) )\n        {\n            currentStoreChannel = initialiseStoreFile( fileA );\n            currentStoreFile = fileA;\n        }\n    }","id":65874,"modified_method":"void switchStoreFile() throws IOException\n    {\n        currentStoreChannel.close();\n\n        if ( currentStoreFile.getName().toLowerCase().endsWith( \"a\" ) )\n        {\n            currentStoreChannel = initialiseStoreFile( fileB );\n            currentStoreFile = fileB;\n        }\n        else if ( currentStoreFile.getName().toLowerCase().endsWith( \"b\" ) )\n        {\n            currentStoreChannel = initialiseStoreFile( fileA );\n            currentStoreFile = fileA;\n        }\n    }","commit_id":"4e06d5f9d7d0d68156f0f7669f3997902ad6566c","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldProperlyRecoveryAfterCrashOnFileCreationDuringRotation() throws Exception\n    {\n        EphemeralFileSystemAbstraction normalFSA = new EphemeralFileSystemAbstraction();\n        /*\n         * Magic number warning. For a rotation threshold of 14, 998 operations on file A falls on truncation of the\n         * file during rotation. This has been discovered via experimentation. The end result is that there is a\n         * failure to create the file to rotate to. This should be recoverable.\n         */\n        AdversarialFileSystemAbstraction breakingFSA = new AdversarialFileSystemAbstraction(\n                new MethodGuardedAdversary(\n                        new CountingAdversary( 20, true ),\n                        FileSystemAbstraction.class.getMethod( \"truncate\", File.class, long.class ) ),\n                normalFSA );\n        SelectiveFileSystemAbstraction combinedFSA = new SelectiveFileSystemAbstraction(\n                new File( testDir.directory(), \"long.a\" ), breakingFSA, normalFSA );\n\n        LongState persistedState = new LongState( combinedFSA, testDir.directory(), 14 );\n        long lastValue = 0;\n\n        try\n        {\n            while ( true ) // it will break from the Exception that AFS will throw\n            {\n                long tempValue = lastValue + 1;\n                persistedState.setTheState( tempValue );\n                lastValue = tempValue;\n            }\n        }\n        catch ( Exception expected )\n        {\n            // this stack trace should contain FSA.truncate()\n            ensureStackTraceContainsExpectedMethod( expected.getStackTrace(), \"truncate\" );\n        }\n\n        LongState restoredState = new LongState( normalFSA, testDir.directory(), 14 );\n        assertEquals( lastValue, restoredState.getTheState() );\n    }","id":65875,"modified_method":"@Test\n    public void shouldProperlyRecoveryAfterCrashOnFileCreationDuringRotation() throws Exception\n    {\n        EphemeralFileSystemAbstraction normalFSA = new EphemeralFileSystemAbstraction();\n        /*\n         * Magic number warning. For a rotation threshold of 14, 998 operations on file A falls on truncation of the\n         * file during rotation. This has been discovered via experimentation. The end result is that there is a\n         * failure to create the file to rotate to. This should be recoverable.\n         */\n        AdversarialFileSystemAbstraction breakingFSA = new AdversarialFileSystemAbstraction(\n                new MethodGuardedAdversary(\n                        new CountingAdversary( 20, true ),\n                        FileSystemAbstraction.class.getMethod( \"truncate\", File.class, long.class ) ),\n                normalFSA );\n        SelectiveFileSystemAbstraction combinedFSA = new SelectiveFileSystemAbstraction(\n                new File( new File( testDir.directory(), \"long-state\" ), \"long.a\" ), breakingFSA, normalFSA );\n\n        LongState persistedState = new LongState( combinedFSA, testDir.directory(), 14 );\n        long lastValue = 0;\n\n        try\n        {\n            while ( true ) // it will break from the Exception that AFS will throw\n            {\n                long tempValue = lastValue + 1;\n                persistedState.setTheState( tempValue );\n                lastValue = tempValue;\n            }\n        }\n        catch ( Exception expected )\n        {\n            // this stack trace should contain FSA.truncate()\n            ensureStackTraceContainsExpectedMethod( expected.getStackTrace(), \"truncate\" );\n        }\n\n        LongState restoredState = new LongState( normalFSA, testDir.directory(), 14 );\n        assertEquals( lastValue, restoredState.getTheState() );\n    }","commit_id":"4e06d5f9d7d0d68156f0f7669f3997902ad6566c","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldProperlyRecoveryAfterCloseOnActiveFileDuringRotation() throws Exception\n    {\n        EphemeralFileSystemAbstraction normalFSA = new EphemeralFileSystemAbstraction();\n        AdversarialFileSystemAbstraction breakingFSA = new AdversarialFileSystemAbstraction(\n                new MethodGuardedAdversary(\n                        new CountingAdversary( 5, true ),\n                        StoreChannel.class.getMethod( \"close\" ) ),\n                normalFSA );\n        SelectiveFileSystemAbstraction combinedFSA = new SelectiveFileSystemAbstraction(\n                new File( testDir.directory(), \"long.a\" ), breakingFSA, normalFSA );\n\n        LongState persistedState = new LongState( combinedFSA, testDir.directory(), 14 );\n        long lastValue = 0;\n\n        try\n        {\n            while ( true ) // it will break from the Exception that AFS will throw\n            {\n                long tempValue = lastValue + 1;\n                persistedState.setTheState( tempValue );\n                lastValue = tempValue;\n            }\n        }\n        catch ( Exception expected )\n        {\n            // this stack trace should contain close()\n            ensureStackTraceContainsExpectedMethod( expected.getStackTrace(), \"close\" );\n        }\n\n        LongState restoredState = new LongState( normalFSA, testDir.directory(), 14 );\n        assertThat( restoredState.getTheState(), greaterThanOrEqualTo( lastValue ) );\n    }","id":65876,"modified_method":"@Test\n    public void shouldProperlyRecoveryAfterCloseOnActiveFileDuringRotation() throws Exception\n    {\n        EphemeralFileSystemAbstraction normalFSA = new EphemeralFileSystemAbstraction();\n        AdversarialFileSystemAbstraction breakingFSA = new AdversarialFileSystemAbstraction(\n                new MethodGuardedAdversary(\n                        new CountingAdversary( 5, true ),\n                        StoreChannel.class.getMethod( \"close\" ) ),\n                normalFSA );\n        SelectiveFileSystemAbstraction combinedFSA = new SelectiveFileSystemAbstraction(\n                new File( new File( testDir.directory(), \"long-state\" ), \"long.a\" ), breakingFSA, normalFSA );\n\n        LongState persistedState = new LongState( combinedFSA, testDir.directory(), 14 );\n        long lastValue = 0;\n\n        try\n        {\n            while ( true ) // it will break from the Exception that AFS will throw\n            {\n                long tempValue = lastValue + 1;\n                persistedState.setTheState( tempValue );\n                lastValue = tempValue;\n            }\n        }\n        catch ( Exception expected )\n        {\n            // this stack trace should contain close()\n            ensureStackTraceContainsExpectedMethod( expected.getStackTrace(), \"close\" );\n        }\n\n        LongState restoredState = new LongState( normalFSA, testDir.directory(), 14 );\n        assertThat( restoredState.getTheState(), greaterThanOrEqualTo( lastValue ) );\n    }","commit_id":"4e06d5f9d7d0d68156f0f7669f3997902ad6566c","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldProperlyRecoveryAfterCrashOnFileForceDuringWrite() throws Exception\n    {\n        EphemeralFileSystemAbstraction normalFSA = new EphemeralFileSystemAbstraction();\n        /*\n         * Magic number warning. For a rotation threshold of 14, 990 operations on file A falls on a force() of the\n         * current active file. This has been discovered via experimentation. The end result is that there is a\n         * flush (but not write) a value. This should be recoverable. Interestingly, the failure semantics are a bit\n         * unclear on what should happen to that value. We assume that exception during persistence requires recovery\n         * to discover if the last argument made it to disk or not. Since we use an EFSA, force is not necessary and\n         * the value that caused the failure is actually \"persisted\" and recovered.\n         */\n        AdversarialFileSystemAbstraction breakingFSA = new AdversarialFileSystemAbstraction(\n                new MethodGuardedAdversary(\n                        new CountingAdversary( 40, true ),\n                        StoreChannel.class.getMethod( \"force\", boolean.class ) ),\n                normalFSA );\n        SelectiveFileSystemAbstraction combinedFSA = new SelectiveFileSystemAbstraction(\n                new File( testDir.directory(), \"long.a\" ), breakingFSA, normalFSA );\n\n        LongState persistedState = new LongState( combinedFSA, testDir.directory(), 14 );\n        long lastValue = 0;\n\n        try\n        {\n            while ( true ) // it will break from the Exception that AFS will throw\n            {\n                long tempValue = lastValue + 1;\n                persistedState.setTheState( tempValue );\n                lastValue = tempValue;\n            }\n        }\n        catch ( Exception expected )\n        {\n            // this stack trace should contain force()\n            ensureStackTraceContainsExpectedMethod( expected.getStackTrace(), \"force\" );\n        }\n\n        LongState restoredState = new LongState( normalFSA, testDir.directory(), 14 );\n        assertThat( restoredState.getTheState(), greaterThanOrEqualTo( lastValue ) );\n    }","id":65877,"modified_method":"@Test\n    public void shouldProperlyRecoveryAfterCrashOnFileForceDuringWrite() throws Exception\n    {\n        EphemeralFileSystemAbstraction normalFSA = new EphemeralFileSystemAbstraction();\n        /*\n         * Magic number warning. For a rotation threshold of 14, 990 operations on file A falls on a force() of the\n         * current active file. This has been discovered via experimentation. The end result is that there is a\n         * flush (but not write) a value. This should be recoverable. Interestingly, the failure semantics are a bit\n         * unclear on what should happen to that value. We assume that exception during persistence requires recovery\n         * to discover if the last argument made it to disk or not. Since we use an EFSA, force is not necessary and\n         * the value that caused the failure is actually \"persisted\" and recovered.\n         */\n        AdversarialFileSystemAbstraction breakingFSA = new AdversarialFileSystemAbstraction(\n                new MethodGuardedAdversary(\n                        new CountingAdversary( 40, true ),\n                        StoreChannel.class.getMethod( \"force\", boolean.class ) ),\n                normalFSA );\n        SelectiveFileSystemAbstraction combinedFSA = new SelectiveFileSystemAbstraction(\n                new File( new File( testDir.directory(), \"long-state\" ), \"long.a\" ), breakingFSA, normalFSA );\n\n        LongState persistedState = new LongState( combinedFSA, testDir.directory(), 14 );\n        long lastValue = 0;\n\n        try\n        {\n            while ( true ) // it will break from the Exception that AFS will throw\n            {\n                long tempValue = lastValue + 1;\n                persistedState.setTheState( tempValue );\n                lastValue = tempValue;\n            }\n        }\n        catch ( Exception expected )\n        {\n            // this stack trace should contain force()\n            ensureStackTraceContainsExpectedMethod( expected.getStackTrace(), \"force\" );\n        }\n\n        LongState restoredState = new LongState( normalFSA, testDir.directory(), 14 );\n        assertThat( restoredState.getTheState(), greaterThanOrEqualTo( lastValue ) );\n    }","commit_id":"4e06d5f9d7d0d68156f0f7669f3997902ad6566c","url":"https://github.com/neo4j/neo4j"},{"original_method":"private File stateFileA()\n    {\n        return new File( testDir.directory(), \"state.a\" );\n    }","id":65878,"modified_method":"private File stateFileA()\n    {\n        return new File( new File( testDir.directory(), \"state-state\" ), \"state.a\" );\n    }","commit_id":"4e06d5f9d7d0d68156f0f7669f3997902ad6566c","url":"https://github.com/neo4j/neo4j"},{"original_method":"private File stateFileB()\n    {\n        return new File( testDir.directory(), \"state.b\" );\n    }","id":65879,"modified_method":"private File stateFileB()\n    {\n        return new File( new File( testDir.directory(), \"state-state\" ), \"state.b\" );\n    }","commit_id":"4e06d5f9d7d0d68156f0f7669f3997902ad6566c","url":"https://github.com/neo4j/neo4j"},{"original_method":"EnterpriseCoreEditionModule( final PlatformModule platformModule, DiscoveryServiceFactory discoveryServiceFactory )\n    {\n        final Dependencies dependencies = platformModule.dependencies;\n        final Config config = platformModule.config;\n        final LogService logging = platformModule.logging;\n        final FileSystemAbstraction fileSystem = platformModule.fileSystem;\n        final File storeDir = platformModule.storeDir;\n        final File clusterStateDirectory = createClusterStateDirectory( storeDir, fileSystem );\n        final LifeSupport life = platformModule.life;\n\n        logProvider = logging.getInternalLogProvider();\n        final Supplier<DatabaseHealth> databaseHealthSupplier = dependencies.provideDependency( DatabaseHealth.class );\n\n        MemberId myself;\n\n        try\n        {\n            StateStorage<MemberId> idStorage = life.add( new DurableStateStorage<>(\n                    fileSystem, clusterStateDirectory, \"raft-member-id\", new MemberIdMarshal(), 1,\n                    databaseHealthSupplier, logProvider ) );\n            MemberId member = idStorage.getInitialState();\n            if ( member == null )\n            {\n                member = new MemberId( UUID.randomUUID() );\n                idStorage.persistStoreData( member );\n            }\n            myself = member;\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n\n        discoveryService = discoveryServiceFactory.coreDiscoveryService( config, myself, logProvider );\n\n        life.add( dependencies.satisfyDependency( discoveryService ) );\n\n        long logThresholdMillis = config.get( CoreEdgeClusterSettings.unknown_address_logging_throttle );\n        int maxQueueSize = config.get( CoreEdgeClusterSettings.outgoing_queue_size );\n\n        final SenderService senderService =\n                new SenderService( new RaftChannelInitializer( new CoreReplicatedContentMarshal(), logProvider ), logProvider, platformModule.monitors,\n                        maxQueueSize, new NonBlockingChannels() );\n        life.add( senderService );\n\n        final MessageLogger<MemberId> messageLogger;\n        if ( config.get( CoreEdgeClusterSettings.raft_messages_log_enable ) )\n        {\n            File logsDir = config.get( GraphDatabaseSettings.logs_directory );\n            messageLogger = life.add( new BetterMessageLogger<>( myself, raftMessagesLog( logsDir ) ) );\n        }\n        else\n        {\n            messageLogger = new NullMessageLogger<>();\n        }\n\n        CopiedStoreRecovery copiedStoreRecovery = new CopiedStoreRecovery( config,\n                platformModule.kernelExtensions.listFactories(), platformModule.pageCache );\n\n        LocalDatabase localDatabase = new LocalDatabase( platformModule.storeDir, copiedStoreRecovery,\n                new StoreFiles( new DefaultFileSystemAbstraction() ),\n                platformModule.dataSourceManager,\n                platformModule.dependencies.provideDependency( TransactionIdStore.class ), databaseHealthSupplier,\n                logProvider);\n\n        RaftOutbound raftOutbound =\n                new RaftOutbound( discoveryService, senderService, localDatabase, logProvider, logThresholdMillis );\n        Outbound<MemberId,RaftMessages.RaftMessage> loggingOutbound = new LoggingOutbound<>(\n                raftOutbound, myself, messageLogger );\n\n        consensusModule =\n                new ConsensusModule( myself, platformModule, raftOutbound, clusterStateDirectory, discoveryService );\n\n        dependencies.satisfyDependency( consensusModule.raftInstance() );\n\n        ReplicationModule replicationModule = new ReplicationModule( myself, platformModule, config, consensusModule,\n                loggingOutbound, clusterStateDirectory,\n                fileSystem, databaseHealthSupplier, logProvider );\n\n        coreStateMachinesModule = new CoreStateMachinesModule( myself, platformModule, clusterStateDirectory,\n                databaseHealthSupplier, config, replicationModule.getReplicator(), consensusModule.raftInstance(),\n                dependencies, localDatabase );\n\n        this.idGeneratorFactory = coreStateMachinesModule.idGeneratorFactory;\n        this.idTypeConfigurationProvider = coreStateMachinesModule.idTypeConfigurationProvider;\n        this.labelTokenHolder = coreStateMachinesModule.labelTokenHolder;\n        this.propertyKeyTokenHolder = coreStateMachinesModule.propertyKeyTokenHolder;\n        this.relationshipTypeTokenHolder = coreStateMachinesModule.relationshipTypeTokenHolder;\n        this.lockManager = coreStateMachinesModule.lockManager;\n        this.commitProcessFactory = coreStateMachinesModule.commitProcessFactory;\n\n        CoreServerModule coreServerModule = new CoreServerModule( myself, platformModule, consensusModule,\n                coreStateMachinesModule, replicationModule, clusterStateDirectory, discoveryService, localDatabase, messageLogger );\n\n        editionInvariants( platformModule, dependencies, config, logging, life );\n\n        this.lockManager = dependencies.satisfyDependency( lockManager );\n\n        life.add( CoreStartupProcess.createLifeSupport(\n                platformModule.dataSourceManager, coreStateMachinesModule.replicatedIdGeneratorFactory, coreServerModule.startupLifecycle, consensusModule.raftTimeoutService(), coreServerModule.membershipWaiterLifecycle ) );\n    }","id":65880,"modified_method":"EnterpriseCoreEditionModule( final PlatformModule platformModule, DiscoveryServiceFactory discoveryServiceFactory )\n    {\n        final Dependencies dependencies = platformModule.dependencies;\n        final Config config = platformModule.config;\n        final LogService logging = platformModule.logging;\n        final FileSystemAbstraction fileSystem = platformModule.fileSystem;\n        final File storeDir = platformModule.storeDir;\n        final File clusterStateDirectory = createClusterStateDirectory( storeDir, fileSystem );\n        final LifeSupport life = platformModule.life;\n\n        logProvider = logging.getInternalLogProvider();\n        final Supplier<DatabaseHealth> databaseHealthSupplier = dependencies.provideDependency( DatabaseHealth.class );\n\n        MemberId myself;\n\n        try\n        {\n            StateStorage<MemberId> idStorage = life.add( new DurableStateStorage<>(\n                    fileSystem, clusterStateDirectory, CORE_MEMBER_ID_NAME, new MemberIdMarshal(), 1,\n                    databaseHealthSupplier, logProvider ) );\n            MemberId member = idStorage.getInitialState();\n            if ( member == null )\n            {\n                member = new MemberId( UUID.randomUUID() );\n                idStorage.persistStoreData( member );\n            }\n            myself = member;\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n\n        discoveryService = discoveryServiceFactory.coreDiscoveryService( config, myself, logProvider );\n\n        life.add( dependencies.satisfyDependency( discoveryService ) );\n\n        long logThresholdMillis = config.get( CoreEdgeClusterSettings.unknown_address_logging_throttle );\n        int maxQueueSize = config.get( CoreEdgeClusterSettings.outgoing_queue_size );\n\n        final SenderService senderService =\n                new SenderService( new RaftChannelInitializer( new CoreReplicatedContentMarshal(), logProvider ), logProvider, platformModule.monitors,\n                        maxQueueSize, new NonBlockingChannels() );\n        life.add( senderService );\n\n        final MessageLogger<MemberId> messageLogger;\n        if ( config.get( CoreEdgeClusterSettings.raft_messages_log_enable ) )\n        {\n            File logsDir = config.get( GraphDatabaseSettings.logs_directory );\n            messageLogger = life.add( new BetterMessageLogger<>( myself, raftMessagesLog( logsDir ) ) );\n        }\n        else\n        {\n            messageLogger = new NullMessageLogger<>();\n        }\n\n        CopiedStoreRecovery copiedStoreRecovery = new CopiedStoreRecovery( config,\n                platformModule.kernelExtensions.listFactories(), platformModule.pageCache );\n\n        LocalDatabase localDatabase = new LocalDatabase( platformModule.storeDir, copiedStoreRecovery,\n                new StoreFiles( new DefaultFileSystemAbstraction() ),\n                platformModule.dataSourceManager,\n                platformModule.dependencies.provideDependency( TransactionIdStore.class ), databaseHealthSupplier,\n                logProvider);\n\n        RaftOutbound raftOutbound =\n                new RaftOutbound( discoveryService, senderService, localDatabase, logProvider, logThresholdMillis );\n        Outbound<MemberId,RaftMessages.RaftMessage> loggingOutbound = new LoggingOutbound<>(\n                raftOutbound, myself, messageLogger );\n\n        consensusModule =\n                new ConsensusModule( myself, platformModule, raftOutbound, clusterStateDirectory, discoveryService );\n\n        dependencies.satisfyDependency( consensusModule.raftInstance() );\n\n        ReplicationModule replicationModule = new ReplicationModule( myself, platformModule, config, consensusModule,\n                loggingOutbound, clusterStateDirectory,\n                fileSystem, databaseHealthSupplier, logProvider );\n\n        coreStateMachinesModule = new CoreStateMachinesModule( myself, platformModule, clusterStateDirectory,\n                databaseHealthSupplier, config, replicationModule.getReplicator(), consensusModule.raftInstance(),\n                dependencies, localDatabase );\n\n        this.idGeneratorFactory = coreStateMachinesModule.idGeneratorFactory;\n        this.idTypeConfigurationProvider = coreStateMachinesModule.idTypeConfigurationProvider;\n        this.labelTokenHolder = coreStateMachinesModule.labelTokenHolder;\n        this.propertyKeyTokenHolder = coreStateMachinesModule.propertyKeyTokenHolder;\n        this.relationshipTypeTokenHolder = coreStateMachinesModule.relationshipTypeTokenHolder;\n        this.lockManager = coreStateMachinesModule.lockManager;\n        this.commitProcessFactory = coreStateMachinesModule.commitProcessFactory;\n\n        CoreServerModule coreServerModule = new CoreServerModule( myself, platformModule, consensusModule,\n                coreStateMachinesModule, replicationModule, clusterStateDirectory, discoveryService, localDatabase, messageLogger );\n\n        editionInvariants( platformModule, dependencies, config, logging, life );\n\n        this.lockManager = dependencies.satisfyDependency( lockManager );\n\n        life.add( CoreStartupProcess.createLifeSupport(\n                platformModule.dataSourceManager, coreStateMachinesModule.replicatedIdGeneratorFactory, coreServerModule.startupLifecycle, consensusModule.raftTimeoutService(), coreServerModule.membershipWaiterLifecycle ) );\n    }","commit_id":"4e06d5f9d7d0d68156f0f7669f3997902ad6566c","url":"https://github.com/neo4j/neo4j"},{"original_method":"public ReplicationModule( MemberId myself, PlatformModule platformModule, Config config, ConsensusModule consensusModule,\n                              Outbound<MemberId,RaftMessages.RaftMessage> loggingOutbound, File clusterStateDirectory,\n                              FileSystemAbstraction fileSystem, Supplier<DatabaseHealth> databaseHealthSupplier, LogProvider logProvider )\n    {\n        LifeSupport life = platformModule.life;\n\n        DurableStateStorage<GlobalSessionTrackerState> sessionTrackerStorage;\n        try\n        {\n            sessionTrackerStorage = life.add(\n                    new DurableStateStorage<>( fileSystem, new File( clusterStateDirectory, \"session-tracker-state\" ),\n                            \"session-tracker\",\n                            new GlobalSessionTrackerState.Marshal( new MemberId.MemberIdMarshal() ),\n                            config.get( CoreEdgeClusterSettings.global_session_tracker_state_size ),\n                            databaseHealthSupplier, logProvider ) );\n\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n\n        sessionTracker = new SessionTracker( sessionTrackerStorage );\n\n        GlobalSession myGlobalSession = new GlobalSession( UUID.randomUUID(), myself );\n        LocalSessionPool sessionPool = new LocalSessionPool( myGlobalSession );\n        progressTracker = new ProgressTrackerImpl( myGlobalSession );\n\n        replicator = new RaftReplicator( consensusModule.raftInstance(), myself,\n                loggingOutbound,\n                sessionPool, progressTracker,\n                new ExponentialBackoffStrategy( 10, SECONDS ) );\n\n    }","id":65881,"modified_method":"public ReplicationModule( MemberId myself, PlatformModule platformModule, Config config, ConsensusModule consensusModule,\n                              Outbound<MemberId,RaftMessages.RaftMessage> loggingOutbound, File clusterStateDirectory,\n                              FileSystemAbstraction fileSystem, Supplier<DatabaseHealth> databaseHealthSupplier, LogProvider logProvider )\n    {\n        LifeSupport life = platformModule.life;\n\n        DurableStateStorage<GlobalSessionTrackerState> sessionTrackerStorage;\n        try\n        {\n            sessionTrackerStorage = life.add( new DurableStateStorage<>( fileSystem, clusterStateDirectory,\n                    SESSION_TRACKER_NAME, new GlobalSessionTrackerState.Marshal( new MemberId.MemberIdMarshal() ),\n                    config.get( CoreEdgeClusterSettings.global_session_tracker_state_size ), databaseHealthSupplier,\n                    logProvider ) );\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n\n        sessionTracker = new SessionTracker( sessionTrackerStorage );\n\n        GlobalSession myGlobalSession = new GlobalSession( UUID.randomUUID(), myself );\n        LocalSessionPool sessionPool = new LocalSessionPool( myGlobalSession );\n        progressTracker = new ProgressTrackerImpl( myGlobalSession );\n\n        replicator = new RaftReplicator( consensusModule.raftInstance(), myself,\n                loggingOutbound,\n                sessionPool, progressTracker,\n                new ExponentialBackoffStrategy( 10, SECONDS ) );\n\n    }","commit_id":"4e06d5f9d7d0d68156f0f7669f3997902ad6566c","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void givenExplicitlyDisabledServerLoggingConfigurationShouldNotLogAccesses() throws Exception\n    {\n        // given\n        server = ServerBuilder.server().withDefaultDatabaseTuning()\n            .withProperty( Configurator.HTTP_LOGGING, \"false\" )\n            .usingDatabaseDir( folder.getRoot().getAbsolutePath() )\n            .build();\n        server.start();\n        FunctionalTestHelper functionalTestHelper = new FunctionalTestHelper( server );\n\n        // when\n        String query = \"?implicitlyDisabled\" + UUID.randomUUID().toString();\n        JaxRsResponse response = new RestRequest().get( functionalTestHelper.webAdminUri() + query );\n        assertEquals( 200, response.getStatus() );\n        response.close();\n\n        // then\n        assertFalse( occursIn( query, new File( logDirectory + File.separator + \"http.log\" ) ) );\n    }","id":65882,"modified_method":"@Test\n    public void givenExplicitlyDisabledServerLoggingConfigurationShouldNotLogAccesses() throws Exception\n    {\n        // given\n        File logDirectory = TargetDirectory.forTest( this.getClass() ).directory(\n                \"givenExplicitlyDisabledServerLoggingConfigurationShouldNotLogAccesses-logdir\", true );\n        FileUtils.forceMkdir( logDirectory );\n        final File confDir = TargetDirectory.forTest( this.getClass() ).directory(\n                \"givenExplicitlyDisabledServerLoggingConfigurationShouldNotLogAccesses-confdir\", true );\n        FileUtils.forceMkdir( confDir );\n\n        final File configFile = HTTPLoggingPreparednessRuleTest.createConfigFile(\n                HTTPLoggingPreparednessRuleTest.createLogbackConfigXml( logDirectory ), confDir );\n\n        NeoServer server = ServerBuilder.server().withDefaultDatabaseTuning()\n            .withProperty( Configurator.HTTP_LOGGING, \"false\" )\n            .withProperty( Configurator.HTTP_LOG_CONFIG_LOCATION, configFile.getPath() )\n            .usingDatabaseDir( TargetDirectory.forTest( this.getClass() ).directory(\n                    \"givenExplicitlyDisabledServerLoggingConfigurationShouldNotLogAccesses-dbdir\", true ).getAbsolutePath() )\n            .build();\n        try\n        {\n            server.start();\n            FunctionalTestHelper functionalTestHelper = new FunctionalTestHelper( server );\n\n            // when\n            String query = \"?implicitlyDisabled\" + UUID.randomUUID().toString();\n            JaxRsResponse response = new RestRequest().get( functionalTestHelper.webAdminUri() + query );\n            assertEquals( 200, response.getStatus() );\n            response.close();\n\n            // then\n            assertFalse( occursIn( query, new File( logDirectory, \"http.log\" ) ) );\n        }\n        finally\n        {\n            server.stop();\n        }\n    }","commit_id":"6df068b8a09391d2ca5a1a4cd847e1cffdcd6fe6","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void givenConfigurationWithUnwritableLogDirectoryShouldFailToStartServer() throws Exception\n    {\n        // given\n        final File confDir = TargetDirectory.forTest( this.getClass() ).directory( \"confdir\" );\n        FileUtils.forceMkdir( confDir );\n        final File unwritableLogDir = createUnwritableDirectory();\n\n        final File configFile = HTTPLoggingPreparednessRuleTest.createConfigFile(\n            HTTPLoggingPreparednessRuleTest.createLogbackConfigXml( unwritableLogDir ), confDir );\n\n        Configuration config = new MapBasedConfiguration();\n        config.setProperty(Configurator.HTTP_LOGGING, \"true\");\n        config.setProperty(Configurator.HTTP_LOG_CONFIG_LOCATION, configFile.getPath());\n        \n        server = ServerBuilder.server().withDefaultDatabaseTuning()\n            .withPreflightTasks( new EnsurePreparedForHttpLogging(config) )\n            .withProperty( Configurator.HTTP_LOGGING, \"true\" )\n            .withProperty( Configurator.HTTP_LOG_CONFIG_LOCATION, configFile.getPath() )\n            .usingDatabaseDir( folder.getRoot().getAbsolutePath() )\n            .build();\n\n        // when\n        try\n        {\n            server.start();\n            fail( \"should have thrown exception\" );\n        }\n        catch ( PreflightFailedException e )\n        {\n            // then\n            assertThat( e.getMessage(),\n                containsString( String.format( \"HTTP log directory [%s]\",\n                    unwritableLogDir.getAbsolutePath() ) ) );\n        }\n    }","id":65883,"modified_method":"@Test\n    public void givenConfigurationWithUnwritableLogDirectoryShouldFailToStartServer() throws Exception\n    {\n        // given\n        final File confDir = TargetDirectory.forTest( this.getClass() ).directory( \"confdir\" );\n        FileUtils.forceMkdir( confDir );\n        final File unwritableLogDir = createUnwritableDirectory();\n\n        final File configFile = HTTPLoggingPreparednessRuleTest.createConfigFile(\n            HTTPLoggingPreparednessRuleTest.createLogbackConfigXml( unwritableLogDir ), confDir );\n\n        Configuration config = new MapBasedConfiguration();\n        config.setProperty(Configurator.HTTP_LOGGING, \"true\");\n        config.setProperty(Configurator.HTTP_LOG_CONFIG_LOCATION, configFile.getPath());\n        \n        NeoServer server = ServerBuilder.server().withDefaultDatabaseTuning()\n            .withPreflightTasks( new EnsurePreparedForHttpLogging(config) )\n            .withProperty( Configurator.HTTP_LOGGING, \"true\" )\n            .withProperty( Configurator.HTTP_LOG_CONFIG_LOCATION, configFile.getPath() )\n            .usingDatabaseDir( TargetDirectory.forTest( this.getClass() ).directory( \"confdir\" ).getAbsolutePath() )\n            .build();\n\n        // when\n        try\n        {\n            server.start();\n            fail( \"should have thrown exception\" );\n        }\n        catch ( PreflightFailedException e )\n        {\n            // then\n            assertThat( e.getMessage(),\n                containsString( String.format( \"HTTP log directory [%s]\",\n                    unwritableLogDir.getAbsolutePath() ) ) );\n        }\n        finally\n        {\n            server.stop();\n        }\n    }","commit_id":"6df068b8a09391d2ca5a1a4cd847e1cffdcd6fe6","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void givenExplicitlyEnabledServerLoggingConfigurationShouldLogAccess() throws Exception\n    {\n        // given\n        logDirectory = TargetDirectory.forTest( this.getClass() ).directory( \"logdir\" );\n        FileUtils.forceMkdir( logDirectory );\n        final File confDir = TargetDirectory.forTest( this.getClass() ).directory( \"confdir\" );\n        FileUtils.forceMkdir( confDir );\n\n        final File configFile = HTTPLoggingPreparednessRuleTest.createConfigFile(\n            HTTPLoggingPreparednessRuleTest.createLogbackConfigXml( logDirectory ), confDir );\n\n        server = ServerBuilder.server().withDefaultDatabaseTuning()\n            .withProperty( Configurator.HTTP_LOGGING, \"true\" )\n            .withProperty( Configurator.HTTP_LOG_CONFIG_LOCATION, configFile.getPath() )\n            .usingDatabaseDir( folder.getRoot().getAbsolutePath() )\n            .build();\n        server.start();\n\n        FunctionalTestHelper functionalTestHelper = new FunctionalTestHelper( server );\n\n        // when\n        String query = \"?explicitlyEnabled=\" + UUID.randomUUID().toString();\n        JaxRsResponse response = new RestRequest().get( functionalTestHelper.webAdminUri() + query );\n        assertEquals( 200, response.getStatus() );\n        response.close();\n\n        // then\n        final File outputLog = new File( logDirectory + File.separator + \"http.log\" );\n        assertTrue( occursIn( query, outputLog ) );\n    }","id":65884,"modified_method":"@Test\n    public void givenExplicitlyEnabledServerLoggingConfigurationShouldLogAccess() throws Exception\n    {\n        // given\n        File logDirectory = TargetDirectory.forTest( this.getClass() ).directory(\n                \"givenExplicitlyEnabledServerLoggingConfigurationShouldLogAccess-logdir\", true );\n        FileUtils.forceMkdir( logDirectory );\n        final File confDir = TargetDirectory.forTest( this.getClass() ).directory(\n                \"givenExplicitlyEnabledServerLoggingConfigurationShouldLogAccess-confdir\", true );\n        FileUtils.forceMkdir( confDir );\n\n        final File configFile = HTTPLoggingPreparednessRuleTest.createConfigFile(\n            HTTPLoggingPreparednessRuleTest.createLogbackConfigXml( logDirectory ), confDir );\n\n        String query = \"?explicitlyEnabled=\" + UUID.randomUUID().toString();\n\n        NeoServer server = ServerBuilder.server().withDefaultDatabaseTuning()\n            .withProperty( Configurator.HTTP_LOGGING, \"true\" )\n            .withProperty( Configurator.HTTP_LOG_CONFIG_LOCATION, configFile.getPath() )\n            .usingDatabaseDir( TargetDirectory.forTest( this.getClass() ).directory(\n                    \"givenExplicitlyEnabledServerLoggingConfigurationShouldLogAccess-dbdir\", true ).getAbsolutePath() )\n            .build();\n        try\n        {\n            server.start();\n\n            FunctionalTestHelper functionalTestHelper = new FunctionalTestHelper( server );\n\n            // when\n            JaxRsResponse response = new RestRequest().get( functionalTestHelper.webAdminUri() + query );\n            assertEquals( 200, response.getStatus() );\n            response.close();\n\n            // then\n            final File outputLog = new File( logDirectory, \"http.log\" );\n            assertTrue( occursIn( query, outputLog ) );\n\n        }\n        catch (Throwable t)\n        {\n            t.printStackTrace();\n        }\n        finally\n        {\n            server.stop();\n        }\n    }","commit_id":"6df068b8a09391d2ca5a1a4cd847e1cffdcd6fe6","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void loadAllMounts()\n    {\n        SessionManager sm = new HashSessionManager();\n\n        final SortedSet<String> mountpoints = new TreeSet<String>( new Comparator<String>()\n        {\n            @Override\n            public int compare( final String o1, final String o2 )\n            {\n                return o2.compareTo( o1 );\n            }\n        } );\n\n        if( requestLoggingConfiguration != null )\n        {\n            loadRequestLogging();\n        }\n\n        mountpoints.addAll( staticContent.keySet() );\n        mountpoints.addAll( jaxRSPackages.keySet() );\n\n        for ( String contentKey : mountpoints )\n        {\n            final boolean isStatic = staticContent.containsKey( contentKey );\n            final boolean isJaxrs = jaxRSPackages.containsKey( contentKey );\n\n            if ( isStatic && isJaxrs )\n            {\n                throw new RuntimeException(\n                    format( \"content-key '%s' is mapped twice (static and jaxrs)\", contentKey ) );\n            }\n            else if ( isStatic )\n            {\n                loadStaticContent( sm, contentKey );\n            }\n            else if ( isJaxrs )\n            {\n                loadJAXRSPackage( sm, contentKey );\n            }\n            else\n            {\n                throw new RuntimeException( format( \"content-key '%s' is not mapped\", contentKey ) );\n            }\n        }\n    }","id":65885,"modified_method":"private void loadAllMounts()\n    {\n        SessionManager sm = new HashSessionManager();\n\n        final SortedSet<String> mountpoints = new TreeSet<String>( new Comparator<String>()\n        {\n            @Override\n            public int compare( final String o1, final String o2 )\n            {\n                return o2.compareTo( o1 );\n            }\n        } );\n\n        mountpoints.addAll( staticContent.keySet() );\n        mountpoints.addAll( jaxRSPackages.keySet() );\n\n        for ( String contentKey : mountpoints )\n        {\n            final boolean isStatic = staticContent.containsKey( contentKey );\n            final boolean isJaxrs = jaxRSPackages.containsKey( contentKey );\n\n            if ( isStatic && isJaxrs )\n            {\n                throw new RuntimeException(\n                    format( \"content-key '%s' is mapped twice (static and jaxrs)\", contentKey ) );\n            }\n            else if ( isStatic )\n            {\n                loadStaticContent( sm, contentKey );\n            }\n            else if ( isJaxrs )\n            {\n                loadJAXRSPackage( sm, contentKey );\n            }\n            else\n            {\n                throw new RuntimeException( format( \"content-key '%s' is not mapped\", contentKey ) );\n            }\n        }\n\n        if( requestLoggingConfiguration != null )\n        {\n            loadRequestLogging();\n        }\n\n    }","commit_id":"6df068b8a09391d2ca5a1a4cd847e1cffdcd6fe6","url":"https://github.com/neo4j/neo4j"},{"original_method":"private URI managementApiUri( ) throws UnknownHostException\n    {\n        try\n        {\n            return new URI( config.getString( Configurator.MANAGEMENT_PATH_PROPERTY_KEY, Configurator.DEFAULT_MANAGEMENT_API_PATH ) );\n        }\n        catch ( URISyntaxException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","id":65886,"modified_method":"private URI managementApiUri( ) throws UnknownHostException\n    {\n        return URI.create( config.getString( Configurator.MANAGEMENT_PATH_PROPERTY_KEY,\n                Configurator.DEFAULT_MANAGEMENT_API_PATH ) );\n    }","commit_id":"6df068b8a09391d2ca5a1a4cd847e1cffdcd6fe6","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void savePeerAssessmentAttachments(PeerAssessmentItem item){\n\t\tif(item != null && item.getAttachmentList() != null){\n\t\t\tgetHibernateTemplate().saveOrUpdateAll(item.getAttachmentList());\n\t\t\tgetHibernateTemplate().flush();\n\t\t}\n\t}","id":65887,"modified_method":"public void savePeerAssessmentAttachments(PeerAssessmentItem item){\n\t\tif(item != null && item.getAttachmentList() != null){\n\t\t\tfor(PeerAssessmentAttachment element : item.getAttachmentList()) {\n\t\t\t\tgetHibernateTemplate().saveOrUpdate(element);\n\t\t\t}\n\t\t\tgetHibernateTemplate().flush();\n\t\t}\n\t}","commit_id":"71a97aefa65adfbfcbfbd4a2f9a6141eb2e1ef6a","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void setAttachmentRefList(List attachmentRefList) {\n\t\tthis.attachmentRefList = attachmentRefList;\n\t}","id":65888,"modified_method":"public void setAttachmentRefList(List<Reference> attachmentRefList) {\n\t\tthis.attachmentRefList = attachmentRefList;\n\t}","commit_id":"71a97aefa65adfbfcbfbd4a2f9a6141eb2e1ef6a","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void report() {\n        for (XField xfield : statMap.keySet()) {\n            FieldStats stats = statMap.get(xfield);\n            if (!stats.interesting)\n                continue;\n            JCIPAnnotationDatabase jcipAnotationDatabase = AnalysisContext.currentAnalysisContext().getJCIPAnnotationDatabase();\n            boolean guardedByThis = \"this\".equals(jcipAnotationDatabase.getFieldAnnotation(xfield, \"GuardedBy\"));\n            boolean notThreadSafe = jcipAnotationDatabase.hasClassAnnotation(xfield.getClassName(), \"NotThreadSafe\");\n            boolean threadSafe = jcipAnotationDatabase.hasClassAnnotation(xfield.getClassName().replace('/', '.'), \"ThreadSafe\");\n            if (notThreadSafe)\n                continue;\n\n            WarningPropertySet<InconsistentSyncWarningProperty> propertySet = new WarningPropertySet<InconsistentSyncWarningProperty>();\n\n            int numReadUnlocked = stats.getNumAccesses(READ_UNLOCKED);\n            int numWriteUnlocked = stats.getNumAccesses(WRITE_UNLOCKED);\n            int numNullCheckUnlocked = stats.getNumAccesses(NULLCHECK_UNLOCKED);\n\n            int numReadLocked = stats.getNumAccesses(READ_LOCKED);\n            int numWriteLocked = stats.getNumAccesses(WRITE_LOCKED);\n            int numNullCheckLocked = stats.getNumAccesses(NULLCHECK_LOCKED);\n\n            int extra = 0;\n            if (numWriteUnlocked > 0)\n                extra = numNullCheckLocked;\n            int locked = numReadLocked + numWriteLocked + numNullCheckLocked;\n            int biasedLocked = numReadLocked + (int) (WRITE_BIAS * (numWriteLocked + numNullCheckLocked + extra));\n            int unlocked = numReadUnlocked + numWriteUnlocked + numNullCheckUnlocked;\n            int biasedUnlocked = numReadUnlocked + (int) (WRITE_BIAS * (numWriteUnlocked));\n            // int writes = numWriteLocked + numWriteUnlocked;\n\n            if (unlocked == 0) {\n                continue;\n                // propertySet.addProperty(InconsistentSyncWarningProperty.NEVER_UNLOCKED);\n            }\n\n            if (guardedByThis) {\n                propertySet.addProperty(InconsistentSyncWarningProperty.ANNOTATED_AS_GUARDED_BY_THIS);\n\n            }\n\n            if (threadSafe) {\n                propertySet.addProperty(InconsistentSyncWarningProperty.ANNOTATED_AS_THREAD_SAFE);\n\n            }\n            if (!guardedByThis && locked == 0 && !stats.isServletField()) {\n                continue;\n                // propertySet.addProperty(InconsistentSyncWarningProperty.NEVER_LOCKED);\n            }\n\n            if (stats.isServletField() && numWriteLocked == 0 && numWriteUnlocked == 0)\n                continue;\n\n            if (DEBUG) {\n                System.out.println(\"IS2: \" + xfield);\n                if (guardedByThis)\n                    System.out.println(\"Guarded by this\");\n                System.out.println(\"  RL: \" + numReadLocked);\n                System.out.println(\"  WL: \" + numWriteLocked);\n                System.out.println(\"  NL: \" + numNullCheckLocked);\n\n                System.out.println(\"  RU: \" + numReadUnlocked);\n                System.out.println(\"  WU: \" + numWriteUnlocked);\n                System.out.println(\"  NU: \" + numNullCheckUnlocked);\n            }\n            if (!EVAL && numReadUnlocked > 0 && ((int) (UNSYNC_FACTOR * (biasedUnlocked - 1))) > biasedLocked\n                    && !stats.isServletField()) {\n                // continue;\n                propertySet.addProperty(InconsistentSyncWarningProperty.MANY_BIASED_UNLOCKED);\n            }\n\n            // NOTE: we ignore access to public, volatile, and final fields\n\n            if (numWriteUnlocked + numWriteLocked == 0) {\n                // No writes outside of constructor\n                if (DEBUG)\n                    System.out.println(\"  No writes outside of constructor\");\n                propertySet.addProperty(InconsistentSyncWarningProperty.NEVER_WRITTEN);\n                // continue;\n            }\n\n            if (numReadUnlocked + numReadLocked == 0) {\n                // No reads outside of constructor\n                if (DEBUG)\n                    System.out.println(\"  No reads outside of constructor\");\n                // continue;\n                propertySet.addProperty(InconsistentSyncWarningProperty.NEVER_READ);\n            }\n\n            if (stats.getNumLocalLocks() == 0) {\n                if (DEBUG)\n                    System.out.println(\"  No local locks\");\n                // continue;\n                propertySet.addProperty(InconsistentSyncWarningProperty.NO_LOCAL_LOCKS);\n            }\n\n            int freq, printFreq;\n            if (locked + unlocked > 0) {\n                freq = (100 * locked) / (locked + unlocked);\n                printFreq = (100 * locked) / (locked + unlocked + numNullCheckUnlocked);\n            } else {\n                printFreq = freq = 0;\n            }\n\n            if (freq < MIN_SYNC_PERCENT) {\n                // continue;\n                propertySet.addProperty(InconsistentSyncWarningProperty.BELOW_MIN_SYNC_PERCENT);\n            }\n            if (DEBUG)\n                System.out.println(\"  Sync %: \" + freq);\n\n            if (stats.getNumGetterMethodAccesses() >= unlocked) {\n                // Unlocked accesses are only in getter method(s).\n                propertySet.addProperty(InconsistentSyncWarningProperty.ONLY_UNSYNC_IN_GETTERS);\n            }\n\n            // At this point, we report the field as being inconsistently\n            // synchronized\n            if (stats.isServletField())\n                propertySet.addProperty(InconsistentSyncWarningProperty.MUTABLE_SERVLET_FIELD);\n\n            BugInstance bugInstance;\n            if (stats.isServletField())\n                bugInstance = new BugInstance(this, \"MSF_MUTABLE_SERVLET_FIELD\", Priorities.NORMAL_PRIORITY).addClass(\n                        xfield.getClassName()).addField(xfield);\n            else\n                bugInstance = new BugInstance(this, guardedByThis ? \"IS_FIELD_NOT_GUARDED\" : \"IS2_INCONSISTENT_SYNC\",\n                        Priorities.NORMAL_PRIORITY).addClass(xfield.getClassName()).addField(xfield).addInt(printFreq)\n                        .describe(IntAnnotation.INT_SYNC_PERCENT);\n\n            propertySet.decorateBugInstance(bugInstance);\n            // Add source lines for unsynchronized accesses\n            for (Iterator<SourceLineAnnotation> j = stats.unsyncAccessIterator(); j.hasNext();) {\n                SourceLineAnnotation accessSourceLine = j.next();\n                bugInstance.addSourceLine(accessSourceLine).describe(\"SOURCE_LINE_UNSYNC_ACCESS\");\n            }\n\n            if (SYNC_ACCESS) {\n                // Add source line for synchronized accesses;\n                // useful for figuring out what the detector is doing\n                for (Iterator<SourceLineAnnotation> j = stats.syncAccessIterator(); j.hasNext();) {\n                    SourceLineAnnotation accessSourceLine = j.next();\n                    bugInstance.addSourceLine(accessSourceLine).describe(\"SOURCE_LINE_SYNC_ACCESS\");\n                }\n            }\n\n            if (EVAL) {\n                bugInstance.addInt(biasedLocked).describe(\"INT_BIASED_LOCKED\");\n                bugInstance.addInt(biasedUnlocked).describe(\"INT_BIASED_UNLOCKED\");\n            }\n\n            bugReporter.reportBug(bugInstance);\n\n        }\n    }","id":65889,"modified_method":"public void report() {\n        if(statMap.isEmpty()){\n            return;\n        }\n        JCIPAnnotationDatabase jcipAnotationDatabase = AnalysisContext.currentAnalysisContext().getJCIPAnnotationDatabase();\n        for (XField xfield : statMap.keySet()) {\n            FieldStats stats = statMap.get(xfield);\n            if (!stats.isInteresting())\n                continue;\n            boolean notThreadSafe = jcipAnotationDatabase.hasClassAnnotation(xfield.getClassName(), \"NotThreadSafe\");\n            if (notThreadSafe)\n                continue;\n            boolean guardedByThis = \"this\".equals(jcipAnotationDatabase.getFieldAnnotation(xfield, \"GuardedBy\"));\n            boolean threadSafe = jcipAnotationDatabase.hasClassAnnotation(xfield.getClassName(), \"ThreadSafe\");\n\n            WarningPropertySet<InconsistentSyncWarningProperty> propertySet = new WarningPropertySet<InconsistentSyncWarningProperty>();\n\n            int numReadUnlocked = stats.getNumAccesses(READ_UNLOCKED);\n            int numWriteUnlocked = stats.getNumAccesses(WRITE_UNLOCKED);\n            int numNullCheckUnlocked = stats.getNumAccesses(NULLCHECK_UNLOCKED);\n\n            int numReadLocked = stats.getNumAccesses(READ_LOCKED);\n            int numWriteLocked = stats.getNumAccesses(WRITE_LOCKED);\n            int numNullCheckLocked = stats.getNumAccesses(NULLCHECK_LOCKED);\n\n            int extra = 0;\n            if (numWriteUnlocked > 0)\n                extra = numNullCheckLocked;\n            int locked = numReadLocked + numWriteLocked + numNullCheckLocked;\n            int biasedLocked = numReadLocked + (int) (WRITE_BIAS * (numWriteLocked + numNullCheckLocked + extra));\n            int unlocked = numReadUnlocked + numWriteUnlocked + numNullCheckUnlocked;\n            int biasedUnlocked = numReadUnlocked + (int) (WRITE_BIAS * (numWriteUnlocked));\n            // int writes = numWriteLocked + numWriteUnlocked;\n\n            if (unlocked == 0) {\n                continue;\n                // propertySet.addProperty(InconsistentSyncWarningProperty.NEVER_UNLOCKED);\n            }\n\n            if (guardedByThis) {\n                propertySet.addProperty(InconsistentSyncWarningProperty.ANNOTATED_AS_GUARDED_BY_THIS);\n\n            }\n\n            if (threadSafe) {\n                propertySet.addProperty(InconsistentSyncWarningProperty.ANNOTATED_AS_THREAD_SAFE);\n\n            }\n            if (!guardedByThis && locked == 0 && !stats.isServletField()) {\n                continue;\n                // propertySet.addProperty(InconsistentSyncWarningProperty.NEVER_LOCKED);\n            }\n\n            if (stats.isServletField() && numWriteLocked == 0 && numWriteUnlocked == 0)\n                continue;\n\n            if (DEBUG) {\n                System.out.println(\"IS2: \" + xfield);\n                if (guardedByThis)\n                    System.out.println(\"Guarded by this\");\n                System.out.println(\"  RL: \" + numReadLocked);\n                System.out.println(\"  WL: \" + numWriteLocked);\n                System.out.println(\"  NL: \" + numNullCheckLocked);\n\n                System.out.println(\"  RU: \" + numReadUnlocked);\n                System.out.println(\"  WU: \" + numWriteUnlocked);\n                System.out.println(\"  NU: \" + numNullCheckUnlocked);\n            }\n            if (!EVAL && numReadUnlocked > 0 && ((int) (UNSYNC_FACTOR * (biasedUnlocked - 1))) > biasedLocked\n                    && !stats.isServletField()) {\n                // continue;\n                propertySet.addProperty(InconsistentSyncWarningProperty.MANY_BIASED_UNLOCKED);\n            }\n\n            // NOTE: we ignore access to public, volatile, and final fields\n\n            if (numWriteUnlocked + numWriteLocked == 0) {\n                // No writes outside of constructor\n                if (DEBUG)\n                    System.out.println(\"  No writes outside of constructor\");\n                propertySet.addProperty(InconsistentSyncWarningProperty.NEVER_WRITTEN);\n                // continue;\n            }\n\n            if (numReadUnlocked + numReadLocked == 0) {\n                // No reads outside of constructor\n                if (DEBUG)\n                    System.out.println(\"  No reads outside of constructor\");\n                // continue;\n                propertySet.addProperty(InconsistentSyncWarningProperty.NEVER_READ);\n            }\n\n            if (stats.getNumLocalLocks() == 0) {\n                if (DEBUG)\n                    System.out.println(\"  No local locks\");\n                // continue;\n                propertySet.addProperty(InconsistentSyncWarningProperty.NO_LOCAL_LOCKS);\n            }\n\n            int freq, printFreq;\n            if (locked + unlocked > 0) {\n                freq = (100 * locked) / (locked + unlocked);\n                printFreq = (100 * locked) / (locked + unlocked + numNullCheckUnlocked);\n            } else {\n                printFreq = freq = 0;\n            }\n\n            if (freq < MIN_SYNC_PERCENT) {\n                // continue;\n                propertySet.addProperty(InconsistentSyncWarningProperty.BELOW_MIN_SYNC_PERCENT);\n            }\n            if (DEBUG)\n                System.out.println(\"  Sync %: \" + freq);\n\n            if (stats.getNumGetterMethodAccesses() >= unlocked) {\n                // Unlocked accesses are only in getter method(s).\n                propertySet.addProperty(InconsistentSyncWarningProperty.ONLY_UNSYNC_IN_GETTERS);\n            }\n\n            // At this point, we report the field as being inconsistently\n            // synchronized\n            if (stats.isServletField())\n                propertySet.addProperty(InconsistentSyncWarningProperty.MUTABLE_SERVLET_FIELD);\n\n            BugInstance bugInstance;\n            if (stats.isServletField())\n                bugInstance = new BugInstance(this, \"MSF_MUTABLE_SERVLET_FIELD\", Priorities.NORMAL_PRIORITY).addClass(\n                        xfield.getClassName()).addField(xfield);\n            else\n                bugInstance = new BugInstance(this, guardedByThis ? \"IS_FIELD_NOT_GUARDED\" : \"IS2_INCONSISTENT_SYNC\",\n                        Priorities.NORMAL_PRIORITY).addClass(xfield.getClassName()).addField(xfield).addInt(printFreq)\n                        .describe(IntAnnotation.INT_SYNC_PERCENT);\n\n            propertySet.decorateBugInstance(bugInstance);\n            // Add source lines for unsynchronized accesses\n            for (Iterator<SourceLineAnnotation> j = stats.unsyncAccessIterator(); j.hasNext();) {\n                SourceLineAnnotation accessSourceLine = j.next();\n                bugInstance.addSourceLine(accessSourceLine).describe(\"SOURCE_LINE_UNSYNC_ACCESS\");\n            }\n\n            if (SYNC_ACCESS) {\n                // Add source line for synchronized accesses;\n                // useful for figuring out what the detector is doing\n                for (Iterator<SourceLineAnnotation> j = stats.syncAccessIterator(); j.hasNext();) {\n                    SourceLineAnnotation accessSourceLine = j.next();\n                    bugInstance.addSourceLine(accessSourceLine).describe(\"SOURCE_LINE_SYNC_ACCESS\");\n                }\n            }\n\n            if (EVAL) {\n                bugInstance.addInt(biasedLocked).describe(\"INT_BIASED_LOCKED\");\n                bugInstance.addInt(biasedUnlocked).describe(\"INT_BIASED_UNLOCKED\");\n            }\n\n            bugReporter.reportBug(bugInstance);\n\n        }\n    }","commit_id":"7804cd971d7ad35708f8cccac9093c3294b03d37","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"FieldStats(XField field) {\n            this.field = field;\n            servletField = FindInconsistentSync2.isServletField(field);\n        }","id":65890,"modified_method":"FieldStats(XField field) {\n            servletField = FindInconsistentSync2.isServletField(field);\n        }","commit_id":"7804cd971d7ad35708f8cccac9093c3294b03d37","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public boolean hasMethodAnnotation(XMethod method, String annotationClass) {\n        return getEntryForClassMember(method).containsKey(annotationClass);\n    }","id":65891,"modified_method":"public boolean hasMethodAnnotation(XMethod method, String annotationClass) {\n        Map<String, ElementValue> map = getEntryForClassMember(method);\n        return map.containsKey(annotationClass);\n    }","commit_id":"7804cd971d7ad35708f8cccac9093c3294b03d37","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public Object getClassAnnotation(String dottedClassName, String annotationClass) {\n        assert dottedClassName.indexOf('/') == -1;\n        return getEntryForClass(dottedClassName).get(annotationClass);\n    }","id":65892,"modified_method":"@CheckForNull\n    public Object getClassAnnotation(@DottedClassName String dottedClassName, String annotationClass) {\n        Map<String, ElementValue> map = getEntryForClass(dottedClassName);\n        return map == null? null : map.get(annotationClass);\n    }","commit_id":"7804cd971d7ad35708f8cccac9093c3294b03d37","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public Map<String, ElementValue> getEntryForClass(String dottedClassName) {\n        assert dottedClassName.indexOf('/') == -1;\n        Map<String, ElementValue> map = classAnnotations.get(dottedClassName);\n        if (map == null) {\n            map = new HashMap<String, ElementValue>(3);\n            classAnnotations.put(dottedClassName, map);\n        }\n        return map;\n    }","id":65893,"modified_method":"@CheckForNull\n    private Map<String, ElementValue> getEntryForClass(@DottedClassName String dottedClassName) {\n        assert dottedClassName.indexOf('/') == -1;\n        return classAnnotations.get(dottedClassName);\n    }","commit_id":"7804cd971d7ad35708f8cccac9093c3294b03d37","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public boolean hasFieldAnnotation(XField field, String annotationClass) {\n        return getEntryForClassMember(field).containsKey(annotationClass);\n    }","id":65894,"modified_method":"public boolean hasFieldAnnotation(XField field, String annotationClass) {\n        Map<String, ElementValue> map = getEntryForClassMember(field);\n        return map != null && map.containsKey(annotationClass);\n    }","commit_id":"7804cd971d7ad35708f8cccac9093c3294b03d37","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public Map<String, ElementValue> getEntryForClassMember(ClassMember member) {\n        Map<String, ElementValue> map = memberAnnotations.get(member);\n        if (map == null) {\n            map = new HashMap<String, ElementValue>();\n            memberAnnotations.put(member, map);\n        }\n        return map;\n    }","id":65895,"modified_method":"@CheckForNull\n    private Map<String, ElementValue> getEntryForClassMember(ClassMember member) {\n        return memberAnnotations.get(member);\n    }","commit_id":"7804cd971d7ad35708f8cccac9093c3294b03d37","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public Object getMethodAnnotation(XMethod method, String annotationClass) {\n        return getEntryForClassMember(method).get(annotationClass);\n    }","id":65896,"modified_method":"@CheckForNull\n    public Object getMethodAnnotation(XMethod method, String annotationClass) {\n        Map<String, ElementValue> map = getEntryForClassMember(method);\n        return map == null? null : map.get(annotationClass);\n    }","commit_id":"7804cd971d7ad35708f8cccac9093c3294b03d37","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public Object getFieldAnnotation(XField field, String annotationClass) {\n        return getEntryForClassMember(field).get(annotationClass);\n    }","id":65897,"modified_method":"@CheckForNull\n    public Object getFieldAnnotation(XField field, String annotationClass) {\n        Map<String, ElementValue> map = getEntryForClassMember(field);\n        return map == null? null : map.get(annotationClass);\n    }","commit_id":"7804cd971d7ad35708f8cccac9093c3294b03d37","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public boolean hasClassAnnotation(String dottedClassName, String annotationClass) {\n        assert dottedClassName.indexOf('/') == -1;\n        return getEntryForClass(dottedClassName).containsKey(annotationClass);\n    }","id":65898,"modified_method":"public boolean hasClassAnnotation(@DottedClassName String dottedClassName, String annotationClass) {\n        assert dottedClassName.indexOf('/') == -1;\n        Map<String, ElementValue> map = getEntryForClass(dottedClassName);\n        return map != null && map.containsKey(annotationClass);\n    }","commit_id":"7804cd971d7ad35708f8cccac9093c3294b03d37","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n    public void visitAnnotation(String annotationClass, Map<String, ElementValue> map, boolean runtimeVisible) {\n\n        if (!annotationClass.startsWith(NET_JCIP_ANNOTATIONS))\n            return;\n        annotationClass = annotationClass.substring(NET_JCIP_ANNOTATIONS.length());\n        ElementValue value = map.get(\"value\");\n        ClassMember member;\n        if (visitingField())\n            member = XFactory.createXField(this);\n        else if (visitingMethod())\n            member = XFactory.createXMethod(this);\n        else {\n            Map<String, ElementValue> annotationsOfThisClass = AnalysisContext.currentAnalysisContext()\n                    .getJCIPAnnotationDatabase().getEntryForClass(getDottedClassName());\n            annotationsOfThisClass.put(annotationClass, value);\n            return;\n        }\n        Map<String, ElementValue> annotationsOfThisMember = AnalysisContext.currentAnalysisContext().getJCIPAnnotationDatabase()\n                .getEntryForClassMember(member);\n        annotationsOfThisMember.put(annotationClass, value);\n    }","id":65899,"modified_method":"@Override\n    public void visitAnnotation(String annotationClass, Map<String, ElementValue> map, boolean runtimeVisible) {\n\n        if (!annotationClass.startsWith(NET_JCIP_ANNOTATIONS)) {\n            return;\n        }\n        annotationClass = annotationClass.substring(NET_JCIP_ANNOTATIONS.length());\n        ElementValue value = map.get(\"value\");\n        ClassMember member;\n        if (visitingField()) {\n            member = XFactory.createXField(this);\n        } else if (visitingMethod()) {\n            member = XFactory.createXMethod(this);\n        } else {\n            AnalysisContext.currentAnalysisContext()\n                    .getJCIPAnnotationDatabase().addEntryForClass(getDottedClassName(), annotationClass, value);\n            return;\n        }\n        AnalysisContext.currentAnalysisContext().getJCIPAnnotationDatabase()\n                .addEntryForClassMember(member, annotationClass, value);\n    }","commit_id":"7804cd971d7ad35708f8cccac9093c3294b03d37","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void removeRedundantImports(@NotNull PsiJavaFile file) throws IncorrectOperationException {\n    if (PsiUtil.isInJspFile(file)) return;\n\n    final PsiImportList importList = file.getImportList();\n    if (importList == null) return;\n    final PsiImportStatementBase[] imports = importList.getAllImportStatements();\n    if( imports.length == 0 ) return;\n\n    final Collection<PsiImportStatementBase> redundants = new THashSet<PsiImportStatementBase>(Arrays.asList(imports));\n    final PsiElement[] roots = file.getPsiRoots();\n    for (PsiElement root : roots) {\n      root.accept(new PsiRecursiveElementVisitor() {\n        public void visitReferenceElement(PsiJavaCodeReferenceElement reference) {\n          if (!reference.isQualified()) {\n            final JavaResolveResult resolveResult = reference.advancedResolve(false);\n            final PsiElement resolveScope = resolveResult.getCurrentFileResolveScope();\n            if (resolveScope instanceof PsiImportStatementBase) {\n              final PsiImportStatementBase importStatementBase = (PsiImportStatementBase)resolveScope;\n              redundants.remove(importStatementBase);\n            }\n          }\n          super.visitReferenceElement(reference);\n        }\n      });\n    }\n\n    for (final PsiImportStatementBase importStatement : redundants) {\n      final PsiJavaCodeReferenceElement ref = importStatement.getImportReference();\n      //Do not remove non-resolving refs\n      if (ref == null || ref.resolve() == null) {\n        continue;\n      }\n\n      importStatement.delete();\n    }\n  }","id":65900,"modified_method":"public void removeRedundantImports(@NotNull PsiJavaFile file) throws IncorrectOperationException {\n    final PsiImportList importList = file.getImportList();\n    if (importList == null) return;\n    final PsiImportStatementBase[] imports = importList.getAllImportStatements();\n    if( imports.length == 0 ) return;\n\n    Set<PsiImportStatementBase> allImports = new THashSet<PsiImportStatementBase>(Arrays.asList(imports));\n    final Collection<PsiImportStatementBase> redundants;\n    if (PsiUtil.isInJspFile(file)) {\n      // remove only duplicate imports\n      redundants = new THashSet<PsiImportStatementBase>(TObjectHashingStrategy.IDENTITY);\n      redundants.addAll(Arrays.asList(imports));\n      redundants.removeAll(allImports);\n      for (PsiImportStatementBase importStatement : imports) {\n        if (importStatement instanceof JspxImportStatement && ((JspxImportStatement)importStatement).isForeignFileImport()) {\n          redundants.remove(importStatement);\n        }\n      }\n    }\n    else {\n      redundants = allImports;\n      final PsiElement[] roots = file.getPsiRoots();\n      for (PsiElement root : roots) {\n        root.accept(new PsiRecursiveElementVisitor() {\n          public void visitReferenceElement(PsiJavaCodeReferenceElement reference) {\n            if (!reference.isQualified()) {\n              final JavaResolveResult resolveResult = reference.advancedResolve(false);\n              final PsiElement resolveScope = resolveResult.getCurrentFileResolveScope();\n              if (resolveScope instanceof PsiImportStatementBase) {\n                final PsiImportStatementBase importStatementBase = (PsiImportStatementBase)resolveScope;\n                redundants.remove(importStatementBase);\n              }\n            }\n            super.visitReferenceElement(reference);\n          }\n        });\n      }\n    }\n\n    for (final PsiImportStatementBase importStatement : redundants) {\n      final PsiJavaCodeReferenceElement ref = importStatement.getImportReference();\n      //Do not remove non-resolving refs\n      if (ref == null || ref.resolve() == null) {\n        continue;\n      }\n\n      importStatement.delete();\n    }\n  }","commit_id":"58ec1345588863c7bbc287b47cd45119f84ce531","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static UsageViewPresentation createPresentation(UsageViewDescriptor descriptor, final Usage[] usages) {\n    UsageViewPresentation presentation = new UsageViewPresentation();\n    presentation.setTabText(RefactoringBundle.message(\"usageView.tabText\"));\n    presentation.setTargetsNodeText(descriptor.getProcessedElementsHeader());\n    presentation.setShowReadOnlyStatusAsRed(true);\n    presentation.setShowCancelButton(true);\n    presentation.setUsagesString(RefactoringBundle.message(\"usageView.usagesText\"));\n    int codeUsageCount = 0;\n    int nonCodeUsageCount = 0;\n    Set<PsiFile> codeFiles = new HashSet<PsiFile>();\n    Set<PsiFile> nonCodeFiles = new HashSet<PsiFile>();\n\n    for (Usage usage : usages) {\n      if (usage instanceof PsiElementUsage) {\n        final PsiElementUsage elementUsage = ((PsiElementUsage)usage);\n        if (elementUsage.isNonCodeUsage()) {\n          nonCodeUsageCount++;\n          nonCodeFiles.add(elementUsage.getElement().getContainingFile());\n        }\n        else {\n          codeUsageCount++;\n          codeFiles.add(elementUsage.getElement().getContainingFile());\n        }\n      }\n    }\n    codeFiles.remove(null);\n    nonCodeFiles.remove(null);\n\n    presentation.setCodeUsagesString(descriptor.getCodeReferencesText(codeUsageCount, codeFiles.size()));\n    presentation.setNonCodeUsagesString(descriptor.getCommentReferencesText(nonCodeUsageCount, nonCodeFiles.size()));\n    return presentation;\n  }","id":65901,"modified_method":"private static UsageViewPresentation createPresentation(UsageViewDescriptor descriptor, final Usage[] usages) {\n    UsageViewPresentation presentation = new UsageViewPresentation();\n    presentation.setTabText(RefactoringBundle.message(\"usageView.tabText\"));\n    presentation.setTargetsNodeText(descriptor.getProcessedElementsHeader());\n    presentation.setShowReadOnlyStatusAsRed(true);\n    presentation.setShowCancelButton(true);\n    presentation.setUsagesString(RefactoringBundle.message(\"usageView.usagesText\"));\n    int codeUsageCount = 0;\n    int nonCodeUsageCount = 0;\n    Set<PsiFile> codeFiles = new HashSet<PsiFile>();\n    Set<PsiFile> nonCodeFiles = new HashSet<PsiFile>();\n\n    for (Usage usage : usages) {\n      if (usage instanceof PsiElementUsage) {\n        final PsiElementUsage elementUsage = (PsiElementUsage)usage;\n        if (elementUsage.isNonCodeUsage()) {\n          nonCodeUsageCount++;\n          nonCodeFiles.add(elementUsage.getElement().getContainingFile());\n        }\n        else {\n          codeUsageCount++;\n          codeFiles.add(elementUsage.getElement().getContainingFile());\n        }\n      }\n    }\n    codeFiles.remove(null);\n    nonCodeFiles.remove(null);\n\n    presentation.setCodeUsagesString(descriptor.getCodeReferencesText(codeUsageCount, codeFiles.size()));\n    presentation.setNonCodeUsagesString(descriptor.getCommentReferencesText(nonCodeUsageCount, nonCodeFiles.size()));\n    return presentation;\n  }","commit_id":"7b3c6f1db400cd904e9ecf0790b51cc8da9d5cb2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void removeRedundantImports(PsiJavaFile file) throws IncorrectOperationException {\n    if (PsiUtil.isInJspFile(file)) return;\n    final PsiImportList importList = file.getImportList();\n    if (importList == null) {\n      return;\n    }\n    final PsiImportStatementBase[] imports = importList.getAllImportStatements();\n    if( imports.length == 0 )\n    {\n      return;\n    }\n\n    final Set<PsiImportStatementBase> redundants = new HashSet<PsiImportStatementBase>(Arrays.asList(imports));\n    final PsiElement[] roots = file.getPsiRoots();\n    for (PsiElement root : roots) {\n      root.accept(new PsiRecursiveElementVisitor() {\n        public void visitReferenceElement(PsiJavaCodeReferenceElement reference) {\n          if (!reference.isQualified()) {\n            final JavaResolveResult resolveResult = reference.advancedResolve(false);\n            final PsiElement resolveScope = resolveResult.getCurrentFileResolveScope();\n            if (resolveScope instanceof PsiImportStatementBase) {\n              //noinspection SuspiciousMethodCalls\n              redundants.remove(resolveScope);\n            }\n          }\n          super.visitReferenceElement(reference);\n        }\n      });\n    }\n\n    for (final PsiImportStatementBase importStatement : redundants) {\n      final PsiJavaCodeReferenceElement ref = importStatement.getImportReference();\n      //Do not remove non-resolving refs\n      if( ref == null || ref.resolve() == null )\n      {\n        continue;\n      }\n\n      importStatement.delete();\n    }\n  }","id":65902,"modified_method":"public void removeRedundantImports(PsiJavaFile file) throws IncorrectOperationException {\n    final PsiImportList importList = file.getImportList();\n    if (importList == null) return;\n    final PsiImportStatementBase[] imports = importList.getAllImportStatements();\n    if( imports.length == 0 ) return;\n\n    Set<PsiImportStatementBase> allImports = new THashSet<PsiImportStatementBase>(Arrays.asList(imports));\n    final Collection<PsiImportStatementBase> redundants;\n    if (PsiUtil.isInJspFile(file)) {\n      // remove only duplicate imports\n      redundants = new THashSet<PsiImportStatementBase>(TObjectHashingStrategy.IDENTITY);\n      redundants.addAll(Arrays.asList(imports));\n      redundants.removeAll(allImports);\n    }\n    else {\n      redundants = allImports;\n      final PsiElement[] roots = file.getPsiRoots();\n      for (PsiElement root : roots) {\n        root.accept(new PsiRecursiveElementVisitor() {\n          public void visitReferenceElement(PsiJavaCodeReferenceElement reference) {\n            if (!reference.isQualified()) {\n              final JavaResolveResult resolveResult = reference.advancedResolve(false);\n              final PsiElement resolveScope = resolveResult.getCurrentFileResolveScope();\n              if (resolveScope instanceof PsiImportStatementBase) {\n                final PsiImportStatementBase importStatementBase = (PsiImportStatementBase)resolveScope;\n                redundants.remove(importStatementBase);\n              }\n            }\n            super.visitReferenceElement(reference);\n          }\n        });\n      }\n    }\n\n    for (final PsiImportStatementBase importStatement : redundants) {\n      final PsiJavaCodeReferenceElement ref = importStatement.getImportReference();\n      //Do not remove non-resolving refs\n      if (ref == null || ref.resolve() == null) {\n        continue;\n      }\n\n      importStatement.delete();\n    }\n  }","commit_id":"7b3c6f1db400cd904e9ecf0790b51cc8da9d5cb2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public PsiElement insertNewLineIndentMarker(PsiFile file, int offset) throws IncorrectOperationException {\n    CheckUtil.checkWritable(file);\n    final CharTable charTable = ((FileElement)SourceTreeToPsiMap.psiElementToTree(file)).getCharTable();\n    PsiElement elementAt = file.findElementAt(offset);\n    if( elementAt == null )\n    {\n      return null;\n    }\n    ASTNode element = SourceTreeToPsiMap.psiElementToTree(elementAt);\n    ASTNode parent = element.getTreeParent();\n    int elementStart = element.getTextRange().getStartOffset();\n    if (element.getElementType() != ElementType.WHITE_SPACE) {\n      /*\n      if (elementStart < offset) return null;\n      Element marker = Factory.createLeafElement(ElementType.NEW_LINE_INDENT, \"###\".toCharArray(), 0, \"###\".length());\n      ChangeUtil.addChild(parent, marker, element);\n      return marker;\n      */\n      return null;\n    }\n\n    ASTNode space1 = Helper.splitSpaceElement((TreeElement)element, offset - elementStart, charTable);\n    ASTNode marker = Factory.createSingleLeafElement(TokenTypeEx.NEW_LINE_INDENT, DUMMY_IDENTIFIER.toCharArray(), 0,\n                                                     DUMMY_IDENTIFIER.length(), charTable, file.getManager());\n    parent.addChild(marker, space1.getTreeNext());\n    return SourceTreeToPsiMap.treeElementToPsi(marker);\n  }","id":65903,"modified_method":"@Nullable\n  public PsiElement insertNewLineIndentMarker(PsiFile file, int offset) throws IncorrectOperationException {\n    CheckUtil.checkWritable(file);\n    final CharTable charTable = ((FileElement)SourceTreeToPsiMap.psiElementToTree(file)).getCharTable();\n    PsiElement elementAt = file.findElementAt(offset);\n    if( elementAt == null )\n    {\n      return null;\n    }\n    ASTNode element = SourceTreeToPsiMap.psiElementToTree(elementAt);\n    ASTNode parent = element.getTreeParent();\n    int elementStart = element.getTextRange().getStartOffset();\n    if (element.getElementType() != TokenType.WHITE_SPACE) {\n      /*\n      if (elementStart < offset) return null;\n      Element marker = Factory.createLeafElement(ElementType.NEW_LINE_INDENT, \"###\".toCharArray(), 0, \"###\".length());\n      ChangeUtil.addChild(parent, marker, element);\n      return marker;\n      */\n      return null;\n    }\n\n    ASTNode space1 = Helper.splitSpaceElement((TreeElement)element, offset - elementStart, charTable);\n    ASTNode marker = Factory.createSingleLeafElement(TokenType.NEW_LINE_INDENT, DUMMY_IDENTIFIER.toCharArray(), 0,\n                                                     DUMMY_IDENTIFIER.length(), charTable, file.getManager());\n    parent.addChild(marker, space1.getTreeNext());\n    return SourceTreeToPsiMap.treeElementToPsi(marker);\n  }","commit_id":"7b3c6f1db400cd904e9ecf0790b51cc8da9d5cb2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static TextRange getSignificantRange(final PsiFile file, final int offset) {\n    final ASTNode elementAtOffset = SourceTreeToPsiMap.psiElementToTree(file.findElementAt(offset));\n    if (elementAtOffset == null) {\n      return new TextRange(offset, offset);\n    }\n\n    if (file instanceof PsiJavaFile) {\n      ASTNode current = elementAtOffset;\n      current = findNearestExpressionParent(current);\n      if (current == null) {\n        if (elementAtOffset.getElementType() == ElementType.WHITE_SPACE) {\n          ASTNode prevElement = elementAtOffset.getTreePrev();\n          if (prevElement == null) {\n            return elementAtOffset.getTextRange();\n          } else {\n            ASTNode prevExpressionParent = findNearestExpressionParent(prevElement);\n            if (prevExpressionParent == null) {\n              return elementAtOffset.getTextRange();\n            } else {\n              return new TextRange(prevExpressionParent.getTextRange().getStartOffset(), elementAtOffset.getTextRange().getEndOffset());\n            }\n          }\n        } else {\n          return elementAtOffset.getTextRange();\n        }\n\n      }\n      else {\n        return current.getTextRange();\n      }\n    } else {\n      return elementAtOffset.getTextRange();\n    }\n  }","id":65904,"modified_method":"private static TextRange getSignificantRange(final PsiFile file, final int offset) {\n    final ASTNode elementAtOffset = SourceTreeToPsiMap.psiElementToTree(file.findElementAt(offset));\n    if (elementAtOffset == null) {\n      return new TextRange(offset, offset);\n    }\n\n    if (file instanceof PsiJavaFile) {\n      ASTNode current = elementAtOffset;\n      current = findNearestExpressionParent(current);\n      if (current == null) {\n        if (elementAtOffset.getElementType() == TokenType.WHITE_SPACE) {\n          ASTNode prevElement = elementAtOffset.getTreePrev();\n          if (prevElement == null) {\n            return elementAtOffset.getTextRange();\n          }\n          else {\n            ASTNode prevExpressionParent = findNearestExpressionParent(prevElement);\n            if (prevExpressionParent == null) {\n              return elementAtOffset.getTextRange();\n            }\n            else {\n              return new TextRange(prevExpressionParent.getTextRange().getStartOffset(), elementAtOffset.getTextRange().getEndOffset());\n            }\n          }\n        }\n        else {\n          return elementAtOffset.getTextRange();\n        }\n\n      }\n      else {\n        return current.getTextRange();\n      }\n    }\n    else {\n      return elementAtOffset.getTextRange();\n    }\n  }","commit_id":"7b3c6f1db400cd904e9ecf0790b51cc8da9d5cb2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isLineToBeIndented(PsiFile file, int offset) {\n    if( !SourceTreeToPsiMap.hasTreeElement( file ) )\n    {\n      return false;\n    }\n    Helper helper = new Helper(file.getFileType(), myProject);\n    char[] chars = file.textToCharArray();\n    int start = CharArrayUtil.shiftBackward(chars, offset - 1, \" \\t\");\n    if( start > 0 && chars[start] != '\\n' && chars[start] != '\\r' )\n    {\n      return false;\n    }\n    int end = CharArrayUtil.shiftForward(chars, offset, \" \\t\");\n    if( end >= chars.length )\n    {\n      return false;\n    }\n    ASTNode element = SourceTreeToPsiMap.psiElementToTree(file.findElementAt(end));\n    if( element == null )\n    {\n      return false;\n    }\n    if( element.getElementType() == ElementType.WHITE_SPACE )\n    {\n      return false;\n    }\n    if( element.getElementType() == ElementType.PLAIN_TEXT )\n    {\n      return false;\n    }\n    /*\n    if( element.getElementType() instanceof IJspElementType )\n    {\n      return false;\n    }\n    */\n    if (getSettings().KEEP_FIRST_COLUMN_COMMENT\n        && (element.getElementType() == ElementType.END_OF_LINE_COMMENT || element.getElementType() == ElementType.C_STYLE_COMMENT)\n    ) {\n      if( helper.getIndent( element, true ) == 0 )\n      {\n        return false;\n      }\n    }\n    return true;\n  }","id":65905,"modified_method":"public boolean isLineToBeIndented(PsiFile file, int offset) {\n    if (!SourceTreeToPsiMap.hasTreeElement(file)) {\n      return false;\n    }\n    Helper helper = new Helper(file.getFileType(), myProject);\n    char[] chars = file.textToCharArray();\n    int start = CharArrayUtil.shiftBackward(chars, offset - 1, \" \\t\");\n    if (start > 0 && chars[start] != '\\n' && chars[start] != '\\r') {\n      return false;\n    }\n    int end = CharArrayUtil.shiftForward(chars, offset, \" \\t\");\n    if (end >= chars.length) {\n      return false;\n    }\n    ASTNode element = SourceTreeToPsiMap.psiElementToTree(file.findElementAt(end));\n    if (element == null) {\n      return false;\n    }\n    if (element.getElementType() == TokenType.WHITE_SPACE) {\n      return false;\n    }\n    if (element.getElementType() == ElementType.PLAIN_TEXT) {\n      return false;\n    }\n    /*\n    if( element.getElementType() instanceof IJspElementType )\n    {\n      return false;\n    }\n    */\n    if (getSettings().KEEP_FIRST_COLUMN_COMMENT &&\n        (element.getElementType() == JavaTokenType.END_OF_LINE_COMMENT || element.getElementType() == JavaTokenType.C_STYLE_COMMENT)) {\n      if (helper.getIndent(element, true) == 0) {\n        return false;\n      }\n    }\n    return true;\n  }","commit_id":"7b3c6f1db400cd904e9ecf0790b51cc8da9d5cb2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int adjustLineIndent(PsiFile file, int offset) throws IncorrectOperationException {\n\n    final JspFile jspFile = PsiUtil.getJspFile(file);\n\n    if (jspFile != null) {\n      file = jspFile;\n    }\n\n    final PsiElement element = file.findElementAt(offset);\n    if (element == null && offset != file.getTextLength()) {\n      return offset;\n    }\n    if (element != null && !(element instanceof PsiWhiteSpace) && insideElement(element, offset)) {\n      return CharArrayUtil.shiftForward(file.textToCharArray(), offset, \" \\t\");\n    }\n    final Language fileLanguage = file.getLanguage();\n    final FormattingModelBuilder builder = fileLanguage.getFormattingModelBuilder();\n    FormattingModelBuilder elementBuilder = builder;\n    if (element != null) {\n      final Language elementLanguage = element.getLanguage();\n      elementBuilder = elementLanguage.getFormattingModelBuilder();\n    }\n    if (builder != null && elementBuilder != null) {\n      final CodeStyleSettings settings = getSettings();\n      final CodeStyleSettings.IndentOptions indentOptions = settings.getIndentOptions(file.getFileType());\n      final TextRange significantRange = getSignificantRange(file, offset);\n      final FormattingModel model = builder.createModel(file, settings);\n\n      int result = FormatterEx.getInstanceEx().adjustLineIndent(model, settings, indentOptions, offset, significantRange);\n      return result;\n    }\n    else {\n      return offset;\n    }\n  }","id":65906,"modified_method":"public int adjustLineIndent(PsiFile file, int offset) throws IncorrectOperationException {\n\n    final JspFile jspFile = PsiUtil.getJspFile(file);\n\n    if (jspFile != null) {\n      file = jspFile;\n    }\n\n    final PsiElement element = file.findElementAt(offset);\n    if (element == null && offset != file.getTextLength()) {\n      return offset;\n    }\n    if (element != null && !(element instanceof PsiWhiteSpace) && insideElement(element, offset)) {\n      return CharArrayUtil.shiftForward(file.textToCharArray(), offset, \" \\t\");\n    }\n    final Language fileLanguage = file.getLanguage();\n    final FormattingModelBuilder builder = fileLanguage.getFormattingModelBuilder();\n    FormattingModelBuilder elementBuilder = builder;\n    if (element != null) {\n      final Language elementLanguage = element.getLanguage();\n      elementBuilder = elementLanguage.getFormattingModelBuilder();\n    }\n    if (builder != null && elementBuilder != null) {\n      final CodeStyleSettings settings = getSettings();\n      final CodeStyleSettings.IndentOptions indentOptions = settings.getIndentOptions(file.getFileType());\n      final TextRange significantRange = getSignificantRange(file, offset);\n      final FormattingModel model = builder.createModel(file, settings);\n\n      return FormatterEx.getInstanceEx().adjustLineIndent(model, settings, indentOptions, offset, significantRange);\n    }\n    else {\n      return offset;\n    }\n  }","commit_id":"7b3c6f1db400cd904e9ecf0790b51cc8da9d5cb2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean satisfiedBy(PsiElement element) {\n    if (!(element instanceof PsiConditionalExpression)) {\n      return false;\n    }\n    final PsiConditionalExpression conditionalExpression = (PsiConditionalExpression)element;\n    if (JspPsiUtil.isInJspFile(element)) {\n      final PsiExpression thenExpression = conditionalExpression.getThenExpression();\n      if (thenExpression == null) {\n        return false;\n      }\n      final PsiExpression elseExpression = conditionalExpression.getElseExpression();\n      if (elseExpression == null) {\n        return false;\n      }\n    }\n    final PsiElement parent = conditionalExpression.getParent();\n    if (parent instanceof PsiExpressionStatement) {\n      return false;\n    }\n    final PsiMember member = PsiTreeUtil.getParentOfType(element, PsiMember.class);\n    if (member instanceof PsiMethod) {\n      final PsiMethod method = (PsiMethod)member;\n      if (!method.isConstructor()) {\n        return true;\n      }\n      final PsiMethodCallExpression methodCallExpression = PsiTreeUtil.getParentOfType(element, PsiMethodCallExpression.class);\n      if (methodCallExpression == null) {\n        return true;\n      }\n      final PsiReferenceExpression methodExpression = methodCallExpression.getMethodExpression();\n      final String methodName = methodExpression.getReferenceName();\n      return !\"super\".equals(methodName);\n    }\n    else if (member instanceof PsiField) {\n      return false;\n    }\n    return true;\n  }","id":65907,"modified_method":"public boolean satisfiedBy(PsiElement element) {\n    if (!(element instanceof PsiConditionalExpression)) {\n      return false;\n    }\n    final PsiConditionalExpression conditionalExpression = (PsiConditionalExpression)element;\n    final PsiElement parent = conditionalExpression.getParent();\n    if (parent instanceof PsiExpressionStatement) {\n      return false;\n    }\n    if (JspPsiUtil.isInJspFile(element)) {\n      return false;\n    }\n    final PsiMember member = PsiTreeUtil.getParentOfType(element, PsiMember.class);\n    if (member instanceof PsiMethod) {\n      final PsiMethod method = (PsiMethod)member;\n      if (!method.isConstructor()) {\n        return true;\n      }\n      final PsiMethodCallExpression methodCallExpression = PsiTreeUtil.getParentOfType(element, PsiMethodCallExpression.class);\n      if (methodCallExpression == null) {\n        return true;\n      }\n      final PsiReferenceExpression methodExpression = methodCallExpression.getMethodExpression();\n      final String methodName = methodExpression.getReferenceName();\n      return !\"super\".equals(methodName);\n    }\n    else if (member instanceof PsiField) {\n      return false;\n    }\n    return true;\n  }","commit_id":"912cf5ec658778098e982d530341b352f9e3bd3e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void addPortletBreadcrumbEntries(\n\t\t\tFolder folder, HttpServletRequest request,\n\t\t\tRenderResponse renderResponse)\n\t\tthrows Exception {\n\n\t\tString strutsAction = ParamUtil.getString(request, \"struts_action\");\n\n\t\tPortletURL portletURL = renderResponse.createRenderURL();\n\n\t\tif (strutsAction.equals(\"/image_gallery_display/select_folder\")) {\n\t\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t\tportletURL.setParameter(\"struts_action\", strutsAction);\n\t\t\tportletURL.setWindowState(LiferayWindowState.POP_UP);\n\n\t\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\t\trequest, themeDisplay.translate(\"home\"), portletURL.toString());\n\t\t}\n\t\telse {\n\t\t\tportletURL.setParameter(\n\t\t\t\t\"struts_action\", \"/image_gallery_display/view\");\n\t\t}\n\n\t\tList<Folder> ancestorFolders = folder.getAncestors();\n\n\t\tCollections.reverse(ancestorFolders);\n\n\t\tfor (Folder ancestorFolder : ancestorFolders) {\n\t\t\tportletURL.setParameter(\n\t\t\t\t\"folderId\", String.valueOf(ancestorFolder.getFolderId()));\n\n\t\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\t\trequest, ancestorFolder.getName(), portletURL.toString());\n\t\t}\n\n\t\tportletURL.setParameter(\n\t\t\t\"folderId\", String.valueOf(folder.getFolderId()));\n\n\t\tif (strutsAction.equals(\"/journal/select_image_gallery\")) {\n\t\t\tportletURL.setParameter(\n\t\t\t\t\"groupId\", String.valueOf(folder.getGroupId()));\n\t\t}\n\n\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\trequest, folder.getName(), portletURL.toString());\n\t}","id":65908,"modified_method":"public static void addPortletBreadcrumbEntries(\n\t\t\tFolder folder, HttpServletRequest request,\n\t\t\tRenderResponse renderResponse)\n\t\tthrows Exception {\n\n\t\tString strutsAction = ParamUtil.getString(request, \"struts_action\");\n\n\t\tPortletURL portletURL = renderResponse.createRenderURL();\n\n\t\tif (strutsAction.equals(\"/image_gallery_display/select_folder\")) {\n\t\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t\tportletURL.setParameter(\"struts_action\", strutsAction);\n\t\t\tportletURL.setWindowState(LiferayWindowState.POP_UP);\n\n\t\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\t\trequest, themeDisplay.translate(\"home\"), portletURL.toString());\n\t\t}\n\t\telse {\n\t\t\tportletURL.setParameter(\n\t\t\t\t\"struts_action\", \"/image_gallery_display/view\");\n\t\t}\n\n\t\tlong defaultFolderId = getDefaultFolderId(request);\n\n\t\tList<Folder> ancestorFolders = Collections.emptyList();\n\n\t\tif ((folder != null) && (folder.getFolderId() != defaultFolderId)) {\n\t\t\tancestorFolders = folder.getAncestors();\n\n\t\t\tint indexOfRootFolder = -1;\n\n\t\t\tfor (int i = 0; i < ancestorFolders.size(); i++) {\n\t\t\t\tFolder ancestorFolder = ancestorFolders.get(i);\n\n\t\t\t\tif (defaultFolderId == ancestorFolder.getFolderId()) {\n\t\t\t\t\tindexOfRootFolder = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (indexOfRootFolder > -1) {\n\t\t\t\tancestorFolders = ancestorFolders.subList(0, indexOfRootFolder);\n\t\t\t}\n\t\t}\n\n\t\tCollections.reverse(ancestorFolders);\n\n\t\tfor (Folder ancestorFolder : ancestorFolders) {\n\t\t\tportletURL.setParameter(\n\t\t\t\t\"folderId\", String.valueOf(ancestorFolder.getFolderId()));\n\n\t\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\t\trequest, ancestorFolder.getName(), portletURL.toString());\n\t\t}\n\n\t\tportletURL.setParameter(\n\t\t\t\"folderId\", String.valueOf(folder.getFolderId()));\n\n\t\tif (strutsAction.equals(\"/journal/select_image_gallery\")) {\n\t\t\tportletURL.setParameter(\n\t\t\t\t\"groupId\", String.valueOf(folder.getGroupId()));\n\t\t}\n\n\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\trequest, folder.getName(), portletURL.toString());\n\t}","commit_id":"40f1811eafa7cc145b60fc21a40903b465f7f627","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void addPortletBreadcrumbEntries(\n\t\t\tDLFolder folder, HttpServletRequest request,\n\t\t\tRenderResponse renderResponse)\n\t\tthrows Exception {\n\n\t\tString strutsAction = ParamUtil.getString(\n\t\t\trequest, \"struts_action\");\n\n\t\tlong groupId = ParamUtil.getLong(request, \"groupId\");\n\n\t\tPortletURL portletURL = renderResponse.createRenderURL();\n\n\t\tif (strutsAction.equals(\"/journal/select_document_library\") ||\n\t\t\tstrutsAction.equals(\"/document_library/select_file_entry\") ||\n\t\t\tstrutsAction.equals(\"/document_library/select_folder\") ||\n\t\t\tstrutsAction.equals(\"/document_library_display/select_folder\")) {\n\n\t\t\tThemeDisplay themeDisplay =\t(ThemeDisplay)request.getAttribute(\n\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t\tportletURL.setWindowState(LiferayWindowState.POP_UP);\n\n\t\t\tportletURL.setParameter(\"struts_action\", strutsAction);\n\t\t\tportletURL.setParameter(\"groupId\", String.valueOf(groupId));\n\n\t\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\t\trequest, themeDisplay.translate(\"documents-home\"),\n\t\t\t\tportletURL.toString());\n\t\t}\n\t\telse {\n\t\t\tportletURL.setParameter(\"struts_action\", \"/document_library/view\");\n\t\t}\n\n\t\tList<DLFolder> ancestorFolders = folder.getAncestors();\n\n\t\tCollections.reverse(ancestorFolders);\n\n\t\tfor (DLFolder ancestorFolder : ancestorFolders) {\n\t\t\tportletURL.setParameter(\n\t\t\t\t\"folderId\", String.valueOf(ancestorFolder.getFolderId()));\n\n\t\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\t\trequest, ancestorFolder.getName(), portletURL.toString());\n\t\t}\n\n\t\tportletURL.setParameter(\n\t\t\t\"folderId\", String.valueOf(folder.getFolderId()));\n\n\t\tif (folder.getFolderId() !=\n\t\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\t\trequest, folder.getName(), portletURL.toString());\n\t\t}\n\t}","id":65909,"modified_method":"public static void addPortletBreadcrumbEntries(\n\t\t\tDLFolder folder, HttpServletRequest request,\n\t\t\tRenderResponse renderResponse)\n\t\tthrows Exception {\n\n\t\tString strutsAction = ParamUtil.getString(\n\t\t\trequest, \"struts_action\");\n\n\t\tlong groupId = ParamUtil.getLong(request, \"groupId\");\n\n\t\tPortletURL portletURL = renderResponse.createRenderURL();\n\n\t\tif (strutsAction.equals(\"/journal/select_document_library\") ||\n\t\t\tstrutsAction.equals(\"/document_library/select_file_entry\") ||\n\t\t\tstrutsAction.equals(\"/document_library/select_folder\") ||\n\t\t\tstrutsAction.equals(\"/document_library_display/select_folder\")) {\n\n\t\t\tThemeDisplay themeDisplay =\t(ThemeDisplay)request.getAttribute(\n\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t\tportletURL.setWindowState(LiferayWindowState.POP_UP);\n\n\t\t\tportletURL.setParameter(\"struts_action\", strutsAction);\n\t\t\tportletURL.setParameter(\"groupId\", String.valueOf(groupId));\n\n\t\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\t\trequest, themeDisplay.translate(\"documents-home\"),\n\t\t\t\tportletURL.toString());\n\t\t}\n\t\telse {\n\t\t\tportletURL.setParameter(\"struts_action\", \"/document_library/view\");\n\t\t}\n\n\t\tPortletPreferences preferences =\n\t\t\tPortletPreferencesFactoryUtil.getPortletPreferences(\n\t\t\t\trequest, PortalUtil.getPortletId(request));\n\n\t\tlong defaultFolderId = GetterUtil.getLong(\n\t\t\tpreferences.getValue(\n\t\t\t\t\"rootFolderId\",\n\t\t\t\tString.valueOf(DLFolderConstants.DEFAULT_PARENT_FOLDER_ID)));\n\n\t\tList<DLFolder> ancestorFolders = Collections.EMPTY_LIST;\n\n\t\tif (folder.getFolderId() != defaultFolderId) {\n\t\t\tancestorFolders = folder.getAncestors();\n\n\t\t\tint indexOfRootFolder = -1;\n\n\t\t\tfor (int i = 0; i < ancestorFolders.size(); i++) {\n\t\t\t\tDLFolder ancestorFolder = ancestorFolders.get(i);\n\n\t\t\t\tif (defaultFolderId == ancestorFolder.getFolderId()) {\n\t\t\t\t\tindexOfRootFolder = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (indexOfRootFolder > -1) {\n\t\t\t\tancestorFolders = ancestorFolders.subList(0, indexOfRootFolder);\n\t\t\t}\n\t\t}\n\n\t\tCollections.reverse(ancestorFolders);\n\n\t\tfor (DLFolder ancestorFolder : ancestorFolders) {\n\t\t\tportletURL.setParameter(\n\t\t\t\t\"folderId\", String.valueOf(ancestorFolder.getFolderId()));\n\n\t\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\t\trequest, ancestorFolder.getName(), portletURL.toString());\n\t\t}\n\n\t\tportletURL.setParameter(\n\t\t\t\"folderId\", String.valueOf(folder.getFolderId()));\n\n\t\tif ((folder.getFolderId() !=\n\t\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID) &&\n\t\t\t(folder.getFolderId() != defaultFolderId)) {\n\n\t\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\t\trequest, folder.getName(), portletURL.toString());\n\t\t}\n\t}","commit_id":"ce366f93af8483962330b883c5e95cb9aa8ebe9a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void doIndex(StaplerRequest req, StaplerResponse rsp) throws IOException {\n        for (Ancestor a : req.getAncestors()) {\n            if (a.getObject() instanceof SearchableModelObject) {\n                SearchableModelObject smo = (SearchableModelObject) a.getObject();\n\n                SearchIndex index = smo.getSearchIndex();\n                String query = req.getParameter(\"q\");\n                SuggestedItem target = find(index, query);\n                if(target!=null) {\n                    // found\n                    rsp.sendRedirect2(a.getUrl()+target.getUrl());\n                    return;\n                }\n            }\n        }\n\n        // TODO: go to suggestion page\n        throw new UnsupportedOperationException();\n    }","id":65910,"modified_method":"public void doIndex(StaplerRequest req, StaplerResponse rsp) throws IOException {\n        List<Ancestor> l = req.getAncestors();\n        for( int i=l.size()-1; i>=0; i-- ) {\n            Ancestor a = l.get(i);\n            if (a.getObject() instanceof SearchableModelObject) {\n                SearchableModelObject smo = (SearchableModelObject) a.getObject();\n\n                SearchIndex index = smo.getSearchIndex();\n                String query = req.getParameter(\"q\");\n                SuggestedItem target = find(index, query);\n                if(target!=null) {\n                    // found\n                    rsp.sendRedirect2(a.getUrl()+target.getUrl());\n                    return;\n                }\n            }\n        }\n\n        // TODO: go to suggestion page\n        throw new UnsupportedOperationException();\n    }","commit_id":"97a21789a3dc69d6ee32646b5866c9b1cfb195f1","url":"https://github.com/kohsuke/hudson"},{"original_method":"protected abstract int getConnectionId();","id":65911,"modified_method":"protected abstract String getConnectionId();","commit_id":"dbc805e237b98834a7b7afb6da7be44da428c399","url":"https://github.com/apache/tomcat"},{"original_method":"void writeBody(Stream stream, ByteBuffer data, int len) throws IOException {\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.writeBody\", Integer.toString(connectionId),\n                    stream.getIdentifier(), Integer.toString(data.remaining())));\n        }\n        synchronized (socketWrapper) {\n            byte[] header = new byte[9];\n            ByteUtil.setThreeBytes(header, 0, len);\n            header[3] = FRAME_TYPE_DATA;\n            if (stream.getOutputBuffer().isFinished()) {\n                header[4] = FLAG_END_OF_STREAM;\n            }\n            ByteUtil.set31Bits(header, 5, stream.getIdentifier().intValue());\n            socketWrapper.write(true, header, 0, header.length);\n            socketWrapper.write(true, data.array(), data.arrayOffset() + data.position(),\n                    len);\n            socketWrapper.flush(true);\n        }\n    }","id":65912,"modified_method":"void writeBody(Stream stream, ByteBuffer data, int len) throws IOException {\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.writeBody\", connectionId, stream.getIdentifier(),\n                    Integer.toString(data.remaining())));\n        }\n        synchronized (socketWrapper) {\n            byte[] header = new byte[9];\n            ByteUtil.setThreeBytes(header, 0, len);\n            header[3] = FRAME_TYPE_DATA;\n            if (stream.getOutputBuffer().isFinished()) {\n                header[4] = FLAG_END_OF_STREAM;\n            }\n            ByteUtil.set31Bits(header, 5, stream.getIdentifier().intValue());\n            socketWrapper.write(true, header, 0, header.length);\n            socketWrapper.write(true, data.array(), data.arrayOffset() + data.position(),\n                    len);\n            socketWrapper.flush(true);\n        }\n    }","commit_id":"dbc805e237b98834a7b7afb6da7be44da428c399","url":"https://github.com/apache/tomcat"},{"original_method":"void writeHeaders(Stream stream, Response coyoteResponse) throws IOException {\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.writeHeaders\",\n                    Integer.toString(connectionId), stream.getIdentifier()));\n        }\n        MimeHeaders headers = coyoteResponse.getMimeHeaders();\n        // Add the pseudo header for status\n        headers.addValue(\":status\").setString(Integer.toString(coyoteResponse.getStatus()));\n        // This ensures the Stream processing thread has control of the socket.\n        synchronized (socketWrapper) {\n            // Frame sizes are allowed to be bigger than 4k but for headers that\n            // should be plenty\n            byte[] header = new byte[9];\n            ByteBuffer target = ByteBuffer.allocate(4 * 1024);\n            boolean first = true;\n            State state = null;\n            while (state != State.COMPLETE) {\n                state = hpackEncoder.encode(coyoteResponse.getMimeHeaders(), target);\n                target.flip();\n                ByteUtil.setThreeBytes(header, 0, target.limit());\n                if (first) {\n                    header[3] = FRAME_TYPE_HEADERS;\n                    if (stream.getOutputBuffer().hasNoBody()) {\n                        header[4] = FLAG_END_OF_STREAM;\n                    }\n                } else {\n                    header[3] = FRAME_TYPE_CONTINUATION;\n                }\n                if (state == State.COMPLETE) {\n                    header[4] += FLAG_END_OF_HEADERS;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(target.limit() + \" bytes\");\n                }\n                ByteUtil.set31Bits(header, 5, stream.getIdentifier().intValue());\n                socketWrapper.write(true, header, 0, header.length);\n                socketWrapper.write(true, target.array(), target.arrayOffset(), target.limit());\n                socketWrapper.flush(true);\n            }\n        }\n    }","id":65913,"modified_method":"void writeHeaders(Stream stream, Response coyoteResponse) throws IOException {\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.writeHeaders\", connectionId,\n                    stream.getIdentifier()));\n        }\n        MimeHeaders headers = coyoteResponse.getMimeHeaders();\n        // Add the pseudo header for status\n        headers.addValue(\":status\").setString(Integer.toString(coyoteResponse.getStatus()));\n        // This ensures the Stream processing thread has control of the socket.\n        synchronized (socketWrapper) {\n            // Frame sizes are allowed to be bigger than 4k but for headers that\n            // should be plenty\n            byte[] header = new byte[9];\n            ByteBuffer target = ByteBuffer.allocate(4 * 1024);\n            boolean first = true;\n            State state = null;\n            while (state != State.COMPLETE) {\n                state = hpackEncoder.encode(coyoteResponse.getMimeHeaders(), target);\n                target.flip();\n                ByteUtil.setThreeBytes(header, 0, target.limit());\n                if (first) {\n                    header[3] = FRAME_TYPE_HEADERS;\n                    if (stream.getOutputBuffer().hasNoBody()) {\n                        header[4] = FLAG_END_OF_STREAM;\n                    }\n                } else {\n                    header[3] = FRAME_TYPE_CONTINUATION;\n                }\n                if (state == State.COMPLETE) {\n                    header[4] += FLAG_END_OF_HEADERS;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(target.limit() + \" bytes\");\n                }\n                ByteUtil.set31Bits(header, 5, stream.getIdentifier().intValue());\n                socketWrapper.write(true, header, 0, header.length);\n                socketWrapper.write(true, target.array(), target.arrayOffset(), target.limit());\n                socketWrapper.flush(true);\n            }\n        }\n    }","commit_id":"dbc805e237b98834a7b7afb6da7be44da428c399","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public SocketState upgradeDispatch(SocketStatus status) {\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.upgradeDispatch.entry\",\n                    Long.toString(connectionId), status));\n        }\n\n        if (!initialized) {\n            // WebConnection is not used so passing null here is fine\n            init(null);\n        }\n\n        SocketState result = SocketState.CLOSED;\n\n        switch(status) {\n        case OPEN_READ:\n            if (!parser.readConnectionPreface()) {\n                close();\n                result = SocketState.CLOSED;\n                break;\n            }\n\n            // Process all the incoming data\n            try {\n                while (processFrame()) {\n                }\n            } catch (Http2Exception h2e) {\n                if (h2e.getStreamId() == 0) {\n                    // Connection error\n                    log.warn(sm.getString(\"upgradeHandler.connectionError\"), h2e);\n                    close(h2e);\n                    break;\n                } else {\n                    // Stream error\n                    // TODO Reset stream\n                }\n            } catch (IOException ioe) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"upgradeHandler.ioerror\",\n                            Long.toString(connectionId)), ioe);\n                }\n                close();\n                result = SocketState.CLOSED;\n                break;\n            }\n\n            result = SocketState.UPGRADED;\n            break;\n\n        case OPEN_WRITE:\n            try {\n                processWrites();\n            } catch (Http2Exception h2e) {\n                if (h2e.getStreamId() == 0) {\n                    // Connection error\n                    log.warn(sm.getString(\"upgradeHandler.connectionError\"), h2e);\n                    close(h2e);\n                    break;\n                } else {\n                    // Stream error\n                    // TODO Reset stream\n                }\n            } catch (IOException ioe) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"upgradeHandler.ioerror\",\n                            Long.toString(connectionId)), ioe);\n                }\n                close();\n                result = SocketState.CLOSED;\n                break;\n            }\n\n            result = SocketState.UPGRADED;\n            break;\n\n        case ASYNC_READ_ERROR:\n        case ASYNC_WRITE_ERROR:\n        case CLOSE_NOW:\n            // This should never happen and will be fatal for this connection.\n            // Add the exception to trace how this point was reached.\n            log.error(sm.getString(\"upgradeHandler.unexpectedStatus\", status),\n                    new IllegalStateException());\n            //$FALL-THROUGH$\n        case DISCONNECT:\n        case ERROR:\n        case TIMEOUT:\n        case STOP:\n            // For all of the above, including the unexpected values, close the\n            // connection.\n            close();\n            result = SocketState.CLOSED;\n            break;\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.upgradeDispatch.exit\",\n                    Long.toString(connectionId), result));\n        }\n        return result;\n    }","id":65914,"modified_method":"@Override\n    public SocketState upgradeDispatch(SocketStatus status) {\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.upgradeDispatch.entry\", connectionId, status));\n        }\n\n        if (!initialized) {\n            // WebConnection is not used so passing null here is fine\n            init(null);\n        }\n\n        SocketState result = SocketState.CLOSED;\n\n        switch(status) {\n        case OPEN_READ:\n            if (!parser.readConnectionPreface()) {\n                close();\n                result = SocketState.CLOSED;\n                break;\n            }\n\n            // Process all the incoming data\n            try {\n                while (processFrame()) {\n                }\n            } catch (Http2Exception h2e) {\n                if (h2e.getStreamId() == 0) {\n                    // Connection error\n                    log.warn(sm.getString(\"upgradeHandler.connectionError\"), h2e);\n                    close(h2e);\n                    break;\n                } else {\n                    // Stream error\n                    // TODO Reset stream\n                }\n            } catch (IOException ioe) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"upgradeHandler.ioerror\", connectionId), ioe);\n                }\n                close();\n                result = SocketState.CLOSED;\n                break;\n            }\n\n            result = SocketState.UPGRADED;\n            break;\n\n        case OPEN_WRITE:\n            try {\n                processWrites();\n            } catch (Http2Exception h2e) {\n                if (h2e.getStreamId() == 0) {\n                    // Connection error\n                    log.warn(sm.getString(\"upgradeHandler.connectionError\"), h2e);\n                    close(h2e);\n                    break;\n                } else {\n                    // Stream error\n                    // TODO Reset stream\n                }\n            } catch (IOException ioe) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"upgradeHandler.ioerror\", connectionId), ioe);\n                }\n                close();\n                result = SocketState.CLOSED;\n                break;\n            }\n\n            result = SocketState.UPGRADED;\n            break;\n\n        case ASYNC_READ_ERROR:\n        case ASYNC_WRITE_ERROR:\n        case CLOSE_NOW:\n            // This should never happen and will be fatal for this connection.\n            // Add the exception to trace how this point was reached.\n            log.error(sm.getString(\"upgradeHandler.unexpectedStatus\", status),\n                    new IllegalStateException());\n            //$FALL-THROUGH$\n        case DISCONNECT:\n        case ERROR:\n        case TIMEOUT:\n        case STOP:\n            // For all of the above, including the unexpected values, close the\n            // connection.\n            close();\n            result = SocketState.CLOSED;\n            break;\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.upgradeDispatch.exit\", connectionId, result));\n        }\n        return result;\n    }","commit_id":"dbc805e237b98834a7b7afb6da7be44da428c399","url":"https://github.com/apache/tomcat"},{"original_method":"private void processFrameData(int flags, int streamId, int payloadSize) throws IOException {\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.processFrame\",\n                    Long.toString(connectionId), Integer.toString(streamId),\n                    Integer.toString(flags), Integer.toString(payloadSize)));\n        }\n\n        // Validate the stream\n        if (streamId == 0) {\n            throw new Http2Exception(sm.getString(\"upgradeHandler.processFrameData.invalidStream\"),\n                    0, Http2Exception.PROTOCOL_ERROR);\n        }\n\n        // Process the Stream\n        // TODO Handle end of stream flag\n        int padLength = 0;\n\n        boolean endOfStream = (flags & 0x01) > 0;\n        boolean padding = (flags & 0x08) > 0;\n\n        if (padding) {\n            byte[] b = new byte[1];\n            readFully(b);\n            padLength = b[0] & 0xFF;\n        }\n\n        // TODO Flow control\n        Stream stream = getStream(streamId);\n        ByteBuffer dest = stream.getInputByteBuffer();\n        synchronized (dest) {\n            readFully(dest, payloadSize);\n            if (endOfStream) {\n                stream.setEndOfStream();\n            }\n            dest.notifyAll();\n        }\n\n        swallow(padLength);\n    }","id":65915,"modified_method":"private void processFrameData(int flags, int streamId, int payloadSize) throws IOException {\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.processFrame\", connectionId,\n                    Integer.toString(streamId), Integer.toString(flags),\n                    Integer.toString(payloadSize)));\n        }\n\n        // Validate the stream\n        if (streamId == 0) {\n            throw new Http2Exception(sm.getString(\"upgradeHandler.processFrameData.invalidStream\"),\n                    0, Http2Exception.PROTOCOL_ERROR);\n        }\n\n        // Process the Stream\n        // TODO Handle end of stream flag\n        int padLength = 0;\n\n        boolean endOfStream = (flags & 0x01) > 0;\n        boolean padding = (flags & 0x08) > 0;\n\n        if (padding) {\n            byte[] b = new byte[1];\n            readFully(b);\n            padLength = b[0] & 0xFF;\n        }\n\n        // TODO Flow control\n        Stream stream = getStream(streamId);\n        ByteBuffer dest = stream.getInputByteBuffer();\n        synchronized (dest) {\n            readFully(dest, payloadSize);\n            if (endOfStream) {\n                stream.setEndOfStream();\n            }\n            dest.notifyAll();\n        }\n\n        swallow(padLength);\n    }","commit_id":"dbc805e237b98834a7b7afb6da7be44da428c399","url":"https://github.com/apache/tomcat"},{"original_method":"private void processFrameHeaders(int flags, int streamId, int payloadSize) throws IOException {\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.processFrame\",\n                    Long.toString(connectionId), Integer.toString(streamId),\n                    Integer.toString(flags), Integer.toString(payloadSize)));\n        }\n\n        // Validate the stream\n        if (streamId == 0) {\n            throw new Http2Exception(sm.getString(\"upgradeHandler.processFrameHeaders.invalidStream\"),\n                    0, Http2Exception.PROTOCOL_ERROR);\n        }\n\n        // Process the stream\n        // TODO Handle end of headers flag\n        // TODO Handle end of stream flag\n        // TODO Handle continutation frames\n        Stream stream = getStream(streamId);\n        int padLength = 0;\n\n        boolean padding = (flags & 0x08) > 0;\n        boolean priority = (flags & 0x20) > 0;\n        int optionalLen = 0;\n        if (padding) {\n            optionalLen = 1;\n        }\n        if (priority) {\n            optionalLen += 5;\n        }\n        if (optionalLen > 0) {\n            byte[] optional = new byte[optionalLen];\n            readFully(optional);\n            int optionalPos = 0;\n            if (padding) {\n                padLength = ByteUtil.getOneByte(optional, optionalPos++);\n            }\n            if (priority) {\n                boolean exclusive = ByteUtil.isBit7Set(optional[optionalPos]);\n                int parentStreamId = ByteUtil.get31Bits(optional, optionalPos);\n                int weight = ByteUtil.getOneByte(optional, optionalPos + 4) + 1;\n                AbstractStream parentStream = getStream(parentStreamId);\n                if (parentStream == null) {\n                    parentStream = this;\n                }\n                stream.rePrioritise(parentStream, exclusive, weight);\n            }\n\n            payloadSize -= optionalLen;\n        }\n\n        hpackDecoder.setHeaderEmitter(stream);\n        while (payloadSize > 0) {\n            int toRead = Math.min(headerReadBuffer.remaining(), payloadSize);\n            // headerReadBuffer in write mode\n            readFully(headerReadBuffer, toRead);\n            // switch to read mode\n            headerReadBuffer.flip();\n            try {\n                hpackDecoder.decode(headerReadBuffer);\n            } catch (HpackException hpe) {\n                throw new Http2Exception(\n                        sm.getString(\"upgradeHandler.processFrameHeaders.decodingFailed\"),\n                        0, Http2Exception.PROTOCOL_ERROR);\n            }\n            // switches to write mode\n            headerReadBuffer.compact();\n            payloadSize -= toRead;\n        }\n        // Should be empty at this point\n        if (headerReadBuffer.position() > 0) {\n            throw new Http2Exception(\n                    sm.getString(\"upgradeHandler.processFrameHeaders.decodingDataLeft\"),\n                    0, Http2Exception.PROTOCOL_ERROR);\n        }\n\n        swallow(padLength);\n\n        // Process this stream on a container thread\n        StreamProcessor streamProcessor = new StreamProcessor(stream, adapter, socketWrapper);\n        streamProcessor.setSslSupport(sslSupport);\n        socketWrapper.getEndpoint().getExecutor().execute(streamProcessor);\n    }","id":65916,"modified_method":"private void processFrameHeaders(int flags, int streamId, int payloadSize) throws IOException {\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.processFrame\", connectionId,\n                    Integer.toString(streamId), Integer.toString(flags),\n                    Integer.toString(payloadSize)));\n        }\n\n        // Validate the stream\n        if (streamId == 0) {\n            throw new Http2Exception(sm.getString(\"upgradeHandler.processFrameHeaders.invalidStream\"),\n                    0, Http2Exception.PROTOCOL_ERROR);\n        }\n\n        // Process the stream\n        // TODO Handle end of headers flag\n        // TODO Handle end of stream flag\n        // TODO Handle continutation frames\n        Stream stream = getStream(streamId);\n        int padLength = 0;\n\n        boolean padding = (flags & 0x08) > 0;\n        boolean priority = (flags & 0x20) > 0;\n        int optionalLen = 0;\n        if (padding) {\n            optionalLen = 1;\n        }\n        if (priority) {\n            optionalLen += 5;\n        }\n        if (optionalLen > 0) {\n            byte[] optional = new byte[optionalLen];\n            readFully(optional);\n            int optionalPos = 0;\n            if (padding) {\n                padLength = ByteUtil.getOneByte(optional, optionalPos++);\n            }\n            if (priority) {\n                boolean exclusive = ByteUtil.isBit7Set(optional[optionalPos]);\n                int parentStreamId = ByteUtil.get31Bits(optional, optionalPos);\n                int weight = ByteUtil.getOneByte(optional, optionalPos + 4) + 1;\n                AbstractStream parentStream = getStream(parentStreamId);\n                if (parentStream == null) {\n                    parentStream = this;\n                }\n                stream.rePrioritise(parentStream, exclusive, weight);\n            }\n\n            payloadSize -= optionalLen;\n        }\n\n        hpackDecoder.setHeaderEmitter(stream);\n        while (payloadSize > 0) {\n            int toRead = Math.min(headerReadBuffer.remaining(), payloadSize);\n            // headerReadBuffer in write mode\n            readFully(headerReadBuffer, toRead);\n            // switch to read mode\n            headerReadBuffer.flip();\n            try {\n                hpackDecoder.decode(headerReadBuffer);\n            } catch (HpackException hpe) {\n                throw new Http2Exception(\n                        sm.getString(\"upgradeHandler.processFrameHeaders.decodingFailed\"),\n                        0, Http2Exception.PROTOCOL_ERROR);\n            }\n            // switches to write mode\n            headerReadBuffer.compact();\n            payloadSize -= toRead;\n        }\n        // Should be empty at this point\n        if (headerReadBuffer.position() > 0) {\n            throw new Http2Exception(\n                    sm.getString(\"upgradeHandler.processFrameHeaders.decodingDataLeft\"),\n                    0, Http2Exception.PROTOCOL_ERROR);\n        }\n\n        swallow(padLength);\n\n        // Process this stream on a container thread\n        StreamProcessor streamProcessor = new StreamProcessor(stream, adapter, socketWrapper);\n        streamProcessor.setSslSupport(sslSupport);\n        socketWrapper.getEndpoint().getExecutor().execute(streamProcessor);\n    }","commit_id":"dbc805e237b98834a7b7afb6da7be44da428c399","url":"https://github.com/apache/tomcat"},{"original_method":"private void processFrameWindowUpdate(int flags, int streamId, int payloadSize)\n            throws IOException {\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.processFrame\",\n                    Long.toString(connectionId), Integer.toString(streamId),\n                    Integer.toString(flags), Integer.toString(payloadSize)));\n        }\n        // Validate the frame\n        if (payloadSize != 4) {\n            // Use stream 0 since this is always a connection error\n            throw new Http2Exception(sm.getString(\"upgradeHandler.processFrameWindowUpdate.invalidPayloadSize\",\n                    Integer.toString(payloadSize)), 0, Http2Exception.FRAME_SIZE_ERROR);\n        }\n\n        byte[] payload = new byte[4];\n        readFully(payload);\n        int windowSizeIncrement = ByteUtil.get31Bits(payload, 0);\n\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.processFrameWindowUpdate.debug\",\n                    Long.toString(connectionId), Integer.toString(streamId),\n                    Integer.toString(windowSizeIncrement)));\n        }\n\n        // Validate the data\n        if (windowSizeIncrement == 0) {\n            throw new Http2Exception(\"upgradeHandler.processFrameWindowUpdate.invalidIncrement\",\n                    streamId, Http2Exception.PROTOCOL_ERROR);\n        }\n        if (streamId == 0) {\n            incrementWindowSize(windowSizeIncrement);\n        } else {\n            Stream stream = getStream(streamId);\n            if (stream == null) {\n                // Old stream already closed.\n                // Ignore\n            } else {\n                stream.incrementWindowSize(windowSizeIncrement);\n            }\n        }\n    }","id":65917,"modified_method":"private void processFrameWindowUpdate(int flags, int streamId, int payloadSize)\n            throws IOException {\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.processFrame\", connectionId,\n                    Integer.toString(streamId), Integer.toString(flags),\n                    Integer.toString(payloadSize)));\n        }\n        // Validate the frame\n        if (payloadSize != 4) {\n            // Use stream 0 since this is always a connection error\n            throw new Http2Exception(sm.getString(\"upgradeHandler.processFrameWindowUpdate.invalidPayloadSize\",\n                    Integer.toString(payloadSize)), 0, Http2Exception.FRAME_SIZE_ERROR);\n        }\n\n        byte[] payload = new byte[4];\n        readFully(payload);\n        int windowSizeIncrement = ByteUtil.get31Bits(payload, 0);\n\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.processFrameWindowUpdate.debug\", connectionId,\n                    Integer.toString(streamId), Integer.toString(windowSizeIncrement)));\n        }\n\n        // Validate the data\n        if (windowSizeIncrement == 0) {\n            throw new Http2Exception(\"upgradeHandler.processFrameWindowUpdate.invalidIncrement\",\n                    streamId, Http2Exception.PROTOCOL_ERROR);\n        }\n        if (streamId == 0) {\n            incrementWindowSize(windowSizeIncrement);\n        } else {\n            Stream stream = getStream(streamId);\n            if (stream == null) {\n                // Old stream already closed.\n                // Ignore\n            } else {\n                stream.incrementWindowSize(windowSizeIncrement);\n            }\n        }\n    }","commit_id":"dbc805e237b98834a7b7afb6da7be44da428c399","url":"https://github.com/apache/tomcat"},{"original_method":"private void processFrameSettings(int flags, int streamId, int payloadSize) throws IOException {\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.processFrame\",\n                    Long.toString(connectionId), Integer.toString(streamId),\n                    Integer.toString(flags), Integer.toString(payloadSize)));\n        }\n        // Validate the frame\n        if (streamId != 0) {\n            throw new Http2Exception(sm.getString(\"upgradeHandler.processFrameSettings.invalidStream\",\n                    Integer.toString(streamId)), 0, Http2Exception.FRAME_SIZE_ERROR);\n        }\n        if (payloadSize % 6 != 0) {\n            throw new Http2Exception(sm.getString(\"upgradeHandler.processFrameSettings.invalidPayloadSize\",\n                    Integer.toString(payloadSize)), 0, Http2Exception.FRAME_SIZE_ERROR);\n        }\n        if (payloadSize > 0 && (flags & 0x1) != 0) {\n            throw new Http2Exception(sm.getString(\"upgradeHandler.processFrameSettings.ackWithNonZeroPayload\"),\n                    0, Http2Exception.FRAME_SIZE_ERROR);\n        }\n\n        if (payloadSize == 0) {\n            // Either an ACK or an empty settings frame\n            if ((flags & 0x1) != 0) {\n                // TODO process ACK\n            }\n        } else {\n            // Process the settings\n            byte[] setting = new byte[6];\n            for (int i = 0; i < payloadSize / 6; i++) {\n                readFully(setting);\n                int id = ByteUtil.getTwoBytes(setting, 0);\n                int value = ByteUtil.getFourBytes(setting, 2);\n                remoteSettings.set(id, value);\n            }\n        }\n        if (firstFrame) {\n            firstFrame = false;\n            hpackDecoder = new HpackDecoder(remoteSettings.getHeaderTableSize());\n            hpackEncoder = new HpackEncoder(localSettings.getHeaderTableSize());\n        }\n\n        // Acknowledge the settings\n        socketWrapper.write(true, SETTINGS_ACK, 0, SETTINGS_ACK.length);\n        socketWrapper.flush(true);\n    }","id":65918,"modified_method":"private void processFrameSettings(int flags, int streamId, int payloadSize) throws IOException {\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.processFrame\", connectionId,\n                    Integer.toString(streamId), Integer.toString(flags),\n                    Integer.toString(payloadSize)));\n        }\n        // Validate the frame\n        if (streamId != 0) {\n            throw new Http2Exception(sm.getString(\"upgradeHandler.processFrameSettings.invalidStream\",\n                    Integer.toString(streamId)), 0, Http2Exception.FRAME_SIZE_ERROR);\n        }\n        if (payloadSize % 6 != 0) {\n            throw new Http2Exception(sm.getString(\"upgradeHandler.processFrameSettings.invalidPayloadSize\",\n                    Integer.toString(payloadSize)), 0, Http2Exception.FRAME_SIZE_ERROR);\n        }\n        if (payloadSize > 0 && (flags & 0x1) != 0) {\n            throw new Http2Exception(sm.getString(\"upgradeHandler.processFrameSettings.ackWithNonZeroPayload\"),\n                    0, Http2Exception.FRAME_SIZE_ERROR);\n        }\n\n        if (payloadSize == 0) {\n            // Either an ACK or an empty settings frame\n            if ((flags & 0x1) != 0) {\n                // TODO process ACK\n            }\n        } else {\n            // Process the settings\n            byte[] setting = new byte[6];\n            for (int i = 0; i < payloadSize / 6; i++) {\n                readFully(setting);\n                int id = ByteUtil.getTwoBytes(setting, 0);\n                int value = ByteUtil.getFourBytes(setting, 2);\n                remoteSettings.set(id, value);\n            }\n        }\n        if (firstFrame) {\n            firstFrame = false;\n            hpackDecoder = new HpackDecoder(remoteSettings.getHeaderTableSize());\n            hpackEncoder = new HpackEncoder(localSettings.getHeaderTableSize());\n        }\n\n        // Acknowledge the settings\n        socketWrapper.write(true, SETTINGS_ACK, 0, SETTINGS_ACK.length);\n        socketWrapper.flush(true);\n    }","commit_id":"dbc805e237b98834a7b7afb6da7be44da428c399","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public void init(WebConnection webConnection) {\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.init\", Long.toString(connectionId)));\n        }\n\n        parser = new Http2Parser(this);\n\n        initialized = true;\n        Stream stream = null;\n\n        socketWrapper.setReadTimeout(getReadTimeout());\n        socketWrapper.setWriteTimeout(getWriteTimeout());\n\n        if (webConnection != null) {\n            // HTTP/2 started via HTTP upgrade.\n            // The initial HTTP/1.1 request is available as Stream 1.\n\n            try {\n                // Acknowledge the upgrade request\n                socketWrapper.write(true, HTTP2_UPGRADE_ACK, 0, HTTP2_UPGRADE_ACK.length);\n                socketWrapper.flush(true);\n\n                // Process the initial settings frame\n                stream = getStream(1);\n                String base64Settings = stream.getCoyoteRequest().getHeader(HTTP2_SETTINGS_HEADER);\n                byte[] settings = Base64.decodeBase64(base64Settings);\n\n                if (settings.length % 6 != 0) {\n                    // Invalid payload length for settings\n                    // TODO i18n\n                    throw new ProtocolException();\n                }\n\n                for (int i = 0; i < settings.length % 6; i++) {\n                    int id = ByteUtil.getTwoBytes(settings, i * 6);\n                    int value = ByteUtil.getFourBytes(settings, (i * 6) + 2);\n                    remoteSettings.set(id, value);\n                }\n\n                firstFrame = false;\n                hpackDecoder = new HpackDecoder(remoteSettings.getHeaderTableSize());\n                hpackEncoder = new HpackEncoder(localSettings.getHeaderTableSize());\n\n                if (!parser.readConnectionPreface()) {\n                    throw new ProtocolException(sm.getString(\"upgradeHandler.invalidPreface\"));\n                }\n            } catch (IOException ioe) {\n                // TODO i18n\n                throw new ProtocolException();\n            }\n        }\n\n        // Send the initial settings frame\n        try {\n            socketWrapper.write(true, SETTINGS_EMPTY, 0, SETTINGS_EMPTY.length);\n            socketWrapper.flush(true);\n\n        } catch (IOException ioe) {\n            throw new IllegalStateException(sm.getString(\"upgradeHandler.sendPrefaceFail\"), ioe);\n        }\n\n        if (webConnection != null) {\n            // Process the initial request on a container thread\n            StreamProcessor streamProcessor = new StreamProcessor(stream, adapter, socketWrapper);\n            streamProcessor.setSslSupport(sslSupport);\n            socketWrapper.getEndpoint().getExecutor().execute(streamProcessor);\n        }\n    }","id":65919,"modified_method":"@Override\n    public void init(WebConnection webConnection) {\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.init\", connectionId));\n        }\n\n        parser = new Http2Parser(this);\n\n        initialized = true;\n        Stream stream = null;\n\n        socketWrapper.setReadTimeout(getReadTimeout());\n        socketWrapper.setWriteTimeout(getWriteTimeout());\n\n        if (webConnection != null) {\n            // HTTP/2 started via HTTP upgrade.\n            // The initial HTTP/1.1 request is available as Stream 1.\n\n            try {\n                // Acknowledge the upgrade request\n                socketWrapper.write(true, HTTP2_UPGRADE_ACK, 0, HTTP2_UPGRADE_ACK.length);\n                socketWrapper.flush(true);\n\n                // Process the initial settings frame\n                stream = getStream(1);\n                String base64Settings = stream.getCoyoteRequest().getHeader(HTTP2_SETTINGS_HEADER);\n                byte[] settings = Base64.decodeBase64(base64Settings);\n\n                if (settings.length % 6 != 0) {\n                    // Invalid payload length for settings\n                    // TODO i18n\n                    throw new ProtocolException();\n                }\n\n                for (int i = 0; i < settings.length % 6; i++) {\n                    int id = ByteUtil.getTwoBytes(settings, i * 6);\n                    int value = ByteUtil.getFourBytes(settings, (i * 6) + 2);\n                    remoteSettings.set(id, value);\n                }\n\n                firstFrame = false;\n                hpackDecoder = new HpackDecoder(remoteSettings.getHeaderTableSize());\n                hpackEncoder = new HpackEncoder(localSettings.getHeaderTableSize());\n\n                if (!parser.readConnectionPreface()) {\n                    throw new ProtocolException(sm.getString(\"upgradeHandler.invalidPreface\"));\n                }\n            } catch (IOException ioe) {\n                // TODO i18n\n                throw new ProtocolException();\n            }\n        }\n\n        // Send the initial settings frame\n        try {\n            socketWrapper.write(true, SETTINGS_EMPTY, 0, SETTINGS_EMPTY.length);\n            socketWrapper.flush(true);\n\n        } catch (IOException ioe) {\n            throw new IllegalStateException(sm.getString(\"upgradeHandler.sendPrefaceFail\"), ioe);\n        }\n\n        if (webConnection != null) {\n            // Process the initial request on a container thread\n            StreamProcessor streamProcessor = new StreamProcessor(stream, adapter, socketWrapper);\n            streamProcessor.setSslSupport(sslSupport);\n            socketWrapper.getEndpoint().getExecutor().execute(streamProcessor);\n        }\n    }","commit_id":"dbc805e237b98834a7b7afb6da7be44da428c399","url":"https://github.com/apache/tomcat"},{"original_method":"private void processFramePriority(int flags, int streamId, int payloadSize) throws IOException {\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.processFrame\",\n                    Long.toString(connectionId), Integer.toString(streamId),\n                    Integer.toString(flags), Integer.toString(payloadSize)));\n        }\n        // Validate the frame\n        if (streamId == 0) {\n            throw new Http2Exception(sm.getString(\"upgradeHandler.processFramePriority.invalidStream\"),\n                    0, Http2Exception.PROTOCOL_ERROR);\n        }\n        if (payloadSize != 5) {\n            throw new Http2Exception(sm.getString(\"upgradeHandler.processFramePriority.invalidPayloadSize\",\n                    Integer.toString(payloadSize)), streamId, Http2Exception.FRAME_SIZE_ERROR);\n        }\n\n        byte[] payload = new byte[5];\n        readFully(payload);\n\n        boolean exclusive = ByteUtil.isBit7Set(payload[0]);\n        int parentStreamId = ByteUtil.get31Bits(payload, 0);\n        int weight = ByteUtil.getOneByte(payload, 4) + 1;\n\n        Stream stream = getStream(streamId);\n        if (stream != null) {\n            // stream == null => an old stream already dropped from the map\n            AbstractStream parentStream;\n            if (parentStreamId == 0) {\n                parentStream = this;\n            } else {\n                parentStream = getStream(parentStreamId);\n                if (parentStream == null) {\n                    parentStream = this;\n                    weight = Constants.DEFAULT_WEIGHT;\n                    exclusive = false;\n                }\n            }\n            stream.rePrioritise(parentStream, exclusive, weight);\n        }\n    }","id":65920,"modified_method":"private void processFramePriority(int flags, int streamId, int payloadSize) throws IOException {\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.processFrame\", connectionId,\n                    Integer.toString(streamId), Integer.toString(flags),\n                    Integer.toString(payloadSize)));\n        }\n        // Validate the frame\n        if (streamId == 0) {\n            throw new Http2Exception(sm.getString(\"upgradeHandler.processFramePriority.invalidStream\"),\n                    0, Http2Exception.PROTOCOL_ERROR);\n        }\n        if (payloadSize != 5) {\n            throw new Http2Exception(sm.getString(\"upgradeHandler.processFramePriority.invalidPayloadSize\",\n                    Integer.toString(payloadSize)), streamId, Http2Exception.FRAME_SIZE_ERROR);\n        }\n\n        byte[] payload = new byte[5];\n        readFully(payload);\n\n        boolean exclusive = ByteUtil.isBit7Set(payload[0]);\n        int parentStreamId = ByteUtil.get31Bits(payload, 0);\n        int weight = ByteUtil.getOneByte(payload, 4) + 1;\n\n        Stream stream = getStream(streamId);\n        if (stream != null) {\n            // stream == null => an old stream already dropped from the map\n            AbstractStream parentStream;\n            if (parentStreamId == 0) {\n                parentStream = this;\n            } else {\n                parentStream = getStream(parentStreamId);\n                if (parentStream == null) {\n                    parentStream = this;\n                    weight = Constants.DEFAULT_WEIGHT;\n                    exclusive = false;\n                }\n            }\n            stream.rePrioritise(parentStream, exclusive, weight);\n        }\n    }","commit_id":"dbc805e237b98834a7b7afb6da7be44da428c399","url":"https://github.com/apache/tomcat"},{"original_method":"public Http2UpgradeHandler(Adapter adapter, Request coyoteRequest) {\n        super (STREAM_ID_ZERO);\n        this.adapter = adapter;\n        this.connectionId = connectionIdGenerator.getAndIncrement();\n\n        // Initial HTTP request becomes stream 0.\n        if (coyoteRequest != null) {\n            Integer key = Integer.valueOf(1);\n            Stream stream = new Stream(key, this, coyoteRequest);\n            streams.put(key, stream);\n            maxRemoteStreamId = 1;\n        }\n    }","id":65921,"modified_method":"public Http2UpgradeHandler(Adapter adapter, Request coyoteRequest) {\n        super (STREAM_ID_ZERO);\n        this.adapter = adapter;\n        this.connectionId = Integer.toString(connectionIdGenerator.getAndIncrement());\n\n        // Initial HTTP request becomes stream 0.\n        if (coyoteRequest != null) {\n            Integer key = Integer.valueOf(1);\n            Stream stream = new Stream(key, this, coyoteRequest);\n            streams.put(key, stream);\n            maxRemoteStreamId = 1;\n        }\n    }","commit_id":"dbc805e237b98834a7b7afb6da7be44da428c399","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    protected final int getConnectionId() {\n        return connectionId;\n    }","id":65922,"modified_method":"@Override\n    protected final String getConnectionId() {\n        return connectionId;\n    }","commit_id":"dbc805e237b98834a7b7afb6da7be44da428c399","url":"https://github.com/apache/tomcat"},{"original_method":"private void processFramePing(int flags, int streamId, int payloadSize)\n            throws IOException {\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.processFrame\",\n                    Long.toString(connectionId), Integer.toString(streamId),\n                    Integer.toString(flags), Integer.toString(payloadSize)));\n        }\n        // Validate the frame\n        if (streamId != 0) {\n            throw new Http2Exception(sm.getString(\"upgradeHandler.processFramePing.invalidStream\",\n                    Integer.toString(streamId)), 0, Http2Exception.FRAME_SIZE_ERROR);\n        }\n        if (payloadSize != 8) {\n            throw new Http2Exception(sm.getString(\"upgradeHandler.processFramePing.invalidPayloadSize\",\n                    Integer.toString(payloadSize)), 0, Http2Exception.FRAME_SIZE_ERROR);\n        }\n        if ((flags & 0x1) == 0) {\n            // Read the payload\n            byte[] payload = new byte[8];\n            readFully(payload);\n            // Echo it back\n            socketWrapper.write(true, PING_ACK, 0, PING_ACK.length);\n            socketWrapper.write(true, payload, 0, payload.length);\n            socketWrapper.flush(true);\n        } else {\n            // This is an ACK.\n            // NO-OP (until such time this implementation decides in initiate\n            // pings)\n        }\n    }","id":65923,"modified_method":"private void processFramePing(int flags, int streamId, int payloadSize)\n            throws IOException {\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.processFrame\", connectionId,\n                    Integer.toString(streamId), Integer.toString(flags),\n                    Integer.toString(payloadSize)));\n        }\n        // Validate the frame\n        if (streamId != 0) {\n            throw new Http2Exception(sm.getString(\"upgradeHandler.processFramePing.invalidStream\",\n                    Integer.toString(streamId)), 0, Http2Exception.FRAME_SIZE_ERROR);\n        }\n        if (payloadSize != 8) {\n            throw new Http2Exception(sm.getString(\"upgradeHandler.processFramePing.invalidPayloadSize\",\n                    Integer.toString(payloadSize)), 0, Http2Exception.FRAME_SIZE_ERROR);\n        }\n        if ((flags & 0x1) == 0) {\n            // Read the payload\n            byte[] payload = new byte[8];\n            readFully(payload);\n            // Echo it back\n            socketWrapper.write(true, PING_ACK, 0, PING_ACK.length);\n            socketWrapper.write(true, payload, 0, payload.length);\n            socketWrapper.flush(true);\n        } else {\n            // This is an ACK.\n            // NO-OP (until such time this implementation decides in initiate\n            // pings)\n        }\n    }","commit_id":"dbc805e237b98834a7b7afb6da7be44da428c399","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    protected final int getConnectionId() {\n        return getParentStream().getConnectionId();\n    }","id":65924,"modified_method":"@Override\n    protected final String getConnectionId() {\n        return getParentStream().getConnectionId();\n    }","commit_id":"dbc805e237b98834a7b7afb6da7be44da428c399","url":"https://github.com/apache/tomcat"},{"original_method":"void flushData() {\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"stream.write\",\n                    Long.toString(getConnectionId()), getIdentifier()));\n        }\n        try {\n            outputBuffer.flush();\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }","id":65925,"modified_method":"void flushData() {\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"stream.write\",getConnectionId(), getIdentifier()));\n        }\n        try {\n            outputBuffer.flush();\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }","commit_id":"dbc805e237b98834a7b7afb6da7be44da428c399","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public void emitHeader(String name, String value, boolean neverIndex) {\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"stream.header.debug\",\n                    Long.toString(getConnectionId()), getIdentifier(), name, value));\n        }\n\n        switch(name) {\n        case \":method\": {\n            coyoteRequest.method().setString(value);\n            break;\n        }\n        case \":path\": {\n            coyoteRequest.requestURI().setString(value);\n            // TODO: This is almost certainly wrong and needs to be decoded\n            coyoteRequest.decodedURI().setString(value);\n            break;\n        }\n        case \":authority\": {\n            int i = value.lastIndexOf(':');\n            if (i > -1) {\n                coyoteRequest.serverName().setString(value.substring(0, i));\n                coyoteRequest.setServerPort(Integer.parseInt(value.substring(i + 1)));\n            } else {\n                coyoteRequest.serverName().setString(value);\n                boolean secure = Boolean.parseBoolean(handler.getProperty(\"secure\"));\n                if (secure) {\n                    coyoteRequest.setServerPort(443);\n                } else {\n                    coyoteRequest.setServerPort(80);\n                }\n            }\n            break;\n        }\n        default: {\n            // Assume other HTTP header\n            coyoteRequest.getMimeHeaders().addValue(name).setString(value);\n        }\n        }\n    }","id":65926,"modified_method":"@Override\n    public void emitHeader(String name, String value, boolean neverIndex) {\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"stream.header.debug\",getConnectionId(), getIdentifier(),\n                    name, value));\n        }\n\n        switch(name) {\n        case \":method\": {\n            coyoteRequest.method().setString(value);\n            break;\n        }\n        case \":path\": {\n            coyoteRequest.requestURI().setString(value);\n            // TODO: This is almost certainly wrong and needs to be decoded\n            coyoteRequest.decodedURI().setString(value);\n            break;\n        }\n        case \":authority\": {\n            int i = value.lastIndexOf(':');\n            if (i > -1) {\n                coyoteRequest.serverName().setString(value.substring(0, i));\n                coyoteRequest.setServerPort(Integer.parseInt(value.substring(i + 1)));\n            } else {\n                coyoteRequest.serverName().setString(value);\n                boolean secure = Boolean.parseBoolean(handler.getProperty(\"secure\"));\n                if (secure) {\n                    coyoteRequest.setServerPort(443);\n                } else {\n                    coyoteRequest.setServerPort(80);\n                }\n            }\n            break;\n        }\n        default: {\n            // Assume other HTTP header\n            coyoteRequest.getMimeHeaders().addValue(name).setString(value);\n        }\n        }\n    }","commit_id":"dbc805e237b98834a7b7afb6da7be44da428c399","url":"https://github.com/apache/tomcat"},{"original_method":"public void rePrioritise(AbstractStream parent, boolean exclusive, int weight) {\n        if (getLog().isDebugEnabled()) {\n            getLog().debug(sm.getString(\"abstractStream.reprioritisation.debug\",\n                    Long.toString(getConnectionId()), getIdentifier(), Boolean.toString(exclusive),\n                    parent.getIdentifier(), Integer.toString(weight)));\n        }\n\n        // Check if new parent is a descendant of this stream\n        if (isDescendant(parent)) {\n            parent.detachFromParent();\n            getParentStream().addChild(parent);\n        }\n\n        if (exclusive) {\n            // Need to move children of the new parent to be children of this\n            // stream. Slightly convoluted to avoid concurrent modification.\n            Iterator<AbstractStream> parentsChildren = parent.getChildStreams().iterator();\n            while (parentsChildren.hasNext()) {\n                AbstractStream parentsChild = parentsChildren.next();\n                parentsChildren.remove();\n                this.addChild(parentsChild);\n            }\n        }\n        parent.addChild(this);\n        this.weight = weight;\n    }","id":65927,"modified_method":"public void rePrioritise(AbstractStream parent, boolean exclusive, int weight) {\n        if (getLog().isDebugEnabled()) {\n            getLog().debug(sm.getString(\"abstractStream.reprioritisation.debug\",\n                    getConnectionId(), getIdentifier(), Boolean.toString(exclusive),\n                    parent.getIdentifier(), Integer.toString(weight)));\n        }\n\n        // Check if new parent is a descendant of this stream\n        if (isDescendant(parent)) {\n            parent.detachFromParent();\n            getParentStream().addChild(parent);\n        }\n\n        if (exclusive) {\n            // Need to move children of the new parent to be children of this\n            // stream. Slightly convoluted to avoid concurrent modification.\n            Iterator<AbstractStream> parentsChildren = parent.getChildStreams().iterator();\n            while (parentsChildren.hasNext()) {\n                AbstractStream parentsChild = parentsChildren.next();\n                parentsChildren.remove();\n                this.addChild(parentsChild);\n            }\n        }\n        parent.addChild(this);\n        this.weight = weight;\n    }","commit_id":"dbc805e237b98834a7b7afb6da7be44da428c399","url":"https://github.com/apache/tomcat"},{"original_method":"protected void prepareQueryPage(D2WContext context, QueryPageInterface qpi, String entityName) {\n        EOEditingContext ec = session().defaultEditingContext();\n        EOFetchSpecification fs = fetchSpecificationFromRequest(entityName);\n        if(qpi instanceof ERD2WQueryPageWithFetchSpecification) {\n            if(fs != null)\n                ((ERD2WQueryPageWithFetchSpecification)qpi).setFetchSpecification(fs);\n        }\n    }","id":65928,"modified_method":"protected void prepareQueryPage(D2WContext context, QueryPageInterface qpi, String entityName) {\n        EOEditingContext ec = session().defaultEditingContext();\n        EOFetchSpecification fs = fetchSpecificationFromRequest(entityName);\n        if(qpi instanceof ERD2WQueryPage) {\n            if(fs != null)\n                ((ERD2WQueryPage)qpi).setFetchSpecification(fs);\n        }\n    }","commit_id":"8630bafebdd5128f62cdb4971d8c409002345dc3","url":"https://github.com/wocommunity/wonder"},{"original_method":"/** Retrieves and executes the fetch specification given in the request. */\n    public EOFetchSpecification fetchSpecificationFromRequest(String entityName) {\n    \tEOFetchSpecification fs = null;\n    \tif(context().request().formValueKeys().containsObject(fetchSpecificationKey)) {\n    \t\tString fsName = context().request().stringFormValueForKey(fetchSpecificationKey);\n    \t\tif(ERXStringUtilities.stringIsNullOrEmpty(fsName)) {\n    \t\t\tEOEntity rootEntity = ERXEOAccessUtilities.entityNamed(session().defaultEditingContext(), entityName);\n    \t\t\t\n    \t\t\tNSMutableArray qualifiers = new NSMutableArray();\n    \t\t\tfor(Enumeration e = context().request().formValueKeys().objectEnumerator(); e.hasMoreElements(); ) {\n    \t\t\t\tString key = (String)e.nextElement();\n    \t\t\t\tEOEntity entity = rootEntity;\n    \t\t\t\tEOAttribute attribute = null;\n    \t\t\t\tString attributeName = key;\n    \t\t\t\tif(key.indexOf(\".\") > 0) {\n    \t\t\t\t\tString path = ERXStringUtilities.keyPathWithoutLastProperty(key);\n    \t\t\t\t\tattributeName = ERXStringUtilities.lastPropertyKeyInKeyPath(key);\n    \t\t\t\t\tentity = ERXEOAccessUtilities.destinationEntityForKeyPath(rootEntity, path);\n    \t\t\t\t}\n    \t\t\t\tif(entity != null) {\n    \t\t\t\t\tattribute = entity.attributeNamed(attributeName);\n    \t\t\t\t\tif(attribute != null) {\n    \t\t\t\t\t\tString stringValue = context().request().stringFormValueForKey(key);\n    \t\t\t\t\t\tif(stringValue != null) {\n    \t\t\t\t\t\t\tObject value;\n    \t\t\t\t\t\t\tif(attribute.adaptorValueType() == EOAttribute.AdaptorDateType) {\n    \t\t\t\t\t\t\t\ttry {\n    \t\t\t\t\t\t\t\t\tvalue = (new NSTimestampFormatter()).parseObject(stringValue);\n    \t\t\t\t\t\t\t\t} catch (ParseException e1) {\n\t\t\t\t\t\t\t\t\t\tthrow NSForwardException._runtimeExceptionForThrowable(e1);\n\t\t\t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t} else {\n          \t\t\t\t\t\t\t value = attribute.newValueForString(stringValue);\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\tNSSelector selector = EOKeyValueQualifier.QualifierOperatorEqual;\n    \t\t\t\t\t\t\tif(stringValue.indexOf('*') >= 0) {\n    \t\t\t\t\t\t\t\tselector = EOKeyValueQualifier.QualifierOperatorCaseInsensitiveLike;\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\tqualifiers.addObject(new EOKeyValueQualifier(key, selector, value));\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tEOQualifier qualifier = null;\n    \t\t\tif(qualifiers.count() > 0) {\n    \t\t\t\tqualifier = new EOAndQualifier(qualifiers);\n    \t\t\t}\n    \t\t\tfs = new EOFetchSpecification(entityName, qualifier, null);\n    \t\t\tfs.setUsesDistinct(true);\n    \t\t} else {\n    \t\t\tfs = EOFetchSpecification.fetchSpecificationNamed(fsName, entityName);\n    \t\t\tNSMutableDictionary bindings = new NSMutableDictionary();\n    \t\t\tEnumeration e = fs.qualifier().bindingKeys().objectEnumerator();\n    \t\t\twhile(e.hasMoreElements()) {\n    \t\t\t\tString key = (String)e.nextElement();\n    \t\t\t\tString formValue = context().request().stringFormValueForKey(key);\n    \t\t\t\tif(formValue != null) {\n    \t\t\t\t\tbindings.setObjectForKey(formValue, key);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\t\n    \t\t\tif(bindings.count() > 0) {\n    \t\t\t\tfs = fs.fetchSpecificationWithQualifierBindings(bindings);\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn fs;\n    }","id":65929,"modified_method":"/** Retrieves and executes the fetch specification given in the request. */\n    public EOFetchSpecification fetchSpecificationFromRequest(String entityName) {\n    \tEOFetchSpecification fs = null;\n    \tif(context().request().formValueKeys().containsObject(fetchSpecificationKey)) {\n    \t\tString fsName = context().request().stringFormValueForKey(fetchSpecificationKey);\n    \t\tif(ERXStringUtilities.stringIsNullOrEmpty(fsName)) {\n    \t\t\tEOEntity rootEntity = ERXEOAccessUtilities.entityNamed(session().defaultEditingContext(), entityName);\n    \t\t\t\n    \t\t\tNSMutableArray qualifiers = new NSMutableArray();\n    \t\t\tfor(Enumeration e = context().request().formValueKeys().objectEnumerator(); e.hasMoreElements(); ) {\n    \t\t\t\tString key = (String)e.nextElement();\n    \t\t\t\tEOEntity entity = rootEntity;\n    \t\t\t\tEOAttribute attribute = null;\n    \t\t\t\tString attributeName = key;\n    \t\t\t\tif(key.indexOf(\".\") > 0) {\n    \t\t\t\t\tString path = ERXStringUtilities.keyPathWithoutLastProperty(key);\n    \t\t\t\t\tattributeName = ERXStringUtilities.lastPropertyKeyInKeyPath(key);\n    \t\t\t\t\tentity = ERXEOAccessUtilities.destinationEntityForKeyPath(rootEntity, path);\n    \t\t\t\t}\n    \t\t\t\tif(entity != null) {\n    \t\t\t\t\tattribute = entity.attributeNamed(attributeName);\n    \t\t\t\t\tif(attribute != null) {\n    \t\t\t\t\t\tString stringValue = context().request().stringFormValueForKey(key);\n    \t\t\t\t\t\tif(stringValue != null) {\n    \t\t\t\t\t\t\tObject value;\n    \t\t\t\t\t\t\tif(attribute.adaptorValueType() == EOAttribute.AdaptorDateType) {\n    \t\t\t\t\t\t\t\ttry {\n    \t\t\t\t\t\t\t\t\tvalue = (new NSTimestampFormatter()).parseObject(stringValue);\n    \t\t\t\t\t\t\t\t} catch (ParseException e1) {\n\t\t\t\t\t\t\t\t\t\tthrow NSForwardException._runtimeExceptionForThrowable(e1);\n\t\t\t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t} else {\n          \t\t\t\t\t\t\t value = attribute.newValueForString(stringValue);\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\tNSSelector selector = EOKeyValueQualifier.QualifierOperatorEqual;\n    \t\t\t\t\t\t\tif(stringValue.indexOf('*') >= 0) {\n    \t\t\t\t\t\t\t\tselector = EOKeyValueQualifier.QualifierOperatorCaseInsensitiveLike;\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\tqualifiers.addObject(new EOKeyValueQualifier(key, selector, value));\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tEOQualifier qualifier = null;\n    \t\t\tif(qualifiers.count() > 0) {\n    \t\t\t\tqualifier = new EOAndQualifier(qualifiers);\n    \t\t\t}\n    \t\t\tfs = new EOFetchSpecification(entityName, qualifier, null);\n    \t\t\t\n    \t\t\tboolean usesDictinct = ERXValueUtilities.booleanValueWithDefault(context().request().stringFormValueForKey(usesDistinctKey), true);\n    \t\t\tfs.setUsesDistinct(usesDictinct);\n    \t\t\t\n    \t\t\tint limit = ERXValueUtilities.intValueWithDefault(context().request().stringFormValueForKey(fetchLimitKey), 200);\n    \t\t\tfs.setFetchLimit(limit);\n    \t\t} else {\n    \t\t\tfs = EOFetchSpecification.fetchSpecificationNamed(fsName, entityName);\n    \t\t\tNSMutableDictionary bindings = new NSMutableDictionary();\n    \t\t\tEnumeration e = fs.qualifier().bindingKeys().objectEnumerator();\n    \t\t\twhile(e.hasMoreElements()) {\n    \t\t\t\tString key = (String)e.nextElement();\n    \t\t\t\tString formValue = context().request().stringFormValueForKey(key);\n    \t\t\t\tif(formValue != null) {\n    \t\t\t\t\tbindings.setObjectForKey(formValue, key);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\t\n    \t\t\tif(bindings.count() > 0) {\n    \t\t\t\tfs = fs.fetchSpecificationWithQualifierBindings(bindings);\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn fs;\n    }","commit_id":"8630bafebdd5128f62cdb4971d8c409002345dc3","url":"https://github.com/wocommunity/wonder"},{"original_method":"public EODataSource queryDataSource() {\n        if (_wasCancelled) {\n            return null;\n        }\n        EODataSource ds = dataSource();\n        if (ds == null || !(ds instanceof EODatabaseDataSource)) {\n            ds = new EODatabaseDataSource(session().defaultEditingContext(), entity().name());\n            setDataSource(ds);\n        }\n        EOFetchSpecification fs = ((EODatabaseDataSource) ds).fetchSpecification();\n        fs.setQualifier(qualifier());\n        fs.setIsDeep(isDeep());\n        fs.setUsesDistinct(usesDistinct());\n        fs.setRefreshesRefetchedObjects(refreshRefetchedObjects());\n        int limit = fetchLimit();\n        if (limit != 0)\n            fs.setFetchLimit(limit);\n        return ds;\n    }","id":65930,"modified_method":"public EODataSource queryDataSource() {\n        if (_wasCancelled) {\n            return null;\n        }\n        EODataSource ds = dataSource();\n        if (ds == null || !(ds instanceof EODatabaseDataSource)) {\n        \tds = new EODatabaseDataSource(session().defaultEditingContext(), entity().name());\n        \tsetDataSource(ds);\n        }\n        EOFetchSpecification fs = queryFetchSpecification();\n        if(fs == null) {\n        \tfs = ((EODatabaseDataSource) ds).fetchSpecification();\n        \tfs.setQualifier(qualifier());\n        \tfs.setIsDeep(isDeep());\n        \tfs.setUsesDistinct(usesDistinct());\n        \tfs.setRefreshesRefetchedObjects(refreshRefetchedObjects());\n        } else {\n        \t((EODatabaseDataSource) ds).setFetchSpecification(fs);\n        }\n        int limit = fetchLimit();\n        if (limit != 0)\n        \tfs.setFetchLimit(limit);\n        return ds;\n    }","commit_id":"8630bafebdd5128f62cdb4971d8c409002345dc3","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Useful method to refresh all of the shared enterprise objects\n     * for a given shared entity. The current implementation depends\n     * on the shared entity to have a fetch specification named 'FetchAll'\n     * which will be created for you if you check the box that says\n     * 'share all objects'.\n     * @param entityName name of the shared entity\n     */\n    // FIXME: Only works with shared objects that share all of their objects, i.e. has a FetchAll fetch spec\n    //\t\talso only works with the global model group.\n    // CHECKME: Should check that this still works under WO 5\n    // MOVEME: ERXEOFUtilities\n    public static void refreshSharedObjectsWithName(String entityName) {\n        EOEditingContext peer = ERXEC.newEditingContext();\n        peer.lock();\n        try {\n            peer.setSharedEditingContext(null);\n            EOFetchSpecification fetchAll = ERXEOAccessUtilities.entityNamed(peer, entityName).fetchSpecificationNamed(\"FetchAll\");\n            if (fetchAll != null) {\n                // Need to refault all the shared EOs first.\n            for (Enumeration e = EOUtilities.objectsForEntityNamed(peer, entityName).objectEnumerator(); e.hasMoreElements();) {\n                EOEnterpriseObject eo = (EOEnterpriseObject)e.nextElement();\n                peer.rootObjectStore().refaultObject(eo, peer.globalIDForObject(eo), peer);\n            }\n                fetchAll.setRefreshesRefetchedObjects(true);\n                peer.objectsWithFetchSpecification(fetchAll);\n            } else {\n            \t_log.warn(\"Attempting to refresh a non-shared EO: \" + entityName);\n            }\n        } finally {\n            peer.unlock();\n        }\n    }","id":65931,"modified_method":"/**\n     * Refreshes all of the shared enterprise objects for a given shared entity,\n     * then notifies the entity's class by calling the static method\n     * sharedEntityDataWasRefreshed() if it implements it.\n     *\n     * @param entityName name of the shared entity\n     */\n    // FIXME: Uses default model group, and default shared editing context.\n    // MOVEME: ERXEOFUtilities\n    public static void refreshSharedObjectsWithName(String entityName) {\n        if (entityName == null) {\n            throw new IllegalStateException(\"Entity name argument is null for method: refreshSharedObjectsWithName\");\n        }\n        EOSharedEditingContext sharedEC = EOSharedEditingContext.defaultSharedEditingContext();\n        sharedEC.lock();\n        try {\n            EOEntity entity = ERXEOAccessUtilities.entityNamed(sharedEC, entityName);\n            NSArray fetchSpecNames = entity.sharedObjectFetchSpecificationNames();\n            int count =  (fetchSpecNames != null) ? fetchSpecNames.count() : 0;\n\n            if ( count > 0 ) { //same check as ERXEOAccessUtilities.entityWithNamedIsShared(), but avoids duplicate work\n                for (int index = 0 ; index < count ; ++index) {\n                    String oneFetchSpecName = (String)fetchSpecNames.objectAtIndex(index);\n                    EOFetchSpecification fs = entity.fetchSpecificationNamed(oneFetchSpecName);\n                    if (fs != null) {\n                        fs.setRefreshesRefetchedObjects(true);\n                        sharedEC.bindObjectsWithFetchSpecification(fs, oneFetchSpecName);\n                    }\n                }\n\n                //notify the entity class, if it wants to know\n                String className = entity.className();\n                Class entityClass = Class.forName(className);\n\n                if (_sharedEntityDataWasRefreshedSelector.implementedByClass(entityClass)) {\n                    _sharedEntityDataWasRefreshedSelector.invoke(entityClass);\n            }\n            } else {\n                _log.warn(\"Attempting to refresh a non-shared EO: \" + entityName);\n            }\n        } catch (Exception e) {\n            throw new NSForwardException(e, \"Exception while refreshing shared objects for entity named \" + entityName);\n        } finally {\n            sharedEC.unlock();\n        }\n    }","commit_id":"914644376ad152b4cc2978d73f44fdd2687e0528","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Fetches an array of objects defined by the globalIDs in a single fetch per entity.\n     * \n     * @param ec the editing context to fetch within\n     * @param globalIDs the global ids to fetch\n     * @param refreshesRefetchedObjects whether or not to refresh refetched objects\n     * @return the fetched EO's\n     */\n    public static NSMutableArray fetchObjectsWithGlobalIDs(EOEditingContext ec, NSArray globalIDs, boolean refreshesRefetchedObjects) {\n    \tNSMutableArray result = new NSMutableArray();\n\t\tec.lock();\n\t\ttry {\n\t    \tNSDictionary gidsByEntity = globalIDsGroupedByEntityName(globalIDs);\n\t    \tfor(Enumeration e = gidsByEntity.keyEnumerator(); e.hasMoreElements();) {\n\t    \t\tString entityName = (String) e.nextElement();\n\t    \t\tNSArray gidsForEntity = (NSArray) gidsByEntity.objectForKey(entityName);\n\t    \t\t\n\t    \t\tNSMutableArray qualifiers = new NSMutableArray();\n\t        \tEOEntity entity = ERXEOAccessUtilities.entityNamed(ec, entityName);\n\t    \t\tfor (Enumeration gids = gidsForEntity.objectEnumerator(); gids.hasMoreElements();) {\n\t    \t\t\tEOGlobalID g = (EOGlobalID) gids.nextElement();\n\t    \t\t\tboolean fetch = refreshesRefetchedObjects;\n\t    \t\t\tif (!fetch) {\n\t    \t\t\t\tEOEnterpriseObject eo;\n\t\t\t\t\t\teo = ec.objectForGlobalID(g);\n\t    \t\t\t\tif (eo != null && !EOFaultHandler.isFault(eo)) {\n\t    \t\t\t\t\tresult.addObject(eo);\n\t    \t\t\t\t}\n\t    \t\t\t\telse {\n\t    \t\t\t\t\tfetch = true;\n\t    \t\t\t\t}\n\t    \t\t\t}\n\t    \t\t\tif (fetch) {\n\t    \t\t\t\tEOQualifier qualifier = entity.qualifierForPrimaryKey(entity.primaryKeyForGlobalID(g));\n\t    \t\t\t\tqualifiers.addObject(qualifier);\n\t    \t\t\t}\n\t    \t\t}\n\t    \t\tEOQualifier qualifier = new EOOrQualifier(qualifiers);\n\t    \t\tEOFetchSpecification fetchSpec = new EOFetchSpecification(entityName, qualifier, null);\n\t    \t\tfetchSpec.setRefreshesRefetchedObjects(refreshesRefetchedObjects);\n\t    \t\tNSArray details = ec.objectsWithFetchSpecification(fetchSpec);\n\t    \t\tresult.addObjectsFromArray(details);\n\t    \t}\n\t\t}\n\t\tfinally {\n\t\t\tec.unlock();\n\t\t}\n    \treturn result;\n    }","id":65932,"modified_method":"/**\n     * Fetches an array of objects defined by the globalIDs in a single fetch per entity.\n     * \n     * @param ec the editing context to fetch within\n     * @param globalIDs the global ids to fetch\n     * @param refreshesRefetchedObjects whether or not to refresh refetched objects\n     * @return the fetched EO's\n     */\n    public static NSMutableArray fetchObjectsWithGlobalIDs(EOEditingContext ec, NSArray globalIDs, boolean refreshesRefetchedObjects) {\n    \tNSMutableArray result = new NSMutableArray();\n\t\tec.lock();\n\t\ttry {\n\t    \tNSDictionary gidsByEntity = globalIDsGroupedByEntityName(globalIDs);\n\t    \tfor(Enumeration e = gidsByEntity.keyEnumerator(); e.hasMoreElements();) {\n\t    \t\tString entityName = (String) e.nextElement();\n\t    \t\tNSArray gidsForEntity = (NSArray) gidsByEntity.objectForKey(entityName);\n\t    \t\t\n\t    \t\tNSMutableArray qualifiers = new NSMutableArray();\n\t        \tEOEntity entity = ERXEOAccessUtilities.entityNamed(ec, entityName);\n\t    \t\tfor (Enumeration gids = gidsForEntity.objectEnumerator(); gids.hasMoreElements();) {\n\t    \t\t\tEOGlobalID g = (EOGlobalID) gids.nextElement();\n\t    \t\t\tboolean fetch = refreshesRefetchedObjects;\n\t    \t\t\tif (!fetch) {\n\t    \t\t\t\tEOEnterpriseObject eo;\n\t\t\t\t\t\teo = ec.objectForGlobalID(g);\n\t    \t\t\t\tif (eo != null && !EOFaultHandler.isFault(eo)) {\n\t    \t\t\t\t\tresult.addObject(eo);\n\t    \t\t\t\t}\n\t    \t\t\t\telse {\n\t    \t\t\t\t\tfetch = true;\n\t    \t\t\t\t}\n\t    \t\t\t}\n\t    \t\t\tif (fetch) {\n\t    \t\t\t\tEOQualifier qualifier = entity.qualifierForPrimaryKey(entity.primaryKeyForGlobalID(g));\n\t    \t\t\t\tqualifiers.addObject(qualifier);\n\t    \t\t\t}\n\t    \t\t}\n\t    \t\tif (qualifiers.count() > 0) {\n\t\t    \t\tEOQualifier qualifier = new EOOrQualifier(qualifiers);\n\t\t    \t\tEOFetchSpecification fetchSpec = new EOFetchSpecification(entityName, qualifier, null);\n\t\t    \t\tfetchSpec.setRefreshesRefetchedObjects(refreshesRefetchedObjects);\n\t\t    \t\tNSArray details = ec.objectsWithFetchSpecification(fetchSpec);\n\t\t    \t\tresult.addObjectsFromArray(details);\n\t    \t\t}\n\t    \t}\n\t\t}\n\t\tfinally {\n\t\t\tec.unlock();\n\t\t}\n    \treturn result;\n    }","commit_id":"87429c55befe6a8c8daac887b6fb7ea7168dc379","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected void setUp() throws Exception {\n        setStartEventd(false);\n        super.setUp();\n        m_peer = new SnmpPeer(InetAddress.getLocalHost());\n        m_signaler = new BarrierSignaler(1);\n        m_objList = new ArrayList();\n    }","id":65933,"modified_method":"protected void setUp() throws Exception {\n        setStartEventd(false);\n        super.setUp();\n        m_peer = new SnmpPeer(InetAddress.getLocalHost());\n        m_signaler = new BarrierSignaler(1);\n        m_objList = new ArrayList();\n        m_mibObjectMap = new TreeMap();\n        \n        for (int i = 0; i < initalMibObjects.length; i++) {\n            String[] mibData = initalMibObjects[i];\n            defineMibObject(mibData[0], mibData[1], mibData[2], mibData[3]);\n            \n        }\n    }","commit_id":"86694122e1c3502ef276d04a273157a688757426","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected MibObject createMibObject(String alias, String oid, String instance, String type) {\n        MibObject sysName = new MibObject();\n        sysName.setAlias(alias);\n        sysName.setOid(oid);\n        sysName.setType(type);\n        sysName.setInstance(instance);\n        return sysName;\n    }","id":65934,"modified_method":"protected MibObject createMibObject(String alias, String oid, String instance, String type) {\n        MibObject mibObj = new MibObject();\n        mibObj.setAlias(alias);\n        mibObj.setOid(oid);\n        mibObj.setType(type);\n        mibObj.setInstance(instance);\n        return mibObj;\n    }","commit_id":"86694122e1c3502ef276d04a273157a688757426","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testManyIfsV2() throws Exception {\n        m_peer.getParameters().setVersion(SnmpSMI.SNMPV2);\n        populateObjList();\n        \n        addIfInfo(createIfInfo(1, 24, \"lo0\", \"P\"));\n        addIfInfo(createIfInfo(2, 55, \"gif0\", \"S\"));\n        addIfInfo(createIfInfo(3, 57, \"stf0\", \"C\"));\n        \n        SnmpIfCollector collector = new SnmpIfCollector(getSession(), m_signaler, \"1\", m_ifMap, m_ifMap.size(), 50);\n        waitForSignal();\n        \n        assertInterfaceMibObjectsPresent(collector.getEntries());\n    }","id":65935,"modified_method":"public void testManyIfsV2() throws Exception {\n        m_peer.getParameters().setVersion(SnmpSMI.SNMPV2);\n        addIfTable();\n        \n        addIfInfo(createIfInfo(1, 24, \"lo0\", \"P\"));\n        addIfInfo(createIfInfo(2, 55, \"gif0\", \"S\"));\n        addIfInfo(createIfInfo(3, 57, \"stf0\", \"C\"));\n        \n        SnmpIfCollector collector = new SnmpIfCollector(getSession(), m_signaler, \"1\", m_ifMap, m_ifMap.size(), 50);\n        waitForSignal();\n        \n        assertInterfaceMibObjectsPresent(collector.getEntries());\n    }","commit_id":"86694122e1c3502ef276d04a273157a688757426","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testInvalidVar() throws Exception {\n        IfInfo ifInfo = new IfInfo(1, 24, \"lo\", \"P\");\n        \n        // TODO test for a list with only one bad var.. other vars should be collected\n        m_objList.add(createMibObject(\"ifInOctets\", \"1.3.6.1.2.1.2.2.2.10\", \"ifIndex\", \"counter\"));\n        \n        ifInfo.setOidList(new ArrayList(m_objList));\n        \n        addIfInfo(ifInfo);\n        \n        SnmpIfCollector collector = new SnmpIfCollector(getSession(), m_signaler, \"1\", m_ifMap, m_ifMap.size(), 50);\n        waitForSignal();\n        \n        // remove the failing element.  Now entries should match\n        m_objList.remove(0);\n        assertInterfaceMibObjectsPresent(collector.getEntries());\n        \n    }","id":65936,"modified_method":"public void testInvalidVar() throws Exception {\n        IfInfo ifInfo = new IfInfo(1, 24, \"lo\", \"P\");\n        \n        addMibObject(\"ifInOctets\", \"1.3.6.1.2.1.2.2.2.10\", \"ifIndex\", \"counter\");\n        \n        ifInfo.setOidList(new ArrayList(m_objList));\n        \n        addIfInfo(ifInfo);\n        \n        SnmpIfCollector collector = new SnmpIfCollector(getSession(), m_signaler, \"1\", m_ifMap, m_ifMap.size(), 50);\n        waitForSignal();\n        \n        // remove the failing element.  Now entries should match\n        m_objList.remove(0);\n        assertInterfaceMibObjectsPresent(collector.getEntries());\n        \n    }","commit_id":"86694122e1c3502ef276d04a273157a688757426","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testManyIfs() throws Exception {\n        populateObjList();\n        \n        addIfInfo(createIfInfo(1, 24, \"lo0\", \"P\"));\n        addIfInfo(createIfInfo(2, 55, \"gif0\", \"S\"));\n        addIfInfo(createIfInfo(3, 57, \"stf0\", \"C\"));\n        \n        SnmpIfCollector collector = new SnmpIfCollector(getSession(), m_signaler, \"1\", m_ifMap, m_ifMap.size(), 50);\n        waitForSignal();\n        \n        assertInterfaceMibObjectsPresent(collector.getEntries());\n    }","id":65937,"modified_method":"public void testManyIfs() throws Exception {\n        addIfTable();\n        \n        addIfInfo(createIfInfo(1, 24, \"lo0\", \"P\"));\n        addIfInfo(createIfInfo(2, 55, \"gif0\", \"S\"));\n        addIfInfo(createIfInfo(3, 57, \"stf0\", \"C\"));\n        \n        SnmpIfCollector collector = new SnmpIfCollector(getSession(), m_signaler, \"1\", m_ifMap, m_ifMap.size(), 50);\n        waitForSignal();\n        \n        assertInterfaceMibObjectsPresent(collector.getEntries());\n    }","commit_id":"86694122e1c3502ef276d04a273157a688757426","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testManyVars() throws Exception {\n        populateObjList();\n        \n        addIfInfo(createIfInfo(1, 24, \"lo\", \"P\"));\n        \n        SnmpIfCollector collector = new SnmpIfCollector(getSession(), m_signaler, \"1\", m_ifMap, m_ifMap.size(), 50);\n        waitForSignal();\n        \n        assertInterfaceMibObjectsPresent(collector.getEntries());\n        \n    }","id":65938,"modified_method":"public void testManyVars() throws Exception {\n        addIfTable();\n        \n        addIfInfo(createIfInfo(1, 24, \"lo\", \"P\"));\n        \n        SnmpIfCollector collector = new SnmpIfCollector(getSession(), m_signaler, \"1\", m_ifMap, m_ifMap.size(), 50);\n        waitForSignal();\n        \n        assertInterfaceMibObjectsPresent(collector.getEntries());\n        \n    }","commit_id":"86694122e1c3502ef276d04a273157a688757426","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testRottenApple() throws Exception {\n        IfInfo ifInfo = new IfInfo(1, 24, \"lo\", \"P\");\n        \n        m_objList.add(createMibObject(\"ifSpeed\", \"1.3.6.1.2.1.2.2.1.5\", \"ifIndex\", \"gauge\"));\n        m_objList.add(createMibObject(\"ifInOctets\", \"1.3.6.1.2.1.2.2.1.10\", \"ifIndex\", \"counter\"));\n        // the oid below is wrong.  Make sure we collect the others anyway\n        m_objList.add(createMibObject(\"ifOutOctets\", \"1.3.6.1.2.1.2.2.2.16\", \"ifIndex\", \"counter\"));\n        m_objList.add(createMibObject(\"ifInErrors\", \"1.3.6.1.2.1.2.2.1.14\", \"ifIndex\", \"counter\"));\n        m_objList.add(createMibObject(\"ifOutErrors\", \"1.3.6.1.2.1.2.2.1.20\", \"ifIndex\", \"counter\"));\n        m_objList.add(createMibObject(\"ifInDiscards\", \"1.3.6.1.2.1.2.2.1.13\", \"ifIndex\", \"counter\"));\n        \n        ifInfo.setOidList(new ArrayList(m_objList));\n        \n        addIfInfo(ifInfo);\n        \n        SnmpIfCollector collector = new SnmpIfCollector(getSession(), m_signaler, \"1\", m_ifMap, m_ifMap.size(), 50);\n        waitForSignal();\n        \n        // remove the bad apple before compare\n        m_objList.remove(2);\n        assertInterfaceMibObjectsPresent(collector.getEntries());\n        \n    }","id":65939,"modified_method":"public void testBadApple() throws Exception {\n        IfInfo ifInfo = new IfInfo(1, 24, \"lo\", \"P\");\n        \n        addIfSpeed();\n        addIfInOctets();\n        // the oid below is wrong.  Make sure we collect the others anyway\n        addMibObject(\"ifOutOctets\", \"1.3.6.1.2.1.2.2.2.16\", \"ifIndex\", \"counter\");\n        addIfInErrors();\n        addIfOutErrors();\n        addIfInDiscards();\n        \n        ifInfo.setOidList(new ArrayList(m_objList));\n        \n        addIfInfo(ifInfo);\n        \n        SnmpIfCollector collector = new SnmpIfCollector(getSession(), m_signaler, \"1\", m_ifMap, m_ifMap.size(), 50);\n        waitForSignal();\n        \n        // remove the bad apple before compare\n        m_objList.remove(2);\n        assertInterfaceMibObjectsPresent(collector.getEntries());\n        \n    }","commit_id":"86694122e1c3502ef276d04a273157a688757426","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void testManyVars(int version, int maxVarsPerPdu) throws Exception, InterruptedException {\n        m_peer.getParameters().setVersion(version);\n        m_objList.add(createMibObject(\"sysDescr\",    \"1.3.6.1.2.1.1.1\", \"0\", \"string\"));\n        m_objList.add(createMibObject(\"sysOid\",      \"1.3.6.1.2.1.1.2\", \"0\", \"objectid\"));\n        m_objList.add(createMibObject(\"sysUptime\",   \"1.3.6.1.2.1.1.3\", \"0\", \"timeTicks\"));\n        m_objList.add(createMibObject(\"sysContact\",  \"1.3.6.1.2.1.1.4\", \"0\", \"string\"));\n        m_objList.add(createMibObject(\"sysName\",     \"1.3.6.1.2.1.1.5\", \"0\", \"string\"));\n        m_objList.add(createMibObject(\"sysLocation\", \"1.3.6.1.2.1.1.6\", \"0\", \"string\"));\n        m_objList.add(createMibObject(\"ifNumber\",    \"1.3.6.1.2.1.2.1\", \"0\", \"integer\"));\n        SnmpNodeCollector collector = createNodeCollector(maxVarsPerPdu);\n        assertMibObjectsPresent(collector.getEntry(), m_objList);\n    }","id":65940,"modified_method":"private void testManyVars(int version, int maxVarsPerPdu) throws Exception, InterruptedException {\n        m_peer.getParameters().setVersion(version);\n        addSystemGroup();\n        addIfNumber();\n        SnmpNodeCollector collector = createNodeCollector(maxVarsPerPdu);\n        assertMibObjectsPresent(collector.getEntry(), m_objList);\n    }","commit_id":"86694122e1c3502ef276d04a273157a688757426","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testInvalidInst() throws Exception {\n        m_objList.add(createMibObject(\"sysUptime\", \"1.3.6.1.2.1.1.3\", \"1\", \"timeTicks\"));\n        SnmpNodeCollector collector = createNodeCollector(50);\n        assertTrue(collector.getEntry().isEmpty());\n    }","id":65941,"modified_method":"public void testInvalidInst() throws Exception {\n        addMibObject(\"sysUptime\", \".1.3.6.1.2.1.1.3\", \"1\", \"timeTicks\");\n        SnmpNodeCollector collector = createNodeCollector(50);\n        assertTrue(collector.getEntry().isEmpty());\n    }","commit_id":"86694122e1c3502ef276d04a273157a688757426","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testOneVar() throws Exception {\n        m_objList.add(createMibObject(\"sysName\", \"1.3.6.1.2.1.1.5\", \"0\", \"string\"));\n        SnmpNodeCollector collector = createNodeCollector(50);\n        assertMibObjectsPresent(collector.getEntry(), m_objList);\n    }","id":65942,"modified_method":"public void testOneVar() throws Exception {\n        addSysName();\n        SnmpNodeCollector collector = createNodeCollector(50);\n        assertMibObjectsPresent(collector.getEntry(), m_objList);\n    }","commit_id":"86694122e1c3502ef276d04a273157a688757426","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testInvalidVar() throws Exception {\n        m_objList.add(createMibObject(\"sysName\", \"1.3.6.1.2.1.2\", \"0\", \"string\"));\n        SnmpNodeCollector collector = createNodeCollector(50);\n        assertTrue(collector.getEntry().isEmpty());\n    }","id":65943,"modified_method":"public void testInvalidVar() throws Exception {\n        addMibObject(\"sysName\", \".1.3.6.1.2.1.2\", \"0\", \"string\");\n        SnmpNodeCollector collector = createNodeCollector(50);\n        assertTrue(collector.getEntry().isEmpty());\n    }","commit_id":"86694122e1c3502ef276d04a273157a688757426","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player player = game.getPlayer(source.getFirstTarget());\n        if (player != null) {\n            player.revealCards(\"Thoughtseize\", player.getHand(), game);\n            Player you = game.getPlayer(source.getControllerId());\n            if (you != null) {\n                TargetCard target = new TargetCard(Zone.HAND, filter);\n                if (you.chooseTarget(outcome, player.getHand(), target, source, game)) {\n                    Card card = player.getHand().get(target.getFirstTarget(), game);\n                    if (card != null) {\n                        return player.discard(card, source, game);\n                    }\n                }\n            }\n        }\n        return false;\n    }","id":65944,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player player = game.getPlayer(source.getFirstTarget());\n        if (player != null) {\n            player.revealCards(\"Thoughtseize\", player.getHand(), game);\n            Player you = game.getPlayer(source.getControllerId());\n            if (you != null) {\n                TargetCard target = new TargetCard(Zone.HAND, filter);\n                target.setRequired(true);\n                if (target.canChoose(source.getControllerId(), game) && you.chooseTarget(outcome, player.getHand(), target, source, game)) {\n                    Card card = player.getHand().get(target.getFirstTarget(), game);\n                    if (card != null) {\n                        return player.discard(card, source, game);\n                    }\n                }\n            }\n        }\n        return false;\n    }","commit_id":"902111e012f1234a1ca2c13e884a396c63947a9e","url":"https://github.com/magefree/mage"},{"original_method":"public Thoughtseize(UUID ownerId) {\n        super(ownerId, 145, \"Thoughtseize\", Rarity.RARE, new CardType[]{CardType.SORCERY}, \"{B}\");\n        this.expansionSetCode = \"LRW\";\n\n        this.color.setBlack(true);\n\n        // Target player reveals his or her hand. You choose a nonland card from it. That player discards that card. You lose 2 life.\n        this.getSpellAbility().addTarget(new TargetPlayer());\n        this.getSpellAbility().addEffect(new ThoughtseizeEffect());\n        this.getSpellAbility().addEffect(new LoseLifeSourceEffect(2));\n    }","id":65945,"modified_method":"public Thoughtseize(UUID ownerId) {\n        super(ownerId, 145, \"Thoughtseize\", Rarity.RARE, new CardType[]{CardType.SORCERY}, \"{B}\");\n        this.expansionSetCode = \"LRW\";\n\n        this.color.setBlack(true);\n\n        // Target player reveals his or her hand. You choose a nonland card from it. That player discards that card. You lose 2 life.\n        this.getSpellAbility().addTarget(new TargetPlayer(true));\n        this.getSpellAbility().addEffect(new ThoughtseizeEffect());\n        this.getSpellAbility().addEffect(new LoseLifeSourceEffect(2));\n    }","commit_id":"902111e012f1234a1ca2c13e884a396c63947a9e","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player player = game.getPlayer(source.getControllerId());\r\n        if (player == null) {\r\n            return false;\r\n        }\r\n\r\n        Cards cards = new CardsImpl();\r\n        int count = Math.min(player.getLibrary().size(), 3);\r\n        for (int i = 0; i < count; i++) {\r\n            Card card = player.getLibrary().removeFromTop(game);\r\n            if (card != null) {\r\n                cards.add(card);\r\n                if (card.getCardType().contains(CardType.CREATURE)) {\r\n                    card.moveToZone(Zone.HAND, source.getId(), game, false);\r\n                } else {\r\n                    card.moveToZone(Zone.GRAVEYARD, source.getId(), game, false);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!cards.isEmpty()) {\r\n            player.revealCards(\"Beast Hunt\", cards, game);\r\n        }\r\n\r\n        return true;\r\n    }","id":65946,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        MageObject sourceObject = game.getObject(source.getSourceId());\r\n        if (controller == null || sourceObject ==  null) {\r\n            return false;\r\n        }\r\n\r\n        Cards cards = new CardsImpl();\r\n        int count = Math.min(controller.getLibrary().size(), 3);\r\n        for (int i = 0; i < count; i++) {\r\n            Card card = controller.getLibrary().removeFromTop(game);\r\n            if (card != null) {\r\n                cards.add(card);\r\n                if (card.getCardType().contains(CardType.CREATURE)) {\r\n                    controller.moveCardToHandWithInfo(card, source.getSourceId(), game, Zone.LIBRARY);\r\n                } else {\r\n                    controller.moveCardToGraveyardWithInfo(card, source.getSourceId(), game, Zone.LIBRARY);\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (!cards.isEmpty()) {\r\n            controller.revealCards(sourceObject.getLogName(), cards, game);\r\n        }\r\n\r\n        return true;\r\n    }","commit_id":"ae4c07da9d3766ce907110cf15b2c2ad43ec40c2","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        boolean applied = false;\r\n        Player you = game.getPlayer(source.getControllerId());\r\n        if (you != null) {\r\n            TargetCardInLibrary target = new TargetCardInLibrary(filter);\r\n            you.searchLibrary(target, game);\r\n            Card targetCard = game.getCard(target.getFirstTarget());\r\n            if (targetCard != null) {\r\n                applied = targetCard.putOntoBattlefield(game, Zone.LIBRARY, source.getSourceId(), you.getId());\r\n            }\r\n            you.shuffleLibrary(game);\r\n        }\r\n        return applied;\r\n    }","id":65947,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        boolean applied = false;\r\n        Player you = game.getPlayer(source.getControllerId());\r\n        if (you != null) {\r\n            TargetCardInLibrary target = new TargetCardInLibrary(filter);\r\n            you.searchLibrary(target, game);\r\n            Card targetCard = game.getCard(target.getFirstTarget());\r\n            if (targetCard == null) {\r\n                applied = false;\r\n            } else{\r\n                applied = you.putOntoBattlefieldWithInfo(targetCard, game, Zone.LIBRARY, source.getSourceId());\r\n                you.shuffleLibrary(game);\r\n            }\r\n        }\r\n        return applied;\r\n    }","commit_id":"ae4c07da9d3766ce907110cf15b2c2ad43ec40c2","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean replaceEvent(GameEvent event, Ability source, Game game) {\r\n        \r\n        Player player = game.getPlayer(source.getControllerId());\r\n        TargetCardInHand target = new TargetCardInHand(new FilterLandCard());\r\n        if (player != null){\r\n            if(player.chooseTarget(Outcome.Discard, target, source, game)){\r\n                player.discard(game.getCard(target.getFirstTarget()), source, game);\r\n                return false;\r\n            }\r\n            else{\r\n                Card card = game.getCard(event.getTargetId());\r\n                if (card != null) {\r\n                    card.moveToZone(Zone.GRAVEYARD, source.getSourceId(), game, false);\r\n                }\r\n                return true;\r\n            }\r\n            \r\n        }\r\n        return false;\r\n    }","id":65948,"modified_method":"@Override\r\n    public boolean replaceEvent(GameEvent event, Ability source, Game game) {        \r\n        Player player = game.getPlayer(source.getControllerId());        \r\n        if (player != null){\r\n            TargetCardInHand target = new TargetCardInHand(new FilterLandCard());\r\n            Cost cost = new DiscardTargetCost(target);\r\n            if (cost.canPay(source.getSourceId(), source.getControllerId(), game) &&\r\n                    player.chooseUse(outcome, \"Discard land? (Otherwise Mox Diamond goes to graveyard)\", game) &&\r\n                    player.chooseTarget(Outcome.Discard, target, source, game)){\r\n                player.discard(game.getCard(target.getFirstTarget()), source, game);\r\n                return false;\r\n            }\r\n            else{\r\n                Card card = game.getCard(event.getTargetId());\r\n                if (card != null) {\r\n                    player.moveCardToGraveyardWithInfo(card, source.getSourceId(), game, null);\r\n                }\r\n                return true;\r\n            }\r\n            \r\n        }\r\n        return false;\r\n    }","commit_id":"ae4c07da9d3766ce907110cf15b2c2ad43ec40c2","url":"https://github.com/magefree/mage"},{"original_method":"public MoxDiamondReplacementEffect() {\r\n        super(Duration.WhileOnBattlefield, Outcome.Exile);\r\n        staticText = \"If Mox Diamond would enter the battlefield, you may discard a land card instead. If you do, put Mox Diamond onto the battlefield. If you don't, put it into its owner's graveyard\";\r\n    }","id":65949,"modified_method":"public MoxDiamondReplacementEffect() {\r\n        super(Duration.WhileOnBattlefield, Outcome.Exile);\r\n        staticText = \"If {this} would enter the battlefield, you may discard a land card instead. If you do, put {this} onto the battlefield. If you don't, put it into its owner's graveyard\";\r\n    }","commit_id":"ae4c07da9d3766ce907110cf15b2c2ad43ec40c2","url":"https://github.com/magefree/mage"},{"original_method":"public Opt(UUID ownerId) {\n        super(ownerId, 64, \"Opt\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{U}\");\n        this.expansionSetCode = \"INV\";\n\n        this.color.setBlue(true);\n\n        // Look at the top card of your library. You may put that card on the bottom of your library.\n        // This is functionally the same as scry, copy scry effect, removing \"scry\", unless theres a simpler way im overlooking?\n        this.getSpellAbility().addEffect(new OptEffect());\n        // Draw a card.\n        this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));\n    }","id":65950,"modified_method":"public Opt(UUID ownerId) {\n        super(ownerId, 64, \"Opt\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{U}\");\n        this.expansionSetCode = \"INV\";\n\n        this.color.setBlue(true);\n\n        // Look at the top card of your library. You may put that card on the bottom of your library.\n        // This is functionally the same as scry, copy scry effect, removing \"scry\", unless theres a simpler way im overlooking?\n        this.getSpellAbility().addEffect(new LookLibraryMayPutToBottomEffect());\n        // Draw a card.\n        this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));\n    }","commit_id":"ae4c07da9d3766ce907110cf15b2c2ad43ec40c2","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n        public boolean apply(Game game, Ability source) {\r\n            Player player = game.getPlayer(source.getControllerId());\r\n            if (player != null && player.getLibrary().size() > 0) {\r\n                CardsImpl cards = new CardsImpl();\r\n                Card card = player.getLibrary().removeFromTop(game);\r\n                if (card != null) {\r\n                    cards.add(card);\r\n                    player.revealCards(\"Skyward Eye Prophets\", cards, game);\r\n                    if (card.getCardType().contains(CardType.LAND)) {\r\n                        card.putOntoBattlefield(game, Zone.HAND, source.getId(), source.getControllerId());\r\n                    } else {\r\n                        card.moveToZone(Zone.HAND, source.getId(), game, true);\r\n                    }\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }","id":65951,"modified_method":"@Override\r\n        public boolean apply(Game game, Ability source) {\r\n            Player controller = game.getPlayer(source.getControllerId());\r\n            MageObject sourceObject = game.getObject(source.getSourceId());\r\n            if (sourceObject == null || controller == null) {\r\n                return false;\r\n            }\r\n            if (controller.getLibrary().size() > 0) {\r\n                CardsImpl cards = new CardsImpl();\r\n                Card card = controller.getLibrary().getFromTop(game);\r\n                if (card == null) {\r\n                    return false;\r\n                }\r\n                cards.add(card);\r\n                controller.revealCards(sourceObject.getLogName(), cards, game);\r\n                if (card.getCardType().contains(CardType.LAND)) {\r\n                    return controller.putOntoBattlefieldWithInfo(card, game, Zone.LIBRARY, source.getSourceId());\r\n                } else {\r\n                    return controller.moveCardToHandWithInfo(card, source.getSourceId(), game, Zone.LIBRARY);\r\n                }\r\n            }\r\n            return true;\r\n        }","commit_id":"ae4c07da9d3766ce907110cf15b2c2ad43ec40c2","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller == null) {\r\n            return false;\r\n        }\r\n\r\n        for (UUID playerId : controller.getInRange()) {\r\n            Player player = game.getPlayer(playerId);\r\n            if (player != null) {\r\n                FilterCreatureCard filterCreatureCard = new FilterCreatureCard(\"creature card from your graveyard\");\r\n                TargetCardInYourGraveyard target = new TargetCardInYourGraveyard(filterCreatureCard);\r\n                target.setRequired(true);\r\n                if (player.chooseTarget(outcome, target, source, game)) {\r\n                    Card card = game.getCard(target.getFirstTarget());\r\n                    if (card != null) {\r\n                        card.putOntoBattlefield(game, Zone.GRAVEYARD, source.getId(), player.getId());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }","id":65952,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller == null) {\r\n            return false;\r\n        }\r\n\r\n        for (UUID playerId : controller.getInRange()) {\r\n            Player player = game.getPlayer(playerId);\r\n            if (player != null) {\r\n                FilterCreatureCard filterCreatureCard = new FilterCreatureCard(\"creature card from your graveyard\");\r\n                filterCreatureCard.add(new OwnerIdPredicate(playerId));\r\n                TargetCardInGraveyard target = new TargetCardInGraveyard(filterCreatureCard);\r\n                target.setRequired(true);\r\n                if (target.canChoose(playerId, game) &&\r\n                        player.chooseTarget(outcome, target, source, game)) {\r\n                    Card card = game.getCard(target.getFirstTarget());\r\n                    if (card != null) {\r\n                        card.putOntoBattlefield(game, Zone.GRAVEYARD, source.getId(), player.getId());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }","commit_id":"8007b16d646b7ea7156fc1b3dbce1147fb03d674","url":"https://github.com/magefree/mage"},{"original_method":"public boolean showRecordTableAsTable() {\n        if (this.showRecordTable() && this.showAsTable().equals(\"true\")) {\n            return true;\n        }\n        return false;\n    }","id":65953,"modified_method":"public boolean showRecordTableAsTable() {\n        if (this.showRecordTable() && this.showAsTable()) {\n            return true;\n        }\n        return false;\n    }","commit_id":"098f97d7c256e52a9f6c9385bd12a5f645b22d6d","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String totalsOnly() {\n        if (this.showTotalsOnly()) {\n            return \"true\";\n        }\n        return \"false\";\n    }","id":65954,"modified_method":"public boolean totalsOnly() {\n        return showTotalsOnly();\n    }","commit_id":"098f97d7c256e52a9f6c9385bd12a5f645b22d6d","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean showTotalsOnlyAsTable() {\n        if (this.showTotalsOnly() && this.showAsTable().equals(\"true\")) {\n            return true;\n        }\n        return false;\n    }","id":65955,"modified_method":"public boolean showTotalsOnlyAsTable() {\n        if (this.showTotalsOnly() && this.showAsTable()) {\n            return true;\n        }\n        return false;\n    }","commit_id":"098f97d7c256e52a9f6c9385bd12a5f645b22d6d","url":"https://github.com/wocommunity/wonder"},{"original_method":"public NSDictionary attributeListDict() {\n        if (this.totalsOnly() != null) {\n            return this.model().flatAttributeListTotalDict();\n        }\n\n        return this.model().flatAttributeDepthDict();\n    }","id":65956,"modified_method":"public NSDictionary attributeListDict() {\n        if (this.totalsOnly()) {\n            return this.model().flatAttributeListTotalDict();\n        }\n\n        return this.model().flatAttributeDepthDict();\n    }","commit_id":"098f97d7c256e52a9f6c9385bd12a5f645b22d6d","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean showRecordTableAsCells() {\n        if (this.showRecordTable() && !this.showAsTable().equals(\"true\")) {\n            return true;\n        }\n        return false;\n    }","id":65957,"modified_method":"public boolean showRecordTableAsCells() {\n        if (this.showRecordTable() && !this.showAsTable()) {\n            return true;\n        }\n        return false;\n    }","commit_id":"098f97d7c256e52a9f6c9385bd12a5f645b22d6d","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean showHeadingsForTotalsOrTable() {\n        if (\"true\".equals(showHeadings())) {\n            return true;\n        }\n        return false;\n    }","id":65958,"modified_method":"public boolean showHeadingsForTotalsOrTable() {\n        return showHeadings();\n    }","commit_id":"098f97d7c256e52a9f6c9385bd12a5f645b22d6d","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String showAsTable() {\n        if (_showAsTable == null) {\n            Object v = (Object)this.valueForBinding(\"showAsTable\");\n            if (ERXValueUtilities.booleanValue(v)) {\n                _showAsTable = \"true\";\n            }else {\n                _showAsTable = \"false\";\n            }\n        }\n        return _showAsTable;\n    }","id":65959,"modified_method":"public boolean showAsTable() {\n        if (_showAsTable == null) {\n            _showAsTable = booleanValueForBinding(\"showAsTable\");\n        }\n        return _showAsTable.booleanValue();\n    }","commit_id":"098f97d7c256e52a9f6c9385bd12a5f645b22d6d","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean showTotalsOnlyAsCells() {\n        if (this.showTotalsOnly() && !this.showAsTable().equals(\"true\")) {\n            return true;\n        }\n        return false;\n    }","id":65960,"modified_method":"public boolean showTotalsOnlyAsCells() {\n        if (this.showTotalsOnly() && !this.showAsTable()) {\n            return true;\n        }\n        return false;\n    }","commit_id":"098f97d7c256e52a9f6c9385bd12a5f645b22d6d","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String showHeadings() {\n        if (this.showSingleValue()) {\n            return \"false\";\n        }\n        if (_showHeadings == null) {\n            Object v = (Object)this.valueForBinding(\"showHeadings\");\n            if (ERXValueUtilities.booleanValue(v)) {\n                _showHeadings = \"true\";\n            }else {\n                _showHeadings = \"false\";\n            }\n        }\n        return _showHeadings;\n    }","id":65961,"modified_method":"public boolean showHeadings() {\n        if (showSingleValue()) {\n            return false;\n        }\n        if (_showHeadings == null) {\n            _showHeadings = booleanValueForBinding(\"showHeadings\");\n        }\n        return _showHeadings.booleanValue();\n    }","commit_id":"098f97d7c256e52a9f6c9385bd12a5f645b22d6d","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean isInSourceContent(@NotNull final VirtualFile fileOrDir) {\n    if (myProjectFileIndex.isInSourceContent(fileOrDir)) {\n      return true;\n    }\n    if (VfsUtilCore.isUnder(fileOrDir, myRootToModuleMap.keySet())) {\n      return true;\n    }\n    return false;\n  }","id":65962,"modified_method":"@Override\n  public boolean isInSourceContent(@NotNull final VirtualFile fileOrDir) {\n    if (myProjectFileIndex.isInSourceContent(fileOrDir)) {\n      return true;\n    }\n    return VfsUtilCore.isUnder(fileOrDir, myRootToModuleMap.keySet());\n  }","commit_id":"129414ad9049520e891c4e78a6b308c0aa732d57","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public CompileContextImpl(final Project project,\n                            final CompilerTask compilerSession,\n                            CompileScope compileScope,\n                            boolean isMake, boolean isRebuild) {\n    myProject = project;\n    myBuildSession = compilerSession;\n    myCompileScope = compileScope;\n    myMake = isMake;\n    myIsRebuild = isRebuild;\n    myStartCompilationStamp = System.currentTimeMillis();\n    myProjectFileIndex = ProjectRootManager.getInstance(myProject).getFileIndex();\n    myProjectCompileScope = new ProjectCompileScope(myProject);\n    myIsAnnotationProcessorsEnabled = CompilerConfiguration.getInstance(project).isAnnotationProcessorsEnabled();\n\n    if (compilerSession != null) {\n      final Object sessionId = ExecutionManagerImpl.EXECUTION_SESSION_ID_KEY.get(compileScope);\n      if (sessionId != null) {\n        // in case compilation is started as a part of some execution session, \n        // all compilation tasks should have the same sessionId in order for successive task not to clean messages \n        // from previous compilation tasks run within this execution session\n        compilerSession.setSessionId(sessionId);\n      }\n    }\n    final CompilerWorkspaceConfiguration workspaceConfig = CompilerWorkspaceConfiguration.getInstance(myProject);\n    myShouldUpdateProblemsView = workspaceConfig.MAKE_PROJECT_ON_SAVE;\n  }","id":65963,"modified_method":"public CompileContextImpl(@NotNull Project project,\n                            @NotNull CompilerTask compilerSession,\n                            @NotNull CompileScope compileScope,\n                            boolean isMake, boolean isRebuild) {\n    myProject = project;\n    myBuildSession = compilerSession;\n    myCompileScope = compileScope;\n    myMake = isMake;\n    myIsRebuild = isRebuild;\n    myStartCompilationStamp = System.currentTimeMillis();\n    myProjectFileIndex = ProjectRootManager.getInstance(myProject).getFileIndex();\n    myProjectCompileScope = new ProjectCompileScope(myProject);\n    myIsAnnotationProcessorsEnabled = CompilerConfiguration.getInstance(project).isAnnotationProcessorsEnabled();\n\n    final Object sessionId = ExecutionManagerImpl.EXECUTION_SESSION_ID_KEY.get(compileScope);\n    if (sessionId != null) {\n      // in case compilation is started as a part of some execution session,\n      // all compilation tasks should have the same sessionId in order for successive task not to clean messages\n      // from previous compilation tasks run within this execution session\n      compilerSession.setSessionId(sessionId);\n    }\n    final CompilerWorkspaceConfiguration workspaceConfig = CompilerWorkspaceConfiguration.getInstance(myProject);\n    myShouldUpdateProblemsView = workspaceConfig.MAKE_PROJECT_ON_SAVE;\n  }","commit_id":"129414ad9049520e891c4e78a6b308c0aa732d57","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isInTestSourceContent(@NotNull final VirtualFile fileOrDir) {\n    if (myProjectFileIndex.isInTestSourceContent(fileOrDir)) {\n      return true;\n    }\n    if (VfsUtilCore.isUnder(fileOrDir, myGeneratedTestRoots)) {\n      return true;\n    }\n    return false;\n  }","id":65964,"modified_method":"@Override\n  public boolean isInTestSourceContent(@NotNull final VirtualFile fileOrDir) {\n    if (myProjectFileIndex.isInTestSourceContent(fileOrDir)) {\n      return true;\n    }\n    return VfsUtilCore.isUnder(fileOrDir, myGeneratedTestRoots);\n  }","commit_id":"129414ad9049520e891c4e78a6b308c0aa732d57","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Module getModuleByFile(VirtualFile file) {\n    final Module module = myProjectFileIndex.getModuleForFile(file);\n    if (module != null) {\n      LOG.assertTrue(!module.isDisposed());\n      return module;\n    }\n    for (final VirtualFile root : myRootToModuleMap.keySet()) {\n      if (VfsUtil.isAncestor(root, file, false)) {\n        final Module mod = myRootToModuleMap.get(root);\n        if (mod != null) {\n          LOG.assertTrue(!mod.isDisposed());\n        }\n        return mod;\n      }\n    }\n    return null;\n  }","id":65965,"modified_method":"@Override\n  public Module getModuleByFile(VirtualFile file) {\n    final Module module = myProjectFileIndex.getModuleForFile(file);\n    if (module != null) {\n      LOG.assertTrue(!module.isDisposed());\n      return module;\n    }\n    for (final VirtualFile root : myRootToModuleMap.keySet()) {\n      if (VfsUtilCore.isAncestor(root, file, false)) {\n        final Module mod = myRootToModuleMap.get(root);\n        if (mod != null) {\n          LOG.assertTrue(!mod.isDisposed());\n        }\n        return mod;\n      }\n    }\n    return null;\n  }","commit_id":"129414ad9049520e891c4e78a6b308c0aa732d57","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void buildStructure(final FSSnapshot.Node from, final Set<File> excluded) {\n    final File nodeFile = from.getFile();\n    if (nodeFile.isDirectory()) {\n      if (PathUtil.isUnder(excluded, nodeFile)) {\n        return;\n      }\n      final File[] children = nodeFile.listFiles();\n      if (children != null) {\n        for (File child : children) {\n          buildStructure(from.addChild(child), excluded);\n        }\n      }\n    }\n  }","id":65966,"modified_method":"private static void buildStructure(final FSSnapshot.Node from, final Set<File> excluded) {\n    if (from.isDirectory()) {\n      final File nodeFile = from.getFile();\n      if (!PathUtil.isUnder(excluded, nodeFile)) {\n        final File[] children = nodeFile.listFiles();\n        if (children != null) {\n          for (File child : children) {\n            buildStructure(from.addChild(child), excluded);\n          }\n        }\n      }\n    }\n  }","commit_id":"441e1446521ee958387e5eb2b0c7555b607248be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean processRecursively(Node from, FileProcessor processor, String srcRoot) throws Exception {\n    if (from.file.isDirectory()) {\n      for (Node child : from.children) {\n        if (!processRecursively(child, processor, srcRoot)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return processor.apply(myModule, from.file, srcRoot);\n  }","id":65967,"modified_method":"private boolean processRecursively(Node from, FileProcessor processor, String srcRoot) throws Exception {\n    if (from.isDirectory()) {\n      for (Node child : from.children) {\n        if (!processRecursively(child, processor, srcRoot)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return processor.apply(myModule, from.file, srcRoot);\n  }","commit_id":"441e1446521ee958387e5eb2b0c7555b607248be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"Node(File file) {\n      this.file = file;\n    }","id":65968,"modified_method":"Node(File file) {\n      this.file = file;\n      myIsDirectory = file.isDirectory();\n    }","commit_id":"441e1446521ee958387e5eb2b0c7555b607248be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Builder.ExitCode build(final CompileContext context, ModuleChunk chunk) throws ProjectBuildException {\n    ExitCode exitCode = ExitCode.OK;\n    final List<File> toCompile = new ArrayList<File>();\n    try {\n      final TimestampStorage tsStorage = context.getBuildDataManager().getTimestampStorage(getName());\n      context.processFiles(chunk, new FileProcessor() {\n        @Override\n        public boolean apply(Module module, File file, String sourceRoot) throws Exception {\n          file = file.getCanonicalFile();\n          String path = file.getPath();\n          if ((path.endsWith(\".groovy\") || path.endsWith(\".gpp\")) && isFileDirty(file, context, tsStorage)) { //todo file type check\n            toCompile.add(file);\n          }\n          return true;\n        }\n      });\n\n      if (toCompile.isEmpty()) {\n        return exitCode;\n      }\n\n      final List<String> cp = new ArrayList<String>();\n      //groovy_rt.jar\n      // IMPORTANT! must be the first in classpath\n      cp.add(ClasspathBootstrap.getResourcePath(GroovyCompilerWrapper.class).getPath());\n\n      for (File file : context.getProjectPaths().getClasspathFiles(chunk, ClasspathKind.compile(context.isCompilingTests()), false)) {\n        cp.add(FileUtil.toCanonicalPath(file.getPath()));\n      }\n\n      final File tempFile = FileUtil.createTempFile(\"ideaGroovyToCompile\", \".txt\", true);\n      final Module representativeModule = chunk.getModules().iterator().next();\n      File moduleOutputDir = context.getProjectPaths().getModuleOutputDir(representativeModule, context.isCompilingTests());\n      final File dir = myForStubs ? FileUtil.createTempDirectory(/*new File(\"/tmp/stubs/\"), */\"groovyStubs\", null) : moduleOutputDir;\n      assert dir != null;\n\n      Set<String> toCompilePaths = new LinkedHashSet<String>();\n      for (File file : toCompile) {\n        toCompilePaths.add(FileUtil.toCanonicalPath(file.getPath()));\n      }\n      \n      String moduleOutputPath = FileUtil.toCanonicalPath(moduleOutputDir.getPath());\n      if (!moduleOutputPath.endsWith(\"/\")) {\n        moduleOutputPath += \"/\";\n      }\n      Map<String, String> class2Src = buildClassToSourceMap(context, toCompilePaths, moduleOutputPath);\n\n      fillFileWithGroovycParameters(tempFile, FileUtil.toCanonicalPath(dir.getPath()), toCompilePaths, moduleOutputPath, class2Src);\n\n      if (myForStubs) {\n        JavaBuilder.addTempSourcePathRoot(context, dir);\n      }\n\n      // todo cmd.add(\"-bootclasspath\");\n      //todo module jdk path\n      final List<String> cmd = ExternalProcessUtil.buildJavaCommandLine(\n        SystemProperties.getJavaHome() + \"/bin/java\",\n        \"org.jetbrains.groovy.compiler.rt.GroovycRunner\",\n        Collections.<String>emptyList(), cp,\n        Arrays.asList(\"-Xmx384m\"/*, \"-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5858\"*/),\n        Arrays.<String>asList(myForStubs ? \"stubs\" : \"groovyc\", tempFile.getPath())\n      );\n\n      context.deleteCorrespondingClasses(toCompile);\n\n      List<GroovycOSProcessHandler.OutputItem> successfullyCompiled = Collections.emptyList();\n      try {\n        final Process process = Runtime.getRuntime().exec(cmd.toArray(new String[cmd.size()]));\n        GroovycOSProcessHandler handler = new GroovycOSProcessHandler(process, null) {\n          @Override\n          protected void updateStatus(@Nullable String status) {\n            context.processMessage(new ProgressMessage(status == null ? GROOVY_COMPILER_IN_OPERATION : status));\n          }\n        };\n        handler.startNotify();\n        handler.waitFor();\n\n        successfullyCompiled = handler.getSuccessfullyCompiled();\n\n        final List<CompilerMessage> messages = handler.getCompilerMessages();\n        for (CompilerMessage message : messages) {\n          context.processMessage(message);\n        }\n\n        boolean hasMessages = !messages.isEmpty();\n\n        final StringBuffer unparsedBuffer = handler.getStdErr();\n        if (unparsedBuffer.length() != 0) {\n          context.processMessage(new CompilerMessage(BUILDER_NAME, BuildMessage.Kind.ERROR, unparsedBuffer.toString()));\n          hasMessages = true;\n        }\n\n        final int exitValue = handler.getProcess().exitValue();\n        if (!hasMessages && exitValue != 0) {\n          context.processMessage(new CompilerMessage(BUILDER_NAME, BuildMessage.Kind.ERROR, \"Internal groovyc error: code \" + exitValue));\n        }\n      }\n      finally {\n        if (myForStubs) {\n          for (GroovycOSProcessHandler.OutputItem item : successfullyCompiled) {\n            tsStorage.saveStamp(new File(item.sourcePath));\n          }\n        }\n        else {\n          final Mappings delta = context.createDelta();\n          final List<File> successfullyCompiledFiles = new ArrayList<File>();\n          if (!successfullyCompiled.isEmpty()) {\n            final Callbacks.Backend callback = delta.getCallback();\n            final OutputToSourceMapping storage = context.getBuildDataManager().getOutputToSourceStorage();\n\n            for (GroovycOSProcessHandler.OutputItem item : successfullyCompiled) {\n              final String sourcePath = FileUtil.toSystemIndependentName(item.sourcePath);\n              final String outputPath = FileUtil.toSystemIndependentName(item.outputPath);\n              storage.update(outputPath, sourcePath);\n              callback.associate(outputPath, Callbacks.getDefaultLookup(sourcePath), new ClassReader(FileUtil.loadFileBytes(new File(outputPath))));\n              successfullyCompiledFiles.add(new File(sourcePath));\n            }\n          }\n\n          final boolean needSecondPass = updateMappings(context, delta, chunk, toCompile, successfullyCompiledFiles);\n          if (needSecondPass) {\n            exitCode = ExitCode.ADDITIONAL_PASS_REQUIRED;\n          }\n        }\n      }\n\n      return exitCode;\n    }\n    catch (Exception e) {\n      throw new ProjectBuildException(e);\n    }\n  }","id":65969,"modified_method":"public Builder.ExitCode build(final CompileContext context, ModuleChunk chunk) throws ProjectBuildException {\n    ExitCode exitCode = ExitCode.OK;\n    final List<File> toCompile = new ArrayList<File>();\n    try {\n      final TimestampStorage tsStorage = context.getBuildDataManager().getTimestampStorage(getName());\n      context.processFiles(chunk, new FileProcessor() {\n        @Override\n        public boolean apply(Module module, File file, String sourceRoot) throws Exception {\n          final String path = file.getPath();\n          if ((path.endsWith(\".groovy\") || path.endsWith(\".gpp\")) && isFileDirty(file, context, tsStorage)) { //todo file type check\n            toCompile.add(file);\n          }\n          return true;\n        }\n      });\n\n      if (toCompile.isEmpty()) {\n        return exitCode;\n      }\n\n      final List<String> cp = new ArrayList<String>();\n      //groovy_rt.jar\n      // IMPORTANT! must be the first in classpath\n      cp.add(ClasspathBootstrap.getResourcePath(GroovyCompilerWrapper.class).getPath());\n\n      for (File file : context.getProjectPaths().getClasspathFiles(chunk, ClasspathKind.compile(context.isCompilingTests()), false)) {\n        cp.add(FileUtil.toCanonicalPath(file.getPath()));\n      }\n\n      final File tempFile = FileUtil.createTempFile(\"ideaGroovyToCompile\", \".txt\", true);\n      final Module representativeModule = chunk.getModules().iterator().next();\n      File moduleOutputDir = context.getProjectPaths().getModuleOutputDir(representativeModule, context.isCompilingTests());\n      final File dir = myForStubs ? FileUtil.createTempDirectory(/*new File(\"/tmp/stubs/\"), */\"groovyStubs\", null) : moduleOutputDir;\n      assert dir != null;\n\n      Set<String> toCompilePaths = new LinkedHashSet<String>();\n      for (File file : toCompile) {\n        toCompilePaths.add(file.getPath());\n      }\n      \n      String moduleOutputPath = FileUtil.toCanonicalPath(moduleOutputDir.getPath());\n      if (!moduleOutputPath.endsWith(\"/\")) {\n        moduleOutputPath += \"/\";\n      }\n      Map<String, String> class2Src = buildClassToSourceMap(context, toCompilePaths, moduleOutputPath);\n\n      fillFileWithGroovycParameters(tempFile, FileUtil.toCanonicalPath(dir.getPath()), toCompilePaths, moduleOutputPath, class2Src);\n\n      if (myForStubs) {\n        JavaBuilder.addTempSourcePathRoot(context, dir);\n      }\n\n      // todo cmd.add(\"-bootclasspath\");\n      //todo module jdk path\n      final List<String> cmd = ExternalProcessUtil.buildJavaCommandLine(\n        SystemProperties.getJavaHome() + \"/bin/java\",\n        \"org.jetbrains.groovy.compiler.rt.GroovycRunner\",\n        Collections.<String>emptyList(), cp,\n        Arrays.asList(\"-Xmx384m\"/*, \"-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5858\"*/),\n        Arrays.<String>asList(myForStubs ? \"stubs\" : \"groovyc\", tempFile.getPath())\n      );\n\n      context.deleteCorrespondingClasses(toCompile);\n\n      List<GroovycOSProcessHandler.OutputItem> successfullyCompiled = Collections.emptyList();\n      try {\n        final Process process = Runtime.getRuntime().exec(cmd.toArray(new String[cmd.size()]));\n        GroovycOSProcessHandler handler = new GroovycOSProcessHandler(process, null) {\n          @Override\n          protected void updateStatus(@Nullable String status) {\n            context.processMessage(new ProgressMessage(status == null ? GROOVY_COMPILER_IN_OPERATION : status));\n          }\n        };\n        handler.startNotify();\n        handler.waitFor();\n\n        successfullyCompiled = handler.getSuccessfullyCompiled();\n\n        final List<CompilerMessage> messages = handler.getCompilerMessages();\n        for (CompilerMessage message : messages) {\n          context.processMessage(message);\n        }\n\n        boolean hasMessages = !messages.isEmpty();\n\n        final StringBuffer unparsedBuffer = handler.getStdErr();\n        if (unparsedBuffer.length() != 0) {\n          context.processMessage(new CompilerMessage(BUILDER_NAME, BuildMessage.Kind.ERROR, unparsedBuffer.toString()));\n          hasMessages = true;\n        }\n\n        final int exitValue = handler.getProcess().exitValue();\n        if (!hasMessages && exitValue != 0) {\n          context.processMessage(new CompilerMessage(BUILDER_NAME, BuildMessage.Kind.ERROR, \"Internal groovyc error: code \" + exitValue));\n        }\n      }\n      finally {\n        if (myForStubs) {\n          for (GroovycOSProcessHandler.OutputItem item : successfullyCompiled) {\n            tsStorage.saveStamp(new File(item.sourcePath));\n          }\n        }\n        else {\n          final Mappings delta = context.createDelta();\n          final List<File> successfullyCompiledFiles = new ArrayList<File>();\n          if (!successfullyCompiled.isEmpty()) {\n            final Callbacks.Backend callback = delta.getCallback();\n            final OutputToSourceMapping storage = context.getBuildDataManager().getOutputToSourceStorage();\n\n            for (GroovycOSProcessHandler.OutputItem item : successfullyCompiled) {\n              final String sourcePath = FileUtil.toSystemIndependentName(item.sourcePath);\n              final String outputPath = FileUtil.toSystemIndependentName(item.outputPath);\n              storage.update(outputPath, sourcePath);\n              callback.associate(outputPath, Callbacks.getDefaultLookup(sourcePath), new ClassReader(FileUtil.loadFileBytes(new File(outputPath))));\n              successfullyCompiledFiles.add(new File(sourcePath));\n            }\n          }\n\n          final boolean needSecondPass = updateMappings(context, delta, chunk, toCompile, successfullyCompiledFiles);\n          if (needSecondPass) {\n            exitCode = ExitCode.ADDITIONAL_PASS_REQUIRED;\n          }\n        }\n      }\n\n      return exitCode;\n    }\n    catch (Exception e) {\n      throw new ProjectBuildException(e);\n    }\n  }","commit_id":"441e1446521ee958387e5eb2b0c7555b607248be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ExitCode build(final CompileContext context, final ModuleChunk chunk) throws ProjectBuildException {\n    try {\n      final TimestampStorage tsStorage = context.getBuildDataManager().getTimestampStorage(BUILDER_NAME);\n      final Set<File> filesToCompile = new LinkedHashSet<File>();\n      final List<File> formsToCompile = new ArrayList<File>();\n      final List<File> upToDateForms = new ArrayList<File>();\n      final Set<String> srcRoots = new HashSet<String>();\n\n      final boolean wholeModuleRebuildRequired = context.isDirty(chunk);\n\n      context.processFiles(chunk, new FileProcessor() {\n        public boolean apply(Module module, File file, String sourceRoot) throws Exception {\n          if (JAVA_SOURCES_FILTER.accept(file)) {\n            srcRoots.add(sourceRoot);\n            if (wholeModuleRebuildRequired || isFileDirty(file, context, tsStorage)) {\n              filesToCompile.add(file);\n            }\n          }\n          else if (FORM_SOURCES_FILTER.accept(file)){\n            if (wholeModuleRebuildRequired || isFileDirty(file, context, tsStorage)) {\n              formsToCompile.add(file);\n            }\n            else {\n              upToDateForms.add(file);\n            }\n          }\n          return true;\n        }\n      });\n\n      // force compilation of bound source file if the form is dirty\n      for (File form : formsToCompile) {\n        for (String root : srcRoots) {\n          final File boundSource = getBoundSource(root, form);\n          if (boundSource != null) {\n            // force compilation of classes that modified forms are bound to\n            filesToCompile.add(boundSource);\n            break;\n          }\n        }\n      }\n\n      // form should be considered dirty if the class it is bound to is also dirty!\n      for (File form : upToDateForms) {\n        for (String root : srcRoots) {\n          final File boundSource = getBoundSource(root, form);\n          if (boundSource != null && filesToCompile.contains(boundSource)) {\n            formsToCompile.add(form);\n            break;\n          }\n        }\n      }\n      upToDateForms.clear();\n\n      context.deleteCorrespondingClasses(filesToCompile);\n\n      return compile(context, chunk, filesToCompile, formsToCompile);\n    }\n    catch (Exception e) {\n      String message = e.getMessage();\n      if (message == null) {\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        e.printStackTrace(new PrintStream(out));\n        message = \"Internal error: \\n\" + out.toString();\n      }\n      context.processMessage(new CompilerMessage(BUILDER_NAME, BuildMessage.Kind.ERROR, message));\n      throw new ProjectBuildException(message, e);\n    }\n  }","id":65970,"modified_method":"public ExitCode build(final CompileContext context, final ModuleChunk chunk) throws ProjectBuildException {\n    try {\n      final TimestampStorage tsStorage = context.getBuildDataManager().getTimestampStorage(BUILDER_NAME);\n      final Set<File> filesToCompile = new LinkedHashSet<File>();\n      final List<File> formsToCompile = new ArrayList<File>();\n      final List<File> upToDateForms = new ArrayList<File>();\n      final Set<String> srcRoots = new HashSet<String>();\n\n      final boolean wholeModuleRebuildRequired = context.isDirty(chunk);\n\n      context.processFiles(chunk, new FileProcessor() {\n        public boolean apply(Module module, File file, String sourceRoot) throws Exception {\n          if (JAVA_SOURCES_FILTER.accept(file)) {\n            srcRoots.add(sourceRoot);\n            if (wholeModuleRebuildRequired || isFileDirty(file, context, tsStorage)) {\n              filesToCompile.add(file);\n            }\n          }\n          else if (FORM_SOURCES_FILTER.accept(file)){\n            if (wholeModuleRebuildRequired || isFileDirty(file, context, tsStorage)) {\n              formsToCompile.add(file);\n            }\n            else {\n              upToDateForms.add(file);\n            }\n          }\n          return true;\n        }\n      });\n\n      // force compilation of bound source file if the form is dirty\n      for (File form : formsToCompile) {\n        for (String root : srcRoots) {\n          final File boundSource = getBoundSource(root, form);\n          if (boundSource != null) {\n            // force compilation of classes that modified forms are bound to\n            filesToCompile.add(boundSource);\n            break;\n          }\n        }\n      }\n\n      // form should be considered dirty if the class it is bound to is also dirty!\n      for (File form : upToDateForms) {\n        for (String root : srcRoots) {\n          final File boundSource = getBoundSource(root, form);\n          if (boundSource != null && filesToCompile.contains(boundSource)) {\n            formsToCompile.add(form);\n            break;\n          }\n        }\n      }\n      upToDateForms.clear();\n\n      context.deleteCorrespondingClasses(filesToCompile);\n\n      return compile(context, chunk, filesToCompile, formsToCompile);\n    }\n    catch (ProjectBuildException e) {\n      throw e;\n    }\n    catch (Exception e) {\n      String message = e.getMessage();\n      if (message == null) {\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        e.printStackTrace(new PrintStream(out));\n        message = \"Internal error: \\n\" + out.toString();\n      }\n      context.processMessage(new CompilerMessage(BUILDER_NAME, BuildMessage.Kind.ERROR, message));\n      throw new ProjectBuildException(message, e);\n    }\n  }","commit_id":"441e1446521ee958387e5eb2b0c7555b607248be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PersistentMultiMaplet(final File file,\n                               final KeyDescriptor<K> k,\n                               final DataExternalizer<V> v,\n                               final TransientMultiMaplet.CollectionConstructor<V> c) {\n    try {\n      map = new PersistentHashMap<K, Collection<V>>(file, k, new DataExternalizer<Collection<V>>() {\n        @Override\n        public void save(final DataOutput out, final Collection<V> value) throws IOException {\n          final int size = value.size();\n\n          out.writeInt(size);\n\n          for (V x : value) {\n            v.save(out, x);\n          }\n        }\n\n        @Override\n        public Collection<V> read(final DataInput in) throws IOException {\n          final Collection<V> result = c.create();\n          final int size = in.readInt();\n\n          for (int i = 0; i < size; i++) {\n            result.add(v.read(in));\n          }\n\n          return result;\n        }\n      });\n    }\n    catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n\n    constr = c;\n  }","id":65971,"modified_method":"public PersistentMultiMaplet(final File file,\n                               final KeyDescriptor<K> k,\n                               final DataExternalizer<V> v,\n                               final TransientMultiMaplet.CollectionConstructor<V> c) throws IOException {\n    map = new PersistentHashMap<K, Collection<V>>(file, k, new DataExternalizer<Collection<V>>() {\n      @Override\n      public void save(final DataOutput out, final Collection<V> value) throws IOException {\n        final int size = value.size();\n\n        out.writeInt(size);\n\n        for (V x : value) {\n          v.save(out, x);\n        }\n      }\n\n      @Override\n      public Collection<V> read(final DataInput in) throws IOException {\n        final Collection<V> result = c.create();\n        final int size = in.readInt();\n\n        for (int i = 0; i < size; i++) {\n          result.add(v.read(in));\n        }\n\n        return result;\n      }\n    });\n\n    constr = c;\n  }","commit_id":"441e1446521ee958387e5eb2b0c7555b607248be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void customize() {\n\n        OsDetails osDetails = getMachine().getMachineDetails().getOsDetails();\n        List<String> commands = Lists.newLinkedList();\n\n        String vmArgsTemplate = processTemplate(entity.getConfig(RiakNode.RIAK_VM_ARGS_TEMPLATE_URL));\n\n        //create entity's runDir\n        DynamicTasks.queueIfPossible(newScript(CUSTOMIZING).body.append(\"true\").newTask());\n\n        DynamicTasks.queueIfPossible(SshEffectorTasks.put(getRunDir() + \"/vm.args\")\n                .contents(Streams.newInputStreamWithContents(vmArgsTemplate))\n                .machine(getMachine())\n                .summary(\"sending the vm.args file to the riak node\"));\n\n\n        commands.add(sudo(\"chown riak:riak \" + getRunDir() + \"/vm.args\"));\n        commands.add(sudo(\"mv \" + getRunDir() + \"/vm.args \" + getEtcDir()));\n\n        // Edit file at getAppConfigLocation as per instructions at\n        // http://docs.basho.com/riak/2.0.0pre20/ops/building/basic-cluster-setup/\n        // Could also set scheduler on linux systems\n\n\n        //FIXME EC2 requires to configure the private IP in order for the riak node to work.\n        //replace instances of 127.0.0.1 with the actual hostname in the app.config and vm.args files\n        commands.add(sudo(format(\"sed -i -e \\\"s/127.0.0.1/%s/g\\\" %s\", getPrivateIp(), getAppConfigLocation())));\n\n\n        //increase open file limit (default min for riak is: 4096)\n        //TODO: detect the actual limit then do the modificaiton.\n        //TODO: modify ulimit for linux distros\n        //    commands.add(sudo(\"launchctl limit maxfiles 4096 32768\"));\n        if (osDetails.isMac())\n            commands.add(\"ulimit -n 4096\");\n\n\n        DynamicTasks.queueIfPossible(newScript(CUSTOMIZING)\n                .failOnNonZeroResultCode()\n                .body.append(commands)\n                .newTask());\n\n        //set the riak node name\n        entity.setAttribute(RiakNode.RIAK_NODE_NAME, format(\"riak@%s\", getHostname()));\n\n    }","id":65972,"modified_method":"@Override\n    public void customize() {\n\n        isRiakOnPath = isPackageInstall ? isRiakOnPath() : true;\n\n        OsDetails osDetails = getMachine().getMachineDetails().getOsDetails();\n        List<String> commands = Lists.newLinkedList();\n\n        String vmArgsTemplate = processTemplate(entity.getConfig(RiakNode.RIAK_VM_ARGS_TEMPLATE_URL));\n\n        //create entity's runDir\n        DynamicTasks.queueIfPossible(newScript(CUSTOMIZING).body.append(\"true\").newTask());\n\n        DynamicTasks.queueIfPossible(SshEffectorTasks.put(getRunDir() + \"/vm.args\")\n                .contents(Streams.newInputStreamWithContents(vmArgsTemplate))\n                .machine(getMachine())\n                .summary(\"sending the vm.args file to the riak node\"));\n\n        //increase open file limit (default min for riak is: 4096)\n        //TODO: detect the actual limit then do the modificaiton.\n        //TODO: modify ulimit for linux distros\n        //    commands.add(sudo(\"launchctl limit maxfiles 4096 32768\"));\n        if (osDetails.isMac())\n            commands.add(\"ulimit -n 4096\");\n        else if (osDetails.isLinux()) {\n            commands.add(sudo(\"chown riak:riak \" + getRunDir() + \"/vm.args\"));\n        }\n\n        commands.add(sudo(\"mv \" + getRunDir() + \"/vm.args \" + getEtcDir()));\n\n        //FIXME EC2 requires to configure the private IP in order for the riak node to work.\n        //replace instances of 127.0.0.1 with the actual hostname in the app.config and vm.args files\n        commands.add(sudo(format(\"sed -i -e \\\"s/127.0.0.1/%s/g\\\" %s\", getPrivateIp(), getAppConfigLocation())));\n\n        ScriptHelper customizeScript = newScript(CUSTOMIZING)\n                .failOnNonZeroResultCode()\n                .body.append(commands);\n\n        if (!isRiakOnPath) {\n            Map<String, String> newPathVariable = ImmutableMap.of(\"PATH\", sbinPath);\n            log.warn(\"riak command not found on PATH. Altering future commands' environment variables from {} to {}\", getShellEnvironment(), newPathVariable);\n            customizeScript.environmentVariablesReset(newPathVariable);\n        }\n\n        customizeScript.execute();\n\n        //set the riak node name\n        entity.setAttribute(RiakNode.RIAK_NODE_NAME, format(\"riak@%s\", getHostname()));\n\n    }","commit_id":"6aac3655267d17513e1a4ed62a875b422d5daad9","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"private Boolean isInCluster() {\n        Optional<Boolean> inCluster = Optional.of(entity.getAttribute(RiakNode.RIAK_NODE_IN_CLUSTER));\n        if (inCluster.isPresent())\n            return inCluster.get();\n        else\n            return Boolean.FALSE;\n    }","id":65973,"modified_method":"private Boolean isInCluster() {\n        return Optional.fromNullable(entity.getAttribute(RiakNode.RIAK_NODE_IN_CLUSTER)).or(Boolean.FALSE);\n    }","commit_id":"6aac3655267d17513e1a4ed62a875b422d5daad9","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public boolean isRunning() {\n\n        return newScript(CHECK_RUNNING)\n                .body.append(sudo(format(\"%s test\", getRiakAdminCmd())))\n                .execute() == 0;\n\n    }","id":65974,"modified_method":"@Override\n    public boolean isRunning() {\n\n        ScriptHelper checkRunningScript = newScript(CHECK_RUNNING)\n                .body.append(format(\"%s ping\", getRiakCmd()));\n\n        if (!isRiakOnPath) {\n            Map<String, String> newPathVariable = ImmutableMap.of(\"PATH\", sbinPath);\n            log.warn(\"riak command not found on PATH. Altering future commands' environment variables from {} to {}\", getShellEnvironment(), newPathVariable);\n            checkRunningScript.environmentVariablesReset(newPathVariable);\n        }\n\n        return (checkRunningScript.execute() == 0);\n\n    }","commit_id":"6aac3655267d17513e1a4ed62a875b422d5daad9","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"private List<String> installLinux(String expandedInstallDir) {\n        LOG.info(\"Ignoring version config ({}) and installing from package manager\", getEntity().getConfig(RiakNode.SUGGESTED_VERSION));\n        isPackageInstall = true;\n        String installBin = Urls.mergePaths(expandedInstallDir, \"bin\");\n        String apt = chainGroup(\n                \"which apt-get\",\n                \"curl http://apt.basho.com/gpg/basho.apt.key | \" + sudo(\"apt-key add -\"),\n                sudo(\"bash -c \\\"echo deb http://apt.basho.com $(lsb_release -sc) main > /etc/apt/sources.list.d/basho.list\\\"\"),\n                sudo(\"apt-get update\"),\n                sudo(\"apt-get -y --allow-unauthenticated install riak=\" + getEntity().getConfig(RiakNode.SUGGESTED_VERSION) + \"*\"));\n        String yum = chainGroup(\n                \"which yum\",\n                sudo(\"yum -y --nogpgcheck install http://yum.basho.com/gpg/basho-release-5-1.noarch.rpm\"),\n                sudo(\"yum -y --nogpgcheck install riak-\" + getEntity().getConfig(RiakNode.SUGGESTED_VERSION) + \"*\"));\n        return ImmutableList.<String>builder()\n                .add(\"mkdir -p \" + installBin)\n                .add(INSTALL_CURL)\n                .add(alternatives(apt, yum))\n                .add(\"ln -s `which riak` \" + Urls.mergePaths(installBin, \"riak\"))\n                .add(\"ln -s `which riak-admin` \" + Urls.mergePaths(installBin, \"riak-admin\"))\n                .build();\n    }","id":65975,"modified_method":"private List<String> installLinux(String expandedInstallDir) {\n        LOG.info(\"Ignoring version config ({}) and installing from package manager\", getEntity().getConfig(RiakNode.SUGGESTED_VERSION));\n        isPackageInstall = true;\n        String installBin = Urls.mergePaths(expandedInstallDir, \"bin\");\n        String apt = chainGroup(\n                //debian fix\n                \"export PATH=$PATH:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\",\n                \"which apt-get\",\n                \"curl http://apt.basho.com/gpg/basho.apt.key | \" + sudo(\"apt-key add -\"),\n                sudo(\"bash -c \\\"echo deb http://apt.basho.com $(lsb_release -sc) main > /etc/apt/sources.list.d/basho.list\\\"\"),\n                sudo(\"apt-get update\"),\n                sudo(\"apt-get -y --allow-unauthenticated install riak=\" + getEntity().getConfig(RiakNode.SUGGESTED_VERSION) + \"*\"));\n        String yum = chainGroup(\n                \"which yum\",\n                sudo(\"yum -y --nogpgcheck install http://yum.basho.com/gpg/basho-release-5-1.noarch.rpm\"),\n                sudo(\"yum -y --nogpgcheck install riak-\" + getEntity().getConfig(RiakNode.SUGGESTED_VERSION) + \"*\"));\n        return ImmutableList.<String>builder()\n                .add(\"mkdir -p \" + installBin)\n                .add(INSTALL_CURL)\n                .add(alternatives(apt, yum))\n                .add(\"ln -s `which riak` \" + Urls.mergePaths(installBin, \"riak\"))\n                .add(\"ln -s `which riak-admin` \" + Urls.mergePaths(installBin, \"riak-admin\"))\n                .build();\n    }","commit_id":"6aac3655267d17513e1a4ed62a875b422d5daad9","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void launch() {\n        newScript(LAUNCHING)\n                .failOnNonZeroResultCode()\n                .body.append(format(\"sudo %s start >/dev/null 2>&1 < /dev/null &\", getRiakCmd()))\n                .execute();\n    }","id":65976,"modified_method":"@Override\n    public void launch() {\n\n        String command = format(\"%s start >/dev/null 2>&1 < /dev/null &\", getRiakCmd());\n        command = isPackageInstall ? \"sudo \" + command : command;\n\n        ScriptHelper launchScript = newScript(LAUNCHING)\n                .failOnNonZeroResultCode()\n                .body.append(command);\n\n        if (!isRiakOnPath) {\n            Map<String, String> newPathVariable = ImmutableMap.of(\"PATH\", sbinPath);\n            log.warn(\"riak command not found on PATH. Altering future commands' environment variables from {} to {}\", getShellEnvironment(), newPathVariable);\n            launchScript.environmentVariablesReset(newPathVariable);\n        }\n\n        launchScript.execute();\n    }","commit_id":"6aac3655267d17513e1a4ed62a875b422d5daad9","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"private String getPrivateIp() {\n        Optional<String> subnetAddress = Optional.of(entity.getAttribute(Attributes.SUBNET_ADDRESS));\n\n        if (subnetAddress.isPresent())\n            return subnetAddress.get();\n        else\n            throw new IllegalArgumentException(\"Subnet address is not set.\");\n    }","id":65977,"modified_method":"private String getPrivateIp() {\n        Optional<String> subnetAddress = Optional.fromNullable(entity.getAttribute(Attributes.SUBNET_ADDRESS));\n\n        if (subnetAddress.isPresent())\n            return subnetAddress.get();\n        else\n            throw new IllegalArgumentException(\"Subnet address is not set.\");\n    }","commit_id":"6aac3655267d17513e1a4ed62a875b422d5daad9","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void leaveCluster() {\n        //TODO: add 'riak-admin cluster force-remove' for erreneous and unrecoverable nodes.\n        //FIXME: find a way to batch commit the changes, instead of committing for every operation.\n\n        if (isInCluster()) {\n            newScript(\"leaveCluster\")\n                    .body.append(format(\"%s cluster leave\"))\n                    .body.append(format(\"%s cluster plan\", getRiakAdminCmd()))\n                    .body.append(format(\"%s cluster commit\", getRiakAdminCmd()))\n                    .failOnNonZeroResultCode()\n                    .execute();\n\n            entity.setAttribute(RiakNode.RIAK_NODE_IN_CLUSTER, Boolean.FALSE);\n\n\n        } else {\n            log.warn(\"entity {}: is not in the riak Cluster\", entity.getId());\n        }\n    }","id":65978,"modified_method":"@Override\n    public void leaveCluster() {\n        //TODO: add 'riak-admin cluster force-remove' for erreneous and unrecoverable nodes.\n        //FIXME: find a way to batch commit the changes, instead of committing for every operation.\n\n        if (isInCluster()) {\n            ScriptHelper leaveClusterScript = newScript(\"leaveCluster\")\n                    .body.append(format(\"%s cluster leave\"))\n                    .body.append(format(\"%s cluster plan\", getRiakAdminCmd()))\n                    .body.append(format(\"%s cluster commit\", getRiakAdminCmd()))\n                    .failOnNonZeroResultCode();\n\n            if (!isRiakOnPath) {\n                Map<String, String> newPathVariable = ImmutableMap.of(\"PATH\", sbinPath);\n                log.warn(\"riak command not found on PATH. Altering future commands' environment variables from {} to {}\", getShellEnvironment(), newPathVariable);\n                leaveClusterScript.environmentVariablesReset(newPathVariable);\n            }\n\n            leaveClusterScript.execute();\n\n\n            entity.setAttribute(RiakNode.RIAK_NODE_IN_CLUSTER, Boolean.FALSE);\n\n\n        } else {\n            log.warn(\"entity {}: is not in the riak Cluster\", entity.getId());\n        }\n    }","commit_id":"6aac3655267d17513e1a4ed62a875b422d5daad9","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void joinCluster(RiakNode node) {\n        //FIXME: find a way to batch commit the changes, instead of committing for every operation.\n        if (!isInCluster()) {\n            String riakName = node.getAttribute(RiakNode.RIAK_NODE_NAME);\n\n            newScript(\"joinCluster\")\n                    .body.append(format(\"%s cluster join %s\", getRiakAdminCmd(), riakName))\n                    .body.append(format(\"%s cluster plan\", getRiakAdminCmd()))\n                    .body.append(format(\"%s cluster commit\", getRiakAdminCmd()))\n                    .failOnNonZeroResultCode()\n                    .execute();\n\n            entity.setAttribute(RiakNode.RIAK_NODE_IN_CLUSTER, Boolean.TRUE);\n        } else {\n            log.warn(\"entity {}: is already in the riak cluster\", entity.getId());\n        }\n    }","id":65979,"modified_method":"@Override\n    public void joinCluster(RiakNode node) {\n        //FIXME: find a way to batch commit the changes, instead of committing for every operation.\n\n        if (!isInCluster()) {\n            String riakName = node.getAttribute(RiakNode.RIAK_NODE_NAME);\n\n            ScriptHelper joinClusterScript = newScript(\"joinCluster\")\n                    .body.append(format(\"%s cluster join %s\", getRiakAdminCmd(), riakName))\n                    .body.append(format(\"%s cluster plan\", getRiakAdminCmd()))\n                    .body.append(format(\"%s cluster commit\", getRiakAdminCmd()))\n                    .failOnNonZeroResultCode();\n\n            if (!isRiakOnPath) {\n                Map<String, String> newPathVariable = ImmutableMap.of(\"PATH\", sbinPath);\n                log.warn(\"riak command not found on PATH. Altering future commands' environment variables from {} to {}\", getShellEnvironment(), newPathVariable);\n                joinClusterScript.environmentVariablesReset(newPathVariable);\n            }\n\n            joinClusterScript.execute();\n\n\n            entity.setAttribute(RiakNode.RIAK_NODE_IN_CLUSTER, Boolean.TRUE);\n        } else {\n            log.warn(\"entity {}: is already in the riak cluster\", entity.getId());\n        }\n    }","commit_id":"6aac3655267d17513e1a4ed62a875b422d5daad9","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void stop() {\n        newScript(STOPPING)\n                .failOnNonZeroResultCode()\n                .body.append(sudo(format(\"%s stop\", getRiakCmd())))\n                .execute();\n\n    }","id":65980,"modified_method":"@Override\n    public void stop() {\n\n        leaveCluster();\n\n        String command = format(\"%s stop\", getRiakCmd());\n        command = isPackageInstall ? \"sudo \" + command : command;\n\n        ScriptHelper stopScript = newScript(STOPPING)\n                .failOnNonZeroResultCode()\n                .body.append(command);\n\n        if (!isRiakOnPath) {\n            Map<String, String> newPathVariable = ImmutableMap.of(\"PATH\", sbinPath);\n            log.warn(\"riak command not found on PATH. Altering future commands' environment variables from {} to {}\", getShellEnvironment(), newPathVariable);\n            stopScript.environmentVariablesReset(newPathVariable);\n        }\n\n        stopScript.execute();\n\n    }","commit_id":"6aac3655267d17513e1a4ed62a875b422d5daad9","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public void visitClassContext(ClassContext classContext) {\n\t\tJavaClass jclass = classContext.getJavaClass();\n\t\tMethod[] methodList = jclass.getMethods();\n\n\t\tfor (int i = 0; i < methodList.length; ++i) {\n\t\t\tMethod method = methodList[i];\n\t\t\tif (method.getCode() == null)\n\t\t\t\tcontinue;\n\n\t\t\tanalyzeMethod(classContext, method);\n\t\t}\n\t}","id":65981,"modified_method":"public void visitClassContext(ClassContext classContext) {\n\t\tJavaClass jclass = classContext.getJavaClass();\n\t\tMethod[] methodList = jclass.getMethods();\n\n\t\tfor (int i = 0; i < methodList.length; ++i) {\n\t\t\tMethod method = methodList[i];\n\t\t\tif (method.getCode() == null)\n\t\t\t\tcontinue;\n\n\t\t\t// We can ignore methods that don't contain a monitorenter\n\t\t\tBitSet bytecodeSet = classContext.getBytecodeSet(method);\n\t\t\tif (!bytecodeSet.get(Constants.MONITORENTER))\n\t\t\t\tcontinue;\n\n\t\t\ttry {\n\t\t\t\tanalyzeMethod(classContext, method);\n\t\t\t} catch (CFGBuilderException e) {\n\t\t\t\tbugReporter.logError(\"FindJSR166LockMonitorEnter caught exception\", e);\n\t\t\t} catch (DataflowAnalysisException e) {\n\t\t\t\tbugReporter.logError(\"FindJSR166LockMonitorEnter caught exception\", e);\n\t\t\t}\n\t\t}\n\t}","commit_id":"a7fb71b40b15fb0cb65a85da1d6b92ccc2869d8b","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void analyzeMethod(ClassContext classContext, Method method) {\n\t\tConstantPoolGen cpg = classContext.getConstantPoolGen();\n\t\ttry {\n\t\t\tBitSet bytecodeSet = classContext.getBytecodeSet(method);\n\t\t\tif (!bytecodeSet.get(Constants.MONITORENTER))\n\t\t\t\treturn;\n\n\t\t\tCFG cfg = classContext.getCFG(method);\n\t\t\tTypeDataflow typeDataflow = classContext.getTypeDataflow(method);\n\n\t\t\tfor (Iterator<BasicBlock> i = cfg.blockIterator(); i.hasNext();) {\n\t\t\t\tBasicBlock basicBlock = i.next();\n\t\t\t\tfor (Iterator<InstructionHandle> j = basicBlock.instructionIterator(); j.hasNext();) {\n\t\t\t\t\tInstructionHandle handle = j.next();\n\t\t\t\t\tInstruction ins = handle.getInstruction();\n\n\t\t\t\t\tif (ins.getOpcode() != Constants.MONITORENTER)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tType type = typeDataflow.getFactAtLocation(new Location(handle, basicBlock)).getInstance(ins, cpg);\n\n\t\t\t\t\tif (!(type instanceof ReferenceType)) {\n\t\t\t\t\t\t// FIXME:\n\t\t\t\t\t\t// Something is deeply wrong if a non-reference type\n\t\t\t\t\t\t// is used for a monitorenter.  But, that's really a\n\t\t\t\t\t\t// verification problem.\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tboolean isSubtype;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tisSubtype = Hierarchy.isSubtype((ReferenceType) type, LOCK_TYPE);\n\t\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\t\tbugReporter.reportMissingClass(e);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isSubtype) {\n\t\t\t\t\t\tMethodGen mg = classContext.getMethodGen(method);\n\t\t\t\t\t\tString sourceFile = classContext.getJavaClass().getSourceFileName();\n\n\t\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"JLM_JSR166_LOCK_MONITORENTER\", NORMAL_PRIORITY)\n\t\t\t\t\t\t        .addClassAndMethod(mg, sourceFile)\n\t\t\t\t\t\t        .addSourceLine(mg, sourceFile, handle));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (CFGBuilderException e) {\n\t\t\tthrow new AnalysisException(\"FindJSR166LockMonitorenter: caught exception \" + e.toString(), e);\n\t\t} catch (DataflowAnalysisException e) {\n\t\t\tthrow new AnalysisException(\"FindJSR166LockMonitorenter: caught exception \" + e.toString(), e);\n\t\t}\n\t}","id":65982,"modified_method":"private void analyzeMethod(ClassContext classContext, Method method)\n\t\t\tthrows CFGBuilderException, DataflowAnalysisException {\n\t\tConstantPoolGen cpg = classContext.getConstantPoolGen();\n\t\tCFG cfg = classContext.getCFG(method);\n\t\tTypeDataflow typeDataflow = classContext.getTypeDataflow(method);\n\t\t\n\t\tfor (Iterator<BasicBlock> i = cfg.blockIterator(); i.hasNext();) {\n\t\t\tBasicBlock basicBlock = i.next();\n\t\t\tfor (Iterator<InstructionHandle> j = basicBlock.instructionIterator(); j.hasNext();) {\n\t\t\t\tInstructionHandle handle = j.next();\n\t\t\t\tInstruction ins = handle.getInstruction();\n\t\t\t\t\n\t\t\t\tif (ins.getOpcode() != Constants.MONITORENTER)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tType type = typeDataflow.getFactAtLocation(new Location(handle, basicBlock)).getInstance(ins, cpg);\n\t\t\t\t\n\t\t\t\tif (!(type instanceof ReferenceType)) {\n\t\t\t\t\t// Something is deeply wrong if a non-reference type\n\t\t\t\t\t// is used for a monitorenter.  But, that's really a\n\t\t\t\t\t// verification problem.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tboolean isSubtype;\n\t\t\t\ttry {\n\t\t\t\t\tisSubtype = Hierarchy.isSubtype((ReferenceType) type, LOCK_TYPE);\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\tbugReporter.reportMissingClass(e);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (isSubtype) {\n\t\t\t\t\tMethodGen mg = classContext.getMethodGen(method);\n\t\t\t\t\tString sourceFile = classContext.getJavaClass().getSourceFileName();\n\t\t\t\t\t\n\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"JLM_JSR166_LOCK_MONITORENTER\", NORMAL_PRIORITY)\n\t\t\t\t\t\t\t.addClassAndMethod(mg, sourceFile)\n\t\t\t\t\t\t\t.addSourceLine(mg, sourceFile, handle));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"a7fb71b40b15fb0cb65a85da1d6b92ccc2869d8b","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void analyzeCodeBlock(@Nullable final PsiElement scope, ProblemsHolder holder) {\n    if (scope == null) return;\n    final StandardDataFlowRunner dfaRunner = new StandardDataFlowRunner(SUGGEST_NULLABLE_ANNOTATIONS);\n    final StandardInstructionVisitor visitor = new DataFlowInstructionVisitor(dfaRunner);\n    final RunnerResult rc = dfaRunner.analyzeMethod(scope, visitor, IGNORE_ASSERT_STATEMENTS);\n    if (rc == RunnerResult.OK) {\n      createDescription(dfaRunner, holder, visitor);\n    }\n    else if (rc == RunnerResult.TOO_COMPLEX) {\n      if (scope.getParent() instanceof PsiMethod) {\n        PsiMethod method = (PsiMethod)scope.getParent();\n        final PsiIdentifier name = method.getNameIdentifier();\n        if (name != null) { // Might be null for synthetic methods like JSP page.\n          holder.registerProblem(name, InspectionsBundle.message(\"dataflow.too.complex\"), ProblemHighlightType.WEAK_WARNING);\n        }\n      }\n    }\n  }","id":65983,"modified_method":"private void analyzeCodeBlock(@Nullable final PsiElement scope, ProblemsHolder holder) {\n    if (scope == null) return;\n\n    PsiClass containingClass = PsiTreeUtil.getParentOfType(scope, PsiClass.class);\n    if (containingClass != null && PsiUtil.isLocalOrAnonymousClass(containingClass)) return;\n\n    final StandardDataFlowRunner dfaRunner = new StandardDataFlowRunner(SUGGEST_NULLABLE_ANNOTATIONS);\n    analyzeDfaWithNestedClosures(scope, holder, dfaRunner, Arrays.asList(dfaRunner.createMemoryState()));\n  }","commit_id":"3bb5907f5f7d85d32134ded2923f3268433d5cf0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final RunnerResult analyzeMethod(@NotNull PsiElement psiBlock, InstructionVisitor visitor, boolean ignoreAssertions) {\n    try {\n      final Collection<DfaMemoryState> initialStates = createInitialStates(psiBlock, visitor);\n      if (initialStates == null) return RunnerResult.NOT_APPLICABLE;\n\n      final ControlFlow flow = createControlFlowAnalyzer().buildControlFlow(psiBlock, ignoreAssertions);\n      if (flow == null) return RunnerResult.NOT_APPLICABLE;\n\n      int endOffset = flow.getInstructionCount();\n      myInstructions = flow.getInstructions();\n      myFields = flow.getFields();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Analyzing code block: \" + psiBlock.getText());\n        for (int i = 0; i < myInstructions.length; i++) {\n          Instruction instruction = myInstructions[i];\n          LOG.debug(i + \": \" + instruction.toString());\n        }\n      }\n\n      Integer tooExpensiveHash = psiBlock.getUserData(TOO_EXPENSIVE_HASH);\n      if (tooExpensiveHash != null && tooExpensiveHash == psiBlock.getText().hashCode()) {\n        LOG.debug(\"Too complex because hasn't changed since being too complex already\");\n        return RunnerResult.TOO_COMPLEX;\n      }\n\n      final ArrayList<DfaInstructionState> queue = new ArrayList<DfaInstructionState>();\n      for (final DfaMemoryState initialState : initialStates) {\n        queue.add(new DfaInstructionState(myInstructions[0], initialState));\n      }\n\n      long timeLimit = ourTimeLimit;\n      final boolean unitTestMode = ApplicationManager.getApplication().isUnitTestMode();\n      WorkingTimeMeasurer measurer = new WorkingTimeMeasurer(timeLimit);\n      int count = 0;\n      while (!queue.isEmpty()) {\n        if (count % 50 == 0 && !unitTestMode && measurer.isTimeOver()) {\n          LOG.debug(\"Too complex because the analysis took too long\");\n          psiBlock.putUserData(TOO_EXPENSIVE_HASH, psiBlock.getText().hashCode());\n          return RunnerResult.TOO_COMPLEX;\n        }\n        ProgressManager.checkCanceled();\n\n        DfaInstructionState instructionState = queue.remove(0);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(instructionState.toString());\n        }\n\n        Instruction instruction = instructionState.getInstruction();\n        long distance = instructionState.getDistanceFromStart();\n\n        if (instruction instanceof BranchingInstruction) {\n          if (!instruction.setMemoryStateProcessed(instructionState.getMemoryState().createCopy())) {\n            LOG.debug(\"Too complex because too many different possible states\");\n            return RunnerResult.TOO_COMPLEX; // Too complex :(\n          }\n        }\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(instructionState.toString());\n        }\n        //System.out.println(instructionState.toString());\n\n        DfaInstructionState[] after = instruction.accept(this, instructionState.getMemoryState(), visitor);\n        if (after != null) {\n          for (DfaInstructionState state : after) {\n            Instruction nextInstruction = state.getInstruction();\n            if ((!(nextInstruction instanceof BranchingInstruction) || !nextInstruction.isMemoryStateProcessed(state.getMemoryState())) && instruction.getIndex() < endOffset) {\n              state.setDistanceFromStart(distance + 1);\n              queue.add(state);\n            }\n          }\n        }\n\n        count++;\n      }\n\n      psiBlock.putUserData(TOO_EXPENSIVE_HASH, null);\n      LOG.debug(\"Analysis ok\");\n      return RunnerResult.OK;\n    }\n    catch (ArrayIndexOutOfBoundsException e) {\n      LOG.error(psiBlock.getText(), e); // TODO fix in better times\n      return RunnerResult.ABORTED;\n    }\n    catch (EmptyStackException e) {\n      if (LOG.isDebugEnabled()) {\n        LOG.error(e); // TODO fix in better times\n      }\n      return RunnerResult.ABORTED;\n    }\n  }","id":65984,"modified_method":"public final RunnerResult analyzeMethod(@NotNull PsiElement psiBlock,\n                                          InstructionVisitor visitor,\n                                          boolean ignoreAssertions,\n                                          @NotNull Collection<DfaMemoryState> initialStates) {\n    try {\n      prepareAnalysis(psiBlock, initialStates);\n\n      final ControlFlow flow = createControlFlowAnalyzer().buildControlFlow(psiBlock, ignoreAssertions);\n      if (flow == null) return RunnerResult.NOT_APPLICABLE;\n\n      int endOffset = flow.getInstructionCount();\n      myInstructions = flow.getInstructions();\n      myFields = flow.getFields();\n      myNestedClosures.clear();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Analyzing code block: \" + psiBlock.getText());\n        for (int i = 0; i < myInstructions.length; i++) {\n          Instruction instruction = myInstructions[i];\n          LOG.debug(i + \": \" + instruction.toString());\n        }\n      }\n\n      Integer tooExpensiveHash = psiBlock.getUserData(TOO_EXPENSIVE_HASH);\n      if (tooExpensiveHash != null && tooExpensiveHash == psiBlock.getText().hashCode()) {\n        LOG.debug(\"Too complex because hasn't changed since being too complex already\");\n        return RunnerResult.TOO_COMPLEX;\n      }\n\n      final ArrayList<DfaInstructionState> queue = new ArrayList<DfaInstructionState>();\n      for (final DfaMemoryState initialState : initialStates) {\n        queue.add(new DfaInstructionState(myInstructions[0], initialState));\n      }\n\n      long timeLimit = ourTimeLimit;\n      final boolean unitTestMode = ApplicationManager.getApplication().isUnitTestMode();\n      WorkingTimeMeasurer measurer = new WorkingTimeMeasurer(timeLimit);\n      int count = 0;\n      while (!queue.isEmpty()) {\n        if (count % 50 == 0 && !unitTestMode && measurer.isTimeOver()) {\n          LOG.debug(\"Too complex because the analysis took too long\");\n          psiBlock.putUserData(TOO_EXPENSIVE_HASH, psiBlock.getText().hashCode());\n          return RunnerResult.TOO_COMPLEX;\n        }\n        ProgressManager.checkCanceled();\n\n        DfaInstructionState instructionState = queue.remove(0);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(instructionState.toString());\n        }\n        //System.out.println(instructionState.toString());\n\n        Instruction instruction = instructionState.getInstruction();\n        long distance = instructionState.getDistanceFromStart();\n\n        if (instruction instanceof BranchingInstruction) {\n          if (!instruction.setMemoryStateProcessed(instructionState.getMemoryState().createCopy())) {\n            LOG.debug(\"Too complex because too many different possible states\");\n            return RunnerResult.TOO_COMPLEX; // Too complex :(\n          }\n        }\n\n        DfaInstructionState[] after = acceptInstruction(visitor, instructionState);\n        for (DfaInstructionState state : after) {\n          Instruction nextInstruction = state.getInstruction();\n          if ((!(nextInstruction instanceof BranchingInstruction) || !nextInstruction.isMemoryStateProcessed(state.getMemoryState())) && instruction.getIndex() < endOffset) {\n            state.setDistanceFromStart(distance + 1);\n            queue.add(state);\n          }\n        }\n\n        count++;\n      }\n\n      psiBlock.putUserData(TOO_EXPENSIVE_HASH, null);\n      LOG.debug(\"Analysis ok\");\n      return RunnerResult.OK;\n    }\n    catch (ArrayIndexOutOfBoundsException e) {\n      LOG.error(psiBlock.getText(), e); // TODO fix in better times\n      return RunnerResult.ABORTED;\n    }\n    catch (EmptyStackException e) {\n      if (LOG.isDebugEnabled()) {\n        LOG.error(e); // TODO fix in better times\n      }\n      return RunnerResult.ABORTED;\n    }\n  }","commit_id":"3bb5907f5f7d85d32134ded2923f3268433d5cf0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final RunnerResult analyzeMethod(@NotNull PsiElement psiBlock, InstructionVisitor visitor) {\n    return analyzeMethod(psiBlock, visitor, false);\n  }","id":65985,"modified_method":"public final RunnerResult analyzeMethod(@NotNull PsiElement psiBlock, InstructionVisitor visitor) {\n    Collection<DfaMemoryState> initialStates = createInitialStates(psiBlock, visitor);\n    return initialStates == null ? RunnerResult.NOT_APPLICABLE : analyzeMethod(psiBlock, visitor, false, initialStates);\n  }","commit_id":"3bb5907f5f7d85d32134ded2923f3268433d5cf0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  protected Collection<DfaMemoryState> createInitialStates(@NotNull PsiElement psiBlock, InstructionVisitor visitor) {\n    PsiClass containingClass = PsiTreeUtil.getParentOfType(psiBlock, PsiClass.class);\n    if (containingClass != null && PsiUtil.isLocalOrAnonymousClass(containingClass)) {\n      final PsiElement parent = containingClass.getParent();\n      final PsiCodeBlock block = DfaPsiUtil.getTopmostBlockInSameClass(parent);\n      if ((parent instanceof PsiNewExpression || parent instanceof PsiDeclarationStatement) && block != null) {\n        final EnvironmentalInstructionVisitor envVisitor = new EnvironmentalInstructionVisitor(visitor, parent);\n        final RunnerResult result = analyzeMethod(block, envVisitor);\n        if (result == RunnerResult.OK) {\n          final Collection<DfaMemoryState> closureStates = envVisitor.getClosureStates();\n          if (!closureStates.isEmpty()) {\n            return closureStates;\n          }\n        }\n        return null;\n      }\n    }\n\n    return Arrays.asList(createMemoryState());\n  }","id":65986,"modified_method":"@Nullable\n  private Collection<DfaMemoryState> createInitialStates(@NotNull PsiElement psiBlock, InstructionVisitor visitor) {\n    PsiClass containingClass = PsiTreeUtil.getParentOfType(psiBlock, PsiClass.class);\n    if (containingClass != null && PsiUtil.isLocalOrAnonymousClass(containingClass)) {\n      final PsiElement parent = containingClass.getParent();\n      final PsiCodeBlock block = DfaPsiUtil.getTopmostBlockInSameClass(parent);\n      if ((parent instanceof PsiNewExpression || parent instanceof PsiDeclarationStatement) && block != null) {\n        final RunnerResult result = analyzeMethod(block, visitor);\n        if (result == RunnerResult.OK) {\n          final Collection<DfaMemoryState> closureStates = myNestedClosures.get(block);\n          if (!closureStates.isEmpty()) {\n            return closureStates;\n          }\n        }\n        return null;\n      }\n    }\n\n    return Arrays.asList(createMemoryState());\n  }","commit_id":"3bb5907f5f7d85d32134ded2923f3268433d5cf0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void analyzeMethod(ClassContext classContext, Method method,\n\t\tStreamResourceTracker resourceTracker)\n\t\tthrows CFGBuilderException, DataflowAnalysisException {\n\n\t\tif (isMainMethod(method)) return;\n\n\t\tpotentialOpenStreamList.clear();\n\n\t\tsuper.analyzeMethod(classContext, method, resourceTracker);\n\n\t\tJavaClass javaClass = classContext.getJavaClass();\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\n\t\tresourceTracker.markTransitiveUninterestingStreamEscapes();\n\n\t\tIterator<PotentialOpenStream> i = potentialOpenStreamList.iterator();\n\t\twhile (i.hasNext()) {\n\t\t\tPotentialOpenStream pos = i.next();\n\n\t\t\tStream stream = pos.stream;\n\n\t\t\tif (stream.isUninteresting())\n\t\t\t\tcontinue;\n\n\t\t\tInstructionHandle constructionHandle = stream.getConstructorHandle();\n\t\t\tif (constructionHandle == null)\n\t\t\t\tcontinue;\n\n\t\t\tif (IGNORE_WRAPPED_UNINTERESTING_STREAMS\n\t\t\t\t&& resourceTracker.isUninterestingStreamEscape(constructionHandle))\n\t\t\t\tcontinue;\n\n\t\t\tString sourceFile = javaClass.getSourceFileName();\n\t\t\tbugReporter.reportBug(new BugInstance(pos.bugType, pos.priority)\n\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t.addSourceLine(methodGen, sourceFile, stream.getLocation().getHandle())\n\t\t\t);\n\t\t}\n\t}","id":65987,"modified_method":"public void analyzeMethod(ClassContext classContext, Method method,\n\t\tStreamResourceTracker resourceTracker,\n\t\tMap<Location, Stream> locationToResourceMap)\n\t\tthrows CFGBuilderException, DataflowAnalysisException {\n\n\t\tif (isMainMethod(method)) return;\n\n\t\tpotentialOpenStreamList.clear();\n\n\t\tsuper.analyzeMethod(classContext, method, resourceTracker, locationToResourceMap);\n\n\t\tJavaClass javaClass = classContext.getJavaClass();\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\n\t\tresourceTracker.markTransitiveUninterestingStreamEscapes();\n\n\t\tIterator<PotentialOpenStream> i = potentialOpenStreamList.iterator();\n\t\twhile (i.hasNext()) {\n\t\t\tPotentialOpenStream pos = i.next();\n\n\t\t\tStream stream = pos.stream;\n\n\t\t\tif (stream.isUninteresting())\n\t\t\t\tcontinue;\n\n\t\t\tInstructionHandle constructionHandle = stream.getConstructorHandle();\n\t\t\tif (constructionHandle == null)\n\t\t\t\tcontinue;\n\n\t\t\tif (IGNORE_WRAPPED_UNINTERESTING_STREAMS\n\t\t\t\t&& resourceTracker.isUninterestingStreamEscape(constructionHandle))\n\t\t\t\tcontinue;\n\n\t\t\tString sourceFile = javaClass.getSourceFileName();\n\t\t\tbugReporter.reportBug(new BugInstance(pos.bugType, pos.priority)\n\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t.addSourceLine(methodGen, sourceFile, stream.getLocation().getHandle())\n\t\t\t);\n\t\t}\n\t}","commit_id":"290fe54f265db2e966836de790221694c7d83ee2","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void visitClassContext(ClassContext classContext) {\n\n\t\ttry {\n\t\t\tfinal JavaClass jclass = classContext.getJavaClass();\n\t\t\tMethod[] methodList = jclass.getMethods();\n\t\t\tfor (int i = 0; i < methodList.length; ++i) {\n\t\t\t\tMethod method = methodList[i];\n\t\t\t\tif (method.isAbstract() || method.isNative())\n\t\t\t\t\tcontinue;\n\n\t\t\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\t\t\tif (methodGen == null)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (DEBUG_METHOD_NAME != null && !DEBUG_METHOD_NAME.equals(method.getName()))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (!prescreen(classContext, method))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tSystem.out.println(\"----------------------------------------------------------------------\");\n\t\t\t\t\tSystem.out.println(\"Analyzing \" + SignatureConverter.convertMethodSignature(methodGen));\n\t\t\t\t\tSystem.out.println(\"----------------------------------------------------------------------\");\n\t\t\t\t}\n\n\t\t\t\tResourceTrackerType resourceTracker = getResourceTracker(classContext, method);\n\t\t\t\tanalyzeMethod(classContext, method, resourceTracker);\n\t\t\t}\n\t\t} catch (CFGBuilderException e) {\n\t\t\tthrow new AnalysisException(e.toString(), e);\n\t\t} catch (DataflowAnalysisException e) {\n\t\t\tthrow new AnalysisException(e.toString(), e);\n\t\t}\n\n\t}","id":65988,"modified_method":"public void visitClassContext(ClassContext classContext) {\n\n\t\tfinal JavaClass jclass = classContext.getJavaClass();\n\t\tMethod[] methodList = jclass.getMethods();\n\t\tfor (int i = 0; i < methodList.length; ++i) {\n\t\t\tMethod method = methodList[i];\n\t\t\tif (method.isAbstract() || method.isNative())\n\t\t\t\tcontinue;\n\n\t\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\t\tif (methodGen == null)\n\t\t\t\tcontinue;\n\n\t\t\tif (DEBUG_METHOD_NAME != null && !DEBUG_METHOD_NAME.equals(method.getName()))\n\t\t\t\tcontinue;\n\n\t\t\tif (!prescreen(classContext, method))\n\t\t\t\tcontinue;\n\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"----------------------------------------------------------------------\");\n\t\t\t\tSystem.out.println(\"Analyzing \" + SignatureConverter.convertMethodSignature(methodGen));\n\t\t\t\tSystem.out.println(\"----------------------------------------------------------------------\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tResourceTrackerType resourceTracker = getResourceTracker(classContext, method);\n\n\t\t\t\tMap<Location, Resource> locationToResourceMap =\n\t\t\t\t\tbuildLocationToResourceMap(classContext, method, resourceTracker);\n\t\t\t\tif (locationToResourceMap.isEmpty())\n\t\t\t\t\tcontinue;\n\n\t\t\t\tanalyzeMethod(classContext, method, resourceTracker, locationToResourceMap);\n\t\t\t} catch (CFGBuilderException e) {\n\t\t\t\tbugReporter.logError(e.toString());\n\t\t\t} catch (DataflowAnalysisException e) {\n\t\t\t\tbugReporter.logError(e.toString());\n\t\t\t}\n\t\t}\n\n\t}","commit_id":"290fe54f265db2e966836de790221694c7d83ee2","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void analyzeMethod(final ClassContext classContext, Method method,\n\t\tResourceTrackerType resourceTracker)\n\t\tthrows CFGBuilderException, DataflowAnalysisException {\n\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\tCFG cfg = classContext.getCFG(method);\n\t\tDepthFirstSearch dfs = classContext.getDepthFirstSearch(method);\n\n\t\tif (DEBUG) System.out.println(SignatureConverter.convertMethodSignature(methodGen));\n\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext(); ) {\n\t\t\tLocation location = i.next();\n\t\t\tBasicBlock basicBlock = location.getBasicBlock();\n\t\t\tInstructionHandle handle = location.getHandle();\n\n\t\t\tResource resource =\n\t\t\t\tresourceTracker.isResourceCreation(basicBlock, handle, methodGen.getConstantPool());\n\t\t\tif (resource != null) {\n\t\t\t\tif (DEBUG) System.out.println(\"Resource creation at \" + handle.getPosition());\n\t\t\t\tResourceValueAnalysis<Resource> analysis =\n\t\t\t\t\tnew ResourceValueAnalysis<Resource>(methodGen, cfg, dfs, resourceTracker,\n\t\t\t\t\t\tresource, bugReporter);\n\t\t\t\tDataflow<ResourceValueFrame, ResourceValueAnalysis<Resource>> dataflow =\n\t\t\t\t\tnew Dataflow<ResourceValueFrame, ResourceValueAnalysis<Resource>>(cfg, analysis);\n\t\n\t\t\t\tdataflow.execute();\n\t\t\t\tinspectResult(classContext.getJavaClass(), methodGen, cfg, dataflow, resource);\n\t\t\t}\n\t\t}\n\t}","id":65989,"modified_method":"public void analyzeMethod(ClassContext classContext, Method method,\n\t\tResourceTrackerType resourceTracker, Map<Location, Resource> locationToResourceMap)\n\t\tthrows CFGBuilderException, DataflowAnalysisException {\n\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\tCFG cfg = classContext.getCFG(method);\n\t\tDepthFirstSearch dfs = classContext.getDepthFirstSearch(method);\n\n\t\tif (DEBUG) System.out.println(SignatureConverter.convertMethodSignature(methodGen));\n\n\t\tfor (Iterator<Map.Entry<Location, Resource>> i = locationToResourceMap.entrySet().iterator();\n\t\t\ti.hasNext(); ) {\n\t\t\tMap.Entry<Location, Resource> entry = i.next();\n\n\t\t\tLocation location = entry.getKey();\n\t\t\tResource resource = entry.getValue();\n\n\t\t\tInstructionHandle handle = location.getHandle();\n\n\t\t\tif (DEBUG) System.out.println(\"Resource creation at \" + handle.getPosition());\n\t\t\tResourceValueAnalysis<Resource> analysis =\n\t\t\t\tnew ResourceValueAnalysis<Resource>(methodGen, cfg, dfs, resourceTracker,\n\t\t\t\t\tresource, bugReporter);\n\t\t\tDataflow<ResourceValueFrame, ResourceValueAnalysis<Resource>> dataflow =\n\t\t\t\tnew Dataflow<ResourceValueFrame, ResourceValueAnalysis<Resource>>(cfg, analysis);\n\n\t\t\tdataflow.execute();\n\t\t\tinspectResult(classContext.getJavaClass(), methodGen, cfg, dataflow, resource);\n\t\t}\n\t}","commit_id":"290fe54f265db2e966836de790221694c7d83ee2","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void visitClassContext(ClassContext classContext) {\n\t\ttry {\n\t\t\tJavaClass javaClass = classContext.getJavaClass();\n\t\t\tif (DEBUG) System.out.println(\"******** Analyzing class \" + javaClass.getClassName());\n\n\t\t\t// Build self-call graph\n\t\t\tSelfCalls selfCalls = new SelfCalls(classContext) {\n\t\t\t\tpublic boolean wantCallsFor(Method method) {\n\t\t\t\t\treturn !method.isPublic();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tselfCalls.execute();\n\t\t\tCallGraph callGraph = selfCalls.getCallGraph();\n\t\t\tif (DEBUG)\n\t\t\t\tSystem.out.println(\"Call graph (not unlocked methods): \" + callGraph.getNumVertices() + \" nodes, \" +\n\t\t\t\t        callGraph.getNumEdges() + \" edges\");\n\n\t\t\t// Find call edges that are obviously locked\n\t\t\tSet<CallSite> obviouslyLockedSites = findObviouslyLockedCallSites(classContext, selfCalls);\n\n\t\t\tSet<Method> lockedMethodSet = findNotUnlockedMethods(classContext, selfCalls, obviouslyLockedSites);\n\t\t\tlockedMethodSet.retainAll(findLockedMethods(classContext, selfCalls, obviouslyLockedSites));\n\n\t\t\tSet<Method> publicReachableMethods\n\t\t\t        = findPublicReachableMethods(classContext, selfCalls);\n\n\t\t\tIterator<Method> i = publicReachableMethods.iterator();\n\t\t\twhile (i.hasNext()) {\n\t\t\t\tMethod method = i.next();\n\t\t\t\tif (classContext.getMethodGen(method) == null)\n\t\t\t\t\tcontinue;\n\t\t\t\t/*\n\t\t\t\tif (isConstructor(method.getName()))\n\t\t\t\t\tcontinue;\n\t\t\t\t*/\n\t\t\t\tif (method.getName().startsWith(\"access$\"))\n\t\t\t\t// Ignore inner class access methods;\n\t\t\t\t// we will treat calls to them as field accesses\n\t\t\t\t\tcontinue;\n\t\t\t\tanalyzeMethod(classContext, method, lockedMethodSet);\n\t\t\t}\n\n\t\t} catch (CFGBuilderException e) {\n\t\t\tthrow new AnalysisException(\"FindInconsistentSync2 caught exception: \" + e.toString(), e);\n\t\t} catch (DataflowAnalysisException e) {\n\t\t\t//e.printStackTrace();\n\t\t\tthrow new AnalysisException(\"FindInconsistentSync2 caught exception: \" + e.toString(), e);\n\t\t}\n\t}","id":65990,"modified_method":"public void visitClassContext(ClassContext classContext) {\n\t\tJavaClass javaClass = classContext.getJavaClass();\n\t\tif (DEBUG) System.out.println(\"******** Analyzing class \" + javaClass.getClassName());\n\t\t\n\t\t// Build self-call graph\n\t\tSelfCalls selfCalls = new SelfCalls(classContext) {\n\t\t\tpublic boolean wantCallsFor(Method method) {\n\t\t\t\treturn !method.isPublic();\n\t\t\t}\n\t\t};\n\t\t\n\t\tSet<Method> lockedMethodSet;\n\t\tSet<Method> publicReachableMethods;\n\t\t\n\t\ttry {\n\t\t\tselfCalls.execute();\n\t\t\tCallGraph callGraph = selfCalls.getCallGraph();\n\t\t\tif (DEBUG)\n\t\t\t\tSystem.out.println(\"Call graph (not unlocked methods): \" + callGraph.getNumVertices() + \" nodes, \" +\n\t\t\t\t\t\tcallGraph.getNumEdges() + \" edges\");\n\t\t\t// Find call edges that are obviously locked\n\t\t\tSet<CallSite> obviouslyLockedSites = findObviouslyLockedCallSites(classContext, selfCalls);\n\t\t\tlockedMethodSet = findNotUnlockedMethods(classContext, selfCalls, obviouslyLockedSites);\n\t\t\tlockedMethodSet.retainAll(findLockedMethods(classContext, selfCalls, obviouslyLockedSites));\n\t\t\tpublicReachableMethods = findPublicReachableMethods(classContext, selfCalls);\n\t\t} catch (CFGBuilderException e) {\n\t\t\tbugReporter.logError(\"Error finding locked call sites\", e);\n\t\t\treturn;\n\t\t} catch (DataflowAnalysisException e) {\n\t\t\tbugReporter.logError(\"Error finding locked call sites\", e);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tIterator<Method> i = publicReachableMethods.iterator();\n\t\twhile (i.hasNext()) {\n\t\t\tMethod method = i.next();\n\t\t\tif (classContext.getMethodGen(method) == null)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t if (isConstructor(method.getName()))\n\t\t\t continue;\n\t\t\t */\n\t\t\tif (method.getName().startsWith(\"access$\"))\n\t\t\t\t// Ignore inner class access methods;\n\t\t\t\t// we will treat calls to them as field accesses\n\t\t\t\tcontinue;\n\t\t\ttry {\n\t\t\t\tanalyzeMethod(classContext, method, lockedMethodSet);\n\t\t\t} catch (CFGBuilderException e) {\n\t\t\t\tbugReporter.logError(\"Error analyzing method\", e);\n\t\t\t} catch (DataflowAnalysisException e) {\n\t\t\t\tbugReporter.logError(\"Error analyzing method\", e);\n\t\t\t}\n\t\t}\n\t}","commit_id":"5df9858795b225106a6cafe384e1a96ab43da5c2","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Find all self-call sites that are obviously locked.\n\t */\n\tprivate Set<CallSite> findObviouslyLockedCallSites(ClassContext classContext, SelfCalls selfCalls)\n\t        throws CFGBuilderException, DataflowAnalysisException {\n\t\tConstantPoolGen cpg = classContext.getConstantPoolGen();\n\n\t\t// Find all obviously locked call sites\n\t\tSet<CallSite> obviouslyLockedSites = new HashSet<CallSite>();\n\t\tfor (Iterator<CallSite> i = selfCalls.callSiteIterator(); i.hasNext();) {\n\t\t\tCallSite callSite = i.next();\n\t\t\tMethod method = callSite.getMethod();\n\t\t\tLocation location = callSite.getLocation();\n\t\t\tInstructionHandle handle = location.getHandle();\n\n\t\t\t// Only instance method calls qualify as candidates for\n\t\t\t// \"obviously locked\"\n\t\t\tInstruction ins = handle.getInstruction();\n\t\t\tif (ins.getOpcode() == Constants.INVOKESTATIC)\n\t\t\t\tcontinue;\n\n\t\t\t// Get lock set for site\n\t\t\tLockChecker lockChecker = classContext.getLockChecker(method);\n\t\t\tLockSet lockSet = lockChecker.getFactAtLocation(location);\n\n\t\t\t// Get value number frame for site\n\t\t\tValueNumberDataflow vnaDataflow = classContext.getValueNumberDataflow(method);\n\t\t\tValueNumberFrame frame = vnaDataflow.getFactAtLocation(location);\n\n\t\t\t// NOTE: if the CFG on which the value number analysis was performed\n\t\t\t// was pruned, there may be unreachable instructions.  Therefore,\n\t\t\t// we can't assume the frame is valid.\n\t\t\tif (!frame.isValid())\n\t\t\t\tcontinue;\n\n\t\t\t// Find the ValueNumber of the receiver object\n\t\t\tint numConsumed = ins.consumeStack(cpg);\n\t\t\tif (numConsumed == Constants.UNPREDICTABLE)\n\t\t\t\tthrow new AnalysisException(\"Unpredictable stack consumption: \" + handle);\n\t\t\t//if (DEBUG) System.out.println(\"Getting receiver for frame: \" + frame);\n\t\t\tValueNumber instance = frame.getStackValue(numConsumed - 1);\n\n\t\t\t// Is the instance locked?\n\t\t\tint lockCount = lockSet.getLockCount(instance.getNumber());\n\t\t\tif (lockCount > 0) {\n\t\t\t\t// This is a locked call site\n\t\t\t\tobviouslyLockedSites.add(callSite);\n\t\t\t}\n\t\t}\n\n\t\treturn obviouslyLockedSites;\n\t}","id":65991,"modified_method":"/**\n\t * Find all self-call sites that are obviously locked.\n\t */\n\tprivate Set<CallSite> findObviouslyLockedCallSites(ClassContext classContext, SelfCalls selfCalls)\n\t        throws CFGBuilderException, DataflowAnalysisException {\n\t\tConstantPoolGen cpg = classContext.getConstantPoolGen();\n\n\t\t// Find all obviously locked call sites\n\t\tSet<CallSite> obviouslyLockedSites = new HashSet<CallSite>();\n\t\tfor (Iterator<CallSite> i = selfCalls.callSiteIterator(); i.hasNext();) {\n\t\t\tCallSite callSite = i.next();\n\t\t\tMethod method = callSite.getMethod();\n\t\t\tLocation location = callSite.getLocation();\n\t\t\tInstructionHandle handle = location.getHandle();\n\n\t\t\t// Only instance method calls qualify as candidates for\n\t\t\t// \"obviously locked\"\n\t\t\tInstruction ins = handle.getInstruction();\n\t\t\tif (ins.getOpcode() == Constants.INVOKESTATIC)\n\t\t\t\tcontinue;\n\n\t\t\t// Get lock set for site\n\t\t\tLockChecker lockChecker = classContext.getLockChecker(method);\n\t\t\tLockSet lockSet = lockChecker.getFactAtLocation(location);\n\n\t\t\t// Get value number frame for site\n\t\t\tValueNumberDataflow vnaDataflow = classContext.getValueNumberDataflow(method);\n\t\t\tValueNumberFrame frame = vnaDataflow.getFactAtLocation(location);\n\n\t\t\t// NOTE: if the CFG on which the value number analysis was performed\n\t\t\t// was pruned, there may be unreachable instructions.  Therefore,\n\t\t\t// we can't assume the frame is valid.\n\t\t\tif (!frame.isValid())\n\t\t\t\tcontinue;\n\n\t\t\t// Find the ValueNumber of the receiver object\n\t\t\tint numConsumed = ins.consumeStack(cpg);\n\t\t\tif (numConsumed == Constants.UNPREDICTABLE)\n\t\t\t\tthrow new DataflowAnalysisException(\n\t\t\t\t\t\t\"Unpredictable stack consumption\",\n\t\t\t\t\t\tclassContext.getMethodGen(method),\n\t\t\t\t\t\thandle);\n\t\t\t//if (DEBUG) System.out.println(\"Getting receiver for frame: \" + frame);\n\t\t\tValueNumber instance = frame.getStackValue(numConsumed - 1);\n\n\t\t\t// Is the instance locked?\n\t\t\tint lockCount = lockSet.getLockCount(instance.getNumber());\n\t\t\tif (lockCount > 0) {\n\t\t\t\t// This is a locked call site\n\t\t\t\tobviouslyLockedSites.add(callSite);\n\t\t\t}\n\t\t}\n\n\t\treturn obviouslyLockedSites;\n\t}","commit_id":"5df9858795b225106a6cafe384e1a96ab43da5c2","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void analyzeMethod(ClassContext classContext, Method method, Set<Method> lockedMethodSet)\n\t        throws CFGBuilderException, DataflowAnalysisException {\n\n\t\tInnerClassAccessMap icam = InnerClassAccessMap.instance();\n\t\tConstantPoolGen cpg = classContext.getConstantPoolGen();\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\tCFG cfg = classContext.getCFG(method);\n\t\tLockChecker lockChecker = classContext.getLockChecker(method);\n\t\tValueNumberDataflow vnaDataflow = classContext.getValueNumberDataflow(method);\n\t\tboolean isGetterMethod = isGetterMethod(classContext, method);\n\n\t\tif (DEBUG)\n\t\t\tSystem.out.println(\"**** Analyzing method \" +\n\t\t\t        SignatureConverter.convertMethodSignature(classContext.getMethodGen(method)));\n\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\t\t\ttry {\n\t\t\t\tInstruction ins = location.getHandle().getInstruction();\n\t\t\t\tXField xfield = null;\n\t\t\t\tboolean isWrite = false;\n\t\t\t\tboolean isLocal = false;\n\n\t\t\t\tif (ins instanceof FieldInstruction) {\n\t\t\t\t\tFieldInstruction fins = (FieldInstruction) ins;\n\t\t\t\t\txfield = Hierarchy.findXField(fins, cpg);\n\t\t\t\t\tisWrite = ins.getOpcode() == Constants.PUTFIELD;\n\t\t\t\t\tisLocal = fins.getClassName(cpg).equals(classContext.getJavaClass().getClassName());\n\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\tSystem.out.println(\"Handling field access: \" + location.getHandle() +\n\t\t\t\t\t\t        \" (frame=\" + vnaDataflow.getFactAtLocation(location) + \")\");\n\t\t\t\t} else if (ins instanceof INVOKESTATIC) {\n\t\t\t\t\tINVOKESTATIC inv = (INVOKESTATIC) ins;\n\t\t\t\t\tInnerClassAccess access = icam.getInnerClassAccess(inv, cpg);\n\t\t\t\t\tif (access != null && access.getMethodSignature().equals(inv.getSignature(cpg))) {\n\t\t\t\t\t\txfield = access.getField();\n\t\t\t\t\t\tisWrite = !access.isLoad();\n\t\t\t\t\t\tisLocal = false;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\"Handling inner class access: \" + location.getHandle() +\n\t\t\t\t\t\t\t        \" (frame=\" + vnaDataflow.getFactAtLocation(location) + \")\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (xfield == null)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// We only care about mutable nonvolatile nonpublic instance fields.\n\t\t\t\tif (xfield.isStatic() || xfield.isPublic() || xfield.isVolatile() || xfield.isFinal())\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// The value number frame could be invalid if the basic\n\t\t\t\t// block became unreachable due to edge pruning (dead code).\n\t\t\t\tValueNumberFrame frame = vnaDataflow.getFactAtLocation(location);\n\t\t\t\tif (!frame.isValid())\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// Get lock set and instance value\n\t\t\t\tValueNumber thisValue = !method.isStatic() ? vnaDataflow.getAnalysis().getThisValue() : null;\n\t\t\t\tLockSet lockSet = lockChecker.getFactAtLocation(location);\n\t\t\t\tInstructionHandle handle = location.getHandle();\n\t\t\t\tValueNumber instance = frame.getInstance(handle.getInstruction(), cpg);\n\t\t\t\n\t\t\t\t// Is the instance locked?\n\t\t\t\t// We consider the access to be locked if either\n\t\t\t\t//   - the object is explicitly locked, or\n\t\t\t\t//   - the field is accessed through the \"this\" reference,\n\t\t\t\t//     and the method is in the locked method set, or\n\t\t\t\t//   - any value returned by a called method is locked;\n\t\t\t\t//     the (conservative) assumption is that the return lock object\n\t\t\t\t//     is correct for synchronizing the access\n\t\t\t\tboolean isExplicitlyLocked = lockSet.getLockCount(instance.getNumber()) > 0;\n\t\t\t\tboolean isAccessedThroughThis = thisValue != null && thisValue.equals(instance);\n\t\t\t\tboolean isLocked = isExplicitlyLocked\n\t\t\t\t        || (lockedMethodSet.contains(method) && isAccessedThroughThis)\n\t\t\t\t        || lockSet.containsReturnValue(vnaDataflow.getAnalysis().getFactory());\n\n\t\t\t\t// Adjust the field so its class name is the same\n\t\t\t\t// as the type of reference it is accessed through.\n\t\t\t\t// This helps fix false positives produced when a\n\t\t\t\t// threadsafe class is extended by a subclass that\n\t\t\t\t// doesn't care about thread safety.\n\t\t\t\tif (ADJUST_SUBCLASS_ACCESSES) {\n\t\t\t\t\t// Find the type of the object instance\n\t\t\t\t\tTypeDataflow typeDataflow = classContext.getTypeDataflow(method);\n\t\t\t\t\tTypeFrame typeFrame = typeDataflow.getFactAtLocation(location);\n\t\t\t\t\tType instanceType = typeFrame.getInstance(handle.getInstruction(), cpg);\n\n\t\t\t\t\t// Note: instance type can be Null,\n\t\t\t\t\t// in which case we won't adjust the field type.\n\t\t\t\t\tif (instanceType != TypeFrame.getNullType()) {\n\t\t\t\t\t\tif (!(instanceType instanceof ObjectType)) {\n\t\t\t\t\t\t\tthrow new AnalysisException(\"Field accessed through non-object reference \" + instanceType,\n\t\t\t\t\t\t\t        methodGen, handle);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tObjectType objType = (ObjectType) instanceType;\n\n\t\t\t\t\t\t// If instance class name is not the same as that of the field,\n\t\t\t\t\t\t// make it so\n\t\t\t\t\t\tString instanceClassName = objType.getClassName();\n\t\t\t\t\t\tif (!instanceClassName.equals(xfield.getClassName())) {\n\t\t\t\t\t\t\txfield = new InstanceField(instanceClassName,\n\t\t\t\t\t\t\t        xfield.getFieldName(),\n\t\t\t\t\t\t\t        xfield.getFieldSignature(),\n\t\t\t\t\t\t\t        xfield.getAccessFlags());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint kind = 0;\n\t\t\t\tkind |= isLocked ? LOCKED : UNLOCKED;\n\t\t\t\tkind |= isWrite ? WRITE : READ;\n\n\t\t\t\tif (isLocked || !isConstructor(method.getName())) {\n\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\tSystem.out.println(\"IS2:\\t\" +\n\t\t\t\t\t\t        SignatureConverter.convertMethodSignature(classContext.getMethodGen(method)) +\n\t\t\t\t\t\t        \"\\t\" + xfield + \"\\t\" + ((isWrite ? \"W\" : \"R\") + \"/\" + (isLocked ? \"L\" : \"U\")));\n\n\t\t\t\t\tFieldStats stats = getStats(xfield);\n\t\t\t\t\tstats.addAccess(kind);\n\n\t\t\t\t\tif (isExplicitlyLocked && isLocal)\n\t\t\t\t\t\tstats.addLocalLock();\n\n\t\t\t\t\tif (isGetterMethod && !isLocked)\n\t\t\t\t\t\tstats.addGetterMethodAccess();\n\n\t\t\t\t\tstats.addAccess(classContext, method, handle, isLocked);\n\t\t\t\t}\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tbugReporter.reportMissingClass(e);\n\t\t\t}\n\t\t}\n\t}","id":65992,"modified_method":"private void analyzeMethod(ClassContext classContext, Method method, Set<Method> lockedMethodSet)\n\t        throws CFGBuilderException, DataflowAnalysisException {\n\n\t\tInnerClassAccessMap icam = InnerClassAccessMap.instance();\n\t\tConstantPoolGen cpg = classContext.getConstantPoolGen();\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\tCFG cfg = classContext.getCFG(method);\n\t\tLockChecker lockChecker = classContext.getLockChecker(method);\n\t\tValueNumberDataflow vnaDataflow = classContext.getValueNumberDataflow(method);\n\t\tboolean isGetterMethod = isGetterMethod(classContext, method);\n\n\t\tif (DEBUG)\n\t\t\tSystem.out.println(\"**** Analyzing method \" +\n\t\t\t        SignatureConverter.convertMethodSignature(classContext.getMethodGen(method)));\n\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\t\t\ttry {\n\t\t\t\tInstruction ins = location.getHandle().getInstruction();\n\t\t\t\tXField xfield = null;\n\t\t\t\tboolean isWrite = false;\n\t\t\t\tboolean isLocal = false;\n\n\t\t\t\tif (ins instanceof FieldInstruction) {\n\t\t\t\t\tFieldInstruction fins = (FieldInstruction) ins;\n\t\t\t\t\txfield = Hierarchy.findXField(fins, cpg);\n\t\t\t\t\tisWrite = ins.getOpcode() == Constants.PUTFIELD;\n\t\t\t\t\tisLocal = fins.getClassName(cpg).equals(classContext.getJavaClass().getClassName());\n\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\tSystem.out.println(\"Handling field access: \" + location.getHandle() +\n\t\t\t\t\t\t        \" (frame=\" + vnaDataflow.getFactAtLocation(location) + \")\");\n\t\t\t\t} else if (ins instanceof INVOKESTATIC) {\n\t\t\t\t\tINVOKESTATIC inv = (INVOKESTATIC) ins;\n\t\t\t\t\tInnerClassAccess access = icam.getInnerClassAccess(inv, cpg);\n\t\t\t\t\tif (access != null && access.getMethodSignature().equals(inv.getSignature(cpg))) {\n\t\t\t\t\t\txfield = access.getField();\n\t\t\t\t\t\tisWrite = !access.isLoad();\n\t\t\t\t\t\tisLocal = false;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\"Handling inner class access: \" + location.getHandle() +\n\t\t\t\t\t\t\t        \" (frame=\" + vnaDataflow.getFactAtLocation(location) + \")\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (xfield == null)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// We only care about mutable nonvolatile nonpublic instance fields.\n\t\t\t\tif (xfield.isStatic() || xfield.isPublic() || xfield.isVolatile() || xfield.isFinal())\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// The value number frame could be invalid if the basic\n\t\t\t\t// block became unreachable due to edge pruning (dead code).\n\t\t\t\tValueNumberFrame frame = vnaDataflow.getFactAtLocation(location);\n\t\t\t\tif (!frame.isValid())\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// Get lock set and instance value\n\t\t\t\tValueNumber thisValue = !method.isStatic() ? vnaDataflow.getAnalysis().getThisValue() : null;\n\t\t\t\tLockSet lockSet = lockChecker.getFactAtLocation(location);\n\t\t\t\tInstructionHandle handle = location.getHandle();\n\t\t\t\tValueNumber instance = frame.getInstance(handle.getInstruction(), cpg);\n\t\t\t\n\t\t\t\t// Is the instance locked?\n\t\t\t\t// We consider the access to be locked if either\n\t\t\t\t//   - the object is explicitly locked, or\n\t\t\t\t//   - the field is accessed through the \"this\" reference,\n\t\t\t\t//     and the method is in the locked method set, or\n\t\t\t\t//   - any value returned by a called method is locked;\n\t\t\t\t//     the (conservative) assumption is that the return lock object\n\t\t\t\t//     is correct for synchronizing the access\n\t\t\t\tboolean isExplicitlyLocked = lockSet.getLockCount(instance.getNumber()) > 0;\n\t\t\t\tboolean isAccessedThroughThis = thisValue != null && thisValue.equals(instance);\n\t\t\t\tboolean isLocked = isExplicitlyLocked\n\t\t\t\t        || (lockedMethodSet.contains(method) && isAccessedThroughThis)\n\t\t\t\t        || lockSet.containsReturnValue(vnaDataflow.getAnalysis().getFactory());\n\n\t\t\t\t// Adjust the field so its class name is the same\n\t\t\t\t// as the type of reference it is accessed through.\n\t\t\t\t// This helps fix false positives produced when a\n\t\t\t\t// threadsafe class is extended by a subclass that\n\t\t\t\t// doesn't care about thread safety.\n\t\t\t\tif (ADJUST_SUBCLASS_ACCESSES) {\n\t\t\t\t\t// Find the type of the object instance\n\t\t\t\t\tTypeDataflow typeDataflow = classContext.getTypeDataflow(method);\n\t\t\t\t\tTypeFrame typeFrame = typeDataflow.getFactAtLocation(location);\n\t\t\t\t\tType instanceType = typeFrame.getInstance(handle.getInstruction(), cpg);\n\n\t\t\t\t\t// Note: instance type can be Null,\n\t\t\t\t\t// in which case we won't adjust the field type.\n\t\t\t\t\tif (instanceType != TypeFrame.getNullType()) {\n\t\t\t\t\t\tif (!(instanceType instanceof ObjectType)) {\n\t\t\t\t\t\t\tthrow new DataflowAnalysisException(\"Field accessed through non-object reference \" + instanceType,\n\t\t\t\t\t\t\t        methodGen, handle);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tObjectType objType = (ObjectType) instanceType;\n\n\t\t\t\t\t\t// If instance class name is not the same as that of the field,\n\t\t\t\t\t\t// make it so\n\t\t\t\t\t\tString instanceClassName = objType.getClassName();\n\t\t\t\t\t\tif (!instanceClassName.equals(xfield.getClassName())) {\n\t\t\t\t\t\t\txfield = new InstanceField(instanceClassName,\n\t\t\t\t\t\t\t        xfield.getFieldName(),\n\t\t\t\t\t\t\t        xfield.getFieldSignature(),\n\t\t\t\t\t\t\t        xfield.getAccessFlags());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint kind = 0;\n\t\t\t\tkind |= isLocked ? LOCKED : UNLOCKED;\n\t\t\t\tkind |= isWrite ? WRITE : READ;\n\n\t\t\t\tif (isLocked || !isConstructor(method.getName())) {\n\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\tSystem.out.println(\"IS2:\\t\" +\n\t\t\t\t\t\t        SignatureConverter.convertMethodSignature(classContext.getMethodGen(method)) +\n\t\t\t\t\t\t        \"\\t\" + xfield + \"\\t\" + ((isWrite ? \"W\" : \"R\") + \"/\" + (isLocked ? \"L\" : \"U\")));\n\n\t\t\t\t\tFieldStats stats = getStats(xfield);\n\t\t\t\t\tstats.addAccess(kind);\n\n\t\t\t\t\tif (isExplicitlyLocked && isLocal)\n\t\t\t\t\t\tstats.addLocalLock();\n\n\t\t\t\t\tif (isGetterMethod && !isLocked)\n\t\t\t\t\t\tstats.addGetterMethodAccess();\n\n\t\t\t\t\tstats.addAccess(classContext, method, handle, isLocked);\n\t\t\t\t}\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tbugReporter.reportMissingClass(e);\n\t\t\t}\n\t\t}\n\t}","commit_id":"5df9858795b225106a6cafe384e1a96ab43da5c2","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"void checkSubstitutes(List<Candidates> importPermutations) throws ResolutionException\n    {\n        Map<Capability, Integer> substituteStatuses = new HashMap<Capability, Integer>(m_subtitutableMap.size());\n        for (Capability substitutable : m_subtitutableMap.keySet())\n        {\n            // initialize with unprocessed\n            substituteStatuses.put(substitutable, UNPROCESSED);\n        }\n        // note we are iterating over the original unmodified map by design\n        for (Capability substitutable : m_subtitutableMap.keySet())\n        {\n            isSubstituted(substitutable, substituteStatuses);\n        }\n\n        // Remove any substituted exports from candidates\n        for (Map.Entry<Capability, Integer> substituteStatus : substituteStatuses.entrySet())\n        {\n            if (substituteStatus.getValue() == SUBSTITUTED)\n            {\n                if (m_dependentMap.isEmpty())\n                {\n                    // make sure the dependents are populated\n                    populateDependents();\n                }\n            }\n            // add a permutation that imports a different candidate for the substituted if possible\n            Requirement substitutedReq = m_subtitutableMap.get(substituteStatus.getKey());\n            if (substitutedReq != null)\n            {\n                permutateIfNeeded(substitutedReq, importPermutations);\n            }\n            Set<Requirement> dependents = m_dependentMap.get(substituteStatus.getKey());\n            if (dependents != null)\n            {\n                for (Requirement dependent : dependents)\n                {\n                    List<Capability> candidates = m_candidateMap.get(dependent);\n                    if (candidates != null)\n                    {\n                        candidates:\n                        for (Iterator<Capability> iCandidates = candidates.iterator(); iCandidates.hasNext();)\n                        {\n                            Capability candidate = iCandidates.next();\n                            Integer candidateStatus = substituteStatuses.get(candidate);\n                            if (candidateStatus == null)\n                            {\n                                candidateStatus = EXPORTED;\n                            }\n                            switch (candidateStatus)\n                            {\n                                case EXPORTED:\n                                    // non-substituted candidate hit before the substituted one; do not continue\n                                    break candidates;\n                                case SUBSTITUTED:\n                                default:\n                                    // Need to remove any substituted that comes before an exported candidate\n                                    iCandidates.remove();\n                                    // continue to next candidate\n                                    break;\n                            }\n                        }\n                        if (candidates.isEmpty())\n                        {\n                            if (Util.isOptional(dependent))\n                            {\n                                m_candidateMap.remove(dependent);\n                            }\n                            else\n                            {\n                                String msg = \"Unable to resolve \" + dependent.getResource()\n                                        + \": missing requirement \" + dependent;\n                                throw new ResolutionException(msg, null, Collections.singleton(dependent));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","id":65993,"modified_method":"void checkSubstitutes(List<Candidates> importPermutations) throws ResolutionException\n    {\n        Map<Capability, Integer> substituteStatuses = new HashMap<Capability, Integer>(m_subtitutableMap.size());\n        for (Capability substitutable : m_subtitutableMap.keySet())\n        {\n            // initialize with unprocessed\n            substituteStatuses.put(substitutable, UNPROCESSED);\n        }\n        // note we are iterating over the original unmodified map by design\n        for (Capability substitutable : m_subtitutableMap.keySet())\n        {\n            isSubstituted(substitutable, substituteStatuses);\n        }\n\n        // Remove any substituted exports from candidates\n        for (Map.Entry<Capability, Integer> substituteStatus : substituteStatuses.entrySet())\n        {\n            if (substituteStatus.getValue() == SUBSTITUTED)\n            {\n                if (m_dependentMap.isEmpty())\n                {\n                    // make sure the dependents are populated\n                    populateDependents();\n                }\n            }\n            // add a permutation that imports a different candidate for the substituted if possible\n            Requirement substitutedReq = m_subtitutableMap.get(substituteStatus.getKey());\n            if (substitutedReq != null)\n            {\n                ResolverImpl.permutateIfNeeded(this, substitutedReq, importPermutations);\n            }\n            Set<Requirement> dependents = m_dependentMap.get(substituteStatus.getKey());\n            if (dependents != null)\n            {\n                for (Requirement dependent : dependents)\n                {\n                    List<Capability> candidates = m_candidateMap.get(dependent);\n                    if (candidates != null)\n                    {\n                        candidates:\n                        for (Iterator<Capability> iCandidates = candidates.iterator(); iCandidates.hasNext();)\n                        {\n                            Capability candidate = iCandidates.next();\n                            Integer candidateStatus = substituteStatuses.get(candidate);\n                            if (candidateStatus == null)\n                            {\n                                candidateStatus = EXPORTED;\n                            }\n                            switch (candidateStatus)\n                            {\n                                case EXPORTED:\n                                    // non-substituted candidate hit before the substituted one; do not continue\n                                    break candidates;\n                                case SUBSTITUTED:\n                                default:\n                                    // Need to remove any substituted that comes before an exported candidate\n                                    iCandidates.remove();\n                                    // continue to next candidate\n                                    break;\n                            }\n                        }\n                        if (candidates.isEmpty())\n                        {\n                            if (Util.isOptional(dependent))\n                            {\n                                clearCandidates(dependent);\n                            }\n                            else\n                            {\n                                String msg = \"Unable to resolve \" + dependent.getResource()\n                                        + \": missing requirement \" + dependent;\n                                throw new ResolutionException(msg, null, Collections.singleton(dependent));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","commit_id":"ddd1f64ae9e777796cdcd26063334186d09177ec","url":"https://github.com/apache/felix"},{"original_method":"public boolean canRemoveCandidate(Requirement req)\n    {\n        List<Capability> candidates = m_candidateMap.get(req);\n        return ((candidates != null) && (candidates.size() > 1 || Util.isOptional(req)));\n    }","id":65994,"modified_method":"public void clearCandidates(Requirement req)\n    {\n        m_candidateMap.remove(req);\n    }","commit_id":"ddd1f64ae9e777796cdcd26063334186d09177ec","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Gets the candidates associated with a given requirement.\n     *\n     * @param req the requirement whose candidates are desired.\n     * @return the matching candidates or null.\n     */\n    public List<Capability> getCandidates(Requirement req)\n    {\n        return Collections.unmodifiableList(m_candidateMap.get(req));\n    }","id":65995,"modified_method":"/**\n     * Gets the candidates associated with a given requirement.\n     *\n     * @param req the requirement whose candidates are desired.\n     * @return the matching candidates or null.\n     */\n    public List<Capability> getCandidates(Requirement req)\n    {\n        return m_candidateMap.get(req);\n    }","commit_id":"ddd1f64ae9e777796cdcd26063334186d09177ec","url":"https://github.com/apache/felix"},{"original_method":"private static Capability getSatisfyingCapability(\n        ResolveContext rc, Candidates allCandidates, Requirement req)\n    {\n        // If the requiring revision is not resolved, then check in the\n        // candidate map for its matching candidate.\n        Capability cap = allCandidates.getFirstCandidate(req);\n        // Otherwise, if the requiring revision is resolved then check\n        // in its wires for the capability satisfying the requirement.\n        if (cap == null && rc.getWirings().containsKey(req.getResource()))\n        {\n            List<Wire> wires =\n                rc.getWirings().get(req.getResource()).getRequiredResourceWires(null);\n            req = getDeclaredRequirement(req);\n            for (Wire w : wires)\n            {\n                if (w.getRequirement().equals(req))\n                {\n// TODO: RESOLVER - This is not 100% correct, since requirements for\n//       dynamic imports with wildcards will reside on many wires and\n//       this code only finds the first one, not necessarily the correct\n//       one. This is only used for the diagnostic message, but it still\n//       could confuse the user.\n                    cap = w.getCapability();\n                    break;\n                }\n            }\n        }\n\n        return cap;\n    }","id":65996,"modified_method":"private static Capability getSatisfyingCapability(\n        ResolveContext rc, Candidates allCandidates, Requirement req)\n    {\n        Capability cap = null;\n\n        // If the requiring revision is not resolved, then check in the\n        // candidate map for its matching candidate.\n        List<Capability> cands = allCandidates.getCandidates(req);\n        if (cands != null)\n        {\n            cap = cands.get(0);\n        }\n        // Otherwise, if the requiring revision is resolved then check\n        // in its wires for the capability satisfying the requirement.\n        else if (rc.getWirings().containsKey(req.getResource()))\n        {\n            List<Wire> wires =\n                rc.getWirings().get(req.getResource()).getRequiredResourceWires(null);\n            req = getDeclaredRequirement(req);\n            for (Wire w : wires)\n            {\n                if (w.getRequirement().equals(req))\n                {\n// TODO: RESOLVER - This is not 100% correct, since requirements for\n//       dynamic imports with wildcards will reside on many wires and\n//       this code only finds the first one, not necessarily the correct\n//       one. This is only used for the diagnostic message, but it still\n//       could confuse the user.\n                    cap = w.getCapability();\n                    break;\n                }\n            }\n        }\n\n        return cap;\n    }","commit_id":"ddd1f64ae9e777796cdcd26063334186d09177ec","url":"https://github.com/apache/felix"},{"original_method":"private static Map<Resource, List<Wire>> populateDynamicWireMap(\n        ResolveContext rc, Resource resource, Requirement dynReq,\n        Map<Resource, Packages> resourcePkgMap,\n        Map<Resource, List<Wire>> wireMap, Candidates allCandidates)\n    {\n        wireMap.put(resource, (List<Wire>) Collections.EMPTY_LIST);\n\n        List<Wire> packageWires = new ArrayList<Wire>();\n\n        // Get the candidates for the current dynamic requirement.\n        // Record the dynamic candidate.\n        Capability dynCand = allCandidates.getFirstCandidate(dynReq);\n\n        if (!rc.getWirings().containsKey(dynCand.getResource()))\n        {\n            populateWireMap(rc, dynCand.getResource(), resourcePkgMap,\n                wireMap, allCandidates);\n        }\n\n        packageWires.add(\n            new WireImpl(\n                resource,\n                dynReq,\n                getDeclaredResource(dynCand.getResource()),\n                getDeclaredCapability(dynCand)));\n\n        wireMap.put(resource, packageWires);\n\n        return wireMap;\n    }","id":65997,"modified_method":"private static Map<Resource, List<Wire>> populateDynamicWireMap(\n        ResolveContext rc, Resource resource, Requirement dynReq,\n        Map<Resource, Packages> resourcePkgMap,\n        Map<Resource, List<Wire>> wireMap, Candidates allCandidates)\n    {\n        wireMap.put(resource, (List<Wire>) Collections.EMPTY_LIST);\n\n        List<Wire> packageWires = new ArrayList<Wire>();\n\n        // Get the candidates for the current dynamic requirement.\n        List<Capability> candCaps = allCandidates.getCandidates(dynReq);\n        // Record the dynamic candidate.\n        Capability dynCand = candCaps.get(0);\n\n        if (!rc.getWirings().containsKey(dynCand.getResource()))\n        {\n            populateWireMap(rc, dynCand.getResource(), resourcePkgMap,\n                wireMap, allCandidates);\n        }\n\n        packageWires.add(\n            new WireImpl(\n                resource,\n                dynReq,\n                getDeclaredResource(dynCand.getResource()),\n                getDeclaredCapability(dynCand)));\n\n        wireMap.put(resource, packageWires);\n\n        return wireMap;\n    }","commit_id":"ddd1f64ae9e777796cdcd26063334186d09177ec","url":"https://github.com/apache/felix"},{"original_method":"private static Wire createWire(Requirement requirement, Candidates allCandidates)\n    {\n        Capability cand = allCandidates.getFirstCandidate(requirement);\n        if (cand == null) {\n            return null;\n        }\n        return new WireImpl(\n            getDeclaredResource(requirement.getResource()),\n            getDeclaredRequirement(requirement),\n            getDeclaredResource(cand.getResource()),\n            getDeclaredCapability(cand));\n    }","id":65998,"modified_method":"private static Wire createWire(Requirement requirement, Candidates allCandidates)\n    {\n        List<Capability> candidates = allCandidates.getCandidates(requirement);\n        if (candidates == null || candidates.isEmpty())\n        {\n            return null;\n        }\n        Capability cand = candidates.get(0);\n        return new WireImpl(\n            getDeclaredResource(requirement.getResource()),\n            getDeclaredRequirement(requirement),\n            getDeclaredResource(cand.getResource()),\n            getDeclaredCapability(cand));\n    }","commit_id":"ddd1f64ae9e777796cdcd26063334186d09177ec","url":"https://github.com/apache/felix"},{"original_method":"public Map<Resource, List<Wire>> resolve(ResolveContext rc) throws ResolutionException\n    {\n        ResolveSession session = new ResolveSession(rc);\n        Map<Resource, List<Wire>> wireMap =\n            new HashMap<Resource, List<Wire>>();\n        Map<Resource, Packages> resourcePkgMap =\n            new HashMap<Resource, Packages>();\n\n        // Make copies of arguments in case we want to modify them.\n        Collection<Resource> mandatoryResources = new ArrayList(rc.getMandatoryResources());\n        Collection<Resource> optionalResources = new ArrayList(rc.getOptionalResources());\n        // keeps track of valid on demand fragments that we have seen.\n        // a null value or TRUE indicate it is valid\n        Map<Resource, Boolean> validOnDemandResources = new HashMap<Resource, Boolean>(0);\n\n        boolean retry;\n        do\n        {\n            retry = false;\n            try\n            {\n                // Create object to hold all candidates.\n                Candidates allCandidates = new Candidates(validOnDemandResources);\n\n                // Populate mandatory resources; since these are mandatory\n                // resources, failure throws a resolve exception.\n                for (Iterator<Resource> it = mandatoryResources.iterator();\n                    it.hasNext();)\n                {\n                    Resource resource = it.next();\n                    if (Util.isFragment(resource) || (rc.getWirings().get(resource) == null))\n                    {\n                        allCandidates.populate(rc, resource, Candidates.MANDATORY);\n                    }\n                    else\n                    {\n                        it.remove();\n                    }\n                }\n\n                // Populate optional resources; since these are optional\n                // resources, failure does not throw a resolve exception.\n                for (Resource resource : optionalResources)\n                {\n                    boolean isFragment = Util.isFragment(resource);\n                    if (isFragment || (rc.getWirings().get(resource) == null))\n                    {\n                        allCandidates.populate(rc, resource, Candidates.OPTIONAL);\n                    }\n                }\n\n                // Merge any fragments into hosts.\n                allCandidates.prepare(rc);\n\n                // Create a combined list of populated resources; for\n                // optional resources. We do not need to consider ondemand\n                // fragments, since they will only be pulled in if their\n                // host is already present.\n                Set<Resource> allResources =\n                    new HashSet<Resource>(mandatoryResources);\n                for (Resource resource : optionalResources)\n                {\n                    if (allCandidates.isPopulated(resource))\n                    {\n                        allResources.add(resource);\n                    }\n                }\n\n                List<Candidates> usesPermutations = session.getUsesPermutations();\n                List<Candidates> importPermutations = session.getImportPermutations();\n\n                // Record the initial candidate permutation.\n                usesPermutations.add(allCandidates);\n\n                ResolutionException rethrow = null;\n\n                // If a populated resource is a fragment, then its host\n                // must ultimately be verified, so store its host requirement\n                // to use for package space calculation.\n                Map<Resource, List<Requirement>> hostReqs =\n                    new HashMap<Resource, List<Requirement>>();\n                for (Resource resource : allResources)\n                {\n                    if (Util.isFragment(resource))\n                    {\n                        hostReqs.put(\n                            resource,\n                            resource.getRequirements(HostNamespace.HOST_NAMESPACE));\n                    }\n                }\n\n                Map<Resource, ResolutionException> faultyResources = null;\n                do\n                {\n                    rethrow = null;\n\n                    resourcePkgMap.clear();\n                    session.getPackageSourcesCache().clear();\n                    // Null out each time a new permutation is attempted.\n                    // We only use this to store a valid permutation which is a\n                    // delta of the current permutation.\n                    session.setMultipleCardCandidates(null);\n\n                    allCandidates = (usesPermutations.size() > 0)\n                        ? usesPermutations.remove(0)\n                        : importPermutations.remove(0);\n//allCandidates.dump();\n\n                    Map<Resource, ResolutionException> currentFaultyResources = null;\n                    try\n                    {\n                        allCandidates.checkSubstitutes(importPermutations);\n                    }\n                    catch (ResolutionException e)\n                    {\n                        rethrow = e;\n                        continue;\n                    }\n\n                    // Reuse a resultCache map for checking package consistency\n                    // for all resources.\n                    Map<Resource, Object> resultCache =\n                        new HashMap<Resource, Object>(allResources.size());\n                    // Check the package space consistency for all 'root' resources.\n                    for (Resource resource : allResources)\n                    {\n                        Resource target = resource;\n\n                        // If we are resolving a fragment, then get its\n                        // host candidate and verify it instead.\n                        List<Requirement> hostReq = hostReqs.get(resource);\n                        if (hostReq != null)\n                        {\n                            target = allCandidates.getFirstCandidate(hostReq.get(0)).getResource();\n                        }\n\n                        calculatePackageSpaces(\n                            session, allCandidates.getWrappedHost(target), allCandidates,\n                            resourcePkgMap, new HashMap(), new HashSet());\n//System.out.println(\"+++ PACKAGE SPACES START +++\");\n//dumpResourcePkgMap(resourcePkgMap);\n//System.out.println(\"+++ PACKAGE SPACES END +++\");\n\n                        try\n                        {\n                            checkPackageSpaceConsistency(\n                                session, allCandidates.getWrappedHost(target),\n                                allCandidates, resourcePkgMap, resultCache);\n                        }\n                        catch (ResolutionException ex)\n                        {\n                            rethrow = ex;\n                            if (currentFaultyResources == null)\n                            {\n                                currentFaultyResources = new HashMap<Resource, ResolutionException>();\n                            }\n                            Resource faultyResource = resource;\n                            // check that the faulty requirement is not from a fragment\n                            for (Requirement faultyReq : ex.getUnresolvedRequirements())\n                            {\n                                if (faultyReq instanceof WrappedRequirement)\n                                {\n                                    faultyResource =\n                                        ((WrappedRequirement) faultyReq)\n                                        .getDeclaredRequirement().getResource();\n                                    break;\n                                }\n                            }\n                            currentFaultyResources.put(faultyResource, ex);\n                        }\n                    }\n                    if (currentFaultyResources != null)\n                    {\n                        if (faultyResources == null)\n                        {\n                            faultyResources = currentFaultyResources;\n                        }\n                        else if (faultyResources.size() > currentFaultyResources.size())\n                        {\n                            // save the optimal faultyResources which has less\n                            faultyResources = currentFaultyResources;\n                        }\n                    }\n                }\n                while ((rethrow != null)\n                    && ((usesPermutations.size() > 0) || (importPermutations.size() > 0)));\n\n                // If there is a resolve exception, then determine if an\n                // optionally resolved resource is to blame (typically a fragment).\n                // If so, then remove the optionally resolved resolved and try\n                // again; otherwise, rethrow the resolve exception.\n                if (rethrow != null)\n                {\n                    if (faultyResources != null)\n                    {\n                        Set<Resource> resourceKeys = faultyResources.keySet();\n                        retry = (optionalResources.removeAll(resourceKeys));\n                        for (Resource faultyResource : resourceKeys)\n                        {\n                            Boolean valid = validOnDemandResources.get(faultyResource);\n                            if (valid != null && valid.booleanValue())\n                            {\n                                // This was an ondemand resource.\n                                // Invalidate it and try again.\n                                validOnDemandResources.put(faultyResource, Boolean.FALSE);\n                                retry = true;\n                            }\n                        }\n                        // log all the resolution exceptions for the uses constraint violations\n                        for (Map.Entry<Resource, ResolutionException> usesError : faultyResources.entrySet())\n                        {\n                            m_logger.logUsesConstraintViolation(usesError.getKey(), usesError.getValue());\n                        }\n                    }\n                    if (!retry)\n                    {\n                        throw rethrow;\n                    }\n                }\n                // If there is no exception to rethrow, then this was a clean\n                // resolve, so populate the wire map.\n                else\n                {\n                    if (session.getMultipleCardCandidates() != null)\n                    {\n                        // Candidates for multiple cardinality requirements were\n                        // removed in order to provide a consistent class space.\n                        // Use the consistent permutation\n                        allCandidates = session.getMultipleCardCandidates();\n                    }\n                    for (Resource resource : allResources)\n                    {\n                        Resource target = resource;\n\n                        // If we are resolving a fragment, then we\n                        // actually want to populate its host's wires.\n                        List<Requirement> hostReq = hostReqs.get(resource);\n                        if (hostReq != null)\n                        {\n                            target = allCandidates.getFirstCandidate(hostReq.get(0)).getResource();\n                        }\n\n                        if (allCandidates.isPopulated(target))\n                        {\n                            wireMap =\n                                populateWireMap(\n                                    rc, allCandidates.getWrappedHost(target),\n                                    resourcePkgMap, wireMap, allCandidates);\n                        }\n                    }\n                }\n            }\n            finally\n            {\n                // Always clear the state.\n                session.getUsesPermutations().clear();\n                session.getImportPermutations().clear();\n                session.setMultipleCardCandidates(null);\n                // TODO this was not cleared out before; but it seems it should be\n                session.getPackageSourcesCache().clear();\n            }\n        }\n        while (retry);\n\n        return wireMap;\n    }","id":65999,"modified_method":"public Map<Resource, List<Wire>> resolve(ResolveContext rc) throws ResolutionException\n    {\n        ResolveSession session = new ResolveSession(rc);\n        Map<Resource, List<Wire>> wireMap =\n            new HashMap<Resource, List<Wire>>();\n        Map<Resource, Packages> resourcePkgMap =\n            new HashMap<Resource, Packages>();\n\n        // Make copies of arguments in case we want to modify them.\n        Collection<Resource> mandatoryResources = new ArrayList(rc.getMandatoryResources());\n        Collection<Resource> optionalResources = new ArrayList(rc.getOptionalResources());\n        // keeps track of valid on demand fragments that we have seen.\n        // a null value or TRUE indicate it is valid\n        Map<Resource, Boolean> validOnDemandResources = new HashMap<Resource, Boolean>(0);\n\n        boolean retry;\n        do\n        {\n            retry = false;\n            try\n            {\n                // Create object to hold all candidates.\n                Candidates allCandidates = new Candidates(validOnDemandResources);\n\n                // Populate mandatory resources; since these are mandatory\n                // resources, failure throws a resolve exception.\n                for (Iterator<Resource> it = mandatoryResources.iterator();\n                    it.hasNext();)\n                {\n                    Resource resource = it.next();\n                    if (Util.isFragment(resource) || (rc.getWirings().get(resource) == null))\n                    {\n                        allCandidates.populate(rc, resource, Candidates.MANDATORY);\n                    }\n                    else\n                    {\n                        it.remove();\n                    }\n                }\n\n                // Populate optional resources; since these are optional\n                // resources, failure does not throw a resolve exception.\n                for (Resource resource : optionalResources)\n                {\n                    boolean isFragment = Util.isFragment(resource);\n                    if (isFragment || (rc.getWirings().get(resource) == null))\n                    {\n                        allCandidates.populate(rc, resource, Candidates.OPTIONAL);\n                    }\n                }\n\n                // Merge any fragments into hosts.\n                allCandidates.prepare(rc);\n\n                // Create a combined list of populated resources; for\n                // optional resources. We do not need to consider ondemand\n                // fragments, since they will only be pulled in if their\n                // host is already present.\n                Set<Resource> allResources =\n                    new HashSet<Resource>(mandatoryResources);\n                for (Resource resource : optionalResources)\n                {\n                    if (allCandidates.isPopulated(resource))\n                    {\n                        allResources.add(resource);\n                    }\n                }\n\n                List<Candidates> usesPermutations = session.getUsesPermutations();\n                List<Candidates> importPermutations = session.getImportPermutations();\n\n                // Record the initial candidate permutation.\n                usesPermutations.add(allCandidates);\n\n                ResolutionException rethrow = null;\n\n                // If a populated resource is a fragment, then its host\n                // must ultimately be verified, so store its host requirement\n                // to use for package space calculation.\n                Map<Resource, List<Requirement>> hostReqs =\n                    new HashMap<Resource, List<Requirement>>();\n                for (Resource resource : allResources)\n                {\n                    if (Util.isFragment(resource))\n                    {\n                        hostReqs.put(\n                            resource,\n                            resource.getRequirements(HostNamespace.HOST_NAMESPACE));\n                    }\n                }\n\n                Map<Resource, ResolutionException> faultyResources = null;\n                do\n                {\n                    rethrow = null;\n\n                    resourcePkgMap.clear();\n                    session.getPackageSourcesCache().clear();\n                    // Null out each time a new permutation is attempted.\n                    // We only use this to store a valid permutation which is a\n                    // delta of the current permutation.\n                    session.setMultipleCardCandidates(null);\n\n                    allCandidates = (usesPermutations.size() > 0)\n                        ? usesPermutations.remove(0)\n                        : importPermutations.remove(0);\n//allCandidates.dump();\n\n                    Map<Resource, ResolutionException> currentFaultyResources = null;\n                    try\n                    {\n                        allCandidates.checkSubstitutes(importPermutations);\n                    }\n                    catch (ResolutionException e)\n                    {\n                        rethrow = e;\n                        continue;\n                    }\n\n                    // Reuse a resultCache map for checking package consistency\n                    // for all resources.\n                    Map<Resource, Object> resultCache =\n                        new HashMap<Resource, Object>(allResources.size());\n                    // Check the package space consistency for all 'root' resources.\n                    for (Resource resource : allResources)\n                    {\n                        Resource target = resource;\n\n                        // If we are resolving a fragment, then get its\n                        // host candidate and verify it instead.\n                        List<Requirement> hostReq = hostReqs.get(resource);\n                        if (hostReq != null)\n                        {\n                            target = allCandidates.getCandidates(hostReq.get(0))\n                                .iterator().next().getResource();\n                        }\n\n                        calculatePackageSpaces(\n                            session, allCandidates.getWrappedHost(target), allCandidates,\n                            resourcePkgMap, new HashMap(), new HashSet());\n//System.out.println(\"+++ PACKAGE SPACES START +++\");\n//dumpResourcePkgMap(resourcePkgMap);\n//System.out.println(\"+++ PACKAGE SPACES END +++\");\n\n                        try\n                        {\n                            checkPackageSpaceConsistency(\n                                session, allCandidates.getWrappedHost(target),\n                                allCandidates, resourcePkgMap, resultCache);\n                        }\n                        catch (ResolutionException ex)\n                        {\n                            rethrow = ex;\n                            if (currentFaultyResources == null)\n                            {\n                                currentFaultyResources = new HashMap<Resource, ResolutionException>();\n                            }\n                            Resource faultyResource = resource;\n                            // check that the faulty requirement is not from a fragment\n                            for (Requirement faultyReq : ex.getUnresolvedRequirements())\n                            {\n                                if (faultyReq instanceof WrappedRequirement)\n                                {\n                                    faultyResource =\n                                        ((WrappedRequirement) faultyReq)\n                                        .getDeclaredRequirement().getResource();\n                                    break;\n                                }\n                            }\n                            currentFaultyResources.put(faultyResource, ex);\n                        }\n                    }\n                    if (currentFaultyResources != null)\n                    {\n                        if (faultyResources == null)\n                        {\n                            faultyResources = currentFaultyResources;\n                        }\n                        else if (faultyResources.size() > currentFaultyResources.size())\n                        {\n                            // save the optimal faultyResources which has less\n                            faultyResources = currentFaultyResources;\n                        }\n                    }\n                }\n                while ((rethrow != null)\n                    && ((usesPermutations.size() > 0) || (importPermutations.size() > 0)));\n\n                // If there is a resolve exception, then determine if an\n                // optionally resolved resource is to blame (typically a fragment).\n                // If so, then remove the optionally resolved resolved and try\n                // again; otherwise, rethrow the resolve exception.\n                if (rethrow != null)\n                {\n                    if (faultyResources != null)\n                    {\n                        Set<Resource> resourceKeys = faultyResources.keySet();\n                        retry = (optionalResources.removeAll(resourceKeys));\n                        for (Resource faultyResource : resourceKeys)\n                        {\n                            Boolean valid = validOnDemandResources.get(faultyResource);\n                            if (valid != null && valid.booleanValue())\n                            {\n                                // This was an ondemand resource.\n                                // Invalidate it and try again.\n                                validOnDemandResources.put(faultyResource, Boolean.FALSE);\n                                retry = true;\n                            }\n                        }\n                        // log all the resolution exceptions for the uses constraint violations\n                        for (Map.Entry<Resource, ResolutionException> usesError : faultyResources.entrySet())\n                        {\n                            m_logger.logUsesConstraintViolation(usesError.getKey(), usesError.getValue());\n                        }\n                    }\n                    if (!retry)\n                    {\n                        throw rethrow;\n                    }\n                }\n                // If there is no exception to rethrow, then this was a clean\n                // resolve, so populate the wire map.\n                else\n                {\n                    if (session.getMultipleCardCandidates() != null)\n                    {\n                        // Candidates for multiple cardinality requirements were\n                        // removed in order to provide a consistent class space.\n                        // Use the consistent permutation\n                        allCandidates = session.getMultipleCardCandidates();\n                    }\n                    for (Resource resource : allResources)\n                    {\n                        Resource target = resource;\n\n                        // If we are resolving a fragment, then we\n                        // actually want to populate its host's wires.\n                        List<Requirement> hostReq = hostReqs.get(resource);\n                        if (hostReq != null)\n                        {\n                            target = allCandidates.getCandidates(hostReq.get(0))\n                                .iterator().next().getResource();\n                        }\n\n                        if (allCandidates.isPopulated(target))\n                        {\n                            wireMap =\n                                populateWireMap(\n                                    rc, allCandidates.getWrappedHost(target),\n                                    resourcePkgMap, wireMap, allCandidates);\n                        }\n                    }\n                }\n            }\n            finally\n            {\n                // Always clear the state.\n                session.getUsesPermutations().clear();\n                session.getImportPermutations().clear();\n                session.setMultipleCardCandidates(null);\n                // TODO this was not cleared out before; but it seems it should be\n                session.getPackageSourcesCache().clear();\n            }\n        }\n        while (retry);\n\n        return wireMap;\n    }","commit_id":"ddd1f64ae9e777796cdcd26063334186d09177ec","url":"https://github.com/apache/felix"}]